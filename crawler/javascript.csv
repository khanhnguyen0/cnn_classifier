code
"import React from react;import TimerMixin from react-timer-mixin;import {  ListView,  LayoutAnimation,  View,  Animated,  Dimensions,  PanResponder,  TouchableWithoutFeedback} from react-native;
let HEIGHT = Dimensions.get(window).height;var Row = React.createClass({  _data: {},  shouldComponentUpdate: function(props) {    if (props.hovering !== this.props.hovering) return true;    if (props.active !== this.props.active) return true;    if (props.rowData.data !== this.props.rowData.data) return true;    if (props.rowHasChanged) return props.rowHasChanged(props.rowData.data, this._data);    return false;  },  handleLongPress: function(e) {    this.refs.view.measure((frameX, frameY, frameWidth, frameHeight, pageX, pageY) => {      let layout = {frameX, frameY, frameWidth, frameHeight, pageX, pageY};      this.props.onRowActive({        layout: layout,        touch: e.nativeEvent,        rowData: this.props.rowData      });    });  },  componentDidUpdate: function(props) {    Take a shallow copy of the active data. So we can do manual comparisons of rows if needed.    if (props.rowHasChanged) {      this._data = (typeof props.rowData.data === object) ? Object.assign({}, props.rowData.data) : props.rowData.data;    }  },  measure: function() {    return this.refs.view.measure.apply(this, Array.from(arguments));  },  render: function() {    let layout = this.props.list.layoutMap[this.props.rowData.index];    let activeData = this.props.list.state.active;
    let activeIndex = activeData ? activeData.rowData.index : -5;    let shouldDisplayHovering = activeIndex !== this.props.rowData.index;    let Row = React.cloneElement(this.props.renderRow(this.props.rowData.data, this.props.rowData.section, this.props.rowData.index, null, this.props.active), {sortHandlers: {onLongPress: this.handleLongPress, onPressOut: this.props.list.cancel}, onLongPress: this.handleLongPress, onPressOut: this.props.list.cancel});    return <View onLayout={this.props.onRowLayout}                 style={[ this.props.active && !this.props.hovering ? {height: 0.01}:null,                          this.props.active && this.props.hovering ? {opacity: 0.0}: null,]} ref=view>          {this.props.hovering && shouldDisplayHovering ? this.props.activeDivider : null}          {Row}        </View>  }});
var SortRow = React.createClass({  getInitialState: function() {    let layout = this.props.list.state.active.layout;    let wrapperLayout = this.props.list.wrapperLayout;
    return {      style: {        position: absolute,        left: 0,        right: 0,        opacity: .2,        height: layout.frameHeight,        overflow: hidden,        backgroundColor: transparent,        marginTop: layout.pageY - wrapperLayout.pageY Account for top bar spacing      }    }  },  render: function() {    let handlers = this.props.panResponder.panHandlers;    return (      <Animated.View ref=view style={[this.state.style, this.props.sortRowStyle, this.props.list.state.pan.getLayout()]}>        {this.props.renderRow(this.props.rowData.data, this.props.rowData.section, this.props.rowData.index, null, true)}      </Animated.View>    );  }});
var SortableListView = React.createClass({  mixins: [TimerMixin],  getInitialState:function() {
    let currentPanValue = {x: 0, y: 0};
    this.state = {      ds: new ListView.DataSource({rowHasChanged: (r1, r2) => {        if (this.props.rowHasChanged) return this.props.rowHasChanged(r1, r2);        return false;      }}),      active: false,      hovering: false,      pan: new Animated.ValueXY(currentPanValue)    };    this.listener = this.state.pan.addListener(e => this.panY = e.y);    let onPanResponderMoveCb = Animated.event([null, {           dx: this.state.pan.x,  x,y are Animated.Value           dy: this.state.pan.y,      }]);
    this.state.panResponder = PanResponder.create({      onStartShouldSetPanResponder: (e) => true,      onMoveShouldSetPanResponderCapture: (e, a) => {        Only capture when moving vertically, this helps for child swiper rows.        let vy = Math.abs(a.vy);        let vx = Math.abs(a.vx);
        return (vy) > vx  && this.state.active;      },      onPanResponderMove: (evt, gestureState) => {        gestureState.dx = 0;        this.moveY = gestureState.moveY;        onPanResponderMoveCb(evt, gestureState);       },
       onPanResponderGrant: (e, gestureState) => {          this.moved = true;          this.props.onMoveStart &&  this.props.onMoveStart();          this.state.pan.setOffset(currentPanValue);          this.state.pan.setValue(currentPanValue);      },      onPanResponderRelease: (e) => {
        this.moved = false;        this.props.onMoveEnd && this.props.onMoveEnd();        if (!this.state.active) {          if (this.state.hovering) this.setState({hovering: false});          this.moveY = null;          return;        }        let itemHeight = this.state.active.layout.frameHeight;        let fromIndex = this.order.indexOf(this.state.active.rowData.index);        let toIndex = this.state.hovering === false ?  fromIndex : Number(this.state.hovering);        let up = toIndex > fromIndex;        if (up) {          toIndex--;        }        if (toIndex === fromIndex) return this.setState({active: false, hovering: false});        let args = {          row: this.state.active.rowData,          from: fromIndex,          to: toIndex        };
        this.props.onRowMoved && this.props.onRowMoved(args);        if (this.props._legacySupport) { rely on parent data changes to set state changes          LayoutAnimation.easeInEaseOut()          this.state.active = false;          this.state.hovering = false;        } else {          this.setState({            active: false,            hovering: false          });        }
        let MAX_HEIGHT = Math.max(0, this.scrollContainerHeight - this.listLayout.height + itemHeight);        if (this.scrollValue > MAX_HEIGHT) {          this.scrollResponder.scrollTo({y: MAX_HEIGHT});        }
        this.state.active = false;        this.state.hovering = false;        this.moveY = null;      }     });
    return this.state;  },  cancel: function() {    if (!this.moved) {      this.setState({        active: false,        hovering: false      });    }  },  componentDidMount: function() {    setTimeout(()=>{      this.scrollResponder = this.refs.list.getScrollResponder();    }, 1);  },  measureWrapper: function() {    if (this.refs.wrapper) {      this.refs.wrapper.measure((frameX, frameY, frameWidth, frameHeight, pageX, pageY) => {
        let layout = {frameX, frameY, frameWidth, frameHeight, pageX, pageY};        this.wrapperLayout = layout;      });    }  },  scrollValue: 0,  scrollContainerHeight: HEIGHT * 1.2, Gets calculated on scroll, but if you havent scrolled needs an initial value  scrollAnimation: function() {    if (this.isMounted() /* deprecated and unnecessary: using TimerMixin */ && this.state.active) {      if (this.moveY == undefined) return this.requestAnimationFrame(this.scrollAnimation);
      let SCROLL_OFFSET = this.wrapperLayout.pageY;      let moveY = this.moveY - SCROLL_OFFSET;      let SCROLL_LOWER_BOUND = 80;      let SCROLL_HIGHER_BOUND = this.listLayout.height - SCROLL_LOWER_BOUND;      let NORMAL_SCROLL_MAX = this.scrollContainerHeight - this.listLayout.height;      let MAX_SCROLL_VALUE = NORMAL_SCROLL_MAX + (this.state.active.layout.frameHeight * 2 );      let currentScrollValue = this.scrollValue;      let newScrollValue = null;      let SCROLL_MAX_CHANGE = 20;
      if (moveY < SCROLL_LOWER_BOUND && currentScrollValue > 0) {        let PERCENTAGE_CHANGE = 1 - (moveY / SCROLL_LOWER_BOUND);        newScrollValue = currentScrollValue - (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);        if (newScrollValue < 0) newScrollValue = 0;      }      if (moveY > SCROLL_HIGHER_BOUND && currentScrollValue < MAX_SCROLL_VALUE) {        let PERCENTAGE_CHANGE = 1 - ((this.listLayout.height - moveY) / SCROLL_LOWER_BOUND);        newScrollValue = currentScrollValue + (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);        if (newScrollValue > MAX_SCROLL_VALUE) newScrollValue = MAX_SCROLL_VALUE;      }      if (moveY < SCROLL_HIGHER_BOUND && currentScrollValue > NORMAL_SCROLL_MAX           && NORMAL_SCROLL_MAX > 0) {        let PERCENTAGE_CHANGE = 1 - ((this.listLayout.height - moveY) / SCROLL_LOWER_BOUND);        pc = PERCENTAGE_CHANGE;
        newScrollValue = currentScrollValue + (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);      }      if (newScrollValue !== null) {        this.scrollValue = newScrollValue;         this.scrollResponder.scrollWithoutAnimationTo(this.scrollValue, 0);         this.scrollResponder.scrollTo({y: this.scrollValue, x: 0, animated: false});      }      this.checkTargetElement();      this.requestAnimationFrame(this.scrollAnimation);    }  },  checkTargetElement() {    let SLOP = 1.0  assume rows will be > 1 pixel high    let scrollValue = this.scrollValue;
    let moveY = this.moveY - this.wrapperLayout.pageY;
    let activeRowY = scrollValue + moveY - this.firstRowY;
    let indexHeight = 0.0;    let i = 0;    let row;    let order = this.order;    let isLast = false;    while (indexHeight < activeRowY + SLOP) {      let key = order[i];      row = this.layoutMap[key];      if (!row) {        isLast = true;        break;      }      indexHeight += row.height;      i++;    }    if (!isLast) i--;        if (i != this.state.hovering && i >= 0) {      LayoutAnimation.easeInEaseOut();      this._previouslyHovering = this.state.hovering;      this.__activeY = this.panY;      this.setState({        hovering: String(i)      })    }
  },  firstRowY: undefined,  layoutMap: {},  _rowRefs: {},  handleRowActive: function(row) {    if (this.props.disableSorting) return;    this.state.pan.setValue({x: 0, y: 0});    LayoutAnimation.easeInEaseOut();    this.moveY = row.layout.pageY;    this.setState({      active: row,      hovering: row.rowData.index,    },  this.scrollAnimation);
  },  renderActiveDivider: function() {    let height = this.state.active ? this.state.active.layout.frameHeight : null    if (this.props.renderActiveDivider) return this.props.renderActiveDivider(height);    return <View style={{height: height}} />  },  renderRow: function(data, section, index, highlightfn, active) {
    let Component = active ? SortRow : Row;    let isActiveRow = (!active && this.state.active && this.state.active.rowData.index === index);    if (!active && isActiveRow) {      active = {active: true};    }    let hoveringIndex = this.order[this.state.hovering] || this.state.hovering;    return (<Component      {...this.props}      activeDivider={this.renderActiveDivider()}      key={index}      active={active}      list={this}      ref={view => { this._rowRefs[active ? ghost : index] = view; }}      hovering={hoveringIndex == index}      panResponder={this.state.panResponder}      rowData={{data, section, index}}      onRowActive={this.handleRowActive}      onRowLayout={layout => this._updateLayoutMap(index, layout.nativeEvent.layout)}      />);  },  _updateLayoutMap(index, layout) {      if (this.firstRowY === undefined || layout.y < this.firstRowY) {          this.firstRowY = layout.y;      }      this.layoutMap[index] = layout;  },  renderActive: function() {    if (!this.state.active) return;    let index = this.state.active.rowData.index;    return this.renderRow(this.props.data[index], s1, index, () => {}, {active: true, thumb: true});  },  componentWillMount: function() {    this.setOrder(this.props);  },  componentWillReceiveProps: function(props) {    this.setOrder(props);  },  setOrder: function(props) {    this.order = props.order || Object.keys(props.data) || [];  },  getScrollResponder: function() {    return this.scrollResponder;  },  render: function() {    let dataSource = this.state.ds.cloneWithRows(this.props.data, this.props.order);
    return <View ref=wrapper style={{flex: 1}} onLayout={()=>{this.measureWrapper()}}>      <ListView        enableEmptySections={true}        {...this.props}        {...this.state.panResponder.panHandlers}        ref=list        dataSource={dataSource}        onScroll={e => {          this.scrollValue = e.nativeEvent.contentOffset.y;          if (this.props.onScroll) this.props.onScroll(e);        }}        onContentSizeChange={(width, height) => {          this.scrollContainerHeight = height;        }}        onLayout={(e) => this.listLayout = e.nativeEvent.layout}        scrollEnabled={!this.state.active && (this.props.scrollEnabled !== false)}        renderRow={this.renderRow}      />      {this.renderActive()}    </View>  },  scrollTo: function(...args) {    this.scrollResponder.scrollTo.apply(this.scrollResponder, args);  }});
module.exports = SortableListView;"
"var path = require(path)var webpack = require(webpack)
module.exports = {  entry: ./demo/main.js,  output: {    path: path.resolve(__dirname, ./demo/dist),    publicPath: /demo/dist/,    filename: build.js  },  resolveLoader: {    root: path.join(__dirname, node_modules),  },  module: {    loaders: [      {        test: vue,        loader: vue      },      {        test: js,        loader: babel,        exclude: node_modules      },      {        test: json,        loader: json      },      {        test: html,        loader: vue-html      },      {        test: scss,        loaders: [style, css, sass]      },      {        test: (pngjpggifsvg),        loader: url,        query: {          limit: 10000,          name: [name].[ext]?[hash]        }      }    ]  },  devServer: {    historyApiFallback: true,    noInfo: true  },  devtool: eval-source-map}
if (process.env.NODE_ENV === production) {  module.exports.devtool = source-map   http://vuejs.github.io/vue-loader/workflow/production.html  module.exports.plugins = (module.exports.plugins || []).concat([    new webpack.DefinePlugin({      process.env: {        NODE_ENV: ""production""      }    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    }),    new webpack.optimize.OccurenceOrderPlugin()  ])}"
";(function () {
  var vSortable = {}  var Sortable = typeof require === function      ? require(sortablejs)      : window.Sortable
  if (!Sortable) {    throw new Error([vue-sortable] cannot locate Sortable.js.)  }
   exposed global options  vSortable.config = {}
  vSortable.install = function (Vue) {    Vue.directive(sortable, function (options) {      options = options || {}
      var sortable = new Sortable(this.el, options)
      if (this.arg && !this.vm.sortable) {        this.vm.sortable = {}      }
        Throw an error if the given ID is not unique      if (this.arg && this.vm.sortable[this.arg]) {        console.warn([vue-sortable] cannot set already defined sortable id:  + this.arg + )      } else if( this.arg ) {        this.vm.sortable[this.arg] = sortable      }    })  }
  if (typeof exports == object) {    module.exports = vSortable  } else if (typeof define == function && define.amd) {    define([], function () {      return vSortable    })  } else if (window.Vue) {    window.vSortable = vSortable    Vue.use(vSortable)  }
})()"
"module.exports = function(grunt){	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-uglify);	 grunt.loadNpmTasks('grunt-karma');
	grunt.initConfig({		uglify: {			target: {				files: {					src/angular-sortable-view.min.js: [src/angular-sortable-view.js]				}			},			options: {				banner: /*Copyright Kamil Pękala http://github.com/kamilkp +						angular-sortable-view v0.0.13 2015/01/13*/			}		},		jshint: {			all: [				src/angular-sortable-view.js,				Gruntfile.js			]		},		 karma: {		 	unit: {		 		configFile: 'karma.conf.js',		 		singleRun: true,		 	},		 	travis: {		 		configFile: 'karma.conf.js',		 		singleRun: true,		 		browsers: [		 			'Firefox'		 		]		 	}		 }	});
	grunt.registerTask(min, Minify javascript source code, uglify);	 grunt.registerTask('test', 'Run unit tests', ['jshint', 'min', 'karma:unit']);	 grunt.registerTask('default', ['test']);	 grunt.registerTask('travis', ['jshint', 'min', 'karma:travis']);};"
"/*! * Muuri v0.2.0 * https://github.com/haltu/muuri * Copyright (c) 2015, Haltu Oy * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the ""Software""), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */!function(t,e){var i=""Muuri"",n=""function""==typeof jQuery?jQuery.Velocity:t.Velocity,r=t.Hammer;t[i]=e(t,n,r)}(this,function(t,e,n,r){""use strict"";function o(){}function s(t){var e=this,i=[],n=!!t.fillGaps,r=!!t.horizontal,o=!!t.alignRight,a=!!t.alignBottom;if(e.width=Math.round(e.width),e.height=Math.round(e.height),r?(e.setWidth=!0,e.width=0):(e.setHeight=!0,e.height=0),e.items.length){for(var l=0;l<e.items.length;l++){var h=e.items[l],u=s.getSlot(e,i,h._width,h._height,!r,n);r?e.width=Math.max(e.width,u.left+u.width):e.height=Math.max(e.height,u.top+u.height),e.slots[h._id]=u}if(o||a)for(var f in e.slots){var u=e.slots[f];o&&(u.left=e.width-(u.left+u.width)),a&&(u.top=e.height-(u.top+u.height))}}}function a(e){var i=this,n=i._settings=m({},a.defaultSettings,e||{});if(!document.body.contains(n.container))throw new Error(""Container must be an existing DOM element"");i._element=n.container,y(n.container,n.containerClass),i._id=++k,i._animQueue=""muuri-""+i._id,i._emitter=new o,i._itemShow=""function""==typeof n.show?n.show():M(n.show,!0),i._itemHide=""function""==typeof n.hide?n.hide():M(n.hide),i._items=[];for(var r=0,s=n.items.length;r<s;r++)i._items[i._items.length]=new a.Item(i,n.items[r]);if(n.layoutOnResize||0===n.layoutOnResize){var l=d(function(){i.refresh(),i.layout()},n.layoutOnResize);i._resizeHandler=function(){l()},t.addEventListener(""resize"",i._resizeHandler)}n.layoutOnInit&&i.layout(!0)}function l(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function h(t,e,i){t.splice(i,0,t.splice(e,1)[0])}function u(t){for(var e=[],i=0,n=t.length;i<n;i++)e.indexOf(t[i])===-1&&(e[e.length]=t[i]);return e}function f(t){return""object""==typeof t&&""[object Object]""===Object.prototype.toString.call(t)}function m(t){for(var e=Array.prototype.slice.call(arguments,1),i=0;i<e.length;i++){var n=e[i];for(var r in n)n.hasOwnProperty(r)&&(f(t[r])&&f(n[r])?m(t[r],n[r]):t[r]=n[r])}return t}function d(e,i){var n,o=""cancel"",s=""finish"";return function(a){n!==r&&(n=t.clearTimeout(n),a===s&&e()),a!==o&&a!==s&&(n=t.setTimeout(function(){n=r,e()},i))}}function c(t,e){var i=null,n={left:t.left-e.left,right:e.left+e.width-(t.left+t.width),top:t.top-e.top,bottom:e.top+e.height-(t.top+t.height)},r=Math.max(t.width+Math.min(n.left,0)+Math.min(n.right,0),0),o=Math.max(t.height+Math.min(n.top,0)+Math.min(n.bottom,0),0),s=r>0&&o>0;return s&&(i={},i.width=r,i.height=o,i.left=t.left+Math.abs(Math.min(n.left,0)),i.right=i.left+i.width,i.top=t.top+Math.abs(Math.min(n.top,0)),i.bottom=i.top+i.height),i}function _(e,i){return t.getComputedStyle(e,null).getPropertyValue(i)}function g(t,e){for(var i in e)t.style[i]=e[i]}function p(t,i){for(var n in i)e.hook(t,n,i[n])}function v(t,e){return("" ""+t.className).indexOf("" ""+e)>-1}function y(t,e){t.classList?t.classList.add(e):v(t,e)&&(t.className+="" ""+e)}function w(t,e){t.classList?t.classList.remove(e):v(t,e)&&(t.className=("" ""+t.className+"" "").replace("" ""+e+"" "","" "").trim())}function C(e,i,n){var o=e.getBoundingClientRect()[i],s=""height""===i,a=s?""Height"":""Width"",l=""inner""+a,h=""client""+a,u=s?""top"":""left"",f=s?""bottom"":""right"";if(n){var m=parseFloat(_(e,""margin-""+u)),d=parseFloat(_(e,""margin-""+f));o+=m>0?m:0,o+=d>0?d:0}else{var c,g;e===document.documentElement?o-=t[l]-document.documentElement[h]:(c=parseFloat(_(e,""border-""+u+""-width"")),g=parseFloat(_(e,""border-""+f+""-width"")),o-=Math.round(o)-e[h]-c-g),o-=c!==r?c:parseFloat(_(e,""border-""+u+""-width"")),o-=g!==r?g:parseFloat(_(e,""border-""+f+""-width""))}return o}function b(e){var i=0,n=0,r=parseFloat(t.pageXOffset),o=parseFloat(t.pageYOffset);if(e.self===t.self)i=r,n=o;else if(e!==document){var s=e.getBoundingClientRect();i+=s.left+r+parseFloat(_(e,""border-left-width"")),n+=s.top+o+parseFloat(_(e,""border-top-width""))}return{left:i,top:n}}function D(e){var i=""fixed""===_(e,""position"");if(i&&rt)return t;var n=e===document.documentElement||e===t?document:e.parentElement||null;if(i){for(;n&&n!==document&&!x(n);)n=n.parentElement||document;return n===document?t:n}for(;n&&n!==document&&""static""===_(n,""position"")&&!x(n);)n=n.parentElement||document;return n}function x(t){var e=_(t,nt.style),i=_(t,""display"");return""none""!==e&&""inline""!==i&&""none""!==i}function S(t,e){var i=b(e),n=b(D(t)||doc);return n.left-=Math.abs(Math.min(parseFloat(_(t,""margin-left"")),0)),n.top-=Math.abs(Math.min(parseFloat(_(t,""margin-top"")),0)),{left:i.left-n.left,top:i.top-n.top}}function R(e){var i=[],n=/(auto|scroll)/,r=e.parentNode;if(rt){if(""fixed""===_(e,""position""))return i;for(;r&&r!==document&&r!==document.documentElement;)n.test(_(r,""overflow"")+_(r,""overflow-y"")+_(r,""overflow-x""))&&(i[i.length]=r),r=""fixed""===_(r,""position"")?null:r.parentNode;null!==r&&(i[i.length]=t)}else{for(;r&&r!==document;)""fixed""!==_(e,""position"")||x(r)?(n.test(_(r,""overflow"")+_(r,""overflow-y"")+_(r,""overflow-x""))&&(i[i.length]=r),e=r,r=r.parentNode):r=r.parentNode;i.length&&i[i.length-1]===document.documentElement&&(i[i.length-1]=t)}return i}function I(t,e){var i=c(t,e);if(!i)return 0;var n={width:t.width,height:t.height,left:0,top:0},r={width:e.width,height:e.height,left:0,top:0},o=c(n,r);return i.width*i.height/(o.width*o.height)*100}function O(t,e,i){return{type:t,event:e,currentLeft:i.left,currentTop:i.top,gridLeft:i.gridX,gridTop:i.gridY}}function X(t,e,i){this.isResolved||(this.isResolved=!0,i(t))}function Y(t){if(!t.elementStyles){var e=[""width"",""height"",""padding"",""margin""];t.elementStyles={};for(var i=0;i<4;i++){var n=e[i],r=t.element.style[n];t.elementStyles[n]=r||""""}for(var i=0;i<4;i++){var n=e[i];t.element.style[n]=_(t.element,n)}}}function L(t){if(t.elementStyles)for(var e in t.elementStyles)t.element.style[e]=t.elementStyles[e]}function E(t,e,i,n,r){i=t.get(i),r=""function""==typeof n?n:r;var o=i.length;if(o){var s=""show""===e,a=s?A:W,l=s?j:B,h=n===!0,u=[],f=!1,m=[];t._emitter.emit(a,i);for(var d=0,c=i.length;d<c;d++){var _=i[d];(s&&!_._active||!s&&_._active)&&(f=!0,s&&(_._noLayoutAnimation=!0,m[m.length]=_)),_[""_""+e](h,function(e,i){e||(u[u.length]=i),--o<1&&(""function""==typeof r&&r(u),t._emitter.emit(l,u))})}f&&(m.length&&t.refresh(m),t.layout())}else""function""==typeof r&&r(i)}function M(t,i){var n=t&&t.duration||0,r=t&&t.easing||""ease-out"";if(n){var o=i?{opacity:1,scale:1}:{opacity:0,scale:.5};return{start:function(t,i,s){i?p(t._child,o):(e(t._child,o,{duration:n,easing:r,queue:t._muuri._animQueue,complete:s}),e.Utilities.dequeue(t._child,t._muuri._animQueue))},stop:function(t){e(t._child,""stop"",t._muuri._animQueue)}}}return{start:P,stop:P}}function Q(t,e,i){for(var n=t.splice(0,t.length),r=0,o=n.length;r<o;r++)n[r](e,i)}if(!document.body)throw Error(""Muuri needs access to document.body to work."");var k=0,P=function(){},F=""function""==typeof t.requestAnimationFrame?t.requestAnimationFrame:null,H=""refresh"",N=""synchronize"",T=""layoutstart"",z=""layoutend"",A=""showstart"",j=""showend"",W=""hidestart"",B=""hideend"",q=""move"",V=""swap"",U=""add"",G=""remove"",Z=""dragstart"",J=""dragmove"",K=""dragscroll"",$=""dragend"",tt=""releasestart"",et=""releaseend"",it=""destroy"",nt=function(){for(var t=[""transform"",""WebkitTransform"",""MozTransform"",""OTransform"",""msTransform""],e=0;e<t.length;e++)if(document.documentElement.style[t[e]]!==r){var i=t[e],n=i.toLowerCase().split(""transform"")[0];return{prefix:n,prop:i,style:n?""-""+n+""-transform"":i}}return null}(),rt=function(){if(!nt)return!0;var t,e,i=document.body,n=document.createElement(""div""),r=document.createElement(""div"");return g(n,{display:""block"",visibility:""hidden"",position:""absolute"",width:""1px"",height:""1px"",left:""1px"",top:""0"",margin:""0""}),g(r,{display:""block"",position:""fixed"",width:""1px"",height:""1px"",left:""0"",top:""0"",margin:""0""}),n.appendChild(r),i.appendChild(n),t=r.getBoundingClientRect().left,n.style[nt.prop]=""translateZ(0)"",e=r.getBoundingClientRect().left,i.removeChild(n),e===t}();return o.prototype.on=function(t,e){var i=this._events=this._events||{},n=i[t]||[];return n[n.length]=e,i[t]=n,this},o.prototype.off=function(t,e){var n=this._events=this._events||{},r=n[t]||[],o=r.length;if(o)for(;o--;)e===r[i]&&r.splice(o,1);return this},o.prototype.emit=function(t,e,i,n){var r=this._events=this._events||{},o=r[t]||[],s=o.length;if(s){var a=arguments.length-1;o=o.concat();for(var l=0;l<s;l++)0===a?o[l]():1===a?o[l](e):2===a?o[l](e,i):o[l](e,i,n)}return this},s.getSlot=function(t,e,i,n,r,o){var a,l,h,u,f,m=e[0]||[],d=[],c={left:null,top:null,width:i,height:n};for(a=0;a<m.length;a++)if(h=m[a],c.width<=h.width&&c.height<=h.height){c.left=h.left,c.top=h.top;break}for(null===c.left&&(c.left=r?0:t.width,c.top=r?t.height:0,o||(f=!0)),r&&c.top+c.height>t.height&&(c.left>0&&(d[d.length]={left:0,top:t.height,width:c.left,height:1/0}),c.left+c.width<t.width&&(d[d.length]={left:c.left+c.width,top:t.height,width:t.width-c.left-c.width,height:1/0}),t.height=c.top+c.height),!r&&c.left+c.width>t.width&&(c.top>0&&(d[d.length]={left:t.width,top:0,width:1/0,height:c.top}),c.top+c.height<t.height&&(d[d.length]={left:t.width,top:c.top+c.height,width:1/0,height:t.height-c.top-c.height}),t.width=c.left+c.width),a=o?0:f?m.length:a;a<m.length;a++)for(u=s.splitRect(m[a],c),l=0;l<u.length;l++)h=u[l],h.width>0&&h.height>0&&(r&&h.top<t.height||!r&&h.left<t.width)&&(d[d.length]=h);return s.purgeSlots(d).sort(r?s.sortRectsTopLeft:s.sortRectsLeftTop),e[0]=d,c},s.sortRectsTopLeft=function(t,e){return t.top<e.top?-1:t.top>e.top?1:t.left<e.left?-1:t.left>e.left?1:0},s.sortRectsLeftTop=function(t,e){return t.left<e.left?-1:t.left>e.left?1:t.top<e.top?-1:t.top>e.top?1:0},s.isRectWithinRect=function(t,e){return t.left>=e.left&&t.top>=e.top&&t.left+t.width<=e.left+e.width&&t.top+t.height<=e.top+e.height},s.purgeSlots=function(t){for(var e=t.length;e--;)for(var i=t[e],n=t.length;n--;){var r=t[n];if(e!==n&&s.isRectWithinRect(i,r)){t.splice(e,1);break}}return t},s.splitRect=function(t,e){var i=[],n=!(e.left>t.left+t.width||e.left+e.width<t.left||e.top>t.top+t.height||e.top+e.height<t.top);return n?(t.left<e.left&&(i[i.length]={left:t.left,top:t.top,width:e.left-t.left,height:t.height}),t.left+t.width>e.left+e.width&&(i[i.length]={left:e.left+e.width,top:t.top,width:t.left+t.width-(e.left+e.width),height:t.height}),t.top<e.top&&(i[i.length]={left:t.left,top:t.top,width:t.width,height:e.top-t.top}),t.top+t.height>e.top+e.height&&(i[i.length]={left:t.left,top:e.top+e.height,width:t.width,height:t.top+t.height-(e.top+e.height)})):i[0]=t,i},a.prototype._getItem=function(t){if(t){if(t instanceof a.Item)return t._muuri===this?t:null;if(""number""==typeof t)return t=t>-1?t:this._items.length+t,this._items[t]||null;for(var e=null,i=0,n=this._items.length;i<n;i++){var r=this._items[i];if(r._element===t){e=r;break}}return e}return this._items[0]||null},a.prototype.on=function(t,e){return this._emitter.on(t,e),this},a.prototype.off=function(t,e){return this._emitter.off(t,e),this},a.prototype.refresh=function(t){t=t?this.get(t):this.get(""active"");for(var e=0,i=t.length;e<i;e++)t[e]._refresh();this._emitter.emit(H,t)},a.prototype.get=function(t,e){var i=t&&""string""!=typeof t;if(e=i?e:t,e=""string""==typeof e?e:null,t=i?[].concat(t):null,e||t){for(var n=t||this._items,r=[],o=""active""===e,s=""inactive""===e,a=0,l=n.length;a<l;a++){var h=i?this._getItem(n[a]):n[a];h&&(!e||o&&h._active||s&&!h._active)&&(r[r.length]=h)}return r}return this._items.concat()},a.prototype.add=function(t,e){var i=[],n=!1;t=[].concat(t);for(var r=0,o=this._items.length;r<o;r++){var s=this._items[r],e=t.indexOf(s._element);e>-1&&t.splice(e,1)}if(!t.length)return i;for(var r=0,o=t.length;r<o;r++){var s=new a.Item(this,t[r]);i[i.length]=s,s._active&&(n=!0,s._noLayoutAnimation=!0)}return e=e<0?this._items.length-e+1:e,this._items.splice.apply(this._items,[e,0].concat(i)),n&&this.layout(),this._emitter.emit(U,i),i},a.prototype.remove=function(t,e){var i=[],n=!1;t=this.get(t);for(var r=0,o=t.length;r<o;r++){var s=t[r];s._active&&(n=!0),i[i.length]=s._destroy(e)}return n&&this.layout(),this._emitter.emit(G,i),i},a.prototype.synchronize=function(){for(var t=0,e=this._items.length;t<e;t++){var i=this._items[t];i._element.parentNode===this._element&&this._element.appendChild(i._element)}this._emitter.emit(N)},a.prototype.layout=function(t,e){var i=this,n=i._emitter,e=""function""==typeof t?t:e,r=t===!0,o=new a.Layout(i),s=-1,l=o.items.length,h=[],u=function(t,i){t||(h[h.length]=i),++s===l&&(""function""==typeof e&&e(h,o),n.emit(z,h,o))};if(n.emit(T,o.items,o),o.setHeight&&g(i._element,{height:o.height+""px""}),o.setWidth&&g(i._element,{width:o.width+""px""}),l)for(var f=0,m=o.items.length;f<m;f++){var d=o.items[f],c=o.slots[d._id];d._left=c.left,d._top=c.top,d._drag.active?u(!1,d):d._layout(r,u)}else u(!0)},a.prototype.show=function(t,e,i){E(this,""show"",t,e,i)},a.prototype.hide=function(t,e,i){E(this,""hide"",t,e,i)},a.prototype.indexOf=function(t){if(""number""==typeof t)return t<=this._items.length-1?t:null;if(t instanceof a.Item){var e=this._items.indexOf(t);return e>-1?e:null}for(var e=null,i=0,n=this._items.length;i<n;i++)if(this._items[i]._element===t){e=i;break}return e},a.prototype.move=function(t,e){t=this._getItem(t),e=this._getItem(e),t&&e&&t!==e&&(h(this._items,this._items.indexOf(t),this._items.indexOf(e)),this._emitter.emit(q,t,e))},a.prototype.swap=function(t,e){t=this._getItem(t),e=this._getItem(e),t&&e&&t!==e&&(l(this._items,this._items.indexOf(t),this._items.indexOf(e)),this._emitter.emit(V,t,e))},a.prototype.destroy=function(){this._resizeHandler&&t.removeEventListener(""resize"",this._resizeHandler);for(var e=this._items.concat(),i=0,n=e.length;i<n;i++)e[i]._destroy();w(this._element,this._settings.containerClass),g(this._element,{height:""""}),this._emitter.emit(it);var r=this._emitter._events;if(r)for(var o=Object.keys(this._emitter._events),i=0,n=o.length;i<n;i++)r[o[i]].length=0;for(var s=Object.keys(this).concat(Object.keys(a.prototype)),i=0;i<s.length;i++)this[s[i]]=null},a.Item=function(t,e){if(e.contains(t._element))throw new Error(""Item element must not be a parent of the grid container element"");e.parentNode!==t._element&&t._element.appendChild(e);var i=t._settings,n=""none""===_(e,""display"");this._id=++k,this._muuri=t,this._element=e,this._child=e.children[0],y(e,i.itemClass),this._active=!n,this._positioning=!1,this._hidden=n,this._hiding=!1,this._showing=!1,this._visibiliyQueue=[],this._layoutQueue=[],p(this._element,{left:""0"",top:""0"",translateX:""0px"",translateY:""0px""}),y(e,n?i.hiddenClass:i.shownClass),p(this._child,{scale:n?0:1,opacity:n?0:1}),n||g(this._element,{display:""block""}),this._refresh(),this._left=0,this._top=0,this._drag={active:!1},this._release={active:!1},t._settings.dragEnabled&&this._initDrag()},a.Item.prototype.inspect=function(){return{element:this._element,width:this._width,height:this._height,left:this._left,top:this._top,active:this._active,positioning:this._positioning,dragging:this._drag.active,releasing:this._release.active,visibility:this._hiding?""hiding"":this._showing?""showing"":this._hidden?""hidden"":""shown""}},a.Item.prototype._initDrag=function(){var t=this,e=t._muuri._settings,i=t._hammer=new n.Manager(t._element);i.add(new n.Pan({event:""drag"",pointers:1,threshold:0,direction:n.DIRECTION_ALL})),i.add(new n.Press({event:""draginit"",pointers:1,threshold:100,time:0})),i.set({touchAction:""none""}),t._resetReleaseData();var r=t._drag;t._resetDragData(),r.checkOverlap=d(function(){r.active&&t._checkOverlap()},e.dragSortInterval);var o=!1;r.predicate=""function""==typeof e.dragPredicate?e.dragPredicate:X,r.predicateData={},r.isPredicateResolved=function(){return o},r.resolvePredicate=function(e){o||""draginitup""===e.type||""dragend""===e.type||""dragcancel""===e.type||(o=!0,t._onDragStart(e))},r.onScroll=function(e){F?F(function(){t._onDragScroll(e)}):t._onDragScroll(e)},i.on(""draginit"",function(e){r.predicateData={},o=!1,r.predicate.call(r.predicateData,e,t,r.resolvePredicate)}).on(""dragstart dragmove"",function(e){o&&r.active&&t._onDragMove(e),r.predicate.call(r.predicateData,e,t,r.resolvePredicate)}).on(""dragend dragcancel draginitup"",function(e){o&&r.active&&t._onDragEnd(e),r.predicate.call(r.predicateData,e,t,r.resolvePredicate)})},a.Item.prototype._resetDragData=function(){var t=this._drag;t.active=!1,t.start=null,t.move=null,t.element=null,t.elemWidth=0,t.elemHeight=0,t.elementStyles=null,t.scrollParents=[],t.left=0,t.top=0,t.gridX=0,t.gridY=0,t.elemClientX=0,t.elemClientY=0,t.containerDiffX=0,t.containerDiffY=0},a.Item.prototype._onDragStart=function(t){var i=this._drag,n=this._muuri._settings,r=this._release.active;if(this._active){this._positioning&&this._stopLayout(),r&&(i.elementStyles=this._release.elementStyles,w(this._element,n.releasingClass),this._resetReleaseData()),i.active=!0,i.start=t,i.move=t,i.element=this._element,i.elemWidth=this._width,i.elemHeight=this._height;var o=parseFloat(e.hook(i.element,""translateX""))||0,s=parseFloat(e.hook(i.element,""translateY""))||0,a=this._muuri._element,l=n.dragContainer;if(i.left=i.gridX=o,i.top=i.gridY=s,l&&l!==a)if(i.element.parentNode===l){var h=S(i.element,a);i.containerDiffX=h.left,i.containerDiffY=h.top,i.gridX=o-i.containerDiffX,i.gridY=s-i.containerDiffY}else{Y(i),l.appendChild(i.element);var h=S(i.element,a);i.containerDiffX=h.left,i.containerDiffY=h.top,i.left=o+i.containerDiffX,i.top=s+i.containerDiffY,p(i.element,{translateX:i.left+""px"",translateY:i.top+""px""})}var f=i.element.getBoundingClientRect();i.elemClientX=f.left,i.elemClientY=f.top,i.scrollParents=R(i.element),l&&l!==a&&(i.scrollParents=u(i.scrollParents.concat(R(a))));for(var m=0,d=i.scrollParents.length;m<d;m++)i.scrollParents[m].addEventListener(""scroll"",i.onScroll);y(i.element,n.draggingClass),this._muuri._emitter.emit(Z,this,O(""dragstart"",t,i))}},a.Item.prototype._onDragMove=function(t){var e=this._drag,i=this._muuri._settings;if(!this._active)return void this._resetDrag();var n=t.deltaX-e.move.deltaX,r=t.deltaY-e.move.deltaY;e.move=t,e.left+=n,e.top+=r,e.gridX+=n,e.gridY+=r,e.elemClientX+=n,e.elemClientY+=r,p(e.element,{translateX:e.left+""px"",translateY:e.top+""px""}),i.dragSort&&e.checkOverlap(),this._muuri._emitter.emit(J,this,O(""dragmove"",t,e))},a.Item.prototype._onDragScroll=function(t){var e=this._drag,i=this._muuri._settings,n=this._muuri._element,r=i.dragContainer,o=e.element.getBoundingClientRect(),s=e.elemClientX-o.left,a=e.elemClientY-o.top;if(r&&r!==n){var l=S(e.element,n);e.containerDiffX=l.left,e.containerDiffY=l.top}e.left+=s,e.top+=a,e.gridX=e.left-e.containerDiffX,e.gridY=e.top-e.containerDiffY,p(e.element,{translateX:e.left+""px"",translateY:e.top+""px""}),i.dragSort&&e.checkOverlap(),this._muuri._emitter.emit(K,this,O(""dragscroll"",t,e))},a.Item.prototype._onDragEnd=function(t){var e=this._drag,i=this._muuri._settings,n=this._release;if(!this._active)return void this._resetDrag();i.dragSort&&e.checkOverlap(""finish"");for(var r=0,o=e.scrollParents.length;r<o;r++)e.scrollParents[r].removeEventListener(""scroll"",e.onScroll);w(e.element,i.draggingClass),e.active=!1,this._muuri._emitter.emit($,this,O(""dragend"",t,e)),n.containerDiffX=e.containerDiffX,n.containerDiffY=e.containerDiffY,n.element=e.element,n.elementStyles=e.elementStyles,this._resetDragData(),this._startRelease()},a.Item.prototype._resetDrag=function(t){for(var e=this._drag,i=this._muuri._settings,n=0,r=e.scrollParents.length;n<r;n++)e.scrollParents[n].removeEventListener(""scroll"",e.onScroll);e.checkOverlap(""cancel""),w(e.element,i.draggingClass),L(e),this._resetDragData()},a.Item.prototype._resetReleaseData=function(){var t=this._release;t.active=!1,t.positioningStarted=!1,t.containerDiffX=0,t.containerDiffY=0,t.element=null,t.elementStyles=null},a.Item.prototype._startRelease=function(){var t=this._muuri._settings,e=this._release;e.active=!0,y(e.element,t.releasingClass),this._muuri._emitter.emit(tt,this),this._layout(!1)},a.Item.prototype._endRelease=function(){var t=this._muuri._settings,e=this._release;w(e.element,t.releasingClass),e.element.parentNode!==this._muuri._element&&(this._muuri._element.appendChild(e.element),p(e.element,{translateX:this._left+""px"",translateY:this._top+""px""})),L(e),this._resetReleaseData(),this._muuri._emitter.emit(et,this)},a.Item.prototype._checkOverlap=function(){for(var t=this._muuri._settings,e=t.dragSortTolerance,i=t.dragSortAction,n=this._muuri._items,r=null,o=0,s={width:this._drag.elemWidth,height:this._drag.elemHeight,left:this._drag.gridX,top:this._drag.gridY},a=0,u=n.length;a<u;a++){var f=n[a];if(f===this)o=a;else if(f._active){var m=I(s,{width:f._width,height:f._height,left:f._left,top:f._top});(!r||m>r.score)&&(r={item:f,score:m,index:a})}}r&&r.score>=e&&(""swap""===i?(l(n,o,r.index),this._muuri._emitter.emit(V,this,r.item)):(h(n,o,r.index),this._muuri._emitter.emit(q,this,r.item)),this._muuri.layout())},a.Item.prototype._stopLayout=function(){var t=this._muuri._settings;this._positioning&&(e(this._element,""stop"",this._muuri._animQueue),w(this._element,t.positioningClass),this._positioning=!1,Q(this._layoutQueue,!0,this))},a.Item.prototype._refresh=function(){this._hidden||(this._width=Math.round(C(this._element,""width"",!0)),this._height=Math.round(C(this._element,""height"",!0)))},a.Item.prototype._layout=function(t,i){var n=this,r=n._muuri._settings,o=n._release,s=o.active&&o.positioningStarted===!1,a=s?r.dragReleaseDuration:r.positionDuration,l=s?r.dragReleaseEasing:r.positionEasing,h=t!==!0&&!n._noLayoutAnimation&&a>0,u=n._positioning,f=function(){w(n._element,r.positioningClass),n._positioning=!1,o.active&&n._endRelease(),Q(n._layoutQueue,!1,n)};n._stopLayout(),""function""==typeof i&&(n._layoutQueue[n._layoutQueue.length]=i),s&&(o.positioningStarted=!0);var m=n._release.active?n._release.containerDiffX:0,d=n._release.active?n._release.containerDiffY:0;if(h){var c=(parseFloat(e.hook(n._element,""translateX""))||0)-m,_=(parseFloat(e.hook(n._element,""translateY""))||0)-d;if(n._left===c&&n._top===_)return void f();n._positioning=!0,u||y(n._element,r.positioningClass),e(n._element,{translateX:n._left+m,translateY:n._top+d},{duration:a,easing:l,complete:f,queue:n._muuri._animQueue}),e.Utilities.dequeue(n._element,n._muuri._animQueue)}else n._noLayoutAnimation&&(n._noLayoutAnimation=!1),p(n._element,{translateX:n._left+m+""px"",translateY:n._top+d+""px""}),f()},a.Item.prototype._show=function(t,e){var i=this,n=i._muuri._settings;if(i._hidden||i._showing)if(i._hidden){i._hiding;i._muuri._itemHide.stop(i),i._active=!0,i._hidden=!1,i._showing=i._hiding=!1,y(i._element,n.shownClass),w(i._element,n.hiddenClass),g(i._element,{display:""block""}),Q(i._visibiliyQueue,!0,i),i._showing=!0,""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e),i._muuri._itemShow.start(i,t,function(){Q(i._visibiliyQueue,!1,i)})}else""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e);else""function""==typeof e&&e(!1,i)},a.Item.prototype._hide=function(t,e){var i=this,n=i._muuri._settings;if(i._hidden&&!i._hiding)""function""==typeof e&&e(!1,i);else if(i._hidden)""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e);else{i._showing;i._muuri._itemShow.stop(i),i._active=!1,i._hidden=!0,i._showing=i._hiding=!1,y(i._element,n.hiddenClass),w(i._element,n.shownClass),Q(i._visibiliyQueue,!0,i),i._hiding=!0,""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e),i._muuri._itemHide.start(i,t,function(){g(i._element,{display:""none""}),Q(i._visibiliyQueue,!1,i)})}},a.Item.prototype._destroy=function(t){var e=(this._muuri,this._muuri._settings),i=this._element,n=this._muuri._items.indexOf(this);this._stopLayout(),this._muuri._itemShow.stop(this),this._muuri._itemHide.stop(this),this._release.active&&(i.parentNode!==this._muuri._element&&this._muuri._element.appendChild(i),this._resetReleaseData()),this._drag.active&&(i.parentNode!==this._muuri._element&&this._muuri._element.appendChild(i),this._resetDrag()),this._hammer&&this._hammer.destroy(),i.removeAttribute(""style""),this._child.removeAttribute(""style""),Q(this._visibiliyQueue,!0,this),w(i,e.positioningClass),w(i,e.draggingClass),w(i,e.releasingClass),w(i,e.itemClass),w(i,e.shownClass),w(i,e.hiddenClass),n>-1&&this._muuri._items.splice(n,1),t&&i.parentNode.removeChild(i);for(var r=Object.keys(this).concat(Object.keys(a.Item.prototype)),o=0;o<r.length;o++)this[r[o]]=null},a.Layout=function(t,e){var i=t._settings.layout;if(this.muuri=t,this.items=e?e.concat():t.get(""active""),this.slots={},this.width=0,this.height=0,this.setWidth=!1,this.setHeight=!1,this.width=C(t._element,""width""),this.height=C(t._element,""height""),""function""==typeof i)i.call(this);else{var n=""string""==typeof i,r=n?i:i[0];if(""function""!=typeof a.Layout.methods[r])throw new Error('Layout method ""'+method+'"" does not exist.');typeof a.Layout.methods[r].call(this,n?{}:i[1])}},a.Layout.methods={firstFit:s},a.defaultSettings={container:null,items:[],positionDuration:300,positionEasing:""ease-out"",show:{duration:300,easing:""ease-out""},hide:{duration:300,easing:""ease-out""},layout:""firstFit"",layoutOnResize:100,layoutOnInit:!0,dragEnabled:!1,dragContainer:null,dragPredicate:null,dragSort:!0,dragSortInterval:50,dragSortTolerance:50,dragSortAction:""move"",dragReleaseDuration:300,dragReleaseEasing:""ease-out"",containerClass:""muuri"",itemClass:""muuri-item"",shownClass:""muuri-shown"",hiddenClass:""muuri-hidden"",positioningClass:""muuri-positioning"",draggingClass:""muuri-dragging"",releasingClass:""muuri-releasing""},a});"
"module.exports = function (config) {    var configuration = {
         base path that will be used to resolve all patterns (eg. files, exclude)        basePath: ,

         frameworks to use         available frameworks: https://npmjs.org/browse/keyword/karma-adapter        frameworks: [jasmine],

         list of files / patterns to load in the browser        files: [            node_modules/jquery/dist/jquery.js,            node_modules/jasmine-jquery/lib/jasmine-jquery.js,            node_modules/jasmine2-custom-message/jasmine2-custom-message.js,            { pattern: Tests/*.html, included: true },            { pattern: Tests/*.js, included: true },            Scripts/moment.min.js,            Scripts/bootstrap-sortable.js        ],

         list of files to exclude        exclude: [        ],

         preprocess matching files before serving them to the browser         available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor        preprocessors: {        },

         test results reporter to use         possible values: 'dots', 'progress'         available reporters: https://npmjs.org/browse/keyword/karma-reporter        reporters: [mocha],

         enable / disable colors in the output (reporters and logs)        colors: true,

         level of logging         possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG        logLevel: config.LOG_INFO,

         enable / disable watching file and executing tests whenever any file changes        autoWatch: false,

         start these browsers         available browser launchers: https://npmjs.org/browse/keyword/karma-launcher        browsers: [PhantomJS],
         Continuous Integration mode         if true, Karma captures browsers, runs the tests and exits        singleRun: true    };
    config.set(configuration);}
"
"/** * Created by lijun on 2016/12/14. */var webpack = require(webpack)var path = require(path)var projectRoot = path.resolve(__dirname, ./)
module.exports = {  entry: ./docs/index.js,  output: {    path: ./build,    publicPath: build/,    filename: build-docs.js  },  resolve: {    root: path.resolve(./),    extensions: [, .js],    fallback: [path.join(__dirname, ../node_modules)],  },  resolveLoader: {    fallback: [path.join(__dirname, ../node_modules)]  },  module: {    preLoaders: [      {        test: js,        loader: eslint,        include: projectRoot,        exclude: node_modules      }    ],    loaders: [      {        test: js,        loader: babel,        include: projectRoot,        exclude: node_modules      },      { test: css, loader: style-loader!css-loader }    ]  },  eslint: {    formatter: require(eslint-friendly-formatter)  },  babel: {    presets: [      es2015,      stage-2    ],    plugins: [transform-runtime]  },  devtool: source-map};

if (process.env.NODE_ENV === production) {  delete module.exports.devtool;  module.exports.plugins = [    new webpack.DefinePlugin({      process.env: {        NODE_ENV: ""production""      }    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    })  ];}"
"/** * Created by lijun on 2016/12/14. */var config = require(./webpack.build.js)var webpack = require(webpack)

config.output.filename = config.output.filename.replace(js, .min.js)
delete config.devtool
config.plugins = [  new webpack.optimize.UglifyJsPlugin({    sourceMap: false,    drop_console: true,    compress: {      warnings: false    }  })]
module.exports = config"
"var path = require(path);var webpack = require(webpack);
module.exports = [{  entry: ./src/index.js,
  output: {    filename: ./lib/standalone/react-sortable.js,    libraryTarget: umd,    library: Sortable  },
  module: {    loaders: [{      test: js,      loader: babel,      include: [        path.join(__dirname, src)      ]    }]  },
  externals: {    react: React  }}, {  entry: ./src/index.js,
  output: {    filename: ./lib/standalone/react-sortable.min.js,    libraryTarget: umd,    library: Sortable  },
  module: {    loaders: [{      test: js,      loader: babel,      include: [        path.join(__dirname, src)      ]    }]  },
  externals: {    react: React  },
  plugins: [    new webpack.DefinePlugin({      process.env: {        NODE_ENV: JSON.stringify(production)      }    }),    new webpack.optimize.UglifyJsPlugin({      output: {        comments: false      },      compress: {        warnings: false      }    })  ]}];"
"use strict;
import React from react;import {  AppRegistry,} from react-native;
import Root from ./App/Root;AppRegistry.registerComponent(Sample, () => Root);"
"use strict;
import React from react;import {  AppRegistry,} from react-native;
import Root from ./App/Root;AppRegistry.registerComponent(Sample, () => Root);"
"var assert = require(assert)var ulid = require(./)
describe(ulid, function() {
  describe(prng, function() {
    it(should produce a number, function() {      assert.strictEqual(false, isNaN(ulid.prng()))    })
    it(should be between 0 and 1, function() {      var num = ulid.prng()      assert(num > 0 && num < 1)    })
  })
  describe(encodeTime, function() {
    it(should return expected encoded result, function() {      assert.strictEqual(01ARYZ6S41, ulid.encodeTime(1469918176385, 10))    })
    it(should change length properly, function() {      assert.strictEqual(0001AS99AA60, ulid.encodeTime(1470264322240, 12))    })
    it(should truncate time if not enough length, function() {      assert.strictEqual(AS4Y1E11, ulid.encodeTime(1470118279201, 8))    })
    it(should throw if time greater than (2 ^ 48) - 1, function() {      assert.throws(() => ulid.encodeTime(Math.pow(2, 48), 8), Error)    })
  })
  describe(encodeRandom, function() {
    it(should return correct length, function() {      assert.strictEqual(12, ulid.encodeRandom(12).length)    })
  })
  describe(ulid, function() {
    it(should return correct length, function() {      assert.strictEqual(26, ulid().length)    })
    it(should return expected encoded time component result, function() {      assert.strictEqual(01ARYZ6S41, ulid(1469918176385).substring(0, 10))    })
    it(should throw an error if seed is not a number, function() {      assert.throws(() => ulid(test), Error)    })
  })
})"
"(function(c){c.fn.stupidtable=function(b){return this.each(function(){var a=c(this);b=b||{};b=c.extend({},c.fn.stupidtable.default_sort_fns,b);a.data(sortFns,b);a.on(click.stupidtable,thead th,function(){c(this).stupidsort()})})};c.fn.stupidsort=function(b){var a=c(this),g=0,f=c.fn.stupidtable.dir,e=a.closest(table),k=a.data(sort)||null;if(null!==k){a.parents(tr).find(th).slice(0,c(this).index()).each(function(){var a=c(this).attr(colspan)||1;g+=parseInt(a,10)});var d;1==arguments.length?d=b:(d=b||a.data(sort-default)||f.ASC,a.data(sort-dir)&&(d=a.data(sort-dir)===f.ASC?f.DESC:f.ASC));if(a.data(sort-dir)!==d)return a.data(sort-dir,d),e.trigger(beforetablesort,{column:g,direction:d}),e.css(display),setTimeout(function(){var b=[],l=e.data(sortFns)[k],h=e.children(tbody).children(tr);h.each(function(a,d){var e=c(d).children().eq(g),f=e.data(sort-value);undefined===typeof f&&(f=e.text(),e.data(sort-value,f));b.push([f,d])});b.sort(function(a,b){return l(a[0],b[0])});d!=f.ASC&&b.reverse();h=c.map(b,function(a){return a[1]});e.children(tbody).append(h);e.find(th).data(sort-dir,null).removeClass(sorting-desc sorting-asc);a.data(sort-dir,d).addClass(sorting-+d);e.trigger(aftertablesort,{column:g,direction:d});e.css(display)},10),a}};c.fn.updateSortVal=function(b){var a=c(this);a.is([data-sort-value])&&a.attr(data-sort-value,b);a.data(sort-value,b);return a};c.fn.stupidtable.dir={ASC:asc,DESC:desc};c.fn.stupidtable.default_sort_fns={:function(b,a){return parseInt(b,10)-parseInt(a,10)},:function(b,a){return parseFloat(b)-parseFloat(a)},string:function(b,a){return b.toString().localeCompare(a.toString())},:function(b,a){b=b.toString().toLocaleLowerCase();a=a.toString().toLocaleLowerCase();return b.localeCompare(a)}}})(jQuery);"
module.exports = require(./lib/AbsoluteGrid.jsx);
"import path from path;import webpack from webpack;import autoprefixer from autoprefixer;import packageObj from ./package.json;
 Get the external packages used by the projectconst externals = {};[ dependencies, peerDependencies ].forEach(depGroup => {    if (packageObj[depGroup]) {        Object.keys(packageObj[depGroup]).forEach(dep => {            externals[dep] = dep;        });    }});
module.exports = {    entry: {        react-sortable-tree: ./src/index,    },    output: {        path: path.join(__dirname, dist, umd),        filename: [name].js,        libraryTarget: umd,        library: ReactSortableTree,    },    resolve: {        extensions: [, .js]    },    devtool: source-map,    plugins: [        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.optimize.OccurenceOrderPlugin(),        new webpack.optimize.UglifyJsPlugin({            compress: {                warnings: false            },            mangle: false,            beautify: true,            comments: true,        }),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    externals,    module: {        loaders: [            {                test: jsx,                loaders: [babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },        ]    }};"
"module.exports = function( grunt ) {	use strict;
	require(load-grunt-tasks)(grunt);
	var banner = /* https://github.com/micmro/performance-bookmarklet by Michael Mrowetz @MicMro   build:<%= grunt.template.today(dd/mm/yyyy) %> */;
	grunt.initConfig({		copy : {			distBookmarklet: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:chromeExtensionfirefoxAddon)js);					},					ext: .js				}]			},			distFirefoxAddon: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:bookmarkletchromeExtension)js);					},					ext: .js				}]			},			distChromeExtension: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:bookmarkletfirefoxAddon)js);					},					ext: .js				}]			}		},		babel: {			options: {				returnUsedHelpers: true			},			dist: {				files: [{					expand: true,					cwd: dist/tempCollect,					src: [**/*.js],					dest: dist/tempEs5,					ext: .js				}]			}		},		browserify: {			options: {				banner: banner			},			distBookmarklet: {				files: {					dist/performanceBookmarklet.js: [dist/tempEs5/**/*.js],				}			},			distFirefoxAddon: {				files: {					dist/performanceBookmarklet.ff.js: [dist/tempEs5/**/*.js],				}			},			distChromeExtension: {				files: {					dist/performanceBookmarklet.chrome.js: [dist/tempEs5/**/*.js],				}			}		},		uglify : {			options: {				compress: {					global_defs: {						DEBUG: false					},					dead_code: true				},				banner: banner			},			distBookmarklet: {				files: {					dist/performanceBookmarklet.min.js: [dist/performanceBookmarklet.js]				}			},			distFirefoxAddon: {				files: {					dist/performanceBookmarklet.ff.min.js: [dist/performanceBookmarklet.ff.js]				}			},			distChromeExtension: {				files: {					dist/performanceBookmarklet.chrome.min.js: [dist/performanceBookmarklet.chrome.js]				}			}		},		watch: {			babelBookmarklet: {				files: [src/**/*, Gruntfile.js],				tasks: [distBookmarklet],				options: {					spawn: false,					interrupt: true				},			},			babelFirefoxAddon: {				files: [src/**/*, Gruntfile.js],				tasks: [distFirefoxAddon],				options: {					spawn: false,					interrupt: true				},			},			babelChromeExtension: {				files: [src/**/*, Gruntfile.js],				tasks: [distChromeExtension],				options: {					spawn: false,					interrupt: true				},			},		}	});

	transform CSS file to JS variable	grunt.registerTask(inlineCssToJs, function() {		var cssFile = src/style.css;		var cssFileDestination = dist/tempCollect/helpers/style.js;		var varName = style;
		var cssContent = grunt.file.read(cssFile);
		clean CSS content		cssContent = cssContent.replace( (?:(?!))g, ).replace(g,  ).replace(g,  ).replace(g,);
		make JS Var and export as module		cssContent = export const  + varName +  =  + cssContent.trim() + ;;
		grunt.log.writeln(cssFile +  transformed to  + cssFileDestination);
		grunt.file.write(cssFileDestination, cssContent);	});
	grunt.registerTask(distBookmarklet, [inlineCssToJs, copy:distBookmarklet, babel, browserify:distBookmarklet, uglify:distBookmarklet]);	grunt.registerTask(distFirefoxAddon, [inlineCssToJs, copy:distFirefoxAddon, babel, browserify:distFirefoxAddon, uglify:distFirefoxAddon]);	grunt.registerTask(distChromeExtension, [inlineCssToJs, copy:distChromeExtension, babel, browserify:distChromeExtension, uglify:distChromeExtension]);	grunt.registerTask(distAll, [distBookmarklet, distFirefoxAddon, distChromeExtension]);
	grunt.registerTask(watchDistBookmarklet, [distBookmarklet, watch:babelBookmarklet]);	grunt.registerTask(watchDistFirefoxAddon, [distFirefoxAddon, watch:babelFirefoxAddon]);	grunt.registerTask(watchDistChromeExtension, [distChromeExtension, watch:babelChromeExtension]);


	grunt.registerTask(default, [watchDistBookmarklet]);};"
"use strict/* ---------- *//* setup */var gulp = require(gulp)var rename = require(gulp-rename)var uglify = require(gulp-uglify)var sourcemaps = require(gulp-sourcemaps)var umd = require(gulp-umd)var strip = require(gulp-strip-code)
/* ---------- *//* convert to umd */gulp.task(umd, function () {  return gulp.src(src/html.sortable.js)    .pipe(strip({       jscs:disable      start_comment: start-testing,      end_comment: end-testing       jscs:enable    }))    .pipe(umd({      exports: function () {        return sortable      },      namespace: function () {        return sortable      }    }))    .pipe(gulp.dest(dist/))})/* ---------- *//* build */gulp.task(minify, [umd], function () {   copy files to dist  gulp.src([dist/html.sortable.js])    .pipe(sourcemaps.init({loadMaps: true}))    .pipe(uglify())    .pipe(rename({      suffix: .min    }))    .pipe(sourcemaps.write(./))    .pipe(gulp.dest(./dist))    .pipe(gulp.dest(./docs))})/* ---------- *//* tasks */gulp.task(default, [umd, minify])"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: eval,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        preLoaders: [            {                test: jsx,                loader: eslint-loader,                include: path.join(__dirname, src)            },        ],        loaders: [            {                test: jsx,                loaders: [react-hot, babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },            { test: json, loader: json },  For the cheerio dependency of enzyme        ],    },    externals: {  All of these are for enzyme        react/addons: true,        react/lib/ExecutionEnvironment: true,        react/lib/ReactContext: true,    },    devServer: {        contentBase: build,        port: 3001    },};"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: source-map,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.NoErrorsPlugin(),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        loaders: [            {                test: jsx,                loaders: [react-hot, babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },        ],    },    devServer: {        contentBase: build,        port: 3001,        stats: {            chunks: false,            hash: false,            version: false,            assets: false,            children: false,        },    },};"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: source-map,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html,        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.optimize.UglifyJsPlugin({            compress: {                warnings: false            },        }),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        loaders: [            {                test: jsx,                loaders: [babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },        ],    }};"
require(babel-core/register);module.exports = require(./karma.conf.babel).default;
"import KarmaJasmine from karma-jasmine;import KarmaWebpack from karma-webpack;import KarmaJasmineDiffReporter from karma-jasmine-diff-reporter;import KarmaJasmineHtmlReporter from karma-jasmine-html-reporter;import KarmaNotifyReporter from karma-notify-reporter;import KarmaSourcemapLoader from karma-sourcemap-loader;import KarmaPhantomjsLauncher from karma-phantomjs-launcher;import webpackConfig from ./webpack.config.test.babel;
export default function setConfig(config) {    config.set({        browsers: [PhantomJS],        frameworks: [jasmine],        files: [src/tests.js],        preprocessors: {            src/tests.js: [webpack, sourcemap]        },        plugins: [            KarmaJasmine,            KarmaWebpack,            KarmaJasmineDiffReporter,            KarmaJasmineHtmlReporter,            KarmaNotifyReporter,            KarmaSourcemapLoader,            KarmaPhantomjsLauncher,        ],        reporters: [            jasmine-diff,            progress,            kjhtml,            notify,        ],        jasmineDiffReporter: {            pretty: 4,            json: true,            multiline: {                before: 2,  2 newlines                after:  2,  2 newlines                indent: 4,  4 spaces            },            color: {                actualFg: red,                expectedFg: green,                actualBg: inverse,                expectedBg: inverse,                actualWhitespaceBg: ,                expectedWhitespaceBg: ,            },        },        webpack: webpackConfig,        webpackMiddleware: {            stats: {                chunks: false,                hash: false,                version: false,                assets: false,                children: false,            },        },        notifyReporter: {            reportEachFailure: false,  Default: false, Will notify on every failed spec            reportSuccess: false,  Default: true, Will notify when a suite was successful        },    });}"
"use strict;
import React from react;import ReactDOM from react-dom; import Perf from 'react-addons-perf';import createAbsoluteGrid from ./index.js;import SampleDisplay from ./demo/SampleDisplay.jsx;import * as data from ./demo/sampleData.js;import * as _ from lodash;
demo();
/** * This demo is meant to show you all of the things that are possible with ReactAbsoluteGrid * If implemented in a Flux project, the grid would be in a render method with the * event handlers calling Actions which would update a Store. For the sake of brevity, * the ""store"" is implemented locally and the changes re-rendered manually * * TODO: implement inside a react component rather than doing this all manually **/
function demo() {
  let sampleItems = data.screens;  let render;  let zoom = 0.7;
  We set a property on each item to let the grid know not to show it  var onFilter = function(event){    var search = new RegExp(event.target.value, i);    sampleItems = sampleItems.map(function(item){      const isMatched = !item.name.match(search);      if(!item.filtered || isMatched !== item.filtered) {        return {          ...item,          filtered: isMatched        }      }      return item;    });    render();  };
  Change the item's sort order  var onMove = function(source, target){    source = _.find(sampleItems, {key: parseInt(source, 10)});    target = _.find(sampleItems, {key: parseInt(target, 10)});
    const targetSort = target.sort;
    CAREFUL, For maximum performance we must maintain the array's order, but change sort    sampleItems = sampleItems.map(function(item){      Decrement sorts between positions when target is greater      if(item.key === source.key) {        return {          ...item,          sort: targetSort        }      } else if(target.sort > source.sort && (item.sort <= target.sort && item.sort > source.sort)){        return {          ...item,          sort: item.sort - 1        };      Increment sorts between positions when source is greater      } else if (item.sort >= target.sort && item.sort < source.sort){        return {          ...item,          sort: item.sort + 1        };      }      return item;    });    Perf.start();    render();    Perf.stop();    Perf.printWasted();  };
  var onMoveDebounced = _.debounce(onMove, 40);
  var unMountTest = function(){    if(ReactDOM.unmountComponentAtNode(document.getElementById(Demo))){      ReactDOM.render(<button onClick={unMountTest}>Remount</button>, document.getElementById(UnmountButton));    }else{      render();      ReactDOM.render(<button onClick={unMountTest}>Test Unmount</button>, document.getElementById(UnmountButton));    }  };
  const AbsoluteGrid = createAbsoluteGrid(SampleDisplay);  render = function(){    ReactDOM.render(<AbsoluteGrid items={sampleItems}                               onMove={onMoveDebounced}                               dragEnabled={true}                               zoom={zoom}                               responsive={true}                               verticalMargin={42}                               itemWidth={230}                               itemHeight={409}/>, document.getElementById(Demo));  };
  var renderDebounced = _.debounce(render, 150);
  Update the zoom value  var onZoom = function(event){    zoom = parseFloat(event.target.value);    renderDebounced();  };
  ReactDOM.render(<input onChange={onZoom} type=range min=0.3 max=1.5 step=0.1 defaultValue={zoom}/>, document.getElementById(Zoom));  ReactDOM.render(<input placeholder=Filter eg: calendar onChange={onFilter} type=text/>, document.getElementById(Filter));  ReactDOM.render(<button onClick={unMountTest}>Test Unmount</button>, document.getElementById(UnmountButton));  render();}"
" Stupid jQuery table plugin.
(function($) {  $.fn.stupidtable = function(sortFns) {    return this.each(function() {      var $table = $(this);      sortFns = sortFns || {};      sortFns = $.extend({}, $.fn.stupidtable.default_sort_fns, sortFns);      $table.data(sortFns, sortFns);
      $table.on(click.stupidtable, thead th, function() {          $(this).stupidsort();      });    });  };

   Expects $(""#mytable"").stupidtable() to have already been called.   Call on a table header.  $.fn.stupidsort = function(force_direction){    var $this_th = $(this);    var th_index = 0;  we'll increment this soon    var dir = $.fn.stupidtable.dir;    var $table = $this_th.closest(table);    var datatype = $this_th.data(sort) || null;
     No datatype? Nothing to do.    if (datatype === null) {      return;    }
     Account for colspans    $this_th.parents(tr).find(th).slice(0, $(this).index()).each(function() {      var cols = $(this).attr(colspan) || 1;      th_index += parseInt(cols,10);    });
    var sort_dir;    if(arguments.length == 1){        sort_dir = force_direction;    }    else{        sort_dir = force_direction || $this_th.data(sort-default) || dir.ASC;        if ($this_th.data(sort-dir))           sort_dir = $this_th.data(sort-dir) === dir.ASC ? dir.DESC : dir.ASC;    }
     Bail if already sorted in this direction    if ($this_th.data(sort-dir) === sort_dir) {      return;    }     Go ahead and set sort-dir.  If immediately subsequent calls have same sort-dir they will bail    $this_th.data(sort-dir, sort_dir);
    $table.trigger(beforetablesort, {column: th_index, direction: sort_dir});
     More reliable method of forcing a redraw    $table.css(display);
     Run sorting asynchronously on a timout to force browser redraw after     `beforetablesort` callback. Also avoids locking up the browser too much.    setTimeout(function() {       Gather the elements for this column      var column = [];      var sortFns = $table.data(sortFns);      var sortMethod = sortFns[datatype];      var trs = $table.children(tbody).children(tr);
       Extract the data for the column that needs to be sorted and pair it up       with the TR itself into a tuple. This way sorting the values will       incidentally sort the trs.      trs.each(function(index,tr) {        var $e = $(tr).children().eq(th_index);        var sort_val = $e.data(sort-value);
         Store and read from the .data cache for display text only sorts         instead of looking through the DOM every time        if(typeof(sort_val) === undefined){          var txt = $e.text();          $e.data(sort-value, txt);          sort_val = txt;        }        column.push([sort_val, tr]);      });
       Sort by the data-order-by value      column.sort(function(a, b) { return sortMethod(a[0], b[0]); });      if (sort_dir != dir.ASC)        column.reverse();
       Replace the content of tbody with the sorted rows. Strangely       enough, .append accomplishes this for us.      trs = $.map(column, function(kv) { return kv[1]; });      $table.children(tbody).append(trs);
       Reset siblings      $table.find(th).data(sort-dir, null).removeClass(sorting-desc sorting-asc);      $this_th.data(sort-dir, sort_dir).addClass(sorting-+sort_dir);
      $table.trigger(aftertablesort, {column: th_index, direction: sort_dir});      $table.css(display);    }, 10);
    return $this_th;  };
   Call on a sortable td to update its value in the sort. This should be the   only mechanism used to update a cell's sort value. If your display value is   different from your sort value, use jQuery's .text() or .html() to update   the td contents, Assumes stupidtable has already been called for the table.  $.fn.updateSortVal = function(new_sort_val){  var $this_td = $(this);    if($this_td.is([data-sort-value])){       For visual consistency with the .data cache      $this_td.attr(data-sort-value, new_sort_val);    }    $this_td.data(sort-value, new_sort_val);    return $this_td;  };
   ------------------------------------------------------------------   Default settings   ------------------------------------------------------------------  $.fn.stupidtable.dir = {ASC: asc, DESC: desc};  $.fn.stupidtable.default_sort_fns = {    : function(a, b) {      return parseInt(a, 10) - parseInt(b, 10);    },    : function(a, b) {      return parseFloat(a) - parseFloat(b);    },    : function(a, b) {      return a.toString().localeCompare(b.toString());    },    : function(a, b) {      a = a.toString().toLocaleLowerCase();      b = b.toString().toLocaleLowerCase();      return a.localeCompare(b);    }  };})(jQuery);"
"var ulid = require(./)
suite(ulid, function() {
  set(iterations, 100000);
  bench(encodeTime, function() {    ulid.encodeTime()  })
  bench(encodeRandom, function() {    ulid.encodeRandom()  })
  bench(generate, function() {    ulid()  })
})"
"use strict;
function factory(prng) {
   Crockford's Base32   https://en.wikipedia.org/wiki/Base32  var ENCODING = 0123456789ABCDEFGHJKMNPQRSTVWXYZ  var ENCODING_LEN = ENCODING.length  var TIME_MAX = 281474976710655  var TIME_LEN = 10  var RANDOM_LEN = 16
  function encodeTime(time, len) {    if (time > TIME_MAX) {      throw new Error(cannot encode time greater than  + TIME_MAX)    }    var mod    var time    var str =     for (var x = len; x > 0; x--) {      mod = time % ENCODING_LEN      str = ENCODING.charAt(mod) + str      time = (time - mod) / ENCODING_LEN    }    return str  }
  function encodeRandom(len) {    var rand    var str =     for (var x = 0; x < len; x++) {      rand = Math.floor(ENCODING_LEN * prng())      str = ENCODING.charAt(rand) + str    }    return str  }
  function ulid(seedTime) {    if(!seedTime) {      seedTime = Date.now();    } else if(isNaN(seedTime) || typeof seedTime !== number) {      throw new Error(seedTime +  must be a number);    }        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN)  }
  ulid.prng = prng  ulid.encodeTime = encodeTime  ulid.encodeRandom = encodeRandom
  return ulid
}
/* istanbul ignore next */function _prng(root) {
  if (root) {    try {      var crypto = root.crypto || root.msCrypto      return function() {        return crypto.getRandomValues(new Uint16Array(1))[0] / 0xFFFF      }    }    catch (e) {}  }  else {    try {      var crypto = require(crypto)      return function() {        return crypto.randomBytes(2).readUInt16LE() / 0xFFFF      }    }    catch (e) {}  }
  if (typeof prng !== function) {    if (typeof console !== undefined && console.warn) {      console.warn([ulid] crypto not usable, falling back to insecure Math.random());    }    return function() {      return Math.random()    }  }
}
/* istanbul ignore next */(function(root, fn) {
  var prng = _prng(root)  var ulid = fn(prng)
  if ((undefined !== typeof module) && module.exports) {    module.exports = ulid  }  else if (typeof define === function && define.amd) {    define(function() {      return ulid    })  }  else {    root.ulid = ulid  }
})(typeof window !== undefined ? window : null, factory)"
"module.exports = function(grunt) {
     Project configuration.    grunt.initConfig({        pkg: grunt.file.readJSON(package.json),        concat: {            options: {                separator: ,                stripBanners: true,                banner: // <%= pkg.name %> <%= pkg.version %> | (c) <%= grunt.template.today(""yyyy"") %> Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license            },            dist: {                src: src/*.js,                dest: build/<%= pkg.name %>.js            }        },        uglify: {            options: {                stripBanners: true,                banner: // <%= pkg.name %> <%= pkg.version %> | (c) <%= grunt.template.today(""yyyy"") %> Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license            },            build: {                src: build/<%= pkg.name %>.js,                dest: build/<%= pkg.name %>.min.js            }        },        jshint: {            files: src/*.js,            options: {                ""-W030"": false,                force: true            }        },        watch: {            scripts: {                files: [src/*.*],                tasks: [default],                options: {                    nospawn: true                }            }        },        jasmine : {            src : src/*.js,            options : {                specs : spec/*.js,                vendor: ext/*.js,                template : require(grunt-template-jasmine-istanbul),                templateOptions: {                    coverage: reports/coverage.json,                    report: reports/coverage                }            }        }    });
    grunt.loadNpmTasks(grunt-contrib-concat);    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-watch);    grunt.loadNpmTasks(grunt-contrib-jshint);    grunt.loadNpmTasks(grunt-contrib-jasmine);
     Default task(s).    grunt.registerTask(default, [jshint, concat, uglify, jasmine]);
};"
"/** * Created by lijun on 2016/12/14. */var config = require(./webpack.config.js)
config.entry = {  table-dragger: ./src/index.js,}
config.output = {  filename: ./dist/[name].js,  library: tableDragger,  libraryTarget: umd}
module.exports = config"
"module.exports = {  root: true,  parser: babel-eslint,  parserOptions: {    sourceType: module  },  extends: airbnb-base,  env: {    browser: true,    node: true  },  plugins: [    html  ],   add your custom rules here  rules: {    no-use-before-define: [error, { functions: false, classes: false }],    import/extensions: [error, always, {      js: never,      vue: never    }],    no-nested-ternary: 0,    space-before-function-paren: 0,    no-underscore-dangle: [error, { allowAfterThis: true }],     allow debugger during development    no-debugger: process.env.NODE_ENV === production ? 2 : 0  }}"
"/*! * Muuri v0.2.0 * https://github.com/haltu/muuri * Copyright (c) 2015, Haltu Oy * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the ""Software""), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */
(function (global, factory) {
  var libName = Muuri;  var depVelocity = typeof jQuery === function ? jQuery.Velocity : global.Velocity;  var depHammer = global.Hammer;
  global[libName] = factory(global, depVelocity, depHammer);
}(this, function (global, Velocity, Hammer, undefined) {
  use strict;
   Document body needs to be ready for tests.  if (!document.body) {    throw Error(Muuri needs access to document.body to work.);  }
  var uuid = 0;  var noop = function () {};  var raf = typeof global.requestAnimationFrame === function ? global.requestAnimationFrame : null;
   Event names.  var evRefresh = refresh;  var evSynchronize = synchronize;  var evLayoutStart = layoutstart;  var evLayoutEnd = layoutend;  var evShowStart = showstart;  var evShowEnd = showend;  var evHideStart = hidestart;  var evHideEnd = hideend;  var evMove = move;  var evSwap = swap;  var evAdd = add;  var evRemove = remove;  var evDragStart = dragstart;  var evDragMove = dragmove;  var evDragScroll = dragscroll;  var evDragEnd = dragend;  var evReleaseStart = releasestart;  var evReleaseEnd = releaseend;  var evDestroy = destroy;
   Get the primary supported transform property.  var supportedTransform = (function () {    var all = [transform, WebkitTransform, MozTransform, OTransform, msTransform];    for (var i = 0; i < all.length; i++) {      if (document.documentElement.style[all[i]] !== undefined) {        var prop = all[i];        var prefix = prop.toLowerCase().split(transform)[0];        return {          prefix: prefix,          prop: prop,          style: prefix ? - + prefix + -transform : prop        };      }    }    return null;  })();
   Detect if current browser positions fixed elements relative to the nearest   ancestor transformed element instead of the window.   https://bugs.chromium.org/p/chromium/issues/detail?id=20574     Borrowed from Mezr library:   https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L95-L113   https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L247-L300  var hasBrokenW3CTELCS = (function () {
     If the browser does not support transforms we can deduct that the     W3C TELCS is broken (non-existent).    if (!supportedTransform) {      return true;    }
    var body = document.body;    var outer = document.createElement(div);    var inner = document.createElement(div);    var leftUntransformed;    var leftTransformed;
    setStyles(outer, {      display: block,      visibility: hidden,      position: absolute,      width: 1px,      height: 1px,      left: 1px,      top: 0,      margin: 0    });
    setStyles(inner, {      display: block,      position: fixed,      width: 1px,      height: 1px,      left: 0,      top: 0,      margin: 0    });
    outer.appendChild(inner);    body.appendChild(outer);    leftUntransformed = inner.getBoundingClientRect().left;    outer.style[supportedTransform.prop] = translateZ(0);    leftTransformed = inner.getBoundingClientRect().left;    body.removeChild(outer);
    return leftTransformed === leftUntransformed;
  })();
  /**   * Emitter   * *******   */
  /**   * Event emitter constructor.   *   * This is a simplified version of jvent.js event emitter library:   * https://github.com/pazguille/jvent/blob/0.2.0/dist/jvent.js   *   *    */  function Emitter() {}
  /**   * Bind an event listener.   *   *    *     *      *      *   returns the Emitter instance.   */  Emitter.prototype.on = function (event, listener) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    listeners[listeners.length] = listener;    events[event] = listeners;
    return this;
  };
  /**   * Unbind all event listeners that match the provided listener function.   *   *    *     *      *      *   returns the Emitter instance.   */  Emitter.prototype.off = function (event, listener) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    var counter = listeners.length;
    if (counter) {      while (counter--) {        if (listener === listeners[i]) {          listeners.splice(counter, 1);        }      }    }
    return this;
  };
  /**   * Emit all listeners in a specified event with the provided arguments.   *   *    *     *      *      *      *      *   returns the Emitter instance.   */  Emitter.prototype.emit = function (event, arg1, arg2, arg3) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    var listenersLength = listeners.length;
    if (listenersLength) {
      var argsLength = arguments.length - 1;      listeners = listeners.concat();
      for (var i = 0; i < listenersLength; i++) {        argsLength === 0 ? listeners[i]() :        argsLength === 1 ? listeners[i](arg1) :        argsLength === 2 ? listeners[i](arg1, arg2) :                           listeners[i](arg1, arg2, arg3);      }
    }
    return this;
  };
  /**   * LayoutFirstFit v0.2.0   * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>   * Released under the MIT license   *   * The default Muuri layout method.   *   *    *      */  function LayoutFirstFit(settings) {
    var layout = this;
     Empty slots data.    var emptySlots = [];
     Normalize settings.    var fillGaps = settings.fillGaps ? true : false;    var isHorizontal = settings.horizontal ? true : false;    var alignRight = settings.alignRight ? true : false;    var alignBottom = settings.alignBottom ? true : false;
     Round container width and height.    layout.width = Math.round(layout.width);    layout.height = Math.round(layout.height);
     Set horizontal/vertical mode.    if (isHorizontal) {      layout.setWidth = true;      layout.width = 0;    }    else {      layout.setHeight = true;      layout.height = 0;    }
     No need to go further if items do not exist.    if (!layout.items.length) {      return;    }
     Find slots for items.    for (var i = 0; i < layout.items.length; i++) {
      var item = layout.items[i];      var slot = LayoutFirstFit.getSlot(layout, emptySlots, item._width, item._height, !isHorizontal, fillGaps);
       Update layout height.      if (isHorizontal) {        layout.width = Math.max(layout.width, slot.left + slot.width);      }      else {        layout.height = Math.max(layout.height, slot.top + slot.height);      }
       Add slot to slots data.      layout.slots[item._id] = slot;
    }
     If the alignment is set to right or bottom, we need to adjust the     results.    if (alignRight || alignBottom) {      for (var id in layout.slots) {        var slot = layout.slots[id];        if (alignRight) {          slot.left = layout.width - (slot.left + slot.width);        }        if (alignBottom) {          slot.top = layout.height - (slot.top + slot.height);        }      }    }
  }
  /**   * Calculate position for the layout item. Returns the left and top position   * of the item in pixels.   *   *    *     *      *      *      *      *      *      *     */  LayoutFirstFit.getSlot = function (layout, slots, itemWidth, itemHeight, vertical, fillGaps) {
    var currentSlots = slots[0] || [];    var newSlots = [];    var item = {      left: null,      top: null,      width: itemWidth,      height: itemHeight    };    var i;    var ii;    var slot;    var potentialSlots;    var ignoreCurrentSlots;
     Try to find a slot for the item.    for (i = 0; i < currentSlots.length; i++) {      slot = currentSlots[i];      if (item.width <= slot.width && item.height <= slot.height) {        item.left = slot.left;        item.top = slot.top;        break;      }    }
     If no slot was found for the item.    if (item.left === null) {
       Position the item in to the bottom left (vertical mode) or top right       (horizontal mode) of the grid.      item.left = vertical ? 0 : layout.width;      item.top = vertical ? layout.height : 0;
       If gaps don't needs filling do not add any current slots to the new       slots array.      if (!fillGaps) {        ignoreCurrentSlots = true;      }
    }
     In vertical mode, if the item's bottom overlaps the grid's bottom.    if (vertical && (item.top + item.height) > layout.height) {
       If item is not aligned to the left edge, create a new slot.      if (item.left > 0) {        newSlots[newSlots.length] = {          left: 0,          top: layout.height,          width: item.left,          height: Infinity        };      }
       If item is not aligned to the right edge, create a new slot.      if ((item.left + item.width) < layout.width) {        newSlots[newSlots.length] = {          left: item.left + item.width,          top: layout.height,          width: layout.width - item.left - item.width,          height: Infinity        };      }
       Update grid height.      layout.height = item.top + item.height;
    }
     In horizontal mode, if the item's right overlaps the grid's right edge.    if (!vertical && (item.left + item.width) > layout.width) {
       If item is not aligned to the top, create a new slot.      if (item.top > 0) {        newSlots[newSlots.length] = {          left: layout.width,          top: 0,          width: Infinity,          height: item.top        };      }
       If item is not aligned to the bottom, create a new slot.      if ((item.top + item.height) < layout.height) {        newSlots[newSlots.length] = {          left: layout.width,          top: item.top + item.height,          width: Infinity,          height: layout.height - item.top - item.height        };      }
       Update grid width.      layout.width = item.left + item.width;
    }
     Clean up the current slots making sure there are no old slots that     overlap with the item. If an old slot overlaps with the item, split it     into smaller slots if necessary.    for (i = fillGaps ? 0 : ignoreCurrentSlots ? currentSlots.length : i; i < currentSlots.length; i++) {      potentialSlots = LayoutFirstFit.splitRect(currentSlots[i], item);      for (ii = 0; ii < potentialSlots.length; ii++) {        slot = potentialSlots[ii];        if (slot.width > 0 && slot.height > 0 && ((vertical && slot.top < layout.height) || (!vertical && slot.left < layout.width))) {          newSlots[newSlots.length] = slot;        }      }    }
     Remove redundant slots and sort the new slots.    LayoutFirstFit.purgeSlots(newSlots).sort(vertical ? LayoutFirstFit.sortRectsTopLeft : LayoutFirstFit.sortRectsLeftTop);
     Update the slots data.    slots[0] = newSlots;
     Return the item.    return item;
  };
  /**   * Sort rectangles with top-left gravity. Assumes that objects with   * properties left, top, width and height are being sorted.   *   *    *     *      *      *     */  LayoutFirstFit.sortRectsTopLeft = function (a, b) {
    return a.top < b.top ? -1 : (a.top > b.top ? 1 : (a.left < b.left ? -1 : (a.left > b.left ? 1 : 0)));
  };
  /**   * Sort rectangles with left-top gravity. Assumes that objects with   * properties left, top, width and height are being sorted.   *   *    *     *      *      *     */  LayoutFirstFit.sortRectsLeftTop = function (a, b) {
    return a.left < b.left ? -1 : (a.left > b.left ? 1 : (a.top < b.top ? -1 : (a.top > b.top ? 1 : 0)));
  };
  /**   * Check if a rectabgle is fully within another rectangle. Assumes that the   * rectangle object has the following properties: left, top, width and height.   *   *    *     *      *      *     */  LayoutFirstFit.isRectWithinRect = function (a, b) {
    return a.left >= b.left && a.top >= b.top && (a.left + a.width) <= (b.left + b.width) && (a.top + a.height) <= (b.top + b.height);
  };
  /**   * Loops through an array of slots and removes all slots that are fully within   * another slot in the array.   *   *    *     *      */  LayoutFirstFit.purgeSlots = function (slots) {
    var i = slots.length;    while (i--) {      var slotA = slots[i];      var ii = slots.length;      while (ii--) {        var slotB = slots[ii];        if (i !== ii && LayoutFirstFit.isRectWithinRect(slotA, slotB)) {          slots.splice(i, 1);          break;        }      }    }
    return slots;
  };
  /**   * Compares a rectangle to another and splits it to smaller pieces (the parts   * that exceed the other rectangles edges). At maximum generates four smaller   * rectangles.   *   *    *     *      *      * returns {Array}   */  LayoutFirstFit.splitRect = function (a, b) {
    var ret = [];    var overlap = !(b.left > (a.left + a.width) || (b.left + b.width) < a.left || b.top > (a.top + a.height) || (b.top + b.height) < a.top);
     If rect a does not overlap with rect b add rect a to the return data as     is.    if (!overlap) {
      ret[0] = a;
    }     If rect a overlaps with rect b split rect a into smaller rectangles and     add them to the return data.    else {
       Left split.      if (a.left < b.left) {        ret[ret.length] = {          left: a.left,          top: a.top,          width: b.left - a.left,          height: a.height        };      }
       Right split.      if ((a.left + a.width) > (b.left + b.width)) {        ret[ret.length] = {          left: b.left + b.width,          top: a.top,          width: (a.left + a.width) - (b.left + b.width),          height: a.height        };      }
       Top split.      if (a.top < b.top) {        ret[ret.length] = {          left: a.left,          top: a.top,          width: a.width,          height: b.top - a.top        };      }
       Bottom split.      if ((a.top + a.height) > (b.top + b.height)) {        ret[ret.length] = {          left: a.left,          top: b.top + b.height,          width: a.width,          height: (a.top + a.height) - (b.top + b.height)        };      }
    }
    return ret;
  };
  /**   * Muuri   * *****   */
  /**   * Creates a new Muuri instance.   *   *    *    *      *   *    *    *      *      *    */  function Muuri(settings) {
    var inst = this;
     Merge user settings with default settings.    var stn = inst._settings = mergeObjects({}, Muuri.defaultSettings, settings || {});
     Make sure a valid container element is provided before going continuing.    if (!document.body.contains(stn.container)) {      throw new Error(Container must be an existing DOM element);    }
     Setup container element.    inst._element = stn.container;    addClass(stn.container, stn.containerClass);
     Instance id.    inst._id = ++uuid;
     Unique animation queue name.    inst._animQueue = muuri- + inst._id;
     Create private eventize instance.    inst._emitter = new Emitter();
     Setup show and hide animations for items.    inst._itemShow = typeof stn.show === function ? stn.show() : showHideAnimation(stn.show, true);    inst._itemHide = typeof stn.hide === function ? stn.hide() : showHideAnimation(stn.hide);
     Setup initial items.    inst._items = [];    for (var i = 0, len = stn.items.length; i < len; i++) {      inst._items[inst._items.length] = new Muuri.Item(inst, stn.items[i]);    }
     Relayout on window resize if enabled.    if (stn.layoutOnResize || stn.layoutOnResize === 0) {      var debounced = debounce(function () {        inst.refresh();        inst.layout();      }, stn.layoutOnResize);      inst._resizeHandler = function () {        debounced();      };      global.addEventListener(resize, inst._resizeHandler);    }
     Layout on init if enabled.    if (stn.layoutOnInit) {      inst.layout(true);    }
  }
  /**   * Get instance's item by element or by index. Target can also be a   * Muuri item instance in which case the function returns the item if it   * exists within related Muuri instance. If nothing is found with the   * provided target null is returned.   *   *    *     *      *     */  Muuri.prototype._getItem = function (target) {
    if (!target) {
      return this._items[0] || null;
    }    else if (target instanceof Muuri.Item) {
      return target._muuri === this ? target : null;
    }    else if (typeof target === number) {
      target = target > -1 ? target : this._items.length + target;      return this._items[target] || null;
    }    else {
      var ret = null;      for (var i = 0, len = this._items.length; i < len; i++) {        var item = this._items[i];        if (item._element === target) {          ret = item;          break;        }      }      return ret;
    }
  };
  /**   * Bind an event listener.   *   *    *     *      *      *   returns the Muuri instance.   */  Muuri.prototype.on = function (event, listener) {
    this._emitter.on(event, listener);    return this;
  };
  /**   * Unbind an event listener.   *   *    *     *      *      *   returns the Muuri instance.   */  Muuri.prototype.off = function (event, listener) {
    this._emitter.off(event, listener);    return this;
  };
  /**   * Recalculate the width and height of the provided targets. If no targets are   * provided all active items will be refreshed.   *   *    *     *      */  Muuri.prototype.refresh = function (items) {
     Get items.    items = items ? this.get(items) : this.get(active);
     Refresh dimensions.    for (var i = 0, len = items.length; i < len; i++) {      items[i]._refresh();    }
     Emit refresh event.    this._emitter.emit(evRefresh, items);
  };
  /**   * Get all items. Optionally you can provide specific targets (indices or   * elements) and filter the results by the items' state (active/inactive).   * Note that the returned array is not the same object used by the instance so   * modifying it will not affect instance's items. All items that are not found   * are omitted from the returned array.   *   *    *     *      *      *   Array of Muuri item instances.   */  Muuri.prototype.get = function (targets, state) {
    var hasTargets = targets && typeof targets !== string;
    state = !hasTargets ? targets : state;    state = typeof state === string ? state : null;    targets = hasTargets ? [].concat(targets) : null;
    if (state || targets) {
      var items = targets || this._items;      var ret = [];      var isActive = state === active;      var isInactive = state === inactive;
      for (var i = 0, len = items.length; i < len; i++) {        var item = hasTargets ? this._getItem(items[i]) : items[i];        if (item && (!state || (isActive && item._active) || (isInactive && !item._active))) {          ret[ret.length] = item;        }      }
      return ret;
    }    else {
      return this._items.concat();
    }
  };
  /**   * Add new items by providing the elements you wish to add to the instance and   * optionally provide the index where you want the items to be inserted into.   * All elements that are not already children of the container element will be   * automatically appended to the container. If an element has it's CSS display   * property set to none it will be marked as inactive during the initiation   * process. As long as the item is inactive it will not be part of the layout,   * but it will retain it's index. You can activate items at any point   * with muuri.show() method. This method will automatically call   * muuri.layout() if one or more of the added elements are visible. If only   * hidden items are added no layout will be called. All the new visible items   * are positioned without animation during their first layout.   *   *    *     *      *      *     */  Muuri.prototype.add = function (elements, index) {
    var newItems = [];    var needsRelayout = false;
     Make sure elements is an array.    elements = [].concat(elements);
     Filter out all elements that exist already in current instance.    for (var i = 0, len = this._items.length; i < len; i++) {      var item = this._items[i];      var index = elements.indexOf(item._element);      if (index > -1) {        elements.splice(index, 1);      }    }
     Return early if there are no valid items.    if (!elements.length) {      return newItems;    }
     Create new items.    for (var i = 0, len = elements.length; i < len; i++) {      var item = new Muuri.Item(this, elements[i]);      newItems[newItems.length] = item;      if (item._active) {        needsRelayout = true;        item._noLayoutAnimation = true;      }    }
     Normalize the index for the splice apply hackery so that value of -1     prepends the new items to the current items.    index = index < 0 ? this._items.length - index + 1 : index;
     Add the new items to the items collection to correct index.    this._items.splice.apply(this._items, [index, 0].concat(newItems));
     If relayout is needed.    if (needsRelayout) {      this.layout();    }
     Emit add event.    this._emitter.emit(evAdd, newItems);
     Return new items    return newItems;
  };
  /**   * Remove items from muuri instances.   *   *    *     *      *      *   The indices of removed items.   */  Muuri.prototype.remove = function (items, removeElement) {
    var indices = [];    var needsRelayout = false;
    items = this.get(items);
    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
       Check it refresh is needed.      if (item._active) {        needsRelayout = true;      }
       Remove item.      indices[indices.length] = item._destroy(removeElement);
    }
     If relayout is needed.    if (needsRelayout) {      this.layout();    }
    this._emitter.emit(evRemove, indices);
    return indices;
  };
  /**   * Order the item elements to match the order of the items. If the item's   * element is not a child of the container it is ignored and left untouched.   * This comes handy if you need to keep the DOM structure matched with the   * order of the items.   *   *    *     */  Muuri.prototype.synchronize = function () {
    for (var i = 0, len = this._items.length; i < len; i++) {      var item = this._items[i];      if (item._element.parentNode === this._element) {        this._element.appendChild(item._element);      }    }
    this._emitter.emit(evSynchronize);
  };
  /**   * Calculate and apply Muuri instance's item positions.   *   *    *     *      *      */  Muuri.prototype.layout = function (instant, callback) {
    var inst = this;    var emitter = inst._emitter;    var callback = typeof instant === function ? instant : callback;    var isInstant = instant === true;    var layout = new Muuri.Layout(inst);    var counter = -1;    var itemsLength = layout.items.length;    var completed = [];    var tryFinish = function (interrupted, item) {
       Push all items to the completed items array which were not interrupted.      if (!interrupted) {        completed[completed.length] = item;      }
       If container and all items have finished their animations (if any).      if (++counter === itemsLength) {
         Call callback.        if (typeof callback === function) {          callback(completed, layout);        }
         Emit layoutend event.        emitter.emit(evLayoutEnd, completed, layout);
      }
    };
     Emit layoutstart event.    emitter.emit(evLayoutStart, layout.items, layout);
     Set container's height if needed.    if (layout.setHeight) {      setStyles(inst._element, {        height: layout.height + px      });    }
     Set container's width if needed.    if (layout.setWidth) {      setStyles(inst._element, {        width: layout.width + px      });    }
     If there are now items let's finish quickly.    if (!itemsLength) {
      tryFinish(true);
    }     If there are items let's position them.    else {
      for (var i = 0, len = layout.items.length; i < len; i++) {
        var item = layout.items[i];        var pos = layout.slots[item._id];
         Update item's position.        item._left = pos.left;        item._top = pos.top;
         Layout non-dragged items.        item._drag.active ? tryFinish(false, item) : item._layout(isInstant, tryFinish);
      }
    }
  };
  /**   * Show instance items.   *   *    *     *      *      *      */  Muuri.prototype.show = function (items, instant, callback) {
    showHideHandler(this, show, items, instant, callback);
  };
  /**   * Hide instance items.   *   *    *     *      *      *      */  Muuri.prototype.hide = function (items, instant, callback) {
    showHideHandler(this, hide, items, instant, callback);
  };
  /**   * Get item's index.   *   *    *     *      *     */  Muuri.prototype.indexOf = function (item) {
    if (typeof item === number) {
      return item <= (this._items.length - 1) ? item : null;
    }    else if (item instanceof Muuri.Item) {
      var index = this._items.indexOf(item);      return index > -1 ? index : null;
    }    else {
      var index = null;      for (var i = 0, len = this._items.length; i < len; i++) {        if (this._items[i]._element === item) {          index = i;          break;        }      }      return index;
    }
  };
  /**   * Move item to another index or in place of another item.   *   *    *     *      *      */  Muuri.prototype.move = function (targetFrom, targetTo) {
    targetFrom = this._getItem(targetFrom);    targetTo = this._getItem(targetTo);
    if (targetFrom && targetTo && (targetFrom !== targetTo)) {      arrayMove(this._items, this._items.indexOf(targetFrom), this._items.indexOf(targetTo));      this._emitter.emit(evMove, targetFrom, targetTo);    }
  };
  /**   * Swap positions of two items.   *   *    *     *      *      */  Muuri.prototype.swap = function (targetA, targetB) {
    targetA = this._getItem(targetA);    targetB = this._getItem(targetB);
    if (targetA && targetB && (targetA !== targetB)) {      arraySwap(this._items, this._items.indexOf(targetA), this._items.indexOf(targetB));      this._emitter.emit(evSwap, targetA, targetB);    }
  };
  /**   * Destroy the instance.   *   *    *     */  Muuri.prototype.destroy = function () {
     Unbind window resize event listener.    if (this._resizeHandler) {      global.removeEventListener(resize, this._resizeHandler);    }
     Destroy items.    var items = this._items.concat();    for (var i = 0, len = items.length; i < len; i++) {      items[i]._destroy();    }
     Restore container.    removeClass(this._element, this._settings.containerClass);    setStyles(this._element, {      height:     });
     Emit destroy event.    this._emitter.emit(evDestroy);
     Remove all event listeners.    var events = this._emitter._events;    if (events) {      var eventNames = Object.keys(this._emitter._events);      for (var i = 0, len = eventNames.length; i < len; i++) {        events[eventNames[i]].length = 0;      }    }
     Render the instance unusable -> nullify all Muuri related properties.    var props = Object.keys(this).concat(Object.keys(Muuri.prototype));    for (var i = 0; i < props.length; i++) {      this[props[i]] = null;    }
  };
  /**   * Muuri - Item   * ************   */
  /**   * Creates a new Muuri Item instance.   *   *    *    *     *      *      */  Muuri.Item = function (muuri, element) {
     Make sure the item element is not a parent of the grid container element.    if (element.contains(muuri._element)) {      throw new Error(Item element must not be a parent of the grid container element);    }
     If the provided item element is not a direct child of the grid container     element, append it to the grid container.    if (element.parentNode !== muuri._element) {      muuri._element.appendChild(element);    }
    var stn = muuri._settings;    var isHidden = getStyle(element, display) === none;
     Instance id.    this._id = ++uuid;    this._muuri = muuri;    this._element = element;    this._child = element.children[0];
     Set item class.    addClass(element, stn.itemClass);
     Set up active state (defines if the item is considered part of the layout     or not).    this._active = isHidden ? false : true;
     Set up positioning state (defines if the item is currently animating     it's position).    this._positioning = false;
     Set up visibility states.    this._hidden = isHidden;    this._hiding = false;    this._showing = false;
     Visibility animation callback queue. Whenever a callback is provided for     show/hide methods and animation is enabled the callback is stored     temporarily to this array. The callbacks are called with the first     argument as false if the animation succeeded without interruptions and     with the first argument as true if the animation was interrupted.    this._visibiliyQueue = [];
     Layout animation callback queue. Whenever a callback is provided for     layout method and animation is enabled the callback is stored temporarily     to this array. The callbacks are called with the first argument as false     if the animation succeeded without interruptions and with the first     argument as true if the animation was interrupted.    this._layoutQueue = [];
     Set element's initial position.    hookStyles(this._element, {      left: 0,      top: 0,      translateX: 0px,      translateY: 0px    });
     Set hidden/shown class.    addClass(element, isHidden ? stn.hiddenClass : stn.shownClass);
     Set hidden/shown styles for the child element.    hookStyles(this._child, {      scale: isHidden ? 0 : 1,      opacity: isHidden ? 0 : 1    });
     Enforce display ""block"" if element is visible.    if (!isHidden) {      setStyles(this._element, {        display: block      });    }
     Set up initial dimensions and positions.    this._refresh();    this._left = 0;    this._top = 0;
     Set up drag & drop.    this._drag = {active: false};    this._release = {active: false};    if (muuri._settings.dragEnabled) {      this._initDrag();    }
  };
  /**   * Inspect instance's data.   *   *    *     */  Muuri.Item.prototype.inspect = function () {
    return {      element: this._element,      width: this._width,      height: this._height,      left: this._left,      top: this._top,      active: this._active,      positioning: this._positioning,      dragging: this._drag.active,      releasing: this._release.active,      visibility: this._hiding  ? hiding : this._showing ? showing : this._hidden  ? hidden : shown    };
  };
  /**   * Make the item draggable with Hammer.js.   *   *    *     */  Muuri.Item.prototype._initDrag = function () {
    var inst = this;    var stn = inst._muuri._settings;
     Initiate Hammer.    var hammer = inst._hammer = new Hammer.Manager(inst._element);
     Add drag recognizer to hammer.    hammer.add(new Hammer.Pan({      event: drag,      pointers: 1,      threshold: 0,      direction: Hammer.DIRECTION_ALL    }));
     Add draginit recognizer to hammer.    hammer.add(new Hammer.Press({      event: draginit,      pointers: 1,      threshold: 100,      time: 0    }));
     This is not ideal, but saves us from a LOT of hacks. Let's try to keep     the default drag setup consistent across devices.    hammer.set({ touchAction: none });
     Setup initial release data.    inst._resetReleaseData();
     Setup initial drag data.    var drag = inst._drag;    inst._resetDragData();
     Add overlap checker function to drag data.    drag.checkOverlap = debounce(function () {      if (drag.active) {        inst._checkOverlap();      }    }, stn.dragSortInterval);
     Add predicate related data to drag data.    var predicateResolved = false;    drag.predicate = typeof stn.dragPredicate === function ? stn.dragPredicate : dragPredicate;    drag.predicateData = {};    drag.isPredicateResolved = function () {      return predicateResolved;    };    drag.resolvePredicate = function (e) {      if (!predicateResolved && e.type !== draginitup && e.type !== dragend && e.type !== dragcancel) {        predicateResolved = true;        inst._onDragStart(e);      }    };
     Add drag sroll handler.    drag.onScroll = function (e) {      if (raf) {        raf(function () {          inst._onDragScroll(e);        });      }      else {        inst._onDragScroll(e);      }    };
     Bind drag events.    hammer    .on(draginit, function (e) {      drag.predicateData = {};      predicateResolved = false;      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    })    .on(dragstart dragmove, function (e) {      if (predicateResolved && drag.active) {        inst._onDragMove(e);      }      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    })    .on(dragend dragcancel draginitup, function (e) {      if (predicateResolved && drag.active) {        inst._onDragEnd(e);      }      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    });
  };
  /**   * Reset drag data.   *   *    *     */  Muuri.Item.prototype._resetDragData = function () {
    var drag = this._drag;
     Is the drag active or not?    drag.active = false;
     Hammer dragstart/dragend event data.    drag.start = null;    drag.move = null;
     The element that is currently dragged (instance element or it's clone).    drag.element = null;
     The curently dragged element's width and height.    drag.elemWidth = 0;    drag.elemHeight = 0;
     Dragged element's inline styles stored for graceful teardown.    drag.elementStyles = null;
     Scroll parents of the dragged element and muuri container.    drag.scrollParents = [];
     The current translateX/translateY position.    drag.left = 0;    drag.top = 0;
     Dragged element's current position within the grid.    drag.gridX = 0;    drag.gridY = 0;
     Dragged element's current offset from window's northwest corner. Does not     account for element's margins.    drag.elemClientX = 0;    drag.elemClientY = 0;
     Offset difference between the dragged element's temporary drag container     and it's original container.    drag.containerDiffX = 0;    drag.containerDiffY = 0;
  };
  /**   * Drag start handler.   *   *    *     */  Muuri.Item.prototype._onDragStart = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;    var isReleased = this._release.active;
     If item is not active, don't start the drag.    if (!this._active) {      return;    }
     Stop current positioning animation.    if (this._positioning) {      this._stopLayout();    }
     If item is being released reset release data, remove release class and     import the current elementStyles to drag object.    if (isReleased) {      drag.elementStyles = this._release.elementStyles;      removeClass(this._element, stn.releasingClass);      this._resetReleaseData();    }
     Setup drag data.    drag.active = true;    drag.start = e;    drag.move = e;    drag.element = this._element;    drag.elemWidth = this._width;    drag.elemHeight = this._height;
     Get element's current position.    var currentLeft = parseFloat(Velocity.hook(drag.element, translateX)) || 0;    var currentTop = parseFloat(Velocity.hook(drag.element, translateY)) || 0;
     Get container references.    var muuriContainer = this._muuri._element;    var dragContainer = stn.dragContainer;
     Set initial left/top drag value.    drag.left = drag.gridX = currentLeft;    drag.top = drag.gridY = currentTop;
     If a specific drag container is set and it is different from the     default muuri container we need to cast some extra spells.    if (dragContainer && dragContainer !== muuriContainer) {
       If dragged element is already in drag container.      if (drag.element.parentNode === dragContainer) {
         Get offset diff.        var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
         Store the container offset diffs to drag data.        drag.containerDiffX = offsetDiff.left;        drag.containerDiffY = offsetDiff.top;
         Set up relative drag position data.        drag.gridX = currentLeft - drag.containerDiffX;        drag.gridY = currentTop - drag.containerDiffY;
      }
       If dragged element is not within the correct container.      else {
         Lock element's width, height, padding and margin before appending         to the temporary container because otherwise the element might         enlarge or shrink after the append procedure if the some of the         properties are defined in relative sizes.        lockElementSize(drag);
         Append element into correct container.        dragContainer.appendChild(drag.element);
         Get offset diff.        var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
         Store the container offset diffs to drag data.        drag.containerDiffX = offsetDiff.left;        drag.containerDiffY = offsetDiff.top;
         Set up drag position data.        drag.left = currentLeft + drag.containerDiffX;        drag.top = currentTop + drag.containerDiffY;
         Fix position to account for the append procedure.        hookStyles(drag.element, {          translateX: drag.left + px,          translateY: drag.top + px        });
      }
    }
     Get and store element's current offset from window's northwest corner.    var elemGbcr = drag.element.getBoundingClientRect();    drag.elemClientX = elemGbcr.left;    drag.elemClientY = elemGbcr.top;
     Get drag scroll parents.    drag.scrollParents = getScrollParents(drag.element);    if (dragContainer && dragContainer !== muuriContainer) {      drag.scrollParents = arrayUnique(drag.scrollParents.concat(getScrollParents(muuriContainer)));    }
     Bind scroll listeners.    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].addEventListener(scroll, drag.onScroll);    }
     Set drag class.    addClass(drag.element, stn.draggingClass);
     Emit dragstart event.    this._muuri._emitter.emit(evDragStart, this, generateDragEvent(dragstart, e, drag));
  };
  /**   * Drag move handler.   *   *    *     */  Muuri.Item.prototype._onDragMove = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     If item is not active, reset drag.    if (!this._active) {      this._resetDrag();      return;    }
     Get delta difference from last dragmove event.    var xDiff = e.deltaX - drag.move.deltaX;    var yDiff = e.deltaY - drag.move.deltaY;
     Update move event.    drag.move = e;
     Update position data.    drag.left += xDiff;    drag.top += yDiff;    drag.gridX += xDiff;    drag.gridY += yDiff;    drag.elemClientX += xDiff;    drag.elemClientY += yDiff;
     Update element's translateX/Y values.    hookStyles(drag.element, {      translateX: drag.left + px,      translateY: drag.top + px    });
     Overlap handling.    if (stn.dragSort) {      drag.checkOverlap();    }
     Emit item-dragmove event.    this._muuri._emitter.emit(evDragMove, this, generateDragEvent(dragmove, e, drag));
  };
  /**   * Drag scroll handler.   *   *    *     */  Muuri.Item.prototype._onDragScroll = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     Get containers.    var muuriContainer = this._muuri._element;    var dragContainer = stn.dragContainer;
     Get offset diff.    var elemGbcr = drag.element.getBoundingClientRect();    var xDiff = drag.elemClientX - elemGbcr.left;    var yDiff = drag.elemClientY - elemGbcr.top;
     Update container diff.    if (dragContainer && dragContainer !== muuriContainer) {
       Get offset diff.      var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
       Store the container offset diffs to drag data.      drag.containerDiffX = offsetDiff.left;      drag.containerDiffY = offsetDiff.top;
    }
     Update position data.    drag.left += xDiff;    drag.top += yDiff;    drag.gridX = drag.left - drag.containerDiffX;    drag.gridY = drag.top - drag.containerDiffY;
     Update element's translateX/Y values.    hookStyles(drag.element, {      translateX: drag.left + px,      translateY: drag.top + px    });
     Overlap handling.    if (stn.dragSort) {      drag.checkOverlap();    }
     Emit item-dragscroll event.    this._muuri._emitter.emit(evDragScroll, this, generateDragEvent(dragscroll, e, drag));
  };
  /**   * Drag end handler.   *   *    *     */  Muuri.Item.prototype._onDragEnd = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;    var release = this._release;
     If item is not active, reset drag.    if (!this._active) {      this._resetDrag();      return;    }
     Finish currently queued overlap check.    if (stn.dragSort) {      drag.checkOverlap(finish);    }
     Remove scroll listeners    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].removeEventListener(scroll, drag.onScroll);    }
     Remove drag classname from element.    removeClass(drag.element, stn.draggingClass);
     Flag drag as inactive.    drag.active = false;
     Emit item-dragend event.    this._muuri._emitter.emit(evDragEnd, this, generateDragEvent(dragend, e, drag));
     Setup release data.    release.containerDiffX = drag.containerDiffX;    release.containerDiffY = drag.containerDiffY;    release.element = drag.element;    release.elementStyles = drag.elementStyles;
     Reset drag data.    this._resetDragData();
     Start the release process.    this._startRelease();
  };
  /**   * Reset drag data and cancel any ongoing drag activity.   *   *    *     */  Muuri.Item.prototype._resetDrag = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     Remove scroll listeners    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].removeEventListener(scroll, drag.onScroll);    }
     Cancel overlap check.    drag.checkOverlap(cancel);
     Remove draggin class.    removeClass(drag.element, stn.draggingClass);
     Remove dragged element's inline styles.    unlockElementSize(drag);
    this._resetDragData();
  };
  /**   * Reset release data.   *   *    *     */  Muuri.Item.prototype._resetReleaseData = function () {
    var release = this._release;    release.active = false;    release.positioningStarted = false;    release.containerDiffX = 0;    release.containerDiffY = 0;    release.element = null;    release.elementStyles = null;
  };
  /**   * Start the release process of an item.   *   *    *     */  Muuri.Item.prototype._startRelease = function () {
    var stn = this._muuri._settings;    var release = this._release;
     Flag release as active.    release.active = true;
     Add release classname to released element.    addClass(release.element, stn.releasingClass);
     Emit releasestart event.    this._muuri._emitter.emit(evReleaseStart, this);
     Position the released item.    this._layout(false);
  };
  /**   * End the release process of an item.   *   *    *     */  Muuri.Item.prototype._endRelease = function () {
    var stn = this._muuri._settings;    var release = this._release;
     Remove release classname from the released element.    removeClass(release.element, stn.releasingClass);
     If the released element is outside the muuri container put it back there     and adjust position accordingly.    if (release.element.parentNode !== this._muuri._element) {      this._muuri._element.appendChild(release.element);      hookStyles(release.element, {        translateX: this._left + px,        translateY: this._top + px      });    }
     Unlock temporary inlined styles.    unlockElementSize(release);
     Reset release data.    this._resetReleaseData();
     Emit releaseend event.    this._muuri._emitter.emit(evReleaseEnd, this);
  };
  /**   * Check (during drag) if an item is overlapping other items and based on   * the configuration do a relayout.   *   *    *     */  Muuri.Item.prototype._checkOverlap = function () {
    var stn = this._muuri._settings;    var overlapTolerance = stn.dragSortTolerance;    var overlapAction = stn.dragSortAction;    var items = this._muuri._items;    var bestMatch = null;    var instIndex = 0;    var instData = {      width: this._drag.elemWidth,      height: this._drag.elemHeight,      left: this._drag.gridX,      top: this._drag.gridY    };
     Find best match (the element with most overlap).    for (var i = 0, len = items.length; i < len; i++) {      var item = items[i];      if (item === this) {        instIndex = i;      }      else if (item._active) {        var overlapScore = getOverlapScore(instData, {          width: item._width,          height: item._height,          left: item._left,          top: item._top        });        if (!bestMatch || overlapScore > bestMatch.score) {          bestMatch = {            item: item,            score: overlapScore,            index: i          };        }      }    }
     Check if the best match overlaps enough to justify a placement switch.    if (bestMatch && bestMatch.score >= overlapTolerance) {      if (overlapAction === swap) {        arraySwap(items, instIndex, bestMatch.index);        this._muuri._emitter.emit(evSwap, this, bestMatch.item);      }      else {        arrayMove(items, instIndex, bestMatch.index);        this._muuri._emitter.emit(evMove, this, bestMatch.item);      }      this._muuri.layout();    }
  };
  /**   * Stop item's position animation if it is currently animating.   *   *    *     */  Muuri.Item.prototype._stopLayout = function () {
    var stn = this._muuri._settings;
    if (this._positioning) {
       Stop animation.      Velocity(this._element, stop, this._muuri._animQueue);
       Remove visibility classes.      removeClass(this._element, stn.positioningClass);
       Reset state.      this._positioning = false;
       Process callback queue.      processQueue(this._layoutQueue, true, this);
    }
  };
  /**   * Recalculate item's dimensions.   *   *    *     */  Muuri.Item.prototype._refresh = function () {
    if (!this._hidden) {      this._width = Math.round(getDimension(this._element, width, true));      this._height = Math.round(getDimension(this._element, height, true));    }
  };
  /**   * Position item based on it's current data.   *   *    *     *      *      */  Muuri.Item.prototype._layout = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;    var release = inst._release;    var isJustReleased = release.active && release.positioningStarted === false;    var animDuration = isJustReleased ? stn.dragReleaseDuration : stn.positionDuration;    var animEasing = isJustReleased ? stn.dragReleaseEasing : stn.positionEasing;    var animEnabled = instant === true || inst._noLayoutAnimation ? false : animDuration > 0;    var isPositioning = inst._positioning;    var finish = function () {
       Remove positioning classes.      removeClass(inst._element, stn.positioningClass);
       Mark the item as not positioning.      inst._positioning = false;
       Finish up release.      if (release.active) {        inst._endRelease();      }
       Process the callback queue.      processQueue(inst._layoutQueue, false, inst);
    };
     Stop currently running animation, if any.    inst._stopLayout();
     Push the callback to the callback queue.    if (typeof callback === function) {      inst._layoutQueue[inst._layoutQueue.length] = callback;    }
     Mark release positiong as started.    if (isJustReleased) {      release.positioningStarted = true;    }
     Get item container offset. This applies only for release handling in the     scenario where the released element is not currently within the muuri     container.    var offsetLeft = inst._release.active ? inst._release.containerDiffX : 0;    var offsetTop = inst._release.active ? inst._release.containerDiffY : 0;
     If no animations are needed, easy peasy!    if (!animEnabled) {
      if (inst._noLayoutAnimation) {        inst._noLayoutAnimation = false;      }
      hookStyles(inst._element, {        translateX: (inst._left + offsetLeft) + px,        translateY: (inst._top + offsetTop) + px      });
      finish();
    }
     If animations are needed, let's dive in.    else {
       Get current (relative) left and top position. Meaning that the       drga container's offset (if applicable) is subtracted from the current       translate values.      var currentLeft = (parseFloat(Velocity.hook(inst._element, translateX)) || 0) - offsetLeft;      var currentTop =  (parseFloat(Velocity.hook(inst._element, translateY)) || 0) - offsetTop;
       If the item is already in correct position there's no need to animate       it.      if (inst._left === currentLeft && inst._top === currentTop) {        finish();        return;      }
       Mark as positioning.      inst._positioning = true;
       Add positioning class if necessary.      if (!isPositioning) {        addClass(inst._element, stn.positioningClass);      }
       Set up the animation.      Velocity(inst._element, {        translateX: inst._left + offsetLeft,        translateY: inst._top + offsetTop      }, {        duration: animDuration,        easing: animEasing,        complete: finish,        queue: inst._muuri._animQueue      });
       Start the animation.      Velocity.Utilities.dequeue(inst._element, inst._muuri._animQueue);
    }
  };
  /**   * Show item.   *   *    *     *      *      */  Muuri.Item.prototype._show = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;
     If item is visible.    if (!inst._hidden && !inst._showing) {
       Call the callback and be done with it.      if (typeof callback === function) {        callback(false, inst);      }
    }
     If item is animating to visible.    else if (!inst._hidden) {
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
    }
     If item is hidden or animating to hidden.    else {
      var isHiding = inst._hiding;
       Stop animation.      inst._muuri._itemHide.stop(inst);
       Update states.      inst._active = true;      inst._hidden = false;      inst._showing = inst._hiding = false;
       Update classes.      addClass(inst._element, stn.shownClass);      removeClass(inst._element, stn.hiddenClass);
       Set element's display style.      setStyles(inst._element, {        display: block      });
       Process current callback queue.      processQueue(inst._visibiliyQueue, true, inst);
       Update state.      inst._showing = true;
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
       Animate child element.      inst._muuri._itemShow.start(inst, instant, function () {
         Process callback queue.        processQueue(inst._visibiliyQueue, false, inst);
      });
    }
  };
  /**   * Hide item.   *   *    *     *      *      */  Muuri.Item.prototype._hide = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;
     If item is hidden.    if (inst._hidden && !inst._hiding) {
       Call the callback and be done with it.      if (typeof callback === function) {        callback(false, inst);      }
    }
     If item is animating to hidden.    else if (inst._hidden) {
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
    }
     If item is visible or animating to visible.    else {
      var isShowing = inst._showing;
       Stop animation.      inst._muuri._itemShow.stop(inst);
       Update states.      inst._active = false;      inst._hidden = true;      inst._showing = inst._hiding = false;
       Update classes.      addClass(inst._element, stn.hiddenClass);      removeClass(inst._element, stn.shownClass);
       Process current callback queue.      processQueue(inst._visibiliyQueue, true, inst);
       Update state.      inst._hiding = true;
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
       Animate child element.      inst._muuri._itemHide.start(inst, instant, function () {
         Hide element.        setStyles(inst._element, {          display: none        });
         Process callback queue.        processQueue(inst._visibiliyQueue, false, inst);
      });
    }
  };
  /**   * Destroy item instance.   *   *    *     *      */  Muuri.Item.prototype._destroy = function (removeElement) {
    var muuri = this._muuri;    var stn = this._muuri._settings;    var element = this._element;    var index = this._muuri._items.indexOf(this);
     Stop animations.    this._stopLayout();    this._muuri._itemShow.stop(this);    this._muuri._itemHide.stop(this);
     If item is being released, stop it gracefully.    if (this._release.active) {      if (element.parentNode !== this._muuri._element) {        this._muuri._element.appendChild(element);      }      this._resetReleaseData();    }
     If item is being dragged, stop it gracefully.    if (this._drag.active) {      if (element.parentNode !== this._muuri._element) {        this._muuri._element.appendChild(element);      }      this._resetDrag();    }
     Destroy Hammer instance and custom touch listeners.    if (this._hammer) {      this._hammer.destroy();    }
     Remove all inline styles.    element.removeAttribute(style);    this._child.removeAttribute(style);
     Handle visibility callback queue, fire all uncompleted callbacks with     interrupted flag.    processQueue(this._visibiliyQueue, true, this);
     Remove Muuri specific classes.    removeClass(element, stn.positioningClass);    removeClass(element, stn.draggingClass);    removeClass(element, stn.releasingClass);    removeClass(element, stn.itemClass);    removeClass(element, stn.shownClass);    removeClass(element, stn.hiddenClass);
     Remove item from Muuri instance if it still exists there.    if (index > -1) {      this._muuri._items.splice(index, 1);    }
     Remove element from DOM.    if (removeElement) {      element.parentNode.removeChild(element);    }
     Render the instance unusable -> nullify all Muuri related properties.    var props = Object.keys(this).concat(Object.keys(Muuri.Item.prototype));    for (var i = 0; i < props.length; i++) {      this[props[i]] = null;    }
  };
  /**   * Creates a new Muuri Layout instance.   *   *    *    *     *      *      */  Muuri.Layout = function (muuri, items) {
    var stn = muuri._settings.layout;
    this.muuri = muuri;    this.items = items ? items.concat() : muuri.get(active);    this.slots = {};    this.width = 0;    this.height = 0;    this.setWidth = false;    this.setHeight = false;
     Calculate the current width and height of the container.    this.width = getDimension(muuri._element, width);    this.height = getDimension(muuri._element, height);
     If the user has provided custom function as a layout method invoke it.    if (typeof stn === function) {
      stn.call(this);
    }     Otherwise parse the layout mode and settings from provided options and     do the calculations.    else {
       Parse the layout method name and settings from muuri settings.      var useDefaults = typeof stn === string;      var methodName = useDefaults ? stn : stn[0];
       Make sure the provided layout method exists.      if (typeof Muuri.Layout.methods[methodName] !== function) {        throw new Error(Layout method "" + method +  "" does not exist.);      }
       Invoke the layout method.      typeof Muuri.Layout.methods[methodName].call(this, useDefaults ? {} : stn[1]);
    }
  };
  /**   * Available layout methods.   *   *    *     */  Muuri.Layout.methods = {    firstFit: LayoutFirstFit  };
  /**   * Muuri - Settings   * ****************   */
  /**   * Default settings.   *   *    *     *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      */  Muuri.defaultSettings = {
     Container    container: null,
     Items    items: [],    positionDuration: 300,    positionEasing: ease-out,    show: {      duration: 300,      easing: ease-out    },    hide: {      duration: 300,      easing: ease-out    },
     Layout    layout: firstFit,    layoutOnResize: 100,    layoutOnInit: true,
     Drag & Drop    dragEnabled: false,    dragContainer: null,    dragPredicate: null,    dragSort: true,    dragSortInterval: 50,    dragSortTolerance: 50,    dragSortAction: move,    dragReleaseDuration: 300,    dragReleaseEasing: ease-out,
     Classnames    containerClass: muuri,    itemClass: muuri-item,    shownClass: muuri-shown,    hiddenClass: muuri-hidden,    positioningClass: muuri-positioning,    draggingClass: muuri-dragging,    releasingClass: muuri-releasing
  };
  /**   * Helpers - Generic   * *****************   */
  /**   * Swap array items.   *   *      *      *      */  function arraySwap(array, indexA, indexB) {
    var temp = array[indexA];    array[indexA] = array[indexB];    array[indexB] = temp;
  }
  /**   * Move array item to another index.   *   *      *      *      */  function arrayMove(array, fromIndex, toIndex) {
    array.splice(toIndex, 0, array.splice(fromIndex, 1)[0]);
  }
  /**   * Returns a new duplicate free version of the provided array.   *   *      *     */  function arrayUnique(array) {
    var ret = [];    for (var i = 0, len = array.length; i < len; i++) {      if (ret.indexOf(array[i]) === -1) {        ret[ret.length] = array[i];      }    }    return ret;
  }
  /**   * Check if a value is a plain object.   *   *      *     */  function isPlainObject(val) {
    return typeof val === object && Object.prototype.toString.call(val) === [object Object];
  }
  /**   * Merge properties of provided objects. The first argument is considered as   * the destination object which inherits the properties of the   * following argument objects. Merges object properties recursively if the   * property's type is object in destination object and the source object.   *   *      *      *   Returns the destination object.   */  function mergeObjects(dest) {
    var sources = Array.prototype.slice.call(arguments, 1);
    for (var i = 0; i < sources.length; i++) {      var source = sources[i];      for (var prop in source) {        if (source.hasOwnProperty(prop)) {          if (isPlainObject(dest[prop]) && isPlainObject(source[prop])) {            mergeObjects(dest[prop], source[prop]);          }          else {            dest[prop] = source[prop];          }        }      }    }
    return dest;
  }
  /**   * Returns a function, that, as long as it continues to be invoked, will not   * be triggered. The function will be called after it stops being called for   * N milliseconds. The returned function accepts one argument which, when   * being ""finish"", calls the debounced function immediately if it is currently   * waiting to be called, and when being ""cancel"" cancels the currently queued   * function call.   *   *      *      *     */  function debounce(fn, wait) {
    var timeout;    var actionCancel = cancel;    var actionFinish = finish;
    return function (action) {
      if (timeout !== undefined) {        timeout = global.clearTimeout(timeout);        if (action === actionFinish) {          fn();        }      }
      if (action !== actionCancel && action !== actionFinish) {        timeout = global.setTimeout(function () {          timeout = undefined;          fn();        }, wait);      }
    };
  }
  /**   * Get intersection area dimensions and position between two rectangles in 2d   * space.   *   *      *      *     */  function getIntersection(a, b) {
    var ret = null;    var overlap = {      left: a.left - b.left,      right: (b.left + b.width) - (a.left + a.width),      top: a.top - b.top,      bottom: (b.top + b.height) - (a.top + a.height)    };    var intersectionWidth = Math.max(a.width + Math.min(overlap.left, 0) + Math.min(overlap.right, 0), 0);    var intersectionHeight = Math.max(a.height + Math.min(overlap.top, 0) + Math.min(overlap.bottom, 0), 0);    var hasIntersection = intersectionWidth > 0 && intersectionHeight > 0;
    if (hasIntersection) {      ret = {};      ret.width = intersectionWidth;      ret.height = intersectionHeight;      ret.left = a.left + Math.abs(Math.min(overlap.left, 0));      ret.right = ret.left + ret.width;      ret.top = a.top + Math.abs(Math.min(overlap.top, 0));      ret.bottom = ret.top + ret.height;    }
    return ret;
  }
  /**   * Helpers - DOM utils   * *******************   */
  /**   * Returns the computed value of an element's style property as a string.   *   *      *      *     */  function getStyle(element, style) {
    return global.getComputedStyle(element, null).getPropertyValue(style);
  }
  /**   * Set inline styles to an element.   *   *      *      */  function setStyles(element, styles) {
    for (var prop in styles) {      element.style[prop] = styles[prop];    }
  }
  /**   * Set inline styles to an element with Velocity's hook method.   *   *      *      */  function hookStyles(element, styles) {
    for (var prop in styles) {      Velocity.hook(element, prop, styles[prop]);    }
  }
  /**   * Check if an element has a specific class name.   *   *      *      *     */  function hasClass(el, className) {
    return (  + el.className).indexOf(  + className) > -1;
  }
  /**   * Add class to an element.   *   *      *      */  function addClass(el, className) {
    if (el.classList) {      el.classList.add(className);    }    else if (hasClass(el, className)) {      el.className +=   + className;    }
  }
  /**   * Remove class name from an element.   *   *      */  function removeClass(el, className) {
    if (el.classList) {      el.classList.remove(className);    }    else if (hasClass(el, className)) {      el.className = (  + el.className +  ).replace(  + className +  ,  ).trim();    }
  }
  /**   * Get element's width/height with padding or with padding, border and margin.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L511-L609   *   *      *      *      */  function getDimension(el, dimension, withMargin) {
    var ret = el.getBoundingClientRect()[dimension];    var isHeight = dimension === height;    var dimensionCapitalized = isHeight ? Height : Width;    var innerDimension = inner + dimensionCapitalized;    var clientDimension = client + dimensionCapitalized;    var edgeA = isHeight ? top : left;    var edgeB = isHeight ? bottom : right;
    if (withMargin) {
      var marginA = parseFloat(getStyle(el, margin- + edgeA));      var marginB = parseFloat(getStyle(el, margin- + edgeB));      ret += marginA > 0 ? marginA : 0;      ret += marginB > 0 ? marginB : 0;
    }    else {
      var borderA;      var borderB;
      if (el === document.documentElement) {        ret -= global[innerDimension] - document.documentElement[clientDimension];      }      else {        borderA = parseFloat(getStyle(el, border- + edgeA + -width));        borderB = parseFloat(getStyle(el, border- + edgeB + -width));        ret -= Math.round(ret) - el[clientDimension] - borderA - borderB;      }
      ret -= borderA !== undefined ? borderA : parseFloat(getStyle(el, border- + edgeA + -width));      ret -= borderB !== undefined ? borderB : parseFloat(getStyle(el, border- + edgeB + -width));
    }
    return ret;
  }
  /**   * Returns the element's offset, which in practice means the vertical and   * horizontal distance between the element's northwest corner and the   * document's northwest corner. This method is a stripped down version of   * Mezr's offset method and tailored for Muuri specifically. By default the   * element's ""dimension edge"" is considered to be the element's padding layer.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L643-L714   *   *      *     */  function getOffset(el) {
    var offsetLeft = 0;    var offsetTop = 0;    var viewportScrollLeft = parseFloat(global.pageXOffset);    var viewportScrollTop = parseFloat(global.pageYOffset);
     For window we just need to get viewport's scroll distance.    if (el.self === global.self) {      offsetLeft = viewportScrollLeft;      offsetTop = viewportScrollTop;    }
     For all elements except the document and window we can use the combination of gbcr and     viewport's scroll distance.    else if (el !== document) {      var gbcr = el.getBoundingClientRect();      offsetLeft += gbcr.left + viewportScrollLeft + parseFloat(getStyle(el, border-left-width));      offsetTop += gbcr.top + viewportScrollTop + parseFloat(getStyle(el, border-top-width));    }
    return {      left: offsetLeft,      top: offsetTop    };
  }
  /**   * Returns the element's offset parent.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L808-L859   *   *      *     */  function getOffsetParent(el) {
    var isFixed = getStyle(el, position) === fixed;
    if (isFixed && hasBrokenW3CTELCS) {      return global;    }
    var offsetParent = el === document.documentElement || el === global ? document : el.parentElement || null;
    if (isFixed) {      while (offsetParent && offsetParent !== document && !isTransformed(offsetParent)) {        offsetParent = offsetParent.parentElement || document;      }      return offsetParent === document ? global : offsetParent;    }    else {      while (offsetParent && offsetParent !== document && getStyle(offsetParent, position) === static && !isTransformed(offsetParent)) {        offsetParent = offsetParent.parentElement || document;      }      return offsetParent;    }
  }
  /**   * Returns true if element is transformed, false if not. In practice the   * element's display value must be anything else than ""none"" or ""inline"" as   * well as have a valid transform value applied in order to be counted as a   * transformed element.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L302-L317   *   *      *     */  function isTransformed(el) {
    var transform = getStyle(el, supportedTransform.style);    var display = getStyle(el, display);
    return transform !== none && display !== inline && display !== none;
  }
  /**   * Calculate the offset difference of two elements. The target element is is   * always considered to be Muuri item's element which means that it's margins   * are considered to be part of it's width and height. The anchor element's   * width and height however always consist of the core and the padding only.   *   *      *      *     */  function getOffsetDiff(target, anchor) {
    var anchorOffset = getOffset(anchor);    var targetZeroPosition = getOffset(getOffsetParent(target) || doc);    targetZeroPosition.left -= Math.abs(Math.min(parseFloat(getStyle(target, margin-left)), 0));    targetZeroPosition.top -= Math.abs(Math.min(parseFloat(getStyle(target, margin-top)), 0));
    return {      left: anchorOffset.left - targetZeroPosition.left,      top: anchorOffset.top - targetZeroPosition.top    };
  }
  /**   * Get element's scroll parents.   *   * Borrowed from jQuery UI library (and heavily modified):   * https://github.com/jquery/jquery-ui/blob/63448148a217da7e64c04b21a04982f0d64aabaa/ui/scroll-parent.js   *   *      *     */  function getScrollParents(element) {
    var ret = [];    var overflowRegex = (autoscroll);    var parent = element.parentNode;
     If positioning of fixed elements is broken (according to W3C spec).    if (hasBrokenW3CTELCS) {
       If the element is fixed it can not have any scroll parents.      if (getStyle(element, position) === fixed) {        return ret;      }
       Find scroll parents.      while (parent && parent !== document && parent !== document.documentElement) {        if (overflowRegex.test(getStyle(parent, overflow) + getStyle(parent, overflow-y) + getStyle(parent, overflow-x))) {          ret[ret.length] = parent;        }        parent = getStyle(parent, position) === fixed ? null : parent.parentNode;      }
       If parent is not fixed element, add window object as the last scroll       parent.      if (parent !== null) {        ret[ret.length] = global;      }
    }     If fixed elements behave as defined in the W3C specification.    else {
       Find scroll parents.      while (parent && parent !== document) {
         If the currently looped element is fixed ignore all parents that are         not transformed.        if (getStyle(element, position) === fixed && !isTransformed(parent)) {          parent = parent.parentNode;          continue;        }
         Add the parent element to return items if it is scrollable.        if (overflowRegex.test(getStyle(parent, overflow) + getStyle(parent, overflow-y) + getStyle(parent, overflow-x))) {          ret[ret.length] = parent;        }
         Update element and parent references.        element = parent;        parent = parent.parentNode;
      }
       Replace reference of possible root element to window object.      if (ret.length && ret[ret.length - 1] === document.documentElement) {        ret[ret.length - 1] = global;      }
    }
    return ret;
  }
  /**   * Helpers - Muuri   * ***************   */
  /**   * Calculate how many percent the intersection area of two items is from the   * maximum potential intersection area between the items.   *   *      *      *   A number between 0-100.   */  function getOverlapScore(a, b) {
    var intersection = getIntersection(a, b);
    if (!intersection) {      return 0;    }
    var aUnpos = {      width: a.width,      height: a.height,      left: 0,      top: 0    };
    var bUnpos = {      width: b.width,      height: b.height,      left: 0,      top: 0    };
    var maxIntersection = getIntersection(aUnpos, bUnpos);
    return (intersection.width * intersection.height) / (maxIntersection.width * maxIntersection.height) * 100;
  }
  /**   * Return parsed drag event data.   *   *      *      *      *     */  function generateDragEvent(type, event, drag) {
    return {      type: type,      event: event,      currentLeft: drag.left,      currentTop: drag.top,      gridLeft: drag.gridX,      gridTop: drag.gridY    };
  }
  /**   * Default drag start predicate handler. The context of the function is   * always a temporary object which is gets reset on each draginit event.   *   *      *      *      */  function dragPredicate(e, item, resolve) {
    if (!this.isResolved) {      this.isResolved = true;      resolve(e);    }
  }
  /**   * Lock dragged element's dimensions.   *   *      */  function lockElementSize(data) {
     Don't override existing element styles.    if (!data.elementStyles) {
      var styles = [width, height, padding, margin];
       Reset element styles.      data.elementStyles = {};
       Store current inline style values.      for (var i = 0; i < 4; i++) {        var style = styles[i];        var value = data.element.style[style];        data.elementStyles[style] = value || ;      }
       Set effective values as inline styles.      for (var i = 0; i < 4; i++) {        var style = styles[i];        data.element.style[style] = getStyle(data.element, style);      }
    }
  }
  /**   * Unlock dragged element's dimensions.   *   *      */  function unlockElementSize(data) {
    if (data.elementStyles) {      for (var style in data.elementStyles) {        data.element.style[style] = data.elementStyles[style];      }    }
  }
  /**   * Show/hide Muuri instance's items.   *   *    *      *    - ""show"" or ""hide"".   *      *      *      */  function showHideHandler(inst, method, items, instant, callback) {
     Sanitize items.    items = inst.get(items);
     Sanitize callback.    callback = typeof instant === function ? instant : callback;
    var counter = items.length;
     If there are no items call the callback, but don't emit any events.    if (!counter) {
      if (typeof callback === function) {        callback(items);      }
    }     If we have some items let's dig in.    else {
      var isShow = method === show;      var startEvent = isShow ? evShowStart : evHideStart;      var endEvent = isShow ? evShowEnd : evHideEnd;      var isInstant = instant === true;      var completed = [];      var needsRelayout = false;      var hiddenItems = [];
       Emit showstart event.      inst._emitter.emit(startEvent, items);
       Show/hide items. The loop cycle must be wrapped in a function in order       to keep the correct reference of the item for the asynchronous callback       of the item's private show/hide method.      for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
         Check if relayout or refresh is needed.        if ((isShow && !item._active) || (!isShow && item._active)) {          needsRelayout = true;          if (isShow) {            item._noLayoutAnimation = true;            hiddenItems[hiddenItems.length] = item;          }        }
         Hide/show the item.        item[_ + method](isInstant, function (interrupted, item) {
           If the current item's animation was not interrupted add it to the           completed set.          if (!interrupted) {            completed[completed.length] = item;          }
           If all items have finished their animations call the callback           and emit the event.          if (--counter < 1) {            if (typeof callback === function) {              callback(completed);            }            inst._emitter.emit(endEvent, completed);          }
        });
      }
       Relayout only if needed.      if (needsRelayout) {        if (hiddenItems.length) {          inst.refresh(hiddenItems);        }        inst.layout();      }
    }
  }
  /**   * Default item show/hide animation flow. Returns and object that contains   * the animation start and stop method.   *   *      *      *     */  function showHideAnimation(opts, isShow) {
    var duration = (opts && opts.duration) || 0;    var easing = (opts && opts.easing) || ease-out;
    if (!duration) {      return {        start: noop,        stop: noop      };    }    else {      var targetStyles = isShow ? {opacity: 1, scale: 1} : {opacity: 0, scale: 0.5};      return {        start: function (item, instant, animDone) {          if (instant) {            hookStyles(item._child, targetStyles);          }          else {            Velocity(item._child, targetStyles, {              duration: duration,              easing: easing,              queue: item._muuri._animQueue,              complete: animDone            });            Velocity.Utilities.dequeue(item._child, item._muuri._animQueue);          }        },        stop: function (item) {          Velocity(item._child, stop, item._muuri._animQueue);        }      };    }
  }
  /**   * Process item's callback queue.   *   *    *      *      *      */  function processQueue(queue, interrupted, instance) {
    var snapshot = queue.splice(0, queue.length);    for (var i = 0, len = snapshot.length; i < len; i++) {      snapshot[i](interrupted, instance);    }
  }
  /**   * Init   */
  return Muuri;
}));"
"module.exports = function (config) {
  var package = require(./package.json);
     Define Sauce Labs browsers.  
  var browsers = [     IE    [Windows 7, internet explorer, 9.0],    [Windows 8, internet explorer, 10.0],    [Windows 8.1, internet explorer, 11.0],     Edge    [Windows 10, MicrosoftEdge, 13.10586],     Firefox    [Windows 10, firefox, 48.0],    [OS X 10.11, firefox, 48.0],     Chrome    [Windows 10, chrome, 53.0],    [OS X 10.11, chrome, 53.0],     Safari    [OS X 10.8, safari, 6.0],    [OS X 10.9, safari, 7.0],    [OS X 10.10, safari, 8.0],    [OS X 10.11, safari, 9.0]  ];
     Generate Sauce Labs launchers.  
  var launchers = {};  browsers.forEach(function (browser) {
    var launcher = {      base: SauceLabs,      platform: browser[0],      browserName: browser[1],      version: browser[2]    };    var key = launcher.platform +  -  + launcher.browserName + (launcher.version ?  -  + launcher.version : );
    if (launcher.browserName === iphone) {      launcher.deviceName = iPhone Simulator;      launcher.deviceOrientation = portrait;    }
    if (launcher.browserName === android) {      launcher.deviceName = Android Emulator;      launcher.deviceOrientation = portrait;    }
    launchers[key] = launcher;
  });
     Karma settings.  
  var stn = {};
  stn.basePath = ;
   https://npmjs.org/browse/keyword/karma-adapter  stn.frameworks = [    qunit  ];
   plugins to use  stn.plugins = [    karma-qunit,    karma-sauce-launcher,    karma-story-reporter  ];
   list of files / patterns to load in the browser  stn.files = [    package.main,    ./tests/tests.js  ];
   list of files to exclude  stn.exclude = [];
   preprocess matching files before serving them to the browser   https://npmjs.org/browse/keyword/karma-preprocessor  stn.preprocessors = {};  stn.preprocessors[package.main] = ['coverage'];
   possible values: 'dots', 'progress', 'story'   https://npmjs.org/browse/keyword/karma-reporter  stn.reporters = [    story,    saucelabs  ];
   enable / disable colors in the output (reporters and logs)  stn.colors = true;
   level of logging   possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG  stn.logLevel = config.LOG_INFO;
  stn.autoWatch = false;
  stn.customLaunchers = launchers;
  stn.browsers = Object.keys(launchers);
  stn.captureTimeout = 240000;
  stn.browserDisconnectTimeout = 5000;
  stn.browserDisconnectTolerance = 4;
  stn.singleRun = true;
  stn.sauceLabs = {    testName: package.name +  -  + package.version +  - unit tests  };
  stn.hostname = 127.0.0.1;
  config.set(stn);
};"
"var package = require(./package.json);var fs = require(fs);var gulp = require(gulp);var jscs = require(gulp-jscs);var karma = require(karma);var uglify = require(gulp-uglify);var rename = require(gulp-rename);var size = require(gulp-size);var rimraf = require(rimraf);var runSequence = require(run-sequence);var fileExists = function (filePath) {  try {    return fs.statSync(filePath).isFile();  } catch (err) {    return false;  }};
 Load environment variables if .env file existsif (fileExists(./.env)) {  require(dotenv).load();}
gulp.task(validate, function () {
  return gulp  .src(package.main)  .pipe(jscs())  .pipe(jscs.reporter());
});
gulp.task(compress, function() {
  var mainMinified = package.main.replace(./, ).replace(.js, .min.js);
  return gulp  .src(package.main)  .pipe(size({title: development}))  .pipe(uglify({    preserveComments: some  }))  .pipe(size({title: minified}))  .pipe(size({title: gzipped, gzip: true}))  .pipe(rename(mainMinified))  .pipe(gulp.dest(./));
});
gulp.task(test, function (done) {
  (new karma.Server({    configFile: __dirname + /karma.conf.js,    action: run  }, function (exitCode) {    done(exitCode);  })).start();
});
gulp.task(clean, function (cb) {
  rimraf(./*.log, function () {    rimraf(./coverage, cb);  });
});
gulp.task(default, function (done) {
  if (process.env.CI) {    runSequence(validate, compress, test, clean, done);  }  else {    runSequence(validate, compress, test, done);  }
});"
"module.exports = function (config) {  config.set({    browsers: [PhantomJS],    frameworks: [jasmine],    files: [test/**/*.js],    reporters: [spec],    preprocessors: {      test/*.js: [webpack]    },    singleRun: true,
    webpack: {       karma watches the test entry points       (you don't need to specify the entry option)      module: {        loaders: [          {            test: js,            loader: babel,            exclude: node_modules          },        ]      }    },
    webpackMiddleware: {      noInfo: true    }  });};"
"let SortableListView = require(./index);let React = require(react);let {  View,  Text,  TouchableHighlight} = require(react-native);

let data = {  hello: {text: world},  how: {text: are you},  test: {text: 123},  this: {text: is},  a: {text: a},  real: {text: real},  drag: {text: drag and drop},  bb: {text: bb},  cc: {text: cc},  dd: {text: dd},  ee: {text: ee},  ff: {text: ff},  gg: {text: gg},  hh: {text: hh},  ii: {text: ii},  jj: {text: jj},  kk: {text: kk}}
let order = Object.keys(data); Array of keys
let RowComponent = React.createClass({  render: function() {    return <TouchableHighlight underlayColor={#eee} style={{padding: 25, backgroundColor: #F8F8F8, borderBottomWidth:1, borderColor: #eee}} {...this.props.sortHandlers}>        <Text>{this.props.data.text}</Text>      </TouchableHighlight>  }})
let MyComponent = React.createClass({  render: function() {    return <SortableListView          style={{flex: 1}}          data={data}          order={order}          onRowMoved={e => {            order.splice(e.to, 0, order.splice(e.from, 1)[0]);            this.forceUpdate();          }}          renderRow={row => <RowComponent data={row} />}        />  }});
module.exports = MyComponent;"
"use strict; generated on 2015-04-04 using generator-gulp-webapp 0.1.0
var gulp = require(gulp);
 load pluginsvar $ = require(gulp-load-plugins)();const babel = require(gulp-babel);
gulp.task(scripts, function () {    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))        .pipe($.jshint())        .pipe($.jshint.reporter(require(jshint-stylish)))        .pipe($.size());});

var rename = require(gulp-rename);
gulp.task(buildjs, [scripts], function () {    var jsFilter = $.filter(**/*.js, {restore: true});
    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))            .pipe(gulp.dest(dist))        .pipe($.size());});
gulp.task(js, [buildjs], function () {    var jsFilter = $.filter(**/*.js, {restore: true});
    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))            .pipe($.uglify())        .pipe(rename({            suffix: .min        }))        .pipe(gulp.dest(dist))        .pipe($.size());});
gulp.task(clean, function () {    return gulp.src([.tmp, dist], { read: false }).pipe($.clean());});
gulp.task(build, [js, copy-js, main-bower-files],function(){        return gulp.src(./bower_components/vue/dist/vue.js)        .pipe(gulp.dest(./examples/libs/vue/dist));        });
gulp.task(default, [clean], function () {    gulp.start(build);});
gulp.task(connect, function () {    var connect = require(connect);    var serveStatic = require(serve-static);    var serveIndex  = require(serve-index);    var app = connect()        .use(require(connect-livereload)({ port: 35729 }))        .use(serveStatic(.tmp))        .use(serveStatic(examples))        .use(serveIndex(examples));
    require(http).createServer(app)        .listen(9000)        .on(listening, function () {            console.log(Started connect web server on http://localhost:9000);        });});
gulp.task(serve, [connect], function () {    require(opn)(http://localhost:9000);});
var mainBowerFiles = require(gulp-main-bower-files);
gulp.task(main-bower-files, function() {    return gulp.src(./bower.json)        .pipe(mainBowerFiles())        .pipe(gulp.dest(./examples/libs));});
gulp.task(copy-js, function() {    return gulp.src(src/**/*.js)                .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))           .pipe(gulp.dest(./examples/src));});
var jip = require(jasmine-istanbul-phantom);var changedSpec = null
gulp.task(test, function(done) {  var options = { callback: done, lib : [bower_components/**/*.js] }
  if (changedSpec)    options.spec = changedSpec
  jip(options)
  changedSpec = null}); gulp.task(watch, [connect, serve], function () {    var server = $.livereload;    server.listen();     watch for changes    gulp.watch([        examples/*.html,        src/**/*.js,        examples/**/*.js,    ]).on(change, server.changed);

    gulp.watch(./bower.json).on(change, function() {        gulp.start(main-bower-files)    });     gulp.watch(src/**/*.js, [scripts]);
    gulp.watch(src/**/*.js).on(change, function() {        gulp.start(copy-js);        gulp.start(test);    });
    gulp.watch(test/spec/*.js).on(change, function(event){        changedSpec = event.path        gulp.start(test)    });
});"
"
(function($){$.extend({tablesorter:newfunction(){var parsers=[],widgets=[];this.defaults={cssHeader:""header"",cssAsc:""headerSortUp"",cssDesc:""headerSortDown"",cssChildRow:""expand-child"",sortInitialOrder:""asc"",sortMultiSortKey:""shiftKey"",sortForce:null,sortAppend:null,sortLocaleCompare:true,textExtraction:""simple"",parsers:{},widgets:[],widgetZebra:{css:[""even"",""odd""]},headers:{},widthFixed:false,cancelSelection:true,sortList:[],headerList:[],dateFormat:""us"",decimal:'/\.|\,/g',onRenderHeader:null,selectorHeaders:'thead th',debug:false};function benchmark(s,d){log(s+"",""+(new Date().getTime()-d.getTime())+""ms"");}this.benchmark=benchmark;function log(s){if(typeof console!=""undefined""&&typeof console.debug!=""undefined""){console.log(s);}else{alert(s);}}function buildParserCache(table,$headers){if(table.config.debug){var parsersDebug="""";}if(table.tBodies.length==0)return;var rows=table.tBodies[0].rows;if(rows[0]){var list=[],cells=rows[0].cells,l=cells.length;for(var i=0;i<l;i++){var p=false;if($.metadata&&($($headers[i]).metadata()&&$($headers[i]).metadata().sorter)){p=getParserById($($headers[i]).metadata().sorter);}else if((table.config.headers[i]&&table.config.headers[i].sorter)){p=getParserById(table.config.headers[i].sorter);}if(!p){p=detectParserForColumn(table,rows,-1,i);}if(table.config.debug){parsersDebug+=""column:""+i+"" parser:""+p.id+""\n"";}list.push(p);}}if(table.config.debug){log(parsersDebug);}return list;};function detectParserForColumn(table,rows,rowIndex,cellIndex){var l=parsers.length,node=false,nodeValue=false,keepLooking=true;while(nodeValue==''&&keepLooking){rowIndex++;if(rows[rowIndex]){node=getNodeFromRowAndCellIndex(rows,rowIndex,cellIndex);nodeValue=trimAndGetNodeText(table.config,node);if(table.config.debug){log('Checking if value was empty on row:'+rowIndex);}}else{keepLooking=false;}}for(var i=1;i<l;i++){if(parsers[i].is(nodeValue,table,node)){return parsers[i];}}return parsers[0];}function getNodeFromRowAndCellIndex(rows,rowIndex,cellIndex){return rows[rowIndex].cells[cellIndex];}function trimAndGetNodeText(config,node){return $.trim(getElementText(config,node));}function getParserById(name){var l=parsers.length;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==name.toLowerCase()){return parsers[i];}}return false;}function buildCache(table){if(table.config.debug){var cacheTime=new Date();}var totalRows=(table.tBodies[0]&&table.tBodies[0].rows.length)||0,totalCells=(table.tBodies[0].rows[0]&&table.tBodies[0].rows[0].cells.length)||0,parsers=table.config.parsers,cache={row:[],normalized:[]};for(var i=0;i<totalRows;++i){var c=$(table.tBodies[0].rows[i]),cols=[];if(c.hasClass(table.config.cssChildRow)){cache.row[cache.row.length-1]=cache.row[cache.row.length-1].add(c);continue;}cache.row.push(c);for(var j=0;j<totalCells;++j){cols.push(parsers[j].format(getElementText(table.config,c[0].cells[j]),table,c[0].cells[j]));}cols.push(cache.normalized.length);cache.normalized.push(cols);cols=null;};if(table.config.debug){benchmark(""Building cache for ""+totalRows+"" rows:"",cacheTime);}return cache;};function getElementText(config,node){var text="""";if(!node)return"""";if(!config.supportsTextContent)config.supportsTextContent=node.textContent||false;if(config.textExtraction==""simple""){if(config.supportsTextContent){text=node.textContent;}else{if(node.childNodes[0]&&node.childNodes[0].hasChildNodes()){text=node.childNodes[0].innerHTML;}else{text=node.innerHTML;}}}else{if(typeof(config.textExtraction)==""function""){text=config.textExtraction(node);}else{text=$(node).text();}}return text;}function appendToTable(table,cache){if(table.config.debug){var appendTime=new Date()}var c=cache,r=c.row,n=c.normalized,totalRows=n.length,checkCell=(n[0].length-1),tableBody=$(table.tBodies[0]),rows=[];for(var i=0;i<totalRows;i++){var pos=n[i][checkCell];rows.push(r[pos]);if(!table.config.appender){var l=r[pos].length;for(var j=0;j<l;j++){tableBody[0].appendChild(r[pos][j]);}}}if(table.config.appender){table.config.appender(table,rows);}rows=null;if(table.config.debug){benchmark(""Rebuilt table:"",appendTime);}applyWidget(table);setTimeout(function(){$(table).trigger(""sortEnd"");},0);};function buildHeaders(table){if(table.config.debug){var time=new Date();}var meta=($.metadata)?true:false;var header_index=computeTableHeaderCellIndexes(table);$tableHeaders=$(table.config.selectorHeaders,table).each(function(index){this.column=header_index[this.parentNode.rowIndex+""-""+this.cellIndex];this.order=formatSortingOrder(table.config.sortInitialOrder);this.count=this.order;if(checkHeaderMetadata(this)||checkHeaderOptions(table,index))this.sortDisabled=true;if(checkHeaderOptionsSortingLocked(table,index))this.order=this.lockedOrder=checkHeaderOptionsSortingLocked(table,index);if(!this.sortDisabled){var $th=$(this).addClass(table.config.cssHeader);if(table.config.onRenderHeader)table.config.onRenderHeader.apply($th);}table.config.headerList[index]=this;});if(table.config.debug){benchmark(""Built headers:"",time);log($tableHeaders);}return $tableHeaders;};function computeTableHeaderCellIndexes(t){var matrix=[];var lookup={};var thead=t.getElementsByTagName('THEAD')[0];var trs=thead.getElementsByTagName('TR');for(var i=0;i<trs.length;i++){var cells=trs[i].cells;for(var j=0;j<cells.length;j++){var c=cells[j];var rowIndex=c.parentNode.rowIndex;var cellId=rowIndex+""-""+c.cellIndex;var rowSpan=c.rowSpan||1;var colSpan=c.colSpan||1var firstAvailCol;if(typeof(matrix[rowIndex])==""undefined""){matrix[rowIndex]=[];}for(var k=0;k<matrix[rowIndex].length+1;k++){if(typeof(matrix[rowIndex][k])==""undefined""){firstAvailCol=k;break;}}lookup[cellId]=firstAvailCol;for(var k=rowIndex;k<rowIndex+rowSpan;k++){if(typeof(matrix[k])==""undefined""){matrix[k]=[];}var matrixrow=matrix[k];for(var l=firstAvailCol;l<firstAvailCol+colSpan;l++){matrixrow[l]=""x"";}}}}return lookup;}function checkCellColSpan(table,rows,row){var arr=[],r=table.tHead.rows,c=r[row].cells;for(var i=0;i<c.length;i++){var cell=c[i];if(cell.colSpan>1){arr=arr.concat(checkCellColSpan(table,headerArr,row++));}else{if(table.tHead.length==1||(cell.rowSpan>1||!r[row+1])){arr.push(cell);}}}return arr;};function checkHeaderMetadata(cell){if(($.metadata)&&($(cell).metadata().sorter===false)){return true;};return false;}function checkHeaderOptions(table,i){if((table.config.headers[i])&&(table.config.headers[i].sorter===false)){return true;};return false;}function checkHeaderOptionsSortingLocked(table,i){if((table.config.headers[i])&&(table.config.headers[i].lockedOrder))return table.config.headers[i].lockedOrder;return false;}function applyWidget(table){var c=table.config.widgets;var l=c.length;for(var i=0;i<l;i++){getWidgetById(c[i]).format(table);}}function getWidgetById(name){var l=widgets.length;for(var i=0;i<l;i++){if(widgets[i].id.toLowerCase()==name.toLowerCase()){return widgets[i];}}};function formatSortingOrder(v){if(typeof(v)!=""Number""){return(v.toLowerCase()==""desc"")?1:0;}else{return(v==1)?1:0;}}function isValueInArray(v,a){var l=a.length;for(var i=0;i<l;i++){if(a[i][0]==v){return true;}}return false;}function setHeadersCss(table,$headers,list,css){$headers.removeClass(css[0]).removeClass(css[1]);var h=[];$headers.each(function(offset){if(!this.sortDisabled){h[this.column]=$(this);}});var l=list.length;for(var i=0;i<l;i++){h[list[i][0]].addClass(css[list[i][1]]);}}function fixColumnWidth(table,$headers){var c=table.config;if(c.widthFixed){var colgroup=$('<colgroup>');$(""tr:first td"",table.tBodies[0]).each(function(){colgroup.append($('<col>').css('width',$(this).width()));});$(table).prepend(colgroup);};}function updateHeaderSortCount(table,sortList){var c=table.config,l=sortList.length;for(var i=0;i<l;i++){var s=sortList[i],o=c.headerList[s[0]];o.count=s[1];o.count++;}}function multisort(table,sortList,cache){if(table.config.debug){var sortTime=new Date();}var dynamicExp=""var sortWrapper = function(a,b) {"",l=sortList.length;for(var i=0;i<l;i++){var c=sortList[i][0];var order=sortList[i][1];var s=(table.config.parsers[c].type==""text"")?((order==0)?makeSortFunction(""text"",""asc"",c):makeSortFunction(""text"",""desc"",c)):((order==0)?makeSortFunction(""numeric"",""asc"",c):makeSortFunction(""numeric"",""desc"",c));var e=""e""+i;dynamicExp+=""var ""+e+"" = ""+s;dynamicExp+=""if(""+e+"") { return ""+e+""; } "";dynamicExp+=""else { "";}var orgOrderCol=cache.normalized[0].length-1;dynamicExp+=""return a[""+orgOrderCol+""]-b[""+orgOrderCol+""];"";for(var i=0;i<l;i++){dynamicExp+=""}; "";}dynamicExp+=""return 0; "";dynamicExp+=""}; "";if(table.config.debug){benchmark(""Evaling expression:""+dynamicExp,new Date());}eval(dynamicExp);cache.normalized.sort(sortWrapper);if(table.config.debug){benchmark(""Sorting on ""+sortList.toString()+"" and dir ""+order+"" time:"",sortTime);}return cache;};function makeSortFunction(type,direction,index){var a=""a[""+index+""]"",b=""b[""+index+""]"";if(type=='text'&&direction=='asc'){return""(""+a+"" == ""+b+"" ? 0 : (""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : (""+a+"" < ""+b+"") ? -1 : 1 )));"";}else if(type=='text'&&direction=='desc'){return""(""+a+"" == ""+b+"" ? 0 : (""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : (""+b+"" < ""+a+"") ? -1 : 1 )));"";}else if(type=='numeric'&&direction=='asc'){return""(""+a+"" === null && ""+b+"" === null) ? 0 :(""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : ""+a+"" - ""+b+""));"";}else if(type=='numeric'&&direction=='desc'){return""(""+a+"" === null && ""+b+"" === null) ? 0 :(""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : ""+b+"" - ""+a+""));"";}};function makeSortText(i){return""((a[""+i+""] < b[""+i+""]) ? -1 : ((a[""+i+""] > b[""+i+""]) ? 1 : 0));"";};function makeSortTextDesc(i){return""((b[""+i+""] < a[""+i+""]) ? -1 : ((b[""+i+""] > a[""+i+""]) ? 1 : 0));"";};function makeSortNumeric(i){return""a[""+i+""]-b[""+i+""];"";};function makeSortNumericDesc(i){return""b[""+i+""]-a[""+i+""];"";};function sortText(a,b){if(table.config.sortLocaleCompare)return a.localeCompare(b);return((a<b)?-1:((a>b)?1:0));};function sortTextDesc(a,b){if(table.config.sortLocaleCompare)return b.localeCompare(a);return((b<a)?-1:((b>a)?1:0));};function sortNumeric(a,b){return a-b;};function sortNumericDesc(a,b){return b-a;};function getCachedSortType(parsers,i){return parsers[i].type;};this.construct=function(settings){return this.each(function(){if(!this.tHead||!this.tBodies)return;var $this,$document,$headers,cache,config,shiftDown=0,sortOrder;this.config={};config=$.extend(this.config,$.tablesorter.defaults,settings);$this=$(this);$.data(this,""tablesorter"",config);$headers=buildHeaders(this);this.config.parsers=buildParserCache(this,$headers);cache=buildCache(this);var sortCSS=[config.cssDesc,config.cssAsc];fixColumnWidth(this);$headers.click(function(e){var totalRows=($this[0].tBodies[0]&&$this[0].tBodies[0].rows.length)||0;if(!this.sortDisabled&&totalRows>0){$this.trigger(""sortStart"");var $cell=$(this);var i=this.column;this.order=this.count++%2;if(this.lockedOrder)this.order=this.lockedOrder;if(!e[config.sortMultiSortKey]){config.sortList=[];if(config.sortForce!=null){var a=config.sortForce;for(var j=0;j<a.length;j++){if(a[j][0]!=i){config.sortList.push(a[j]);}}}config.sortList.push([i,this.order]);}else{if(isValueInArray(i,config.sortList)){for(var j=0;j<config.sortList.length;j++){var s=config.sortList[j],o=config.headerList[s[0]];if(s[0]==i){o.count=s[1];o.count++;s[1]=o.count%2;}}}else{config.sortList.push([i,this.order]);}};setTimeout(function(){setHeadersCss($this[0],$headers,config.sortList,sortCSS);appendToTable($this[0],multisort($this[0],config.sortList,cache));},1);return false;}}).mousedown(function(){if(config.cancelSelection){this.onselectstart=function(){return false};return false;}});$this.bind(""update"",function(){var me=this;setTimeout(function(){me.config.parsers=buildParserCache(me,$headers);cache=buildCache(me);},1);}).bind(""updateCell"",function(e,cell){var config=this.config;var pos=[(cell.parentNode.rowIndex-1),cell.cellIndex];cache.normalized[pos[0]][pos[1]]=config.parsers[pos[1]].format(getElementText(config,cell),cell);}).bind(""sorton"",function(e,list){$(this).trigger(""sortStart"");config.sortList=list;var sortList=config.sortList;updateHeaderSortCount(this,sortList);setHeadersCss(this,$headers,sortList,sortCSS);appendToTable(this,multisort(this,sortList,cache));}).bind(""appendCache"",function(){appendToTable(this,cache);}).bind(""applyWidgetId"",function(e,id){getWidgetById(id).format(this);}).bind(""applyWidgets"",function(){applyWidget(this);});if($.metadata&&($(this).metadata()&&$(this).metadata().sortlist)){config.sortList=$(this).metadata().sortlist;}if(config.sortList.length>0){$this.trigger(""sorton"",[config.sortList]);}applyWidget(this);});};this.addParser=function(parser){var l=parsers.length,a=true;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==parser.id.toLowerCase()){a=false;}}if(a){parsers.push(parser);};};this.addWidget=function(widget){widgets.push(widget);};this.formatFloat=function(s){var i=parseFloat(s);return(isNaN(i))?0:i;};this.formatInt=function(s){var i=parseInt(s);return(isNaN(i))?0:i;};this.isDigit=function(s,config){return/^[-+]?\d*$/.test($.trim(s.replace(/[,.']/g,'')));};this.clearTableBody=function(table){if($.browser.msie){function empty(){while(this.firstChild)this.removeChild(this.firstChild);}empty.apply(table.tBodies[0]);}else{table.tBodies[0].innerHTML="""";}};}});$.fn.extend({tablesorter:$.tablesorter.construct});var ts=$.tablesorter;ts.addParser({id:""text"",is:function(s){return true;},format:function(s){return $.trim(s.toLocaleLowerCase());},type:""text""});ts.addParser({id:""digit"",is:function(s,table){var c=table.config;return $.tablesorter.isDigit(s,c);},format:function(s){return $.tablesorter.formatFloat(s);},type:""numeric""});ts.addParser({id:""currency"",is:function(s){return/^[£$€?.]/.test(s);},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/[£$€]/g),""""));},type:""numeric""});ts.addParser({id:""ipAddress"",is:function(s){return/^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);},format:function(s){var a=s.split("".""),r="""",l=a.length;for(var i=0;i<l;i++){var item=a[i];if(item.length==2){r+=""0""+item;}else{r+=item;}}return $.tablesorter.formatFloat(r);},type:""numeric""});ts.addParser({id:""url"",is:function(s){return/^(https?|ftp|file):\/\/$/.test(s);},format:function(s){return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//),''));},type:""text""});ts.addParser({id:""isoDate"",is:function(s){return/^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);},format:function(s){return $.tablesorter.formatFloat((s!="""")?new Date(s.replace(new RegExp(/-/g),""/"")).getTime():""0"");},type:""numeric""});ts.addParser({id:""percent"",is:function(s){return/\%$/.test($.trim(s));},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g),""""));},type:""numeric""});ts.addParser({id:""usLongDate"",is:function(s){return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));},format:function(s){return $.tablesorter.formatFloat(new Date(s).getTime());},type:""numeric""});ts.addParser({id:""shortDate"",is:function(s){return/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);},format:function(s,table){var c=table.config;s=s.replace(/\-/g,""/"");if(c.dateFormat==""us""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,""$3/$1/$2"");}else if (c.dateFormat == ""pt"") {s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, ""$3/$2/$1"");} else if(c.dateFormat==""uk""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,""$3/$2/$1"");}else if(c.dateFormat==""dd/mm/yy""||c.dateFormat==""dd-mm-yy""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/,""$1/$2/$3"");}return $.tablesorter.formatFloat(new Date(s).getTime());},type:""numeric""});ts.addParser({id:""time"",is:function(s){return/^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);},format:function(s){return $.tablesorter.formatFloat(new Date(""2000/01/01 ""+s).getTime());},type:""numeric""});ts.addParser({id:""metadata"",is:function(s){return false;},format:function(s,table,cell){var c=table.config,p=(!c.parserMetadataName)?'sortValue':c.parserMetadataName;return $(cell).metadata()[p];},type:""numeric""});ts.addWidget({id:""zebra"",format:function(table){if(table.config.debug){var time=new Date();}var $tr,row=-1,odd;$(""tr:visible"",table.tBodies[0]).each(function(i){$tr=$(this);if(!$tr.hasClass(table.config.cssChildRow))row++;odd=(row%2==0);$tr.removeClass(table.config.widgetZebra.css[odd?0:1]).addClass(table.config.widgetZebra.css[odd?1:0])});if(table.config.debug){$.tablesorter.benchmark(""Applying Zebra widget"",time);}}});})(jQuery);"
"/* *  * TableSorter 2.0 - Client-side table sorting with ease! * Version 2.0.5b * @requires jQuery v1.2.3 *  * Copyright (c) 2007 Christian Bach * Examples and docs at: http://tablesorter.com * Dual licensed under the MIT and GPL licenses: * http://www.opensource.org/licenses/mit-license.php * http://www.gnu.org/licenses/gpl.html *  *//** *  *  Create a sortable table with multi-column sorting capabilitys *  *   *  Create a simple tablesorter interface. *  *   *  Create a tablesorter interface and sort on the first and secound column column headers. *  *   *           *  Create a tablesorter interface and disableing the first and second  column headers. *       *  *   *  *  Create a tablesorter interface and set a column parser for the first *       and second column. *  *  *   *            settings An object literal containing key/value pairs to provide *            optional settings. *  *  * @option String cssHeader (optional) A string of the class name to be appended *         to sortable tr elements in the thead of the table. Default value: *         ""header"" *  * @option String cssAsc (optional) A string of the class name to be appended to *         sortable tr elements in the thead on a ascending sort. Default value: *         ""headerSortUp"" *  * @option String cssDesc (optional) A string of the class name to be appended *         to sortable tr elements in the thead on a descending sort. Default *         value: ""headerSortDown"" *  * @option String sortInitialOrder (optional) A string of the inital sorting *         order can be asc or desc. Default value: ""asc"" *  * @option String sortMultisortKey (optional) A string of the multi-column sort *         key. Default value: ""shiftKey"" *  * @option String textExtraction (optional) A string of the text-extraction *         method to use. For complex html structures inside td cell set this *         option to ""complex"", on large tables the complex option can be slow. *         Default value: ""simple"" *  * @option Object headers (optional) An object of instructions for per-column *         controls in the format: headers: { 0: { option: setting }, ... }. For  *         example, to disable sorting on the first two columns of a table: *         headers: { 0: { sorter: false}, 1: {sorter: false} }. *         Default value: null. *  * @option Array sortList (optional) An array of instructions for per-column sorting  *         and direction in the format: [[columnIndex, sortDirection], ... ] where  *         columnIndex is a zero-based index for your columns left-to-right and  *         sortDirection is 0 for Ascending and 1 for Descending. A valid argument  *         that sorts ascending first by column 1 and then column 2 looks like:  *         [[0,0],[1,0]]. Default value: null. *  * @option Array sortForce (optional) An array containing forced sorting rules. *         Use to add an additional forced sort that will be appended to the dynamic *         selections by the user. For example, can be used to sort people alphabetically *         after some other user-selected sort that results in rows with the same value  *         like dates or money due. It can help prevent data from appearing as though it  *         has a random secondary sort. Default value: null. *  * @option Boolean sortLocaleCompare (optional) Boolean flag indicating whatever *         to use String.localeCampare method or not. Default set to true. *  *  * @option Array sortAppend (optional) An array containing forced sorting rules. *         This option let's you specify a default sorting rule, which is *         appended to user-selected rules. Default value: null *  * @option Boolean widthFixed (optional) Boolean flag indicating if tablesorter *         should apply fixed widths to the table columns. This is usefull when *         using the pager companion plugin. This options requires the dimension *         jquery plugin. Default value: false *  * @option Boolean cancelSelection (optional) Boolean flag indicating if *         tablesorter should cancel selection of the table headers text. *         Default value: true *  * @option Boolean debug (optional) Boolean flag indicating if tablesorter *         should display debuging information usefull for development. *  *  jQuery *  *   *  * @cat Plugins/Tablesorter *  *  /christian.bach@polyester.se */
(function ($) {    $.extend({        tablesorter: new        function () {
            var parsers = [],                widgets = [];
            this.defaults = {                cssHeader: header,                cssAsc: headerSortUp,                cssDesc: headerSortDown,                cssChildRow: expand-child,                sortInitialOrder: asc,                sortMultiSortKey: shiftKey,                sortForce: null,                sortAppend: null,                sortLocaleCompare: true,                textExtraction: simple,                parsers: {}, widgets: [],                widgetZebra: {                    css: [even, odd]                }, headers: {}, widthFixed: false,                cancelSelection: true,                sortList: [],                headerList: [],                dateFormat: us,                decimal: /|/g,                onRenderHeader: null,                selectorHeaders: thead th,                debug: false            };
            /* debuging utils */
            function benchmark(s, d) {                log(s + , + (new Date().getTime() - d.getTime()) + ms);            }
            this.benchmark = benchmark;
            function log(s) {                if (typeof console != undefined && typeof console.debug != undefined) {                    console.log(s);                } else {                    alert(s);                }            }
            /* parsers utils */
            function buildParserCache(table, $headers) {
                if (table.config.debug) {                    var parsersDebug = ;                }
                if (table.tBodies.length == 0) return;  In the case of empty tables                var rows = table.tBodies[0].rows;
                if (rows[0]) {
                    var list = [],                        cells = rows[0].cells,                        l = cells.length;
                    for (var i = 0; i < l; i++) {
                        var p = false;
                        if ($.metadata && ($($headers[i]).metadata() && $($headers[i]).metadata().sorter)) {
                            p = getParserById($($headers[i]).metadata().sorter);
                        } else if ((table.config.headers[i] && table.config.headers[i].sorter)) {
                            p = getParserById(table.config.headers[i].sorter);                        }                        if (!p) {
                            p = detectParserForColumn(table, rows, -1, i);                        }
                        if (table.config.debug) {                            parsersDebug += column: + i +  parser: + p.id + ;                        }
                        list.push(p);                    }                }
                if (table.config.debug) {                    log(parsersDebug);                }
                return list;            };
            function detectParserForColumn(table, rows, rowIndex, cellIndex) {                var l = parsers.length,                    node = false,                    nodeValue = false,                    keepLooking = true;                while (nodeValue ==  && keepLooking) {                    rowIndex++;                    if (rows[rowIndex]) {                        node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);                        nodeValue = trimAndGetNodeText(table.config, node);                        if (table.config.debug) {                            log(Checking if value was empty on row: + rowIndex);                        }                    } else {                        keepLooking = false;                    }                }                for (var i = 1; i < l; i++) {                    if (parsers[i].is(nodeValue, table, node)) {                        return parsers[i];                    }                }                 0 is always the generic parser (text)                return parsers[0];            }
            function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {                return rows[rowIndex].cells[cellIndex];            }
            function trimAndGetNodeText(config, node) {                return $.trim(getElementText(config, node));            }
            function getParserById(name) {                var l = parsers.length;                for (var i = 0; i < l; i++) {                    if (parsers[i].id.toLowerCase() == name.toLowerCase()) {                        return parsers[i];                    }                }                return false;            }
            /* utils */
            function buildCache(table) {
                if (table.config.debug) {                    var cacheTime = new Date();                }
                var totalRows = (table.tBodies[0] && table.tBodies[0].rows.length) || 0,                    totalCells = (table.tBodies[0].rows[0] && table.tBodies[0].rows[0].cells.length) || 0,                    parsers = table.config.parsers,                    cache = {                        row: [],                        normalized: []                    };
                for (var i = 0; i < totalRows; ++i) {
                                        var c = $(table.tBodies[0].rows[i]),                        cols = [];
                     if this is a child row, add it to the last row's children and                     continue to the next row                    if (c.hasClass(table.config.cssChildRow)) {                        cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);                         go to the next for loop                        continue;                    }
                    cache.row.push(c);
                    for (var j = 0; j < totalCells; ++j) {                        cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));                    }
                    cols.push(cache.normalized.length);  add position for rowCache                    cache.normalized.push(cols);                    cols = null;                };
                if (table.config.debug) {                    benchmark(Building cache for  + totalRows +  rows:, cacheTime);                }
                return cache;            };
            function getElementText(config, node) {            	                if (!node) return ;                		        var $node = $(node),		            data = $node.attr(data-sort-value);		        if (data !== undefined) return data;
                var text = ;
                if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;
                if (config.textExtraction == simple) {                    if (config.supportsTextContent) {                        text = node.textContent;                    } else {                        if (node.childNodes[0] && node.childNodes[0].hasChildNodes()) {                            text = node.childNodes[0].innerHTML;                        } else {                            text = node.innerHTML;                        }                    }                } else {                    if (typeof(config.textExtraction) == function) {                        text = config.textExtraction(node);                    } else {                        text = $(node).text();                    }                }                return text;            }
            function appendToTable(table, cache) {
                if (table.config.debug) {                    var appendTime = new Date()                }
                var c = cache,                    r = c.row,                    n = c.normalized,                    totalRows = n.length,                    checkCell = (n[0].length - 1),                    tableBody = $(table.tBodies[0]),                    rows = [];

                for (var i = 0; i < totalRows; i++) {                    var pos = n[i][checkCell];
                    rows.push(r[pos]);
                    if (!table.config.appender) {
                        var o = ;                        var l = r[pos].length;                        for (var j = 0; j < l; j++) {                            tableBody[0].appendChild(r[pos][j]);                        }
                                             }                }


                if (table.config.appender) {
                    table.config.appender(table, rows);                }
                rows = null;
                if (table.config.debug) {                    benchmark(Rebuilt table:, appendTime);                }
                 apply table widgets                applyWidget(table);
                 trigger sortend                setTimeout(function () {                    $(table).trigger(sortEnd);                }, 0);
            };
            function buildHeaders(table) {
                if (table.config.debug) {                    var time = new Date();                }
                var meta = ($.metadata) ? true : false;                                var header_index = computeTableHeaderCellIndexes(table);
                var $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {
                    this.column = header_index[this.parentNode.rowIndex + - + this.cellIndex];                     this.column = index;                    this.order = formatSortingOrder(table.config.sortInitialOrder);                    										this.count = this.order;
                    if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;					if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);
                    if (!this.sortDisabled) {                        var $th = $(this).addClass(table.config.cssHeader);                        if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);                    }
                     add cell to headerList                    table.config.headerList[index] = this;                });
                if (table.config.debug) {                    benchmark(Built headers:, time);                    log($tableHeaders);                }
                return $tableHeaders;
            };
             from:             http://www.javascripttoolbox.com/lib/table/examples.php             http://www.javascripttoolbox.com/temp/table_cellindex.html

            function computeTableHeaderCellIndexes(t) {                var matrix = [];                var lookup = {};                var thead = t.getElementsByTagName(THEAD)[0];                var trs = thead.getElementsByTagName(TR);
                for (var i = 0; i < trs.length; i++) {                    var cells = trs[i].cells;                    for (var j = 0; j < cells.length; j++) {                        var c = cells[j];
                        var rowIndex = c.parentNode.rowIndex;                        var cellId = rowIndex + - + c.cellIndex;                        var rowSpan = c.rowSpan || 1;                        var colSpan = c.colSpan || 1                        var firstAvailCol;                        if (typeof(matrix[rowIndex]) == undefined) {                            matrix[rowIndex] = [];                        }                         Find first available column in the first row                        for (var k = 0; k < matrix[rowIndex].length + 1; k++) {                            if (typeof(matrix[rowIndex][k]) == undefined) {                                firstAvailCol = k;                                break;                            }                        }                        lookup[cellId] = firstAvailCol;                        for (var k = rowIndex; k < rowIndex + rowSpan; k++) {                            if (typeof(matrix[k]) == undefined) {                                matrix[k] = [];                            }                            var matrixrow = matrix[k];                            for (var l = firstAvailCol; l < firstAvailCol + colSpan; l++) {                                matrixrow[l] = x;                            }                        }                    }                }                return lookup;            }
            function checkCellColSpan(table, rows, row) {                var arr = [],                    r = table.tHead.rows,                    c = r[row].cells;
                for (var i = 0; i < c.length; i++) {                    var cell = c[i];
                    if (cell.colSpan > 1) {                        arr = arr.concat(checkCellColSpan(table, headerArr, row++));                    } else {                        if (table.tHead.length == 1 || (cell.rowSpan > 1 || !r[row + 1])) {                            arr.push(cell);                        }                         headerArr[row] = (i+row);                    }                }                return arr;            };
            function checkHeaderMetadata(cell) {                if (($.metadata) && ($(cell).metadata().sorter === false)) {                    return true;                };                return false;            }
            function checkHeaderOptions(table, i) {                if ((table.config.headers[i]) && (table.config.headers[i].sorter === false)) {                    return true;                };                return false;            }						 function checkHeaderOptionsSortingLocked(table, i) {                if ((table.config.headers[i]) && (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder;                return false;            }			            function applyWidget(table) {                var c = table.config.widgets;                var l = c.length;                for (var i = 0; i < l; i++) {
                    getWidgetById(c[i]).format(table);                }
            }
            function getWidgetById(name) {                var l = widgets.length;                for (var i = 0; i < l; i++) {                    if (widgets[i].id.toLowerCase() == name.toLowerCase()) {                        return widgets[i];                    }                }            };
            function formatSortingOrder(v) {                if (typeof(v) != Number) {                    return (v.toLowerCase() == desc) ? 1 : 0;                } else {                    return (v == 1) ? 1 : 0;                }            }
            function isValueInArray(v, a) {                var l = a.length;                for (var i = 0; i < l; i++) {                    if (a[i][0] == v) {                        return true;                    }                }                return false;            }
            function setHeadersCss(table, $headers, list, css) {                 remove all header information                $headers.removeClass(css[0]).removeClass(css[1]);
                var h = [];                $headers.each(function (offset) {                    if (!this.sortDisabled) {                        h[this.column] = $(this);                    }                });
                var l = list.length;                for (var i = 0; i < l; i++) {                    h[list[i][0]].addClass(css[list[i][1]]);                }            }
            function fixColumnWidth(table, $headers) {                var c = table.config;                if (c.widthFixed) {                    var colgroup = $(<colgroup>);                    $(tr:first td, table.tBodies[0]).each(function () {                        colgroup.append($(<col>).css(width, $(this).width()));                    });                    $(table).prepend(colgroup);                };            }
            function updateHeaderSortCount(table, sortList) {                var c = table.config,                    l = sortList.length;                for (var i = 0; i < l; i++) {                    var s = sortList[i],                        o = c.headerList[s[0]];                    o.count = s[1];                    o.count++;                }            }
            /* sorting methods */                        var sortWrapper;
            function multisort(table, sortList, cache) {
                if (table.config.debug) {                    var sortTime = new Date();                }
                var dynamicExp = sortWrapper = function(a,b) {,                    l = sortList.length;
                 TODO: inline functions.                for (var i = 0; i < l; i++) {
                    var c = sortList[i][0];                    var order = sortList[i][1];                     var s = (getCachedSortType(table.config.parsers,c) == ""text"") ?                     ((order == 0) ? ""sortText"" : ""sortTextDesc"") : ((order == 0) ?                     ""sortNumeric"" : ""sortNumericDesc"");                     var s = (table.config.parsers[c].type == ""text"") ? ((order == 0)                     ? makeSortText(c) : makeSortTextDesc(c)) : ((order == 0) ?                     makeSortNumeric(c) : makeSortNumericDesc(c));                    var s = (table.config.parsers[c].type == text) ? ((order == 0) ? makeSortFunction(text, asc, c) : makeSortFunction(text, desc, c)) : ((order == 0) ? makeSortFunction(numeric, asc, c) : makeSortFunction(numeric, desc, c));                    var e = e + i;
                    dynamicExp += var  + e +  =  + s;  + ""(a["" + c + ""],b["" + c                     + ""]); "";                    dynamicExp += if( + e + ) { return  + e + ; } ;                    dynamicExp += else { ;
                }
                 if value is the same keep orignal order                var orgOrderCol = cache.normalized[0].length - 1;                dynamicExp += return a[ + orgOrderCol + ]-b[ + orgOrderCol + ];;
                for (var i = 0; i < l; i++) {                    dynamicExp += }; ;                }
                dynamicExp += return 0; ;                dynamicExp += }; ;
                if (table.config.debug) {                    benchmark(Evaling expression: + dynamicExp, new Date());                }
                eval(dynamicExp);
                cache.normalized.sort(sortWrapper);
                if (table.config.debug) {                    benchmark(Sorting on  + sortList.toString() +  and dir  + order +  time:, sortTime);                }
                return cache;            };
            function makeSortFunction(type, direction, index) {                var a = a[ + index + ],                    b = b[ + index + ];                if (type == text && direction == asc) {                    return ( + a +  ==  + b +  ? 0 : ( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY : ( + a +  <  + b + ) ? -1 : 1 )));;                } else if (type == text && direction == desc) {                    return ( + a +  ==  + b +  ? 0 : ( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY : ( + b +  <  + a + ) ? -1 : 1 )));;                } else if (type == numeric && direction == asc) {                    return ( + a +  === null &&  + b +  === null) ? 0 :( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY :  + a +  -  + b + ));;                } else if (type == numeric && direction == desc) {                    return ( + a +  === null &&  + b +  === null) ? 0 :( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY :  + b +  -  + a + ));;                }            };
            function makeSortText(i) {                return ((a[ + i + ] < b[ + i + ]) ? -1 : ((a[ + i + ] > b[ + i + ]) ? 1 : 0));;            };
            function makeSortTextDesc(i) {                return ((b[ + i + ] < a[ + i + ]) ? -1 : ((b[ + i + ] > a[ + i + ]) ? 1 : 0));;            };
            function makeSortNumeric(i) {                return a[ + i + ]-b[ + i + ];;            };
            function makeSortNumericDesc(i) {                return b[ + i + ]-a[ + i + ];;            };
            function sortText(a, b) {                if (table.config.sortLocaleCompare) return a.localeCompare(b);                return ((a < b) ? -1 : ((a > b) ? 1 : 0));            };
            function sortTextDesc(a, b) {                if (table.config.sortLocaleCompare) return b.localeCompare(a);                return ((b < a) ? -1 : ((b > a) ? 1 : 0));            };
            function sortNumeric(a, b) {                return a - b;            };
            function sortNumericDesc(a, b) {                return b - a;            };
            function getCachedSortType(parsers, i) {                return parsers[i].type;            }; /* public methods */            this.construct = function (settings) {                return this.each(function () {                     if no thead or tbody quit.                    if (!this.tHead || !this.tBodies) return;                     declare                    var $this, $document, $headers, cache, config, shiftDown = 0,                        sortOrder;                     new blank config object                    this.config = {};                     merge and extend.                    config = $.extend(this.config, $.tablesorter.defaults, settings);                     store common expression for speed                    $this = $(this);                     save the settings where they read                    $.data(this, tablesorter, config);                     build headers                    $headers = buildHeaders(this);                     try to auto detect column type, and store in tables config                    this.config.parsers = buildParserCache(this, $headers);                     build the cache for the tbody cells                    cache = buildCache(this);                     get the css class names, could be done else where.                    var sortCSS = [config.cssDesc, config.cssAsc];                     fixate columns if the users supplies the fixedWidth option                    fixColumnWidth(this);                     apply event handling to headers                     this is to big, perhaps break it out?                    $headers.click(
                    function (e) {                        var totalRows = ($this[0].tBodies[0] && $this[0].tBodies[0].rows.length) || 0;                        if (!this.sortDisabled && totalRows > 0) {                             Only call sortStart if sorting is                             enabled.                            $this.trigger(sortStart);                             store exp, for speed                            var $cell = $(this);                             get current column index                            var i = this.column;                             get current column sort order                            this.order = this.count++ % 2;							 always sort on the locked order.							if(this.lockedOrder) this.order = this.lockedOrder;														 user only whants to sort on one                             column                            if (!e[config.sortMultiSortKey]) {                                 flush the sort list                                config.sortList = [];                                if (config.sortForce != null) {                                    var a = config.sortForce;                                    for (var j = 0; j < a.length; j++) {                                        if (a[j][0] != i) {                                            config.sortList.push(a[j]);                                        }                                    }                                }                                 add column to sort list                                config.sortList.push([i, this.order]);                                 multi column sorting                            } else {                                 the user has clicked on an all                                 ready sortet column.                                if (isValueInArray(i, config.sortList)) {                                     revers the sorting direction                                     for all tables.                                    for (var j = 0; j < config.sortList.length; j++) {                                        var s = config.sortList[j],                                            o = config.headerList[s[0]];                                        if (s[0] == i) {                                            o.count = s[1];                                            o.count++;                                            s[1] = o.count % 2;                                        }                                    }                                } else {                                     add column to sort list array                                    config.sortList.push([i, this.order]);                                }                            };                            setTimeout(function () {                                 set css for headers                                setHeadersCss($this[0], $headers, config.sortList, sortCSS);                                appendToTable(	                                $this[0], multisort(	                                $this[0], config.sortList, cache)								);                            }, 1);                             stop normal event by returning false                            return false;                        }                         cancel selection                    }).mousedown(function () {                        if (config.cancelSelection) {                            this.onselectstart = function () {                                return false                            };                            return false;                        }                    });                     apply easy methods that trigger binded events                    $this.bind(update, function () {                        var me = this;                        setTimeout(function () {                             rebuild parsers.                            me.config.parsers = buildParserCache(                            me, $headers);                             rebuild the cache map                            cache = buildCache(me);                        }, 1);                    }).bind(updateCell, function (e, cell) {                        var config = this.config;                         get position from the dom.                        var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex];                         update cache                        cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(                        getElementText(config, cell), cell);                    }).bind(sorton, function (e, list) {                        $(this).trigger(sortStart);                        config.sortList = list;                         update and store the sortlist                        var sortList = config.sortList;                         update header count index                        updateHeaderSortCount(this, sortList);                         set css for headers                        setHeadersCss(this, $headers, sortList, sortCSS);                         sort the table and append it to the dom                        appendToTable(this, multisort(this, sortList, cache));                    }).bind(appendCache, function () {                        appendToTable(this, cache);                    }).bind(applyWidgetId, function (e, id) {                        getWidgetById(id).format(this);                    }).bind(applyWidgets, function () {                         apply widgets                        applyWidget(this);                    });                    if ($.metadata && ($(this).metadata() && $(this).metadata().sortlist)) {                        config.sortList = $(this).metadata().sortlist;                    }                     if user has supplied a sort list to constructor.                    if (config.sortList.length > 0) {                        $this.trigger(sorton, [config.sortList]);                    }                     apply widgets                    applyWidget(this);                });            };            this.addParser = function (parser) {                var l = parsers.length,                    a = true;                for (var i = 0; i < l; i++) {                    if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {                        a = false;                    }                }                if (a) {                    parsers.push(parser);                };            };            this.addWidget = function (widget) {                widgets.push(widget);            };            this.formatFloat = function (s) {                var i = parseFloat(s);                return (isNaN(i)) ? 0 : i;            };            this.formatInt = function (s) {                var i = parseInt(s);                return (isNaN(i)) ? 0 : i;            };            this.isDigit = function (s, config) {                 replace all an wanted chars and match.                return .test($.trim(s.replace(g, )));            };            this.clearTableBody = function (table) {                if ($.browser.msie) {                    while (table.tBodies[0].firstChild) {                        table.tBodies[0].removeChild(table.tBodies[0].firstChild);                    }                } else {                    table.tBodies[0].innerHTML = ;                }            };        }    });
     extend plugin scope    $.fn.extend({        tablesorter: $.tablesorter.construct    });
     make shortcut    var ts = $.tablesorter;
     add default parsers    ts.addParser({        id: text,        is: function (s) {            return true;        }, format: function (s) {            return $.trim(s.toLocaleLowerCase());        }, type: text    });
    ts.addParser({        id: digit,        is: function (s, table) {            var c = table.config;            return $.tablesorter.isDigit(s, c);        }, format: function (s) {            return $.tablesorter.formatFloat(s);        }, type: numeric    });
    ts.addParser({        id: currency,        is: function (s) {            return .test(s);        }, format: function (s) {            return $.tablesorter.formatFloat(s.replace(new RegExp(g), ));        }, type: numeric    });
    ts.addParser({        id: ipAddress,        is: function (s) {            return .test(s);        }, format: function (s) {            var a = s.split(.),                r = ,                l = a.length;            for (var i = 0; i < l; i++) {                var item = a[i];                if (item.length == 2) {                    r += 0 + item;                } else {                    r += item;                }            }            return $.tablesorter.formatFloat(r);        }, type: numeric    });
    ts.addParser({        id: url,        is: function (s) {            return (httpsftpfile):.test(s);        }, format: function (s) {            return jQuery.trim(s.replace(new RegExp((httpsftpfile):), ));        }, type: text    });
    ts.addParser({        id: isoDate,        is: function (s) {            return .test(s);        }, format: function (s) {            return $.tablesorter.formatFloat((s != ) ? new Date(s.replace(            new RegExp(-g), /)).getTime() : 0);        }, type: numeric    });
    ts.addParser({        id: percent,        is: function (s) {            return .test($.trim(s));        }, format: function (s) {            return $.tablesorter.formatFloat(s.replace(new RegExp(%g), ));        }, type: numeric    });
    ts.addParser({        id: usLongDate,        is: function (s) {            return s.match(new RegExp( , (') ((:)(:(AMPM)))));        }, format: function (s) {            return $.tablesorter.formatFloat(new Date(s).getTime());        }, type: numeric    });
    ts.addParser({        id: shortDate,        is: function (s) {            return .test(s);        }, format: function (s, table) {            var c = table.config;            s = s.replace(g, /);            if (c.dateFormat == us) {                 reformat the string in ISO format                s = s.replace(()()(), $3/$1/$2);            }                if (c.dateFormat == pt) {                s = s.replace(()()(), $3/$2/$1);               } else if (c.dateFormat == uk) {                 reformat the string in ISO format                s = s.replace(()()(), $3/$2/$1);            } else if (c.dateFormat == dd/mm/yy || c.dateFormat == dd-mm-yy) {                s = s.replace(()()(), $1/$2/$3);            }            return $.tablesorter.formatFloat(new Date(s).getTime());        }, type: numeric    });    ts.addParser({        id: time,        is: function (s) {            return ((:)(:(ampm))).test(s);        }, format: function (s) {            return $.tablesorter.formatFloat(new Date(2000/01/01  + s).getTime());        }, type: numeric    });    ts.addParser({        id: metadata,        is: function (s) {            return false;        }, format: function (s, table, cell) {            var c = table.config,                p = (!c.parserMetadataName) ? sortValue : c.parserMetadataName;            return $(cell).metadata()[p];        }, type: numeric    });     add default widgets    ts.addWidget({        id: zebra,        format: function (table) {            if (table.config.debug) {                var time = new Date();            }            var $tr, row = -1,                odd;             loop through the visible rows            $(tr:visible, table.tBodies[0]).each(function (i) {                $tr = $(this);                 style children rows the same way the parent                 row was styled                if (!$tr.hasClass(table.config.cssChildRow)) row++;                odd = (row % 2 == 0);                $tr.removeClass(                table.config.widgetZebra.css[odd ? 0 : 1]).addClass(                table.config.widgetZebra.css[odd ? 1 : 0])            });            if (table.config.debug) {                $.tablesorter.benchmark(Applying Zebra widget, time);            }        }    });})(jQuery);"
"/* * Metadata - jQuery plugin for parsing metadata from elements * * Copyright (c) 2006 John Resig, Yehuda Katz, J�örn Zaefferer, Paul McLanahan * * Dual licensed under the MIT and GPL licenses: *   http://www.opensource.org/licenses/mit-license.php *   http://www.gnu.org/licenses/gpl.html * * Revision: $Id$ * */
/** * Sets the type of metadata to use. Metadata is encoded in JSON, and each property * in the JSON will become a property of the element itself. * * There are three supported types of metadata storage: * *   attr:  Inside an attribute. The name parameter indicates *which* attribute. *           *   class: Inside the class attribute, wrapped in curly braces: { } *    *   elem:  Inside a child element (e.g. a script tag). The *          name parameter indicates *which* element. *           * The metadata for an element is loaded the first time the element is accessed via jQuery. * * As a result, you can define the metadata type, use $(expr) to load the metadata into the elements * matched by expr, then redefine the metadata type and run another $(expr) for other elements. *  *   * *   * @before $.metadata.setType(""class"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from the class attribute *  *   * @before $.metadata.setType(""attr"", ""data"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from a ""data"" attribute *  *   * @before $.metadata.setType(""elem"", ""script"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from a nested script element *  *   type The encoding type *   name The name of the attribute to be used to get metadata (optional) * @cat Plugins/Metadata * @descr Sets the type of encoding to be used when loading metadata for the first time *  undefined *   */
(function($) {
$.extend({	metadata : {		defaults : {			type: class,			name: metadata,			cre: ({}),			single: metadata		},		setType: function( type, name ){			this.defaults.type = type;			this.defaults.name = name;		},		get: function( elem, opts ){			var settings = $.extend({},this.defaults,opts);			 check for empty string in single property			if ( !settings.single.length ) settings.single = metadata;						var data = $.data(elem, settings.single);			 returned cached data if it already exists			if ( data ) return data;						data = {};						if ( settings.type == class ) {				var m = settings.cre.exec( elem.className );				if ( m )					data = m[1];			} else if ( settings.type == elem ) {				if( !elem.getElementsByTagName )					return undefined;				var e = elem.getElementsByTagName(settings.name);				if ( e.length )					data = $.trim(e[0].innerHTML);			} else if ( elem.getAttribute != undefined ) {				var attr = elem.getAttribute( settings.name );				if ( attr )					data = attr;			}						if ( data.indexOf( { ) <0 )			data = { + data + };						data = eval(( + data + ));						$.data( elem, settings.single, data );			return data;		}	}});
/** * Returns the metadata object for the first member of the jQuery object. * *   * @descr Returns element's metadata object *   opts An object contianing settings to override the defaults *  jQuery * @cat Plugins/Metadata */$.fn.metadata = function( opts ){	return $.metadata.get( this[0], opts );};
})(jQuery);"
"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll(left)}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:""script""}):c.globalEval(b.text||b.textContent||b.innerHTML||"""");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b===""object""){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,""events"");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type===""click"")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"""")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType===mouseenter||i.preType===mouseleave)f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return""live.""+(a&&a!==""*""?a+""."":"""")+b.replace(/\./g,""`"").replace(/ /g,&)}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]===""string""&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return""scrollTo""in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,Wa=(00A0)(00A0)g,Xa=<()>(?:<>),P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a===body&&!b){this.context=s;this[0]=s.body;this.selector=body;this.length=1;return this}if(typeof a===string)if((d=Ta.exec(a))&&(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:,jquery:1.4.2,length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===find)f.selector=this.selector+(this.selector? :)+d;else if(b)f.selector=this.selector+.+b+(+d+);return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),slice,R.call(arguments).join(,))},map:function(a){return this.pushStack(c.map(this,function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a===boolean){f=a;a=arguments[1]||{};b=2}if(typeof a!==object&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler(ready)}},bindReady:function(){if(!xa){xa=true;if(s.readyState===complete)return c.ready();if(s.addEventListener){s.addEventListener(DOMContentLoaded,L,false);A.addEventListener(load,c.ready,false)}else if(s.attachEvent){s.attachEvent(onreadystatechange,L);A.attachEvent(onload,c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)===[object Function]},isArray:function(a){return $.call(a)===[object Array]},isPlainObject:function(a){if(!a||$.call(a)!==[object Object]||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,constructor)&&!aa.call(a.constructor.prototype,isPrototypeOf))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!==string||!a)return null;a=c.trim(a);if(.test(a.replace((?:u)g,@).replace(""""truefalsenull-(?:)(?:)g,]).replace((?::,)(?:)g,)))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function(return +a))();else c.error(Invalid JSON: +a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName(head)[0]||s.documentElement,d=s.createElement(script);d.type=text/javascript;if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||).replace(Wa,)},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a===string||c.isFunction(a)||typeof a!==function&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length===number)for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b===string){d=a;a=d[b];b=w}else if(b&&!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=(webkit)().exec(a)||(opera)(?:version)().exec(a)||(msie) ().exec(a)||!compatible.test(a)&&(mozilla)(?: rv:()).exec(a)||[];return{browser:a[1]||,version:a[2]||0}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener(DOMContentLoaded,L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState===complete){s.detachEvent(onreadystatechange,L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement(script),d=s.createElement(div),f=script+J();d.style.display=none;d.innerHTML=   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>;var e=d.getElementsByTagName(*),j=d.getElementsByTagName(a)[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName(tbody).length,htmlSerialize:!!d.getElementsByTagName(link).length,style:red.test(j.getAttribute(style)),hrefNormalized:j.getAttribute(href)===/a,opacity:055.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName(input)[0].value===on,optSelected:s.createElement(select).appendChild(s.createElement(option)).selected,parentNode:d.removeChild(d.appendChild(s.createElement(div))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type=text/javascript;try{b.appendChild(s.createTextNode(window.+f+=1;))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent(onclick,function k(){c.support.noCloneEvent=false;d.detachEvent(onclick,k)});d.cloneNode(true).fireEvent(onclick)}d=s.createElement(div);d.innerHTML=<input type='radio' name='radiotest' checked='checked'/>;a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement(div);k.style.width=k.style.paddingLeft=1px;s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display=none});a=function(k){var n=s.createElement(div);k=on+k;var r=k in n;if(!r){n.setAttribute(k,return;);r=typeof n[k]===function}return r};c.support.submitBubbles=a(submit);c.support.changeBubbles=a(change);a=b=d=e=j=null}})();c.props={for:htmlFor,class:className,readonly:readOnly,maxlength:maxLength,cellspacing:cellSpacing,rowspan:rowSpan,colspan:colSpan,tabindex:tabIndex,usemap:useMap,frameborder:frameBorder};var G=jQuery+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b===string&&d===w)return null;f||(f=++Ya);if(typeof b===object){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b===string?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a===undefined&&this.length)return c.data(this[0]);else if(typeof a===object)return this.each(function(){c.data(this,a)});var d=a.split(.);d[1]=d[1]?.+d[1]:;if(b===w){var f=this.triggerHandler(getData+d[1]+!,[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger(setData+d[1]+!,[d[0],b]).each(function(){c.data(this,a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||fx)+queue;var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||fx;var d=c.queue(a,b),f=d.shift();if(f===inprogress)f=d.shift();if(f){b===fx&&d.unshift(inprogress);f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!==string){b=a;a=fx}if(b===w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a===fx&&d[0]!==inprogress&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||fx;return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||fx,[])}});var Aa=g,ca=,Za=g,$a=hrefsrcstyle,ab=(buttoninput)i,bb=(buttoninputobjectselecttextarea)i,cb=(aarea)i,Ba=radiocheckbox;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,);this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr(class)))});if(a&&typeof a===string)for(var b=(a||).split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j= +e.className+ ,i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf( +b[o]+ )<0)i+= +b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr(class)))});if(a&&typeof a===string||a===w)for(var b=(a||).split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=( +e.className+ ).replace(Aa, ),i=0,o=b.length;i<o;i++)j=j.replace( +b[i]+ , );e.className=c.trim(j)}else e.className=}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b===boolean;if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr(class),b),b)});return this.each(function(){if(d===string)for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?addClass:removeClass](e)}else if(d===undefined||d===boolean){this.className&&c.data(this,__className__,this.className);this.className=this.className||a===false?:c.data(this,__className__)||}})},hasClass:function(a){a= +a+ ;for(var b=0,d=this.length;b<d;b++)if(( +this[b].className+ ).replace(Aa, ).indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,option))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,select)){var d=b.selectedIndex,f=[],e=b.options;b=b.type===select-one;if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute(value)===null?on:b.value;return(b.value||).replace(Za,)}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r===number)r+=;if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,select)){var u=c.makeArray(r);c(option,this).each(function(){this.selected=c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b===type&&ab.test(a.nodeName)&&a.parentNode&&c.error(type property can't be changed);a[b]=d}if(c.nodeName(a,form)&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b===tabIndex)return(b=a.getAttributeNode(tabIndex))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b===style){if(e)a.style.cssText=+d;return a.style.cssText}e&&a.setAttribute(b,+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=(),db=function(a){return a.replace(g,function(b){return+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!==undefined&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split( );for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(.)>-1){r=k.split(.);k=r.shift();j.namespace=r.slice(0).sort().join(.)}else{r=[];j.namespace=}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent(on+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b===string&&b.charAt(0)===.){b=b||;for(e in C)c.event.remove(a,e+b)}else{for(b=b.split( );e=b[j++];){n=e;i=e.indexOf(.)<0;o=[];if(!i){o=e.split(.);e=o.shift();k=new RegExp((^|.)+c.map(o.slice(0).sort(),db).join(.(?:.*.)?)+(.|$))}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a===object?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf(!)>=0){a.type=e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,handle))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d[on+e]&&d[on+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,a)&&e===click,k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f[on+e])f[on+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f[on+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(.)<0&&!a.exclusive;if(!b){d=a.type.split(.);a.type=d.shift();f=new RegExp((^|.)+d.slice(0).sort().join(.(?:.*.)?)+(.|$))}e=c.data(this,events);d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which.split( ),fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,);c.each(c.data(this,events).live||[],function(){if(d===this.origType.replace(O,))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent(on+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:mouseover,mouseleave:mouseout},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==form){c.event.add(this,click.specialSubmit,function(a){var b=a.target,d=b.type;if((d===submit||d===image)&&c(b).closest(form).length)return na(submit,this,arguments)});c.event.add(this,keypress.specialSubmit,function(a){var b=a.target,d=b.type;if((d===text||d===password)&&c(b).closest(form).length&&a.keyCode===13)return na(submit,this,arguments)})}else return false},teardown:function(){c.event.remove(this,.specialSubmit)}};if(!c.support.changeBubbles){var da=textareainputselecti,ea,Fa=function(a){var b=a.type,d=a.value;if(b===radio||b===checkbox)d=a.checked;else if(b===select-multiple)d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join(-):;else if(a.nodeName.toLowerCase()===select)d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,_change_data);e=Fa(d);if(a.type!==focusout||d.type!==radio)c.data(d,_change_data,e);if(!(f===w||e===f))if(f!=null||e){a.type=change;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d===radio||d===checkbox||b.nodeName.toLowerCase()===select)return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!==textarea||a.keyCode===32&&(d===checkbox||d===radio)||d===select-multiple)return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,_change_data,Fa(a))}},setup:function(){if(this.type===file)return false;for(var a in ea)c.event.add(this,a+.specialChange,ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,.specialChange);return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:focusin,blur:focusout},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each([bind,one],function(a,b){c.fn[b]=function(d,f,e){if(typeof d===object){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b===one?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d===unload&&b!==one)this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a===object&&!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind(live):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,lastToggle+a.guid)||0)%d;c.data(this,lastToggle+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:focusin,blur:focusout,mouseenter:mouseover,mouseleave:mouseout};c.each([live,die],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||).split( );(i=d[o++])!=null;){j=O.exec(i);k=;if(j){k=j[0];i=i.replace(O,)}if(i===hover)d.push(mouseenter+k,mouseleave+k);else{n=i;if(i===focus||i===blur){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b===live?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each(blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error.split( ),function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent(onunload,function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h=,l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!==""string""){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['""][^'""]*['""]|[^[\]'""]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!==string)return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]===~||p[0]===+)&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D=;if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||g);if(j.call(y)===[object Array])if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!==){q[1]=(q[1]||).replace(g,);m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],);break}}}}m||(m=h.getElementsByTagName(*));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-1)!==){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],);if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throwSyntax error, unrecognized expression: +g;};var n=k.selectors={order:[ID,NAME,TAG],match:{ID:#((?:)),CLASS:((?:)),NAME:name=((?:)),ATTR:((?:))(?:(=)()()),TAG:((?:)),CHILD::(onlynthlastfirst)-child(?:(evenodd)),POS::(ntheqgtltfirstlastevenodd)(?:())(?=),PSEUDO::((?:))(?:()((?:)))},leftMatch:{},attrMap:{class:className,for:htmlFor},attrHandle:{href:function(g){return g.getAttribute(href)}},relative:{:function(g,h){var l=typeof h===string,m=l&&!.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},:function(g,h){var l=typeof h===string;if(l&&!.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},:function(g,h,l){var m=e++,q=d;if(typeof h===string&&!.test(h)){var p=h=h.toLowerCase();q=b}q(parentNode,h,m,g,p,l)},:function(g,h,l){var m=e++,q=d;if(typeof h===string&&!.test(h)){var p=h=h.toLowerCase();q=b}q(previousSibling,h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!==undefined&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!==undefined){var l=[];h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute(name)===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g= +g[1].replace(g,)+ ;if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&( +v.className+ ).replace(g, ).indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(g,)},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]===nth){var h=(-)()n((?:-)).exec(g[2]===even&&2n||g[2]===odd&&2n+1||!.test(g[2])&&0n++g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(g,);if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]===~=)g[4]= +g[4]+ ;return g},PSEUDO:function(g,h,l,m,q){if(g[1]===not)if((f.exec(g[3])||).length>1||.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!==hidden},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){returnhi.test(g.nodeName)},text:function(g){returntext===g.type},radio:function(g){returnradio===g.type},checkbox:function(g){returncheckbox===g.type},file:function(g){returnfile===g.type},password:function(g){returnpassword===g.type},submit:function(g){returnsubmit===g.type},image:function(g){returnimage===g.type},reset:function(g){returnreset===g.type},button:function(g){returnbutton===g.type||g.nodeName.toLowerCase()===button},input:function(g){returninputselecttextareabuttoni.test(g.nodeName)}},setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q===contains)return(g.textContent||g.innerText||a([g])||).indexOf(h[3])>=0;else if(q===not){h=h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error(Syntax error, unrecognized expression: +q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case only:case first:for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l===first)return true;m=g;case last:for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case nth:l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute(id)===h},TAG:function(g,h){return h===*&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return( +(g.className||g.getAttribute(class))+ ).indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+;var m=h[2];h=h[4];return g==null?m===!=:m====?l===h:m===*=?l.indexOf(h)>=0:m===~=?( +l+ ).indexOf(h)>=0:!h?l&&g!==false:m===!=?l!==h:m===^=?l.indexOf(h)===0:m===$=?l.substr(l.length-h.length)===h:m===|=?l===h||l.substr(0,h.length+1)===h+-:false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+(?!)(?!).source);n.leftMatch[u]=new RegExp(((?:)).source+n.match[u].source.replace(()g,function(g,h){return+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)===[object Array])Array.prototype.push.apply(h,g);else if(typeof g.length===number)for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if(sourceIndexin s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement(div),h=script+(new Date).getTime();g.innerHTML=<a name='+h+'/>;var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!==undefined&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!==undefined&&q.getAttributeNode(id).nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!==undefined&&m.getAttributeNode(id);return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement(div);g.appendChild(s.createComment());if(g.getElementsByTagName(*).length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]===*){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML=<a href='#'></a>;if(g.firstChild&&typeof g.firstChild.getAttribute!==undefined&&g.firstChild.getAttribute(href)!==#)n.attrHandle.href=function(h){return h.getAttribute(href,2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement(div);h.innerHTML=<p class='TEST'></p>;if(!(h.querySelectorAll&&h.querySelectorAll(.TEST).length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();(function(){var g=s.createElement(div);g.innerHTML=<div class='test e'></div><div class='test'></div>;if(!(!g.getElementsByClassName||g.getElementsByClassName(e).length===0)){g.lastChild.className=e;if(g.getElementsByClassName(e).length!==1){n.order.splice(1,0,CLASS);n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!==undefined&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!==HTML:false},ga=function(g,h){var l=[],m=,q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,)}g=n.relative[g]?g+*:g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[:]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=Until,fb=(?:parentsprevUntilprevAll),gb=,;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b===string){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack(,find,a),d=0,f=0,e=this.length;f<e;f++){d=b.length;c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),not,a)},filter:function(a){return this.pushStack(Ia(this,a,true),filter,a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j={},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===string)return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a===string?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,parentNode)},parentsUntil:function(a,b,d){return c.dir(a,parentNode,d)},next:function(a){return c.nth(a,2,nextSibling)},prev:function(a){return c.nth(a,2,previousSibling)},nextAll:function(a){return c.dir(a,nextSibling)},prevAll:function(a){return c.dir(a,previousSibling)},nextUntil:function(a,b,d){return c.dir(a,nextSibling,d)},prevUntil:function(a,b,d){return c.dir(a,previousSibling,d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,iframe)?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f===string)e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(,))}});c.extend({filter:function(a,b,d){if(d)a=:not(+a+);return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja= jQuery=""(?:null)""g,V=,Ka=(<())>g,hb=(?:areabrcolembedhrimginputlinkmetaparam)i,La=<(),ib=<tbodyi,jb=<&#;,ta=<script<object<embed<option<stylei,ua=checked(?:=checked)i,Ma=function(a,b,d){return hb.test(d)?a:b+></+d+>},F={option:[1,<select multiple='multiple'>,</select>],legend:[1,<fieldset>,</fieldset>],thead:[1,<table>,</table>],tr:[2,<table><tbody>,</tbody></table>],td:[3,<table><tbody><tr>,</tr></tbody></table>],col:[2,<table><tbody></tbody><colgroup>,</colgroup></table>],area:[1,<map>,</map>],_default:[0,,]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,div<div>,</div>];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=c(this);d.text(a.call(this,b,d.text()))});if(typeof a!==object&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,body)||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,before,arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,after,arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName(*));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName(*));b.firstChild;)b.removeChild(b.firstChild);return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement(div);d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,).replace(=()>g,=""$1"">).replace(V,)],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find(*),b.find(*))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,):null;else if(typeof a===string&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||[,])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName(*));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!==string)a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),replaceWith,a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,table)?u.getElementsByTagName(tbody)[0]||u.appendChild(u.ownerDocument.createElement(tbody)):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i===string&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,tr);for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:append,prependTo:prepend,insertBefore:before,insertAfter:after,replaceAll:replaceWith},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement===undefined)b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i===number)i+=;if(i){if(typeof i===string&&!jb.test(i))i=b.createTextNode(i);else if(typeof i===string){i=i.replace(Ka,Ma);var o=(La.exec(i)||[,])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement(div);for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o===table&&!n?r.firstChild&&r.firstChild.childNodes:k[1]===<table>&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],tbody)&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],script)&&(!e[j].type||e[j].type.toLowerCase()===text/javascript))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName(script))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=z-indexfont-weightopacityzoomline-heighti,Na=alpha,Oa=opacity=(),ha=floati,ia=-()ig,lb=()g,mb=-(?:px)i,nb=-,ob={position:absolute,visibility:hidden,display:block},pb=[Left,Right],qb=[Top,Bottom],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?cssFloat:styleFloat,ja=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e===number&&!kb.test(f))e+=px;c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b===width||b===height)&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b===opacity){if(e){f.zoom=1;b=parseInt(d,10)+===NaN?:alpha(opacity=+d*100+);a=f.filter||c.curCSS(a,filter)||;f.filter=Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf(opacity=)>=0?parseFloat(Oa.exec(f.filter)[1])/100+:}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b===width||b===height){var e,j=b===width?pb:qb;function i(){e=b===width?a.offsetWidth:a.offsetHeight;f!==border&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,padding+this,true))||0);if(f===margin)e+=parseFloat(c.curCSS(a,margin+this,true))||0;else e-=parseFloat(c.curCSS(a,border+this+Width,true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b===opacity&&a.currentStyle){f=Oa.test(a.currentStyle.filter||)?parseFloat(RegExp.$1)/100+:;return f===?1:f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b=float;b=b.replace(lb,-$1).toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=a.getPropertyValue(b);if(b===opacity&&f===)f=1}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d===fontSize?1em:f||0;f=e.pixelLeft+px;e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()===tr;return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,display)===none};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=<script()script>gi,ub=selecttextareai,vb=colordatedatetimeemailhiddenmonthnumberpasswordrangesearchteltexttimeurlweeki,N==(&),ka=,wb=(&)_=(&),xb=(:)(),yb=%20g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==string)return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf( );if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f=GET;if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===object){b=c.param(b,c.ajaxSettings.traditional);f=POST}var j=this;c.ajax({url:a,type:f,dataType:html,data:b,complete:function(i,o){if(o===success||o===notmodified)j.html(e?c(<div />).append(i.responseText.replace(tb,)).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each(ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend.split( ),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:GET,url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,script)},getJSON:function(a,b,d){return c.get(a,b,d,json)},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:POST,url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:GET,contentType:application/x-www-form-urlencoded,processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!==file:||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject(Microsoft.XMLHTTP)}catch(a){}},accepts:{xml:application/xml, text/xml,html:text/html,script:text/javascript, application/javascript,json:application/json, text/javascript,text:text/plain,_default:*/*}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&e.success.call(k,o,i,x);e.global&&f(ajaxSuccess,[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f(""ajaxComplete"",[x,e]);e.global&&!--c.active&&c.event.trigger(""ajaxStop"")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!==""string"")e.data=c.param(e.data,e.traditional);if(e.dataType===""jsonp""){if(n===""GET"")N.test(e.url)||(e.url+=(ka.test(e.url)?&:?)+(e.jsonp||callback)+=?);else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+&:)+(e.jsonp||callback)+=?;e.dataType=json}if(e.dataType===json&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||jsonp+sb++;if(e.data)e.data=(e.data+).replace(N,=+j+$1);e.url=e.url.replace(N,=+j+$1);e.dataType=script;A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType===script&&e.cache===null)e.cache=false;if(e.cache===false&&n===GET){var r=J(),u=e.url.replace(wb,$1_=+r+$2);e.url=u+(u===e.url?(ka.test(e.url)?&:?)+_=+r:)}if(e.data&&n===GET)e.url+=(ka.test(e.url)?&:?)+e.data;e.global&&!c.active++&&c.event.trigger(ajaxStart);r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType===script&&n===GET&&r){var z=s.getElementsByTagName(head)[0]||s.documentElement,C=s.createElement(script);C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState===loaded||this.readyState===complete)){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader(Content-Type,e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader(If-Modified-Since,c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader(If-None-Match,c.etag[e.url])}r||x.setRequestHeader(X-Requested-With,XMLHttpRequest);x.setRequestHeader(Accept,e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+, */*:e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger(ajaxStop);x.abort();return false}e.global&&f(ajaxSend,[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q===abort){E||d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q===timeout)){E=true;x.onreadystatechange=c.noop;i=q===timeout?timeout:!c.httpSuccess(x)?error:e.ifModified&&c.httpNotModified(x,e.url)?notmodified:success;var p;if(i===success)try{o=c.httpData(x,e.dataType,e)}catch(v){i=parsererror;p=v}if(i===success||i===notmodified)j||b();else c.handleError(e,x,i,p);d();q===timeout&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);g(abort)}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g(timeout)},e.timeout);try{x.send(n===POST||n===PUT||n===DELETE?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger(ajaxError,[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol===file:||a.status>=200&&a.status<300||a.status===304||a.status===1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader(Last-Modified),f=a.getResponseHeader(Etag);if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader(content-type)||,e=b===xml||!b&&f.indexOf(xml)>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName===parsererror&&c.error(parsererror);if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a===string)if(b===json||!b&&f.indexOf(json)>=0)a=c.parseJSON(a);else if(b===script||!b&&f.indexOf(javascript)>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||.test(i)?f(i,n):d(i+[+(typeof n===object||c.isArray(n)?k:)+],n)});else!b&&o!=null&&typeof o===object?c.each(o,function(k,n){d(i+[+k+],n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+""=""+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join(&).replace(yb,+)}});var la={},Ab=toggleshowhide,Bb=(=)()(),W,va=[[height,marginTop,marginBottom,paddingTop,paddingBottom],[width,marginLeft,marginRight,paddingLeft,paddingRight],[opacity]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K(show,3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],olddisplay);this[a].style.display=d||;if(c.css(this[a],display)===none){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c(<+d+ />).appendTo(body);f=e.css(display);if(f===none)f=block;e.remove();la[d]=f}c.data(this[a],olddisplay,f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],olddisplay)||;return this}},hide:function(a,b){if(a||a===0)return this.animate(K(hide,3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],olddisplay);!d&&d!==none&&c.data(this[a],olddisplay,c.css(this[a],display))}a=0;for(b=this.length;a<b;a++)this[a].style.display=none;return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a===boolean;if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(:hidden);c(this)[f?show:hide]()}):this.animate(K(toggle,3),a,b);return this},fadeTo:function(a,b,d){return this.filter(:hidden).css(opacity,0).show().end().animate({opacity:b},a,d)},animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?each:queue](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(:hidden),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]===hide&&o||a[i]===show&&!o)return j.complete.call(this);if((i===height||i===width)&&this.style){j.display=c.css(this,display);j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow=hidden;j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u===toggle?o?show:hide:u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||px;if(E!==px){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]===-=?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,)}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K(show,1),slideUp:K(hide,1),slideToggle:K(toggle,1),fadeIn:{opacity:show},fadeOut:{opacity:hide}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a===object?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===number?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this);if((this.prop===height||this.prop===width)&&this.elem.style)this.elem.style.display=block},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||px;this.now=this.start;this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop===width||this.prop===height?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,olddisplay);this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,display)===none)this.elem.style.display=block}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?swing:linear);this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,opacity,a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop===width||a.prop===height?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset=getBoundingClientRectin s.documentElement?function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position===fixed)break;j=e?e.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&t(abledh)i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!==visible){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position===relative||f.position===static){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&f.position===fixed){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement(div),d,f,e,j=parseFloat(c.curCSS(a,marginTop,true))||0;c.extend(b.style,{position:absolute,top:0,left:0,margin:0,border:0,width:1px,height:1px,visibility:hidden});b.innerHTML=<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>;a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position=fixed;f.style.top=20px;this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top=;d.style.overflow=hidden;d.style.position=relative;this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,marginTop,true))||0;d+=parseFloat(c.curCSS(a,marginLeft,true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(static.test(c.curCSS(a,position)))a.style.position=relative;var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,top,true),10)||0,i=parseInt(c.curCSS(a,left,true),10)||0;if(c.isFunction(b))b=b.call(a,d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};usingin b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=bodyhtmli.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,marginTop,true))||0;d.left-=parseFloat(c.curCSS(a,marginLeft,true))||0;f.top+=parseFloat(c.curCSS(b[0],borderTopWidth,true))||0;f.left+=parseFloat(c.curCSS(b[0],borderLeftWidth,true))||0;return{top:d.top-f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!bodyhtmli.test(a.nodeName)&&c.css(a,position)===static;)a=a.offsetParent;return a})}});c.each([Left,Top],function(a,b){var d=scroll+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?pageXOffsetin j?j[a?pageYOffset:pageXOffset]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each([Height,Width],function(a,b){var d=b.toLowerCase();c.fn[inner+b]=function(){return this[0]?c.css(this[0],d,false,padding):null};c.fn[outer+b]=function(f){return this[0]?c.css(this[0],d,false,f?margin:border):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});returnscrollToine&&e.document?e.document.compatMode===CSS1Compat&&e.document.documentElement[client+b]||e.document.body[client+b]:e.nodeType===9?Math.max(e.documentElement[client+b],e.body[scroll+b],e.documentElement[scroll+b],e.body[offset+b],e.documentElement[offset+b]):f===w?c.css(e,d):this.css(d,typeof f===string?f:f+px)}});A.jQuery=A.$=c})(window);"
"/* * jQuery UI Nested Sortable * v 1.3.5 / 21 jun 2012 * http://mjsarfatti.com/code/nestedSortable * * Depends on: *	 jquery.ui.sortable.js 1.8+ * * Copyright (c) 2010-2012 Manuele J Sarfatti * Licensed under the MIT License * http://www.opensource.org/licenses/mit-license.php */
(function($) {
	$.widget(mjs.nestedSortable, $.extend({}, $.ui.sortable.prototype, {
		options: {			tabSize: 20,			disableNesting: mjs-nestedSortable-no-nesting,			errorClass: mjs-nestedSortable-error,			doNotClear: false,			listType: ol,			maxLevels: 0,			protectRoot: false,			rootID: null,			rtl: false,			isAllowed: function(item, parent) { return true; }		},
		_create: function() {			this.element.data(sortable, this.element.data(nestedSortable));
			if (!this.element.is(this.options.listType))				throw new Error(nestedSortable: Please check the listType option is set to your actual list type);
			return $.ui.sortable.prototype._create.apply(this, arguments);		},
		destroy: function() {			this.element				.removeData(nestedSortable)				.unbind(.nestedSortable);			return $.ui.sortable.prototype.destroy.apply(this, arguments);		},
		_mouseDrag: function(event) {
			Compute the helpers position			this.position = this._generatePosition(event);			this.positionAbs = this._convertPositionTo(absolute);
			if (!this.lastPositionAbs) {				this.lastPositionAbs = this.positionAbs;			}
			var o = this.options;
			Do scrolling			if(this.options.scroll) {				var scrolled = false;				if(this.scrollParent[0] != document && this.scrollParent[0].tagName != HTML) {
					if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;					else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;					else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				} else {
					if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);					else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);					else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
				if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)					$.ui.ddmanager.prepareOffsets(this, event);			}
			Regenerate the absolute position used for position checks			this.positionAbs = this._convertPositionTo(absolute);
       Find the top offset before rearrangement,      var previousTopOffset = this.placeholder.offset().top;
			Set the helper position			if(!this.options.axis || this.options.axis != y) this.helper[0].style.left = this.position.left+px;			if(!this.options.axis || this.options.axis != x) this.helper[0].style.top = this.position.top+px;
			Rearrange			for (var i = this.items.length - 1; i >= 0; i--) {
				Cache variables and intersection, continue if no intersection				var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);				if (!intersection) continue;
				if(itemElement != this.currentItem[0] cannot intersect with itself					&&	this.placeholder[intersection == 1 ? next : prev]()[0] != itemElement no useless actions that have been done before					&&	!$.contains(this.placeholder[0], itemElement) no action if the item moved is the parent of the item checked					&& (this.options.type == semi-dynamic ? !$.contains(this.element[0], itemElement) : true)					&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container				) {
					$(itemElement).mouseenter();
					this.direction = intersection == 1 ? down : up;
					if (this.options.tolerance == pointer || this._intersectsWithSides(item)) {						$(itemElement).mouseleave();						this._rearrange(event, item);					} else {						break;					}
					 Clear emtpy ul's/ol's					this._clearEmpty(itemElement);
					this._trigger(change, event, this._uiHash());					break;				}			}
			var parentItem = (this.placeholder[0].parentNode.parentNode &&							 $(this.placeholder[0].parentNode.parentNode).closest(.ui-sortable).length)				       			? $(this.placeholder[0].parentNode.parentNode)				       			: null,			    level = this._getLevel(this.placeholder),			    childLevels = this._getChildLevels(this.helper);
       To find the previous sibling in the list, keep backtracking until we hit a valid list item.			var previousItem = this.placeholder[0].previousSibling ? $(this.placeholder[0].previousSibling) : null;			if (previousItem != null) {				while (previousItem[0].nodeName.toLowerCase() != li || previousItem[0] == this.currentItem[0] || previousItem[0] == this.helper[0]) {					if (previousItem[0].previousSibling) {						previousItem = $(previousItem[0].previousSibling);					} else {						previousItem = null;						break;					}				}			}
       To find the next sibling in the list, keep stepping forward until we hit a valid list item.      var nextItem = this.placeholder[0].nextSibling ? $(this.placeholder[0].nextSibling) : null;      if (nextItem != null) {        while (nextItem[0].nodeName.toLowerCase() != li || nextItem[0] == this.currentItem[0] || nextItem[0] == this.helper[0]) {          if (nextItem[0].nextSibling) {            nextItem = $(nextItem[0].nextSibling);          } else {            nextItem = null;            break;          }        }      }
			var newList = document.createElement(o.listType);
			this.beyondMaxLevels = 0;						 If the item is moved to the left, send it to its parent's level unless there are siblings below it.			if (parentItem != null && nextItem == null &&					(o.rtl && (this.positionAbs.left + this.helper.outerWidth() > parentItem.offset().left + parentItem.outerWidth()) ||					!o.rtl && (this.positionAbs.left < parentItem.offset().left))) {				parentItem.after(this.placeholder[0]);				this._clearEmpty(parentItem[0]);				this._trigger(change, event, this._uiHash());			}			 If the item is below a sibling and is moved to the right, make it a child of that sibling.			else if (previousItem != null &&						(o.rtl && (this.positionAbs.left + this.helper.outerWidth() < previousItem.offset().left + previousItem.outerWidth() - o.tabSize) ||						!o.rtl && (this.positionAbs.left > previousItem.offset().left + o.tabSize))) {				this._isAllowed(previousItem, level, level+childLevels+1);				if (!previousItem.children(o.listType).length) {					previousItem[0].appendChild(newList);				}         If this item is being moved from the top, add it to the top of the list.        if (previousTopOffset && (previousTopOffset <= previousItem.offset().top)) {          previousItem.children(o.listType).prepend(this.placeholder);        }         Otherwise, add it to the bottom of the list.        else {				  previousItem.children(o.listType)[0].appendChild(this.placeholder[0]);        }				this._trigger(change, event, this._uiHash());			}			else {				this._isAllowed(parentItem, level, level+childLevels);			}
			Post events to containers			this._contactContainers(event);
			Interconnect with droppables			if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);
			Call callbacks			this._trigger(sort, event, this._uiHash());
			this.lastPositionAbs = this.positionAbs;			return false;
		},
		_mouseStop: function(event, noPropagation) {
			 If the item is in a position not allowed, send it back			if (this.beyondMaxLevels) {
				this.placeholder.removeClass(this.options.errorClass);
				if (this.domPosition.prev) {					$(this.domPosition.prev).after(this.placeholder);				} else {					$(this.domPosition.parent).prepend(this.placeholder);				}
				this._trigger(revert, event, this._uiHash());
			}
			 Clean last empty ul/ol			for (var i = this.items.length - 1; i >= 0; i--) {				var item = this.items[i].item[0];				this._clearEmpty(item);			}
			$.ui.sortable.prototype._mouseStop.apply(this, arguments);
		},
		serialize: function(options) {
			var o = $.extend({}, this.options, options),				items = this._getItemsAsjQuery(o && o.connected),			    str = [];
			$(items).each(function() {				var res = ($(o.item || this).attr(o.attribute || id) || )						.match(o.expression || (()())),				    pid = ($(o.item || this).parent(o.listType)						.parent(o.items)						.attr(o.attribute || id) || )						.match(o.expression || (()()));
				if (res) {					str.push(((o.key || res[1]) + [ + (o.key && o.expression ? res[1] : res[2]) + ])						+ =						+ (pid ? (o.key && o.expression ? pid[1] : pid[2]) : o.rootID));				}			});
			if(!str.length && o.key) {				str.push(o.key + =);			}
			return str.join(&);
		},
		toHierarchy: function(options) {
			var o = $.extend({}, this.options, options),				sDepth = o.startDepthCount || 0,			    ret = [];
			$(this.element).children(o.items).each(function () {				var level = _recursiveItems(this);				ret.push(level);			});
			return ret;
			function _recursiveItems(item) {				var id = ($(item).attr(o.attribute || id) || ).match(o.expression || (()()));				if (id) {					var currentItem = {id : id[2]};					if ($(item).children(o.listType).children(o.items).length > 0) {						currentItem.children = [];						$(item).children(o.listType).children(o.items).each(function() {							var level = _recursiveItems(this);							currentItem.children.push(level);						});					}					return currentItem;				}			}		},
		toArray: function(options) {
			var o = $.extend({}, this.options, options),				sDepth = o.startDepthCount || 0,			    ret = [],			    left = 2;
			ret.push({				item_id: o.rootID,				parent_id: none,				depth: sDepth,				left: 1,				right: ($(o.items, this.element).length + 1) * 2			});
			$(this.element).children(o.items).each(function () {				left = _recursiveArray(this, sDepth + 1, left);			});
			ret = ret.sort(function(a,b){ return (a.left - b.left); });
			return ret;
			function _recursiveArray(item, depth, left) {
				var right = left + 1,				    id,				    pid;
				if ($(item).children(o.listType).children(o.items).length > 0) {					depth ++;					$(item).children(o.listType).children(o.items).each(function () {						right = _recursiveArray($(this), depth, right);					});					depth --;				}
				id = ($(item).attr(o.attribute || id)).match(o.expression || (()()));
				if (depth === sDepth + 1) {					pid = o.rootID;				} else {					var parentItem = ($(item).parent(o.listType)											 .parent(o.items)											 .attr(o.attribute || id))											 .match(o.expression || (()()));					pid = parentItem[2];				}
				if (id) {						ret.push({item_id: id[2], parent_id: pid, depth: depth, left: left, right: right});				}
				left = right + 1;				return left;			}
		},
		_clearEmpty: function(item) {
			var emptyList = $(item).children(this.options.listType);			if (emptyList.length && !emptyList.children().length && !this.options.doNotClear) {				emptyList.remove();			}
		},
		_getLevel: function(item) {
			var level = 1;
			if (this.options.listType) {				var list = item.closest(this.options.listType);				while (list && list.length > 0 &&                     	!list.is(.ui-sortable)) {					level++;					list = list.parent().closest(this.options.listType);				}			}
			return level;		},
		_getChildLevels: function(parent, depth) {			var self = this,			    o = this.options,			    result = 0;			depth = depth || 0;
			$(parent).children(o.listType).children(o.items).each(function (index, child) {					result = Math.max(self._getChildLevels(child, depth + 1), result);			});
			return depth ? result + 1 : result;		},
		_isAllowed: function(parentItem, level, levels) {			var o = this.options,				isRoot = $(this.domPosition.parent).hasClass(ui-sortable) ? true : false,				maxLevels = this.placeholder.closest(.ui-sortable).nestedSortable(option, maxLevels);  this takes into account the maxLevels set to the recipient list
			 Is the root protected?			 Are we trying to nest under a no-nest?			 Are we nesting too deep?			if (!o.isAllowed(this.currentItem, parentItem) ||				parentItem && parentItem.hasClass(o.disableNesting) ||				o.protectRoot && (parentItem == null && !isRoot || isRoot && level > 1)) {					this.placeholder.addClass(o.errorClass);					if (maxLevels < levels && maxLevels != 0) {						this.beyondMaxLevels = levels - maxLevels;					} else {						this.beyondMaxLevels = 1;					}			} else {				if (maxLevels < levels && maxLevels != 0) {					this.placeholder.addClass(o.errorClass);					this.beyondMaxLevels = levels - maxLevels;				} else {					this.placeholder.removeClass(o.errorClass);					this.beyondMaxLevels = 0;				}			}		}
	}));
	$.mjs.nestedSortable.prototype.options = $.extend({}, $.ui.sortable.prototype.options, $.mjs.nestedSortable.prototype.options);})(jQuery);"
"const gulp = require(gulp);
gulp.task(scripts, require(./gulp/tasks/scripts));gulp.task(set-watching, require(./gulp/tasks/set-watching));gulp.task(css, require(./gulp/tasks/css));gulp.task(jekyll, require(./gulp/tasks/jekyll));gulp.task(test, require(./gulp/tasks/test));
gulp.task(watch, gulp.series(  set-watching,  gulp.parallel(css, scripts),  jekyll));
gulp.task(default, gulp.series(scripts, test));"
"module.exports = {  extends: @odopod,};
"
"module.exports = function (config) {  use strict;
  var cfg = {    bowerComponents: demo/bower_components  };
  config.set({    basePath: ,    frameworks: [jasmine],
     files to load in the browser    files: [       components      cfg.bowerComponents + /angular/angular.js,      cfg.bowerComponents + /angular-mocks/angular-mocks.js,
       source files      source/**/*main.js,      source/**/*.js,
       tests      test/**/*.spec.js    ],
     generate js files from html templates to expose them during testing    preprocessors: {      **/*.html: ng-html2js    },
     https://github.com/karma-runner/karma-ng-html2js-preprocessor#configuration    ngHtml2JsPreprocessor: {       setting this option will create only a single module that contains templates       from all the files, so you can load them all with module('foo')    },
     files to exclude    exclude: [],
     level of logging     possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG    logLevel: config.LOG_INFO,
    port: 9876,    reporters: dots  });};"
"/* jshint node:true */
use strict;
var fs = require(fs);var path = require(path);
module.exports = function() {  var wiredep = require(wiredep);
  var bower_dependencies = wiredep({ cwd: __dirname });
  var js_dependencies = []    .concat(bower_dependencies.packages[jquery].main)    .concat(bower_dependencies.packages[jquery-ui].main)    .map(function(p) {      return p.replace(path.join(__dirname, /), );    });
  var css_dependencies = [    bower_components/jquery-ui/themes/smoothness/jquery-ui.css  ];
  function putThemInVendorDir (filepath) {    return vendor/ + path.basename(filepath);  }
  return {    humaName : UI.Sortable,    repoName : ui-sortable,    inlineHTML : fs.readFileSync(__dirname + /demo/demo.html),    inlineJS : fs.readFileSync(__dirname + /demo/demo.js),    css: css_dependencies.map(putThemInVendorDir).concat([demo/demo.css]),    js : function(defaultJsFiles){       HACK TO LOAD JQUERY BEFORE ANGULAR      return [vendor/jquery.js].concat(defaultJsFiles, js_dependencies.slice(1).map(putThemInVendorDir).concat([dist/sortable.js]));    },    bowerData: { main : ./sortable.js },    tocopy : css_dependencies.concat(js_dependencies)  };};"
"/** * angular-drag-and-drop-lists v2.1.0 * * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc * Copyright (c) 2014-2017 Google Inc. * https://github.com/marceljuenemann/angular-drag-and-drop-lists * * License: MIT */!function(e){function n(e,n){returnall==n?e:e.filter(function(e){return-1!=n.toLowerCase().indexOf(e)})}var a=application/x-dnd,r=application/json,t=Text,d=[move,copy,link]e.directive(dndDraggable,[$parse,$timeout,function(e,i){return function(l,f,c){f.attr(draggable,true),c.dndDisableIf&&l.$watch(c.dndDisableIf,function(e){f.attr(draggable,!e)}),f.on(dragstart,function(s){if(s=s.originalEvent||s,false==f.attr(draggable))return!0o.isDragging=!0,o.itemType=c.dndType&&l.$eval(c.dndType).toLowerCase(),o.dropEffect=none,o.effectAllowed=c.dndEffectAllowed||d[0],s.dataTransfer.effectAllowed=o.effectAllowedvar g=l.$eval(c.dndDraggable),u=a+(o.itemType?-+o.itemType:)try{s.dataTransfer.setData(u,angular.toJson(g))}catch(p){var v=angular.toJson({item:g,type:o.itemType})try{s.dataTransfer.setData(r,v)}catch(p){var D=n(d,o.effectAllowed)s.dataTransfer.effectAllowed=D[0],s.dataTransfer.setData(t,v)}}if(f.addClass(dndDragging),i(function(){f.addClass(dndDraggingSource)},0),s._dndHandle&&s.dataTransfer.setDragImage&&s.dataTransfer.setDragImage(f[0],0,0),e(c.dndDragstart)(l,{event:s}),c.dndCallback){var y=e(c.dndCallback)o.callback=function(e){return y(l,e||{})}}s.stopPropagation()}),f.on(dragend,function(n){n=n.originalEvent||n,l.$apply(function(){var a=o.dropEffect,r={copy:dndCopied,link:dndLinked,move:dndMoved,none:dndCanceled}e(c[r[a]])(l,{event:n}),e(c.dndDragend)(l,{event:n,dropEffect:a})}),o.isDragging=!1,o.callback=void 0,f.removeClass(dndDragging),f.removeClass(dndDraggingSource),n.stopPropagation(),i(function(){f.removeClass(dndDraggingSource)},0)}),f.on(click,function(n){c.dndSelected&&(n=n.originalEvent||n,l.$apply(function(){e(c.dndSelected)(l,{event:n})}),n.stopPropagation())}),f.on(selectstart,function(){this.dragDrop&&this.dragDrop()})}}]),e.directive(dndList,[$parse,function(e){return function(i,l,f){function c(e){if(!e)return tfor(var n=0;n<e.length;n++)if(e[n]==t||e[n]==r||e[n].substr(0,a.length)==a)return e[n]return null}function s(e){return o.isDragging?o.itemType||void 0:e==t||e==r?null:e&&e.substr(a.length+1)||void 0}function g(e){return E.disabled?!1:E.externalSources||o.isDragging?E.allowedTypes&&null!==e?e&&-1!=E.allowedTypes.indexOf(e):!0:!1}function u(e,a){var r=dreturn a||(r=n(r,e.dataTransfer.effectAllowed)),o.isDragging&&(r=n(r,o.effectAllowed)),f.dndEffectAllowed&&(r=n(r,f.dndEffectAllowed)),r.length?e.ctrlKey&&-1!=r.indexOf(copy)?copy:e.altKey&&-1!=r.indexOf(link)?link:r[0]:none}function p(){return T.remove(),l.removeClass(""dndDragover""),!0}function v(n,a,r,t,d,l){return e(n)(i,{callback:o.callback,dropEffect:r,event:a,external:!o.isDragging,index:void 0!==d?d:D(),item:l||void 0,type:t})}function D(){return Array.prototype.indexOf.call(m.children,h)}function y(){var ereturn angular.forEach(l.children(),function(n){var a=angular.element(n)a.hasClass(dndPlaceholder)&&(e=a)}),e||angular.element(<li class='dndPlaceholder'></li>)}var T=y()T.remove()var h=T[0],m=l[0],E={}l.on(dragenter,function(e){e=e.originalEvent||evar n=f.dndAllowedTypes&&i.$eval(f.dndAllowedTypes)E={allowedTypes:angular.isArray(n)&&n.join(|).toLowerCase().split(|),disabled:f.dndDisableIf&&i.$eval(f.dndDisableIf),externalSources:f.dndExternalSources&&i.$eval(f.dndExternalSources),horizontal:f.dndHorizontalList&&i.$eval(f.dndHorizontalList)}var a=c(e.dataTransfer.types)return a&&g(s(a))?void e.preventDefault():!0}),l.on(dragover,function(e){e=e.originalEvent||evar n=c(e.dataTransfer.types),a=s(n)if(!n||!g(a))return!0if(h.parentNode!=m&&l.append(T),e.target!=m){for(var r=e.target;r.parentNode!=m&&r.parentNode;)r=r.parentNodeif(r.parentNode==m&&r!=h){var d=r.getBoundingClientRect()if(E.horizontal)var o=e.clientX<d.left+d.width/2else var o=e.clientY<d.top+d.height/2m.insertBefore(h,o?r:r.nextSibling)}}var i=n==t,D=u(e,i)returnnone==D?p():f.dndDragover&&!v(f.dndDragover,e,D,a)?p():(e.preventDefault(),i||(e.dataTransfer.dropEffect=D),l.addClass(dndDragover),e.stopPropagation(),!1)}),l.on(drop,function(e){e=e.originalEvent||evar n=c(e.dataTransfer.types),a=s(n)if(!n||!g(a))return!0e.preventDefault()try{var d=JSON.parse(e.dataTransfer.getData(n))}catch(l){return p()}if((n==t||n==r)&&(a=d.type||void 0,d=d.item,!g(a)))return p()var y=n==t,T=u(e,y)if(none==T)return p()var h=D()return f.dndDrop&&(d=v(f.dndDrop,e,T,a,h,d),!d)?p():(o.dropEffect=T,y||(e.dataTransfer.dropEffect=T),d!==!0&&i.$apply(function(){i.$eval(f.dndList).splice(h,0,d)}),v(f.dndInserted,e,T,a,h,d),p(),e.stopPropagation(),!1)}),l.on(dragleave,function(e){e=e.originalEvent||evar n=document.elementFromPoint(e.clientX,e.clientY)m.contains(n)&&!e._dndPhShown?e._dndPhShown=!0:p()})}}]),e.directive(dndNodrag,function(){return function(e,n,a){n.attr(draggable,true),n.on(dragstart,function(e){e=e.originalEvent||e,e._dndHandle||(e.dataTransfer.types&&e.dataTransfer.types.length||e.preventDefault(),e.stopPropagation())}),n.on(dragend,function(e){e=e.originalEvent||e,e._dndHandle||e.stopPropagation()})}}),e.directive(dndHandle,function(){return function(e,n,a){n.attr(draggable,true),n.on(dragstart dragend,function(e){e=e.originalEvent||e,e._dndHandle=!0})}})var o={}}(angular.module(dndLists,[]));"
"var path = require(path);var webpack = require(webpack);var autoprefixer = require(autoprefixer);var ExtractTextPlugin = require(extract-text-webpack-plugin);var argv = require(yargs).argv;var minify = Boolean(argv.minify);var outputName = react-sortable-hoc;var plugins = {    default: [        new ExtractTextPlugin(../../styles.css)    ],    minify: [        new webpack.optimize.UglifyJsPlugin({            beautify: false,            comments: false,            mangle: false        }),        new ExtractTextPlugin(../../styles.min.css)    ]}
module.exports = {    devtool: (minify) ? source-map : null,    entry: [        ./src/index    ],    output: {        path: path.join(__dirname, dist/umd),        filename: (minify) ? outputName + .min.js : outputName + .js,        library: SortableHOC,        libraryTarget: umd    },    externals: {        react: {            commonjs: react,            commonjs2: react,            amd: react,            root: React        },        react-dom: {            commonjs: react-dom,            commonjs2: react-dom,            amd: react-dom,            root: ReactDOM        }    },    plugins: (minify) ? plugins.minify : plugins.default,    resolve: {		extensions: [, .js, .jsx, .scss]    },    module: {        loaders: [            {                test: jsx,                loaders: [babel],                exclude: node_modules,                include: path.join(__dirname, src)            },            {				test: (scsscss),				loader: ExtractTextPlugin.extract(style, css?-minimize&modules&importLoaders=1&localIdentName=Cal__[name]__[local]!postcss!sass?output=nested),                include: path.join(__dirname, src)            }        ]    },    postcss: [autoprefixer]}"
"var path = require(path);var webpack = require(webpack);var autoprefixer = require(autoprefixer);var HtmlWebpackPlugin = require(html-webpack-plugin);var DashboardPlugin = require(webpack-dashboard/plugin);
module.exports = {    devtool: cheap-module-eval-source-map,    entry: [        webpack-hot-middleware/client,        ./index    ],    output: {        path: path.join(__dirname, dist),        filename: bundle.js,        publicPath: /static/    },    plugins: [        new DashboardPlugin(),        new HtmlWebpackPlugin({			template: ./index.html,			inject: body  Inject all scripts into the body		}),        new webpack.optimize.OccurenceOrderPlugin(),        new webpack.HotModuleReplacementPlugin()    ],    resolve: {		extensions: [, .js, .jsx, .scss]    },    module: {        loaders: [            {                test: jsx,                loaders: [babel],                exclude: node_modules,                include: __dirname            },            {                test: (scss),                loaders: [style, css?sourceMap&modules&importLoaders=1&localIdentName=Cal__[name]__[local]!postcss!sass?sourceMap]            },            {                test: (css),                loaders: [style, css]            }        ]    },    postcss: [autoprefixer]}"
"use strict;
const gulp            = require(gulp);const jshint          = require(gulp-jshint);const stylish         = require(jshint-stylish);const rename          = require(gulp-rename);const jscs            = require(gulp-jscs);const uglify          = require(gulp-uglify);const livereload      = require(gulp-livereload);const exec            = require(child_process).exec;
gulp.task(default, [watch]);
gulp.task(watch, () => {    livereload.listen(35730);
    gulp.watch([        ./src/*.js,        ./src/*.hbs    ], [reload-js])        .on(change, function(e) {            console.log(                [gulp-watch] file  +                e.path +                 was  +                e.type +                , building            );        });});
gulp.task(reload-js, [build-dist], () => {    return livereload.changed();});
gulp.task(prod, [uglify]);
gulp.task(uglify, [build], () => {    return gulp.src([        ./dist/mixitup.js    ])        .pipe(uglify({            preserveComments: license        }))        .pipe(rename(mixitup.min.js))        .on(error, e => console.error([uglify]  + e.message))        .pipe(gulp.dest(./dist/))        .pipe(gulp.dest(./demos/));});
gulp.task(build, [build-dist], done => {    exec(node node_modules/mixitup-build/docs.js -s mixitup.js, (e, out) => {        if (out) {            console.log(out);        }
        done(e);    });});
gulp.task(build-dist, [lint, code-style], done => {    exec(node node_modules/mixitup-build/dist.js -o mixitup.js, (e, out) => {        if (out) {            console.log(out);        }
        done(e);    });});
gulp.task(lint, () => {    return gulp.src([        ./src/*.js    ], {        base: /    })        .pipe(jshint(./.jshintrc))        .pipe(jshint.reporter(stylish))        .pipe(jshint.reporter(fail));});
gulp.task(code-style, () => {    return gulp.src([        ./src/*.js    ], {        base: /    })        .pipe(jscs())        .pipe(jscs.reporter());});"
"use strict;
var fs = require(fs);
module.exports = function(grunt) {
     Project configuration.    grunt.initConfig({         Metadata.        pkg: grunt.file.readJSON(bootstrap-table.jquery.json),        banner: /* +                * <%= pkg.name %> - v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %> +                <%= pkg.homepage ? ""* "" + pkg.homepage : """" %> +                * Copyright (c) <%= grunt.template.today(""yyyy"") %> <%= pkg.author.name %> +                * Licensed <%= _.pluck(pkg.licenses, ""type"").join("", "") %> +                */,         Task configuration.        clean: [dist, docs/dist],        concat: {            basic_target: {                src: ['src/<%= pkg.name %>.js', 'src/extensions/**/*.js'],                dest: 'dist/<%= pkg.name %>-all.js'            },            locale_target: {                src: [src/locale/**/*.js],                dest: dist/<%= pkg.name %>-locale-all.js            }        },        uglify: {            options: {                banner: <%= banner %>            },            basic_target: {                files: {                    dist/<%= pkg.name %>.min.js: [src/<%=pkg.name %>.js],                    'dist/<%= pkg.name %>-all.min.js': ['dist/<%=pkg.name %>-all.js'],                    dist/<%= pkg.name %>-locale-all.min.js: [dist/<%=pkg.name %>-locale-all.js]                }            },            locale_target: {                files: [{                    expand: true,                    cwd: src/locale,                    src: **/*.js,                    dest: dist/locale,                    ext: .min.js  replace .js to .min.js                }]            },            extensions_target: {                files: [{                    expand: true,                    cwd: src/extensions,                    src: **/*.js,                    dest: dist/extensions,                    ext: .min.js  replace .js to .min.js                }]            }        },        cssmin: {            add_banner: {                options: {                    banner: <%= banner %>                },                files: {                    dist/<%= pkg.name %>.min.css: [src/<%=pkg.name %>.css]                }            }        },        copy: {            source: {                cwd: src,                      set working folder / root to copy                src: [**/*.js, **/*.css],    copy all files and subfolders                dest: dist,                    destination folder                expand: true                     required when using cwd            },            files: {                cwd: dist,             set working folder / root to copy                src: **/*,             copy all files and subfolders                dest: docs/dist,       destination folder                expand: true             required when using cwd            }        },        release: {            options: {                additionalFiles: [bootstrap-table.jquery.json],                beforeRelease: [docs, default]            }        }    });
    var bumpVersion = function (path, version, startWith) {        var lines = fs.readFileSync(path, utf8).split();        lines.forEach(function (line, i) {            if (line.indexOf(startWith) === 0) {                lines[i] = startWith + version;            }        });        fs.writeFileSync(path, lines.join(), utf8);
        grunt.log.ok(bumped version of  + path +  to  + version);    };
    grunt.registerTask(docs, build the docs, function () {        var version = require(./package.json).version;        bumpVersion(./_config.yml, version, current_version: );        bumpVersion(./src/bootstrap-table.js, version,  * version: );        bumpVersion(./src/bootstrap-table.css, version,  * version: );
        var changeLog = fs.readFileSync(./CHANGELOG.md, utf8);        var latestLogs = changeLog.split(### )[1];        var date = new Date();
        var lines = [            ### Latest release ( +            [date.getFullYear(), date.getMonth() + 1, date.getDate()].join(-) + ),            ,            #### v + latestLogs        ];        fs.writeFileSync(./docs/_includes/latest-release.md, lines.join(), utf8);
        grunt.log.ok(updated the latest-release.md to  + version);    });
    grunt.loadNpmTasks(grunt-contrib-clean);    grunt.loadNpmTasks(grunt-contrib-concat);    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-cssmin);    grunt.loadNpmTasks(grunt-contrib-copy);    grunt.loadNpmTasks(grunt-release);
    grunt.registerTask(default, [clean, concat, uglify, cssmin, copy]);};"
"const webpack = require(webpack),      PACKAGE = require(./package.json);
module.exports = {  entry: {    list: ./src/index.js,    list.min: ./src/index.js  },  output: {    path: __dirname + /dist,    filename: [name].js,    library: List  },  module: {    rules: [{      enforce: pre,      test: js,      exclude: (node_modulessrcutilsextendjs),      loader: jshint-loader    }]  },  devServer: {    inline: true  },  plugins: [    new webpack.optimize.UglifyJsPlugin({      include: minjs,      minimize: true    }),    new webpack.BannerPlugin({      banner: List.js v + PACKAGE.version +  ( + PACKAGE.homepage + ) by  + PACKAGE.author.name +  ( + PACKAGE.author.url + )    })  ]};"
"/** * jQuery plugin for Sortable * 	<> *   */(function (factory) {	use strict;
	if (typeof define === function && define.amd) {		define([jquery], factory);	}	else {		/* jshint sub:true */		factory(jQuery);	}})(function ($) {	use strict;

	/* CODE */

	/**	 * jQuery plugin for Sortable	 *     	 *               	 *  	 */	$.fn.sortable = function (options) {		var retVal,			args = arguments;
		this.each(function () {			var $el = $(this),				sortable = $el.data(sortable);
			if (!sortable && (options instanceof Object || !options)) {				sortable = new Sortable(this, options);				$el.data(sortable, sortable);			}
			if (sortable) {				if (options === widget) {					retVal = sortable;				}				else if (options === destroy) {					sortable.destroy();					$el.removeData(sortable);				}				else if (typeof sortable[options] === function) {					retVal = sortable[options].apply(sortable, [].slice.call(args, 1));				}				else if (options in sortable.options) {					retVal = sortable.option.apply(sortable, args);				}			}		});
		return (retVal === void 0) ? this : retVal;	};});"
"/*! Sortable 1.5.1 - MIT | git://github.com/rubaxa/Sortable.git */!function(a){""use strict"";""function""==typeof define&&define.amd?define(a):""undefined""!=typeof module&&""undefined""!=typeof module.exports?module.exports=a():window.Sortable=a()}(function(){""use strict"";function a(a,b){if(!a||!a.nodeType||1!==a.nodeType)throw""Sortable: `el` must be HTMLElement, and not ""+{}.toString.call(a);this.el=a,this.options=b=t({},b),a[T]=this;var c={group:Math.random(),sort:!0,disabled:!1,store:null,handle:null,scroll:!0,scrollSensitivity:30,scrollSpeed:10,draggable:/[uo]l/i.test(a.nodeName)?""li"":"">*"",ghostClass:""sortable-ghost"",chosenClass:""sortable-chosen"",dragClass:""sortable-drag"",ignore:""a, img"",filter:null,preventOnFilter:!0,animation:0,setData:function(a,b){a.setData(""Text"",b.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:""data-id"",delay:0,forceFallback:!1,fallbackClass:""sortable-fallback"",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0}};for(var d in c)!(d in b)&&(b[d]=c[d]);ga(b);for(var e in this)""_""===e.charAt(0)&&""function""==typeof this[e]&&(this[e]=this[e].bind(this));this.nativeDraggable=!b.forceFallback&&$,f(a,""mousedown"",this._onTapStart),f(a,""touchstart"",this._onTapStart),f(a,""pointerdown"",this._onTapStart),this.nativeDraggable&&(f(a,""dragover"",this),f(a,""dragenter"",this)),ea.push(this._onDragOver),b.store&&this.sort(b.store.get(this))}function b(a,b){""clone""!==a.lastPullMode&&(b=!0),z&&z.state!==b&&(i(z,""display"",b?""none"":""""),b||z.state&&(a.options.group.revertClone?(A.insertBefore(z,B),a._animate(w,z)):A.insertBefore(z,w)),z.state=b)}function c(a,b,c){if(a){c=c||V;do if("">*""===b&&a.parentNode===c||r(a,b))return a;while(a=d(a))}return null}function d(a){var b=a.host;return b&&b.nodeType?b:a.parentNode}function e(a){a.dataTransfer&&(a.dataTransfer.dropEffect=""move""),a.preventDefault()}function f(a,b,c){a.addEventListener(b,c,Z)}function g(a,b,c){a.removeEventListener(b,c,Z)}function h(a,b,c){if(a)if(a.classList)a.classList[c?""add"":""remove""](b);else{var d=("" ""+a.className+"" "").replace(R,"" "").replace("" ""+b+"" "","" "");a.className=(d+(c?"" ""+b:"""")).replace(R,"" "")}}function i(a,b,c){var d=a&&a.style;if(d){if(void 0===c)return V.defaultView&&V.defaultView.getComputedStyle?c=V.defaultView.getComputedStyle(a,""""):a.currentStyle&&(c=a.currentStyle),void 0===b?c:c[b];b in d||(b=""-webkit-""+b),d[b]=c+(""string""==typeof c?"""":""px"")}}function j(a,b,c){if(a){var d=a.getElementsByTagName(b),e=0,f=d.length;if(c)for(;e<f;e++)c(d[e],e);return d}return[]}function k(a,b,c,d,e,f,g){a=a||b[T];var h=V.createEvent(""Event""),i=a.options,j=""on""+c.charAt(0).toUpperCase()+c.substr(1);h.initEvent(c,!0,!0),h.to=b,h.from=e||b,h.item=d||b,h.clone=z,h.oldIndex=f,h.newIndex=g,b.dispatchEvent(h),i[j]&&i[j].call(a,h)}function l(a,b,c,d,e,f,g){var h,i,j=a[T],k=j.options.onMove;return h=V.createEvent(""Event""),h.initEvent(""move"",!0,!0),h.to=b,h.from=a,h.dragged=c,h.draggedRect=d,h.related=e||b,h.relatedRect=f||b.getBoundingClientRect(),a.dispatchEvent(h),k&&(i=k.call(j,h,g)),i}function m(a){a.draggable=!1}function n(){aa=!1}function o(a,b){var c=a.lastElementChild,d=c.getBoundingClientRect();return(b.clientY-(d.top+d.height)>5||b.clientX-(d.right+d.width)>5)&&c}function p(a){for(var b=a.tagName+a.className+a.src+a.href+a.textContent,c=b.length,d=0;c--;)d+=b.charCodeAt(c);return d.toString(36)}function q(a,b){var c=0;if(!a||!a.parentNode)return-1;for(;a&&(a=a.previousElementSibling);)""TEMPLATE""===a.nodeName.toUpperCase()||"">*""!==b&&!r(a,b)||c++;return c}function r(a,b){if(a){b=b.split(""."");var c=b.shift().toUpperCase(),d=new RegExp(""\\s(""+b.join(""|"")+"")(?=\\s)"",""g"");return!(""""!==c&&a.nodeName.toUpperCase()!=c||b.length&&(("" ""+a.className+"" "").match(d)||[]).length!=b.length)}return!1}function s(a,b){var c,d;return function(){void 0===c&&(c=arguments,d=this,setTimeout(function(){1===c.length?a.call(d,c[0]):a.apply(d,c),c=void 0},b))}}function t(a,b){if(a&&b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function u(a){return X?X(a).clone(!0)[0]:Y&&Y.dom?Y.dom(a).cloneNode(!0):a.cloneNode(!0)}function v(a){for(var b=a.getElementsByTagName(""input""),c=b.length;c--;){var d=b[c];d.checked&&da.push(d)}}if(""undefined""==typeof window||!window.document)return function(){throw new Error(""Sortable.js requires a window with a document"")};var w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q={},R=/\s+/g,S=/left|right|inline/,T=""Sortable""+(new Date).getTime(),U=window,V=U.document,W=U.parseInt,X=U.jQuery||U.Zepto,Y=U.Polymer,Z=!1,$=!!(""draggable""in V.createElement(""div"")),_=function(a){return!navigator.userAgent.match(/Trident.*rv[ :]?11\./)&&(a=V.createElement(""x""),a.style.cssText=""pointer-events:auto"",""auto""===a.style.pointerEvents)}(),aa=!1,ba=Math.abs,ca=Math.min,da=[],ea=[],fa=s(function(a,b,c){if(c&&b.scroll){var d,e,f,g,h,i,j=c[T],k=b.scrollSensitivity,l=b.scrollSpeed,m=a.clientX,n=a.clientY,o=window.innerWidth,p=window.innerHeight;if(E!==c&&(D=b.scroll,E=c,F=b.scrollFn,D===!0)){D=c;do if(D.offsetWidth<D.scrollWidth||D.offsetHeight<D.scrollHeight)break;while(D=D.parentNode)}D&&(d=D,e=D.getBoundingClientRect(),f=(ba(e.right-m)<=k)-(ba(e.left-m)<=k),g=(ba(e.bottom-n)<=k)-(ba(e.top-n)<=k)),f||g||(f=(o-m<=k)-(m<=k),g=(p-n<=k)-(n<=k),(f||g)&&(d=U)),Q.vx===f&&Q.vy===g&&Q.el===d||(Q.el=d,Q.vx=f,Q.vy=g,clearInterval(Q.pid),d&&(Q.pid=setInterval(function(){return i=g?g*l:0,h=f?f*l:0,""function""==typeof F?F.call(j,h,i,a):void(d===U?U.scrollTo(U.pageXOffset+h,U.pageYOffset+i):(d.scrollTop+=i,d.scrollLeft+=h))},24)))}},30),ga=function(a){function b(a,b){return void 0!==a&&a!==!0||(a=c.name),""function""==typeof a?a:function(c,d){var e=d.options.group.name;return b?a:a&&(a.join?a.indexOf(e)>-1:e==a)}}var c={},d=a.group;d&&""object""==typeof d||(d={name:d}),c.name=d.name,c.checkPull=b(d.pull,!0),c.checkPut=b(d.put),c.revertClone=d.revertClone,a.group=c};a.prototype={constructor:a,_onTapStart:function(a){var b,d=this,e=this.el,f=this.options,g=f.preventOnFilter,h=a.type,i=a.touches&&a.touches[0],j=(i||a).target,l=a.target.shadowRoot&&a.path[0]||j,m=f.filter;if(v(e),!w&&!(""mousedown""===h&&0!==a.button||f.disabled)&&(j=c(j,f.draggable,e),j&&C!==j)){if(b=q(j,f.draggable),""function""==typeof m){if(m.call(this,a,j,this))return k(d,l,""filter"",j,e,b),void(g&&a.preventDefault())}else if(m&&(m=m.split("","").some(function(a){if(a=c(l,a.trim(),e))return k(d,a,""filter"",j,e,b),!0})))return void(g&&a.preventDefault());f.handle&&!c(l,f.handle,e)||this._prepareDragStart(a,i,j,b)}},_prepareDragStart:function(a,b,c,d){var e,g=this,i=g.el,l=g.options,n=i.ownerDocument;c&&!w&&c.parentNode===i&&(N=a,A=i,w=c,x=w.parentNode,B=w.nextSibling,C=c,L=l.group,J=d,this._lastX=(b||a).clientX,this._lastY=(b||a).clientY,w.style[""will-change""]=""transform"",e=function(){g._disableDelayedDrag(),w.draggable=g.nativeDraggable,h(w,l.chosenClass,!0),g._triggerDragStart(a,b),k(g,A,""choose"",w,A,J)},l.ignore.split("","").forEach(function(a){j(w,a.trim(),m)}),f(n,""mouseup"",g._onDrop),f(n,""touchend"",g._onDrop),f(n,""touchcancel"",g._onDrop),f(n,""pointercancel"",g._onDrop),f(n,""selectstart"",g),l.delay?(f(n,""mouseup"",g._disableDelayedDrag),f(n,""touchend"",g._disableDelayedDrag),f(n,""touchcancel"",g._disableDelayedDrag),f(n,""mousemove"",g._disableDelayedDrag),f(n,""touchmove"",g._disableDelayedDrag),f(n,""pointermove"",g._disableDelayedDrag),g._dragStartTimer=setTimeout(e,l.delay)):e())},_disableDelayedDrag:function(){var a=this.el.ownerDocument;clearTimeout(this._dragStartTimer),g(a,""mouseup"",this._disableDelayedDrag),g(a,""touchend"",this._disableDelayedDrag),g(a,""touchcancel"",this._disableDelayedDrag),g(a,""mousemove"",this._disableDelayedDrag),g(a,""touchmove"",this._disableDelayedDrag),g(a,""pointermove"",this._disableDelayedDrag)},_triggerDragStart:function(a,b){b=b||(""touch""==a.pointerType?a:null),b?(N={target:w,clientX:b.clientX,clientY:b.clientY},this._onDragStart(N,""touch"")):this.nativeDraggable?(f(w,""dragend"",this),f(A,""dragstart"",this._onDragStart)):this._onDragStart(N,!0);try{V.selection?setTimeout(function(){V.selection.empty()}):window.getSelection().removeAllRanges()}catch(a){}},_dragStarted:function(){if(A&&w){var b=this.options;h(w,b.ghostClass,!0),h(w,b.dragClass,!1),a.active=this,k(this,A,""start"",w,A,J)}else this._nulling()},_emulateDragOver:function(){if(O){if(this._lastX===O.clientX&&this._lastY===O.clientY)return;this._lastX=O.clientX,this._lastY=O.clientY,_||i(y,""display"",""none"");var a=V.elementFromPoint(O.clientX,O.clientY),b=a,c=ea.length;if(b)do{if(b[T]){for(;c--;)ea[c]({clientX:O.clientX,clientY:O.clientY,target:a,rootEl:b});break}a=b}while(b=b.parentNode);_||i(y,""display"","""")}},_onTouchMove:function(b){if(N){var c=this.options,d=c.fallbackTolerance,e=c.fallbackOffset,f=b.touches?b.touches[0]:b,g=f.clientX-N.clientX+e.x,h=f.clientY-N.clientY+e.y,j=b.touches?""translate3d(""+g+""px,""+h+""px,0)"":""translate(""+g+""px,""+h+""px)"";if(!a.active){if(d&&ca(ba(f.clientX-this._lastX),ba(f.clientY-this._lastY))<d)return;this._dragStarted()}this._appendGhost(),P=!0,O=f,i(y,""webkitTransform"",j),i(y,""mozTransform"",j),i(y,""msTransform"",j),i(y,""transform"",j),b.preventDefault()}},_appendGhost:function(){if(!y){var a,b=w.getBoundingClientRect(),c=i(w),d=this.options;y=w.cloneNode(!0),h(y,d.ghostClass,!1),h(y,d.fallbackClass,!0),h(y,d.dragClass,!0),i(y,""top"",b.top-W(c.marginTop,10)),i(y,""left"",b.left-W(c.marginLeft,10)),i(y,""width"",b.width),i(y,""height"",b.height),i(y,""opacity"",""0.8""),i(y,""position"",""fixed""),i(y,""zIndex"",""100000""),i(y,""pointerEvents"",""none""),d.fallbackOnBody&&V.body.appendChild(y)||A.appendChild(y),a=y.getBoundingClientRect(),i(y,""width"",2*b.width-a.width),i(y,""height"",2*b.height-a.height)}},_onDragStart:function(a,b){var c=a.dataTransfer,d=this.options;this._offUpEvents(),L.checkPull(this,this,w,a)&&(z=u(w),z.draggable=!1,z.style[""will-change""]="""",i(z,""display"",""none""),h(z,this.options.chosenClass,!1),A.insertBefore(z,w),k(this,A,""clone"",w)),h(w,d.dragClass,!0),b?(""touch""===b?(f(V,""touchmove"",this._onTouchMove),f(V,""touchend"",this._onDrop),f(V,""touchcancel"",this._onDrop),f(V,""pointermove"",this._onTouchMove),f(V,""pointerup"",this._onDrop)):(f(V,""mousemove"",this._onTouchMove),f(V,""mouseup"",this._onDrop)),this._loopId=setInterval(this._emulateDragOver,50)):(c&&(c.effectAllowed=""move"",d.setData&&d.setData.call(this,c,w)),f(V,""drop"",this),setTimeout(this._dragStarted,0))},_onDragOver:function(d){var e,f,g,h,j=this.el,k=this.options,m=k.group,p=a.active,q=L===m,r=!1,s=k.sort;if(void 0!==d.preventDefault&&(d.preventDefault(),!k.dragoverBubble&&d.stopPropagation()),!w.animated&&(P=!0,p&&!k.disabled&&(q?s||(h=!A.contains(w)):M===this||(p.lastPullMode=L.checkPull(this,p,w,d))&&m.checkPut(this,p,w,d))&&(void 0===d.rootEl||d.rootEl===this.el))){if(fa(d,k,this.el),aa)return;if(e=c(d.target,k.draggable,j),f=w.getBoundingClientRect(),M!==this&&(M=this,r=!0),h)return b(p,!0),x=A,void(z||B?A.insertBefore(w,z||B):s||A.appendChild(w));if(0===j.children.length||j.children[0]===y||j===d.target&&(e=o(j,d))){if(e){if(e.animated)return;g=e.getBoundingClientRect()}b(p,q),l(A,j,w,f,e,g,d)!==!1&&(w.contains(j)||(j.appendChild(w),x=j),this._animate(f,w),e&&this._animate(g,e))}else if(e&&!e.animated&&e!==w&&void 0!==e.parentNode[T]){G!==e&&(G=e,H=i(e),I=i(e.parentNode)),g=e.getBoundingClientRect();var t=g.right-g.left,u=g.bottom-g.top,v=S.test(H.cssFloat+H.display)||""flex""==I.display&&0===I[""flex-direction""].indexOf(""row""),C=e.offsetWidth>w.offsetWidth,D=e.offsetHeight>w.offsetHeight,E=(v?(d.clientX-g.left)/t:(d.clientY-g.top)/u)>.5,F=e.nextElementSibling,J=l(A,j,w,f,e,g,d),K=!1;if(J!==!1){if(aa=!0,setTimeout(n,30),b(p,q),1===J||J===-1)K=1===J;else if(v){var N=w.offsetTop,O=e.offsetTop;K=N===O?e.previousElementSibling===w&&!C||E&&C:e.previousElementSibling===w||w.previousElementSibling===e?(d.clientY-g.top)/u>.5:O>N}else r||(K=F!==w&&!D||E&&D);w.contains(j)||(K&&!F?j.appendChild(w):e.parentNode.insertBefore(w,K?F:e)),x=w.parentNode,this._animate(f,w),this._animate(g,e)}}}},_animate:function(a,b){var c=this.options.animation;if(c){var d=b.getBoundingClientRect();1===a.nodeType&&(a=a.getBoundingClientRect()),i(b,""transition"",""none""),i(b,""transform"",""translate3d(""+(a.left-d.left)+""px,""+(a.top-d.top)+""px,0)""),b.offsetWidth,i(b,""transition"",""all ""+c+""ms""),i(b,""transform"",""translate3d(0,0,0)""),clearTimeout(b.animated),b.animated=setTimeout(function(){i(b,""transition"",""""),i(b,""transform"",""""),b.animated=!1},c)}},_offUpEvents:function(){var a=this.el.ownerDocument;g(V,""touchmove"",this._onTouchMove),g(V,""pointermove"",this._onTouchMove),g(a,""mouseup"",this._onDrop),g(a,""touchend"",this._onDrop),g(a,""pointerup"",this._onDrop),g(a,""touchcancel"",this._onDrop),g(a,""selectstart"",this)},_onDrop:function(b){var c=this.el,d=this.options;clearInterval(this._loopId),clearInterval(Q.pid),clearTimeout(this._dragStartTimer),g(V,""mousemove"",this._onTouchMove),this.nativeDraggable&&(g(V,""drop"",this),g(c,""dragstart"",this._onDragStart)),this._offUpEvents(),b&&(P&&(b.preventDefault(),!d.dropBubble&&b.stopPropagation()),y&&y.parentNode.removeChild(y),A!==x&&""clone""===a.active.lastPullMode||z&&z.parentNode.removeChild(z),w&&(this.nativeDraggable&&g(w,""dragend"",this),m(w),w.style[""will-change""]="""",h(w,this.options.ghostClass,!1),h(w,this.options.chosenClass,!1),A!==x?(K=q(w,d.draggable),K>=0&&(k(null,x,""add"",w,A,J,K),k(this,A,""remove"",w,A,J,K),k(null,x,""sort"",w,A,J,K),k(this,A,""sort"",w,A,J,K))):w.nextSibling!==B&&(K=q(w,d.draggable),K>=0&&(k(this,A,""update"",w,A,J,K),k(this,A,""sort"",w,A,J,K))),a.active&&(null!=K&&K!==-1||(K=J),k(this,A,""end"",w,A,J,K),this.save()))),this._nulling()},_nulling:function(){A=w=x=y=B=z=C=D=E=N=O=P=K=G=H=M=L=a.active=null,da.forEach(function(a){a.checked=!0}),da.length=0},handleEvent:function(a){switch(a.type){case""drop"":case""dragend"":this._onDrop(a);break;case""dragover"":case""dragenter"":w&&(this._onDragOver(a),e(a));break;case""selectstart"":a.preventDefault()}},toArray:function(){for(var a,b=[],d=this.el.children,e=0,f=d.length,g=this.options;e<f;e++)a=d[e],c(a,g.draggable,this.el)&&b.push(a.getAttribute(g.dataIdAttr)||p(a));return b},sort:function(a){var b={},d=this.el;this.toArray().forEach(function(a,e){var f=d.children[e];c(f,this.options.draggable,d)&&(b[a]=f)},this),a.forEach(function(a){b[a]&&(d.removeChild(b[a]),d.appendChild(b[a]))})},save:function(){var a=this.options.store;a&&a.set(this)},closest:function(a,b){return c(a,b||this.options.draggable,this.el)},option:function(a,b){var c=this.options;return void 0===b?c[a]:(c[a]=b,void(""group""===a&&ga(c)))},destroy:function(){var a=this.el;a[T]=null,g(a,""mousedown"",this._onTapStart),g(a,""touchstart"",this._onTapStart),g(a,""pointerdown"",this._onTapStart),this.nativeDraggable&&(g(a,""dragover"",this),g(a,""dragenter"",this)),Array.prototype.forEach.call(a.querySelectorAll(""[draggable]""),function(a){a.removeAttribute(""draggable"")}),ea.splice(ea.indexOf(this._onDragOver),1),this._onDrop(),this.el=a=null}},f(V,""touchmove"",function(b){a.active&&b.preventDefault()});try{window.addEventListener(""test"",null,Object.defineProperty({},""passive"",{get:function(){Z={capture:!1,passive:!1}}}))}catch(a){}return a.utils={on:f,off:g,css:i,find:j,is:function(a,b){return!!c(a,b,a)},extend:t,throttle:s,closest:c,toggleClass:h,clone:u,index:q},a.create=function(b,c){return new a(b,c)},a.version=""1.5.1"",a});"
"/**! * Sortable * 	<> *   */
(function sortableModule(factory) {	use strict;
	if (typeof define === function && define.amd) {		define(factory);	}	else if (typeof module != undefined && typeof module.exports != undefined) {		module.exports = factory();	}	else {		/* jshint sub:true */		window[Sortable] = factory();	}})(function sortableFactory() {	use strict;
	if (typeof window == undefined || !window.document) {		return function sortableError() {			throw new Error(Sortable.js requires a window with a document);		};	}
	var dragEl,		parentEl,		ghostEl,		cloneEl,		rootEl,		nextEl,		lastDownEl,
		scrollEl,		scrollParentEl,		scrollCustomFn,
		lastEl,		lastCSS,		lastParentCSS,
		oldIndex,		newIndex,
		activeGroup,		putSortable,
		autoScroll = {},
		tapEvt,		touchEvt,
		moved,
		 */		R_SPACE = g,		R_FLOAT = leftrightinline,
		expando = Sortable + (new Date).getTime(),
		win = window,		document = win.document,		parseInt = win.parseInt,
		$ = win.jQuery || win.Zepto,		Polymer = win.Polymer,
		captureMode = false,
		supportDraggable = !!(draggable in document.createElement(div)),		supportCssPointerEvents = (function (el) {			 false when IE11			if (!!navigator.userAgent.match(Tridentrv11)) {				return false;			}			el = document.createElement(x);			el.style.cssText = pointer-events:auto;			return el.style.pointerEvents === auto;		})(),
		_silent = false,
		abs = Math.abs,		min = Math.min,
		savedInputChecked = [],		touchDragOverListeners = [],
		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {			 Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521			if (rootEl && options.scroll) {				var _this = rootEl[expando],					el,					rect,					sens = options.scrollSensitivity,					speed = options.scrollSpeed,
					x = evt.clientX,					y = evt.clientY,
					winWidth = window.innerWidth,					winHeight = window.innerHeight,
					vx,					vy,
					scrollOffsetX,					scrollOffsetY				;
				 Delect scrollEl				if (scrollParentEl !== rootEl) {					scrollEl = options.scroll;					scrollParentEl = rootEl;					scrollCustomFn = options.scrollFn;
					if (scrollEl === true) {						scrollEl = rootEl;
						do {							if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||								(scrollEl.offsetHeight < scrollEl.scrollHeight)							) {								break;							}							/* jshint boss:true */						} while (scrollEl = scrollEl.parentNode);					}				}
				if (scrollEl) {					el = scrollEl;					rect = scrollEl.getBoundingClientRect();					vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);					vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);				}

				if (!(vx || vy)) {					vx = (winWidth - x <= sens) - (x <= sens);					vy = (winHeight - y <= sens) - (y <= sens);
					/* jshint expr:true */					(vx || vy) && (el = win);				}

				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {					autoScroll.el = el;					autoScroll.vx = vx;					autoScroll.vy = vy;
					clearInterval(autoScroll.pid);
					if (el) {						autoScroll.pid = setInterval(function () {							scrollOffsetY = vy ? vy * speed : 0;							scrollOffsetX = vx ? vx * speed : 0;
							if (function === typeof(scrollCustomFn)) {								return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);							}
							if (el === win) {								win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);							} else {								el.scrollTop += scrollOffsetY;								el.scrollLeft += scrollOffsetX;							}						}, 24);					}				}			}		}, 30),
		_prepareGroup = function (options) {			function toFn(value, pull) {				if (value === void 0 || value === true) {					value = group.name;				}
				if (typeof value === function) {					return value;				} else {					return function (to, from) {						var fromGroup = from.options.group.name;
						return pull							? value							: value && (value.join								? value.indexOf(fromGroup) > -1								: (fromGroup == value)							);					};				}			}
			var group = {};			var originalGroup = options.group;
			if (!originalGroup || typeof originalGroup != object) {				originalGroup = {name: originalGroup};			}
			group.name = originalGroup.name;			group.checkPull = toFn(originalGroup.pull, true);			group.checkPut = toFn(originalGroup.put);			group.revertClone = originalGroup.revertClone;
			options.group = group;		}	;

	/**	 *   Sortable	 *     	 *          	 */	function Sortable(el, options) {		if (!(el && el.nodeType && el.nodeType === 1)) {			throw Sortable: `el` must be HTMLElement, and not  + {}.toString.call(el);		}
		this.el = el;  root element		this.options = options = _extend({}, options);

		 Export instance		el[expando] = this;
		 Default options		var defaults = {			group: Math.random(),			sort: true,			disabled: false,			store: null,			handle: null,			scroll: true,			scrollSensitivity: 30,			scrollSpeed: 10,			draggable: li.test(el.nodeName) ? li : >*,			ghostClass: sortable-ghost,			chosenClass: sortable-chosen,			dragClass: sortable-drag,			ignore: a, img,			filter: null,			preventOnFilter: true,			animation: 0,			setData: function (dataTransfer, dragEl) {				dataTransfer.setData(Text, dragEl.textContent);			},			dropBubble: false,			dragoverBubble: false,			dataIdAttr: data-id,			delay: 0,			forceFallback: false,			fallbackClass: sortable-fallback,			fallbackOnBody: false,			fallbackTolerance: 0,			fallbackOffset: {x: 0, y: 0}		};

		 Set default options		for (var name in defaults) {			!(name in options) && (options[name] = defaults[name]);		}
		_prepareGroup(options);
		 Bind all private methods		for (var fn in this) {			if (fn.charAt(0) === _ && typeof this[fn] === function) {				this[fn] = this[fn].bind(this);			}		}
		 Setup drag mode		this.nativeDraggable = options.forceFallback ? false : supportDraggable;
		 Bind events		_on(el, mousedown, this._onTapStart);		_on(el, touchstart, this._onTapStart);		_on(el, pointerdown, this._onTapStart);
		if (this.nativeDraggable) {			_on(el, dragover, this);			_on(el, dragenter, this);		}
		touchDragOverListeners.push(this._onDragOver);
		 Restore sorting		options.store && this.sort(options.store.get(this));	}

	Sortable.prototype =   */ {		constructor: Sortable,
		_onTapStart: function (evt) {			var _this = this,				el = this.el,				options = this.options,				preventOnFilter = options.preventOnFilter,				type = evt.type,				touch = evt.touches && evt.touches[0],				target = (touch || evt).target,				originalTarget = evt.target.shadowRoot && evt.path[0] || target,				filter = options.filter,				startIndex;
			_saveInputCheckedState(el);

			 Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.			if (dragEl) {				return;			}
			if (type === mousedown && evt.button !== 0 || options.disabled) {				return;  only left button or enabled			}

			target = _closest(target, options.draggable, el);
			if (!target) {				return;			}
			if (lastDownEl === target) {				 Ignoring duplicate `down`				return;			}
			 Get the index of the dragged element within its parent			startIndex = _index(target, options.draggable);
			 Check filter			if (typeof filter === function) {				if (filter.call(this, evt, target, this)) {					_dispatchEvent(_this, originalTarget, filter, target, el, startIndex);					preventOnFilter && evt.preventDefault();					return;  cancel dnd				}			}			else if (filter) {				filter = filter.split(,).some(function (criteria) {					criteria = _closest(originalTarget, criteria.trim(), el);
					if (criteria) {						_dispatchEvent(_this, criteria, filter, target, el, startIndex);						return true;					}				});
				if (filter) {					preventOnFilter && evt.preventDefault();					return;  cancel dnd				}			}
			if (options.handle && !_closest(originalTarget, options.handle, el)) {				return;			}
			 Prepare `dragstart`			this._prepareDragStart(evt, touch, target, startIndex);		},
		_prepareDragStart: function (evt, touch, target, startIndex) {			var _this = this,				el = _this.el,				options = _this.options,				ownerDocument = el.ownerDocument,				dragStartFn;
			if (target && !dragEl && (target.parentNode === el)) {				tapEvt = evt;
				rootEl = el;				dragEl = target;				parentEl = dragEl.parentNode;				nextEl = dragEl.nextSibling;				lastDownEl = target;				activeGroup = options.group;				oldIndex = startIndex;
				this._lastX = (touch || evt).clientX;				this._lastY = (touch || evt).clientY;
				dragEl.style[will-change] = transform;
				dragStartFn = function () {					 Delayed drag has been triggered					 we can re-enable the events: touchmove/mousemove					_this._disableDelayedDrag();
					 Make the element draggable					dragEl.draggable = _this.nativeDraggable;
					 Chosen item					_toggleClass(dragEl, options.chosenClass, true);
					 Bind the events: dragstart/dragend					_this._triggerDragStart(evt, touch);
					 Drag start event					_dispatchEvent(_this, rootEl, choose, dragEl, rootEl, oldIndex);				};
				 Disable ""draggable""				options.ignore.split(,).forEach(function (criteria) {					_find(dragEl, criteria.trim(), _disableDraggable);				});
				_on(ownerDocument, mouseup, _this._onDrop);				_on(ownerDocument, touchend, _this._onDrop);				_on(ownerDocument, touchcancel, _this._onDrop);				_on(ownerDocument, pointercancel, _this._onDrop);				_on(ownerDocument, selectstart, _this);
				if (options.delay) {					 If the user moves the pointer or let go the click or touch					 before the delay has been reached:					 disable the delayed drag					_on(ownerDocument, mouseup, _this._disableDelayedDrag);					_on(ownerDocument, touchend, _this._disableDelayedDrag);					_on(ownerDocument, touchcancel, _this._disableDelayedDrag);					_on(ownerDocument, mousemove, _this._disableDelayedDrag);					_on(ownerDocument, touchmove, _this._disableDelayedDrag);					_on(ownerDocument, pointermove, _this._disableDelayedDrag);
					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);				} else {					dragStartFn();				}

			}		},
		_disableDelayedDrag: function () {			var ownerDocument = this.el.ownerDocument;
			clearTimeout(this._dragStartTimer);			_off(ownerDocument, mouseup, this._disableDelayedDrag);			_off(ownerDocument, touchend, this._disableDelayedDrag);			_off(ownerDocument, touchcancel, this._disableDelayedDrag);			_off(ownerDocument, mousemove, this._disableDelayedDrag);			_off(ownerDocument, touchmove, this._disableDelayedDrag);			_off(ownerDocument, pointermove, this._disableDelayedDrag);		},
		_triggerDragStart: function (evt, touch) {			touch = touch || (evt.pointerType == touch ? evt : null);
			if (touch) {				 Touch device support				tapEvt = {					target: dragEl,					clientX: touch.clientX,					clientY: touch.clientY				};
				this._onDragStart(tapEvt, touch);			}			else if (!this.nativeDraggable) {				this._onDragStart(tapEvt, true);			}			else {				_on(dragEl, dragend, this);				_on(rootEl, dragstart, this._onDragStart);			}
			try {				if (document.selection) {										 Timeout neccessary for IE9										setTimeout(function () {						document.selection.empty();					});									} else {					window.getSelection().removeAllRanges();				}			} catch (err) {			}		},
		_dragStarted: function () {			if (rootEl && dragEl) {				var options = this.options;
				 Apply effect				_toggleClass(dragEl, options.ghostClass, true);				_toggleClass(dragEl, options.dragClass, false);
				Sortable.active = this;
				 Drag start event				_dispatchEvent(this, rootEl, start, dragEl, rootEl, oldIndex);			} else {				this._nulling();			}		},
		_emulateDragOver: function () {			if (touchEvt) {				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {					return;				}
				this._lastX = touchEvt.clientX;				this._lastY = touchEvt.clientY;
				if (!supportCssPointerEvents) {					_css(ghostEl, display, none);				}
				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),					parent = target,					i = touchDragOverListeners.length;
				if (parent) {					do {						if (parent[expando]) {							while (i--) {								touchDragOverListeners[i]({									clientX: touchEvt.clientX,									clientY: touchEvt.clientY,									target: target,									rootEl: parent								});							}
							break;						}
						target = parent;  store last element					}					/* jshint boss:true */					while (parent = parent.parentNode);				}
				if (!supportCssPointerEvents) {					_css(ghostEl, display, );				}			}		},

		_onTouchMove: function (/**TouchEvent*/evt) {			if (tapEvt) {				var	options = this.options,					fallbackTolerance = options.fallbackTolerance,					fallbackOffset = options.fallbackOffset,					touch = evt.touches ? evt.touches[0] : evt,					dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,					dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,					translate3d = evt.touches ? translate3d( + dx + px, + dy + px,0) : translate( + dx + px, + dy + px);
				 only set the status to dragging, when we are actually dragging				if (!Sortable.active) {					if (fallbackTolerance &&						min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance					) {						return;					}
					this._dragStarted();				}
				 as well as creating the ghost element on the document body				this._appendGhost();
				moved = true;				touchEvt = touch;
				_css(ghostEl, webkitTransform, translate3d);				_css(ghostEl, mozTransform, translate3d);				_css(ghostEl, msTransform, translate3d);				_css(ghostEl, transform, translate3d);
				evt.preventDefault();			}		},
		_appendGhost: function () {			if (!ghostEl) {				var rect = dragEl.getBoundingClientRect(),					css = _css(dragEl),					options = this.options,					ghostRect;
				ghostEl = dragEl.cloneNode(true);
				_toggleClass(ghostEl, options.ghostClass, false);				_toggleClass(ghostEl, options.fallbackClass, true);				_toggleClass(ghostEl, options.dragClass, true);
				_css(ghostEl, top, rect.top - parseInt(css.marginTop, 10));				_css(ghostEl, left, rect.left - parseInt(css.marginLeft, 10));				_css(ghostEl, width, rect.width);				_css(ghostEl, height, rect.height);				_css(ghostEl, opacity, 0.8);				_css(ghostEl, position, fixed);				_css(ghostEl, zIndex, 100000);				_css(ghostEl, pointerEvents, none);
				options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
				 Fixing dimensions.				ghostRect = ghostEl.getBoundingClientRect();				_css(ghostEl, width, rect.width * 2 - ghostRect.width);				_css(ghostEl, height, rect.height * 2 - ghostRect.height);			}		},
		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {			var dataTransfer = evt.dataTransfer,				options = this.options;
			this._offUpEvents();
			if (activeGroup.checkPull(this, this, dragEl, evt)) {				cloneEl = _clone(dragEl);
				cloneEl.draggable = false;				cloneEl.style[will-change] = ;
				_css(cloneEl, display, none);				_toggleClass(cloneEl, this.options.chosenClass, false);
				rootEl.insertBefore(cloneEl, dragEl);				_dispatchEvent(this, rootEl, clone, dragEl);			}
			_toggleClass(dragEl, options.dragClass, true);
			if (useFallback) {				if (useFallback === touch) {					 Bind touch events					_on(document, touchmove, this._onTouchMove);					_on(document, touchend, this._onDrop);					_on(document, touchcancel, this._onDrop);					_on(document, pointermove, this._onTouchMove);					_on(document, pointerup, this._onDrop);				} else {					 Old brwoser					_on(document, mousemove, this._onTouchMove);					_on(document, mouseup, this._onDrop);				}
				this._loopId = setInterval(this._emulateDragOver, 50);			}			else {				if (dataTransfer) {					dataTransfer.effectAllowed = move;					options.setData && options.setData.call(this, dataTransfer, dragEl);				}
				_on(document, drop, this);				setTimeout(this._dragStarted, 0);			}		},
		_onDragOver: function (/**Event*/evt) {			var el = this.el,				target,				dragRect,				targetRect,				revert,				options = this.options,				group = options.group,				activeSortable = Sortable.active,				isOwner = (activeGroup === group),				isMovingBetweenSortable = false,				canSort = options.sort;
			if (evt.preventDefault !== void 0) {				evt.preventDefault();				!options.dragoverBubble && evt.stopPropagation();			}
			if (dragEl.animated) {				return;			}
			moved = true;
			if (activeSortable && !options.disabled &&				(isOwner					? canSort || (revert = !rootEl.contains(dragEl))  Reverting item into the original list					: (						putSortable === this ||						(							(activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&							group.checkPut(this, activeSortable, dragEl, evt)						)					)				) &&				(evt.rootEl === void 0 || evt.rootEl === this.el)  touch fallback			) {				 Smart auto-scrolling				_autoScroll(evt, options, this.el);
				if (_silent) {					return;				}
				target = _closest(evt.target, options.draggable, el);				dragRect = dragEl.getBoundingClientRect();
				if (putSortable !== this) {					putSortable = this;					isMovingBetweenSortable = true;				}
				if (revert) {					_cloneHide(activeSortable, true);					parentEl = rootEl;  actualization
					if (cloneEl || nextEl) {						rootEl.insertBefore(dragEl, cloneEl || nextEl);					}					else if (!canSort) {						rootEl.appendChild(dragEl);					}
					return;				}

				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||					(el === evt.target) && (target = _ghostIsLast(el, evt))				) {					if (target) {						if (target.animated) {							return;						}
						targetRect = target.getBoundingClientRect();					}
					_cloneHide(activeSortable, isOwner);
					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {						if (!dragEl.contains(el)) {							el.appendChild(dragEl);							parentEl = el;  actualization						}
						this._animate(dragRect, dragEl);						target && this._animate(targetRect, target);					}				}				else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {					if (lastEl !== target) {						lastEl = target;						lastCSS = _css(target);						lastParentCSS = _css(target.parentNode);					}
					targetRect = target.getBoundingClientRect();
					var width = targetRect.right - targetRect.left,						height = targetRect.bottom - targetRect.top,						floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)							|| (lastParentCSS.display == flex && lastParentCSS[flex-direction].indexOf(row) === 0),						isWide = (target.offsetWidth > dragEl.offsetWidth),						isLong = (target.offsetHeight > dragEl.offsetHeight),						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,						nextSibling = target.nextElementSibling,						moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt),						after = false					;
					if (moveVector !== false) {						_silent = true;						setTimeout(_unsilent, 30);
						_cloneHide(activeSortable, isOwner);
						if (moveVector === 1 || moveVector === -1) {							after = (moveVector === 1);						}						else if (floating) {							var elTop = dragEl.offsetTop,								tgTop = target.offsetTop;
							if (elTop === tgTop) {								after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;							}							else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {								after = (evt.clientY - targetRect.top) / height > 0.5;							} else {								after = tgTop > elTop;							}						} else if (!isMovingBetweenSortable) {							after = (nextSibling !== dragEl) && !isLong || halfway && isLong;						}
						if (!dragEl.contains(el)) {							if (after && !nextSibling) {								el.appendChild(dragEl);							} else {								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);							}						}
						parentEl = dragEl.parentNode;  actualization
						this._animate(dragRect, dragEl);						this._animate(targetRect, target);					}				}			}		},
		_animate: function (prevRect, target) {			var ms = this.options.animation;
			if (ms) {				var currentRect = target.getBoundingClientRect();
				if (prevRect.nodeType === 1) {					prevRect = prevRect.getBoundingClientRect();				}
				_css(target, transition, none);				_css(target, transform, translate3d(					+ (prevRect.left - currentRect.left) + px,					+ (prevRect.top - currentRect.top) + px,0)				);
				target.offsetWidth;  repaint
				_css(target, transition, all  + ms + ms);				_css(target, transform, translate3d(0,0,0));
				clearTimeout(target.animated);				target.animated = setTimeout(function () {					_css(target, transition, );					_css(target, transform, );					target.animated = false;				}, ms);			}		},
		_offUpEvents: function () {			var ownerDocument = this.el.ownerDocument;
			_off(document, touchmove, this._onTouchMove);			_off(document, pointermove, this._onTouchMove);			_off(ownerDocument, mouseup, this._onDrop);			_off(ownerDocument, touchend, this._onDrop);			_off(ownerDocument, pointerup, this._onDrop);			_off(ownerDocument, touchcancel, this._onDrop);			_off(ownerDocument, selectstart, this);		},
		_onDrop: function (/**Event*/evt) {			var el = this.el,				options = this.options;
			clearInterval(this._loopId);			clearInterval(autoScroll.pid);			clearTimeout(this._dragStartTimer);
			 Unbind events			_off(document, mousemove, this._onTouchMove);
			if (this.nativeDraggable) {				_off(document, drop, this);				_off(el, dragstart, this._onDragStart);			}
			this._offUpEvents();
			if (evt) {				if (moved) {					evt.preventDefault();					!options.dropBubble && evt.stopPropagation();				}
				ghostEl && ghostEl.parentNode.removeChild(ghostEl);
				if (rootEl === parentEl || Sortable.active.lastPullMode !== clone) {					 Remove clone					cloneEl && cloneEl.parentNode.removeChild(cloneEl);				}
				if (dragEl) {					if (this.nativeDraggable) {						_off(dragEl, dragend, this);					}
					_disableDraggable(dragEl);					dragEl.style[will-change] = ;
					 Remove class's					_toggleClass(dragEl, this.options.ghostClass, false);					_toggleClass(dragEl, this.options.chosenClass, false);
					if (rootEl !== parentEl) {						newIndex = _index(dragEl, options.draggable);
						if (newIndex >= 0) {							 Add event							_dispatchEvent(null, parentEl, add, dragEl, rootEl, oldIndex, newIndex);
							 Remove event							_dispatchEvent(this, rootEl, remove, dragEl, rootEl, oldIndex, newIndex);
							 drag from one list and drop into another							_dispatchEvent(null, parentEl, sort, dragEl, rootEl, oldIndex, newIndex);							_dispatchEvent(this, rootEl, sort, dragEl, rootEl, oldIndex, newIndex);						}					}					else {						if (dragEl.nextSibling !== nextEl) {							 Get the index of the dragged element within its parent							newIndex = _index(dragEl, options.draggable);
							if (newIndex >= 0) {								 drag & drop within the same list								_dispatchEvent(this, rootEl, update, dragEl, rootEl, oldIndex, newIndex);								_dispatchEvent(this, rootEl, sort, dragEl, rootEl, oldIndex, newIndex);							}						}					}
					if (Sortable.active) {						/* jshint eqnull:true */						if (newIndex == null || newIndex === -1) {							newIndex = oldIndex;						}
						_dispatchEvent(this, rootEl, end, dragEl, rootEl, oldIndex, newIndex);
						 Save sorting						this.save();					}				}
			}
			this._nulling();		},
		_nulling: function() {			rootEl =			dragEl =			parentEl =			ghostEl =			nextEl =			cloneEl =			lastDownEl =
			scrollEl =			scrollParentEl =
			tapEvt =			touchEvt =
			moved =			newIndex =
			lastEl =			lastCSS =
			putSortable =			activeGroup =			Sortable.active = null;
			savedInputChecked.forEach(function (el) {				el.checked = true;			});			savedInputChecked.length = 0;		},
		handleEvent: function (/**Event*/evt) {			switch (evt.type) {				case drop:				case dragend:					this._onDrop(evt);					break;
				case dragover:				case dragenter:					if (dragEl) {						this._onDragOver(evt);						_globalDragOver(evt);					}					break;
				case selectstart:					evt.preventDefault();					break;			}		},

		/**		 * Serializes the item into an array of string.		 *  		 */		toArray: function () {			var order = [],				el,				children = this.el.children,				i = 0,				n = children.length,				options = this.options;
			for (; i < n; i++) {				el = children[i];				if (_closest(el, options.draggable, this.el)) {					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));				}			}
			return order;		},

		/**		 * Sorts the elements according to the array.		 *       order of the items		 */		sort: function (order) {			var items = {}, rootEl = this.el;
			this.toArray().forEach(function (id, i) {				var el = rootEl.children[i];
				if (_closest(el, this.options.draggable, rootEl)) {					items[id] = el;				}			}, this);
			order.forEach(function (id) {				if (items[id]) {					rootEl.removeChild(items[id]);					rootEl.appendChild(items[id]);				}			});		},

		/**		 * Save the current sorting		 */		save: function () {			var store = this.options.store;			store && store.set(this);		},

		/**		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.		 *      		 *             default: `options.draggable`		 *  		 */		closest: function (el, selector) {			return _closest(el, selector || this.options.draggable, this.el);		},

		/**		 * Set/get option		 *     		 *          		 *  		 */		option: function (name, value) {			var options = this.options;
			if (value === void 0) {				return options[name];			} else {				options[name] = value;
				if (name === group) {					_prepareGroup(options);				}			}		},

		/**		 * Destroy		 */		destroy: function () {			var el = this.el;
			el[expando] = null;
			_off(el, mousedown, this._onTapStart);			_off(el, touchstart, this._onTapStart);			_off(el, pointerdown, this._onTapStart);
			if (this.nativeDraggable) {				_off(el, dragover, this);				_off(el, dragenter, this);			}
			 Remove draggable attributes			Array.prototype.forEach.call(el.querySelectorAll([draggable]), function (el) {				el.removeAttribute(draggable);			});
			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);
			this._onDrop();
			this.el = el = null;		}	};

	function _cloneHide(sortable, state) {		if (sortable.lastPullMode !== clone) {			state = true;		}
		if (cloneEl && (cloneEl.state !== state)) {			_css(cloneEl, display, state ? none : );
			if (!state) {				if (cloneEl.state) {					if (sortable.options.group.revertClone) {						rootEl.insertBefore(cloneEl, nextEl);						sortable._animate(dragEl, cloneEl);					} else {						rootEl.insertBefore(cloneEl, dragEl);					}				}			}
			cloneEl.state = state;		}	}

	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {		if (el) {			ctx = ctx || document;
			do {				if ((selector === >* && el.parentNode === ctx) || _matches(el, selector)) {					return el;				}				/* jshint boss:true */			} while (el = _getParentOrHost(el));		}
		return null;	}

	function _getParentOrHost(el) {		var parent = el.host;
		return (parent && parent.nodeType) ? parent : el.parentNode;	}

	function _globalDragOver(/**Event*/evt) {		if (evt.dataTransfer) {			evt.dataTransfer.dropEffect = move;		}		evt.preventDefault();	}

	function _on(el, event, fn) {		el.addEventListener(event, fn, captureMode);	}

	function _off(el, event, fn) {		el.removeEventListener(event, fn, captureMode);	}

	function _toggleClass(el, name, state) {		if (el) {			if (el.classList) {				el.classList[state ? add : remove](name);			}			else {				var className = (  + el.className +  ).replace(R_SPACE,  ).replace(  + name +  ,  );				el.className = (className + (state ?   + name : )).replace(R_SPACE,  );			}		}	}

	function _css(el, prop, val) {		var style = el && el.style;
		if (style) {			if (val === void 0) {				if (document.defaultView && document.defaultView.getComputedStyle) {					val = document.defaultView.getComputedStyle(el, );				}				else if (el.currentStyle) {					val = el.currentStyle;				}
				return prop === void 0 ? val : val[prop];			}			else {				if (!(prop in style)) {					prop = -webkit- + prop;				}
				style[prop] = val + (typeof val === string ?  : px);			}		}	}

	function _find(ctx, tagName, iterator) {		if (ctx) {			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
			if (iterator) {				for (; i < n; i++) {					iterator(list[i], i);				}			}
			return list;		}
		return [];	}


	function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {		sortable = (sortable || rootEl[expando]);
		var evt = document.createEvent(Event),			options = sortable.options,			onName = on + name.charAt(0).toUpperCase() + name.substr(1);
		evt.initEvent(name, true, true);
		evt.to = rootEl;		evt.from = fromEl || rootEl;		evt.item = targetEl || rootEl;		evt.clone = cloneEl;
		evt.oldIndex = startIndex;		evt.newIndex = newIndex;
		rootEl.dispatchEvent(evt);
		if (options[onName]) {			options[onName].call(sortable, evt);		}	}

	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt) {		var evt,			sortable = fromEl[expando],			onMoveFn = sortable.options.onMove,			retVal;
		evt = document.createEvent(Event);		evt.initEvent(move, true, true);
		evt.to = toEl;		evt.from = fromEl;		evt.dragged = dragEl;		evt.draggedRect = dragRect;		evt.related = targetEl || toEl;		evt.relatedRect = targetRect || toEl.getBoundingClientRect();
		fromEl.dispatchEvent(evt);
		if (onMoveFn) {			retVal = onMoveFn.call(sortable, evt, originalEvt);		}
		return retVal;	}

	function _disableDraggable(el) {		el.draggable = false;	}

	function _unsilent() {		_silent = false;	}

	  */	function _ghostIsLast(el, evt) {		var lastEl = el.lastElementChild,			rect = lastEl.getBoundingClientRect();
		 5 — min delta		 abs — нельзя добавлять, а то глюки при наведении сверху		return (			(evt.clientY - (rect.top + rect.height) > 5) ||			(evt.clientX - (rect.right + rect.width) > 5)		) && lastEl;	}

	/**	 * Generate id	 *     	 *  	 * 	 */	function _generateId(el) {		var str = el.tagName + el.className + el.src + el.href + el.textContent,			i = str.length,			sum = 0;
		while (i--) {			sum += str.charCodeAt(i);		}
		return sum.toString(36);	}
	/**	 * Returns the index of an element within its parent for a selected set of	 * elements	 *    	 *    	 *  	 */	function _index(el, selector) {		var index = 0;
		if (!el || !el.parentNode) {			return -1;		}
		while (el && (el = el.previousElementSibling)) {			if ((el.nodeName.toUpperCase() !== TEMPLATE) && (selector === >* || _matches(el, selector))) {				index++;			}		}
		return index;	}
	function _matches(/**HTMLElement*/el, /**String*/selector) {		if (el) {			selector = selector.split(.);
			var tag = selector.shift().toUpperCase(),				re = new RegExp(s( + selector.join(|) + )(?=s), g);
			return (				(tag ===  || el.nodeName.toUpperCase() == tag) &&				(!selector.length || ((  + el.className +  ).match(re) || []).length == selector.length)			);		}
		return false;	}
	function _throttle(callback, ms) {		var args, _this;
		return function () {			if (args === void 0) {				args = arguments;				_this = this;
				setTimeout(function () {					if (args.length === 1) {						callback.call(_this, args[0]);					} else {						callback.apply(_this, args);					}
					args = void 0;				}, ms);			}		};	}
	function _extend(dst, src) {		if (dst && src) {			for (var key in src) {				if (src.hasOwnProperty(key)) {					dst[key] = src[key];				}			}		}
		return dst;	}
	function _clone(el) {		return $			? $(el).clone(true)[0]			: (Polymer && Polymer.dom				? Polymer.dom(el).cloneNode(true)				: el.cloneNode(true)			);	}
	function _saveInputCheckedState(root) {		var inputs = root.getElementsByTagName(input);		var idx = inputs.length;
		while (idx--) {			var el = inputs[idx];			el.checked && savedInputChecked.push(el);		}	}
	 Fixed #973: 	_on(document, touchmove, function (evt) {		if (Sortable.active) {			evt.preventDefault();		}	});
	try {		window.addEventListener(test, null, Object.defineProperty({}, passive, {			get: function () {				captureMode = {					capture: false,					passive: false				};			}		}));	} catch (err) {}
	 Export utils	Sortable.utils = {		on: _on,		off: _off,		css: _css,		find: _find,		is: function (el, selector) {			return !!_closest(el, selector, el);		},		extend: _extend,		throttle: _throttle,		closest: _closest,		toggleClass: _toggleClass,		clone: _clone,		index: _index	};

	/**	 * Create sortable instance	 *    	 *        	 */	Sortable.create = function (el, options) {		return new Sortable(el, options);	};

	 Export	Sortable.version = 1.5.1;	return Sortable;});"
"module.exports = function (grunt) {	use strict;
	grunt.initConfig({		pkg: grunt.file.readJSON(package.json),
		version: {			js: {				src: [<%= pkg.exportName %>.js, *.json]			},			cdn: {				options: {					prefix: (cdnjs.cloudflare.com/ajax/libs/Sortable|cdn.jsdelivr.net/sortable)/,					replace: [0-9.]+				},				src: [README.md]			}		},
		jshint: {			all: [*.js, !*.min.js],
			options: {				jshintrc: true			}		},
		uglify: {			options: {				banner: /*! <%= pkg.exportName %> <%= pkg.version %> - <%= pkg.license %> | <%= pkg.repository.url %> */			},			dist: {				files: {					<%= pkg.exportName %>.min.js: [<%= pkg.exportName %>.js]				}			},			jquery: {				files: {}			}		},
		jquery: {}	});

	grunt.registerTask(jquery, function (exportName, uglify) {		if (exportName == min) {			exportName = null;			uglify = min;		}
		if (!exportName) {			exportName = sortable;		}
		var fs = require(fs),			filename = jquery.fn. + exportName + .js;
		grunt.log.oklns(filename);
		fs.writeFileSync(			filename,			(fs.readFileSync(jquery.binding.js) + )				.replace($.fn.sortable, $.fn. + exportName)				.replace(/* CODE */,					(fs.readFileSync(Sortable.js) + )						.replace(function(var)Export, $1)				)		);
		if (uglify) {			var opts = {};
			opts[jquery.fn. + exportName + .min.js] = filename;			grunt.config.set(uglify.jquery.files, opts);
			grunt.task.run(uglify:jquery);		}	});

	grunt.loadNpmTasks(grunt-version);	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-uglify);
	grunt.registerTask(tests, [jshint]);	grunt.registerTask(default, [tests, version, uglify:dist]);};"
"var webpack = require(webpack)var webpackDevMiddleware = require(webpack-dev-middleware)var webpackHotMiddleware = require(webpack-hot-middleware)var config = require(./webpack.config.dev)
var app = new (require(express))()var port = 3001
var compiler = webpack(config)app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }))app.use(webpackHotMiddleware(compiler))
app.get(/, function(req, res) {  res.sendFile(__dirname + /index.html)})
app.listen(port, function(error) {  if (error) {    console.error(error)  } else {    console.info(==> 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser., port, port)  }})"
"import babel-polyfill;import React, {Component} from react;import {render} from react-dom;import {SortableContainer, SortableElement, arrayMove} from ./src/index;import range from lodash/range;import random from lodash/random;
const SortableItem = SortableElement(({height, value}) => (    <div style={{        position: relative,        width: 100%,        display: block,        padding: 20,        backgroundColor: #FFF,        borderBottom: 1px solid #EFEFEF,        boxSizing: border-box,        WebkitUserSelect: none,        height: height    }}>        Item {value}    </div>));
const SortableList = SortableContainer(({items}) => (    <div style={{        width: 80%,        height: 80vh,        maxWidth: 500px,        margin: 0 auto,        overflow: auto,        backgroundColor: #f3f3f3,        border: 1px solid #EFEFEF,        borderRadius: 3    }}>        {items.map(({height, value}, index) => <SortableItem key={item-} index={index} value={value} height={height}/>)}    </div>));
class Example extends Component {    state = {        items: range(100).map((value) => {            return {                value,                height: random(49, 120)            };        })    };    onSortEnd = ({oldIndex, newIndex}) => {        let {items} = this.state;
        this.setState({            items: arrayMove(items, oldIndex, newIndex)        });    };    render() {        const {items} = this.state;
        return <SortableList items={items} onSortEnd={this.onSortEnd} />;    }}
render(<Example />,  document.getElementById(root))"
"var sass = require(node-sass);
module.exports = function processSass(data, filename) {    var result;    result = sass.renderSync({        data: data,        file: filename    }).css;    return result.toString(utf8);};"
"/** * angular-drag-and-drop-lists v2.1.0 * * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc * Copyright (c) 2014-2017 Google Inc. * https://github.com/marceljuenemann/angular-drag-and-drop-lists * * License: MIT */(function(dndLists) {
   In standard-compliant browsers we use a custom mime type and also encode the dnd-type in it.   However, IE and Edge only support a limited number of mime types. The workarounds are described   in https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design  var MIME_TYPE = application/x-dnd;  var EDGE_MIME_TYPE = application/json;  var MSIE_MIME_TYPE = Text;
   All valid HTML5 drop effects, in the order in which we prefer to use them.  var ALL_EFFECTS = [move, copy, link];
  /**   * Use the dnd-draggable attribute to make your element draggable   *   * Attributes:   * - dnd-draggable      Required attribute. The value has to be an object that represents the data   *                      of the element. In case of a drag and drop operation the object will be   *                      serialized and unserialized on the receiving end.   * - dnd-effect-allowed Use this attribute to limit the operations that can be performed. Valid   *                      options are ""move"", ""copy"" and ""link"", as well as ""all"", ""copyMove"",   *                      ""copyLink"" and ""linkMove"". The semantics of these operations are up to you   *                      and have to be implemented using the callbacks described below. If you   *                      allow multiple options, the user can choose between them by using the   *                      modifier keys (OS specific). The cursor will be changed accordingly,   *                      expect for IE and Edge, where this is not supported.   * - dnd-type           Use this attribute if you have different kinds of items in your   *                      application and you want to limit which items can be dropped into which   *                      lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute   *                      must be a lower case string. Upper case characters can be used, but will   *                      be converted to lower case automatically.   * - dnd-disable-if     You can use this attribute to dynamically disable the draggability of the   *                      element. This is useful if you have certain list items that you don't want   *                      to be draggable, or if you want to disable drag & drop completely without   *                      having two different code branches (e.g. only allow for admins).   *   * Callbacks:   * - dnd-dragstart      Callback that is invoked when the element was dragged. The original   *                      dragstart event will be provided in the local event variable.   * - dnd-moved          Callback that is invoked when the element was moved. Usually you will   *                      remove your element from the original list in this callback, since the   *                      directive is not doing that for you automatically. The original dragend   *                      event will be provided in the local event variable.   * - dnd-copied         Same as dnd-moved, just that it is called when the element was copied   *                      instead of moved, so you probably want to implement a different logic.   * - dnd-linked         Same as dnd-moved, just that it is called when the element was linked   *                      instead of moved, so you probably want to implement a different logic.   * - dnd-canceled       Callback that is invoked if the element was dragged, but the operation was   *                      canceled and the element was not dropped. The original dragend event will   *                      be provided in the local event variable.   * - dnd-dragend        Callback that is invoked when the drag operation ended. Available local   *                      variables are event and dropEffect.   * - dnd-selected       Callback that is invoked when the element was clicked but not dragged.   *                      The original click event will be provided in the local event variable.   * - dnd-callback       Custom callback that is passed to dropzone callbacks and can be used to   *                      communicate between source and target scopes. The dropzone can pass user   *                      defined variables to this callback.   *   * CSS classes:   * - dndDragging        This class will be added to the element while the element is being   *                      dragged. It will affect both the element you see while dragging and the   *                      source element that stays at it's position. Do not try to hide the source   *                      element with this class, because that will abort the drag operation.   * - dndDraggingSource  This class will be added to the element after the drag operation was   *                      started, meaning it only affects the original element that is still at   *                      it's source position, and not the ""element"" that the user is dragging with   *                      his mouse pointer.   */  dndLists.directive(dndDraggable, [$parse, $timeout, function($parse, $timeout) {    return function(scope, element, attr) {       Set the HTML5 draggable attribute on the element.      element.attr(draggable, true);
       If the dnd-disable-if attribute is set, we have to watch that.      if (attr.dndDisableIf) {        scope.$watch(attr.dndDisableIf, function(disabled) {          element.attr(draggable, !disabled);        });      }
      /**       * When the drag operation is started we have to prepare the dataTransfer object,       * which is the primary way we communicate with the target element       */      element.on(dragstart, function(event) {        event = event.originalEvent || event;
         Check whether the element is draggable, since dragstart might be triggered on a child.        if (element.attr(draggable) == false) return true;
         Initialize global state.        dndState.isDragging = true;        dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase();
         Set the allowed drop effects. See below for special IE handling.        dndState.dropEffect = none;        dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0];        event.dataTransfer.effectAllowed = dndState.effectAllowed;
         Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:         https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design        var item = scope.$eval(attr.dndDraggable);        var mimeType = MIME_TYPE + (dndState.itemType ? (- + dndState.itemType) : );        try {          event.dataTransfer.setData(mimeType, angular.toJson(item));        } catch (e) {           Setting a custom MIME type did not work, we are probably in IE or Edge.          var data = angular.toJson({item: item, type: dndState.itemType});          try {            event.dataTransfer.setData(EDGE_MIME_TYPE, data);          } catch (e) {             We are in Internet Explorer and can only use the Text MIME type. Also note that IE             does not allow changing the cursor in the dragover event, therefore we have to choose             the one we want to display now by setting effectAllowed.            var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);            event.dataTransfer.effectAllowed = effectsAllowed[0];            event.dataTransfer.setData(MSIE_MIME_TYPE, data);          }        }
         Add CSS classes. See documentation above.        element.addClass(dndDragging);        $timeout(function() { element.addClass(dndDraggingSource); }, 0);
         Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).        if (event._dndHandle && event.dataTransfer.setDragImage) {          event.dataTransfer.setDragImage(element[0], 0, 0);        }
         Invoke dragstart callback and prepare extra callback for dropzone.        $parse(attr.dndDragstart)(scope, {event: event});        if (attr.dndCallback) {          var callback = $parse(attr.dndCallback);          dndState.callback = function(params) { return callback(scope, params || {}); };        }
        event.stopPropagation();      });
      /**       * The dragend event is triggered when the element was dropped or when the drag       * operation was aborted (e.g. hit escape button). Depending on the executed action       * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.       */      element.on(dragend, function(event) {        event = event.originalEvent || event;
         Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine         the used effect, but Chrome has not implemented that field correctly. On Windows         it always sets it to 'none', while Chrome on Linux sometimes sets it to something         else when it's supposed to send 'none' (drag operation aborted).        scope.$apply(function() {          var dropEffect = dndState.dropEffect;          var cb = {copy: dndCopied, link: dndLinked, move: dndMoved, none: dndCanceled};          $parse(attr[cb[dropEffect]])(scope, {event: event});          $parse(attr.dndDragend)(scope, {event: event, dropEffect: dropEffect});        });
         Clean up        dndState.isDragging = false;        dndState.callback = undefined;        element.removeClass(dndDragging);        element.removeClass(dndDraggingSource);        event.stopPropagation();
         In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.        $timeout(function() { element.removeClass(dndDraggingSource); }, 0);      });
      /**       * When the element is clicked we invoke the callback function       * specified with the dnd-selected attribute.       */      element.on(click, function(event) {        if (!attr.dndSelected) return;
        event = event.originalEvent || event;        scope.$apply(function() {          $parse(attr.dndSelected)(scope, {event: event});        });
         Prevent triggering dndSelected in parent elements.        event.stopPropagation();      });
      /**       * Workaround to make element draggable in IE9       */      element.on(selectstart, function() {        if (this.dragDrop) this.dragDrop();      });    };  }]);
  /**   * Use the dnd-list attribute to make your list element a dropzone. Usually you will add a single   * li element as child with the ng-repeat directive. If you don't do that, we will not be able to   * position the dropped element correctly. If you want your list to be sortable, also add the   * dnd-draggable directive to your li element(s).   *   * Attributes:   * - dnd-list             Required attribute. The value has to be the array in which the data of   *                        the dropped element should be inserted. The value can be blank if used   *                        with a custom dnd-drop handler that always returns true.   * - dnd-allowed-types    Optional array of allowed item types. When used, only items that had a   *                        matching dnd-type attribute will be dropable. Upper case characters will   *                        automatically be converted to lower case.   * - dnd-effect-allowed   Optional string expression that limits the drop effects that can be   *                        performed in the list. See dnd-effect-allowed on dnd-draggable for more   *                        details on allowed options. The default value is all.   * - dnd-disable-if       Optional boolean expresssion. When it evaluates to true, no dropping   *                        into the list is possible. Note that this also disables rearranging   *                        items inside the list.   * - dnd-horizontal-list  Optional boolean expresssion. When it evaluates to true, the positioning   *                        algorithm will use the left and right halfs of the list items instead of   *                        the upper and lower halfs.   * - dnd-external-sources Optional boolean expression. When it evaluates to true, the list accepts   *                        drops from sources outside of the current browser tab. This allows to   *                        drag and drop accross different browser tabs. The only major browser   *                        that does not support this is currently Microsoft Edge.   *   * Callbacks:   * - dnd-dragover         Optional expression that is invoked when an element is dragged over the   *                        list. If the expression is set, but does not return true, the element is   *                        not allowed to be dropped. The following variables will be available:   *                        - event: The original dragover event sent by the browser.   *                        - index: The position in the list at which the element would be dropped.   *                        - type: The dnd-type set on the dnd-draggable, or undefined if non was   *                          set. Will be null for drops from external sources in IE and Edge,   *                          since we don't know the type in those cases.   *                        - dropEffect: One of move, copy or link, see dnd-effect-allowed.   *                        - external: Whether the element was dragged from an external source.   *                        - callback: If dnd-callback was set on the source element, this is a   *                          function reference to the callback. The callback can be invoked with   *                          custom variables like this: callback({var1: value1, var2: value2}).   *                          The callback will be executed on the scope of the source element. If   *                          dnd-external-sources was set and external is true, this callback will   *                          not be available.   * - dnd-drop             Optional expression that is invoked when an element is dropped on the   *                        list. The same variables as for dnd-dragover will be available, with the   *                        exception that type is always known and therefore never null. There   *                        will also be an item variable, which is the transferred object. The   *                        return value determines the further handling of the drop:   *                        - falsy: The drop will be canceled and the element won't be inserted.   *                        - true: Signalises that the drop is allowed, but the dnd-drop   *                          callback already took care of inserting the element.   *                        - otherwise: All other return values will be treated as the object to   *                          insert into the array. In most cases you want to simply return the   *                          item parameter, but there are no restrictions on what you can return.   * - dnd-inserted         Optional expression that is invoked after a drop if the element was   *                        actually inserted into the list. The same local variables as for   *                        dnd-drop will be available. Note that for reorderings inside the same   *                        list the old element will still be in the list due to the fact that   *                        dnd-moved was not called yet.   *   * CSS classes:   * - dndPlaceholder       When an element is dragged over the list, a new placeholder child   *                        element will be added. This element is of type li and has the class   *                        dndPlaceholder set. Alternatively, you can define your own placeholder   *                        by creating a child element with dndPlaceholder class.   * - dndDragover          Will be added to the list while an element is dragged over the list.   */  dndLists.directive(dndList, [$parse, function($parse) {    return function(scope, element, attr) {       While an element is dragged over the list, this placeholder element is inserted       at the location where the element would be inserted after dropping.      var placeholder = getPlaceholderElement();      placeholder.remove();
      var placeholderNode = placeholder[0];      var listNode = element[0];      var listSettings = {};
      /**       * The dragenter event is fired when a dragged element or text selection enters a valid drop       * target. According to the spec, we either need to have a dropzone attribute or listen on       * dragenter events and call preventDefault(). It should be noted though that no browser seems       * to enforce this behaviour.       */      element.on(dragenter, function (event) {        event = event.originalEvent || event;
         Calculate list properties, so that we don't have to repeat this on every dragover event.        var types = attr.dndAllowedTypes && scope.$eval(attr.dndAllowedTypes);        listSettings = {          allowedTypes: angular.isArray(types) && types.join(|).toLowerCase().split(|),          disabled: attr.dndDisableIf && scope.$eval(attr.dndDisableIf),          externalSources: attr.dndExternalSources && scope.$eval(attr.dndExternalSources),          horizontal: attr.dndHorizontalList && scope.$eval(attr.dndHorizontalList)        };
        var mimeType = getMimeType(event.dataTransfer.types);        if (!mimeType || !isDropAllowed(getItemType(mimeType))) return true;        event.preventDefault();      });
      /**       * The dragover event is triggered ""every few hundred milliseconds"" while an element       * is being dragged over our list, or over an child element.       */      element.on(dragover, function(event) {        event = event.originalEvent || event;
         Check whether the drop is allowed and determine mime type.        var mimeType = getMimeType(event.dataTransfer.types);        var itemType = getItemType(mimeType);        if (!mimeType || !isDropAllowed(itemType)) return true;
         Make sure the placeholder is shown, which is especially important if the list is empty.        if (placeholderNode.parentNode != listNode) {          element.append(placeholder);        }
        if (event.target != listNode) {           Try to find the node direct directly below the list node.          var listItemNode = event.target;          while (listItemNode.parentNode != listNode && listItemNode.parentNode) {            listItemNode = listItemNode.parentNode;          }
          if (listItemNode.parentNode == listNode && listItemNode != placeholderNode) {             If the mouse pointer is in the upper half of the list item element,             we position the placeholder before the list item, otherwise after it.            var rect = listItemNode.getBoundingClientRect();            if (listSettings.horizontal) {              var isFirstHalf = event.clientX < rect.left + rect.width / 2;            } else {              var isFirstHalf = event.clientY < rect.top + rect.height / 2;            }            listNode.insertBefore(placeholderNode,                isFirstHalf ? listItemNode : listItemNode.nextSibling);          }        }
         In IE we set a fake effectAllowed in dragstart to get the correct cursor, we therefore         ignore the effectAllowed passed in dataTransfer. We must also not access dataTransfer for         drops from external sources, as that throws an exception.        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;        var dropEffect = getDropEffect(event, ignoreDataTransfer);        if (dropEffect == none) return stopDragover();
         At this point we invoke the callback, which still can disallow the drop.         We can't do this earlier because we want to pass the index of the placeholder.        if (attr.dndDragover && !invokeCallback(attr.dndDragover, event, dropEffect, itemType)) {          return stopDragover();        }
         Set dropEffect to modify the cursor shown by the browser, unless we're in IE, where this         is not supported. This must be done after preventDefault in Firefox.        event.preventDefault();        if (!ignoreDataTransfer) {          event.dataTransfer.dropEffect = dropEffect;        }
        element.addClass(dndDragover);        event.stopPropagation();        return false;      });
      /**       * When the element is dropped, we use the position of the placeholder element as the       * position where we insert the transferred data. This assumes that the list has exactly       * one child element per array element.       */      element.on(drop, function(event) {        event = event.originalEvent || event;
         Check whether the drop is allowed and determine mime type.        var mimeType = getMimeType(event.dataTransfer.types);        var itemType = getItemType(mimeType);        if (!mimeType || !isDropAllowed(itemType)) return true;
         The default behavior in Firefox is to interpret the dropped element as URL and         forward to it. We want to prevent that even if our drop is aborted.        event.preventDefault();
         Unserialize the data that was serialized in dragstart.        try {          var data = JSON.parse(event.dataTransfer.getData(mimeType));        } catch(e) {          return stopDragover();        }
         Drops with invalid types from external sources might not have been filtered out yet.        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) {          itemType = data.type || undefined;          data = data.item;          if (!isDropAllowed(itemType)) return stopDragover();        }
         Special handling for internal IE drops, see dragover handler.        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;        var dropEffect = getDropEffect(event, ignoreDataTransfer);        if (dropEffect == none) return stopDragover();
         Invoke the callback, which can transform the transferredObject and even abort the drop.        var index = getPlaceholderIndex();        if (attr.dndDrop) {          data = invokeCallback(attr.dndDrop, event, dropEffect, itemType, index, data);          if (!data) return stopDragover();        }
         The drop is definitely going to happen now, store the dropEffect.        dndState.dropEffect = dropEffect;        if (!ignoreDataTransfer) {          event.dataTransfer.dropEffect = dropEffect;        }
         Insert the object into the array, unless dnd-drop took care of that (returned true).        if (data !== true) {          scope.$apply(function() {            scope.$eval(attr.dndList).splice(index, 0, data);          });        }        invokeCallback(attr.dndInserted, event, dropEffect, itemType, index, data);
         Clean up        stopDragover();        event.stopPropagation();        return false;      });
      /**       * We have to remove the placeholder when the element is no longer dragged over our list. The       * problem is that the dragleave event is not only fired when the element leaves our list,       * but also when it leaves a child element. Therefore, we determine whether the mouse cursor       * is still pointing to an element inside the list or not.       */      element.on(dragleave, function(event) {        event = event.originalEvent || event;
        var newTarget = document.elementFromPoint(event.clientX, event.clientY);        if (listNode.contains(newTarget) && !event._dndPhShown) {           Signalize to potential parent lists that a placeholder is already shown.          event._dndPhShown = true;        } else {          stopDragover();        }      });
      /**       * Given the types array from the DataTransfer object, returns the first valid mime type.       * A type is valid if it starts with MIME_TYPE, or it equals MSIE_MIME_TYPE or EDGE_MIME_TYPE.       */      function getMimeType(types) {        if (!types) return MSIE_MIME_TYPE;  IE 9 workaround.        for (var i = 0; i < types.length; i++) {          if (types[i] == MSIE_MIME_TYPE || types[i] == EDGE_MIME_TYPE ||              types[i].substr(0, MIME_TYPE.length) == MIME_TYPE) {            return types[i];          }        }        return null;      }
      /**       * Determines the type of the item from the dndState, or from the mime type for items from       * external sources. Returns undefined if no item type was set and null if the item type could       * not be determined.       */      function getItemType(mimeType) {        if (dndState.isDragging) return dndState.itemType || undefined;        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) return null;        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;      }
      /**       * Checks various conditions that must be fulfilled for a drop to be allowed, including the       * dnd-allowed-types attribute. If the item Type is unknown (null), the drop will be allowed.       */      function isDropAllowed(itemType) {        if (listSettings.disabled) return false;        if (!listSettings.externalSources && !dndState.isDragging) return false;        if (!listSettings.allowedTypes || itemType === null) return true;        return itemType && listSettings.allowedTypes.indexOf(itemType) != -1;      }
      /**       * Determines which drop effect to use for the given event. In Internet Explorer we have to       * ignore the effectAllowed field on dataTransfer, since we set a fake value in dragstart.       * In those cases we rely on dndState to filter effects. Read the design doc for more details:       * https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design       */      function getDropEffect(event, ignoreDataTransfer) {        var effects = ALL_EFFECTS;        if (!ignoreDataTransfer) {          effects = filterEffects(effects, event.dataTransfer.effectAllowed);        }        if (dndState.isDragging) {          effects = filterEffects(effects, dndState.effectAllowed);        }        if (attr.dndEffectAllowed) {          effects = filterEffects(effects, attr.dndEffectAllowed);        }         MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,         therefore the following modifier keys will only affect other operating systems.        if (!effects.length) {          return none;        } else if (event.ctrlKey && effects.indexOf(copy) != -1) {          return copy;        } else if (event.altKey && effects.indexOf(link) != -1) {          return link;        } else {          return effects[0];        }      }
      /**       * Small helper function that cleans up if we aborted a drop.       */      function stopDragover() {        placeholder.remove();        element.removeClass(dndDragover);        return true;      }
      /**       * Invokes a callback with some interesting parameters and returns the callbacks return value.       */      function invokeCallback(expression, event, dropEffect, itemType, index, item) {        return $parse(expression)(scope, {          callback: dndState.callback,          dropEffect: dropEffect,          event: event,          external: !dndState.isDragging,          index: index !== undefined ? index : getPlaceholderIndex(),          item: item || undefined,          type: itemType        });      }
      /**       * We use the position of the placeholder node to determine at which position of the array the       * object needs to be inserted       */      function getPlaceholderIndex() {        return Array.prototype.indexOf.call(listNode.children, placeholderNode);      }
      /**       * Tries to find a child element that has the dndPlaceholder class set. If none was found, a       * new li element is created.       */      function getPlaceholderElement() {        var placeholder;        angular.forEach(element.children(), function(childNode) {          var child = angular.element(childNode);          if (child.hasClass(dndPlaceholder)) {            placeholder = child;          }        });        return placeholder || angular.element(<li class='dndPlaceholder'></li>);      }    };  }]);
  /**   * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting   * drag operations. This is especially useful if you want to use input elements inside of   * dnd-draggable elements or create specific handle elements. Note: This directive does not work   * in Internet Explorer 9.   */  dndLists.directive(dndNodrag, function() {    return function(scope, element, attr) {       Set as draggable so that we can cancel the events explicitly      element.attr(draggable, true);
      /**       * Since the element is draggable, the browser's default operation is to drag it on dragstart.       * We will prevent that and also stop the event from bubbling up.       */      element.on(dragstart, function(event) {        event = event.originalEvent || event;
        if (!event._dndHandle) {           If a child element already reacted to dragstart and set a dataTransfer object, we will           allow that. For example, this is the case for user selections inside of input elements.          if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {            event.preventDefault();          }          event.stopPropagation();        }      });
      /**       * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element       * would be removed.       */      element.on(dragend, function(event) {        event = event.originalEvent || event;        if (!event._dndHandle) {          event.stopPropagation();        }      });    };  });
  /**   * Use the dnd-handle directive within a dnd-nodrag element in order to allow dragging with that   * element after all. Therefore, by combining dnd-nodrag and dnd-handle you can allow   * dnd-draggable elements to only be dragged via specific ""handle"" elements. Note that Internet   * Explorer will show the handle element as drag image instead of the dnd-draggable element. You   * can work around this by styling the handle element differently when it is being dragged. Use   * the CSS selector .dndDragging:not(.dndDraggingSource) [dnd-handle] for that.   */  dndLists.directive(dndHandle, function() {    return function(scope, element, attr) {      element.attr(draggable, true);
      element.on(dragstart dragend, function(event) {        event = event.originalEvent || event;        event._dndHandle = true;      });    };  });
  /**   * Filters an array of drop effects using a HTML5 effectAllowed string.   */  function filterEffects(effects, effectAllowed) {    if (effectAllowed == all) return effects;    return effects.filter(function(effect) {      return effectAllowed.toLowerCase().indexOf(effect) != -1;    });  }
  /**   * For some features we need to maintain global state. This is done here, with these fields:   * - callback: A callback function set at dragstart that is passed to internal dropzone handlers.   * - dropEffect: Set in dragstart to ""none"" and to the actual value in the drop handler. We don't   *   rely on the dropEffect passed by the browser, since there are various bugs in Chrome and   *   Safari, and Internet Explorer defaults to copy if effectAllowed is copyMove.   * - effectAllowed: Set in dragstart based on dnd-effect-allowed. This is needed for IE because   *   setting effectAllowed on dataTransfer might result in an undesired cursor.   * - isDragging: True between dragstart and dragend. Falsy for drops from external sources.   * - itemType: The item type of the dragged element set via dnd-type. This is needed because IE   *   and Edge don't support custom mime types that we can use to transfer this information.   */  var dndState = {};
})(angular.module(dndLists, []));"
"/* jshint node:true */
use strict;
module.exports = function(grunt) {
  require(load-grunt-tasks)(grunt);
   Default task.  grunt.registerTask(default, [test]);  grunt.registerTask(test, [jshint, karma:unit]);  grunt.registerTask(serve, [karma:continuous, dist, build:gh-pages, connect:continuous, watch]);  grunt.registerTask(dist, [ngmin, surround:main, uglify, surround:banner ]);  grunt.registerTask(coverage, [jshint, karma:coverage]);  grunt.registerTask(junit, [jshint, karma:junit]);

   HACK TO ACCESS TO THE COMPONENT PUBLISHER  function fakeTargetTask(prefix){    return function(){
      if (this.args.length !== 1) {        return grunt.log.fail(Just give the name of the  + prefix +  you want like :grunt  + prefix + :bower);      }
      var done = this.async();      var spawn = require(child_process).spawn;      spawn(./node_modules/.bin/gulp, [ prefix, --branch=+this.args[0] ].concat(grunt.option.flags()), {        cwd : ./node_modules/angular-ui-publisher,        stdio: inherit      }).on(close, done);    };  }
  grunt.registerTask(build, fakeTargetTask(build));  grunt.registerTask(publish, fakeTargetTask(publish));  

   HACK TO MAKE TRAVIS WORK  var testConfig = function(configFile, customOptions) {    var options = { configFile: configFile, singleRun: true };    var travisOptions = process.env.TRAVIS && {      browsers: [Chrome, Firefox],      reporters: [dots, coverage, coveralls],      preprocessors: { src/*.js: [coverage] },      coverageReporter: {        reporters: [{          type: text        }, {          type: lcov,          dir: coverage/        }]      },    };    return grunt.util._.extend(options, customOptions, travisOptions);  };  

   Project configuration.  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),    meta: {      banner: [/**,         * <%= pkg.name %> - <%= pkg.description %>,         * @version v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %>,         * @link <%= pkg.homepage %>,         * @license <%= pkg.license %>,         */,        ].join()    },
    connect: {      options: {        base : out/built/gh-pages,        open: true,        livereload: true      },      server: { options: { keepalive: true } },      continuous: { options: { keepalive: false } }    },
    coveralls: {      options: {        coverage_dir: coverage/,         debug: true         dryRun: true,         force: true,         recursive: true      }    },
    karma: {      unit: testConfig(test/karma.conf.js),      server: {configFile: test/karma.conf.js},      continuous: {configFile: test/karma.conf.js,  background: true },      coverage: {        configFile: test/karma.conf.js,        reporters: [progress, coverage],        preprocessors: { src/*.js: [coverage] },        coverageReporter: {          reporters: [{            type: text          }, {            type: lcov,            dir: coverage/          }]        },        singleRun: true      },      junit: {        configFile: test/karma.conf.js,        reporters: [progress, junit],        junitReporter: {          outputFile: junit/unit.xml,          suite: unit        },        singleRun: true      }    },
    jshint: {      src: {        files:{ src : [src/**/*.js, demo/**/*.js] },        options: { jshintrc: .jshintrc }      },      test: {        files:{ src : [ test/*.js, gruntFile.js] },        options: grunt.util._.extend({}, grunt.file.readJSON(.jshintrc), grunt.file.readJSON(test/.jshintrc))      }    },
    uglify: {      build: {        expand: true,        cwd: dist,        src: [*.js, !*.min.js],        ext: .min.js,        dest: dist      }    },
    surround: {      main: {        expand: true,        cwd: src,        src: [*.js],        dest: dist,        options: {          prepend: [(function(window, angular, undefined) {,                    use strict;].join(),          append: })(window, window.angular);        }      },      banner: {        expand: true,        cwd: dist,        src: [*.js],        dest: dist,        options: {          prepend: <%= meta.banner %>        }      }    },
    ngmin: {      main: {        expand: true,        cwd: src,        src: [*.js],        dest: dist      }    },
    changelog: {      options: {        dest: CHANGELOG.md      }    },
    watch: {      src: {        files: [src/*],        tasks: [jshint:src, karma:unit:run, dist, build:gh-pages]      },      test: {        files: [test/*.js],        tasks: [jshint:test, karma:unit:run]      },      demo: {        files: [demo/*, publish.js],        tasks: [jshint, build:gh-pages]      },      livereload: {        files: [out/built/gh-pages/**/*],        options: { livereload: true }      }    }  });
};"
require(./dist/ng-sortable);module.exports = as.sortable;
"/*jshint undef: false, unused: false, indent: 2*/
module.exports = function (grunt) {  use strict;   load all grunt tasks automatically  require(load-grunt-tasks)(grunt);
  var mountFolder = function (connect, dir) {    return connect.static(require(path).resolve(dir));  };
  var cfg = {    srcDir: source,    buildDir: dist,    demoDir: demo  };
   project configuration  grunt.initConfig({    cfg: cfg,
     watch    watch: {      livereload: {        files: [          <%= cfg.demoDir %>/**/*.js,          <%= cfg.demoDir %>/**/*.css,          <%= cfg.demoDir %>/**/*.html,          !<%= cfg.buildDir %>/*.js,          !<%= cfg.demoDir %>/dist/*.js,          !<%= cfg.demoDir %>/bower_components/**/*        ],        options: {          livereload: true        }      },      build: {        files: [          <%= cfg.srcDir %>/**/*.*,          !<%= cfg.buildDir %>/*.*        ],        tasks: [jshint:source, clean:build, concat:build, uglify:build, cssmin, copy]      },      cssmin: {        files: [          <%= cfg.srcDir %>/**/*.css        ],        tasks: [cssmin, copy]      }    },
     clean up files as part of other tasks    clean: {      build: {        src: [<%= cfg.buildDir %>/**]      },      demo: {        src: [<%= cfg.demoDir %>/dist/**]      }    },
     prepare files for demo    copy: {      build: {        expand: true,        cwd: <%= cfg.srcDir %>/,        src: [*.css],        dest: <%= cfg.buildDir %>/      },      demo: {        files: [          {            expand: true,            src: [<%= cfg.buildDir %>/*.*],            dest: <%= cfg.demoDir %>/          }        ]      }    },
    jshint: {      options: {        jshintrc: true,        reporter: require(jshint-stylish)      },      source: {        files: {          src: [<%= cfg.srcDir %>/**/*.js]        }      },      demo: {        files: {          src: [            <%= cfg.demoDir %>/**/*.js,            !<%= cfg.demoDir %>/bower_components/**/*          ]        }      }    },
     concat    concat: {      build: {        src: [          <%= cfg.srcDir %>/sortable-main.js,          <%= cfg.srcDir %>/sortable-helper.js,          <%= cfg.srcDir %>/sortable.js,          <%= cfg.srcDir %>/sortable-item-handle.js,          <%= cfg.srcDir %>/sortable-item.js        ],        dest: <%= cfg.buildDir %>/ng-sortable.js      }    },
     uglify    uglify: {      options: {        preserveComments: some,        mangle: false      },      build: {        files: {          <%= cfg.buildDir %>/ng-sortable.min.js: [<%= cfg.buildDir %>/ng-sortable.js]        }      }    },
    cssmin: {      add_banner: {        options: {          banner: /* ng-sortable css file */        },        files: {          <%= cfg.buildDir %>/ng-sortable.min.css: [<%= cfg.srcDir %>/ng-sortable.css],          <%= cfg.buildDir %>/ng-sortable.style.min.css: [<%= cfg.srcDir %>/ng-sortable.style.css]        }      }    },
     connect    connect: {      options: {        port: 9009,        livereload: 93729,        hostname: 0.0.0.0      },      demo: {        options: {          middleware: function (connect) {            return [              mountFolder(connect, )            ];          }        }      }    },
     open    open: {      server: {        path: http://localhost:<%= connect.options.port %>/<%= cfg.demoDir %>/      }    },
     karma    karma: {      options: {        configFile: karma.conf.js,        autoWatch: true      },
      single: {        singleRun: true,        browsers: [Chrome]      },
      continuous: {        singleRun: false,        browsers: [Chrome]      }    },
     available tasks    tasks_list: {      options: {},      project: {        options: {          tasks: [            {              name: build,              info: Create a build of (tested) the source files            },            {              name: serve,              info: Build the project, watch file changes and start a web server            },            {              name: test,              info: Runt tests            },            {              name: test:continuous,              info: Runt tests continuously            }          ]        }      }    }  });
   default  grunt.registerTask(default, [tasks_list:project]);  grunt.registerTask(build, [jshint:source, clean:build, concat:build, cssmin, uglify:build, copy]);  grunt.registerTask(serve, [open, connect:demo, watch]);  grunt.registerTask(test, [karma:single]);  grunt.registerTask(test:continuous, [karma:continuous]);};

"
