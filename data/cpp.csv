keywords
"#include <iostream>
 
int main()
{
  bool is_open[100] = { false };
 
  

  for (int pass = 0; pass < 100; ++pass)
    for (int door = pass; door < 100; door += pass+1)
      is_open[door] = !is_open[door];
 
  

  for (int door = 0; door < 100; ++door)
    std::cout << strv << door+1 << (is_open[door]? strv : strv) << std::endl;
  return 0;
}#include <iostream>
 
int main()
{
  int square = 1, increment = 3;
  for (int door = 1; door <= 100; ++door)
  {
    std::cout << strv << door;
    if (door == square)
    {
      std::cout << strv << std::endl;
      square += increment;
      increment += 2;
    }
    else
      std::cout << strv << std::endl;
  }
  return 0;
}#include <iostream> //compiled with strv , from RaptorOne
 
int main()
{
    for(int i=1; i*i<=100; i++)
            std::cout<<strv<<i*i<<strv<<std::endl;
}"
" 
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
 
typedef struct {
    int s[4];
}userI;
 
class jit{
public:
    void decode( std::string& file, std::vector<userI>& ui ) {
        std::ifstream f( file.c_str(), std::ios_base::in );
        fileBuffer = std::string( ( std::istreambuf_iterator<char>( f ) ), std::istreambuf_iterator<char>() );
        f.close();
        for( std::vector<userI>::iterator t = ui.begin(); t != ui.end(); t++ ) {
            if( !decode( ( *t ).s ) ) break;
        }
        std::cout << """";
    }
private:
    bool decode( int* ui ) {
        int l = 0, t = 0, p = 0, c = 0, a = 0;
        for( std::string::iterator i = fileBuffer.begin(); i != fileBuffer.end(); i++ ) {
            if( p == ui[0] && l == ui[1] && t == ui[2] && c == ui[3] ) {
                if( *i == '!' )  return false;
                std::cout << *i; return true;
            }
            if( *i == '' )      { l++; t = c = 0; }  
            else if( *i == '' ) { t++; c = 0; }
            else if( *i == '' ) { p++; l = t = c = 0; }
            else                  { c++;}
        }
        return false;
    }
    std::string fileBuffer;
};
void getUserInput( std::vector<userI>& u ) {
    std::string h = strv
                    strv;
    //std::getline( std::cin, h );
    std::stringstream ss( h );
    userI a;
    int x = 0;
    while( std::getline( ss, h, ' ' ) ) {
        a.s[x] = atoi( h.c_str() );
        if( ++x == 4 ) {
            u.push_back( a );
            x = 0;
        }
    }
}
int main( int argc, char* argv[] ) {
    std::vector<userI> ui;
    getUserInput( ui );
 
    jit j;
    j.decode( std::string( strv ), ui );
    return 0;
}
 "
" 
#include <bitset>
#include <iostream>
#include <string>
#include <assert.h>
 
uint32_t gray_encode(uint32_t b)
{
    return b ^ (b >> 1);
}
 
uint32_t gray_decode(uint32_t g)
{
    for (uint32_t bit = 1U << 31; bit > 1; bit >>= 1)
    {
        if (g & bit) g ^= bit >> 1;
    }
    return g;
}
 
std::string to_binary(int value) 

{
    const std::bitset<32> bs(value);
    const std::string str(bs.to_string());
    const size_t pos(str.find('1'));
    return pos == std::string::npos ? strv : str.substr(pos);
}
 
int main()
{
    std::cout << ""NumberBinaryGrayDecoded"";
    for (uint32_t n = 0; n < 32; ++n)
    {
        uint32_t g = gray_encode(n);
        assert(gray_decode(g) == n);
 
        std::cout << n << """" << to_binary(n) << """" << to_binary(g) << """" << g << """";
    }
}"
"bool isOdd(int x) 
{
    return x % 2;
}
 
bool isEven(int x)
{
    return !(x % 2);
} 
template < typename T > 
constexpr inline bool isEven( const T& v )
{
    return isEven( int( v ) );
}
 
template <> 
constexpr inline bool isEven< int >( const int& v )
{
    return (v & 1) == 0;
}
 
template < typename T > 
constexpr inline bool isOdd( const T& v )
{
    return !isEven(v);
}
 "
"#include <boost/math/common_factor.hpp>
#include <iostream>
 
int main( ) {
   std::cout << strv << 
      boost::math::lcm( 12 , 18 ) << "" ,""
      << strv << boost::math::gcd( 12 , 18 ) << strv << std::endl ;
   return 0 ;
}"
"#include <vector>
#include <memory>	// for auto_ptr
#include <cmath>	// for the log10 and floor functions
#include <iostream>
#include <iomanip>	// for the setw function
 
using namespace std;
 
typedef vector< int > IntRow;
typedef vector< IntRow > IntTable;
 
auto_ptr< IntTable > getZigZagArray( int dimension )
{
	auto_ptr< IntTable > zigZagArrayPtr( new IntTable(
		dimension, IntRow( dimension ) ) );
 
	

	int lastValue = dimension * dimension - 1;
	int currNum = 0;
	int currDiag = 0;
	int loopFrom;
	int loopTo;
	int i;
	int row;
	int col;
	do
	{
		if ( currDiag < dimension ) 

		{
			loopFrom = 0;
			loopTo = currDiag;
		}
		else 

		{
			loopFrom = currDiag - dimension + 1;
			loopTo = dimension - 1;
		}
 
		for ( i = loopFrom; i <= loopTo; i++ )
		{
			if ( currDiag % 2 == 0 ) 

			{
				row = loopTo - i + loopFrom;
				col = i;
			}
			else 

			{
				row = i;
				col = loopTo - i + loopFrom;
			}
 
			( *zigZagArrayPtr )[ row ][ col ] = currNum++;
		}
 
		currDiag++;
	}
	while ( currDiag <= lastValue );
 
	return zigZagArrayPtr;
}
 
void printZigZagArray( const auto_ptr< IntTable >& zigZagArrayPtr )
{
	size_t dimension = zigZagArrayPtr->size();
 
	int fieldWidth = static_cast< int >( floor( log10(
		static_cast< double >( dimension * dimension - 1 ) ) ) ) + 2;
 
	size_t col;
	for ( size_t row = 0; row < dimension; row++ )
	{
		for ( col = 0; col < dimension; col++ )
			cout << setw( fieldWidth ) << ( *zigZagArrayPtr )[ row ][ col ];
		cout << endl;
	}
}
 
int main()
{
	printZigZagArray( getZigZagArray( 5 ) );
}"
"#include <iostream>
#include <cmath>
#include <complex>
 
int main()
{
  std::cout << strv << std::pow(0,0) << std::endl;
  std::cout << strv <<
    std::pow(std::complex<double>(0),std::complex<double>(0)) << std::endl;
  return 0;
}"
"











#include <iostream>
enum class zd {N00,N01,N10,N11};
class N {
private:
  int dVal = 0, dLen;
  void _a(int i) {
    for (;; i++) {
      if (dLen < i) dLen = i;
      switch ((zd)((dVal >> (i*2)) & 3)) {
        case zd::N00: case zd::N01: return;
        case zd::N10: if (((dVal >> ((i+1)*2)) & 1) != 1) return;
                      dVal += (1 << (i*2+1)); return;
        case zd::N11: dVal &= ~(3 << (i*2)); _b((i+1)*2);
  }}}
  void _b(int pos) {
    if (pos == 0) {++*this; return;}
    if (((dVal >> pos) & 1) == 0) {
      dVal += 1 << pos;
      _a(pos/2);
      if (pos > 1) _a((pos/2)-1);
      } else {
      dVal &= ~(1 << pos);
      _b(pos + 1);
      _b(pos - ((pos > 1)? 2:1));
  }}
  void _c(int pos) {
    if (((dVal >> pos) & 1) == 1) {dVal &= ~(1 << pos); return;}
    _c(pos + 1);
    if (pos > 0) _b(pos - 1); else ++*this;
    return;
  }
public:
  N(char const* x = strv) {
    int i = 0, q = 1;
    for (; x[i] > 0; i++);
    for (dLen = --i/2; i >= 0; i--) {dVal+=(x[i]-48)*q; q*=2;
  }}
  const N& operator++() {dVal += 1; _a(0); return *this;}
  const N& operator+=(const N& other) {
    for (int GN = 0; GN < (other.dLen + 1) * 2; GN++) if ((other.dVal >> GN) & 1 == 1) _b(GN);
    return *this;
  }
  const N& operator-=(const N& other) {
    for (int GN = 0; GN < (other.dLen + 1) * 2; GN++) if ((other.dVal >> GN) & 1 == 1) _c(GN);
    for (;((dVal >> dLen*2) & 3) == 0 or dLen == 0; dLen--);
    return *this;
  }
  const N& operator*=(const N& other) {
    N Na = other, Nb = other, Nt, Nr;
    for (int i = 0; i <= (dLen + 1) * 2; i++) {
      if (((dVal >> i) & 1) > 0) Nr += Nb;
      Nt = Nb; Nb += Na; Na = Nt;
    }
    return *this = Nr;
  }
  const bool operator<=(const N& other) const {return dVal <= other.dVal;}
  friend std::ostream& operator<<(std::ostream&, const N&);
};
N operator strv N(char const* x) {return N(x);}
std::ostream &operator<<(std::ostream &os, const N &G) {
  const static std::string dig[] {strv,strv,strv}, dig1[] {strv,strv,strv};
  if (G.dVal == 0) return os << strv;
  os << dig1[(G.dVal >> (G.dLen*2)) & 3];
  for (int i = G.dLen-1; i >= 0; i--) os << dig[(G.dVal >> (i*2)) & 3];
  return os;
}
 int main(void) {
  N G;
  G = 10N;
  G += 10N;
  std::cout << G << std::endl;
  G += 10N;
  std::cout << G << std::endl;
  G += 1001N;
  std::cout << G << std::endl;
  G += 1000N;
  std::cout << G << std::endl;
  G += 10101N;
  std::cout << G << std::endl;
  return 0;
}int main(void) {
  N G;
  G = 1000N;
  G -= 101N;
  std::cout << G << std::endl;
  G = 10101010N;
  G -= 1010101N;
  std::cout << G << std::endl;
  return 0;
} 
int main(void) {
  N G = 1001N;
  G *= 101N;
  std::cout << G << std::endl;
 
  G = 101010N;
  G += 101N;
  std::cout << G << std::endl;
  return 0;
}"
" 








#include <iostream>
class N {
private:
  int dVal = 0, dLen;
public:
  N(char const* x = strv){
    int i = 0, q = 1;
    for (; x[i] > 0; i++);
    for (dLen = --i/2; i >= 0; i--) {
      dVal+=(x[i]-48)*q;
      q*=2;
  }}
  const N& operator++() {
    for (int i = 0;;i++) {
      if (dLen < i) dLen = i;
      switch ((dVal >> (i*2)) & 3) {
        case 0: dVal += (1 << (i*2)); return *this;
        case 1: dVal += (1 << (i*2)); if (((dVal >> ((i+1)*2)) & 1) != 1) return *this;
        case 2: dVal &= ~(3 << (i*2));
  }}}
  const bool operator<=(const N& other) const {return dVal <= other.dVal;}
  friend std::ostream& operator<<(std::ostream&, const N&);
};
N operator strv N(char const* x) {return N(x);}
std::ostream &operator<<(std::ostream &os, const N &G) {
  const static std::string dig[] {strv,strv,strv}, dig1[] {strv,strv,strv};
  if (G.dVal == 0) return os << strv;
  os << dig1[(G.dVal >> (G.dLen*2)) & 3];
  for (int i = G.dLen-1; i >= 0; i--) os << dig[(G.dVal >> (i*2)) & 3];
  return os;
}
  
int main(void) {
//for (N G; G <= 101010N; ++G) std::cout << G << std::endl;       // from zero to 101010M
  for (N G(101N); G <= 101010N; ++G) std::cout << G << std::endl; 

  return 0;
}
 "
"#include <vector>
#include <utility>
#include <iostream>
#include <boost/algorithm/string.hpp>
 
std::string create_xml( std::vector<std::string> & ,std::vector<std::string> & ) ;
 
int main( ) {
   std::vector<std::string> names , remarks ;
   names.push_back( strv ) ;
   names.push_back( strv ) ;
   names.push_back ( strv ) ;
   remarks.push_back( strv ) ;
   remarks.push_back( ""Burns: When chapman billies leave the street ..."" ) ;
   remarks.push_back( strv ) ;
   std::cout << ""This is in XML:"" ;
   std::cout << create_xml( names , remarks ) << std::endl ;
   return 0 ;
}
 
std::string create_xml( std::vector<std::string> & names ,
      std::vector<std::string> & remarks ) {
   std::vector<std::pair<std::string , std::string> > entities ;
   entities.push_back( std::make_pair( strv , strv ) ) ;
   entities.push_back( std::make_pair( strv , strv ) ) ;
   entities.push_back( std::make_pair( strv , strv ) ) ;
   std::string xmlstring ( ""<CharacterRemarks>"" ) ;
   std::vector<std::string>::iterator vsi = names.begin( ) ;
   typedef std::vector<std::pair<std::string , std::string> >::iterator Vpss ;
   for ( ; vsi != names.end( ) ; vsi++ ) {
      for ( Vpss vs = entities.begin( ) ; vs != entities.end( ) ; vs++ ) {
	 boost::replace_all ( *vsi , vs->first , vs->second ) ;
      }
   }
   for ( vsi = remarks.begin( ) ; vsi != remarks.end( ) ; vsi++ ) {
      for ( Vpss vs = entities.begin( ) ; vs != entities.end( ) ; vs++ ) {
	 boost::replace_all ( *vsi , vs->first , vs->second ) ;
      }
   }
   for ( int i = 0 ; i < names.size( ) ; i++ ) {
      xmlstring.append( ""<Character name="").append( names[ i ] ).append( "">"")
	 .append( remarks[ i ] ).append( ""</Character>"" ) ;
   }
   xmlstring.append( strv ) ;
   return xmlstring ;
}"
"#include <iostream>
#include <functional>
 
template <typename F>
struct RecursiveFunc {
	std::function<F(RecursiveFunc)> o;
};
 
template <typename A, typename B>
std::function<B(A)> Y (std::function<std::function<B(A)>(std::function<B(A)>)> f) {
	RecursiveFunc<std::function<B(A)>> r = {
		std::function<std::function<B(A)>(RecursiveFunc<std::function<B(A)>>)>([f](RecursiveFunc<std::function<B(A)>> w) {
			return f(std::function<B(A)>([w](A x) {
				return w.o(w)(x);
			}));
		})
	};
	return r.o(r);
}
 
typedef std::function<int(int)> Func;
typedef std::function<Func(Func)> FuncFunc;
FuncFunc almost_fac = [](Func f) {
	return Func([f](int n) {
		if (n <= 1) return 1;
		return n * f(n - 1);
	});
};
 
FuncFunc almost_fib = [](Func f) {
	return Func([f](int n) {
	 	if (n <= 2) return 1;
		return  f(n - 1) + f(n - 2);
	});
};
 
int main() {
	auto fib = Y(almost_fib);
	auto fac = Y(almost_fac);
	std::cout << strv << fib(10) << std::endl;
	std::cout << strv << fac(10) << std::endl;
	return 0;
}#include <iostream>
#include <functional>
int main () {
  auto y = ([] (auto f) { return
              ([] (auto x) { return x (x); }
                 ([=] (auto y) -> std:: function <int (int)> { return
                    f ([=] (auto a) { return
                          (y (y)) (a) ;});}));});
 
  auto almost_fib = [] (auto f) { return
                       [=] (auto n) { return
                         n < 2? n: f (n - 1) + f (n - 2) ;};};
  auto almost_fac = [] (auto f) { return 
                       [=] (auto n) { return 
                         n <= 1? n: n * f (n - 1); };};
 
  auto fib = y (almost_fib);
  auto fac = y (almost_fac);
  std:: cout << fib (10) << '' 
             << fac (10) << '';
}template <typename A, typename B>
std::function<B(A)> Y (std::function<std::function<B(A)>(std::function<B(A)>)> f) {
	return [f](A x) {
		return f(Y(f))(x);
	};
}template <typename A, typename B>
struct YFunctor {
  const std::function<std::function<B(A)>(std::function<B(A)>)> f;
  YFunctor(std::function<std::function<B(A)>(std::function<B(A)>)> _f) : f(_f) {}
  B operator()(A x) const {
    return f(*this)(x);
  }
};
 
template <typename A, typename B>
std::function<B(A)> Y (std::function<std::function<B(A)>(std::function<B(A)>)> f) {
  return YFunctor<A,B>(f);
}"
"#include <vector>
#include <string>
#include <iostream>
#include <boost/regex.hpp>
#include <algorithm>
#include <iterator>
 
int main( ) {
   const std::string xmltext( 
      ""<inventory title=OmniCorp Store #45x10^3>""
	""<section name=health>""
	  ""<item upc=123456789 stock=12>""
	    strv
	    strv
	    strv
	  strv
	  ""<item upc=445322344 stock=18>""
	    strv
	    strv
	    strv
	  strv
	strv
	""<section name=food>""
	  ""<item upc=485672034 stock=653>""
	    strv
	    strv
	    strv
	  strv
	  ""<item upc=132957764 stock=44>""
	    strv
	    strv
	    strv
	  strv
	strv
      strv ) ;
   std::string::size_type found = xmltext.find( strv , 0 ) ; //beginning of first item
   std::string::size_type foundnext = xmltext.find(  strv , found + 5 ) ; //and its end
   std::cout << ""The first item is"" << xmltext.substr( found + 5 , foundnext - ( found + 5 ) ) << '' ;
   std::string::const_iterator start , end ;
   start = xmltext.begin( ) ;
   end = xmltext.end( ) ;
   boost::match_results<std::string::const_iterator> what ;
   boost::regex pricefind( ""<price>(d+.?d+)</price>"" ) ;//this regex finds the prices
   start = xmltext.begin( ) ;
   std::cout << ""The prices are:"" ;
   while ( boost::regex_search( start , end , what , pricefind ) ) { 
      std::string price( what[ 1 ].first , what[ 1 ].second ) ;//find the first price
      std::cout << price << std::endl ;                        
      start = what[ 1 ].second ;                               //continue search after first price found
   }
   start = xmltext.begin( ) ;
   std::vector<std::string> names ;
   boost::regex namefind( strv ) ;            //find characters, be greedy!
   while ( boost::regex_search ( start , end , what , namefind ) ) {
      std::string name ( what[ 1 ].first , what[ 1 ].second ) ;
      names.push_back( name ) ;
      start = what[ 1 ].second ;
   }
   std::cout << ""The following name elements were found in the xml string:"" ;
   std::copy( names.begin( ) , names.end( ) , std::ostream_iterator<std::string>( std::cout , """" )) ;
   return 0 ;
}"
"/*Using the Qt library's XML parser.*/
#include <iostream>
 
#include <QDomDocument>
#include <QObject>
 
int main() {
    QDomDocument doc;
 
    doc.setContent(
       QObject::tr(
          ""<Students>""
          ""<Student Name=April Gender=F DateOfBirth=1989-01-02 />""
          ""<Student Name=Bob Gender=M  DateOfBirth=1990-03-04 />""
          ""<Student Name=Chad Gender=M  DateOfBirth=1991-05-06 />""
          ""<Student Name=Dave Gender=M  DateOfBirth=1992-07-08>""
          ""<Pet Type=dog Name=Rover />""
          ""</Student>""
          ""<Student DateOfBirth=1993-09-10 Gender=F Name=&#x00C9;mily />""
          strv));
 
    QDomElement n = doc.documentElement().firstChildElement(strv);
    while(!n.isNull()) {
        std::cout << qPrintable(n.attribute(strv)) << std::endl;
        n = n.nextSiblingElement();
    }
    return 0;
}"
"template<class InputIterator, class InputIterator2>
void writedat(const char* filename,
              InputIterator xbegin, InputIterator xend,
              InputIterator2 ybegin, InputIterator2 yend,
              int xprecision=3, int yprecision=5)
{
  std::ofstream f;
  f.exceptions(std::ofstream::failbit | std::ofstream::badbit);
  f.open(filename);
  for ( ; xbegin != xend and ybegin != yend; ++xbegin, ++ybegin)
    f << std::setprecision(xprecision) << *xbegin << ''
      << std::setprecision(yprecision) << *ybegin << '';
}#include <algorithm>
#include <cmath>    // ::sqrt()
#include <fstream>
#include <iomanip>  // setprecision()
#include <iostream>
#include <string>
#include <vector>
 
int main()
{
  try {
    

    double x[] = {1, 2, 3, 1e11};
    const size_t xsize = sizeof(x) / sizeof(*x);
    std::vector<double> y(xsize);
    std::transform(&x[0], &x[xsize], y.begin(), ::sqrt);
 
    

    writedat(strv, &x[0], &x[xsize], y.begin(), y.end());
 
    

    std::ifstream f(strv);
    for (std::string line; std::getline(f, line); )
      std::cout << line << std::endl;
  }
  catch(std::exception& e) {
    std::cerr << strv << e.what() << ""'"";
    return 1;
  }
  return 0;
}"
" 
#include <stdio.h>
#include <string.h>
 
#define defenum(name, val0, val1, val2, val3, val4) \    enum name { val0, val1, val2, val3, val4 }; \    const char *name ## _str[] = { # val0, # val1, # val2, # val3, # val4 }
 
defenum( Attrib,    Color, Man, Drink, Animal, Smoke );
defenum( Colors,    Red, Green, White, Yellow, Blue );
defenum( Mans,      English, Swede, Dane, German, Norwegian );
defenum( Drinks,    Tea, Coffee, Milk, Beer, Water );
defenum( Animals,   Dog, Birds, Cats, Horse, Zebra );
defenum( Smokes,    PallMall, Dunhill, Blend, BlueMaster, Prince );
 
void printHouses(int ha[5][5]) {
    const char **attr_names[5] = {Colors_str, Mans_str, Drinks_str, Animals_str, Smokes_str};
 
    printf(strv, strv);
    for (const char *name : Attrib_str) printf(strv, name);
    printf("""");
 
    for (int i = 0; i < 5; i++) {
        printf(strv, i);
        for (int j = 0; j < 5; j++) printf(strv, attr_names[j][ha[i][j]]);
        printf("""");
    }
}
 
struct HouseNoRule {
    int houseno;
    Attrib a; int v;
} housenos[] = {
    {2, Drink, Milk},     

    {0, Man, Norwegian}   

};
 
struct AttrPairRule {
    Attrib a1; int v1;
    Attrib a2; int v2;
 
    bool invalid(int ha[5][5], int i) {
        return (ha[i][a1] >= 0 && ha[i][a2] >= 0) &&
               ((ha[i][a1] == v1 && ha[i][a2] != v2) ||
                (ha[i][a1] != v1 && ha[i][a2] == v2));
    }
} pairs[] = {
    {Man, English,      Color, Red},     

    {Man, Swede,        Animal, Dog},    

    {Man, Dane,         Drink, Tea},     

    {Color, Green,      Drink, Coffee},  

    {Smoke, PallMall,   Animal, Birds},  

    {Smoke, Dunhill,    Color, Yellow},  

    {Smoke, BlueMaster, Drink, Beer},    

    {Man, German,       Smoke, Prince}    

};
 
struct NextToRule {
    Attrib a1; int v1;
    Attrib a2; int v2;
 
    bool invalid(int ha[5][5], int i) {
        return (ha[i][a1] == v1) &&
               ((i == 0 && ha[i + 1][a2] >= 0 && ha[i + 1][a2] != v2) ||
                (i == 4 && ha[i - 1][a2] != v2) ||
                (ha[i + 1][a2] >= 0 && ha[i + 1][a2] != v2 && ha[i - 1][a2] != v2));
    }
} nexttos[] = {
    {Smoke, Blend,      Animal, Cats},    

    {Smoke, Dunhill,    Animal, Horse},   

    {Man, Norwegian,    Color, Blue},     

    {Smoke, Blend,      Drink, Water}     

};
 
struct LeftOfRule {
    Attrib a1; int v1;
    Attrib a2; int v2;
 
    bool invalid(int ha[5][5]) {
        return (ha[0][a2] == v2) || (ha[4][a1] == v1);
    }
 
    bool invalid(int ha[5][5], int i) {
        return ((i > 0 && ha[i][a1] >= 0) &&
                ((ha[i - 1][a1] == v1 && ha[i][a2] != v2) ||
                 (ha[i - 1][a1] != v1 && ha[i][a2] == v2)));
    }
} leftofs[] = {
    {Color, Green,  Color, White}     

};
 
bool invalid(int ha[5][5]) {
    for (auto &rule : leftofs) if (rule.invalid(ha)) return true;
 
    for (int i = 0; i < 5; i++) {
#define eval_rules(rules) for (auto &rule : rules) if (rule.invalid(ha, i)) return true;
        eval_rules(pairs);
        eval_rules(nexttos);
        eval_rules(leftofs);
    }
    return false;
}
 
void search(bool used[5][5], int ha[5][5], const int hno, const int attr) {
    int nexthno, nextattr;
    if (attr < 4) {
        nextattr = attr + 1;
        nexthno = hno;
    } else {
        nextattr = 0;
        nexthno = hno + 1;
    }
 
    if (ha[hno][attr] != -1) {
        search(used, ha, nexthno, nextattr);
    } else {
        for (int i = 0; i < 5; i++) {
            if (used[attr][i]) continue;
            used[attr][i] = true;
            ha[hno][attr] = i;
 
            if (!invalid(ha)) {
                if ((hno == 4) && (attr == 4)) {
                    printHouses(ha);
                } else {
                    search(used, ha, nexthno, nextattr);
                }
            }
 
            used[attr][i] = false;
        }
        ha[hno][attr] = -1;
    }
}
 
int main() {
    bool used[5][5] = {};
    int ha[5][5]; memset(ha, -1, sizeof(ha));
 
    for (auto &rule : housenos) {
        ha[rule.houseno][rule.a] = rule.v;
        used[rule.a][rule.v] = true;
    }
 
    search(used, ha, 0, 0);
 
    return 0;
}
 "
" 
#include <iomanip>
#include <ctime>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <fstream>
 
const int WID = 10, HEI = 10, MIN_WORD_LEN = 3, MIN_WORD_CNT = 25;
 
class Cell {
public:
    Cell() : val( 0 ), cntOverlap( 0 ) {}
    char val; int cntOverlap;
};
class Word {
public:
    Word( std::string s, int cs, int rs, int ce, int re, int dc, int dr ) : 
      word( s ), cols( cs ), rows( rs ), cole( ce ), rowe( re ), dx( dc ), dy( dr ) {}
    bool operator ==( const std::string& s ) { return 0 == word.compare( s ); }
    std::string word;
    int cols, rows, cole, rowe, dx, dy;
};
class words {
public:
    void create( std::string& file ) {
        std::ifstream f( file.c_str(), std::ios_base::in );
        std::string word;
        while( f >> word ) {
            if( word.length() < MIN_WORD_LEN || word.length() > WID || word.length() > HEI ) continue;
            if( word.find_first_not_of( strv ) != word.npos ) continue;
            dictionary.push_back( word );
        }
        f.close();
        std::random_shuffle( dictionary.begin(), dictionary.end() );
        buildPuzzle();
    }
 
    void printOut() {
        std::cout << """";
        for( int x = 0; x < WID; x++ ) std::cout << x << strv;
        std::cout << """";
        for( int y = 0; y < HEI; y++ ) {
            std::cout << y << """";
            for( int x = 0; x < WID; x++ )
                std::cout << puzzle[x][y].val << strv;
            std::cout << """";
        }
        size_t wid1 = 0, wid2 = 0;
        for( size_t x = 0; x < used.size(); x++ ) {
            if( x & 1 ) {
                if( used[x].word.length() > wid1 ) wid1 = used[x].word.length();
            } else {
                if( used[x].word.length() > wid2 ) wid2 = used[x].word.length();
            }
        }
        std::cout << """";
        std::vector<Word>::iterator w = used.begin();
        while( w != used.end() ) {
            std::cout << std::right << std::setw( wid1 ) << ( *w ).word << strv << ( *w ).cols << strv << ( *w ).rows << strv 
                      << ( *w ).cole << strv << ( *w ).rowe << "")"";
            w++;
            if( w == used.end() ) break;
            std::cout << std::setw( wid2 ) << ( *w ).word << strv << ( *w ).cols << strv << ( *w ).rows << strv 
                      << ( *w ).cole << strv << ( *w ).rowe << "")"";
            w++;
        }
        std::cout << """";
    }
private:
    void addMsg() {
        std::string msg = strv;
        int stp = 9, p = rand() % stp;
        for( size_t x = 0; x < msg.length(); x++ ) {
            puzzle[p % WID][p / HEI].val = msg.at( x );
            p += rand() % stp + 4;
        }
    }
    int getEmptySpaces() {
        int es = 0;
        for( int y = 0; y < HEI; y++ ) {
            for( int x = 0; x < WID; x++ ) {
                if( !puzzle[x][y].val ) es++;
            }
        }
        return es;
    }
    bool check( std::string word, int c, int r, int dc, int dr ) {
        for( size_t a = 0; a < word.length(); a++ ) {
            if( c < 0 || r < 0 || c >= WID || r >= HEI ) return false;
            if( puzzle[c][r].val && puzzle[c][r].val != word.at( a ) ) return false;
            c += dc; r += dr;
        }
        return true;
    }
    bool setWord( std::string word, int c, int r, int dc, int dr ) {
        if( !check( word, c, r, dc, dr ) ) return false;
        int sx = c, sy = r;
        for( size_t a = 0; a < word.length(); a++ ) {
            if( !puzzle[c][r].val ) puzzle[c][r].val = word.at( a );
            else puzzle[c][r].cntOverlap++;
            c += dc; r += dr;
        }
        used.push_back( Word( word, sx, sy, c - dc, r - dr, dc, dr ) );
        return true;
    }
    bool add2Puzzle( std::string word ) {
        int x = rand() % WID, y = rand() % HEI,
            z = rand() % 8;
        for( int d = z; d < z + 8; d++ ) {
            switch( d % 8 ) {
                case 0: if( setWord( word, x, y,  1,  0 ) ) return true; break;
                case 1: if( setWord( word, x, y, -1, -1 ) ) return true; break;
                case 2: if( setWord( word, x, y,  0,  1 ) ) return true; break;
                case 3: if( setWord( word, x, y,  1, -1 ) ) return true; break;
                case 4: if( setWord( word, x, y, -1,  0 ) ) return true; break;
                case 5: if( setWord( word, x, y, -1,  1 ) ) return true; break;
                case 6: if( setWord( word, x, y,  0, -1 ) ) return true; break;
                case 7: if( setWord( word, x, y,  1,  1 ) ) return true; break;
            }
        }
        return false;
    }
    void clearWord() {
        if( used.size() ) {
            Word lastW = used.back();
            used.pop_back();
 
            for( size_t a = 0; a < lastW.word.length(); a++ ) {
                if( puzzle[lastW.cols][lastW.rows].cntOverlap == 0 ) {
                    puzzle[lastW.cols][lastW.rows].val = 0;
                }
                if( puzzle[lastW.cols][lastW.rows].cntOverlap > 0 ) {
                    puzzle[lastW.cols][lastW.rows].cntOverlap--;
                }
                lastW.cols += lastW.dx; lastW.rows += lastW.dy;
            }
        }
    }
    void buildPuzzle() {
        addMsg();
        int es = 0, cnt = 0;
        size_t idx = 0;
        do {
            for( std::vector<std::string>::iterator w = dictionary.begin(); w != dictionary.end(); w++ ) {
                if( std::find( used.begin(), used.end(), *w ) != used.end() ) continue;
 
                if( add2Puzzle( *w ) ) {
                    es = getEmptySpaces();
                    if( !es && used.size() >= MIN_WORD_CNT ) 
                        return;
                }
            }
            clearWord();
            std::random_shuffle( dictionary.begin(), dictionary.end() );
 
        } while( ++cnt < 100 );
    }
    std::vector<Word> used;
    std::vector<std::string> dictionary;
    Cell puzzle[WID][HEI];
};
int main( int argc, char* argv[] ) {
    unsigned s = unsigned( time( 0 ) );
    srand( s );
    words w; w.create( std::string( strv ) );
    w.printOut();
    return 0;
}
 "
" 
#include <windows.h>
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
int main(int argc, char* argv[])
{
	cout << 
		strv << endl <<
		""        _____     _____|        _____|      "" << endl <<
		""   _____    _  /     / |     | /     / |     |"" << endl <<
		strv << endl <<
		"" /     / /____/||      |____/ ||      |____/ |"" << endl <<
		""|     | |____|/ |         | / |         | / "" << endl <<
		""|     |  _____  |      ___|/  |      ___|/  "" << endl <<
		""|     |     |             |             "" << endl <<
		""| _____|    |    _____        _____     "" << endl <<
		""| |     /____/|    |     |        |     |     "" << endl <<
		"" |_____|    ||    |_____|        |_____|     "" << endl <<
		strv;
 
	cout << endl << endl << endl;
 
	system( strv );
	return 0;
}
//--------------------------------------------------------------------------------------------------
  






 
#include <iostream>
#include <string>
 
int main()
{
    std::string strAscii3D =
        ""  /$$$$$$  /$$$$$$$  /$$$$$$$ ""
        "" /$$__  $$| $$__  $$| $$__  $$""
        ""| $$  __/| $$   $$| $$   $$""
        ""| $$      | $$$$$$$/| $$$$$$$/""
        ""| $$      | $$____/ | $$____/ ""
        ""| $$    $$| $$      | $$      ""
        ""|  $$$$$$/| $$      | $$      ""
        "" ______/ |__/      |__/  "";
 
    std::cout << """" << strAscii3D << std::endl;
 
    return 0;
}
 "
"#include <ggi/ggi.h>
#include <set>
#include <map>
#include <utility>
#include <iostream>
#include <fstream>
#include <string>
 
#include <unistd.h> // for usleep
 
enum cell_type { none, wire, head, tail };
 






 


 
class display
{
public:
  display(int sizex, int sizey, int pixsizex, int pixsizey,
          ggi_color* colors);
  ~display()
  {
    ggiClose(visual);
    ggiExit();
  }
 
  void flush();
  bool keypressed() { return ggiKbhit(visual); }
  void clear();
  void putpixel(int x, int y, cell_type c);
private:
  ggi_visual_t visual;
  int size_x, size_y;
  int pixel_size_x, pixel_size_y;
  ggi_pixel pixels[4];
};
 
display::display(int sizex, int sizey, int pixsizex, int pixsizey,
                 ggi_color* colors):
  pixel_size_x(pixsizex),
  pixel_size_y(pixsizey)
{
  if (ggiInit() < 0)
  {
    std::cerr << ""couldn't open ggi"";
    exit(1);
  }
 
  visual = ggiOpen(NULL);
  if (!visual)
  {
    ggiPanic(""couldn't open visual"");
  }
 
  ggi_mode mode;
  if (ggiCheckGraphMode(visual, sizex, sizey,
                        GGI_AUTO, GGI_AUTO, GT_4BIT,
                        &mode) != 0)
  {
    if (GT_DEPTH(mode.graphtype) < 2) 

      ggiPanic(""low-color displays are not supported!"");
  }
  if (ggiSetMode(visual, &mode) != 0)
  {
    ggiPanic(""couldn't set graph mode"");
  }
  ggiAddFlags(visual, GGIFLAG_ASYNC);
 
  size_x = mode.virt.x;
  size_y = mode.virt.y;
 
  for (int i = 0; i < 4; ++i)
    pixels[i] = ggiMapColor(visual, colors+i);
}
 
void display::flush()
{
  

  ggiSetDisplayFrame(visual, ggiGetWriteFrame(visual));
 
  

  ggiFlush(visual);
 
  

  

  

  ggiSetWriteFrame(visual, 1-ggiGetDisplayFrame(visual));
}
 
void display::clear()
{
  ggiSetGCForeground(visual, pixels[0]);
  ggiDrawBox(visual, 0, 0, size_x, size_y);
}
 
void display::putpixel(int x, int y, cell_type cell)
{
  

  

  ggiSetGCForeground(visual, pixels[cell]);
  ggiDrawBox(visual,
             x*pixel_size_x, y*pixel_size_y,
             pixel_size_x, pixel_size_y);
}
 






 


class wireworld
{
public:
  void set(int posx, int posy, cell_type type);
  void draw(display& destination);
  void step();
private:
  typedef std::pair<int, int> position;
  typedef std::set<position> position_set;
  typedef position_set::iterator positer;
  position_set wires, heads, tails;
};
 
void wireworld::set(int posx, int posy, cell_type type)
{
  position p(posx, posy);
  wires.erase(p);
  heads.erase(p);
  tails.erase(p);
  switch(type)
  {
  case head:
    heads.insert(p);
    break;
  case tail:
    tails.insert(p);
    break;
  case wire:
    wires.insert(p);
    break;
  }
}
 
void wireworld::draw(display& destination)
{
  destination.clear();
  for (positer i = heads.begin(); i != heads.end(); ++i)
    destination.putpixel(i->first, i->second, head);
  for (positer i = tails.begin(); i != tails.end(); ++i)
    destination.putpixel(i->first, i->second, tail);
  for (positer i = wires.begin(); i != wires.end(); ++i)
    destination.putpixel(i->first, i->second, wire);
  destination.flush();
}
 
void wireworld::step()
{
  std::map<position, int> new_heads;
  for (positer i = heads.begin(); i != heads.end(); ++i)
    for (int dx = -1; dx <= 1; ++dx)
      for (int dy = -1; dy <= 1; ++dy)
      {
        position pos(i->first + dx, i->second + dy);
        if (wires.count(pos))
          new_heads[pos]++;
      }
  wires.insert(tails.begin(), tails.end());
  tails.swap(heads);
  heads.clear();
  for (std::map<position, int>::iterator i = new_heads.begin();
       i != new_heads.end();
       ++i)
  {


    if (i->second < 3)
    {
      wires.erase(i->first);
      heads.insert(i->first);
    }
  }
}
 
ggi_color colors[4] =
  {{ 0x0000, 0x0000, 0x0000 },  

   { 0x8000, 0x8000, 0x8000 },  

   { 0xffff, 0xffff, 0x0000 },  

   { 0xffff, 0x0000, 0x0000 }}; 

 
int main(int argc, char* argv[])
{
  int display_x = 800;
  int display_y = 600;
  int pixel_x = 5;
  int pixel_y = 5;
 
  if (argc < 2)
  {
    std::cerr << ""No file name given!"";
    return 1;
  }
 
  

  std::ifstream f(argv[1]);
  wireworld w;
  std::string line;
  int line_number = 0;
  while (std::getline(f, line))
  {
    for (int col = 0; col < line.size(); ++col)
    {
      switch (line[col])
      {
      case 'h': case 'H':
        w.set(col, line_number, head);
        break;
      case 't': case 'T':
        w.set(col, line_number, tail);
        break;
      case 'w': case 'W': case '.':
        w.set(col, line_number, wire);
        break;
      default:
        std::cerr << strv << line[col] << """";
        return 1;
      case ' ':
        ; 

      }
    }
    ++line_number;
  }
 
  display d(display_x, display_y, pixel_x, pixel_y, colors);
 
  w.draw(d);
 
  while (!d.keypressed())
  {
    usleep(100000);
    w.step();
    w.draw(d);
  }
  std::cout << std::endl;
}"
"#include <iostream>
#include <sstream>
#include <string>
 
const char *text =
{
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
};
 
std::string wrap(const char *text, size_t line_length = 72)
{
    std::istringstream words(text);
    std::ostringstream wrapped;
    std::string word;
 
    if (words >> word) {
        wrapped << word;
        size_t space_left = line_length - word.length();
        while (words >> word) {
            if (space_left < word.length() + 1) {
                wrapped << '' << word;
                space_left = line_length - word.length();
            } else {
                wrapped << ' ' << word;
                space_left -= word.length() + 1;
            }
        }
    }
    return wrapped.str();
}
 
int main()
{
    std::cout << ""Wrapped at 72:"" << wrap(text) << """";
    std::cout << ""Wrapped at 80:"" << wrap(text, 80) << """";
}"
"#include <iostream>
#include <string>
#include <boost/asio.hpp>
#include <boost/regex.hpp>
int main()
{
    boost::asio::ip::tcp::iostream s(strv, strv);
    if(!s)
        std::cout << ""Could not connect to tycho.usno.navy.mil"";
    s  << ""GET /cgi-bin/timer.pl HTTP/1.0""
       << ""Host: tycho.usno.navy.mil""
       << ""Accept: */*""
       << ""Connection: close"" ;
    for(std::string line; getline(s, line); )
    {
        boost::smatch matches;
        if(regex_search(line, matches, boost::regex(""<BR>(.+s+UTC)"") ) )
        {
            std::cout << matches[1] << '';
            break;
        }
    }
}"
"#include strv
#include strv
#include <iostream>
 
using namespace boost::filesystem;
 
int main()
{
  path current_dir(strv); //
  boost::regex pattern(strv); 

  for (recursive_directory_iterator iter(current_dir), end;
       iter != end;
       ++iter)
  {
    std::string name = iter->path().filename().string();
    if (regex_match(name, pattern))
      std::cout << iter->path() << """";
  }
}"
"#include <QApplication>
#include <QMainWindow>
 
int main(int argc, char *argv[])
{
 QApplication app(argc, argv);
 QMainWindow window;
 window.show();
 return app.exec();
}#include <iostream>
#include <gtkmm.h>
 
int
main( int argc, char* argv[] )
{
 try
 {
  Gtk::Main m( argc, argv ) ;
  Gtk::Window win ;
  m.run( win ) ;
 }
 
 catch( std::exception const & exc )
 {
  std::cout << exc.what() << std::endl ;
  exit( -1 ) ;
 }
 
 exit( 0 ) ;
}"
"#include strv
#include strv
#include <iostream>
 
using namespace boost::filesystem;
 
int main()
{
  path current_dir(strv);
  

  boost::regex pattern(strv);
  for (directory_iterator iter(current_dir), end;
       iter != end;
       ++iter)
  {
    boost::smatch match;
    std::string fn = iter->path().filename().string(); 

    if (boost::regex_match( fn, match, pattern))
    {
      std::cout << match[0] << """";
    }
  }
}"
" 
#include <windows.h>
#include <vector>
#include <string>
 
using namespace std;
 
//////////////////////////////////////////////////////
struct Point {
  int x, y;
};
 
//////////////////////////////////////////////////////
class MyBitmap {
 public:
  MyBitmap() : pen_(nullptr) {}
  ~MyBitmap() {
    DeleteObject(pen_);
    DeleteDC(hdc_);
    DeleteObject(bmp_);
  }
 
  bool Create(int w, int h) {
    BITMAPINFO	bi;
    ZeroMemory(&bi, sizeof(bi));
 
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biBitCount = sizeof(DWORD) * 8;
    bi.bmiHeader.biCompression = BI_RGB;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biWidth = w;
    bi.bmiHeader.biHeight = -h;
 
    void *bits_ptr = nullptr;
    HDC dc = GetDC(GetConsoleWindow());
    bmp_ = CreateDIBSection(dc, &bi, DIB_RGB_COLORS, &bits_ptr, nullptr, 0);
    if (!bmp_) return false;
 
    hdc_ = CreateCompatibleDC(dc);
    SelectObject(hdc_, bmp_);
    ReleaseDC(GetConsoleWindow(), dc);
 
    width_ = w;
    height_ = h;
 
    return true;
  }
 
  void SetPenColor(DWORD clr) {
    if (pen_) DeleteObject(pen_);
    pen_ = CreatePen(PS_SOLID, 1, clr);
    SelectObject(hdc_, pen_);
  }
 
  bool SaveBitmap(const char* path) {
    HANDLE file = CreateFile(path, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (file == INVALID_HANDLE_VALUE) {
      return false;
    }
 
    BITMAPFILEHEADER fileheader;
    BITMAPINFO infoheader;
    BITMAP bitmap;    
    GetObject(bmp_, sizeof(bitmap), &bitmap);
 
    DWORD* dwp_bits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
    ZeroMemory(dwp_bits, bitmap.bmWidth * bitmap.bmHeight * sizeof(DWORD));
    ZeroMemory(&infoheader, sizeof(BITMAPINFO));
    ZeroMemory(&fileheader, sizeof(BITMAPFILEHEADER));
 
    infoheader.bmiHeader.biBitCount = sizeof(DWORD) * 8;
    infoheader.bmiHeader.biCompression = BI_RGB;
    infoheader.bmiHeader.biPlanes = 1;
    infoheader.bmiHeader.biSize = sizeof(infoheader.bmiHeader);
    infoheader.bmiHeader.biHeight = bitmap.bmHeight;
    infoheader.bmiHeader.biWidth = bitmap.bmWidth;
    infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof(DWORD);
 
    fileheader.bfType = 0x4D42;
    fileheader.bfOffBits = sizeof(infoheader.bmiHeader) + sizeof(BITMAPFILEHEADER);
    fileheader.bfSize = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
    GetDIBits(hdc_, bmp_, 0, height_, (LPVOID)dwp_bits, &infoheader, DIB_RGB_COLORS);
 
    DWORD wb;
    WriteFile(file, &fileheader, sizeof(BITMAPFILEHEADER), &wb, nullptr);
    WriteFile(file, &infoheader.bmiHeader, sizeof(infoheader.bmiHeader), &wb, nullptr);
    WriteFile(file, dwp_bits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, nullptr);
    CloseHandle(file);
 
    delete[] dwp_bits;
    return true;
  }
 
  HDC hdc() { return hdc_; }
  int width() { return width_; }
  int height() { return height_; }
 
 private:
  HBITMAP bmp_;
  HDC hdc_;
  HPEN pen_;
  int width_, height_;
};
 
static int DistanceSqrd(const Point& point, int x, int y) {
  int xd = x - point.x;
  int yd = y - point.y;
  return (xd * xd) + (yd * yd);
}
 
//////////////////////////////////////////////////////
class Voronoi {
 public:
  void Make(MyBitmap* bmp, int count) {
    bmp_ = bmp;
    CreatePoints(count);
    CreateColors();
    CreateSites();
    SetSitesPoints();
  }
 
 private:
  void CreateSites() {
    int w = bmp_->width(), h = bmp_->height(), d;
    for (int hh = 0; hh < h; hh++) {
      for (int ww = 0; ww < w; ww++) {
        int ind = -1, dist = INT_MAX;
        for (size_t it = 0; it < points_.size(); it++) {
          const Point& p = points_[it];
          d = DistanceSqrd(p, ww, hh);
          if (d < dist) {
            dist = d;
            ind = it;
          }
        }
 
        if (ind > -1)
          SetPixel(bmp_->hdc(), ww, hh, colors_[ind]);
        else
          __asm nop 

        }
    }
  }
 
  void SetSitesPoints() {
    for (const auto& point : points_) {
      int x = point.x, y = point.y;
      for (int i = -1; i < 2; i++)
        for (int j = -1; j < 2; j++)
          SetPixel(bmp_->hdc(), x + i, y + j, 0);
    }
  }
 
  void CreatePoints(int count) {
    const int w = bmp_->width() - 20, h = bmp_->height() - 20;
    for (int i = 0; i < count; i++) {
      points_.push_back({ rand() % w + 10, rand() % h + 10 });
    }
  }
 
  void CreateColors() {
    for (size_t i = 0; i < points_.size(); i++) {
      DWORD c = RGB(rand() % 200 + 50, rand() % 200 + 55, rand() % 200 + 50);
      colors_.push_back(c);
    }
  }
 
  vector<Point> points_;
  vector<DWORD> colors_;
  MyBitmap* bmp_;
};
 
//////////////////////////////////////////////////////
int main(int argc, char* argv[]) {
  ShowWindow(GetConsoleWindow(), SW_MAXIMIZE);
  srand(GetTickCount());
 
  MyBitmap bmp;
  bmp.Create(512, 512);
  bmp.SetPenColor(0);
 
  Voronoi v;
  v.Make(&bmp, 50);
 
  BitBlt(GetDC(GetConsoleWindow()), 20, 20, 512, 512, bmp.hdc(), 0, 0, SRCCOPY);
  bmp.SaveBitmap(strv);
 
  system(strv);
 
  return 0;
}
 "
"#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <array>
using namespace std;
 
typedef array<pair<char, double>, 26> FreqArray;
 
class VigenereAnalyser 
{
private:
  array<double, 26> targets;
  array<double, 26> sortedTargets;
  FreqArray freq;
 
  

  FreqArray& frequency(const string& input) 
  {
    for (char c = 'A'; c <= 'Z'; ++c)
      freq[c - 'A'] = make_pair(c, 0);
 
    for (size_t i = 0; i < input.size(); ++i)
      freq[input[i] - 'A'].second++;
 
    return freq;
  }
 
  double correlation(const string& input) 
  {
    double result = 0.0;
    frequency(input);
 
    sort(freq.begin(), freq.end(), [](pair<char, double> u, pair<char, double> v)->bool
      { return u.second < v.second; });
 
    for (size_t i = 0; i < 26; ++i)
      result += freq[i].second * sortedTargets[i];
 
    return result;
  }
 
public:
  VigenereAnalyser(const array<double, 26>& targetFreqs) 
  {
    targets = targetFreqs;
    sortedTargets = targets;
    sort(sortedTargets.begin(), sortedTargets.end());
  }
 
  pair<string, string> analyze(string input) 
  {
    string cleaned;
    for (size_t i = 0; i < input.size(); ++i) 
    {
      if (input[i] >= 'A' && input[i] <= 'Z')
        cleaned += input[i];
      else if (input[i] >= 'a' && input[i] <= 'z')
        cleaned += input[i] + 'A' - 'a';
    }
 
    size_t bestLength = 0;
    double bestCorr = -100.0;
 
    

    

    for (size_t i = 2; i < cleaned.size() / 20; ++i) 
    {
      vector<string> pieces(i);
      for (size_t j = 0; j < cleaned.size(); ++j)
        pieces[j % i] += cleaned[j];
 
      

      

      double corr = -0.5*i;
      for (size_t j = 0; j < i; ++j)
        corr += correlation(pieces[j]);
 
      if (corr > bestCorr) 
      {
        bestLength = i;
        bestCorr = corr;
      }
    }
 
    if (bestLength == 0)
      return make_pair(strv, strv);
 
    vector<string> pieces(bestLength);
    for (size_t i = 0; i < cleaned.size(); ++i)
      pieces[i % bestLength] += cleaned[i];
 
    vector<FreqArray> freqs;
    for (size_t i = 0; i < bestLength; ++i)
      freqs.push_back(frequency(pieces[i]));
 
    string key = strv;
    for (size_t i = 0; i < bestLength; ++i) 
    {
      sort(freqs[i].begin(), freqs[i].end(), [](pair<char, double> u, pair<char, double> v)->bool
        { return u.second > v.second; });
 
      size_t m = 0;
      double mCorr = 0.0;
      for (size_t j = 0; j < 26; ++j) 
      {
        double corr = 0.0;
        char c = 'A' + j;
        for (size_t k = 0; k < 26; ++k) 
        {
          int d = (freqs[i][k].first - c + 26) % 26;
          corr += freqs[i][k].second * targets[d];
        }
 
        if (corr > mCorr) 
        {
          m = j;
          mCorr = corr;
        }
      }
 
      key += m + 'A';
    }
 
    string result = strv;
    for (size_t i = 0; i < cleaned.size(); ++i)
      result += (cleaned[i] - key[i % key.length()] + 26) % 26 + 'A';
 
    return make_pair(result, key);
  }
};
 
int main() 
{
  string input =
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv
    strv;
 
  array<double, 26> english = {
    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228,
    0.02015, 0.06094, 0.06966, 0.00153, 0.00772, 0.04025,
    0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987,
    0.06327, 0.09056, 0.02758, 0.00978, 0.02360, 0.00150,
    0.01974, 0.00074};
 
  VigenereAnalyser va(english);
  pair<string, string> output = va.analyze(input);
 
  cout << strv << output.second << endl << endl;
  cout << strv << output.first << endl;
}"
"#include <iostream>
#include <string>
using namespace std;
 
class Vigenere
{
public:
  string key;
 
  Vigenere(string key)
  {
    for(int i = 0; i < key.size(); ++i)
    {
      if(key[i] >= 'A' && key[i] <= 'Z')
        this->key += key[i];
      else if(key[i] >= 'a' && key[i] <= 'z')
        this->key += key[i] + 'A' - 'a';
    }
  }
 
  string encrypt(string text)
  {
    string out;
 
    for(int i = 0, j = 0; i < text.length(); ++i)
    {
      char c = text[i];
 
      if(c >= 'a' && c <= 'z')
        c += 'A' - 'a';
      else if(c < 'A' || c > 'Z')
        continue;
 
      out += (c + key[j] - 2*'A') % 26 + 'A'; 
      j = (j + 1) % key.length();
    }
 
    return out;
  }
 
  string decrypt(string text)
  {
    string out;
 
    for(int i = 0, j = 0; i < text.length(); ++i)
    {
      char c = text[i];
 
      if(c >= 'a' && c <= 'z')
        c += 'A' - 'a';
      else if(c < 'A' || c > 'Z')
        continue;
 
      out += (c - key[j] + 26) % 26 + 'A'; 
      j = (j + 1) % key.length();
    }
 
    return out;
  }
};
 
int main()
{
  Vigenere cipher(strv);
 
  string original = strv;
  string encrypted = cipher.encrypt(original);
  string decrypted = cipher.decrypt(encrypted);
 
  cout << original << endl;
  cout << strv << encrypted << endl;
  cout << strv << decrypted << endl;
}"
"#include <map>
#include <iostream>
#include <cmath>
 
template<typename F>
 bool test_distribution(F f, int calls, double delta)
{
  typedef std::map<int, int> distmap;
  distmap dist;
 
  for (int i = 0; i < calls; ++i)
    ++dist[f()];
 
  double mean = 1.0/dist.size();
 
  bool good = true;
 
  for (distmap::iterator i = dist.begin(); i != dist.end(); ++i)
  {
    if (std::abs((1.0 * i->second)/calls - mean) > delta)
    {
      std::cout << strv << i->second/(1.0*calls)
                << strv << i->first
                << strv << delta
                << strv << mean << """";
      good = false;
    }
  }
 
  return good;
}"
"#include <boost/cstdint.hpp>
 
boost::int_least32_t foo;"
"#include <iostream>
 
template< class T >
class D3Vector {
 
template< class U >
friend std::ostream & operator<<( std::ostream & , const D3Vector<U> & ) ;   
 
public :
   D3Vector( T a , T b , T c ) {
      x = a ;
      y = b ;
      z = c ;
   }
 
   T dotproduct ( const D3Vector & rhs ) {
      T scalar = x * rhs.x + y * rhs.y + z * rhs.z ;
      return scalar ;
   }
 
   D3Vector crossproduct ( const D3Vector & rhs ) {
      T a = y * rhs.z - z * rhs.y ;
      T b = z * rhs.x - x * rhs.z ;
      T c = x * rhs.y - y * rhs.x ;
      D3Vector product( a , b , c ) ;
      return product ;
   }
 
   D3Vector triplevec( D3Vector & a , D3Vector & b ) {
      return crossproduct ( a.crossproduct( b ) ) ;
   }
 
   T triplescal( D3Vector & a, D3Vector & b ) {
      return dotproduct( a.crossproduct( b ) ) ;
   }
 
private :
   T x , y , z ;  
} ;
 
template< class T >
std::ostream & operator<< ( std::ostream & os , const D3Vector<T> & vec ) {
   os << strv  << vec.x << strv << vec.y << strv << vec.z << strv ;
   return os ;
}
 
int main( ) {
   D3Vector<int> a( 3 , 4 , 5 ) , b ( 4 , 3 , 5 ) , c( -5 , -12 , -13 ) ;
   std::cout << strv << a.dotproduct( b ) << """" ;
   std::cout << strv << a.crossproduct( b ) << """" ;
   std::cout << strv << a.triplescal( b , c ) << """" ;
   std::cout << strv << a.triplevec( b , c ) << """" ;
   return 0 ;
}"
"#include <iostream>
 
template<typename T>
 void print(T const& t)
{
  std::cout << t;
}
 
template<typename First, typename ... Rest>
 void print(First const& first, Rest const& ... rest)
{
  std::cout << first;
  print(rest ...);
}
 
int main()
{
  int i = 10;
  std::string s = strv;
  print(strv, i, "" and s = "", s, """");
}"
int a;std::vector<int> intVec;
"#include <cstdlib>
std::size_t intsize = sizeof(int);#include <climits>
#include <cstdlib>
std::size_t intbits = CHAR_BITS*sizeof(int);#include <cstdlib>
int a = 1;
std::size_t a_size = sizeof a;#include <cstdlib>
std::size_t size = sizeof (3*6 + 7.5);"
"#include <cmath>
#include <iostream>
 
double vdc(int n, double base = 2)
{
    double vdc = 0, denom = 1;
    while (n)
    {
        vdc += fmod(n, base) / (denom *= base);
        n /= base; 

    }
    return vdc;
}
 
int main() 
{
    for (double base = 2; base < 6; ++base)
    {
        std::cout << strv << base << """";
        for (int n = 0; n < 10; ++n)
        {
            std::cout << vdc(n, base) << strv;
        }
        std::cout << """";
    }
}"
"#include <iostream>
#include <string>
using namespace std;
 
int main()
{
     

     

     long int integer_input;
     string string_input;
     cout << strv;
     cin >> integer_input;
     cout << strv;
     cin >> string_input;
     return 0;
} cin >> string_input; getline(cin, string_input);"
"#include <vector>
#include <utility>
#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>
#include <cmath>
 
bool isVampireNumber( long number, std::vector<std::pair<long, long> > & solution ) {
   std::ostringstream numberstream ;
   numberstream << number ;
   std::string numberstring( numberstream.str( ) ) ;
   std::sort ( numberstring.begin( ) , numberstring.end( ) ) ;
   int fanglength = numberstring.length( ) / 2 ;
   long start = static_cast<long>( std::pow( 10 , fanglength - 1 ) ) ;
   long end = start * 10 ;
   for ( long i = start ; i < ( end - start ) / 2 ; i++ ) { 
      if ( number % i == 0 ) {
	 long quotient = number / i ;
	 if ( ( i % 10 == 0 ) && ( quotient % 10 == 0 ) ) 
	    return false ;
	 numberstream.str( strv ) ; //clear the number stream
	 numberstream << i << quotient ;
	 std::string divisorstring ( numberstream.str( ) ) ;
         std::sort ( divisorstring.begin( ) , divisorstring.end( ) ) ;
	 if ( divisorstring == numberstring ) {
	    std::pair<long , long> divisors = std::make_pair( i, quotient ) ;
	    solution.push_back( divisors ) ;
	 }
      }
   }
   return !solution.empty( ) ;
}
 
void printOut( const std::pair<long, long> & solution ) {
   std::cout << strv << solution.first << strv << solution.second << strv ;
}
 
int main( ) {
   int vampireNumbersFound = 0 ;
   std::vector<std::pair<long , long> > solutions ;
   double i = 1.0 ;
   while ( vampireNumbersFound < 25 ) {
      long start = static_cast<long>( std::pow( 10 , i ) ) ;
      long end = start * 10 ;
      for ( long num = start ; num < end ; num++ ) {
	 if ( isVampireNumber( num , solutions ) ) {
	    std::cout << vampireNumbersFound << strv << num << "" is a vampire number! These are the fangs:"" ;
	    std::for_each( solutions.begin( ) , solutions.end( ) , printOut ) ;
	    std::cout << ""_______________"" << std::endl ;
	    solutions.clear( ) ;
	    vampireNumbersFound++ ;
	    if ( vampireNumbersFound == 25 ) 
	       break ;
	 }
      }
      i += 2.0 ;
   }
   std::vector<long> testnumbers ;
   testnumbers.push_back( 16758243290880 ) ;
   testnumbers.push_back( 2495901734865 ) ;
   testnumbers.push_back( 14593825548650 ) ;
   for ( std::vector<long>::const_iterator svl = testnumbers.begin( ) ; 
	 svl != testnumbers.end( ) ; svl++ ) {
      if ( isVampireNumber( *svl , solutions ) ) {
	 std::cout << *svl << "" is a vampire number! The fangs:"" ;
	 std::for_each( solutions.begin( ) , solutions.end( ) , printOut ) ;
	 std::cout << std::endl ;
	 solutions.clear( ) ;
      } else {
	 std::cout << *svl << strv << std::endl ;
      }
   }
   return 0 ;
}"
"#ifndef TASK_H
#define TASK_H
 
#include <QWidget>
 
class QLabel ;
class QLineEdit ;
class QVBoxLayout ;
class QHBoxLayout ;
 
class EntryWidget : public QWidget {
 
   Q_OBJECT 
public :
   EntryWidget( QWidget *parent = 0 ) ;
private :
   QHBoxLayout *upperpart , *lowerpart ;
   QVBoxLayout *entryLayout ;
   QLineEdit *stringinput ;
   QLineEdit *numberinput ;
   QLabel *stringlabel ;
   QLabel *numberlabel ;
} ;
 
#endif#include <QLineEdit>
#include <QLabel>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QString>
#include strv
 
EntryWidget::EntryWidget ( QWidget *parent ) 
   : QWidget( parent ) {
      entryLayout = new QVBoxLayout( this ) ;
      stringlabel = new QLabel( strv ) ;
      stringinput = new QLineEdit( strv ) ;
      stringinput->setMaxLength( 20 ) ;
      stringinput->setInputMask( QString( strv ) ) ;
      upperpart = new QHBoxLayout ;
      upperpart->addWidget( stringlabel ) ;
      upperpart->addWidget( stringinput ) ;
      numberlabel = new QLabel( strv ) ;
      numberinput = new QLineEdit( strv ) ;
      numberinput->setMaxLength( 5 ) ;
      numberinput->setInputMask( QString( strv ) ) ;
      lowerpart = new QHBoxLayout ;
      lowerpart->addWidget( numberlabel ) ;
      lowerpart->addWidget( numberinput ) ;
      entryLayout->addLayout( upperpart ) ;
      entryLayout->addLayout( lowerpart ) ;
      setLayout( entryLayout ) ;
}#include <QApplication>
#include strv
 
int main( int argc , char *argv[ ] ) {
   QApplication app( argc , argv ) ;
   EntryWidget theWidget ;
   theWidget.show( ) ;
   return app.exec( ) ;
}"
"#include <QByteArray>
#include <iostream>
 
int main( ) {
   QByteArray text ( strv ) ;
   QByteArray encoded( text.toPercentEncoding( ) ) ;
   std::cout << encoded.data( ) << '' ;
   return 0 ;
}"
" 
#include <iostream>
#include <set>
#include <boost/filesystem.hpp>
 
namespace fs = boost::filesystem;
 
int main(void)
{
    fs::path p(fs::current_path());
    std::set<std::string> tree;
 
    for (auto it = fs::directory_iterator(p); it != fs::directory_iterator(); ++it)
        tree.insert(it->path().filename().native());
 
    for (auto entry : tree)
        std::cout << entry << '';
}
 "
"#include <string>
#include strv
#include <iostream>
 
int main( ) {
   std::string encoded( strv ) ;
   std::string decoded ;
   Poco::URI::decode ( encoded , decoded ) ;
   std::cout << encoded << strv << decoded << strv << std::endl ;
   return 0 ;
}"
" 
#include <vector>
#include <string>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <iomanip>
//--------------------------------------------------------------------------------------------------
typedef unsigned int uint;
using namespace std;
const uint TAPE_MAX_LEN = 49152;
//--------------------------------------------------------------------------------------------------
struct action { char write, direction; };
//--------------------------------------------------------------------------------------------------
class tape
{
public:
    tape( uint startPos = TAPE_MAX_LEN >> 1 ) : MAX_LEN( TAPE_MAX_LEN ) { _sp = startPos; reset(); }
    void reset() { clear( '0' ); headPos = _sp; }
    char read(){ return _t[headPos]; }
    void input( string a ){ if( a == strv ) return; for( uint s = 0; s < a.length(); s++ ) _t[headPos + s] = a[s]; }
    void clear( char c ) {  _t.clear(); blk = c; _t.resize( MAX_LEN, blk ); }
    void action( const action* a ) { write( a->write ); move( a->direction ); }
    void print( int c = 10 ) 
    {
	int ml = static_cast<int>( MAX_LEN ), st = static_cast<int>( headPos ) - c, ed = static_cast<int>( headPos ) + c + 1, tx;
	for( int x = st; x < ed; x++ ) 
	{ tx = x; if( tx < 0 ) tx += ml; if( tx >= ml ) tx -= ml; cout << _t[tx]; } 
	cout << endl << setw( c + 1 ) << strv << endl; 
    }
private:
    void move( char d ) { if( d == 'N' ) return; headPos += d == 'R' ? 1 : -1; if( headPos >= MAX_LEN ) headPos = d == 'R' ? 0 : MAX_LEN - 1; }
    void write( char a ) { if( a != 'N' ) { if( a == 'B' ) _t[headPos] = blk; else _t[headPos] = a; } }
    string _t; uint headPos, _sp; char blk; const uint MAX_LEN;
};
//--------------------------------------------------------------------------------------------------
class state
{
public:
    bool operator ==( const string o ) { return o == name; }
    string name, next; char symbol, write, direction;
};
//--------------------------------------------------------------------------------------------------
class actionTable
{
public:
    bool loadTable( string file )
    {
	reset();
	ifstream mf; mf.open( file.c_str() ); if( mf.is_open() )
	{
	    string str; state stt;
	    while( mf.good() )
	    {
		getline( mf, str ); if( str[0] == '' ) break;
		parseState( str, stt ); states.push_back( stt );
	    }
	    while( mf.good() )
	    {
		getline( mf, str ); if( str == strv ) continue;
		if( str[0] == '!' ) blank = str.erase( 0, 1 )[0];
		if( str[0] == '^' ) curState = str.erase( 0, 1 );
		if( str[0] == '>' ) input = str.erase( 0, 1 );
	    }
	    mf.close(); return true;
	}
	cout << strv << file << endl; return false;
    }
 
    bool action( char symbol, action& a )
    {
	vector<state>::iterator f = states.begin();
	while( true )
	{
	    f = find( f, states.end(), curState );
	    if( f == states.end() ) return false;
	    if( ( *f ).symbol == '*' || ( *f ).symbol == symbol || ( ( *f ).symbol == 'B' && blank == symbol ) )
	    { a.direction = ( *f ).direction; a.write = ( *f ).write; curState = ( *f ).next; break; }
	    f++;
	}
	return true;
    }
    void reset() { states.clear(); blank = '0'; curState = input = strv; }
    string getInput() { return input; }
    char getBlank() { return blank; }
private:
    void parseState( string str, state& stt )
    {
	string a[5]; int idx = 0;
	for( string::iterator si = str.begin(); si != str.end(); si++ )
	{ if( ( *si ) == ';' ) idx++; else a[idx].append( &( *si ), 1 ); }
	stt.name = a[0]; stt.symbol = a[1][0]; stt.write = a[2][0]; stt.direction = a[3][0]; stt.next = a[4];
    }
    vector<state> states; char blank; string curState, input;
};
//--------------------------------------------------------------------------------------------------
class utm
{
public:
    utm() { files[0] = strv; files[1] = strv; files[2] = strv; }
    void start()
    {
	while( true )
	{
	    reset(); int t = showMenu(); if( t == 0 ) return;
	    if( !at.loadTable( files[t - 1] ) ) return; startMachine();
	}
    }
private:
    void simulate()
    {
	char r; action a;
	while( true ) { tp.print(); r = tp.read(); if( !( at.action( r, a ) ) ) break; tp.action( &a ); }
	cout << endl << endl; system( strv );
    }
 
    int showMenu()
    {
	int t = -1;
	while( t < 0 || t > 3 )
	{
	    system( strv ); cout << ""1. Incrementer2. Busy beaver3. Sort0. Quit"";
	    cout << endl << endl << strv; cin >> t;
	}
	return t;
    }
 
    void reset() { tp.reset(); at.reset(); }
    void startMachine() { system( strv ); tp.clear( at.getBlank() ); tp.input( at.getInput() ); simulate(); }
 
    tape tp; actionTable at; string files[7];
};
//--------------------------------------------------------------------------------------------------
int main( int a, char* args[] ){ utm mm; mm.start(); return 0; }
//--------------------------------------------------------------------------------------------------
 "
"#include <cmath>
#include <iostream>
#include <string>
#include <iomanip>
#include <vector>
 
class ulamSpiral {
public:
    void create( unsigned n, unsigned startWith = 1 ) {
        _lst.clear();
        if( !( n & 1 ) ) n++;
        _mx = n;
        unsigned v = n * n;
        _wd = static_cast<unsigned>( log10( static_cast<long double>( v ) ) ) + 1;
        for( unsigned u = 0; u < v; u++ )
            _lst.push_back( -1 );
 
        arrange( startWith );
 
    }
    void display( char c ) {
        if( !c ) displayNumbers();
        else displaySymbol( c );
    }
 
private:
    bool isPrime( unsigned u ) {
        if( u < 4 ) return u > 1;
        if( !( u % 2 ) || !( u % 3 ) ) return false;
 
        unsigned q = static_cast<unsigned>( sqrt( static_cast<long double>( u ) ) ),
                 c = 5;
        while( c <= q ) {
            if( !( u % c ) || !( u % ( c + 2 ) ) ) return false;
            c += 6;
        }
        return true;
    }
    void arrange( unsigned s ) {
        unsigned stp = 1, n = 1, posX = _mx >> 1, 
                 posY = posX, stC = 0;
        int dx = 1, dy = 0;
 
        while( posX < _mx && posY < _mx ) {
            _lst.at( posX + posY * _mx ) =  isPrime( s ) ? s : 0;
            s++;
 
            if( dx ) {
                posX += dx;
                if( ++stC == stp ) {
                    dy = -dx;
                    dx = stC = 0;
                }
            } else {
                posY += dy;
                if( ++stC == stp ) {
                    dx = dy;
                    dy = stC = 0;
                    stp++;
                }
            }
        }
    }
    void displayNumbers() {
        unsigned ct = 0;
        for( std::vector<unsigned>::iterator i = _lst.begin(); i != _lst.end(); i++ ) {
            if( *i ) std::cout << std::setw( _wd ) << *i << strv;
            else std::cout << std::string( _wd, '*' ) << strv;
            if( ++ct >= _mx ) {
                std::cout << """";
                ct = 0;
            }
        }
        std::cout << """";
    }
    void displaySymbol( char c ) {
        unsigned ct = 0;
        for( std::vector<unsigned>::iterator i = _lst.begin(); i != _lst.end(); i++ ) {
            if( *i ) std::cout << c;
            else std::cout << strv;
            if( ++ct >= _mx ) {
                std::cout << """";
                ct = 0;
            }
        }
        std::cout << """";
    }
 
    std::vector<unsigned> _lst;
    unsigned _mx, _wd;
};
 
int main( int argc, char* argv[] )
{
    ulamSpiral ulam;
    ulam.create( 9 );
    ulam.display( 0 );
    ulam.create( 35 );
    ulam.display( '#' );
    return 0;
}#pragma once
 
#include <cmath>
#include <sstream>
#include <iomanip>
 
inline bool is_prime(unsigned a)  {
   if (a == 2) return true;
   if (a <= 1 || a % 2 == 0) return false;
   const unsigned max(std::sqrt(a));
   for (unsigned n = 3; n <= max; n += 2) if (a % n == 0)  return false;
   return true;
}
 
enum direction { RIGHT, UP, LEFT, DOWN };
const char* N = strv;
 
template<const unsigned SIZE>
class Ulam
{
public:
    Ulam(unsigned start = 1, const char c = '') {
        direction dir = RIGHT;
        unsigned y = SIZE / 2;
        unsigned x = SIZE % 2 == 0 ?  y - 1 :  y; 

        for (unsigned j = start; j <= SIZE * SIZE - 1 + start; j++) {
            if (is_prime(j)) {
                std::ostringstream os(strv);
                if (c == '') os << std::setw(4) << j;
                else           os << strv << c << ' ';
                s[y][x] = os.str();
            }
            else s[y][x] = N;
 
            switch (dir) {
            case RIGHT : if (x <= SIZE - 1 && s[y - 1][x].empty() && j > start) { dir = UP; }; break;
            case UP : if (s[y][x - 1].empty()) { dir = LEFT; }; break;
            case LEFT : if (x == 0 || s[y + 1][x].empty()) { dir = DOWN; }; break;
            case DOWN : if (s[y][x + 1].empty()) { dir = RIGHT; }; break;
            }
 
            switch (dir) {
            case RIGHT : x += 1; break;
            case UP : y -= 1; break;
            case LEFT : x -= 1; break;
            case DOWN : y += 1; break;
            }
        }
    }
 
    template<const unsigned S> friend std::ostream& operator <<(std::ostream&, const Ulam<S>&);
 
private:
    std::string s[SIZE][SIZE];
};
 
template<const unsigned SIZE>
std::ostream& operator <<(std::ostream& os, const Ulam<SIZE>& u) {
    for (unsigned i = 0; i < SIZE; i++) {
        os << '[';
        for (unsigned j = 0; j < SIZE; j++) os << u.s[i][j];
        os << ']' << std::endl;
    }
    return os;
}#include <cstdlib>
#include <iostream>
#include strv
 
int main(const int argc, const char* argv[]) {
    using namespace std;
 
    cout << Ulam<9>() << endl;
    const Ulam<9> v(1, '*');
    cout << v << endl;
 
	return EXIT_SUCCESS;
}"
"#include <boost/scoped_ptr.hpp>
#include <iostream>
#include <queue>
 
template<typename T>
class TreeNode {
public:
  TreeNode(const T& n, TreeNode* left = NULL, TreeNode* right = NULL)
    : mValue(n),
      mLeft(left),
      mRight(right) {}
 
  T getValue() const {
    return mValue;
  }
 
  TreeNode* left() const {
    return mLeft.get();
  }
 
  TreeNode* right() const {
    return mRight.get();
  }
 
  void preorderTraverse() const {
    std::cout << strv << getValue();
    if(mLeft)  { mLeft->preorderTraverse();  }
    if(mRight) { mRight->preorderTraverse(); }
  }
 
  void inorderTraverse() const {
    if(mLeft)  { mLeft->inorderTraverse();  }
    std::cout << strv << getValue();
    if(mRight) { mRight->inorderTraverse(); }
  }
 
  void postorderTraverse() const {
    if(mLeft)  { mLeft->postorderTraverse();  }
    if(mRight) { mRight->postorderTraverse(); }
    std::cout << strv << getValue();
  }
 
  void levelorderTraverse() const {
    std::queue<const TreeNode*> q;
    q.push(this);
 
    while(!q.empty()) {
      const TreeNode* n = q.front();
      q.pop();
      std::cout << strv << n->getValue();
 
      if(n->left())  { q.push(n->left());  }
      if(n->right()) { q.push(n->right()); }
    }
  }
 
protected:
  T mValue;
  boost::scoped_ptr<TreeNode> mLeft;
  boost::scoped_ptr<TreeNode> mRight;
 
private:
  TreeNode();
};
 
int main() {
  TreeNode<int> root(1,
    new TreeNode<int>(2,
      new TreeNode<int>(4,
        new TreeNode<int>(7)),
      new TreeNode<int>(5)),
    new TreeNode<int>(3,
      new TreeNode<int>(6,
        new TreeNode<int>(8),
        new TreeNode<int>(9))));
 
  std::cout << strv;
  root.preorderTraverse();
  std::cout << std::endl;
 
  std::cout << strv;
  root.inorderTraverse();
  std::cout << std::endl;
 
  std::cout << strv;
  root.postorderTraverse();
  std::cout << std::endl;
 
  std::cout << strv;
  root.levelorderTraverse();
  std::cout << std::endl;
 
  return 0;
}"
" 
#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>
#include <iomanip>
 
int main( ) {
   std::vector<double> input( 11 ) , results( 11 ) ;
   std::cout << ""Please enter 11 numbers!"" ;
   for ( int i = 0 ; i < input.size( ) ; i++ ) 
      std::cin >> input[i];
 
   std::transform( input.begin( ) , input.end( ) , results.begin( ) ,
	 [ ]( double n )-> double { return sqrt( abs( n ) ) + 5 * pow( n , 3 ) ; } ) ;
   for ( int i = 10 ; i > -1 ; i-- ) {
      std::cout << strv << std::setw( 3 ) << input[ i ] << strv ; 
      if ( results[ i ] > 400 ) 
	 std::cout << strv ;
      else 
	 std::cout << results[ i ] << strv ;
      std::cout << std::endl ;
   }
   return 0 ;
}"
"void move(int n, int from, int to, int via) {
  if (n == 1) {
    std::cout << strv << from << strv << to << std::endl;
  } else {
    move(n - 1, from, via, to);
    move(1, from, to, via);
    move(n - 1, via, to, from);
  }
}"
"#include <iostream>
#include <cmath>
 
#ifdef M_PI // defined by all POSIX systems and some non-POSIX ones
double const pi = M_PI;
#else
double const pi = 4*std::atan(1);
#endif
 
double const degree = pi/180;
 
int main()
{
  std::cout << ""=== radians ==="";
  std::cout << strv << std::sin(pi/3) << """";
  std::cout << strv << std::cos(pi/3) << """";
  std::cout << strv << std::tan(pi/3) << """";
  std::cout << strv << std::asin(0.5) << """";
  std::cout << strv << std::acos(0.5) << """";
  std::cout << strv << std::atan(0.5) << """";
 
  std::cout << ""=== degrees ==="";
  std::cout << strv << std::sin(60*degree) << """";
  std::cout << strv << std::cos(60*degree) << """";
  std::cout << strv << std::tan(60*degree) << """";
  std::cout << strv << std::asin(0.5)/degree << ""°"";
  std::cout << strv << std::acos(0.5)/degree << ""°"";
  std::cout << strv << std::atan(0.5)/degree << ""°"";
 
  return 0;
}"
"#include <string>
#include <set>
#include <list>
#include <map>
#include <iostream>
 
 
struct Employee
{
	std::string Name;
	std::string ID;
	unsigned long Salary;
	std::string Department;
	Employee(std::string _Name = strv, std::string _ID = strv, unsigned long _Salary = 0, std::string _Department = strv)
	: Name(_Name), ID(_ID), Salary(_Salary), Department(_Department)
	{ }
 
	void display(std::ostream& out) const
	{
		out << Name << """" << ID << """" << Salary << """" << Department << std::endl;
	}
};
 


struct CompareEarners
{
	bool operator()(const Employee& e1, const Employee& e2)
	{
		return (e1.Salary > e2.Salary);
	}
};
 


typedef std::list<Employee> EMPLOYEELIST;
 




typedef std::set<Employee, CompareEarners> DEPARTMENTPAYROLL;
 
typedef std::map<std::string, DEPARTMENTPAYROLL> DEPARTMENTLIST;
 
void initialize(EMPLOYEELIST& Employees)
{
	

	Employees.push_back(Employee(strv, strv, 32000, strv));
	Employees.push_back(Employee(strv, strv, 47000, strv));
	Employees.push_back(Employee(strv, strv, 53500, strv));
	Employees.push_back(Employee(strv, strv, 18000, strv));
	Employees.push_back(Employee(strv, strv, 27800, strv));
	Employees.push_back(Employee(strv, strv, 41500, strv));
	Employees.push_back(Employee(strv, strv, 49500, strv));
	Employees.push_back(Employee(strv, strv, 21900, strv));
	Employees.push_back(Employee(strv, strv, 15900, strv));
	Employees.push_back(Employee(strv, strv, 19250, strv));
	Employees.push_back(Employee(strv, strv, 27000, strv));
	Employees.push_back(Employee(strv, strv, 57000, strv));
	Employees.push_back(Employee(strv, strv, 29900, strv));
}
 
void group(EMPLOYEELIST& Employees, DEPARTMENTLIST& Departments)
{
	

	for( EMPLOYEELIST::iterator iEmployee = Employees.begin();
		 Employees.end() != iEmployee;
		 ++iEmployee )
	{
		DEPARTMENTPAYROLL& groupSet = Departments[iEmployee->Department];
 
		

		groupSet.insert(*iEmployee);
	}
}
 
void present(DEPARTMENTLIST& Departments, unsigned int N)
{
	

	for( DEPARTMENTLIST::iterator iDepartment = Departments.begin();
		 Departments.end() != iDepartment;
		 ++iDepartment )
	{
		std::cout << strv << iDepartment->first << std::endl;
		std::cout << ""NameIDSalaryDepartment"" << std::endl;
		

		unsigned int rank = 1;
		for( DEPARTMENTPAYROLL::iterator iEmployee = iDepartment->second.begin();
			 ( iDepartment->second.end() != iEmployee) && (rank <= N);
			 ++iEmployee, ++rank )
		{
			iEmployee->display(std::cout);
		}
		std::cout << std::endl;
	}
}
 
int main(int argc, char* argv[])
{
	

	EMPLOYEELIST Employees;
 
	

	initialize(Employees);
 
	

	DEPARTMENTLIST Departments;
 
	

	

	group(Employees, Departments);
 
	

	present(Departments, 3);
 
	return 0;
}"
" 
#include <iostream>
#include <iterator>
#include <vector>
int main( int argc, char* argv[] ) {
    std::vector<bool> t;
    t.push_back( 0 );
    size_t len = 1;
    std::cout << t[0] << """";
    do {
        for( size_t x = 0; x < len; x++ )
            t.push_back( t[x] ? 0 : 1 );
        std::copy( t.begin(), t.end(), std::ostream_iterator<bool>( std::cout ) );
        std::cout << """";
        len = t.size();
    } while( len < 60 );
    return 0;
}
 "
"#include <ctime>
#include <iostream>
using namespace std;
 
int identity(int x) { return x; }
int sum(int num) {
  for (int i = 0; i < 1000000; i++)
    num += i;
  return num;
}
 
double time_it(int (*action)(int), int arg) {
  clock_t start_time = clock();
  action(arg);
  clock_t finis_time = clock();
  return ((double) (finis_time - start_time)) / CLOCKS_PER_SEC;
}
 
int main() {
  cout << strv << time_it(identity, 4) << strv << endl;
  cout << strv << time_it(sum, 4) << strv << endl;
  return 0;
}"
"#include <iostream>
#include <array>
#include <string>
using namespace std;
 
int main()
{
    const array<string, 12> days
    {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv
    };
 
    const array<string, 12> gifts
    {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv
    };
 
    for(int i = 0; i < days.size(); ++i)
    {
        cout << strv << days[i] << strv
             << "" to me"";
 
        if(i == 0)
        {
            cout << ""A partridge in a pear tree"";
        }
        else
        {
            int j = i + 1;
            while(j-- > 0) cout << gifts[j] << """";
        }
 
        cout << """";
    }
 
    return 0;
}"
"#include <string>
#include <sstream>
#include <vector>
#include <iterator>
#include <iostream>
#include <algorithm>
int main()
{
    std::string s = strv;
    std::vector<std::string> v;
    std::istringstream buf(s);
    for(std::string token; getline(buf, token, ','); )
        v.push_back(token);
    copy(v.begin(), v.end(), std::ostream_iterator<std::string>(std::cout, strv));
    std::cout << '';
}#include <string>
#include <locale>
#include <sstream>
#include <vector>
#include <iterator>
#include <iostream>
#include <algorithm>
struct comma_ws : std::ctype<char> {
    static const mask* make_table() {
    static std::vector<mask> v(classic_table(), classic_table() + table_size);
        v[','] |= space;  

        return &v[0];
    }
    comma_ws(std::size_t refs = 0) : ctype<char>(make_table(), false, refs) {}
};
int main()
{
    std::string s = strv;
    std::istringstream buf(s);
    buf.imbue(std::locale(buf.getloc(), new comma_ws));
    std::istream_iterator<std::string> beg(buf), end;
    std::vector<std::string> v(beg, end);
    copy(v.begin(), v.end(), std::ostream_iterator<std::string>(std::cout, strv));
    std::cout << '';
}#include <string>
#include <vector>
#include <iterator>
#include <algorithm>
#include <iostream>
#include <boost/tokenizer.hpp>
int main()
{
    std::string s = strv;
    boost::tokenizer<> tok(s);
    std::vector<std::string> v(tok.begin(), tok.end());
    copy(v.begin(), v.end(), std::ostream_iterator<std::string>(std::cout, strv))
    std::cout << '';
}"
" 
#include <fstream>
#include <iostream>
#include <unordered_map>
#include <vector>
 
struct Textonym_Checker {
private:
    int total;
    int elements;
    int textonyms;
    int max_found;
    std::vector<std::string> max_strings;
    std::unordered_map<std::string, std::vector<std::string>> values;
 
    int get_mapping(std::string &result, const std::string &input)
    {
        static std::unordered_map<char, char> mapping = {
            {'A', '2'}, {'B', '2'}, {'C', '2'},
            {'D', '3'}, {'E', '3'}, {'F', '3'},
            {'G', '4'}, {'H', '4'}, {'I', '4'},
            {'J', '5'}, {'K', '5'}, {'L', '5'},
            {'M', '6'}, {'N', '6'}, {'O', '6'},
            {'P', '7'}, {'Q', '7'}, {'R', '7'}, {'S', '7'},
            {'T', '8'}, {'U', '8'}, {'V', '8'},
            {'W', '9'}, {'X', '9'}, {'Y', '9'}, {'Z', '9'}
        };
 
        result = input;
        for (char &c : result) {
            if (!isalnum(c)) return 0;
            if (isalpha(c)) c = mapping[toupper(c)];
        }
 
        return 1;
    }
 
public:
    Textonym_Checker(void) : total(0), elements(0), textonyms(0), max_found(0) { }
 
    ~Textonym_Checker(void) { }
 
    void add(const std::string &str) {
        std::string mapping;
        total += 1;
 
        if (!get_mapping(mapping, str)) return;
 
        const int num_strings = values[mapping].size();
 
        textonyms += num_strings == 1 ? 1 : 0;
        elements  += 1;
 
        if (num_strings > max_found) {
            max_strings.clear();
            max_strings.push_back(mapping);
            max_found = num_strings;
        }
        else if (num_strings == max_found) {
            max_strings.push_back(mapping);
        }
 
        values[mapping].push_back(str);
    }
 
    void results(const std::string &filename) {
        std::cout << strv << total << strv << filename << """";
 
        std::cout << strv << elements << strv << filename;
        std::cout << "" which can be represented by the digit key mapping."";
        std::cout << strv << values.size() <<
                     "" digit combinations to represent them."";
        std::cout << textonyms << "" digit combinations represent Textonyms."";
        std::cout << strv;
        std::cout << max_found + 1 << "" words each:"";
 
        for (auto it1 = max_strings.begin(); it1 != max_strings.end(); ++it1) {
            std::cout << '' << *it1 << strv;
            for (auto it2 = values[*it1].begin(); it2 != values[*it1].end(); ++it2) {
                std::cout << *it2 << strv;
            }
            std::cout << """";
        }
        std::cout << '';
    }
 
    void match(const std::string &str) {
        auto match = values.find(str);
 
        if (match == values.end()) {
            std::cout << strv << str << ""' not found"";
        }
        else {
            std::cout << strv << str << strv;
            for (auto it = values[str].begin(); it != values[str].end(); ++it)
                std::cout << *it << strv;
            std::cout << '';
        }
    }
};
 
int main(void)
{
    std::string filename = strv;
    std::ifstream input(filename);
    Textonym_Checker tc;
 
    if (input.is_open()) {
        std::string line;
        while (getline(input, line))
            tc.add(line);
    }
 
    input.close();
 
    tc.results(filename);
    tc.match(strv);
    tc.match(strv);
    tc.match(strv);
    tc.match(strv);
}
 "
"#include <fstream>
#include <iostream>
#include <iterator>
#include <string>
#include <vector>
 
int main()
{
    const char logfilename[] = strv;
    std::ifstream logfile(logfilename);
 
    if (!logfile.is_open())
    {
        std::cerr << strv << logfilename << """";
        return -1;
    }
 
    int license = 0, max_license = 0;
    std::vector<std::string> max_timestamp;
 
    for (std::string logline; std::getline(logfile, logline); )
    {
        std::string action(logline.substr(8,3));
 
        if (action == strv)
        {
            if (++license >= max_license)
            {
                if (license > max_license)
                {
                    max_license = license;
                    max_timestamp.clear();
                }
                max_timestamp.push_back(logline.substr(14, 19));
            }
        }
        else if (action == strv)
        {
            --license;
        }
    }
 
    std::cout << strv << license
        << ""Maximum simultaneous license: "" << max_license
        << ""Maximum license time(s):"";
 
    std::copy(max_timestamp.begin(), max_timestamp.end(),
        std::ostream_iterator<std::string>(std::cout, """"));
}"
" 
#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
enum players { Computer, Human, Draw, None };
const int iWin[8][3] = { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 }, { 0, 3, 6 }, { 1, 4, 7 }, { 2, 5, 8 }, { 0, 4, 8 }, { 2, 4, 6 } };
 
//--------------------------------------------------------------------------------------------------
class ttt
{
public:
    ttt() { _p = rand() % 2; reset(); }
 
    void play()
    {
	int res = Draw;
	while( true )
	{
	    drawGrid();
	    while( true )
	    {
		if( _p ) getHumanMove();
		else getComputerMove();
 
		drawGrid();
 
		res = checkVictory();
		if( res != None ) break;
 
		++_p %= 2;
	    }
 
	    if( res == Human ) cout << strv;
	    else if( res == Computer ) cout << strv;
	    else cout << strv;
 
	    cout << endl << endl;
 
	    string r;
	    cout << strv; cin >> r;
	    if( r != strv && r != strv ) return;
 
	    ++_p %= 2;
	    reset();
 
	}
    }
 
private:
    void reset() 
    {
	for( int x = 0; x < 9; x++ )
	    _field[x] = None;
    }
 
    void drawGrid()
    {
	system( strv );
 
        COORD c = { 0, 2 };
	SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), c );
 
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl << endl << endl;
 
	int f = 0;
	for( int y = 0; y < 5; y += 2 )
	    for( int x = 1; x < 11; x += 4 )
	    {
		if( _field[f] != None )
		{
		    COORD c = { x, 2 + y };
		    SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), c );
		    string o = _field[f] == Computer ? strv : strv;
		    cout << o;
		}
		f++;
	    }
 
        c.Y = 9;
	SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), c );
    }
 
    int checkVictory()
    {
	for( int i = 0; i < 8; i++ )
	{
	    if( _field[iWin[i][0]] != None &&
		_field[iWin[i][0]] == _field[iWin[i][1]] && _field[iWin[i][1]] == _field[iWin[i][2]] )
	    {
		return _field[iWin[i][0]];
	    }
	}
 
	int i = 0;
	for( int f = 0; f < 9; f++ )
	{
	    if( _field[f] != None )
		i++;
	}
	if( i == 9 ) return Draw;
 
	return None;
    }
 
    void getHumanMove()
    {
	int m;
	cout << strv;
	while( true )
	{
	    m = 0;
	    do
	    { cin >> m; }
	    while( m < 1 && m > 9 );
 
	    if( _field[m - 1] != None )
		cout << strv << endl;
	    else break;
	}
 
	_field[m - 1] = Human;
    }
 
    void getComputerMove()
    {
	int move = 0;
 
	do{ move = rand() % 9; }
	while( _field[move] != None );
 
	for( int i = 0; i < 8; i++ )
	{
	    int try1 = iWin[i][0], try2 = iWin[i][1], try3 = iWin[i][2];
 
	    if( _field[try1] != None && _field[try1] == _field[try2] && _field[try3] == None )
	    {
		move = try3;
		if( _field[try1] == Computer ) break;
	    }
 
	    if( _field[try1] != None && _field[try1] == _field[try3] && _field[try2] == None ) 
	    {			
		move = try2;
		if( _field[try1] == Computer ) break;
	    }
 
	    if( _field[try2] != None && _field[try2] == _field[try3] && _field[try1] == None )
	    {
		move = try1;
		if( _field[try2] == Computer ) break;
	    }
        }
	_field[move] = Computer;
 
    }
 
 
int _p;
int _field[9];
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( GetTickCount() );
 
    ttt tic;
    tic.play();
 
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <boost/regex.hpp>
#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <cstdlib>
#include <algorithm>
using namespace std ;
 
boost::regex e ( ""s+"" ) ; 
 
int main( int argc , char *argv[ ] ) { 
   ifstream infile( argv[ 1 ] ) ; 
   vector<string> duplicates ;
   set<string> datestamps ; //for the datestamps
   if ( ! infile.is_open( ) ) { 
      cerr << strv << argv[ 1 ] << '' ;
      return 1 ; 
   }   
   int all_ok = 0  ;//all_ok for lines in the given pattern e
   int pattern_ok = 0 ; //overall field pattern of record is ok
   while ( infile ) { 
      string eingabe ;
      getline( infile , eingabe ) ;
      boost::sregex_token_iterator i ( eingabe.begin( ), eingabe.end( ) , e , -1 ), j  ;//we tokenize on empty fields
      vector<string> fields( i, j ) ;
      if ( fields.size( ) == 49 ) //we expect 49 fields in a record
         pattern_ok++ ;
      else
         cout << ""Format not ok!"" ;
      if ( datestamps.insert( fields[ 0 ] ).second ) { //not duplicated
         int howoften = ( fields.size( ) - 1 ) / 2 ;//number of measurement
                                                    //devices and values
         for ( int n = 1 ; atoi( fields[ 2 * n ].c_str( ) ) >= 1 ; n++ ) {
            if ( n == howoften ) {
               all_ok++ ;
               break ;
            }
         }
      }
      else {
         duplicates.push_back( fields[ 0 ] ) ;//first field holds datestamp
      }
   }
   infile.close( ) ;
   cout << strv << duplicates.size() << "" datestamps were duplicated:"" ;
   copy( duplicates.begin( ) , duplicates.end( ) ,
         ostream_iterator<string>( cout , """" ) ) ;
   cout << all_ok << "" records were complete and ok!"" ;
   return 0 ;
}"
"#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iomanip>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
 
using std::cout;
using std::endl;
const int NumFlags = 24;
 
int main()
{
    std::fstream file(strv);
 
    int badCount = 0;
    std::string badDate;
    int badCountMax = 0;
    while(true)
    {
        std::string line;
        getline(file, line);
        if(!file.good())
            break;
 
        std::vector<std::string> tokens;
        boost::algorithm::split(tokens, line, boost::is_space());
 
        if(tokens.size() != NumFlags * 2 + 1)
        {
            cout << strv << endl;
            return 0;
        }
 
        double total = 0.0;
        int accepted = 0;
        for(size_t i = 1; i < tokens.size(); i += 2)
        {
            double val = boost::lexical_cast<double>(tokens[i]);
            int flag = boost::lexical_cast<int>(tokens[i+1]);
            if(flag > 0)
            {
                total += val;
                ++accepted;
                badCount = 0;
            }
            else
            {
                ++badCount;
                if(badCount > badCountMax)
                {
                    badCountMax = badCount;
                    badDate = tokens[0];
                }
            }
        }
 
        cout << tokens[0];
        cout << strv << std::setw(2) << (NumFlags - accepted);
        cout << strv << std::setw(2) << accepted;
        cout << strv << std::setprecision(5) << total / accepted << endl;
    }
    cout << endl;
    cout << strv << badCountMax << endl;
    cout << strv << badDate << endl;
}"
" 
#include <Windows.h>
int main()
{
  bool showCursor = false;
 
  HANDLE std_out = GetStdHandle(STD_OUTPUT_HANDLE); 

  CONSOLE_CURSOR_INFO cursorInfo;                   

  GetConsoleCursorInfo(out, &cursorInfo);           

  cursorInfo.bVisible = showCursor;                 

  SetConsoleCursorInfo(out, &cursorInfo);           

}
 "
"#include <iostream>
 
int main()
{
    std::cout << static_cast<char>(163); 

    return 0;
}"
" 
#include <iostream>
#include <iomanip>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class converter
{
public:
    converter() : KTC( 273.15f ), KTDel( 3.0f / 2.0f ), KTF( 9.0f / 5.0f ), KTNew( 33.0f / 100.0f ),
		  KTRank( 9.0f / 5.0f ), KTRe( 4.0f / 5.0f ), KTRom( 21.0f / 40.0f ) {}
 
    void convert( float kelvin )
    {
	float cel = kelvin - KTC,
	      del = ( 373.15f - kelvin ) * KTDel,
	      fah = kelvin * KTF - 459.67f,
	      net = cel * KTNew,
	      rnk = kelvin * KTRank,
	      rea = cel * KTRe, 
	      rom = cel * KTRom + 7.5f;
 
	cout << endl << left
	     << strv << endl 
	     << strv << endl << setw( 13 )
	     << strv << cel << endl << setw( 13 )
	     << strv << del << endl << setw( 13 )
	     << strv << fah << endl << setw( 13 )
	     << strv << kelvin << endl  << setw( 13 )
	     << strv << net << endl << setw( 13 )
	     << strv << rnk << endl << setw( 13 )
	     << strv << rea << endl << setw( 13 )
	     << strv << rom << endl << endl << endl;
	}
private:
    const float KTRank, KTC, KTF, KTRe, KTDel, KTNew, KTRom;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    converter con;
    float k;
    while( true )
    {
	cout << strv;
	cin >> k;
	con.convert( k );
	system( strv );
	system( strv );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <fstream>
#include <iostream>
#include <ctime>
using namespace std;
 
#define note_file strv
 
int main(int argc, char **argv)
{
	if(argc>1)
	{
		ofstream Notes(note_file, ios::app);
		time_t timer = time(NULL);
		if(Notes.is_open())
		{
			Notes << asctime(localtime(&timer)) << '';
			for(int i=1;i<argc;i++)
				Notes << argv[i] << ' ';
			Notes << endl;
			Notes.close();
		}
	}
	else
	{
		ifstream Notes(note_file, ios::in);
		string line;
		if(Notes.is_open())
		{
			while(!Notes.eof())
			{
				getline(Notes, line);
				cout << line << endl;
			}
			Notes.close();
		}
	}
}"
"#include <iostream>
#include <stdlib.h>
 
class trit {
public:
    static const trit False, Maybe, True;
 
    trit operator !() const {
        return static_cast<Value>(-value);
    }
 
    trit operator &&(const trit &b) const {
        return (value < b.value) ? value : b.value;
    }
 
    trit operator ||(const trit &b) const {
        return (value > b.value) ? value : b.value;
    }
 
    trit operator >>(const trit &b) const {
        return -value > b.value ? static_cast<Value>(-value) : b.value;
    }
 
    trit operator ==(const trit &b) const {
        return static_cast<Value>(value * b.value);
    }
 
    char chr() const {
        return strv[value + 1];
    }
 
protected:
    typedef enum { FALSE=-1, MAYBE, TRUE } Value;
 
    Value value;
 
    trit(const Value value) : value(value) { }
};
 
std::ostream& operator<<(std::ostream &os, const trit &t)
{
    os << t.chr();
    return os;
}
 
const trit trit::False = trit(trit::FALSE);
const trit trit::Maybe = trit(trit::MAYBE);
const trit trit::True = trit(trit::TRUE);
 
int main(int, char**) {
    const trit trits[3] = { trit::True, trit::Maybe, trit::False };
 
#define for_each(name) \    for (size_t name=0; name<3; ++name)
 
#define show_op(op) \    std::cout << std::endl << #op << strv; \    for_each(a) std::cout << ' ' << trits[a]; \    std::cout << std::endl << strv; \    for_each(a) { \        std::cout << std::endl << trits[a] << strv; \        for_each(b) std::cout << ' ' << (trits[a] op trits[b]); \    } \    std::cout << std::endl;
 
    std::cout << strv << std::endl;
    for_each(a) std::cout << trits[a] << strv << !trits[a] << std::endl;
 
    show_op(&&);
    show_op(||);
    show_op(>>);
    show_op(==);
    return EXIT_SUCCESS;
}"
"#include <iostream>
#include <boost/date_time/posix_time/posix_time.hpp>
 
int main( ) {
   boost::posix_time::ptime t ( boost::posix_time::second_clock::local_time( ) ) ;
   std::cout << to_simple_string( t ) << std::endl ;
   return 0 ;
}#include <chrono>
#include <ctime> //for conversion std::ctime()
#include <iostream>
 
int main() {
    auto timenow = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    std::cout << std::ctime(&timenow) << std::endl;
}"
"#include <future>
#include <iostream>
#include <fstream>
#include <mutex>
#include <queue>
#include <string>
#include <thread>
 
struct lock_queue
{
    std::queue<std::string> q;
    std::mutex mutex;
};
 
void reader(std::string filename, std::future<size_t> lines, lock_queue& out)
{
    std::string line;
    std::ifstream in(filename);
    while(std::getline(in, line)) {
        line += '';
        std::lock_guard<std::mutex> lock(out.mutex);
        out.q.push(line);
    } {
        std::lock_guard<std::mutex> lock(out.mutex);
        out.q.push(strv);
    }
    lines.wait();
    std::cout << ""Printed "" << lines.get() << "" lines"";
}
 
void printer(std::promise<size_t> lines, lock_queue& in)
{
    std::string s;
    size_t line_n = 0;
    bool print = false;
    while(true) {
        {
            std::lock_guard<std::mutex> lock(in.mutex);
            if(( print = not in.q.empty() )) { //Assignment intended
                s = in.q.front();
                in.q.pop();
            }
        }
        if(print) {
            if(s == strv) break;
            std::cout << s;
            ++line_n;
            print = false;
        }
    }
    lines.set_value(line_n);
}
 
int main()
{
    lock_queue queue;
    std::promise<size_t> promise;
    std::thread t1(reader, strv, promise.get_future(), std::ref(queue));
    std::thread t2(printer, std::move(promise), std::ref(queue));
    t1.join(); t2.join();
}"
"#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>
#include <string>
 
using namespace std;
 
int main( ) {
   string setA[] = { strv, strv , strv, strv };
   string setB[] = { strv , strv, strv, strv  };
   set<string> 
       firstSet( setA , setA + 4 ),
       secondSet( setB , setB + 4 ),
       symdiff;
 
   set_symmetric_difference( firstSet.begin(), firstSet.end(),
                             secondSet.begin(), secondSet.end(),
                             inserter( symdiff, symdiff.end() ) );
 
   copy( symdiff.begin(), symdiff.end(), ostream_iterator<string>( cout , strv ) );
   cout << endl;
   return 0;
}"
"#include <iostream>
#include <numeric>
#include <vector>
 
double add_square(double prev_sum, double new_val)
{
  return prev_sum + new_val*new_val;
}
 
double vec_add_squares(std::vector<double>& v)
{
  return std::accumulate(v.begin(), v.end(), 0.0, add_square);
}
 
int main()
{
  

  std::vector<double> v; 

  std::cout << vec_add_squares(v) << std::endl;
 
  

  double data[] = { 0, 1, 3, 1.5, 42, 0.1, -4 };
  v.assign(data, data+7);
  std::cout << vec_add_squares(v) << std::endl;
  return 0;
}#include <numeric>
#include <vector>
#include strv
 
double vec_add_squares(std::vector<double>& v)
{
  using namespace boost::lambda;
 
  return std::accumulate(v.begin(), v.end(), 0.0, _1 + _2 * _2);
}"
"#include <iostream>
 
double f(double x);
 
int main()
{
    unsigned int start = 1;
    unsigned int end = 1000;
    double sum = 0;
 
    for( unsigned int x = start; x <= end; ++x )
    {
        sum += f(x);
    }
    std::cout << strv << start << strv << end << strv << sum << std::endl;
    return 0;
}
 
 
double f(double x)
{
    return ( 1.0 / ( x * x ) );
}"
"#include <iostream>
#include <cmath>
int SumDigits(const unsigned long long int digits, const int BASE = 10) {
    int sum = 0;
    unsigned long long int x = digits;
    for (int i = log(digits)/log(BASE); i>0; i--){
        const double z = std::pow(BASE,i);
	  const unsigned long long int t = x/z;
	  sum += t;
	  x -= t*z;
    }
    return x+sum;
}
 
int main() {
        std::cout << SumDigits(1) << ' '
                  << SumDigits(12345) << ' '
                  << SumDigits(123045) << ' '
                  << SumDigits(0xfe, 16) << ' '
                  << SumDigits(0xf0e, 16) << std::endl;
        return 0;
} 


#include <iostream>
#include <cmath>
 
typedef unsigned long long int T;
template <typename T, T i> void For(T &sum, T &x, const T &BASE)
{
    const double z(std::pow(BASE,i));
    const T t = x/z;
    sum += t;
    x -= t*z; 
    For<T, i-1>(sum,x,BASE);
}
template <> void For<T,0>(T &, T &, const T &){}
 
template <typename T, T digits, int BASE> T SumDigits()
 {
    T sum(0);
    T x(digits);
    const T end(log(digits)/log(BASE));
    For<T,end>(sum,x,BASE);
    return x+sum;
}
 
int main() 
{
        std::cout << SumDigits<T, 1     , 10>()  << ' '
                  << SumDigits<T, 12345 , 10>()  << ' '
                  << SumDigits<T, 123045, 10>()  << ' '
                  << SumDigits<T, 0xfe  , 16>()  << ' '
                  << SumDigits<T, 0xf0e , 16>()  << std::endl;
        return 0;
}
 "
" 
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
typedef unsigned long long bigInt;
 
using namespace std;
//--------------------------------------------------------------------------------------------------
class m35
{
public:
    void doIt( bigInt i )
    {
	bigInt sum = 0;
	for( bigInt a = 1; a < i; a++ )
	    if( !( a % 3 ) || !( a % 5 ) ) sum += a;
 
	cout << strv << sum << strv << i << endl << endl;
    }
 
    

    void doIt_b( bigInt i )
    {
	bigInt sum = 0;
	for( bigInt a = 0; a < 28; a++ )
	{
	    if( !( a % 3 ) || !( a % 5 ) )
	    {
		sum += a;
		for( bigInt s = 30; s < i; s += 30 )
		    if( a + s < i ) sum += ( a + s );
 
	    }
	}
	cout << strv << sum << strv << i << endl << endl;
    }
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    m35 m; m.doIt( 1000 );
    return system( strv );
}
 "
" 


 
#include <iostream>
using std::cout;
using std::endl;
 
#include <boost/array.hpp>
#include <boost/circular_buffer.hpp>
 
class Subtractive_generator {
private:
    static const int param_i = 55;
    static const int param_j = 24;
    static const int initial_load = 219;
    static const int mod = 1e9;
    boost::circular_buffer<int> r;
public:
    Subtractive_generator(int seed);
    int next(); 
    int operator()(){return next();} 
};
 
Subtractive_generator::Subtractive_generator(int seed)
:r(param_i)
{
    boost::array<int, param_i> s;
    s[0] = seed;
    s[1] = 1;
    for(int n = 2; n < param_i; ++n){
        int t = s[n-2]-s[n-1];
        if (t < 0 ) t+= mod;
        s[n] = t;
    }
 
    for(int n = 0; n < param_i; ++n){
	int i = (34 * (n+1)) % param_i;
        r.push_back(s[i]);
    }
    for(int n = param_i; n <= initial_load; ++n) next();
}
 
int Subtractive_generator::next()
{
    int t = r[0]-r[31];
    if (t < 0) t += mod;
    r.push_back(t);
    return r[param_i-1];
}
 
int main()
{
    Subtractive_generator rg(292929);
 
    cout << strv << rg() << endl;
    cout << strv << rg() << endl;
    cout << strv << rg() << endl;
    cout << strv << rg() << endl;
    cout << strv << rg() << endl;
    cout << strv << rg() << endl;
    cout << strv << rg() << endl;
 
    return 0;
} 
 "
"#include <numeric>
#include <functional>
 
int arg[] = { 1, 2, 3, 4, 5 };
int sum  = std::accumulate(arg, arg+5, 0, std::plus<int>());






int prod = std::accumulate(arg, arg+5, 1, std::multiplies<int>());

template <typename T> T sum (const T *array, const unsigned n)
{
    T accum = 0;
    for (unsigned i=0; i<n; i++)
        accum += array[i];
    return accum;
}
template <typename T> T prod (const T *array, const unsigned n)
{
    T accum = 1;
    for (unsigned i=0; i<n; i++)
        accum *= array[i];
    return accum;
}
 
#include <iostream>
using std::cout;
using std::endl;
 
int main ()
{
    int aint[] = {1, 2, 3};
    cout << sum(aint,3) << strv << prod(aint, 3) << endl;
    float aflo[] = {1.1, 2.02, 3.003, 4.0004};
    cout << sum(aflo,4) << strv << prod(aflo,4) << endl;
    return 0;
}"
"#include <string>
#include <iostream>
 
int main( ) {
   std::string word( strv ) ;
   std::cout << strv << word.substr( 1 ) << "" !"" ;
   std::cout << strv << word.substr( 0 , word.length( ) - 1 ) << "" !"" ;
   std::cout << strv << word.substr( 1 , word.length( ) - 2 ) << "" !"" ;
   return 0 ;
}"
"#include <iostream>
#include <string>
 
int main()
{
  std::string s = strv;
 
  int const n = 3;
  int const m = 4;
  char const c = '2';
  std::string const sub = strv;
 
  std::cout << s.substr(n, m)<< """";
  std::cout << s.substr(n) << """";
  std::cout << s.substr(0, s.size()-1) << """";
  std::cout << s.substr(s.find(c), m) << """";
  std::cout << s.substr(s.find(sub), m) << """";
}"
"#include <iostream>
using namespace std;
 
class SudokuSolver {
private:
    int grid[81];
 
public:
 
    SudokuSolver(string s) {
        for (unsigned int i = 0; i < s.length(); i++) {
            grid[i] = (int) (s[i] - '0');
        }
    }
 
    void solve() {
        try {
            placeNumber(0);
            cout << strv << endl;
        } catch (char* ex) {
            cout << ex << endl;
            cout << this->toString() << endl;
        }
    }
 
    void placeNumber(int pos) {
        if (pos == 81) {
            throw (char*) strv;
        }
        if (grid[pos] > 0) {
            placeNumber(pos + 1);
            return;
        }
        for (int n = 1; n <= 9; n++) {
            if (checkValidity(n, pos % 9, pos / 9)) {
                grid[pos] = n;
                placeNumber(pos + 1);
                grid[pos] = 0;
            }
        }
    }
 
    bool checkValidity(int val, int x, int y) {
        for (int i = 0; i < 9; i++) {
            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)
                return false;
        }
        int startX = (x / 3) * 3;
        int startY = (y / 3) * 3;
        for (int i = startY; i < startY + 3; i++) {
            for (int j = startX; j < startX + 3; j++) {
                if (grid[i * 9 + j] == val)
                    return false;
            }
        }
        return true;
    }
 
    string toString() {
        string sb;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c[2];
                c[0] = grid[i * 9 + j] + '0';
                c[1] = '';
                sb.append(c);
                sb.append(strv);
                if (j == 2 || j == 5)
                    sb.append(strv);
            }
            sb.append("""");
            if (i == 2 || i == 5)
                sb.append(""------+-------+------"");
        }
        return sb;
    }
 
};
 
int main() {
    SudokuSolver ss(
            (string) strv +
            (string) strv +
            (string) strv +
            (string) strv +
            (string) strv +
            (string) strv +
            (string) strv +
            (string) strv +
            (string) strv
            );
    ss.solve();
}"
" 
#include <iostream>
#include <string>
#include <fstream>
 
class cipher {
public:
    bool work( std::string e, std::string f, std::string k ) {
        if( e.length() < 1 ) return false;
        fileBuffer = readFile( f );
        if( strv == fileBuffer ) return false;
        keyBuffer = readFile( k );
        if( strv == keyBuffer ) return false;
 
        outName = f;
        outName.insert( outName.find_first_of( strv ), strv );
 
        switch( e[0] ) {
            case 'e': return encode();
            case 'd': return decode();
        }
        return false;
    }
private:
    bool encode() {
        size_t idx, len = keyBuffer.length() >> 1;
        for( std::string::iterator i = fileBuffer.begin(); i != fileBuffer.end(); i++ ) {
            idx = keyBuffer.find_first_of( *i );
            if( idx < len ) outBuffer.append( 1, keyBuffer.at( idx + len ) );
            else outBuffer.append( 1, *i );
        }
        return saveOutput();
    }
    bool decode() {
        size_t idx, l = keyBuffer.length(), len = l >> 1;
        for( std::string::iterator i = fileBuffer.begin(); i != fileBuffer.end(); i++ ) {
            idx = keyBuffer.find_last_of( *i );
            if( idx >= len && idx < l ) outBuffer.append( 1, keyBuffer.at( idx - len ) );
            else outBuffer.append( 1, *i );
        }
        return saveOutput();
    }
    bool saveOutput() {
        std::ofstream o( outName.c_str() );
        o.write( outBuffer.c_str(), outBuffer.size() );
        o.close();
        return true;
    }
    std::string readFile( std::string fl ) {
        std::string buffer = strv;
        std::ifstream f( fl.c_str(), std::ios_base::in );
        if( f.good() ) {
            buffer = std::string( ( std::istreambuf_iterator<char>( f ) ), std::istreambuf_iterator<char>() );
            f.close();
        }
        return buffer;
    }
    std::string fileBuffer, keyBuffer, outBuffer, outName;
};
 
int main( int argc, char* argv[] ) {
    if( argc < 4 ) {
        std::cout << ""<d or e>Decrypt or Encrypt<filename>Input file, the output file will have""
        ""'_out' added to it.<key>file with the key to encode/decode"";
    } else {
        cipher c;
        if( c.work( argv[1], argv[2], argv[3] ) ) std::cout << ""File successfully saved!"";
        else std::cout << ""Something went wrong!"";
    }
    return 0;
}
 "
" 
#include <fstream>
#include <iostream>
#include <iterator>
#include <vector>
 
class subleq {
public:
    void load_and_run( std::string file ) {
        std::ifstream f( file.c_str(), std::ios_base::in );
        std::istream_iterator<int> i_v, i_f( f );
        std::copy( i_f, i_v, std::back_inserter( memory ) );
        f.close();
        run();
    }
 
private:
    void run() {
        int pc = 0, next, a, b, c;
        char z;
        do {
            next = pc + 3;
            a = memory[pc]; b = memory[pc + 1]; c = memory[pc + 2];
            if( a == -1 ) {
                std::cin >> z; memory[b] = static_cast<int>( z );
            } else if( b == -1 ) {
                std::cout << static_cast<char>( memory[a] );
            } else {
                memory[b] -= memory[a];
                if( memory[b] <= 0 ) next = c;
            }
            pc = next;
        } while( pc >= 0 );
    }
 
    std::vector<int> memory;
};
 
int main( int argc, char* argv[] ) {
    subleq s;
    if( argc > 1 ) {
        s.load_and_run( argv[1] );
    } else {
        std::cout << ""usage: subleq <filename>"";
    }
    return 0;
}
 "
"#include <string>
#include <iostream>
#include <algorithm>
#include <boost/lambda/lambda.hpp>
#include <boost/lambda/casts.hpp>
#include <ctime>
#include <cstdlib>
using namespace boost::lambda ;
 
struct MyRandomizer {
   char operator( )( ) {
      return static_cast<char>( rand( ) % 256 ) ;
   }
} ;
 
std::string deleteControls ( std::string startstring ) {
   std::string noControls( strv ) ;//creating space for 
   //the standard algorithm remove_copy_if
   std::remove_copy_if( startstring.begin( ) , startstring.end( ) , noControls.begin( ) ,
	 ll_static_cast<int>( _1 ) < 32 && ll_static_cast<int>( _1 ) == 127 ) ;
   return noControls ;
}
 
std::string deleteExtended( std::string startstring ) {
   std::string noExtended ( strv ) ;//same as above
   std::remove_copy_if( startstring.begin( ) , startstring.end( ) , noExtended.begin( ) ,
	 ll_static_cast<int>( _1 ) > 127 || ll_static_cast<int>( _1 ) < 32 ) ;
   return noExtended ;
}
 
int main( ) {
   std::string my_extended_string ;
   for ( int i = 0 ; i < 40 ; i++ ) //we want the extended string to be 40 characters long
      my_extended_string.append( strv ) ;
   srand( time( 0 ) ) ;
   std::generate_n( my_extended_string.begin( ) , 40 , MyRandomizer( ) ) ;
   std::string no_controls( deleteControls( my_extended_string ) ) ;
   std::string no_extended ( deleteExtended( my_extended_string ) ) ;
   std::cout << strv << my_extended_string << std::endl ;
   std::cout << strv << no_controls << std::endl ;
   std::cout << strv << no_extended << std::endl ;
   return 0 ;
}"
"#include <boost/algorithm/string.hpp>
#include <string>
#include <iostream>
 
int main( ) {
   std::string testphrase( strv ) ;
   std::string lefttrimmed = boost::trim_left_copy( testphrase ) ;
   std::string righttrimmed = boost::trim_right_copy( testphrase ) ;
   std::cout << strv << testphrase << """" ;
   std::cout << strv << lefttrimmed << """" ;
   std::cout << strv << righttrimmed << """" ;
   boost::trim( testphrase ) ;
   std::cout << strv <<  testphrase  << """" ;
   return 0 ;
}"
"#include <iostream>
#include <string>
 
std::string strip_white(const std::string& input)
{
   size_t b = input.find_first_not_of(' ');
   if (b == std::string::npos) b = 0;
   return input.substr(b, input.find_last_not_of(' ') + 1 - b);
}
 
std::string strip_comments(const std::string& input, const std::string& delimiters)
{
   return strip_white(input.substr(0, input.find_first_of(delimiters)));
}
 
int main( ) {
   std::string input;
   std::string delimiters(strv);
   while ( getline(std::cin, input) && !input.empty() ) {
      std::cout << strip_comments(input, delimiters) << std::endl ;
   }
   return 0;
}"
"#include <string>
#include <iostream> 
#include <iterator>
#include <fstream>
#include <boost/regex.hpp>
 
int main( ) {
    std::ifstream codeFile( strv ) ;
    if ( codeFile ) {
       boost::regex commentre( ""/*.*?*/"" ) ;//comment start and end, and as few characters in between as possible
       std::string my_erase( strv ) ;             //erase them
       std::string stripped ;
       std::string code( (std::istreambuf_iterator<char>( codeFile ) ) ,
	     std::istreambuf_iterator<char>( ) ) ;
       codeFile.close( ) ;
       stripped = boost::regex_replace( code , commentre , my_erase ) ;
       std::cout << ""Code unstripped:"" << stripped << std::endl ;
       return 0 ;
    }
    else {
       std::cout << strv << std::endl ;
       return 1 ;
    }
}"
"#include <algorithm>
#include <iostream>
#include <string>
 
std::string stripchars(std::string str, const std::string &chars)
{
    str.erase(
        std::remove_if(str.begin(), str.end(), [&](char c){
            return chars.find(c) != std::string::npos;
        }),
        str.end()
    );
    return str;
}
 
int main()
{
    std::cout << stripchars(strv, strv) << '';
    return 0;
}"
"include <vector>
#include <algorithm>
#include <string>
#include <iostream>
 
int main( ) {
   std::vector<std::string> myStrings { strv , strv } ;
   std::string prepended = std::accumulate( myStrings.begin( ) , 
	 myStrings.end( ) , std::string( strv ) , []( std::string a , 
	    std::string b ) { return a + b ; } ) ;
   std::cout << prepended << std::endl ;
   return 0 ;
}"
"#include <string>
using namespace std;
 
string s1=strv;
string s2=strv;
string s3=strv;
//Beginning
s1.compare(0,s3.size(),s3)==0;
//End
s1.compare(s1.size()-s3.size(),s3.size(),s3)==0;
//Anywhere
s1.find(s2)//returns string::npos
int loc=s2.find(s3)//returns 0
loc=s2.find(s3,loc+1)//returns 2"
"#include <string> // (not <string.h>!)
using std::string;
 
int main()
{
  string s = strv;
  string::size_type length = s.length(); 

  string::size_type size = s.size();     

  

  string::size_type bytes = s.length() * sizeof(string::value_type); 
}#include <string>
using std::wstring;
 
int main()
{
  wstring s = L"""";
  wstring::size_type length = s.length() * sizeof(wstring::value_type); 

}#include <string>
using std::wstring;
 
int main()
{
  wstring s = L"""";
  wstring::size_type length = s.length();
}#include <iostream>
#include <codecvt>
int main()
{
    std::string utf8 = """"; 

    std::cout << strv << utf8.size() << '';
    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> conv;
    std::cout << strv << conv.from_bytes(utf8).size() << '';
}#include <cwchar>  // for mbstate_t
#include <locale>
 


std::size_t char_length(std::string const& text, char const* locale_name)
{
  

  

  

  std::size_t len = text.length();
  char const* input = text.data();
 
  

  std::locale loc(locale_name);
 
  

  typedef std::codecvt<wchar_t, char, std::mbstate_t> cvt_type;
  cvt_type const& cvt = std::use_facet<cvt_type>(loc);
 
  

  std::size_t bufsize = cvt.max_length()*len;
  wchar_t* destbuf = new wchar_t[bufsize];
  wchar_t* dest_end;
 
  

  mbstate_t state = mbstate_t();
  cvt.in(state, input, input+len, input, destbuf, destbuf+bufsize, dest_end);
 
  

  std::size_t length = dest_end - destbuf;
 
  

  delete[] destbuf;
 
  

  return length;
}#include <iostream>
 
int main()
{
  

  std::cout << char_length("""", strv) << """"; 

 
  

  std::cout << char_length("""", strv) << """"; 

}"
"#include <string>
#include <iostream>
 
int main( ) {
   std::string original( strv ) , toBeReplaced( strv ) ,
      replacement ( strv ) ;
   std::string newString = original.replace( original.find( strv ) ,
	 toBeReplaced.length( ) , replacement ) ;
   std::cout << strv << newString << "" "" ;
   return 0 ;
}"
"#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>
 
template <typename T>
void demo_compare(const T &a, const T &b, const std::string &semantically) {
    std::cout << a << strv << b << strv << ((a == b) ? strv : strv)
              << strv << semantically << strv << std::endl;
 
    std::cout << a << strv << b << strv << ((a != b) ? strv : strv)
              << semantically << strv << std::endl;
 
    std::cout << a << strv << ((a < b) ? strv : strv) << semantically
              << strv << b << '.' << std::endl;
 
    std::cout << a << strv << ((a > b) ? strv : strv) << semantically
              << strv << b << '.' << std::endl;
}
 
int main(int argc, char *argv[]) {
    

    std::string a((argc > 1) ? argv[1] : strv);
    std::string b((argc > 2) ? argv[2] : strv);
    demo_compare<std::string>(a, b, strv);
 
    

    std::transform(a.begin(), a.end(), a.begin(), ::tolower);
    std::transform(b.begin(), b.end(), b.begin(), ::tolower);
    demo_compare<std::string>(a, b, strv);
 
    

    

    double numA, numB;
    std::istringstream(a) >> numA;
    std::istringstream(b) >> numB;
    demo_compare<double>(numA, numB, strv);
    return (a == b);
}"
"#include <string>
#include <iostream>
 
int main() {
   std::string s = strv;
   std::cout << s << strv << std::endl;
   std::string s2 = s + strv;
   std::cout << s2 << std::endl;
   return 0;
}"
"#include <algorithm>
#include <string>
#include <cctype>
 
/// \brief in-place convert string to upper case
/// \return ref to transformed string
void str_toupper(std::string &str) {
  std::transform(str.begin(), 
                 str.end(), 
                 str.begin(),
                 (int(*)(int)) std::toupper);
}
 
/// \brief in-place convert string to lower case
/// \return ref to transformed string
void str_tolower(std::string &str) {
  std::transform(str.begin(), 
                 str.end(), 
                 str.begin(),
                 (int(*)(int)) std::tolower);
}#include <iostream>
#include <string>
 
using namespace std;
int main() {
  string foo(strv);
  str_toupper(foo);
  cout << foo << endl;
  str_tolower(foo);
  cout << foo << endl;
  return 0;
}"
"#include <iostream>
#include <string>
 
int main( ) {
   std::string greeting( strv ) ;
   greeting.append( strv ) ;
   std::cout << greeting << std::endl ;
   return 0 ;
}"
"#include <iostream>
#include <string>
#include <map>
#include <algorithm> // for min, max
using namespace std;
 
class StraddlingCheckerboard
{
  map<char, string> table;
  char first[10], second[10], third[10];
  int rowU, rowV;
 
public:
  StraddlingCheckerboard(const string &alphabet, int u, int v)
  {
    rowU = min(u, v);
    rowV = max(u, v);
 
    for(int i = 0, j = 0; i < 10; ++i)
    {
      if(i != u && i != v)
      {
        first[i] = alphabet[j];
        table[alphabet[j]] = '0' + i;
        ++j;
      }
 
      second[i] = alphabet[i+8];
      table[alphabet[i+8]] = '0' + rowU;
      table[alphabet[i+8]] += '0' + i;
 
      third[i] = alphabet[i+18];
      table[alphabet[i+18]] = '0' + rowV;
      table[alphabet[i+18]] += '0' + i;
    }
  }
 
  string encode(const string &plain)
  {
    string out;
    for(int i = 0; i < plain.size(); ++i)
    {
      char c = plain[i];
      if(c >= 'a' && c <= 'z')
        c += 'A' - 'a';
 
      if(c >= 'A' && c <= 'Z')
        out += table[c];
      else if(c >= '0' && c <= '9')
      {
        out += table['/'];
        out += c;
      }
    }
    return out;
  }
 
  string decode(const string &cipher)
  {
    string out;
    int state = 0;
    for(int i = 0; i < cipher.size(); ++i)
    {
      int n = cipher[i] - '0';
      char next = 0;
 
      if(state == 1)
        next = second[n];
      else if(state == 2)
        next = third[n];
      else if(state == 3)
        next = cipher[i];
      else if(n == rowU)
        state = 1;
      else if(n == rowV)
        state = 2;
      else
        next = first[n];
 
      if(next == '/')
        state = 3;
      else if(next != 0)
      {
        state = 0;
        out += next;
      }
    }
    return out;
  }
};int main()
{
  StraddlingCheckerboard sc(strv, 3, 7);
 
  string original = strv;
  string en = sc.encode(original);
  string de = sc.decode(en);
 
  cout << strv << original << endl;
  cout << strv << en << endl;
  cout << strv << de << endl;
 
  return 0;
}"
"#include <random>
#include <map>
#include <string>
#include <iostream>
#include <cmath>
#include <iomanip>
 
int main( ) {
   std::random_device myseed ;
   std::mt19937 engine ( myseed( ) ) ;
   std::normal_distribution<> normDistri ( 2 , 3 ) ;
   std::map<int , int> normalFreq ;
   int sum = 0 ; //holds the sum of the randomly created numbers
   double mean = 0.0 ;
   double stddev = 0.0 ;
   for ( int i = 1 ; i < 10001 ; i++ ) 
      ++normalFreq[ normDistri ( engine ) ] ;
   for ( auto MapIt : normalFreq ) {
      sum += MapIt.first * MapIt.second ;
   }
   mean = sum / 10000 ;
   stddev = sqrt( sum / 10000 ) ;
   std::cout << strv << mean << strv ;
   std::cout << strv << stddev << "" !"" ;
   std::cout << ""And now the histogram:"" ;
   for ( auto MapIt : normalFreq ) {
      std::cout << std::left << std::setw( 4 ) << MapIt.first << 
	 std::string( MapIt.second / 100 , '*' ) << std::endl ;
   }
   return 0 ;
}"
" 
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <vector>
 
unsigned gcd( unsigned i, unsigned j ) {
    return i ? i < j ? gcd( j % i, i ) : gcd( i % j, j ) : j;
}
void createSequence( std::vector<unsigned>& seq, int c ) {
    if( 1500 == seq.size() ) return;
    unsigned t = seq.at( c ) + seq.at( c + 1 );
    seq.push_back( t );
    seq.push_back( seq.at( c + 1 ) );
    createSequence( seq, c + 1 );
}
int main( int argc, char* argv[] ) {
    std::vector<unsigned> seq( 2, 1 );
    createSequence( seq, 0 );
 
    std::cout << ""First fifteen members of the sequence:    "";
    for( unsigned x = 0; x < 15; x++ ) {
        std::cout << seq[x] << strv;    
    }
 
    std::cout << """";    
    for( unsigned x = 1; x < 11; x++ ) {
        std::vector<unsigned>::iterator i = std::find( seq.begin(), seq.end(), x );
        if( i != seq.end() ) {
            std::cout << std::setw( 3 ) << x << strv << 1 + distance( seq.begin(), i ) << """";
        }
    }
 
    std::cout << """";
    std::vector<unsigned>::iterator i = std::find( seq.begin(), seq.end(), 100 );
    if( i != seq.end() ) {
        std::cout << 100 << strv << 1 + distance( seq.begin(), i ) << """";
    }
 
    std::cout << """";
    unsigned g;
    bool f = false;
    for( int x = 0, y = 1; x < 1000; x++, y++ ) {
        g =  gcd( seq[x], seq[y] );
	if( g != 1 ) f = true;
        std::cout << std::setw( 4 ) << x + 1 << strv << seq[x] << strv 
                  << seq[y] << strv << g << ( g != 1 ? "" <-- ERROR"" : """" );
    }
    std::cout << """" << ( f ? strv : strv ) << """";
    return 0;
}
 "
"#include <algorithm>
#include <iomanip>
#include <iostream>
#include <vector>
 
const int dataset[] = {
     12,127, 28, 42, 39,113, 42, 18, 44,118, 44, 37,113,124, 37, 48,127, 36,
     29, 31,125,139,131,115,105,132,104,123, 35,113,122, 42,117,119, 58,109,
     23,105, 63, 27, 44,105, 99, 41,128,121,116,125, 32, 61, 37,127, 29,113,
    121, 58,114,126, 53,114, 96, 25,109,  7, 31,141, 46, 13, 27, 43,117,116,
     27,  7, 68, 40, 31,115,124, 42,128, 52, 71,118,117, 38, 27,106, 33,117,
    116,111, 40,119, 47,105, 57,122,109,124,115, 43,120, 43, 27, 27, 18, 28,
     48,125,107,114, 34,133, 45,120, 30,127, 31,116,146
};
const int datasize = sizeof(dataset) / sizeof(dataset[0]);
 
int main()
{
    typedef std::pair<int,int> StemLeaf;
    std::vector<StemLeaf> stemplot;
 
    for (int i = 0; i < datasize; ++i)
    {
        stemplot.push_back(StemLeaf(dataset[i] / 10, dataset[i] % 10));
    }
 
    std::sort(stemplot.begin(), stemplot.end());  

 
    int lo = stemplot.front().first; 

    int hi = stemplot.back().first; 

 
    for (std::vector<StemLeaf>::iterator itr = stemplot.begin(); lo <= hi; ++lo)
    {
        std::cout << std::setw(2) << lo << strv; 

 
        

        for ( ; itr != stemplot.end() && itr->first == lo; ++itr)
        {
            std::cout << strv << itr->second; 

        }
 
        std::cout << std::endl;
    }
}"
"#include <iostream>
#include <random>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <cmath>
 
void printStars ( int number ) {
   if ( number > 0 ) { 
      for ( int i = 0 ; i < number + 1 ; i++ ) 
	 std::cout << '*' ;
   }
   std::cout << '' ;
}
 
int main( int argc , char *argv[] ) {
   const int numberOfRandoms = std::atoi( argv[1] ) ;
   std::random_device rd ;
   std::mt19937 gen( rd( ) ) ;
   std::uniform_real_distribution<> distri( 0.0 , 1.0 ) ;
   std::vector<double> randoms ;
   for ( int i = 0 ; i < numberOfRandoms + 1 ; i++ ) 
      randoms.push_back ( distri( gen ) ) ;
   std::sort ( randoms.begin( ) , randoms.end( ) ) ;
   double start = 0.0 ;
   for ( int i = 0 ;  i < 9 ; i++ ) {
      double to = start + 0.1 ;
      int howmany =  std::count_if ( randoms.begin( ) , randoms.end( ),
	        [&start , &to] ( double c ) { return c >= start 
		  && c < to ; } ) ;
      if ( start == 0.0 ) //double 0.0 output as 0
	 std::cout << strv << strv << to << strv ;
      else 
	 std::cout << start << strv << to << strv ;
      if ( howmany > 50 ) //scales big interval numbers to printable length
	 howmany = howmany / ( howmany / 50 ) ;
      printStars ( howmany ) ;
      start += 0.1 ;
   }
   double mean = std::accumulate( randoms.begin( ) , randoms.end( ) , 0.0 ) / randoms.size( ) ;
   double sum = 0.0 ;
   for ( double num : randoms ) 
      sum += std::pow( num - mean , 2 ) ;
   double stddev = std::pow( sum / randoms.size( ) , 0.5 ) ;
   std::cout << strv << mean << strv << std::endl ;
   std::cout << strv << stddev << strv << std::endl ;
   return 0 ;
}"
"#include <algorithm>
#include <iostream>
#include <string>
#include <array>
#include <vector>
 
template<typename T>
T unique(T&& src)
{
    T retval(std::move(src));
    std::sort(retval.begin(), retval.end(), std::less<typename T::value_type>());
    retval.erase(std::unique(retval.begin(), retval.end()), retval.end());
    return retval;
}
 
#define USE_FAKES 1
 
auto states = unique(std::vector<std::string>({
#if USE_FAKES
    strv, strv,
#endif
    strv, strv, strv, strv,
    strv, strv, strv,
    strv,
    strv, strv, strv,
    strv, strv, strv, strv,
    strv, strv, strv,
    strv, strv, strv, strv,
    strv, strv, strv, strv,
    strv, strv, strv, strv,
    strv, strv, strv, strv,
    strv, strv, strv,
    strv, strv,
    strv, strv, strv, strv,
    strv, strv, strv,
    strv, strv, strv, strv
}));
 
struct counted_pair
{
    std::string name;
    std::array<int, 26> count{};
 
    void count_characters(const std::string& s)
    {
        for (auto&& c : s) {
            if (c >= 'a' && c <= 'z') count[c - 'a']++;
            if (c >= 'A' && c <= 'Z') count[c - 'A']++;
        }
    }
 
    counted_pair(const std::string& s1, const std::string& s2)
        : name(s1 + strv + s2)
    {
        count_characters(s1);
        count_characters(s2);
    }
};
 
bool operator<(const counted_pair& lhs, const counted_pair& rhs)
{
    auto lhs_size = lhs.name.size();
    auto rhs_size = rhs.name.size();
    return lhs_size == rhs_size
            ? std::lexicographical_compare(lhs.count.begin(),
                                           lhs.count.end(),
                                           rhs.count.begin(),
                                           rhs.count.end())
            : lhs_size < rhs_size;
}
 
bool operator==(const counted_pair& lhs, const counted_pair& rhs)
{
    return lhs.name.size() == rhs.name.size() && lhs.count == rhs.count;
}
 
int main()
{
    const int n_states = states.size();
 
    std::vector<counted_pair> pairs;
    for (int i = 0; i < n_states; i++) {
        for (int j = 0; j < i; j++) {
            pairs.emplace_back(counted_pair(states[i], states[j]));
        }
    }
    std::sort(pairs.begin(), pairs.end());
 
    auto start = pairs.begin();
    while (true) {
        auto match = std::adjacent_find(start, pairs.end());
        if (match == pairs.end()) {
            break;
        }
        auto next = match + 1;
        std::cout << match->name << strv << next->name << """";
        start = next;
    }
}"
"void step_up()
{
  while (!step()) step_up();
}void step_up()
{
  for (int i = 0; i < 1; step()? ++i : --i);
}"
" 


#include<string>
#include<iostream>
auto spliter(const std::string &input) {
   auto firstCommaPast = false;
   std::string res =strv;
   auto prev = '';
   for(auto it = input.cbegin(); it != input.cend();++it) {
      if(*it!=prev) {
         if(!firstCommaPast) {
            firstCommaPast = true;
         } else {
            res+=strv;
         }
      }
      res+=*it;
      prev=*it;
   }
   return res;
}
 
int main() {
   auto input = Rstrv;
   std::cout<<spliter(input);
}  "
"#include <stack>#include <deque>
template <class T, class Sequence = std::deque<T> >
class stack {
  friend bool operator== (const stack&, const stack&);
  friend bool operator<  (const stack&, const stack&);
public:
  typedef typename Sequence::value_type      value_type;
  typedef typename Sequence::size_type       size_type;
  typedef          Sequence                  container_type;
  typedef typename Sequence::reference       reference;
  typedef typename Sequence::const_reference const_reference;
protected:
  Sequence seq;
public:
  stack() : seq() {}
  explicit stack(const Sequence& s0) : seq(s0) {}
  bool empty() const { return seq.empty(); }
  size_type size() const { return seq.size(); }
  reference top() { return seq.back(); }
  const_reference top() const { return seq.back(); }
  void push(const value_type& x) { seq.push_back(x); }
  void pop() { seq.pop_back(); }
};
 
template <class T, class Sequence>
bool operator==(const stack<T,Sequence>& x, const stack<T,Sequence>& y)
{
  return x.seq == y.seq;
}
template <class T, class Sequence>
bool operator<(const stack<T,Sequence>& x, const stack<T,Sequence>& y)
{
  return x.seq < y.seq;
}
 
template <class T, class Sequence>
bool operator!=(const stack<T,Sequence>& x, const stack<T,Sequence>& y)
{
  return !(x == y);
}
template <class T, class Sequence>
bool operator>(const stack<T,Sequence>& x, const stack<T,Sequence>& y)
{
  return y < x;
}
template <class T, class Sequence>
bool operator<=(const stack<T,Sequence>& x, const stack<T,Sequence>& y)
{
  return !(y < x);
}
template <class T, class Sequence>
bool operator>=(const stack<T,Sequence>& x, const stack<T,Sequence>& y)
{
  return !(x < y);
}"
"#include <iostream>
#include <sstream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <locale>
 
class Sparkline {
    public:
        Sparkline(std::wstring &cs) : charset( cs ){
        }
        virtual ~Sparkline(){
        }
 
        void print(std::string spark){
            const char *delim = strv;
            std::vector<float> data;
            

            std::string::size_type last = spark.find_first_not_of(delim, 0);
            

            std::string::size_type pos = spark.find_first_of(delim, last);
 
            while( pos != std::string::npos || last != std::string::npos ){
                std::string tok = spark.substr(last, pos-last);
                

                std::stringstream ss(tok);
                float entry;
                ss >> entry;
 
                data.push_back( entry );
 
                last = spark.find_first_not_of(delim, pos);
                pos = spark.find_first_of(delim, last);
            }
 
            

            float min = *std::min_element( data.begin(), data.end() );
            float max = *std::max_element( data.begin(), data.end() );
 
            float skip = (charset.length()-1) / (max - min);
 
            std::wcout<<Lstrv<<min<<Lstrv<<max<<Lstrv<<(max-min)<<std::endl;
 
            std::vector<float>::const_iterator it;
            for(it = data.begin(); it != data.end(); it++){
                float v = ( (*it) - min ) * skip; 
                std::wcout<<charset[ (int)floor( v ) ];
            }
            std::wcout<<std::endl;
 
        }
    private:
        std::wstring &charset;
};
 
int main( int argc, char **argv ){
    std::wstring charset = L"""";
 
    

    std::locale::global(std::locale(strv));
 
    Sparkline sl(charset);
 
    sl.print(strv);
    sl.print(strv);
 
    return 0;
}"
"std::cout << ""Tür"";
std::cout << ""T"";extern int Tür; 

extern int T\u00FCr; 
int const\
ant; 
char const str = strv;
char c = 'x'; 
#include <iostream>#define STR(x) #x
int main()
{
  std::cout << STR(Hello world) << std::endl; 

}#define THE(x) the_ ## x
int THE(answer) = 42; 
"
"#include <vector>
#include <memory>	// for auto_ptr
#include <cmath>	// for the ceil and log10 and floor functions
#include <iostream>
#include <iomanip>	// for the setw function
 
using namespace std;
 
typedef vector< int > IntRow;
typedef vector< IntRow > IntTable;
 
auto_ptr< IntTable > getSpiralArray( int dimension )
{
	auto_ptr< IntTable > spiralArrayPtr( new IntTable(
		dimension, IntRow( dimension ) ) );
 
	int numConcentricSquares = static_cast< int >( ceil(
		static_cast< double >( dimension ) / 2.0 ) );
 
	int j;
	int sideLen = dimension;
	int currNum = 0;
 
	for ( int i = 0; i < numConcentricSquares; i++ )
	{
		

		for ( j = 0; j < sideLen; j++ )
			( *spiralArrayPtr )[ i ][ i + j ] = currNum++;
 
		

		for ( j = 1; j < sideLen; j++ )
			( *spiralArrayPtr )[ i + j ][ dimension - 1 - i ] = currNum++;
 
		

		for ( j = sideLen - 2; j > -1; j-- )
			( *spiralArrayPtr )[ dimension - 1 - i ][ i + j ] = currNum++;
 
		

		for ( j = sideLen - 2; j > 0; j-- )
			( *spiralArrayPtr )[ i + j ][ i ] = currNum++;
 
		sideLen -= 2;
	}
 
	return spiralArrayPtr;
}
 
void printSpiralArray( const auto_ptr< IntTable >& spiralArrayPtr )
{
	size_t dimension = spiralArrayPtr->size();
 
	int fieldWidth = static_cast< int >( floor( log10(
		static_cast< double >( dimension * dimension - 1 ) ) ) ) + 2;
 
	size_t col;
	for ( size_t row = 0; row < dimension; row++ )
	{
		for ( col = 0; col < dimension; col++ )
			cout << setw( fieldWidth ) << ( *spiralArrayPtr )[ row ][ col ];
		cout << endl;
	}
}
 
int main()
{
	printSpiralArray( getSpiralArray( 5 ) );
}#include <vector>
#include <iostream>
using namespace std;
int main() {
	const int n = 5;
	const int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};
	int x = 0, y = -1, c = 0;
	vector<vector<int>> m(n, vector<int>(n));
	for (int i = 0, im = 0; i < n + n - 1; ++i, im = i % 4) 
		for (int j = 0, jlen = (n + n - i) / 2; j < jlen; ++j)
			m[x += dx[im]][y += dy[im]] = ++c;
	for (auto & r : m) {
		for (auto & v : r)
			cout << v << ' ';
		cout << endl;
	}
}"
"#include <list>
 
template <typename T>
std::list<T> strandSort(std::list<T> lst) {
  if (lst.size() <= 1)
    return lst;
  std::list<T> result;
  std::list<T> sorted;
  while (!lst.empty()) {
    sorted.push_back(lst.front());
    lst.pop_front();
    for (typename std::list<T>::iterator it = lst.begin(); it != lst.end(); ) {
      if (sorted.back() <= *it) {
        sorted.push_back(*it);
        it = lst.erase(it);
      } else
        it++;
    }
    result.merge(sorted);
  }
  return result;
}"
"#include <algorithm>
#include <iostream>
#include <map>
#include <queue>
#include <string>
#include <vector>
using namespace std;
 
const char *men_data[][11] = {
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,   strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv, strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv }
};
 
const char *women_data[][11] = {
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv, strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv, strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv },
    { strv,  strv,strv,strv,strv,strv,strv,strv,strv,strv,strv }
};
 
typedef vector<string> PrefList;
typedef map<string, PrefList> PrefMap;
typedef map<string, string> Couples;
 


bool prefers(const PrefList &prefer, const string &first, const string &second)
{
    for (PrefList::const_iterator it = prefer.begin(); it != prefer.end(); ++it)
    {
        if (*it == first) return true;
        if (*it == second) return false;
    }
    return false; 

}
 
void check_stability(const Couples &engaged, const PrefMap &men_pref, const PrefMap &women_pref)
{
    cout << ""Stablility:"";
    bool stable = true;
    for (Couples::const_iterator it = engaged.begin(); it != engaged.end(); ++it)
    {
        const string &bride = it->first;
        const string &groom = it->second;
        const PrefList &preflist = men_pref.at(groom);
 
        for (PrefList::const_iterator it = preflist.begin(); it != preflist.end(); ++it)
        {
            if (*it == bride) 

                break;
            if (prefers(preflist, *it, bride) && 

                prefers(women_pref.at(*it), groom, engaged.at(*it))) 

            {
                cout << """" << *it <<
                    strv << groom <<
                    strv << engaged.at(*it) <<
                    strv << groom <<
                    strv << *it <<
                    strv << bride << """";
                stable = false;
            }
        }
    }
    if (stable) cout << ""(all marriages stable)"";
}
 
int main()
{
    PrefMap men_pref, women_pref;
    queue<string> bachelors;
 
    

    for (int i = 0; i < 10; ++i) 

    {
        for (int j = 1; j < 11; ++j) 

        {
              men_pref[  men_data[i][0]].push_back(  men_data[i][j]);
            women_pref[women_data[i][0]].push_back(women_data[i][j]);
        }
        bachelors.push(men_data[i][0]);
    }
 
    Couples engaged; 

 
    cout << ""Matchmaking:"";
    while (!bachelors.empty())
    {
        const string &suitor = bachelors.front();
        const PrefList &preflist = men_pref[suitor];
 
        for (PrefList::const_iterator it = preflist.begin(); it != preflist.end(); ++it)
        {
            const string &bride = *it;
 
            if (engaged.find(bride) == engaged.end()) 

            {
                cout << """" << bride << strv << suitor << """";
                engaged[bride] = suitor; 

                break;
            }
 
            const string &groom = engaged[bride];
 
            if (prefers(women_pref[bride], suitor, groom))
            {
                cout << """" << bride << strv << groom << strv << suitor << """";
                bachelors.push(groom); 

                engaged[bride] = suitor; 

                break;
            }
        }
        bachelors.pop(); 

    }
 
    cout << ""Engagements:"";
    for (Couples::const_iterator it = engaged.begin(); it != engaged.end(); ++it)
    {
        cout << """" << it->first << strv << it->second << """";
    }
 
    check_stability(engaged, men_pref, women_pref);
 
    cout << ""Perturb:"";
    std::swap(engaged[strv], engaged[strv]);
    cout << ""engage abi with "" << engaged[strv] << strv << engaged[strv] << """";
 
    check_stability(engaged, men_pref, women_pref);
}"
" 
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>
 
int main(int argc, char* argv[]) {
  std::vector<std::thread> threads;
 
  for (int i = 1; i < argc; ++i) {
    threads.emplace_back([i, &argv]() {
      int arg = std::stoi(argv[i]);
      std::this_thread::sleep_for(std::chrono::seconds(arg));
      std::cout << argv[i] << std::endl;
    });
  }
 
  for (auto& thread : threads) {
    thread.join();
  }
}
 "
" 
#include <iostream>
#include <time.h>
 
//------------------------------------------------------------------------------
using namespace std;
 
//------------------------------------------------------------------------------
class stooge
{
public:
    void sort( int* arr, int start, int end )
    {
        if( arr[start] > arr[end - 1] ) swap( arr[start], arr[end - 1] );
	int n = end - start; if( n > 2 )
	{
	    n /= 3; sort( arr, start, end - n );
	    sort( arr, start + n, end ); sort( arr, start, end - n );
        }
    }
};
//------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( static_cast<unsigned int>( time( NULL ) ) ); stooge s; int a[80], m = 80; 
    cout << ""before:"";
    for( int x = 0; x < m; x++ ) { a[x] = rand() % 40 - 20;  cout << a[x] << strv; }
    s.sort( a, 0, m ); cout << ""after:""; 
    for( int x = 0; x < m; x++ ) cout << a[x] << strv; cout << """"; 
    return system( strv );
}
 "
" 
#include <time.h>
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int MAX = 126;
class shell
{
public:
    shell() 
    { _gap[0] = 1750; _gap[1] = 701; _gap[2] = 301; _gap[3] = 132; _gap[4] = 57; _gap[5] = 23; _gap[6] = 10; _gap[7] = 4; _gap[8] = 1; }
 
    void sort( int* a, int count )
    {
	_cnt = count;
	for( int x = 0; x < 9; x++ )
	    if( count > _gap[x] )
	    { _idx = x; break; }
 
	sortIt( a );
    }
 
private:	
    void sortIt( int* arr )
    {
	bool sorted = false;
	while( true )
	{
	    sorted = true;
	    int st = 0;
	    for( int x = _gap[_idx]; x < _cnt; x += _gap[_idx] )
	    {
		if( arr[st] > arr[x] )
		{ swap( arr[st], arr[x] ); sorted = false; }
		st = x;
	    }
	    if( ++_idx >= 8 ) _idx = 8;
	    if( sorted && _idx == 8 ) break;
	}
    }
 
    void swap( int& a, int& b ) { int t = a; a = b; b = t; }
 
    int _gap[9], _idx, _cnt;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( static_cast<unsigned int>( time( NULL ) ) ); int arr[MAX];
    for( int x = 0; x < MAX; x++ )
	arr[x] = rand() % MAX - rand() % MAX;
 
    cout << "" Before: ========="";
    for( int x = 0; x < 7; x++ )
    {
	for( int a = 0; a < 18; a++ )
	{ cout << arr[x * 18 + a] << strv; }
	cout << endl;
    }
    cout << endl; shell s; s.sort( arr, MAX );
 
    cout << "" After: ========"";
    for( int x = 0; x < 7; x++ )
    {
	for( int a = 0; a < 18; a++ )
	{ cout << arr[x * 18 + a] << strv; }
	cout << endl;
    }
    cout << endl << endl; return system( strv );
}
//--------------------------------------------------------------------------------------------------
 "
"#include <algorithm>
#include <iterator>
#include <iostream>
 
template<typename ForwardIterator> void selection_sort(ForwardIterator begin,
                                                       ForwardIterator end) {
  for(auto i = begin; i != end; ++i) {
    std::iter_swap(i, std::min_element(i, end));
  }
}
 
int main() {
  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};
  selection_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
}"
"#include <iostream>
#include <vector>
#include <stack>
#include <iterator>
#include <algorithm>
#include <cassert>
 
template <class E>
struct pile_less {
  bool operator()(const std::stack<E> &pile1, const std::stack<E> &pile2) const {
    return pile1.top() < pile2.top();
  }
};
 
template <class E>
struct pile_greater {
  bool operator()(const std::stack<E> &pile1, const std::stack<E> &pile2) const {
    return pile1.top() > pile2.top();
  }
};
 
 
template <class Iterator>
void patience_sort(Iterator first, Iterator last) {
  typedef typename std::iterator_traits<Iterator>::value_type E;
  typedef std::stack<E> Pile;
 
  std::vector<Pile> piles;
  

  for (Iterator it = first; it != last; it++) {
    E& x = *it;
    Pile newPile;
    newPile.push(x);
    typename std::vector<Pile>::iterator i =
      std::lower_bound(piles.begin(), piles.end(), newPile, pile_less<E>());
    if (i != piles.end())
      i->push(x);
    else
      piles.push_back(newPile);
  }
 
  

  

  std::make_heap(piles.begin(), piles.end(), pile_greater<E>());
  for (Iterator it = first; it != last; it++) {
    std::pop_heap(piles.begin(), piles.end(), pile_greater<E>());
    Pile &smallPile = piles.back();
    *it = smallPile.top();
    smallPile.pop();
    if (smallPile.empty())
      piles.pop_back();
    else
      std::push_heap(piles.begin(), piles.end(), pile_greater<E>());
  }
  assert(piles.empty());
}
 
int main() {
  int a[] = {4, 65, 2, -31, 0, 99, 83, 782, 1};
  patience_sort(a, a+sizeof(a)/sizeof(*a));
  std::copy(a, a+sizeof(a)/sizeof(*a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << std::endl;
  return 0;
}"
"#include <algorithm>
#include <iostream>
#include <iterator>
 


class radix_test
{
    const int bit; 

public:
    radix_test(int offset) : bit(offset) {} 

 
    bool operator()(int value) const 

    {
        if (bit == 31) 

            return value < 0; 

        else
            return !(value & (1 << bit)); 

    }
};
 


void lsd_radix_sort(int *first, int *last)
{
    for (int lsb = 0; lsb < 32; ++lsb) 

    {
        std::stable_partition(first, last, radix_test(lsb));
    }
}
 


void msd_radix_sort(int *first, int *last, int msb = 31)
{
    if (first != last && msb >= 0)
    {
        int *mid = std::partition(first, last, radix_test(msb));
        msb--; 

        msd_radix_sort(first, mid, msb); 

        msd_radix_sort(mid, last, msb); 

    }
}
 


int main()
{
    int data[] = { 170, 45, 75, -90, -802, 24, 2, 66 };
 
    lsd_radix_sort(data, data + 8);
    

 
    std::copy(data, data + 8, std::ostream_iterator<int>(std::cout, strv));
 
    return 0;
}"
"#include <algorithm>
 
template<typename ForwardIterator>
 void permutation_sort(ForwardIterator begin, ForwardIterator end)
{
  while (std::next_permutation(begin, end))
  {
    

  }
}"
"#include <iterator>
#include <algorithm> // for std::partition
#include <functional> // for std::less
 


template<typename T>
 T median(T t1, T t2, T t3)
{
  if (t1 < t2)
  {
    if (t2 < t3)
      return t2;
    else if (t1 < t3)
      return t3;
    else
      return t1;
  }
  else
  {
    if (t1 < t3)
      return t1;
    else if (t2 < t3)
      return t3;
    else
      return t2;
  }
}
 


template<typename Order> struct non_strict_op:
  public std::binary_function<typename Order::second_argument_type,
                              typename Order::first_argument_type,
                              bool>
{
  non_strict_op(Order o): order(o) {}
  bool operator()(typename Order::second_argument_type arg1,
                  typename Order::first_argument_type arg2) const
  {
    return !order(arg2, arg1);
  }
private:
  Order order;
};
 
template<typename Order> non_strict_op<Order> non_strict(Order o)
{
  return non_strict_op<Order>(o);
}
 
template<typename RandomAccessIterator,
         typename Order>
 void quicksort(RandomAccessIterator first, RandomAccessIterator last, Order order)
{
  if (first != last && first+1 != last)
  {
    typedef typename std::iterator_traits<RandomAccessIterator>::value_type value_type;
    RandomAccessIterator mid = first + (last - first)/2;
    value_type pivot = median(*first, *mid, *(last-1));
    RandomAccessIterator split1 = std::partition(first, last, std::bind2nd(order, pivot));
    RandomAccessIterator split2 = std::partition(split1, last, std::bind2nd(non_strict(order), pivot));
    quicksort(first, split1, order);
    quicksort(split2, last, order);
  }
}
 
template<typename RandomAccessIterator>
 void quicksort(RandomAccessIterator first, RandomAccessIterator last)
{
  quicksort(first, last, std::less<typename std::iterator_traits<RandomAccessIterator>::value_type>());
}#include <iterator>
#include <algorithm> // for std::partition
#include <functional> // for std::less
 
template<typename RandomAccessIterator,
         typename Order>
 void quicksort(RandomAccessIterator first, RandomAccessIterator last, Order order)
{
  if (last - first > 1)
  {
    RandomAccessIterator split = std::partition(first+1, last, std::bind2nd(order, *first));
    std::iter_swap(first, split-1);
    quicksort(first, split-1, order);
    quicksort(split, last, order);
  }
}
 
template<typename RandomAccessIterator>
 void quicksort(RandomAccessIterator first, RandomAccessIterator last)
{
  quicksort(first, last, std::less<typename std::iterator_traits<RandomAccessIterator>::value_type>());
}"
"#include <algorithm>
#include <iostream>
#include <iterator>
 
template <typename RandomAccessIterator, typename Predicate>
void insertion_sort(RandomAccessIterator begin, RandomAccessIterator end,
                    Predicate p) {
  for (auto i = begin; i != end; ++i) {
    std::rotate(std::upper_bound(begin, i, *i, p), i, i + 1);
  }
}
 
template <typename RandomAccessIterator>
void insertion_sort(RandomAccessIterator begin, RandomAccessIterator end) {
  insertion_sort(
      begin, end,
      std::less<
          typename std::iterator_traits<RandomAccessIterator>::value_type>());
}
 
int main() {
  int a[] = { 100, 2, 56, 200, -52, 3, 99, 33, 177, -199 };
  insertion_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
}"
"#include <iterator>
#include <algorithm> // for std::inplace_merge
#include <functional> // for std::less
 
template<typename RandomAccessIterator, typename Order>
 void mergesort(RandomAccessIterator first, RandomAccessIterator last, Order order)
{
  if (last - first > 1)
  {
    RandomAccessIterator middle = first + (last - first) / 2;
    mergesort(first, middle, order);
    mergesort(middle, last, order);
    std::inplace_merge(first, middle, last, order);
  }
}
 
template<typename RandomAccessIterator>
 void mergesort(RandomAccessIterator first, RandomAccessIterator last)
{
  mergesort(first, last, std::less<typename std::iterator_traits<RandomAccessIterator>::value_type>());
}"
" 
#include <time.h>
#include <iostream>
#include <vector>
 
using namespace std;
 
class cSort
{
public:
    void doIt( vector<unsigned> s )
    {
	sq = s; display(); c_sort();
	cout << strv << wr << endl; display(); 
    }
private:
    void display()
    {
	copy( sq.begin(), sq.end(), ostream_iterator<unsigned>( std::cout, strv ) );
	cout << endl;
    }
    void c_sort()
    {
	wr = 0;
	unsigned it, p, vlen = static_cast<unsigned>( sq.size() ); 
	for( unsigned c = 0; c < vlen - 1; c++ )
	{
	    it = sq[c];
	    p = c;
	    for( unsigned d = c + 1; d < vlen; d++ )
		if( sq[d] < it ) p++;
 
	    if( c == p ) continue;
 
	    doSwap( p, it );
 
	    while( c != p )
	    {
		p = c;
		for( unsigned e = c + 1; e < vlen; e++ )
		    if( sq[e] < it ) p++;
 
		doSwap( p, it );
	    }
	}
    }
    void doSwap( unsigned& p, unsigned& it )
    {
	while( sq[p] == it ) p++;
	swap( it, sq[p] );
	wr++;
    }
    vector<unsigned> sq;
    unsigned wr;
};
 
int main(int argc, char ** argv)
{
    srand( static_cast<unsigned>( time( NULL ) ) );
    vector<unsigned> s;
    for( int x = 0; x < 20; x++ )
	s.push_back( rand() % 100 + 21 );
 
    cSort c; c.doIt( s );
    return 0;
}
 "
"#include <algorithm>
#include <iterator>
#include <iostream>
 
template<typename RandomAccessIterator>
void gnome_sort(RandomAccessIterator begin, RandomAccessIterator end) {
  auto i = begin + 1;
  auto j = begin + 2;
 
  while (i < end) {
    if (!(*i < *(i - 1))) {
      i = j;
      ++j;
    } else {
      std::iter_swap(i - 1, i);
      --i;
      if (i == begin) {
        i = j;
        ++j;
      }
    }
  }
}
 
int main() {
  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};
  gnome_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
}"
"#include <algorithm>
#include <iterator>
#include <iostream>
 
template<typename RandomAccessIterator>
void heap_sort(RandomAccessIterator begin, RandomAccessIterator end) {
  std::make_heap(begin, end);
  std::sort_heap(begin, end);
}
 
int main() {
  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};
  heap_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
} 
#include <iostream>
#include <vector>
 
using namespace std;
 
void shift_down(vector<int>& heap,int i, int max) {
    int i_big, c1, c2;
    while(i < max) {
        i_big = i;
        c1 = (2*i) + 1;
        c2 = c1 + 1;
        if( c1<max && heap[c1]>heap[i_big] )
            i_big = c1;
        if( c2<max && heap[c2]>heap[i_big] )
            i_big = c2;
        if(i_big == i) return;
        swap(heap[i],heap[i_big]);
        i = i_big;
    }
}
 
void to_heap(vector<int>& arr) {
    int i = (arr.size()/2) - 1;
    while(i >= 0) {
        shift_down(arr, i, arr.size());
        --i;
    }
}
 
void heap_sort(vector<int>& arr) {
    to_heap(arr);
    int end = arr.size() - 1;
    while (end > 0) {
        swap(arr[0], arr[end]);
        shift_down(arr, 0, end);
        --end;
    }
}
 
int main() {
    vector<int> data = {
        12, 11, 15, 10, 9, 1, 2,
        3, 13, 14, 4, 5, 6, 7, 8
    };
    heap_sort(data);
    for(int i : data) cout << i << strv;
}"
"template<class ForwardIterator>
void combsort ( ForwardIterator first, ForwardIterator last )
{
    static const double shrink_factor = 1.247330950103979;
    typedef typename std::iterator_traits<ForwardIterator>::difference_type difference_type;
    difference_type gap = std::distance(first, last);
    bool swaps = true;
 
    while ( (gap > 1) || (swaps == true) ){
        if (gap > 1)
            gap = static_cast<difference_type>(gap/shrink_factor);
 
        swaps = false;
        ForwardIterator itLeft(first);
        ForwardIterator itRight(first); std::advance(itRight, gap);
 
        for ( ; itRight!=last; ++itLeft, ++itRight ){
            if ( (*itRight) < (*itLeft) ){
                std::iter_swap(itLeft, itRight);
                swaps = true;
            }
        }
    }
}"
" 
#include <iostream>
#include <time.h>
 
//------------------------------------------------------------------------------
using namespace std;
 
//------------------------------------------------------------------------------
const int MAX = 30;
 
//------------------------------------------------------------------------------
class cSort
{
public:
    void sort( int* arr, int len )
    {
	int mi, mx, z = 0; findMinMax( arr, len, mi, mx );
	int nlen = ( mx - mi ) + 1; int* temp = new int[nlen];
	memset( temp, 0, nlen * sizeof( int ) );
 
	for( int i = 0; i < len; i++ ) temp[arr[i] - mi]++;
 
	for( int i = mi; i <= mx; i++ )
	{
	    while( temp[i - mi] )
	    {
		arr[z++] = i;
		temp[i - mi]--;
	    }
	}
 
	delete [] temp;
    }
 
private:
    void findMinMax( int* arr, int len, int& mi, int& mx )
    {
	mi = INT_MAX; mx = 0;
	for( int i = 0; i < len; i++ )
	{
	    if( arr[i] > mx ) mx = arr[i];
	    if( arr[i] < mi ) mi = arr[i];
	}
    }
};
//------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( time( NULL ) ); int arr[MAX];
    for( int i = 0; i < MAX; i++ )
	arr[i] = rand() % 140 - rand() % 40 + 1;
 
    for( int i = 0; i < MAX; i++ )
	cout << arr[i] << strv;
    cout << endl << endl;
 
    cSort s; s.sort( arr, MAX );
 
    for( int i = 0; i < MAX; i++ )
	cout << arr[i] << strv;
    cout << endl << endl;
 
    return system( strv );
}
//------------------------------------------------------------------------------
 #include <algorithm>
#include <iterator>
#include <iostream>
#include <vector>
 
template<typename ForwardIterator> void counting_sort(ForwardIterator begin,
                                                      ForwardIterator end) {
  auto min_max = std::minmax_element(begin, end);
  if (min_max.first == min_max.second) {  

    return;
  }
  auto min = *min_max.first;
  auto max = *min_max.second;
  std::vector<unsigned> count((max - min) + 1, 0u);
  for (auto i = begin; i != end; ++i) {
    ++count[*i - min];
  }
  for (auto i = min; i <= max; ++i) {
    for (auto j = 0; j < count[i - min]; ++j) {
      *begin++ = i;
    }
  }
}
 
int main() {
  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};
  counting_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
}"
" 
#include <iostream>
#include <windows.h>
 
const int EL_COUNT = 77, LLEN = 11;
 
class cocktailSort
{
public:
    void sort( int* arr, int len )
    {
	bool notSorted = true;
	while( notSorted )
	{
	    notSorted = false;
	    for( int a = 0; a < len - 1; a++ )
	    {
		if( arr[a] > arr[a + 1] )
		{
		    sSwap( arr[a], arr[a + 1] );
		    notSorted = true;
		}
	    }
 
	    if( !notSorted ) break;
	    notSorted = false;
 
	    for( int a = len - 1; a > 0; a-- )
	    {
		if( arr[a - 1] > arr[a] )
		{
		    sSwap( arr[a], arr[a - 1] );
		    notSorted = true;
		}
	    }
	}
    }
 
private:
    void sSwap( int& a, int& b )
    {
	int t = a;
   	a = b; b = t;
    }
};
 
int main( int argc, char* argv[] )
{
    srand( GetTickCount() );
    cocktailSort cs;
    int arr[EL_COUNT];
 
    for( int x = 0; x < EL_COUNT; x++ )
        arr[x] = rand() % EL_COUNT + 1;
 
    std::cout << strv << std::endl << strv << std::endl;
    for( int x = 0; x < EL_COUNT; x += LLEN )
    {
	for( int s = x; s < x + LLEN; s++ )
	    std::cout << arr[s] << strv;
 
	std::cout << std::endl;
    }
 
    //DWORD now = GetTickCount(); 
    cs.sort( arr, EL_COUNT );
    //now = GetTickCount() - now;
 
    std::cout << std::endl << std::endl << strv << std::endl << strv << std::endl;
    for( int x = 0; x < EL_COUNT; x += LLEN )
    {
	for( int s = x; s < x + LLEN; s++ )
	    std::cout << arr[s] << strv;
 
	std::cout << std::endl;
    }
 
    std::cout << std::endl << std::endl << std::endl << std::endl;
    //std::cout << now << std::endl << std::endl; 
    return 0;
}
 #include <algorithm>
#include <iostream>
#include <iterator>
 
template <typename RandomAccessIterator>
void cocktail_sort(RandomAccessIterator begin, RandomAccessIterator end) {
  bool swapped = true;
  while (begin != end-- && swapped) {
    swapped = false;
    for (auto i = begin; i != end; ++i) {
      if (*(i + 1) < *i) {
        std::iter_swap(i, i + 1);
        swapped = true;
      }
    }
    if (!swapped) {
      break;
    }
    swapped = false;
    for (auto i = end - 1; i != begin; --i) {
      if (*i < *(i - 1)) {
        std::iter_swap(i, i - 1);
        swapped = true;
      }
    }
    ++begin;
  }
}
 
int main() {
  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};
  cocktail_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
}"
"#include <algorithm>
#include <iostream>
#include <iterator>
 
template <typename RandomAccessIterator>
void bubble_sort(RandomAccessIterator begin, RandomAccessIterator end) {
  bool swapped = true;
  while (begin != end-- && swapped) {
    swapped = false;
    for (auto i = begin; i != end; ++i) {
      if (*(i + 1) < *i) {
        std::iter_swap(i, i + 1);
        swapped = true;
      }
    }
  }
}
 
int main() {
  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};
  bubble_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
}"
"#include <algorithm>
#include <iostream>
#include <iterator>
#include <random>
 
template <typename RandomAccessIterator, typename Predicate>
void bogo_sort(RandomAccessIterator begin, RandomAccessIterator end,
               Predicate p) {
  std::random_device rd;
  std::mt19937 generator(rd());
  while (!std::is_sorted(begin, end, p)) {
    std::shuffle(begin, end, generator);
  }
}
 
template <typename RandomAccessIterator>
void bogo_sort(RandomAccessIterator begin, RandomAccessIterator end) {
  bogo_sort(
      begin, end,
      std::less<
          typename std::iterator_traits<RandomAccessIterator>::value_type>());
}
 
int main() {
  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};
  bogo_sort(std::begin(a), std::end(a));
  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, strv));
  std::cout << """";
}"
"#include <algorithm>
#include <string>
#include <cctype>
 


struct icompare_char {
  bool operator()(char c1, char c2) {
    return std::toupper(c1) < std::toupper(c2);
  }
};
 


struct compare {
  bool operator()(std::string const& s1, std::string const& s2) {
    if (s1.length() > s2.length())
      return true;
    if (s1.length() < s2.length())
      return false;
    return std::lexicographical_compare(s1.begin(), s1.end(),
                                        s2.begin(), s2.end(),
                                        icompare_char());
  }
};
 
int main() {
  std::string strings[8] = {strv, strv, strv, strv, strv, strv, strv, strv};
  std::sort(strings, strings+8, compare());
  return 0;
}"
"//this algorithm only works with positive, whole numbers.
//O(2n) time complexity where n is the summation of the whole list to be sorted. 
//O(3n) space complexity.
 
#include <iostream>
#include <vector>
 
using std::cout;
using std::vector;
 
void distribute(int dist, vector<int> &List) {
	//*beads* go down into different buckets using gravity (addition).
    if (dist > List.size() )
        List.resize(dist); //resize if too big for current vector
 
    for (int i=0; i < dist; i++)
        List[i]++;
}
 
vector<int> beadSort(int *myints, int n) {
    vector<int> list, list2, fifth (myints, myints + n);
 
    cout << strv;
    for (int i=0; i < fifth.size(); i++)
        distribute (fifth[i], list);
    cout << '';
 
    cout << ""Beads on their sides: "";
    for (int i=0; i < list.size(); i++)
        cout << strv << list[i];
    cout << '';
 
    //second part
 
    cout << strv;
    for (int i=0; i < list.size(); i++)
        distribute (list[i], list2);
    cout << '';
 
    return list2;
}
 
int main() {
    int myints[] = {734,3,1,24,324,324,32,432,42,3,4,1,1};
	vector<int> sorted = beadSort(myints, sizeof(myints)/sizeof(int));
	cout << strv;
	for(unsigned int i=0; i<sorted.size(); i++)
		cout << sorted[i] << ' ';
}"
"#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
 
template <typename ValueIterator, typename IndicesIterator>
void sortDisjoint(ValueIterator valsBegin, IndicesIterator indicesBegin,
		  IndicesIterator indicesEnd) {
    std::vector<int> temp;
 
    for (IndicesIterator i = indicesBegin; i != indicesEnd; ++i)
        temp.push_back(valsBegin[*i]); 

 
    std::sort(indicesBegin, indicesEnd); 

    std::sort(temp.begin(), temp.end()); 

 
    std::vector<int>::const_iterator j = temp.begin();
    for (IndicesIterator i = indicesBegin; i != indicesEnd; ++i, ++j)
        valsBegin[*i] = *j; 

}
 
 
int main()
{
    int values[] = { 7, 6, 5, 4, 3, 2, 1, 0 };
    int indices[] = { 6, 1, 7 };
 
    sortDisjoint(values, indices, indices+3);
 
    std::copy(values, values + 8, std::ostream_iterator<int>(std::cout, strv));
    std::cout << """";
 
    return 0;
}#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
 
template <typename ValueIterator, typename IndicesIterator>
struct DisjointSubsetIterator :
  public std::iterator<std::random_access_iterator_tag,
		       typename std::iterator_traits<ValueIterator>::value_type> {
  typedef typename std::iterator_traits<ValueIterator>::value_type V;
  ValueIterator valsBegin;
  IndicesIterator i;
  DisjointSubsetIterator() { }
  DisjointSubsetIterator(const ValueIterator &_v, IndicesIterator _i) :
    valsBegin(_v), i(_i) { }
  DisjointSubsetIterator& operator++() { ++i; return *this; }
  DisjointSubsetIterator operator++(int) {
    DisjointSubsetIterator tmp = *this; ++(*this); return tmp; }
  bool operator==(const DisjointSubsetIterator& y) { return i == y.i; }
  bool operator!=(const DisjointSubsetIterator& y) { return i != y.i; }
  V &operator*() { return valsBegin[*i]; }
  DisjointSubsetIterator& operator--() { --i; return *this; }
  DisjointSubsetIterator operator--(int) {
    DisjointSubsetIterator tmp = *this; --(*this); return tmp; }
  DisjointSubsetIterator& operator+=(int n) { i += n; return *this; }
  DisjointSubsetIterator& operator-=(int n) { i -= n; return *this; }
  DisjointSubsetIterator operator+(int n) {
    DisjointSubsetIterator tmp = *this; return tmp += n; }
  DisjointSubsetIterator operator-(int n) {
    DisjointSubsetIterator tmp = *this; return tmp -= n; }
  int operator-(const DisjointSubsetIterator &y) { return i - y.i; }
  V &operator[](int n) { return *(*this + n); }
  bool operator<(const DisjointSubsetIterator &y) { return i < y.i; }
  bool operator>(const DisjointSubsetIterator &y) { return i > y.i; }
  bool operator<=(const DisjointSubsetIterator &y) { return i <= y.i; }
  bool operator>=(const DisjointSubsetIterator &y) { return i >= y.i; }
};
template <typename ValueIterator, typename IndicesIterator>
DisjointSubsetIterator<ValueIterator, IndicesIterator>
operator+(int n, const DisjointSubsetIterator<ValueIterator, IndicesIterator> &i) {
  return i + n; }
 
template <typename ValueIterator, typename IndicesIterator>
void sortDisjoint(ValueIterator valsBegin, IndicesIterator indicesBegin,
		  IndicesIterator indicesEnd) {
  std::sort(DisjointSubsetIterator<ValueIterator, IndicesIterator>(valsBegin, indicesBegin),
            DisjointSubsetIterator<ValueIterator, IndicesIterator>(valsBegin, indicesEnd));
}
 
 
int main()
{
    int values[] = { 7, 6, 5, 4, 3, 2, 1, 0 };
    int indices[] = { 6, 1, 7 };
 
    sortDisjoint(values, indices, indices+3);
 
    std::copy(values, values + 8, std::ostream_iterator<int>(std::cout, strv));
    std::cout << """";
 
    return 0;
}"
"#include <algorithm>
 
int main()
{
    int nums[] = {2,4,3,1,2};
    std::sort(nums, nums+sizeof(nums)/sizeof(int));
    return 0;
}#include <algorithm>
#include <vector>
 
int main()
{
    std::vector<int> nums;
    nums.push_back(2);
    nums.push_back(4);
    nums.push_back(3);
    nums.push_back(1);
    nums.push_back(2);
    std::sort(nums.begin(), nums.end());
    return 0;
}#include <list>
 
int main()
{
    std::list<int> nums;
    nums.push_back(2);
    nums.push_back(4);
    nums.push_back(3);
    nums.push_back(1);
    nums.push_back(2);
    nums.sort();
    return 0;
}"
"#include <algorithm>
#include <iostream>
#include <string>
 
struct entry {
  std::string name;
  std::string value;
};
 
int main() {
  entry array[] = { { strv, strv }, { strv, strv },
                    { strv, strv }, { strv, strv } };
 
  std::cout << ""Before sorting:"";
  for (const auto &e : array) {
    std::cout << strv << e.name << strv << e.value << ""}"";
  }
 
  std::sort(std::begin(array), std::end(array), 
            [](const entry & a, const entry & b) {
    return a.name < b.name;
  });
 
  std::cout << ""After sorting:"";
  for (const auto &e : array) {
    std::cout << strv << e.name << strv << e.value << ""}"";
  }
}"
"#include <string>
#include <vector>
#include <algorithm>
#include <boost/tokenizer.hpp>
#include <iostream>
 
std::vector<std::string> splitOnChar ( std::string & s , const char c ) {
   typedef boost::tokenizer<boost::char_separator<char>> tokenizer ;
   std::vector<std::string> parts ;
   boost::char_separator<char> sep( &c ) ;
   tokenizer tokens( s , sep ) ;
   for ( auto it = tokens.begin( ) ; it != tokens.end( ) ; it++ ) 
      parts.push_back( *it ) ;
   return parts ;
}
 
bool myCompare ( const std::string & s1 , const std::string & s2 ) {
   std::string firstcopy( s1 ) ;
   std::string secondcopy ( s2 ) ;
   std::vector<std::string> firstparts( splitOnChar ( firstcopy, '.' ) ) ;
   std::vector<std::string> secondparts( splitOnChar ( secondcopy, '.' ) ) ;
   std::vector<int> numbers1( firstparts.size( ) ) ;
   std::vector<int> numbers2( secondparts.size( ) ) ;
   std::transform( firstparts.begin( ) , firstparts.end( ) , numbers1.begin( ) ,
	 []( std::string st ) { return std::stoi( st , nullptr ) ; } ) ;
   std::transform( secondparts.begin( ) , secondparts.end( ) , numbers2.begin( ) ,
	 []( std::string st ) { return std::stoi( st , nullptr ) ; } ) ;
   auto it1 = numbers1.begin( ) ;
   auto it2 = numbers2.begin( ) ;
   while ( *it1 == *it2 ) {
      it1++ ;
      it2++ ;
   }
   if ( it1 == numbers1.end( )  || it2 == numbers2.end( )  )
      return std::lexicographical_compare( s1.begin( ) , s1.end( ) , s2.begin( ) , s2.end( ) ) ;
   return *it1 < *it2 ;
}
 
int main( ) {
   std::vector<std::string> arrayOID { strv ,
      strv ,
      strv ,
      strv ,
      strv ,
      strv } ;
   std::sort( arrayOID.begin( ) , arrayOID.end( ) , myCompare ) ;
   for ( std::string s : arrayOID ) 
      std::cout << s << '' ;
   return 0 ;
}"
" 
#include <vector>
#include <sstream>
#include <iostream>
#include <iterator>
#include <cstdlib>
#include <string>
#include <bitset>
 
using namespace std;
typedef bitset<4> hood_t;
 
struct node
{
	int val;
	hood_t neighbors;
};
 
class nSolver
{
public:
 
	void solve(vector<string>& puzz, int max_wid)
	{
		if (puzz.size() < 1) return;
		wid = max_wid; 
		hei = static_cast<int>(puzz.size()) / wid;
		max = wid * hei;
		int len = max, c = 0;
		arr = vector<node>(len, node({ 0, 0 }));
		weHave = vector<bool>(len + 1, false);
 
		for (const auto& s : puzz)
		{
			if (s == strv) { max--; arr[c++].val = -1; continue; }
			arr[c].val = atoi(s.c_str());
			if (arr[c].val > 0) weHave[arr[c].val] = true;
			c++;
		}
 
		solveIt(); c = 0;
		for (auto&& s : puzz)
		{
			if (s == strv)
				s = std::to_string(arr[c].val);
			c++;
		}
	}
 
private:
	bool search(int x, int y, int w, int dr)
	{
		if ((w > max && dr > 0) || (w < 1 && dr < 0) || (w == max && weHave[w])) return true;
 
		node& n = arr[x + y * wid];
		n.neighbors = getNeighbors(x, y);
		if (weHave[w])
		{
			for (int d = 0; d < 4; d++)
			{
				if (n.neighbors[d])
				{
					int a = x + dx[d], b = y + dy[d];
					if (arr[a + b * wid].val == w)
						if (search(a, b, w + dr, dr)) 
							return true;
				}
			}
			return false;
		}
 
		for (int d = 0; d < 4; d++)
		{
			if (n.neighbors[d])
			{
				int a = x + dx[d], b = y + dy[d];
				if (arr[a + b * wid].val == 0)
				{
					arr[a + b * wid].val = w;
					if (search(a, b, w + dr, dr)) 
						return true;
					arr[a + b * wid].val = 0;
				}
			}
		}
		return false;
	}
 
	hood_t getNeighbors(int x, int y)
	{
		hood_t retval;
		for (int xx = 0; xx < 4; xx++)
		{
			int a = x + dx[xx], b = y + dy[xx];
			if (a < 0 || b < 0 || a >= wid || b >= hei) 
				continue;
			if (arr[a + b * wid].val > -1)
				retval.set(xx);
		}
		return retval;
	}
 
	void solveIt()
	{
		int x, y, z; findStart(x, y, z);
		if (z == 99999) { cout << ""Can't find start point!""; return; }
		search(x, y, z + 1, 1);
		if (z > 1) search(x, y, z - 1, -1);
	}
 
	void findStart(int& x, int& y, int& z)
	{
		z = 99999;
		for (int b = 0; b < hei; b++)
		for (int a = 0; a < wid; a++)
		if (arr[a + wid * b].val > 0 && arr[a + wid * b].val < z)
		{
			x = a; y = b;
			z = arr[a + wid * b].val;
		}
 
	}
 
	vector<int> dx = vector<int>({ -1, 1, 0, 0 });
	vector<int> dy = vector<int>({ 0, 0, -1, 1 });
	int wid, hei, max;
	vector<node> arr;
	vector<bool> weHave;
};
 
//------------------------------------------------------------------------------
int main(int argc, char* argv[])
{
	int wid; string p;
	//p = strv; wid = 9;
	//p = strv; wid = 9;
	p = strv; wid = 9;
 
	istringstream iss(p); vector<string> puzz;
	copy(istream_iterator<string>(iss), istream_iterator<string>(), back_inserter<vector<string> >(puzz));
	nSolver s; s.solve(puzz, wid);
 
	int c = 0;
	for (const auto& s : puzz)
	{
		if (s != strv && s != strv)
		{
			if (atoi(s.c_str()) < 10) cout << strv;
			cout << s << strv;
		}
		else cout << strv;
		if (++c >= wid) { cout << endl; c = 0; }
	}
	cout << endl << endl;
	return system(strv);
}
 "
" 
#include <vector>
#include <sstream>
#include <iostream>
#include <iterator>
#include <stdlib.h>
#include <string.h>
 
using namespace std;
 
struct node
{
    int val;
    unsigned char neighbors;
};
 
class nSolver
{
public:
    nSolver()
    {
	dx[0] = -2; dy[0] = -2; dx[1] = -2; dy[1] =  2;
	dx[2] =  2; dy[2] = -2; dx[3] =  2; dy[3] =  2;
	dx[4] = -3; dy[4] =  0; dx[5] =  3; dy[5] =  0; 
	dx[6] =  0; dy[6] = -3; dx[7] =  0; dy[7] =  3;
    }
 
    void solve( vector<string>& puzz, int max_wid )
    {
	if( puzz.size() < 1 ) return;
	wid = max_wid; hei = static_cast<int>( puzz.size() ) / wid;
	int len = wid * hei, c = 0; max = len;
	arr = new node[len]; memset( arr, 0, len * sizeof( node ) );
 
	for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
	{
	    if( ( *i ) == strv ) { max--; arr[c++].val = -1; continue; }
	    arr[c].val = atoi( ( *i ).c_str() );
	    c++;
	}
 
	solveIt(); c = 0;
	for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
	{
	    if( ( *i ) == strv )
	    {
		ostringstream o; o << arr[c].val;
		( *i ) = o.str();
	    }
	    c++;
	}
	delete [] arr;
    }
 
private:
    bool search( int x, int y, int w )
    {
	if( w > max ) return true;
 
	node* n = &arr[x + y * wid];
	n->neighbors = getNeighbors( x, y );
 
	for( int d = 0; d < 8; d++ )
	{
	    if( n->neighbors & ( 1 << d ) )
	    {
		int a = x + dx[d], b = y + dy[d];
		if( arr[a + b * wid].val == 0 )
		{
		    arr[a + b * wid].val = w;
		    if( search( a, b, w + 1 ) ) return true;
		    arr[a + b * wid].val = 0;
		}
	    }
	}
	return false;
    }
 
    unsigned char getNeighbors( int x, int y )
    {
	unsigned char c = 0; int a, b;
	for( int xx = 0; xx < 8; xx++ )
	{
	    a = x + dx[xx], b = y + dy[xx];
	    if( a < 0 || b < 0 || a >= wid || b >= hei ) continue;
	    if( arr[a + b * wid].val > -1 ) c |= ( 1 << xx );
	}
	return c;
    }
 
    void solveIt()
    {
	int x, y, z; findStart( x, y, z );
	if( z == 99999 ) { cout << ""Can't find start point!""; return; }
	search( x, y, z + 1 );
    }
 
    void findStart( int& x, int& y, int& z )
    {
	for( int b = 0; b < hei; b++ )
	    for( int a = 0; a < wid; a++ )
		if( arr[a + wid * b].val == 0 ) 
		{ 
		    x = a; y = b; z = 1;
		    arr[a + wid * b].val = z;
		    return;
		}
    }
 
    int wid, hei, max, dx[8], dy[8];
    node* arr;
};
 
int main( int argc, char* argv[] )
{
    int wid; string p;
    p = strv; wid = 7;
    istringstream iss( p ); vector<string> puzz;
    copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( puzz ) );
    nSolver s; s.solve( puzz, wid );
    int c = 0;
    for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
    {
	if( ( *i ) != strv && ( *i ) != strv )
	{
	    if( atoi( ( *i ).c_str() ) < 10 ) cout << strv;
	    cout << ( *i ) << strv;
	}
	else cout << strv;
	if( ++c >= wid ) { cout << endl; c = 0; }
    }
    cout << endl << endl;
    return system( strv );
}
 "
" 
#include <vector>
#include <sstream>
#include <iostream>
#include <iterator>
#include <stdlib.h>
#include <string.h>
 
using namespace std;
 
struct node
{
    int val;
    unsigned char neighbors;
};
 
class nSolver
{
public:
    nSolver()
    {
	dx[0] = -1; dy[0] = -2; dx[1] = -1; dy[1] =  2;
	dx[2] =  1; dy[2] = -2; dx[3] =  1; dy[3] =  2;
	dx[4] = -2; dy[4] = -1; dx[5] = -2; dy[5] =  1; 
	dx[6] =  2; dy[6] = -1; dx[7] =  2; dy[7] =  1;
    }
 
    void solve( vector<string>& puzz, int max_wid )
    {
	if( puzz.size() < 1 ) return;
	wid = max_wid; hei = static_cast<int>( puzz.size() ) / wid;
	int len = wid * hei, c = 0; max = len;
	arr = new node[len]; memset( arr, 0, len * sizeof( node ) );
 
	for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
	{
	    if( ( *i ) == strv ) { max--; arr[c++].val = -1; continue; }
	    arr[c].val = atoi( ( *i ).c_str() );
	    c++;
	}
 
	solveIt(); c = 0;
	for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
	{
	    if( ( *i ) == strv )
	    {
		ostringstream o; o << arr[c].val;
		( *i ) = o.str();
	    }
	    c++;
	}
	delete [] arr;
    }
 
private:
    bool search( int x, int y, int w )
    {
	if( w > max ) return true;
 
	node* n = &arr[x + y * wid];
	n->neighbors = getNeighbors( x, y );
 
	for( int d = 0; d < 8; d++ )
	{
	    if( n->neighbors & ( 1 << d ) )
	    {
		int a = x + dx[d], b = y + dy[d];
		if( arr[a + b * wid].val == 0 )
		{
		    arr[a + b * wid].val = w;
		    if( search( a, b, w + 1 ) ) return true;
		    arr[a + b * wid].val = 0;
		}
	    }
	}
	return false;
    }
 
    unsigned char getNeighbors( int x, int y )
    {
	unsigned char c = 0; int a, b;
	for( int xx = 0; xx < 8; xx++ )
	{
	    a = x + dx[xx], b = y + dy[xx];
	    if( a < 0 || b < 0 || a >= wid || b >= hei ) continue;
	    if( arr[a + b * wid].val > -1 ) c |= ( 1 << xx );
	}
	return c;
    }
 
    void solveIt()
    {
	int x, y, z; findStart( x, y, z );
	if( z == 99999 ) { cout << ""Can't find start point!""; return; }
	search( x, y, z + 1 );
    }
 
    void findStart( int& x, int& y, int& z )
    {
	z = 99999;
	for( int b = 0; b < hei; b++ )
	    for( int a = 0; a < wid; a++ )
		if( arr[a + wid * b].val > 0 && arr[a + wid * b].val < z ) 
		{ 
		    x = a; y = b;
		    z = arr[a + wid * b].val;
		}
 
    }
 
    int wid, hei, max, dx[8], dy[8];
    node* arr;
};
 
int main( int argc, char* argv[] )
{
    int wid; string p;
    //p = strv; wid = 8;
    p = strv; wid = 13;
    istringstream iss( p ); vector<string> puzz;
    copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( puzz ) );
    nSolver s; s.solve( puzz, wid );
    int c = 0;
    for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
    {
	if( ( *i ) != strv && ( *i ) != strv )
	{
	    if( atoi( ( *i ).c_str() ) < 10 ) cout << strv;
	    cout << ( *i ) << strv;
        }
	else cout << strv;
	if( ++c >= wid ) { cout << endl; c = 0; }
    }
    cout << endl << endl;
    return system( strv );
}
 "
" 
#include <iostream>
#include <sstream>
#include <iterator>
#include <vector>
 
//------------------------------------------------------------------------------
using namespace std;
 
//------------------------------------------------------------------------------
struct node
{
    int val;
    unsigned char neighbors;
};
//------------------------------------------------------------------------------
class hSolver
{
public:
    hSolver()
    {
	dx[0] = -1; dx[1] = 0; dx[2] = 1; dx[3] = -1; dx[4] = 1; dx[5] = -1; dx[6] = 0; dx[7] = 1;
	dy[0] = -1; dy[1] = -1; dy[2] = -1; dy[3] = 0; dy[4] = 0; dy[5] = 1; dy[6] = 1; dy[7] = 1;
    }
 
    void solve( vector<string>& puzz, int max_wid )
    {
	if( puzz.size() < 1 ) return;
	wid = max_wid; hei = static_cast<int>( puzz.size() ) / wid;
	int len = wid * hei, c = 0; max = 0;
	arr = new node[len]; memset( arr, 0, len * sizeof( node ) );
	weHave = new bool[len + 1]; memset( weHave, 0, len + 1 );
 
	for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
	{
	    if( ( *i ) == strv ) {    arr[c++].val = -1; continue; }
	    arr[c].val = atoi( ( *i ).c_str() );
	    if( arr[c].val > 0 ) weHave[arr[c].val] = true;
	    if( max < arr[c].val ) max = arr[c].val;
	    c++;
	}
 
	solveIt(); c = 0;
	for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
	{
	    if( ( *i ) == strv )
	    {
		ostringstream o; o << arr[c].val;
		( *i ) = o.str();
	    }
	    c++;
	}
	delete [] arr;
	delete [] weHave;
    }
 
private:
    bool search( int x, int y, int w )
    {
	if( w == max ) return true;
 
	node* n = &arr[x + y * wid];
	n->neighbors = getNeighbors( x, y );
	if( weHave[w] )
	{
	    for( int d = 0; d < 8; d++ )
	    {
		if( n->neighbors & ( 1 << d ) )
		{
		    int a = x + dx[d], b = y + dy[d];
		    if( arr[a + b * wid].val == w )
		    if( search( a, b, w + 1 ) ) return true;
		}
	    }
	    return false;
	}
 
	for( int d = 0; d < 8; d++ )
	{
	    if( n->neighbors & ( 1 << d ) )
	    {
		int a = x + dx[d], b = y + dy[d];
		if( arr[a + b * wid].val == 0 )
		{
		    arr[a + b * wid].val = w;
		    if( search( a, b, w + 1 ) ) return true;
		    arr[a + b * wid].val = 0;
		}
	    }
	}
	return false;
    }
 
    unsigned char getNeighbors( int x, int y )
    {
	unsigned char c = 0; int m = -1, a, b;
	for( int yy = -1; yy < 2; yy++ )
	    for( int xx = -1; xx < 2; xx++ )
	    {
		if( !yy && !xx ) continue;
		m++; a = x + xx, b = y + yy;
		if( a < 0 || b < 0 || a >= wid || b >= hei ) continue;
		if( arr[a + b * wid].val > -1 ) c |= ( 1 << m );
	    }
	return c;
    }
 
    void solveIt()
    {
	int x, y; findStart( x, y );
	if( x < 0 ) { cout << ""Can't find start point!""; return; }
	search( x, y, 2 );
    }
 
    void findStart( int& x, int& y )
    {
	for( int b = 0; b < hei; b++ )
	    for( int a = 0; a < wid; a++ )
		if( arr[a + wid * b].val == 1 ) { x = a; y = b; return; }
	x = y = -1;
    }
 
    int wid, hei, max, dx[8], dy[8];
    node* arr;
    bool* weHave;
};
//------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    int wid;
    string p = strv; wid = 8;
    //string p = strv; wid = 9;
    //string p = strv; wid = 9;
 
    istringstream iss( p ); vector<string> puzz;
    copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( puzz ) );
    hSolver s; s.solve( puzz, wid );
 
    int c = 0;
    for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )
    {
	if( ( *i ) != strv && ( *i ) != strv )
	{
	    if( atoi( ( *i ).c_str() ) < 10 ) cout << strv;
	    cout << ( *i ) << strv;
	}
	else cout << strv;
	if( ++c >= wid ) { cout << endl; c = 0; }
    }
    cout << endl << endl;
    return system( strv );
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <regex>
#include <tuple>
#include <set>
#include <array>
using namespace std;
 
class Board
{
public:
  vector<vector<char>> sData, dData;
  int px, py;
 
  Board(string b)
  {
    regex pattern(""([^n]+)n?"");
    sregex_iterator end, iter(b.begin(), b.end(), pattern);
 
    int w = 0;
    vector<string> data;
    for(; iter != end; ++iter){
      data.push_back((*iter)[1]);
      w = max(w, (*iter)[1].length());
    }
 
    for(int v = 0; v < data.size(); ++v){
      vector<char> sTemp, dTemp;
      for(int u = 0; u < w; ++u){
        if(u > data[v].size()){
          sTemp.push_back(' ');
          dTemp.push_back(' ');
        }else{
          char s = ' ', d = ' ', c = data[v][u];
 
          if(c == '#')
            s = '#';
          else if(c == '.' || c == '*' || c == '+')
            s = '.';
 
          if(c == '@' || c == '+'){
            d = '@';
            px = u;
            py = v;
          }else if(c == '$' || c == '*')
            d = '*';
 
          sTemp.push_back(s);
          dTemp.push_back(d);
        }
      }
 
      sData.push_back(sTemp);
      dData.push_back(dTemp);
    }
  }
 
  bool move(int x, int y, int dx, int dy, vector<vector<char>> &data)
  {
    if(sData[y+dy][x+dx] == '#' || data[y+dy][x+dx] != ' ') 
      return false;
 
    data[y][x] = ' ';
    data[y+dy][x+dx] = '@';
 
    return true;
  }
 
  bool push(int x, int y, int dx, int dy, vector<vector<char>> &data)
  {
    if(sData[y+2*dy][x+2*dx] == '#' || data[y+2*dy][x+2*dx] != ' ')
      return false;
 
    data[y][x] = ' ';
    data[y+dy][x+dx] = '@';
    data[y+2*dy][x+2*dx] = '*';
 
    return true;
  }
 
  bool isSolved(const vector<vector<char>> &data)
  {
    for(int v = 0; v < data.size(); ++v)
      for(int u = 0; u < data[v].size(); ++u)
        if((sData[v][u] == '.') ^ (data[v][u] == '*'))
          return false;
    return true;
  }
 
  string solve()
  {
    set<vector<vector<char>>> visited;
    queue<tuple<vector<vector<char>>, string, int, int>> open;
 
    open.push(make_tuple(dData, strv, px, py));
    visited.insert(dData);
 
    array<tuple<int, int, char, char>, 4> dirs;
    dirs[0] = make_tuple(0, -1, 'u', 'U');
    dirs[1] = make_tuple(1, 0, 'r', 'R');
    dirs[2] = make_tuple(0, 1, 'd', 'D');
    dirs[3] = make_tuple(-1, 0, 'l', 'L');
 
    while(open.size() > 0){
      vector<vector<char>> temp, cur = get<0>(open.front());
      string cSol = get<1>(open.front());
      int x = get<2>(open.front());
      int y = get<3>(open.front());
      open.pop();
 
      for(int i = 0; i < 4; ++i){
        temp = cur;
        int dx = get<0>(dirs[i]);
        int dy = get<1>(dirs[i]);
 
        if(temp[y+dy][x+dx] == '*'){
          if(push(x, y, dx, dy, temp) && (visited.find(temp) == visited.end())){
            if(isSolved(temp))
              return cSol + get<3>(dirs[i]);
            open.push(make_tuple(temp, cSol + get<3>(dirs[i]), x+dx, y+dy));
            visited.insert(temp);
          }
        }else if(move(x, y, dx, dy, temp) && (visited.find(temp) == visited.end())){
          if(isSolved(temp))
            return cSol + get<2>(dirs[i]);
          open.push(make_tuple(temp, cSol + get<2>(dirs[i]), x+dx, y+dy));
          visited.insert(temp);
        }
      }
    }
 
    return strv;
  }
};
 
int main()
{
  string level =
    ""#######""
    ""#     #""
    ""#     #""
    ""#. #  #""
    ""#. $$ #""
    ""#.$$  #""
    ""#.#  @#""
    strv;
 
  Board b(level);
 
  cout << level << endl << endl << b.solve() << endl;
  return 0;
}#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <tuple>
#include <array>
#include <map>
#include <boost/algorithm/string.hpp>
#include <boost/unordered_set.hpp>
 
using namespace std;
 
typedef vector<char> TableRow;
typedef vector<TableRow> Table;
 
struct Board {
  Table sData, dData;
  int px, py;
 
  Board(string b) {
    vector<string> data;
    boost::split(data, b, boost::is_any_of(""""));
 
    size_t width = 0;
    for (auto &row: data)
      width = max(width, row.size());
 
    map<char,char> maps = {{' ',' '}, {'.','.'}, {'@',' '},
                           {'#','#'}, {'$',' '}},
                   mapd = {{' ',' '}, {'.',' '}, {'@','@'},
                           {'#',' '}, {'$','*'}};
 
    for (size_t r = 0; r < data.size(); r++) {
      TableRow sTemp, dTemp;
      for (size_t c = 0; c < width; c++) {
        char ch = c < data[r].size() ? data[r][c] : ' ';
        sTemp.push_back(maps[ch]);
        dTemp.push_back(mapd[ch]);
        if (ch == '@') {
          px = c;
          py = r;
        }
      }
      sData.push_back(sTemp);
      dData.push_back(dTemp);
    }
  }
 
  bool move(int x, int y, int dx, int dy, Table &data) {
    if (sData[y+dy][x+dx] == '#' || data[y+dy][x+dx] != ' ')
      return false;
 
    data[y][x] = ' ';
    data[y+dy][x+dx] = '@';
    return true;
  }
 
  bool push(int x, int y, int dx, int dy, Table &data) {
    if (sData[y+2*dy][x+2*dx] == '#' || data[y+2*dy][x+2*dx] != ' ')
      return false;
 
    data[y][x] = ' ';
    data[y+dy][x+dx] = '@';
    data[y+2*dy][x+2*dx] = '*';
    return true;
  }
 
  bool isSolved(const Table &data) {
    for (size_t r = 0; r < data.size(); r++)
      for (size_t c = 0; c < data[r].size(); c++)
        if ((sData[r][c] == '.') != (data[r][c] == '*'))
          return false;
    return true;
  }
 
  string solve() {
    boost::unordered_set<Table, boost::hash<Table>> visited;
    visited.insert(dData);
 
    queue<tuple<Table, string, int, int>> open;
    open.push(make_tuple(dData, strv, px, py));
 
    vector<tuple<int, int, char, char>> dirs = {
        make_tuple( 0, -1, 'u', 'U'),
        make_tuple( 1,  0, 'r', 'R'),
        make_tuple( 0,  1, 'd', 'D'),
        make_tuple(-1,  0, 'l', 'L')
    };
 
    while (open.size() > 0) {
      Table temp, cur = get<0>(open.front());
      string cSol = get<1>(open.front());
      int x = get<2>(open.front());
      int y = get<3>(open.front());
      open.pop();
 
      for (int i = 0; i < 4; ++i) {
        temp = cur;
        int dx = get<0>(dirs[i]);
        int dy = get<1>(dirs[i]);
 
        if (temp[y+dy][x+dx] == '*') {
          if (push(x, y, dx, dy, temp) &&
              visited.find(temp) == visited.end()) {
            if (isSolved(temp))
              return cSol + get<3>(dirs[i]);
            open.push(make_tuple(temp, cSol + get<3>(dirs[i]),
                                 x+dx, y+dy));
            visited.insert(temp);
          }
        } else if (move(x, y, dx, dy, temp) &&
                   visited.find(temp) == visited.end()) {
          if (isSolved(temp))
            return cSol + get<2>(dirs[i]);
          open.push(make_tuple(temp, cSol + get<2>(dirs[i]),
                               x+dx, y+dy));
          visited.insert(temp);
        }
      }
    }
 
    return strv;
  }
};
 
int main() {
  string level = ""#######""
                 ""#     #""
                 ""#     #""
                 ""#. #  #""
                 ""#. $$ #""
                 ""#.$$  #""
                 ""#.#  @#""
                 strv;
 
  cout << level << endl << endl;
  Board board(level);
  cout << board.solve() << endl;
  return 0;
}"
" 
#include <windows.h>
#include <ctime>
#include <iostream>
#include <string>
 
const int WID = 60, HEI = 30, MAX_LEN = 600;
enum DIR { NORTH, EAST, SOUTH, WEST };
 
class snake {
public:
    snake() {
        console = GetStdHandle( STD_OUTPUT_HANDLE ); SetConsoleTitle( strv ); 
        COORD coord = { WID + 1, HEI + 2 }; SetConsoleScreenBufferSize( console, coord );
        SMALL_RECT rc = { 0, 0, WID, HEI + 1 }; SetConsoleWindowInfo( console, TRUE, &rc );
        CONSOLE_CURSOR_INFO ci = { 1, false }; SetConsoleCursorInfo( console, &ci );
    }
    void play() {
        std::string a;
        while( 1 ) {
            createField(); alive = true;
            while( alive ) { drawField(); readKey(); moveSnake(); Sleep( 50 ); }
            COORD c = { 0, HEI + 1 }; SetConsoleCursorPosition( console, c );
            SetConsoleTextAttribute( console, 0x000b );
            std::cout << strv; std::cin >> a;
            if( a.at( 0 ) != 'Y' && a.at( 0 ) != 'y' ) return;
        }
    }
private:
    void createField() {
        COORD coord = { 0, 0 }; DWORD c;
        FillConsoleOutputCharacter( console, ' ', ( HEI + 2 ) * 80, coord, &c );
        FillConsoleOutputAttribute( console, 0x0000, ( HEI + 2 ) * 80, coord, &c );
        SetConsoleCursorPosition( console, coord );
        int x = 0, y = 1; for( ; x < WID * HEI; x++ ) brd[x] = 0;
        for( x = 0; x < WID; x++ ) {
            brd[x] = brd[x + WID * ( HEI - 1 )] = '+';
        }
        for( ; y < HEI; y++ ) {
            brd[0 + WID * y] = brd[WID - 1 + WID * y] = '+';
        }
        do {
            x = rand() % WID; y = rand() % ( HEI >> 1 ) + ( HEI >> 1 );
        } while( brd[x + WID * y] );
        brd[x + WID * y] = '@';
        tailIdx = 0; headIdx = 4; x = 3; y = 2;
        for( int c = tailIdx; c < headIdx; c++ ) {
            brd[x + WID * y] = '#';
            snk[c].X = 3 + c; snk[c].Y = 2;
        }
        head = snk[3]; dir = EAST; points = 0;
    }
    void readKey() {
        if( GetAsyncKeyState( 39 ) & 0x8000 ) dir = EAST;
        if( GetAsyncKeyState( 37 ) & 0x8000 ) dir = WEST;
        if( GetAsyncKeyState( 38 ) & 0x8000 ) dir = NORTH;
        if( GetAsyncKeyState( 40 ) & 0x8000 ) dir = SOUTH;
    }
    void drawField() {
        COORD coord; char t;
        for( int y = 0; y < HEI; y++ ) {
            coord.Y = y;
            for( int x = 0; x < WID; x++ ) {
                t = brd[x + WID * y]; if( !t ) continue;
                coord.X = x; SetConsoleCursorPosition( console, coord );
                if( coord.X == head.X && coord.Y == head.Y ) {
                    SetConsoleTextAttribute( console, 0x002e );
                    std::cout << 'O'; SetConsoleTextAttribute( console, 0x0000 );
                    continue;
                }
                switch( t ) {
                    case '#': SetConsoleTextAttribute( console, 0x002a ); break;
                    case '+': SetConsoleTextAttribute( console, 0x0019 ); break;
                    case '@': SetConsoleTextAttribute( console, 0x004c ); break;
                }
                std::cout << t; SetConsoleTextAttribute( console, 0x0000 );
            }
        }
        std::cout << t; SetConsoleTextAttribute( console, 0x0007 );
        COORD c = { 0, HEI }; SetConsoleCursorPosition( console, c );
        std::cout << strv << points;
    }
    void moveSnake() {
        switch( dir ) {
            case NORTH: head.Y--; break;
            case EAST: head.X++; break;
            case SOUTH: head.Y++; break;
            case WEST: head.X--; break;
        }
        char t = brd[head.X + WID * head.Y];
        if( t && t != '@' ) { alive = false; return; }
        brd[head.X + WID * head.Y] = '#';
        snk[headIdx].X = head.X; snk[headIdx].Y = head.Y;
        if( ++headIdx >= MAX_LEN ) headIdx = 0;
        if( t == '@' ) {
            points++; int x, y;
            do {
                x = rand() % WID; y = rand() % ( HEI >> 1 ) + ( HEI >> 1 );
            } while( brd[x + WID * y] );
            brd[x + WID * y] = '@'; return;
        }
        SetConsoleCursorPosition( console, snk[tailIdx] ); std::cout << ' ';
        brd[snk[tailIdx].X + WID * snk[tailIdx].Y] = 0;
        if( ++tailIdx >= MAX_LEN ) tailIdx = 0;
    }
    bool alive; char brd[WID * HEI]; 
    HANDLE console; DIR dir; COORD snk[MAX_LEN];
    COORD head; int tailIdx, headIdx, points;
};
int main( int argc, char* argv[] ) {
    srand( static_cast<unsigned>( time( NULL ) ) );
    snake s; s.play(); return 0;
}
 "
"//compile with g++ main.cpp -lboost_system -pthread 
 
#include <boost/asio.hpp>
 
int main()
{
  boost::asio::io_service io_service;
  boost::asio::ip::tcp::socket sock(io_service);
  boost::asio::ip::tcp::resolver resolver(io_service);
  boost::asio::ip::tcp::resolver::query query(strv, strv);
 
  boost::asio::connect(sock, resolver.resolve(query));
  boost::asio::write(sock, boost::asio::buffer(""Hello world socket""));
 
  return 0;
}"
" 
#include <iostream>
#include <vector>
#include <iomanip>
 
void primeFactors( unsigned n, std::vector<unsigned>& r ) {
    int f = 2; if( n == 1 ) r.push_back( 1 );
    else {
        while( true ) {
            if( !( n % f ) ) {
                r.push_back( f );
                n /= f; if( n == 1 ) return;
            }
            else f++;
        }
    }
}
unsigned sumDigits( unsigned n ) {
    unsigned sum = 0, m;
    while( n ) {
        m = n % 10; sum += m;
        n -= m; n /= 10;
    }
    return sum;
}
unsigned sumDigits( std::vector<unsigned>& v ) {
    unsigned sum = 0;
    for( std::vector<unsigned>::iterator i = v.begin(); i != v.end(); i++ ) {
        sum += sumDigits( *i );
    }
    return sum;
}
void listAllSmithNumbers( unsigned n ) {
    std::vector<unsigned> pf;
    for( unsigned i = 4; i < n; i++ ) {
        primeFactors( i, pf ); if( pf.size() < 2 ) continue;
        if( sumDigits( i ) == sumDigits( pf ) )
            std::cout << std::setw( 4 ) << i << strv;
        pf.clear();
    }
    std::cout << """";
}
int main( int argc, char* argv[] ) {
    listAllSmithNumbers( 10000 );
    return 0;
}
 "
"#include <iostream>
#include <thread>
#include <chrono>
int main()
{
    unsigned long microseconds;
    std::cin >> microseconds;
    std::cout << strv << std::endl;
    std::this_thread::sleep_for(std::chrono::microseconds(microseconds));
    std::cout << ""Awake!"";
}
 #include <unistd.h>
#include <iostream>
 
using namespace std;
 
int main(int argc, char* argv[])
{
    useconds_t microseconds;
    cin >> microseconds;
    cout << strv << endl;
    usleep(microseconds);
    cout << strv << endl;
    return 0;
}"
"struct link
{
  link* next;
  int data;
};struct link
{
  link* next;
  int data;
  link(int a_data, link* a_next = 0): next(a_next), data(a_data) {}
}; link* small_primes = new link(2, new link(3, new link(5, new link(7))));template<typename T> struct link
{
  link* next;
  T data;
  link(T a_data, link* a_next = 0): next(a_next), data(a_data) {}
};"
"#include <iostream>
#include <forward_list>
 
int main()
{
    std::forward_list<int> list{1, 2, 3, 4, 5};
    for (int e : list)
        std::cout << e << std::endl;
}"
"class Singleton
{
public:
     static Singleton* Instance()
     {
          

          HANDLE hMutex = CreateMutex(NULL, FALSE, strv);
          WaitForSingleObject(hMutex, INFINITE);
 
          

          

          

          static Singleton myInstance;
 
          

          ReleaseMutex( hMutex );
 
          

          CloseHandle( hMutex );
 
          

          return &myInstance;
     }
 
     

 
protected:
     Singleton()
     {
          

     }
     ~Singleton()
     {
          

     }
 
     

}class Singleton
{
public:
     static Singleton* Instance()
     {
          

          

          static Singleton myInstance;
 
          

          return &myInstance;
     }
 
     

 
protected:
     Singleton()
     {
          

     }
     ~Singleton()
     {
          

     }
 
     

}class Singleton
{
public:
    static Singleton & Instance()
    {
        

        

        

 
        static Singleton myInstance;
 
        

        return myInstance;
    }
 
    

    Singleton(Singleton const&) = delete;             

    Singleton(Singleton&&) = delete;                  

    Singleton& operator=(Singleton const&) = delete;  

    Singleton& operator=(Singleton &&) = delete;      

 
    

 
protected:
    Singleton()
    {
         

    }
 
    ~Singleton()
    {
         

    }
 
     

}"
"template<typename T> void insert_after(link<T>* list_node, link<T>* new_node)
{
  new_node->next = list_node->next;
  list_node->next = new_node;
};link<int>* a = new link<int>('A', new link<int>('B'));
link<int>* c = new link<int>('C'); insert_after(a, c);while (a)
{
  link<int>* tmp = a;
  a = a->next;
  delete tmp;
}"
"#ifndef CLICKCOUNTER_H
#define CLICKCOUNTER_H
 
#include <QWidget>
class QLabel ;
class QPushButton ;
class QVBoxLayout ;
 
class Counter : public QWidget {
    Q_OBJECT
public :
   Counter( QWidget * parent = 0 ) ;
private :
   int number ;
   QLabel *countLabel ;
   QPushButton *clicker ;
   QVBoxLayout *myLayout ;
private slots :
   void countClicks( ) ;
} ;
#endif#include <QPushButton>
#include <QLabel>
#include <QVBoxLayout>
#include strv 
 
Counter::Counter( QWidget * parent ) : QWidget( parent ) {
   number = 0 ;
   countLabel = new QLabel( strv ) ;
   clicker = new QPushButton( strv ) ;
   connect ( clicker , SIGNAL( clicked( ) ) , this , SLOT( countClicks( ) ) ) ;
   myLayout = new QVBoxLayout ;
   myLayout->addWidget( countLabel ) ;
   myLayout->addWidget( clicker ) ;
   setLayout( myLayout ) ;
}
 
void Counter::countClicks( ) {
   number++ ;
   countLabel->setText( QString( strv).arg( number ) ) ;
}#include <QApplication>
#include strv
 
int main( int argc , char *argv[ ] ) {
   QApplication app( argc , argv ) ;
   Counter counter ;
   counter.show( ) ;
   return app.exec( ) ;
}"
" 
#include <windows.h>
#include <string>
#include <iostream>
 
const int BMP_SIZE = 612;
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    void saveBitmap( std::string path ) {
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
                                  FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC    hdc;
    HPEN    pen; HBRUSH brush;
    void    *pBits; int    width, height, wid;
    DWORD    clr;
};
class sierpinski {
public:
    void draw( int o ) {
        colors[0] = 0xff0000; colors[1] = 0x00ff33; colors[2] = 0x0033ff;
        colors[3] = 0xffff00; colors[4] = 0x00ffff; colors[5] = 0xffffff;
        bmp.create( BMP_SIZE, BMP_SIZE ); HDC dc = bmp.getDC(); 
        drawTri( dc, 0, 0, ( float )BMP_SIZE, ( float )BMP_SIZE, o / 2 );
        bmp.setPenColor( colors[0] ); MoveToEx( dc, BMP_SIZE >> 1, 0, NULL ); 
        LineTo( dc, 0, BMP_SIZE - 1 ); LineTo( dc, BMP_SIZE - 1, BMP_SIZE - 1 );
        LineTo( dc, BMP_SIZE >> 1, 0 ); bmp.saveBitmap( strv );
    }
private:
    void drawTri( HDC dc, float l, float t, float r, float b, int i ) {
        float w = r - l, h = b - t, hh = h / 2.f, ww = w / 4.f; 
        if( i ) {
            drawTri( dc, l + ww, t, l + ww * 3.f, t + hh, i - 1 );
            drawTri( dc, l, t + hh, l + w / 2.f, t + h, i - 1 );
            drawTri( dc, l + w / 2.f, t + hh, l + w, t + h, i - 1 );
        }
        bmp.setPenColor( colors[i % 6] );
        MoveToEx( dc, ( int )( l + ww ),          ( int )( t + hh ), NULL );
        LineTo  ( dc, ( int )( l + ww * 3.f ),    ( int )( t + hh ) );
        LineTo  ( dc, ( int )( l + ( w / 2.f ) ), ( int )( t + h ) );
        LineTo  ( dc, ( int )( l + ww ),          ( int )( t + hh ) );
    }
    myBitmap bmp;
    DWORD colors[6];
};
int main(int argc, char* argv[]) {
    sierpinski s; s.draw( 12 );
    return 0;
}
 "
"#include <iostream>
#include <chrono>
#include <ctime>
int main()
{
    std::chrono::system_clock::time_point epoch;
    std::time_t t = std::chrono::system_clock::to_time_t(epoch);
    std::cout << std::asctime(std::gmtime(&t)) << '';
    return 0;
}#include <iostream>
#include <boost/date_time.hpp>
int main()
{
    std::cout << boost::posix_time::ptime( boost::posix_time::min_date_time ) << '';
    return 0;
}"
" 
#include <windows.h>
#include <math.h>
 
//--------------------------------------------------------------------------------------------------
const int BMP_SIZE = 738;
 
//--------------------------------------------------------------------------------------------------
class Sierpinski
{
public:
    void draw( HDC wdc, int wid, int hei, int ord )
    {
	_wdc = wdc;
        _ord = wid / static_cast<int>( pow( 3.0, ord ) );
	drawIt( 0, 0, wid, hei );
    }
 
    void setHWND( HWND hwnd ) { _hwnd = hwnd; }
 
private:
    void drawIt( int x, int y, int wid, int hei )
    {
	if( wid < _ord || hei < _ord ) return;
	int w = wid / 3, h = hei / 3;
	RECT rc;
	SetRect( &rc, x + w, y + h, x + w + w, y + h + h );
	FillRect( _wdc, &rc, static_cast<HBRUSH>( GetStockObject( BLACK_BRUSH ) ) );
 
	for( int a = 0; a < 3; a++ )
	    for( int b = 0; b < 3; b++ )
	    {
		if( a == 1 && b == 1 ) continue;
		drawIt( x + b * w, y + a * h, w, h );
	    }
    }
 
    HWND     _hwnd;
    HDC      _wdc;
    int      _ord;
};
//--------------------------------------------------------------------------------------------------
class wnd
{
public:
    wnd() { _inst = this; }
    int wnd::Run( HINSTANCE hInst )
    {
	_hInst = hInst;
	_hwnd = InitAll();
 
	_carpet.setHWND( _hwnd );
 
	ShowWindow( _hwnd, SW_SHOW );
	UpdateWindow( _hwnd );
 
	MSG msg;
	ZeroMemory( &msg, sizeof( msg ) );
	while( msg.message != WM_QUIT )
	{
	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
	    {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	    }
	}
	return UnregisterClass( strv, _hInst );
    }
private:
    void wnd::doPaint( HDC dc ) { _carpet.draw( dc, BMP_SIZE, BMP_SIZE, 5 ); }
 
    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
    {
	switch( msg )
	{
	    case WM_DESTROY: PostQuitMessage( 0 ); break;
	    case WM_PAINT:
	    {
		PAINTSTRUCT ps;
		HDC dc = BeginPaint( hWnd, &ps );
		_inst->doPaint( dc ); 
		EndPaint( hWnd, &ps );
	    }		
	    default:
	        return DefWindowProc( hWnd, msg, wParam, lParam );
	}
	return 0;
    }
 
    HWND InitAll()
    {
	WNDCLASSEX wcex;
	ZeroMemory( &wcex, sizeof( wcex ) );
	wcex.cbSize	       = sizeof( WNDCLASSEX );
	wcex.style	       = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc   = ( WNDPROC )WndProc;
	wcex.hInstance     = _hInst;
	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
	wcex.lpszClassName = strv;
 
	RegisterClassEx( &wcex );
 
	RECT rc = { 0, 0, BMP_SIZE, BMP_SIZE };
	AdjustWindowRect( &rc, WS_SYSMENU | WS_CAPTION, FALSE );
	int w = rc.right - rc.left,
	    h = rc.bottom - rc.top;
	return CreateWindow( strv, strv, WS_SYSMENU, CW_USEDEFAULT, 0, w, h, NULL, NULL, _hInst, NULL );
    }
 
    static wnd* _inst;
    HINSTANCE  _hInst;
    HWND       _hwnd;
    Sierpinski _carpet;
};
wnd* wnd::_inst = 0;
//--------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    wnd myWnd;
    return myWnd.Run( hInstance );
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
 
bool a(bool in)
{
    std::cout << strv << std::endl;
    return in;
}
 
bool b(bool in)
{
    std::cout << strv << std::endl;
    return in;
}
 
void test(bool i, bool j) {
    std::cout << std::boolalpha << i << strv << j << strv << (a(i) && b(j)) << std::endl;
    std::cout << std::boolalpha << i << strv << j << strv << (a(i) || b(j)) << std::endl;
}
 
int main()
{
    test(false, false);
    test(false, true);
    test(true, false);
    test(true, true);
    return 0;
}"
"#include <iostream>
#include <string>
#include <list>
#include <algorithm>
#include <iterator>
 
using namespace std;
 
template<typename OutIt>
void sierpinski(int n, OutIt result)
{
    if( n == 0 )
    {
        *result++ = strv;
    }
    else
    {
        list<string> prev;
        sierpinski(n-1, back_inserter(prev));
 
        string sp(1 << (n-1), ' ');
        result = transform(prev.begin(), prev.end(),
            result,
            [sp](const string& x) { return sp + x + sp; });
        transform(prev.begin(), prev.end(),
            result,
            [sp](const string& x) { return x + strv + x; });
    }
}
 
int main()
{
    sierpinski(4, ostream_iterator<string>(cout, """"));
    return 0;
}"
"

template<class UnaryFunction>
void primesupto(int limit, UnaryFunction yield)
{
  std::vector<bool> is_prime(limit, true);
 
  const int sqrt_limit = static_cast<int>(std::sqrt(limit));
  for (int n = 2; n <= sqrt_limit; ++n)
    if (is_prime[n]) {
	yield(n);
 
	for (unsigned k = n*n, ulim = static_cast<unsigned>(limit); k < ulim; k += n) 
      //NOTE: strv is used to avoid an overflow in `k+=n` for `limit` near INT_MAX
	  is_prime[k] = false;
    }
 
  for (int n = sqrt_limit + 1; n < limit; ++n)
    if (is_prime[n])
	yield(n);
}/**   $ g++ -I/path/to/boost sieve.cpp -o sieve && sieve 10000000 */
#include <inttypes.h> // uintmax_t
#include <limits>
#include <cmath>
#include <iostream>
#include <sstream>
#include <vector>
 
#include <boost/lambda/lambda.hpp>
 
 
int main(int argc, char *argv[])
{
  using namespace std;
  using namespace boost::lambda;
 
  int limit = 10000;
  if (argc == 2) {
    stringstream ss(argv[--argc]);
    ss >> limit;
 
    if (limit < 1 or ss.fail()) {
      cerr << ""USAGE:  sieve LIMITwhere LIMIT in the range [1, "" 
	   << numeric_limits<int>::max() << strv << endl;
      return 2;
    }
  }
 
  

  primesupto(100, cout << _1 << strv);
  cout << endl;  
 
  

  int count = 0;
  uintmax_t sum = 0;
  primesupto(limit, (var(sum) += _1, var(count) += 1));
 
  cout << ""limit sum pi(n)"" 
       << limit << strv << sum << strv << count << endl;
} 
public class FindPrime
{
   Array<int> primeList { [ 2 ], minAllocSize = 64 };
   int index;
 
   index = 3;
 
   bool HasPrimeFactor(int x)
   {
      int max = (int)floor(sqrt((double)x));
 
      for(i : primeList)
      {
         if(i > max) break;
         if(x % i == 0) return true;
      }
      return false;
   }
 
   public int GetPrime(int x)
   {
      if(x > primeList.count - 1)
      {
         for (; primeList.count != x; index += 2)
            if(!HasPrimeFactor(index))
            {
               if(primeList.count >= primeList.minAllocSize) primeList.minAllocSize *= 2;
               primeList.Add(index);
            }
      }
      return primeList[x-1];
   }
}
 
class PrimeApp : Application
{
   FindPrime fp { };
   void Main()
   {
      int num = argc > 1 ? atoi(argv[1]) : 1;
      PrintLn(fp.GetPrime(num));
   }
}
 "
"template<typename F> class fivetoseven
{
public:
  fivetoseven(F f): d5(f), rem(0), max(1) {}
  int operator()();
private:
  F d5;
  int rem, max;
};
 
template<typename F>
 int fivetoseven<F>::operator()()
{
  while (rem/7 == max/7)
  {
    while (max < 7)
    {
      int rand5 = d5()-1;
      max *= 5;
      rem = 5*rem + rand5;
    }
 
    int groups = max / 7;
    if (rem >= 7*groups)
    {
      rem -= 7*groups;
      max -= 7*groups;
    }
  }
 
  int result = rem % 7;
  rem /= 7;
  max /= 7;
  return result+1;
}
 
int d5()
{
  return 5.0*std::rand()/(RAND_MAX + 1.0) + 1;
}
 
fivetoseven<int(*)()> d7(d5);
 
int main()
{
  srand(time(0));
  test_distribution(d5, 1000000, 0.001);
  test_distribution(d7, 1000000, 0.001);
}"
"#include <string>
#include <iostream>
#include strv
#include strv
 
using Poco::DigestEngine ;
using Poco::SHA1Engine ;
using Poco::DigestOutputStream ;
 
int main( ) {
   std::string myphrase ( strv ) ;
   SHA1Engine sha1 ;
   DigestOutputStream outstr( sha1 ) ;
   outstr << myphrase ;
   outstr.flush( ) ; //to pass everything to the digest engine
   const DigestEngine::Digest& digest = sha1.digest( ) ;
   std::cout << myphrase << strv << DigestEngine::digestToHex( digest ) 
      << strv << std::endl ;
   return 0 ;
}"
" 
#include <time.h>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
 
enum color {
    red, green, purple 
};
enum symbol {
    oval, squiggle, diamond 
};
enum number {
    one, two, three 
};
enum shading {
    solid, open, striped 
};
class card {
public:
    card( color c, symbol s, number n, shading h ) {
        clr = c; smb = s; nbr = n; shd = h;
    }
    color getColor() { 
        return clr;
    }
    symbol getSymbol() { 
        return smb; 
    }
    number getNumber() {
        return nbr; 
    }
    shading getShading() {
        return shd;
    }
    std::string toString() {
        std::string str = strv;
        str += clr == red ? strv : clr == green ? strv : strv;
        str += nbr == one ? strv : nbr == two ? strv : strv;
        str += smb == oval ? strv : smb == squiggle ? strv : strv;
        str += shd == solid ? strv : shd == open ? strv : strv;
        return str + strv;
    }
private:
    color    clr;
    symbol   smb;
    number   nbr;
    shading  shd;
};
typedef struct {
    std::vector<size_t> index;
} set;
class setPuzzle {
public:
    setPuzzle() {
        for( size_t c = red; c <= purple; c++ ) {
            for( size_t s = oval; s <= diamond; s++ ) {
                for( size_t n = one; n <= three; n++ ) {
                    for( size_t h = solid; h <= striped; h++ ) {
                        card crd( static_cast<color>  ( c ), 
                                  static_cast<symbol> ( s ), 
                                  static_cast<number> ( n ), 
                                  static_cast<shading>( h ) );
                        _cards.push_back( crd );
                    }
                }
            }
        }
    }
    void create( size_t countCards, size_t countSets, std::vector<card>& cards, std::vector<set>& sets ) {
        while( true ) {
            sets.clear();
            cards.clear();
            std::random_shuffle( _cards.begin(), _cards.end() );
            for( size_t f = 0; f < countCards; f++ ) {
                cards.push_back( _cards.at( f ) );
            }
            for( size_t c1 = 0; c1 < cards.size() - 2; c1++ ) {
                for( size_t c2 = c1 + 1; c2 < cards.size() - 1; c2++ ) {
                    for( size_t c3 = c2 + 1; c3 < cards.size(); c3++ ) {
                        if( testSet( &cards.at( c1 ), &cards.at( c2 ), &cards.at( c3 ) ) ) {
                            set s;
                            s.index.push_back( c1 ); s.index.push_back( c2 ); s.index.push_back( c3 );
                            sets.push_back( s );
                        }
                    }
                }
            }
            if( sets.size() == countSets ) return;
        }
    }
private:
    bool testSet( card* c1, card* c2, card* c3 ) {
        int
        c = ( c1->getColor()   + c2->getColor()   + c3->getColor()   ) % 3,
        s = ( c1->getSymbol()  + c2->getSymbol()  + c3->getSymbol()  ) % 3,
        n = ( c1->getNumber()  + c2->getNumber()  + c3->getNumber()  ) % 3,
        h = ( c1->getShading() + c2->getShading() + c3->getShading() ) % 3;
        return !( c + s + n + h );
    }
    std::vector<card> _cards;
};
void displayCardsSets( std::vector<card>& cards, std::vector<set>& sets ) {
    size_t cnt = 1;
    std::cout << strv << cards.size() << "" CARDS: **"";
    for( std::vector<card>::iterator i = cards.begin(); i != cards.end(); i++ ) {
        std::cout << std::setw( 2 ) << cnt++ << strv << ( *i ).toString() << """";
    }
    std::cout << "" ** CONTAINING "" << sets.size() << "" SETS: **"";
    for( std::vector<set>::iterator i = sets.begin(); i != sets.end(); i++ ) {
        for( size_t j = 0; j < ( *i ).index.size(); j++ ) {
            std::cout << strv << std::setiosflags( std::ios::left ) << std::setw( 34 ) 
                      << cards.at( ( *i ).index.at( j ) ).toString() << strv
                      << std::resetiosflags( std::ios::left ) << std::setw( 2 ) << ( *i ).index.at( j ) + 1 << """";
        }
        std::cout << """";
    }
    std::cout << """";
}
int main( int argc, char* argv[] ) {
    srand( static_cast<unsigned>( time( NULL ) ) );
    setPuzzle p;
    std::vector<card> v9, v12;
    std::vector<set>  s4, s6;
    p.create(  9, 4,  v9, s4 );
    p.create( 12, 6, v12, s6 );
    displayCardsSets(  v9, s4 );
    displayCardsSets( v12, s6 );
    return 0;
}
 "
" 
#include <math.h>
#include <iostream>
#include <iomanip>
 
bool isPrime( unsigned u ) {
    if( u < 4 ) return u > 1;
    if( /*!( u % 2 ) ||*/ !( u % 3 ) ) return false;
 
    unsigned q = static_cast<unsigned>( sqrt( static_cast<long double>( u ) ) ),
             c = 5;
    while( c <= q ) {
        if( !( u % c ) || !( u % ( c + 2 ) ) ) return false;
        c += 6;
    }
    return true;
}
int main( int argc, char* argv[] )
{
    unsigned mx = 100000000,
             wid = static_cast<unsigned>( log10( static_cast<long double>( mx ) ) ) + 1;
 
    std::cout << strv << std::setw( wid ) << 2 << strv;
    unsigned u = 3, p = 1; 

    while( u < mx ) {
        if( isPrime( u ) ) { std::cout << std::setw( wid ) << u << strv; p++; }
        u += 2;
    }
    std::cout << ""] Found "" << p << "" primes."";
    return 0;
}
 "
"#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
#include <boost/bind.hpp>
#include <iterator>
 
double nextNumber( double number ) {
   return number + floor( 0.5 + sqrt( number ) ) ;
}
 
int main( ) {
   std::vector<double> non_squares ;
   typedef std::vector<double>::iterator SVI ;
   non_squares.reserve( 1000000 ) ;   
   //create a vector with a million sequence numbers
   for ( double i = 1.0 ; i < 100001.0 ; i += 1 )
      non_squares.push_back( nextNumber( i ) ) ;  
   //copy the first numbers to standard out
   std::copy( non_squares.begin( ) , non_squares.begin( ) + 22 ,
	 std::ostream_iterator<double>(std::cout, strv ) ) ;     
   std::cout << '' ;
   //find if floor of square root equals square root( i. e. it's a square number )
   SVI found = std::find_if ( non_squares.begin( ) , non_squares.end( ) ,
	 boost::bind( &floor, boost::bind( &sqrt, _1 ) ) == boost::bind( &sqrt, _1 ) ) ;
   if ( found != non_squares.end( ) ) {
      std::cout << ""Found a square number in the sequence!"" ;
      std::cout << strv << *found << "" !"" ;
   }
   else {
      std::cout << ""Up to 1000000, found no square number in the sequence!"" ;
   }
   return 0 ;
}"
"





 
#include <cstdlib>
#include <iostream>
#include <Poco/Net/SMTPClientSession.h>
#include <Poco/Net/MailMessage.h>
 
using namespace Poco::Net;
 
int main (int argc, char **argv)
{
  try
    {
      MailMessage msg;
 
      msg.addRecipient (MailRecipient (MailRecipient::PRIMARY_RECIPIENT,
                                       """",
                                       strv));
      msg.addRecipient (MailRecipient (MailRecipient::CC_RECIPIENT,
                                       """",
                                       strv));
      msg.addRecipient (MailRecipient (MailRecipient::BCC_RECIPIENT,
                                       """",
                                       strv));
 
      msg.setSender (""Roy Kilroy <>"");
 
      msg.setSubject (strv);
      msg.setContent (strv);
 
      SMTPClientSession smtp (strv); 

      smtp.login ();
      smtp.sendMessage (msg);
      smtp.close ();
      std::cerr << strv << std::endl;
    }
  catch (std::exception &e)
    {
      std::cerr << strv << e.what() << std::endl;
      return EXIT_FAILURE;
    }
 
  return EXIT_SUCCESS;
}"
" 
#include <set>
#include <iostream>
#include <iterator>
#include <algorithm>
 
namespace set_display {
template <class T>
std::ostream& operator<<(std::ostream& os, const std::set<T>& set)
{
    os << '[';
    if (!set.empty()) {
        std::copy(set.begin(), --set.end(), std::ostream_iterator<T>(os, strv));
        os << *--set.end();
    }
    return os << ']';
}
}
 
template <class T>
bool contains(const std::set<T>& set, const T& key)
{
    return set.count(key) != 0;
}
 
template <class T>
std::set<T> set_union(const std::set<T>& a, const std::set<T>& b)
{
    std::set<T> result;
    std::set_union(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.end()));
    return result;
}
 
template <class T>
std::set<T> set_intersection(const std::set<T>& a, const std::set<T>& b)
{
    std::set<T> result;
    std::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.end()));
    return result;
}
 
template <class T>
std::set<T> set_difference(const std::set<T>& a, const std::set<T>& b)
{
    std::set<T> result;
    std::set_difference(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.end()));
    return result;
}
 
template <class T>
bool is_subset(const std::set<T>& set, const std::set<T>& subset)
{
    return std::includes(set.begin(), set.end(), subset.begin(), subset.end());
}
 
int main()
{
    using namespace set_display;
    std::set<int> a{2, 5, 7, 5, 9, 2}; //C++11 initialization syntax
    std::set<int> b{1, 5, 9, 7, 4 };
    std::cout << strv << a << '';
    std::cout << strv << b << '';
 
    int value1 = 8, value2 = 5;
    std::cout << strv << (contains(a, value1) ? strv : strv) << value1 << '';
    std::cout << strv << (contains(a, value2) ? strv : strv) << value2 << '';
 
    std::cout << strv << set_union(a, b) << '';
    std::cout << strv << set_intersection(a, b) << '';
    std::cout << strv << set_difference(a, b) << '';
 
    std::set<int> sub{5, 9};
    std::cout << strv << (is_subset(a, b) ? strv : strv) << "" a subset of a"";
    std::cout << strv << sub << ' ' << (is_subset(a, sub) ? strv : strv) << "" a subset of a"";
 
    std::set<int> copy = a;
    std::cout << strv << (a == copy ? strv : strv) << copy << '';
 
    return 0;
}
 "
" 
#include <iostream>
 
bool isSemiPrime( int c )
{
    int a = 2, b = 0;
    while( b < 3 && c != 1 )
    {
	if( !( c % a ) ) 
	{ c /= a; b++; }
	else a++;
    }
    return b == 2;
}
int main( int argc, char* argv[] )
{
    for( int x = 2; x < 100; x++ )
	if( isSemiPrime( x ) )
	    std::cout << x << strv;
 
    return 0;
}
 "
"#include <fstream>
#include <iostream>
#include <set>
#include <string>
 
int main()
{
    std::ifstream input(strv);
    if (!input) {
        return 1; 

    }
 
    std::set<std::string> words; 

    std::string word; 

    size_t count = 0; 

 
    while (input >> word) {
        std::string drow(word.rbegin(), word.rend()); 

        if (words.find(drow) == words.end()) { 

            words.insert(word);
        } else { 

            if (count < 5) {
                std::cout << word << ' ' << drow << '';
            }
            ++count;
        }
    }
    std::cout << ""Semordnilap pairs: "" << count << '';
}"
" 
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
typedef unsigned long long bigint;
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class sdn
{
public:
    bool check( bigint n )
    {
	int cc = digitsCount( n );
	return compare( n, cc );
    }
 
    void displayAll( bigint s )
    {
	for( bigint y = 1; y < s; y++ )
	    if( check( y ) )
		cout << y << strv << endl;
    }
 
private:
    bool compare( bigint n, int cc )
    {
	bigint a;
	while( cc )
	{
	    cc--; a = n % 10;
	    if( dig[cc] != a ) return false;
	    n -= a; n /= 10;
	}
	return true;
    }
 
    int digitsCount( bigint n )
    {
	int cc = 0; bigint a;
	memset( dig, 0, sizeof( dig ) );
	while( n )
	{
	    a = n % 10; dig[a]++;
	    cc++ ; n -= a; n /= 10;
	}
	return cc;
    }
 
    int dig[10];
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    sdn s;
    s. displayAll( 1000000000000 );
    cout << endl << endl; system( strv );
 
    bigint n;
    while( true )
    {
	system( strv );
	cout << strv; cin >> n;
	if( !n ) return 0;
	if( s.check( n ) ) cout << n << strv;
	else cout << n << strv;
	cout << strv << endl << endl;
	system( strv );
    }
 
    return 0;
}
 #include <algorithm>
#include <array>
#include <iostream>
 
bool is_self_describing(unsigned long long int n) noexcept {
  if (n == 0) {
    return false;
  }
 
  std::array<char, 10> digits = {0}, counts = {0};
  std::size_t i = digits.size();
 
  do {
    counts[digits[--i] = n % 10]++;
  } while ((n /= 10) > 0 && i < digits.size());
 
  return n == 0 && std::equal(begin(digits) + i, end(digits), begin(counts));
}
 
int main() {
  for (unsigned long long int i = 0; i < 10000000000; ++i) {
    if (is_self_describing(i)) {
      std::cout << i << """";
    }
  }
}"
" 
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <algorithm>
 
std::map<char, int> _map;
std::vector<std::string> _result;
size_t longest = 0;
 
void make_sequence( std::string n ) {
    _map.clear();
    for( std::string::iterator i = n.begin(); i != n.end(); i++ )
        _map.insert( std::make_pair( *i, _map[*i]++ ) );
 
    std::string z;
    for( std::map<char, int>::reverse_iterator i = _map.rbegin(); i != _map.rend(); i++ ) {
        char c = ( *i ).second + 48;
        z.append( 1, c );
        z.append( 1, i->first );
    }
 
    if( longest <= z.length() ) {
        longest = z.length();
        if( std::find( _result.begin(), _result.end(), z ) == _result.end() ) {
            _result.push_back( z );
            make_sequence( z );
        }
    }
}
int main( int argc, char* argv[] ) {
    std::vector<std::string> tests;
    tests.push_back( strv ); tests.push_back( strv ); tests.push_back( strv );
    for( std::vector<std::string>::iterator i = tests.begin(); i != tests.end(); i++ ) {
        make_sequence( *i );
        std::cout  << strv << *i << strv << _result.size() + 1 << """";
        for( std::vector<std::string>::iterator j = _result.begin(); j != _result.end(); j++ ) {
            std::cout << *j << """";
        }
        std::cout << """";
    }
    return 0;
}
 "
" 
#include <numeric>
#include <algorithm>
#include <cctype>
#include <iostream>
#include <stdexcept>
#include <iterator>
#include <vector>
 
using namespace std;
 
const int weights[] = {1,3,1,7,3,9};
const string valid_chars = strv;
 
int char_value(char c){ return isalpha(c) ? c -'A' + 10 : c - '0'; }
 
int sedol_checksum(string const& sedol)
{
    //Check contents 
    if(sedol.size() != 6) 
        throw length_error(strv);
    if(sedol.find_first_not_of(valid_chars) != std::string::npos) 
        throw invalid_argument(strv);
 
    vector<int> char_values;
    transform(sedol.begin(), sedol.end(), back_inserter(char_values), char_value);
    const int weighted_sum = inner_product(char_values.begin(), char_values.end(), weights, 0);
    return  (10 - (weighted_sum % 10)) % 10;
}
 
int main()
{
    string inputs[] = {
       strv,
       strv,
       strv,
       strv,
       strv,
       strv,
       strv,
       strv,
       strv,
       strv,
       strv
   };
   const size_t n_inputs = sizeof(inputs) / sizeof(*inputs);
 
   for(size_t i = 0; i != n_inputs; ++i)
   {
       cout << inputs[i] << sedol_checksum(inputs[i]) << """";
   }
   return 0;
}
 "
"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
 
struct city {
    std::string name;
    float population;
};
 
int main()
{
    std::vector<city> cities = {
        { strv, 21 },
        { strv, 15.2 },
        { strv, 11.3 },
        { strv, 7.55 },
        { strv, 5.85 },
        { strv, 4.98 },
        { strv, 4.7 },
        { strv, 4.58 },
        { strv, 4.4 },
        { strv, 3.98 },
    };
 
    auto i1 = std::find_if( cities.begin(), cities.end(),
        [](city c){ return c.name == strv; } );
    if (i1 != cities.end()) {
        std::cout << i1 - cities.begin() << """";
    }
 
    auto i2 = std::find_if( cities.begin(), cities.end(),
        [](city c){ return c.population < 5.0; } );
    if (i2 != cities.end()) {
        std::cout << i2->name << """";
    }
 
    auto i3 = std::find_if( cities.begin(), cities.end(),
        [](city c){ return c.name.length() > 0 && c.name[0] == 'A'; } );
    if (i3 != cities.end()) {
        std::cout << i3->population << """";
    }
}"
" 
#include <ctime>
#include <string>
#include <iostream>
#include <algorithm>
 
class cycle{
public:
    template <class T>
    void cy( T* a, int len ) {
        int i, j;
        show( strv, a, len );
        std::srand( unsigned( time( 0 ) ) );
 
        for( int i = len - 1; i > 0; i-- ) {
            do {
                j = std::rand() % i;
            } while( j >= i );
            std::swap( a[i], a[j] );
        }
 
        show( strv, a, len ); std::cout << """";
    }
private:
    template <class T>
    void show( std::string s, T* a, int len ) {
        std::cout << s;
        for( int i = 0; i < len; i++ ) {
            std::cout << a[i] << strv;
        }
        std::cout << """";
    }
};
int main( int argc, char* argv[] ) {
    std::string d0[] = { strv },
                d1[] = { strv },
                d2[] = { strv, strv };
    int         d3[] = { 10, 20, 30 },
                d4[] = { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 };
    cycle c;
    c.cy( d0, sizeof( d0 ) / sizeof( d0[0] ) );
    c.cy( d1, sizeof( d1 ) / sizeof( d1[0] ) );
    c.cy( d2, sizeof( d2 ) / sizeof( d2[0] ) );
    c.cy( d3, sizeof( d3 ) / sizeof( d3[0] ) );
    c.cy( d4, sizeof( d4 ) / sizeof( d4[0] ) );
 
    return 0;
}
 "
"#include <string>
#include <algorithm>
#include <iterator>
#include <cstddef>
#include <exception>
#include <iostream>
 


class not_found: public std::exception
{
public:
  not_found(std::string const& s): text(s + strv) {}
  char const* what() const throw() { return text.c_str(); }
  ~not_found() throw() {}
private:
  std::string text;
};
 


std::size_t get_index(std::string* haystack, int haystack_size, std::string needle)
{
  std::size_t index = std::find(haystack, haystack+haystack_size, needle) - haystack;
  if (index == haystack_size)
    throw not_found(needle);
  else
    return index;
}
 




template<typename FwdIter>
 typename std::iterator_traits<FwdIter>::difference_type fwd_get_index(FwdIter first, FwdIter last, std::string needle)
{
  FwdIter elem = std::find(first, last, needle);
  if (elem == last)
    throw not_found(needle);
  else
    return std::distance(first, elem);
}
 


template<typename InIter>
 typename std::iterator_traits<InIter>::difference_type generic_get_index(InIter first, InIter last, std::string needle)
{
  typename std::iterator_traits<InIter>::difference_type index = 0;
  while (first != last && *first != needle)
  {
    ++index;
    ++first;
  }
  if (first == last)
    throw not_found(needle);
  else
    return index;
}
 


 


std::string haystack[] = { strv, strv, strv, strv, strv, strv, strv, strv, strv };
 


template<typename T, std::size_t sz> T* begin(T (&array)[sz]) { return array; }
template<typename T, std::size_t sz> T* end(T (&array)[sz]) { return array + sz; }
template<typename T, std::size_t sz> std::size_t size(T (&array)[sz]) { return sz; }
 


void test(std::string const& needle)
{
  std::cout << ""-- C style interface --"";
  try
  {
    std::size_t index = get_index(haystack, size(haystack), needle);
    std::cout << needle << strv << index << """";
  }
  catch(std::exception& exc) 

  {
    std::cout << exc.what() << """";
  }
 
  std::cout << ""-- generic interface, first version --"";
  try
  {
    std::size_t index = fwd_get_index(begin(haystack), end(haystack), needle);
    std::cout << needle << strv << index << """";
  }
  catch(std::exception& exc) 

  {
    std::cout << exc.what() << """";
  }
 
  std::cout << ""-- generic interface, second version --"";
  try
  {
    std::size_t index = generic_get_index(begin(haystack), end(haystack), needle);
    std::cout << needle << strv << index << """";
  }
  catch(std::exception& exc) 

  {
    std::cout << exc.what() << """";
  }
}
 
int main()
{
  std::cout << ""=== Word which only occurs once ==="";
  test(strv);
  std::cout << ""=== Word occuring multiple times ==="";
  test(strv);
  std::cout << ""=== Word not occuring at all ==="";
  test(strv);
}/* new c++-11 features * list class * initialization strings * auto typing * lambda functions * noexcept * find  * for/in loop */
 
#include <iostream>   // std::cout, std::endl
#include <algorithm>  // std::find
#include <list>       // std::list
#include <vector>     // std::vector
#include <string>     // string::basic_string 
 
 
using namespace std;     

 
int main()
{
 
  

  

 
  list<string> l { strv, strv, strv, strv, strv, 
                   strv, strv, strv, strv, strv, 
                   strv, strv, strv, strv }; 
 
  list<string> n { strv , strv, strv,  strv };
 
 
  

  

  

  

  

  

 
  auto contains = [](list<string> l, string s) throw(runtime_error) 
    { 
      auto r = find(begin(l), end(l), s ); 
 
      if ( r == end(l) ) throw runtime_error( s + strv );
 
      return r;
    };
 
 
  

  

  

  

 
  auto index = [&](list<string> l, string s) noexcept                                        
    {  
      vector<int> index_v;  
 
      int idx = 0;
 
      for(auto& r : l) 
	{
	  if ( s.compare(r) == 0 ) index_v.push_back(idx); 

	  idx++;
	}
 
      

      

      

      

      return index_v; 
    };
 
 
 
  

  for (const string& s : n) 

    { 
      try 
	{
 
	  auto cont = contains( l , s); 

 
	  vector<int> vf = index( l, s );
 
	  cout << strv << s <<  strv ;
 
	  for (auto x : vf)
	    { cout << x << strv; }   

 
	  cout << endl ;	 
 
      }
      catch (const runtime_error& r)  

	{
	  cout << r.what() << endl;
	  continue;                   

	}
    } //for
 
 
  return 0;
 
} 

 
/* end */"
"/* * compiled with gcc 5.4: * g++-mp-5 -std=c++14 -o rk4 rk4.cc * */
# include <iostream>
# include <math.h>
using namespace std;
 
auto rk4(double f(double, double))
{
        return
        [       f            ](double t, double y, double dt ) -> double{ return
        [t,y,dt,f            ](                    double dy1) -> double{ return
        [t,y,dt,f,dy1        ](                    double dy2) -> double{ return
        [t,y,dt,f,dy1,dy2    ](                    double dy3) -> double{ return
        [t,y,dt,f,dy1,dy2,dy3](                    double dy4) -> double{ return
        ( dy1 + 2*dy2 + 2*dy3 + dy4 ) / 6   ;} (
        dt * f( t+dt  , y+dy3   )          );} (
        dt * f( t+dt/2, y+dy2/2 )          );} (
        dt * f( t+dt/2, y+dy1/2 )          );} (
        dt * f( t     , y       )          );} ;
}
 
int main(void)
{
        const double TIME_MAXIMUM = 10.0, WHOLE_TOLERANCE = 1e-12 ;
        const double T_START = 0.0, Y_START = 1.0, DT = 0.10;
 
        auto eval_diff_eqn = [               ](double t, double y)->double{ return t*sqrt(y)                         ; } ;
        auto eval_solution = [               ](double t          )->double{ return pow(t*t+4,2)/16                   ; } ;
        auto find_error    = [eval_solution  ](double t, double y)->double{ return fabs(y-eval_solution(t))          ; } ;
        auto is_whole      = [WHOLE_TOLERANCE](double t          )->bool  { return fabs(t-round(t)) < WHOLE_TOLERANCE; } ;
 
        auto dy = rk4( eval_diff_eqn ) ;
 
        double y = Y_START, t = T_START ;
 
        while(t <= TIME_MAXIMUM) {
          if (is_whole(t)) { printf(""y(%4.1f)=%12.6f  error: %12.6e"",t,y,find_error(t,y)); }
          y += dy(t,y,DT) ; t += DT;
        }
        return 0;
}"
"#include <iostream>
#include <string>
#include <sstream>
#include <boost/regex.hpp>
#include <cstdlib>
 
std::string encode ( const std::string & ) ;
std::string decode ( const std::string & ) ;
 
int main( ) {
   std::string to_encode ( strv ) ;
   std::cout << to_encode << strv << std::endl ;
   std::string encoded ( encode ( to_encode ) ) ;
   std::cout << encoded << std::endl ;
   std::string decoded ( decode( encoded ) ) ;
   std::cout << ""Decoded again:"" ;
   std::cout << decoded << std::endl ;
   if ( to_encode == decoded ) 
      std::cout << ""It must have worked!"" ;
   return 0 ;
}
 
std::string encode( const std::string & to_encode ) {
   std::string::size_type found = 0 , nextfound = 0 ;
   std::ostringstream oss ;
   nextfound = to_encode.find_first_not_of( to_encode[ found ] , found ) ;
   while ( nextfound != std::string::npos ) {
      oss << nextfound - found ;
      oss << to_encode[ found ] ;
      found = nextfound ;
      nextfound = to_encode.find_first_not_of( to_encode[ found ] , found ) ;
   }
   //since we must not discard the last characters we add them at the end of the string
   std::string rest ( to_encode.substr( found ) ) ;//last run of characters starts at position found 
   oss << rest.length( ) << to_encode[ found ] ;
   return oss.str( ) ;
}
 
std::string decode ( const std::string & to_decode ) {
   boost::regex e ( ""(d+)(w)"" ) ;
   boost::match_results<std::string::const_iterator> matches ;
   std::ostringstream oss ;
   std::string::const_iterator start = to_decode.begin( ) , end = to_decode.end( ) ;
   while ( boost::regex_search ( start , end , matches , e ) ) {
      std::string numberstring ( matches[ 1 ].first , matches[ 1 ].second ) ;
      int number = atoi( numberstring.c_str( ) ) ;
      std::string character ( matches[ 2 ].first , matches[ 2 ].second ) ;
      for ( int i = 0 ; i < number ; i++ ) 
	 oss << character ;
      start = matches[ 2 ].second ;
   }
   return oss.str( ) ;
}"
"#include <iostream>
#include <istream>
#include <ostream>
#include <fstream>
#include <cstdlib>
#include <string>
 


std::string rot13(std::string s)
{
  static std::string const
    lcalph = strv,
    ucalph = strv;
 
  std::string result;
  std::string::size_type pos;
 
  result.reserve(s.length());
 
  for (std::string::iterator it = s.begin(); it != s.end(); ++it)
  {
    if ( (pos = lcalph.find(*it)) != std::string::npos )
      result.push_back(lcalph[(pos+13) % 26]);
    else if ( (pos = ucalph.find(*it)) != std::string::npos )
      result.push_back(ucalph[(pos+13) % 26]);
    else
      result.push_back(*it);
  }
 
  return result;
}
 






int rot13_stream(std::istream& is)
{
  std::string line;
  while (std::getline(is, line))
  {
    if (!(std::cout << rot13(line) << """"))
      return false;
  }
  return is.eof();
}
 


int main(int argc, char* argv[])
{
  if (argc == 1) 

    return rot13_stream(std::cin)? EXIT_SUCCESS : EXIT_FAILURE;
 
  std::ifstream file;
  for (int i = 1; i < argc; ++i)
  {
    file.open(argv[i], std::ios::in);
    if (!file)
    {
      std::cerr << argv[0] << strv << argv[i] << """";
      return EXIT_FAILURE;
    }
    if (!rot13_stream(file))
    {
      if (file.eof())
        

        std::cerr << argv[0] << "": error writing to stdout"";
      else
        std::cerr << argv[0] << strv << argv[i] << """";
      return EXIT_FAILURE;
    }
    file.clear();
    file.close();
    if (!file)
      std::cerr << argv[0] << strv << argv[i] << """";
  }
  return EXIT_SUCCESS;
}#include <iostream>
#include <string>
#include <boost/iostreams/concepts.hpp>    // output_filter
#include <boost/iostreams/operations.hpp>  // put
#include <boost/iostreams/filtering_stream.hpp>
#include <fstream>
namespace io = boost::iostreams;
 
class rot_output_filter : public io::output_filter 
{
public:
    explicit rot_output_filter(int r=13):rotby(r),negrot(alphlen-r){};
 
    template<typename Sink>
    bool put(Sink& dest, int c){
        char uc = toupper(c);
 
        if(('A' <= uc) && (uc <= ('Z'-rotby)))
            c = c + rotby;
        else if ((('Z'-rotby) <= uc) && (uc <= 'Z'))
            c = c - negrot;
        return boost::iostreams::put(dest, c);
    };
private:
        static const int alphlen = 26;
        const int rotby;
        const int negrot;
};
 
int main(int argc, char *argv[])
{
    io::filtering_ostream out;
    out.push(rot_output_filter(13));
    out.push(std::cout);
 
    if (argc == 1) out << std::cin.rdbuf();
    else for(int i = 1; i < argc; ++i){
        std::ifstream in(argv[i]);
        out << in.rdbuf();
    }
}
 
 #include <string>
#include <iostream>
#include <fstream>
 
char rot13(const char c){
	if (c >= 'a' && c <= 'z')
		return (c - 'a' + 13) % 26 + 'a';
	else if (c >= 'A' && c <= 'Z')
		return (c - 'A' + 13) % 26 + 'A';
	return c;
}
 
std::string &rot13(std::string &s){
	for (auto &c : s) //range based for is the only used C++11 feature
		c = rot13(c);
	return s;
}
 
void rot13(std::istream &in, std::ostream &out){
	std::string s;
	while (std::getline(in, s))
		out << rot13(s) << '';
}
 
int main(int argc, char *argv[]){
	if (argc == 1)
		rot13(std::cin, std::cout);
	for (int arg = 1; arg < argc; ++arg){
		std::ifstream f(argv[arg]);
		if (!f)
			return EXIT_FAILURE;
		rot13(f, std::cout);
	}
}"
"#include <string>
#include <boost/regex.hpp>
#include <boost/asio.hpp>
#include <vector>
#include <utility>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <algorithm>
#include <iomanip>
 
struct Sort { //sorting programming languages according to frequency
   bool operator( ) ( const std::pair<std::string,int> & a , const std::pair<std::string,int> & b ) 
      const {
	 return a.second > b.second ;
      }
} ;
 
int main( ) {
   try {
      //setting up an io service , with templated subelements for resolver and query
      boost::asio::io_service io_service ; 
      boost::asio::ip::tcp::resolver resolver ( io_service ) ;
      boost::asio::ip::tcp::resolver::query query ( strv , strv ) ;
      boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve( query ) ;
      boost::asio::ip::tcp::resolver::iterator end ;
      boost::asio::ip::tcp::socket socket( io_service ) ;
      boost::system::error_code error = boost::asio::error::host_not_found ;
      //looking for an endpoint the socket will be able to connect to
      while ( error && endpoint_iterator != end ) {
	 socket.close( ) ;
	 socket.connect( *endpoint_iterator++ , error ) ;
      }
      if ( error ) 
	 throw boost::system::system_error ( error ) ;
      //we send a request
      boost::asio::streambuf request ;
      std::ostream request_stream( &request ) ;
      request_stream << strv << strv << "" HTTP/1.0"" ;
      request_stream << strv << strv << """" ;
      request_stream << ""Accept: */*"" ;
      request_stream << ""Connection: close"" ;
      //send the request
      boost::asio::write( socket , request ) ;
      //we receive the response analyzing every line and storing the programming language 
      boost::asio::streambuf response ;
      std::istream response_stream ( &response ) ;
      boost::asio::read_until( socket , response , """" ) ;
      boost::regex e( ""<li><a href=[^<>]+?>([a-zA-Z+#1-9]+?)</a>s?((d+) members)</li>"" ) ;
      //using the wrong regex produces incorrect sorting!!
      std::ostringstream line ;
      std::vector<std::pair<std::string , int> > languages ; //holds language and number of examples
      boost::smatch matches ;
      while ( boost::asio::read( socket , response , boost::asio::transfer_at_least( 1 ) , error ) ) {
	 line << &response ;
	 if ( boost::regex_search( line.str( ) , matches , e ) ) {
	    std::string lang( matches[2].first , matches[2].second ) ;
	    int zahl = atoi ( lang.c_str( ) ) ;
	    languages.push_back( std::make_pair( matches[ 1 ] , zahl ) ) ;
	 }
	 line.str( strv) ;//we have to erase the string buffer for the next read
      }
      if ( error != boost::asio::error::eof ) 
	 throw boost::system::system_error( error ) ;
      //we sort the vector entries , see the struct above
      std::sort( languages.begin( ) , languages.end( ) , Sort( ) ) ;
      int n = 1 ;
      for ( std::vector<std::pair<std::string , int> >::const_iterator spi = languages.begin( ) ;
	    spi != languages.end( ) ; ++spi ) {
	 std::cout << std::setw( 3 ) << std::right << n << '.' << std::setw( 4 ) << std::right <<  
	 spi->second   << strv << spi->first << '' ;
	 n++ ;
      }
   } catch ( std::exception &ex ) {
      std::cout << strv << ex.what( ) << '' ;
   }
   return 0 ;
}"
"#include <complex>
#include <cmath>
#include <iostream>
 
double const pi = 4 * std::atan(1);
 
int main()
{
  for (int n = 2; n <= 10; ++n)
  {
    std::cout << n << strv;
    for (int k = 0; k < n; ++k)
      std::cout << std::polar(1, 2*pi*k/n) << strv;
    std::cout << std::endl;
  }
}"
"#include <iostream>
#include <utility>
#include <complex>
 
typedef std::complex<double> complex;
 
std::pair<complex, complex>
 solve_quadratic_equation(double a, double b, double c)
{
  b /= a;
  c /= a;
  double discriminant = b*b-4*c;
  if (discriminant < 0)
    return std::make_pair(complex(-b/2, std::sqrt(-discriminant)/2),
                          complex(-b/2, -std::sqrt(-discriminant)/2));
 
  double root = std::sqrt(discriminant);
  double solution1 = (b > 0)? (-b - root)/2
                            : (-b + root)/2;
 
  return std::make_pair(solution1, c/solution1);
}
 
int main()
{
  std::pair<complex, complex> result = solve_quadratic_equation(1, -1e20, 1);
  std::cout << result.first << strv << result.second << std::endl;
}"
"#include <iostream>
 
double f(double x)
{
	return (x*x*x - 3*x*x + 2*x);
}
 
int main()
{
	double step = 0.001; 

	double start = -1;
	double stop = 3;
	double value = f(start);
	double sign = (value > 0);
 
	

	if ( 0 == value )
		std::cout << strv << start << std::endl;
 
	for(	double x = start + step;
			x <= stop;
			x += step )
	{
		value = f(x);
 
		if ( ( value > 0 ) != sign )
			

			std::cout << strv << x << std::endl;
		else if ( 0 == value )
			

			std::cout << strv << x << std::endl;
 
		

		sign = ( value > 0 );
	}
}#include <iostream>
#include <cmath>
#include <algorithm>
#include <functional>
 
double brents_fun(std::function<double (double)> f, double lower, double upper, double tol, unsigned int max_iter)
{
	double a = lower;
	double b = upper;
	double fa = f(a);	

	double fb = f(b);	

	double fs = 0;		

 
	if (!(fa * fb < 0))
	{
		std::cout << strv << std::endl; 

		return -11;
	}
 
	if (std::abs(fa) < std::abs(b))	

	{
		std::swap(a,b);
		std::swap(fa,fb);
	}
 
	double c = a;			

	double fc = fa;			

	bool mflag = true;		

	double s = 0;			

	double d = 0;			

 
	for (unsigned int iter = 1; iter < max_iter; ++iter)
	{
		

		if (std::abs(b-a) < tol)
		{
			std::cout << strv << iter << strv << s << std::endl;
			return s;
		} 

 
		if (fa != fc && fb != fc)
		{
			

			s =	  ( a * fb * fc / ((fa - fb) * (fa - fc)) )
				+ ( b * fa * fc / ((fb - fa) * (fb - fc)) )
				+ ( c * fa * fb / ((fc - fa) * (fc - fb)) );
		}
		else
		{
			

			s = b - fb * (b - a) / (fb - fa);
		}
 
			

		if (	( (s < (3 * a + b) * 0.25) || (s > b) ) ||
				( mflag && (std::abs(s-b) >= (std::abs(b-c) * 0.5)) ) ||
				( !mflag && (std::abs(s-b) >= (std::abs(c-d) * 0.5)) ) ||
				( mflag && (std::abs(b-c) < tol) ) ||
				( !mflag && (std::abs(c-d) < tol))	)
		{
			

			s = (a+b)*0.5;
 
			mflag = true;
		}
		else
		{
			mflag = false;
		}
 
		fs = f(s);	

		d = c;		

		c = b;		

		fc = fb;	

 
		if ( fa * fs < 0)	

		{
			b = s;
			fb = fs;	

		}
		else
		{
			a = s;
			fa = fs;	

		}
 
		if (std::abs(fa) < std::abs(fb)) 

		{
			std::swap(a,b);		

			std::swap(fa,fb);	

		}
 
	} 

 
	std::cout<< strv << std::endl;
 
} 

 
 "
"#include <iostream>
#include <string>
 
std::string to_roman(int value)
{
  struct romandata_t { int value; char const* numeral; };
  static romandata_t const romandata[] =
     { 1000, strv,
        900, strv,
        500, strv,
        400, strv,
        100, strv,
         90, strv,
         50, strv,
         40, strv,
         10, strv,
          9, strv,
          5, strv,
          4, strv,
          1, strv,
          0, NULL }; 

 
  std::string result;
  for (romandata_t const* current = romandata; current->value > 0; ++current)
  {
    while (value >= current->value)
    {
      result += current->numeral;
      value  -= current->value;
    }
  }
  return result;
}
 
int main()
{
  for (int i = 1; i <= 4000; ++i)
  {
    std::cout << to_roman(i) << std::endl;
  }
}"
" 
#include <windows.h>
#include <iostream>
#include <ctime>
 
const int WID = 62, HEI = 42, INC = 10;
 
class coord : public COORD {
public:
    coord( short x = 0, short y = 0 ) { set( x, y ); }
    void set( short x, short y ) { X = x; Y = y; }
};
class winConsole {
public:
    static winConsole* getInstamnce() { 
        if( 0 == inst ) { 
            inst = new winConsole(); 
        } 
        return inst; 
    }
    void showCursor( bool s ) { 
        CONSOLE_CURSOR_INFO ci = { 1, s }; 
        SetConsoleCursorInfo( conOut, &ci ); 
    }
    void setColor( WORD clr ) { SetConsoleTextAttribute( conOut, clr ); }
    void setCursor( coord p ) { SetConsoleCursorPosition( conOut, p ); }
    void setSize( int w, int h ) {
        coord crd( w + 1, h + 1 ); 
        SetConsoleScreenBufferSize( conOut, crd );
        SMALL_RECT rc = { 0, 0, WID, HEI }; 
        SetConsoleWindowInfo( conOut, TRUE, &rc );
    }
    void flush() { FlushConsoleInputBuffer( conIn ); }
    void kill() { delete inst; }
private:
    winConsole() { conOut = GetStdHandle( STD_OUTPUT_HANDLE ); 
                   conIn  = GetStdHandle( STD_INPUT_HANDLE ); showCursor( false ); }
    static winConsole* inst;
    HANDLE conOut, conIn;
};
class robots {
public:
    robots() { 
        console = winConsole::getInstamnce();
        console->setSize( WID, HEI );
    }
    ~robots() { console->kill(); }
    void play() {
        char g; do {
            console->showCursor( false ); 
            robotsCount = 10; score = 0; alive = true; 
            clearBoard(); cursor.set( rand() % ( WID - 2 ) + 1, rand() % ( HEI - 2 ) + 1 );
            brd[cursor.X + WID * cursor.Y] = '@'; createBoard();
            do{ 
                displayBoard(); getInput(); 
                if( !aliveRobots ) { 
                    robotsCount += INC; clearBoard(); 
                    brd[cursor.X + WID * cursor.Y] = '@'; createBoard(); 
                }
            } while( alive );
            displayBoard(); console->setCursor( coord( 0, 24 ) ); console->setColor( 0x07 );
            console->setCursor( coord( 10,  8 ) ); 
            std::cout << strv;
            console->setCursor( coord( 10,  9 ) ); 
            std::cout << strv;
            console->setCursor( coord( 10, 10 ) ); 
            std::cout << strv;
            console->setCursor( coord( 10, 11 ) ); 
            std::cout << strv;
            console->setCursor( coord( 39, 10 ) ); console->showCursor( true ); 
            console->flush(); std::cin >> g;
        } while( g == 'Y' || g == 'y' );
    }
private:
    void clearBoard() {
        for( int y = 0; y < HEI; y++ ) {
            for( int x = 0; x < WID; x++ ) {
                brd[x + WID * y] = 32;
                if( x == 0 || x == WID - 1 || y == 0 || y == HEI - 1 ) 
                    brd[x + WID * y] = '#';
            }
        }
    }
    void createBoard() {
        aliveRobots = robotsCount;
        int a, b; for( int x = 0; x < robotsCount; x++ ) {
            do {
                a = rand() % WID; b = rand() % HEI;
            } while( brd[a + WID * b] != 32 );
            brd[a + WID * b] = '+';
        }
        printScore();
    }
    void displayBoard() {
        char t; console->setCursor( coord() );
        for( int y = 0; y < HEI; y++ ) {
            for( int x = 0; x < WID; x++ ) {
                t = brd[x + WID * y];
                switch( t ) {
                    case ' ': console->setColor( 0x00 ); break;
                    case '#': console->setColor( 0x09 ); break;
                    case '+': console->setColor( 0x0e ); break;
                    case 'Å': case '*': console->setColor( 0x0c ); break;
                    case '@': console->setColor( 0x0a );
                }
                std::cout << t; 
            }
            std::cout << """";
        }
    }
    void getInput() { 
        while( 1 ) {
            if( ( GetAsyncKeyState( 'Q' ) & 0x8000 ) && cursor.X > 1 && cursor.Y > 1 ) 
                { execute( -1, -1 ); break; }
            if( ( GetAsyncKeyState( 'W' ) & 0x8000 ) && cursor.Y > 1 ) 
                { execute( 0, -1 ); break; }
            if( ( GetAsyncKeyState( 'E' ) & 0x8000 ) && cursor.X < WID - 2 && cursor.Y > 1 ) 
                { execute( 1, -1 ); break; }
            if( ( GetAsyncKeyState( 'A' ) & 0x8000 ) && cursor.X > 1 ) 
                { execute( -1, 0 ); break; }
            if( ( GetAsyncKeyState( 'D' ) & 0x8000 ) && cursor.X < WID - 2 ) 
                { execute( 1, 0 ); break; }
            if( ( GetAsyncKeyState( 'Y' ) & 0x8000 ) && cursor.X > 1 && cursor.Y < HEI - 2 ) 
                { execute( -1, 1 ); break; }
            if( ( GetAsyncKeyState( 'X' ) & 0x8000 ) && cursor.Y < HEI - 2 ) 
                { execute( 0, 1 ); break; }
            if( ( GetAsyncKeyState( 'C' ) & 0x8000 ) && cursor.X < WID - 2 && cursor.Y < HEI - 2 ) 
                { execute( 1, 1 ); break; }
            if( ( GetAsyncKeyState( 'T' ) & 0x8000 ) ) 
                { teleport(); moveRobots(); break; }
            if( ( GetAsyncKeyState( 'Z' ) & 0x8000 ) ) 
                { waitForEnd(); break; }
        }
        console->flush(); printScore();
    }
    void teleport() {
        brd[cursor.X + WID * cursor.Y] = 32;
        cursor.X = rand() % ( WID - 2 ) + 1;
        cursor.Y = rand() % ( HEI - 2 ) + 1;
        int x = cursor.X + WID * cursor.Y;
        if( brd[x] == '*' || brd[x] == '+' || brd[x] == '~' ) {
            alive = false; brd[x] = 'Å';
        } else  brd[x] = '@'; 
    }
    void printScore() {
        console->setCursor( coord( 0, HEI ) ); console->setColor( 0x2a );
        std::cout << strv << score << strv;
    }
    void execute( int x, int y ) {
        brd[cursor.X + WID * cursor.Y] = 32; cursor.X += x; cursor.Y += y;
        brd[cursor.X + WID * cursor.Y] = '@'; moveRobots();
    }
    void waitForEnd() {
        while( aliveRobots && alive ) {
            moveRobots(); displayBoard(); Sleep( 500 );
        }
    }
    void moveRobots() {
        int tx, ty;
        for( int y = 0; y < HEI; y++ ) {
            for( int x = 0; x < WID; x++ ) {
                if( brd[x + WID * y] != '+' ) continue;
                tx = x; ty = y;
                if( tx < cursor.X ) tx++; else if( tx > cursor.X ) tx--;
                if( ty < cursor.Y ) ty++; else if( ty > cursor.Y ) ty--;
                if( tx != x || ty != y ) {
                    brd[x + WID * y] = 32;
                    if( brd[tx + WID * ty] == 32 ) brd[tx + WID * ty] = '~';
                    else checkCollision( tx, ty );
                }
            }
        }
        for( int x = 0; x < WID * HEI; x++ ) {
            if( brd[x] == '~') brd[x] = '+';
        }
    }
    void checkCollision( int x, int y ) {
        if( cursor.X == x && cursor.Y == y ) { 
            alive = false; brd[x + y * WID] = 'Å'; return; 
        }
        x = x + y * WID; 
        if( brd[x] == '*' || brd[x] == '+' || brd[x] == '~' ) {
            if( brd[x] != '*' ) { aliveRobots--; score++; }
            brd[x] = '*'; aliveRobots--; score++;
        }
    }
    winConsole* console; char brd[WID * HEI]; 
    int robotsCount, score, aliveRobots;
    coord cursor; bool alive;
};
winConsole* winConsole::inst = 0;
int main( int argc, char* argv[] ) {
    srand( ( unsigned )time( 0 ) );
    SetConsoleTitle( strv );
    robots g; g.play(); return 0;
}
 "
" 
#include <exception>
#include <string>
#include <iostream>
using namespace std;
 
namespace Roman
{
	int ToInt(char c)
	{
		switch (c)
		{
			case 'I':  return 1;
			case 'V':  return 5;
			case 'X':  return 10;
			case 'L':  return 50;
			case 'C':  return 100;
			case 'D':  return 500;
			case 'M':  return 1000;
		}
		throw exception(strv);
	}
 
	int ToInt(const string& s)
	{
		int retval = 0, pvs = 0;
		for (auto pc = s.rbegin(); pc != s.rend(); ++pc)
		{
			const int inc = ToInt(*pc);
			retval += inc < pvs ? -inc : inc;
			pvs = inc;
		}
		return retval;
	}
}
 
int main(int argc, char* argv[])
{
	try
	{
		cout << strv << Roman::ToInt(strv) << """";
		cout << strv << Roman::ToInt(strv) << """";
		cout << strv << Roman::ToInt(strv) << """";
	}
	catch (exception& e)
	{
		cerr << e.what();
		return -1;
	}
	return 0;
}
 "
" 
#include <windows.h>
#include <iostream>
#include <string>
 
//-------------------------------------------------------------------------------
using namespace std;
 
//-------------------------------------------------------------------------------
enum choices { ROCK, SPOCK, PAPER, LIZARD, SCISSORS, MX_C };
enum indexes { PLAYER, COMPUTER, DRAW };
 
//-------------------------------------------------------------------------------
class stats
{
public:
    stats() : _draw( 0 )
    {
        ZeroMemory( _moves, sizeof( _moves ) );
	ZeroMemory( _win, sizeof( _win ) );
    }
    void draw()		        { _draw++; }
    void win( int p )	        { _win[p]++; }
    void move( int p, int m )   { _moves[p][m]++; }
    int getMove( int p, int m ) { return _moves[p][m]; }
    string format( int a )
    {
	char t[32];
	wsprintf( t, strv, a );
	string d( t );
	return d;
    }
 
    void print()
    {
        string  d = format( _draw ),
	       pw = format( _win[PLAYER] ),		cw = format( _win[COMPUTER] ),
	       pr = format( _moves[PLAYER][ROCK] ),	cr = format( _moves[COMPUTER][ROCK] ),
               pp = format( _moves[PLAYER][PAPER] ),	cp = format( _moves[COMPUTER][PAPER] ),
	       ps = format( _moves[PLAYER][SCISSORS] ), cs = format( _moves[COMPUTER][SCISSORS] ),
	       pl = format( _moves[PLAYER][LIZARD] ),	cl = format( _moves[COMPUTER][LIZARD] ),
	       pk = format( _moves[PLAYER][SPOCK] ),	ck = format( _moves[COMPUTER][SPOCK] );
 
	system( strv );
	cout << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv  << pw << strv << pr << strv << pp << strv << ps << strv << pl << strv << pk << strv << endl;
	cout << strv << d << strv << endl;
	cout << strv  << cw << strv << cr << strv << cp << strv << cs << strv << cl << strv << ck << strv << endl;
	cout << strv << endl;
	cout << endl << endl;
 
	system( strv );
 
    }
 
private:
    int _moves[2][MX_C], _win[2], _draw;
};
//-------------------------------------------------------------------------------
class rps
{
private:
    int makeMove()
    {
	int total = 0, r, s;
	for( int i = 0; i < MX_C; total += statistics.getMove( PLAYER, i++ ) );
	r = rand() % total;
 
	for( int i = ROCK; i < SCISSORS; i++ )
	{
	    s = statistics.getMove( PLAYER, i );
	    if( r < s ) return ( i + 1 );
	    r -= s;
	}
 
	return ROCK;
    }
 
    void printMove( int p, int m )
    {
	if( p == COMPUTER ) cout << strv;
	else cout << strv;
 
	switch( m )
	{
	    case ROCK: cout << ""ROCK""; break;
	    case PAPER: cout << ""PAPER""; break;
	    case SCISSORS: cout << ""SCISSORS""; break;
	    case LIZARD: cout << ""LIZARD""; break;
	    case SPOCK: cout << ""SPOCK"";
	}
    }
 
public:
    rps()
    {
	checker[ROCK][ROCK] = 2; checker[ROCK][PAPER] = 1; checker[ROCK][SCISSORS] = 0; checker[ROCK][LIZARD] = 0; checker[ROCK][SPOCK] = 1;
	checker[PAPER][ROCK] = 0; checker[PAPER][PAPER] = 2; checker[PAPER][SCISSORS] = 1; checker[PAPER][LIZARD] = 1; checker[PAPER][SPOCK] = 0;
	checker[SCISSORS][ROCK] = 1; checker[SCISSORS][PAPER] = 0; checker[SCISSORS][SCISSORS] = 2; checker[SCISSORS][LIZARD] = 0; checker[SCISSORS][SPOCK] = 1;
	checker[LIZARD][ROCK] = 1; checker[LIZARD][PAPER] = 0; checker[LIZARD][SCISSORS] = 1; checker[LIZARD][LIZARD] = 2; checker[LIZARD][SPOCK] = 0;
	checker[SPOCK][ROCK] = 0; checker[SPOCK][PAPER] = 1; checker[SPOCK][SCISSORS] = 0; checker[SPOCK][LIZARD] = 1; checker[SPOCK][SPOCK] = 2;
    }
    void play()
    {
	int p, r, m;
	while( true )
	{
	    cout << strv;
	    cin >> p;
	    if( !p || p < 0 ) break;
	    if( p > 0 && p < 6 )
	    {
		p--;
		cout << endl;
		printMove( PLAYER, p );
		statistics.move( PLAYER, p );
 
		m = makeMove();
		statistics.move( COMPUTER, m );
		printMove( COMPUTER, m );
 
		r = checker[p][m];
		switch( r )
		{
		    case DRAW: 
		        cout << endl << strv << endl << endl; 
		        statistics.draw();
		    break;
		    case COMPUTER: 
			cout << endl << strv << endl << endl;  
			statistics.win( COMPUTER );
		    break;
		    case PLAYER: 
			cout << endl << strv << endl << endl; 
			statistics.win( PLAYER );
 
		}
		system( strv );
	    }
	    system( strv );
	}
	statistics.print();
    }
 
private:
    stats statistics;
    int checker[MX_C][MX_C];
};
//-------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( GetTickCount() );
    rps game;
    game.play();
    return 0;
}
//-------------------------------------------------------------------------------
 "
"#include <iostream>
#include <string>
#include <algorithm>
 
int main()
{
  std::string s;
  std::getline(std::cin, s);
  std::reverse(s.begin(), s.end()); 

  std::cout << s << std::endl;
  return 0;
}"
"#include <algorithm>
#include <array>
#include <cstdint>
#include <iostream>
#include <tuple>
 
std::tuple<int, int> minmax(const int * numbers, const std::size_t num) {
   const auto maximum = std::max_element(numbers, numbers + num);
   const auto minimum = std::min_element(numbers, numbers + num);
   return std::make_tuple(*minimum, *maximum) ;
}
 
int main( ) {
   const auto numbers = std::array<int, 8>{{17, 88, 9, 33, 4, 987, -10, 2}};
   int min{};
   int max{};
   std::tie(min, max) = minmax(numbers.data(), numbers.size());
   std::cout << strv << min << strv << max << ""!"" ;
}"
"class animal {
public:
  virtual void bark() 

  {
    throw strv;
  }
};
 
class elephant : public animal 

{
};
 
int main()
{
  elephant e;
  e.bark();  

}
 "
" 
#include <algorithm>
#include <functional>
#include <string>
#include <iostream>
#include <vector>
 
//code for a C++11 compliant compiler
template <class BidirectionalIterator, class T>
void block_reverse_cpp11(BidirectionalIterator first, BidirectionalIterator last, T const& separator) {
   std::reverse(first, last);
   auto block_last = first;
   do {
      using std::placeholders::_1;
      auto block_first = std::find_if_not(block_last, last, 
         std::bind(std::equal_to<T>(),_1, separator));
      block_last = std::find(block_first, last, separator);
      std::reverse(block_first, block_last);
   } while(block_last != last);
}
 
//code for a C++03 compliant compiler
template <class BidirectionalIterator, class T>
void block_reverse_cpp03(BidirectionalIterator first, BidirectionalIterator last, T const& separator) {
   std::reverse(first, last);
   BidirectionalIterator block_last = first;
   do {
      BidirectionalIterator block_first = std::find_if(block_last, last, 
         std::bind2nd(std::not_equal_to<T>(), separator));
      block_last = std::find(block_first, last, separator);
      std::reverse(block_first, block_last);
   } while(block_last != last);
}
 
int main() {
   std::string str1[] = 
    {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv
    };
 
   std::for_each(begin(str1), end(str1), [](std::string& s){
      block_reverse_cpp11(begin(s), end(s), ' ');
      std::cout << s << std::endl;
   });
 
   std::for_each(begin(str1), end(str1), [](std::string& s){
      block_reverse_cpp03(begin(s), end(s), ' ');
      std::cout << s << std::endl;
   });
 
   return 0;
}
  
#include <string>
#include <iostream>
using namespace std;
 
string invertString( string s )
{
    string st, tmp;
    for( string::iterator it = s.begin(); it != s.end(); it++ )
    {
        if( *it != 32 ) tmp += *it;
        else
        {
            st = strv + tmp + st;
            tmp.clear();
        }
    }
    return tmp + st;
}
 
int main( int argc, char* argv[] )
{
    string str[] = 
    {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv
    };
    for( int i = 0; i < 10; i++ )
        cout << invertString( str[i] ) << """";
 
    cout << """";
    return system( strv );
}
 "
"template <typename Function>
void repeat(Function f, unsigned int n) {
 for(unsigned int i=n; 0<i; i--)
  f();
}#include <iostream>
void example() {
 std::cout << ""Example"";
}
 
repeat(example, 4); repeat([]{std::cout << ""Example"";}, 4);"
"#include <string>
#include <iostream>
 
std::string repeat( const std::string &word, int times ) {
   std::string result ;
   result.reserve(times*word.length()); 

   for ( int a = 0 ; a < times ; a++ ) 
      result += word ;
   return result ;
}
 
int main( ) {
   std::cout << repeat( strv , 5 ) << std::endl ;
   return 0 ;
}#include <string>
#include <iostream>
 
int main( ) {
   std::cout << std::string( 5, '*' ) << std::endl ;
   return 0 ;
}"
"#include <string>
#include <vector>
#include <boost/regex.hpp>
 
bool is_repstring( const std::string & teststring , std::string & repunit ) {
   std::string regex( ""^(.+)1+(.*)$"" ) ;
   boost::regex e ( regex ) ;
   boost::smatch what ;
   if ( boost::regex_match( teststring , what , e , boost::match_extra ) ) {
      std::string firstbracket( what[1 ] ) ;
      std::string secondbracket( what[ 2 ] ) ;
      if ( firstbracket.length( ) >= secondbracket.length( ) &&
	    firstbracket.find( secondbracket ) != std::string::npos ) {
	 repunit = firstbracket  ;
      }
   }
   return !repunit.empty( ) ;
}
 
int main( ) {
   std::vector<std::string> teststrings { strv , strv , strv ,
      strv , strv , strv , strv , strv , strv , strv , strv } ;
   std::string theRep ;
   for ( std::string myString : teststrings ) {
      if ( is_repstring( myString , theRep ) ) {
	 std::cout << myString << "" is a rep string! Here is a repeating string:"" ;
	 std::cout << theRep << strv ;
      }
      else {
	 std::cout << myString << strv ;
      }
      theRep.clear( ) ;
      std::cout << std::endl ;
   }
   return 0 ;
}"
"#include <cstdio>
 
int main()
{
    std::rename(strv, strv);
    std::rename(strv, strv);
    std::rename(strv, strv);
    std::rename(strv, strv);
    return 0;
}#include strv
 
int main()
{
    boost::filesystem::rename(
        boost::filesystem::path(strv),
        boost::filesystem::path(strv));
    boost::filesystem::rename(
        boost::filesystem::path(strv),
        boost::filesystem::path(strv));
    boost::filesystem::rename(
        boost::filesystem::path(strv),
        boost::filesystem::path(strv));
    boost::filesystem::rename(
        boost::filesystem::path(strv),
        boost::filesystem::path(strv));*/
    return 0;
}"
"#include <fstream>
#include <iostream>
#include <string>
#include <cstdlib>
#include <list>
 
void deleteLines( const std::string & , int , int ) ;
 
int main( int argc, char * argv[ ] ) {
   if ( argc != 4 ) {
      std::cerr << ""Error! Invoke with <deletelines filename startline skipnumber>!"" ;
      return 1 ;
   }
   std::string filename( argv[ 1 ] ) ;
   int startfrom = atoi( argv[ 2 ] ) ;
   int howmany = atoi( argv[ 3 ] ) ;
   deleteLines ( filename , startfrom , howmany ) ;
   return 0 ;
}
 
void deleteLines( const std::string & filename , int start , int skip ) {
   std::ifstream infile( filename.c_str( ) , std::ios::in ) ;
   if ( infile.is_open( ) ) {
      std::string line ;
      std::list<std::string> filelines ;
      while ( infile ) {
	 getline( infile , line ) ;
	 filelines.push_back( line ) ;
      }
      infile.close( ) ;
      if ( start > filelines.size( ) ) {
	 std::cerr << ""Error! Starting to delete lines past the end of the file!"" ;
	 return ;
      }
      if ( ( start + skip ) > filelines.size( ) ) {
	 std::cerr << ""Error! Trying to delete lines past the end of the file!"" ;
	 return ;
      }
      std::list<std::string>::iterator deletebegin = filelines.begin( ) , deleteend ;
      for ( int i = 1 ; i < start ; i++ )
	 deletebegin++ ;
      deleteend = deletebegin ;
      for( int i = 0 ; i < skip ; i++ )
	 deleteend++ ;
      filelines.erase( deletebegin , deleteend ) ;
      std::ofstream outfile( filename.c_str( ) , std::ios::out | std::ios::trunc ) ;
      if ( outfile.is_open( ) ) {
	 for ( std::list<std::string>::const_iterator sli = filelines.begin( ) ;
	       sli != filelines.end( ) ; sli++ )
	    outfile << *sli << """" ;
      }
      outfile.close( ) ;
   }
   else {
      std::cerr << strv << filename << "" !"" ;
      return ;
   }
}"
"#include <set>
#include <iostream>
using namespace std;
 
int main() {
    typedef set<int> TySet;
    int data[] = {1, 2, 3, 2, 3, 4};
 
    TySet unique_set(data, data + 6);
 
    cout << strv << endl;
    for (TySet::iterator iter = unique_set.begin(); iter != unique_set.end(); iter++)
          cout << *iter << strv;
    cout << endl;
}#include <ext/hash_set>
#include <iostream>
using namespace std;
 
int main() {
    typedef __gnu_cxx::hash_set<int> TyHash;
    int data[] = {1, 2, 3, 2, 3, 4};
 
    TyHash unique_set(data, data + 6);
 
    cout << strv << endl;
    for (TyHash::iterator iter = unique_set.begin(); iter != unique_set.end(); iter++)
          cout << *iter << strv;
    cout << endl;
}#include <tr1/unordered_set>
#include <iostream>
using namespace std;
 
int main() {
    typedef tr1::unordered_set<int> TyHash;
    int data[] = {1, 2, 3, 2, 3, 4};
 
    TyHash unique_set(data, data + 6);
 
    cout << strv << endl;
    for (TyHash::iterator iter = unique_set.begin(); iter != unique_set.end(); iter++)
          cout << *iter << strv;
    cout << endl;
}#include <iostream>
#include <iterator>
#include <algorithm>
 


template<typename T> T* end(T (&array)[size]) { return array+size; }
 
int main()
{
  int data[] = { 1, 2, 3, 2, 3, 4 };
  std::sort(data, end(data));
  int* new_end = std::unique(data, end(data));
  std::copy(data, new_end, std::ostream_iterator<int>(std::cout, strv);
  std::cout << std::endl;
}#include <algorithm>
#include <iostream>
#include <vector>
 
int main() {
  std::vector<int> data = {1, 2, 3, 2, 3, 4};
 
  std::sort(data.begin(), data.end());
  data.erase(std::unique(data.begin(), data.end()), data.end());
 
  for(int& i: data) std::cout << i << strv;
  std::cout << std::endl;
  return 0;
}"
"#include <iostream>
#include <string>
#include <iterator>
#include <boost/regex.hpp>
 
int main()
{
  boost::regex re(strv);
  std::string s = strv;
 
  

  if (boost::regex_match(s, re))
    std::cout << ""The string matches."";
  else
    std::cout << ""Oops - not found?"";
 
  

  boost::regex re2(strv);
  boost::smatch match;
  if (boost::regex_search(s, match, re2))
  {
    std::cout << strv << match.length()
              << strv << match.position() << ""."";
    std::cout << ""Matched character sequence: ""
              << match.str() << """";
  }
  else
  {
    std::cout << ""Oops - not found?"";
  }
 
  

  std::string dest_string;
  boost::regex_replace(std::back_inserter(dest_string),
                       s.begin(), s.end(),
                       re2,
                       strv);
  std::cout << dest_string << std::endl;
}"
" 
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <set>
#include <regex>
using namespace std;
 
map<string, string> terminals;
map<string, vector<vector<string>>> nonterminalRules;
map<string, set<string>> nonterminalFirst;
map<string, vector<string>> nonterminalCode;
 
int main(int argc, char **argv) {
	if (argc < 3) {
		cout << strv << endl;
		return 1;
	}
 
	ifstream inFile(argv[1]);
	ofstream outFile(argv[2]);
 
	regex blankLine(Rstrv);
	regex terminalPattern(Rstrv);
	regex rulePattern(Rstrv);
	regex argPattern(Rstrv);
	smatch results;
 
	

	string line;
	while (true) {
		getline(inFile, line);
 
		

		if (regex_match(line, blankLine))
			break;
 
		regex_match(line, results, terminalPattern);
		terminals[results[1]] = results[2];
	}
 
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl << endl;
 
	

	outFile << strv << endl;
	outFile << strv << endl << endl;
 
	outFile << strv << endl;
	outFile << strv << endl << endl;
 
	outFile << strv << endl;
	outFile << strv << endl << endl;
 
	for (auto i = terminals.begin(); i != terminals.end(); ++i) {
		string name = i->first + strv;
		string pattern = i->second;
 
		outFile << strv << name << ""(R(^s*("" << pattern << "")));"" << endl;
		outFile << strv << name << strv << endl;
		outFile << ""		nextToken = "" << i->first << "";"" << endl;
		outFile << strv << endl;
		outFile << strv << name << "", );"" << endl;
		outFile << strv << endl;
		outFile << strv << endl << endl;
	}
 
	outFile << ""	static regex eof(R(s*));"" << endl;
	outFile << strv << endl;
	outFile << ""		nextToken = ;"" << endl;
	outFile << ""		nextTokenValue = ;"" << endl;
	outFile << strv << endl;
	outFile << strv << endl << endl;
 
	outFile << ""	throw Unknown token;"" << endl;
	outFile << strv << endl << endl;
 
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl << endl;
 
	

	while (true) {
		getline(inFile, line);
 
		

		if (regex_match(line, results, rulePattern))
			break;
 
		outFile << line << endl;
	}
 
	

	while (true) {
		

		string name = results[1];
		stringstream ss(results[2]);
 
		string tempString;
		vector<string> tempVector;
		while (ss >> tempString)
			tempVector.push_back(tempString);
		nonterminalRules[name].push_back(tempVector);
 
		

		string code = strv;
		while (true) {
			getline(inFile, line);
 
			if (!inFile || regex_match(line, results, rulePattern))
				break;
 
			

			line = regex_replace(line, argPattern, strv);
 
			code += line + """";
		}
		nonterminalCode[name].push_back(code);
 
		

		if (!inFile)
			break;
	}
 
	

	bool done = false;
	while (!done)
		for (auto i = nonterminalRules.begin(); i != nonterminalRules.end(); ++i) {
			string name = i->first;
			done = true; 
 
			if (nonterminalFirst.find(i->first) == nonterminalFirst.end())
				nonterminalFirst[i->first] = set<string>();
 
			for (int j = 0; j < i->second.size(); ++j) {
				if (i->second[j].size() == 0)
					nonterminalFirst[i->first].insert(strv);
				else {
					string first = i->second[j][0];
					if (nonterminalFirst.find(first) != nonterminalFirst.end()) {
						for (auto k = nonterminalFirst[first].begin(); k != nonterminalFirst[first].end(); ++k) {
							if (nonterminalFirst[name].find(*k) == nonterminalFirst[name].end()) {
								nonterminalFirst[name].insert(*k);
								done = false;
							}
						}
					} else if (nonterminalFirst[name].find(first) == nonterminalFirst[name].end()) {
						nonterminalFirst[name].insert(first);
						done = false;
					}
				}
			}
		}
 
	

	for (auto i = nonterminalRules.begin(); i != nonterminalRules.end(); ++i) {
		string name = i->first + strv;
		outFile << strv << name << strv << endl;
	}
	outFile << endl;
 
	

	for (auto i = nonterminalRules.begin(); i != nonterminalRules.end(); ++i) {
		string name = i->first + strv;
		outFile << strv << name << strv << endl;
		outFile << strv << endl;
		outFile << ""	results.push_back();"" << endl << endl;
 
		

		int epsilon = -1;
		for (int j = 0; epsilon == -1 && j < i->second.size(); ++j)
			if (i->second[j].size() == 0)
				epsilon = j;
 
		

		for (int j = 0; j < i->second.size(); ++j) {
			

			if (j == epsilon)
				continue;
 
			string token = i->second[j][0];
			if (terminals.find(token) != terminals.end())
				outFile << ""	if (nextToken == "" << i->second[j][0] << "") {"" << endl;
			else {
				outFile << strv;
				bool first = true;
				for (auto k = nonterminalFirst[token].begin(); k != nonterminalFirst[token].end(); ++k, first = false) {
					if (!first)
						outFile << strv;
					outFile << ""nextToken == "" << (*k) << """";
				}
				outFile << strv << endl;
			}
 
			for (int k = 0; k < i->second[j].size(); ++k) {
				if (terminals.find(i->second[j][k]) != terminals.end()) {
					outFile << ""		if(same("" << i->second[j][k] << ""))"" << endl;
					outFile << strv << endl;
					outFile << strv << endl;
					outFile << ""			throw Syntax error - mismatched token;"" << endl;
				} else
					outFile << strv << i->second[j][k] << strv << endl;
			}
 
			

			outFile << nonterminalCode[i->first][j];
 
			outFile << strv << endl << endl;
		}
 
		if (epsilon == -1)
			outFile << ""	throw Syntax error - unmatched token;"" << endl;
		else
			outFile << nonterminalCode[i->first][epsilon];
 
		outFile << strv << endl << endl;
	}
 
	

	outFile << strv << endl;
	outFile << strv << endl;
	outFile << ""		cout << Usage: <input file> << endl;"" << endl;
	outFile << strv << endl;
	outFile << strv << endl << endl;
 
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << ""	input = ;"" << endl << endl;
 
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << strv << endl;
	outFile << ""		input += line + n;"" << endl;
	outFile << strv << endl << endl;
 
	outFile << strv << endl << endl;
 
	outFile << strv << endl;
	outFile << strv << endl;
}
 "
" 
#include <iostream>
#include <string>
#include <windows.h>
#include <mmsystem.h>
 
#pragma comment ( lib, strv )
using namespace std;
 
class recorder
{
public:
    void start()
    {
	paused = rec = false; action = strv;
	while( true )
	{
	    cout << endl << strv << action << strv << endl << endl;
	    cout << strv << endl << strv << endl << strv << endl << strv << endl << strv << endl;
	    char c; cin >> c;
	    if( c > '0' && c < '6' )
	    {
		switch( c )
		{
		    case '1': record(); break;
		    case '2': play();   break;
		    case '3': pause();  break;
		    case '4': stop();   break;
		    case '5': stop();   return;
		}
	    }
	}
    }
private:
    void record()
    {
	if( mciExecute( strv) )
	{ 
	    mciExecute( strv ); 
	    action = strv; rec = true; 
	}
    }
    void play()
    {
	if( paused )
	    mciExecute( strv );
	else
	    if( mciExecute( strv ) )
		mciExecute( strv );
 
	action = strv;
	paused = false;
    }
    void pause()
    {
	if( rec ) return;
	mciExecute( strv );
	paused = true; action = strv;
    }
    void stop()
    {
	if( rec )
	{
	    mciExecute( strv );
	    mciExecute( strv );
	    mciExecute( strv );
	    action = strv; rec = false;
	}
	else
	{
	    mciExecute( strv );
	    mciExecute( strv );
	    action = strv;
	}
    }
    bool mciExecute( string cmd )
    {
	if( mciSendString( cmd.c_str(), NULL, 0, NULL ) )
	{
	    cout << strv << cmd << endl;
	    return false;
	}
	return true;
    }
 
    bool paused, rec;
    string action;
};
 
int main( int argc, char* argv[] )
{
    recorder r; r.start();
    return 0;
}
 "
"#include <algorithm> // for std::swap
#include <cstddef>
#include <cassert>
 










//




































//




template<typename MatrixType> struct matrix_traits
{
  typedef typename MatrixType::index_type index_type;
  typedef typename MatrixType::value_type value_type;
  static index_type min_row(MatrixType const& A)
  { return A.min_row(); }
  static index_type max_row(MatrixType const& A)
  { return A.max_row(); }
  static index_type min_column(MatrixType const& A)
  { return A.min_column(); }
  static index_type max_column(MatrixType const& A)
  { return A.max_column(); }
  static value_type& element(MatrixType& A, index_type i, index_type k)
  { return A(i,k); }
  static value_type element(MatrixType const& A, index_type i, index_type k)
  { return A(i,k); }
};
 




template<typename T, std::size_t rows, std::size_t columns>
 struct matrix_traits<T[rows][columns]>
{
  typedef std::size_t index_type;
  typedef T value_type;
  static index_type min_row(T const (&)[rows][columns])
  { return 0; }
  static index_type max_row(T const (&)[rows][columns])
  { return rows-1; }
  static index_type min_column(T const (&)[rows][columns])
  { return 0; }
  static index_type max_column(T const (&)[rows][columns])
  { return columns-1; }
  static value_type& element(T (&A)[rows][columns],
                             index_type i, index_type k)
  { return A[i][k]; }
  static value_type element(T const (&A)[rows][columns],
                            index_type i, index_type k)
  { return A[i][k]; }
};
 






template<typename MatrixType>
 void swap_rows(MatrixType& A,
                 typename matrix_traits<MatrixType>::index_type i,
                 typename matrix_traits<MatrixType>::index_type k)
{
  matrix_traits<MatrixType> mt;
  typedef typename matrix_traits<MatrixType>::index_type index_type;
 
  

  assert(mt.min_row(A) <= i);
  assert(i <= mt.max_row(A));
 
  assert(mt.min_row(A) <= k);
  assert(k <= mt.max_row(A));
 
  for (index_type col = mt.min_column(A); col <= mt.max_column(A); ++col)
    std::swap(mt.element(A, i, col), mt.element(A, k, col));
}
 


template<typename MatrixType>
 void divide_row(MatrixType& A,
                  typename matrix_traits<MatrixType>::index_type i,
                  typename matrix_traits<MatrixType>::value_type v)
{
  matrix_traits<MatrixType> mt;
  typedef typename matrix_traits<MatrixType>::index_type index_type;
 
  assert(mt.min_row(A) <= i);
  assert(i <= mt.max_row(A));
 
  assert(v != 0);
 
  for (index_type col = mt.min_column(A); col <= mt.max_column(A); ++col)
    mt.element(A, i, col) /= v;
}
 


template<typename MatrixType>
 void add_multiple_row(MatrixType& A,
                  typename matrix_traits<MatrixType>::index_type i,
                  typename matrix_traits<MatrixType>::index_type k,
                  typename matrix_traits<MatrixType>::value_type v)
{
  matrix_traits<MatrixType> mt;
  typedef typename matrix_traits<MatrixType>::index_type index_type;
 
  assert(mt.min_row(A) <= i);
  assert(i <= mt.max_row(A));
 
  assert(mt.min_row(A) <= k);
  assert(k <= mt.max_row(A));
 
  for (index_type col = mt.min_column(A); col <= mt.max_column(A); ++col)
    mt.element(A, i, col) += v * mt.element(A, k, col);
}
 


template<typename MatrixType>
 void to_reduced_row_echelon_form(MatrixType& A)
{
  matrix_traits<MatrixType> mt;
  typedef typename matrix_traits<MatrixType>::index_type index_type;
 
  index_type lead = mt.min_row(A);
 
  for (index_type row = mt.min_row(A); row <= mt.max_row(A); ++row)
  {
    if (lead > mt.max_column(A))
      return;
    index_type i = row;
    while (mt.element(A, i, lead) == 0)
    {
      ++i;
      if (i > mt.max_row(A))
      {
        i = row;
        ++lead;
        if (lead > mt.max_column(A))
          return;
      }
    }
    swap_rows(A, i, row);
    divide_row(A, row, mt.element(A, row, lead));
    for (i = mt.min_row(A); i <= mt.max_row(A); ++i)
    {
      if (i != row)
        add_multiple_row(A, i, row, -mt.element(A, i, lead));
    }
  }
}
 


#include <iostream>
 
int main()
{
  double M[3][4] = { {  1, 2, -1,  -4 },
                     {  2, 3, -1, -11 },
                     { -2, 0, -3,  22 } };
 
  to_reduced_row_echelon_form(M);
  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 4; ++j)
      std::cout << M[i][j] << '';
    std::cout << """";
  }
 
  return EXIT_SUCCESS;
}"
"#include <iostream>
#include <cmath>
 
#ifdef M_E
static double euler_e = M_E;
#else
static double euler_e = std::exp(1); 

#endif
 
#ifdef M_PI
static double pi = M_PI;
#else
static double pi = std::acos(-1);
#endif
 
int main()
{
  std::cout << strv << euler_e
            << ""pi = "" << pi
            << ""sqrt(2) = "" << std::sqrt(2.0)
            << ""ln(e) = "" << std::log(e)
            << ""lg(100) = "" << std::log10(100.0)
            << ""exp(3) = "" << std::exp(3.0)
            << ""|-4.5| = "" << std::abs(-4.5)   

            << ""floor(4.5) = "" << std::floor(4.5)
            << ""ceiling(4.5) = "" << std::ceil(4.5)
            << ""pi^2 = "" << std::pow(pi,2.0) << std::endl;
}"
"#include <iostream>
#include <fstream>
#include <string>
#include <iterator>
 
int main( ) 
{
    if (std::ifstream infile(strv))
    {
        

        std::string fileData(std::istreambuf_iterator<char>(infile), std::istreambuf_iterator<char>());
 
        cout << strv << fileData.size() << ""chars"";
 
        

        return 0;
   }
   else 
   {
      std::cout << ""file not found!"";
      return 1;
   }
}
 "
"#include <fstream>
#include <string>
#include <iostream>
 
int main( int argc , char** argv ) {
   int linecount = 0 ;
   std::string line ;
   std::ifstream infile( argv[ 1 ] ) ;
   if ( infile ) {
      while ( getline( infile , line ) ) {
	 std::cout << linecount << strv << line << '' ;//supposing '\n' to be line end
	 linecount++ ;
      }
   }
   infile.close( ) ;
   return 0 ;
}#include <Core/Core.h>
 
using namespace Upp;
 
CONSOLE_APP_MAIN
{
	FileIn in(CommandLine()[0]);
	while(in && !in.IsEof())
		Cout().PutLine(in.GetLine());
}"
" 
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <iomanip>
 
#define msg0 strv
#define msg1 strv
#define msg2 strv
#define msg3 strv
#define msg4 strv
 
typedef unsigned char u8;
 
enum direction {
    UP, DOWN, LEFT, RIGHT
};
 
class stackFrame {
public:
    stackFrame() { }
    stackFrame( int ipc, int ipl, direction dir) :
    IPC( ipc ), IPL( ipl ), DIR( dir ) { }
    int IPC, IPL;
    direction DIR;
} ;
 
class SNUSP {
public:
    SNUSP() : IPC( 0 ), IPL( 0 ), MPT( 0 ), DIR( RIGHT ) { 
        memory.push_back( 0 ); 
    }
 
    ~SNUSP() { 
        memory.clear();
        code.clear();
    }
 
    void run( std::string filename, bool lg ) {
        logging = lg;
        if( logging ) {
            std::ofstream o( strv, std::ios_base::trunc );
            strm << ""+------+-------+-------+-------+-------+-------+| INST |  IPC  |  IPL  |  MPT  |  DIR  |  MEM  |"";
            log( strm.str() );
        }
 
        if( !openFile( filename ) ) {
            std::cout << strv << filename << ""'"";
            return;
        }
 
        while( execute( code[IPL][IPC] ) );
        std::cout << """" << memory[MPT];
    }
private:
    bool execute( u8 u ) {
        stackFrame sf;
        switch( u ) {
            case '<':
                if( --MPT < 0 ) {
                    if( logging ) log( msg4 );
                    return false;
                }
            break;
            case '>':
                if( ++MPT >= static_cast<int>( memory.size() ) ) { memory.push_back( 0 ); }
            break;
            case '+':
                memory[MPT]++;
            break;
            case '-':
                memory[MPT]--;
            break;
            case ',':
                std::cin >> memory[MPT];
            break;
            case '.':
                std::cout << static_cast<u8>( memory[MPT] );
            break;
            case '!':
                if( step() ) {
                    if( logging ) log( msg3 );
                    return false;
                }
            break;
            case '?':
                if( !memory[MPT] ) {
                    if( step() ) {
                        if( logging ) log( msg2 );
                        return false;
                    }
                }
            break;
            case '@':
                stack.push_back( stackFrame( IPC + ( DIR == RIGHT ? 1 : DIR == LEFT ? -1 : 0 ), 
                                             IPL + ( DIR == DOWN  ? 1 : DIR == UP   ? -1 : 0 ), DIR ) );
            break;
            case '#':
                if( !stack.size() ) {
                    if( logging ) log( msg1);
                    return false;
                }
                sf = stack.back();
                stack.pop_back();
                IPC = sf.IPC; IPL = sf.IPL; DIR = sf.DIR;
            break;
            case '/':
                DIR = DIR == RIGHT ? UP : DIR == LEFT ? DOWN : DIR == DOWN ? LEFT : RIGHT;
            break;
            case '':
                DIR = DIR == RIGHT ? DOWN : DIR == LEFT ? UP : DIR == DOWN ? RIGHT : LEFT;
            break;
        }
 
        if( logging ) {
            strm << strv << std::setw( 5 ) << u  << strv << std::setw( 6 ) << IPC << strv << std::setw( 6 ) 
            << IPL << strv << std::setw( 6 ) << MPT << strv << std::setw( 6 ) << DIR << strv << std::setw( 6 )           << memory[MPT] << strv;
            log( strm.str() );
        }
 
        if( step() ) {
            if( logging ) log( msg0 );
            return false;
        }
 
        return true;
    }
 
    bool step() {
        IPC += DIR == RIGHT ? 1 : DIR == LEFT ? -1 : 0;
        IPL += DIR == DOWN  ? 1 : DIR == UP   ? -1 : 0;
        return ( IPL >= static_cast<int>( code.size() ) || IPL < 0 || 
                 IPC >= static_cast<int>( code[IPL].length() ) || IPC < 0 );
    }
 
    bool openFile( std::string filename ) {
        std::ifstream in;
        in.open( filename.c_str() );
        if( !in.good() ) {
            return false;
        }
 
        std::string line;
        size_t max_len = 0, len;
        while( std::getline( in, line ) ) {
            len = line.length();
            if( max_len < len ) max_len = len;
            code.push_back( line );
            if( !IPC && !IPL ) {
                std::size_t i = static_cast<int>( line.find( '$' ) );
                if( i < line.npos ) {
                    IPL = code.size() - 1;
                    IPC = i;
                }
            }
        }
        in.close();
 
        for( std::vector<std::string>::iterator i = code.begin(); i != code.end(); i++ ) {
            if( ( *i ).length() < max_len ) ( *i ).insert( ( *i ).end(), max_len - ( *i ).length(), ' ' );
        }
        return true;
    }
 
    void log( std::string msg )
    {
        std::ofstream logDegug( strv, std::ios_base::out | std::ios_base::app );
        logDegug << msg << ""+------+-------+-------+-------+-------+-------+"" << std::endl;
        strm.str( strv );
    }
 
    std::vector<std::string>            code;
    std::vector<stackFrame>             stack;
    std::vector<int>                    memory;
    std::stringstream                   strm;
    int                                 IPC, IPL, MPT;
    direction                           DIR;
    bool                                logging;
};
 
int main( int argc,  char* argv[] ) {
    if( argc < 2 ) {
        std::cout << ""Doh!!!Usage:[/L] Filename/LLog each command to a log file"";
    } else {
        SNUSP s;
        s.run( argv[argc == 3 ? 2 : 1], ( argv[1][0] == '/' && toupper( argv[1][1] ) == 'L' ) );
    }
    std::cout << """";
    return 0;
}
 "
"#include strv
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <boost/tokenizer.hpp>
#include <boost/algorithm/string/case_conv.hpp>
using namespace std;
using namespace boost;
 
typedef boost::tokenizer<boost::char_separator<char> > Tokenizer;
static const char_separator<char> sep(strv,strv);
 
//Assume that the config file represent a struct containing all the parameters to load
struct configs{
	string fullname;
	string favoritefruit;
	bool needspelling;
	bool seedsremoved;
	vector<string> otherfamily;
} conf;
 
void parseLine(const string &line, configs &conf)
{
	if (line[0] == '#' || line.empty())
		return;
	Tokenizer tokenizer(line, sep);
	vector<string> tokens;
	for (Tokenizer::iterator iter = tokenizer.begin(); iter != tokenizer.end(); iter++)
		tokens.push_back(*iter);
	if (tokens[0] == strv){
		algorithm::to_lower(tokens[1]);
		if (tokens[1] == strv)
			conf.needspelling = false;
		if (tokens[1] == strv)
			conf.seedsremoved = false;
	}
	algorithm::to_lower(tokens[0]);
	if (tokens[0] == strv)
		conf.needspelling = true;
	if (tokens[0] == strv)
		conf.seedsremoved = true;
	if (tokens[0] == strv){
		for (unsigned int i=1; i<tokens.size(); i++)
			conf.fullname += tokens[i] + strv;
		conf.fullname.erase(conf.fullname.size() -1, 1);
	}
	if (tokens[0] == strv) 
		for (unsigned int i=1; i<tokens.size(); i++)
			conf.favoritefruit += tokens[i];
	if (tokens[0] == strv){
		unsigned int i=1;
		string tmp;
		while (i<=tokens.size()){		
			if ( i == tokens.size() || tokens[i] ==strv){
				tmp.erase(tmp.size()-1, 1);
				conf.otherfamily.push_back(tmp);
				tmp = strv;
				i++;
			}
			else{
				tmp += tokens[i];
				tmp += strv;
				i++;
			}
		}
	}
}
 
int _tmain(int argc, TCHAR* argv[])
{
	if (argc != 2)
	{
		wstring tmp = argv[0];
		wcout << Lstrv << tmp << Lstrv << endl;
		return -1;
	}
	ifstream file (argv[1]);
 
	if (file.is_open())
		while(file.good())
		{
			char line[255];
			file.getline(line, 255);
			string linestring(line);
			parseLine(linestring, conf);
		}
	else
	{
		cout << strv << endl;
		return -2;
	}
 
	cout << strv << conf.fullname << endl;
	cout << strv << conf.favoritefruit << endl;
	cout << strv << (conf.needspelling?strv:strv) << endl;
	cout << strv << (conf.seedsremoved?strv:strv) << endl;
	string otherFamily;
	for (unsigned int i = 0; i < conf.otherfamily.size(); i++)
		otherFamily += conf.otherfamily[i] + strv;
	otherFamily.erase(otherFamily.size()-2, 2);
	cout << strv << otherFamily << endl;
 
	return 0;
}
 #include <iostream>
#include <iomanip>
#include <string>
#include <exception>
#include <fstream>
#include <vector>
#include <algorithm>
 
struct confi {
	std::string fullname;
	std::string favouritefruit;
	bool needspeeling;
	bool seedsremoved;
	std::vector<std::string> otherfamily;
};
 
void read_config(std::ifstream& in, confi& out) {
	in.open(strv);
	std::string str;
	out.needspeeling = false;
	out.seedsremoved = false;
	while(!in.eof()) {
		while(getline(in,str)) {
			std::string::size_type begin = str.find_first_not_of("" "");
			//Skips blank lines
			if(begin == std::string::npos)
				continue;
			//Skips #
			if(std::string(strv).find(str[begin]) != std::string::npos)
				continue;
			std::string firstWord;
			try {
				firstWord = str.substr(0,str.find(strv));
			}
			catch(std::exception& e) {
				firstWord = str.erase(str.find_first_of(strv),str.find_first_not_of(strv));
			}
			std::transform(firstWord.begin(),firstWord.end(),firstWord.begin(), ::toupper);
			if(firstWord == strv)
				out.fullname = str.substr(str.find(strv)+1,str.length());
			if(firstWord == strv)
				out.favouritefruit = str.substr(str.find(strv)+1,str.length());
			if(firstWord == strv)
				out.needspeeling = true;
			if(firstWord == strv)
				out.seedsremoved = true;
			if(firstWord == strv) {
				size_t found = str.find(strv);
				if(found != std::string::npos) {
					out.otherfamily.push_back(str.substr(str.find_first_of(strv)+1,found-str.find_first_of(strv)-1));
					out.otherfamily.push_back(str.substr(found+2,str.length()));
				}
			}
 
		}
	}
	std::cout << strv << out.fullname << std::endl;
	std::cout << strv << out.favouritefruit << std::endl;
	std::cout << strv;
	if(out.needspeeling == true)
		std::cout << strv << std::endl;
	else
		std::cout << strv << std::endl;
	std::cout << strv;
	if(out.seedsremoved == true)
		std::cout << strv << std::endl;
	else
		std::cout << strv << std::endl;
	std::cout << strv << out.otherfamily[0] << strv << out.otherfamily[1] << std::endl;
}
int main() {
	std::ifstream inp;
	confi outp;
	read_config(inp,outp);
}
 "
" 
#include <stdio.h>
#include <time.h>
#include <iostream>
#include <algorithm>
#include <map>
#include <vector>
#include <sstream>
 
typedef unsigned uint;
 
const std::string directions[] = { strv, strv, strv, strv, strv, strv };
const std::string objectName[] = { strv, strv, strv, strv };
const uint MAX_DOORS = sizeof( directions ) / sizeof( directions[0] ), MX_R = 26;
 
enum keyWord { north, south, east, west, up, down, inventory, unequip, look, help, quit, attack, drop, take, equip, alias, name, all, nothing, gold, ladder, sledge };
const keyWord inverted[] = { south, north, west, east, down, up };
 
class position
{
public:
    position() : x(0), y(0), z(0) { }
    position( int a, int b, int c ) : x(a), y(b), z(c) { }
    void set( int a, int b, int c ) {
         x = a; y = b; z = c;
    }
    bool operator ==( const position o ) { 
        return o.x == x && o.y == y && o.z == z; 
    }
    position& operator =( position o ) {
        x = o.x; y = o.y; z = o.z; 
        return *this;
    }
    position& operator +=( const position& o ) {
        x += o.x; y += o.y; z += o.z;
        return *this; 
    }
    friend position operator+( position l, const position& r ) {
        return l += r;
    }
    int    x, y, z;
};
 
const position dirVec[] = { position( 0, -1, 0 ), position( 0, 1, 0 ), position( 1, 0, 0 ), position( -1, 0, 0 ), position( 0, 0, -1 ), position( 0, 0, 1 ) };
 
typedef struct {
    keyWord action, subKey;
    std::string str1, str2;
}command;
 
typedef void ( *callee )( command );
 
class parser
{
public:
    parser() {
        std::string c[] = { directions[0], directions[1], directions[2], directions[3], directions[4], directions[5], strv, strv, 
            strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, objectName[0], objectName[1], objectName[2], objectName[3] };
        for( uint i = 0; i < sizeof( c ) / sizeof( c[0] ); i++ ) {
            actions.insert( std::make_pair( hashStr( c[i] ), static_cast<keyWord>( i ) ) );
            names.insert( std::make_pair( static_cast<keyWord>( i ), c[i] ) );
        }
    }
    void addAlias( std::string or, std::string nw ) {
        std::map<uint, keyWord>::iterator it = actions.find( hashStr( or ) );
        if( it == actions.end() ) { 
            std::cout << strv + or + "" doesn't seem to exist!""; 
            return; 
        }
        actions.insert( std::make_pair( hashStr( nw ), it->second ) );
        std::cout << ""Done"";
    }
    bool parse( std::string a, command& cmd ) {
        std::transform( a.begin(), a.end(), a.begin(), ::tolower );
        std::istringstream iss( a ); 
        std::vector<std::string> vec;
        copy( std::istream_iterator<std::string>( iss ), std::istream_iterator<std::string>(), std::back_inserter<std::vector<std::string> >( vec ) );
        std::map<uint, keyWord>::iterator it = actions.find( hashStr( vec[0] ) );
        if( it == actions.end() ) { 
            std::cout << strv + vec[0] + ""' doesn't make any sense!""; 
            return false; 
        }
        cmd.action = it->second; 
        if( cmd.action < attack ) return  true;
        if( cmd.action < name ) {
            if( vec.size() < 2 ) { 
                std::cout << strv + names[cmd.action] + ""'?""; 
                return false; 
            }
            if( !vec[1].compare( strv ) || !vec[1].compare( strv ) ) vec[1] = strv;
            it = actions.find( hashStr( vec[1] ) );
            if( it == actions.end() ) { 
                std::cout << strv + vec[1] + ""' means.""; 
                return false; 
            }
            cmd.subKey = it->second;
            if( cmd.action == alias ) {
                if( vec.size() < 3 ) { 
                    std::cout << ""Aren't you forgetting something?""; 
                    return false; 
                }
                std::map<uint, keyWord>::iterator it = actions.find( hashStr( vec[2] ) );
                if( it != actions.end() ) { 
                    std::cout << strv + vec[2] + ""' is already a keyword!""; 
                    return false; 
                }
                if( cmd.subKey > name ) { 
                    std::cout << strv + vec[1] + ""' is allowed!""; 
                    return false; 
                }
                cmd.str1 = vec[1]; 
                cmd.str2 = vec[2];
            }
            return true;
        }
        if( cmd.action == name ) { 
            if( vec.size() < 2 ) { 
                std::cout << ""What name?""; 
                return false; 
            }
            cmd.str1 = vec[1]; 
            return true; 
        }
        std::cout << strv + vec[0] + ""'!""; 
        return false;
    }
private:
    unsigned hashStr( std::string s ) {
        unsigned wrd = 0x4e67c6a7, p = 0;
        while( p < s.length() ) 
            wrd ^= ( ( wrd << 5 ) + s[p++] + ( wrd >> 2 ) );
        return wrd;
    }
    std::map<uint, keyWord> actions;
    std::map<keyWord, std::string> names;
};
 
class treasure
{
public:
    treasure( keyWord k, uint c ) : key(k), cnt(c) { }
    keyWord key;
    uint cnt;
};
 
class box
{
public:
    void display() {
        if( !stuff.size() ) { 
            std::cout << objectName[0] + "".""; 
            return; 
        }
        std::ostringstream oss;
        for( std::map<keyWord, uint>::iterator it = stuff.begin(); it != stuff.end(); it++ ) {
            if( it->second > 0 ) {
                oss << strv << it->second << strv << objectName[it->first - nothing]; std::cout << oss.str();
                if( it->first == gold ) std::cout << ( it->second > 1 ? strv : strv );
                else std::cout << ( it->second > 1 ? strv : strv );
                std::cout << """"; 
                oss.str( strv );
            }
        }
        std::cout << """";
    }
    void stow( std::vector<treasure> t ) {
        for( std::vector<treasure>::iterator i = t.begin(); i != t.end(); i++ ) {
            std::map<keyWord, uint>::iterator it = stuff.find( ( *i ).key );
            if( it == stuff.end() ) stuff.insert( std::make_pair( ( *i ).key, ( *i ).cnt ) ); 
            else it->second += ( *i ).cnt;
        }
    }
    std::vector<treasure> dump( keyWord k, uint c = 0 ) {
        std::vector<treasure> t;
        if( k == all ) {
            for( std::map<keyWord, unsigned>::iterator it = stuff.begin(); it != stuff.end(); it++ ) {
                t.push_back( treasure( ( *it ).first, ( *it ).second ) );
            }
            stuff.clear();
        }
        else {
            std::map<keyWord, unsigned>::iterator it = stuff.find( k );
            if( it == stuff.end() ) return t;
            uint z = ( it->second ); 
            c = k == ladder ? 1 : !c ? z : c;
            it->second -= c; 
            if( !it->second ) stuff.erase( it );
            t.push_back( treasure( k, c ) );
        }
        return t;
    }
    size_t size() {
        return stuff.size();
    }
    uint count( keyWord k ) {
        std::map<keyWord, unsigned>::iterator it = stuff.find( k );
        if( it != stuff.end() ) return ( *it ).second;
        return 0;
    }
private:
    std::map<keyWord, uint> stuff;
};
 
class room
{
public:
    room( std::string n ) : name(n), visited(false) {
        memset( bRooms, 0, sizeof( bRooms ) ); 
        memset( ladderZ, 0, sizeof( ladderZ ) ); 
    }
    void describe() {
        std::cout << ""** Room: "" + name + "" **""; 
        std::vector<std::string> ex; 
        getExits( ex );
        if( !ex.size() ) std::cout << ""There are no exits from this room."";
        else {
            std::cout << strv;
            for( std::vector<std::string>::iterator x = ex.begin(); x != ex.end(); x++ ) {
                std::cout << *x + strv;
            }
            std::cout << """";
        }
        if( loot.size() ) {
            std::cout << ""Here you can see:""; 
            loot.display();
            return;
        }
        std::cout << ""You see nothing useful here.""; 
    }
    room* atk( keyWord d, uint lvl ) {
        if( bRooms[d] ) return 0;
        room* r = new room( strv ); 
        bRooms[d] = r->bRooms[inverted[d]] = true;
        r->addLoot( false, lvl );
        return r;
    }
    void addLoot( bool forceSledge, uint lvl ) {
        std::vector<treasure> t;
        if( forceSledge ) t.push_back( treasure( sledge, 1 ) );
        else if( rand() % 10 > 6 )  t.push_back( treasure( sledge, 1 ) );
        if( rand() % 10 > 6 ) t.push_back( treasure( gold, rand() % 8 + 1 ) );
        if( rand() % 10 == 2 || ( !ladderZ[lvl] && rand() % 10 < 5 ) ) {
            t.push_back( treasure( ladder, 1 ) ); 
            ladderZ[lvl] = true;
        }
        loot.stow( t );
    }
    void setName( std::string n ) {
        name = n;
        std::cout << ""OK"";
    }
    std::vector<treasure> tak( keyWord k ) {
        return loot.dump( k );
    }
    void drp( std::vector<treasure> t ) {
        loot.stow( t );
    }
    uint count( keyWord k ) {
        return loot.count( k );
    }
    void setVisited() {
        visited = true;
        lastTime = time( 0 );
    }
    bool wasVisited() {
        return visited;
    }
    time_t lastTimeVisited() {
        return lastTime;
    }
    void getExits( std::vector<std::string>& ex ) {
        for( uint x = 0; x < MAX_DOORS; x++ )
            if( bRooms[x] )
                ex.push_back( directions[x] );
    }
private:
    std::string    name;
    box loot;
    time_t lastTime;
    bool bRooms[MAX_DOORS], ladderZ[MX_R], visited;
};
 
class player
{
public:
    player() : curRoom(0) { }
    ~player() {
        deleteRooms();
    }
    void init() {
        equipped = nothing; deleteRooms();
        curRoom = new room( strv ); 
        curRoom->setVisited(); 
        curRoom->addLoot( true, pos.z );
        do pos.set( rand() % MX_R, rand() % MX_R, rand() % MX_R );
        while( pos.x == 8 && pos.y == 8 && pos.z == 8 ); 
        cave.insert( std::make_pair( pos.x + pos.y * MX_R + MX_R * MX_R * pos.z, curRoom ) );
        lok();
    }
    void lok() {
        curRoom->describe();
        if( equipped > nothing ) std::cout << strv << objectName[equipped - nothing] << """";
    }
    void une() {
        if( equipped == nothing ) { 
            std::cout << ""You are equipped with nothing!""; 
            return; 
        }
        equipped = nothing;
        std::cout << ""Done"";
    }
    void inv() {
        std::cout << strv; 
        std::cout << ( !loot.size() ? strv : "":"" );
        loot.display();
    }
    void tak( keyWord k ) {
        if( k < gold && k != all ) { 
            std::cout << ""I don't know how to do that!""; 
            return; 
        }
        if( k == ladder && loot.count( k ) ) { 
            std::cout << ""These things are so heavy, you can't carry more than one!""; 
            return; 
        }
        std::vector<treasure> t = curRoom->tak( k );
        if( !t.size() ) {
            if( k == all ) std::cout << ""There is nothing here to take!"";
            else std::cout << ""I can't take what's not here!"";
            return;
        }
        loot.stow( t );
        if( k == all ) {
            uint lc = loot.count( ladder );
            while( lc > 1 ) {
                drp( ladder, true );
                lc--;
            }
        }
        std::cout << ""Taken"";
    }
    void equ( keyWord k ) {
        if( k < sledge ) { 
            std::cout << ""I don't know how to equip this!""; 
            return; 
        }
        if( equipped != nothing ) return;
 
        if( !loot.count( k ) ) { 
            std::cout << strv; 
            return; 
        }
        equipped = k;
        std::cout << ""OK"";
    }
    bool atk( keyWord k ) {
        if( equipped == nothing ) { 
            std::cout << ""I cannot let you hurt yourself!""; 
            return true; 
        }
        if( checkBoundaries( k ) ) { 
            std::cout << ""The rocks here are too hard, you broke your sledge!""; 
            equipped = nothing; 
            std::vector<std::string> ex;
            curRoom->getExits( ex );
            if( !ex.size() ) {
                std::cout << ""Unfortunately you are trapped in here ---- FOREVER!""
                             ""*** G A M E * O V E R ***"";
                return false;
            }
            return true; 
        }
        uint lvl = pos.z + k == up ? -1 : k == down ? 1 : 0;
        room* r = curRoom->atk( k, lvl );
        if( !r ) { 
            std::cout << ""There is already a doorway there!""; 
            return true; 
        }
        position p = pos + dirVec[k]; 
        cave.insert( std::make_pair( p.x + MX_R * p.y + MX_R * MX_R * p.z, r ) );
        std::cout << ""KA-POW!"";
    }
    void mov( keyWord d ) {
        if( d > down ) { 
            std::cout << ""I don't know how to move in that direction!""; 
            return; 
        }
        if( d == up && loot.count( ladder ) ) { 
            std::cout << ""You are not strong enough to climb up there carrying a ladder!""; 
            return; 
        }
        position p = pos + dirVec[d];
        std::map<uint, room*>::iterator it = cave.find( p.x + MX_R * p.y + MX_R * MX_R * p.z );
        if( it == cave.end() ) {
            std::cout << strv; 
            if( d == up ) std::cout << strv;
            else if( d == down ) std::cout << strv; 
            else std::cout << strv;
            std::cout << "" blocking your way!""; 
        }
        else {
            curRoom = it->second; 
            pos = p;
            if( d == up && !curRoom->count( ladder ) ) { 
                std::cout << ""I didn't know you could fly!""; 
                return; 
            }
            if( curRoom->wasVisited() ) {
                if( rand() % 10 > 5 && difftime( time( 0 ), curRoom->lastTimeVisited() ) > 180 ) curRoom->addLoot( false, pos.z );
            }
            curRoom->setVisited();
        }
    }
    void drp( keyWord k, bool silence = false ) {
        curRoom->drp( loot.dump( k ) );
        if( !silence ) std::cout << ""Dropped""; 
    }
    room* currentRoom() {
        return curRoom;
    }
    position getPos() {
        return pos;
    }
private:
    void deleteRooms() {
        for( std::map<uint, room*>::iterator it = cave.begin(); it != cave.end(); it++ )
            delete it->second;
        cave.clear();
    }
    bool checkBoundaries( keyWord k ) {
        return k == up && pos.z - 1 < 0 || k == down && pos.z + 1 >= MX_R || k == west && pos.x - 1 < 0 || 
               k == east && pos.x + 1 >= MX_R || k == north && pos.y - 1 < 0 || k == south && pos.y + 1 >= MX_R;
    }
    room* curRoom;
    box loot;
    position pos;
    keyWord equipped;
    std::map<uint, room*> cave;
};
 
class game
{
public:
    game() {
        instance = this; 
        goal.set( 3, 3, 3 );
        callee c[] = { mov, mov, mov, mov, mov, mov, inv, une, lok, hlp, qit, atk, drp, tak, eqp, als, nam, 0, 0, 0, 0 };
        for( uint i = 0; i < sizeof( c ) / sizeof( c[0] ); i++ )
            functions.insert( std::make_pair( static_cast<keyWord>( i ), c[i] ) );
    }
    void play() {
        command cmdLine; 
        std::string a;
        while( true ) {
            initGame();
            while( !gameOver ) {
                std::cout << "">""; 
                std::getline( std::cin, a ); 
                if( !cmdParser.parse( a, cmdLine ) ) continue;
                std::map<keyWord, callee>::iterator it = functions.find( cmdLine.action );
                if( it == functions.end() ) { 
                    std::cout << strv; 
                    continue; 
                }
                it->second( cmdLine );
            }
            if( playerQuit ) return;
            std::cout << ""Play again (Y/N)?>"";
            std::getline( std::cin, a ); 
            if( a[0] != 'y' && a[0] != 'Y' ) return;
        }
    }
private:
    void checkWin() {
        if( plr.getPos() == goal ) {
            std::cout << ""You have found the ** TREASURE ROOOM **""
                ""All around you are thousands and thousands of piles of gold ** and they are all yours! ** ""
                ""CONGRATULATIONS!!!"";
            gameOver = true; 
            playerQuit = false;
            return;
        }
        plr.currentRoom()->describe();
    }
    void initGame() {
        gameOver = false; 
        playerQuit = true;
        plr.init();
    }
    void showHelp() {
        std::cout << "" ** Welcome Dungeon Explorer **Dig your way to Room 8, 8, 8! (...but where is it?)""
                     ""In your journey you can use following commands:* north, south, east, west, up and down: move in that direction""
                     ""* attack <direction>: if equipped with sledge, it will open a passage  in that direction""
                     ""* drop <object>: drops the object in the room you are* take <object>: takes a object from room into you inventory""
                     ""* inventory: list all things you are carrying* look: describes the room you are in""strv
                     ""with the object* unequip: the opposite of equip* name <new name>: rename the room you are in""
                     ""* alias <command> <new name>: creates a alias for the command* quit: terminates the game* help: show this long text...""
                     ""  ** To go upwards, you need a ladder! **"";
    }
    static void atk( command c ) { 
        if( !instance->plr.atk( c.subKey ) ) {
            instance->gameOver = true;
            instance->playerQuit = false;
        }
    }
    static void mov( command c ) { instance->plr.mov( c.action ); instance->checkWin(); }
    static void inv( command c ) { instance->plr.inv(); }
    static void une( command c ) { instance->plr.une(); }
    static void lok( command c ) { instance->plr.lok(); }
    static void drp( command c ) { instance->plr.drp( c.subKey ); }
    static void tak( command c ) { instance->plr.tak( c.subKey ); }
    static void eqp( command c ) { instance->plr.equ( c.subKey ); }
    static void nam( command c ) { instance->plr.currentRoom()->setName( c.str1 ); }
    static void als( command c ) { instance->cmdParser.addAlias( c.str1, c.str2 ); }
    static void hlp( command c ) { instance->showHelp(); }
    static void qit( command c ) { instance->gameOver = true; }
 
    bool gameOver, playerQuit;
    std::map<keyWord, callee> functions;
    parser cmdParser;
    player plr;
    position goal;
    static game* instance;
};
 
game* game::instance = 0;
int main( int argc, char* argv[] )
{
    srand( static_cast<uint>( time( NULL ) ) );
    game g; g.play();
    return 0;
}
 "
"#include <string>
#include <fstream>
#include <iostream>
 
int main( ) {
   std::cout << ""Which file do you want to look at ?"" ;
   std::string input ;
   std::getline( std::cin , input ) ;
   std::ifstream infile( input.c_str( ) , std::ios::in ) ;
   std::string file( input ) ;
   std::cout << ""Which file line do you want to see ? ( Give a number > 0 ) ?"" ;
   std::getline( std::cin , input ) ;
   int linenumber = std::stoi( input ) ;
   int lines_read = 0 ;
   std::string line ;
   if ( infile.is_open( ) ) {
      while ( infile ) {
	 getline( infile , line ) ;
	 lines_read++ ;
	 if ( lines_read == linenumber ) {
	    std::cout << line << std::endl ;
	    break ; 
	 }
      }
      infile.close( ) ;
      if ( lines_read < linenumber ) 
	 std::cout << strv << linenumber << strv << file << "" !"" ;
      return 0 ;
   }
   else {
      std::cerr << strv << file << "" !"" ;
      return 1 ;
   }
}"
"#include <algorithm>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <limits>
 
using namespace std;
 
const double epsilon = numeric_limits<float>().epsilon();
const numeric_limits<double> DOUBLE;
const double MIN = DOUBLE.min();
const double MAX = DOUBLE.max();
 
struct Point { const double x, y; };
 
struct Edge {
    const Point a, b;
 
    bool operator()(const Point& p) const
    {
        if (a.y > b.y) return Edge{ b, a }(p);
        if (p.y == a.y || p.y == b.y) return operator()({ p.x, p.y + epsilon });
        if (p.y > b.y || p.y < a.y || p.x > max(a.x, b.x)) return false;
        if (p.x < min(a.x, b.x)) return true;
        auto blue = abs(a.x - p.x) > MIN ? (p.y - a.y) / (p.x - a.x) : MAX;
        auto red = abs(a.x - b.x) > MIN ? (b.y - a.y) / (b.x - a.x) : MAX;
        return blue >= red;
    }
};
 
struct Figure {
    const string  name;
    const initializer_list<Edge> edges;
 
    bool contains(const Point& p) const
    {
        auto c = 0;
        for (auto e : edges) if (e(p)) c++;
        return c % 2 != 0;
    }
 
    template<unsigned char W = 3>
    void check(const initializer_list<Point>& points, ostream& os) const
    {
        os << strv << name <<  '?' << endl;
        for (auto p : points)
            os << strv << setw(W) << p.x << ',' << setw(W) << p.y << strv << boolalpha << contains(p) << endl;
        os << endl;
    }
};
 
int main()
{
    const initializer_list<Point> points =  { { 5.0, 5.0}, {5.0, 8.0}, {-10.0, 5.0}, {0.0, 5.0}, {10.0, 5.0}, {8.0, 5.0}, {10.0, 10.0} };
    const Figure square = { strv,
        {  {{0.0, 0.0}, {10.0, 0.0}}, {{10.0, 0.0}, {10.0, 10.0}}, {{10.0, 10.0}, {0.0, 10.0}}, {{0.0, 10.0}, {0.0, 0.0}} }
    };
 
    const Figure square_hole = { strv,
        {  {{0.0, 0.0}, {10.0, 0.0}}, {{10.0, 0.0}, {10.0, 10.0}}, {{10.0, 10.0}, {0.0, 10.0}}, {{0.0, 10.0}, {0.0, 0.0}},
           {{2.5, 2.5}, {7.5, 2.5}}, {{7.5, 2.5}, {7.5, 7.5}}, {{7.5, 7.5}, {2.5, 7.5}}, {{2.5, 7.5}, {2.5, 2.5}}
        }
    };
 
    const Figure strange = { strv,
        {  {{0.0, 0.0}, {2.5, 2.5}}, {{2.5, 2.5}, {0.0, 10.0}}, {{0.0, 10.0}, {2.5, 7.5}}, {{2.5, 7.5}, {7.5, 7.5}},
           {{7.5, 7.5}, {10.0, 10.0}}, {{10.0, 10.0}, {10.0, 0.0}}, {{10.0, 0}, {2.5, 2.5}}
        }
    };
 
    const Figure exagon = { strv,
        {  {{3.0, 0.0}, {7.0, 0.0}}, {{7.0, 0.0}, {10.0, 5.0}}, {{10.0, 5.0}, {7.0, 10.0}}, {{7.0, 10.0}, {3.0, 10.0}},
           {{3.0, 10.0}, {0.0, 5.0}}, {{0.0, 5.0}, {3.0, 0.0}}
        }
    };
 
    for(auto f : {square, square_hole, strange, exagon})
        f.check(points, cout);
 
    return EXIT_SUCCESS;
}"
"#include <iostream>
#include <ctime>
 




class CRateState
{
protected:
    time_t m_lastFlush;
    time_t m_period;
    size_t m_tickCount;
public:
    CRateState(time_t period);
    void Tick();
};
 
CRateState::CRateState(time_t period) : m_lastFlush(std::time(NULL)),
                                        m_period(period),
                                        m_tickCount(0)
{ }
 
void CRateState::Tick()
{
    m_tickCount++;
 
    time_t now = std::time(NULL);
 
    if((now - m_lastFlush) >= m_period)
    {
        //TPS Report
        size_t tps = 0.0;
        if(m_tickCount > 0)
            tps = m_tickCount / (now - m_lastFlush);
 
        std::cout << tps << strv << std::endl;
 
        //Reset
        m_tickCount = 0;
        m_lastFlush = now;
    }
}
 




void something_we_do()
{
    

    

    

    //
    

    

    

    volatile size_t anchor = 0;
    for(size_t x = 0; x < 0xffff; ++x)
    {
        anchor = x;
    }
}
 
int main()
{
    time_t start = std::time(NULL);
 
    CRateState rateWatch(5);
 
    

    for(time_t latest = start; (latest - start) < 20; latest = std::time(NULL))
    {
        

        something_we_do();
 
        

        rateWatch.Tick();
    }
 
    return 0;
}"
"#include <random>
#include <functional>
#include <vector>
#include <algorithm>
using namespace std;
 
int main()
{
  random_device seed;
  mt19937 engine(seed());
  normal_distribution<double> dist(1.0, 0.5);
  auto rnd = bind(dist, engine);
 
  vector<double> v(1000);
  generate(v.begin(), v.end(), rnd);
  return 0;
}#include <cstdlib>   // for rand
#include <cmath>     // for atan, sqrt, log, cos
#include <algorithm> // for generate_n
 
double const pi = 4*std::atan(1.0);
 


class normal_distribution
{
public:
  normal_distribution(double m, double s): mu(m), sigma(s) {}
  double operator() const 

  {
    double r1 = (std::rand() + 1.0)/(RAND_MAX + 1.0); 

    double r2 = (std::rand() + 1.0)/(RAND_MAX + 1.0);
    return mu + sigma * std::sqrt(-2*std::log(r1))*std::cos(2*pi*r2);
  }
private:
  const double mu, sigma;
};
 
int main()
{
  double array[1000];
  std::generate_n(array, 1000, normal_distribution(1.0, 0.5));
  return 0;
} 
#include <vector>
#include strv
#include strv    
#include <boost/random/normal_distribution.hpp>
#include <algorithm>
 
typedef boost::mt19937 RNGType; ///< mersenne twister generator
 
int main() {
    RNGType rng;
    boost::normal_distribution<> rdist(1.0,0.5); /**< normal distribution                            with mean of 1.0 and standard deviation of 0.5 */
 
    boost::variate_generator< RNGType, boost::normal_distribution<> >
                    get_rand(rng, rdist);  
 
    std::vector<double> v(1000);
    generate(v.begin(),v.end(),get_rand);
    return 0;
}
 "
" 
#include <iostream>
#include <iterator>
#include <cstddef>
 
template<typename InIter>
 void extract_ranges(InIter begin, InIter end, std::ostream& os)
{
  if (begin == end)
    return;
 
  int current = *begin++;
  os << current;
  int count = 1;
 
  while (begin != end)
  {
    int next = *begin++;
    if (next == current+1)
      ++count;
    else
    {
      if (count > 2)
        os << '-';
      else
        os << ',';
      if (count > 1)
        os << current << ',';
      os << next;
      count = 1;
    }
    current = next;
  }
 
  if (count > 1)
    os << (count > 2? '-' : ',') << current;
}
 
template<typename T, std::size_t n>
 T* end(T (&array)[n])
{
  return array+n;
}
 
int main()
{
  int data[] = { 0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
                 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
                 25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
                 37, 38, 39 };
 
  extract_ranges(data, end(data), std::cout);
  std::cout << std::endl;
}
 "
"#include <iostream>
#include <sstream>
#include <iterator>
#include <climits>
#include <deque>
 


//






//


template<typename OutIter>
 bool parse_number_list_with_ranges(std::istream& is, OutIter out)
{
  int number;
  

  while (is >> number)
  {
    *out++ = number;
 
    char c;
    if (is >> c)
      switch(c)
      {
      case ',':
        continue;
      case '-':
        {
          int number2;
          if (is >> number2)
          {
            if (number2 < number)
              return false;
            while (number < number2)
              *out++ = ++number;
            char c2;
            if (is >> c2)
              if (c2 == ',')
                continue;
              else
                return false;
            else
              return is.eof();
          }
          else
            return false;
        }
      default:
        return is.eof();
      }
    else
      return is.eof();
  }
  

  

  return false;
}
 
int main()
{
  std::istringstream example(strv);
  std::deque<int> v;
  bool success = parse_number_list_with_ranges(example, std::back_inserter(v));
  if (success)
  {
    std::copy(v.begin(), v.end()-1,
              std::ostream_iterator<int>(std::cout, strv));
    std::cout << v.back() << """";
  }
  else
    std::cout << strv;
}"
"#include <iostream>
#include <random>
 
int main()
{
    std::random_device rd;
    std::uniform_int_distribution<long> dist; 

 
    std::cout << strv << dist(rd) << std::endl;
}"
"#include <iostream>
#include <string>
#include <random>
 
int main()
{
    std::random_device rd;
    std::uniform_int_distribution<int> dist(1, 10);
    std::mt19937 mt(rd());
 
    std::cout << strv << dist(rd) << std::endl;
    std::cout << strv << dist(mt) << std::endl;
}"
"#include <iostream>
#include <cmath>
#include <utility>
#include <vector>
#include <stdexcept>
using namespace std;
 
typedef std::pair<double, double> Point;
 
double PerpendicularDistance(const Point &pt, const Point &lineStart, const Point &lineEnd)
{
	double dx = lineEnd.first - lineStart.first;
	double dy = lineEnd.second - lineStart.second;
 
	//Normalise
	double mag = pow(pow(dx,2.0)+pow(dy,2.0),0.5);
	if(mag > 0.0)
	{
		dx /= mag; dy /= mag;
	}
 
	double pvx = pt.first - lineStart.first;
	double pvy = pt.second - lineStart.second;
 
	//Get dot product (project pv onto normalized direction)
	double pvdot = dx * pvx + dy * pvy;
 
	//Scale line direction vector
	double dsx = pvdot * dx;
	double dsy = pvdot * dy;
 
	//Subtract this from pv
	double ax = pvx - dsx;
	double ay = pvy - dsy;
 
	return pow(pow(ax,2.0)+pow(ay,2.0),0.5);
}
 
void RamerDouglasPeucker(const vector<Point> &pointList, double epsilon, vector<Point> &out)
{
	if(pointList.size()<2)
		throw invalid_argument(strv);
 
	

	double dmax = 0.0;
	size_t index = 0;
	size_t end = pointList.size()-1;
	for(size_t i = 1; i < end; i++)
	{
		double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);
		if (d > dmax)
		{
			index = i;
			dmax = d;
		}
	}
 
	

	if(dmax > epsilon)
	{
		

		vector<Point> recResults1;
		vector<Point> recResults2;
		vector<Point> firstLine(pointList.begin(), pointList.begin()+index+1);
		vector<Point> lastLine(pointList.begin()+index, pointList.end());
		RamerDouglasPeucker(firstLine, epsilon, recResults1);
		RamerDouglasPeucker(lastLine, epsilon, recResults2);
 
		

		out.assign(recResults1.begin(), recResults1.end()-1);
		out.insert(out.end(), recResults2.begin(), recResults2.end());
		if(out.size()<2)
			throw runtime_error(strv);
	} 
	else 
	{
		//Just return start and end points
		out.clear();
		out.push_back(pointList[0]);
		out.push_back(pointList[end]);
	}
}
 
int main()
{
	vector<Point> pointList;
	vector<Point> pointListOut;
 
	pointList.push_back(Point(0.0, 0.0));
	pointList.push_back(Point(1.0, 0.1));
	pointList.push_back(Point(2.0, -0.1));
	pointList.push_back(Point(3.0, 5.0));
	pointList.push_back(Point(4.0, 6.0));
	pointList.push_back(Point(5.0, 7.0));
	pointList.push_back(Point(6.0, 8.1));
	pointList.push_back(Point(7.0, 9.0));
	pointList.push_back(Point(8.0, 9.0));
	pointList.push_back(Point(9.0, 9.0));
 
	RamerDouglasPeucker(pointList, 1.0, pointListOut);
 
	cout << strv << endl;
	for(size_t i=0;i< pointListOut.size();i++)
	{
		cout << pointListOut[i].first << strv << pointListOut[i].second << endl;
	}
 
	return 0;
}"
"#include <iostream>
 
void quote(char const* c)
{
  while (*c)
  {
    switch(*c)
    {
    case '':
      std::cout << """";break;
    case '':
      std::cout << ""n"";break;
    case '':
      std::cout << """";break;
    default:
      std::cout << *c;
    }
    ++c;
  }
}
 
int main()
{
  char const* parts[] = {
    ""#include <iostream>void quote(char const* c){  while (*c)  {    switch(*c)    {    case '':      std::cout << ;break;    case 'n':      std::cout << n;break;    case '':      std::cout << ;break;    default:      std::cout << *c;    }    ++c;  }}int main(){  char const* parts[] = {    "",
    "",    "",
    ""  };    std::cout << parts[0];  quote(parts[0]);  std::cout << parts[1];  quote(parts[1]);  std::cout << parts[1];  quote(parts[2]);  std::cout << parts[2];  return 0;}""
  };
 
  std::cout << parts[0];
  quote(parts[0]);
  std::cout << parts[1];
  quote(parts[1]);
  std::cout << parts[1];
  quote(parts[2]);
  std::cout << parts[2];
 
  return 0;
}"
"#include <algorithm>
#include <iostream>
 
int main() {
  for (int i = 0; i < 10; i++) {
    int a[] = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};
    std::nth_element(a, a + i, a + sizeof(a)/sizeof(*a));
    std::cout << a[i];
    if (i < 9) std::cout << strv;
  }
  std::cout << std::endl;
 
  return 0;
}#include <iterator>
#include <algorithm>
#include <functional>
#include <cstdlib>
#include <ctime>
#include <iostream>
 
template <typename Iterator>
Iterator select(Iterator begin, Iterator end, int n) {
  typedef typename std::iterator_traits<Iterator>::value_type T;
  while (true) {
    Iterator pivotIt = begin + std::rand() % std::distance(begin, end);
    std::iter_swap(pivotIt, end-1);  

    pivotIt = std::partition(begin, end-1, std::bind2nd(std::less<T>(), *(end-1)));
    std::iter_swap(end-1, pivotIt);  

    if (n == pivotIt - begin) {
      return pivotIt;
    } else if (n < pivotIt - begin) {
      end = pivotIt;
    } else {
      n -= pivotIt+1 - begin;
      begin = pivotIt+1;
    }
  }
}
 
int main() {
  std::srand(std::time(NULL));
  for (int i = 0; i < 10; i++) {
    int a[] = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};
    std::cout << *select(a, a + sizeof(a)/sizeof(*a), i);
    if (i < 9) std::cout << strv;
  }
  std::cout << std::endl;
 
  return 0;
}"
"#include <queue>
#include <cassert> // for run time assertions
 
int main()
{
  std::queue<int> q;
  assert( q.empty() );        

 
  q.push(1);                  

  assert( !q.empty() );       

  assert( q.front() == 1 );   

 
  q.push(2);                  

  assert( !q.empty() );       

  assert( q.front() == 1 );   

 
  q.push(3);                  

  assert( !q.empty() );       

  assert( q.front() == 1 );   

 
  q.pop();                    

  assert( !q.empty() );       

  assert( q.front() == 2);    

 
  q.pop();
  assert( !q.empty() );
  assert( q.front() == 3);
 
  q.push(4);
  assert( !q.empty() );
  assert( q.front() == 3);
 
  q.pop();
  assert( !q.empty() );
  assert( q.front() == 4);
 
  q.pop();
  assert( q.empty() );
 
  q.push(5);
  assert( !q.empty() );
  assert( q.front() == 5);
 
  q.pop();
  assert( q.empty() );
}  std::queue<int, std::list<int> >"
"namespace rosettacode
{
  template<typename T> class queue
  {
  public:
    queue();
    ~queue();
    void push(T const& t);
    T pop();
    bool empty();
  private:
    void drop();
    struct node;
    node* head;
    node* tail;
  };
 
  template<typename T> struct queue<T>::node
  {
    T data;
    node* next;
    node(T const& t): data(t), next(0) {}
  };
 
  template<typename T>
   queue<T>::queue():
    head(0)
  {
  }
 
  template<typename T>
   inline void queue<T>::drop()
  {
    node* n = head;
    head = head->next;
    delete n;
  }
 
  template<typename T>
   queue<T>::~queue()
  {
    while (!empty())
      drop();
  }
 
  template<typename T>
   void queue<T>::push(T const& t)
  {
    node*& next = head? tail->next : head;
    next = new node(t);
    tail = next;
  }
 
  template<typename T>
   T queue<T>::pop()
  {
    T tmp = head->data;
    drop();
    return tmp;
  }
 
  template<typename T>
   bool queue<T>::empty()
  {
    return head == 0;
  }
}"
"/* * g++ -O3 -Wall --std=c++11 qr_standalone.cpp -o qr_standalone */
#include <cstdio>
#include <cstdlib>
#include <cstring> // for memset
#include <limits>
#include <iostream>
#include <vector>
 
#include <math.h>
 
class Vector;
 
class Matrix {
 
public:
  

  Matrix() : m(0), n(0), data(nullptr) {}
 
  

  Matrix(int m_, int n_) : Matrix() {
    m = m_;
    n = n_;
    allocate(m_,n_);
  }
 
  

  Matrix(const Matrix& mat) : Matrix(mat.m,mat.n) {
 
    for (int i = 0; i < m; i++)
      for (int j = 0; j < n; j++)
	(*this)(i,j) = mat(i,j);
  }
 
  

  template<int rows, int cols>
  Matrix(double (&a)[rows][cols]) : Matrix(rows,cols) {
 
    for (int i = 0; i < m; i++)
      for (int j = 0; j < n; j++)
	(*this)(i,j) = a[i][j];
  }
 
  

  ~Matrix() {
    deallocate();
  }
 
 
  

  double& operator() (int i, int j) {
    return data[i+m*j]; }
  double  operator() (int i, int j) const {
    return data[i+m*j]; }
 
  

  Matrix& operator=(const Matrix& source) {
 
    

    if (this != &source) { 
      if ( (m*n) != (source.m * source.n) ) { 

	allocate(source.m,source.n);          

      }
      

      std::copy(source.data, source.data + source.m*source.n, data);
    }
    return *this;
  }
 
  

  void compute_minor(const Matrix& mat, int d) {
 
    allocate(mat.m, mat.n);
 
    for (int i = 0; i < d; i++)
      (*this)(i,i) = 1.0;
    for (int i = d; i < mat.m; i++)
      for (int j = d; j < mat.n; j++)
	(*this)(i,j) = mat(i,j);
 
  }
 
  

  

  

  void mult(const Matrix& a, const Matrix& b) {
 
    if (a.n != b.m) {
      std::cerr << ""Matrix multiplication not possible, sizes don't match !"";
      return;
    }
 
    

    if (a.m != m or b.n != n)
      allocate(a.m, b.n);
 
    memset(data,0,m*n*sizeof(double));
 
    for (int i = 0; i < a.m; i++)
      for (int j = 0; j < b.n; j++)
	for (int k = 0; k < a.n; k++)
	  (*this)(i,j) += a(i,k) * b(k,j);
 
  }
 
  void transpose() {
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < i; j++) {
	double t = (*this)(i,j);
	(*this)(i,j) = (*this)(j,i);
	(*this)(j,i) = t;
      }
    }
  }
 
  

  void extract_column(Vector& v, int c);  
 
  

  void allocate(int m_, int n_) {
 
    

    deallocate();
 
    

    m = m_;
    n = n_;
 
    data = new double[m_*n_];
    memset(data,0,m_*n_*sizeof(double));
 
  } 

 
  

  void deallocate() {
 
    if (data)
      delete[] data;
 
    data = nullptr;
 
  }    
 
  int m, n;
 
private:
  double* data;
 
}; 

 


class Vector {
 
public:
  

  Vector() : size(0), data(nullptr) {}
 
  

  Vector(int size_) : Vector() {
    size = size_;
    allocate(size_);
  }
 
  

  ~Vector() {
    deallocate();
  }
 
  

  double& operator() (int i) {
    return data[i]; }
  double  operator() (int i) const {
    return data[i]; }
 
  

  Vector& operator=(const Vector& source) {
 
    

    if (this != &source) { 
      if ( size != (source.size) ) {   

	allocate(source.size);         

      }
      

      std::copy(source.data, source.data + source.size, data);
    }
    return *this;
  }
 
  

  void allocate(int size_) {
 
    deallocate();
 
    

    size = size_;
 
    data = new double[size_];
    memset(data,0,size_*sizeof(double));
 
  } 

 
  

  void deallocate() {
 
    if (data)
      delete[] data;
 
    data = nullptr;
 
  }    
 
  

  double norm() {
    double sum = 0;
    for (int i = 0; i < size; i++) sum += (*this)(i) * (*this)(i);
    return sqrt(sum);
  }
 
  

  void rescale(double factor) {
    for (int i = 0; i < size; i++) (*this)(i) /= factor;
  }
 
  void rescale_unit() {
    double factor = norm();
    rescale(factor);
  }
 
  int size;
 
private:
  double* data;
 
}; 

 


void vmadd(const Vector& a, const Vector& b, double s, Vector& c)
{
  if (c.size != a.size or c.size != b.size) {
    std::cerr << ""[vmadd]: vector sizes don't match"";
    return;
  }
 
  for (int i = 0; i < c.size; i++)
    c(i) = a(i) + s * b(i);
}
 


// !!! m is allocated here !!!
void compute_householder_factor(Matrix& mat, const Vector& v)
{
 
  int n = v.size;
  mat.allocate(n,n);
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
      mat(i,j) = -2 *  v(i) * v(j);
  for (int i = 0; i < n; i++)
    mat(i,i) += 1;  
}
 


void Matrix::extract_column(Vector& v, int c) {
  if (m != v.size) {
    std::cerr << ""[Matrix::extract_column]: Matrix and Vector sizes don't match"";
    return;
  }
 
  for (int i = 0; i < m; i++)
    v(i) = (*this)(i,c);
}
 
void matrix_show(const Matrix&  m, const std::string& str=strv)
{
  std::cout << str << """";
  for(int i = 0; i < m.m; i++) {
    for (int j = 0; j < m.n; j++) {
      printf(strv, m(i,j));
    }
    printf("""");
  }
  printf("""");
}
 


double matrix_compare(const Matrix& A, const Matrix& B) {
  

  if (A.m != B.m or  A.n != B.n)
    return std::numeric_limits<double>::max();
 
  double res=0;
  for(int i = 0; i < A.m; i++) {
    for (int j = 0; j < A.n; j++) {
      res += (A(i,j)-B(i,j)) * (A(i,j)-B(i,j));
    }
  }
 
  res /= A.m*A.n;
  return res;
}
 
void householder(Matrix& mat,
		 Matrix& R,
		 Matrix& Q)
{
 
  int m = mat.m;
  int n = mat.n;
 
  

  std::vector<Matrix> qv(m);
 
  

  Matrix z(mat);
  Matrix z1;
 
  for (int k = 0; k < n && k < m - 1; k++) {
 
    Vector e(m), x(m);
    double a;
 
    

    z1.compute_minor(z, k);
 
    

    z1.extract_column(x, k);
 
    a = x.norm();
    if (mat(k,k) > 0) a = -a;
 
    for (int i = 0; i < e.size; i++)
      e(i) = (i == k) ? 1 : 0;
 
    

    vmadd(x, e, a, e);
 
    

    e.rescale_unit();
 
    

    compute_householder_factor(qv[k], e);
 
    

    z.mult(qv[k], z1);
 
  }
 
  Q = qv[0];
 
  

  for (int i = 1; i < n && i < m - 1; i++) {
 
    z1.mult(qv[i], Q);
    Q = z1;
 
  }
 
  R.mult(Q, mat);
  Q.transpose();
}
 
double in[][3] = {
  { 12, -51,   4},
  {  6, 167, -68},
  { -4,  24, -41},
  { -1,   1,   0},
  {  2,   0,   3},
};
 
int main()
{
  Matrix A(in); 
  Matrix Q, R;
 
  matrix_show(A,strv);  
 
  

  householder(A, R, Q);
 
  matrix_show(Q,strv);
  matrix_show(R,strv);
 
  

  Matrix A_check;
  A_check.mult(Q, R);
 
  

  double l2 = matrix_compare(A,A_check);
 
  

  matrix_show(A_check, l2 < 1e-12 ? strv : strv);
 
  return EXIT_SUCCESS;
}
 "
" 
#include <windows.h>
#include <string>
#include <iostream>
 
const int BMP_SIZE = 720, LINE_LEN = 120, BORDER = 100;
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    void saveBitmap( std::string path ) {
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
                                  FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC    hdc;
    HPEN    pen; HBRUSH brush;
    void    *pBits; int    width, height, wid;
    DWORD    clr;
};
class tree {
public:
    tree() {
        bmp.create( BMP_SIZE, BMP_SIZE ); bmp.clear();
        clr[0] = RGB( 90, 30, 0 );   clr[1] = RGB( 255, 255, 0 );
        clr[2] = RGB( 0, 255, 255 ); clr[3] = RGB( 255, 255, 255 );
        clr[4] = RGB( 255, 0, 0 );   clr[5] = RGB( 0, 100, 190 );
    }
    void draw( int it, POINT a, POINT b ) {
        if( !it ) return;
        bmp.setPenColor( clr[it % 6] );
        POINT df = { b.x - a.x, a.y -  b.y }; POINT c = { b.x - df.y, b.y - df.x };
        POINT d = { a.x - df.y, a.y - df.x };
        POINT e = { d.x + ( ( df.x - df.y ) / 2 ), d.y - ( ( df.x + df.y ) / 2 )};
        drawSqr( a, b, c, d ); draw( it - 1, d, e ); draw( it - 1, e, c );
    }
    void save( std::string p ) { bmp.saveBitmap( p ); }
private:
    void drawSqr( POINT a, POINT b, POINT c, POINT d ) {
        HDC dc = bmp.getDC();
        MoveToEx( dc, a.x, a.y, NULL );
        LineTo( dc, b.x, b.y );
        LineTo( dc, c.x, c.y );
        LineTo( dc, d.x, d.y );
        LineTo( dc, a.x, a.y );
    }
    myBitmap bmp;
    DWORD clr[6];
};
int main( int argc, char* argv[] ) {
    POINT ptA = { ( BMP_SIZE >> 1 ) - ( LINE_LEN >> 1 ), BMP_SIZE - BORDER },
          ptB = { ptA.x + LINE_LEN, ptA.y };
    tree t; t.draw( 12, ptA, ptB );
    

    t.save( strv );
    return 0;
}
 "
"#include <cstdlib>
 
void problem_occured()
{
  std::exit(EXIT_FAILURE);
}#include <cstdlib>
 
void problem_occured()
{
  std::abort();
}#include <exception>
 
void problem_occured()
{
  std::terminate();
}"
"#include <vector>
#include <iostream>
#include <algorithm>
 
std::vector<int> properDivisors ( int number ) {
   std::vector<int> divisors ;
   for ( int i = 1 ; i < number / 2 + 1 ; i++ )
      if ( number % i == 0 )
	 divisors.push_back( i ) ;
   return divisors ;
}
 
int main( ) {
   std::vector<int> divisors ;
   unsigned int maxdivisors = 0 ;
   int corresponding_number = 0 ;
   for ( int i = 1 ; i < 11 ; i++ ) {
      divisors =  properDivisors ( i ) ;
      std::cout << strv << i << "":"" ;
      for ( int number : divisors ) { 
	 std::cout << number << strv ;
      }
      std::cout << std::endl ;
      divisors.clear( ) ;
   }
   for ( int i = 11 ; i < 20001 ; i++ ) {
      divisors =  properDivisors ( i ) ;
      if ( divisors.size( ) > maxdivisors ) {
	 maxdivisors = divisors.size( ) ;
	 corresponding_number = i ;
      }
      divisors.clear( ) ;
   }
 
   std::cout << strv << corresponding_number <<
      strv << maxdivisors << "" divisors!"" ; 
   return 0 ;
}
 "
"#include <iostream>
using namespace std;
 
template<class T = double>
class Quaternion
{
public:
  T w, x, y, z;
 
  

  Quaternion(const T &w, const T &x, const T &y, const T &z): w(w), x(x), y(y), z(z) {};
  Quaternion(const T &x, const T &y, const T &z): w(T()), x(x), y(y), z(z) {}; 

  Quaternion(const T &r): w(r), x(T()), y(T()), z(T()) {};
  Quaternion(): w(T()), x(T()), y(T()), z(T()) {};
 
  

  Quaternion(const Quaternion &q): w(q.w), x(q.x), y(q.y), z(q.z) {};
  Quaternion& operator=(const Quaternion &q) { w=q.w; x=q.x; y=q.y; z=q.z; return *this; }
 
  

  Quaternion operator-() const { return Quaternion(-w, -x, -y, -z); }
  Quaternion operator~() const { return Quaternion(w, -x, -y, -z); } 

 
  

  T normSquared() const { return w*w + x*x + y*y + z*z; }
 
  

  Quaternion& operator+=(const T &r) 
    { w += r; return *this; }
  Quaternion& operator+=(const Quaternion &q) 
    { w += q.w; x += q.x; y += q.y; z += q.z; return *this; }
 
  Quaternion& operator-=(const T &r) 
    { w -= r; return *this; }
  Quaternion& operator-=(const Quaternion &q) 
    { w -= q.w; x -= q.x; y -= q.y; z -= q.z; return *this; }
 
  Quaternion& operator*=(const T &r) 
    { w *= r; x *= r; y *= r; z *= r; return *this; }
  Quaternion& operator*=(const Quaternion &q) 
  { 
    T oldW(w), oldX(x), oldY(y), oldZ(z);
    w = oldW*q.w - oldX*q.x - oldY*q.y - oldZ*q.z;
    x = oldW*q.x + oldX*q.w + oldY*q.z - oldZ*q.y;
    y = oldW*q.y + oldY*q.w + oldZ*q.x - oldX*q.z;
    z = oldW*q.z + oldZ*q.w + oldX*q.y - oldY*q.x;
    return *this;
  }
 
  Quaternion& operator/=(const T &r) 
    { w /= r; x /= r; y /= r; z /= r; return *this; }
  Quaternion& operator/=(const Quaternion &q) 
  { 
    T oldW(w), oldX(x), oldY(y), oldZ(z), n(q.normSquared());
    w = (oldW*q.w + oldX*q.x + oldY*q.y + oldZ*q.z) / n;
    x = (oldX*q.w - oldW*q.x + oldY*q.z - oldZ*q.y) / n;
    y = (oldY*q.w - oldW*q.y + oldZ*q.x - oldX*q.z) / n;
    z = (oldZ*q.w - oldW*q.z + oldX*q.y - oldY*q.x) / n;
    return *this;
  }
 
  

  Quaternion operator+(const T &r) const { return Quaternion(*this) += r; }
  Quaternion operator+(const Quaternion &q) const { return Quaternion(*this) += q; }
  Quaternion operator-(const T &r) const { return Quaternion(*this) -= r; }
  Quaternion operator-(const Quaternion &q) const { return Quaternion(*this) -= q; }
  Quaternion operator*(const T &r) const { return Quaternion(*this) *= r; }
  Quaternion operator*(const Quaternion &q) const { return Quaternion(*this) *= q; }
  Quaternion operator/(const T &r) const { return Quaternion(*this) /= r; }
  Quaternion operator/(const Quaternion &q) const { return Quaternion(*this) /= q; }
 
  

  bool operator==(const Quaternion &q) const 
    { return (w == q.w) && (x == q.x) && (y == q.y) && (z == q.z); }
  bool operator!=(const Quaternion &q) const { return !operator==(q); }
 
  

  

  template<class T> friend Quaternion<T> operator+(const T &r, const Quaternion<T> &q);
  template<class T> friend Quaternion<T> operator-(const T &r, const Quaternion<T> &q);
  template<class T> friend Quaternion<T> operator*(const T &r, const Quaternion<T> &q);
  template<class T> friend Quaternion<T> operator/(const T &r, const Quaternion<T> &q);
 
  

  template<class T> friend ostream& operator<<(ostream &io, const Quaternion<T> &q);
};
 


template<class T>
Quaternion<T> operator+(const T &r, const Quaternion<T> &q) 
  { return q+r; }
 
template<class T>
Quaternion<T> operator-(const T &r, const Quaternion<T> &q)
  { return Quaternion<T>(r-q.w, q.x, q.y, q.z); }
 
template<class T>
Quaternion<T> operator*(const T &r, const Quaternion<T> &q) 
  { return q*r; }
 
template<class T>
Quaternion<T> operator/(const T &r, const Quaternion<T> &q)
{
  T n(q.normSquared());
  return Quaternion(r*q.w/n, -r*q.x/n, -r*q.y/n, -r*q.z/n);
}
 
template<class T>
ostream& operator<<(ostream &io, const Quaternion<T> &q)
{ 
  io << q.w;
  (q.x < T()) ? (io << strv << (-q.x) << strv) : (io << strv << q.x << strv);
  (q.y < T()) ? (io << strv << (-q.y) << strv) : (io << strv << q.y << strv);
  (q.z < T()) ? (io << strv << (-q.z) << strv) : (io << strv << q.z << strv);
  return io;
}int main()
{
  Quaternion<> q0(1, 2, 3, 4);
  Quaternion<> q1(2, 3, 4, 5);
  Quaternion<> q2(3, 4, 5, 6);
  double r = 7;
 
  cout << strv << q0 << endl;
  cout << strv << q1 << endl;
  cout << strv << q2 << endl;
  cout << strv << r << endl;
  cout << endl;
  cout << strv << -q0 << endl;
  cout << strv << ~q0 << endl;
  cout << endl;
  cout << strv << r*q0 << endl;
  cout << strv << r+q0 << endl;
  cout << strv << q0/r << endl;
  cout << strv << q0-r << endl;
  cout << endl;
  cout << strv << q0+q1 << endl;
  cout << strv << q0-q1 << endl;
  cout << strv << q0*q1 << endl;
  cout << strv << q0/q1 << endl;
  cout << endl;
  cout << strv << q0*~q0 << endl;
  cout << strv << q0+q1*q2 << endl;
  cout << strv << (q0+q1)*q2 << endl;
  cout << strv << q0*q1*q2 << endl;
  cout << strv << (q0*q1)*q2 << endl;
  cout << strv << q0*(q1*q2) << endl;
  cout << endl;
  cout << strv << sqrt(q0.normSquared()) << endl;
  cout << endl;
  cout << strv << (q0*q1 - q1*q0) << endl;
 
  

  Quaternion<int> q5(2), q6(3);
  cout << endl << q5*q6 << endl;
}"
"#include <iostream>
 
using namespace std;
 
int main(int argc, char **argv) {
	char *program = argv[0];
	cout << strv << program << endl;
 
	return 0;
}"
"#include <cstdlib>
#include <iostream>
#include <vector>
#include <utility>
#include <algorithm>
#include <ctime>
#include <iomanip>
 
int main( ) {
   typedef std::vector<std::pair<std::string, double> >::const_iterator SPI ;
   typedef std::vector<std::pair<std::string , double> > ProbType ;
   ProbType probabilities ;
   probabilities.push_back( std::make_pair( strv , 1/5.0 ) ) ; 
   probabilities.push_back( std::make_pair( strv , 1/6.0 ) ) ;
   probabilities.push_back( std::make_pair( strv , 1/7.0 ) ) ;
   probabilities.push_back( std::make_pair( strv , 1/8.0 ) ) ;
   probabilities.push_back( std::make_pair( strv , 1/9.0 ) ) ;
   probabilities.push_back( std::make_pair( strv , 1/10.0 ) ) ;
   probabilities.push_back( std::make_pair( strv , 1/11.0 ) ) ;
   probabilities.push_back( std::make_pair( strv , 1759/27720.0 ) ) ;
   std::vector<std::string> generated ; //for the strings that are generatod
   std::vector<int> decider ; //holds the numbers that determine the choice of letters 
   for ( int i = 0 ; i < probabilities.size( ) ; i++ ) {
      if ( i == 0 ) {
	 decider.push_back( 27720 * (probabilities[ i ].second) ) ;
      }
      else {
	 int number = 0 ;
	 for ( int j = 0 ; j < i ; j++ ) {
	    number +=  27720 * ( probabilities[ j ].second ) ;
	 }
	 number += 27720 * probabilities[ i ].second ;
	 decider.push_back( number ) ;
      }
   }
   srand( time( 0 ) ) ;
   for ( int i = 0 ; i < 1000000 ; i++ ) {
      int randnumber = rand( ) % 27721 ;
      int j = 0 ; 
      while ( randnumber > decider[ j ] ) 
	 j++ ;
      generated.push_back( ( probabilities[ j ]).first ) ;
   }
   std::cout << ""letter  frequency attained   frequency expected"" ;
   for ( SPI i = probabilities.begin( ) ; i != probabilities.end( ) ; i++ ) {
      std::cout << std::left << std::setw( 8 ) << i->first ;
      int found = std::count ( generated.begin( ) , generated.end( ) , i->first ) ;
      std::cout << std::left << std::setw( 21 ) << found / 1000000.0 ;
      std::cout << std::left << std::setw( 17 ) << i->second << '' ;
   }
   return 0 ;
}"
"#include <iostream>
#include <string>
#include <queue>
#include <utility>
 
int main() {
  std::priority_queue<std::pair<int, std::string> > pq;
  pq.push(std::make_pair(3, strv));
  pq.push(std::make_pair(4, strv));
  pq.push(std::make_pair(5, strv));
  pq.push(std::make_pair(1, strv));
  pq.push(std::make_pair(2, strv));
 
  while (!pq.empty()) {
    std::cout << pq.top().first << strv << pq.top().second << std::endl;
    pq.pop();
  }
 
  return 0;
}#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <utility>
 
int main() {
  std::vector<std::pair<int, std::string> > pq;
  pq.push_back(std::make_pair(3, strv));
  pq.push_back(std::make_pair(4, strv));
  pq.push_back(std::make_pair(5, strv));
  pq.push_back(std::make_pair(1, strv));
 
  

  std::make_heap(pq.begin(), pq.end());
 
  

  pq.push_back(std::make_pair(2, strv));
  std::push_heap(pq.begin(), pq.end());
 
  while (!pq.empty()) {
    

    std::cout << pq[0].first << strv << pq[0].second << std::endl;
    

    std::pop_heap(pq.begin(), pq.end());
    pq.pop_back();
  }
 
  return 0;
}"
"#include <vector>
#include <iostream>
#include <cmath>
#include <utility>
#include <map>
#include <iomanip>
 
bool isPrime( int i ) {
   int stop = std::sqrt( static_cast<double>( i ) ) ;
   for ( int d = 2 ; d <= stop ; d++ )
      if ( i % d == 0 )
	 return false ;
   return true ;
}
 
class Compare {
public :
   Compare( ) {
   }
 
   bool operator( ) ( const std::pair<int , int> & a , const std::pair<int, int> & b ) {
      if ( a.first != b.first ) 
	 return a.first < b.first ;
      else
	 return a.second < b.second ;
   }
};
 
int main( ) {
   std::vector<int> primes {2} ;
   int current = 3 ;
   while ( primes.size( ) < 1000000 ) {
      if ( isPrime( current ) ) 
	 primes.push_back( current ) ;
      current += 2 ;
   }
   Compare myComp ;
   std::map<std::pair<int, int>, int , Compare> conspiracy (myComp) ;
   for ( int i = 0 ; i < primes.size( ) -1 ; i++ ) {
      int a = primes[i] % 10 ;
      int b = primes[ i + 1 ] % 10 ;
      std::pair<int , int> numbers { a , b} ;
      conspiracy[numbers]++ ;
   }
   std::cout << ""1000000 first primes. Transitions prime % 10 → next-prime % 10."" ;
   for ( auto it = conspiracy.begin( ) ; it != conspiracy.end( ) ; it++ ) {
      std::cout << (it->first).first << strv << (it->first).second << strv ;
      int frequency = it->second ;
      std::cout << std::right << std::setw( 15 ) << frequency << strv ;
      std::cout.setf(std::ios::fixed, std::ios::floatfield ) ;
      std::cout.precision( 2 ) ;
      std::cout << (static_cast<double>(frequency) / 1000000.0) * 100 << "" %"" ;
   }
   return 0 ;
}"
"#include <iostream>
#include <gmpxx.h>
 








//




template<typename Integer, typename OutputIterator>
 void decompose(Integer n, OutputIterator out)
{
  Integer i(2);
 
  while (n != 1)
  {
    while (n % i == Integer(0))
    {
      *out++ = i;
      n /= i;
    }
    ++i;
  }
}
 






template<typename T> class infix_ostream_iterator:
  public std::iterator<T, std::output_iterator_tag>
{
  class Proxy;
  friend class Proxy;
  class Proxy
  {
  public:
    Proxy(infix_ostream_iterator& iter): iterator(iter) {}
    Proxy& operator=(T const& value)
    {
      if (!iterator.first)
      {
        iterator.stream << iterator.infix;
      }
      iterator.stream << value;
    }
  private:
    infix_ostream_iterator& iterator;
  };
public:
  infix_ostream_iterator(std::ostream& os, char const* inf):
    stream(os),
    first(true),
    infix(inf)
  {
  }
  infix_ostream_iterator& operator++() { first = false; return *this; }
  infix_ostream_iterator operator++(int)
  {
    infix_ostream_iterator prev(*this);
    ++*this;
    return prev;
  }
  Proxy operator*() { return Proxy(*this); }
private:
  std::ostream& stream;
  bool first;
  char const* infix;
};
 
int main()
{
  std::cout << strv;
  mpz_class number;
  std::cin >> number;
 
  if (number <= 0)
    std::cout << ""this number is not positive!;"";
  else
  {
    std::cout << strv;
    decompose(number, infix_ostream_iterator<mpz_class>(std::cout, strv));
    std::cout << """";
  }
}"
"#include <cmath>
 
bool is_prime(unsigned int n)
{
    if (n <= 1)
        return false;
    if (n == 2)
        return true;
    for (unsigned int i = 2; i <= sqrt(n); ++i)
        if (n % i == 0)
            return false;
    return true;
}"
"#include <iostream>
#include <cmath>
 
int main( ) {
   double froms[ ] = { 0.00 , 0.06 , 0.11 , 0.16 , 0.21 , 0.26 , 
       0.31 , 0.36 , 0.41 , 0.46 , 0.51 , 0.56 , 0.61 , 0.66 ,
       0.71 , 0.76 , 0.81 , 0.86 , 0.91 , 0.96 } ;
   double tos[ ] = { 0.06 , 0.11 , 0.16 , 0.21 , 0.26 , 0.31 ,
      0.36 , 0.41 , 0.46 , 0.51 , 0.56 , 0.61 , 0.66 , 0.71 ,
      0.76 , 0.81 , 0.86 , 0.91 , 0.96 , 1.01 } ;
   double replacements [] = { 0.10 , 0.18 , 0.26 , 0.32 , 0.38 ,
      0.44 , 0.50 , 0.54 , 0.58 , 0.62 , 0.66 , 0.70 , 0.74 ,
      0.78 , 0.82 , 0.86 , 0.90 , 0.94 , 0.98 , 1.00 } ;
   double number = 0.1 ;
   std::cout << ""Enter a fractional number between 0 and 1 ( 0 to end )!"" ;
   std::cin >> number ;
   while ( number != 0 ) {
      if ( number < 0 || number > 1 ) {
	 std::cerr << ""Error! Only positive values between 0 and 1 are allowed!"" ;
	 return 1 ;
      }
      int n = 0 ;
      while ( ! ( number >= froms[ n ] && number < tos[ n ] ) ) 
	 n++ ;
      std::cout << strv << replacements[ n ] << '' ;
      std::cout << ""Enter a fractional number ( 0 to end )!"" ;
      std::cin >> number ;
   }
   return 0 ;
}
 "
"#include <iostream>
#include <bitset>
#include <climits>
 
size_t popcount(unsigned long long n) {
  return std::bitset<CHAR_BIT * sizeof n>(n).count();
}
 
int main() {
  {
    unsigned long long n = 1;
    for (int i = 0; i < 30; i++) {
      std::cout << popcount(n) << strv;
      n *= 3;
    }
    std::cout << std::endl;
  }
 
  int od[30];
  int ne = 0, no = 0;
  std::cout << strv;
  for (int n = 0; ne+no < 60; n++) {
    if ((popcount(n) & 1) == 0) {
      if (ne < 30) {
	std::cout << n << strv;
	ne++;
      }
    } else {
      if (no < 30) {
	od[no++] = n;
      }
    }
  }
  std::cout << std::endl;
  std::cout << strv;
  for (int i = 0; i < 30; i++) {
    std::cout << od[i] << strv;
  }
  std::cout << std::endl;
 
  return 0;
}"
" 
#include <windows.h>
#include <sstream>
#include <ctime>
 
const float PI = 3.1415926536f, TWO_PI = 2.f * PI;
class vector2
{
public:
    vector2( float a = 0, float b = 0 ) { set( a, b ); }
    void set( float a, float b ) { x = a; y = b; }
    void rotate( float r ) {
        float _x = x, _y = y,
               s = sinf( r ), c = cosf( r ),
               a = _x * c - _y * s, b = _x * s + _y * c;
        x = a; y = b;
    }
    vector2 add( const vector2& v ) {
        x += v.x; y += v.y;
        return *this;
    }
    float x, y;
};
class myBitmap
{
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap(){
        DeleteObject( pen );
        DeleteObject( brush );
        DeleteDC( hdc );
        DeleteObject( bmp );
    }
    bool create( int w, int h ){
        BITMAPINFO    bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
 
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
 
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
 
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ){
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ){
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ){
        clr = c; createPen();
    }
    void setPenWidth( int w ){
        wid = w; createPen();
    }
    void saveBitmap( std::string path ){
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
 
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
 
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
private:
    void createPen(){
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC hdc;
    HPEN pen; HBRUSH brush;
    void *pBits; int width, height, wid;
    DWORD clr;
};
int main( int argc, char* argv[] ) {
    srand( unsigned( time( 0 ) ) );
    myBitmap bmp;
    bmp.create( 600, 600 ); bmp.clear();
    HDC dc = bmp.getDC();
    float fs = ( TWO_PI ) / 100.f;
    int index = 0;
    std::string a = strv, b;
    float ang, len;
    vector2 p1, p2;
 
    for( float step = 0.1f; step < 5.1f; step += .05f ) {
        ang = 0; len = 2;
        p1.set( 300, 300 );
        bmp.setPenColor( RGB( rand() % 50 + 200, rand() % 300 + 220, rand() % 50 + 200 ) );
        for( float xx = 0; xx < TWO_PI; xx += fs ) {
            MoveToEx( dc, (int)p1.x, (int)p1.y, NULL );
            p2.set( 0, len ); p2.rotate( ang ); p2.add( p1 );
            LineTo( dc, (int)p2.x, (int)p2.y );
            p1 = p2; ang += step; len += step;
        }
        std::ostringstream ss; ss << index++;
        b = a + ss.str() + strv;
        bmp.saveBitmap( b );
        bmp.clear();
    }
    return 0;
}
 "
"#include <iostream>
#include <set>
#include <vector>
#include <iterator>
#include <algorithm>
typedef std::set<int> set_type;
typedef std::set<set_type> powerset_type;
 
powerset_type powerset(set_type const& set)
{
  typedef set_type::const_iterator set_iter;
  typedef std::vector<set_iter> vec;
  typedef vec::iterator vec_iter;
 
  struct local
  {
    static int dereference(set_iter v) { return *v; }
  };
 
  powerset_type result;
 
  vec elements;
  do
  {
    set_type tmp;
    std::transform(elements.begin(), elements.end(),
                   std::inserter(tmp, tmp.end()),
                   local::dereference);
    result.insert(tmp);
    if (!elements.empty() && ++elements.back() == set.end())
    {
      elements.pop_back();
    }
    else
    {
      set_iter iter;
      if (elements.empty())
      {
        iter = set.begin();
      }
      else
      {
        iter = elements.back();
        ++iter;
      }
      for (; iter != set.end(); ++iter)
      {
        elements.push_back(iter);
      }
    }
  } while (!elements.empty());
 
  return result;
}
 
int main()
{
  int values[4] = { 2, 3, 5, 7 };
  set_type test_set(values, values+4);
 
  powerset_type test_powerset = powerset(test_set);
 
  for (powerset_type::iterator iter = test_powerset.begin();
       iter != test_powerset.end();
       ++iter)
  {
    std::cout << strv;
    char const* prefix = strv;
    for (set_type::iterator iter2 = iter->begin();
         iter2 != iter->end();
         ++iter2)
    {
      std::cout << prefix << *iter2;
      prefix = strv;
    }
    std::cout << "" }"";
  }
} 
#include <set>
#include <iostream>
 
template <class S>
auto powerset(const S& s)
{
    std::set<S> ret;
    ret.emplace();
    for (auto&& e: s) {
        std::set<S> rs;
        for (auto x: ret) {
            x.insert(e);
            rs.insert(x);
        }
        ret.insert(begin(rs), end(rs));
    }
    return ret;
}
 
int main()
{
    std::set<int> s = {2, 3, 5, 7};
    auto pset = powerset(s);
 
    for (auto&& subset: pset) {
        std::cout << strv;
        char const* prefix = strv;
        for (auto&& e: subset) {
            std::cout << prefix << e;
            prefix = strv;
        }
        std::cout << "" }"";
    }
}
 #include <iostream>
#include <set>
 
template<typename Set> std::set<Set> powerset(const Set& s, size_t n)
{
    typedef typename Set::const_iterator SetCIt;
    typedef typename std::set<Set>::const_iterator PowerSetCIt;
    std::set<Set> res;
    if(n > 0) {
        std::set<Set> ps = powerset(s, n-1);
        for(PowerSetCIt ss = ps.begin(); ss != ps.end(); ss++)
            for(SetCIt el = s.begin(); el != s.end(); el++) {
                Set subset(*ss);
                subset.insert(*el);
                res.insert(subset);
            }
        res.insert(ps.begin(), ps.end());
    } else
        res.insert(Set());
    return res;
}
template<typename Set> std::set<Set> powerset(const Set& s)
{
    return powerset(s, s.size());
}
 "
"#include <iostream>
 
class T
{
public:
  virtual void identify() { std::cout << strv << std::endl; }
  virtual T* clone() { return new T(*this); }
  virtual ~T() {}
};
 
class S: public T
{
public:
  virtual void identify() { std::cout << strv << std::endl; }
  virtual S* clone() { return new S(*this); }
};
 
class X 

{
public:
  

  X(T* t): member(t) {}
 
  

  X(X const& other): member(other.member->clone()) {}
 
  

  X& operator=(X const& other)
  {
    T* new_member = other.member->clone();
    delete member;
    member = new_member;
  }
 
  

  ~X() { delete member; }
 
  

  void identify_member() { member->identify(); }
 
private:
  T* member;
};
 
int main()
{
  X original(new S);      

  X copy = original;      

  copy.identify_member(); 

}"
"class Point
{
  protected:
    int x, y;
  public:
    Point(int x0 = 0, int y0 = 0) : x(x0), y(y0) {}
    Point(const Point& p) : x(p.x), y(p.y) {}
    virtual ~Point() {}
    const Point& operator=(const Point& p)
    {
      if(this != &p)
      {
        x = p.x;
        y = p.y;
      }
      return *this;
    }
    int getX() { return x; }
    int getY() { return y; }
    int setX(int x0) { x = x0; }
    int setY(int y0) { y = y0; }
    virtual void print() { printf(""Point""); }
};
 
class Circle : public Point
{
  private:
    int r;
  public:
    Circle(Point p, int r0 = 0) : Point(p), r(r0) {}
    Circle(int x0 = 0, int y0 = 0, int r0 = 0) : Point(x0, y0), r(r0) {}
    virtual ~Circle() {}
    const Circle& operator=(const Circle& c)
    {
      if(this != &c)
      {
        x = c.x;
        y = c.y;
        r = c.r;
      }
      return *this;
    }
    int getR() { return r; }
    int setR(int r0) { r = r0; }
    virtual void print() { printf(""Circle""); }
};
 
int main()
{
  Point* p = new Point();
  Point* c = new Circle();
  p->print();
  c->print();     
  return 0;
}

template <typename Derived>
class PointShape
{
protected:
  int x, y;
public:
  PointShape(int x0, int y0) : x(x0), y(y0) { }
  ~PointShape() { }
  int getX() { return x; }
  int getY() { return y; }
  int setX(int x0) { x = x0; }
  int setY(int y0) { y = y0; }
 
  

  void print() { reinterpret_cast<const Derived*>(this)->printType(); }
};
 
class Point : public PointShape<Point>
{
public:
  Point(int x0 = 0, int y0 = 0) : PointShape(x0, y0) { }
  Point(const Point& p) : PointShape(p.x, p.y) { }
  ~Point() {}
  const Point& operator=(const Point& p)
  {
    if(this != &p)
    {
      x = p.x;
      y = p.y;
    }
    return *this;
  }
  void printType() { printf(""Point""); }
};
 
class Circle : public PointShape<Circle>
{
private:
  int r;
public:
  Circle(int x0 = 0, int y0 = 0, int r0 = 0) : PointShape(x0, y0), r(r0) { }
  Circle(Point p, int r0 = 0) : PointShape(p.x, p.y), r(r0) { }
  ~Circle() {}
  const Circle& operator=(const Circle& c)
  {
    if(this != &c)
    {
      x = c.x;
      y = c.y;
      r = c.r;
    }
    return *this;
  }
  int getR() { return r; }
  int setR(int r0) { r = r0; }
  void printType() { printf(""Circle""); }
};
 
int main()
{
  Point* p = new Point();
  Point* c = new Circle();
  p->print();
  c->print();
  return 0;
}"
" 
#include <iostream>
#include <sstream>
#include <algorithm>
#include <vector>
 
using namespace std;
 
class poker
{
public:
    poker() { face = strv; suit = strv; }
    string analyze( string h )
    {
	memset( faceCnt, 0, 13 ); memset( suitCnt, 0, 4 ); vector<string> hand;
	transform( h.begin(), h.end(), h.begin(), toupper ); istringstream i( h );
	copy( istream_iterator<string>( i ), istream_iterator<string>(), back_inserter<vector<string> >( hand ) );
	if( hand.size() != 5 ) return strv; vector<string>::iterator it = hand.begin();
	sort( it, hand.end() ); if( hand.end() != adjacent_find( it, hand.end() ) ) return strv;
	while( it != hand.end() )
	{
	    if( ( *it ).length() != 2 ) return strv;
	    int n = face.find( ( *it ).at( 0 ) ), l = suit.find( ( *it ).at( 1 ) );
	    if( n < 0 || l < 0 ) return strv;
	    faceCnt[n]++; suitCnt[l]++; it++;
	}
	cout << h << strv; return analyzeHand();
    }
private:
    string analyzeHand()
    {
	bool p1 = false, p2 = false, t = false, f = false, fl = false, st = false;
	for( int x = 0; x < 13; x++ )
	    switch( faceCnt[x] )
	    {
		case 2: if( p1 ) p2 = true; else p1 = true; break;
		case 3: t = true; break;
		case 4: f = true;
	    }
	for( int x = 0; x < 4; x++ )if( suitCnt[x] == 5 ){ fl = true; break; }
 
	if( !p1 && !p2 && !t && !f )
        {
	    int s = 0;
	    for( int x = 0; x < 13; x++ )
	    { 
		if( faceCnt[x] ) s++; else s = 0;
		if( s == 5 ) break;
	    }
	    st = ( s == 5 ) || ( s == 4 && faceCnt[0] && !faceCnt[1] );
	}
 
	if( st && fl ) return strv;
	else if( f ) return strv; 
	else if( p1 && t ) return strv;
	else if( fl ) return strv;
	else if( st ) return strv;
	else if( t ) return strv;
	else if( p1 && p2 ) return strv;
	else if( p1 ) return strv;
        return strv;
    }
    string face, suit;
    unsigned char faceCnt[13], suitCnt[4];
};
 
int main( int argc, char* argv[] )
{
    poker p; 
    cout << p.analyze( strv ) << endl; cout << p.analyze( strv ) << endl;
    cout << p.analyze( strv ) << endl; cout << p.analyze( strv ) << endl;
    cout << p.analyze( strv ) << endl; cout << p.analyze( strv ) << endl;
    cout << p.analyze( strv ) << endl; cout << p.analyze( strv ) << endl;
    cout << p.analyze( strv ) << endl << endl; return system( strv );
}
 "
"int* pointer2(&var);int var = 3;
int& ref = var;


int& ref2(var);int v = ref; 

ref = 42; 
int array[10];
int& ref3 = array[0];v = (&ref)[3]; 
"
" 
#include <windows.h>
#include <string>
#include <vector>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int HSTEP = 46, MWID = 40, MHEI = 471;
const float VSTEP = 2.3f;
 
//--------------------------------------------------------------------------------------------------
class vector2
{
public:
    vector2() { x = y = 0; }
    vector2( float a, float b )  { x = a; y = b; }
    void set( float a, float b ) { x = a; y = b; }
    float x, y;
};
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteObject( brush );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO    bi;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes      = 1;
	bi.bmiHeader.biWidth       =  w;
	bi.bmiHeader.biHeight      = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc );
 
	width = w; height = h;
	return true;
    }
 
    void clear( BYTE clr = 0 )
    {
	memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
 
    void setBrushColor( DWORD bClr )
    {
	if( brush ) DeleteObject( brush );
	brush = CreateSolidBrush( bClr );
	SelectObject( hdc, brush );
    }
 
    void setPenColor( DWORD c ) { clr = c; createPen(); }
 
    void setPenWidth( int w )   { wid = w; createPen(); }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO       infoheader;
	BITMAP           bitmap;
	DWORD            wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
 
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    void createPen()
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, wid, clr );
	SelectObject( hdc, pen );
    }
 
    HBITMAP bmp;
    HDC     hdc;
    HPEN    pen;
    HBRUSH  brush;
    void    *pBits;
    int     width, height, wid;
    DWORD   clr;
};
//--------------------------------------------------------------------------------------------------
class plot
{
public:
    plot() { bmp.create( 512, 512 ); }
 
    void draw( vector<vector2>* pairs )
    {
	bmp.clear( 0xff );
	drawGraph( pairs );
	plotIt( pairs );
 
	HDC dc = GetDC( GetConsoleWindow() );
	BitBlt( dc, 0, 30, 512, 512, bmp.getDC(), 0, 0, SRCCOPY );
	ReleaseDC( GetConsoleWindow(), dc );
	//bmp.saveBitmap( strv );
    }
 
private:
    void drawGraph( vector<vector2>* pairs )
    {
	HDC dc = bmp.getDC();
	bmp.setPenColor( RGB( 240, 240, 240 ) );
	DWORD b = 11, c = 40, x; 
	RECT rc; char txt[8];
 
	for( x = 0; x < pairs->size(); x++ )
	{
	    MoveToEx( dc, 40, b, NULL ); LineTo( dc, 500, b );
	    MoveToEx( dc, c, 11, NULL ); LineTo( dc, c, 471 );
 
	    wsprintf( txt, strv, ( pairs->size() - x ) * 20 );
	    SetRect( &rc, 0, b - 9, 36, b + 11 );
	    DrawText( dc, txt, lstrlen( txt ), &rc, DT_RIGHT | DT_VCENTER | DT_SINGLELINE );
 
	    wsprintf( txt, strv, x );
	    SetRect( &rc, c - 8, 472, c + 8, 492 );
	    DrawText( dc, txt, lstrlen( txt ), &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE );
 
	    c += 46; b += 46;
	}
 
	SetRect( &rc, 0, b - 9, 36, b + 11 );
	DrawText( dc, strv, 1, &rc, DT_RIGHT | DT_VCENTER | DT_SINGLELINE );
 
	bmp.setPenColor( 0 ); bmp.setPenWidth( 3 );
	MoveToEx( dc, 40, 11, NULL ); LineTo( dc, 40, 471 );
	MoveToEx( dc, 40, 471, NULL ); LineTo( dc, 500, 471 );
    }
 
    void plotIt( vector<vector2>* pairs )
    {	
	HDC dc = bmp.getDC();
	HBRUSH br = CreateSolidBrush( 255 );
	RECT rc;
 
	bmp.setPenColor( 255 ); bmp.setPenWidth( 2 );
	vector<vector2>::iterator it = pairs->begin();
	int a = MWID + HSTEP * static_cast<int>( ( *it ).x ), b = MHEI - static_cast<int>( VSTEP * ( *it ).y );
	MoveToEx( dc, a, b, NULL );
	SetRect( &rc, a - 3, b - 3, a + 3, b + 3 ); FillRect( dc, &rc, br );
 
	it++;
	for( ; it < pairs->end(); it++ )
	{
	    a = MWID + HSTEP * static_cast<int>( ( *it ).x );
	    b = MHEI - static_cast<int>( VSTEP * ( *it ).y );
	    SetRect( &rc, a - 3, b - 3, a + 3, b + 3 );
	    FillRect( dc, &rc, br ); LineTo( dc, a, b );
	}
 
	DeleteObject( br );
    }
 
    myBitmap bmp;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );
    plot pt;
    vector<vector2> pairs;
    pairs.push_back( vector2( 0, 2.7f ) ); pairs.push_back( vector2( 1, 2.8f ) );
    pairs.push_back( vector2( 2.0f, 31.4f ) ); pairs.push_back( vector2( 3.0f, 38.1f ) );
    pairs.push_back( vector2( 4.0f, 58.0f ) ); pairs.push_back( vector2( 5.0f, 76.2f ) );
    pairs.push_back( vector2( 6.0f, 100.5f ) ); pairs.push_back( vector2( 7.0f, 130.0f ) );
    pairs.push_back( vector2( 8.0f, 149.3f ) ); pairs.push_back( vector2( 9.0f, 180.0f ) );
 
    pt.draw( &pairs );
    system( strv );
 
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <deque>
#include <algorithm>
#include <ostream>
#include <iterator>
 
namespace cards
{
class card
{
public:
    enum pip_type { two, three, four, five, six, seven, eight, nine, ten,
                    jack, queen, king, ace, pip_count };
    enum suite_type { hearts, spades, diamonds, clubs, suite_count };
    enum { unique_count = pip_count * suite_count };
 
    card(suite_type s, pip_type p): value(s + suite_count * p) {}
 
    explicit card(unsigned char v = 0): value(v) {}
 
    pip_type pip() { return pip_type(value / suite_count); }
 
    suite_type suite() { return suite_type(value % suite_count); }
 
private:
    unsigned char value;
};
 
const char* const pip_names[] =
    { strv, strv, strv, strv, strv, strv, strv, strv, strv,
      strv, strv, strv, strv };
 
std::ostream& operator<<(std::ostream& os, card::pip_type pip)
{
    return os << pip_names[pip];
}
 
const char* const suite_names[] =
    { strv, strv, strv, strv };
 
std::ostream& operator<<(std::ostream& os, card::suite_type suite)
{
    return os << suite_names[suite];
}
 
std::ostream& operator<<(std::ostream& os, card c)
{
    return os << c.pip() << strv << c.suite();
}
 
class deck
{
public:
    deck()
    {
        for (int i = 0; i < card::unique_count; ++i) {
            cards.push_back(card(i));
        }
    }
 
    void shuffle() { std::random_shuffle(cards.begin(), cards.end()); }
 
    card deal() { card c = cards.front(); cards.pop_front(); return c; }
 
    typedef std::deque<card>::const_iterator const_iterator;
    const_iterator begin() const { return cards.cbegin(); }
    const_iterator end() const { return cards.cend(); }
private:
    std::deque<card> cards;
};
 
inline std::ostream& operator<<(std::ostream& os, const deck& d)
{
    std::copy(d.begin(), d.end(), std::ostream_iterator<card>(os, """"));
    return os;
}
}
 "
" 
#include <windows.h>
#include <math.h>
#include <string>
 
const int BMP_SIZE = 240, MY_TIMER = 987654;
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
 
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
 
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
 
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    void saveBitmap( std::string path ) {
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
 
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
 
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
 
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    DWORD* bits()          { return ( DWORD* )pBits; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC    hdc;
    HPEN    pen; HBRUSH brush;
    void    *pBits; int width, height, wid;
    DWORD    clr;
};
class plasma
{
public:
    plasma() {
        currentTime = 0; _WD = BMP_SIZE >> 1; _WV = BMP_SIZE << 1;
        _bmp.create( BMP_SIZE, BMP_SIZE ); _bmp.clear();
        plasma1 = new BYTE[BMP_SIZE * BMP_SIZE * 4];
        plasma2 = new BYTE[BMP_SIZE * BMP_SIZE * 4];
        int i, j, dst = 0;
        double temp;
        for( j = 0; j < BMP_SIZE * 2; j++ ) {
            for( i = 0; i < BMP_SIZE * 2; i++ ) {
                plasma1[dst] = ( BYTE )( 128.0 + 127.0 * ( cos( ( double )hypot( BMP_SIZE - j, BMP_SIZE - i ) / 64.0 ) ) );
                plasma2[dst] = ( BYTE )( ( sin( ( sqrt( 128.0 + ( BMP_SIZE - i ) * ( BMP_SIZE - i ) + 
                               ( BMP_SIZE - j ) * ( BMP_SIZE - j ) ) - 4.0 ) / 32.0 ) + 1 ) * 90.0 );
                dst++;
            }
        }
    }
    void update() {
        DWORD dst;
        BYTE a, c1,c2, c3;
        currentTime += ( double )( rand() % 2 + 1 );
 
        int x1 = _WD + ( int )( ( _WD - 1 ) * sin( currentTime  / 137 ) ),
            x2 = _WD + ( int )( ( _WD - 1 ) * sin( -currentTime /  75 ) ),
            x3 = _WD + ( int )( ( _WD - 1 ) * sin( -currentTime / 125 ) ),
            y1 = _WD + ( int )( ( _WD - 1 ) * cos( currentTime  / 123 ) ),
            y2 = _WD + ( int )( ( _WD - 1 ) * cos( -currentTime /  85 ) ),
            y3 = _WD + ( int )( ( _WD - 1 ) * cos( -currentTime / 108 ) );
 
        int src1 = y1 * _WV + x1, src2 = y2 * _WV + x2, src3 = y3 * _WV + x3;
 
        DWORD* bits = _bmp.bits();
        for( int j = 0; j < BMP_SIZE; j++ ) {
            dst = j * BMP_SIZE;
            for( int i= 0; i < BMP_SIZE; i++ ) {
                a = plasma2[src1] + plasma1[src2] + plasma2[src3];
                c1 = a << 1; c2 = a << 2; c3 = a << 3;
                bits[dst + i] = RGB( c1, c2, c3 );
                src1++; src2++; src3++;
            }
            src1 += BMP_SIZE; src2 += BMP_SIZE; src3 += BMP_SIZE;
        }
        draw();
    }
    void setHWND( HWND hwnd ) { _hwnd = hwnd; }
private:
    void draw() {
        HDC dc = _bmp.getDC(), wdc = GetDC( _hwnd );
        BitBlt( wdc, 0, 0, BMP_SIZE, BMP_SIZE, dc, 0, 0, SRCCOPY );
        ReleaseDC( _hwnd, wdc );
    }
    myBitmap _bmp; HWND _hwnd; float _ang;
    BYTE *plasma1, *plasma2;
    double currentTime; int _WD, _WV;
};
class wnd
{
public:
    wnd() { _inst = this; }
    int wnd::Run( HINSTANCE hInst ) {
        _hInst = hInst; _hwnd = InitAll();
        SetTimer( _hwnd, MY_TIMER, 15, NULL );
        _plasma.setHWND( _hwnd );
        ShowWindow( _hwnd, SW_SHOW );
        UpdateWindow( _hwnd );
        MSG msg;
        ZeroMemory( &msg, sizeof( msg ) );
        while( msg.message != WM_QUIT ) {
            if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 ) {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }
        return UnregisterClass( strv, _hInst );
    }
private:
    void wnd::doPaint( HDC dc ) { _plasma.update(); }
    void wnd::doTimer()         { _plasma.update(); }
    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) {
        switch( msg ) {
            case WM_PAINT: {
                    PAINTSTRUCT ps;
                    _inst->doPaint( BeginPaint( hWnd, &ps ) );
                    EndPaint( hWnd, &ps );
                    return 0;
                }
            case WM_DESTROY: PostQuitMessage( 0 ); break;
            case WM_TIMER: _inst->doTimer(); break;
            default: return DefWindowProc( hWnd, msg, wParam, lParam );
        }
        return 0;
    }
    HWND InitAll() {
        WNDCLASSEX wcex;
        ZeroMemory( &wcex, sizeof( wcex ) );
        wcex.cbSize        = sizeof( WNDCLASSEX );
        wcex.style         = CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc   = ( WNDPROC )WndProc;
        wcex.hInstance     = _hInst;
        wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
        wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
        wcex.lpszClassName = strv;
 
        RegisterClassEx( &wcex );
 
        RECT rc = { 0, 0, BMP_SIZE, BMP_SIZE };
        AdjustWindowRect( &rc, WS_SYSMENU | WS_CAPTION, FALSE );
        int w = rc.right - rc.left, h = rc.bottom - rc.top;
        return CreateWindow( strv, strv, WS_SYSMENU, CW_USEDEFAULT, 0, w, h, NULL, NULL, _hInst, NULL );
    }
    static wnd* _inst; HINSTANCE _hInst; HWND _hwnd; plasma _plasma;
};
wnd* wnd::_inst = 0;
int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow ) {
    wnd myWnd;
    return myWnd.Run( hInstance );
}
 "
" 
#include <windows.h>
 
//--------------------------------------------------------------------------------------------------
class pinstripe
{
public:
    pinstripe()                        { createColors(); }
    void setDimensions( int x, int y ) { _mw = x; _mh = y; }
    void createColors()
    {
	colors[0] = 0; colors[1] = RGB( 255, 255, 255 );
    }
 
    void draw( HDC dc )
    {
        HPEN pen;
	int lh = _mh / 4, row, cp;
	for( int lw = 1; lw < 5; lw++ )
	{
	    cp = 0;
            row = ( lw - 1 ) * lh;
	    for( int x = 0 + lw > 1 ? lw > 3 ? 2 : 1 : 0; x < _mw; x += lw )
	    {
		pen = CreatePen( PS_SOLID, lw, colors[cp] );
	        ++cp %= 2;
 
		SelectObject( dc, pen );
		MoveToEx( dc, x, row, NULL );
		LineTo( dc, x, row + lh );
		DeleteObject( pen );
	    }
	}
    }
 
private:
    int _mw, _mh;
    DWORD colors[2];
};
//--------------------------------------------------------------------------------------------------
pinstripe pin;
 
//--------------------------------------------------------------------------------------------------
void PaintWnd( HWND hWnd )
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint( hWnd, &ps );
    pin.draw( hdc );
    EndPaint( hWnd, &ps );
}
//--------------------------------------------------------------------------------------------------
LRESULT CALLBACK WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
	case WM_DESTROY: PostQuitMessage( 0 ); break;
	case WM_PAINT: PaintWnd( hWnd ); break;
	default:
	    return DefWindowProc( hWnd, msg, wParam, lParam );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
HWND InitAll( HINSTANCE hInstance )
{
    WNDCLASSEX wcex;
    ZeroMemory( &wcex, sizeof( wcex ) );
 
    wcex.cbSize	       = sizeof( WNDCLASSEX );
    wcex.style	       = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc   = WndProc;
    wcex.hInstance     = hInstance;
    wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
    wcex.lpszClassName = strv;
 
    RegisterClassEx( &wcex ); 
    return CreateWindow( strv, strv, WS_POPUP, CW_USEDEFAULT, 0, 200, 200, NULL, NULL, hInstance, NULL );
}
//--------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    srand( GetTickCount() );
 
    HWND hwnd = InitAll( hInstance );
    if( !hwnd ) return -1;
 
    int mw = GetSystemMetrics( SM_CXSCREEN ),
	mh = GetSystemMetrics( SM_CYSCREEN );
 
    pin.setDimensions( mw, mh );
 
    RECT rc = { 0, 0, mw, mh };
 
    AdjustWindowRectEx( &rc, WS_POPUP, FALSE, 0 );
    int w = rc.right  - rc.left, 
	h = rc.bottom - rc.top;
 
    int posX = ( GetSystemMetrics( SM_CXSCREEN ) >> 1 ) - ( w >> 1 ),
	posY = ( GetSystemMetrics( SM_CYSCREEN ) >> 1 ) - ( h >> 1 );
 
    SetWindowPos( hwnd, HWND_TOP, posX, posY, w, h, SWP_NOZORDER );
    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );
 
    MSG msg;
    ZeroMemory( &msg, sizeof( msg ) );
    while( msg.message != WM_QUIT )
    {
	if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
	{
	    TranslateMessage( &msg );
	    DispatchMessage( &msg );
	}
    }
    return UnregisterClass( strv, hInstance );
}
//--------------------------------------------------------------------------------------------------
 "
" 
#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int PLAYERS = 4, MAX_POINTS = 100;
 
//--------------------------------------------------------------------------------------------------
enum Moves { ROLL, HOLD };
 
//--------------------------------------------------------------------------------------------------
class player
{
public:
    player()                     { current_score = round_score = 0; }
    void addCurrScore()          { current_score += round_score; }
    int getCurrScore()           { return current_score; }
    int getRoundScore()          { return round_score; }
    void addRoundScore( int rs ) { round_score += rs; }
    void zeroRoundScore()        { round_score = 0; }
    virtual int getMove() = 0;
    virtual ~player() {}
 
protected:
    int current_score, round_score;
};
//--------------------------------------------------------------------------------------------------
class RAND_Player : public player
{
    virtual int getMove()
    {
	if( round_score + current_score >= MAX_POINTS ) return HOLD;
 
	if( rand() % 10 < 5 ) return ROLL;
	if( round_score > 0 ) return HOLD;
	return ROLL;
    }
};
//--------------------------------------------------------------------------------------------------
class Q2WIN_Player : public player
{
    virtual int getMove()
    {
	if( round_score + current_score >= MAX_POINTS ) return HOLD;
 
	int q = MAX_POINTS - current_score;
	if( q < 6 ) return ROLL;
	q /= 4;
	if( round_score < q ) return ROLL;
	return HOLD;
    }
};
//--------------------------------------------------------------------------------------------------
class AL20_Player : public player
{
    virtual int getMove()
    {
	if( round_score + current_score >= MAX_POINTS ) return HOLD;
 
	if( round_score < 20 ) return ROLL;
	return HOLD;
    }
};
//--------------------------------------------------------------------------------------------------
class AL20T_Player : public player
{
    virtual int getMove()
    {
	if( round_score + current_score >= MAX_POINTS ) return HOLD;
 
	int d = ( 100 * round_score ) / 20;
	if( round_score < 20 && d < rand() % 100 ) return ROLL;
	return HOLD;
    }
};
//--------------------------------------------------------------------------------------------------
class Auto_pigGame
{
public:
    Auto_pigGame() 
    {
	_players[0] = new RAND_Player();
	_players[1] = new Q2WIN_Player();
	_players[2] = new AL20_Player();
        _players[3] = new AL20T_Player();
    }
 
    ~Auto_pigGame()
    {
	delete _players[0];
	delete _players[1];
	delete _players[2];
        delete _players[3];
    }
 
    void play()
    {
	int die, p = 0;
	bool endGame = false;
 
	while( !endGame )
	{
	    switch( _players[p]->getMove() )
	    {
		case ROLL:
	    	    die = rand() % 6 + 1;
		    if( die == 1 )
		    {
			cout << strv << p + 1 << strv << die << strv << _players[p]->getCurrScore() << endl << endl;
			nextTurn( p );
			continue;
		    }
		    _players[p]->addRoundScore( die );
		    cout << strv << p + 1 << strv << die << strv << _players[p]->getRoundScore() << endl;
		break;
		case HOLD:
	    	    _players[p]->addCurrScore();
		    cout << strv << p + 1 << strv << _players[p]->getCurrScore() << endl << endl;
		    if( _players[p]->getCurrScore() >= MAX_POINTS )
			endGame = true;
		    else nextTurn( p );
 
	    }
	}
	showScore();
    }
 
private:
    void nextTurn( int& p )
    {
	_players[p]->zeroRoundScore();
	++p %= PLAYERS;
    }
 
    void showScore()
    {
	cout << endl;
	cout << strv  << _players[0]->getCurrScore() << endl;
	cout << strv << _players[1]->getCurrScore() << endl;
        cout << strv << _players[2]->getCurrScore() << endl;
	cout << strv  << _players[3]->getCurrScore() << endl << endl << endl;
 
	system( strv );
    }
 
    player*	_players[PLAYERS];
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( GetTickCount() );
    Auto_pigGame pg;
    pg.play();
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <string>
 
using namespace std;
 
class playfair
{
public:
    void doIt( string k, string t, bool ij, bool e )
    {
	createGrid( k, ij ); getTextReady( t, ij, e );
	if( e ) doIt( 1 ); else doIt( -1 );
	display();
    }
 
private:
    void doIt( int dir )
    {
	int a, b, c, d; string ntxt;
	for( string::const_iterator ti = _txt.begin(); ti != _txt.end(); ti++ )
	{
	    if( getCharPos( *ti++, a, b ) )
		if( getCharPos( *ti, c, d ) )
		{
		    if( a == c )     { ntxt += getChar( a, b + dir ); ntxt += getChar( c, d + dir ); }
		    else if( b == d ){ ntxt += getChar( a + dir, b ); ntxt += getChar( c + dir, d ); }
		    else             { ntxt += getChar( c, b ); ntxt += getChar( a, d ); }
		}
	}
	_txt = ntxt;
    }
 
    void display()
    {
	cout << "" OUTPUT:========="" << endl;
	string::iterator si = _txt.begin(); int cnt = 0;
	while( si != _txt.end() )
	{
	    cout << *si; si++; cout << *si << strv; si++;
	    if( ++cnt >= 26 ) cout << endl, cnt = 0;
	}
	cout << endl << endl;
    }
 
    char getChar( int a, int b )
    {
	return _m[ (b + 5) % 5 ][ (a + 5) % 5 ];
    }
 
    bool getCharPos( char l, int &a, int &b )
    {
	for( int y = 0; y < 5; y++ )
	    for( int x = 0; x < 5; x++ )
		if( _m[y][x] == l )
		{ a = x; b = y; return true; }
 
	return false;
    }
 
    void getTextReady( string t, bool ij, bool e )
    {
	for( string::iterator si = t.begin(); si != t.end(); si++ )
	{
	    *si = toupper( *si ); if( *si < 65 || *si > 90 ) continue;
	    if( *si == 'J' && ij ) *si = 'I';
	    else if( *si == 'Q' && !ij ) continue;
	    _txt += *si;
	}
	if( e )
	{
	    string ntxt = strv; size_t len = _txt.length();
	    for( size_t x = 0; x < len; x += 2 )
	    {
		ntxt += _txt[x];
		if( x + 1 < len )
		{
		    if( _txt[x] == _txt[x + 1] ) ntxt += 'X';
		    ntxt += _txt[x + 1];
		}
	    }
	    _txt = ntxt;
	}
	if( _txt.length() & 1 ) _txt += 'X';
    }
 
    void createGrid( string k, bool ij )
    {
	if( k.length() < 1 ) k = strv; 
	k += strv; string nk = strv;
	for( string::iterator si = k.begin(); si != k.end(); si++ )
	{
	    *si = toupper( *si ); if( *si < 65 || *si > 90 ) continue;
	    if( ( *si == 'J' && ij ) || ( *si == 'Q' && !ij ) )continue;
	    if( nk.find( *si ) == -1 ) nk += *si;
	}
	copy( nk.begin(), nk.end(), &_m[0][0] );
    }
 
    string _txt; char _m[5][5];
};
 
int main( int argc, char* argv[] )
{
    string key, i, txt; bool ij, e;
    cout << strv; getline( cin, i ); e = ( i[0] == 'e' || i[0] == 'E' );
    cout << strv; getline( cin, key ); 
    cout << strv; getline( cin, i ); ij = ( i[0] == 'y' || i[0] == 'Y' );
    cout << strv; getline( cin, txt ); 
    playfair pf; pf.doIt( key, txt, ij, e ); return system( strv );
}"
" 
#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int PLAYERS = 2, MAX_POINTS = 100;
 
//--------------------------------------------------------------------------------------------------
class player
{
public:
    player() { reset(); }
    void reset()
    {
	name = strv;
	current_score = round_score = 0;
    }
    string getName()             { return name; }
    void setName( string n )     { name = n; }
    int getCurrScore()           { return current_score; }
    void addCurrScore()          { current_score += round_score; }
    int getRoundScore()          { return round_score; }
    void addRoundScore( int rs ) { round_score += rs; }
    void zeroRoundScore()        { round_score = 0; }
 
private:
    string name;
    int current_score, round_score;
};
//--------------------------------------------------------------------------------------------------
class pigGame
{
public:
    pigGame() { resetPlayers(); }
 
    void play()
    {
	while( true )
	{
	    system( strv );
	    int p = 0;
	    while( true )
	    {
		if( turn( p ) )
		{
		    praise( p );
		    break;
		}
 
		++p %= PLAYERS;
	    }
 
	    string r;
	    cout << strv; cin >> r;
	    if( r != strv && r != strv ) return;
	    resetPlayers();
	}
    }
 
private:
    void resetPlayers()
    {
	system( strv );
	string n;
	for( int p = 0; p < PLAYERS; p++ )
	{
	    _players[p].reset();
	    cout << strv << p + 1 << strv; cin >> n;
	    _players[p].setName( n );
	}
 
    }
 
    void praise( int p )
    {
	system( strv );
	cout << strv << _players[p].getName() << strv << endl << endl;
	cout << strv << endl;
	drawScoreboard();
	cout << endl << endl;
    }
 
    void drawScoreboard()
    {
	for( int p = 0; p < PLAYERS; p++ )
	    cout << _players[p].getName() << strv << _players[p].getCurrScore() << strv << endl;
	cout << endl;
    }
 
    bool turn( int p )
    {
	system( strv );
	drawScoreboard();
	_players[p].zeroRoundScore();
	string r;
	int die;
	while( true )
	{
	    cout << _players[p].getName() << strv << _players[p].getRoundScore() << endl;
	    cout << strv; cin >> r;
	    if( r == strv || r == strv )
	    {
		_players[p].addCurrScore();
		return _players[p].getCurrScore() >= MAX_POINTS;
	    }
	    if( r == strv || r == strv )
	    {
		die = rand() % 6 + 1;
		if( die == 1 )
		{
	    	    cout << _players[p].getName() << strv << endl << endl;
		    system( strv );
		    return false;
		}
		_players[p].addRoundScore( die );
	    }
	    cout << endl;
	}
	return false;
    }
 
    player	_players[PLAYERS];
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( GetTickCount() );
    pigGame pg;
    pg.play();
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>
#include <sstream>
 
int main() {
   std::string s = strv;
   std::cout << strv << s << ''
             << strv << std::string(s.rbegin(), s.rend()) << '' ;
   std::istringstream is(s);
   std::vector<std::string> words(std::istream_iterator<std::string>(is), {});
   std::cout << strv ;
   for(auto w : words)
      std::cout << std::string(w.rbegin(), w.rend()) << ' ';
   std::cout << ''
             << strv ;
   reverse_copy(words.begin(), words.end(), std::ostream_iterator<std::string>(std::cout, strv));
   std::cout << '' ;
}
 "
"#include <iostream>
#include <random>
#include <vector>
 
int main( ) {
   std::vector<int> numbers { 11 , 88 , -5 , 13 , 4 , 121 , 77 , 2 } ;
   std::random_device seed ;
   

   std::mt19937 engine( seed( ) ) ;
   

   std::uniform_int_distribution<int> choose( 0 , numbers.size( ) - 1 ) ;
   std::cout << strv << numbers[ choose( engine ) ] 
      << "" !"" ;
   return 0 ;
}"
" 
#include <iostream>
#include <algorithm>
#include <bitset>
 
using namespace std;
 
class pernNumber
{
public:
    void displayFirst( unsigned cnt )
    {
	unsigned pn = 3; 
	while( cnt )
	{
	    if( isPernNumber( pn ) )
	    { 
		cout << pn << strv; cnt--;
	    }
	    pn++;
	}
    }
    void displayFromTo( unsigned a, unsigned b )
    {
	for( unsigned p = a; p <= b; p++ )
	    if( isPernNumber( p ) )
		cout << p << strv;
    }
 
private:
    bool isPernNumber( unsigned p )
    {
	string bin = bitset<64>( p ).to_string();
	unsigned c = count( bin.begin(), bin.end(), '1' );
	return isPrime( c );
    }
    bool isPrime( unsigned p )
    {
	if( p == 2 ) return true;
	if( p < 2 || !( p % 2 ) ) return false;
	for( unsigned x = 3; ( x * x ) <= p; x += 2 )
	    if( !( p % x ) ) return false;
	return true;
    }
};
int main( int argc, char* argv[] )
{
    pernNumber p; 
    p.displayFirst( 25 ); cout << endl;
    p.displayFromTo( 888888877, 888888888 ); cout << endl;
    return 0;
}
 "
" 
#include <iostream>
#include <vector>
 
using namespace std;
 
vector<int> UpTo(int n, int offset = 0)
{
	vector<int> retval(n);
	for (int ii = 0; ii < n; ++ii)
		retval[ii] = ii + offset;
	return retval;
}
 
struct JohnsonTrotterState_
{
	vector<int> values_;
	vector<int> positions_;	

	vector<bool> directions_;
	int sign_;
 
	JohnsonTrotterState_(int n) : values_(UpTo(n, 1)), positions_(UpTo(n + 1, -1)), directions_(n + 1, false), sign_(1) {}
 
	int LargestMobile() const	

	{
		for (int r = values_.size(); r > 0; --r)
		{
			const int loc = positions_[r] + (directions_[r] ? 1 : -1);
			if (loc >= 0 && loc < values_.size() && values_[loc] < r)
				return r;
		}
		return 0;
	}
 
	bool IsComplete() const { return LargestMobile() == 0; }
 
	void operator++()	

	{
		const int r = LargestMobile();
		const int rLoc = positions_[r];
		const int lLoc = rLoc + (directions_[r] ? 1 : -1);
		const int l = values_[lLoc];
		

		swap(values_[lLoc], values_[rLoc]);
		swap(positions_[l], positions_[r]);
		sign_ = -sign_;
		

		for (auto pd = directions_.begin() + r + 1; pd != directions_.end(); ++pd)
			*pd = !*pd;
	}
};
 
int main(void)
{
	JohnsonTrotterState_ state(4);
	do
	{
		for (auto v : state.values_)
			cout << v << strv;
		cout << """";
		++state;
	} while (!state.IsComplete());
}
 "
"#include<iostream>
#include<vector>
#include<numeric>
#include<functional>
 
class
{
public:
    int64_t operator()(int n, int k){ return partial_factorial(n, k) / factorial(n - k);}
private:
    int64_t partial_factorial(int from, int to) { return from == to ? 1 : from * partial_factorial(from - 1, to); }
    int64_t factorial(int n) { return n == 0 ? 1 : n * factorial(n - 1);}
}combinations;
 
int main()
{
    static constexpr int treatment = 9;
    const std::vector<int> data{ 85, 88, 75, 66, 25, 29, 83, 39, 97,
                                 68, 41, 10, 49, 16, 65, 32, 92, 28, 98 };
 
    int treated = std::accumulate(data.begin(), data.begin() + treatment, 0);
 
    std::function<int (int, int, int)> pick;
    pick = [&](int n, int from, int accumulated)
            {
                if(n == 0)
                    return accumulated > treated ? 1 : 0;
                else
                    return pick(n - 1, from - 1, accumulated + data[from - 1]) +
                            (from > n ? pick(n, from - 1, accumulated) : 0);
            };
 
    int total   = combinations(data.size(), treatment);
    int greater = pick(treatment, data.size(), 0);
    int lesser  = total - greater;
 
    std::cout << strv << 100.0 * lesser  / total << strv << lesser  << std::endl
              << strv << 100.0 * greater / total << strv << greater << std::endl;
}"
" 
#include <iostream>
#include <algorithm>
#include <vector>
 
int pShuffle( int t ) {
    std::vector<int> v, o, r;
 
    for( int x = 0; x < t; x++ ) {
        o.push_back( x + 1 );
    }
 
    r = o;
    int t2 = t / 2 - 1, c = 1;
 
    while( true ) {
        v = r;
        r.clear();
 
        for( int x = t2; x > -1; x-- ) {
            r.push_back( v[x + t2 + 1] );
            r.push_back( v[x] );
        }
 
        std::reverse( r.begin(), r.end() );
 
        if( std::equal( o.begin(), o.end(), r.begin() ) ) return c;
        c++;
    }
}
 
int main() {
    int s[] = { 8, 24, 52, 100, 1020, 1024, 10000 };
    for( int x = 0; x < 7; x++ ) {
        std::cout << strv << s[x] << strv;
        std::cout << pShuffle( s[x] ) << ""."";
    }
    return 0;
}
 "
"#include <algorithm>
#include <string>
#include <vector>
#include <iostream>
 
template<class T>
void print(const std::vector<T> &vec)
{
    for (typename std::vector<T>::const_iterator i = vec.begin(); i != vec.end(); ++i)
    {
        std::cout << *i;
        if ((i + 1) != vec.end())
            std::cout << strv;
    }
    std::cout << std::endl;
}
 
int main()
{
    //Permutations for strings
    std::string example(strv);
    std::sort(example.begin(), example.end());
    do {
        std::cout << example << '';
    } while (std::next_permutation(example.begin(), example.end()));
 
    

    std::vector<int> another;
    another.push_back(1234);
    another.push_back(4321);
    another.push_back(1234);
    another.push_back(9999);
 
    std::sort(another.begin(), another.end());
    do {
        print(another);
    } while (std::next_permutation(another.begin(), another.end()));
 
    return 0;
}"
"#include <algorithm>
#include <random>
#include <vector>
#include <iostream>
#include <numeric>
#include <iomanip>
using VecIt = std::vector<int>::const_iterator ;
 
//creates vector of length n, based on probability p for 1
std::vector<int> createVector( int n, double p ) {
   std::vector<int> result( n ) ;
   std::random_device rd ;
   std::mt19937 gen( rd( ) ) ;
   std::uniform_real_distribution<> dis( 0 , 1 ) ;
   for ( int i = 0 ; i < n ; i++ ) {
      double number = dis( gen ) ;
      if ( number <= p ) 
	 result[ i ] = 1 ;
      else 
	 result[ i ] = 0 ;
   }
   return result ;
}
 
//find number of 1 runs in the vector
int find_Runs( const std::vector<int> & numberVector ) {
   int runs = 0 ;
   VecIt found = numberVector.begin( ) ;
   while ( ( found = std::find( found , numberVector.end( ) , 1 ) ) 
	 != numberVector.end( ) ) {
      runs++ ;
      while ( found != numberVector.end( ) && ( *found == 1 ) ) 
	 std::advance( found , 1 ) ;
      if ( found == numberVector.end( ) ) 
	 break ;
   }
   return runs ;
}
 
int main( ) {
   std::cout << ""t = 100"" ;
   std::vector<double> p_values { 0.1 , 0.3 , 0.5 , 0.7 , 0.9 } ;
   for ( double p : p_values ) { 
      std::cout << strv << p << strv << p * ( 1 - p ) << std::endl ;
      for ( int n = 10 ; n < 100000 ; n *= 10 ) {
	 std::vector<double> runsFound ;
	 for ( int i = 0 ; i < 100 ; i++ ) {
	    std::vector<int> ones_and_zeroes = createVector( n , p ) ;
	    runsFound.push_back( find_Runs( ones_and_zeroes ) / static_cast<double>( n ) ) ;
	 }
	 double average = std::accumulate( runsFound.begin( ) , runsFound.end( ) , 0.0 ) / runsFound.size( ) ;
	 std::cout << strv << std::setw( 6 ) << std::right << n << strv << average << std::endl ;
      }
   }
   return 0 ;
}"
"#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
 
using namespace std;
 
class Grid {
public:
    Grid(const double p, const int x, const int y) : m(x), n(y) {
        const int thresh = static_cast<int>(RAND_MAX * p);
 
        

        

        start = new cell[m * (n + 2)];
        cells = start + m;
        for (auto i = 0; i < m; i++) start[i] = RBWALL;
        end = cells;
        for (auto i = 0; i < y; i++) {
            for (auto j = x; --j;)
                *end++ = (rand() < thresh ? BWALL : 0) | (rand() < thresh ? RWALL : 0);
            *end++ = RWALL | (rand() < thresh ? BWALL : 0);
        }
        memset(end, 0u, sizeof(cell) * m);
    }
 
    ~Grid() {
        delete[] start;
        cells = 0;
        start = 0;
        end = 0;
    }
 
    int percolate() const {
        auto i = 0;
        for (; i < m && !fill(cells + i); i++);
        return i < m;
    }
 
    void show() const {
        for (auto j = 0; j < m; j++)
            cout << (strv);
        cout << '+' << endl;
 
        for (auto i = 0; i <= n; i++) {
            cout << (i == n ? ' ' : '|');
            for (auto j = 0; j < m; j++) {
                cout << ((cells[i * m + j] & FILL) ? strv : strv);
                cout << ((cells[i * m + j] & RWALL) ? '|' : ' ');
            }
            cout << endl;
 
            if (i == n) return;
 
            for (auto j = 0; j < m; j++)
                cout << ((cells[i * m + j] & BWALL) ? strv : strv);
            cout << '+' << endl;
        }
    }
 
private:
    enum cell_state {
        FILL   = 1 << 0,
        RWALL  = 1 << 1,       

        BWALL  = 1 << 2,       

        RBWALL = RWALL | BWALL 

    };
 
    typedef unsigned int cell;
 
    bool fill(cell* p) const {
        if ((*p & FILL)) return false;
        *p |= FILL;
        if (p >= end) return true; 

 
        return (!(p[0] & BWALL) && fill(p + m)) || (!(p[0] & RWALL) && fill(p + 1))
                ||(!(p[-1] & RWALL) && fill(p - 1)) || (!(p[-m] & BWALL) && fill(p - m));
    }
 
    cell* cells;
    cell* start;
    cell* end;
    const int m;
    const int n;
};
 
int main() {
    const auto M = 10, N = 10;
    const Grid grid(.5, M, N);
    grid.percolate();
    grid.show();
 
    const auto C = 10000;
    cout << endl << strv << M << strv << N << strv << C << strv << endl;
    for (auto p = 1; p < M; p++) {
        auto cnt = 0, i = 0;
        for (; i < C; i++)
            cnt += Grid(p / static_cast<double>(M), M, N).percolate();
        cout << strv << p / static_cast<double>(M) << strv << static_cast<double>(cnt) / i << endl;
    }
 
    return EXIT_SUCCESS;
}"
"#include <iostream>
using namespace std ;
 
int divisor_sum( int number ) { 
   int sum = 0 ; 
   for ( int i = 1 ; i < number ; i++ ) 
      if ( number % i == 0 ) 
         sum += i ; 
   return sum; 
}
 
int main( ) { 
   cout << ""Perfect numbers from 1 to 33550337:"" ;
   for ( int num = 1 ; num < 33550337 ; num++ ) { 
      if (divisor_sum(num) == num) 
         cout << num << '' ;
   }   
   return 0 ; 
}
 "
"#include <QImage>
#include <cstdlib>
#include <QColor>
#include <iostream>
 
int main( int argc , char *argv[ ] ) {
   if ( argc != 3 ) {
      std::cout << strv 
	 << "" <file of image 2>"" ;
      return 1 ;
   }
   QImage firstImage ( argv[ 1 ] ) ;
   QImage secondImage ( argv[ 2 ] ) ;
   double totaldiff = 0.0 ; //holds the number of different pixels
   int h = firstImage.height( ) ;
   int w = firstImage.width( ) ;
   int hsecond = secondImage.height( ) ;
   int wsecond = secondImage.width( ) ;
   if ( w != wsecond || h != hsecond ) {
      std::cerr << ""Error, pictures must have identical dimensions!"" ;
      return 2 ;
   } 
   for ( int y = 0 ; y < h ; y++ ) {
      uint *firstLine = ( uint* )firstImage.scanLine( y ) ;
      uint *secondLine = ( uint* )secondImage.scanLine( y ) ;
      for ( int x = 0 ; x < w ; x++ ) {
	 uint pixelFirst = firstLine[ x ] ;
	 int rFirst = qRed( pixelFirst ) ;
	 int gFirst = qGreen( pixelFirst ) ;
	 int bFirst = qBlue( pixelFirst ) ;
	 uint pixelSecond = secondLine[ x ] ;
	 int rSecond = qRed( pixelSecond ) ;
	 int gSecond = qGreen( pixelSecond ) ;
	 int bSecond = qBlue( pixelSecond ) ;
	 totaldiff += std::abs( rFirst - rSecond ) / 255.0 ;
	 totaldiff += std::abs( gFirst - gSecond ) / 255.0 ;
	 totaldiff += std::abs( bFirst -bSecond ) / 255.0 ;
      }
   }
   std::cout << strv <<
      (totaldiff * 100)  / (w * h * 3)  << "" % !"" ;
   return 0 ;
}"
" 
#include <time.h>
#include <iostream>
#include <string>
 
using namespace std;
 
class penney
{
public:
    penney()
    { pW = cW = 0;  }
    void gameLoop()
    {
	string a;
	while( true )
	{
	    playerChoice = computerChoice = strv;
	    if( rand() % 2 ) 
	    { computer(); player(); }
	    else
	    { player(); computer(); }
 
	    play();
 
	    cout << strv; cin >> a;
	    if( a[0] != 'Y' && a[0] != 'y' ) 
	    {
		cout << strv << cW << strv << endl << strv << pW << strv;
		break;
	    }
	    cout << endl << endl;
        }
    }
private:
    void computer()
    {
        if( playerChoice.length() == 0 )
	{
	    for( int x = 0; x < 3; x++ )
		computerChoice.append( ( rand() % 2 ) ? strv : strv, 1 );	
	}
	else
	{
	    computerChoice.append( playerChoice[1] == 'T' ? strv : strv, 1 );
	    computerChoice += playerChoice.substr( 0, 2 );
	}
	cout << strv << computerChoice << endl;
    }
    void player()
    {
	cout << strv; cin >> playerChoice;
    }
    void play()
    {
	sequence = strv;
	while( true )
	{
	    sequence.append( ( rand() % 2 ) ? strv : strv, 1 );
	    if( sequence.find( playerChoice ) != sequence.npos )
	    {
		showWinner( 1 );
		break;
	    }
	    else if( sequence.find( computerChoice ) != sequence.npos )
	    {
		showWinner( 0 );
		break;
	    }
	}
    }
    void showWinner( int i )
    {
	string s;
	if( i ) { s = strv; pW++; }
	else { s = strv; cW++; }
	cout << strv << sequence << endl << s << endl << endl;
    }
    string playerChoice, computerChoice, sequence;
    int pW, cW;
};
int main( int argc, char* argv[] )
{
    srand( static_cast<unsigned>( time( NULL ) ) );
    penney game; game.gameLoop();
    return 0;
}
 "
" 
#include <iostream>
#include <string>
#include <algorithm>
#include <ctime>
 
const std::string CHR[] = { strv, strv, 
                            strv, ""!#$%&'()*+,-./:;<=>?@[]^_{|}~"" };
const std::string UNS = strv;
 
std::string createPW( int len, bool safe ) {
    std::string pw;
    char t;
    for( int x = 0; x < len; x += 4 ) {
        for( int y = x; y < x + 4 && y < len; y++ ) {
            do {
                t = CHR[y % 4].at( rand() % CHR[y % 4].size() );
            } while( safe && UNS.find( t ) != UNS.npos );
            pw.append( 1, t );
        }
    }
    std::random_shuffle( pw.begin(), pw.end() );
    return pw;
}
void generate( int len, int count, bool safe ) {
    for( int c = 0; c < count; c++ ) {
        std::cout << createPW( len, safe ) << """";
    }
    std::cout << """";
}
int main( int argc, char* argv[] ){
    if( argv[1][1] == '?' || argc < 5 ) {
        std::cout << ""Syntax: PWGEN length count safe seed /?""
                     ""length:the length of the password(min 4)""
                     ""count:how many passwords should be generated""
                     ""safe:1 will exclud visually similar characters, 0 won't""
                     ""seed:number to seed the random generator or 0""
                     ""/?this text"";
    } else {
        int l = atoi( argv[1] ),
            c = atoi( argv[2] ),
            s = atoi( argv[4] );
        if( s == 0 ) s = int( std::time( 0 ) );
        if( l < 4 ) {
            std::cout << ""Passwords must be at least 4 characters long."";
        } else {
            std::srand( unsigned( s ) );
            generate( l, c, argv[3][0] == '1' );
        }
    }
    return 0;
}
 "
"#include <utility> // For declval.
#include <algorithm>
#include <array>
#include <iterator>
#include <iostream>
 
/* Partial application helper. */
template< class F, class Arg >
struct PApply
{
    F f;
    Arg arg;
 
    template< class F_, class Arg_ >
    PApply( F_&& f, Arg_&& arg )
        : f(std::forward<F_>(f)), arg(std::forward<Arg_>(arg))
    {
    }
 
    /*      * The return type of F only gets deduced based on the number of arguments     * supplied. PApply otherwise has no idea whether f takes 1 or 10 args.     */
    template< class ... Args >
    auto operator() ( Args&& ...args )
        -> decltype( f(arg,std::declval<Args>()...) )
    {
        return f( arg, std::forward<Args>(args)... );
    }
};
 
template< class F, class Arg >
PApply<F,Arg> papply( F&& f, Arg&& arg )
{
    return PApply<F,Arg>( std::forward<F>(f), std::forward<Arg>(arg) );
}
 
/* Apply f to cont. */
template< class F >
std::array<int,4> fs( F&& f, std::array<int,4> cont )
{
    std::transform( std::begin(cont), std::end(cont), std::begin(cont), 
                    std::forward<F>(f) );
    return cont;
}
 
std::ostream& operator << ( std::ostream& out, const std::array<int,4>& c )
{
    std::copy( std::begin(c), std::end(c), 
               std::ostream_iterator<int>(out, strv) );
    return out;
}
 
int f1( int x ) { return x * 2; }
int f2( int x ) { return x * x; }
 
int main()
{
    std::array<int,4> xs = {{ 0, 1, 2, 3 }};
    std::array<int,4> ys = {{ 2, 4, 6, 8 }};
 
    auto fsf1 = papply( fs<decltype(f1)>, f1 );
    auto fsf2 = papply( fs<decltype(f2)>, f2 );
 
    std::cout << ""xs:""
              << ""fsf1: "" << fsf1(xs) << ''
              << ""fsf2: "" << fsf2(xs) << """"
              << ""ys:""
              << ""fsf1: "" << fsf1(ys) << ''
              << ""fsf2: "" << fsf2(ys) << '';
}"
"#include <iostream>
#include <algorithm>
#include<cstdio>
using namespace std;
void Pascal_Triangle(int size) {
 
	int a[100][100];
	int i, j;
 
	//first row and first coloumn has the same value=1
	for (i = 1; i <= size; i++) {
		a[i][1] = a[1][i] = 1;
	}
 
	//Generate the full Triangle
	for (i = 2; i <= size; i++) {
		for (j = 2; j <= size - i; j++) {
			if (a[i - 1][j] == 0 || a[i][j - 1] == 0) {
				break;
			}
			a[i][j] = a[i - 1][j] + a[i][j - 1];
		}
	}
 
	/* 	  1 1 1 1	  1 2 3	  1 3	  1 	first print as above format--> 	for (i = 1; i < size; i++) {		for (j = 1; j < size; j++) {			if (a[i][j] == 0) {					break;			}				printf(strv,a[i][j]);		}			cout<<strv;	}*/
 
	

 
	int row,space;
	for (i = 1; i < size; i++) {
		space=row=i;
		j=1;
 
		while(space<=size+(size-i)+1){
			 cout<<strv;
			 space++;
		 }
 
		while(j<=i){
			if (a[row][j] == 0){
				   break;
			   }
 
			if(j==1){
				printf(strv,a[row--][j++]);
			}
			else
				printf(strv,a[row--][j++]);
		}
			cout<<"""";
	}
 
}
 
int main()
{
	//freopen(strv,stdout);
 
	int size;
	cin>>size;
	Pascal_Triangle(size);
}
 
}

#include<iostream>
#include<vector>
using namespace std;
void print_vector(vector<int> dummy){
	for (vector<int>::iterator i = dummy.begin(); i != dummy.end(); ++i)
		cout<<*i<<strv;
	cout<<endl;
}
void print_vector_of_vectors(vector<vector<int>> dummy){
	for (vector<vector<int>>::iterator i = dummy.begin(); i != dummy.end(); ++i)
		print_vector(*i);
	cout<<endl;
}
vector<vector<int>> dynamic_triangle(int dummy){
	vector<vector<int>> result;
	if (dummy > 0){ 

		vector<int> row;
		

		row.push_back(1);
		result.push_back(row);
		

		if (dummy > 1){
			row.clear();
			row.push_back(1); row.push_back(1);
			result.push_back(row);
		}
		

		if (dummy > 2){
			for (int i = 2; i < dummy; i++){
				row.clear();
				row.push_back(1);
				for (int j = 1; j < i; j++)
					row.push_back(result.back().at(j - 1) + result.back().at(j));
				row.push_back(1);
				result.push_back(row);
			}
		}
	}
	return result;
}
vector<vector<int>> static_triangle(int dummy){
	vector<vector<int>> result;
	if (dummy > 0){ 

		vector<int> row;
		result.resize(dummy); 

		

		row.resize(1);
		row.at(0) = 1;
		result.at(0) = row;
		

		if (result.size() > 1){
			row.resize(2);
			row.at(0) = 1; row.at(1) = 1;
			result.at(1) = row;
		}
		

		if (result.size() > 2){
			for (int i = 2; i < result.size(); i++){
				row.resize(i + 1); 

				row.front() = 1;
				for (int j = 1; j < row.size() - 1; j++)
					row.at(j) = result.at(i - 1).at(j - 1) + result.at(i - 1).at(j);
				row.back() = 1;
				result.at(i) = row;
			}
		}
	}
	return result;
}
int main(){
	vector<vector<int>> triangle;
	int n;
	cout<<endl<<strv<<endl<<strv;
	cin>>n;
	

	triangle = dynamic_triangle(n);
	cout<<endl<<strv<<endl<<endl;
	print_vector_of_vectors(triangle);
	

	triangle = static_triangle(n);
	cout<<endl<<strv<<endl<<endl;
	print_vector_of_vectors(triangle);
	return 0;
}
 
 

#include<iostream>
#include<vector>
using namespace std;
class pascal_triangle{
	vector<vector<int>> data; 

	void print_row(vector<int> dummy){
		for (vector<int>::iterator i = dummy.begin(); i != dummy.end(); ++i)
			cout<<*i<<strv;
		cout<<endl;
	}
public:
	pascal_triangle(int dummy){ 

		if (dummy > 0){ 

			vector<int> row;
			data.resize(dummy); 

			

			row.resize(1);
			row.at(0) = 1;
			data.at(0) = row;
			

			if (data.size() > 1){
				row.resize(2);
				row.at(0) = 1; row.at(1) = 1;
				data.at(1) = row;
			}
			

			if (data.size() > 2){
				for (int i = 2; i < data.size(); i++){
					row.resize(i + 1); 

					row.front() = 1;
					for (int j = 1; j < row.size() - 1; j++)
						row.at(j) = data.at(i - 1).at(j - 1) + data.at(i - 1).at(j);
					row.back() = 1;
					data.at(i) = row;
				}
			}
		}
	}
	~pascal_triangle(){
		for (vector<vector<int>>::iterator i = data.begin(); i != data.end(); ++i)
			i->clear(); 

		data.clear();
	}
	void print_row(int dummy){
		if (dummy < data.size())
			for (vector<int>::iterator i = data.at(dummy).begin(); i != data.at(dummy).end(); ++i)
				cout<<*i<<strv;
		cout<<endl;
	}
	void print(){
		for (int i = 0; i < data.size(); i++)
			print_row(i);
	}
	int get_coeff(int dummy1, int dummy2){
		int result = 0;
		if ((dummy1 < data.size()) && (dummy2 < data.at(dummy1).size()))
				result = data.at(dummy1).at(dummy2);
		return result;
	}
	vector<int> get_row(int dummy){
		vector<int> result;
		if (dummy < data.size())
			result = data.at(dummy);
		return result;
	}
};
int main(){
	int n;
	cout<<endl<<strv<<endl<<endl<<strv;
	cin>>n;
	pascal_triangle myptri(n);
	cout<<endl<<strv<<endl;
	myptri.print();
	cout<<endl<<strv<<endl;
	myptri.print_row(n/2);
	cout<<endl<<strv<<endl;
	cout<<myptri.get_coeff(n/2, n/4)<<endl<<endl;
	return 0;
}
 
 "
"#include <vector>
#include <string>
#include <sstream>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <iterator>
#include <cstdlib>
 
double rpn(const std::string &expr){
  std::istringstream iss(expr);
  std::vector<double> stack;
  std::cout << ""InputOperationStack after"" << std::endl;
  std::string token;
  while (iss >> token) {
    std::cout << token << """";
    double tokenNum;
    if (std::istringstream(token) >> tokenNum) {
      std::cout << ""Push"";
      stack.push_back(tokenNum);
    } else {
      std::cout << ""Operate"";
      double secondOperand = stack.back();
      stack.pop_back();
      double firstOperand = stack.back();
      stack.pop_back();
      if (token == strv)
	stack.push_back(firstOperand * secondOperand);
      else if (token == strv)
	stack.push_back(firstOperand / secondOperand);
      else if (token == strv)
	stack.push_back(firstOperand - secondOperand);
      else if (token == strv)
	stack.push_back(firstOperand + secondOperand);
      else if (token == strv)
	stack.push_back(std::pow(firstOperand, secondOperand));
      else { //just in case
	std::cerr << strv << std::endl;
	std::exit(1);
      }
    }
    std::copy(stack.begin(), stack.end(), std::ostream_iterator<double>(std::cout, strv));
    std::cout << std::endl;
  }
  return stack.back();
}
 
int main() {
  std::string s = strv;
  std::cout << strv << rpn(s) << std::endl;
 
  return 0;
}"
"template<class T> 
class tree
{
  T value;
  tree *left;
  tree *right;
public:
  void replace_all (T new_value);
};template<class T>
void tree<T>::replace_all (T new_value)
{
  value = new_value;
  if (left != NULL) 
    left->replace_all (new_value);
  if (right != NULL)
    right->replace_all (new_value);
}"
"#include <iostream>
#include <iterator>
#include <vector>
#include <ppl.h> // MSVC++
#include <concurrent_vector.h> // MSVC++
 
struct Factors
{
    int number;
    std::vector<int> primes;
};
 
const int data[] =
{
    12757923, 12878611, 12878893, 12757923, 15808973, 15780709, 197622519
};
 
int main()
{
    

    Concurrency::concurrent_vector<Factors> results;
 
    

    Concurrency::parallel_for_each(std::begin(data), std::end(data), [&](int n)
    {
        Factors factors;
        factors.number = n;
        for (int f = 2; n > 1; ++f)
        {
            while (n % f == 0)
            {
                factors.primes.push_back(f);
                n /= f;
            }
        }
        results.push_back(factors); 

    });
    

 
    

    auto max = std::max_element(results.begin(), results.end(), [](const Factors &a, const Factors &b)
    {
        return a.primes.front() < b.primes.front();
    });
 
    

    std::for_each(results.begin(), results.end(), [&](const Factors &f)
    {
        if (f.primes.front() == max->primes.front())
        {
            std::cout << f.number << strv;
            std::copy(f.primes.begin(), f.primes.end(), std::ostream_iterator<int>(std::cout, strv));
            std::cout << ""]"";
        }
    });
    return 0;
}"
"#include <algorithm>
#include <cctype>
#include <string>
#include <iostream>
 
const std::string alphabet(strv);
 
bool is_pangram(std::string s)
{
    std::transform(s.begin(), s.end(), s.begin(), ::tolower);
    std::sort(s.begin(), s.end());
    return std::includes(s.begin(), s.end(), alphabet.begin(), alphabet.end());
}
 
int main()
{
    const auto examples = {strv,
                           strv};
 
    std::cout.setf(std::ios::boolalpha);
    for (auto& text : examples) {
        std::cout << ""Is "" << text << "" a pangram? - "" << is_pangram(text) << std::endl;
    }
}
 "
"#include <string>
#include <algorithm>
 
bool is_palindrome(std::string const& s)
{
  return std::equal(s.begin(), s.end(), s.rbegin());
}#include <string>
#include <algorithm>
 
bool is_palindrome(std::string const& s)
{
  return std::equal(s.begin(), s.begin()+s.length()/2, s.rbegin());
}"
"#include <algorithm>
#include <fstream>
#include <iostream>
#include <iterator>
#include <string>
#include <vector>
 
bool ordered(const std::string &word)
{
    return std::is_sorted(word.begin(), word.end()); 

}
 
int main()
{
    std::ifstream infile(strv);
    if (!infile) {
        std::cerr << ""Can't open word file"";
        return -1;
    }
 
    std::vector<std::string> words;
    std::string word;
    int longest = 0;
 
    while (std::getline(infile, word)) {
        int length = word.length();
        if (length < longest) continue; 

 
        if (ordered(word)) {
            if (longest < length) {
                longest = length; 

                words.clear(); 

            }
            words.push_back(word);
        }
    }
    std::copy(words.begin(), words.end(), std::ostream_iterator<std::string>(std::cout, """"));
}"
"#include <iostream>
#include <vector>
 
int main() {
  std::vector<int> a;
  a.push_back(1);
  a.push_back(2);
  a.push_back(1);
  a.push_back(3);
  a.push_back(2);
  std::vector<int> b;
  b.push_back(1);
  b.push_back(2);
  b.push_back(0);
  b.push_back(4);
  b.push_back(4);
  b.push_back(0);
  b.push_back(0);
  b.push_back(0);
 
  std::cout << std::boolalpha << (a < b) << std::endl; 

  return 0;
}"
"#include <vector>
#include <algorithm>
#include <string>
 


template <class T>
struct sort_table_functor {
  typedef bool (*CompFun)(const T &, const T &);
  const CompFun ordering;
  const int column;
  const bool reverse;
  sort_table_functor(CompFun o, int c, bool r) :
    ordering(o), column(c), reverse(r) { }
  bool operator()(const std::vector<T> &x, const std::vector<T> &y) const {
    const T &a = x[column],
            &b = y[column];
    return reverse ? ordering(b, a)
                   : ordering(a, b);
  }
};
 


template <class T>
bool myLess(const T &x, const T &y) { return x < y; }
 


template <class T>
void sort_table(std::vector<std::vector<T> > &table,
                int column = 0, bool reverse = false,
                bool (*ordering)(const T &, const T &) = myLess) {
  std::sort(table.begin(), table.end(),
            sort_table_functor<T>(ordering, column, reverse));
}
 
#include <iostream>
 


template <class T>
void print_matrix(std::vector<std::vector<T> > &data) {
  for () {
    for (int j = 0; j < 3; j++)
      std::cout << data[i][j] << """";
    std::cout << std::endl;
  }
}
 


bool desc_len_comparator(const std::string &x, const std::string &y) {
  return x.length() > y.length();
}
 
int main() {
 
  std::string data_array[3][3] =
    {
      {strv, strv, strv},
      {strv, strv, strv},
      {strv, strv, strv}
    };
 
  std::vector<std::vector<std::string> > data_orig;
  for (int i = 0; i < 3; i++) {
    std::vector<std::string> row;
    for (int j = 0; j < 3; j++)
      row.push_back(data_array[i][j]);
    data_orig.push_back(row);
  }
  print_matrix(data_orig);
 
  std::vector<std::vector<std::string> > data = data_orig;
  sort_table(data);
  print_matrix(data);
 
  data = data_orig;
  sort_table(data, 2);
  print_matrix(data);
 
  data = data_orig;
  sort_table(data, 1);
  print_matrix(data);
 
  data = data_orig;
  sort_table(data, 1, true);
  print_matrix(data);
 
  data = data_orig;
  sort_table(data, 0, false, desc_len_comparator);
  print_matrix(data);
 
  return 0;
}"
"#include <random>
#include <iostream>
#include <iterator>
#include <algorithm>
using namespace std;
 
mt19937 engine; //mersenne twister
 
unsigned int one_of_n(unsigned int n) {
	unsigned int choice;
	for(unsigned int i = 0; i < n; ++i) {
		uniform_int_distribution<unsigned int> distribution(0, i);
		if(!distribution(engine))
			choice = i;
	}
	return choice;
}
 
int main() {
	engine = mt19937(random_device()()); //seed random generator from system
	unsigned int results[10] = {0};
	for(unsigned int i = 0; i < 1000000; ++i)
		results[one_of_n(10)]++;
	ostream_iterator<unsigned int> out_it(cout, strv);
	copy(results, results+10, out_it);
	cout << '';
}
 "
" 
#include <iostream>
#include <iomanip>
//-------------------------------------------------------------------------------------------
using namespace std;
 
//-------------------------------------------------------------------------------------------
class ormConverter
{
public:
    ormConverter() :  AR( 0.7112f ), CE( 0.01f ), DI( 0.0254f ), FU( 0.3048f ), KI( 1000.0f ), LI( 0.00254f ), ME( 1.0f ),
		      MI( 7467.6f ), PI( 0.1778f ), SA( 2.1336f ), TO( 0.000254f ), VE( 0.04445f ), VR( 1066.8f ) {}
    void convert( char c, float l )
    {
	system( strv );
	cout << endl << l;
	switch( c )
	{
	    case 'A': cout << strv;     l *= AR; break;
	    case 'C': cout << strv; l *= CE; break;
	    case 'D': cout << strv;      l *= DI; break;
	    case 'F': cout << strv;        l *= FU; break;
	    case 'K': cout << strv;  l *= KI; break;
	    case 'L': cout << strv;     l *= LI; break;
	    case 'M': cout << strv;      l *= ME; break;
	    case 'I': cout << strv;      l *= MI; break;
	    case 'P': cout << strv;       l *= PI; break;
	    case 'S': cout << strv;     l *= SA; break;
	    case 'T': cout << strv;     l *= TO; break;
	    case 'V': cout << strv;    l *= VE; break;
	    case 'E': cout << strv;     l *= VR;
	}
 
	float ar = l / AR, ce = l / CE, di = l / DI, fu = l / FU, ki = l / KI, li = l / LI, me = l / ME,
	      mi = l / MI, pi = l / PI, sa = l / SA, to = l / TO, ve = l / VE, vr = l / VR;
	cout << left << endl << strv << endl
	     << setw( 12 ) << strv << ar << endl << setw( 12 ) << strv << ce << endl
	     << setw( 12 ) << strv << di << endl << setw( 12 ) << strv << fu << endl
	     << setw( 12 ) << strv << ki << endl << setw( 12 ) << strv << li << endl
	     << setw( 12 ) << strv << me << endl << setw( 12 ) << strv << mi << endl
	     << setw( 12 ) << strv << pi << endl << setw( 12 ) << strv << sa << endl
	     << setw( 12 ) << strv << to << endl << setw( 12 ) << strv << ve << endl
	     << setw( 12 ) << strv << vr << endl << endl << endl;
    }
private:
    const float AR, CE, DI, FU, KI, LI, ME, MI, PI, SA, TO, VE, VR;
};
//-------------------------------------------------------------------------------------------
int _tmain(int argc, _TCHAR* argv[])
{
    ormConverter c;
    char s; float l;
    while( true )
    {
	cout << ""What unit:(A)rshin, (C)entimeter, (D)iuym, (F)ut(K)ilometer, (L)iniya, (M)eter, m(I)lia, (P)iad(S)azhen, (T)ochka, (V)ershok, v(E)rsta, (Q)uit"";
	cin >> s; if( s & 32 ) s ^= 32; if( s == 'Q' ) return 0;
	cout << strv; cin >> l; if( l == 0 ) return 0;
	c.convert( s, l ); system( strv ); system( strv );
    }
    return 0;
}
//-------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <cctype>
#include <functional>
 
using namespace std;
 
bool odd()
{
  function<void ()> prev = []{};
  while(true) {
    int c = cin.get();
    if (!isalpha(c)) {
      prev();
      cout.put(c);
      return c != '.';
    }
    prev = [=] { cout.put(c); prev();  };
  }
}
 
bool even() 
{
  while(true) {
    int c;
    cout.put(c = cin.get());
    if (!isalpha(c)) return c != '.';
  }
}
 
 
int main()
{
  bool e = false;
  while( e ? odd() : even() ) e = !e;
  return 0;
}"
"#include <iostream>
#include <bitset>
#include <string>
 
const int ArraySize = 20;
const int NumGenerations = 10;
const std::string Initial = strv;
 
int main()
{
    

    std::bitset<ArraySize + 2> array(Initial);
 
    for(int j = 0; j < NumGenerations; ++j)
    {
        std::bitset<ArraySize + 2> tmpArray(array);
        for(int i = ArraySize; i >= 1 ; --i)
        {
            if(array[i])
                std::cout << strv;
            else
                std::cout << strv;
            int val = (int)array[i-1] << 2 | (int)array[i] << 1 | (int)array[i+1];
            tmpArray[i] = (val == 3 || val == 5 || val == 6);
        }
        array = tmpArray;
        std::cout << std::endl;
    }
}"
"#include <string>
#include <fstream>
#include <boost/serialization/string.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/serialization/base_object.hpp>
#include <iostream>
 
class Employee {
public :   
   Employee( ) { }
 
   Employee ( const std::string &dep , const std::string &namen ) 
      : department( dep ) , name( namen ) {
	 my_id = count++ ;
      }
 
   std::string getName( ) const {
      return name ;
   }
 
   std::string getDepartment( ) const {
      return department ;
   }
 
   int getId( ) const {
      return my_id ;
   }
 
   void setDepartment( const std::string &dep ) {
      department.assign( dep ) ;
   }
 
   virtual void print( ) {
      std::cout << strv << name << '' ;
      std::cout << strv << my_id << '' ;
      std::cout << strv << department << '' ;
   }
 
   virtual ~Employee( ) { } 
   static int count ;
private :
   std::string name ;
   std::string department ;
   int my_id ;
   friend class boost::serialization::access ;
 
   template <class Archive>
      void serialize( Archive &ar, const unsigned int version ) {
	 ar & my_id ;
	 ar & name ;
	 ar & department ;
      }
 
} ;
 
class Worker : public Employee {
public :
   Worker( const std::string & dep, const std::string &namen ,
	 double hourlyPay ) : Employee( dep , namen ) , salary( hourlyPay) { }
 
   Worker( ) { }
 
   double getSalary( ) {
      return salary ;
   }
 
   void setSalary( double pay ) {
      if ( pay > 0 ) 
	 salary = pay ;
   }
 
   virtual void print( ) {
      Employee::print( ) ;
      std::cout << strv << salary << '' ;
   }
private :
   double salary ;
   friend class boost::serialization::access ;
   template <class Archive>
      void serialize ( Archive & ar, const unsigned int version ) {
	 ar & boost::serialization::base_object<Employee>( *this ) ;
	 ar & salary ;
      }
} ;
 
int Employee::count = 0 ;
 
int main( ) {
   std::ofstream storefile( strv  ) ; //creating objects of base class
   const Employee emp1( strv , strv  ) ;
   const Employee emp2( strv , strv ) ;
   const Employee emp3( strv , strv ) ;
   const Employee emp4( strv , strv ) ;
   const Worker worker1( strv , strv , 20 ) ;//creating objects of derived class
   const Worker worker2 ( strv , strv , 55.35 ) ;
   boost::archive::text_oarchive oar ( storefile ) ;//starting serialization into designated file
   oar << emp1 ; 
   oar << emp2 ;
   oar << emp3 ;
   oar << emp4 ;
   oar << worker1 ;
   oar << worker2 ;
   storefile.close( ) ;
   std::cout << ""Reading out the data again"" ;
   Employee e1 , e2 , e3 , e4 ; //creating instances of base class objects for deserialization
   Worker w1, w2 ; 

   std::ifstream sourcefile( strv  ) ;
   boost::archive::text_iarchive iar( sourcefile ) ;//starting deserialization
   iar >> e1 >> e2 >> e3 >> e4 ; 
   iar >> w1 >> w2 ;
   sourcefile.close( ) ;
   std::cout << ""And here are the data after deserialization!( abridged):"" ;
   e1.print( ) ;
   e3.print( ) ;
   w2.print( ) ;
   return 0 ;
}"
" 
namespace Rosetta {
 
    /*! Implementation of Gauss-Legendre quadrature    *  http://en.wikipedia.org/wiki/Gaussian_quadrature    *  http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature    *     */
    template <int N>
    class GaussLegendreQuadrature {
    public:
        enum {eDEGREE = N};
 
        /*! Compute the integral of a functor        *        *   @param a    lower limit of integration        *   @param b    upper limit of integration        *   @param f    the function to integrate        *   @param err  callback in case of problems        */
        template <typename Function>
        double integrate(double a, double b, Function f) {
            double p = (b - a) / 2;
            double q = (b + a) / 2;
            const LegendrePolynomial& legpoly = s_LegendrePolynomial;
 
            double sum = 0;
            for (int i = 1; i <= eDEGREE; ++i) {
                sum += legpoly.weight(i) * f(p * legpoly.root(i) + q);
            }
 
            return p * sum;
        }
 
        /*! Print out roots and weights for information        */
        void print_roots_and_weights(std::ostream& out) const {
            const LegendrePolynomial& legpoly = s_LegendrePolynomial;
            out << strv;
            for (int i = 0; i <= eDEGREE; ++i) {
                out << ' ' << legpoly.root(i);
            }
            out << '';
            out << strv;
            for (int i = 0; i <= eDEGREE; ++i) {
                out << ' ' << legpoly.weight(i);
            }
            out << '';
        }
    private:
        /*! Implementation of the Legendre polynomials that form        *   the basis of this quadrature        */
        class LegendrePolynomial {
        public:
            LegendrePolynomial () {
                

                for (int i = 0; i <= eDEGREE; ++i) {
                    double dr = 1;
 
                    

                    Evaluation eval(cos(M_PI * (i - 0.25) / (eDEGREE + 0.5)));
                    do {
                        dr = eval.v() / eval.d();
                        eval.evaluate(eval.x() - dr);
                    } while (fabs (dr) > 2e-16);
 
                    this->_r[i] = eval.x();
                    this->_w[i] = 2 / ((1 - eval.x() * eval.x()) * eval.d() * eval.d());
                }
            }
 
            double root(int i) const { return this->_r[i]; }
            double weight(int i) const { return this->_w[i]; }
        private:
            double _r[eDEGREE + 1];
            double _w[eDEGREE + 1];
 
            /*! Evaluate the value *and* derivative of the            *   Legendre polynomial            */
            class Evaluation {
            public:
                explicit Evaluation (double x) : _x(x), _v(1), _d(0) {
                    this->evaluate(x);
                }
 
                void evaluate(double x) {
                    this->_x = x;
 
                    double vsub1 = x;
                    double vsub2 = 1;
                    double f     = 1 / (x * x - 1);
 
                    for (int i = 2; i <= eDEGREE; ++i) {
                        this->_v = ((2 * i - 1) * x * vsub1 - (i - 1) * vsub2) / i;
                        this->_d = i * f * (x * this->_v - vsub1);
 
                        vsub2 = vsub1;
                        vsub1 = this->_v;
                    }
                }
 
                double v() const { return this->_v; }
                double d() const { return this->_d; }
                double x() const { return this->_x; }
 
            private:
                double _x;
                double _v;
                double _d;
            };
        };
 
        /*! Pre-compute the weights and abscissae of the Legendre polynomials        */
        static LegendrePolynomial s_LegendrePolynomial;
    };
 
    template <int N>
    typename GaussLegendreQuadrature<N>::LegendrePolynomial GaussLegendreQuadrature<N>::s_LegendrePolynomial;
}
 


double RosettaExp(double x) {
    return exp(x);
}
 
int main() {
    Rosetta::GaussLegendreQuadrature<5> gl5;
 
    std::cout << std::setprecision(10);
 
    gl5.print_roots_and_weights(std::cout);
    std::cout << strv << gl5.integrate(-3., 3., RosettaExp) << '';
    std::cout << strv << RosettaExp(3) - RosettaExp(-3) << ''; 
}
 "
"

template<typename Method, typename F, typename Float>
 double integrate(F f, Float a, Float b, int steps, Method m)
{
  double s = 0;
  double h = (b-a)/steps;
  for (int i = 0; i < steps; ++i)
    s += m(f, a + h*i, h);
  return h*s;
}
 


class rectangular
{
public:
  enum position_type { left, middle, right };
  rectangular(position_type pos): position(pos) {}
  template<typename F, typename Float>
   double operator()(F f, Float x, Float h) const
  {
    switch(position)
    {
    case left:
      return f(x);
    case middle:
      return f(x+h/2);
    case right:
      return f(x+h);
    }
  }
private:
  const position_type position;
};
 
class trapezium
{
public:
  template<typename F, typename Float>
   double operator()(F f, Float x, Float h) const
  {
    return (f(x) + f(x+h))/2;
  }
};
 
class simpson
{
public:
  template<typename F, typename Float>
   double operator()(F f, Float x, Float h) const
  {
    return (f(x) + 4*f(x+h/2) + f(x+h))/6;
  }
};
 


double f(double x) { return x*x; }
 


double rl = integrate(f, 0.0, 1.0, 10, rectangular(rectangular::left));
double rm = integrate(f, 0.0, 1.0, 10, rectangular(rectangular::middle));
double rr = integrate(f, 0.0, 1.0, 10, rectangular(rectangular::right));
double t  = integrate(f, 0.0, 1.0, 10, trapezium());
double s  = integrate(f, 0.0, 1.0, 10, simpson());"
"#include <string>
#include <iostream>
using std::string;
 
const char* smallNumbers[] = {
  strv, strv, strv, strv, strv, strv,
  strv, strv, strv, strv, strv,
  strv, strv, strv, strv, strv,
  strv, strv, strv, strv
};
 
string spellHundreds(unsigned n) {
  string res;
  if (n > 99) {
    res = smallNumbers[n/100];
    res += strv;
    n %= 100;
    if (n) res += strv;
  }
  if (n >= 20) {
    static const char* Decades[] = {
      strv, strv, strv, strv, strv,
      strv, strv, strv, strv, strv
    };
    res += Decades[n/10];
    n %= 10;
    if (n) res += strv;
  }
  if (n < 20 && n > 0)
    res += smallNumbers[n];
  return res;
}
 
 
const char* thousandPowers[] = {
  strv, strv,  strv, strv };
 
typedef unsigned long Spellable;
 
string spell(Spellable n) {
  if (n < 20) return smallNumbers[n];
  string res;
  const char** pScaleName = thousandPowers;
  Spellable scaleFactor = 1000000000;	

  while (scaleFactor > 0) {
    if (n >= scaleFactor) {
      Spellable h = n / scaleFactor;
      res += spellHundreds(h) + *pScaleName;
      n %= scaleFactor;
      if (n) res += strv;
    }
    scaleFactor /= 1000;
    ++pScaleName;
  }
  return res;
}
 
int main() {
#define SPELL_IT(x) std::cout << #x strv << spell(x) << std::endl;
  SPELL_IT(      99);
  SPELL_IT(     300);
  SPELL_IT(     310);
  SPELL_IT(    1501);
  SPELL_IT(   12609);
  SPELL_IT(  512609);
  SPELL_IT(43112609);
  SPELL_IT(1234567890);
  return 0;
}"
"#include <iostream>
#include <cstdlib>
if (object == 0) {
   std::cout << strv;
} 
#include <boost/optional.hpp>
#include <iostream>
 
boost::optional<int> maybeInt()
 
int main()
{
  boost::optional<int> maybe = maybeInt();
 
  if(!maybe)
    std::cout << ""object is null"";
}
  
int *p = nullptr;
...
if (p == nullptr){
  

}
//or just
if (p){
  

}
 "
"#pragma once
 
#include <cmath>
#include <string>
#include <sstream>
#include <iomanip>
 
class Approx {
public:
    Approx(double _v, double _s = 0.0) : v(_v), s(_s) {}
 
    operator std::string() const {
        std::ostringstream os(strv);
        os << std::setprecision(15) << v << strv << std::setprecision(15) << s << std::ends;
        return os.str();
    }
 
    Approx operator +(const Approx& a) const { return Approx(v + a.v, sqrt(s * s + a.s * a.s)); }
    Approx operator +(double d) const { return Approx(v + d, s); }
    Approx operator -(const Approx& a) const { return Approx(v - a.v, sqrt(s * s + a.s * a.s)); }
    Approx operator -(double d) const { return Approx(v - d, s); }
 
    Approx operator *(const Approx& a) const {
        const double t = v * a.v;
        return Approx(v, sqrt(t * t * s * s / (v * v) + a.s * a.s / (a.v * a.v)));
    }
 
    Approx operator *(double d) const { return Approx(v * d, fabs(d * s)); }
 
    Approx operator /(const Approx& a) const {
        const double t = v / a.v;
        return Approx(t, sqrt(t * t * s * s / (v * v) + a.s * a.s / (a.v * a.v)));
    }
 
    Approx operator /(double d) const { return Approx(v / d, fabs(d * s)); }
 
    Approx pow(double d) const {
        const double t = ::pow(v, d);
        return Approx(t, fabs(t * d * s / v));
    }
 
private:
    double v, s;
};#include <cstdlib>
#include <iostream>
#include strv
 
int main(const int argc, const char* argv[]) {
    const Approx x1(100, 1.1);
    const Approx x2(50, 1.2);
    const Approx y1(200, 2.2);
    const Approx y2(100, 2.3);
    std::cout << std::string(((x1 - x2).pow(2.) + (y1 - y2).pow(2.)).pow(0.5)) << std::endl; 

 
	return EXIT_SUCCESS;
}"
"double NthRoot(double m_nValue, double index, double guess, double pc)
   {
       double result = guess;
       double result_next;
       do
       {
           result_next = (1.0/index)*((index-1.0)*result+(m_nValue)/(pow(result,(index-1.0))));
           result = result_next;
           pc--;
       }while(pc>1);
       return result;
   };
 double NthRoot(double value, double degree)
{
    return pow(value, (double)(1 / degree));
};
 "
" 




template<uint _N, uint _G> class Nonogram {
  enum class ng_val : char {X='#',B='.',V='?'};
  template<uint _NG> struct N {
    N() {}
    N(std::vector<int> ni,const int l) : X{},B{},Tx{},Tb{},ng(ni),En{},gNG(l){}
    std::bitset<_NG> X, B, T, Tx, Tb;
    std::vector<int> ng;
    int En, gNG;
    void        fn (const int n,const int i,const int g,const int e,const int l){ 
      if (fe(g,l,false) and fe(g+l,e,true)){
      if ((n+1) < ng.size()) {if (fe(g+e+l,1,false)) fn(n+1,i-e-1,g+e+l+1,ng[n+1],0);}
      else {
        if (fe(g+e+l,gNG-(g+e+l),false)){Tb &= T.flip(); Tx &= T.flip(); ++En;}
      }}
      if (l<=gNG-g-i-1) fn(n,i,g,e,l+1);
    }
    void        fi (const int n,const bool g) {X.set(n,g); B.set(n, not g);}
    ng_val      fg (const int n) const{return (X.test(n))? ng_val::X : (B.test(n))? ng_val::B : ng_val::V;}
    inline bool fe (const int n,const int i, const bool g){
      for (int e = n;e<n+i;++e) if ((g and fg(e)==ng_val::B) or (!g and fg(e)==ng_val::X)) return false; else T[e] = g;
      return true;
    }
    int         fl (){
      if (En == 1) return 1;
      Tx.set(); Tb.set(); En=0;
      fn(0,std::accumulate(ng.cbegin(),ng.cend(),0)+ng.size()-1,0,ng[0],0);
      return En;
    }}; 

  std::vector<N<_G>> ng;
  std::vector<N<_N>> gn;
  int En, zN, zG;
  void setCell(uint n, uint i, bool g){ng[n].fi(i,g); gn[i].fi(n,g);}
public:
  Nonogram(const std::vector<std::vector<int>>& n,const std::vector<std::vector<int>>& i,const std::vector<std::string>& g = {}) : ng{}, gn{}, En{}, zN(n.size()), zG(i.size()) {
    for (int n=0; n<zG; n++) gn.push_back(N<_N>(i[n],zN));
    for (int i=0; i<zN; i++) {
      ng.push_back(N<_G>(n[i],zG));
      if (i < g.size()) for(int e=0; e<zG or e<g[i].size(); e++) if (g[i][e]=='#') setCell(i,e,true);
    }}
  bool solve(){
    int i{}, g{};  
    for (int l = 0; l<zN; l++) {
      if ((g = ng[l].fl()) == 0) return false; else i+=g;
      for (int i = 0; i<zG; i++) if (ng[l].Tx[i] != ng[l].Tb[i]) setCell (l,i,ng[l].Tx[i]);
    }
    for (int l = 0; l<zG; l++) {
      if ((g = gn[l].fl()) == 0) return false; else i+=g;
      for (int i = 0; i<zN; i++) if (gn[l].Tx[i] != gn[l].Tb[i]) setCell (i,l,gn[l].Tx[i]);
    }
    if (i == En)    return false; else En = i;
    if (i == zN+zG) return true;  else return solve();
  }
  const std::string toStr() const {
    std::ostringstream n;
    for (int i = 0; i<zN; i++){for (int g = 0; g<zG; g++){n << static_cast<char>(ng[i].fg(g));}n<<std::endl;}
    return n.str();
  }};
  




int main(){
  std::ifstream n (strv);
  if (!n) {
    std::cerr << ""Unable to open nono.txt."";
    exit(EXIT_FAILURE);
  }
  std::string i;
  getline(n,i);
  std::istringstream g(i);
  std::string e;
  std::vector<std::vector<int>> N;
    while (g >> e) {
      std::vector<int> G;
      for (char l : e) G.push_back((int)l-64);
      N.push_back(G);
    }
  getline(n,i);
  std::istringstream gy(i);
  std::vector<std::vector<int>> G;
    while (gy >> e) {
      std::vector<int> N;
      for (char l : e) N.push_back((int)l-64);
      G.push_back(N);
    }
  Nonogram<32,32> myN(N,G);
  if (!myN.solve()) std::cout << strv << std::endl;
  std::cout << """" << myN.toStr() << std::endl; 
}
  
int main(){
  const std::vector<std::vector<int>> Ngchq={{        7,3,1, 1,7},
                                             {      1,1,2,2, 1,1},
                                             {  1,3,1,3,1,1, 3,1},
                                             {  1,3,1,1,6,1, 3,1},
                                             {  1,3,1,5,2,1, 3,1},
                                             {        1,1,2, 1,1},
                                             {    7,1,1,1,1, 1,7},
                                             {               3,3},
                                             {1,2,3,1,1,3,1, 1,2},
                                             {      1,1,3,2, 1,1},
                                             {      4,1,4,2, 1,2},
                                             {  1,1,1,1,1,4, 1,3},
                                             {      2,1,1,1, 2,5},
                                             {      3,2,2,6, 3,1},                                                                                                                                                              
                                             {      1,9,1,1, 2,1},
                                             {      2,1,2,2, 3,1},
                                             {    3,1,1,1,1, 5,1},
                                             {          1,2, 2,5},
                                             {    7,1,2,1,1, 1,3},
                                             {    1,1,2,1,2, 2,1},
                                             {      1,3,1,4, 5,1},
                                             {      1,3,1,3,10,2},
                                             {      1,3,1,1, 6,6},
                                             {      1,1,2,1, 1,2},
                                             {        7,2,1, 2,5}};
  const std::vector<std::vector<int>> Ggchq={{        7,2,1,1,7},
                                             {      1,1,2,2,1,1},
                                             {1,3,1,3,1,3,1,3,1},
                                             {  1,3,1,1,5,1,3,1},
                                             {  1,3,1,1,4,1,3,1},
                                             {      1,1,1,2,1,1},
                                             {    7,1,1,1,1,1,7},
                                             {            1,1,3},
                                             {    2,1,2,1,8,2,1},
                                             {  2,2,1,2,1,1,1,2},
                                             {        1,7,3,2,1},
                                             {  1,2,3,1,1,1,1,1},
                                             {        4,1,1,2,6},
                                             {    3,3,1,1,1,3,1},
                                             {        1,2,5,2,2},
                                             {2,2,1,1,1,1,1,2,1},
                                             {    1,3,3,2,1,8,1},
                                             {            6,2,1},
                                             {      7,1,4,1,1,3},
                                             {        1,1,1,1,4},
                                             {      1,3,1,3,7,1},
                                             {1,3,1,1,1,2,1,1,4},
                                             {      1,3,1,4,3,3},
                                             {    1,1,2,2,2,6,1},
                                             {      7,1,3,2,1,1}};
 
  std::vector<std::string> n = {strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,                                                      
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv,
                                strv};
  Nonogram<25,25> myN(Ngchq,Ggchq,n);
  if (!myN.solve()) std::cout << strv << std::endl;
  std::cout << """" << myN.toStr() << std::endl;
}
 "
" 
#include <iomanip>
#include <iostream>
#include <algorithm>
#include <numeric>
#include <string>
#include <vector>
 
typedef std::pair<int, std::vector<int> > puzzle;
 
class nonoblock {
public:
    void solve( std::vector<puzzle>& p ) {
        for( std::vector<puzzle>::iterator i = p.begin(); i != p.end(); i++ ) {
            counter = 0;
            std::cout << strv << ( *i ).first << strv;
            for( std::vector<int>::iterator it = ( *i ).second.begin(); it != ( *i ).second.end(); it++ )
                std::cout << *it << strv;
            std::cout << strv;
            int s = std::accumulate( ( *i ).second.begin(), ( *i ).second.end(), 0 ) + ( ( *i ).second.size() > 0 ? ( *i ).second.size() - 1 : 0 );
            if( ( *i ).first - s < 0 ) {
                std::cout << ""has no solution!"";
                continue;
            }
            std::cout << "" Possible configurations:"";
            std::string b( ( *i ).first, '-' );
            solve( *i, b, 0 );
            std::cout << """";
        } 
    }
 
private:
    void solve( puzzle p, std::string n, int start ) {
        if( p.second.size() < 1 ) {
            output( n );
            return;
        }
        std::string temp_string;
        int offset,
            this_block_size = p.second[0];
 
        int space_need_for_others = std::accumulate( p.second.begin() + 1, p.second.end(), 0 );
        space_need_for_others += p.second.size() - 1;
 
        int space_for_curr_block = p.first - space_need_for_others - std::accumulate( p.second.begin(), p.second.begin(), 0 );
 
        std::vector<int> v1( p.second.size() - 1 );
        std::copy( p.second.begin() + 1, p.second.end(), v1.begin() );
        puzzle p1 = std::make_pair( space_need_for_others, v1 );
 
        for( int a = 0; a < space_for_curr_block; a++ ) {
            temp_string = n;
 
            if( start + this_block_size > n.length() ) return;
 
            for( offset = start; offset < start + this_block_size; offset++ )
                temp_string.at( offset ) = 'o';
 
            if( p1.first ) solve( p1, temp_string, offset + 1 );
            else output( temp_string );
 
            start++;
        }
    }
    void output( std::string s ) {
        char b = 65 - ( s.at( 0 ) == '-' ? 1 : 0 );
        bool f = false;
        std::cout << std::setw( 3 ) << ++counter << ""|"";
        for( std::string::iterator i = s.begin(); i != s.end(); i++ ) {
            b += ( *i ) == 'o' && f ? 1 : 0;
            std::cout << ( ( *i ) == 'o' ? b : '_' ) << strv;
            f = ( *i ) == '-' ? true : false;
        }
        std::cout << """";
    }
 
    unsigned counter;
};
 
int main( int argc, char* argv[] )
{
    std::vector<puzzle> problems;
    std::vector<int> blocks; 
    blocks.push_back( 2 ); blocks.push_back( 1 );
    problems.push_back( std::make_pair( 5, blocks ) );
    blocks.clear();
    problems.push_back( std::make_pair( 5, blocks ) );
    blocks.push_back( 8 );
    problems.push_back( std::make_pair( 10, blocks ) );
    blocks.clear();
    blocks.push_back( 2 ); blocks.push_back( 3 );
    problems.push_back( std::make_pair( 5, blocks ) );
    blocks.push_back( 2 ); blocks.push_back( 3 );
    problems.push_back( std::make_pair( 15, blocks ) );
 
    nonoblock nn;
    nn.solve( problems );
 
    return 0;
}
 "
"void number_reversal_game()
{
	cout << strv;
	cout << strv;
	cout << ""Anything besides numbers are ignored."";
	cout << ""  |1__2__3__4__5__6__7__8__9|"";
	int list[9] = {1,2,3,4,5,6,7,8,9};
        do
        {
	  shuffle_list(list,9);
        } while(check_array(list, 9));
 
	int tries=0;
	unsigned int i;
	int input;
 
	while(!check_array(list, 9))
	{
		cout << strv << tries << ((tries<10) ? strv : strv);
		for(i=0;i<9;i++)cout << list[i] << strv;
		cout << strv;
		while(1)
		{
			cin >> input;
			if(input>1&&input<10)
				break;
 
			cout << ""Please enter a number between 2 and 9:"";
		}
		tries++;
		do_flip(list, 9, input);
	}
	cout << ""Hurray! You solved it in %d moves!"";
} 
#include <iostream>
#include <algorithm>
#include <functional>
#include <iterator>
#include <cstdlib>
#include <ctime>
 
template<typename T, int size>
 bool is_sorted(T (&array)[size])
{
  return std::adjacent_find(array, array+size, std::greater<T>())
    == array+size;
}
 
int main()
{
  std::srand(std::time(0));
 
  int list[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
 
  do
  {
    std::random_shuffle(list, list+9);
  } while (is_sorted(list));
 
  int score = 0;
 
  do
  {
    std::cout << strv;
    std::copy(list, list+9, std::ostream_iterator<int>(std::cout, strv));
 
    int rev;
    while (true)
    {
      std::cout << ""Digits to reverse? "";
      std::cin >> rev;
      if (rev > 1 && rev < 10)
        break;
      std::cout << strv;
    }
 
    ++score;
    std::reverse(list, list + rev);
  } while (!is_sorted(list));
 
  std::cout << ""Congratulations, you sorted the list.""
            << strv << score << strv << std::endl;
  return 0;
}
 "
"#include <iostream>
#include <iomanip>
 
int main()
{
  for (int i = 0; i <= 33; i++)
    std::cout << std::setw(6) << std::dec << i << strv
              << std::setw(6) << std::hex << i << strv
              << std::setw(6) << std::oct << i << std::endl;
 
  return 0;
}"
"#include <iostream>
#include <sstream>
 
int main()
{
  int num;
 
  std::istringstream(strv) >> num;
  std::cout << num << std::endl; 

 
  std::istringstream(strv) >> std::dec >> num;
  std::cout << num << std::endl; 

 
  std::istringstream(strv) >> std::hex >> num;
  std::cout << num << std::endl; 

 
  std::istringstream(strv) >> std::oct >> num;
  std::cout << num << std::endl; 

 
  

 
  return 0;
}"
"#include <string>
#include <cstdlib>
#include <algorithm>
#include <cassert>
 
std::string const digits = strv;
 
std::string to_base(unsigned long num, int base)
{
  if (num == 0)
    return strv;
 
  std::string result;
  while (num > 0) {
    std::ldiv_t temp = std::div(num, (long)base);
    result += digits[temp.rem];
    num = temp.quot;
  }
  std::reverse(result.begin(), result.end());
  return result;
}
 
unsigned long from_base(std::string const& num_str, int base)
{
  unsigned long result = 0;
  for (std::string::size_type pos = 0; pos < num_str.length(); ++pos)
    result = result * base + digits.find(num_str[pos]);
  return result;
}"
"#import <iostream>
#import <string>
#import <sstream>
 
std::string makeList(std::string separator) {
  int counter = 1;
 
  auto makeItem = [=](std::string item) mutable {
    return (std::ostringstream() << counter++ << separator << item << """").str();
  };
 
  return makeItem(strv) + makeItem(strv) + makeItem(strv);
}
 
int main() {
  std::cout << makeList(strv);
  return 0;
}"
" 
#include <iostream>
#include <string>
#include <windows.h>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class bells
{
public:
    void start()
    {
	watch[0] = strv; watch[1] = strv; watch[2] = strv; watch[3] = strv; watch[4] = strv; watch[5] =  strv; 
	count[0] = strv; count[1] = strv; count[2] = strv; count[3] = strv; count[4] = strv; count[5] = strv; count[6] = strv; count[7] = strv;
	_inst = this; CreateThread( NULL, 0, bell, NULL, 0, NULL );
    }
private:
    static DWORD WINAPI bell( LPVOID p )
    {
	DWORD wait = _inst->waitTime();
	while( true )
	{
	    Sleep( wait );
	    _inst->playBell();
	    wait = _inst->waitTime();
	}
	return 0;
    }
 
    DWORD waitTime() 
    { 
	GetLocalTime( &st );
	int m = st.wMinute >= 30 ? st.wMinute - 30 : st.wMinute;
	return( 1800000 - ( ( m * 60 + st.wSecond ) * 1000 + st.wMilliseconds ) );
    }
 
    void playBell()
    {
	GetLocalTime( &st );
	int b = ( 2 * st.wHour + st.wMinute / 30 ) % 8; b = b == 0 ? 8 : b;
	int w = ( 60 * st.wHour + st.wMinute ); 
	if( w < 1 ) w = 5; else w = ( w - 1 ) / 240;
	char hr[32]; wsprintf( hr, strv, st.wHour, st.wMinute );
 
	cout << hr << strv << watch[w] << strv << count[b - 1] << strv;
	if( b > 1 ) cout << strv; else cout << strv; cout << strv << endl;
 
	for( int x = 0, c = 1; x < b; x++, c++ )
	{
	    cout << """"; Sleep( 500 );
	    if( !( c % 2 ) ) Sleep( 300 );
	}
    }
 
    SYSTEMTIME st;
    string watch[7], count[8];
    static bells* _inst;
};
//--------------------------------------------------------------------------------------------------
bells* bells::_inst = 0;
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    bells b; b.start();
    while( 1 ); 

    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"/*	Not best code, wrote it really quick.  Will add updated code using more C++11 features soon!*/
 
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
 
int main() {
	std::vector<int> sequence = { 0, 1, 2, 3, 4 };
	std::vector<int> work = { 0 };
	std::vector<std::vector<int>> results;
	while (work != sequence) {
		bool zeroed = false;
		size_t index_zero_started = 0;
		for (size_t i = 0; i < work.size(); ++i) {
			if (work[i] >= sequence.size()) {
				if (i == 0) {
					work[i] = 0;
					work.push_back(0);
					index_zero_started = i;
				} else {
					++work[i - 1];
					for (size_t j = i; j < work.size(); ++j) {
						work[j] = 0;
					}
					index_zero_started = i - 1;
				}
				zeroed = true;
				break;
			}
		}
		if (zeroed) {
			for (size_t i = index_zero_started + 1; i < work.size(); ++i) {
				work[i] = work[i - 1] + 1;
			}
		} else {
			std::vector<int> temp_differences;
			std::adjacent_difference(std::begin(work), std::end(work), std::back_inserter(temp_differences));
			if (std::find_if(std::begin(temp_differences) + 1, std::end(temp_differences), 
				[](const int& n) { return n > 1; }) != std::end(temp_differences)) {
				results.push_back(work);
			}
			++work.back();
		}
	}
	std::cout << strv;
	std::copy(std::begin(sequence), std::end(sequence), std::ostream_iterator<int>(std::cout, strv));
	std::cout << std::endl;
	for (auto& e: results) {
		std::cout << strv;
		std::copy(std::begin(e), std::end(e), std::ostream_iterator<int>(std::cout, strv));
		std::cout << std::endl;
	}
	return 0;
}"
" 
#include <iostream>
#include <vector>
using namespace std;
typedef unsigned int uint;
 
class NarcissisticDecs
{
public:
    void makeList( int mx )
    {
	uint st = 0, tl; int pwr = 0, len;
        while( narc.size() < mx )
	{
	    len = getDigs( st );
	    if( pwr != len )
	    {
		pwr = len;
		fillPower( pwr );
	    }
            tl = 0;
	    for( int i = 1; i < 10; i++ )
		tl += static_cast<uint>( powr[i] * digs[i] );
 
	    if( tl == st ) narc.push_back( st );
	    st++;
	}
    }
 
    void display()
    {
	for( vector<uint>::iterator i = narc.begin(); i != narc.end(); i++ )
	    cout << *i << strv;
	cout << """";
    }
 
private:
    int getDigs( uint st )
    {
	memset( digs, 0, 10 * sizeof( int ) );
	int r = 0;
	while( st )
	{
	    digs[st % 10]++;
	    st /= 10;
	    r++;
	}
        return r;
    }
 
    void fillPower( int z )
    {
	for( int i = 1; i < 10; i++ )
	    powr[i] = pow( static_cast<float>( i ), z );
    }
 
    vector<uint> narc;
    uint powr[10];
    int digs[10];
};
 
int main( int argc, char* argv[] )
{
    NarcissisticDecs n;
    n.makeList( 25 );
    n.display();
    return system( strv );
}
 "
"#include <string>
#include <iostream>
 
using namespace std;
 
string Suffix(int num)
{
    switch (num % 10)
    {
        case 1 : if(num % 100 != 11) return strv;
           break;
        case 2 : if(num % 100 != 12) return strv;
           break;
        case 3 : if(num % 100 != 13) return strv;
    }
 
    return strv;
}
 
int main()
{
    cout << strv << endl;
    for (int i = 0; i < 26; i++)
        cout << i << Suffix(i) << strv;
 
    cout << endl;
 
    cout << strv << endl;
    for (int i = 250; i < 266; i++)
        cout << i << Suffix(i) << strv;
 
    cout << endl;
 
    cout << strv << endl;
    for (int i = 1000; i < 1026; i++)
        cout << i << Suffix(i) << strv;
 
    cout << endl;
 
    return 0;
}"
" 
#include <iostream>
#include <windows.h>
#include <mmsystem.h>
 
#pragma comment ( lib, strv )
 
typedef unsigned char byte;
 
typedef union 
{ 
    unsigned long word; 
    unsigned char data[4]; 
}
midi_msg;
 
class midi
{
public:
    midi()
    {
	if( midiOutOpen( &device, 0, 0, 0, CALLBACK_NULL) != MMSYSERR_NOERROR ) 
	{
	    std::cout << strv << std::endl;
	    device = 0;
	}
    }
    ~midi()
    {
	midiOutReset( device );
	midiOutClose( device );
    }
    bool isOpen() { return device != 0; }
    void setInstrument( byte i )
    {
	message.data[0] = 0xc0; message.data[1] = i;
	message.data[2] = 0; message.data[3] = 0;
	midiOutShortMsg( device, message.word );
    }
    void playNote( byte n, unsigned i )
    {
	playNote( n ); Sleep( i ); stopNote( n );
    }
 
private:
    void playNote( byte n )
    {
	message.data[0] = 0x90; message.data[1] = n;
	message.data[2] = 127; message.data[3] = 0;
	midiOutShortMsg( device, message.word );
    }
    void stopNote( byte n )
    {
	message.data[0] = 0x90; message.data[1] = n;
	message.data[2] = 0; message.data[3] = 0;
	midiOutShortMsg( device, message.word );
    }
    HMIDIOUT device;
    midi_msg message;
};
 
int main( int argc, char* argv[] )
{
    midi m;
    if( m.isOpen() )
    {
	byte notes[] = { 60, 62, 64, 65, 67, 69, 71, 72 };
	m.setInstrument( 42 );
	for( int x = 0; x < 8; x++ )
	    m.playNote( notes[x], rand() % 100 + 158 );
	Sleep( 1000 );
    }
    return 0;
}
 "
"class foo_params{
	friend void foo(foo_params p);
public:
    foo_params(int r):
        required_param_(r),
	optional_x_(0),
	optional_y_(1),
	optional_z_(3.1415)
	{}
     foo_params& x(int i){
	optional_x_=i;
	return *this;
     }
     foo_params& y(int i){
	optional_y_=i;
	return *this;
     }
     foo_params& z(float f){
	optional_z_=f;
	return *this;
     }
private:
        int 	required_param_;
	int 	optional_x_;
	int 	optional_y_; 
	float 	optional_z_;
};void foo(foo_params p){ . . .}foo(foo_params(42).x(7).z(23.54));#include <boost/parameter/name.hpp>
#include <boost/parameter/preprocessor.hpp>
#include <string>
 
BOOST_PARAMETER_NAME(foo)
BOOST_PARAMETER_NAME(bar)
BOOST_PARAMETER_NAME(baz)
BOOST_PARAMETER_NAME(bonk)
 
BOOST_PARAMETER_FUNCTION(
    (int),  

    function_with_named_parameters, 

    tag,  

    (required 

        (foo, (int)) 
        (bar, (float))
    )
    (optional 

        (baz, (bool) , false)
        (bonk, (std::string), strv)
    ) 
)
{
    if (baz && (bar > 1.0)) return foo;
    return bonk.size();
}function_with_named_parameters(1, 10.0);
function_with_named_parameters(7, _bar = 3.14);
function_with_named_parameters( _bar = 0.0, _foo = 42);
function_with_named_parameters( _bar = 2.5, _bonk= strv, _foo = 9);
function_with_named_parameters(9, 2.5, true, strv);"
"#include <iostream>
#include <vector>
#include <iterator>
 
class Hofstadter
{
public:
  static int F(int n) {
    if ( n == 0 ) return 1;
    return n - M(F(n-1));
  }
  static int M(int n) {
    if ( n == 0 ) return 0;
    return n - F(M(n-1));
  }
};
 
using namespace std;
 
int main()
{
  int i;
  vector<int> ra, rb;
 
  for(i=0; i < 20; i++) {
    ra.push_back(Hofstadter::F(i));
    rb.push_back(Hofstadter::M(i));
  }
  copy(ra.begin(), ra.end(),
       ostream_iterator<int>(cout, strv));
  cout << endl;
  copy(rb.begin(), rb.end(),
       ostream_iterator<int>(cout, strv));
  cout << endl;
  return 0;
}class Hofstadter
{
public:
  static int F(int n);
  static int M(int n);
};
 
int Hofstadter::F(int n)
{
  if ( n == 0 ) return 1;
  return n - M(F(n-1));
}
 
int Hofstadter::M(int n)
{
  if ( n == 0 ) return 0;
  return n - F(M(n-1));
}"
" 
#include <math.h>
#include <iostream>
 
unsigned pwr[10];
 
unsigned munch( unsigned i ) {
    unsigned sum = 0;
    while( i ) {
        sum += pwr[(i % 10)];
        i /= 10;
    }
    return sum;
}
 
int main( int argc, char* argv[] ) {
    for( int i = 0; i < 10; i++ )
        pwr[i] = (unsigned)pow( (float)i, (float)i );
    std::cout << ""Munchausen Numbers=================="";
    for( unsigned i = 1; i < 5000; i++ )
        if( i == munch( i ) ) std::cout << i << """";
    return 0;
}
 "
" 
#include <windows.h>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int BMP_SIZE = 512;
 
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteObject( brush );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO    bi;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes      = 1;
	bi.bmiHeader.biWidth       =  w;
	bi.bmiHeader.biHeight      = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc );
 
	width = w; height = h;
	return true;
    }
 
    void clear( BYTE clr = 0 )
    {
	memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
 
    void setBrushColor( DWORD bClr )
    {
	if( brush ) DeleteObject( brush );
	brush = CreateSolidBrush( bClr );
	SelectObject( hdc, brush );
    }
 
    void setPenColor( DWORD c ) { clr = c; createPen(); }
 
    void setPenWidth( int w )   { wid = w; createPen(); }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO       infoheader;
	BITMAP           bitmap;
	DWORD            wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
 
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    void createPen()
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, wid, clr );
	SelectObject( hdc, pen );
    }
 
    HBITMAP bmp;
    HDC     hdc;
    HPEN    pen;
    HBRUSH  brush;
    void    *pBits;
    int     width, height, wid;
    DWORD   clr;
};
//--------------------------------------------------------------------------------------------------
class mSquares
{
public:
    mSquares()
    {
        bmp.create( BMP_SIZE, BMP_SIZE );
        createPallete();
    }
 
    void draw()
    {
	HDC dc = bmp.getDC();
	for( int y = 0; y < BMP_SIZE; y++ )
	    for( int x = 0; x < BMP_SIZE; x++ )
	    {
		int c = ( x ^ y ) % 256;
		SetPixel( dc, x, y, clrs[c] );
	    }
 
	BitBlt( GetDC( GetConsoleWindow() ), 30, 30, BMP_SIZE, BMP_SIZE, dc, 0, 0, SRCCOPY );
	//bmp.saveBitmap( strv );
    }
 
private:
    void createPallete()
    {
	for( int x = 0; x < 256; x++ )
	clrs[x] = RGB( x<<1, x, x<<2 );//rand() % 180 + 50, rand() % 200 + 50, rand() % 180 + 50 );
    }
 
    unsigned int clrs[256];
    myBitmap bmp;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );
    srand( GetTickCount() );
    mSquares s; s.draw();
    return system( strv );
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <boost/tokenizer.hpp>
#include <string>
 
int main( ) {
   std::string str( strv ) , output ;
   typedef boost::tokenizer<boost::char_separator<char> > tokenizer ;
   boost::char_separator<char> separator ( strv , strv ) , sep ( strv )  ;
   tokenizer mytok( str , separator ) ;
   tokenizer::iterator tok_iter = mytok.begin( ) ;
   for ( ; tok_iter != mytok.end( ) ; ++tok_iter )
      output.append( *tok_iter ) ;
   tokenizer nexttok ( output , sep ) ;
   for ( tok_iter = nexttok.begin( ) ; tok_iter != nexttok.end( ) ;
	 ++tok_iter ) 
      std::cout << *tok_iter << strv ;
   std::cout << '' ;
   return 0 ;
}"
" 
#include <algorithm>
#include <iostream>
#include <iterator>
/*Generate multifactorials to 9   Nigel_Galloway  November 14th., 2012.*/
int main(void) {
   for (int g = 1; g < 10; g++) {
     int v[11], n=0;
     generate_n(std::ostream_iterator<int>(std::cout, strv), 10, [&]{n++; return v[n]=(g<n)? v[n-g]*n : n;});
     std::cout << std::endl;
   }
   return 0;
}
 "
"#include <string>
#include <vector>
#include <map>
#include <iostream>
#include <algorithm>
#include <utility>
#include <sstream>
 
std::string mostFreqKHashing ( const std::string & input , int k ) {
   std::ostringstream oss ;
   std::map<char, int> frequencies ;
   for ( char c : input ) {
      frequencies[ c ] = std::count ( input.begin( ) , input.end( ) , c ) ;
   }
   std::vector<std::pair<char , int>> letters ( frequencies.begin( ) , frequencies.end( ) ) ;
   std::sort ( letters.begin( ) , letters.end( ) , [input] ( std::pair<char, int> a ,
	         std::pair<char, int> b ) { char fc = std::get<0>( a ) ; char fs = std::get<0>( b ) ; 
	         int o = std::get<1>( a ) ; int p = std::get<1>( b ) ; if ( o != p ) { return o > p ; }
	         else { return input.find_first_of( fc ) < input.find_first_of ( fs ) ; } } ) ;
   for ( int i = 0 ; i < letters.size( ) ; i++ ) {
      oss << std::get<0>( letters[ i ] ) ;
      oss << std::get<1>( letters[ i ] ) ;
   }
   std::string output ( oss.str( ).substr( 0 , 2 * k ) ) ;
   if ( letters.size( ) >= k ) {
      return output ;
   }
   else {
      return output.append( strv ) ;
   }
}
 
int mostFreqKSimilarity ( const std::string & first , const std::string & second ) {
   int i = 0 ;
   while ( i < first.length( ) - 1  ) {
      auto found = second.find_first_of( first.substr( i , 2 ) ) ;
      if ( found != std::string::npos ) 
	 return std::stoi ( first.substr( i , 2 )) ;
      else 
	 i += 2 ;
   }
   return 0 ;
}
 
int mostFreqKSDF ( const std::string & firstSeq , const std::string & secondSeq , int num ) {
   return mostFreqKSimilarity ( mostFreqKHashing( firstSeq , num ) , mostFreqKHashing( secondSeq , num ) ) ;
}
 
int main( ) {
   std::string s1(strv ) ;
   std::string s2( strv ) ;
   std::cout << strv << mostFreqKHashing( s1 , 2 ) << '' ;
   std::cout << strv << mostFreqKHashing( s2 , 2 ) << '' ;
   return 0 ;
}
 "
"

T* p = new T[n]; 

 
//If default initialisation is not what you want, or if T is a POD type which will be uninitialized
for(size_t i = 0; i != n; ++i)
   p[i] = make_a_T(); //or some other expression of type T
 


delete[] p;#include <vector>
#include <algorithm>
#include <iterator>
 


std::vector<T> vec1(n); 

 


std::vector<T> vec2(n, t); 

 


std::generate_n(std::back_inserter(vec), n, makeT); //makeT is a function of type T(void)
 #include <vector>
#include <tr1/memory>
using namespace std;
using namespace std::tr1;
 
typedef shared_ptr<T> TPtr_t;


std::vector<TPtr_t > bvec_WRONG(n, p); 

 


std::vector<TPtr_t> bvec_ALSO_WRONG(n, TPtr_t(new T(*p)) ); 

 


std::vector<TPtr_t > bvec(n);
for (int i = 0; i < n; ++i)
  bvec[i] = TPtr_t(new T(*p); //or any other call to T's constructor
 




std::vector<TPtr_t> bvec2;
for (int i = 0; i < n; ++i)
  bvec2.push_back(TPtr_t(new T(*p)); 
 
 "
" 
#include <iostream>
#include <iterator>
#include <sstream>
#include <vector>
 
using namespace std;
 
class MTF
{
public:
    string encode( string str )
    {
	fillSymbolTable();
	vector<int> output;
	for( string::iterator it = str.begin(); it != str.end(); it++ )
	{
	    for( int i = 0; i < 26; i++ )
	    {
		if( *it == symbolTable[i] )
		{
		    output.push_back( i );
		    moveToFront( i );
		    break;
		}
	    }
	}
	string r;
	for( vector<int>::iterator it = output.begin(); it != output.end(); it++ )
	{
	    ostringstream ss;
	    ss << *it;
	    r += ss.str() + strv;
	}
	return r;
    }
 
    string decode( string str )
    {
	fillSymbolTable();
	istringstream iss( str ); vector<int> output;
	copy( istream_iterator<int>( iss ), istream_iterator<int>(), back_inserter<vector<int> >( output ) );
	string r;
	for( vector<int>::iterator it = output.begin(); it != output.end(); it++ )
	{
	    r.append( 1, symbolTable[*it] );
	    moveToFront( *it );
	}
	return r;
    }
 
private:
    void moveToFront( int i )
    {
	char t = symbolTable[i];
	for( int z = i - 1; z >= 0; z-- )
	    symbolTable[z + 1] = symbolTable[z];
 
        symbolTable[0] = t;
    }
 
    void fillSymbolTable()
    {
        for( int x = 0; x < 26; x++ )
	    symbolTable[x] = x + 'a';
    }
 
    char symbolTable[26];
};
 
int main()
{
    MTF mtf;
    string a, str[] = { strv, strv, strv };
    for( int x = 0; x < 3; x++ )
    {
        a = str[x];
        cout << a << strv;
        a = mtf.encode( a );
        cout << a << strv << mtf.decode( a ) << endl;
    }
    return 0;
}
 "
"





#include <vector>
#include <iostream>
#include <iomanip>
#include <thread>
#include <future>
 




static void print(const std::vector<int> &pos)
{
	

	for (int i = 0; i < pos.size(); i++) {
		std::cout << std::setw(3) << char('a' + i);
	}
 
	std::cout << '';
 
	for (int row = 0; row < pos.size(); row++) {
		int col = pos[row];
		std::cout << row + 1 << std::setw(3 * col + 3) << strv;
		std::cout << '';
	}
 
	std::cout << """";
}
 
static bool threatens(int row_a, int col_a, int row_b, int col_b)
{
	return row_a == row_b 

		or col_a == col_b 

		or std::abs(row_a - row_b) == std::abs(col_a - col_b); 

}
 






static bool good(const std::vector<int> &pos, int end_idx)
{
	for (int row_a = 0; row_a < end_idx; row_a++) {
		for (int row_b = row_a + 1; row_b < end_idx; row_b++) {
			int col_a = pos[row_a];
			int col_b = pos[row_b];
			if (threatens(row_a, col_a, row_b, col_b)) {
				return false;
			}
		}
	}
 
	return true;
}
 
static std::mutex print_count_mutex; 

static int n_sols = 0; 

 


static void n_queens(std::vector<int> &pos, int index)
{
	

	if (index >= pos.size()) {
		if (good(pos, index)) {
			std::lock_guard<std::mutex> lock(print_count_mutex);
			print(pos);
			n_sols++;
		}
 
		return;
	}
 
	

	if (not good(pos, index)) {
		return;
	}
 
	

	if (index == 0) {
		std::vector<std::future<void>> fts;
		for (int col = 0; col < pos.size(); col++) {
			pos[index] = col;
			auto ft = std::async(std::launch::async, [=]{ auto cpos(pos); n_queens(cpos, index + 1); });
			fts.push_back(std::move(ft));
		}
 
		for (const auto &ft : fts) {
			ft.wait();
		}
	} else { 

		for (int col = 0; col < pos.size(); col++) {
			pos[index] = col;
			n_queens(pos, index + 1);
		}
	}
}
 
int main()
{
	std::vector<int> start(12); 

	n_queens(start, 0);
	std::cout << n_sols << "" solutions found."";
	return 0;
}
  






//


//


//






//




//




 






 
#include <algorithm>
#include <ciso646>
#include <iomanip>
#include <iostream>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>
 
 


struct queens
/////////////////////////////////////////////////////////////////////////// //
{
  

 
  

  //
  typedef signed char index_type;
 
  

  //
  

  

  

  //
  struct solution_type: std::vector <index_type>
  {
    typedef std::vector <index_type> base_type;
 
    

    solution_type( std::size_t N          ): base_type( N, -1 ) { }
    solution_type( const solution_type& s ): base_type( s     ) { }
 
    

    bool operator < ( const solution_type& s ) const
    {
      auto mm = std::mismatch( begin(), end(), s.begin() );
      return (mm.first != end()) and (*mm.first < *mm.second);
    }
 
    

    void vflip() { std::reverse( begin(), end() ); }
 
    void hflip() { for (auto& x : *this) x = size() - 1 - x; }
 
    void transpose()
    {
      solution_type result( size() );
      for (index_type y = 0; (std::size_t)y < size(); y++)
        result[ (*this)[ y ] ] = y;
      swap( result );
    }
  };
 
  

 
  const int                N;
  std::set <solution_type> solutions;
 
  

 
  queens( int N = 8 ):
    N( (N < 0) ? 0 : N )
  {
    

    

    

 
    solution_type solution( N );
    index_type row = 0;
    while (true)
    {
      

      ++solution[ row ];
 
      

      if ((row == 0) and (solution[ 0 ] > N/2)) break;
 
      if (solution[ row ] < N)
      {
        

        if (ok( solution, row, solution[ row ] ))
        {
          

          if (row == N-1)
          {
            

            solution_type
            s = solution;  solutions.insert( s );
            s.vflip();     solutions.insert( s );
            s.hflip();     solutions.insert( s );
            s.vflip();     solutions.insert( s );
            s.transpose(); solutions.insert( s );
            s.vflip();     solutions.insert( s );
            s.hflip();     solutions.insert( s );
            s.vflip();     solutions.insert( s );
          }
          

          else solution[ ++row ] = -1;
        }
 
      

      

      }
      else --row;
    }
  }
 
  

  

  

 
  bool ok( const solution_type& columns, index_type row, index_type column )
  {
    for (index_type r = 0; r < row; r++)
    {
      index_type c         = columns[ r ];
      index_type delta_row = row - r;
      index_type delta_col = (c < column) ? (column - c) : (c - column);
 
      if ((c == column) or (delta_row == delta_col))
        return false;
    }
    return true;
  }
 
  

  //
  

  //
  

  

  

  

  

  

  

  

  

  //
  friend
  std::ostream&
  operator << ( std::ostream& outs, const queens::solution_type& solution )
  {
    static const char* squares[] = { strv, strv };
    index_type N = solution.size();
 
    

    for (auto n = N; n--; )
      outs << (char)('a' + solution[ n ]) << (N - n) << strv;
 
    

    for (auto queen : solution)
    {
      outs << """";
      for (index_type col = 0; col < N; col++)
        outs << squares[ col == queen ];
    }
    return outs;
  }
 
  

  //
  

  

 
  friend
  std::ostream&
  operator << ( std::ostream& outs, const queens& q )
  {
    if (q.solutions.empty()) outs << strv;
    else                     outs << q.solutions.size();
    outs << strv;
 
    std::size_t n = 1;
    for (auto solution : q.solutions)
    {
      outs << ""#"" << n++ << """" << solution;
    }
 
    return outs;
  }
};
 
 
/* ///////////////////////////////////////////////////////////////////////////string_to <type> ( x )/////////////////////////////////////////////////////////////////////////// */
 
template <typename T>
T string_to( const std::string& s )
{
  T result;
  std::istringstream ss( s );
  ss >> result;
  if (!ss.eof()) throw std::runtime_error( strv );
  return result;
}
 
template <typename T, T default_value>
T string_to( const std::string& s )
{
  try { return string_to <T> ( s ); }
  catch (...) { return default_value; }
}
 
 
/* ///////////////////////////////////////////////////////////////////////////main program/////////////////////////////////////////////////////////////////////////// */
 
int usage( const std::string& name )
{
  std::cerr <<
    ""usage:  "" << name << "" 8""
    strv
    ""Solve the N-Queens problem, brute-force,""
    ""and show all solutions for an 8x8 board.""
    strv
    ""(Specify a value other than 8 for the board size you want.)"";
  return 1;
}
 
int main( int argc, char** argv )
{
  signed N =
    (argc < 2) ? 8 :
    (argc > 2) ? 0 : string_to <signed, 0> ( argv[ 1 ] );
 
  if (N <= 0) return usage( argv[ 0 ] );
 
  std::cout << queens( N ) << """";
}
  
#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class point
{
public:
    int x, y;
    point(){ x = y = 0; }
    void set( int a, int b ){ x = a; y = b; }
};
//--------------------------------------------------------------------------------------------------
class nQueens
{
public:
    void solve( int c )
    {
        _count = c; int len = ( c + 1 ) * ( c + 1 ); _queens = new bool[len]; memset( _queens, 0, len );
	_cl = new bool[c]; memset( _cl, 0, c ); _ln = new bool[c]; memset( _ln, 0, c );
	point pt; pt.set( rand() % c, rand() % c ); putQueens( pt, c ); displayBoard();
	delete [] _queens; delete [] _ln; delete [] _cl;
    }
 
private:
    void displayBoard()
    {
	system( strv ); string t = strv, q = strv, s = strv;
	COORD c = { 0, 0 }; HANDLE h = GetStdHandle( STD_OUTPUT_HANDLE );
	for( int y = 0, cy = 0; y < _count; y++ )
	{
	    int yy = y * _count;
	    for( int x = 0; x < _count; x++ )
	    {
		SetConsoleCursorPosition( h, c ); cout << t;
		c.Y++; SetConsoleCursorPosition( h, c );
		if( _queens[x + yy] ) cout << q; else cout << s;
		c.Y++; SetConsoleCursorPosition( h, c );
		cout << t; c.Y = cy; c.X += 4;
	    }
	    cy += 2; c.X = 0; c.Y = cy;
        }
    }
 
    bool checkD( int x, int y, int a, int b )
    {
	if( x < 0 || y < 0 || x >= _count || y >= _count ) return true;
	if( _queens[x + y * _count] ) return false;
	if( checkD( x + a, y + b, a, b ) ) return true;
	return false;
    }
 
    bool check( int x, int y )
    {
	if( _ln[y] || _cl[x] )        return false;
	if( !checkD( x, y, -1, -1 ) ) return false;
	if( !checkD( x, y,  1, -1 ) ) return false;
	if( !checkD( x, y, -1,  1 ) ) return false;
	if( !checkD( x, y,  1,  1 ) ) return false;
	return true;
    }
 
    bool putQueens( point pt, int cnt )
    {
	int it = _count;
	while( it )
	{
	    if( !cnt ) return true;
	    if( check( pt.x, pt.y ) )
	    {
		_queens[pt.x + pt.y * _count] = _cl[pt.x] = _ln[pt.y] = true;
		point tmp = pt; if( ++tmp.x >= _count ) tmp.x = 0; if( ++tmp.y >= _count ) tmp.y = 0;
		if( putQueens( tmp, cnt - 1 ) ) return true;
		_queens[pt.x + pt.y * _count] = _cl[pt.x] = _ln[pt.y] = false;
	    }
	    if( ++pt.x >= _count ) pt.x = 0;
	    it--;
	}
	return false;
    }
 
    int          _count;
    bool*        _queens, *_ln, *_cl;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    nQueens n; int nq;
    while( true )
    {
	system( strv ); cout << strv; cin >> nq;
	if( nq < 4 ) return 0; n.solve( nq ); cout << endl << endl;
	system( strv );
    }
    return  0;
}
//--------------------------------------------------------------------------------------------------
  
#include <windows.h>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
typedef unsigned int uint;
 
//--------------------------------------------------------------------------------------------------
class nQueens_Heuristic
{
public:
    void solve( uint n ) { makeList( n ); drawBoard( n ); }
 
private:
    void drawBoard( uint n )
    {
	system( strv ); string t = strv, q = strv, s = strv;
	COORD c = { 0, 0 }; HANDLE h = GetStdHandle( STD_OUTPUT_HANDLE );
	uint w = 0;
	for( uint y = 0, cy = 0; y < n; y++ )
	{
	    for( uint x = 0; x < n; x++ )
	    {
		SetConsoleCursorPosition( h, c ); cout << t;
		c.Y++; SetConsoleCursorPosition( h, c );
		if( x + 1 == solution[w] ) cout << q; else cout << s;
		c.Y++; SetConsoleCursorPosition( h, c );
		cout << t; c.Y = cy; c.X += 4;
	    }
	    cy += 2; c.X = 0; c.Y = cy; w++;
	}
	solution.clear(); odd.clear(); evn.clear();
    }
 
    void makeList( uint n )
    {
	uint r = n % 6;
	for( uint x = 1; x <= n; x++ )
	{
	    if( x & 1 ) odd.push_back( x );
	    else evn.push_back( x );
	}
	if( r == 2 )
	{
	    swap( odd[0], odd[1] );
	    odd.erase( find( odd.begin(), odd.end(), 5 ) );
	    odd.push_back( 5 );
	}
	else if( r == 3 )
	{
	    odd.erase( odd.begin() ); odd.erase( odd.begin() );
	    odd.push_back( 1 ); odd.push_back( 3 );
	    evn.erase( evn.begin() ); evn.push_back( 2 );
	}
	vector<uint>::iterator it = evn.begin();
	while( it != evn.end() ) 
	{
	    solution.push_back( ( *it ) );
	    it++;
	}
	it = odd.begin();
	while( it != odd.end() ) 
	{
	    solution.push_back( ( *it ) );
	    it++;
	}
    }
 
    vector<uint> odd, evn, solution;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    uint n; nQueens_Heuristic nQH;
    while( true )
    {
	cout << strv; cin >> n;
	if( n < 4 ) return 0;
	nQH.solve( n ); cout << endl << endl;
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <iomanip>
#include <cmath> // for log10()
#include <algorithm> // for max()
 
size_t table_column_width(const int min, const int max)
{
    unsigned int abs_max = std::max(max*max, min*min);
 
    

    

    

    

    size_t colwidth = 2 + std::log10(abs_max);
 
    

    

    

    if (min < 0 && max > 0)
	++colwidth;
    return colwidth;
}
 
struct Writer_
{
    decltype(std::setw(1)) fmt_;
    Writer_(size_t w) : fmt_(std::setw(w)) {}
    template<class T_> Writer_& operator()(const T_& info) { std::cout << fmt_ << info; return *this; }
};
 
void print_table_header(const int min, const int max)
{
    Writer_ write(table_column_width(min, max));
 
    

    write(strv);
    for(int col = min; col <= max; ++col)
        write(col);
 
    

    std::cout << std::endl << std::endl;
}
 
void print_table_row(const int num, const int min, const int max)
{
    Writer_ write(table_column_width(min, max));
 
    

    write(num);
 
    

    for(int multiplicand = min; multiplicand < num; ++multiplicand)
        write(strv);
 
    

    for(int multiplicand = num; multiplicand <= max; ++multiplicand)
        write(num * multiplicand);
 
    

    std::cout << std::endl << std::endl;
}
 
void print_table(const int min, const int max)
{
    

    print_table_header(min, max);
 
    

    for(int row = min; row <= max; ++row)
        print_table_row(row, min, max);
}
 
int main()
{
    print_table(1, 12);
    return 0;
}
 "
"#include<iostream>
#include<conio.h>
using namespace std;
typedef unsigned long ulong;
 
int ith_digit_finder(long long n, long b, long i){
 /**     n = number whose digits we need to extract     b = radix in which the number if represented     i = the ith bit (ie, index of the bit that needs to be extracted) **/
    while(i>0){
        n/=b;
        i--;
    }
    return (n%b);
}
 
long eeuclid(long m, long b, long *inverse){        /// eeuclid( modulus, num whose inv is to be found, variable to put inverse )
    /// Algorithm used from Stallings book
    long A1 = 1, A2 = 0, A3 = m,
         B1 = 0, B2 = 1, B3 = b,
         T1, T2, T3, Q;
 
         cout<<endl<<strv<<endl;
 
        while(1){
            if(B3 == 0){
                *inverse = 0;
                return A3;      

            }
 
            if(B3 == 1){
                *inverse = B2; 

                return B3;      

            }
 
            Q = A3/B3;
 
            T1 = A1 - Q*B1;
            T2 = A2 - Q*B2;
            T3 = A3 - Q*B3;
 
            A1 = B1; A2 = B2; A3 = B3;
            B1 = T1; B2 = T2; B3 = T3;
 
       }
    cout<<endl<<strv<<endl;
}
 
long long mon_red(long m, long m_dash, long T, int n, long b = 2){
/**    m = modulus    m_dash = m' = -m^-1 mod b    T = number whose modular reduction is needed, the o/p of the function is TR^-1 mod m    n = number of bits in m (2n is the number of bits in T)    b = radix used (for practical implementations, is equal to 2, which is the default value)**/
    long long A,ui, temp, Ai;       

    if( m_dash < 0 ) m_dash = m_dash + b;
    A = T;
    for(int i = 0; i<n; i++){
    ///    ui = ( (A%b)*m_dash ) % b;        // step 2.1; A%b gives ai (MISTAKE -- A%b will always give the last digit of A if A is represented in base b); hence we need the function ith_digit_finder()
        Ai = ith_digit_finder(A, b, i);
        ui = ( ( Ai % b) * m_dash ) % b;
        temp  = ui*m*power(b, i);
        A = A + temp;
    }
    A = A/power(b, n);
    if(A >= m) A = A - m;
    return A;
}
 
int main(){
    long a, b, c, d=0, e, inverse = 0;
    cout<<strv;
    cin >> a;
    cout<<strv;
    cin>>b;
    cout<<strv;
    cin>>c;
    eeuclid(c, a, &d);      

    e = mon_red(a, -d, b, length_finder(a, c), c);
    cout<<strv<<e;
    return 0;
}"
"#include <iostream>
 using namespace std;
 
int mul_inv(int a, int b)
{
	int b0 = b, t, q;
	int x0 = 0, x1 = 1;
	if (b == 1) return 1;
	while (a > 1) {
		q = a / b;
		t = b, b = a % b, a = t;
		t = x0, x0 = x1 - q * x0, x1 = t;
	}
	if (x1 < 0) x1 += b0;
	return x1;
}
 
int main(void) {
	cout<<mul_inv(42, 2017)<<endl;
	return 0;
}
 #include <iostream>
 
short ObtainMultiplicativeInverse(int a, int b, int s0 = 1, int s1 = 0)
{
    return b==0? s0: ObtainMultiplicativeInverse(b, a%b, s1, s0 - s1*(a/b));
}
 
int main(int argc, char* argv[])
{
    std::cout << ObtainMultiplicativeInverse(42, 2017) << std::endl;
    return 0;
}
 "
"int meaning_of_life();#include <iostream>
 
using namespace std;
 
int meaning_of_life() {
	return 42;
}
 
#ifdef SCRIPTEDMAIN
 
int main() {
	cout << strv << meaning_of_life() << endl;
	return 0;
}
 
#endif#include strv
#include <iostream>
 
using namespace std;
 
extern int meaning_of_life();
 
int main() {
	cout << strv << meaning_of_life() << endl;
	return 0;
}"
" 
#include<iostream>
#include<math.h>
#include<stdlib.h>
#include<time.h>
 
using namespace std;
int main(){
    int jmax=1000; 

    int imax=1000; 

    double x,y;    

    int hit;       

    srand(time(0));
    for (int j=0;j<jmax;j++){
        hit=0;
        x=0; y=0;
        for(int i=0;i<imax;i++){
            x=double(rand())/double(RAND_MAX);
            y=double(rand())/double(RAND_MAX);
        if(y<=sqrt(1-pow(x,2))) hit+=1; }          //Choosing HITs according to analytic formula of circle
    cout<<strv<<4*double(hit)/double(imax)<<endl; }  

}
 "
"#include <iostream>
#include <cstdlib>
#include <ctime>
 
int randint(int n)
{
  return (1.0*n*std::rand())/(1.0+RAND_MAX);
}
 
int other(int doorA, int doorB)
{
  int doorC;
  if (doorA == doorB)
  {
    doorC = randint(2);
    if (doorC >= doorA)
      ++doorC;
  }
  else
  {
    for (doorC = 0; doorC == doorA || doorC == doorB; ++doorC)
    {
      

    }
  }
  return doorC;
}
 
int check(int games, bool change)
{
  int win_count = 0;
  for (int game = 0; game < games; ++game)
  {
    int const winning_door = randint(3);
    int const original_choice = randint(3);
    int open_door = other(original_choice, winning_door);
 
    int const selected_door = change?
                                other(open_door, original_choice)
                              : original_choice;
 
    if (selected_door == winning_door)
      ++win_count;
  }
 
  return win_count;
}
 
int main()
{
  std::srand(std::time(0));
 
  int games = 10000;
  int wins_stay = check(games, false);
  int wins_change = check(games, true);
  std::cout << strv << 100.0*wins_stay/games << strv << 100.0*wins_change/games << ""%"";
}"
" 
#include <iostream>
#include <string>
#include <windows.h>
using namespace std;
typedef unsigned char byte;
 
enum fieldValues : byte { OPEN, CLOSED = 10, MINE, UNKNOWN, FLAG, ERR };
 
class fieldData
{
public:
    fieldData() : value( CLOSED ), open( false ) {}
    byte value;
    bool open, mine;
};
 
class game
{
public:
    ~game()
    { if( field ) delete [] field; }
 
    game( int x, int y )
    {
        go = false; wid = x; hei = y;
	field = new fieldData[x * y];
	memset( field, 0, x * y * sizeof( fieldData ) );
	oMines = ( ( 22 - rand() % 11 ) * x * y ) / 100;
	mMines = 0;
	int mx, my, m = 0;
	for( ; m < oMines; m++ )
	{
	    do
	    { mx = rand() % wid; my = rand() % hei; }
	    while( field[mx + wid * my].mine );
	    field[mx + wid * my].mine = true;
	}
	graphs[0] = ' '; graphs[1] = '.'; graphs[2] = '*'; 
	graphs[3] = '?'; graphs[4] = '!'; graphs[5] = 'X'; 
    }
 
    void gameLoop()
    {
	string c, r, a;
	int col, row;
	while( !go )
	{
	    drawBoard();
	    cout << ""Enter column, row and an action( c r a ):Actions: o => open, f => flag, ? => unknown"";
	    cin >> c >> r >> a;
	    if( c[0] > 'Z' ) c[0] -= 32; if( a[0] > 'Z' ) a[0] -= 32;
	    col = c[0] - 65; row = r[0] - 49;
	    makeMove( col, row, a );
	}
    }
 
private:
    void makeMove( int x, int y, string a )
    {
	fieldData* fd = &field[wid * y + x];
	if( fd->open && fd->value < CLOSED )
	{
	    cout << strv;
	    Sleep( 3000 ); return;
	}
	if( a[0] == 'O' ) openCell( x, y );
	else if( a[0] == 'F' ) 
	{
	    fd->open = true;
	    fd->value = FLAG;
	    mMines++;
	    checkWin();
	}
	else
	{
	    fd->open = true;
	    fd->value = UNKNOWN;
	}
    }
 
    bool openCell( int x, int y )
    {
	if( !isInside( x, y ) ) return false;
	if( field[x + y * wid].mine ) boom();
	else 
	{
	    if( field[x + y * wid].value == FLAG )
	    {
		field[x + y * wid].value = CLOSED;
		field[x + y * wid].open = false;
		mMines--;
	    }
	    recOpen( x, y );
	    checkWin();
	}
	return true;
    }
 
    void drawBoard()
    {
	system( strv );
	cout << strv << mMines << strv << oMines << """";		
	for( int x = 0; x < wid; x++ )
	    cout << strv << ( char )( 65 + x ) << strv; 
	cout << """"; int yy;
	for( int y = 0; y < hei; y++ )
	{
	    yy = y * wid;
	    for( int x = 0; x < wid; x++ )
		cout << strv;
 
	    cout << ""+""; fieldData* fd;
	    for( int x = 0; x < wid; x++ )
	    {
		fd = &field[x + yy]; cout<< strv;
		if( !fd->open ) cout << ( char )graphs[1] << strv;
		else 
		{
		    if( fd->value > 9 )
			cout << ( char )graphs[fd->value - 9] << strv;
		    else
		    {
			if( fd->value < 1 ) cout << strv;
			    else cout << ( char )(fd->value + 48 ) << strv;
		    }
		}
	    }
	    cout << strv << y + 1 << """";
	}
	for( int x = 0; x < wid; x++ )
	    cout << strv;
 
	cout << ""+"";
    }
 
    void checkWin()
    {
	int z = wid * hei - oMines, yy;
	fieldData* fd;
	for( int y = 0; y < hei; y++ )
	{
	    yy = wid * y;
	    for( int x = 0; x < wid; x++ )
	    {
		fd = &field[x + yy];
		if( fd->open && fd->value != FLAG ) z--;
	    }
	}
	if( !z ) lastMsg( strv);
    }
 
    void boom()
    {
	int yy; fieldData* fd;
	for( int y = 0; y < hei; y++ )
	{
	    yy = wid * y;
	    for( int x = 0; x < wid; x++ )
	    {
		fd = &field[x + yy];
		if( fd->value == FLAG )
		{
		    fd->open = true;
		    fd->value = fd->mine ? MINE : ERR;
		}
		else if( fd->mine )
		{
		    fd->open = true;
		    fd->value = MINE;
		}
	    }
	}
	lastMsg( strv );
    }
 
    void lastMsg( string s )
    {
	go = true; drawBoard();
	cout << s << """";
    }
 
    bool isInside( int x, int y ) { return ( x > -1 && y > -1 && x < wid && y < hei ); }
 
    void recOpen( int x, int y )
    {
	if( !isInside( x, y ) || field[x + y * wid].open ) return;
	int bc = getMineCount( x, y );
	field[x + y * wid].open = true;
	field[x + y * wid].value = bc;
	if( bc ) return;
 
	for( int yy = -1; yy < 2; yy++ )
	    for( int xx = -1; xx < 2; xx++ )
	    {
		if( xx == 0 && yy == 0 ) continue;
		recOpen( x + xx, y + yy );
	    }
    }
 
    int getMineCount( int x, int y )
    {
	int m = 0;
	for( int yy = -1; yy < 2; yy++ )
	    for( int xx = -1; xx < 2; xx++ )
	    {
		if( xx == 0 && yy == 0 ) continue;
		if( isInside( x + xx, y + yy ) && field[x + xx + ( y + yy ) * wid].mine ) m++;
	    }
 
	return m;
    }
 
    int wid, hei, mMines, oMines;
    fieldData* field; bool go;
    int graphs[6];
};
 
int main( int argc, char* argv[] )
{
    srand( GetTickCount() );
    game g( 4, 6 ); g.gameLoop();
    return system( strv );
}
 "
"#include <iostream>
 
std::string middleThreeDigits(int n)
{
    auto number = std::to_string(std::abs(n));
    auto length = number.size();
 
    if (length < 3) {
        return strv;
    } else if (length % 2 == 0) {
        return strv;
    } else {
        return number.substr(length / 2 - 1, 3);
    }
}
 
int main()
{
    auto values {123, 12345, 1234567, 987654321, 10001,
                 -10001, -123, -100, 100, -12345,
                 1, 2, -1, -10, 2002, -2002, 0};
 
    for (auto&& v : values) {
        std::cout << strv << v << strv <<
                     middleThreeDigits(v) << """";
    }
}
 "
"#include <iostream>
#include <string>
#include <vector>
 
void print_menu(const std::vector<std::string>& terms)
{
    for (size_t i = 0; i < terms.size(); i++) {
        std::cout << i + 1 << strv << terms[i] << '';
    }
}
 
int parse_entry(const std::string& entry, int max_number)
{
    int number = std::stoi(entry);
    if (number < 1 || number > max_number) {
        throw std::invalid_argument(strv);
    }
 
    return number;
}
 
std::string data_entry(const std::string& prompt, const std::vector<std::string>& terms)
{
    if (terms.empty()) {
        return strv;
    }
 
    int choice;
    while (true) {
        print_menu(terms);
        std::cout << prompt;
 
        std::string entry;
        std::cin >> entry;
 
        try {
            choice = parse_entry(entry, terms.size());
            return terms[choice - 1];
        } catch (std::invalid_argument&) {
            

        }
    }
}
 
int main()
{
    std::vector<std::string> terms = {strv, strv, strv, strv};
    std::cout << strv << data_entry(strv, terms) << std::endl;
}
 "
"#include <string>
 
int main()
{
  int* p;
 
  p = new int;    

  delete p;       

 
  p = new int(2); 

  delete p;       

 
  std::string* p2;
 
  p2 = new std::string; 

  delete p2;            

 
  p = new int[10]; 

  delete[] p;      

 
  p2 = new std::string[10]; 

  delete[] p2;              

}int main()
{
  void* memory = operator new(20); 

  operator delete(memory);         

}#include <new>
 
int main()
{
  union
  {
    int alignment_dummy; 

    char data[2*sizeof(int)]; 

  };
  int* p = new(&data) int(3); 

  new(p+1) int(5); 

}void* memory_for_p = operator new(sizeof(int));
int* p = new(memory_for_p) int(3);#include <new>
 
int* p = new(std::nothrow) int(3);#include <cstddef>
#include <cstdlib>
#include <new>
 
class MyClass
{
public:
  void* operator new(std::size_t size)
  {
    void* p = std::malloc(size);
    if (!p) throw std::bad_alloc();
    return p;
  }
  void operator delete(void* p)
  {
    free(p);
  }
};
 
int main()
{
  MyClass* p = new MyClass; 

  delete p;                 

 
  int* p2 = new int; 

  delete p2;         

}class arena { /* ... */ };
 
void* operator new(std::size_t size, arena& a)
{
  return arena.alloc(size);
}
 
void operator delete(void* p, arena& a)
{
  arena.dealloc(p);
}
 
arena whatever(/* ... */);
 
int* p = new(whatever) int(3); 
class MyClass { /*...*/ };
 
int main()
{
  MyClass* p = new(whatever) MyClass; 

  

  p->~MyClass(); 

  operator delete(p, whatever); 

}"
"#include <string>
#include <iostream>
#include strv
#include strv
 
using Poco::DigestEngine ;
using Poco::MD5Engine ;
using Poco::DigestOutputStream ;
 
int main( ) {
   std::string myphrase ( strv ) ;
   MD5Engine md5 ;
   DigestOutputStream outstr( md5 ) ;
   outstr << myphrase ;
   outstr.flush( ) ; //to pass everything to the digest engine
   const DigestEngine::Digest& digest = md5.digest( ) ;
   std::cout << myphrase << "" as a MD5 digest :"" << DigestEngine::digestToHex( digest ) 
      << strv << std::endl ;
   return 0 ;
}"
" 
#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int BMP_SIZE = 512, CELL_SIZE = 8;
 
//--------------------------------------------------------------------------------------------------
enum directions { NONE, NOR = 1, EAS = 2, SOU = 4, WES = 8 };
 
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO	bi;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize	   = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes	   = 1;
	bi.bmiHeader.biWidth	   =  w;
	bi.bmiHeader.biHeight	   = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc ); 
	width = w; height = h;
 
	return true;
    }
 
    void clear()
    {
	ZeroMemory( pBits, width * height * sizeof( DWORD ) );
    }
 
    void setPenColor( DWORD clr )
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, 1, clr );
	SelectObject( hdc, pen );
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO	 infoheader;
	BITMAP		 bitmap;
	DWORD		 wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
 
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    HBITMAP bmp;
    HDC	    hdc;
    HPEN    pen;
    void    *pBits;
    int	    width, height;
};
//--------------------------------------------------------------------------------------------------
class mazeGenerator
{
public:
    mazeGenerator()
    {
	_world = 0; 
	_bmp.create( BMP_SIZE, BMP_SIZE ); 
	_bmp.setPenColor( RGB( 0, 255, 0 ) ); 
    }
 
    ~mazeGenerator() { killArray(); }
 
    BYTE* getMaze() const { return _world; }
 
    void create( int side )
    {
	_s = side;
	generate();
    }
 
private:
    void generate()
    {
	killArray();
	_world = new BYTE[_s * _s];
	ZeroMemory( _world, _s * _s );
	_ptX = rand() % _s; _ptY = rand() % _s;
	carve();
    }
 
    void carve()
    {
	while( true )
	{
	    int d = getDirection();
	    if( d < NOR ) return;
 
	    switch( d )
	    {
		case NOR:
		    _world[_ptX + _s * _ptY] |= NOR; _ptY--;
		    _world[_ptX + _s * _ptY] = SOU | SOU << 4;
		break;
		case EAS:
		    _world[_ptX + _s * _ptY] |= EAS; _ptX++;
		    _world[_ptX + _s * _ptY] = WES | WES << 4;
		break;
		case SOU:
		    _world[_ptX + _s * _ptY] |= SOU; _ptY++;
		    _world[_ptX + _s * _ptY] = NOR | NOR << 4;
		break;
		case WES:
		    _world[_ptX + _s * _ptY] |= WES; _ptX--;
		    _world[_ptX + _s * _ptY] = EAS | EAS << 4;
	    }
	}
    }
 
    int getDirection()
    {
	int d = 1 << rand() % 4;
	while( true )
	{
	    for( int x = 0; x < 4; x++ )
	    {
		if( testDir( d ) ) return d;
		d <<= 1;
		if( d > 8 ) d = 1;
	    }
	    d = ( _world[_ptX + _s * _ptY] & 0xf0 ) >> 4;
	    if( !d ) return -1;
	    switch( d )
	    {
		case NOR: _ptY--; break;
		case EAS: _ptX++; break;
		case SOU: _ptY++; break;
		case WES: _ptX--; break;
	    }
 
	    d = 1 << rand() % 4;
        }
    }
 
    bool testDir( int d )
    {
	switch( d )
	{
	    case NOR: return ( _ptY - 1 > -1 && !_world[_ptX + _s * ( _ptY - 1 )] );
	    case EAS: return ( _ptX + 1 < _s && !_world[_ptX + 1 + _s * _ptY] );
	    case SOU: return ( _ptY + 1 < _s && !_world[_ptX + _s * ( _ptY + 1 )] );
	    case WES: return ( _ptX - 1 > -1 && !_world[_ptX - 1 + _s * _ptY] );
	}
	return false;
    }
 
    void killArray() { if( _world ) delete [] _world; }
 
    BYTE*    _world;
    int      _s, _ptX, _ptY;
    myBitmap _bmp;
};
//--------------------------------------------------------------------------------------------------
class mazeSolver
{
public:
    mazeSolver()      
    {
	_bmp.create( BMP_SIZE, BMP_SIZE );
	_pts = 0;
    }
 
    ~mazeSolver() { killPoints(); }
 
    void solveIt( BYTE* maze, int size, int sX, int sY, int eX, int eY )
    {
	_lastDir = NONE;
	_world = maze; _s = size; _sx = sX; _sy = sY; _ex = eX; _ey = eY;
 
	for( int y = 0; y < _s; y++ )
	    for( int x = 0; x < _s; x++ )
		_world[x + _s * y] &= 0x0f;
 
        _world[_sx + _s * _sy] |= NOR << 4;
 
	killPoints();
	_pts = new BYTE[_s * _s];
	ZeroMemory( _pts, _s * _s );
 
	findTheWay();
 
	_sx = sX; _sy = sY;
	display();
    }
 
private:
    int invert( int d )
    {
	switch( d )
	{
	    case NOR: return SOU;
	    case SOU: return NOR;
	    case WES: return EAS;
	    case EAS: return WES;
	}
	return NONE;
    }
 
    void updatePosition( int d )
    {
        switch( d )
	{
	    case NOR: _sy--; break;
	    case EAS: _sx++; break;
	    case SOU: _sy++; break;
	    case WES: _sx--;
	}
    }
 
    void findTheWay()
    {
	while( true )
	{
	    int d = getDirection();
	    if( d < NOR ) return;
	    _lastDir = invert( d );
	    _world[_sx + _s * _sy] |= d;
	    _pts[_sx + _s * _sy] = d;
	    updatePosition( d );
	    if( _sx == _ex && _sy == _ey ) return;
	    _world[_sx + _s * _sy] |= _lastDir << 4;
	}
    }
 
    int getDirection()
    {
	int d = 1 << rand() % 4;
	while( true )
	{
	    for( int x = 0; x < 4; x++ )
	    {
		if( testDirection( d ) ) return d;
		d <<= 1;
		if( d > 8 ) d = 1;
	    }
 
	    d = ( _world[_sx + _s * _sy] & 0xf0 ) >> 4;
	    if( !d ) return -1;
	    _pts[_sx + _s * _sy] = 0;
	    updatePosition( d );
	    _lastDir = invert( d );
	    d = 1 << rand() % 4;
	}
    }
 
    bool testDirection( int d )
    {
	if( d == _lastDir || !( _world[_sx + _s * _sy] & d ) ) return false;
	switch( d )
	{
	    case NOR: 
		return _sy - 1 > -1 && !( _world[_sx + _s * ( _sy - 1 )] & 0xf0 );
	    case EAS: 
		return _sx + 1 < _s && !( _world[_sx + 1 + _s * _sy] & 0xf0 );
	    case SOU: 
		return _sy + 1 < _s && !( _world[_sx + _s * ( _sy + 1 )] & 0xf0 );
	    case WES: 
		return _sx - 1 > -1 && !( _world[_sx - 1 + _s * _sy] & 0xf0 );
	}
	return false;
    }
 
    void display()
    {
	_bmp.setPenColor( RGB( 0, 255, 0 ) );
	_bmp.clear();
	HDC dc = _bmp.getDC();
	for( int y = 0; y < _s; y++ )
	{
	    int yy = y * _s;
	    for( int x = 0; x < _s; x++ )
	    {
		BYTE b = _world[x + yy];
		int nx = x * CELL_SIZE, 
		    ny = y * CELL_SIZE;
 
		if( !( b & NOR ) )
		{
		    MoveToEx( dc, nx, ny, NULL );
		    LineTo( dc, nx + CELL_SIZE + 1, ny );
		}
		if( !( b & EAS ) )
		{
		    MoveToEx( dc, nx + CELL_SIZE, ny, NULL );
		    LineTo( dc, nx + CELL_SIZE, ny + CELL_SIZE + 1 );
		}
		if( !( b & SOU ) )
		{
		    MoveToEx( dc, nx, ny + CELL_SIZE, NULL );
		    LineTo( dc, nx + CELL_SIZE + 1, ny + CELL_SIZE );
		}
		if( !( b & WES ) )
		{
		    MoveToEx( dc, nx, ny, NULL );
		    LineTo( dc, nx, ny + CELL_SIZE + 1 );
		}
	    }
	}
 
	drawEndPoints( dc );
	_bmp.setPenColor( RGB( 255, 0, 0 ) );
 
	for( int y = 0; y < _s; y++ )
	{
	    int yy = y * _s;
	    for( int x = 0; x < _s; x++ )
	    {
		BYTE d = _pts[x + yy];
		if( !d ) continue;
 
		int nx = x * CELL_SIZE + 4, 
		    ny = y * CELL_SIZE + 4;
 
		MoveToEx( dc, nx, ny, NULL );
		switch( d )
		{
		    case NOR: LineTo( dc, nx, ny - CELL_SIZE - 1 ); break;
		    case EAS: LineTo( dc, nx + CELL_SIZE + 1, ny ); break;
		    case SOU: LineTo( dc, nx, ny + CELL_SIZE + 1 ); break;
		    case WES: LineTo( dc, nx - CELL_SIZE - 1, ny ); break;
		}
	    }
	}
 
	_bmp.saveBitmap( ""f:rcmaze_s.bmp"" );
	BitBlt( GetDC( GetConsoleWindow() ), 10, 60, BMP_SIZE, BMP_SIZE, _bmp.getDC(), 0, 0, SRCCOPY );
    }
 
    void drawEndPoints( HDC dc )
    {
	RECT rc;
	int x = 1 + _sx * CELL_SIZE, y = 1 + _sy * CELL_SIZE;
	SetRect( &rc, x, y, x + CELL_SIZE - 1, y + CELL_SIZE - 1 );
	FillRect( dc, &rc, ( HBRUSH )GetStockObject( WHITE_BRUSH ) );
	x = 1 + _ex * CELL_SIZE, y = 1 + _ey * CELL_SIZE;
	SetRect( &rc, x, y, x + CELL_SIZE - 1, y + CELL_SIZE - 1 );
	FillRect( dc, &rc, ( HBRUSH )GetStockObject( WHITE_BRUSH ) );
    }
 
    void killPoints() { if( _pts ) delete [] _pts; }
 
    BYTE*    _world, *_pts;
    int      _s, _sx, _sy, _ex, _ey, _lastDir;
    myBitmap _bmp;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );
    srand( GetTickCount() );
 
    mazeGenerator mg;
    mazeSolver ms;
    int s;
    while( true )
    {
	cout << strv; cin >> s;
	if( !s ) return 0;
	if( !( s & 1 ) ) s++;
	if( s >= 3 ) 
	{
	    mg.create( s );
	    int sx, sy, ex, ey;
	    while( true )
	    {
		sx = rand() % s; sy = rand() % s;
		ex = rand() % s; ey = rand() % s;
		if( ex != sx || ey != sy ) break;
	    }
	    ms.solveIt( mg.getMaze(), s, sx, sy, ex, ey );
	    cout << endl;
	}
	system( strv );
	system( strv );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
" 
#include <iostream>
 
int main( int argc, char* argv[] )
{
    int triangle[] = 
    {
	55,
	94, 48,
	95, 30, 96,
	77, 71, 26, 67,
	97, 13, 76, 38, 45,
	7, 36, 79, 16, 37, 68,
	48, 7, 9, 18, 70, 26, 6,
	18, 72, 79, 46, 59, 79, 29, 90,
	20, 76, 87, 11, 32, 7, 7, 49, 18,
	27, 83, 58, 35, 71, 11, 25, 57, 29, 85,
	14, 64, 36, 96, 27, 11, 58, 56, 92, 18, 55,
	2, 90, 3, 60, 48, 49, 41, 46, 33, 36, 47, 23,
	92, 50, 48, 2, 36, 59, 42, 79, 72, 20, 82, 77, 42,
	56, 78, 38, 80, 39, 75, 2, 71, 66, 66, 1, 3, 55, 72,
	44, 25, 67, 84, 71, 67, 11, 61, 40, 57, 58, 89, 40, 56, 36,
	85, 32, 25, 85, 57, 48, 84, 35, 47, 62, 17, 1, 1, 99, 89, 52,
	6, 71, 28, 75, 94, 48, 37, 10, 23, 51, 6, 48, 53, 18, 74, 98, 15,
	27, 2, 92, 23, 8, 71, 76, 84, 15, 52, 92, 63, 81, 10, 44, 10, 69, 93
    };
 
    const int size = sizeof( triangle ) / sizeof( int );
    const int tn = static_cast<int>(sqrt(2.0 * size));
    assert(tn * (tn + 1) == 2 * size);    

 
    

    for (int n = tn - 1; n > 0; --n)   

        for (int k = (n * (n-1)) / 2; k < (n * (n+2)) / 2; ++k)
            triangle[k] += std::max(triangle[k + n], triangle[k + n + 1]);
 
    std::cout << strv << triangle[0] << """";
}
 "
"#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/io.hpp>
 
int main()
{
  using namespace boost::numeric::ublas;
 
  matrix<double> m(3,3);
 
  for(int i=0; i!=m.size1(); ++i)
    for(int j=0; j!=m.size2(); ++j)
      m(i,j)=3*i+j;
 
  std::cout << trans(m) << std::endl;
}#include <iostream>
#include strv
 
#if !defined(ARRAY_SIZE)
    #define ARRAY_SIZE(x) (sizeof((x)) / sizeof((x)[0]))
#endif
 
template<class T>
void printMatrix(const Matrix<T>& m) {
    std::cout << strv << m.rowNum() << strv << m.colNum() << std::endl;
    for (unsigned int i = 0; i < m.rowNum(); i++) {
        for (unsigned int j = 0; j < m.colNum(); j++) {
            std::cout <<  m[i][j] << strv;
        }
        std::cout << std::endl;
    }
} /* printMatrix() */
 
int main() {
    int  am[2][3] = {
        {1,2,3},
        {4,5,6},
    };
 
    Matrix<int> a(ARRAY_SIZE(am), ARRAY_SIZE(am[0]), am[0], ARRAY_SIZE(am)*ARRAY_SIZE(am[0]));
 
    try {
        std::cout << strv << std::endl;
        printMatrix(a);
        std::cout << std::endl;
        a.transpose();
        std::cout << strv << std::endl;
        printMatrix(a);
    } catch (MatrixException& e) {
        std::cerr << e.message() << std::endl;
        return e.errorCode();
    }
 
} /* main() */#ifndef _MATRIX_H
#define	_MATRIX_H
 
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
 
#define MATRIX_ERROR_CODE_COUNT 5
#define MATRIX_ERR_UNDEFINED strv
#define MATRIX_ERR_WRONG_ROW_INDEX strv
#define MATRIX_ERR_MUL_ROW_AND_COL_NOT_EQUAL strv
#define MATRIX_ERR_MUL_ROW_AND_COL_BE_GREATER_THAN_ZERO strv
#define MATRIX_ERR_TOO_FEW_DATA strv
 
class MatrixException {
private:
    std::string message_;
    int errorCode_;
public:
    MatrixException(std::string message = MATRIX_ERR_UNDEFINED);
 
    inline std::string message() {
        return message_;
    };
 
    inline int errorCode() {
        return errorCode_;
    };
};
 
MatrixException::MatrixException(std::string message) {
    errorCode_ = MATRIX_ERROR_CODE_COUNT + 1;
    std::stringstream ss(message);
    ss >> errorCode_;
    if (errorCode_ < 1) {
        errorCode_ = MATRIX_ERROR_CODE_COUNT + 1;
    }
    std::string::size_type pos = message.find(' ');
    if (errorCode_ <= MATRIX_ERROR_CODE_COUNT && pos != std::string::npos) {
        message_ = message.substr(pos + 1);
    } else {
        message_ = message + strv;
    }
}
 
/** * Generic class for matrices. */
template <class T>
class Matrix {
private:
    std::vector<T> v; 

    unsigned int m;   

    unsigned int n;   

protected:
 
    virtual void clear() {
        v.clear();
        m = n = 0;
    }
public:
 
    Matrix() {
        clear();
    }
    Matrix(unsigned int, unsigned int, T* = 0, unsigned int = 0);
    Matrix(unsigned int, unsigned int, const std::vector<T>&);
 
    virtual ~Matrix() {
        clear();
    }
    Matrix& operator=(const Matrix&);
    std::vector<T> operator[](unsigned int) const;
    Matrix operator*(const Matrix&);
    void transpose();
 
    inline unsigned int rowNum() const {
        return m;
    }
 
    inline unsigned int colNum() const {
        return n;
    }
 
    inline unsigned int size() const {
        return v.size();
    }
 
    inline void add(const T& t) {
        v.push_back(t);
    }
};
 
template <class T>
Matrix<T>::Matrix(unsigned int row, unsigned int col, T* data, unsigned int dataLength) {
    clear();
    if (row > 0 && col > 0) {
        m = row;
        n = col;
        unsigned int mxn = m * n;
        if (dataLength && data) {
            for (unsigned int i = 0; i < dataLength && i < mxn; i++) {
                v.push_back(data[i]);
            }
        }
    }
}
 
template <class T>
Matrix<T>::Matrix(unsigned int row, unsigned int col, const std::vector<T>& data) {
    clear();
    if (row > 0 && col > 0) {
        m = row;
        n = col;
        unsigned int mxn = m * n;
        if (data.size() > 0) {
            for (unsigned int i = 0; i < mxn && i < data.size(); i++) {
                v.push_back(data[i]);
            }
        }
    }
}
 
template<class T>
Matrix<T>& Matrix<T>::operator=(const Matrix<T>& other) {
    clear();
    if (other.m > 0 && other.n > 0) {
        m = other.m;
        n = other.n;
        unsigned int mxn = m * n;
        for (unsigned int i = 0; i < mxn && i < other.size(); i++) {
            v.push_back(other.v[i]);
        }
    }
    return *this;
}
 
template<class T>
std::vector<T> Matrix<T>::operator[](unsigned int index) const {
    std::vector<T> result;
    if (index >= m) {
        throw MatrixException(MATRIX_ERR_WRONG_ROW_INDEX);
    } else if ((index + 1) * n > size()) {
        throw MatrixException(MATRIX_ERR_TOO_FEW_DATA);
    } else {
        unsigned int begin = index * n;
        unsigned int end = begin + n;
        for (unsigned int i = begin; i < end; i++) {
            result.push_back(v[i]);
        }
    }
    return result;
}
 
template<class T>
Matrix<T> Matrix<T>::operator*(const Matrix<T>& other) {
    Matrix result(m, other.n);
    if (n != other.m) {
        throw MatrixException(MATRIX_ERR_MUL_ROW_AND_COL_NOT_EQUAL);
    } else if (m <= 0 || n <= 0 || other.n <= 0) {
        throw MatrixException(MATRIX_ERR_MUL_ROW_AND_COL_BE_GREATER_THAN_ZERO);
    } else if (m * n > size() || other.m * other.n > other.size()) {
        throw MatrixException(MATRIX_ERR_TOO_FEW_DATA);
    } else {
        for (unsigned int i = 0; i < m; i++) {
            for (unsigned int j = 0; j < other.n; j++) {
                T temp = v[i * n] * other.v[j];
                for (unsigned int k = 1; k < n; k++) {
                    temp += v[i * n + k] * other.v[k * other.n + j];
                }
                result.v.push_back(temp);
            }
        }
    }
    return result;
}
 
template<class T>
void Matrix<T>::transpose() {
    if (m * n > size()) {
        throw MatrixException(MATRIX_ERR_TOO_FEW_DATA);
    } else {
        std::vector<T> v2;
        std::swap(v, v2);
        for (unsigned int i = 0; i < n; i++) {
            for (unsigned int j = 0; j < m; j++) {
                v.push_back(v2[j * n + i]);
            }
        }
        std::swap(m, n);
    }
}
 
#endif	/* _MATRIX_H */#include <iostream>
 
int main(){
    const int l = 5;
    const int w = 3;
    int m1[l][w] = {{1,2,3}, {4,5,6}, {7,8,9}, {10,11,12}, {13,14,15}};
    int m2[w][l];
 
    for(int i=0; i<w; i++){
        for(int x=0; x<l; x++){
            m2[i][x]=m1[x][i];
        }
    }
 
    

 
    std::cout << strv;
    for(int i=0; i<l; i++){
        std::cout << std::endl;
        for(int x=0; x<w; x++){
            std::cout << m1[i][x] << strv;
        }
    }
 
    std::cout << ""After:"";
    for(int i=0; i<w; i++){
        std::cout << std::endl;
        for(int x=0; x<l; x++){
            std::cout << m2[i][x] << strv;
        }
    }
 
    std::cout << std::endl;
 
    return 0;
}"
"#include <complex>
#include <cmath>
#include <iostream>
using namespace std;
 
template<int MSize = 3, class T = complex<double> >
class SqMx {
  typedef T Ax[MSize][MSize];
  typedef SqMx<MSize, T> Mx;
 
private:
  Ax a;
  SqMx() { }
 
public:
  SqMx(const Ax &_a) { 

    for (int r = 0; r < MSize; r++)
      for (int c = 0; c < MSize; c++)
        a[r][c] = _a[r][c];
  }
 
  static Mx identity() {
    Mx m;
    for (int r = 0; r < MSize; r++)
      for (int c = 0; c < MSize; c++)
        m.a[r][c] = (r == c ? 1 : 0);
    return m;
  }
 
  friend ostream &operator<<(ostream& os, const Mx &p)
  { 

    for (int i = 0; i < MSize; i++) {
      for (int j = 0; j < MSize; j++)
        os << p.a[i][j] << strv;
      os << endl;
    }
    return os;
  }
 
  Mx operator*(const Mx &b) {
    Mx d;
    for (int r = 0; r < MSize; r++)
      for (int c = 0; c < MSize; c++) {
        d.a[r][c] = 0;
        for (int k = 0; k < MSize; k++)
          d.a[r][c] += a[r][k] * b.a[k][c];
      }
    return d;
  }  

  Mx operator^(int n) {
    if (n < 0)
      throw strv;
 
    Mx d = identity();
    for (Mx sq = *this; n > 0; sq = sq * sq, n /= 2)
      if (n % 2 != 0)
        d = d * sq;
    return d;
  } 
};
 
typedef SqMx<> M3;
typedef complex<double> creal;
 
int main() {
  double q = sqrt(0.5);
  creal array[3][3] =
    {{creal(q,  0), creal(q, 0), creal(0, 0)},
     {creal(0, -q), creal(0, q), creal(0, 0)},
     {creal(0,  0), creal(0, 0), creal(0, 1)}};
  M3 m(array);
 
  cout << strv << endl
       << (m ^ 23) << endl;
 
  return 0;
}"
" 
#include <iostream>
#include <algorithm>
#include <ctime>
#include <string>
#include <vector>
 
typedef std::vector<char> vecChar;
 
class master {
public:
    master( size_t code_len, size_t clr_count, size_t guess_count, bool rpt ) {
        std::string color = strv;
 
        if( code_len < 4 ) code_len = 4; else if( code_len > 10 ) code_len = 10;
        if( !rpt && clr_count < code_len ) clr_count = code_len; 
        if( clr_count < 2 ) clr_count = 2; else if( clr_count > 20 ) clr_count = 20;
        if( guess_count < 7 ) guess_count = 7; else if( guess_count > 20 ) guess_count = 20;
 
        codeLen = code_len; colorsCnt = clr_count; guessCnt = guess_count; repeatClr = rpt;
 
        for( size_t s = 0; s < colorsCnt; s++ ) {
            colors.append( 1, color.at( s ) );
        }
    }
    void play() {
        bool win = false;
        combo = getCombo();
 
        while( guessCnt ) {
            showBoard();
            if( checkInput( getInput() ) ) {
                win = true;
                break;
            }
            guessCnt--;
        }
        if( win ) {
            std::cout << ""--------------------------------"" <<
                ""Very well done!You found the code: "" << combo <<
                ""--------------------------------"";
        } else {
            std::cout << ""--------------------------------"" <<
                ""I am sorry, you couldn't make it!The code was: "" << combo <<
                ""--------------------------------"";
        }
    }
private:
    void showBoard() {
        vecChar::iterator y;
        for( int x = 0; x < guesses.size(); x++ ) {
            std::cout << ""--------------------------------"";
            std::cout << x + 1 << strv;
            for( y = guesses[x].begin(); y != guesses[x].end(); y++ ) {
                std::cout << *y << strv;
            }
 
            std::cout << strv;
            for( y = results[x].begin(); y != results[x].end(); y++ ) {
                std::cout << *y << strv;
            }
 
            int z = codeLen - results[x].size();
            if( z > 0 ) {
                for( int x = 0; x < z; x++ ) std::cout << strv;
            }
        }
        std::cout << """";
    }
    std::string getInput() {
        std::string a;
        while( true ) {
            std::cout << strv << colors << strv;
            a = strv; std::cin >> a;
            std::transform( a.begin(), a.end(), a.begin(), ::toupper );
            if( a.length() > codeLen ) a.erase( codeLen );
            bool r = true;
            for( std::string::iterator x = a.begin(); x != a.end(); x++ ) {
                if( colors.find( *x ) == std::string.npos ) {
                    r = false;
                    break;
                }
            }
            if( r ) break;
        }
        return a;
    }
    bool checkInput( std::string a ) {
        vecChar g;
        for( std::string::iterator x = a.begin(); x != a.end(); x++ ) {
            g.push_back( *x );
        }
        guesses.push_back( g );
 
        int black = 0, white = 0;
        std::vector<bool> match( codeLen, false );
 
        for( int b = 0; b < codeLen; b++ ) {
            if( a.at( b ) == combo.at( b ) ) {
                match[b] = true;
                black++;
                continue;
            }
 
            for( int w = 0; w < codeLen; w++ ) {
                if( !match[b] && w != b && a.at( w ) == combo.at( b ) ) {
                    match[b] = true;
                    white++;
                    continue;
                }
            }
        }
 
        vecChar r;
        for( int b = 0; b < black; b++ ) r.push_back( 'X' );
        for( int w = 0; w < white; w++ ) r.push_back( 'O' );
        results.push_back( r );
 
        return ( black == codeLen );
    }
    std::string getCombo() {
        std::string c, clr = colors;
        int l, z;
 
        for( size_t s = 0; s < codeLen; s++ ) {
            z = rand() % ( int )clr.length();
            c.append( 1, clr[z] );
            if( !repeatClr ) clr.erase( z, 1 );
        }
        return c;
    }
 
    size_t codeLen, colorsCnt, guessCnt;
    bool repeatClr;
    std::vector<vecChar> guesses, results;
    std::string colors, combo;
};
 
int main( int argc, char* argv[] ) {
    srand( unsigned( time( 0 ) ) );
    master m( 4, 8, 12, false );
    m.play();
    return 0;
}
 "
" 
#include <ctime>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <string>
#include <vector>
#include <map>
class markov {
public:
    void create( std::string& file, int keyLen, int words ) {
        std::ifstream f( file.c_str(), std::ios_base::in );
        fileBuffer = std::string( ( std::istreambuf_iterator<char>( f ) ), std::istreambuf_iterator<char>() );
        f.close();
        if( fileBuffer.length() < 1 ) return;
        createDictionary( keyLen );
        createText( words - keyLen );
    }
private:
    void createText( int w ) {
        std::string key, first, second;
        size_t next, pos;
        std::map<std::string, std::vector<std::string> >::iterator it = dictionary.begin();
        std::advance( it, rand() % dictionary.size() );
        key = ( *it ).first;
        std::cout << key;
        while( true ) {
            std::vector<std::string> d = dictionary[key];
            if( d.size() < 1 ) break;
            second = d[rand() % d.size()];
            if( second.length() < 1 ) break;
            std::cout << strv << second;
            if( --w < 0 ) break;
            next = key.find_first_of( 32, 0 );
            first = key.substr( next + 1 );
            key = first + strv + second;
        }
        std::cout << """";
    }
    void createDictionary( int kl ) {
        std::string w1, key;
        size_t wc = 0, pos, textPos, next;
        next = fileBuffer.find_first_not_of( 32, 0 );
        if( next == -1 ) return;
        while( wc < kl ) {
            pos = fileBuffer.find_first_of( ' ', next );
            w1 = fileBuffer.substr( next, pos - next );
            key += w1 + strv;
            next = fileBuffer.find_first_not_of( 32, pos + 1 );
            if( next == -1 ) return;
            wc++;
        }
        key = key.substr( 0, key.size() - 1 );
        while( true ) {
            next = fileBuffer.find_first_not_of( 32, pos + 1 );
            if( next == -1 ) return;
            pos = fileBuffer.find_first_of( 32, next );
            w1 = fileBuffer.substr( next, pos - next );
            if( w1.size() < 1 ) break;
            if( std::find( dictionary[key].begin(), dictionary[key].end(), w1 ) == dictionary[key].end() ) 
                dictionary[key].push_back( w1 );
            key = key.substr( key.find_first_of( 32 ) + 1 ) + strv + w1;
        }
    }
    std::string fileBuffer;
    std::map<std::string, std::vector<std::string> > dictionary;
};
int main( int argc, char* argv[] ) {
    srand( unsigned( time( 0 ) ) );
    markov m;
    m.create( std::string( strv ), 3, 200 );
    return 0;
}
 "
"#include <iostream>
#include <blitz/tinymat.h>
 
int main()
{
  using namespace blitz;
 
  TinyMatrix<double,3,3> A, B, C;
 
  A = 1, 2, 3,
      4, 5, 6,
      7, 8, 9;
 
  B = 1, 0, 0,
      0, 1, 0,
      0, 0, 1;
 
  C = product(A, B);
 
  std::cout << C << std::endl;
} 
#include <iostream>
#include strv
 
#if !defined(ARRAY_SIZE)
    #define ARRAY_SIZE(x) (sizeof((x)) / sizeof((x)[0]))
#endif
 
int main() {
    int  am[2][3] = {
        {1,2,3},
        {4,5,6},
    };
    int  bm[3][2] = {
        {1,2},
        {3,4},
        {5,6}
    };
 
    Matrix<int> a(ARRAY_SIZE(am), ARRAY_SIZE(am[0]), am[0], ARRAY_SIZE(am)*ARRAY_SIZE(am[0]));
    Matrix<int> b(ARRAY_SIZE(bm), ARRAY_SIZE(bm[0]), bm[0], ARRAY_SIZE(bm)*ARRAY_SIZE(bm[0]));
    Matrix<int> c;
 
    try {
        c = a * b;
        for (unsigned int i = 0; i < c.rowNum(); i++) {
            for (unsigned int j = 0; j < c.colNum(); j++) {
                std::cout <<  c[i][j] << strv;
            }
            std::cout << std::endl;
        }
    } catch (MatrixException& e) {
        std::cerr << e.message() << std::endl;
        return e.errorCode();
    }
 
} /* main() */
  
#ifndef _MATRIX_H
#define	_MATRIX_H
 
#include <sstream>
#include <string>
#include <vector>
 
#define MATRIX_ERROR_CODE_COUNT 5
#define MATRIX_ERR_UNDEFINED strv
#define MATRIX_ERR_WRONG_ROW_INDEX strv
#define MATRIX_ERR_MUL_ROW_AND_COL_NOT_EQUAL strv
#define MATRIX_ERR_MUL_ROW_AND_COL_BE_GREATER_THAN_ZERO strv
#define MATRIX_ERR_TOO_FEW_DATA strv
 
class MatrixException {
private:
    std::string message_;
    int errorCode_;
public:
    MatrixException(std::string message = MATRIX_ERR_UNDEFINED);
 
    inline std::string message() {
        return message_;
    };
 
    inline int errorCode() {
        return errorCode_;
    };
};
 
MatrixException::MatrixException(std::string message) {
    errorCode_ = MATRIX_ERROR_CODE_COUNT + 1;
    std::stringstream ss(message);
    ss >> errorCode_;
    if (errorCode_ < 1) {
        errorCode_ = MATRIX_ERROR_CODE_COUNT + 1;
    }
    std::string::size_type pos = message.find(' ');
    if (errorCode_ <= MATRIX_ERROR_CODE_COUNT && pos != std::string::npos) {
        message_ = message.substr(pos + 1);
    } else {
        message_ = message + strv;
    }
}
 
/** * Generic class for matrices. */
template <class T>
class Matrix {
private:
    std::vector<T> v; 

    unsigned int m;   

    unsigned int n;   

protected:
 
    virtual void clear() {
        v.clear();
        m = n = 0;
    }
public:
 
    Matrix() {
        clear();
    }
    Matrix(unsigned int, unsigned int, T* = 0, unsigned int = 0);
    Matrix(unsigned int, unsigned int, const std::vector<T>&);
 
    virtual ~Matrix() {
        clear();
    }
    Matrix& operator=(const Matrix&);
    std::vector<T> operator[](unsigned int) const;
    Matrix operator*(const Matrix&);
 
    inline unsigned int rowNum() const {
        return m;
    }
 
    inline unsigned int colNum() const {
        return n;
    }
 
    inline unsigned int size() const {
        return v.size();
    }
 
    inline void add(const T& t) {
        v.push_back(t);
    }
};
 
template <class T>
Matrix<T>::Matrix(unsigned int row, unsigned int col, T* data, unsigned int dataLength) {
    clear();
    if (row > 0 && col > 0) {
        m = row;
        n = col;
        unsigned int mxn = m * n;
        if (dataLength && data) {
            for (unsigned int i = 0; i < dataLength && i < mxn; i++) {
                v.push_back(data[i]);
            }
        }
    }
}
 
template <class T>
Matrix<T>::Matrix(unsigned int row, unsigned int col, const std::vector<T>& data) {
    clear();
    if (row > 0 && col > 0) {
        m = row;
        n = col;
        unsigned int mxn = m * n;
        if (data.size() > 0) {
            for (unsigned int i = 0; i < mxn && i < data.size(); i++) {
                v.push_back(data[i]);
            }
        }
    }
}
 
template<class T>
Matrix<T>& Matrix<T>::operator=(const Matrix<T>& other) {
    clear();
    if (other.m > 0 && other.n > 0) {
        m = other.m;
        n = other.n;
        unsigned int mxn = m * n;
        for (unsigned int i = 0; i < mxn && i < other.size(); i++) {
            v.push_back(other.v[i]);
        }
    }
    return *this;
}
 
template<class T>
std::vector<T> Matrix<T>::operator[](unsigned int index) const {
    std::vector<T> result;
    if (index >= m) {
        throw MatrixException(MATRIX_ERR_WRONG_ROW_INDEX);
    } else if ((index + 1) * n > size()) {
        throw MatrixException(MATRIX_ERR_TOO_FEW_DATA);
    } else {
        unsigned int begin = index * n;
        unsigned int end = begin + n;
        for (unsigned int i = begin; i < end; i++) {
            result.push_back(v[i]);
        }
    }
    return result;
}
 
template<class T>
Matrix<T> Matrix<T>::operator*(const Matrix<T>& other) {
    Matrix result(m, other.n);
    if (n != other.m) {
        throw MatrixException(MATRIX_ERR_MUL_ROW_AND_COL_NOT_EQUAL);
    } else if (m <= 0 || n <= 0 || other.n <= 0) {
        throw MatrixException(MATRIX_ERR_MUL_ROW_AND_COL_BE_GREATER_THAN_ZERO);
    } else if (m * n > size() || other.m * other.n > other.size()) {
        throw MatrixException(MATRIX_ERR_TOO_FEW_DATA);
    } else {
        for (unsigned int i = 0; i < m; i++) {
            for (unsigned int j = 0; j < other.n; j++) {
                T temp = v[i * n] * other.v[j];
                for (unsigned int k = 1; k < n; k++) {
                    temp += v[i * n + k] * other.v[k * other.n + j];
                }
                result.v.push_back(temp);
            }
        }
    }
    return result;
}
 
#endif	/* _MATRIX_H */
 "
"#include <iostream>
#include <utility>
 
template<typename tVal>
tVal map_value(std::pair<tVal,tVal> a, std::pair<tVal, tVal> b, tVal inVal)
{
  tVal inValNorm = inVal - a.first;
  tVal aUpperNorm = a.second - a.first;
  tVal normPosition = inValNorm / aUpperNorm;
 
  tVal bUpperNorm = b.second - b.first;
  tVal bValNorm = normPosition * bUpperNorm;
  tVal outVal = b.first + bValNorm;
 
  return outVal;
}
 
int main()
{
  std::pair<float,float> a(0,10), b(-1,0);
 
  for(float value = 0.0; 10.0 >= value; ++value)
    std::cout << strv << value << strv << map_value(a, b, value) << std::endl;
 
  return 0;
}"
" 
#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int BMP_SIZE = 512, CELL_SIZE = 8;
 
//--------------------------------------------------------------------------------------------------
enum directions { NONE, NOR = 1, EAS = 2, SOU = 4, WES = 8 };
 
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO	bi;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize	   = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes	   = 1;
	bi.bmiHeader.biWidth	   =  w;
	bi.bmiHeader.biHeight	   = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc ); 
	width = w; height = h;
 
	return true;
    }
 
    void clear()
    {
	ZeroMemory( pBits, width * height * sizeof( DWORD ) );
    }
 
    void setPenColor( DWORD clr )
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, 1, clr );
	SelectObject( hdc, pen );
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO	 infoheader;
	BITMAP		 bitmap;
	DWORD		 wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
 
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    HBITMAP bmp;
    HDC	    hdc;
    HPEN    pen;
    void    *pBits;
    int	    width, height;
};
//--------------------------------------------------------------------------------------------------
class mazeGenerator
{
public:
    mazeGenerator()
    {
	_world = 0; 
	_bmp.create( BMP_SIZE, BMP_SIZE ); 
	_bmp.setPenColor( RGB( 0, 255, 0 ) ); 
    }
 
    ~mazeGenerator() { killArray(); }
 
    void create( int side )
    {
	_s = side;
	generate();
	display();
    }
 
private:
    void generate()
    {
	killArray();
	_world = new BYTE[_s * _s];
	ZeroMemory( _world, _s * _s );
	_ptX = rand() % _s; _ptY = rand() % _s;
	carve();
    }
 
    void carve()
    {
	while( true )
	{
	    int d = getDirection();
	    if( d < NOR ) return;
 
	    switch( d )
	    {
	        case NOR:
	            _world[_ptX + _s * _ptY] |= NOR; _ptY--;
		    _world[_ptX + _s * _ptY] = SOU | SOU << 4;
		break;
	        case EAS:
		    _world[_ptX + _s * _ptY] |= EAS; _ptX++;
		    _world[_ptX + _s * _ptY] = WES | WES << 4;
		break;
		case SOU:
		    _world[_ptX + _s * _ptY] |= SOU; _ptY++;
		    _world[_ptX + _s * _ptY] = NOR | NOR << 4;
		break;
		case WES:
		    _world[_ptX + _s * _ptY] |= WES; _ptX--;
		    _world[_ptX + _s * _ptY] = EAS | EAS << 4;
	    }
	}
    }
 
    void display()
    {
	_bmp.clear();
	HDC dc = _bmp.getDC();
	for( int y = 0; y < _s; y++ )
	{
	    int yy = y * _s;
	    for( int x = 0; x < _s; x++ )
	    {
		BYTE b = _world[x + yy];
		int nx = x * CELL_SIZE, 
		    ny = y * CELL_SIZE;
 
		if( !( b & NOR ) )
		{
		    MoveToEx( dc, nx, ny, NULL );
		    LineTo( dc, nx + CELL_SIZE + 1, ny );
		}
		if( !( b & EAS ) )
		{
		    MoveToEx( dc, nx + CELL_SIZE, ny, NULL );
		    LineTo( dc, nx + CELL_SIZE, ny + CELL_SIZE + 1 );
		}
		if( !( b & SOU ) )
		{
		    MoveToEx( dc, nx, ny + CELL_SIZE, NULL );
		    LineTo( dc, nx + CELL_SIZE + 1, ny + CELL_SIZE );
		}
		if( !( b & WES ) )
		{
		    MoveToEx( dc, nx, ny, NULL );
		    LineTo( dc, nx, ny + CELL_SIZE + 1 );
		}
	    }
	}
 
	//_bmp.saveBitmap( strv );
	BitBlt( GetDC( GetConsoleWindow() ), 10, 60, BMP_SIZE, BMP_SIZE, _bmp.getDC(), 0, 0, SRCCOPY );
    }
 
    int getDirection()
    {
	int d = 1 << rand() % 4;
	while( true )
	{
	    for( int x = 0; x < 4; x++ )
	    {
		if( testDir( d ) ) return d;
		d <<= 1;
		if( d > 8 ) d = 1;
	    }
	    d = ( _world[_ptX + _s * _ptY] & 0xf0 ) >> 4;
	    if( !d ) return -1;
	    switch( d )
	    {
		case NOR: _ptY--; break;
		case EAS: _ptX++; break;
		case SOU: _ptY++; break;
		case WES: _ptX--; break;
	    }
            d = 1 << rand() % 4;
	}
    }
 
    bool testDir( int d )
    {
	switch( d )
	{
	    case NOR: return ( _ptY - 1 > -1 && !_world[_ptX + _s * ( _ptY - 1 )] );
	    case EAS: return ( _ptX + 1 < _s && !_world[_ptX + 1 + _s * _ptY] );
	    case SOU: return ( _ptY + 1 < _s && !_world[_ptX + _s * ( _ptY + 1 )] );
	    case WES: return ( _ptX - 1 > -1 && !_world[_ptX - 1 + _s * _ptY] );
	}
	return false;
    }
 
    void killArray() { if( _world ) delete [] _world; }
 
    BYTE*    _world;
    int      _s, _ptX, _ptY;
    myBitmap _bmp;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );
    srand( GetTickCount() );
 
    mazeGenerator mg;
    int s;
    while( true )
    {
	cout << strv; cin >> s;
	if( !s ) return 0;
	if( !( s & 1 ) ) s++;
	if( s >= 3 ) mg.create( s );
	cout << endl;
	system( strv );
	system( strv );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <tr1/memory>
using std::tr1::shared_ptr;
using std::tr1::enable_shared_from_this;
 
struct Arg {
  virtual int run() = 0;
  virtual ~Arg() { };
};
 
int A(int, shared_ptr<Arg>, shared_ptr<Arg>, shared_ptr<Arg>,
      shared_ptr<Arg>, shared_ptr<Arg>);
 
class B : public Arg, public enable_shared_from_this<B> {
private:
  int k;
  const shared_ptr<Arg> x1, x2, x3, x4;
 
public:
  B(int _k, shared_ptr<Arg> _x1, shared_ptr<Arg> _x2, shared_ptr<Arg> _x3,
    shared_ptr<Arg> _x4)
    : k(_k), x1(_x1), x2(_x2), x3(_x3), x4(_x4) { }
  int run() {
    return A(--k, shared_from_this(), x1, x2, x3, x4);
  }
};
 
class Const : public Arg {
private:
  const int x;
public:
  Const(int _x) : x(_x) { }
  int run () { return x; }
};
 
int A(int k, shared_ptr<Arg> x1, shared_ptr<Arg> x2, shared_ptr<Arg> x3,
      shared_ptr<Arg> x4, shared_ptr<Arg> x5) {
  if (k <= 0)
    return x4->run() + x5->run();
  else {
    shared_ptr<Arg> b(new B(k, x1, x2, x3, x4));
    return b->run();
  }
}
 
int main() {
  std::cout << A(10, shared_ptr<Arg>(new Const(1)),
                 shared_ptr<Arg>(new Const(-1)),
                 shared_ptr<Arg>(new Const(-1)),
                 shared_ptr<Arg>(new Const(1)),
                 shared_ptr<Arg>(new Const(0))) << std::endl;
  return 0;
}#include <functional>
#include <iostream>
 
typedef std::function<int()> F;
 
static int A(int k, const F &x1, const F &x2, const F &x3, const F &x4, const F &x5)
{
	F B = [=, &k, &B]
	{
		return A(--k, B, x1, x2, x3, x4);
	};
 
	return k <= 0 ? x4() + x5() : B();
}
 
static F L(int n)
{
	return [n] { return n; };
}
 
int main()
{
	std::cout << A(10, L(1), L(-1), L(-1), L(1), L(0)) << std::endl;
	return 0;
}#include <tr1/functional>
#include <iostream>
 
typedef std::tr1::function<int()> F;
 
static int A(int k, const F &x1, const F &x2, const F &x3, const F &x4, const F &x5);
 
struct B_class {
  int &k;
  const F x1, x2, x3, x4;
  B_class(int &_k, const F &_x1, const F &_x2, const F &_x3, const F &_x4) :
    k(_k), x1(_x1), x2(_x2), x3(_x3), x4(_x4) { }
  int operator()() const { return A(--k, *this, x1, x2, x3, x4); }
};
 
static int A(int k, const F &x1, const F &x2, const F &x3, const F &x4, const F &x5)
{
  F B = B_class(k, x1, x2, x3, x4);
  return k <= 0 ? x4() + x5() : B();
}
 
struct L {
  const int n;
  L(int _n) : n(_n) { }
  int operator()() const { return n; }
};
 
int main()
{
  std::cout << A(10, L(1), L(-1), L(-1), L(1), L(0)) << std::endl;
  return 0;
}"
"UINT_64 TGost::SWAP32(UINT_32 N1, UINT_32 N2)
{
    UINT_64 N;
	N = N1;
	N = (N<<32)|N2;
	return UINT_64(N);
}
 
UINT_32 TGost::ReplaceBlock(UINT_32 x)
{   
    register i;
    UINT_32 res = 0UL;
    for(i=7;i>=0;i--)
    {
       ui4_0 = x>>(i*4);
       ui4_0 = BS[ui4_0][i];
       res = (res<<4)|ui4_0;
    }
    return res;
}
 
UINT_64 TGost::MainStep(UINT_64 N,UINT_32 X)
{
   UINT_32 N1,N2,S=0UL;
   N1=UINT_32(N);
   N2=N>>32;
   S = N1 + X % 0x4000000000000;
   S = ReplaceBlock(S);
   S = (S<<11)|(S>>21);
   S ^= N2;
   N2 = N1;
   N1 = S;
   return SWAP32(N2,N1);
}"
"#include <cstdlib>
#include <complex>
 


template<typename ElementType, std::size_t dim1, std::size_t dim2>
 std::size_t get_first_dimension(ElementType (&a)[dim1][dim2])
{
  return dim1;
}
 
template<typename ElementType, std::size_t dim1, std::size_t dim2>
 std::size_t get_second_dimension(ElementType (&a)[dim1][dim2])
{
  return dim2;
}
 
 
template<typename ColorType, typename ImageType>
 void draw_Mandelbrot(ImageType& image,                                   //where to draw the image
                      ColorType set_color, ColorType non_set_color,       //which colors to use for set/non-set points
                      double cxmin, double cxmax, double cymin, double cymax,//the rect to draw in the complex plane
                      unsigned int max_iterations)                          //the maximum number of iterations
{
  std::size_t const ixsize = get_first_dimension(image);
  std::size_t const iysize = get_first_dimension(image);
  for (std::size_t ix = 0; ix < ixsize; ++ix)
    for (std::size_t iy = 0; iy < iysize; ++iy)
    {
      std::complex<double> c(cxmin + ix/(ixsize-1.0)*(cxmax-cxmin), cymin + iy/(iysize-1.0)*(cymax-cymin));
      std::complex<double> z = 0;
      unsigned int iterations;
 
      for (iterations = 0; iterations < max_iterations && std::abs(z) < 2.0; ++iterations) 
        z = z*z + c;
 
      image[ix][iy] = (iterations == max_iterations) ? set_color : non_set_color;
 
    }
}"
" 
#include <iostream>
#include <sstream>
#include <iomanip>
using namespace std;
 
class magicSqr
{
public: 
    magicSqr() { sqr = 0; }
    ~magicSqr() { if( sqr ) delete [] sqr; }
 
    void create( int d )
    {
        if( sqr ) delete [] sqr;
        if( !( d & 1 ) ) d++; sz = d;
        sqr = new int[sz * sz];
        memset( sqr, 0, sz * sz * sizeof( int ) );
        fillSqr();
    }
 
    void display()
    {
        cout << strv << sz << strv << sz << """";
        cout << strv << magicNumber() << """";
        ostringstream cvr; cvr << sz * sz;
        int l = cvr.str().size();
 
	for( int y = 0; y < sz; y++ )
	{
	    int yy = y * sz;
	    for( int x = 0; x < sz; x++ )
		cout << setw( l + 2 ) << sqr[yy + x];
 
	    cout << """";
	}
        cout << """";
    }
 
private:
    void fillSqr()
    {
	int sx = sz / 2, sy = 0, c = 0;
	while( c < sz * sz )
	{
	    if( !sqr[sx + sy * sz] )
	    {
		sqr[sx + sy * sz]= c + 1;
		inc( sx ); dec( sy ); 
		c++;
	    }
	    else
	    {
		dec( sx ); inc( sy ); inc( sy );
	    }
	}
    }
 
    int magicNumber()
    { return sz * ( ( sz * sz ) + 1 ) / 2; }
 
    void inc( int& a )
    { if( ++a == sz ) a = 0; }
 
    void dec( int& a )
    { if( --a < 0 ) a = sz - 1; }
 
    bool checkPos( int x, int y )
    { return( isInside( x ) && isInside( y ) && !sqr[sz * y + x] ); }
 
    bool isInside( int s )
    { return ( s < sz && s > -1 ); }
 
    int* sqr;
    int sz;
};
 
int main( int argc, char* argv[] )
{
    magicSqr s;
    s.create( 5 );
    s.display();
    return 0;
}
 "
" 
#include <iostream>
#include <sstream>
#include <iomanip>
using namespace std;
 
class magicSqr
{
public: 
    magicSqr() { sqr = 0; }
    ~magicSqr() { if( sqr ) delete [] sqr; }
 
    void create( int d ) {
        if( sqr ) delete [] sqr;
        if( d & 1 ) d++;
        while( d % 4 == 0 ) { d += 2; }
        sz = d;
        sqr = new int[sz * sz];
        memset( sqr, 0, sz * sz * sizeof( int ) );
        fillSqr();
    }
    void display() {
        cout << strv << sz << strv << sz << """";
        cout << strv << magicNumber() << """";
        ostringstream cvr; cvr << sz * sz;
        int l = cvr.str().size();
 
        for( int y = 0; y < sz; y++ ) {
            int yy = y * sz;
            for( int x = 0; x < sz; x++ ) {
                cout << setw( l + 2 ) << sqr[yy + x];
            }
            cout << """";
        }
        cout << """";
    }
private:
    void siamese( int from, int to ) {
        int oneSide = to - from, curCol = oneSide / 2, curRow = 0, count = oneSide * oneSide, s = 1;
 
        while( count > 0 ) {
            bool done = false;
            while ( false == done ) {
                if( curCol >= oneSide ) curCol = 0;
                if( curRow < 0 ) curRow = oneSide - 1;
                done = true;
                if( sqr[curCol + sz * curRow] != 0 ) {
                    curCol -= 1; curRow += 2;
                    if( curCol < 0 ) curCol = oneSide - 1;
                    if( curRow >= oneSide ) curRow -= oneSide;
 
                    done = false;
                }
            }
            sqr[curCol + sz * curRow] = s;
            s++; count--; curCol++; curRow--;
        }
    }
    void fillSqr() {
        int n = sz / 2, ns = n * sz, size = sz * sz, add1 = size / 2, add3 = size / 4, add2 = 3 * add3;
 
        siamese( 0, n );
 
        for( int r = 0; r < n; r++ ) {
            int row = r * sz;
            for( int c = n; c < sz; c++ ) {
                int m = sqr[c - n + row];
 
                sqr[c + row] = m + add1;
                sqr[c + row + ns] = m + add3;
                sqr[c - n + row + ns] = m + add2;
            }
        }
 
        int lc = ( sz - 2 ) / 4, co = sz - ( lc - 1 ); 
        for( int r = 0; r < n; r++ ) {
            int row = r * sz;    
            for( int c = co; c < sz; c++ ) {    
                sqr[c + row] -= add3;
                sqr[c + row + ns] += add3;
            }
        }
        for( int r = 0; r < n; r++ ) {
            int row = r * sz;    
            for( int c = 0; c < lc; c++ ) {
                int cc = c;
                if( r == lc ) cc++;
                sqr[cc + row] += add2;
                sqr[cc + row + ns] -= add2;
            }
        }
    }
    int magicNumber() { return sz * ( ( sz * sz ) + 1 ) / 2; }
 
    void inc( int& a ) { if( ++a == sz ) a = 0; }
 
    void dec( int& a ) { if( --a < 0 ) a = sz - 1; }
 
    bool checkPos( int x, int y ) { return( isInside( x ) && isInside( y ) && !sqr[sz * y + x] ); }
 
    bool isInside( int s ) { return ( s < sz && s > -1 ); }
 
    int* sqr;
    int sz;
};
int main( int argc, char* argv[] ) {
    magicSqr s; s.create( 6 );
    s.display();
    return 0;
}
 "
"#include <iostream>
#include <sstream>
#include <iomanip>
using namespace std;
 
class magicSqr
{
public: 
    magicSqr( int d ) {
        while( d % 4 > 0 ) { d++; }
        sz = d;
        sqr = new int[sz * sz];
        fillSqr();
    }
    ~magicSqr() { delete [] sqr; }
 
    void display() const {
        cout << strv << sz << strv << sz << """";
        cout << strv << magicNumber() << """";
        ostringstream cvr; cvr << sz * sz;
        int l = cvr.str().size();
 
        for( int y = 0; y < sz; y++ ) {
            int yy = y * sz;
            for( int x = 0; x < sz; x++ ) {
                cout << setw( l + 2 ) << sqr[yy + x];
            }
            cout << """";
        }
        cout << """";
    }
private:
    void fillSqr() {
        static const bool tempAll[4][4] = {{ 1, 0, 0, 1 }, { 0, 1, 1, 0 }, { 0, 1, 1, 0 }, { 1, 0, 0, 1 } };
        int i = 0;
        for( int curRow = 0; curRow < sz; curRow++ ) {
            for( int curCol = 0; curCol < sz; curCol++ ) {
                sqr[curCol + sz * curRow] = tempAll[curRow % 4][curCol % 4] ? i + 1 : sz * sz - i;
                i++;
            }
        }
    }
    int magicNumber() const { return sz * ( ( sz * sz ) + 1 ) / 2; }
 
    int* sqr;
    int sz;
};
 
int main( int argc, char* argv[] ) {
    magicSqr s( 8 );
    s.display();
    return 0;
}"
"#include <iostream>
#include <string>
using namespace std;
 
int main()
{
  string story, input;
 
  //Loop
  while(true)
  {
    //Get a line from the user
    getline(cin, input);
 
    //If it's blank, break this loop
    if(input == """")
      break;
 
    //Add the line to the story
    story += input;
  }
 
  //While there is a '<' in the story
  int begin;
  while((begin = story.find(strv)) != string::npos)
  {
    //Get the category from between '<' and '>'
    int end = story.find(strv);
    string cat = story.substr(begin + 1, end - begin - 1);
 
    //Ask the user for a replacement
    cout << strv << cat << strv;
    cin >> input;
 
    //While there's a matching category 
    //in the story
    while((begin = story.find(strv + cat + strv)) != string::npos)
    {
      //Replace it with the user's replacement
      story.replace(begin, cat.length()+2, input);
    }
  }
 
  //Output the final story
  cout << endl << story;
 
  return 0;
}"
"#include <string>
#include <map>
 






template <typename Iterator>
Iterator compress(const std::string &uncompressed, Iterator result) {
  

  int dictSize = 256;
  std::map<std::string,int> dictionary;
  for (int i = 0; i < 256; i++)
    dictionary[std::string(1, i)] = i;
 
  std::string w;
  for (std::string::const_iterator it = uncompressed.begin();
       it != uncompressed.end(); ++it) {
    char c = *it;
    std::string wc = w + c;
    if (dictionary.count(wc))
      w = wc;
    else {
      *result++ = dictionary[w];
      

      dictionary[wc] = dictSize++;
      w = std::string(1, c);
    }
  }
 
  

  if (!w.empty())
    *result++ = dictionary[w];
  return result;
}
 




template <typename Iterator>
std::string decompress(Iterator begin, Iterator end) {
  

  int dictSize = 256;
  std::map<int,std::string> dictionary;
  for (int i = 0; i < 256; i++)
    dictionary[i] = std::string(1, i);
 
  std::string w(1, *begin++);
  std::string result = w;
  std::string entry;
  for ( ; begin != end; begin++) {
    int k = *begin;
    if (dictionary.count(k))
      entry = dictionary[k];
    else if (k == dictSize)
      entry = w + w[0];
    else
      throw strv;
 
    result += entry;
 
    

    dictionary[dictSize++] = w + entry[0];
 
    w = entry;
  }
  return result;
}
 
#include <iostream>
#include <iterator>
#include <vector>
 
int main() {
  std::vector<int> compressed;
  compress(strv, std::back_inserter(compressed));
  copy(compressed.begin(), compressed.end(), std::ostream_iterator<int>(std::cout, strv));
  std::cout << std::endl;
  std::string decompressed = decompress(compressed.begin(), compressed.end());
  std::cout << decompressed << std::endl;
 
  return 0;
}"
"#include <iostream>
using namespace std;
 
int toInt(const char c)
{
    return c-'0';
}
 
int confirm( const char *id)
{
    bool is_odd_dgt = true;
    int s = 0;
    const char *cp;
 
    for(cp=id; *cp; cp++);
    while(cp > id) {
        --cp;
        int k = toInt(*cp);
        if (is_odd_dgt) {
            s += k;
        }
        else {
            s += (k!=9)? (2*k)%9 : 9;
        }
	is_odd_dgt = !is_odd_dgt;
    }
    return 0 == s%10;
}
 
int main( )
{
    const char * t_cases[] = {
        strv,
        strv,
        strv,
        strv,
        NULL,
    };
    for ( const char **cp = t_cases; *cp; cp++) {
        cout << *cp << strv << confirm(*cp) << endl;
    }
    return 0;
}#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
 
bool luhn( const string& id)
{
  static const int m[10]  = {0,2,4,6,8,1,3,5,7,9}; 

  bool is_odd_dgt = false;
  auto lambda = [&](int a, char c) {return a + ((is_odd_dgt = !is_odd_dgt) ? c-'0' : m[c-'0']);};
  int s = std::accumulate(id.rbegin(), id.rend(), 0, lambda);
  return 0 == s%10;
}
 
int main( )
{
  auto t_cases = {strv, strv, strv, strv};
  auto print = [](const string & s) {cout << s << strv << luhn(s) << endl;};
  for_each(t_cases.begin(), t_cases.end(), print);
  return 0;
}
 #include <iostream>
#include <type_traits>
 
template<size_t I, int... Args>
struct find_impl;
 
template<int A, int... Args>
struct find_impl<0, A, Args...> {
    using type = std::integral_constant<int, A>;
};
 
template<int A, int B, int... Args>
struct find_impl<0, A, B, Args...> {
    using type = std::integral_constant<int, A>;
};
 
template<size_t I, int A, int B, int... Args>
struct find_impl<I, A, B, Args...> {
    using type = typename find_impl<I-1, B, Args...>::type;
};
 
namespace detail {
template<typename, typename>
struct append_sequence
{};
 
template<typename T, typename... Ts>
struct append_sequence<T, std::tuple<Ts...>> {
    using type = std::tuple<Ts..., T>;
};
 
template<typename... Ts>
struct reverse_sequence {
    using type = std::tuple<>;
};
 
template<typename T, typename... Ts>
struct reverse_sequence<T, Ts...> {
    using type = typename append_sequence<
                            T,
                            typename reverse_sequence<Ts...>::type
                        >::type;
};
}
 
template<size_t I>
using rule3 = typename find_impl<I, 0, 2, 4, 6, 8, 1, 3, 5, 7, 9>::type;
 
template<int A, char C, bool dgt>
struct calc
    : std::integral_constant<int, A + C - '0'>
{};
 
template<int A, char C>
struct calc<A, C, false>
    : std::integral_constant<int, A + rule3<C - '0'>::type::value>
{};
 
template<typename Acc, bool Dgt, char...>
struct luhn_impl;
 
template<typename Acc, bool Dgt, char A, char... Args>
struct luhn_impl<Acc, Dgt, A, Args...> {
    using type = typename calc<Acc::value, A, Dgt>::type;
};
 
template<typename Acc, bool Dgt, char A, char B, char... Args>
struct luhn_impl<Acc, Dgt, A, B, Args...> {
    using type =
        typename luhn_impl<typename calc<Acc::value, A, Dgt>::type, !Dgt, B, Args...>::type;
};
 
template<typename>
struct luhn;
 
template<typename... Args>
struct luhn<std::tuple<Args...>> {
    using type = typename luhn_impl<std::integral_constant<int, 0>, true, Args::value...>::type;
    constexpr static bool result = (type::value % 10) == 0;
};
 
template<char... Args>
bool operator strv _luhn() {
    return luhn<typename detail::reverse_sequence<std::integral_constant<char, Args>...>::type>::result;
}
 
int main() {
    std::cout << std::boolalpha;
    std::cout << 49927398716_luhn << std::endl;
    std::cout << 49927398717_luhn << std::endl;
    std::cout << 1234567812345678_luhn << std::endl;
    std::cout << 1234567812345670_luhn << std::endl;
    return 0;
}
 "
"#include <iostream>
#include <gmpxx.h>
 
static bool is_mersenne_prime(mpz_class p)
{
        if( 2 == p )
                return true;
        else
        {
                mpz_class s(4);
                mpz_class div( (mpz_class(1) << p.get_ui()) - 1 );
                for( mpz_class i(3);  i <= p;  ++i )
                {
                        s =  (s * s - mpz_class(2)) % div ;
                }
 
                return ( s == mpz_class(0) );
        }
}
 
int main()
{
        mpz_class maxcount(45);
        mpz_class found(0);
        mpz_class check(0);
        for( mpz_nextprime(check.get_mpz_t(), check.get_mpz_t());
             found < maxcount;
             mpz_nextprime(check.get_mpz_t(), check.get_mpz_t()))
        {
                //std::cout << strv << std::flush;
                if( is_mersenne_prime(check) )
                {
                        ++found;
                        std::cout << strv << check << strv << std::flush;
                }
        }
}"
" 
#include <vector>
#include <iostream>
using namespace std;
 
class ludic
{
public:
    void ludicList()
    {
        _list.push_back( 1 );
 
        vector<int> v;
        for( int x = 2; x < 22000; x++ )
            v.push_back( x );
 
        while( true )
        {
            vector<int>::iterator i = v.begin();
            int z = *i;
            _list.push_back( z );
 
            while( true )
            {
                i = v.erase( i );
                if( distance( i, v.end() ) <= z - 1 ) break;
                advance( i, z - 1 );
            }
            if( v.size() < 1 ) return;
        }
    }
 
    void show( int s, int e )
    {
        for( int x = s; x < e; x++ )
            cout << _list[x] << strv;
    }
 
    void findTriplets( int e )
    {
        int lu, x = 0;
        while( _list[x] < e )
        {
            lu = _list[x];
            if( inList( lu + 2 ) && inList( lu + 6 ) )
                cout << strv << lu << strv << lu + 2 << strv << lu + 6 << "")"";
            x++;
        }
    }
 
    int count( int e )
    {
        int x = 0, c = 0;
        while( _list[x++] <= 1000 ) c++;
        return c;
    }
 
private:
    bool inList( int lu )
    {
        for( int x = 0; x < 250; x++ )
            if( _list[x] == lu ) return true;
        return false;
    }
 
    vector<int> _list;
};
 
int main( int argc, char* argv[] )
{
    ludic l;
    l.ludicList();
    cout << strv << """";
    l.show( 0, 25 );
    cout << ""There are "" << l.count( 1000 ) << strv << """";
    cout << ""2000 to 2005'th ludic numbers:"" << """";
    l.show( 1999, 2005 );
    cout << ""all triplets of ludic numbers < 250:"" << """";
    l.findTriplets( 250 );
    cout << """";
    return system( strv );
}
 "
"int i = 1024;
while(i > 0) {
  std::cout << i << std::endl;
  i /= 2;
}for (int i = 1024; i>0; i /= 2)
  std::cout << i << std::endl;for (init; cond; update)
  statement;{
  init;
  while (cond)
  {
    statement;
    update;
  }
}"
"#include <iostream>
 
int main()
{ 
  int i;
  for (i = 1; i<10 ; i++)
    std::cout << i << strv;
  std::cout<<i;
  return 0;
}"
"while (true)
  std::cout << strv << std::endl;for (;;)
  std::cout << strv << std::endl;do
  std::cout << strv << std::endl;
while (true);"
"#include<cstdlib>
#include<ctime>
#include<iostream>
 
using namespace std;
int main()
{
    int arr[10][10];
    srand(time(NULL));
    for(auto& row: arr)
        for(auto& col: row)
            col = rand() % 20 + 1;
 
    ([&](){
       for(auto& row : arr)
           for(auto& col: row)
           {
               cout << col << endl;
               if(col == 20)return;
           }
    })();
    return 0;
}#include<cstdlib>
#include<ctime>
#include<iostream>
 
using namespace std;
int main()
{
    int arr[10][10];
    srand(time(NULL));
    for(auto& row: arr)
        for(auto& col: row)
            col = rand() % 20 + 1;
 
    for(auto& row : arr) {
        for(auto& col: row) {
            cout << ' ' << col;
            if (col == 20) goto out;
        }
        cout << endl;
    }
    out:
 
    return 0;
}"
"for (container_type::iterator i = container.begin(); i != container.end(); ++i)
{
  std::cout << *i << """";
}std::copy(container.begin(), container.end(),
          std::ostream_iterator<container_type::value_type>(std::cout, """"));void print_element(container_type::value_type const& v)
{
  std::cout << v << """";
}
 
...
  std::for_each(container.begin(), container.end(), print_element);for (auto element: container)
{
  std::cout << element << """";
}for (auto const& element: container)
{
  std::cout << element << """";
}for (auto&& element: container) //use a 'universal reference'
{
  element += 42;
}"
"for (int i = 1; i < 10; i += 2)
  std::cout << i << std::endl;"
"for(int i = 10; i >= 0; --i)
  std::cout << i << """";"
"int val = 0;
do{
   val++;
   std::cout << val << std::endl;
}while(val % 6 != 0);"
"for(int i = 1; i <= 5; ++i) {
  for(int j = 1; j <= i; j++)
    std::cout << strv;
  std::cout << std::endl;
}"
"for(int i = 1;i <= 10; i++){
   cout << i;
   if(i % 5 == 0){
      cout << endl;
      continue;
   }
   cout << strv;
}"
"#include <iostream>
#include <ctime>
#include <cstdlib>
 
int main()
{
    srand(time(0));
    while(true)
    {
    	int a = 0 + rand() % 19;
    	std::cout << a << std::endl;
    	if (a == 10)
    		break;
    	int b = 0 + rand() % 19;
    	std::cout << b << std::endl;
    }
    return 0;
}"
"#include <iostream>
#include <vector>
 
int main(int argc, char* argv[])
{
   std::vector<char> ls(3); ls[0] = 'a'; ls[1] = 'b'; ls[2] = 'c';
   std::vector<char> us(3); us[0] = 'A'; us[1] = 'B'; us[2] = 'C';
   std::vector<int> ns(3);  ns[0] = 1;   ns[1] = 2;   ns[2] = 3;
 
   std::vector<char>::const_iterator lIt = ls.begin();
   std::vector<char>::const_iterator uIt = us.begin();
   std::vector<int>::const_iterator nIt = ns.begin();
   for(; lIt != ls.end() && uIt != us.end() && nIt != 
ns.end();
       ++lIt, ++uIt, ++nIt)
   {
      std::cout << *lIt << *uIt << *nIt << """";
   }
}#include <iostream>
 
int main(int argc, char* argv[])
{
   char ls[] = {'a', 'b', 'c'};
   char us[] = {'A', 'B', 'C'};
   int ns[] = {1, 2, 3};
 
   for(size_t li = 0, ui = 0, ni = 0;
       li < sizeof(ls) && ui < sizeof(us) && ni 
< sizeof(ns) / sizeof(int);
       ++li, ++ui, ++ni)
   {
      std::cout << ls[li] << us[ui] << ns[ni] <<
 """";
   }
}#include <iostream>
#include <vector>
 
int main(int argc, char* argv[])
{
    auto lowers = std::vector<char>({'a', 'b', 'c'});
    auto uppers = std::vector<char>({'A', 'B', 'C'});
    auto nums = std::vector<int>({1, 2, 3});
 
    auto ilow = lowers.cbegin();
    auto iup = uppers.cbegin();
    auto inum = nums.cbegin();
 
    for(; ilow != lowers.end() 
        and iup != uppers.end() 
        and inum != nums.end()
        ; ++ilow, ++iup, ++inum)
    {
       std::cout << *ilow << *iup << *inum << """";
    }
}#include <iostream>
#include <iterator>
 
int main(int argc, char* argv[])
{
    char lowers[] = {'a', 'b', 'c'};
    char uppers[] = {'A', 'B', 'C'};
    int nums[] = {1, 2, 3};
 
    auto ilow = std::begin(lowers);
    auto iup = std::begin(uppers);
    auto inum = std::begin(nums);
 
    for(; ilow != std::end(lowers)
        and iup != std::end(uppers)
        and inum != std::end(nums)
        ; ++ilow, ++iup, ++inum )
    {
       std::cout << *ilow << *iup << *inum << """";
    }
}#include <iostream>
#include <array>
 
int main(int argc, char* argv[])
{
    auto lowers = std::array<char, 3>({'a', 'b', 'c'});
    auto uppers = std::array<char, 3>({'A', 'B', 'C'});
    auto nums = std::array<int, 3>({1, 2, 3});
 
    auto ilow = lowers.cbegin();
    auto iup = uppers.cbegin();
    auto inum = nums.cbegin();
 
    for(; ilow != lowers.end()
        and iup != uppers.end()
        and inum != nums.end()
        ; ++ilow, ++iup, ++inum )
    {
       std::cout << *ilow << *iup << *inum << """";
    }
}#include <iostream>
#include <array>
#include <algorithm>
 
int main(int argc, char* argv[])
{
    auto lowers = std::array<char, 3>({'a', 'b', 'c'});
    auto uppers = std::array<char, 3>({'A', 'B', 'C'});
    auto nums = std::array<int, 3>({1, 2, 3});
 
    auto const minsize = std::min(
                lowers.size(),
                std::min(
                    uppers.size(), 
                    nums.size()
                    )
                );
 
    for(size_t i = 0; i < minsize; ++i)
    {
       std::cout << lowers[i] << uppers[i] << nums[i] << """";
    }
}"
"#include <string>
#include <sstream>
 
std::string lookandsay(const std::string &s)
{
  std::ostringstream r;
 
  for (unsigned int i = 0; i != s.length(); ) {
    unsigned int new_i = s.find_first_not_of(s[i], i+1);
    if (new_i == std::string::npos)
      new_i = s.length();
 
    r << new_i - i << s[i];
    i = new_i;
  }
  return r.str();
}
 
#include <iostream>
 
int main()
{
  std::string laf = strv;
 
  std::cout << laf << std::endl;
  for (int i = 0; i < 10; i++) {
    laf = lookandsay(laf);
    std::cout << laf << std::endl;
  }
 
  return 0;
}"
"#include <iostream>
#include <vector>
#include <tr1/memory>
#include <algorithm>
#include <iterator>
 
template <typename E>
struct Node {
  E value;
  std::tr1::shared_ptr<Node<E> > pointer;
};
 
template <class E>
struct node_ptr_less {
  bool operator()(const std::tr1::shared_ptr<Node<E> > &node1,
		  const std::tr1::shared_ptr<Node<E> > &node2) const {
    return node1->value < node2->value;
  }
};
 
 
template <typename E>
std::vector<E> lis(const std::vector<E> &n) {
  typedef std::tr1::shared_ptr<Node<E> > NodePtr;
 
  std::vector<NodePtr> pileTops;
  

  for (typename std::vector<E>::const_iterator it = n.begin(); it != n.end(); it++) {
    NodePtr node(new Node<E>());
    node->value = *it;
    typename std::vector<NodePtr>::iterator j =
      std::lower_bound(pileTops.begin(), pileTops.end(), node, node_ptr_less<E>());
    if (j != pileTops.begin())
      node->pointer = *(j-1);
    if (j != pileTops.end())
      *j = node;
    else
      pileTops.push_back(node);
  }
  

  std::vector<E> result;
  for (NodePtr node = pileTops.back(); node != NULL; node = node->pointer)
    result.push_back(node->value);
  std::reverse(result.begin(), result.end());
  return result;
}
 
int main() {
  int arr1[] = {3,2,6,4,5,1};
  std::vector<int> vec1(arr1, arr1 + sizeof(arr1)/sizeof(*arr1));
  std::vector<int> result1 = lis(vec1);
  std::copy(result1.begin(), result1.end(), std::ostream_iterator<int>(std::cout, strv));
  std::cout << std::endl;
 
  int arr2[] = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};
  std::vector<int> vec2(arr2, arr2 + sizeof(arr2)/sizeof(*arr2));
  std::vector<int> result2 = lis(vec2);
  std::copy(result2.begin(), result2.end(), std::ostream_iterator<int>(std::cout, strv));
  std::cout << std::endl;
  return 0;
}"
"#include <string>
#include <algorithm>
#include <iostream>
#include <set>
#include <vector>
 
void findSubstrings ( const std::string & word , std::set<std::string> & substrings ) {
   int l = word.length( ) ;
   for ( int start = 0 ; start < l ; start++ ) {
      for ( int length = 1 ; length < l - start + 1 ; length++ ) {
	 substrings.insert ( word.substr( start , length ) ) ;
      }
   }
}
 
std::string lcs ( const std::string & first , const std::string & second ) {
   std::set<std::string> firstSubstrings , secondSubstrings ;
   findSubstrings ( first , firstSubstrings ) ;
   findSubstrings ( second , secondSubstrings ) ;
   std::set<std::string> common ;
   std::set_intersection ( firstSubstrings.begin( ) , firstSubstrings.end( ) , 
	 secondSubstrings.begin( ) , secondSubstrings.end( ) ,
	 std::inserter ( common , common.begin( ) ) ) ;
   std::vector<std::string> commonSubs ( common.begin( ) , common.end( ) ) ;
   std::sort ( commonSubs.begin( ) , commonSubs.end( ) , []( const std::string &s1 , 
	    const std::string &s2 ) { return s1.length( ) > s2.length( ) ; } ) ;
   return *(commonSubs.begin( ) ) ;
}
 
int main( ) {
   std::string s1 (strv ) ;
   std::string s2 ( strv ) ;
   std::cout << strv << s1 << strv << s2 << "" is:"" ;
   std::cout << lcs ( s1 , s2 ) << "" !"" ;
   return 0 ;
}"
"#include <stdint.h>
#include <string>
#include <memory>                       // for shared_ptr<>
#include <iostream>
#include <deque>
#include <map>
#include <algorithm>                    // for lower_bound()
#include <iterator>                     // for prev()
 
using namespace std;
 
class LCS {
protected:
  

  class Pair {
  public:
    uint32_t index1;
    uint32_t index2;
    shared_ptr<Pair> next;
 
    Pair(uint32_t index1, uint32_t index2, shared_ptr<Pair> next = nullptr)
      : index1(index1), index2(index2), next(next) {
    }
 
    static shared_ptr<Pair> Reverse(const shared_ptr<Pair> pairs) {
      shared_ptr<Pair> head = nullptr;
      for (auto next = pairs; next != nullptr; next = next->next)
        head = make_shared<Pair>(next->index1, next->index2, head);
      return head;
    }
  };
 
  typedef deque<shared_ptr<Pair>> PAIRS;
  typedef deque<uint32_t> THRESHOLD;
  typedef deque<uint32_t> INDEXES;
  typedef map<char, INDEXES> CHAR2INDEXES;
  typedef deque<INDEXES*> MATCHES;
 
  

  uint64_t Pairs(MATCHES& matches, shared_ptr<Pair> *pairs) {
    auto trace = pairs != nullptr;
    PAIRS traces;
    THRESHOLD threshold;
 
    //
    //[Assert]After each index1 iteration threshold[index3] is the least index2
    

    //
    uint32_t index1 = 0;
    for (const auto& it1 : matches) {
      if (!it1->empty()) {
        auto dq2 = *it1;
        auto limit = threshold.end();
        for (auto it2 = dq2.begin(); it2 != dq2.end(); it2++) {
          

          auto index2 = *it2;
 
	  //
          

          

          

          //
          limit = lower_bound(threshold.begin(), limit, index2);
          auto index3 = distance(threshold.begin(), limit);
 
          //
          

          

          

          

          //
          

          

          //
          auto skip = it2 + 1 != dq2.end() &&
            (limit == threshold.begin() || *(limit - 1) < *(it2 + 1));
 
          if (skip) continue;
 
          if (limit == threshold.end()) {
            

            threshold.push_back(index2);
            limit = prev(threshold.end());
            if (trace) {
              auto prefix = index3 > 0 ? traces[index3 - 1] : nullptr;
              auto last = make_shared<Pair>(index1, index2, prefix);
              traces.push_back(last);
            }
          }
          else if (index2 < *limit) {
            

            *limit = index2;
            if (trace) {
              auto prefix = index3 > 0 ? traces[index3 - 1] : nullptr;
              auto last = make_shared<Pair>(index1, index2, prefix);
              traces[index3] = last;
            }
          }
        }                                 

      }
 
      index1++;
    }                                     

 
    if (trace) {
      auto last = traces.size() > 0 ? traces.back() : nullptr;
      

      *pairs = Pair::Reverse(last);
    }
 
    auto length = threshold.size();
    return length;
  }
 
  //
  

  

  

  //
  

  

  

  //
  void Match(CHAR2INDEXES& indexes, MATCHES& matches,
    const string& s1, const string& s2) {
    uint32_t index = 0;
    for (const auto& it : s2)
      indexes[it].push_front(index++);
 
    for (const auto& it : s1) {
      auto& dq2 = indexes[it];
      matches.push_back(&dq2);
    }
  }
 
  string Select(shared_ptr<Pair> pairs, uint64_t length,
    bool right, const string& s1, const string& s2) {
    string buffer;
    buffer.reserve(length);
    for (auto next = pairs; next != nullptr; next = next->next) {
      auto c = right ? s2[next->index2] : s1[next->index1];
      buffer.push_back(c);
    }
    return buffer;
  }
 
public:
  string Correspondence(const string& s1, const string& s2) {
    CHAR2INDEXES indexes;
    MATCHES matches;                    

    Match(indexes, matches, s1, s2);
    shared_ptr<Pair> pairs;             

    auto length = Pairs(matches, &pairs);
    return Select(pairs, length, false, s1, s2);
  }
};    LCS lcs;
    auto s = lcs.Correspondence(s1, s2);
    cout << s << endl;"
"#include <set>
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include <numeric>
 
std::set<std::string> createPrefixes ( const std::string & s ) {
   std::set<std::string> result ;
   for ( int i = 1 ; i < s.size( ) + 1 ; i++ )
      result.insert( s.substr( 0 , i )) ;
   return result ;
}
 
std::set<std::string> findIntersection ( const std::set<std::string> & a ,
      const std::set<std::string> & b ) {
   std::set<std::string> intersection ;
   std::set_intersection( a.begin( ) , a.end( ) , b.begin( ) , b.end( ) ,
	 std::inserter ( intersection , intersection.begin( ) ) ) ;
   return intersection  ;
}
 
std::set<std::string> findCommonPrefixes( const std::vector<std::string> & theStrings ) {
   std::set<std::string> result ;
   if ( theStrings.size( ) == 1 ) {
      result.insert( *(theStrings.begin( ) ) ) ;
   }
   if ( theStrings.size( ) > 1 ) {
      std::vector<std::set<std::string>> prefixCollector ;
      for ( std::string s : theStrings )
	 prefixCollector.push_back( createPrefixes ( s ) ) ;
      std::set<std::string> neutralElement (createPrefixes( *(theStrings.begin( ) ) )) ;
      result = std::accumulate( prefixCollector.begin( ) , prefixCollector.end( ) ,
	    neutralElement , findIntersection ) ;
   }
   return result ;
}
 
std::string lcp( const std::vector<std::string> & allStrings ) {
   if ( allStrings.size( ) == 0 ) 
      return strv ;
   if ( allStrings.size( ) == 1 ) {
      return allStrings[ 0 ] ;
   }
   if ( allStrings.size( ) > 1 ) {
      std::set<std::string> prefixes( findCommonPrefixes ( allStrings ) ) ;
      if ( prefixes.empty( ) ) 
	 return strv ;
      else {
	 std::vector<std::string> common ( prefixes.begin( ) , prefixes.end( ) ) ;
	 std::sort( common.begin( ) , common.end( ) , [] ( const std::string & a, 
		  const std::string & b ) { return a.length( ) > b.length( ) ; } ) ;
	 return *(common.begin( ) ) ;
      }
   }
}
 
int main( ) {
   std::vector<std::string> input { strv , strv , strv } ;
   std::cout << ""lcp(interspecies,interstellar,interstate) = "" << lcp ( input ) << std::endl ;
   input.clear( ) ;
   input.push_back( strv ) ;
   input.push_back ( strv ) ;
   std::cout << ""lcp( throne , throne"" << strv << lcp ( input ) << std::endl ;
   input.clear( ) ;
   input.push_back( strv ) ;
   std::cout << ""lcp( cheese ) = "" << lcp ( input ) << std::endl ;
   input.clear( ) ;
   std::cout << ""lcp() = "" << lcp ( input ) << std::endl ;
   input.push_back( strv ) ;
   input.push_back( strv ) ;
   std::cout << ""lcp( prefix , suffix ) = "" << lcp ( input ) << std::endl ;
   input.clear( ) ;
   input.push_back( strv ) ;
   input.push_back( strv ) ;
   std::cout << ""lcp( foo , foobar ) = "" << lcp ( input ) << std::endl ;
   return 0 ;
} 
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
 
std::string lcp( const std::vector<std::string> & allStrings ) {
	if (allStrings.empty()) return std::string();
	const std::string &s0 = allStrings.front();
	auto end = s0.cend();
	for(auto it=std::next(allStrings.cbegin()); it != allStrings.cend(); it++){
		auto loc = std::mismatch(s0.cbegin(), s0.cend(), it->cbegin(), it->cend());
		if (std::distance(loc.first, end)>0) end = loc.first;
	}
	return std::string(s0.cbegin(), end);
}
 
int main( ) {
   std::vector<std::string> input { strv , strv , strv } ;
   std::cout << ""lcp(interspecies,interstellar,interstate) = "" << lcp ( input ) << std::endl ;
   input.clear( ) ;
   input.push_back( strv ) ;
   input.push_back ( strv ) ;
   std::cout << ""lcp( throne , throne"" << strv << lcp ( input ) << std::endl ;
   input.clear( ) ;
   input.push_back( strv ) ;
   std::cout << ""lcp( cheese ) = "" << lcp ( input ) << std::endl ;
   input.clear( ) ;
   std::cout << ""lcp() = "" << lcp ( input ) << std::endl ;
   input.push_back( strv ) ;
   input.push_back( strv ) ;
   std::cout << ""lcp( prefix , suffix ) = "" << lcp ( input ) << std::endl ;
   input.clear( ) ;
   input.push_back( strv ) ;
   input.push_back( strv ) ;
   std::cout << ""lcp( foo , foobar ) = "" << lcp ( input ) << std::endl ;
   return 0 ;
}
 "
"void print_logic(bool a, bool b)
{
  std::cout << std::boolalpha; 

  std::cout << strv << (a && b) << """";
  std::cout << strv << (a || b) << """";
  std::cout << strv << (!a) << """";
}"
"auto strA = R""(this isa newline-separatedraw string)"";
 "
" 
#include <iostream>
#include <sstream>
//--------------------------------------------------------------------------------------------------
typedef long long bigInt;
//--------------------------------------------------------------------------------------------------
using namespace std;
//--------------------------------------------------------------------------------------------------
class number
{
public:
    number()                                { s = strv; neg = false; }
    number( bigInt a )                      { set( a ); }
    number( string a )                      { set( a ); }
    void set( bigInt a )                    { neg = false; if( a < 0 ) { a = -a; neg = true; } ostringstream o; o << a; s = o.str(); clearStr(); }
    void set( string a )                    { neg = false; s = a; if( s.length() > 1 && s[0] == '-' ) { neg = true; } clearStr(); }
    number operator *  ( const number& b )  { return this->mul( b ); }
    number& operator *= ( const number& b ) { *this = *this * b; return *this; }
    number& operator = ( const number& b )  { s = b.s; return *this; }
    friend ostream& operator << ( ostream& out, const number& a ) { if( a.neg ) out << strv; out << a.s; return out; }
    friend istream& operator >> ( istream& in, number& a ){ string b; in >> b; a.set( b ); return in; }
 
private:
    number mul( const number& b )
    {
	number a; bool neg = false;
	string r, bs = b.s; r.resize( 2 * max( b.s.length(), s.length() ), '0' );
	int xx, ss, rr, t, c, stp = 0;
	string::reverse_iterator xi = bs.rbegin(), si, ri;
	for( ; xi != bs.rend(); xi++ )
	{
	    c = 0; ri = r.rbegin() + stp;
	    for( si = s.rbegin(); si != s.rend(); si++ )
	    {
		xx = ( *xi ) - 48; ss = ( *si ) - 48; rr = ( *ri ) - 48;
		ss = ss * xx + rr + c; t = ss % 10; c = ( ss - t ) / 10;
		( *ri++ ) = t + 48;
	    }
	    if( c > 0 ) ( *ri ) = c + 48;
	    stp++;
	}
	trimLeft( r ); t = b.neg ? 1 : 0; t += neg ? 1 : 0;
	if( t & 1 ) a.s = strv + r;
	else a.s = r;
	return a;
    }
 
    void trimLeft( string& r )
    {
	if( r.length() < 2 ) return;
	for( string::iterator x = r.begin(); x != ( r.end() - 1 ); )
	{
	    if( ( *x ) != '0' ) return;
	    x = r.erase( x );
	}
    }
 
    void clearStr()
    {
	for( string::iterator x = s.begin(); x != s.end(); )
	{
	    if( ( *x ) < '0' || ( *x ) > '9' ) x = s.erase( x );
	    else x++;
	}
    }
    string s;
    bool neg;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    number a, b;
    a.set( strv ); b.set( strv );
    cout << a * b << endl << endl;
 
    cout << strv; cin >> a;
    cout << strv; cin >> b;
    cout << strv << a * b << endl << endl;
    return system( strv );
}
//-------------------------------------------------------------------------------------------------- 
  
#include <iostream>
#include <vector>
using namespace std;
 
typedef unsigned long native_t;
 
struct ZPlus_	

{
	vector<native_t> digits_;	

 
	ZPlus_(native_t n) : digits_(1, n)
	{
		while(Sweep());
	}
 
	bool Sweep()	

	{
		bool changed = false;
		int carry = 0;
		for (auto pd = digits_.begin(); pd != digits_.end(); ++pd)
		{
			*pd += carry;
			carry = *pd / 10;
			*pd -= 10 * carry;
			changed = changed || carry > 0;
		}
		if (carry)
			digits_.push_back(carry);
		return changed || carry > 9;
	}
};
 
ZPlus_ operator*(const ZPlus_& lhs, const ZPlus_& rhs)
{
	ZPlus_ retval(0);
	

	retval.digits_.resize(lhs.digits_.size() + rhs.digits_.size(), 0ul);
	

	for (size_t ir = 0; ir < rhs.digits_.size(); ++ir)
		for (size_t il = 0; il < lhs.digits_.size(); ++il)
			retval.digits_[ir + il] += rhs.digits_[ir] * lhs.digits_[il];
	

	while(retval.Sweep());
	while (!retval.digits_.empty() && !retval.digits_.back())
		retval.digits_.pop_back();
	return retval;
}
 
ostream& operator<<(ostream& dst, const ZPlus_& n)
{
	for (auto pd = n.digits_.rbegin(); pd != n.digits_.rend(); ++pd)
		dst << *pd;
	return dst;
}
 
int main(int argc, char* argv[])
{
	int p2 = 1;
	ZPlus_ n(2ul);
	for (int ii = 0; ii < 7; ++ii)
	{
		p2 *= 2;
		n = n * n;
		cout << strv << p2 << strv << n << """";
	}
	return 0;
}"
"#include <fstream>
#include <iostream>
#include <numeric>
#include <unistd.h>
#include <vector>
 
std::vector<size_t> get_cpu_times() {
    std::ifstream proc_stat(strv);
    proc_stat.ignore(5, ' '); 

    std::vector<size_t> times;
    for (size_t time; proc_stat >> time; times.push_back(time));
    return times;
}
 
bool get_cpu_times(size_t &idle_time, size_t &total_time) {
    const std::vector<size_t> cpu_times = get_cpu_times();
    if (cpu_times.size() < 4)
        return false;
    idle_time = cpu_times[3];
    total_time = std::accumulate(cpu_times.begin(), cpu_times.end(), 0);
    return true;
}
 
int main(int, char *[]) {
    size_t previous_idle_time=0, previous_total_time=0;
    for (size_t idle_time, total_time; get_cpu_times(idle_time, total_time); sleep(1)) {
        const float idle_time_delta = idle_time - previous_idle_time;
        const float total_time_delta = total_time - previous_total_time;
        const float utilization = 100.0 * (1.0 - idle_time_delta / total_time_delta);
        std::cout << utilization << '%' << std::endl;
        previous_idle_time = idle_time;
        previous_total_time = total_time;
    }
}"
"#include <iostream>
 
int main()
{
  std::cout << ( (727 == 0x2d7) && 
                 (727 == 01327)     ? strv : strv)
            << std::endl;
 
  return 0;
}"
"#include <iostream>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class mRND
{
public:
    void seed( unsigned int s ) { _seed = s; }
 
protected:
    mRND() : _seed( 0 ), _a( 0 ), _c( 0 ), _m( 2147483648 ) {}
    int rnd() { return( _seed = ( _a * _seed + _c ) % _m ); }
 
    int _a, _c;
    unsigned int _m, _seed;
};
//--------------------------------------------------------------------------------------------------
class MS_RND : public mRND
{
public:
    MS_RND()  { _a = 214013; _c = 2531011; }
    int rnd() { return mRND::rnd() >> 16; }
};
//--------------------------------------------------------------------------------------------------
class BSD_RND : public mRND
{
public:
    BSD_RND() { _a = 1103515245; _c = 12345; }
    int rnd() { return mRND::rnd(); }
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    BSD_RND bsd_rnd;
    MS_RND ms_rnd;
 
    cout << strv << endl << strv << endl;
    for( int x = 0; x < 10; x++ )
	cout << ms_rnd.rnd() << endl;
 
    cout << endl  << strv << endl << strv << endl;
    for( int x = 0; x < 10; x++ )
	cout << bsd_rnd.rnd() << endl;
 
    cout << endl << endl;
    system( strv );
    return 0;
}
//--------------------------------------------------------------------------------------------------#include <iostream>
#include <random>
 
int main() {
 
  std::linear_congruential_engine<std::uint_fast32_t, 1103515245, 12345, 1 << 31> bsd_rand(0);
  std::linear_congruential_engine<std::uint_fast32_t, 214013, 2531011, 1 << 31> ms_rand(0);
 
  std::cout << strv << std::endl << strv << std::endl;
  for (int i = 0; i < 10; i++) {
    std::cout << bsd_rand() << std::endl;
  }
  std::cout << std::endl;
  std::cout << strv << std::endl << strv << std::endl;
  for (int i = 0; i < 10; i++) {
    std::cout << (ms_rand() >> 16) << std::endl;
  }
 
  return 0;
}"
"#include <vector>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <iterator>
 
void list_comprehension( std::vector<int> & , int ) ;
 
int main( ) {
   std::vector<int> triangles ;
   list_comprehension( triangles , 20 ) ;
   std::copy( triangles.begin( ) , triangles.end( ) ,
	 std::ostream_iterator<int>( std::cout , strv ) ) ;
   std::cout << std::endl ;
   return 0 ;
}
 
void list_comprehension( std::vector<int> & numbers , int upper_border ) {
   for ( int a = 1 ; a < upper_border ; a++ ) {
      for ( int b = a + 1 ; b < upper_border ; b++ ) {
	 double c = pow( a * a + b * b , 0.5 ) ; //remembering Mr. Pythagoras
	 if ( ( c * c ) < pow( upper_border , 2 ) + 1 ) {
	    if ( c == floor( c ) ) {
	       numbers.push_back( a ) ;
	       numbers.push_back( b ) ;	      
	       numbers.push_back( static_cast<int>( c ) ) ;
	    }
	 }
      }
   }
}
 #include <functional>
#include <iostream>
 
void PythagoreanTriples(int limit, std::function<void(int,int,int)> yield)
{
    for (int a = 1; a < limit; ++a) {
        for (int b = a+1; b < limit; ++b) {
            for (int c = b+1; c <= limit; ++c) {
                if (a*a + b*b == c*c) {
                    yield(a, b, c);
                }
            }
        }
    }
}
 
int main()
{
    PythagoreanTriples(20, [](int x, int y, int z)
    {
        std::cout << x << strv << y << strv << z << """";
    });
    return 0;
}"
"#include <fstream>
#include <iostream>
 
int main()
{
	std::ifstream input(strv, std::ios_base::binary);
	if (!input)
	{
		std::cerr << ""error: can't open file"";
		return -1;
	}
 
	size_t count[256];
	std::fill_n(count, 256, 0);
 
	for (char c; input.get(c); ++count[uint8_t(c)]) 

		; 

 
	for (size_t i = 0; i < 256; ++i)
	{
		if (count[i] && isgraph(i)) 

		{
			std::cout << char(i) << strv << count[i] << '';
		}
	}
}"
" 
#include <vector>
#include <string>
#include <algorithm>
#include <iostream>
#include <sstream>
using namespace std;
 
#if 1 // optimized for 64-bit architecture
typedef unsigned long usingle;
typedef unsigned long long udouble;
const int word_len = 32;
#else // optimized for 32-bit architecture
typedef unsigned short usingle;
typedef unsigned long udouble;
const int word_len = 16;
#endif
 
class bignum {
private:
    

    

    vector<usingle> rep_;
public:
    explicit bignum(usingle n = 0) { if (n > 0) rep_.push_back(n); }
    bool equals(usingle n) const {
        if (n == 0) return rep_.empty();
        if (rep_.size() > 1) return false;
        return rep_[0] == n;
    }
    bignum add(usingle addend) const {
        bignum result(0);
        udouble sum = addend;
        for (size_t i = 0; i < rep_.size(); ++i) {
            sum += rep_[i];
            result.rep_.push_back(sum & (((udouble)1 << word_len) - 1));
            sum >>= word_len;
        }
        if (sum > 0) result.rep_.push_back((usingle)sum);
        return result;
    }
    bignum add(const bignum& addend) const {
        bignum result(0);
        udouble sum = 0;
        size_t sz1 = rep_.size();
        size_t sz2 = addend.rep_.size();
        for (size_t i = 0; i < max(sz1, sz2); ++i) {
            if (i < sz1) sum += rep_[i];
            if (i < sz2) sum += addend.rep_[i];
            result.rep_.push_back(sum & (((udouble)1 << word_len) - 1));
            sum >>= word_len;
        }
        if (sum > 0) result.rep_.push_back((usingle)sum);
        return result;
    }
    bignum multiply(usingle factor) const {
        bignum result(0);
        udouble product = 0;
        for (size_t i = 0; i < rep_.size(); ++i) {
            product += (udouble)rep_[i] * factor;
            result.rep_.push_back(product & (((udouble)1 << word_len) - 1));
            product >>= word_len;
        }
        if (product > 0)
            result.rep_.push_back((usingle)product);
        return result;
    }
    void divide(usingle divisor, bignum& quotient, usingle& remainder) const {
        quotient.rep_.resize(0);
        udouble dividend = 0;
        remainder = 0;
        for (size_t i = rep_.size(); i > 0; --i) {
            dividend = ((udouble)remainder << word_len) + rep_[i - 1];
            usingle quo = (usingle)(dividend / divisor);
            remainder = (usingle)(dividend % divisor);
            if (quo > 0 || i < rep_.size())
                quotient.rep_.push_back(quo);
        }
        reverse(quotient.rep_.begin(), quotient.rep_.end());
    }
};
 
ostream& operator<<(ostream& os, const bignum& x);
 
ostream& operator<<(ostream& os, const bignum& x) {
    string rep;
    bignum dividend = x;
    bignum quotient;
    usingle remainder;
    while (true) {
        dividend.divide(10, quotient, remainder);
        rep += (char)('0' + remainder);
        if (quotient.equals(0)) break;
        dividend = quotient;
    }
    reverse(rep.begin(), rep.end());
    os << rep;
    return os;
}
 
bignum lfact(usingle n);
 
bignum lfact(usingle n) {
    bignum result(0);
    bignum f(1);
    for (usingle k = 1; k <= n; ++k) {
        result = result.add(f);
        f = f.multiply(k);
    }
    return result;
}
 
int main() {
    for (usingle i = 0; i <= 10; ++i) {
        cout << strv << i << strv << lfact(i) << endl;
    }
 
    for (usingle i = 20; i <= 110; i += 10) {
        cout << strv << i << strv << lfact(i) << endl;
    }
 
    for (usingle i = 1000; i <= 10000; i += 1000) {
        stringstream ss;
        ss << lfact(i);
        cout << strv << i << strv << ss.str().size()
            << strv << endl;
    }
}
 "
"#include <boost/math/common_factor.hpp>
#include <iostream>
 
int main( ) {
   std::cout << strv << 
      boost::math::lcm( 12 , 18 ) << "" ,""
      << strv << boost::math::gcd( 12 , 18 ) << strv << std::endl ;
   return 0 ;
} 
#include <cstdlib>
#include <iostream>
#include <tuple>
 
using namespace std;
 
int gcd(int a, int b) {
    a = abs(a);
    b = abs(b);
    while (b != 0) {
        tie(a, b) = make_tuple(b, a % b);
    }
    return a;
}
 
int lcm(int a, int b) {
    int c = gcd(a, b);
    return c == 0 ? 0 : a / c * b;
}
 
int main() {
    cout << strv << lcm(12, 18)
         << "" ,""
         << strv << gcd(12, 18) << strv << endl;
    return 0;
}
 "
"#include <iostream>
 
bool is_leap_year(int year) {
  return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
}
 
int main() {
  for (auto year : {1900, 1994, 1996, 1997, 2000}) {
    std::cout << year << (is_leap_year(year) ? strv : strv) << "" a leap year."";
  }
}"
"#include <iostream>
#include <sstream>
#include <algorithm>
#include <vector>
#include <string>
 
std::string findLargestConcat ( std::vector< int > & mynumbers ) {
   std::vector<std::string> concatnumbers ;
   std::sort ( mynumbers.begin( ) , mynumbers.end( ) ) ;
   do {
      std::ostringstream numberstream ;
      for ( int i : mynumbers ) 
	 numberstream << i ;
      concatnumbers.push_back( numberstream.str( ) ) ;
   } while ( std::next_permutation( mynumbers.begin( ) ,
	    mynumbers.end( ) )) ;
   return *( std::max_element( concatnumbers.begin( ) ,
	 concatnumbers.end( ) ) ) ;
}
 
int main( ) {
   std::vector<int> mynumbers = { 98, 76 , 45 , 34, 9 , 4 , 3 , 1 } ;
   std::vector<int> othernumbers = { 54 , 546 , 548 , 60 } ;
   std::cout << strv <<
      findLargestConcat( mynumbers ) << "" !"" ;
   std::cout << strv << findLargestConcat( othernumbers ) 
      << "" !"" ;
   return 0 ;
}"
"#include <boost/date_time/gregorian/gregorian.hpp>
#include <iostream>
#include <cstdlib>
 
int main( int argc , char* argv[ ] ) {
   using namespace boost::gregorian ;
 
   greg_month months[ ] = { Jan , Feb , Mar , Apr , May , Jun , Jul ,
      Aug , Sep , Oct , Nov , Dec } ;
   greg_year gy = atoi( argv[ 1 ] ) ;
   for ( int i = 0 ; i < 12 ; i++ ) {
      last_day_of_the_week_in_month lwdm ( Friday , months[ i ] ) ;
      date d = lwdm.get_date( gy ) ;
      std::cout << d << std::endl ;
   }
   return 0 ;
}"
" 
#include <windows.h>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int BMP_SIZE = 600, CELL_SIZE = 4, GRID_SIZE = BMP_SIZE / CELL_SIZE;
const bool INFINIT_RUN = false;
 
enum cellState { WHITE, BLACK, ANT };
enum facing { NOR, EAS, SOU, WES };
enum state { RUNNING, RESTING };
 
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO	bi;
	ZeroMemory( &bi, sizeof( bi ) );
 
	bi.bmiHeader.biSize	   = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes	   = 1;
	bi.bmiHeader.biWidth	   =  w;
	bi.bmiHeader.biHeight	   = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc ); 
 
	width = w; height = h;
 
	return true;
    }
 
    void clear()
    {
	ZeroMemory( pBits, width * height * sizeof( DWORD ) );
    }
 
    void setPenColor( DWORD clr )
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, 1, clr );
	SelectObject( hdc, pen );
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO	 infoheader;
	BITMAP		 bitmap;
	DWORD		 wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
 
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    HBITMAP bmp;
    HDC	    hdc;
    HPEN    pen;
    void   *pBits;
    int	    width, height;
};
//--------------------------------------------------------------------------------------------------
class Ant
{
public:
    Ant() 
    {
	_bmp.create( BMP_SIZE, BMP_SIZE );
	ZeroMemory( _grid, sizeof( _grid ) );
	RED_BRUSH = CreateSolidBrush( 255 );
	_antState = RUNNING;
    }
 
    ~Ant()
    {
	DeleteObject( RED_BRUSH );
    }
 
    void setPosition( int x, int y )
    {
	_sx = x; _sy = y;
	_facing = WES;
    }
 
    void mainLoop()
    {
	switch( _antState )
	{
	    case RUNNING:
	        simulate();
		

	    case RESTING:
		display();
	}
    }
 
    void setHWND( HWND hwnd ) { _hwnd = hwnd; }
 
private:
    void simulate()
    {
	switch( _grid[_sx][_sy] )
	{
	    case BLACK:
		_grid[_sx][_sy] = WHITE;
		if( --_facing < NOR ) _facing = WES;
	    break;
	    case WHITE:
		_grid[_sx][_sy] = BLACK;
		if( ++_facing > WES ) _facing = NOR;
	}
	switch( _facing )
	{
	    case NOR: 
		if( --_sy < 0 )
		{
		    if( INFINIT_RUN ) _sy = GRID_SIZE - 1;
		    else _antState = RESTING;
		}
	    break;
	    case EAS:
		if( ++_sx >= GRID_SIZE )
		{
		    if( INFINIT_RUN ) _sx = 0;
		    else _antState = RESTING;
		}
	    break;
	    case SOU:
		if( ++_sy >= GRID_SIZE )
		{
		    if( INFINIT_RUN ) _sy = 0;
		    else _antState = RESTING;
		}
	    break;
	    case WES:
	        if( --_sx < 0 )
		{
		    if( INFINIT_RUN ) _sx = GRID_SIZE - 1;
		    else _antState = RESTING;
		}
	}
    }
 
    void display()
    {
        _bmp.clear();
 
        HBRUSH br; RECT rc;
        int xx, yy; HDC dc = _bmp.getDC();
 
        for( int y = 0; y < GRID_SIZE; y++ )
	    for( int x = 0; x < GRID_SIZE; x++ )
	    {
	        switch( _grid[x][y] )
	        {
		    case BLACK: br = static_cast<HBRUSH>( GetStockObject( BLACK_BRUSH ) ); break;
		    case WHITE: br = static_cast<HBRUSH>( GetStockObject( WHITE_BRUSH ) );
	        }
	        if( x == _sx && y == _sy ) br = RED_BRUSH;
 
	        xx = x * CELL_SIZE; yy = y * CELL_SIZE;
	        SetRect( &rc, xx, yy, xx + CELL_SIZE, yy + CELL_SIZE );
	        FillRect( dc, &rc, br );
	    }
 
        HDC wdc = GetDC( _hwnd );
        BitBlt( wdc, 0, 0, BMP_SIZE, BMP_SIZE, dc, 0, 0, SRCCOPY );
        ReleaseDC( _hwnd, wdc );
    }
 
    myBitmap _bmp;
    HWND     _hwnd;
    HBRUSH   RED_BRUSH;
    BYTE     _grid[GRID_SIZE][GRID_SIZE];
    int      _sx, _sy, _facing;
    state    _antState;
};
//--------------------------------------------------------------------------------------------------
class wnd
{
public:
    int wnd::Run( HINSTANCE hInst )
    {
	_hInst = hInst;
	_hwnd = InitAll();
 
	_ant.setHWND( _hwnd );
	_ant.setPosition( GRID_SIZE / 2, GRID_SIZE / 2 );
 
	ShowWindow( _hwnd, SW_SHOW );
	UpdateWindow( _hwnd );
 
	MSG msg;
	ZeroMemory( &msg, sizeof( msg ) );
	while( msg.message != WM_QUIT )
	{
	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
	    {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	    }
	    else
	    {
		_ant.mainLoop();
	    }
	}
	return UnregisterClass( strv, _hInst );
    }
private:
    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
    {
	switch( msg )
	{
	    case WM_DESTROY: PostQuitMessage( 0 ); break;
	    default:
		return DefWindowProc( hWnd, msg, wParam, lParam );
	}
	return 0;
    }
 
    HWND InitAll()
    {
	WNDCLASSEX wcex;
	ZeroMemory( &wcex, sizeof( wcex ) );
	wcex.cbSize	       = sizeof( WNDCLASSEX );
	wcex.style	       = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc   = ( WNDPROC )WndProc;
	wcex.hInstance     = _hInst;
	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
	wcex.lpszClassName = strv;
 
	RegisterClassEx( &wcex );
 
	return CreateWindow( strv, strv, WS_SYSMENU, CW_USEDEFAULT, 0, BMP_SIZE, BMP_SIZE, NULL, NULL, _hInst, NULL );
    }
 
    HINSTANCE _hInst;
    HWND      _hwnd;
    Ant       _ant;
};
//--------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    wnd myWnd;
    return myWnd.Run( hInstance );
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
#include <functional>
#include <vector>
#include <cstdlib>
#include <ctime>
 
template <typename T>
std::function<std::vector<T>(T)> s_of_n_creator(int n) {
  std::vector<T> sample;
  int i = 0;
  return [=](T item) mutable {
    i++;
    if (i <= n) {
      sample.push_back(item);
    } else if (std::rand() % i < n) {
      sample[std::rand() % n] = item;
    }
    return sample;
  };
}
 
int main() {
  std::srand(std::time(NULL));
  int bin[10] = {0};
  for (int trial = 0; trial < 100000; trial++) {
    auto s_of_n = s_of_n_creator<int>(3);
    std::vector<int> sample;
    for (int i = 0; i < 10; i++)
      sample = s_of_n(i);
    for (int s : sample)
      bin[s]++;
  }
  for (int x : bin)
    std::cout << x << std::endl;
  return 0;
}#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
 
template <typename T>
class SOfN {
  std::vector<T> sample;
  int i;
  const int n;
 public:
  SOfN(int _n) : i(0), n(_n) { }
  std::vector<T> operator()(T item) {
    i++;
    if (i <= n) {
      sample.push_back(item);
    } else if (std::rand() % i < n) {
      sample[std::rand() % n] = item;
    }
    return sample;
  }
};
 
int main() {
  std::srand(std::time(NULL));
  int bin[10] = {0};
  for (int trial = 0; trial < 100000; trial++) {
    SOfN<int> s_of_n(3);
    std::vector<int> sample;
    for (int i = 0; i < 10; i++)
      sample = s_of_n(i);
    for (std::vector<int>::const_iterator i = sample.begin(); i != sample.end(); i++)
      bin[*i]++;
  }
  for (int i = 0; i < 10; i++)
    std::cout << bin[i] << std::endl;
  return 0;
}"
" 
#include<iostream>
#include<algorithm>
#include<string.h>
 
using namespace std;
double result;
double capacity = 15;
int NumberOfItems;
int number;
 
struct items
{
    char name[32];
    double weight;
    double price;
    double m;
} item[256];
 
bool cmp(items a,items b)
{
    return a.price/a.weight > b.price/b.weight; 

}
 
int main()
{
NumberOfItems=9;
strcpy(item[1].name,strv);
item[1].weight=3.8;
item[1].price=36;
 
strcpy(item[2].name,strv);
item[2].weight=5.4;
item[2].price=43;
 
strcpy(item[3].name,strv);
item[3].weight=3.6;
item[3].price=90;
 
strcpy(item[4].name,strv);
item[4].weight=2.4;
item[4].price=45;
 
strcpy(item[5].name,strv);
item[5].weight=4.0;
item[5].price=30;
 
strcpy(item[6].name,strv);
item[6].weight=2.5;
item[6].price=56;
 
strcpy(item[7].name,strv);
item[7].weight=3.7;
item[7].price=67;
 
strcpy(item[8].name,strv);
item[8].weight=3.0;
item[8].price=95;
 
strcpy(item[9].name,strv);
item[9].weight=5.9;
item[9].price=98;
 
 
sort(item+1,item+NumberOfItems+1,cmp); 

 
 number = 1;
 while(capacity>0&&number<=NumberOfItems)
 {
  if(item[number].weight<=capacity)
    {
        result+=item[number].price;
        capacity-=item[number].weight;
        item[number].m=1;
    }
  else
  {
      result+=(item[number].price)*(capacity/item[number].weight);
      item[number].m=(capacity/item[number].weight);
      capacity=0;
 
  }
  ++number;
 }
 
cout<<strv<<result<<'';
cout<<strv<<(double)15-capacity<<'';
cout<<""Items Used:"";
for(int i=1;i<=NumberOfItems;++i)
    if(item[i].m)
    {
       cout<<strv<<item[i].m*item[i].weight<<""kg of ""<<item[i].name<<"" and the value it brought is ""<<item[i].price*item[i].m<<"""";
    }
 
return 0;
}
 
  


#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
 
using namespace std;
 
struct item_type
{
    double  weight, value;
    string  name;
};
 
vector< item_type > items =
{
    { 3.8, 36, strv    },
    { 5.4, 43, strv    },
    { 3.6, 90, strv     },
    { 2.4, 45, strv },
    { 4.0, 30, strv  },
    { 2.5, 56, strv   },
    { 3.7, 67, strv    },
    { 3.0, 95, strv  },
    { 5.9, 98, strv }
};
 
int main()
{
    sort
    ( 
        begin( items ), end( items ),
        [] (const item_type& a, const item_type& b)
        {
            return a.value / a.weight > b.value / b.weight;
        }
    );
 
    double space = 15;
 
    for ( const auto& item : items )
    {
        if ( space >= item.weight )
            cout << strv << item.name << endl;
        else 
        {
            cout << strv << space << strv << item.name << endl;
            break;
        }
 
        space -= item.weight;
    }
}
 "
"#include <cstdlib>
#include <algorithm>
#include <iterator>
 
template<typename RandomAccessIterator>
void knuthShuffle(RandomAccessIterator begin, RandomAccessIterator end) {
  for(unsigned int n = end - begin - 1; n >= 1; --n) {
    unsigned int k = rand() % (n + 1);
    if(k != n) {
      std::iter_swap(begin + k, begin + n);
    }
  }
}#include <algorithm>
#include <vector>
 
int main()
{
    int array[] = { 1,2,3,4,5,6,7,8,9 }; 

    std::vector<int> vec(array, array + 9); 

 
    std::random_shuffle(array, array + 9); 

    std::random_shuffle(vec.begin(), vec.end()); 

}"
"#include <iostream>
#include <iomanip>
#include <array>
#include <string>
#include <tuple>
#include <algorithm>
using namespace std;
 
template<int N = 8>
class Board 
{
public:
    array<pair<int, int>, 8> moves;
    array<array<int, N>, N> data;
 
    Board() 
    {
        moves[0] = make_pair(2, 1);
        moves[1] = make_pair(1, 2);
        moves[2] = make_pair(-1, 2);
        moves[3] = make_pair(-2, 1);
        moves[4] = make_pair(-2, -1);
        moves[5] = make_pair(-1, -2);
        moves[6] = make_pair(1, -2);
        moves[7] = make_pair(2, -1);
    }
 
    array<int, 8> sortMoves(int x, int y) const 
    {
        array<tuple<int, int>, 8> counts;
        for(int i = 0; i < 8; ++i) 
        {
            int dx = get<0>(moves[i]);
            int dy = get<1>(moves[i]);
 
            int c = 0;
            for(int j = 0; j < 8; ++j) 
            {
                int x2 = x + dx + get<0>(moves[j]);
                int y2 = y + dy + get<1>(moves[j]);
 
                if (x2 < 0 || x2 >= N || y2 < 0 || y2 >= N)
                    continue;
                if(data[y2][x2] != 0)
                    continue;
 
                c++;
            }
 
            counts[i] = make_tuple(c, i);
        }
 
        

        random_shuffle(counts.begin(), counts.end());
 
        

        sort(counts.begin(), counts.end());
 
        array<int, 8> out;
        for(int i = 0; i < 8; ++i)
            out[i] = get<1>(counts[i]);
        return out;
    }
 
    void solve(string start) 
    {
        for(int v = 0; v < N; ++v)
            for(int u = 0; u < N; ++u)
                data[v][u] = 0;
 
        int x0 = start[0] - 'a';
        int y0 = N - (start[1] - '0');
        data[y0][x0] = 1;
 
        array<tuple<int, int, int, array<int, 8>>, N*N> order;
        order[0] = make_tuple(x0, y0, 0, sortMoves(x0, y0));
 
        int n = 0;
        while(n < N*N-1) 
        {
            int x = get<0>(order[n]);
            int y = get<1>(order[n]);
 
            bool ok = false;
            for(int i = get<2>(order[n]); i < 8; ++i) 
            {
                int dx = moves[get<3>(order[n])[i]].first;
                int dy = moves[get<3>(order[n])[i]].second;
 
                if(x+dx < 0 || x+dx >= N || y+dy < 0 || y+dy >= N)
                    continue;
                if(data[y + dy][x + dx] != 0) 
                    continue;
 
                ++n;
                get<2>(order[n]) = i + 1;
                data[y+dy][x+dx] = n + 1;
                order[n] = make_tuple(x+dx, y+dy, 0, sortMoves(x+dx, y+dy));
                ok = true;
                break;
            }
 
            if(!ok) 

            {
                data[y][x] = 0;
                --n;
            }
        }
    }
 
    template<int N>
    friend ostream& operator<<(ostream &out, const Board<N> &b);
};
 
template<int N>
ostream& operator<<(ostream &out, const Board<N> &b) 
{
    for (int v = 0; v < N; ++v) 
    {
        for (int u = 0; u < N; ++u) 
        {
            if (u != 0) out << strv;
            out << setw(3) << b.data[v][u];
        }
        out << endl;
    }
    return out;
}
 
int main() 
{
    Board<5> b1;
    b1.solve(strv);
    cout << b1 << endl;
 
    Board<8> b2;
    b2.solve(strv);
    cout << b2 << endl;
 
    Board<31> b3; 

    b3.solve(strv);
    cout << b3 << endl;
    return 0;
}"
"#include <iostream>
#include <vector>
#include <algorithm>
#include <stdexcept>
#include <memory>
#include <sys/time.h>
 
using std::cout;
using std::endl;
 
class StopTimer
{
public:
    StopTimer(): begin_(getUsec()) {}
    unsigned long long getTime() const { return getUsec() - begin_; }
private:
    static unsigned long long getUsec()
    {//...you might want to use something else under Windows
        timeval tv;
        const int res = ::gettimeofday(&tv, 0);
        if(res)
            return 0;
        return tv.tv_usec + 1000000 * tv.tv_sec;
    }
    unsigned long long begin_;
};
 
struct KnapsackTask
{
    struct Item
    {
        std::string name;
        unsigned w, v, qty;
        Item(): w(), v(), qty() {}
        Item(const std::string& iname, unsigned iw, unsigned iv, unsigned iqty):
            name(iname), w(iw), v(iv), qty(iqty)
        {}
    };
    typedef std::vector<Item> Items;
    struct Solution
    {
        unsigned v, w;
        unsigned long long iterations, usec;
        std::vector<unsigned> n;
        Solution(): v(), w(), iterations(), usec() {}
    };
    //...
    KnapsackTask(): maxWeight_(), totalWeight_() {}
    void add(const Item& item)
    {
        const unsigned totalItemWeight = item.w * item.qty;
        if(const bool invalidItem = !totalItemWeight)
            throw std::logic_error(strv + item.name);
        totalWeight_ += totalItemWeight;
        items_.push_back(item);
    }
    const Items& getItems() const { return items_; }
    void setMaxWeight(unsigned maxWeight) { maxWeight_ = maxWeight; }
    unsigned getMaxWeight() const { return std::min(totalWeight_, maxWeight_); }
 
private:
    unsigned maxWeight_, totalWeight_;
    Items items_;
};
 
class BoundedKnapsackRecursiveSolver
{
public:
    typedef KnapsackTask Task;
    typedef Task::Item Item;
    typedef Task::Items Items;
    typedef Task::Solution Solution;
 
    void solve(const Task& task)
    {
        Impl(task, solution_).solve();
    }
    const Solution& getSolution() const { return solution_; }
private:
    class Impl
    {
        struct Candidate
        {
            unsigned v, n;
            bool visited;
            Candidate(): v(), n(), visited(false) {}
        };
        typedef std::vector<Candidate> Cache;
    public:
        Impl(const Task& task, Solution& solution):
            items_(task.getItems()),
            maxWeight_(task.getMaxWeight()),
            maxColumnIndex_(task.getItems().size() - 1),
            solution_(solution),
            cache_(task.getMaxWeight() * task.getItems().size()),
            iterations_(0)
        {}
        void solve()
        {
            if(const bool nothingToSolve = !maxWeight_ || items_.empty())
                return;
            StopTimer timer;
            Candidate candidate;
            solve(candidate, maxWeight_, items_.size() - 1);
            convertToSolution(candidate);
            solution_.usec = timer.getTime();
        }
    private:
        void solve(Candidate& current, unsigned reminderWeight, const unsigned itemIndex)
        {
            ++iterations_;
 
            const Item& item(items_[itemIndex]);
 
            if(const bool firstColumn = !itemIndex)
            {
                const unsigned maxQty = std::min(item.qty, reminderWeight/item.w);
                current.v = item.v * maxQty;
                current.n = maxQty;
                current.visited = true;
            }
            else
            {
                const unsigned nextItemIndex = itemIndex - 1;
                {
                    Candidate& nextItem = cachedItem(reminderWeight, nextItemIndex);
                    if(!nextItem.visited)
                        solve(nextItem, reminderWeight, nextItemIndex);
                    current.visited = true;
                    current.v = nextItem.v;
                    current.n = 0;
                }
                if(reminderWeight >= item.w)
                {
                    for (unsigned numberOfItems = 1; numberOfItems <= item.qty; ++numberOfItems)
                    {
                        reminderWeight -= item.w;
                        Candidate& nextItem = cachedItem(reminderWeight, nextItemIndex);
                        if(!nextItem.visited)
                            solve(nextItem, reminderWeight, nextItemIndex);
 
                        const unsigned checkValue = nextItem.v + numberOfItems * item.v;
                        if ( checkValue > current.v)
                        {
                            current.v = checkValue;
                            current.n = numberOfItems;
                        }
                        if(!(reminderWeight >= item.w))
                            break;
                    }
                }
            }
        }
        void convertToSolution(const Candidate& candidate)
        {
            solution_.iterations = iterations_;
            solution_.v = candidate.v;
            solution_.n.resize(items_.size());
 
            const Candidate* iter = &candidate;
            unsigned weight = maxWeight_, itemIndex = items_.size() - 1;
            while(true)
            {
                const unsigned currentWeight = iter->n * items_[itemIndex].w;
                solution_.n[itemIndex] = iter->n;
                weight -= currentWeight;
                if(!itemIndex--)
                    break;
                iter = &cachedItem(weight, itemIndex);
            }
            solution_.w = maxWeight_ - weight;
        }
        Candidate& cachedItem(unsigned weight, unsigned itemIndex)
        {
            return cache_[weight * maxColumnIndex_ + itemIndex];
        }
        const Items& items_;
        const unsigned maxWeight_;
        const unsigned maxColumnIndex_;
        Solution& solution_;
        Cache cache_;
        unsigned long long iterations_;
    };
    Solution solution_;
};
 
void populateDataset(KnapsackTask& task)
{
    typedef KnapsackTask::Item Item;
    task.setMaxWeight( 400 );
    task.add(Item(strv,9,150,1));
    task.add(Item(strv,13,35,1));
    task.add(Item(strv,153,200,2));
    task.add(Item(strv,50,60,2));
    task.add(Item(strv,15,60,2));
    task.add(Item(strv,68,45,3));
    task.add(Item(strv,27,60,3));
    task.add(Item(strv,39,40,3));
    task.add(Item(strv,23,30,1));
    task.add(Item(strv,52,10,3));
    task.add(Item(strv,11,70,1));
    task.add(Item(strv,32,30,1));
    task.add(Item(strv,24,15,2));
    task.add(Item(strv,48,10,2));
    task.add(Item(strv,73,40,1));
    task.add(Item(strv,42,70,1));
    task.add(Item(strv,43,75,1));
    task.add(Item(strv,22,80,1));
    task.add(Item(strv,7,20,1));
    task.add(Item(strv,18,12,2));
    task.add(Item(strv,4,50,1));
    task.add(Item(strv,30,10,2));
}
 
int main()
{
    KnapsackTask task;
    populateDataset(task);
 
    BoundedKnapsackRecursiveSolver solver;
    solver.solve(task);
    const KnapsackTask::Solution& solution = solver.getSolution();
 
    cout << strv << solution.iterations << endl;
    cout << strv << solution.usec << strv << endl;
    cout << strv << endl;
    for (unsigned i = 0; i < solution.n.size(); ++i)
    {
        if (const bool itemIsNotInKnapsack = !solution.n[i])
            continue;
        cout << strv << solution.n[i] << ' ' << task.getItems()[i].name << strv << task.getItems()[i].w << strv << endl;
    }
 
    cout << strv << solution.w << strv << solution.v << endl;
    return 0;
}"
"#include <vector>
#include <string>
#include <iostream>
#include <boost/tuple/tuple.hpp>
#include <set>
 
int findBestPack( const std::vector<boost::tuple<std::string , int , int> > & , 
      std::set<int> & , const int  ) ;
 
int main( ) {
   std::vector<boost::tuple<std::string , int , int> > items ;
   //===========fill the vector with data====================
   items.push_back( boost::make_tuple( strv , 0  ,  0 ) ) ;
   items.push_back( boost::make_tuple( strv , 9 , 150 ) ) ;
   items.push_back( boost::make_tuple( strv , 13 , 35 ) ) ;
   items.push_back( boost::make_tuple( strv , 153 , 200 ) ) ;
   items.push_back( boost::make_tuple( strv, 50 , 160 ) ) ;
   items.push_back( boost::make_tuple( strv , 15 , 60 ) ) ;
   items.push_back( boost::make_tuple( strv, 68 , 45 ) ) ;
   items.push_back( boost::make_tuple( strv, 27 , 60 ) ) ;
   items.push_back( boost::make_tuple( strv , 39 , 40 ) ) ;
   items.push_back( boost::make_tuple( strv , 23 , 30 ) ) ;
   items.push_back( boost::make_tuple( strv , 52 , 10 ) ) ;
   items.push_back( boost::make_tuple( strv , 11 , 70 ) ) ;
   items.push_back( boost::make_tuple( strv , 32 , 30 ) ) ;
   items.push_back( boost::make_tuple( strv , 24 , 15 ) ) ;
   items.push_back( boost::make_tuple( strv , 48 , 10 ) ) ;
   items.push_back( boost::make_tuple( strv , 73 , 40 ) ) ;
   items.push_back( boost::make_tuple( strv , 42 , 70 ) ) ;
   items.push_back( boost::make_tuple( strv , 43 , 75 ) ) ;
   items.push_back( boost::make_tuple( strv , 22 , 80 ) ) ;
   items.push_back( boost::make_tuple( strv , 7 , 20 ) ) ;
   items.push_back( boost::make_tuple( strv , 18 , 12 ) ) ;
   items.push_back( boost::make_tuple( strv , 4 , 50 ) ) ;
   items.push_back( boost::make_tuple( strv , 30 , 10 ) ) ;
   const int maximumWeight = 400 ;
   std::set<int> bestItems ; //these items will make up the optimal value
   int bestValue = findBestPack( items , bestItems , maximumWeight ) ;
   std::cout << strv <<
      bestValue << "" !"" ;
   int totalweight = 0 ;
   std::cout << ""The following items should be packed in the knapsack:"" ;
   for ( std::set<int>::const_iterator si = bestItems.begin( ) ; 
	 si != bestItems.end( ) ; si++ ) { 
      std::cout << (items.begin( ) + *si)->get<0>( ) << """" ;
      totalweight += (items.begin( ) + *si)->get<1>( ) ;
   }
   std::cout << strv << totalweight << "" !"" ;
   return 0 ;
}
 
int findBestPack( const std::vector<boost::tuple<std::string , int , int> > & items ,std::set<int> & bestItems , const int weightlimit ) {
   //dynamic programming approach sacrificing storage space for execution
   //time , creating a table of optimal values for every weight and a 
   //second table of sets with the items collected so far in the knapsack
   //the best value is in the bottom right corner of the values table,
   //the set of items in the bottom right corner of the sets' table.
   const int n = items.size( ) ;
   int bestValues [ n ][ weightlimit ] ;
   std::set<int> solutionSets[ n ][ weightlimit ] ;
   std::set<int> emptyset ;
   for ( int i = 0 ; i < n ; i++ ) {
      for ( int j = 0 ; j < weightlimit  ; j++ ) {
	 bestValues[ i ][ j ] = 0 ;
	 solutionSets[ i ][ j ] = emptyset ;
       }
    }
    for ( int i = 0 ; i < n ; i++ ) {
       for ( int weight = 0 ; weight < weightlimit ; weight++ ) {
	  if ( i == 0 )
	     bestValues[ i ][ weight ] = 0 ;
	  else  {
	     int itemweight = (items.begin( ) + i)->get<1>( ) ; 
	     if ( weight < itemweight ) {
		bestValues[ i ][ weight ] = bestValues[ i - 1 ][ weight ] ;
		solutionSets[ i ][ weight ] = solutionSets[ i - 1 ][ weight ] ;
	     } else { 

		if ( bestValues[ i - 1 ][ weight - itemweight ] + 
		   (items.begin( ) + i)->get<2>( ) >
		        bestValues[ i - 1 ][ weight ] ) {
		   bestValues[ i ][ weight ] = 
		       bestValues[ i - 1 ][ weight - itemweight ] + 
	        	(items.begin( ) + i)->get<2>( ) ;
		  solutionSets[ i ][ weight ] = 
		      solutionSets[ i - 1 ][ weight - itemweight ] ;
		  solutionSets[ i ][ weight ].insert( i ) ;
	     }
	     else {
		bestValues[ i ][ weight ] = bestValues[ i - 1 ][ weight ] ;
		solutionSets[ i ][ weight ] = solutionSets[ i - 1 ][ weight ] ;
	     }
	  }
       }
      }
    }
    bestItems.swap( solutionSets[ n - 1][ weightlimit - 1 ] ) ;
    return bestValues[ n - 1 ][ weightlimit - 1 ] ;
}"
" 
#include <windows.h>
#include <string>
#include <complex>
 
const int BMP_SIZE = 600, ITERATIONS = 512;
const long double FCT = 2.85, hFCT = FCT / 2.0;
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    void saveBitmap( std::string path ) {
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
            FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
    DWORD* bits() const { return ( DWORD* )pBits; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC    hdc;
    HPEN    pen; HBRUSH brush;
    void    *pBits; int    width, height, wid;
    DWORD    clr;
};
class julia {
public:
    void draw( std::complex<long double> k ) {
        bmp.create( BMP_SIZE, BMP_SIZE );
        DWORD* bits = bmp.bits();
        int res, pos;
        std::complex<long double> c, factor( FCT / BMP_SIZE, FCT / BMP_SIZE ) ;
 
        for( int y = 0; y < BMP_SIZE; y++ ) {
            pos = y * BMP_SIZE;
 
            c.imag( ( factor.imag() * y ) + -hFCT );
 
            for( int x = 0; x < BMP_SIZE; x++ ) {
                c.real( factor.real() * x + -hFCT );
                res = inSet( c, k );
                if( res ) {
                    int n_res = res % 255;
                    if( res < ( ITERATIONS >> 1 ) ) res = RGB( n_res << 2, n_res << 3, n_res << 4 );
                    else res = RGB( n_res << 4, n_res << 2, n_res << 5 );
                }
                bits[pos++] = res;
            }
        }
        bmp.saveBitmap( strv );
    }
private:
    int inSet( std::complex<long double> z, std::complex<long double> c ) {
        long double dist;//, three = 3.0;
        for( int ec = 0; ec < ITERATIONS; ec++ ) {
            z = z * z; z = z + c;
            dist = ( z.imag() * z.imag() ) + ( z.real() * z.real() );
            if( dist > 3 ) return( ec );
        }
        return 0;
    }
    myBitmap bmp;
};
int main( int argc, char* argv[] ) {
    std::complex<long double> c;
    long double factor = FCT / BMP_SIZE;
    c.imag( ( factor * 184 ) + -1.4 );
    c.real( ( factor * 307 ) + -2.0 );
    julia j; j.draw( c ); return 0;    
}
 "
"#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iterator>
#include <utility>
 
long string2long( const std::string & s ) {
   long result ;
   std::istringstream( s ) >> result ;
   return result ;
}
 
bool isKaprekar( long number ) {
   long long squarenumber = ((long long)number) * number ;
   std::ostringstream numberbuf ;
   numberbuf << squarenumber ;
   std::string numberstring = numberbuf.str( ) ;
   for ( int i = 0 ; i < numberstring.length( ) ; i++ ) {
      std::string firstpart = numberstring.substr( 0 , i ) ,
                  secondpart = numberstring.substr( i ) ;
      //we do not accept figures ending in a sequence of zeroes
      if ( secondpart.find_first_not_of( strv ) == std::string::npos ) {
	 return false ;
      }
      if ( string2long( firstpart ) + string2long( secondpart ) == number ) {
	 return true ;
      }
   }
   return false ;
}
 
int main( ) {
   std::vector<long> kaprekarnumbers ;
   kaprekarnumbers.push_back( 1 ) ;
   for ( int i = 2 ; i < 1000001 ; i++ ) {
      if ( isKaprekar( i ) ) 
	 kaprekarnumbers.push_back( i ) ;
   }
   std::vector<long>::const_iterator svi = kaprekarnumbers.begin( ) ;
   std::cout << ""Kaprekar numbers up to 10000: "" ;
   while ( *svi < 10000 ) {
      std::cout << *svi << strv ;
      svi++ ;
   }
   std::cout << '' ;
   std::cout << ""All the Kaprekar numbers up to 1000000 :"" ;
   std::copy( kaprekarnumbers.begin( ) , kaprekarnumbers.end( ) ,
	 std::ostream_iterator<long>( std::cout , """" ) ) ;
   std::cout << strv << kaprekarnumbers.size( )
      << "" Kaprekar numbers less than one million!"" ;
   return 0 ;
} 


//


//
#include <iostream>
int main() {
	const int Base = 10;
	const int N = 6;
	int Paddy_cnt = 0;
	for (int nz=1; nz<=N; nz++)
		for (unsigned long long int k=pow((double)Base,nz-1); k<pow((double)Base,nz); k++)
			if ((k*(k-1))%(Base-1) == 0)
				for (int n=nz; n<nz*2; n++){
					const unsigned long long int B = pow((double)Base,n);
					const double nr = k*(B-k)/(B-1);
					const int q = k-nr;
					if ((k*k==q*B+nr && 0<nr)){
						std::cout << std::dec << ++Paddy_cnt << strv << k << strv  << q << strv << (int)nr << strv << k*k << strv << k%(Base-1) << """";
						break;
				}}
	return 0;
}
  
const int Base = 16;
const int N = 4;
std::cout << std::dec << ++Paddy_cnt << strv << std::hex << k << strv  << q << strv << (int)nr << strv << k*k << strv << k%(Base-1) << """";
 

//


//
#include <cmath>
int main() {
	const ran r(10);
	int Paddy_cnt = 0;
	for (int nz=1; nz<=6; nz++)
		for (unsigned long long int k : co9(std::pow(r.base,nz-1),std::pow(r.base,nz)-1,&r))
			for (int n=nz; n<nz*2; n++) {
				const unsigned long long int B = pow(r.base,n);
				const double nr = k*(B-k)/(B-1);
				const int q = k-nr;
				if ((k*k==q*B+nr && 0<nr)) {
					std::cout << ++Paddy_cnt << strv << k << strv  << q << strv << (int)nr << strv << k*k << strv << k%(r.base-1) << """";
			}}
	return 0;
} 
	const ran r = ran(16);
					std::cout << std::dec << ++Paddy_cnt << strv << std::hex << k << strv  << q << strv << (int)nr << strv << k*k << strv << k%(r.base-1) << """";
 "
" 
#include <algorithm>
#include <string>
#include <iostream>
#include <iterator> 
 
class jortSort {
public:
    template<class T>
    bool jort_sort( T* o, size_t s ) {
        T* n = copy_array( o, s );
        sort_array( n, s );
        bool r = false;
 
        if( n ) {
            r = check( o, n, s );
            delete [] n;
        }
        return r;
    }
 
private:
    template<class T>
    T* copy_array( T* o, size_t s ) {
        T* z = new T[s];
        memcpy( z, o, s * sizeof( T ) );
        //std::copy( o, o + s, z );
        return z;
    }
    template<class T>
    void sort_array( T* n, size_t s ) {
        std::sort( n, n + s );
    }
    template<class T>
    bool check( T* n, T* o, size_t s ) {
        for( size_t x = 0; x < s; x++ )
            if( n[x] != o[x] ) return false;
        return true;
    }
};
 
jortSort js;
 
template<class T>
void displayTest( T* o, size_t s ) {
    std::copy( o, o + s, std::ostream_iterator<T>( std::cout, strv ) );
    std::cout << strv << ( js.jort_sort( o, s ) ? strv : strv ) << """";
}
 
int main( int argc, char* argv[] ) {
    const size_t s = 5;
    std::string oStr[] = { strv, strv, strv, strv, strv };
    displayTest( oStr, s );
    std::swap( oStr[0], oStr[1] );
    displayTest( oStr, s );
 
    int oInt[] = { 1, 2, 3, 4, 5 };
    displayTest( oInt, s );
    std::swap( oInt[0], oInt[1] );
    displayTest( oInt, s );
 
    return 0;
}
 "
"#include strv
 
using namespace Upp;
 
CONSOLE_APP_MAIN
{
	JsonArray a;
	a << Json(strv, strv)(strv, strv) << Json(strv, strv)(strv, strv);
	String txt = ~a;
	Cout() << txt << '';
	Value v = ParseJSON(txt);
	for(int i = 0; i < v.GetCount(); i++)
		Cout() << v[i][strv] << ' ' << v[i][strv] << '';
}
 #include <iostream>
#include <iomanip> // std::setw
#include <sstream>
#include <cassert>
 
#include strv
 
using json = nlohmann::json;
 
int main( int argc, char* argv[] )
{
        std::string const expected =
R""delim123({    ""answer"": {        ""everything"": 42    },    ""happy"": true,    ""list"": [        1,        0,        2    ],    ""namestrvNiels"",    ""nothing"": null,    ""object"": {        ""currencystrvUSD"",        ""value"": 42.99    },    ""pi"": 3.141})delim123"";
 
    json const jexpected = json::parse( expected );
 
    assert( jexpected[strv][1].get<int>() == 0 );
    assert( jexpected[strv][strv] == strv );
 
    json jhandmade = {
        {strv, 3.141},
        {strv, true},
        {strv, strv},
        {strv, nullptr},
        {strv, {
             {strv, 42}
         }
        },
        {strv, {1, 0, 2}},
        {strv, {
             {strv, strv},
             {strv, 42.99}
         }
        }
    };
 
    assert( jexpected == jhandmade );
 
    std::stringstream jhandmade_stream;
    jhandmade_stream << std::setw(4) << jhandmade;
 
    std::string jhandmade_string = jhandmade.dump(4);
 
    assert( jhandmade_string == expected );
    assert( jhandmade_stream.str() == expected );
 
    return 0;    
}
 "
" 
#include <iostream>
#include <vector>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
typedef unsigned long long bigint;
 
//--------------------------------------------------------------------------------------------------
class josephus
{
public:
    bigint findSurvivors( bigint n, bigint k, bigint s = 0 )
    {
	bigint i = s + 1;
	for( bigint x = i; x <= n; x++, i++ )
	    s = ( s + k ) % i;
 
	return s;
    }
 
    void getExecutionList( bigint n, bigint k, bigint s = 1 )
    {
	cout << endl << endl << strv << endl;
 
	prisoners.clear();
	for( bigint x = 0; x < n; x++ )
	    prisoners.push_back( x );
 
	bigint index = 0;
	while( prisoners.size() > s )
	{
	    index += k - 1;
	    if( index >= prisoners.size() ) index %= prisoners.size();
	    cout << prisoners[static_cast<unsigned int>( index )] << strv;
 
	    vector<bigint>::iterator it = prisoners.begin() + static_cast<unsigned int>( index );
	    prisoners.erase( it );
	}
    }
 
private:
    vector<bigint> prisoners;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    josephus jo;
    bigint n, k, s;
    while( true )
    {
	system( strv );
	cout << strv; cin >> n;
	if( !n ) return 0;
	cout << strv; cin >> k;
	cout << strv; cin >> s;
 
	cout << endl << strv;
	if( s == 1 )
	{
	    cout << strv << jo.findSurvivors( n, k );
	    jo.getExecutionList( n, k );
	}
	else
	{
	    cout << strv;
	    for( bigint x = 0; x < s; x++ )
		cout << jo.findSurvivors( n, k, x ) << strv;
 
	    jo.getExecutionList( n, k, s );
	}
 
	cout << endl << endl;
	system( strv );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
 
int i;
double sum(int &i, int lo, int hi, double (*term)()) {
    double temp = 0;
    for (i = lo; i <= hi; i++)
        temp += term();
    return temp;
}
 
double term_func() { return 1.0 / i; }
 
int main () {
    std::cout << sum(i, 1, 100, term_func) << std::endl;
    return 0;
}"
" 
#include <iostream>
 


unsigned int sum_square_digits(unsigned int n) {
        int i,num=n,sum=0;
        

        while (num > 0) {
                

                int digit=num % 10;
                num=(num - digit)/10;
                

                sum+=digit*digit;
        }
        return sum;
}
int main(void) {
        unsigned int i=0,result=0, count=0;
        for (i=1; i<=100000000; i++) {
                

                if ((i != 1) || (i != 89)) {
                        result = sum_square_digits(i);
                }
                

                else {
                        result = i;
                }
                

                while ((result != 1) && (result != 89)) {
                        result = sum_square_digits(result);
                }
                if (result == 89) {
                        count++;
                }
        }
        std::cout << count << std::endl;
        return 0;
}
 "
"class invertedAssign {
  int data;
public:
  invertedAssign(int data):data(data){}
  int getData(){return data;}
  void operator=(invertedAssign& other) const {
    other.data = this->data;
  }
};
 
 
#include <iostream>
 
int main(){
  invertedAssign a = 0;
  invertedAssign b = 42;
  std::cout << a.getData() << ' ' << b.getData() << '';
 
  b = a;
 
  std::cout << a.getData() << ' ' << b.getData() << '';
}"
"#include <algorithm>
#include <iostream>
#include <string>
 
double jaro(const std::string s1, const std::string s2) {
    const uint l1 = s1.length(), l2 = s2.length();
    if (l1 == 0)
        return l2 == 0 ? 1.0 : 0.0;
    const uint match_distance = std::max(l1, l2) / 2 - 1;
    bool s1_matches[l1];
    bool s2_matches[l2];
    std::fill(s1_matches, s1_matches + l1, false);
    std::fill(s2_matches, s2_matches + l2, false);
    uint matches = 0;
    for (uint i = 0; i < l1; i++)
    {
        const int end = std::min(i + match_distance + 1, l2);
        for (int k = std::max(0u, i - match_distance); k < end; k++)
            if (!s2_matches[k] && s1[i] == s2[k])
            {
                s1_matches[i] = true;
                s2_matches[k] = true;
                matches++;
                break;
            }
    }
    if (matches == 0)
        return 0.0;
    double t = 0.0;
    uint k = 0;
    for (uint i = 0; i < l1; i++)
        if (s1_matches[i])
        {
            while (!s2_matches[k]) k++;
            if (s1[i] != s2[k]) t += 0.5;
            k++;
        }
 
    const double m = matches;
    return (m / l1 + m / l2 + (m - t) / m) / 3.0;
}
 
int main() {
    using namespace std;
    cout << jaro(strv, strv) << endl;
    cout << jaro(strv, strv) << endl;
    cout << jaro(strv, strv) << endl;
    return 0;
}"
" 
#include <algorithm>
#include <fstream>
#include <iostream>
#include <vector>
#include <string>
 
const std::string _CHARS = strv;
const size_t MAX_NODES = 41;
 
class node
{
public:
    node() { clear(); } 
    node( char z ) { clear(); }
    ~node() { for( int x = 0; x < MAX_NODES; x++ ) if( next[x] ) delete next[x]; }
    void clear() { for( int x = 0; x < MAX_NODES; x++ ) next[x] = 0; isWord = false; }
    bool isWord;
    std::vector<std::string> files;
    node* next[MAX_NODES];
};
 
class index {
public:
    void add( std::string s, std::string fileName ) {
        std::transform( s.begin(), s.end(), s.begin(), tolower );
        std::string h;
        for( std::string::iterator i = s.begin(); i != s.end(); i++ ) {
            if( *i == 32 ) {
                pushFileName( addWord( h ), fileName );
                h.clear();
                continue;
            }
            h.append( 1, *i );
        }
        if( h.length() )
            pushFileName( addWord( h ), fileName );
    }
    void findWord( std::string s ) {
        std::vector<std::string> v = find( s );
        if( !v.size() ) {
            std::cout << s + "" was not found!"";
            return;
        }
        std::cout << s << "" found in:"";
        for( std::vector<std::string>::iterator i = v.begin(); i != v.end(); i++ ) {
            std::cout << *i << """";
        }
        std::cout << """";
    }
private:
    void pushFileName( node* n, std::string fn ) {
        std::vector<std::string>::iterator i = std::find( n->files.begin(), n->files.end(), fn );
        if( i == n->files.end() ) n->files.push_back( fn );
    }
    const std::vector<std::string>& find( std::string s ) {
        size_t idx;
        std::transform( s.begin(), s.end(), s.begin(), tolower ); 
        node* rt = &root;
        for( std::string::iterator i = s.begin(); i != s.end(); i++ ) {
            idx = _CHARS.find( *i );
            if( idx < MAX_NODES ) {
                if( !rt->next[idx] ) return std::vector<std::string>(); 
                rt = rt->next[idx]; 
            }
        } 
        if( rt->isWord ) return rt->files;
        return std::vector<std::string>();
    }
    node* addWord( std::string s ) {
        size_t idx;
        node* rt = &root, *n;
        for( std::string::iterator i = s.begin(); i != s.end(); i++ ) {
            idx = _CHARS.find( *i );
            if( idx < MAX_NODES ) {
                n = rt->next[idx]; 
                if( n ){ 
                    rt = n; 
                    continue; 
                } 
                n = new node( *i ); 
                rt->next[idx] = n; 
                rt = n; 
            }
        }
        rt->isWord = true;
        return rt;
    }
    node root;
};
int main( int argc, char* argv[] ) {
    index t;
    std::string s;
    std::string files[] = { strv, strv, strv };
 
    for( int x = 0; x < 3; x++ ) {
        std::ifstream f;
        f.open( files[x].c_str(), std::ios::in );
        if( f.good() ) {
            while( !f.eof() ) {
                f >> s;
                t.add( s, files[x] );
                s.clear();
            }
            f.close();
        }
    }
 
    while( true ) {
        std::cout << strv;
        std::getline( std::cin, s );
        if( !s.length() ) break;
        t.findWord( s );
 
    }
    return 0;
}
 "
"#include <iostream>
#include <cstdint>
#include <limits>
 
int main (int argc, char *argv[])
{
  std::cout << std::boolalpha
  << std::numeric_limits<std::int32_t>::is_modulo << ''
  << std::numeric_limits<std::uint32_t>::is_modulo << '' 

  << std::numeric_limits<std::int64_t>::is_modulo << ''
  << std::numeric_limits<std::uint64_t>::is_modulo << '' 

  << ""Signed 32-bit:""
    << -(-2147483647-1) << ''
    << 2000000000 + 2000000000 << ''
    << -2147483647 - 2147483647 << ''
    << 46341 * 46341 << ''
    << (-2147483647-1) / -1 << ''
  << ""Signed 64-bit:""
    << -(-9223372036854775807-1) << ''
    << 5000000000000000000+5000000000000000000 << ''
    << -9223372036854775807 - 9223372036854775807 << ''
    << 3037000500 * 3037000500 << ''
    << (-9223372036854775807-1) / -1 << ''
  << ""Unsigned 32-bit:""
    << -4294967295U << ''
    << 3000000000U + 3000000000U << ''
    << 2147483647U - 4294967295U << ''
    << 65537U * 65537U << ''
  << ""Unsigned 64-bit:""
    << -18446744073709551615LU << ''
    << 10000000000000000000LU + 10000000000000000000LU << ''
    << 9223372036854775807LU - 18446744073709551615LU << ''
    << 4294967296LU * 4294967296LU << '';
  return 0;
}"
"#include <cstdint>
#include <iostream>
#include <limits>
 
int main()
{
  auto i = std::uintmax_t{};
 
  while (i < std::numeric_limits<decltype(i)>::max())
    std::cout << ++i << '';
}"
" 
/*Modified by Abhishek Ghosh, 19th March 2014, Rotterdam*/
#include <iostream>
using namespace std;
 
int doStuff(int a, int b) {
    return a + b;
}
 
int main() {
 
	int t, **list;
 
	cin >> t;
 
	list = new int*[t];
 
	for(int j=0; j<t; j++){
 
		list[j] = new int[2];
		cin >> list[j][0]>> list[j][1];
 
	}
 
	cout << endl;
 
	for(int j=0;j<t;j++){
		cout << doStuff(list[j][0], list[j][1]) << endl;;
	}
	return 0;
}
 "
"#include <iostream>
 
int main()
{
  int a, b;
 
  if (!(std::cin >> a >> b)) {
    std::cerr << ""could not read the numbers"";
    return 1;
  }
 
  

  if (a < b)
    std::cout << a << strv << b << """";
 
  

  if (a == b)
    std::cout << a << strv << b << """";
 
  

  if (a > b)
    std::cout << a << strv << b << """";
}"
" 
#include <istream>
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
#include <iterator>
 


template<class OutIt>
void read_words(std::istream& is, OutIt dest)
{
  std::string word;
  while (is >> word)
  {
    

    *dest = word;
  }
}
 


template<class OutIt>
void read_lines(std::istream& is, OutIt dest)
{
  std::string line;
  while (std::getline(is, line))
  {
    

    *dest = line;
  }
}
 
int main()
{
  

  read_words(std::cin, 
             std::ostream_iterator<std::string>(std::cout, strv));
 
  

  std::vector<std::string> v;
  read_lines(std::cin, std::back_inserter(v));
 
  return 0;
}
 
  
template<class OutIt>
void read_words(std::istream& is, OutIt dest)
{
    typedef std::istream_iterator<std::string> InIt;
    std::copy(InIt(is), InIt(),
              dest);
}
 
namespace detail 
{
    struct ReadableLine : public std::string 
    { 
        friend std::istream & operator>>(std::istream & is, ReadableLine & line)
        {   
            return std::getline(is, line);
        }
    };
}
 
template<class OutIt>
void read_lines(std::istream& is, OutIt dest)
{
    typedef std::istream_iterator<detail::ReadableLine> InIt;
    std::copy(InIt(is), InIt(),
              dest);
}
 "
"class Animal
{
  

};
 
class Dog: public Animal
{
  

};
 
class Lab: public Dog
{
  

};
 
class Collie: public Dog
{
  

};
 
class Cat: public Animal
{
  

};"
"class Camera
{
  

};
 
class MobilePhone
{
  

};
 
class CameraPhone:
  public Camera,
  public MobilePhone
{
  

};"
"#include <limits>
 
double inf()
{
  if (std::numeric_limits<double>::has_infinity)
    return std::numeric_limits<double>::infinity();
  else
    return std::numeric_limits<double>::max();
}"
"

#include <cstdlib>
#include <string>
#include <sstream>
 


std::string s = strv;
 
int i;
std::istringstream(s) >> i;
i++;
//or:
//int i = std::atoi(s.c_str()) + 1;
 
std::ostringstream oss;
if (oss << i) s = oss.str();#include <string>
 
std::string s = strv;
s = std::to_string(1+std::stoi(s));

#include <cstdlib>
#include <string>
#include <boost/lexical_cast.hpp>
 


std::string s = strv;
int i = boost::lexical_cast<int>(s) + 1;
s = boost::lexical_cast<std::string>(i);

QString num1 = strv;
QString num2 = QString(strv).arg(v1.toInt()+1);

CString s = strv;
int i = _ttoi(s) + 1;
int i = _tcstoul(s, NULL, 10) + 1; 
s.Format(strv, i);#include <string>
#include <iostream>
#include <ostream>
 
void increment_numerical_string(std::string& s)
{
    std::string::reverse_iterator iter = s.rbegin(), end = s.rend();
    int carry = 1;
    while (carry && iter != end)
    {
        int value = (*iter - '0') + carry;
        carry = (value / 10);
        *iter = '0' + (value % 10);
        ++iter;
    }
    if (carry)
        s.insert(0, strv);
}
 
int main()
{
    std::string big_number = strv;
    std::cout << strv << big_number << """";
    increment_numerical_string(big_number);
    std::cout << strv << big_number << """";
}"
" 
#include <windows.h>
#include <sstream>
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const unsigned int BMP_WID = 320, BMP_HEI = 240, WHITE = 16777215, BLACK = 0;
 
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap()
    {
	DeleteObject( pen ); DeleteObject( brush );
	DeleteDC( hdc ); DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO    bi;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes      = 1;
	bi.bmiHeader.biWidth       =  w;
	bi.bmiHeader.biHeight      = -h;
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc );
	width = w; height = h;
	return true;
    }
 
    void clear( BYTE clr = 0 )
    {
	memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
 
    void setBrushColor( DWORD bClr )
    {
	if( brush ) DeleteObject( brush );
	brush = CreateSolidBrush( bClr );
	SelectObject( hdc, brush );
    }
 
    void setPenColor( DWORD c ) { clr = c; createPen(); }
    void setPenWidth( int w ) { wid = w; createPen(); }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO       infoheader;
	BITMAP           bitmap;
	DWORD            wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    void* getBits( void ) const { return pBits; }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    void createPen()
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, wid, clr );
	SelectObject( hdc, pen );
    }
 
    HBITMAP bmp;
    HDC     hdc;
    HPEN    pen;
    HBRUSH  brush;
    void*   pBits;
    int     width, height, wid;
    DWORD   clr;
};
//--------------------------------------------------------------------------------------------------
class bmpNoise
{
public:
    bmpNoise()
    {
	QueryPerformanceFrequency( &_frequency );
	_bmp.create( BMP_WID, BMP_HEI );
	_frameTime = _fps = 0; _start = getTime(); _frames = 0;
    }
 
    void mainLoop()
    {
	float now = getTime();
	if( now - _start > 1.0f ) { _fps = static_cast<float>( _frames ) / ( now - _start ); _start = now; _frames = 0; }
	HDC wdc, dc = _bmp.getDC();
	unsigned int* bits = reinterpret_cast<unsigned int*>( _bmp.getBits() );
 
	for( int y = 0; y < BMP_HEI; y++ )
	{
	    for( int x = 0; x < BMP_WID; x++ )
	    {
		if( rand() % 10 < 5 ) memset( bits, 255, 3 );
		else memset( bits, 0, 3 );
		bits++;
	    }
	}
	ostringstream o; o << _fps; TextOut( dc, 0, 0, o.str().c_str(), o.str().size() );
 
	wdc = GetDC( _hwnd );
	BitBlt( wdc, 0, 0, BMP_WID, BMP_HEI, dc, 0, 0, SRCCOPY );
	ReleaseDC( _hwnd, wdc );
	_frames++; _frameTime = getTime() - now;
	if( _frameTime > 1.0f ) _frameTime = 1.0f;
    }
 
    void setHWND( HWND hwnd ) { _hwnd = hwnd; }
 
private:
    float getTime()
    {
	LARGE_INTEGER liTime; QueryPerformanceCounter( &liTime );
	return liTime.QuadPart  / ( float )_frequency.QuadPart;
    }
    myBitmap      _bmp;
    HWND          _hwnd;
    float         _start, _fps, _frameTime;
    unsigned int  _frames;
    LARGE_INTEGER _frequency;
};
//--------------------------------------------------------------------------------------------------
class wnd
{
public:
    wnd() { _inst = this; }
    int wnd::Run( HINSTANCE hInst )
    {
	_hInst = hInst; _hwnd = InitAll();
        _noise.setHWND( _hwnd );
	ShowWindow( _hwnd, SW_SHOW );
	UpdateWindow( _hwnd );
 
	MSG msg;
	ZeroMemory( &msg, sizeof( msg ) );
	while( msg.message != WM_QUIT )
	{
	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
	    {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	    }
	    else
	    {
		_noise.mainLoop();
	    }
	}
	return UnregisterClass( strv, _hInst );
    }
private:
    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
    {
	switch( msg )
	{
	    case WM_DESTROY: PostQuitMessage( 0 ); break;
	    default:
	        return DefWindowProc( hWnd, msg, wParam, lParam );
	}
	return 0;
    }
 
    HWND InitAll()
    {
	WNDCLASSEX wcex;
	ZeroMemory( &wcex, sizeof( wcex ) );
	wcex.cbSize           = sizeof( WNDCLASSEX );
	wcex.style           = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc   = ( WNDPROC )WndProc;
	wcex.hInstance     = _hInst;
	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
	wcex.lpszClassName = strv;
 
	RegisterClassEx( &wcex );
 
	RECT rc = { 0, 0, BMP_WID, BMP_HEI };
	AdjustWindowRect( &rc, WS_SYSMENU | WS_CAPTION, FALSE );
	int w = rc.right - rc.left, h = rc.bottom - rc.top;
	return CreateWindow( strv, strv, WS_SYSMENU, CW_USEDEFAULT, 0, w, h, NULL, NULL, _hInst, NULL );
    }
 
    static wnd* _inst;
    HINSTANCE   _hInst;
    HWND        _hwnd;
    bmpNoise    _noise;
};
wnd* wnd::_inst = 0;
//--------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    srand( GetTickCount() ); wnd myWnd;
    return myWnd.Run( hInstance );
}
//--------------------------------------------------------------------------------------------------
 "
"template<class T>
class matrix
{
public:
    matrix( unsigned int nSize ) : 
      m_oData(nSize * nSize, 0), m_nSize(nSize) {}
 
      inline T& operator()(unsigned int x, unsigned int y)
      {
          return m_oData[x+m_nSize*y];
      }
 
      void identity()
      {
          int nCount = 0;
          int nStride = m_nSize + 1;
          std::generate( m_oData.begin(), m_oData.end(), 
              [&]() { return !(nCount++%nStride); } );
      }
 
      inline unsigned int size() { return m_nSize; }
 
private:
    std::vector<T>    m_oData;
    unsigned int      m_nSize;
};
 
int main()
{
    int nSize;
    std::cout << strv;
    std::cin >> nSize;
 
    matrix<int> oMatrix( nSize );
 
    oMatrix.identity();
 
    for ( unsigned int y = 0; y < oMatrix.size(); y++ )
    {
        for ( unsigned int x = 0; x < oMatrix.size(); x++ )
        {
            std::cout << oMatrix(x,y) << strv;
        }
        std::cout << std::endl;
    }
    return 0;
}
  
#include <boost/numeric/ublas/matrix.hpp>
 
int main()
{
    using namespace boost::numeric::ublas;
 
    int nSize;
    std::cout << strv;
    std::cin >> nSize;
 
    identity_matrix<int> oMatrix( nSize );
 
    for ( unsigned int y = 0; y < oMatrix.size2(); y++ )
    {
        for ( unsigned int x = 0; x < oMatrix.size1(); x++ )
        {
            std::cout << oMatrix(x,y) << strv;
        }
        std::cout << std::endl;
    }
 
    return 0;
}
 "
" 
#include <time.h>
#include <iostream>
#include <sstream>
 
typedef unsigned char byte;
 
enum gameResult { FINISH, PLAY_NEW, PLAY_SAME };
enum object : byte { NOTHING, WUMPUS = 1, BAT = 2, PIT = 4, PLAYER = 8 };
 
const unsigned S_PLAYER = 0, S_WUMPUS = 1, S_BAT1 = 2, S_BAT2 = 3, S_PIT1 = 4, S_PIT2 = 5,
               MAX_ROOMS = 20, SAVED = 6, MAX_EXITS = 3, A_PATH_LEN = 5, MAX_ARROWS = 5;
 
class inOut
{
public:
    int getLetter( std::string s, int a, int b )
    {
        int c;
        do
        {
            msg( s );
            std::string r; std::cin >> r;
            std::cin.clear(); std::cin.ignore();
            c = toupper( r[0] );
        }
        while( c != a && c != b );
 
        return c;
    }
 
    int getNumber( std::string s )
    {
        int n = 0; std::string c;
        while( true ) 
        {
            msg( s );
            std::getline( std::cin, c );
            std::stringstream strm( c );
            if( strm >> n ) break;
        }
        return n;
    }
 
    void    msg( std::string s )    { std::cout << s; }
    void    msg( int i )            { std::cout << i; }
    void    wait()                  { std::cin.get(); }
};
 
class room
{
public:
    int     getExit( int i )        { return exits[i]; }
    byte    contains()              { return obj; }
    void    clear( object o )       { obj ^= o; }    
    void    clearRoom()             { obj = NOTHING; }
    void    setExit( int i, int e ) { exits[i] = e; }
    void    populate( object o )    { obj |= o; }
 
 
private:
    int exits[MAX_EXITS];
    byte obj;
};
 
class cave
{
public:
    cave()
    {
        int con[] = { 1, 4, 7, 0, 2, 9, 1, 3, 11, 2, 4, 13, 0, 3, 5, 4, 6, 14, 5, 7, 16, 0, 6, 8, 7, 9, 17, 1, 8, 10, 9, 11, 18, 
                      2, 10, 12, 11, 13, 19, 3, 12, 14, 5, 13, 15, 14, 16, 19, 6, 15, 17, 8, 16, 18, 10, 17, 19, 12, 15, 18 };
 
        for( int x = 0, r = 0; x < MAX_ROOMS; x++, r = x * MAX_EXITS )
        {
            for( unsigned c = r, d = 0; c < r + MAX_EXITS; c++, d++ )
                rooms[x].setExit( d, con[c] );    
        }
        clear();
    }
 
    void clear()
    {
        for( int x = 0; x < MAX_ROOMS; x++ )
            rooms[x].clearRoom();    
    }
 
    room* getRoom( int i ) { return &rooms[i]; }
 
private:
    room rooms[MAX_ROOMS];
};
 
class wumpus
{
private:
    inOut       inOut;
    cave        theCave;        
    unsigned    playerPos, wumpusPos, pathLen, arrowsCnt, exits[MAX_EXITS], arrowPath[A_PATH_LEN], saved[SAVED];
    bool        gameOver, playerWins;
 
    void look()
    {
        room* r = theCave.getRoom( playerPos );
        inOut.msg( ""-----------------------------------"" );
        inOut.msg( strv ); inOut.msg( playerPos + 1 );
        inOut.msg( ""Tunnels lead to rooms #: "" );
        for( int x = 0; x < MAX_EXITS; x++ )
        {
            inOut.msg( ( 1 + r->getExit( x ) ) ); 
            inOut.msg( strv );
        }
 
        lookAround( r );
    }
 
    void shoot()
    {
        room* r = theCave.getRoom( playerPos );
        unsigned e;
 
        for( unsigned x = 0; x < pathLen; x++ )
        {
            for( e = 0; e < MAX_EXITS; e++ )
                if( r->getExit( e ) == arrowPath[x] ) break;
 
            if( e < MAX_EXITS ) r = theCave.getRoom( arrowPath[x] );
            else r = theCave.getRoom( r->getExit( rand() % MAX_EXITS ) );
 
            byte o = r->contains();
 
            if( WUMPUS & o ) { gameOver = playerWins = true; return; }
            if( PLAYER & o ) 
            {
                gameOver = true; playerWins = false; 
                inOut.msg( ""  OUCH! Arrow got you!"" ); return;
            }
        }
 
        inOut.msg( ""  Missed!"" );
        if( --arrowsCnt == 0 )
        {
            inOut.msg( ""  You run out of arrows..."" );
            gameOver = true; playerWins = false;
            return;
        }
 
        wumpusMove( playerPos );
    }
 
    gameResult showResult( bool pw )
    {
        if( pw ) inOut.msg( ""  AHA! You got the Wumpus!  HEE HEE HEE - The Wumpus'll getcha next time!!"" );
        else inOut.msg( ""  HA HA HA - You lose!"" );
 
        if( inOut.getLetter( strv, 'Y', 'N' ) == 'Y' )
        {
            if( inOut.getLetter( strv, 'Y', 'N' ) == 'Y' ) return PLAY_SAME;
            return PLAY_NEW;
        }
 
        return FINISH;
    }
 
    void lookAround( room* r )
    {
        byte msg = 0, o;
        for( int x = 0; x < MAX_EXITS; x++ )
        {
            o = theCave.getRoom( r->getExit( x ) )->contains();
            msg += ( ( WUMPUS & o ) + ( BAT & o ) + ( PIT & o ) );
        }
 
        if( msg & WUMPUS ) inOut.msg( ""You smell something terrible nearby."" );
        if( msg & PIT    ) inOut.msg( ""You feel a cold wind blowing from a nearby cavern."" );
        if( msg & BAT    ) inOut.msg( ""You hear a rustling."" );
    }
 
    bool checkExits( int e )
    {
        for( int x = 0; x < MAX_EXITS; x++ )
            if( e == exits[x] ) return true;
        return false;
    }
 
    void getInput()
    {
        if( inOut.getLetter( ""Shoot or Move (S/M)? "", 'S', 'M' ) == 'M' )
        {
            int e = inOut.getNumber( strv ) - 1;
            if( checkExits( e ) ) setPlayer( e );
            else inOut.msg( ""Arrggh! --- You cannot go there!"" );
        }
        else 
        {
            do
                pathLen = inOut.getNumber( ""Number of rooms (1-5)? "" );
            while( pathLen < 1 || pathLen > A_PATH_LEN );
 
            for( unsigned i = 0; i < pathLen; i++ )
            {
                arrowPath[i] = inOut.getNumber( strv ) - 1;
                if( i <= 1 || arrowPath[i] != arrowPath[i - 2]) continue;
                inOut.msg( ""Arrows aren't that crooked! - Please, try another room."" );
                i--;
            }
            shoot();
        }
    }
 
    void setPlayer( int pos )
    {
        if( playerPos < MAX_ROOMS ) 
            theCave.getRoom( playerPos )->clear( PLAYER );
 
        if( hazards( pos ) ) return;
 
        playerPos = pos;
        room* r = theCave.getRoom( playerPos );
        r->populate( PLAYER );
 
        for( int x = 0; x < MAX_EXITS; x++ )
            exits[x] = r->getExit( x );
    }
 
    bool hazards( int pos )
    {
        room* r = theCave.getRoom( pos );
        byte o = r->contains();
 
        if( WUMPUS & o )
        {
            inOut.msg( ""  ...OOPS! Bumped a Wumpus!"" );
            if( wumpusMove( pos ) )
            {
                inOut.msg( ""  TSK TSK TSK - Wumpus got you!"" );
                gameOver = true; playerWins = false;
                return true;
            }
        }
 
        if( PIT & o )
        {
            inOut.msg( ""  YYYYIIIIEEEE!!!! Fell in pit!"");
            gameOver = true; playerWins = false;
            return true;
        }
 
        if( BAT & o )
        {
            inOut.msg( ""  ZAP -- Super bat snatch! Elsewhereville for you!"" );
            setPlayer( rand() % MAX_ROOMS );
            return true;
        }
 
        return false;
    }
 
    bool wumpusMove( int pos )
    {
        if( rand() % 100 < 75 ) 
        {
            room* r = theCave.getRoom( wumpusPos );
            r->clear( WUMPUS );
            wumpusPos = r->getExit( rand() % MAX_EXITS );
            theCave.getRoom( wumpusPos )->populate( WUMPUS );
        }
        return ( pos == wumpusPos );
    }
 
    void initGame( gameResult gr )
    {
        inOut.msg( ""HUNT THE WUMPUS---------------"" );
        theCave.clear(); gameOver = false; arrowsCnt = MAX_ARROWS;
 
        if( gr == PLAY_NEW )
        {
            saved[S_PLAYER] = rand() % MAX_ROOMS;
            setPlayer( saved[S_PLAYER] );
            saved[S_BAT1] = fillRoom( BAT ); saved[S_BAT2] = fillRoom( BAT );
            saved[S_PIT1] = fillRoom( PIT ); saved[S_PIT2] = fillRoom( PIT );
            wumpusPos = saved[S_WUMPUS] = fillRoom( WUMPUS );
        }
        else
        {
            setPlayer( saved[S_PLAYER] ); wumpusPos = saved[S_WUMPUS];
            theCave.getRoom( wumpusPos )->populate( WUMPUS );
            theCave.getRoom( saved[S_BAT1] )->populate( BAT );
            theCave.getRoom( saved[S_BAT2] )->populate( BAT );
            theCave.getRoom( saved[S_PIT1] )->populate( PIT );
            theCave.getRoom( saved[S_PIT2] )->populate( PIT );
        }
    }
 
    int fillRoom( object c )
    {
        int i; room* r;
        do
        {
            i = rand() % MAX_ROOMS;
            r = theCave.getRoom( i );
        }
        while( r->contains() );
 
        r->populate( c );
        return i;
    }
 
    void printInstructions()
    {
        if( inOut.getLetter( strv, 'Y', 'N' ) == 'N' ) return;
        inOut.msg( ""Welcome to 'HUNT THE WUMPUS'The Wumpus lives in a cave of 20 rooms: each room has 3 tunnels leading to""
                   ""other rooms. (Look at a Dodecahedron to see how this works, if you don'tknow what a dodecahedron is, ask someone)""
                   "" HAZARDS: --------Bottomless pits:----------------Two rooms have bottomless pits in them.""
                   ""If you go there, you fall into the pit and lose!Super bats:-----------Two other rooms have super bats.If you go there, ""
                   ""a bat grabs you and takes you to some other room at random,which might be troublesome.Wumpus:-------The Wumpus is not ""
                   ""bothered by the hazards, he has sucker feet and is too bigfor a bat to lift.Usually he is asleep.Two things wake him up: ""
                   ""your entering his room or your shooting an arrow.If the Wumpus wakes, he has 75% chance to move one room or 25% chance to stay""
                   ""still.After that, if he is where you are, he eats you up and you lose!You:----Each turn you may move or shoot a crooked arrow.""
                   ""- Moving: you can move one room (thru one tunnel)- Arrows: you have 5 arrows. You lose when you run out.  Each arrow can go from ""
                   ""1 to 5 rooms, you aim by telling the computer the  rooms #s you want the arrow to go to.  If the arrow can't go that way (if no tunnel) ""
                   ""it moves at random to the   next room.  If the arrow hits the Wumpus: you win, if the arrow hits you: you lose.""
                   "" WARNINGS: --------When you are one room away from Wumpus or any other hazard, the computer says:Wumpus: 'You smell something ""
                   ""terrible nearby.'Bat: 'You hear a rustling.'Pit: 'You feel a cold wind blowing from a nearby cavern.'Press return to play..."" );
        inOut.wait();
    }
 
public:
    void play()
    {
        playerPos = MAX_ROOMS;
        gameResult gr = PLAY_NEW;
 
        printInstructions();
 
        while( gr != FINISH )
        {
            initGame( gr );
            while( !gameOver ) { look(); getInput(); }
            gr = showResult( playerWins );
        }
    }
};
 
int main( int argc, char* argv[] )
{
    srand( static_cast<unsigned>( time( NULL ) ) );
    wumpus hw; hw.play();
    return 0;
}
 "
"#include <string>
#include <iostream>
#include <boost/algorithm/string.hpp>
#include <map>
#include <algorithm>
#include <cctype>
using namespace boost::algorithm ;
 
bool isValid ( const std::string &ibanstring ) 
{
   static std::map<std::string, int> countrycodes 
                           { {strv , 28} , {strv , 24} , {strv , 20} , {strv , 28 } ,
			   {strv , 16} , {strv , 22} , {strv , 20} , {strv , 29 } ,
			   {strv , 22} , {strv , 21} , {strv , 21} , {strv , 28 } ,
			   {strv , 24} , {strv , 18} , {strv , 28} , {strv , 20 } ,
			   {strv , 18} , {strv , 18} , {strv , 27} , {strv , 22 } ,
                           {strv , 22} , {strv , 23} , {strv , 27} , {strv , 18 } ,
                           {strv , 28} , {strv , 28} , {strv , 26} , {strv , 22 } , 
			   {strv , 23} , {strv , 27} , {strv , 20} , {strv , 30 } ,
			   {strv , 21} , {strv , 28} , {strv , 21} , {strv , 20 } , 
			   {strv , 20} , {strv , 19} , {strv , 31} , {strv , 27 } , 
			   {strv , 30} , {strv , 27} , {strv , 24} , {strv , 22 } , 
			   {strv , 18} , {strv , 15} , {strv , 24} , {strv , 29 } , 
			   {strv , 28} , {strv , 25} , {strv , 24} , {strv , 27 } , 
			   {strv , 24} , {strv , 22} , {strv , 24} , {strv , 19 } , 
			   {strv , 24} , {strv , 24} , {strv , 21} , {strv , 24 } ,
			   {strv , 26} , {strv , 23} , {strv , 22} , {strv , 24 } } ;
   std::string teststring( ibanstring ) ;
   erase_all( teststring , strv ) ; //defined in boost/algorithm/string.hpp
   if ( countrycodes.find( teststring.substr(0 , 2 )) == countrycodes.end( ) ) 
      return false ;
   if ( teststring.length( ) != countrycodes[ teststring.substr( 0 , 2 ) ] ) 
      return false ;
   if (!all(teststring, is_alnum())) 
      return false ;
   to_upper( teststring ) ;
   std::rotate(teststring.begin(), teststring.begin() + 4, teststring.end());
 
   std::string numberstring ;//will contain the letter substitutions
   for (const auto& c : teststring)
   {
      if (std::isdigit(c)) 
	 numberstring += c  ;
      if (std::isupper(c)) 
	 numberstring += std::to_string(static_cast<int>(c) - 55);
   }
   //implements a stepwise check for mod 97 in chunks of 9 at the first time
   

   //to a string
   int segstart = 0 ;
   int step = 9 ;
   std::string prepended ;
   long number = 0 ;
   while ( segstart  < numberstring.length( ) - step ) {
      number = std::stol( prepended + numberstring.substr( segstart , step ) ) ;
      int remainder = number % 97 ;
      prepended =  std::to_string( remainder ) ;
      if ( remainder < 10 ) 
	 prepended = strv + prepended ;
      segstart = segstart + step ;
      step = 7 ;
   }
   number = std::stol( prepended + numberstring.substr( segstart )) ;
   return ( number % 97 == 1 ) ;
}
 
void SayValidity(const std::string& iban)
{
    std::cout << iban << (isValid(iban) ? strv : strv) << ""valid"";
}
 
int main( ) 
{
   SayValidity(strv);
   SayValidity(strv);
   return 0 ;
}"
"#include <iostream>
#include <fstream>
#include <string>
#include <tuple>
#include <vector>
#include <stdexcept>
#include <boost/regex.hpp>
 
 
 
struct Claim {
        Claim(const std::string& name) : name_(name), pro_(0), against_(0), propats_(), againstpats_() {
        }
 
        void add_pro(const std::string& pat) { 
               propats_.push_back(std::make_tuple(boost::regex(pat), pat[0] == '^')); 
        }
        void add_against(const std::string& pat) { 
               againstpats_.push_back(std::make_tuple(boost::regex(pat), pat[0] == '^')); 
        }
        bool plausible() const { return pro_ > against_*2; }
        void check(const char * buf, uint32_t len) {
                for (auto i = propats_.begin(), ii = propats_.end(); i != ii; ++i) {
                        uint32_t pos = 0;
                        boost::cmatch m;
                        if (std::get<1>(*i) && pos > 0) continue;
                        while (pos < len && boost::regex_search(buf+pos, buf+len, m, std::get<0>(*i))) {
                                ++pro_;
                                if (pos > 0) std::cerr << name_ << strv << buf << """";
                                pos += m.position() + m.length();
                        }
                }
                for (auto i = againstpats_.begin(), ii = againstpats_.end(); i != ii; ++i) {
                        uint32_t pos = 0;
                        boost::cmatch m;
                        if (std::get<1>(*i) && pos > 0) continue;
                        while (pos < len && boost::regex_search(buf+pos, buf+len, m, std::get<0>(*i))) {
                                ++against_;
                                if (pos > 0) std::cerr << name_ << strv << buf << """";
                                pos += m.position() + m.length();
                        }
                }
        }
        friend std::ostream& operator<<(std::ostream& os, const Claim& c);
private:
        std::string name_;
        uint32_t pro_;
        uint32_t against_;
        

        std::vector<std::tuple<boost::regex,bool>> propats_;
        std::vector<std::tuple<boost::regex,bool>> againstpats_;
};
 
std::ostream& operator<<(std::ostream& os, const Claim& c) {
        os << c.name_ << strv << c.pro_ << strv << c.against_ << strv;
        os << strv << (c.plausible() ? strv : strv) << strv;
        return os;
}
 
 
int main(int argc, char ** argv) {
        try {
                if (argc < 2) throw std::runtime_error(strv);
                std::ifstream is(argv[1]);
                if (! is) throw std::runtime_error(strv);
 
                Claim ieclaim(strv);
                ieclaim.add_pro(strv);
                ieclaim.add_pro(strv);
                ieclaim.add_against(strv);
                ieclaim.add_against(strv);
 
                Claim ceiclaim(strv);
                ceiclaim.add_pro(strv);
                ceiclaim.add_against(strv);
 
                {
                        const uint32_t MAXLEN = 32;
                        char buf[MAXLEN];
                        uint32_t longest = 0;
                        while (is) {
                                is.getline(buf, sizeof(buf));
                                if (is.gcount() <= 0) break;
                                else if (is.gcount() > longest) longest = is.gcount();
                                ieclaim.check(buf, is.gcount());
                                ceiclaim.check(buf, is.gcount());
                        }
                        if (longest >= MAXLEN) throw std::runtime_error(strv);
                }
 
                std::cout << ieclaim << """";
                std::cout << ceiclaim << """";
                std::cout << strv << (ieclaim.plausible() && ceiclaim.plausible() ? strv : strv) << """";
 
 
        } catch (const std::exception& ex) {
                std::cerr << strv << ex.what() << """";
                return -1;
        }
        return 0;
}
 "
" 
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
 
int main() {
	WSADATA wsaData;
	WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
 
	addrinfo *result = NULL;
	addrinfo hints;
 
	ZeroMemory( &hints, sizeof( hints ) );
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
 
	getaddrinfo( strv, strv, &hints, &result ); 

 
	SOCKET s = socket( result->ai_family, result->ai_socktype, result->ai_protocol );
 
	connect( s, result->ai_addr, (int)result->ai_addrlen );
 
	freeaddrinfo( result );
 
	send( s, ""GET / HTTP/1.0"", 16, 0 );
 
	char buffer[512];
	int bytes;
 
	do {
		bytes = recv( s, buffer, 512, 0 );
 
		if ( bytes > 0 )
			std::cout.write(buffer, bytes);
	} while ( bytes > 0 );
 
	return 0;
}
  
#include <Web/Web.h>
 
using namespace Upp;
 
CONSOLE_APP_MAIN
{
	Cout() << HttpClient(strv).ExecuteRedirect();
}
 "
"#include <iostream>
#include <queue>
#include <map>
#include <climits> // for CHAR_BIT
#include <iterator>
#include <algorithm>
 
const int UniqueSymbols = 1 << CHAR_BIT;
const char* SampleString = strv;
 
typedef std::vector<bool> HuffCode;
typedef std::map<char, HuffCode> HuffCodeMap;
 
class INode
{
public:
    const int f;
 
    virtual ~INode() {}
 
protected:
    INode(int f) : f(f) {}
};
 
class InternalNode : public INode
{
public:
    INode *const left;
    INode *const right;
 
    InternalNode(INode* c0, INode* c1) : INode(c0->f + c1->f), left(c0), right(c1) {}
    ~InternalNode()
    {
        delete left;
        delete right;
    }
};
 
class LeafNode : public INode
{
public:
    const char c;
 
    LeafNode(int f, char c) : INode(f), c(c) {}
};
 
struct NodeCmp
{
    bool operator()(const INode* lhs, const INode* rhs) const { return lhs->f > rhs->f; }
};
 
INode* BuildTree(const int (&frequencies)[UniqueSymbols])
{
    std::priority_queue<INode*, std::vector<INode*>, NodeCmp> trees;
 
    for (int i = 0; i < UniqueSymbols; ++i)
    {
        if(frequencies[i] != 0)
            trees.push(new LeafNode(frequencies[i], (char)i));
    }
    while (trees.size() > 1)
    {
        INode* childR = trees.top();
        trees.pop();
 
        INode* childL = trees.top();
        trees.pop();
 
        INode* parent = new InternalNode(childR, childL);
        trees.push(parent);
    }
    return trees.top();
}
 
void GenerateCodes(const INode* node, const HuffCode& prefix, HuffCodeMap& outCodes)
{
    if (const LeafNode* lf = dynamic_cast<const LeafNode*>(node))
    {
        outCodes[lf->c] = prefix;
    }
    else if (const InternalNode* in = dynamic_cast<const InternalNode*>(node))
    {
        HuffCode leftPrefix = prefix;
        leftPrefix.push_back(false);
        GenerateCodes(in->left, leftPrefix, outCodes);
 
        HuffCode rightPrefix = prefix;
        rightPrefix.push_back(true);
        GenerateCodes(in->right, rightPrefix, outCodes);
    }
}
 
int main()
{
    

    int frequencies[UniqueSymbols] = {0};
    const char* ptr = SampleString;
    while (*ptr != '')
        ++frequencies[*ptr++];
 
    INode* root = BuildTree(frequencies);
 
    HuffCodeMap codes;
    GenerateCodes(root, HuffCode(), codes);
    delete root;
 
    for (HuffCodeMap::const_iterator it = codes.begin(); it != codes.end(); ++it)
    {
        std::cout << it->first << strv;
        std::copy(it->second.begin(), it->second.end(),
                  std::ostream_iterator<bool>(std::cout));
        std::cout << std::endl;
    }
    return 0;
}"
"#include <iostream>
 
int main() {
   const int size = 100000;
   int hofstadters[size] = { 1, 1 };  
   for (int i = 3 ; i < size; i++) 
      hofstadters[ i - 1 ] = hofstadters[ i - 1 - hofstadters[ i - 1 - 1 ]] +
                             hofstadters[ i - 1 - hofstadters[ i - 2 - 1 ]];
   std::cout << strv;
   for (int i = 0; i < 10; i++) 
      std::cout << hofstadters[ i ] << ' ';
   std::cout << std::endl << strv << hofstadters[ 999 ] << strv << std::endl;
   int less_than_preceding = 0;
   for (int i = 0; i < size - 1; i++)
      if (hofstadters[ i + 1 ] < hofstadters[ i ]) 
	     less_than_preceding++;
   std::cout << strv << size << strv;
   std::cout << less_than_preceding << strv << std::endl;
   return 0;
}"
"#include <iomanip>
#include <iostream>
#include <set>
#include <vector>
 
using namespace std;
 
unsigned hofstadter(unsigned rlistSize, unsigned slistSize)
{
    auto n = rlistSize > slistSize ? rlistSize : slistSize;
    auto rlist = new vector<unsigned> { 1, 3, 7 };
    auto slist = new vector<unsigned> { 2, 4, 5, 6 };
    auto list = rlistSize > 0 ? rlist : slist;
    auto target_size = rlistSize > 0 ? rlistSize : slistSize;
 
    while (list->size() > target_size) list->pop_back();
 
    while (list->size() < target_size)
    {
        auto lastIndex = rlist->size() - 1;
        auto lastr = (*rlist)[lastIndex];
        auto r = lastr + (*slist)[lastIndex];
        rlist->push_back(r);
        for (auto s = lastr + 1; s < r && list->size() < target_size;)
            slist->push_back(s++);
    }
 
    auto v = (*list)[n - 1];
    delete rlist;
    delete slist;
    return v;
}
 
ostream& operator<<(ostream& os, const set<unsigned>& s)
{
    cout << '(' << s.size() << strv;
    auto i = 0;
    for (auto c = s.begin(); c != s.end();)
    {
        if (i++ % 20 == 0) os << endl;
        os << setw(5) << *c++;
    }
    return os;
}
 
int main(int argc, const char* argv[])
{
    const auto v1 = atoi(argv[1]);
    const auto v2 = atoi(argv[2]);
    set<unsigned> r, s;
    for (auto n = 1; n <= v2; n++)
    {
        if (n <= v1)
            r.insert(hofstadter(n, 0));
        s.insert(hofstadter(0, n));
    }
    cout << strv << r << endl;
    cout << strv << s << endl;
 
    int m = max(*r.rbegin(), *s.rbegin());
    for (auto n = 1; n <= m; n++)
        if (r.count(n) == s.count(n))
            clog << strv << n << strv << endl;
 
    return 0;
}"
" 
#include <deque>
#include <iostream>
 
int hcseq(int n)
{
  static std::deque<int> seq(2, 1);
  while (seq.size() < n)
  {
    int x = seq.back();
    seq.push_back(seq[x-1] + seq[seq.size()-x]);
  }
  return seq[n-1];
}
 
int main()
{
  int pow2 = 1;
  for (int i = 0; i < 20; ++i)
  {
    int pow2next = 2*pow2;
    double max = 0;
    for (int n = pow2; n < pow2next; ++n)
    {
      double anon = hcseq(n)/double(n);
      if (anon > max)
        max = anon;
    }
    std::cout << strv << i
              << strv << pow2 << strv << i+1
              << strv << pow2next << strv << max << """";
    pow2 = pow2next;
  }
}
 "
"#include <iostream>
#include <vector>
 
using namespace std;
 
double horner(vector<double> v, double x)
{
  double s = 0;
 
  for( vector<double>::const_reverse_iterator i = v.rbegin(); i != v.rend(); i++ )
    s = s*x + *i;
  return s;
}
 
int main()
{
  double c[] = { -19, 7, -4, 6 };
  vector<double> v(c, c + sizeof(c)/sizeof(double));
  cout << horner(v, 3.0) << endl;
  return 0;
} 
#include <iostream>
 
template<typename BidirIter>
 double horner(BidirIter begin, BidirIter end, double x)
{
  double result = 0;
  while (end != begin)
    result = result*x + *--end;
  return result;
}
 
int main()
{
  double c[] = { -19, 7, -4, 6 };
  std::cout << horner(c, c + 4, 3) << std::endl;
}
 "
" 


#include <tr1/functional>
#include <iostream>
 
using namespace std;
using namespace std::tr1;
 
void first(function<void()> f)
{
  f();
}
 
void second()
{
  cout << ""second"";
}
 
int main()
{
  first(second);
}
 #include <iostream>
#include <functional>
 
template<class Func>
typename Func::result_type first(Func func, typename Func::argument_type arg)
{
  return func(arg);
}
 
class second : public std::unary_function<int, int>
{
public:
  result_type operator()(argument_type arg) const
  {
    return arg * arg;
  }
};
 
int main()
{
  std::cout << first(second(), 2) << std::endl;
  return 0;
}"
"#include <iostream>
#include <iomanip>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/math/constants/constants.hpp>
typedef boost::multiprecision::cpp_dec_float_50 decfloat;
 
int main()
{
    const decfloat ln_two = boost::math::constants::ln_two<decfloat>();
    decfloat numerator = 1, denominator = ln_two;
 
    for(int n = 1; n <= 17; n++) {
        decfloat h = (numerator *= n) / (denominator *= ln_two) / 2;
        decfloat tenths_dig = floor((h - floor(h)) * 10);
        std::cout << strv << std::setw(2) << n << strv << std::setw(25) << std::fixed << h << 
            (tenths_dig == 0 || tenths_dig == 9 ? strv : strv) << ""an almost-integer."";
    }
}
 "
"#include <iostream> // Only for cout to demonstrate
 
int main()
{
  std::cout <<
Rstrv),  then an optional
identifier (here I've used strv),  then an opening parenthesis ('(').  If youuse  an  identifier,  it  cannot  be longer than 16 characters,  and it cannotcontain a space,  either opening or closing parentheses, a backslash, a tab, avertical tab, a form feed, or a newline.   It  ends with a closing parenthesis (')'),  the identifer (if you used one),and a double-quote.   All  characters are okay in a raw string,  no escape sequences are necessaryor recognized, and all whitespace is preserved.)EOF"";}"
"#include <algorithm>
#include <cmath>
#include <iostream>
#include <tuple>
#include <vector>
 
int gcd(int a, int b)
{
    int rem = 1, dividend, divisor;
    std::tie(divisor, dividend) = std::minmax(a, b);
    while (rem != 0) {
        rem = dividend % divisor;
        if (rem != 0) {
            dividend = divisor;
            divisor = rem;
        }
    }
    return divisor;
}
 
struct Triangle
{
    int a;
    int b;
    int c;
};
 
int perimeter(const Triangle& triangle)
{
    return triangle.a + triangle.b + triangle.c;
}
 
double area(const Triangle& t)
{
    double p_2 = perimeter(t) / 2.;
    double area_sq = p_2 * ( p_2 - t.a ) * ( p_2 - t.b ) * ( p_2 - t.c );
    return sqrt(area_sq);
}
 
std::vector<Triangle> generate_triangles(int side_limit = 200)
{
    std::vector<Triangle> result;
    for(int a = 1; a <= side_limit; ++a)
        for(int b = 1; b <= a; ++b)
            for(int c = a+1-b; c <= b; ++c) 

            {
                Triangle t{a, b, c};
                double t_area = area(t);
                if(t_area == 0) continue;
                if( std::floor(t_area) == std::ceil(t_area) && gcd(a, gcd(b, c)) == 1)
                    result.push_back(t);
            }
    return result;
}
 
bool compare(const Triangle& lhs, const Triangle& rhs)
{
    return std::make_tuple(area(lhs), perimeter(lhs), std::max(lhs.a, std::max(lhs.b, lhs.c))) <
           std::make_tuple(area(rhs), perimeter(rhs), std::max(rhs.a, std::max(rhs.b, rhs.c)));
}
 
struct area_compare
{
    bool operator()(const Triangle& t, int i) { return area(t) < i; }
    bool operator()(int i, const Triangle& t) { return i < area(t); }
};
 
int main()
{
    auto tri = generate_triangles();
    std::cout << strv << tri.size() << "" primitive Heronian triangles with sides up to 200"";
 
    std::cout << ""First ten when ordered by increasing area, then perimeter, then maximum sides:"";
    std::sort(tri.begin(), tri.end(), compare);
    std::cout << ""areaperimetersides"";
    for(int i = 0; i < 10; ++i)
        std::cout << area(tri[i]) << '' << perimeter(tri[i]) << """" <<
                     tri[i].a << 'x' << tri[i].b << 'x' << tri[i].c << '';
 
    std::cout << ""All with area 210 subject to the previous ordering:"";
    auto range = std::equal_range(tri.begin(), tri.end(), 210, area_compare());
    std::cout << ""areaperimetersides"";
    for(auto it = range.first; it != range.second; ++it)
        std::cout << area(*it) << '' << perimeter(*it) << """" <<
                     it->a << 'x' << it->b << 'x' << it->c << '';
}"
"#include <iostream>
 
int main () {
  std::cerr << strv << std::endl;
}"
"#include <iostream>
 
int main() {
  std::cout << strv;
  return 0;
}"
"#include <iostream>
int main() {
    using namespace std;
    cout << strv << endl;
    return 0;
}"
"#include <iostream>
 
int main () {
  std::cout << strv << std::endl;
}using namespace System;
int main()
{
  Console::WriteLine(strv);
}"
"#include <iostream>
#include <fstream>
 
int main(){
  std::ofstream lprFile;
  lprFile.open( strv );
  lprFile << ""Hello World!"";
  lprFile.close();
  return 0;
}"
"#include <map>
#include <string>
 
int
main( int argc, char* argv[] )
{
 std::string keys[] = { strv, strv, strv } ;
 std::string vals[] = { strv, strv, strv } ;
 
 std::map< std::string, std::string > hash ;
 
 for( int i = 0 ; i < 3 ; i++ )
 {
  hash[ keys[i] ] = vals[i] ;
 }
}#include <map>       // for std::map
#include <algorithm> // for std::transform
#include <string>    // for std::string
#include <utility>   // for std::make_pair
 
int main()
{
  std::string keys[] = { strv, strv, strv };
  std::string vals[] = { strv, strv, strv };
 
  std::map<std::string, std::string> hash;
 
  std::transform(keys, keys+3,
                 vals,
                 std::inserter(hash, hash.end()),
                 std::make_pair<std::string, std::string>);
}"
"#include <gtkmm.h>
int main(int argc, char *argv[])
{
   Gtk::Main app(argc, argv);
   Gtk::MessageDialog msg(strv);
   msg.run();
}#include strv
void ShowGoodbyeWorld(CWnd* pWnd)
{
    pWnd->SetWindowText(_T(strv));
} 
#include <FL/Fl.H>
#include <FL/Fl_Window.H>
#include <FL/Fl_Box.H>
 
int main(int argc, char **argv) {
  Fl_Window *window = new Fl_Window(300,180);
  Fl_Box *box = new Fl_Box(20,40,260,100,strv);
  box->box(FL_UP_BOX);
  box->labelsize(36);
  box->labelfont(FL_BOLD+FL_ITALIC);
  box->labeltype(FL_SHADOW_LABEL);
  window->end();
  window->show(argc, argv);
  return Fl::run();
}
  
using namespace System::Windows::Forms;
 
int main(array<System::String^> ^args)
{
  MessageBox::Show(strv, strv);
  return 0;
}
 "
"#include <vector>
#include <iostream>
 
int sumDigits ( int number ) {
   int sum = 0 ;
   while ( number != 0 ) {
      sum += number % 10 ;
      number /= 10 ;
   }
   return sum ;
}
 
bool isHarshad ( int number ) {
   return number % ( sumDigits ( number ) ) == 0 ;
}
 
int main( ) {
   std::vector<int> harshads ;
   int i = 0 ;
   while ( harshads.size( ) != 20 ) {
      i++ ;
      if ( isHarshad ( i ) ) 
	 harshads.push_back( i ) ;
   }
   std::cout << ""The first 20 Harshad numbers:"" ;
   for ( int number : harshads )
      std::cout << number << strv ;
   std::cout << std::endl ;
   int start = 1001 ;
   while ( ! ( isHarshad ( start ) ) ) 
      start++ ;
   std::cout << strv << start << '' ;
   return 0 ;
}"
"#include <map>
#include <set>
 
bool happy(int number) {
  static std::map<int, bool> cache;
 
  std::set<int> cycle;
  while (number != 1 && !cycle.count(number)) {
    if (cache.count(number)) {
      number = cache[number] ? 1 : 0;
      break;
    }
    cycle.insert(number);
    int newnumber = 0;
    while (number > 0) {
      int digit = number % 10;
      newnumber += digit * digit;
      number /= 10;
    }
    number = newnumber;
  }
  bool happiness = number == 1;
  for (std::set<int>::const_iterator it = cycle.begin();
       it != cycle.end(); it++)
    cache[*it] = happiness;
  return happiness;
}
 
#include <iostream>
 
int main() {
  for (int i = 1; i < 50; i++)
    if (happy(i))
      std::cout << i << std::endl;
  return 0;
}unsigned int happy_iteration(unsigned int n)
{
  unsigned int result = 0;
  while (n > 0)
  {
    unsigned int lastdig = n % 10;
    result += lastdig*lastdig;
    n /= 10;
  }
  return result;
}
 
bool is_happy(unsigned int n)
{
  unsigned int n2 = happy_iteration(n);
  while (n != n2)
  {
    n = happy_iteration(n);
    n2 = happy_iteration(happy_iteration(n2));
  }
  return n == 1;
}
 
#include <iostream>
 
int main()
{
  unsigned int current_number = 1;
 
  unsigned int happy_count = 0;
  while (happy_count != 8)
  {
    if (is_happy(current_number))
    {
      std::cout << current_number << strv;
      ++happy_count;
    }
    ++current_number;
  }
  std::cout << std::endl;
}"
"#ifndef TASK_H
#define TASK_H
 
#include <QWidget>
 
class QPushButton ;
class QString ;
class QLineEdit ;
class QLabel ;
class QVBoxLayout ;
class QHBoxLayout ;
 
class MyWidget : public QWidget {
 
    Q_OBJECT
public:
   MyWidget( QWidget *parent = 0 ) ;
private slots:
   void buttonChange( const QString & ) ;
   void addField( ) ;
   void subtractField( ) ;
private :
   QVBoxLayout *thisWidgetLayout ;
   QLabel *instruction ;
   QPushButton *increment ;
   QPushButton *decrement ;
   QLineEdit *entryField ;
   QHBoxLayout *lowerPart ;
} ;
#endif#include <QtGui>
#include <QString>
#include strv 
 
MyWidget::MyWidget ( QWidget *parent ) 
   : QWidget( parent ) {
   thisWidgetLayout = new QVBoxLayout ( this )  ;
   instruction = new QLabel ;
   instruction->setText( strv ) ;
   instruction->setWordWrap( true ) ;
   lowerPart = new QHBoxLayout ;
   entryField = new QLineEdit( strv ) ;
   increment = new QPushButton( strv ) ;
   decrement = new QPushButton( strv ) ;
   increment->setDefault( true ) ;
   connect( entryField , SIGNAL ( textChanged ( const QString &  ) ) , 
	    this , SLOT ( buttonChange( const QString & )) ) ;
   connect( entryField , SIGNAL ( textEdited ( const QString &  ) ) , 
	    this , SLOT ( buttonChange( const QString & )) ) ;
   connect( increment , SIGNAL ( clicked( ) ) , this ,
	 SLOT ( addField( ) )) ;
   connect( decrement , SIGNAL ( clicked( ) ) , this ,
	 SLOT ( subtractField( ))) ;
   lowerPart->addWidget( entryField ) ;
   lowerPart->addWidget( increment ) ;
   lowerPart->addWidget( decrement ) ;
   thisWidgetLayout->addWidget( instruction ) ;
   thisWidgetLayout->addLayout( lowerPart ) ;
   setLayout( thisWidgetLayout ) ;
}
 
void MyWidget::buttonChange( const QString & text ) {
   bool ok ;
   increment->setEnabled( text.toInt( &ok, 10 ) < 10 ) ;
   increment->setDisabled( text.toInt( &ok, 10 ) > 9 ) ;
   decrement->setEnabled( text.toInt( &ok, 10 ) > 0 ) ;
   decrement->setDisabled( text.toInt( &ok, 10 ) <= 0 ) ;
   if ( ! ( text == strv ) ) 
      entryField->setReadOnly( true ) ;
}
 
void MyWidget::addField( ) { 
   bool ok ;
   int number = entryField->text( ).toInt( &ok , 10 ) ;
   number++ ;
   entryField->setText( QString(strv).arg( number )) ;
}
 
void MyWidget::subtractField( ) {
   bool ok ;
   int number = entryField->text( ).toInt( &ok , 10 ) ;
   number-- ;
   entryField->setText( QString(strv).arg( number )) ;
}#include <QApplication>
#include strv
 
int main( int argc, char *argv[ ] ) {
   QApplication app( argc , argv ) ;
   MyWidget theWidget ;
   theWidget.show( ) ;
   return app.exec( ) ;
}"
"#include <iostream>
#include <vector>
#include <utility>
 
std::vector<int> hailstone(int i)
{
    std::vector<int> v;
    while(true){ 
        v.push_back(i);
        if (1 == i) break; 
        i = (i % 2) ? (3 * i + 1) : (i / 2);
    }
    return v;
}
 
std::pair<int,int> find_longest_hailstone_seq(int n)
{
    std::pair<int, int> maxseq(0, 0);
    int l; 
    for(int i = 1; i < n; ++i){
        l = hailstone(i).size(); 
        if (l > maxseq.second) maxseq = std::make_pair(i, l);
    }   
    return maxseq;
}
 
int main () {
 


    std::vector<int> h27;
    h27 = hailstone(27); 


    int l = h27.size();
    std::cout << strv << l;


    std::cout << strv;
    std::cout << h27[0] << strv << h27[1] << strv 
              << h27[2] << strv << h27[3] << std::endl;


    std::cout << strv
              << h27[l-4] << strv << h27[l-3] << strv 
              << h27[l-2] << strv << h27[l-1] << std::endl;
 
    std::pair<int,int> m = find_longest_hailstone_seq(100000); 
 
    std::cout << strv << m.first 
              << strv << m.second << strv <<std::endl;  
 
    return 0;
}"
"#ifndef INTERACTION_H
#define INTERACTION_H
#include <QWidget>
 
class QPushButton ;
class QLineEdit ;
class QVBoxLayout ;
class MyWidget : public QWidget {
   Q_OBJECT 
 
public :
   MyWidget( QWidget *parent = 0 ) ;
private :
   QLineEdit *entryField ;
   QPushButton *increaseButton ;
   QPushButton *randomButton ;
   QVBoxLayout *myLayout ;
private slots :
   void doIncrement( ) ;
   void findRandomNumber( ) ;
} ;
#endif#include <QPushButton>
#include <QLineEdit>
#include <QMessageBox>
#include <QString>
#include <QRegExpValidator>
#include <QVBoxLayout>
#include <QRegExp>
#include <ctime> //for the srand initialization
#include <cstdlib> //for the random number
#include strv 
 
MyWidget::MyWidget (QWidget *parent ) : QWidget( parent ) {
   myLayout = new QVBoxLayout( ) ;
   entryField = new QLineEdit( strv ) ;
   QRegExp rx( ""d+"" ) ;
   QValidator *myvalidator = new QRegExpValidator( rx , this ) ;
   entryField->setValidator( myvalidator ) ;
   increaseButton = new QPushButton( strv ) ;
   connect( increaseButton, SIGNAL( clicked( ) ) ,
	 this , SLOT( doIncrement( ) )) ;
   randomButton = new QPushButton( strv ) ;
   connect( randomButton , SIGNAL( clicked( ) ) ,
	 this , SLOT ( findRandomNumber( ) )) ;
   myLayout->addWidget( entryField ) ;
   myLayout->addWidget( increaseButton ) ;
   myLayout->addWidget( randomButton ) ;
   setLayout( myLayout ) ;
}
 
void MyWidget::doIncrement( ) {
   bool ok ;
   int zahl = entryField->text( ).toInt( &ok, 10 ) ;
   entryField->setText( QString( strv).arg( ++zahl ) ) ;
}
 
void MyWidget::findRandomNumber( ) {
   QMessageBox msgBox( this ) ;
   msgBox.setText( strv ) ;
   msgBox.setStandardButtons( QMessageBox::Yes | QMessageBox::No ) ;
   int ret = msgBox.exec( ) ;
   switch ( ret ) {
      case QMessageBox::Yes :
	 srand( time( 0 ) ) ;
	 int zahl = random( ) ;
	 entryField->setText( QString( strv ).arg( zahl )) ;
	 break ;
   }
}#include <QApplication>
#include strv
 
int main( int argc , char *argv[ ] ) {
   QApplication app( argc, argv ) ;
   MyWidget theWidget ;
   theWidget.show( ) ;
   return app.exec( ) ;
}#include <QApplication>
#include <QWidget>
#include <QVBoxLayout>
#include <QPushButton>
#include <QLineEdit>
#include <QIntValidator>
#include <QMessageBox>
#include <QTime>
 
int main(int argc, char **argv) {
    qsrand(QTime::currentTime().msec());
 
    QApplication app(argc, argv);
 
    auto *edit = new QLineEdit(strv);
    edit->setValidator(new QIntValidator());
 
    auto *incButton = new QPushButton(strv);
    QObject::connect(incButton, &QPushButton::clicked, 
            [edit]() { edit->setText( QString::number(edit->text().toInt() + 1)); } );
 
    auto *rndButton = new QPushButton(strv);
    QObject::connect(rndButton, &QPushButton::clicked, 
            [edit]() { 
                auto result = QMessageBox(
                    QMessageBox::Warning,
                    strv,
                    strv,
                    QMessageBox::Ok | QMessageBox::Cancel
                ).exec();
 
                if (result == QMessageBox::Ok)
                    edit->setText( QString::number(qrand())); 
            } );
 
    auto *vbox = new QVBoxLayout;
    vbox->addWidget(edit);
    vbox->addWidget(incButton);
    vbox->addWidget(rndButton);
 
    QWidget mainWindow;
    mainWindow.setLayout(vbox);
    mainWindow.show();
 
    return app.exec();
}"
"#include <iostream>
#include <algorithm>
#include <string>
#include <iterator>
 
struct GuessNumberIterator : std::iterator<std::random_access_iterator_tag, int> {
  int i;
  GuessNumberIterator() { }
  GuessNumberIterator(int _i) : i(_i) { }
  GuessNumberIterator& operator++() { ++i; return *this; }
  GuessNumberIterator operator++(int) {
    GuessNumberIterator tmp = *this; ++(*this); return tmp; }
  bool operator==(const GuessNumberIterator& y) { return i == y.i; }
  bool operator!=(const GuessNumberIterator& y) { return i != y.i; }
  int operator*() {
    std::cout << strv << i << strv;
    std::string s;
    std::cin >> s;
    return (s != strv && (s[0] == 'y' || s[0] == 'Y')) ? 0 : -1;
  }
  GuessNumberIterator& operator--() { --i; return *this; }
  GuessNumberIterator operator--(int) {
    GuessNumberIterator tmp = *this; --(*this); return tmp; }
  GuessNumberIterator& operator+=(int n) { i += n; return *this; }
  GuessNumberIterator& operator-=(int n) { i -= n; return *this; }
  GuessNumberIterator operator+(int n) {
    GuessNumberIterator tmp = *this; return tmp += n; }
  GuessNumberIterator operator-(int n) {
    GuessNumberIterator tmp = *this; return tmp -= n; }
  int operator-(const GuessNumberIterator &y) { return i - y.i; }
  int operator[](int n) { return *(*this + n); }
  bool operator<(const GuessNumberIterator &y) { return i < y.i; }
  bool operator>(const GuessNumberIterator &y) { return i > y.i; }
  bool operator<=(const GuessNumberIterator &y) { return i <= y.i; }
  bool operator>=(const GuessNumberIterator &y) { return i >= y.i; }
};
inline GuessNumberIterator operator+(int n, GuessNumberIterator &i) { return i + n; }
 
const int lower = 0;
const int upper = 100;
 
int main() {
  std::cout << ""Instructions:""
	    << strv << lower << strv
	    << upper << "" (exclusive) and""
	    << ""I will guess it. After each guess, I will ask you if it is less than""
	    << ""or equal to some number, and you will respond with yes or no."";
  int answer = std::lower_bound(GuessNumberIterator(lower), GuessNumberIterator(upper), 0).i;
  std::cout << strv << answer << ""."";
  return 0;
}"
"#include <iostream>
#include <cstdlib>
#include <ctime>
 
int main()
{
    srand(time(0));
    int n = 1 + (rand() % 10);
    int g;
    std::cout << ""I'm thinking of a number between 1 and 10.Try to guess it! "";
    while(true)
    {
        std::cin >> g;
        if (g == n)
            break;
        else
            std::cout << ""That's not my number.Try another guess! "";
    }
    std::cout << strv;
    return 0;
}
 
 "
" 
#include <iostream>
#include <vector>


//


//
class Ham {
private:
	std::vector<unsigned int> _H, _hp, _hv, _x;
public:
	bool operator!=(const Ham& other) const {return true;}
	Ham begin() const {return *this;}
        Ham end() const {return *this;}
	unsigned int operator*() const {return _x.back();}
	Ham(const std::vector<unsigned int> &pfs):_H(pfs),_hp(pfs.size(),0),_hv({pfs}),_x({1}){}
	const Ham& operator++() {
	  for (int i=0; i<_H.size(); i++) for (;_hv[i]<=_x.back();_hv[i]=_x[++_hp[i]]*_H[i]);
	  _x.push_back(_hv[0]);
	  for (int i=1; i<_H.size(); i++) if (_hv[i]<_x.back()) _x.back()=_hv[i];
	  return *this;
	}
};
  
int main() {
  int count = 1;
  for (unsigned int i : Ham({2,3,5})) {
    if (count <= 62) std::cout << i << ' ';
    if (count++ == 1691) {
      std::cout << ""The one thousand six hundred and ninety first Hamming Number is "" << i << std::endl;
      break;
    }
  }
  return 0;
}
  
int main() {
  int count = 1;
  for (unsigned int i : Ham({2,3,5,7})) {
    std::cout << i << ' ';
    if (count++ == 64) break;
  }
  std::cout << std::endl;
  return 0;
}
 #include <chrono>
#include <iostream>
#include <gmpxx.h>
#include <functional>
#include <memory>
 
template<class T>
class Lazy {
public:
	T _v;
private:
	std::function<T()> _f;
 
public:
	explicit Lazy(std::function<T()> thnk)
		: _v(T()), _f(thnk) {};
	T value() { 

		if (this->_f != nullptr) {
			this->_v = this->_f();
			this->_f = nullptr;
		}
		return this->_v;
	}
};
 
template<class T>
class LazyList {
public:
	T head;
	std::shared_ptr<Lazy<LazyList<T>>> tail;
	LazyList(): head(T()) {} 

	LazyList(T head, std::function<LazyList<T>()> thnk)
		: head(head), tail(std::make_shared<Lazy<LazyList<T>>>(thnk)) {}
	

	bool isEmpty() { return this->tail == nullptr; }
};
 
typedef std::shared_ptr<mpz_class> PBI;
typedef LazyList<PBI> LL;
typedef std::function<LL(LL)> FLL2LL;
 
LL merge(LL a, LL b) {
	auto ha = a.head; auto hb = b.head;
	if (*ha < *hb) {
		return LL(ha, [=]() { return merge(a.tail->value(), b); });
	} else {
		return LL(hb, [=]() { return merge(a, b.tail->value()); });
	}
}
 
LL smult(int m, LL s) {
	const auto im = mpz_class(m);
	const auto psmlt =
			std::make_shared<FLL2LL>([](LL ss) { return ss; });
	*psmlt = [=](LL ss) {
		return LL(std::make_shared<mpz_class>(*ss.head * im),
				  [=]() { return (*psmlt)(ss.tail->value()); });
	};
	return (*psmlt)(s); 

}
 
LL u(LL s, int n) {
	const auto r = std::make_shared<LL>(LL()); 

	*r = smult(n, LL(std::make_shared<mpz_class>(1), [=]() { return *r; }));
	if (!s.isEmpty()) { *r = merge(s, *r); }
	return *r;
}
 
LL hammings() {
	auto r = LL();
	for (auto pn : std::vector<int>({5, 3, 2})) {
		r = u(r, pn);
	}
	return LL(std::make_shared<mpz_class>(1), [=]() { return r; });
}
 
int main() {
	auto hmgs = hammings();
	for (auto i = 0; i < 20; ++i) {
		std::cout << *hmgs.head << strv;
		hmgs = hmgs.tail->value();
	}
	std::cout << """";
 
	hmgs = hammings();
	for (auto i = 1; i < 1691; ++i) hmgs = hmgs.tail->value();
	std::cout << *hmgs.head << """";
 
	auto start = std::chrono::steady_clock::now();
	hmgs = hammings();
	for (auto i = 1; i < 1000000; ++i) hmgs = hmgs.tail->value();
	auto stop = std::chrono::steady_clock::now();
 
	auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);
	std::cout << *hmgs.head << strv << ms.count() << ""milliseconds."";
}#include <chrono>
#include <iostream>
#include <vector>
#include <gmpxx.h>
 
class Hammings {
private:
	const mpz_class _two = 2, _three = 3, _five = 5;
	std::vector<mpz_class> _m = {}, _h = {1};
	mpz_class _x5 = 5, _x53 = 9, _mrg = 3, _x532 = 2;
	int _i = 1, _j = 0;
public:
	Hammings() {_m.reserve(65536); _h.reserve(65536); };
	bool operator!=(const Hammings& other) const { return true; }
	Hammings begin() const { return *this; }
	Hammings end() const { return *this; }
	mpz_class operator*() { return _h.back(); }
	const Hammings& operator++() {
		if (_i > _h.capacity() / 2) {
			_h.erase(_h.begin(), _h.begin() + _i);
			_i = 0;
		}
		if (_x532 < _mrg) {
			_h.push_back(_x532);
			_x532 = _h[_i++] * _two;
		} else {
			_h.push_back(_mrg);
			if (_x53 < _x5) {
				_mrg = _x53;
				_x53 = _m[_j++] * _three;
			} else {
				_mrg = _x5;
				_x5 = _x5 * _five;
			}
			if (_j > _m.capacity() / 2) {
				_m.erase(_m.begin(), _m.begin() + _j);
				_j = 0;
			}
			_m.push_back(_mrg);
		}
		return *this;
	}
};
 
int main() {
	auto cnt = 1;
	for (auto hmg : Hammings()) {
		if (cnt <= 20) std::cout << hmg << strv;
		if (cnt == 20) std::cout << """";
		if (cnt++ >= 1691) {
			std::cout << hmg << """";
			break;
		}
	}
 
	auto start = std::chrono::steady_clock::now();
	hmgs = hammings();
	auto&& hmgitr = Hammings();
	for (auto i = 1; i < 1000000; ++i) ++hmgitr;
	auto stop = std::chrono::steady_clock::now();
 
	auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);
	std::cout << *hmgitr << strv << ms.count() << ""milliseconds."";
}"
" 
#include <windows.h>
#include <iostream>
#include <ctime>
 
const int WID = 79, HEI = 22;
const float NCOUNT = ( float )( WID * HEI );
 
class coord : public COORD {
public:
    coord( short x = 0, short y = 0 ) { set( x, y ); }
    void set( short x, short y ) { X = x; Y = y; }
};
class winConsole {
public:
    static winConsole* getInstamnce() { if( 0 == inst ) { inst = new winConsole(); } return inst; }
    void showCursor( bool s ) { CONSOLE_CURSOR_INFO ci = { 1, s }; SetConsoleCursorInfo( conOut, &ci ); }
    void setColor( WORD clr ) { SetConsoleTextAttribute( conOut, clr ); }
    void setCursor( coord p ) { SetConsoleCursorPosition( conOut, p ); }
    void flush() { FlushConsoleInputBuffer( conIn ); }
    void kill() { delete inst; }
private:
    winConsole() { conOut = GetStdHandle( STD_OUTPUT_HANDLE ); 
                   conIn  = GetStdHandle( STD_INPUT_HANDLE ); showCursor( false ); }
    static winConsole* inst;
    HANDLE conOut, conIn;
};
class greed {
public:
    greed() { console = winConsole::getInstamnce(); }
    ~greed() { console->kill(); }
    void play() {
        char g; do {
            console->showCursor( false ); createBoard();
            do { displayBoard(); getInput(); } while( existsMoves() );
            displayBoard(); console->setCursor( coord( 0, 24 ) ); console->setColor( 0x07 );
            console->setCursor( coord( 19,  8 ) ); std::cout << strv;
            console->setCursor( coord( 19,  9 ) ); std::cout << strv;
            console->setCursor( coord( 19, 10 ) ); std::cout << strv;
            console->setCursor( coord( 19, 11 ) ); std::cout << strv;
            console->setCursor( coord( 48, 10 ) ); console->showCursor( true ); console->flush(); std::cin >> g;
        } while( g == 'Y' || g == 'y' );
    }
private:
    void createBoard() {
        for( int y = 0; y < HEI; y++ ) {
            for( int x = 0; x < WID; x++ ) {
                brd[x + WID * y] = rand() % 9 + 1;
            }
        }
        cursor.set( rand() % WID, rand() % HEI );
        brd[cursor.X + WID * cursor.Y] = 0; score = 0;
        printScore();
    }
    void displayBoard() {
        console->setCursor( coord() ); int i;
		for( int y = 0; y < HEI; y++ ) {
            for( int x = 0; x < WID; x++ ) {
                i = brd[x + WID * y]; console->setColor( 6 + i );
                if( !i ) std::cout << strv; else std::cout << i;
            }
            std::cout << """";
        }
        console->setColor( 15 ); console->setCursor( cursor ); std::cout << strv;
    }
    void getInput() { 
        while( 1 ) {
            if( ( GetAsyncKeyState( 'Q' ) & 0x8000 ) && cursor.X > 0 && cursor.Y > 0 ) { execute( -1, -1 ); break; }
            if( ( GetAsyncKeyState( 'W' ) & 0x8000 ) &&  cursor.Y > 0 ) { execute( 0, -1 ); break; }
            if( ( GetAsyncKeyState( 'E' ) & 0x8000 ) && cursor.X < WID - 1 && cursor.Y > 0 ) { execute( 1, -1 ); break; }
            if( ( GetAsyncKeyState( 'A' ) & 0x8000 ) && cursor.X > 0 ) { execute( -1, 0 ); break; }
            if( ( GetAsyncKeyState( 'D' ) & 0x8000 ) && cursor.X < WID - 1 ) { execute( 1, 0 ); break; }
            if( ( GetAsyncKeyState( 'Y' ) & 0x8000 ) && cursor.X > 0 && cursor.Y < HEI - 1 ) { execute( -1, 1 ); break; }
            if( ( GetAsyncKeyState( 'X' ) & 0x8000 ) && cursor.Y < HEI - 1 ) { execute( 0, 1 ); break; }
            if( ( GetAsyncKeyState( 'C' ) & 0x8000 ) && cursor.X < WID - 1 && cursor.Y < HEI - 1 ) { execute( 1, 1 ); break; }
        }
        console->flush(); printScore();
    }
    void printScore() {
        console->setCursor( coord( 0, 24 ) ); console->setColor( 0x2a );
        std::cout << strv << score << strv << score * 100.f / NCOUNT << strv;
    }
    void execute( int x, int y ) {
        int i = brd[cursor.X + x + WID * ( cursor.Y + y )];
        if( countSteps( i, x, y ) ) {
            score += i;
            while( i ) {
                --i; cursor.X += x; cursor.Y += y;
                brd[cursor.X + WID * cursor.Y] = 0;
            }
        }
    }
    bool countSteps( int i, int x, int y ) {
        coord t( cursor.X, cursor.Y );
        while( i ) {
            --i; t.X += x; t.Y += y;
            if( t.X < 0 || t.Y < 0 || t.X >= WID || t.Y >= HEI || !brd[t.X + WID * t.Y] ) return false;
        }
        return true;
    }
    bool existsMoves() {
        int i;
        for( int y = -1; y < 2; y++ ) {
            for( int x = -1; x < 2; x++ ) {
                if( !x && !y ) continue;
                i = brd[cursor.X + x + WID * ( cursor.Y + y )];
                if( i > 0 && countSteps( i, x, y ) ) return true;
            }
        }
        return false;
    }
    winConsole* console;
    int brd[WID * HEI];
    float score; coord cursor;
};
winConsole* winConsole::inst = 0;
int main( int argc, char* argv[] ) {
    srand( ( unsigned )time( 0 ) );
    SetConsoleTitle( strv );
    greed g; g.play(); return 0;
}
 "
"#ifndef MYWIDGET_H
#define MYWIDGET_H
#include <QWidget>
 
class QPaintEvent ;
 
class MyWidget : public QWidget {
public :
   MyWidget( ) ;
 
protected :
   void paintEvent( QPaintEvent * ) ;
} ;
#endif#include <QtGui>
#include strv
 
MyWidget::MyWidget( ) {
   setGeometry( 0, 0 , 640 , 480 ) ;
}
 
void MyWidget::paintEvent ( QPaintEvent * ) {
   QBrush myBrush( Qt::SolidPattern ) ;
   QPainter myPaint( this ) ;
   int run = 0 ; //how often have we run through the loop ?
   int colorcomp = 0 ;
   for ( int columncount = 8 ; columncount < 128 ; columncount *= 2 ) {
      int colorgap = 255 / columncount ;
      int columnwidth = 640 / columncount ; 

      int columnheight = 480 / 4 ; //we're looking at quarters
      if ( run % 2 == 0 ) { //we start with black columns 
	 colorcomp = 0 ;
      }
      else { //we start with white columns 
	 colorcomp = 255 ;
	 colorgap *= -1 ; //we keep subtracting color values 
      }
      int ystart = 0 + columnheight * run ; //determines the y coordinate of the first column per row
      int xstart = 0 ;
      for ( int i = 0 ; i < columncount ; i++ ) {
	 myBrush.setColor( QColor( colorcomp, colorcomp , colorcomp ) ) ;
	 myPaint.fillRect( xstart , ystart , columnwidth , columnheight , myBrush ) ;
	 xstart += columnwidth ;
	 colorcomp += colorgap ; //we choose the next color 
      }
      run++ ;
   }
}#include <QApplication>
#include strv
 
int main( int argc, char * argv[ ] ) {
   QApplication app( argc , argv ) ;
   MyWidget window ;
   window.setWindowTitle( QApplication::translate( strv , strv ) ) ;
   window.show( ) ;
   return app.exec( ) ;
}"
"#include <iostream>
#include <cstdlib>
#include <ctime>
 
int main()
{
    std::srand(std::time(0));
    int lower, upper, guess;
    std::cout << strv;
    std::cin >> lower;
    std::cout << strv;
    std::cin >> upper;
    int random_number = lower + std::rand() % ((upper + 1) - lower);
 
    do
    {
        std::cout << strv;
        std::cin >> guess;
        if (guess > random_number)
            std::cout << ""Your guess is too high"";
        else if (guess < random_number)
            std::cout << ""Your guess is too low"";
        else
            std::cout << ""You got it!"";
    } while (guess != random_number);
 
    return 0;
}"
"#include <utility>   // for std::pair
#include <iterator>  // for std::iterator_traits
#include <iostream>  // for std::cout
#include <ostream>   // for output operator and std::endl
#include <algorithm> // for std::copy
#include <iterator>  // for std::output_iterator
 


//






//
















//






template<typename ForwardIterator>
 std::pair<ForwardIterator, ForwardIterator>
 max_subseq(ForwardIterator begin, ForwardIterator end)
{
  typedef typename std::iterator_traits<ForwardIterator>::value_type
    value_type;
 
  ForwardIterator seq_begin = begin, seq_end = seq_begin;
  value_type seq_sum = value_type();
  ForwardIterator current_begin = begin;
  value_type current_sum = value_type();
 
  value_type zero = value_type();
 
  for (ForwardIterator iter = begin; iter != end; ++iter)
  {
    value_type value = *iter;
    if (zero < value)
    {
      if (current_sum < zero)
      {
        current_sum = zero;
        current_begin = iter;
      }
    }
    else
    {
      if (seq_sum < current_sum)
      {
        seq_begin = current_begin;
        seq_end = iter;
        seq_sum = current_sum;
      }
    }
    current_sum += value;
  }
 
  if (seq_sum < current_sum)
  {
    seq_begin = current_begin;
    seq_end = end;
    seq_sum = current_sum;
  }
 
  return std::make_pair(seq_begin, seq_end);
}
 


int array[] = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 };
 


template<typename T, int N> int* end(T (&arr)[N]) { return arr+N; }
 
int main()
{
  

  std::pair<int*, int*> seq = max_subseq(array, end(array));
 
  

  std::copy(seq.first, seq.second, std::ostream_iterator<int>(std::cout, strv));
  std::cout << std::endl;
 
  return 0;
}"
" 
#include <time.h>
#include <map>
#include <vector>
#include <algorithm>
#include <string>
#include <iostream>
 
const std::string s = strv, v = strv;
const int handCards = 9, drawCards = 3;
 
class card {
public:
    friend std::ostream& operator<< (std::ostream& os, const card& c ) { 
        os << v[c.val] << s[c.suit]; 
        return os;
    }
    bool isValid()                       { return val > -1; }
    void set( char s, char v )           { suit = s; val = v; }
    char getRank()                       { return v[val]; }
    bool operator == ( const char o )    { return v[val] == o; }
    bool operator < ( const card& a )    { if( val == a.val ) return suit < a.suit; return val < a.val; }
private:
    char                                 suit, val;
};
class deck {
public:
    static deck* instance() {
        if( !inst ) inst = new deck();
        return inst;
    }
    void destroy() {
        delete inst;
        inst = 0;
    }
    card draw() {
        card c;
        if( cards.size() > 0 ) { 
            c = cards.back();
            cards.pop_back();
            return c; 
        }
        c.set( -1, -1 );
        return c;
    }
private:
    deck() { 
        newDeck(); 
    }
    void newDeck() {
        card c; 
        for( char s = 0; s < 4; s++ ) {
            for( char v = 0; v < 13; v++ ) {
                c.set( s, v ); 
                cards.push_back( c ); 
            }
        }
        random_shuffle( cards.begin(), cards.end() );
        random_shuffle( cards.begin(), cards.end() );
    }
    static deck* inst;
    std::vector<card> cards;
};
class player {
public:
    player( std::string n ) : nm( n ) { 
        for( int x = 0; x < handCards; x++ )
            hand.push_back( deck::instance()->draw() );
        sort( hand.begin(), hand.end() );  
    }
    void outputHand() { 
        for( std::vector<card>::iterator x = hand.begin(); x != hand.end(); x++ ) 
            std::cout << ( *x ) << strv;
        std::cout << """"; 
    }
    bool addCard( card c ) { 
        hand.push_back( c );
        return checkForBook();
    }
    std::string name() { 
        return nm; 
    }
    bool holds( char c ) { 
        return( hand.end() != find( hand.begin(), hand.end(), c ) ); 
    }
    card takeCard( char c ) {
        std::vector<card>::iterator it = find( hand.begin(), hand.end(), c );
        std::swap( ( *it ), hand.back() );
        card d = hand.back();
        hand.pop_back();
        hasCards();
        sort( hand.begin(), hand.end() ); 
        return d;
    }
    size_t getBooksCount() {
        return books.size();
    }
    void listBooks() {
        for( std::vector<char>::iterator it = books.begin(); it != books.end(); it++ )
            std::cout << ( *it ) << strv;
        std::cout << """";
    }
    bool checkForBook() {
        bool ret = false;
        std::map<char, int> countMap;
        for( std::vector<card>::iterator it = hand.begin(); it != hand.end(); it++ )
            countMap[( *it ).getRank()]++;
        for( std::map<char, int>::iterator it = countMap.begin(); it != countMap.end(); it++ ) {
            if( ( *it ).second == 4 ) {
                do {
                    takeCard( ( *it ).first );
                } while( holds( ( *it ).first ) );
                books.push_back( ( *it ).first );
                ( *it ).second = 0;
                ret = true;
            }
        }
        sort( hand.begin(), hand.end() );
        return ret;
    }
    bool hasCards() {
        if( hand.size() < 1 ) {
            card c;
            for( int x = 0; x < drawCards; x++ ) {
                c = deck::instance()->draw();
                if( c.isValid() ) addCard( c );
                else break;
            }
        }
        return( hand.size() > 0 );
    }
protected:
    std::string nm; 
    std::vector<card> hand;
    std::vector<char> books;
};
class aiPlayer : public player {
public:
    aiPlayer( std::string n ) : player( n ), askedIdx( -1 ), lastAsked( 0 ), nextToAsk( -1 ) { }
    void rememberCard( char c ) {
        if( asked.end() != find( asked.begin(), asked.end(), c ) || !asked.size() )
            asked.push_back( c );  
    }
    char makeMove() {
        if( askedIdx < 0 || askedIdx >= static_cast<int>( hand.size() ) ) {
            askedIdx = rand() % static_cast<int>( hand.size() );
        }
 
        char c;
        if( nextToAsk > -1 ) {
            c = nextToAsk;
            nextToAsk = -1;
        } else {
            while( hand[askedIdx].getRank() == lastAsked ) {
                if( ++askedIdx == hand.size() ) {
                    askedIdx = 0;
                    break;
                }
            }
            c = hand[askedIdx].getRank();
            if( rand() % 100 > 25 && asked.size() ) {
                for( std::vector<char>::iterator it = asked.begin(); it != asked.end(); it++ ) {
		    if( holds( *it ) ) {
			c = ( *it );
			break;
		    }
		}
            }
        }
        lastAsked = c;
        return c;
    }
    void clearMemory( char c ) {
        std::vector<char>::iterator it = find( asked.begin(), asked.end(), c );
        if( asked.end() != it ) {
            std::swap( ( *it ), asked.back() );
            asked.pop_back();
        }
    }
    bool addCard( card c ) {
        if( !holds( c.getRank() ) )
            nextToAsk = c.getRank();
        return player::addCard( c );
    }
private:
    std::vector<char> asked;
    char nextToAsk, lastAsked;
    int askedIdx;
};
class goFish {
public:
    goFish() {
        plr = true; 
        std::string n; 
        std::cout << strv; std::cin >> n; 
        p1 = new player( n ); 
        p2 = new aiPlayer( strv );
    }
    ~goFish() { 
        if( p1 ) delete p1; 
        if( p2 ) delete p2;
        deck::instance()->destroy();
    }
    void play() {
        while( true ) {
            if( process( getInput() ) ) break;
        }
        std::cout << """";
        showBooks();
        if( p1->getBooksCount() > p2->getBooksCount() ) {
            std::cout << ""*** !!! CONGRATULATIONS !!! ***"";
        } else {
            std::cout << ""*** !!! YOU LOSE - HA HA HA !!! ***"";
        }
    }
private:
    void showBooks() {
        if( p1->getBooksCount() > 0 ) {
            std::cout << ""Your Book(s): "";
            p1->listBooks();
        }
        if( p2->getBooksCount() > 0 ) {
            std::cout << ""My Book(s): "";
            p2->listBooks();
        }
    }
    void showPlayerCards() {
        std::cout << """" << p1->name() << "", these are your cards:"";
        p1->outputHand();
        showBooks();
    }
    char getInput() {
        char c;
        if( plr ) {
            if( !p1->hasCards() ) return -1;
            showPlayerCards();
            std::string w;
            while( true ) {
                std::cout << ""What card(rank) do you want? ""; std::cin >> w;
                c = toupper( w[0] );
                if( p1->holds( c ) ) break; 
                std::cout << p1->name() << "", you can't ask for a card you don't have!""; 
            }
        } else {
            if( !p2->hasCards() ) return -1;
            c = p2->makeMove();
            showPlayerCards();
            std::string r;
            std::cout << ""Do you have any "" << c << strv;
            do {
                std::getline( std::cin, r );
                r = toupper( r[0] );
            }
            while( r[0] != 'Y' && r[0] != 'G' );
            bool hasIt = p1->holds( c );
            if( hasIt && r[0] == 'G' )
                std::cout << ""Are you trying to cheat me?! I know you do..."";
            if( !hasIt && r[0] == 'Y' )
                std::cout << ""Nooooo, you don't have it!!!"";
        }
        return c;
    }
    bool process( char c ) {
        if( c < 0 ) return true;
        if( plr ) p2->rememberCard( c );
 
        player *a, *b;
        a = plr ? p2 : p1;
        b = plr ? p1 : p2;
        bool r;
        if( a->holds( c ) ) {
            while( a->holds( c ) ) {
                r = b->addCard( a->takeCard( c ) );
            }
            if( plr && r )p2->clearMemory( c );
        } else {
            fish();
            plr = !plr;
        }
        return false;
    }
    void fish() {
        std::cout << ""  *** GO FISH! ***"";
        card c = deck::instance()->draw();
        if( plr ) {
            std::cout << strv << c << "".******** Your turn is over! ********"" << std::string( 36, '-' ) << """";
            if( p1->addCard( c ) ) p2->clearMemory( c.getRank() );
        } else {
            std::cout << ""********* My turn is over! *********"" << std::string( 36, '-' ) << """";
            p2->addCard( c );
        }
    }
 
    player        *p1;
    aiPlayer    *p2;
    bool        plr;
};
deck* deck::inst = 0;
int main( int argc, char* argv[] ) {
    srand( static_cast<unsigned>( time( NULL ) ) ); 
    goFish f;  f.play(); 
    return 0;
}
 "
"#include <algorithm>
#include <cassert>
 
template<typename Ty> Ty max(unsigned int count, Ty values[]) {
     assert(count > 0);
     return *std::max_element(values, values + count);
}"
"#include <fstream>
#include <iterator>
#include <boost/regex.hpp>
#include <string>
#include <iostream>
 
int main( int argc , char *argv[ ] ) {
   boost::regex to_be_replaced( ""Goodbye Londons*!"" ) ;
   std::string replacement( strv ) ;
   for ( int i = 1 ; i < argc ; i++ ) {
      std::ifstream infile ( argv[ i ] ) ;
      if ( infile ) {
	 std::string filetext( (std::istreambuf_iterator<char>( infile )) ,
	       std::istreambuf_iterator<char>( ) ) ;
	 std::string changed ( boost::regex_replace( filetext , to_be_replaced , replacement )) ;
	 infile.close( ) ;
	 std::ofstream outfile( argv[ i ] , std::ios_base::out | std::ios_base::trunc ) ;
	 if ( outfile.is_open( ) ) { 
	    outfile << changed ;
	    outfile.close( ) ;
	 }
      }
      else 
	 std::cout << strv << argv[ i ] << "" !"" ;
   }
   return 0 ;
}#include <regex>
#include <fstream>
 
using namespace std;
using ist = istreambuf_iterator<char>;
using ost = ostreambuf_iterator<char>;
 
int main(){
    auto from = strv, to = strv;
    for(auto filename : {strv, strv, strv}) {
        ifstream infile {filename};
        string content {ist {infile}, ist{}};
        infile.close();
        ofstream outfile {filename};
        regex_replace(ost {outfile}, begin(content), end(content), regex {from}, to);
    }
    return 0;
}
 "
"#include <iostream>
using namespace std;
 
template<class T>
class Generator
{
public:
  virtual T operator()() = 0;
};
 


template<class T, T P>
class PowersGenerator: Generator<T> {};
 


template<int P>
class PowersGenerator<int, P>: Generator<int>
{
public:
  int i;
  PowersGenerator() { i = 1; }
  virtual int operator()() 
  { 
    int o = 1; 
    for(int j = 0; j < P; ++j) o *= i; 
    ++i;
    return o; 
  }
};
 


template<class T, class G, class F>
class Filter: Generator<T>
{
public:
  G gen;
  F filter;
  T lastG, lastF;
 
  Filter() { lastG = gen(); lastF = filter(); }
 
  virtual T operator()() 
  {
    while(lastG >= lastF)
    {
      if(lastG == lastF)
        lastG = gen();
      lastF = filter();
    }
 
    T out = lastG;
    lastG = gen();
    return out;
  }
};
 
int main()
{
  Filter<int, PowersGenerator<int, 2>, PowersGenerator<int, 3>> gen;
 
  for(int i = 0; i < 20; ++i)
    gen();
 
  for(int i = 20; i < 30; ++i)
    cout << i << strv << gen() << endl;
}"
"template<typename T> void swap(T& left, T& right)
{
  T tmp(left);
  left = right;
  right = tmp;
}std::swap(x,y);template<class T>
void swap(T &lhs, T &rhs){
  T tmp = std::move(lhs);
  lhs = std::move(rhs);
  rhs = std::move(tmp);
}"
" 
#include <ctime>
#include <iostream>
#include <string>
#include <algorithm>
 
class chessBoard {
public:
    void generateRNDBoard( int brds ) {
        int a, b, i; char c;
        for( int cc = 0; cc < brds; cc++ ) {
            memset( brd, 0, 64 );
            std::string pieces = strv;
            random_shuffle( pieces.begin(), pieces.end() );
 
            while( pieces.length() ) {
                i = rand() % pieces.length(); c = pieces.at( i );
                while( true ) {
                    a = rand() % 8; b = rand() % 8;
                    if( brd[a][b] == 0 ) {
                        if( c == 'P' && !b || c == 'p' && b == 7 || 
                          ( ( c == 'K' || c == 'k' ) && search( c == 'k' ? 'K' : 'k', a, b ) ) ) continue;
                        break;
                    }
                }
                brd[a][b] = c;
                pieces = pieces.substr( 0, i ) + pieces.substr( i + 1 );
            }
            print();
        }
    }
private:
    bool search( char c, int a, int b ) {
        for( int y = -1; y < 2; y++ ) {
            for( int x = -1; x < 2; x++ ) {
                if( !x && !y ) continue;
                if( a + x > -1 && a + x < 8 && b + y >-1 && b + y < 8 ) {
                    if( brd[a + x][b + y] == c ) return true;
                }
            }
        }
        return false;
    }
    void print() {
        int e = 0;
        for( int y = 0; y < 8; y++ ) {
            for( int x = 0; x < 8; x++ ) {
                if( brd[x][y] == 0 ) e++;
                else {
                    if( e > 0 ) { std::cout << e; e = 0; }
                    std::cout << brd[x][y];
                }
            }
            if( e > 0 ) { std::cout << e; e = 0; } 
            if( y < 7 ) std::cout << strv;
        }
        std::cout << "" w - - 0 1"";
 
        for( int y = 0; y < 8; y++ ) {
            for( int x = 0; x < 8; x++ ) {
                if( brd[x][y] == 0 ) std::cout << strv;
                else std::cout << brd[x][y];
            }
            std::cout << """";
        }
 
        std::cout << """";
    }
    char brd[8][8];
};
int main( int argc, char* argv[] ) {
    srand( ( unsigned )time( 0 ) );
    chessBoard c;
    c.generateRNDBoard( 2 );
    return 0;
}
 "
"#include <string>
#include <numeric>
 
int main() {
    std::string lower(26,' ');
 
    std::iota(lower.begin(), lower.end(), 'a');
}"
" 
#include <iostream>
#include <string>
#include <time.h>
using namespace std;
 
namespace
{
    void placeRandomly(char* p, char c)
    {
	int loc = rand() % 8;
	if (!p[loc])
	    p[loc] = c;
	else
	    placeRandomly(p, c);    

    }
    int placeFirst(char* p, char c, int loc = 0)
    {
	while (p[loc]) ++loc;
	p[loc] = c;
        return loc;
    }
 
    string startPos()
    {
	char p[8]; memset( p, 0, 8 );
 
	

	p[2 * (rand() % 4)] = 'B';
	p[2 * (rand() % 4) + 1] = 'B';
 
	

	for (char c : strv)
	    placeRandomly(p, c);
 
	

	placeFirst(p, 'R', placeFirst(p, 'K', placeFirst(p, 'R')));
 
	return string(p, 8);
    }
}   

 
namespace chess960
{
    void generate( int c )
    {
	for( int x = 0; x < c; x++ )
	    cout << startPos() << """";
    }
}
 
int main( int argc, char* argv[] )
{
    srand( time( NULL ) );
    chess960::generate( 10 );
    cout << """";
    return system( strv );
}
 "
" 
#include <algorithm>
#include <iostream>
#include <vector>
#include <string>
 
class pair  {
public:
    pair( int s, std::string z )            { p = std::make_pair( s, z ); }
    bool operator < ( const pair& o ) const { return i() < o.i(); }
    int i() const                           { return p.first; }
    std::string s() const                   { return p.second; }
private:
    std::pair<int, std::string> p;
};
void gFizzBuzz( int c, std::vector<pair>& v ) {
    bool output;
    for( int x = 1; x <= c; x++ ) {
        output = false;
        for( std::vector<pair>::iterator i = v.begin(); i != v.end(); i++ ) {
            if( !( x % ( *i ).i() ) ) {
                std::cout << ( *i ).s();
                output = true;
            }
        }
        if( !output ) std::cout << x;
        std::cout << """";
    }
}
int main( int argc, char* argv[] ) {
    std::vector<pair> v;
    v.push_back( pair( 7, strv ) );
    v.push_back( pair( 3, strv ) );
    v.push_back( pair( 5, strv ) );
    std::sort( v.begin(), v.end() );
    gFizzBuzz( 20, v );
    return 0;
}
 "
" 
#include strv
#include <windows.h>
#include <stdlib.h>
 
const int BMP_WID = 410, BMP_HEI = 230, MAX_BALLS = 120;
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
 
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp;
    HDC     hdc;
    HPEN    pen;
    HBRUSH  brush;
    void    *pBits;
    int     width, height, wid;
    DWORD   clr;
};
class point {
public:
    int x; float y;
    void set( int a, float b ) { x = a; y = b; }
};
typedef struct {
    point position, offset;
    bool alive, start;
}ball;
class galton {
public :
    galton() {
        bmp.create( BMP_WID, BMP_HEI );
        initialize();
    }
    void setHWND( HWND hwnd ) { _hwnd = hwnd; }
    void simulate() {
        draw(); update(); Sleep( 1 );
    }
private:
    void draw() {
        bmp.clear();
        bmp.setPenColor( RGB( 0, 255, 0 ) );
        bmp.setBrushColor( RGB( 0, 255, 0 ) );
        int xx, yy;
        for( int y = 3; y < 14; y++ ) {
            yy = 10 * y;
            for( int x = 0; x < 41; x++ ) {
                xx = 10 * x;
                if( pins[y][x] )
                    Rectangle( bmp.getDC(), xx - 3, yy - 3, xx + 3, yy + 3 );
            }
        }
        bmp.setPenColor( RGB( 255, 0, 0 ) );
        bmp.setBrushColor( RGB( 255, 0, 0 ) );
        ball* b; 
        for( int x = 0; x < MAX_BALLS; x++ ) {
            b = &balls[x];
            if( b->alive )
                Rectangle( bmp.getDC(), static_cast<int>( b->position.x - 3 ), static_cast<int>( b->position.y - 3 ), 
                                        static_cast<int>( b->position.x + 3 ), static_cast<int>( b->position.y + 3 ) );
        }
        for( int x = 0; x < 70; x++ ) {
            if( cols[x] > 0 ) {
                xx = 10 * x;
                Rectangle( bmp.getDC(), xx - 3, 160, xx + 3, 160 + cols[x] );
            }
        }
        HDC dc = GetDC( _hwnd );
        BitBlt( dc, 0, 0, BMP_WID, BMP_HEI, bmp.getDC(), 0, 0, SRCCOPY );
        ReleaseDC( _hwnd, dc );
    }
    void update() {
        ball* b;
        for( int x = 0; x < MAX_BALLS; x++ ) {
            b = &balls[x];
            if( b->alive ) {
                b->position.x += b->offset.x; b->position.y += b->offset.y;
                if( x < MAX_BALLS - 1 && !b->start && b->position.y > 50.0f ) {
                    b->start = true;
                    balls[x + 1].alive = true;
                }
                int c = ( int )b->position.x, d = ( int )b->position.y + 6;
                if( d > 10 || d < 41 ) {
                    if( pins[d / 10][c / 10] ) {
                        if( rand() % 30 < 15 ) b->position.x -= 10;
                        else b->position.x += 10;
                    }
                }
                if( b->position.y > 160 ) {
                    b->alive = false;
                    cols[c / 10] += 1;
                }
            }
        }
    }
    void initialize() {
        for( int x = 0; x < MAX_BALLS; x++ ) {
            balls[x].position.set( 200, -10 );
            balls[x].offset.set( 0, 0.5f );
            balls[x].alive = balls[x].start = false;
        }
        balls[0].alive = true;
        for( int x = 0; x < 70; x++ )
            cols[x] = 0;
        for( int y = 0; y < 70; y++ )
            for( int x = 0; x < 41; x++ )
                pins[x][y] = false;
        int p;
        for( int y = 0; y < 11; y++ ) {
            p = ( 41 / 2 ) - y;
            for( int z = 0; z < y + 1; z++ ) {
                pins[3 + y][p] = true;
                p += 2;
            }
        }
    }
    myBitmap bmp;
    HWND _hwnd;
    bool pins[70][40];
    ball balls[MAX_BALLS];
    int cols[70];
};
class wnd {
public:
    int wnd::Run( HINSTANCE hInst ) {
        _hInst = hInst;
        _hwnd = InitAll();
        _gtn.setHWND( _hwnd );
        ShowWindow( _hwnd, SW_SHOW );
        UpdateWindow( _hwnd );
        MSG msg;
        ZeroMemory( &msg, sizeof( msg ) );
        while( msg.message != WM_QUIT ) {
            if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 ) {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            } else _gtn.simulate();
        }
        return UnregisterClass( strv, _hInst );
    }
private:
    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) {
        switch( msg ) {
            case WM_DESTROY: PostQuitMessage( 0 ); break;
            default:
                return static_cast<int>( DefWindowProc( hWnd, msg, wParam, lParam ) );
        }
        return 0;
    }
    HWND InitAll() {
        WNDCLASSEX wcex;
        ZeroMemory( &wcex, sizeof( wcex ) );
        wcex.cbSize           = sizeof( WNDCLASSEX );
        wcex.style           = CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc   = ( WNDPROC )WndProc;
        wcex.hInstance     = _hInst;
        wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
        wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
        wcex.lpszClassName = strv;
        RegisterClassEx( &wcex );
        RECT rc;
        SetRect( &rc, 0, 0, BMP_WID, BMP_HEI );
        AdjustWindowRect( &rc, WS_CAPTION, FALSE );
        return CreateWindow( strv, strv, WS_SYSMENU, CW_USEDEFAULT, 0, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, _hInst, NULL );
    }
    HINSTANCE _hInst;
    HWND      _hwnd;
    galton    _gtn;
};
int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow ) {
    srand( GetTickCount() );
    wnd myWnd; 
    return myWnd.Run( hInstance );
}
 "
"int noargs(); 

int twoargs(int a,int b); 

int twoargs(int ,int); 

int anyargs(...); 

int atleastoneargs(int, ...); 

template<typename T> T declval(T); //A function template
template<typename ...T> tuple<T...> make_tuple(T...); //Function template using parameter pack (since c++11)
 "
"inline double multiply(double a, double b)
{
   return a*b;
}template<typename Number>
  Number multiply(Number a, Number b)
{
   return a*b;
}"
"#include <functional>
#include <cmath>
#include <iostream>
 


template <class Fun1, class Fun2>
class compose_functor :
  public std::unary_function<typename Fun2::argument_type,
                             typename Fun1::result_type>
{
protected:
  Fun1 f;
  Fun2 g;
 
public:
  compose_functor(const Fun1& _f, const Fun2& _g)
    : f(_f), g(_g) { }
 
  typename Fun1::result_type
  operator()(const typename Fun2::argument_type& x) const
  { return f(g(x)); }
};
 




template <class Fun1, class Fun2>
inline compose_functor<Fun1, Fun2>
compose(const Fun1& f, const Fun2& g)
{ return compose_functor<Fun1,Fun2>(f, g); }
 
int main() {
  std::cout << compose(std::ptr_fun(::sin), std::ptr_fun(::asin))(0.5) << std::endl;
 
  return 0;
}#include <iostream>
#include <functional>
#include <cmath>
 
template <typename A, typename B, typename C>
std::function<C(A)> compose(std::function<C(B)> f, std::function<B(A)> g) {
  return [f,g](A x) { return f(g(x)); };
}
 
int main() {
  std::function<double(double)> f = sin;
  std::function<double(double)> g = asin;
  std::cout << compose(f, g)(0.5) << std::endl;
 
  return 0;
} 
#include <iostream>
#include <math.h>
 
template <class F, class G>
decltype(auto) compose(F&& f, G&& g)
{
    return [=](auto x) { return f(g(x)); };
}
 
int main() {
  std::cout << compose(sin, asin)(0.5) << """";
  return 0;
}
 #include <iostream>
#include <cmath>
#include <ext/functional>
 
int main() {
  std::cout << __gnu_cxx::compose1(std::ptr_fun(::sin), std::ptr_fun(::asin))(0.5) << std::endl;
 
  return 0;
}"
" 
#include <windows.h>
#include <string>
#include <math.h>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const float PI = 3.1415926536f;
 
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO	bi;
	void		*pBits;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize	   = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes	   = 1;
	bi.bmiHeader.biWidth	   =  w;
	bi.bmiHeader.biHeight	   = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc ); 
 
	width = w; height = h;
 
	return true;
    }
 
    void setPenColor( DWORD clr )
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, 1, clr );
	SelectObject( hdc, pen );
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER	fileheader;
	BITMAPINFO			infoheader;
	BITMAP				bitmap;
	DWORD*				dwpBits;
	DWORD				wb;
	HANDLE				file;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
 
	dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC()     { return hdc; }
    int getWidth()  { return width; }
    int getHeight() { return height; }
 
private:
    HBITMAP bmp;
    HDC	    hdc;
    HPEN    pen;
    int     width, height;
};
//--------------------------------------------------------------------------------------------------
class vector2
{
public:
    vector2() { x = y = 0; }
    vector2( int a, int b ) { x = a; y = b; }
    void set( int a, int b ) { x = a; y = b; }
    void rotate( float angle_r )
    {
	float _x = static_cast<float>( x ),
	      _y = static_cast<float>( y ),
	       s = sinf( angle_r ), 
	       c = cosf( angle_r ),
	       a = _x * c - _y * s, 
	       b = _x * s + _y * c;
 
	x = static_cast<int>( a ); 
	y = static_cast<int>( b );
    }
 
    int x, y;
};
//--------------------------------------------------------------------------------------------------
class fractalTree
{
public:
    fractalTree()		      { _ang = DegToRadian( 24.0f ); }
    float DegToRadian( float degree ) { return degree * ( PI / 180.0f ); }
 
    void create( myBitmap* bmp )
    {
	_bmp = bmp;
	float line_len = 130.0f;
 
	vector2 sp( _bmp->getWidth() / 2, _bmp->getHeight() - 1 );
	MoveToEx( _bmp->getDC(), sp.x, sp.y, NULL );
	sp.y -= static_cast<int>( line_len );
	LineTo( _bmp->getDC(), sp.x, sp.y);
 
	drawRL( &sp, line_len, 0, true );
	drawRL( &sp, line_len, 0, false );
    }
 
private:
    void drawRL( vector2* sp, float line_len, float a, bool rg )
    {
	line_len *= .75f;
	if( line_len < 2.0f ) return;
 
	MoveToEx( _bmp->getDC(), sp->x, sp->y, NULL );
	vector2 r( 0, static_cast<int>( line_len ) );
 
        if( rg ) a -= _ang;
        else a += _ang; 
 
	r.rotate( a );
	r.x += sp->x; r.y = sp->y - r.y;
 
	LineTo( _bmp->getDC(), r.x, r.y );
 
	drawRL( &r, line_len, a, true );
	drawRL( &r, line_len, a, false );
    }
 
    myBitmap* _bmp;
    float     _ang;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );
 
    myBitmap bmp;
    bmp.create( 640, 512 );
    bmp.setPenColor( RGB( 255, 255, 0 ) );
 
    fractalTree tree;
    tree.create( &bmp );
 
    BitBlt( GetDC( GetConsoleWindow() ), 0, 20, 648, 512, bmp.getDC(), 0, 0, SRCCOPY );
 
    bmp.saveBitmap( strv );
 
    system( strv );
 
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
" 
#include <iostream>
#include <sstream>
#include <iterator>
#include <vector>
#include <cmath>
 
using namespace std;
 
class fractran
{
public:
    void run( std::string p, int s, int l  )
    {
        start = s; limit = l;
        istringstream iss( p ); vector<string> tmp;
        copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( tmp ) );
 
        string item; vector< pair<float, float> > v;
	pair<float, float> a;
	for( vector<string>::iterator i = tmp.begin(); i != tmp.end(); i++ )
	{
	    string::size_type pos = ( *i ).find( '/', 0 );
	    if( pos != std::string::npos )
	    {
		a = make_pair( atof( ( ( *i ).substr( 0, pos ) ).c_str() ), atof( ( ( *i ).substr( pos + 1 ) ).c_str() ) );
		v.push_back( a );
	    }
	}
 
	exec( &v );
    }
 
private:
    void exec( vector< pair<float, float> >* v )
    {
	int cnt = 0;
	while( cnt < limit )
	{
	    cout << cnt << strv << start << """";
	    cnt++;
	    vector< pair<float, float> >::iterator it = v->begin();
	    bool found = false; float r;
	    while( it != v->end() )
	    {
		r  = start * ( ( *it ).first / ( *it ).second );
		if( r == floor( r ) )
		{
		    found = true;
		    break;
		}
		++it;
	    }
 
	    if( found ) start = ( int )r;
	    else break;
	}
    }
    int start, limit;
};
int main( int argc, char* argv[] )
{
    fractran f; f.run( strv, 2, 15 );
    cin.get();
    return 0;
}
 "
"#include <vector>
#include <iterator>
#include <algorithm>
 
















template<typename InputIterator, typename OutputIterator>
 OutputIterator forward_difference(InputIterator first, InputIterator last,
                                   OutputIterator dest)
{
  

  if (first == last)
    return dest;
 
  typedef typename std::iterator_traits<InputIterator>::value_type value_type;
 
  value_type temp = *first++;
  while (first != last)
  {
    value_type temp2 = *first++;
    *dest++ = temp2 - temp;
    temp = temp2;
  }
 
  return dest;
}
 




















template<typename InputIterator, typename OutputIterator>
 OutputIterator nth_forward_difference(int order,
                                       InputIterator first, InputIterator last,
                                       OutputIterator dest)
{
  

  if (order == 0)
    return std::copy(first, last, dest);
 
  

  if (order == 1)
    return forward_difference(first, last, dest);
 
  

  typedef typename std::iterator_traits<InputIterator>::value_type value_type;
  std::vector<value_type> temp_storage;
 
  

  forward_difference(first, last, std::back_inserter(temp_storage));
 
  

  typename std::vector<value_type>::iterator begin = temp_storage.begin(),
                                             end = temp_storage.end();
  for (int i = 1; i < order-1; ++i)
    end = forward_difference(begin, end, begin);
 
  

  return forward_difference(begin, end, dest);
}
 


#include <iostream>
 
int main()
{
  double array[10] = { 90.0, 47.0, 58.0, 29.0, 22.0, 32.0, 55.0, 5.0, 55.0, 73.0 };
 
  

  std::vector<double> dest;
  nth_forward_difference(1, array, array+10, std::back_inserter(dest));
 
  

  std::copy(dest.begin(), dest.end(), std::ostream_iterator<double>(std::cout, strv));
  std::cout << std::endl;
 
  

  nth_forward_difference(2, array, array+10, std::ostream_iterator<double>(std::cout, strv));
  std::cout << std::endl;
 
  nth_forward_difference(9, array, array+10, std::ostream_iterator<double>(std::cout, strv));
  std::cout << std::endl;
 
  nth_forward_difference(10, array, array+10, std::ostream_iterator<double>(std::cout, strv));
  std::cout << std::endl;
 
  nth_forward_difference(0, array, array+10, std::ostream_iterator<double>(std::cout, strv));
  std::cout << std::endl;
 
  

  

  double* end = nth_forward_difference(3, array, array+10, array);
 
  for (double* p = array; p < end; ++p)
    std::cout << *p << strv;
  std::cout << std::endl;
 
  return 0;
} 
#include <iostream>
#include <numeric>


//


//
int main() {
    int x[] = {NULL,-43,11,-29,-7,10,23,-50,50,18};
    const int N = sizeof(x) / sizeof(int) - 1;
    for (int ord = 0; ord < N - 1; ord++) {
        std::adjacent_difference(x+1, x + N + 1 - ord, x);
        for (int i = 1; i < N - ord; i++) std::cout << x[i] << ' ';
        std::cout << std::endl;
    }
    return 0;
}
  
#include <iostream>
#include <numeric>


//


//
int main() {
    int x[] = {NULL,-43,11,-29,-7,10,23,-50,50,18};
    const int N = sizeof(x) / sizeof(int) - 1;
    for (int ord = 0; ord < N - 1; ord++) std::adjacent_difference(x+1, x + N + 1 - ord, x);
    std::cout << x[1] << std::endl;
    return 0;
}
  
#include <iostream>
#include <algorithm>








//
int main() {
    const int P[] = {1,-8,28,-56,70,-56,28,-8,1};
    int x[] = {-43,11,-29,-7,10,23,-50,50,18};
    std::transform(x, x + sizeof(x) / sizeof(int), P, x, std::multiplies<int>());
    std::cout << std::accumulate(x, x + sizeof(x) / sizeof(int), 0) << std::endl;
    return 0;
}
 "
"#include<iostream>
#include<unistd.h>
 
int main()
{
  pid_t pid = fork();
 
  if (pid == 0)
  {
    std::cout << ""This is the new process"";
  }
  else if (pid > 0)
  {
    std::cout << ""This is the original process"";
  }
  else
  {
    std::cerr << ""ERROR: Something went wrong"";
  }
 
  return 0;
}"
"#include <iostream>
#include <iomanip>
 
int main()
{
  std::cout << std::setfill('0') << std::setw(9) << std::fixed << std::setprecision(3) << 7.125 << std::endl;
  return 0;
}"
"#include <iostream> 
 
int main()
{
 LOOP:
  std::cout << ""Hello, World!"";
 goto LOOP;
}#include <iostream>
#include <ostream>
 
void foo()
{
  std::cout << ""Going to throw an exception."";
  throw 7; 

  std::throw << ""This output will never execute."";
}
 
void bar()
{
  std::cout << ""Going to call foo()."";
  foo();
  std::cout << ""This will be skipped by the exception coming from foo."";
}
 
void baz()
{
  try 

  {   

    std::cout << ""Going to call bar()."";
    bar();
    std::cout << ""This will be skipped by the exception coming from foo."";
  }
  catch(...) 

  {
    std::cout << ""An exception occured. I'll just throw it on."";
    throw; 

  }
  std::cout << ""This will not be executed due to the re-throw in the catch block"";
}
 
void foobar()
{
  try
  {
    baz();
  }
  catch(char const* s)
  {
    std::cout << ""If foo had thrown a char const*, this code would be executed."";
    std::cout << strv << s << ""."";
  }
  catch(int i)
  {
    std::cout << strv << i << "" (should be 7)."";
    std::cout << ""Not rethrowing the int."";
  }
  catch(...)
  {
    std::cout << ""This catch-all doesn't get invoked because the catch(int) above""
              << ""already took care of the exception (even if it had rethrown the""
              << ""exception, this catch-all would not be invoked, because it's""
              << ""only invoked for exceptions coming from the try block."";
  }
  std::cout << ""This will be executed, since the exception was handled above, and not rethrown."";
}
 
int main()
{
  try
  {
    foobar();
  }
  catch(...)
  {
    std::cout << ""The main function never sees the exception, because it's completely handled""
              << ""inside foobar(). Thus this catch-all block never gets invoked."";
  }
}"
" 
#include <windows.h>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
enum states { NONE, TREE, FIRE };
const int MAX_SIDE = 500;
 
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO	bi;
	ZeroMemory( &bi, sizeof( bi ) );
 
	bi.bmiHeader.biSize	   = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes	   = 1;
	bi.bmiHeader.biWidth	   =  w;
	bi.bmiHeader.biHeight	   = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc ); 
 
	width = w; height = h;
 
	return true;
    }
 
    void clear()
    {
	ZeroMemory( pBits, width * height * sizeof( DWORD ) );
    }
 
    void setPenColor( DWORD clr )
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, 1, clr );
	SelectObject( hdc, pen );
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO	 infoheader;
	BITMAP		 bitmap;
	DWORD		 wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
 
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    HBITMAP bmp;
    HDC	    hdc;
    HPEN    pen;
    void	*pBits;
    int	    width, height;
};
//--------------------------------------------------------------------------------------------------
class forest
{
public:
    forest()
    {
	_bmp.create( MAX_SIDE, MAX_SIDE ); 
	initForest( 0.05f, 0.005f );
    }
 
    void initForest( float p, float f )
    {
	_p = p; _f = f;
	seedForest();
    }
 
    void mainLoop()
    {
	display();
	simulate();
    }
 
    void setHWND( HWND hwnd ) { _hwnd = hwnd; }
 
private:
    float probRand() { return ( float )rand() / 32768.0f; }
 
    void display()
    {
	HDC bdc = _bmp.getDC();
	DWORD clr;
 
	for( int y = 0; y < MAX_SIDE; y++ )
	{
	    for( int x = 0; x < MAX_SIDE; x++ )
	    {
		switch( _forest[x][y] )
		{
		    case FIRE: clr = 255; break;
		    case TREE: clr = RGB( 0, 255, 0 ); break;
		    default: clr = 0;
		}
 
		SetPixel( bdc, x, y, clr );
	    }
	}
 
	HDC dc = GetDC( _hwnd );
	BitBlt( dc, 0, 0, MAX_SIDE, MAX_SIDE, _bmp.getDC(), 0, 0, SRCCOPY );
	ReleaseDC( _hwnd, dc );
    }
 
    void seedForest()
    {
	ZeroMemory( _forestT, sizeof( _forestT ) );
	ZeroMemory( _forest, sizeof( _forest ) );
	for( int y = 0; y < MAX_SIDE; y++ )
	    for( int x = 0; x < MAX_SIDE; x++ )
		if( probRand() < _p ) _forest[x][y] = TREE;
    }
 
    bool getNeighbors( int x, int y )
    {
	int a, b;
	for( int yy = -1; yy < 2; yy++ )
	    for( int xx = -1; xx < 2; xx++ )
	    {
		if( !xx && !yy ) continue;
		a = x + xx; b = y + yy;
		if( a < MAX_SIDE && b < MAX_SIDE && a > -1 && b > -1 )
		if( _forest[a][b] == FIRE ) return true;
	    }
 
	return false;
    }
 
    void simulate()
    {
	for( int y = 0; y < MAX_SIDE; y++ )
	{
	    for( int x = 0; x < MAX_SIDE; x++ )
	    {
		switch( _forest[x][y] )
		{
		    case FIRE: _forestT[x][y] = NONE; break;
		    case NONE: if( probRand() < _p ) _forestT[x][y] = TREE; break;
		    case TREE: if( getNeighbors( x, y ) || probRand() < _f ) _forestT[x][y] = FIRE;
		}
	    }
	}
 
	for( int y = 0; y < MAX_SIDE; y++ )
	    for( int x = 0; x < MAX_SIDE; x++ )
		_forest[x][y] = _forestT[x][y];
    }
 
    myBitmap _bmp;
    HWND     _hwnd;
    BYTE     _forest[MAX_SIDE][MAX_SIDE], _forestT[MAX_SIDE][MAX_SIDE];
    float    _p, _f;
};
//--------------------------------------------------------------------------------------------------
class wnd
{
public:
    int wnd::Run( HINSTANCE hInst )
    {
	_hInst = hInst;
	_hwnd = InitAll();
 
	_ff.setHWND( _hwnd );
	_ff.initForest( 0.02f, 0.001f );
 
	ShowWindow( _hwnd, SW_SHOW );
	UpdateWindow( _hwnd );
 
	MSG msg;
	ZeroMemory( &msg, sizeof( msg ) );
	while( msg.message != WM_QUIT )
	{
	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
	    {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	    }
	    else
	    {
		_ff.mainLoop();
	    }
	}
	return UnregisterClass( strv, _hInst );
    }
private:
    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
    {
	switch( msg )
	{
	    case WM_DESTROY: PostQuitMessage( 0 ); break;
	    default:
		return DefWindowProc( hWnd, msg, wParam, lParam );
	}
	return 0;
    }
 
    HWND InitAll()
    {
	WNDCLASSEX wcex;
	ZeroMemory( &wcex, sizeof( wcex ) );
	wcex.cbSize	       = sizeof( WNDCLASSEX );
	wcex.style	       = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc   = ( WNDPROC )WndProc;
	wcex.hInstance     = _hInst;
	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
	wcex.lpszClassName = strv;
 
	RegisterClassEx( &wcex );
 
	return CreateWindow( strv, strv, WS_SYSMENU, CW_USEDEFAULT, 0, MAX_SIDE, MAX_SIDE, NULL, NULL, _hInst, NULL );
    }
 
    HINSTANCE _hInst;
    HWND      _hwnd;
    forest    _ff;
};
//--------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    srand( GetTickCount() );
    wnd myWnd;
    return myWnd.Run( hInstance );
}
//--------------------------------------------------------------------------------------------------
 "
" 
#include <time.h>
#include <iostream>
#include <string>
 
typedef unsigned char byte;
using namespace std;
 
class flip
{
public:
    flip() { field = 0; target = 0; }
    void play( int w, int h ) { wid = w; hei = h; createField(); gameLoop(); }
 
private:
    void gameLoop()
    {
	int moves = 0;
	while( !solved() )
	{
	    display(); string r; cout << strv; cin >> r;
	    for( string::iterator i = r.begin(); i != r.end(); i++ )
	    {
		byte ii = ( *i );
		if( ii - 1 >= '0' && ii - 1 <= '9' ) { flipCol( ii - '1' ); moves++; }
		else if( ii >= 'a' && ii <= 'z' ) { flipRow( ii - 'a' ); moves++; }
	    }
	}
	cout << endl << endl << strv << endl << strv << moves << strv << endl << endl;
    }
 
    void display()
    { system( strv ); output( strv, target ); output( strv, field ); }
 
    void output( string t, byte* f )
    {
	cout << t << endl;
	cout << strv; for( int x = 0; x < wid; x++ ) cout << strv << static_cast<char>( x + '1' ); cout << endl;
	for( int y = 0; y < hei; y++ )
	{
	    cout << static_cast<char>( y + 'a' ) << strv;
	    for( int x = 0; x < wid; x++ )
		cout << static_cast<char>( f[x + y * wid] + 48 ) << strv;
	    cout << endl;
	}
	cout << endl << endl;
    }
 
    bool solved()
    {
	for( int y = 0; y < hei; y++ )
	    for( int x = 0; x < wid; x++ )
		if( target[x + y * wid] != field[x + y * wid] ) return false;
	return true;
    }
 
    void createTarget()
    {
	for( int y = 0; y < hei; y++ )
	    for( int x = 0; x < wid; x++ )
		if( frnd() < .5f ) target[x + y * wid] = 1;
	        else target[x + y * wid] = 0;
	memcpy( field, target, wid * hei );
    }
 
    void flipCol( int c )
    { for( int x = 0; x < hei; x++ ) field[c + x * wid] = !field[c + x * wid]; }
 
    void flipRow( int r )
    { for( int x = 0; x < wid; x++ ) field[x + r * wid] = !field[x + r * wid]; }
 
    void calcStartPos()
    {
	int flips = ( rand() % wid + wid + rand() % hei + hei ) >> 1;
	for( int x = 0; x < flips; x++ )
	{ if( frnd() < .5f ) flipCol( rand() % wid ); else flipRow( rand() % hei ); }
    }
 
    void createField()
    {
        if( field ){ delete [] field; delete [] target; }
        int t = wid * hei; field = new byte[t]; target = new byte[t];
	memset( field, 0, t ); memset( target, 0, t ); createTarget();
	while( true ) { calcStartPos(); if( !solved() ) break; }
    }
 
    float frnd() { return static_cast<float>( rand() ) / static_cast<float>( RAND_MAX ); }
 
    byte* field, *target; int wid, hei;
};
 
int main( int argc, char* argv[] )
{ srand( time( NULL ) ); flip g; g.play( 3, 3 ); return system( strv ); }
 "
"#include <vector>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <algorithm>
#include <iostream>
#include <iterator>
using namespace boost::gregorian ;
 
void print( const date &d ) {
   std::cout << d.year( ) << strv << d.month( ) << """" ;
}
 
int main( ) {
   greg_month longmonths[ ] = {Jan, Mar , May , Jul ,
      Aug , Oct , Dec } ;
   int monthssize = sizeof ( longmonths ) / sizeof (greg_month ) ;
   typedef std::vector<date> DateVector ;
   DateVector weekendmonster ;
   std::vector<unsigned short> years_without_5we_months ;
   for ( unsigned short i = 1900 ; i < 2101 ; i++ ) {
      bool months_found = false ; //does a given year have 5 weekend months ?
      for ( int j = 0 ; j < monthssize ; j++ ) {
	 date d ( i , longmonths[ j ] , 1 ) ;
	 if ( d.day_of_week( ) == Friday ) {  //for the month to have 5 weekends
	    weekendmonster.push_back( d ) ;
	    if ( months_found == false )
	       months_found = true ;
         }
      }
      if ( months_found == false ) {
	 years_without_5we_months.push_back( i ) ;
      }
   }
   std::cout << strv << weekendmonster.size( )
      << "" months with 5 complete weekends!"" ;
   std::cout << ""Months with 5 complete weekends are:"" ;
   std::for_each( weekendmonster.begin( ) , weekendmonster.end( ) , print ) ;
   std::cout <<  years_without_5we_months.size( ) << "" years had no months with 5 complete weekends!"" ;
   std::cout << ""These are:"" ;
   std::copy( years_without_5we_months.begin( ) , years_without_5we_months.end( ) ,
	 std::ostream_iterator<unsigned short>( std::cout , """" ) ) ;
   std::cout << std::endl ;
   return 0 ;
}"
" 
#include <windows.h>
#include <sstream>
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class floyds_tri
{
public:
    floyds_tri()  { lastLineLen = 0; }
    ~floyds_tri() { killArray(); }
 
    void create( int rows )
    {
	_rows = rows;
	calculateLastLineLen();
	display();
    }
 
private:
    void killArray()
    {
	if( lastLineLen ) 
	    delete [] lastLineLen;
    }
 
    void calculateLastLineLen()
    {
	killArray();
	lastLineLen = new BYTE[_rows];
 
	int s = 1 + ( _rows * ( _rows - 1 ) ) / 2;
 
	for( int x = s, ix = 0; x < s + _rows; x++, ix++ )
	{
	    ostringstream cvr;
	    cvr << x;
	    lastLineLen[ix] = static_cast<BYTE>( cvr.str().size() );
	}
    }
 
    void display()
    {
	cout << endl << ""Floyds Triangle - "" << _rows << strv << endl << strv << endl;
	int number = 1;
	for( int r = 0; r < _rows; r++ )
	{
	    for( int c = 0; c <= r; c++ )
	    {
		ostringstream cvr;
		cvr << number++;
		string str = cvr.str();
		while( str.length() < lastLineLen[c] )
		    str = strv + str;
		cout << str << strv;
	    }
	    cout << endl;
	}
    }
 
    int _rows;
    BYTE* lastLineLen;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    floyds_tri t;
    int s;
    while( true )
    {
	cout << strv; cin >> s;
	if( !s ) return 0;
	if( s > 0 ) t.create( s );
 
	cout << endl << endl;
	system( strv );
    }
 
    return 0;
}
//--------------------------------------------------------------------------------------------------"
"#include <list>
#include <boost/any.hpp>
 
typedef std::list<boost::any> anylist;
 
void flatten(std::list<boost::any>& list)
{
  typedef anylist::iterator iterator;
 
  iterator current = list.begin();
  while (current != list.end())
  {
    if (current->type() == typeid(anylist))
    {
      iterator next = current;
      ++next;
      list.splice(next, boost::any_cast<anylist&>(*current));
      current = list.erase(current);
    }
    else
      ++current;
  }
}#include <cctype>
#include <iostream>
 






 
void skipwhite(char const** s)
{
  while (**s && std::isspace((unsigned char)**s))
  {
    ++*s;
  }
}
 
anylist create_anylist_i(char const** s)
{
  anylist result;
  skipwhite(s);
  if (**s != '[')
    throw strv;
  ++*s;
  while (true)
  {
    skipwhite(s);
    if (!**s)
      throw strv;
    else if (**s == ']')
    {
      ++*s;
      return result;
    }
    else if (**s == '[')
      result.push_back(create_anylist_i(s));
    else if (std::isdigit((unsigned char)**s))
    {
      int i = 0;
      while (std::isdigit((unsigned char)**s))
      {
        i = 10*i + (**s - '0');
        ++*s;
      }
      result.push_back(i);
    }
    else
      throw strv;
 
    skipwhite(s);
    if (**s != ',' && **s != ']')
      throw strv;
    if (**s == ',')
      ++*s;
  }
}
 
anylist create_anylist(char const* i)
{
  return create_anylist_i(&i);
}
 






 
void print_list(anylist const& list);
 
void print_item(boost::any const& a)
{
  if (a.type() == typeid(int))
    std::cout << boost::any_cast<int>(a);
  else if (a.type() == typeid(anylist))
    print_list(boost::any_cast<anylist const&>(a));
  else
    std::cout << strv;
}
 
void print_list(anylist const& list)
{
  std::cout << '[';
  anylist::const_iterator iter = list.begin();
  while (iter != list.end())
  {
    print_item(*iter);
    ++iter;
    if (iter != list.end())
      std::cout << strv;
  }
  std::cout << ']';
}
 






 
int main()
{
  anylist list =
    create_anylist(strv);
  print_list(list);
  std::cout << """";
  flatten(list);
  print_list(list);
  std::cout << """";
}"
" 
#include <functional>
#include <algorithm>
#include <iostream>
#include <vector>
#include <cmath>
 
using std::cout;
using std::endl;
using std::vector;
using std::function;
using std::transform;
using std::back_inserter;
 
typedef function<double(double)> FunType;
 
vector<FunType> A = {sin, cos, tan, [](double x) { return x*x*x; } };
vector<FunType> B = {asin, acos, atan, [](double x) { return exp(log(x)/3); } };
 
template <typename A, typename B, typename C>
function<C(A)> compose(function<C(B)> f, function<B(A)> g) {
    return [f,g](A x) { return f(g(x)); };
}
 
int main() {
    vector<FunType> composedFuns;
    auto exNums = {0.0, 0.2, 0.4, 0.6, 0.8, 1.0};
 
    transform(B.begin(), B.end(),
                A.begin(),
                back_inserter(composedFuns),
                compose<double, double, double>);
 
    for (auto num: exNums)
        for (auto fun: composedFuns)
            cout << u8""f.f("" << num << strv << fun(num) << endl;
 
    return 0;
}
 "
"#include <algorithm>
#include <vector>
#include <set>
#include <iterator>
#include <iostream>
#include <string>
 
static const std::string GivenPermutations[] = {
  strv,strv,strv,strv,
  strv,strv,strv,strv,
  strv,strv,strv,strv,
  strv,strv,strv,strv,
  strv,strv,strv,strv,
  strv,strv,strv
};
static const size_t NumGivenPermutations = sizeof(GivenPermutations) / sizeof(*GivenPermutations);
 
int main()
{
    std::vector<std::string> permutations;
    std::string initial = strv;
    permutations.push_back(initial);
 
    while(true)
    {
        std::string p = permutations.back();
        std::next_permutation(p.begin(), p.end());
        if(p == permutations.front())
            break;
        permutations.push_back(p);
    }
 
    std::vector<std::string> missing;
    std::set<std::string> given_permutations(GivenPermutations, GivenPermutations + NumGivenPermutations);
    std::set_difference(permutations.begin(), permutations.end(), given_permutations.begin(),
        given_permutations.end(), std::back_inserter(missing));
    std::copy(missing.begin(), missing.end(), std::ostream_iterator<std::string>(std::cout, """"));
    return 0;
}"
"#include <iostream>
#include <cmath>
#include <assert.h>
using namespace std;
 
/** Calculate determinant of matrix:	[a b]	[c d]*/
inline double Det(double a, double b, double c, double d)
{
	return a*d - b*c;
}
 
///Calculate intersection of two lines.
///\return true if found, false if not found or error
bool LineLineIntersect(double x1, double y1, //Line 1 start
	double x2, double y2, //Line 1 end
	double x3, double y3, //Line 2 start
	double x4, double y4, //Line 2 end
	double &ixOut, double &iyOut) //Output 
{
	double detL1 = Det(x1, y1, x2, y2);
	double detL2 = Det(x3, y3, x4, y4);
	double x1mx2 = x1 - x2;
	double x3mx4 = x3 - x4;
	double y1my2 = y1 - y2;
	double y3my4 = y3 - y4;
 
	double xnom = Det(detL1, x1mx2, detL2, x3mx4);
	double ynom = Det(detL1, y1my2, detL2, y3my4);
	double denom = Det(x1mx2, y1my2, x3mx4, y3my4);
	if(denom == 0.0)//Lines don't seem to cross
	{
		ixOut = NAN;
		iyOut = NAN;
		return false;
	}
 
	ixOut = xnom / denom;	
	iyOut = ynom / denom;
	if(!isfinite(ixOut) || !isfinite(iyOut)) //Probably a numerical issue
		return false;
 
	return true; //All OK
}
 
int main()
{
	

 
	//Line 1
	double x1=4.0, y1=0.0;
	double x2=6.0, y2=10.0;
 
	//Line 2
	double x3=0.0, y3=3.0;
	double x4=10.0, y4=7.0;
 
	double ix = -1.0, iy = -1.0;
	bool result = LineLineIntersect(x1, y1, x2, y2, x3, y3, x4, y4, ix, iy);
	cout << strv <<  result << strv << ix << strv << iy << endl;
 
	double eps = 1e-6;
	assert(result == true);
	assert(fabs(ix - 5.0) < eps);
	assert(fabs(iy - 5.0) < eps);
 
}"
"#include <iostream>
 
using namespace std;
int main ()
{
       for (int i = 1; i <= 100; i++) 
       {
               if ((i % 15) == 0)
                       cout << ""FizzBuzz"";
               else if ((i % 3) == 0)
                       cout << ""Fizz"";
               else if ((i % 5) == 0)
                       cout << ""Buzz"";
               else
                       cout << i << """";
       }
       return 0;
}#include <iostream>
using namespace std;
 
int main()
{
  for (int i = 0; i <= 100; ++i)
  {
    bool fizz = (i % 3) == 0;
    bool buzz = (i % 5) == 0;
    if (fizz)
      cout << strv;
    if (buzz)
      cout << strv;
    if (!fizz && !buzz)
      cout << i;
    cout << """";
  }
  return 0;
}#include <iostream>
 
int main()
{
    int i, f = 2, b = 4; 
 
    for ( i = 1 ; i <= 100 ; ++i, --f, --b )
    {
        if ( f && b ) { std::cout << i;             }
        if ( !f )     { std::cout << strv; f = 3; }
        if ( !b )     { std::cout << strv; b = 5; }
        std::cout << std::endl;
    }
 
    return 0;
}
 #include <iostream>                                                                                                     
#include <algorithm>
#include <vector>
 
int main()
{
  std::vector<int> range(100);
  std::iota(range.begin(), range.end(), 1);
 
  std::vector<std::string> values;
  values.resize(range.size());
 
  auto fizzbuzz = [](int i) -> std::string {
    if ((i%15) == 0) return strv;
    if ((i%5) == 0)  return strv;
    if ((i%3) == 0)  return strv;
    return std::to_string(i);
  };
 
  std::transform(range.begin(), range.end(), values.begin(), fizzbuzz);
 
  for (auto& str: values) std::cout << str << std::endl;
 
  return 0;
}#include <iostream>
 
template <int n, int m3, int m5> 
struct fizzbuzz : fizzbuzz<n-1, (n-1)%3, (n-1)%5>
{
  fizzbuzz() 
  { std::cout << n << std::endl; }
};
 
template <int n>
struct fizzbuzz<n, 0, 0> : fizzbuzz<n-1, (n-1)%3, (n-1)%5>
{
  fizzbuzz() 
  { std::cout << strv << std::endl; }
};
 
template <int n, int p>
struct fizzbuzz<n, 0, p> : fizzbuzz<n-1, (n-1)%3, (n-1)%5>
{
  fizzbuzz() 
  { std::cout << strv << std::endl; }
};
 
template <int n, int p>
struct fizzbuzz<n, p, 0> : fizzbuzz<n-1, (n-1)%3, (n-1)%5>
{
  fizzbuzz() 
  { std::cout << strv << std::endl; }
};
 
template <>
struct fizzbuzz<0,0,0>
{
  fizzbuzz() 
  { std::cout << 0 << std::endl; }
};
 
template <int n>
struct fb_run
{
  fizzbuzz<n, n%3, n%5> fb;
};
 
int main()
{
  fb_run<100> fb;
  return 0;
}#include <iostream>
#include <string>
#include <cstdlib>
#include <boost/mpl/string.hpp>
#include <boost/mpl/fold.hpp>
#include <boost/mpl/size_t.hpp>
 
using namespace std;
using namespace boost;
 
///////////////////////////////////////////////////////////////////////////////


template <int accum, int base, int exp> struct POWER_CORE : POWER_CORE<accum * base, base, exp - 1>{};
 
template <int accum, int base>
struct POWER_CORE<accum, base, 0>
{
    enum : int { val = accum };
};
 
template <int base, int exp> struct POWER : POWER_CORE<1, base, exp>{};
 
///////////////////////////////////////////////////////////////////////////////


template <int depth, unsigned int i> struct NUM_DIGITS_CORE : NUM_DIGITS_CORE<depth + 1, i / 10>{};
 
template <int depth>
struct NUM_DIGITS_CORE<depth, 0>
{
    enum : int { val = depth};
};
 
template <int i> struct NUM_DIGITS : NUM_DIGITS_CORE<0, i>{};
 
template <>
struct NUM_DIGITS<0>
{
    enum : int { val = 1 };
};
 
///////////////////////////////////////////////////////////////////////////////


template <int i>
struct DIGIT_TO_CHAR
{
    enum : char{ val = i + 48 };
};
 
///////////////////////////////////////////////////////////////////////////////


template <unsigned int i, int place> 

struct DIGIT_AT
{
    enum : char{ val = (i / POWER<10, place>::val) % 10 };
};
 
struct NULL_CHAR
{
    enum : char{ val = '' };
};
 
///////////////////////////////////////////////////////////////////////////////


template <unsigned int i, int place> 

    struct ALT_CHAR : DIGIT_TO_CHAR< DIGIT_AT<i, place>::val >{};
 
///////////////////////////////////////////////////////////////////////////////


 


template <unsigned int i, int offset, int numDigits, bool inRange>  
    struct OFFSET_CHAR_CORE_CHECKED{};
template <unsigned int i, int offset, int numDigits>                
    struct OFFSET_CHAR_CORE_CHECKED<i, offset, numDigits, false> : NULL_CHAR{};
template <unsigned int i, int offset, int numDigits>                
    struct OFFSET_CHAR_CORE_CHECKED<i, offset, numDigits, true>  : ALT_CHAR<i, (numDigits - offset) - 1 >{};
 


template <unsigned int i, int offset, int numDigits>
    struct OFFSET_CHAR_CORE : OFFSET_CHAR_CORE_CHECKED<i, offset, numDigits, offset < numDigits>{};
 


template <unsigned int i, int offset>
    struct OFFSET_CHAR : OFFSET_CHAR_CORE<i, offset, NUM_DIGITS<i>::val>{};
 
///////////////////////////////////////////////////////////////////////////////


template <unsigned int i>
struct IntToStr
{
    const static char str[];
    typedef typename mpl::string<
    OFFSET_CHAR<i, 0>::val,
    OFFSET_CHAR<i, 1>::val,
    OFFSET_CHAR<i, 2>::val,
    OFFSET_CHAR<i, 3>::val,
    OFFSET_CHAR<i, 4>::val,
    OFFSET_CHAR<i, 5>::val,
    /*OFFSET_CHAR<i, 6>::val,    OFFSET_CHAR<i, 7>::val,    OFFSET_CHAR<i, 8>::val,    OFFSET_CHAR<i, 9>::val,*/
    NULL_CHAR::val>::type type;
};
 
template <unsigned int i>
const char IntToStr<i>::str[] = 
{
    OFFSET_CHAR<i, 0>::val,
    OFFSET_CHAR<i, 1>::val,
    OFFSET_CHAR<i, 2>::val,
    OFFSET_CHAR<i, 3>::val,
    OFFSET_CHAR<i, 4>::val,
    OFFSET_CHAR<i, 5>::val,
    OFFSET_CHAR<i, 6>::val,
    OFFSET_CHAR<i, 7>::val,
    OFFSET_CHAR<i, 8>::val,
    OFFSET_CHAR<i, 9>::val,
    NULL_CHAR::val
};
 
template <bool condition, class Then, class Else>
struct IF
{
    typedef Then RET;
};
 
template <class Then, class Else>
struct IF<false, Then, Else>
{
    typedef Else RET;
};
 
 
template < typename Str1, typename Str2 >
struct concat : mpl::insert_range<Str1, typename mpl::end<Str1>::type, Str2> {};
template <typename Str1, typename Str2, typename Str3 >
struct concat3 : mpl::insert_range<Str1, typename mpl::end<Str1>::type, typename concat<Str2, Str3 >::type > {};
 
typedef typename mpl::string<'f','i','z','z'>::type fizz;
typedef typename mpl::string<'b','u','z','z'>::type buzz;
typedef typename mpl::string<'', ''>::type mpendl;
typedef typename concat<fizz, buzz>::type fizzbuzz;
 


 
template <int N>
struct FizzBuzz
{
    typedef typename concat3<typename FizzBuzz<N - 1>::type, typename IF<N % 15 == 0, typename fizzbuzz::type, typename IF<N % 3 == 0, typename fizz::type, typename IF<N % 5 == 0, typename buzz::type, typename IntToStr<N>::type >::RET >::RET >::RET, typename mpendl::type>::type type;
};
 
template <>
struct FizzBuzz<1>
{
    typedef mpl::string<'1','',''>::type type;
};
 
int main(int argc, char** argv)
{
    const int n = 7;
    std::cout << mpl::c_str<FizzBuzz<n>::type>::value << std::endl;
	return 0;
}"
" 
#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class lastSunday
{
public:
    lastSunday()
    {
	m[0]  = strv; m[1]  = strv; m[2]  = strv; m[3]  = strv; 
	m[4]  = strv; m[5]  = strv; m[6]  = strv; m[7]  = strv; 
	m[8]  = strv; m[9]  = strv; m[10] = strv; m[11] = strv; 
    }
 
    void findLastSunday( int y )
    {
	year = y;
	isleapyear();
 
	int days[] = { 31, isleap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
		d;
	for( int i = 0; i < 12; i++ )
	{
	    d = days[i];
	    while( true )
	    {
		if( !getWeekDay( i, d ) ) break;
		d--;
	    }
	    lastDay[i] = d;
	}
 
	display();
    }
 
private:
    void isleapyear()
    {
	isleap = false;
	if( !( year % 4 ) )
	{
	    if( year % 100 ) isleap = true;
	    else if( !( year % 400 ) ) isleap = true;
	}
    }
 
    void display()
    {
	system( strv );
	cout << strv << year << endl << strv << endl;
	for( int x = 0; x < 12; x++ )
	    cout << m[x] << lastDay[x] << endl;
 
	cout << endl << endl;
    }
 
    int getWeekDay( int m, int d )
    {
	int y = year;
 
	int f = y + d + 3 * m - 1;
	m++;
	if( m < 3 ) y--;
	else f -= int( .4 * m + 2.3 );
 
	f += int( y / 4 ) - int( ( y / 100 + 1 ) * 0.75 );
	f %= 7;
 
	return f;
    }
 
    int lastDay[12], year;
    string m[12];
    bool isleap;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    int y;
    lastSunday ls;
 
    while( true )
    {
	system( strv );
	cout << strv; 
	cin >> y;
	if( !y ) return 0;
 
	ls.findLastSunday( y );
 
	system( strv );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
" 
#include <iostream>
 
void recurse(unsigned int i)
{
  std::cout<<i<<"""";
  recurse(i+1);
}
 
int main()
{
  recurse(0);
}
 "
"#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
 
std::string longestPath( const std::vector<std::string> & , char ) ;
 
int main( ) {
   std::string dirs[ ] = {
      strv ,
      strv ,
      strv } ;
   std::vector<std::string> myDirs ( dirs , dirs + 3 ) ;
   std::cout << strv
             << longestPath( myDirs , '/' ) << ""!"" ;
   return 0 ;
}
 
std::string longestPath( const std::vector<std::string> & dirs , char separator ) {
   std::vector<std::string>::const_iterator vsi = dirs.begin( ) ;
   int maxCharactersCommon = vsi->length( ) ;
   std::string compareString = *vsi ;
   for ( vsi = dirs.begin( ) + 1 ; vsi != dirs.end( ) ; vsi++ ) {
      std::pair<std::string::const_iterator , std::string::const_iterator> p = 
	 std::mismatch( compareString.begin( ) , compareString.end( ) , vsi->begin( ) ) ;
      if (( p.first - compareString.begin( ) ) < maxCharactersCommon ) 
	 maxCharactersCommon = p.first - compareString.begin( ) ;
   }
   std::string::size_type found = compareString.rfind( separator , maxCharactersCommon ) ;
   return compareString.substr( 0 , found ) ;
}"
"#include <iostream>
#include <fstream>
 
std::ios::off_type getFileSize(const char *filename) {
  std::ifstream f(filename);
  std::ios::pos_type begin = f.tellg();
  f.seekg(0, std::ios::end);
  std::ios::pos_type end = f.tellg();
  return end - begin;
}
 
int main() {
  std::cout << getFileSize(strv) << std::endl;
  std::cout << getFileSize(strv) << std::endl;
  return 0;
}#include <iostream>
#include <fstream>
 
int main()
{
	std::cout << std::ifstream(strv, std::ios::binary | std::ios::ate).tellg() << """"
		  << std::ifstream(strv, std::ios::binary | std::ios::ate).tellg() << """";
}"
"#include <boost/filesystem/operations.hpp>
#include <ctime>
#include <iostream>
 
int main( int argc , char *argv[ ] ) {
   if ( argc != 2 ) {
      std::cerr << ""Error! Syntax: moditime <filename>!"" ;
      return 1 ;
   }
   boost::filesystem::path p( argv[ 1 ] ) ;
   if ( boost::filesystem::exists( p ) ) {
      std::time_t t = boost::filesystem::last_write_time( p ) ;
      std::cout << strv << std::ctime( &t ) << strv << argv[ 1 ] 
	 << "" was modified the last time!"" ;
      std::cout << ""Setting the modification time to now:"" ;
      std::time_t n = std::time( 0 ) ;
      boost::filesystem::last_write_time( p , n ) ; 
      t = boost::filesystem::last_write_time( p ) ;
      std::cout << strv << std::ctime( &t ) << std::endl ;
      return 0 ;
   } else {
      std::cout << strv << argv[ 1 ] << '' ;
      return 2 ;
   }
}"
"#include <vector>
#include <algorithm>
#include <functional>
#include <iterator>
#include <iostream>
 
int main() {
  std::vector<int> ary;
  for (int i = 0; i < 10; i++)
    ary.push_back(i);
  std::vector<int> evens;
  std::remove_copy_if(ary.begin(), ary.end(), back_inserter(evens),
                      std::bind2nd(std::modulus<int>(), 2)); 

  std::copy(evens.begin(), evens.end(),
            std::ostream_iterator<int>(std::cout, """"));
 
  return 0;
}#include <vector>
#include <algorithm>
#include <iterator>
#include <iostream>
 
using namespace std;
 
int main() {
  vector<int> ary = {1, 2, 3, 4, 5, 6, 7, 8, 9};
  vector<int> evens;
 
  copy_if(ary.begin(), ary.end(), back_inserter(evens),
      [](int i) { return i % 2 == 0; });
 
  

  copy(evens.begin(), evens.end(), ostream_iterator<int>(cout, """"));
}"
"#include <iostream>
#include <fstream>
#include <string>
 
using namespace std;
 
int main() {
    string line;
    ifstream input ( strv );
    ofstream output (strv);
 
    if (output.is_open()) {
        if (input.is_open()){
            while (getline (input,line)) {
                output << line << endl;
            }
            input.close(); 

        }
        else {
            cout << ""input.txt cannot be opened!"";
        }
        output.close(); 

    }
    else {
        cout << ""output.txt cannot be written to!"";
    }
    return 0;
}#include <iostream>
#include <fstream>
#include <cstdlib>
 
int main()
{
  std::ifstream input(strv);
  if (!input.is_open())
  {
    std::cerr << ""could not open input.txt for reading."";
    return EXIT_FAILURE;
  }
 
  std::ofstream output(strv);
  if (!output.is_open())
  {
    std::cerr << ""could not open output.txt for writing."";
    return EXIT_FAILURE;
  }
 
  output << input.rdbuf();
  if (!output)
  {
    std::cerr << ""error copying the data."";
    return EXIT_FAILURE;
  }
 
  return EXIT_SUCCESS;
}# include <algorithm>
# include <fstream>
 
int main() {
  std::ifstream ifile(strv);
  std::ofstream ofile(strv);
  std::copy(std::istreambuf_iterator<char>(ifile),
            std::istreambuf_iterator<char>(),
            std::ostreambuf_iterator<char>(ofile));
}#include <fstream>
 
int main()
{
  std::ifstream input(strv);
  std::ofstream output(strv);
  output << input.rdbuf();
}"
" 
#include <windows.h>
#include <string>
using namespace std;
 
class myBitmap
{
public:
    myBitmap() : pen( NULL ) {}
    ~myBitmap()
    {
        DeleteObject( pen );
        DeleteDC( hdc );
        DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
        BITMAPINFO	bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes	   = 1;
	bi.bmiHeader.biWidth	   =  w;
	bi.bmiHeader.biHeight	   = -h;
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc ); 
	width = w; height = h;
	clear();
	return true;
    }
 
    void clear()
    {
	ZeroMemory( pBits, width * height * sizeof( DWORD ) );
    }
 
    void setPenColor( DWORD clr )
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, 1, clr );
	SelectObject( hdc, pen );
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO	 infoheader;
	BITMAP		 bitmap;
	DWORD*		 dwpBits;
	DWORD		 wb;
	HANDLE		 file;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
	dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC()     { return hdc; }
    int getWidth()  { return width; }
    int getHeight() { return height; }
 
private:
    HBITMAP bmp;
    HDC	    hdc;
    HPEN    pen;
    void    *pBits;
    int	    width, height;
};
class fiboFractal
{
public:
    fiboFractal( int l )
    {
	bmp.create( 600, 440 );
	bmp.setPenColor( 0x00ff00 );
	createWord( l ); createFractal();
	bmp.saveBitmap( strv );
    }
private:
    void createWord( int l )
    {
	string a = strv, b = strv, c;
	l -= 2;
	while( l-- )
	{ c = b + a; a = b; b = c; }
	fWord = c;
    }
 
    void createFractal()
    {
	int n = 1, px = 10, dir, 
	    py = 420, len = 1, 
	    x = 0, y = -len, goingTo = 0;
 
	HDC dc = bmp.getDC();
	MoveToEx( dc, px, py, NULL );
	for( string::iterator si = fWord.begin(); si != fWord.end(); si++ )
	{
	    px += x; py += y;
	    LineTo( dc, px, py );
	    if( !( *si - 48 ) )
	    {	

		if( n & 1 ) dir = 1;	

		else dir = 0;			

		switch( goingTo )
		{
		    case 0: 

		        y = 0;
			if( dir ){ x = len; goingTo = 1; }
			else { x = -len; goingTo = 3; }
		    break;
		    case 1: 

			x = 0;
			if( dir ) { y = len; goingTo = 2; }
			else { y = -len; goingTo = 0; }
		    break;
		    case 2: 

			y = 0;
			if( dir ) { x = -len; goingTo = 3; }
			else { x = len; goingTo = 1; }
		    break;
		    case 3: 

			x = 0;
			if( dir ) { y = -len; goingTo = 0; }
			else { y = len; goingTo = 2; }
		}
            }
	    n++;
        }
    }
 
    string fWord;
    myBitmap bmp;
};
int main( int argc, char* argv[] )
{
    fiboFractal ff( 23 );
    return system( strv );
}
 "
"#include <iostream>
#include <fstream>
 
int main( int argc, char **argv ){
    if( argc <= 1 ){
        std::cerr << strv<<argv[0]<<strv << std::endl;
        return -1;
    }
 
    std::ifstream input(argv[1]);
    if(!input.good()){
        std::cerr << strv<<argv[1]<<strv << std::endl;
        return -1;
    }
 
    std::string line, name, content;
    while( std::getline( input, line ).good() ){
        if( line.empty() || line[0] == '>' ){ 

            if( !name.empty() ){ 

                std::cout << name << strv << content << std::endl;
                name.clear();
            }
            if( !line.empty() ){
                name = line.substr(1);
            }
            content.clear();
        } else if( !name.empty() ){
            if( line.find(' ') != std::string::npos ){ 

                name.clear();
                content.clear();
            } else {
                content += line;
            }
        }
    }
    if( !name.empty() ){ 

        std::cout << name << strv << content << std::endl;
    }
 
    return 0;
}"
"#include <string>
#include <map>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <iomanip>
 
double log2( double number ) {
   return ( log( number ) / log( 2 ) ) ;
}
 
double find_entropy( std::string & fiboword ) {
   std::map<char , int> frequencies ;
   std::for_each( fiboword.begin( ) , fiboword.end( ) ,
	 [ & frequencies ]( char c ) { frequencies[ c ]++ ; } ) ; 
   int numlen = fiboword.length( ) ;
   double infocontent = 0 ;
   for ( std::pair<char , int> p : frequencies ) {
      double freq = static_cast<double>( p.second ) / numlen ;
      infocontent += freq * log2( freq ) ;
   }
   infocontent *= -1 ;
   return infocontent ;
}
 
void printLine( std::string &fiboword , int n ) {
   std::cout << std::setw( 5 ) << std::left << n ;
   std::cout << std::setw( 12 ) << std::right << fiboword.size( ) ;
   std::cout << strv << std::setw( 16 ) << std::setprecision( 13 ) 
      << std::left << find_entropy( fiboword ) ;
   std::cout << """" ;
}
 
int main( ) {
   std::cout << std::setw( 5 ) << std::left << strv ;
   std::cout << std::setw( 12 ) << std::right << strv ;
   std::cout << strv << std::setw( 16 ) << std::left << strv ; 
   std::cout << """" ;
   std::string firststring ( strv ) ;
   int n = 1 ;
   printLine( firststring , n ) ;
   std::string secondstring( strv ) ;
   n++ ;
   printLine( secondstring , n ) ;
   while ( n < 37 ) {
      std::string resultstring = firststring + secondstring ;
      firststring.assign( secondstring ) ;
      secondstring.assign( resultstring ) ;
      n++ ;
      printLine( resultstring , n ) ;
   }
   return 0 ;
}"
"#include <vector>
#include <iostream>
#include <numeric>
#include <iterator>
#include <memory>
#include <string>
#include <algorithm>
#include <iomanip>
 
std::vector<int> nacci ( const std::vector<int> & start , int arity ) {
   std::vector<int> result ( start ) ;
   int sumstart = 1 ;//summing starts at vector's begin + sumstart as
                     //soon as the vector is longer than arity
   while ( result.size( ) < 15 ) { //we print out the first 15 numbers
      if ( result.size( ) <= arity ) 
	 result.push_back( std::accumulate( result.begin( ) , 
		  result.begin( ) + result.size( ) , 0 ) ) ;
      else { 
	 result.push_back( std::accumulate ( result.begin( ) +
	  sumstart , result.begin( ) + sumstart + arity  , 0 )) ;
	 sumstart++ ;
      }
   }
   return std::move ( result ) ;
}
 
int main( ) {
   std::vector<std::string> naccinames {strv , strv , 
      strv , strv , strv , strv , strv , strv , strv } ;
   const std::vector<int> fibo { 1 , 1 } , lucas { 2 , 1 } ;
   for ( int i = 2 ; i < 11 ; i++ ) {
      std::vector<int> numberrow = nacci ( fibo , i ) ;
      std::cout << std::left << std::setw( 10 ) << 
	 naccinames[ i - 2 ].append( strv ) <<
	 std::setw( 2 ) << strv ;
      std::copy ( numberrow.begin( ) , numberrow.end( ) ,
	    std::ostream_iterator<int>( std::cout , strv ) ) ; 
      std::cout << ""..."" ;
      numberrow = nacci ( lucas , i ) ;
      std::cout << strv << i ; 
      if ( i < 10 )               //for formatting purposes
	 std::cout << strv ;
      else 
	 std::cout << strv ;
      std::copy ( numberrow.begin( ) , numberrow.end( ) ,
	    std::ostream_iterator<int>( std::cout , strv ) ) ; 
      std::cout << ""..."" ;
   }
   return 0 ;
} 
#include <iostream>
#include <vector>
 






class nacci_t
{
    std::vector< int >  history;
    unsigned            windex;             

    unsigned            rindex;             

    int                 running_sum;        

 
  public:
 
    nacci_t( unsigned int order, int a0 = 1, int a1 = 1 )
    :   history( order + 1 ), windex( 0 ), rindex( order - 1 ), 
        running_sum( a0 + a1 )
    {
        

        history[order - 1] = a0;
        history[order - 0] = a1;
    }
 
    int operator()() 
    {
        int result   = history[ rindex ];   

        running_sum -= history[ windex ];   

 
        history[ windex ] = running_sum;    

        running_sum      += running_sum;    

 
        if ( ++windex == history.size() ) windex = 0;
        if ( ++rindex == history.size() ) rindex = 0;
 
        return result;
    }
};
 
int main()
{
    for ( unsigned int i = 2; i <= 10; ++i )
    {
        nacci_t nacci( i ); 

 
        std::cout << strv << i << strv;
 
        for ( int j = 0; j < 10; ++j )
            std::cout << strv << nacci();
 
        std::cout << std::endl;
    }
 
    for ( unsigned int i = 2; i <= 10; ++i )
    {
        nacci_t lucas( i, 2, 1 ); 

 
        std::cout << strv << i << strv;
 
        for ( int j = 0; j < 10; ++j )
            std::cout << strv << lucas();
 
        std::cout << std::endl;
    }
}
 "
"#include <string>
#include <algorithm>
#include <iostream>
#include <vector>
#include <regex>
 
std::string findExtension ( const std::string & filename ) {
   auto position = filename.find_last_of ( '.' ) ;
   if ( position == std::string::npos )
      return strv ;
   else {
      std::string extension ( filename.substr( position + 1 ) ) ;
      if (std::regex_search (extension, std::regex(strv) ))
         return strv ;
      else
         return extension ;
   }
}
 
int main( ) {
   std::vector<std::string> filenames {strv , strv ,
      strv , strv , strv ,
      strv, strv } ;
   std::vector<std::string> extensions( filenames.size( ) ) ;
   std::transform( filenames.begin( ) , filenames.end( ) , extensions.begin( ) , findExtension ) ;
   for ( int i = 0 ; i < filenames.size( ) ; i++ )
      std::cout << filenames[i] << strv << extensions[i] << "" !"" ;
   return 0 ;
}
 "
"#include <iostream>
 
int main()
{
        unsigned int a = 1, b = 1;
        unsigned int target = 48;
        for(unsigned int n = 3; n <= target; ++n)
        {
                unsigned int fib = a + b;
                std::cout << strv<< n << strv << fib << std::endl;
                a = b;
                b = fib;
        }
 
        return 0;
}#include <iostream>
#include <gmpxx.h>
 
int main()
{
        mpz_class a = mpz_class(1), b = mpz_class(1);
        mpz_class target = mpz_class(100);
        for(mpz_class n = mpz_class(3); n <= target; ++n)
        {
                mpz_class fib = b + a;
                if ( fib < b )
                {
                        std::cout << strv << n << std::endl;
                        break;
                }
                std::cout << strv<< n << strv << fib << std::endl;
                a = b;
                b = fib;
        }
        return 0;
}#include <algorithm>
#include <vector>
#include <functional>
#include <iostream>
 
unsigned int fibonacci(unsigned int n) {
  if (n == 0) return 0;
  std::vector<int> v(n+1);
  v[1] = 1;
  transform(v.begin(), v.end()-2, v.begin()+1, v.begin()+2, std::plus<int>());
  

  return v[n];
}#include <numeric>
#include <vector>
#include <functional>
#include <iostream>
 
unsigned int fibonacci(unsigned int n) {
  if (n == 0) return 0;
  std::vector<int> v(n, 1);
  adjacent_difference(v.begin(), v.end()-1, v.begin()+1, std::plus<int>());
  

  return v[n-1];
}
 #include <iostream>
 
template <int n> struct fibo
{
    enum {value=fibo<n-1>::value+fibo<n-2>::value};
};
 
template <> struct fibo<0>
{
    enum {value=0};
};
 
template <> struct fibo<1>
{
    enum {value=1};
};
 
 
int main(int argc, char const *argv[])
{
    std::cout<<fibo<12>::value<<std::endl;
    std::cout<<fibo<46>::value<<std::endl;
    return 0;
}#include <iostream>
 
inline void fibmul(int* f, int* g)
{
  int tmp = f[0]*g[0] + f[1]*g[1];
  f[1] = f[0]*g[1] + f[1]*(g[0] + g[1]);
  f[0] = tmp;
}
 
int fibonacci(int n)
{
  int f[] = { 1, 0 };
  int g[] = { 0, 1 };
  while (n > 0)
  {
    if (n & 1) 

    {
      fibmul(f, g);
      --n;
    }
    else
    {
      fibmul(g, g);
      n >>= 1;
    }
  }
  return f[1];
}
 
int main()
{
  for (int i = 0; i < 20; ++i)
    std::cout << fibonacci(i) << strv;
  std::cout << std::endl;
} 




int main(void) {
  char NG[22] = {'1',0};
  int x = -1;
  N G;
  for (int fibs = 1; fibs <= 20; fibs++) {
   for (;G <= N(NG); ++G) x++;
   NG[fibs] = '0';
   NG[fibs+1] = 0;
   std::cout << x << strv;
  }
  std::cout << std::endl;
  return 0;
}
  




#include <algorithm>
#include <iostream>
#include <iterator>
int main()
{
   int x = 1, y = 1;
   generate_n(std::ostream_iterator<int>(std::cout, strv), 21, [&]{int n=x; x=y; y+=n; return n;});
   return 0;
}
 "
"#include <complex>
#include <iostream>
#include <valarray>
 
const double PI = 3.141592653589793238460;
 
typedef std::complex<double> Complex;
typedef std::valarray<Complex> CArray;
 




void fft(CArray& x)
{
    const size_t N = x.size();
    if (N <= 1) return;
 
    

    CArray even = x[std::slice(0, N/2, 2)];
    CArray  odd = x[std::slice(1, N/2, 2)];
 
    

    fft(even);
    fft(odd);
 
    

    for (size_t k = 0; k < N/2; ++k)
    {
        Complex t = std::polar(1.0, -2 * PI * k / N) * odd[k];
        x[k    ] = even[k] + t;
        x[k+N/2] = even[k] - t;
    }
}
 




// !!! Warning : in some cases this code make result different from not optimased version above (need to fix bug)
void fft(CArray &x)
{
	

	unsigned int N = x.size(), k = N, n;
	double thetaT = 3.14159265358979323846264338328L / N;
	Complex phiT = Complex(cos(thetaT), sin(thetaT)), T;
	while (k > 1)
	{
		n = k;
		k >>= 1;
		phiT = phiT * phiT;
		T = 1.0L;
		for (unsigned int l = 0; l < k; l++)
		{
			for (unsigned int a = l; a < N; a += n)
			{
				unsigned int b = a + k;
				Complex t = x[a] - x[b];
				x[a] += x[b];
				x[b] = t * T;
			}
			T *= phiT;
		}
	}
	

	unsigned int m = (unsigned int)log2(N);
	for (unsigned int a = 0; a < N; a++)
	{
		unsigned int b = a;
		

		b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));
		b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));
		b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));
		b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));
		b = ((b >> 16) | (b << 16)) >> (32 - m);
		if (b > a)
		{
			Complex t = x[a];
			x[a] = x[b];
			x[b] = t;
		}
	}
	//// Normalize (This section make it not working correctly)
	//Complex f = 1.0 / sqrt(N);
	//for (unsigned int i = 0; i < N; i++)
	//	x[i] *= f;
}
 


void ifft(CArray& x)
{
    

    x = x.apply(std::conj);
 
    

    fft( x );
 
    

    x = x.apply(std::conj);
 
    

    x /= x.size();
}
 
int main()
{
    const Complex test[] = { 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 };
    CArray data(test, 8);
 
    

    fft(data);
 
    std::cout << strv << std::endl;
    for (int i = 0; i < 8; ++i)
    {
        std::cout << data[i] << std::endl;
    }
 
    

    ifft(data);
 
    std::cout << std::endl << strv << std::endl;
    for (int i = 0; i < 8; ++i)
    {
        std::cout << data[i] << std::endl;
    }
    return 0;
}"
"#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
 
std::vector<int> GenerateFactors(int n)
{
    std::vector<int> factors;
    factors.push_back(1);
    factors.push_back(n);
    for(int i = 2; i * i <= n; ++i)
    {
        if(n % i == 0)
        {
            factors.push_back(i);
            if(i * i != n)
                factors.push_back(n / i);
        }
    }
 
    std::sort(factors.begin(), factors.end());
    return factors;
}
 
int main()
{
    const int SampleNumbers[] = {3135, 45, 60, 81};
 
    for(size_t i = 0; i < sizeof(SampleNumbers) / sizeof(int); ++i)
    {
        std::vector<int> factors = GenerateFactors(SampleNumbers[i]);
        std::cout << strv << SampleNumbers[i] << "" are:"";
        std::copy(factors.begin(), factors.end(), std::ostream_iterator<int>(std::cout, """"));
        std::cout << std::endl;
    }
}"
"template<typename Number>
 Number power(Number base, int exponent)
{
  int zerodir;
  Number factor;
  if (exponent < 0)
  {
    zerodir = 1;
    factor = Number(1)/base;
  }
  else
  {
    zerodir = -1;
    factor = base;
  }
 
  Number result(1);
  while (exponent != 0)
  {
    if (exponent % 2 != 0)
    {
      result *= factor;
      exponent += zerodir;
    }
    else
    {
      factor *= factor;
      exponent /= 2;
    }
  }
  return result;
}"
"#include <boost/iterator/counting_iterator.hpp>
#include <algorithm>
 
int factorial(int n)
{
  

  return std::accumulate(boost::counting_iterator<int>(1), boost::counting_iterator<int>(n+1), 1, std::multiplies<int>());
}long long int Factorial(long long int m_nValue)
   {
       long long int result=m_nValue;
       long long int result_next;
       long long int pc = m_nValue;
       do
       {
           result_next = result*(pc-1);
           result = result_next;
           pc--;
       }while(pc>2);
       m_nValue = result;
       return m_nValue;
   }template <int N>
struct Factorial 
{
    enum { value = N * Factorial<N - 1>::value };
};
 
template <>
struct Factorial<0> 
{
    enum { value = 1 };
};
 




void foo()
{
    int x = Factorial<4>::value; 

    int y = Factorial<0>::value; 

}"
"void runCode(string code)
{
    int c_len = code.length();
    unsigned accumulator=0;
    int bottles;
    for(int i=0;i<c_len;i++)
    {
        switch(code[i])
        {
            case 'Q':
                cout << code << endl;
                break;
 
            case 'H':
                cout << strv << endl;
                break;
 
            case '9':
                //Nice bottles song alg. from RC :)
                bottles = 99;
                do {
                    cout << bottles << strv << endl;
                    cout << bottles << strv << endl;
                    cout << strv << endl;
                    cout << --bottles << strv << endl << endl;
                } while( bottles > 0 );
                break;
 
            case '+':
                //Am I the only one finding this one weird? :o
                accumulator++;
                break;
        }
    }
};"
system(strv);
"struct MyException
{
  

};#include <exception>
struct MyException: std::exception
{
  char const* what() const throw() { return strv; }
}

void foo()
{
  throw MyException();
}
 


void foo2() throw(MyException)
{
  throw MyException();
}
 


void foo3() throw(MyException, std::bad_exception)
{
  throw MyException();
}try {
  foo();
}
catch (MyException &exc)
{
  

}
catch (std::exception &exc)
{
  

  

  std::cerr << exc.what() << std::endl;
}
catch (...)
{
  

}"
"#include <iostream>
class U0 {};
class U1 {};
 
void baz(int i)
{
    if (!i) throw U0();
    else throw U1();
}
void bar(int i) { baz(i); }
 
void foo()
{
    for (int i = 0; i < 2; i++)
    {   
        try {
            bar(i);
        } catch(U0 e) {
		std::cout<< ""Exception U0 caught"";
        }
    }
}
 
int main() {
    foo();
    std::cout<< ""Should never get here!"";
    return 0;
}"
" 
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
 
struct rule
{
  std::string pattern;
  std::string replacement;
  bool terminal;
  rule(std::string pat, std::string rep, bool term):
    pattern(pat),
    replacement(rep),
    terminal(term)
  {
  }
};
 
std::string const whitespace = "" "";
std::string::size_type const npos = std::string::npos;
 
bool is_whitespace(char c)
{
  return whitespace.find(c) != npos;
}
 
std::vector<rule> read_rules(std::ifstream& rulefile)
{
  std::vector<rule> rules;
  std::string line;
  while (std::getline(rulefile, line))
  {
    std::string::size_type pos;
 
    

    pos = line.find('#');
    if (pos != npos)
      line.resize(pos);
 
    

    if (line.find_first_not_of(whitespace) == npos)
      continue;
 
    

    pos = line.find(strv);
    while (pos != npos && (pos == 0 || !is_whitespace(line[pos-1])))
      pos = line.find(strv, pos+1);
 
    if (pos == npos || line.length() < pos+3 || !is_whitespace(line[pos+2]))
    {
      std::cerr << strv << line << """";
      std::exit(EXIT_FAILURE);
    }
 
    std::string pattern = line.substr(0, pos-1);
    std::string replacement = line.substr(pos+3);
 
    

    pattern.erase(pattern.find_last_not_of(whitespace)+1);
    replacement.erase(0, replacement.find_first_not_of(whitespace));
 
    

    bool terminal = !replacement.empty() && replacement[0] == '.';
    if (terminal)
      replacement.erase(0,1);
 
    rules.push_back(rule(pattern, replacement, terminal));
  }
 
  return rules;
}
 
std::string markov(std::vector<rule> rules, std::string input)
{
  std::string& output = input;
  std::vector<rule>::iterator iter = rules.begin();
 
  

  

  while (iter != rules.end())
  {
    std::string::size_type pos = output.find(iter->pattern);
    if (pos != npos)
    {
      output.replace(pos, iter->pattern.length(), iter->replacement);
      if (iter->terminal)
        break;
      iter = rules.begin();
    }
    else
      ++iter;
  }
 
  return output;
}
 
int main(int argc, char* argv[])
{
  if (argc != 3)
  {
    std::cout << ""usage: "" << argv[0] << "" rulefile text"";
    return EXIT_FAILURE;
  }
 
  std::ifstream rulefile(argv[1]);
  std::vector<rule> rules = read_rules(rulefile);
 
  std::string input(argv[2]);
  std::string output = markov(rules, input);
 
  std::cout << output << """";
}"
"#include <iostream>
#include <cmath>
#include <set>
using namespace std;
 
bool find() 
{
	const auto MAX = 250;
	vector<double> pow5(MAX);
	for (auto i = 1; i < MAX; i++) 
		pow5[i] = (double)i * i * i * i * i;
	for (auto x0 = 1; x0 < MAX; x0++) {
		for (auto x1 = 1; x1 < x0; x1++) {
			for (auto x2 = 1; x2 < x1; x2++) {
				for (auto x3 = 1; x3 < x2; x3++) {
					auto sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3];
					if (binary_search(pow5.begin(), pow5.end(), sum))
					{
						cout << x0 << strv << x1 << strv << x2 << strv << x3 << strv << pow(sum, 1.0 / 5.0) << endl;
						return true;
					}
				}
			}
		}
	}
	

	return false;
}
 
int main(void)
{
	int tm = clock();
	if (!find())
		cout << ""Nothing found!"";
	printf(""time=%d milliseconds"", (int)((clock() - tm) * 1000 / CLOCKS_PER_SEC));
	return 0;
}	set<double> pow5s;
	for (auto i = 1; i < MAX; i++) 
	{
		pow5[i] = (double)i * i * i * i * i;
		pow5s.insert(pow5[i]);
	}
	//...
        if (pow5s.find(sum) != pow5s.end())bool find() 
{
	const auto MAX = 250;
	vector<double> pow5(MAX);
	for (auto i = 1; i < MAX; i++) 
		pow5[i] = (double)i * i * i * i * i;
	auto rs = 5;
	for (auto x0 = 1; x0 < MAX; x0++) {
		for (auto x1 = 1; x1 < x0; x1++) {
			for (auto x2 = 1; x2 < x1; x2++) {
				auto s2 = pow5[x0] + pow5[x1] + pow5[x2];
				while (rs > 0 && pow5[rs] > s2) --rs;
				for (auto x3 = 1; x3 < x2; x3++) {
					auto sum = s2 + pow5[x3];
					while (rs < MAX - 1 && pow5[rs] < sum) ++rs;
					if (pow5[rs] == sum)
					{
						cout << x0 << strv << x1 << strv << x2 << strv << x3 << strv << pow(sum, 1.0 / 5.0) << endl;
						return true;
					}
				}
			}
		}
	}
	

	return false;
}				for (auto x3 = 1; x3 < x2; x3++) 
				{
					

					if (int err30 = (x0 + x1 + x2 + x3 - rs) % 30)
						x3 += 30 - err30;
					if (x3 >= x2)
						break;
					auto sum = s2 + pow5[x3];template<class C_, class LT_> C_ Unique(const C_& src, const LT_& less)
{
	C_ retval(src);
	std::sort(retval.begin(), retval.end(), less);
	retval.erase(unique(retval.begin(), retval.end()), retval.end());
	return retval;
}
 
template<class I_, class P_> I_ HuntFwd(const I_& hint, const I_& end, const P_& less)	

{
	I_ retval(hint);
	int step = 1;
	

	while (end - retval > step)
	{
		I_ test = retval + step;
		if (!less(test))
			break;
		retval = test;
		step <<= 1;
	}
	

	while (step > 1)
	{
		step >>= 1;
		if (end - retval <= step)
			continue;
		I_ test = retval + step;
		if (less(test))
			retval = test;
	}
	if (retval != end && less(retval))
		++retval;
	return retval;
}
 
bool DPFind(int how_many)
{
	const int MAX = 1000;
	vector<double> pow5(MAX);
	for (int i = 1; i < MAX; i++)
		pow5[i] = (double)i * i * i * i * i;
	vector<pair<double, int>> diffs;
	for (int i = 2; i < MAX; ++i)
	{
		for (int j = 1; j < i; ++j)
			diffs.emplace_back(pow5[i] - pow5[j], j);
	}
	auto firstLess = [](const pair<double, int>& lhs, const pair<double, int>& rhs) { return lhs.first < rhs.first; };
	diffs = Unique(diffs, firstLess);
 
	for (int x4 = 4; x4 < MAX - 1; ++x4)
	{
		for (int x3 = 3; x3 < x4; ++x3)
		{
			

			const auto s2 = pow5[x4] + pow5[x3];
			auto pd = upper_bound(diffs.begin() + 1, diffs.end(), make_pair(s2, 0), firstLess) - 1;
			for (int x2 = 2; x2 < x3; ++x2)
			{
				const auto sum = s2 + pow5[x2];
				pd = HuntFwd(pd, diffs.end(), [&](decltype(pd) it){ return it->first < sum; });
				if (pd != diffs.end() && pd->first == sum && pd->second < x3)	

				{
					const double y = pow(pd->first + pow5[pd->second], 0.2);
					cout << x4 << strv << x3 << strv << x2 << strv << pd->second << strv << static_cast<int>(y + 0.5) << """";
					if (--how_many <= 0)
						return true;
				}
			}
		}
	}
	return false;
}"
"double Factorial(double nValue)
   {
       double result = nValue;
       double result_next;
       double pc = nValue;
       do
       {
           result_next = result*(pc-1);
           result = result_next;
           pc--;
       }while(pc>2);
       nValue = result;
       return nValue;
   }
 
double EvaluateBinomialCoefficient(double nValue, double nValue2)
   {
       double result;
       if(nValue2 == 1)return nValue;
       result = (Factorial(nValue))/(Factorial(nValue2)*Factorial((nValue - nValue2)));
       nValue2 = result;
       return nValue2;
   }int main()
{
    cout<<strv<< EvaluateBinomialCoefficient(5,3);
    cin.get();
}"
"#include <string>
#include <cstdlib>
#include <iostream>
#include <cassert>
#include <algorithm>
#include <vector>
#include <ctime>
 
std::string allowed_chars = strv;
 










class selection
{
public:
  

  

  

  

  static int fitness(std::string candidate)
  {
    assert(target.length() == candidate.length());
 
    int fitness_so_far = 0;
 
    for (int i = 0; i < target.length(); ++i)
    {
      int target_pos = allowed_chars.find(target[i]);
      int candidate_pos = allowed_chars.find(candidate[i]);
      int diff = std::abs(target_pos - candidate_pos);
      fitness_so_far -= std::min(diff, int(allowed_chars.length()) - diff);
    }
 
    return fitness_so_far;
  }
 
  

  static int target_length() { return target.length(); }
private:
  static std::string target;
};
 
std::string selection::target = strv;
 


void move_char(char& c, int distance)
{
  while (distance < 0)
    distance += allowed_chars.length();
  int char_pos = allowed_chars.find(c);
  c = allowed_chars[(char_pos + distance) % allowed_chars.length()];
}
 




std::string mutate(std::string parent, double mutation_rate)
{
  for (int i = 0; i < parent.length(); ++i)
    if (std::rand()/(RAND_MAX + 1.0) < mutation_rate)
    {
      int distance = std::rand() % 3 + 1;
      if(std::rand()%2 == 0)
        move_char(parent[i], distance);
      else
        move_char(parent[i], -distance);
    }
  return parent;
}
 




bool less_fit(std::string const& s1, std::string const& s2)
{
  return selection::fitness(s1) < selection::fitness(s2);
}
 
int main()
{
  int const C = 100;
 
  std::srand(time(0));
 
  std::string parent;
  for (int i = 0; i < selection::target_length(); ++i)
  {
    parent += allowed_chars[std::rand() % allowed_chars.length()];
  }
 
  int const initial_fitness = selection::fitness(parent);
 
  for(int fitness = initial_fitness;
      fitness < 0;
      fitness = selection::fitness(parent))
  {
    std::cout << parent << strv << fitness << """";
    double const mutation_rate = 0.02 + (0.9*fitness)/initial_fitness;
    std::vector<std::string> childs;
    childs.reserve(C+1);
 
    childs.push_back(parent);
    for (int i = 0; i < C; ++i)
      childs.push_back(mutate(parent, mutation_rate));
 
    parent = *std::max_element(childs.begin(), childs.end(), less_fit);
  }
  std::cout << strv << parent << """";
}#include <iostream>
#include <time.h>
#include strv
 
using namespace std;
 
int main(int argc, char** argv)
{
	int threads = 0;
 
	char* targetString = strv;
	if(argc > 1) targetString = argv[1];
	int C = 100;
	if(argc > 2) C = atoi(argv[2]);
	SL_FLOAT P = 0.05;
	if(argc > 3) P = atof(argv[3]);
	int seed = time(NULL);
	if(argc > 4) seed = atoi(argv[4]);
 
	int targetDims[] = {strlen(targetString), 0};
	Sequence<char> target((void*)targetString, targetDims);
 
	sl_init(threads);
 
	Sequence<char> parent;
	Sequence<char> newParent;
	Sequence<int> parentRands;
	sl_create(seed++, 1, 27, target.size(), threads, parentRands);
	sl_initializeParent(parentRands, threads, parent);
 
	Sequence< Sequence<int> > charRands;
	Sequence< Sequence<SL_FLOAT> > rateRands;
 
	cout << ""Start:"" << parent << endl;
	for(int i = 1; !(parent == target); i++)
	{
		sl_create(seed++, 1, 27, C, target.size(), threads, charRands);
		sl_create(seed++, 0.0, 1.0, C, target.size(), threads, rateRands);
 
		sl_evolve(target, parent, C, P, rateRands, charRands, threads, newParent);
		parent = newParent;
 
		cout << strv << i << "":"" << parent << endl;
	}
	cout << ""End:"" << parent << endl;
 
	sl_done();
 
	return 0;
}"
"#include <iomanip>
#include <iostream>
 
typedef double F(double,double);
 
/*Approximates y(t) in y'(t)=f(t,y) with y(a)=y0 andt=a..b and the step size h.*/
void euler(F f, double y0, double a, double b, double h)
{
    double y = y0;
    for (double t = a; t < b; t += h)
    {
        std::cout << std::fixed << std::setprecision(3) << t << strv << y << """";
        y += h * f(t, y);
    }
    std::cout << ""done"";
}
 


double newtonCoolingLaw(double, double t)
{
    return -0.07 * (t - 20);
}
 
int main()
{
    euler(newtonCoolingLaw, 100, 0, 100,  2);
    euler(newtonCoolingLaw, 100, 0, 100,  5);
    euler(newtonCoolingLaw, 100, 0, 100, 10);
}"
"template<int N>
struct Half    
{              
        enum { Result = N >> 1 };
};                               
 
template<int N>
struct Double  
{              
        enum { Result = N << 1 };
};                               
 
template<int N>
struct IsEven  
{              
        static const bool Result = (N & 1) == 0;
};
 
template<int Multiplier, int Multiplicand>
struct EthiopianMultiplication
{
        template<bool Cond, int Plier, int RunningTotal>
        struct AddIfNot
        {
                enum { Result = Plier + RunningTotal };
        };
        template<int Plier, int RunningTotal>
        struct AddIfNot <true, Plier, RunningTotal>
        {
                enum { Result = RunningTotal };
        };
 
        template<int Plier, int Plicand, int RunningTotal>
        struct Loop
        {
                enum { Result = Loop<Half<Plier>::Result, Double<Plicand>::Result,
                       AddIfNot<IsEven<Plier>::Result, Plicand, RunningTotal >::Result >::Result };
        };
        template<int Plicand, int RunningTotal>
        struct Loop <0, Plicand, RunningTotal>
        {
                enum { Result = RunningTotal };
        };
 
        enum { Result = Loop<Multiplier, Multiplicand, 0>::Result };
};
 
#include <iostream>
 
int main(int, char **)
{
        std::cout << EthiopianMultiplication<17, 54>::Result << std::endl;
        return 0;
}"
"#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
 
template <typename T>
std::vector<size_t> equilibrium(T first, T last)
{
    typedef typename std::iterator_traits<T>::value_type value_t;
 
    value_t left  = 0;
    value_t right = std::accumulate(first, last, value_t(0));
    std::vector<size_t> result;
 
    for (size_t index = 0; first != last; ++first, ++index)
    {
        right -= *first;
        if (left == right)
        {
            result.push_back(index);
        }
        left += *first;
    }
    return result;
}
 
template <typename T>
void print(const T& value)
{
    std::cout << value << """";
}
 
int main() 
{
    const int data[] = { -7, 1, 5, 2, -4, 3, 0 };
 
    std::vector<size_t> indices(equilibrium(data, data + 7));
 
    std::for_each(indices.begin(), indices.end(), print<size_t>);
}"
"#include <cstdlib>
#include <cstdio>
 
int main()
{
   puts(getenv(strv));
   return 0;
}"
"enum fruits { apple, banana, cherry };
 
enum fruits { apple = 0, banana = 1, cherry = 2 };enum class fruits { apple, banana, cherry };
 
enum class fruits { apple = 0, banana = 1, cherry = 2 };enum class fruits : unsigned int { apple, banana, cherry };enum fruits : unsigned int { apple, banana, cherry };"
"#include <string>
#include <map>
#include <iostream>
#include <algorithm>
#include <cmath>
 
double log2( double number ) {
   return log( number ) / log( 2 ) ;
}
 
int main( int argc , char *argv[ ] ) {
   std::string teststring( argv[ 1 ] ) ;
   std::map<char , int> frequencies ;
   for ( char c : teststring )
     frequencies[ c ] ++ ;
   int numlen = teststring.length( ) ;
   double infocontent = 0 ;
   for ( std::pair<char , int> p : frequencies ) {
      double freq = static_cast<double>( p.second ) / numlen ;
      infocontent += freq * log2( freq ) ;
   }
   infocontent *= -1 ;
   std::cout << strv << teststring 
      << strv << infocontent << "" !"" ;
   return 0 ;
}"
"#include <string>
 


 
std::string str; 

 
if (str.empty()) { ... } 

 


if (str.length() == 0) { ... }
if (str == strv) { ... }"
" 
#include <iostream>
#include <boost/filesystem.hpp>
 
using namespace boost::filesystem;
 
int main(int argc, char *argv[])
{
    for (int i = 1; i < argc; ++i) {
        path p(argv[i]);
 
        if (exists(p) && is_directory(p))
            std::cout << strv << argv[i] << strv << (!is_empty(p) ? strv : strv) << "" empty"";
        else
            std::cout << strv << argv[i] << ""' could not be found"";
    }
}
 "
int main(){}
"#include <bitset>
#include <stdio.h>
 
#define SIZE	           80
#define RULE               30
#define RULE_TEST(x)       (RULE & 1 << (7 & (x)))
 
void evolve(std::bitset<SIZE> &s) {
    int i;
    std::bitset<SIZE> t(0);
    t[SIZE-1] = RULE_TEST( s[0] << 2 | s[SIZE-1] << 1 | s[SIZE-2] );
    t[     0] = RULE_TEST( s[1] << 2 | s[     0] << 1 | s[SIZE-1] );
    for (i = 1; i < SIZE-1; i++)
	t[i] = RULE_TEST( s[i+1] << 2 | s[i] << 1 | s[i-1] );
    for (i = 0; i < SIZE; i++) s[i] = t[i];
}
void show(std::bitset<SIZE> s) {
    int i;
    for (i = SIZE; i--; ) printf(strv, s[i] ? '#' : ' ');
    printf(""|"");
}
unsigned char byte(std::bitset<SIZE> &s) {
    unsigned char b = 0;
    int i;
    for (i=8; i--; ) {
	b |= s[0] << i; 
	evolve(s);
    }
    return b;
}
 
int main() {
    int i;
    std::bitset<SIZE> state(1);
    for (i=10; i--; )
	printf(strv, byte(state), i ? ' ' : '');
    return 0;
}"
"#include <iostream>
 
class MyOtherClass
{
public:
  const int m_x;
  MyOtherClass(const int initX = 0) : m_x(initX) { }
 
};
 
int main()
{
  MyOtherClass mocA, mocB(7);
 
  std::cout << mocA.m_x << std::endl; 

  std::cout << mocB.m_x << std::endl; 

 
  

  

 
  return 0;
}class MyClass
{
private:
    int x;
 
public:
    int getX() const
    {
        return x;
    }
};"
" 
#include <iostream>
#include <iomanip>
#include <string>
 
class oo {
public:
    void evolve( int l, int rule ) {
        std::string    cells = strv;
        std::cout << strv << rule << "":"";
        for( int x = 0; x < l; x++ ) {
            addNoCells( cells );
            std::cout << std::setw( 40 + ( static_cast<int>( cells.length() ) >> 1 ) ) << cells << """";
            step( cells, rule );
        }
    }
private:
    void step( std::string& cells, int rule ) {
        int bin;
        std::string newCells;
        for( size_t i = 0; i < cells.length() - 2; i++ ) {
            bin = 0;
            for( size_t n = i, b = 2; n < i + 3; n++, b >>= 1 ) {
                bin += ( ( cells[n] == 'O' ? 1 : 0 ) << b );
            }
            newCells.append( 1, rule & ( 1 << bin ) ? 'O' : '.' );
        }
        cells = newCells;
    }
    void addNoCells( std::string& s ) {
        char l = s.at( 0 ) == 'O' ? '.' : 'O',
             r = s.at( s.length() - 1 ) == 'O' ? '.' : 'O';
        s = l + s + r;
        s = l + s + r;
    }
};
int main( int argc, char* argv[] ) {
    oo o;
    o.evolve( 35, 90 );
    std::cout << """";
    return 0;
}
 "
"#include <vector>
#include <iostream>
#include <algorithm>
#include <sstream>
#include <string>
#include <cmath>
 
bool isPrime ( int number ) {
   if ( number <= 1 ) 
      return false ;
   if ( number == 2 )
      return true ;
   for ( int i = 2 ; i <= std::sqrt( number ) ; i++ ) {
      if ( number % i == 0 )
	 return false ;
   }
   return true ;
}
 
int reverseNumber ( int n ) {
   std::ostringstream oss ;
   oss << n ;
   std::string numberstring ( oss.str( ) ) ;
   std::reverse ( numberstring.begin( ) , numberstring.end( ) ) ;
   return std::stoi ( numberstring ) ;
}
 
bool isEmirp ( int n ) {
   return isPrime ( n ) && isPrime ( reverseNumber ( n ) )
      && n != reverseNumber ( n ) ;
}
 
int main( ) {
   std::vector<int> emirps ;
   int i = 1 ;
   while ( emirps.size( ) < 20 ) {
      if ( isEmirp( i ) ) {
         emirps.push_back( i ) ;
      }
      i++ ;
   }
   std::cout << ""The first 20 emirps:"" ;
   for ( int i : emirps ) 
      std::cout << i << strv ;
   std::cout << '' ;
   int newstart = 7700 ;
   while ( newstart < 8001 ) {
      if ( isEmirp ( newstart ) ) 
	std::cout << newstart << '' ;
      newstart++ ;
   }
   while ( emirps.size( ) < 10000 ) {
      if ( isEmirp ( i ) ) {
	 emirps.push_back( i ) ;
      }
      i++ ;
   }
   std::cout << strv << emirps[9999] << "" !"" ;
 
   return 0 ;
}"
"#include <bitset>
#include <stdio.h>
 
#define SIZE	           80
#define RULE               30
#define RULE_TEST(x)       (RULE & 1 << (7 & (x)))
 
void evolve(std::bitset<SIZE> &s) {
    int i;
    std::bitset<SIZE> t(0);
    t[SIZE-1] = RULE_TEST( s[0] << 2 | s[SIZE-1] << 1 | s[SIZE-2] );
    t[     0] = RULE_TEST( s[1] << 2 | s[     0] << 1 | s[SIZE-1] );
    for (i = 1; i < SIZE-1; i++)
	t[i] = RULE_TEST( s[i+1] << 2 | s[i] << 1 | s[i-1] );
    for (i = 0; i < SIZE; i++) s[i] = t[i];
}
void show(std::bitset<SIZE> s) {
    int i;
    for (i = SIZE; --i; ) printf(strv, s[i] ? '#' : ' ');
    printf("""");
}
int main() {
    int i;
    std::bitset<SIZE> state(1);
    state <<= SIZE / 2;
    for (i=0; i<10; i++) {
	show(state);
	evolve(state);
    }
    return 0;
}"
" 
#include<graphics.h>
#include<iostream>
 
int main()
{
    int k;
    initwindow(1500,810,strv);
 
    do{
       std::cout<<strv;
       std::cin>>k;
 
       if(k>0){
                bar3d(100, 100, 100 + 2*k, 100 + 4*k, 3*k, 1);
       }
       }while(k>0);
 
    return 0;
}
 
 "
"#include <algorithm>
#include <iostream>
 


template <typename BidIt, typename T>
void dnf_partition(BidIt first, BidIt last, const T& low, const T& high)
{
    for (BidIt next = first; next != last; ) {
        if (*next < low) {
            std::iter_swap(first++, next++);
        } else if (!(*next < high)) {
            std::iter_swap(next, --last);
        } else {
            ++next;
        }
    }
}
 
enum Colors { RED, WHITE, BLUE };
 
void print(const Colors *balls, size_t size)
{
    static const char *label[] = { strv, strv, strv };
 
    std::cout << strv;
    for (size_t i = 0; i < size; ++i) {
        std::cout << ' ' << label[balls[i]];
    }
    std::cout << ""Sorted: "" << std::boolalpha << std::is_sorted(balls, balls + size) << '';
}
 
int main()
{
    Colors balls[] = { RED, WHITE, BLUE, RED, WHITE, BLUE, RED, WHITE, BLUE };
 
    std::random_shuffle(balls, balls + 9);
    print(balls, 9);
 
    dnf_partition(balls, balls + 9, WHITE, BLUE);
    print(balls, 9);
}"
" 
#include <windows.h>
#include <string>
#include <math.h>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const int BMP_SIZE = 300, MY_TIMER = 987654, CENTER = BMP_SIZE >> 1, SEC_LEN = CENTER - 20,
          MIN_LEN = SEC_LEN - 20, HOUR_LEN = MIN_LEN - 20;
const float PI = 3.1415926536f;
 
//--------------------------------------------------------------------------------------------------
class vector2
{
public:
    vector2() { x = y = 0; }
    vector2( int a, int b ) { x = a; y = b; }
    void set( int a, int b ) { x = a; y = b; }
    void rotate( float angle_r )
    {
	float _x = static_cast<float>( x ),
	      _y = static_cast<float>( y ),
	       s = sinf( angle_r ),
	       c = cosf( angle_r ),
	       a = _x * c - _y * s,
	       b = _x * s + _y * c;
 
	x = static_cast<int>( a );
	y = static_cast<int>( b );
    }
    int x, y;
};
//--------------------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteObject( brush );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO    bi;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes      = 1;
	bi.bmiHeader.biWidth       =  w;
	bi.bmiHeader.biHeight      = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc );
 
	width = w; height = h;
	return true;
    }
 
    void clear( BYTE clr = 0 )
    {
	memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
 
    void setBrushColor( DWORD bClr )
    {
	if( brush ) DeleteObject( brush );
	brush = CreateSolidBrush( bClr );
	SelectObject( hdc, brush );
    }
 
    void setPenColor( DWORD c )
    {
	clr = c;
	createPen();
    }
 
    void setPenWidth( int w )
    {
	wid = w;
	createPen();
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO       infoheader;
	BITMAP           bitmap;
	DWORD            wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
 
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    void createPen()
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, wid, clr );
	SelectObject( hdc, pen );
    }
 
    HBITMAP bmp;
    HDC     hdc;
    HPEN    pen;
    HBRUSH  brush;
    void    *pBits;
    int     width, height, wid;
    DWORD   clr;
};
//--------------------------------------------------------------------------------------------------
class clock
{
public:
    clock()  
    {
	_bmp.create( BMP_SIZE, BMP_SIZE );
	_bmp.clear( 100 );
	_bmp.setPenWidth( 2 );
	_ang = DegToRadian( 6 );
    }
 
    void setNow()
    {
	GetLocalTime( &_sysTime );
	draw();
    }
 
    float DegToRadian( float degree ) { return degree * ( PI / 180.0f ); }
 
    void setHWND( HWND hwnd ) { _hwnd = hwnd; }
 
private:
    void drawTicks( HDC dc )
    {
	vector2 line;
	_bmp.setPenWidth( 1 );
	for( int x = 0; x < 60; x++ )
	{
	    line.set( 0, 50 );
	    line.rotate( static_cast<float>( x + 30 ) * _ang );
	    MoveToEx( dc, CENTER - static_cast<int>( 2.5f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.5f * static_cast<float>( line.y ) ), NULL );
	    LineTo( dc, CENTER - static_cast<int>( 2.81f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.81f * static_cast<float>( line.y ) ) );
	}
 
	_bmp.setPenWidth( 3 );
	for( int x = 0; x < 60; x += 5 )
	{
	    line.set( 0, 50 );
	    line.rotate( static_cast<float>( x + 30 ) * _ang );
	    MoveToEx( dc, CENTER - static_cast<int>( 2.5f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.5f * static_cast<float>( line.y ) ), NULL );
	    LineTo( dc, CENTER - static_cast<int>( 2.81f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.81f * static_cast<float>( line.y ) ) );
	}
    }
 
    void drawHands( HDC dc )
    {
	float hp = DegToRadian( ( 30.0f * static_cast<float>( _sysTime.wMinute ) ) / 60.0f );
	int h = ( _sysTime.wHour > 12 ? _sysTime.wHour - 12 : _sysTime.wHour ) * 5;
 
	_bmp.setPenWidth( 3 );
	_bmp.setPenColor( RGB( 0, 0, 255 ) );
	drawHand( dc, HOUR_LEN, ( _ang * static_cast<float>( 30 + h ) ) + hp );
 
	_bmp.setPenColor( RGB( 0, 128, 0 ) );
	drawHand( dc, MIN_LEN, _ang * static_cast<float>( 30 + _sysTime.wMinute ) );
 
	_bmp.setPenWidth( 2 );
	_bmp.setPenColor( RGB( 255, 0, 0 ) );
	drawHand( dc, SEC_LEN, _ang * static_cast<float>( 30 + _sysTime.wSecond ) );
    }
 
    void drawHand( HDC dc, int len, float ang )
    {
	vector2 line;
	line.set( 0, len );
	line.rotate( ang );
	MoveToEx( dc, CENTER, CENTER, NULL );
	LineTo( dc, line.x + CENTER, line.y + CENTER );
    }
 
    void draw()
    {
	HDC dc = _bmp.getDC();
 
	_bmp.setBrushColor( RGB( 250, 250, 250 ) );
	Ellipse( dc, 0, 0, BMP_SIZE, BMP_SIZE );
	_bmp.setBrushColor( RGB( 230, 230, 230 ) );
	Ellipse( dc, 10, 10, BMP_SIZE - 10, BMP_SIZE - 10 );
 
	drawTicks( dc );
	drawHands( dc );
 
	_bmp.setPenColor( 0 ); _bmp.setBrushColor( 0 );
	Ellipse( dc, CENTER - 5, CENTER - 5, CENTER + 5, CENTER + 5 );
 
	_wdc = GetDC( _hwnd );
	BitBlt( _wdc, 0, 0, BMP_SIZE, BMP_SIZE, dc, 0, 0, SRCCOPY );
	ReleaseDC( _hwnd, _wdc );
    }
 
    myBitmap   _bmp;
    HWND       _hwnd;
    HDC        _wdc;
    SYSTEMTIME _sysTime;
    float      _ang;
};
//--------------------------------------------------------------------------------------------------
class wnd
{
public:
    wnd() { _inst = this; }
    int wnd::Run( HINSTANCE hInst )
    {
	_hInst = hInst;
	_hwnd = InitAll();
	SetTimer( _hwnd, MY_TIMER, 1000, NULL );
	_clock.setHWND( _hwnd );
 
	ShowWindow( _hwnd, SW_SHOW );
	UpdateWindow( _hwnd );
 
	MSG msg;
	ZeroMemory( &msg, sizeof( msg ) );
	while( msg.message != WM_QUIT )
	{
	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
	    {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	    }
	}
	return UnregisterClass( strv, _hInst );
    }
private:
    void wnd::doPaint( HDC dc ) { _clock.setNow(); }
    void wnd::doTimer()         { _clock.setNow(); }
    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
    {
	switch( msg )
	{
	    case WM_DESTROY: PostQuitMessage( 0 ); break;
	    case WM_PAINT:
	    {
		PAINTSTRUCT ps;
		HDC dc = BeginPaint( hWnd, &ps );
		_inst->doPaint( dc );
		EndPaint( hWnd, &ps );
		return 0;
	    }
	    case WM_TIMER: _inst->doTimer(); break;
	    default:
		return DefWindowProc( hWnd, msg, wParam, lParam );
	}
	return 0;
    }
 
    HWND InitAll()
    {
	WNDCLASSEX wcex;
	ZeroMemory( &wcex, sizeof( wcex ) );
	wcex.cbSize           = sizeof( WNDCLASSEX );
	wcex.style           = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc   = ( WNDPROC )WndProc;
	wcex.hInstance     = _hInst;
	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
	wcex.lpszClassName = strv;
 
	RegisterClassEx( &wcex );
 
	RECT rc = { 0, 0, BMP_SIZE, BMP_SIZE };
	AdjustWindowRect( &rc, WS_SYSMENU | WS_CAPTION, FALSE );
	int w = rc.right - rc.left, h = rc.bottom - rc.top;
	return CreateWindow( strv, strv, WS_SYSMENU, CW_USEDEFAULT, 0, w, h, NULL, NULL, _hInst, NULL );
    }
 
    static wnd* _inst;
    HINSTANCE  _hInst;
    HWND       _hwnd;
    clock      _clock;
};
wnd* wnd::_inst = 0;
//--------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    wnd myWnd;
    return myWnd.Run( hInstance );
}
//--------------------------------------------------------------------------------------------------
 "
"template <typename T>
void insert_after(Node<T>* N, T&& data)
{
    auto node = new Node<T>{N, N->next, std::forward(data)};
    if(N->next != nullptr)
        N->next->prev = node;
    N->next = node;
}"
"#include <iostream>
#include <list>
 
int main ()
{
    std::list<int> numbers {1, 5, 7, 0, 3, 2};
    for(const auto& i: numbers)
        std::cout << i << ' ';
    std::cout << '';
}"
"template <typename T>
struct Node
{
    Node* next;
    Node* prev;
    T data;
};"
"#include <iostream>
#include <list>
 
int main ()
{
    std::list<int> numbers {1, 5, 7, 0, 3, 2};
    numbers.insert(numbers.begin(), 9); //Insert at the beginning
    numbers.insert(numbers.end(), 4); //Insert at the end
    auto it = std::next(numbers.begin(), numbers.size() / 2); //Iterator to the middle of the list
    numbers.insert(it, 6); //Insert in the middle
    for(const auto& i: numbers)
        std::cout << i << ' ';
    std::cout << '';
}"
" 
#include <windows.h>
#include <iostream>
 
//-----------------------------------------------------------------------------------------
using namespace std;
 
//-----------------------------------------------------------------------------------------
const int BMP_SIZE = 800, NORTH = 1, EAST = 2, SOUTH = 4, WEST = 8, LEN = 1;
 
//-----------------------------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap()
    {
	DeleteObject( pen ); DeleteObject( brush );
	DeleteDC( hdc ); DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO bi;
	ZeroMemory( &bi, sizeof( bi ) );
	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes      = 1;
	bi.bmiHeader.biWidth       =  w;
	bi.bmiHeader.biHeight      = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc );
 
	width = w; height = h;
	return true;
    }
 
    void clear( BYTE clr = 0 )
    {
	memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
 
    void setBrushColor( DWORD bClr )
    {
	if( brush ) DeleteObject( brush );
	brush = CreateSolidBrush( bClr );
	SelectObject( hdc, brush );
    }
 
    void setPenColor( DWORD c )
    {
	clr = c; createPen();
    }
 
    void setPenWidth( int w )
    {
	wid = w; createPen();
    }
 
    void saveBitmap( string path )
     {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO       infoheader;
	BITMAP           bitmap;
	DWORD            wb;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
 
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
 
private:
    void createPen()
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, wid, clr );
	SelectObject( hdc, pen );
    }
 
    HBITMAP bmp;
    HDC     hdc;
    HPEN    pen;
    HBRUSH  brush;
    void    *pBits;
    int     width, height, wid;
    DWORD   clr;
};
//-----------------------------------------------------------------------------------------
class dragonC
{
public:
    dragonC() { bmp.create( BMP_SIZE, BMP_SIZE ); dir = WEST; }
    void draw( int iterations ) { generate( iterations ); draw(); }
 
private:
    void generate( int it )
    {
	generator.push_back( 1 );
	string temp;
 
	for( int y = 0; y < it - 1; y++ )
	{
	    temp = generator; temp.push_back( 1 );
	    for( string::reverse_iterator x = generator.rbegin(); x != generator.rend(); x++ )
		temp.push_back( !( *x ) );
 
	    generator = temp;
	}
    }
 
    void draw()
    {
	HDC dc = bmp.getDC();
	unsigned int clr[] = { 0xff, 0xff00, 0xff0000, 0x00ffff };
	int mov[] = { 0, 0, 1, -1, 1, -1, 1, 0 }; int i = 0;
 
	for( int t = 0; t < 4; t++ )
	{
	    int a = BMP_SIZE / 2, b = a; a += mov[i++]; b += mov[i++];
	    MoveToEx( dc, a, b, NULL );
 
	    bmp.setPenColor( clr[t] );
	    for( string::iterator x = generator.begin(); x < generator.end(); x++ )
	    {
		switch( dir )
		{
		    case NORTH:
			if( *x ) { a += LEN; dir = EAST; }
			else { a -= LEN; dir = WEST; }				
		    break;
		    case EAST:
			if( *x ) { b += LEN; dir = SOUTH; }
			else { b -= LEN; dir = NORTH; }
		    break;
		    case SOUTH:
			if( *x ) { a -= LEN; dir = WEST; }
			else { a += LEN; dir = EAST; }
		    break;
		    case WEST:
			if( *x ) { b -= LEN; dir = NORTH; }
			else { b += LEN; dir = SOUTH; }
		}
	        LineTo( dc, a, b );
	    }
	}
	// !!! change this path !!!
	bmp.saveBitmap( strv );
    }
 
    int dir;
    myBitmap bmp;
    string generator;
};
//-----------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    dragonC d; d.draw( 17 );
    return system( strv );
}
//-----------------------------------------------------------------------------------------
 "
" 
#include <Rcpp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
using namespace Rcpp ;
 


CharacterVector getNameInfo(std::string fqdn) {
 
  struct addrinfo hints, *res, *res0;
	int error;
	char host[NI_MAXHOST];
 
  memset(&hints, 0, sizeof hints);
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;
 
	error = getaddrinfo(fqdn.c_str(), NULL, &hints, &res0);
	if (error) { return(NA_STRING);	}
 
  int i = 0 ;
	for (res = res0; res; res = res->ai_next) {
  	error = getnameinfo(res->ai_addr, res->ai_addrlen,
		    host, sizeof host, NULL, 0, NI_NUMERICHOST);
		if (!error) { i++ ; }
	}
 
  CharacterVector results(i) ;
 
  i = 0;
 
  for (res = res0; res; res = res->ai_next) {
		error = getnameinfo(res->ai_addr, res->ai_addrlen,
		    host, sizeof host, NULL, 0, NI_NUMERICHOST);
		if (!error) { results[i++] = host ; }
	}
 
  freeaddrinfo(res0);
 
  return(results) ;
 
}
 "
"#include <iostream>
#include <numeric>
 
int main()
{
    int a[] = { 1, 3, -5 };
    int b[] = { 4, -2, -1 };
 
    std::cout << std::inner_product(a, a + sizeof(a) / sizeof(a[0]), b, 0) << std::endl;
 
    return 0;
} 
#include <valarray>
#include <iostream>
 
int main()
{
    std::valarray<double> xs = {1,3,-5};
    std::valarray<double> ys = {4,-2,-1};
 
    double result = (xs * ys).sum();
 
    std::cout << result << '';
 
    return 0;
}"
" 
#include <iostream>
#include <algorithm>
#include <vector>
#include <sstream>
#include <iterator>
using namespace std;
class myTuple
{
public:
    void set( int a, int b, string c ) { t.first.first = a; t.first.second = b; t.second = c; }
    bool operator == ( pair<int, int> p ) { return p.first == t.first.first && p.second == t.first.second; }
    string second() { return t.second; }
private:
    pair<pair<int, int>, string> t;
};
class discordian
{
public:
    discordian() {
        myTuple t;
        t.set( 5, 1, strv ); holyday.push_back( t ); t.set( 19, 2, strv ); holyday.push_back( t );
        t.set( 29, 2, strv ); holyday.push_back( t ); t.set( 19, 3, strv ); holyday.push_back( t );
        t.set( 3, 5, strv ); holyday.push_back( t ); t.set( 31, 5, strv ); holyday.push_back( t );
        t.set( 15, 7, strv ); holyday.push_back( t ); t.set( 12, 8, strv ); holyday.push_back( t ); 
        t.set( 26, 9, strv ); holyday.push_back( t ); t.set( 24, 10, strv ); holyday.push_back( t ); 
        t.set( 8, 12, strv ); holyday.push_back( t ); 
        seasons.push_back( strv ); seasons.push_back( strv ); seasons.push_back( strv ); 
        seasons.push_back( strv ); seasons.push_back( strv );
        wdays.push_back( strv ); wdays.push_back( strv ); wdays.push_back( strv );
        wdays.push_back( strv ); wdays.push_back( strv ); 
    }
    void convert( int d, int m, int y ) {
        if( d == 0 || m == 0 || m > 12 || d > getMaxDay( m, y ) ) { 
            cout << ""This is not a date!""; 
            return; 
        }
        vector<myTuple>::iterator f = find( holyday.begin(), holyday.end(), make_pair( d, m ) ); 
        int dd = d, day, wday, sea,  yr = y + 1166;
        for( int x = 1; x < m; x++ )
            dd += getMaxDay( x, 1 );
        day = dd % 73; if( !day ) day = 73; 
        wday = dd % 5; 
        sea  = ( dd - 1 ) / 73;
        if( d == 29 && m == 2 && isLeap( y ) ) { 
            cout << ( *f ).second() << strv << seasons[sea] << strv << yr; 
            return; 
        }
        cout << wdays[wday] << strv << seasons[sea] << strv << day;
        if( day > 10 && day < 14 ) cout << strv; 
        else switch( day % 10) { 
            case 1: cout << strv; break; 
            case 2: cout << strv; break; 
            case 3: cout << strv; break; 
            default: cout << strv; 
        }
        cout << strv << yr;
        if( f != holyday.end() ) cout << strv << ( *f ).second();
    }
private:
    int getMaxDay( int m, int y ) { 
        int dd[] = { 0, 31, isLeap( y ) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; return dd[m]; 
    }
    bool isLeap( int y ) { 
        bool l = false; 
        if( !( y % 4 ) ) { 
            if( y % 100 ) l = true; 
            else if( !( y % 400 ) ) l = true; 
        }
        return l; 
    }
    vector<myTuple> holyday; vector<string> seasons, wdays;
};
int main( int argc, char* argv[] ) {
    string date; discordian disc;
    while( true ) {
        cout << strv; getline( cin, date ); if( date == strv ) break;
        if( date.length() == 10 ) {
            istringstream iss( date ); 
            vector<string> vc;
            copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( vc ) );
            disc.convert( atoi( vc[0].c_str() ), atoi( vc[1].c_str() ), atoi( vc[2].c_str() ) ); 
            cout << """";
        } else cout << ""Is this a date?!"";
    }
    return 0;
}
 "
"#include <iostream>
#include <vector>
#include <string>
#include <list>
 
#include <limits> // for numeric_limits
 
#include <set>
#include <utility> // for pair
#include <algorithm>
#include <iterator>
 
 
typedef int vertex_t;
typedef double weight_t;
 
const weight_t max_weight = std::numeric_limits<double>::infinity();
 
struct neighbor {
    vertex_t target;
    weight_t weight;
    neighbor(vertex_t arg_target, weight_t arg_weight)
        : target(arg_target), weight(arg_weight) { }
};
 
typedef std::vector<std::vector<neighbor> > adjacency_list_t;
 
 
void DijkstraComputePaths(vertex_t source,
                          const adjacency_list_t &adjacency_list,
                          std::vector<weight_t> &min_distance,
                          std::vector<vertex_t> &previous)
{
    int n = adjacency_list.size();
    min_distance.clear();
    min_distance.resize(n, max_weight);
    min_distance[source] = 0;
    previous.clear();
    previous.resize(n, -1);
    std::set<std::pair<weight_t, vertex_t> > vertex_queue;
    vertex_queue.insert(std::make_pair(min_distance[source], source));
 
    while (!vertex_queue.empty()) 
    {
        weight_t dist = vertex_queue.begin()->first;
        vertex_t u = vertex_queue.begin()->second;
        vertex_queue.erase(vertex_queue.begin());
 
        

	const std::vector<neighbor> &neighbors = adjacency_list[u];
        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();
             neighbor_iter != neighbors.end();
             neighbor_iter++)
        {
            vertex_t v = neighbor_iter->target;
            weight_t weight = neighbor_iter->weight;
            weight_t distance_through_u = dist + weight;
	    if (distance_through_u < min_distance[v]) {
	        vertex_queue.erase(std::make_pair(min_distance[v], v));
 
	        min_distance[v] = distance_through_u;
	        previous[v] = u;
	        vertex_queue.insert(std::make_pair(min_distance[v], v));
 
	    }
 
        }
    }
}
 
 
std::list<vertex_t> DijkstraGetShortestPathTo(
    vertex_t vertex, const std::vector<vertex_t> &previous)
{
    std::list<vertex_t> path;
    for ( ; vertex != -1; vertex = previous[vertex])
        path.push_front(vertex);
    return path;
}
 
 
int main()
{
    

    adjacency_list_t adjacency_list(6);
    

    adjacency_list[0].push_back(neighbor(1, 7));
    adjacency_list[0].push_back(neighbor(2, 9));
    adjacency_list[0].push_back(neighbor(5, 14));
    

    adjacency_list[1].push_back(neighbor(0, 7));
    adjacency_list[1].push_back(neighbor(2, 10));
    adjacency_list[1].push_back(neighbor(3, 15));
    

    adjacency_list[2].push_back(neighbor(0, 9));
    adjacency_list[2].push_back(neighbor(1, 10));
    adjacency_list[2].push_back(neighbor(3, 11));
    adjacency_list[2].push_back(neighbor(5, 2));
    

    adjacency_list[3].push_back(neighbor(1, 15));
    adjacency_list[3].push_back(neighbor(2, 11));
    adjacency_list[3].push_back(neighbor(4, 6));
    

    adjacency_list[4].push_back(neighbor(3, 6));
    adjacency_list[4].push_back(neighbor(5, 9));
    

    adjacency_list[5].push_back(neighbor(0, 14));
    adjacency_list[5].push_back(neighbor(2, 2));
    adjacency_list[5].push_back(neighbor(4, 9));
 
    std::vector<weight_t> min_distance;
    std::vector<vertex_t> previous;
    DijkstraComputePaths(0, adjacency_list, min_distance, previous);
    std::cout << strv << min_distance[4] << std::endl;
    std::list<vertex_t> path = DijkstraGetShortestPathTo(4, previous);
    std::cout << strv;
    std::copy(path.begin(), path.end(), std::ostream_iterator<vertex_t>(std::cout, strv));
    std::cout << std::endl;
 
    return 0;
}#include <iostream>
#include <vector>
#include <string>
#include <list>
 
#include <limits> // for numeric_limits
 
#include <queue>
#include <utility> // for pair
#include <algorithm>
#include <iterator>
 
 
typedef int vertex_t;
typedef double weight_t;
 
const weight_t max_weight = std::numeric_limits<double>::infinity();
 
struct neighbor {
    vertex_t target;
    weight_t weight;
    neighbor(vertex_t arg_target, weight_t arg_weight)
        : target(arg_target), weight(arg_weight) { }
};
 
typedef std::vector<std::vector<neighbor> > adjacency_list_t;
typedef std::pair<weight_t, vertex_t> weight_vertex_pair_t;
 
void DijkstraComputePaths(vertex_t source,
                          const adjacency_list_t &adjacency_list,
                          std::vector<weight_t> &min_distance,
                          std::vector<vertex_t> &previous)
{
    int n = adjacency_list.size();
    min_distance.clear();
    min_distance.resize(n, max_weight);
    min_distance[source] = 0;
    previous.clear();
    previous.resize(n, -1);
    

    std::priority_queue<weight_vertex_pair_t,
			std::vector<weight_vertex_pair_t>,
			std::greater<weight_vertex_pair_t> > vertex_queue;
    vertex_queue.push(std::make_pair(min_distance[source], source));
 
    while (!vertex_queue.empty()) 
    {
        weight_t dist = vertex_queue.top().first;
        vertex_t u = vertex_queue.top().second;
        vertex_queue.pop();
 
	

	

	

	if (dist > min_distance[u])
	    continue;
 
        

	const std::vector<neighbor> &neighbors = adjacency_list[u];
        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();
             neighbor_iter != neighbors.end();
             neighbor_iter++)
        {
            vertex_t v = neighbor_iter->target;
            weight_t weight = neighbor_iter->weight;
            weight_t distance_through_u = dist + weight;
	    if (distance_through_u < min_distance[v]) {
	        min_distance[v] = distance_through_u;
	        previous[v] = u;
	        vertex_queue.push(std::make_pair(min_distance[v], v));
 
	    }
 
        }
    }
}
 
 
std::list<vertex_t> DijkstraGetShortestPathTo(
    vertex_t vertex, const std::vector<vertex_t> &previous)
{
    std::list<vertex_t> path;
    for ( ; vertex != -1; vertex = previous[vertex])
        path.push_front(vertex);
    return path;
}
 
 
int main()
{
    

    adjacency_list_t adjacency_list(6);
    

    adjacency_list[0].push_back(neighbor(1, 7));
    adjacency_list[0].push_back(neighbor(2, 9));
    adjacency_list[0].push_back(neighbor(5, 14));
    

    adjacency_list[1].push_back(neighbor(0, 7));
    adjacency_list[1].push_back(neighbor(2, 10));
    adjacency_list[1].push_back(neighbor(3, 15));
    

    adjacency_list[2].push_back(neighbor(0, 9));
    adjacency_list[2].push_back(neighbor(1, 10));
    adjacency_list[2].push_back(neighbor(3, 11));
    adjacency_list[2].push_back(neighbor(5, 2));
    

    adjacency_list[3].push_back(neighbor(1, 15));
    adjacency_list[3].push_back(neighbor(2, 11));
    adjacency_list[3].push_back(neighbor(4, 6));
    

    adjacency_list[4].push_back(neighbor(3, 6));
    adjacency_list[4].push_back(neighbor(5, 9));
    

    adjacency_list[5].push_back(neighbor(0, 14));
    adjacency_list[5].push_back(neighbor(2, 2));
    adjacency_list[5].push_back(neighbor(4, 9));
 
    std::vector<weight_t> min_distance;
    std::vector<vertex_t> previous;
    DijkstraComputePaths(0, adjacency_list, min_distance, previous);
    std::cout << strv << min_distance[4] << std::endl;
    std::list<vertex_t> path = DijkstraGetShortestPathTo(4, previous);
    std::cout << strv;
    std::copy(path.begin(), path.end(), std::ostream_iterator<vertex_t>(std::cout, strv));
    std::cout << std::endl;
 
    return 0;
}"
" 
#include <vector>
#include <string>
#include <iostream>
#include <boost/cstdint.hpp>
#include <boost/thread.hpp>
#include <boost/thread/locks.hpp>
#include <boost/format.hpp>
#include <boost/shared_ptr.hpp>
 
typedef boost::mutex Fork;
typedef boost::shared_ptr< Fork > ForkPtr;
typedef boost::lock_guard< Fork > ForkLock;
 
#define MIN_WAIT_TIME 100
#define NUM_MEALS     10
#define MAX_JITTER    50
 
template< typename Stream >
class AtomicLogger {
public:
 
  AtomicLogger( Stream& stream ) :
    m_mutex(),
    m_stream( stream )
  {
  }
 
  void log( const std::string& str ) {
    boost::mutex::scoped_lock lock( m_mutex );
    m_stream << str << std::endl;
  }
 
private:
  mutable boost::mutex m_mutex;
  Stream& m_stream;
};
typedef AtomicLogger< std::ostream > AtomicLoggerOstream;
typedef boost::shared_ptr< AtomicLoggerOstream > AtomicLoggerOstreamPtr;
 
class Philosopher {
public:
 
  Philosopher( 
	      const std::string& name, 
	      ForkPtr fork_left, 
	      ForkPtr fork_right, 
	      AtomicLoggerOstreamPtr p_logger ) :
    m_name( name ),
    m_continue( true ),
    mp_fork_left( fork_left ),
    mp_fork_right( fork_right ),
    m_thread( boost::thread( boost::bind( &Philosopher::thread_func, 
					  this, 
					  &m_continue, 
					  mp_fork_left, 
					  mp_fork_right ) ) ),
    m_meals_left( NUM_MEALS ),
    mp_logger( p_logger )
  {
  }
 
  ~Philosopher() {
    done_dining();
    wait_for_cmplt();
  }
 
  void done_dining() { m_continue = false; }
 
  void wait_for_cmplt() { m_thread.join(); }
 
private:
  inline bool can_grab_fork( ForkPtr& p_fork ) { return p_fork->try_lock(); }
 
  void thread_func( volatile bool* p_continue, ForkPtr fork_left, ForkPtr fork_right ) {
    bool failed_to_grab_fork = false;
 
    while( p_continue && m_meals_left ) {
      mp_logger->log( boost::str( boost::format( strv ) % this->m_name ) );
      wait();
      mp_logger->log( boost::str( boost::format( strv ) % this->m_name ) );
 
      

      if( can_grab_fork( fork_left ) ) {
	ForkLock lock_left( *fork_left, boost::adopt_lock );
	if( can_grab_fork( fork_right ) ) {
	  ForkLock lock_right( *fork_right, boost::adopt_lock );
	  

	  mp_logger->log( boost::str( boost::format( strv ) % m_name % m_meals_left ) );
	  wait();
	  

	  --m_meals_left;
	} else {
	  failed_to_grab_fork = true;
	}
      } else {
	failed_to_grab_fork = true;
      }
 
      if( failed_to_grab_fork ) {
	mp_logger->log( boost::str( boost::format( strv ) % m_name ) );
	failed_to_grab_fork = false;
	wait();
      }
    }
 
    mp_logger->log( boost::str( boost::format( strv ) % m_name ) );
  }
 
  inline void wait() {
    wait( MIN_WAIT_TIME + ( std::rand() % MAX_JITTER ) );
  }
 
  inline void wait( boost::uint32_t time_in_ms ) { 
    boost::this_thread::sleep( boost::posix_time::milliseconds( time_in_ms ) ); 
  }
 
  std::string m_name;
  volatile bool m_continue;
  ForkPtr mp_fork_left;  

  ForkPtr mp_fork_right; 

  boost::thread m_thread;
  boost::uint32_t m_meals_left;
  AtomicLoggerOstreamPtr mp_logger;
};
typedef boost::shared_ptr< Philosopher > PhilosopherPtr;
 
int main() {
  const int N = 5;
  std::string names[] = { strv, strv, strv, strv, strv };
 
  std::vector< PhilosopherPtr > philosophers;
  philosophers.reserve( N );
 
  

  AtomicLoggerOstreamPtr p_logger( new AtomicLoggerOstream( std::cout ) );
 
  

  std::vector< ForkPtr > forks;
  forks.reserve( N );
  for( int i = 0; i < N; ++i ) {
    forks.push_back( ForkPtr( new Fork() ) );
  }
 
  

  for( int i = 0; i < N; ++i ) {
    philosophers.push_back( PhilosopherPtr(
					   new Philosopher( names[ i ], forks[ i ], forks[ (i + 1) % N ], p_logger ) ) );
  }
 
  

  for( int i = 0; i < N; ++i ) {
    philosophers[ i ]->wait_for_cmplt();
  }
 
  p_logger->log( strv );
 
  return 0;  
}
 
 #include <algorithm>
#include <array>
#include <atomic>
#include <chrono>
//We are using only standard library, so snprintf instead of Boost::Format
#include <cstdio>
#include <iostream>
#include <mutex>
#include <random>
#include <string>
#include <thread>
 
std::mutex cout_mutex;
 
struct Fork {
    std::mutex mutex;
};
 
struct Dinner {
    std::atomic<bool> ready {false};
    std::array<Fork, 5> forks;
    ~Dinner() { std::cout << strv; }
};
 
class Philosopher
{
    std::mt19937 rng{std::random_device {}()};
 
    const std::string name;
    const Dinner& dinner;
    Fork& left;
    Fork& right;
    std::thread worker;
 
    void live();
    void dine();
    void ponder();
  public:
    Philosopher(std::string name_, const Dinner& dinn, Fork& l, Fork& r)
      : name(std::move(name_)), dinner(dinn) , left(l), right(r), worker(&Philosopher::live, this)
    {}
    ~Philosopher()
    {
        worker.join();
        std::lock_guard<std::mutex>  cout_lock(cout_mutex);
        std::cout << name << strv << std::endl;
    }
};
 
void Philosopher::live()
{
    while (not dinner.ready)
        ; //You spin me right round, baby, right round...
    do {//Aquire forks first
        //lock uses deadlock prevention mechanism to acquire mutexes safely
        std::lock(left.mutex, right.mutex);
        dine(); //Dine adopts lock on forks and releases them
        if(not dinner.ready) break;
        ponder();
    } while(dinner.ready);
}
 
void Philosopher::dine()
{
    std::lock_guard<std::mutex>  left_lock( left.mutex, std::adopt_lock);
    std::lock_guard<std::mutex> right_lock(right.mutex, std::adopt_lock);
 
    thread_local std::array<const char*, 3> foods {{strv, strv, strv}};
    thread_local std::array<const char*, 3> reactions {{
        strv, strv, strv
    }};
    thread_local std::uniform_int_distribution<> dist(1, 6);
    std::shuffle(    foods.begin(),     foods.end(), rng);
    std::shuffle(reactions.begin(), reactions.end(), rng);
 
    if(not dinner.ready) return;
    {
        std::lock_guard<std::mutex>  cout_lock(cout_mutex);
        std::cout << name << strv << std::endl;
    }
    constexpr size_t buf_size = 64;
    char buffer[buf_size];
    for(int i = 0; i < 3; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(dist(rng)*50));
        snprintf(buffer, buf_size, reactions[i], foods[i]);
        std::lock_guard<std::mutex>  cout_lock(cout_mutex);
        std::cout << name << strv << buffer << std::endl;
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(dist(rng))*50);
    std::lock_guard<std::mutex>  cout_lock(cout_mutex);
    std::cout << name << strv << std::endl;
}
 
void Philosopher::ponder()
{
    static constexpr std::array<const char*, 5> topics {{
        strv, strv, strv, strv, strv
    }};
    thread_local std::uniform_int_distribution<> wait(1, 6);
    thread_local std::uniform_int_distribution<> dist(0, topics.size() - 1);
    while(dist(rng) > 0) {
        std::this_thread::sleep_for(std::chrono::milliseconds(wait(rng)*150));
        std::lock_guard<std::mutex>  cout_lock(cout_mutex);
        std::cout << name << strv << topics[dist(rng)] << '.' << std::endl;
        if(not dinner.ready) return;
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(wait(rng)*150));
    std::lock_guard<std::mutex>  cout_lock(cout_mutex);
    std::cout << name << strv << std::endl;
}
 
int main()
{
    Dinner dinner;
    std::array<Philosopher, 5> philosophers {{
            {strv, dinner, dinner.forks[0], dinner.forks[1]},
            {strv,      dinner, dinner.forks[1], dinner.forks[2]},
            {strv,   dinner, dinner.forks[2], dinner.forks[3]},
            {strv,      dinner, dinner.forks[3], dinner.forks[4]},
            {strv,   dinner, dinner.forks[4], dinner.forks[0]},
    }};
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << strv << std::endl;
    dinner.ready = true;
    std::this_thread::sleep_for(std::chrono::seconds(5));
    dinner.ready = false;
    std::lock_guard<std::mutex>  cout_lock(cout_mutex);
    std::cout << strv << std::endl;
}"
"

//


//
#include <iostream>
#include <cmath>
#include <utility>
 
template<class P_> P_ IncFirst(const P_& src) {return P_(src.first + 1, src.second);}
 
std::pair<int, int> DigitalRoot(unsigned long long digits, int base = 10) 
{
    int x = SumDigits(digits, base);
    return x < base ? std::make_pair(1, x) : IncFirst(DigitalRoot(x, base));  

}
 
int main() {
    const unsigned long long ip[] = {961038,923594037444,670033,448944221089};
    for (auto i:ip){
        auto res = DigitalRoot(i);
        std::cout << i << strv << res.second << strv << res.first << """";
    }
    std::cout << """";
    const unsigned long long hip[] = {0x7e0,0x14e344,0xd60141,0x12343210};
    for (auto i:hip){
        auto res = DigitalRoot(i,16);
        std::cout << std::hex << i << strv << res.second << strv << res.first << """";
    }
    return 0;
}"
"#include <vector>
#include <iostream>
#include <stdexcept>
using namespace std;
 
typedef std::pair<double, double> TriPoint;
 
inline double Det2D(TriPoint &p1, TriPoint &p2, TriPoint &p3) 
{
	return +p1.first*(p2.second-p3.second)
		+p2.first*(p3.second-p1.second)
		+p3.first*(p1.second-p2.second);
}
 
void CheckTriWinding(TriPoint &p1, TriPoint &p2, TriPoint &p3, bool allowReversed)
{
	double detTri = Det2D(p1, p2, p3);
	if(detTri < 0.0)
	{
		if (allowReversed)
		{
			TriPoint a = p3;
			p3 = p2;
			p2 = a;
		}
		else throw std::runtime_error(strv);
	}
}
 
bool BoundaryCollideChk(TriPoint &p1, TriPoint &p2, TriPoint &p3, double eps)
{
	return Det2D(p1, p2, p3) < eps;
}
 
bool BoundaryDoesntCollideChk(TriPoint &p1, TriPoint &p2, TriPoint &p3, double eps)
{
	return Det2D(p1, p2, p3) <= eps;
}
 
bool TriTri2D(TriPoint *t1,
	TriPoint *t2,
	double eps = 0.0, bool allowReversed = false, bool onBoundary = true)
{
	//Trangles must be expressed anti-clockwise
	CheckTriWinding(t1[0], t1[1], t1[2], allowReversed);
	CheckTriWinding(t2[0], t2[1], t2[2], allowReversed);
 
	bool (*chkEdge)(TriPoint &, TriPoint &, TriPoint &, double) = NULL;
	if(onBoundary) //Points on the boundary are considered as colliding
		chkEdge = BoundaryCollideChk;
	else //Points on the boundary are not considered as colliding
		chkEdge = BoundaryDoesntCollideChk;
 
	//For edge E of trangle 1,
	for(int i=0; i<3; i++)
	{
		int j=(i+1)%3;
 
		//Check all points of trangle 2 lay on the external side of the edge E. If
		//they do, the triangles do not collide.
		if (chkEdge(t1[i], t1[j], t2[0], eps) &&
			chkEdge(t1[i], t1[j], t2[1], eps) &&
			chkEdge(t1[i], t1[j], t2[2], eps))
			return false;
	}
 
	//For edge E of trangle 2,
	for(int i=0; i<3; i++)
	{
		int j=(i+1)%3;
 
		//Check all points of trangle 1 lay on the external side of the edge E. If
		//they do, the triangles do not collide.
		if (chkEdge(t2[i], t2[j], t1[0], eps) &&
			chkEdge(t2[i], t2[j], t1[1], eps) &&
			chkEdge(t2[i], t2[j], t1[2], eps))
			return false;
	}
 
	//The triangles collide
	return true;
}
 
int main()
{
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(0,5)};
	TriPoint t2[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(0,6)};
	cout << TriTri2D(t1, t2) << strv << true << endl;}
 
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(0,5),TriPoint(5,0)};
	TriPoint t2[] = {TriPoint(0,0),TriPoint(0,5),TriPoint(5,0)};
	cout << TriTri2D(t1, t2, 0.0, true) << strv << true << endl;}
 
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(0,5)};
	TriPoint t2[] = {TriPoint(-10,0),TriPoint(-5,0),TriPoint(-1,6)};
	cout << TriTri2D(t1, t2) << strv << false << endl;}
 
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(2.5,5)};
	TriPoint t2[] = {TriPoint(0,4),TriPoint(2.5,-1),TriPoint(5,4)};
	cout << TriTri2D(t1, t2) << strv << true << endl;}
 
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,1),TriPoint(0,2)};
	TriPoint t2[] = {TriPoint(2,1),TriPoint(3,0),TriPoint(3,2)};
	cout << TriTri2D(t1, t2) << strv << false << endl;}
 
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,1),TriPoint(0,2)};
	TriPoint t2[] = {TriPoint(2,1),TriPoint(3,-2),TriPoint(3,4)};
	cout << TriTri2D(t1, t2) << strv << false << endl;}
 
	//Barely touching
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,0),TriPoint(0,1)};
	TriPoint t2[] = {TriPoint(1,0),TriPoint(2,0),TriPoint(1,1)};
	cout << TriTri2D(t1, t2, 0.0, false, true) << strv << true << endl;}
 
	//Barely touching
	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,0),TriPoint(0,1)};
	TriPoint t2[] = {TriPoint(1,0),TriPoint(2,0),TriPoint(1,1)};
	cout << TriTri2D(t1, t2, 0.0, false, false) << strv << false << endl;}
 
}"
"#include <afx.h>HANDLE mutex;mutex = CreateMutex( NULL, TRUE, strv );
if ( GetLastError() == ERROR_ALREADY_EXISTS )
{
     

}CloseHandle( mutex );"
" 
#include <iomanip>
#include <map>
#include <vector>
#include <iostream>
using namespace std;
 
void calcMDR( int n, int c, int& a, int& b )
{
    int m = n % 10; n /= 10;
    while( n )
    {
	m *= ( n % 10 );
	n /= 10;
    }
    if( m >= 10 ) calcMDR( m, ++c, a, b );
    else { a = m; b = c; }
}
 
void table()
{
    map<int, vector<int> > mp;
    int n = 0, a, b;
    bool f = true;
    while( f )
    {
	f = false;
	calcMDR( n, 1, a, b );
	mp[a].push_back( n );
	n++;
	for( int x = 0; x < 10; x++ )
	    if( mp[x].size() < 5 )
	    { f = true; break; }
    }
 
    cout << ""|  MDR  |  [n0..n4]+-------+------------------------------------+"";
    for( int x = 0; x < 10; x++ )
    {
	cout << right << strv << setw( 6 ) << x << strv;
	for( vector<int>::iterator i = mp[x].begin(); i != mp[x].begin() + 5; i++ )
	    cout << setw( 6 ) << *i << strv;
	cout << ""|"";
    }
    cout << ""+-------+------------------------------------+"";
}
 
int main( int argc, char* argv[] )
{
    cout << ""|  NUMBER  |   MDR    |    MP    |+----------+----------+----------+"";
    int numbers[] = { 123321, 7739, 893, 899998 }, a, b;
    for( int x = 0; x < 4; x++ )
    {
	cout << right << strv  << setw( 9 ) << numbers[x] << strv;
	calcMDR( numbers[x], 1, a, b );
	cout << setw( 9 ) << a  << strv << setw( 9 ) << b << ""|"";
    }
    cout << ""+----------+----------+----------+"";
    table();
    return system( strv );
}
 "
" 
#include<iostream>
#include<csignal> /* for signal */
#include<cstdlib>
 
using namespace std;
 
void fpe_handler(int signal)
{
    cerr << strv << endl;
    exit(signal);
}
 
int main()
{
    

    signal(SIGFPE, fpe_handler);
 
    int a = 1;
    int b = 0;
    cout << a/b << endl;
 
    return 0;
}
 "
"#include <sstream> // for istringstream
 
using namespace std;
 
bool isNumeric( const char* pszInput, int nNumberBase )
{
	istringstream iss( pszInput );
 
	if ( nNumberBase == 10 )
	{
		double dTestSink;
		iss >> dTestSink;
	}
	else if ( nNumberBase == 8 || nNumberBase == 16 )
	{
		int nTestSink;
		iss >> ( ( nNumberBase == 8 ) ? oct : hex ) >> nTestSink;
	}
	else
		return false;
 
	

	if ( ! iss )
		return false;
 
	

	return ( iss.rdbuf()->in_avail() == 0 );
}
  
bool isNumeric( const char* pszInput, int nNumberBase )
{
	string base = strv;
	string input = pszInput;
 
	return (input.find_first_not_of(base.substr(0, nNumberBase)) == string::npos);
}
  
bool isNumeric(const std::string& input) {
    return std::all_of(input.begin(), input.end(), ::isdigit);
}
 "
" 
#include <tr1/memory>
#include <string>
#include <iostream>
#include <tr1/functional>
 
using namespace std;
using namespace std::tr1;
using std::tr1::function;
 


class IDelegate
{
public:
    virtual ~IDelegate() {}
};
 
//interface for delegates supporting thing 
class IThing
{
public:
    virtual ~IThing() {}
    virtual std::string Thing() = 0;
};
 


class DelegateA : virtual public IDelegate
{
};
 


class DelegateB : public IThing, public IDelegate
{
    std::string Thing()
    {
        return strv;
    }
};
 
class Delegator
{
public:
    std::string Operation()
    {
        if(Delegate) //have delegate
           if (IThing * pThing = dynamic_cast<IThing*>(Delegate.get()))
            //delegate provides IThing interface
            return pThing->Thing();
 
        return strv;
    }
 
    shared_ptr<IDelegate> Delegate;
};
 
int main()
{
    shared_ptr<DelegateA> delegateA(new DelegateA());
    shared_ptr<DelegateB> delegateB(new DelegateB());
    Delegator delegator;
 
    

    std::cout << delegator.Operation() << std::endl;
 
    

    delegator.Delegate = delegateA;
    std::cout << delegator.Operation() << std::endl;
 
    

    delegator.Delegate = delegateB;
    std::cout << delegator.Operation() << std::endl;
 
/*Prints:   default implementation  default implementation  delegate implementation */
}
 "
"#include <cstdio>
#include <direct.h>
 
int main() {
	remove( strv );
	remove( strv );
	_rmdir( strv );
	_rmdir( strv );
 
	return 0;
}"
"#include <stdexcept>
 
class tiny_int
{
public:
  tiny_int(int i):
    value(i)
  {
    if (value < 1)
      throw std::out_of_range(strv);
    if (value > 10)
      throw std::out_of_range(strv);
  }
  operator int() const
  {
    return value;
  }
  tiny_int& operator+=(int i)
  {
    

    

    *this = value + i;
    return *this;
  }
  tiny_int& operator-=(int i)
  {
    *this = value - i;
    return *this;
  }
  tiny_int& operator*=(int i)
  {
    *this = value * i;
    return *this;
  }
  tiny_int& operator/=(int i)
  {
    *this = value / i;
    return *this;
  }
  tiny_int& operator<<=(int i)
  {
    *this = value << i;
    return *this;
  }
  tiny_int& operator>>=(int i)
  {
    *this = value >> i;
    return *this;
  }
  tiny_int& operator&=(int i)
  {
    *this = value & i;
    return *this;
  }
  tiny_int& operator|=(int i)
  {
    *this = value | i;
    return *this;
  }
private:
  unsigned char value; 

};"
" 
#include <windows.h>
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class fc_dealer
{
public:
    void deal( int game )
    {
	_gn = game;
	fillDeck();
	shuffle();
	display();
    }
 
private:
    void fillDeck()
    {
	int p = 0;
	for( int c = 0; c < 13; c++ )
	    for( int s = 0; s < 4; s++ )
		_cards[p++] = c | s << 4;
    }
 
    void shuffle()
    {
	srand( _gn );
	int cc = 52, nc, lc;
	while( cc )
	{
	    nc = rand() % cc;
	    lc = _cards[--cc];
	    _cards[cc] = _cards[nc];
	    _cards[nc] = lc;
	}
    }
 
    void display()
    {
	char* suit = strv;
	char* symb = strv;
	int z = 0;
	cout << strv << _gn << endl << strv << endl;
	for( int c = 51; c >= 0; c-- )
	{
	    cout << symb[_cards[c] & 15] << suit[_cards[c] >> 4] << strv;
	    if( ++z >= 8 )
	    {
		cout << endl;
		z = 0;
	    }
	}
    }
 
    int _cards[52], _gn;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    fc_dealer dealer;
    int gn;
    while( true )
    {
	cout << endl << strv; cin >> gn;
	if( !gn ) break;
 
	system( strv );
	dealer.deal( gn );
	cout << endl << endl;
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 #include <string>       // std::string
#include <iostream>     // std::cout
#include <sstream>      // std::stringstream
#include <vector>       // std::vector
 
using namespace std;
 
//------------------------------------------------------------------------------
 
class Random {
public:
        void init(uint32_t seed) { _seed = seed; }
        int roll() { return (_seed = (_seed * MULT + INCR) & MASK) >> 16; }
private:
        int _seed;
        enum { MULT = 214013, INCR = 2531011, MASK = (1U << 31) - 1 };
};
 
//------------------------------------------------------------------------------
 
class Card {
public:
        Card(int value) : _value(value) { }
        int suit() const { return _value % 4; }
        int rank() const { return _value / 4; }
        string str() const {
                stringstream s; s << _ranks[rank()] << _suits[suit()]; return s.str();
        }
private:
        int _value;
        const char* _suits = strv;
        const char* _ranks = strv;
};
 
//------------------------------------------------------------------------------
 
class Deck {
public:
        Deck(int seed) {
                _random.init(seed);
                for (int i = 0; i < 52; i++)
                        _cards.push_back(Card(51 - i));
                for (int i = 0; i < 51; i++) {
                        int j = 51 - _random.roll() % (52 - i);
                        swap(_cards[i], _cards[j]);
                }
        }
        string str() const {
                stringstream s;
                for (int i = 0; i < _cards.size(); i++)
                        s << _cards[i].str() << (i % 8 == 7 || i == 51 ? """" : strv);
                return s.str();
        }
private:
        vector<Card>    _cards;
        Random          _random;
};
 
//------------------------------------------------------------------------------
 
int main(int argc, const char * argv[])
{
        {
                Deck deck(1);
                cout << strv << endl << deck.str() << endl;
        }
        {
                Deck deck(617);
                cout << strv << endl << deck.str() << endl;
        }
        return 0;
}
 "
"



 
#include <vector>
#include <string>
#include <iostream>
#include <ctime>
 
/** Return the current date in a string, formatted as either ISO-8601 *  or strv. * *  The date is initialized when the object is created and will return *  the same date for the lifetime of the object.  The date returned *  is the date in the local timezone. */
class Date
{
    struct tm ltime;
 
public:
    /// Default constructor.
    Date()
    {
        time_t t = time(0);
        localtime_r(&t, &ltime);
    }
 
    /** Return the date based on a format string.  The format string is     *  fed directly into strftime().  See the strftime() documentation     *  for information on the proper construction of format strings.     *     *  @param[in] fmt is a valid strftime() format string.     *     *  @return a string containing the formatted date, or a blank string     *      if the format string was invalid or resulted in a string that     *      exceeded the internal buffer length.     */
    std::string getDate(const char* fmt)
    {
        char out[200];
        size_t result = strftime(out, sizeof out, fmt, &ltime);
        return std::string(out, out + result);
    }
 
    /** Return the date in ISO-8601 date format.     *     *  @return a string containing the date in ISO-8601 date format.     */
    std::string getISODate() {return getDate(strv);}
 
    /** Return the date formatted as strv.     *     *  @return a string containing the date in the specified format.     */
    std::string getTextDate() {return getDate(strv);}
};
 
int main()
{
    Date d;
    std::cout << d.getISODate() << std::endl;
    std::cout << d.getTextDate() << std::endl;
    return 0;
}"
"#include <string>
#include <iostream>
#include <boost/date_time/local_time/local_time.hpp>
#include <sstream>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <vector>
#include <boost/algorithm/string.hpp>
#include <cstdlib>
#include <locale>
 
 
int main( ) {
   std::string datestring (strv ) ;
   //we must first parse the date string into a date , a time and a time
   //zone part , to take account of present restrictions in the input facets
   //of the Boost::DateTime library used for this example
   std::vector<std::string> elements ;
   //parsing the date string
   boost::split( elements , datestring , boost::is_any_of( strv ) ) ;
   std::string datepart = elements[ 0 ] + strv + strv + elements[ 1 ] + strv +
      elements[ 2 ] ; //we must add 0 to avoid trouble with the boost::date_input format strings
   std::string timepart = elements[ 3 ] ;
   std::string timezone = elements[ 4 ] ;
   const char meridians[ ] = { 'a' , 'p' } ;
   //we have to find out if the time is am or pm, to change the hours appropriately
   std::string::size_type found = timepart.find_first_of( meridians, 0 ) ;
   std::string twelve_hour ( timepart.substr( found , 1 ) ) ;
   timepart = timepart.substr( 0 , found ) ; //we chop off am or pm
   elements.clear( ) ;
   boost::split( elements , timepart , boost::is_any_of ( strv ) ) ;
   long hour = std::atol( (elements.begin( ))->c_str( ) ) ;

   if ( twelve_hour == strv ) //it's post meridian, we're converting to 24-hour-clock
      hour += 12 ;
   long minute = std::atol( ( elements.begin( ) + 1)->c_str( ) ) ; 
   boost::local_time::tz_database tz_db ;
   tz_db.load_from_file( strv ) ;
   //according to the time zone database, this corresponds to one possible EST time zone
   boost::local_time::time_zone_ptr dyc = tz_db.time_zone_from_region( strv ) ;
   //this is the string input format to initialize the date field 
   boost::gregorian::date_input_facet *f =
      new boost::gregorian::date_input_facet( strv  ) ;
   std::stringstream ss ;
   ss << datepart ;
   ss.imbue( std::locale( std::locale::classic( ) , f ) ) ;
   boost::gregorian::date d ;
   ss >> d ;
   boost::posix_time::time_duration td (  hour , minute , 0  ) ;
   //that's how we initialize the New York local time , by using date and adding
   //time duration with values coming from parsed date input string
   boost::local_time::local_date_time lt ( d , td ,  dyc ,
	 boost::local_time::local_date_time::NOT_DATE_TIME_ON_ERROR ) ;
   std::cout << strv << lt << '' ;
   ss.str( strv ) ;
   ss << lt ;
   //we have to add 12 hours, so a new time duration object is created
   boost::posix_time::time_duration td2 (12 , 0 , 0 , 0 ) ;
   boost::local_time::local_date_time ltlater = lt + td2 ; //local time 12 hours later
   boost::gregorian::date_facet *f2 =
      new boost::gregorian::date_facet( strv ) ;
   std::cout.imbue( std::locale( std::locale::classic( ) , f2 ) ) ;
   std::cout << strv << ss.str( )  << strv << ltlater << "" !"" ;
   //what's New York time in the Berlin time zone ?
   boost::local_time::time_zone_ptr bt = tz_db.time_zone_from_region( strv ) ;
   std::cout.imbue( std::locale( strv ) ) ; //choose the output forman appropriate for the time zone
   std::cout << strv << ltlater.local_time_in( bt ) << "" in Berlin!"" ;
   return 0 ;
}
 "
"#include <boost/date_time/gregorian/gregorian.hpp>
#include <iostream>
 
int main( ) {
   using namespace boost::gregorian ;
 
   std::cout
      << ""Yuletide holidays must be allowed in the following years:"" ;
   for ( int i = 2008 ; i < 2121 ; i++ ) {
      greg_year gy = i ;
      date d  ( gy, Dec , 25 ) ;
      if ( d.day_of_week( ) == Sunday ) {
	 std::cout << i << std::endl ;
      }
   }
   std::cout << """" ;
   return 0 ;
}"
" 
#include <assert.h>
#include <cmath>
#include <vector>
#include <iostream>
 
template<int N> struct MomentsAccumulator_
{
	std::vector<double> m_;
	MomentsAccumulator_() : m_(N + 1, 0.0) {}
	void operator()(double v)
	{
		double inc = 1.0;
		for (auto& mi : m_)
		{
			mi += inc;
			inc *= v;
		}
	}
};
 
double Stdev(const std::vector<double>& moments)
{
	assert(moments.size() > 2);
	assert(moments[0] > 0.0);
	const double mean = moments[1] / moments[0];
	const double meanSquare = moments[2] / moments[0];
	return sqrt(meanSquare - mean * mean);
}
 
int main(void)
{
	std::vector<int> data({ 2, 4, 4, 4, 5, 5, 7, 9 });
	MomentsAccumulator_<2> accum;
	for (auto d : data)
	{
		accum(d);
		std::cout << strv << Stdev(accum.m_) << """";
	}
}
 "
"#include <string>
#include <iostream>
 
int main()
{
    

    char* data = new char[sizeof(std::string)];
 
    

    std::string* stringPtr = new (data) std::string(strv);
 
    std::cout << *stringPtr << strv << stringPtr << std::endl;
 
    

    

    stringPtr->~basic_string();
    stringPtr = new (data) std::string(strv);
 
    std::cout << *stringPtr << strv << stringPtr << std::endl;
 
    

    stringPtr->~basic_string();
    delete[] data;
}"
"#include <map>
#include <vector>
#include <iostream>
#include <fstream>
#include <utility>
#include <functional>
#include <string>
#include <sstream>
#include <algorithm>
#include <cctype>
 
class CSV
{
public:
    CSV(void) : m_nCols( 0 ), m_nRows( 0 )
    {}
 
    bool open( const char* filename, char delim = ',' )
    {
        std::ifstream file( filename );
 
        clear();
        if ( file.is_open() )
        {
            open( file, delim );
            return true;
        }
 
        return false;
    }
 
    void open( std::istream& istream, char delim = ',' )
    {
        std::string         line;
 
        clear();
        while ( std::getline( istream, line ) )
        {
            unsigned int nCol = 0;
            std::istringstream    lineStream(line);
            std::string           cell;
 
            while( std::getline( lineStream, cell, delim ) )
            {
                m_oData[std::make_pair( nCol, m_nRows )] = trim( cell );
                nCol++;
            }
            m_nCols = std::max( m_nCols, nCol );
            m_nRows++;
        }
    }
 
    bool save( const char* pFile, char delim = ',' )
    {
        std::ofstream ofile( pFile );
        if ( ofile.is_open() )
        {
            save( ofile );
            return true;
        }
        return false;
    }
 
    void save( std::ostream& ostream, char delim = ',' )
    {
        for ( unsigned int nRow = 0; nRow < m_nRows; nRow++ )
        {
            for ( unsigned int nCol = 0; nCol < m_nCols; nCol++ )
            {
                ostream << trim( m_oData[std::make_pair( nCol, nRow )] );
                if ( (nCol+1) < m_nCols )
                {
                    ostream << delim;
                }
                else
                {
                    ostream << std::endl;
                }
            }
        }
    }
 
    void clear()
    {
        m_oData.clear();
        m_nRows = m_nCols = 0;
    }
 
    std::string& operator()( unsigned int nCol, unsigned int nRow )
    {
        m_nCols = std::max( m_nCols, nCol+1 );
        m_nRows = std::max( m_nRows, nRow+1 );
        return m_oData[std::make_pair(nCol, nRow)];
    }
 
    inline unsigned int GetRows() { return m_nRows; }
    inline unsigned int GetCols() { return m_nCols; }
 
private:
    

    inline std::string &trim(std::string &s) 
    {
 
        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
        return s;
    }
 
private:
    std::map<std::pair<unsigned int, unsigned int>, std::string> m_oData;
 
    unsigned int    m_nCols;
    unsigned int    m_nRows;
};
 
 
int main()
{
    CSV oCSV;
 
    oCSV.open( strv );
    oCSV( 0, 0 ) = strv;
    oCSV( 1, 1 ) = strv;
    oCSV( 2, 2 ) = strv;
    oCSV( 3, 3 ) = strv;
    oCSV( 4, 4 ) = strv;
    oCSV.save( strv );
    return 0;
}"
"#include <string>
#include <boost/regex.hpp>
#include <iostream>
 
std::string csvToHTML( const std::string & ) ;
 
int main( ) {
   std::string text = ""Character,Speech"" 
                            ""The multitude,The messiah! Show us the messiah!"" 
			    ""Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>"" 
	                    ""The multitude,Who are you?"" 
		            ""Brians mother,I'm his mother; that's who!"" 
		            ""The multitude,Behold his mother! Behold his mother!"" ;
  std::cout << csvToHTML( text ) ;
  return 0 ;
}
 
std::string csvToHTML( const std::string & csvtext ) {
   //the order of the regexes and the replacements is decisive!
   std::string regexes[ 5 ] = { strv , strv , ""^(.+?)b"" , strv , """" } ;
   const char* replacements [ 5 ] = { strv , strv , strv , strv, ""</TD></TR>""  } ;  
   boost::regex e1( regexes[ 0 ] ) ; 
   std::string tabletext = boost::regex_replace( csvtext , e1 ,
     replacements[ 0 ] , boost::match_default | boost::format_all ) ;
   for ( int i = 1 ; i < 5 ; i++ ) {
      e1.assign( regexes[ i ] ) ;
      tabletext = boost::regex_replace( tabletext , e1 , replacements[ i ] , boost::match_default | boost::format_all ) ;
   }
   tabletext = std::string( ""<TABLE>"" ) + tabletext ;
   tabletext.append( ""</TABLE>"" ) ;
   return tabletext ;
}"
"#include <iostream>
#include <istream>
#include <ostream>
 
int main()
{
  

  int dim1, dim2;
  std::cin >> dim1 >> dim2;
 
  

  double* array_data = new double[dim1*dim2];
  double** array = new double*[dim1];
  for (int i = 0; i < dim1; ++i)
    array[i] = array_data + dim2*i;
 
  

  array[0][0] = 3.5;
 
  

  std::cout << array[0][0] << std::endl;
 
  

  delete[] array;
  delete[] array_data;
 
  return 0;
}#include <iostream>
#include <istream>
#include <ostream>
#include <vector>
 
int main()
{
  

  int dim1, dim2;
  std::cin >> dim1 >> dim2;
 
  

  std::vector<std::vector<double> > array(dim1, std::vector<double>(dim2));
 
  

  array[0][0] = 3.5;
 
  

  std::cout << array[0][0] << std::endl;
 
  

  return 0;
}#include <iostream>
#include strv
 
typedef boost::multi_array<double, 2> two_d_array_type;
 
int main()
{
    

    int dim1, dim2;
    std::cin >> dim1 >> dim2;
 
    

    two_d_array_type A(boost::extents[dim1][dim2]);
 
    

    A[0][0] = 3.1415;
 
    

    std::cout << A[0][0] << std::endl;
 
    return 0;
}#include <cstdlib>
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/io.hpp>
 
int main (const int argc, const char** argv) {
    if (argc > 2) {
        using namespace boost::numeric::ublas;
 
        matrix<double> m(atoi(argv[1]), atoi(argv[2])); 

        for (unsigned i = 0; i < m.size1(); i++)
            for (unsigned j = 0; j < m.size2(); j++)
                m(i, j) = 1.0 + i + j; 

        std::cout << m << std::endl; 

        return EXIT_SUCCESS;
    }
 
    return EXIT_FAILURE;
}"
"#include <fstream>
#include <direct.h>
 
int main() {
	std::fstream f( strv, std::ios::out );
	f.close();
	f.open( strv, std::ios::out );
	f.close();
 
	_mkdir( strv );
	_mkdir( strv );
 
	return 0;
}"
"#include <algorithm>
#include <array>
#include <cstdint>
#include <numeric>
 


#include <iomanip>
#include <iostream>
#include <string>
 


std::array<std::uint_fast32_t, 256> generate_crc_lookup_table() noexcept
{
  auto const reversed_polynomial = std::uint_fast32_t{0xEDB88320uL};
 
  

  

  struct byte_checksum
  {
    std::uint_fast32_t operator()() noexcept
    {
      auto checksum = static_cast<std::uint_fast32_t>(n++);
 
      for (auto i = 0; i < 8; ++i)
        checksum = (checksum >> 1) ^ ((checksum & 0x1u) ? reversed_polynomial : 0);
 
      return checksum;
    }
 
    unsigned n = 0;
  };
 
  auto table = std::array<std::uint_fast32_t, 256>{};
  std::generate(table.begin(), table.end(), byte_checksum{});
 
  return table;
}
 




template <typename InputIterator>
std::uint_fast32_t crc(InputIterator first, InputIterator last)
{
  

  static auto const table = generate_crc_lookup_table();
 
  

  

  return std::uint_fast32_t{0xFFFFFFFFuL} &
    ~std::accumulate(first, last,
      ~std::uint_fast32_t{0} & std::uint_fast32_t{0xFFFFFFFFuL},
        [](std::uint_fast32_t checksum, std::uint_fast8_t value) 
          { return table[(checksum ^ value) & 0xFFu] ^ (checksum >> 8); });
}
 
int main()
{
  auto const s = std::string{strv};
 
  std::cout << std::hex << std::setw(8) << std::setfill('0') << crc(s.begin(), s.end()) << '';
}
 #include <boost\crc.hpp>
#include <string>
#include <iostream>
 
int main()
{
    std::string str( strv );
    boost::crc_32_type  crc;
    crc.process_bytes( str.data(), str.size() );
 
    std::cout << strv << std::hex << crc.checksum() << std::endl;
    return 0;
}"
"#include <iostream>
#include <string>
 


int countSubstring(const std::string& str, const std::string& sub)
{
    if (sub.length() == 0) return 0;
    int count = 0;
    for (size_t offset = str.find(sub); offset != std::string::npos;
	 offset = str.find(sub, offset + sub.length()))
    {
        ++count;
    }
    return count;
}
 
int main()
{
    std::cout << countSubstring(strv, strv)    << '';
    std::cout << countSubstring(strv, strv)        << '';
    std::cout << countSubstring(strv, strv) << '';
 
    return 0;
}"
"#include <iostream>
 
int main()
{
  unsigned i = 0;
  do
  {
    std::cout << std::oct << i << std::endl;
    ++i;
  } while(i != 0);
  return 0;
}"
"#include <fstream>
#include <boost/array.hpp>
#include <string>
#include <cstdlib>
#include <ctime>
#include <sstream>
 
void makeGap( int gap , std::string & text ) {
   for ( int i = 0 ; i < gap ; i++ ) 
      text.append( strv ) ;
}
 
int main( ) {
   boost::array<char , 3> chars = { 'X' , 'Y' , 'Z' } ;
   int headgap = 3 ;
   int bodygap = 3 ;
   int tablegap = 6 ;
   int rowgap = 9 ;
   std::string tabletext( ""<html>"" ) ;
   makeGap( headgap , tabletext ) ;
   tabletext += ""<head></head>"" ;
   makeGap( bodygap , tabletext ) ;
   tabletext += ""<body>"" ;
   makeGap( tablegap , tabletext ) ;
   tabletext += ""<table>"" ;
   makeGap( tablegap + 1 , tabletext ) ;
   tabletext += ""<thead align=right>"" ;
   makeGap( tablegap, tabletext ) ;
   tabletext += strv ;
   for ( int i = 0 ; i < 3 ; i++ ) {
      tabletext += strv ;
      tabletext += *(chars.begin( ) + i ) ;
      tabletext += strv ;
   }
   tabletext += ""</tr>"" ;
   makeGap( tablegap + 1 , tabletext ) ;
   tabletext += strv ;
   makeGap( tablegap + 1 , tabletext ) ;
   tabletext += ""<tbody align=right>"" ;
   srand( time( 0 ) ) ;
   for ( int row = 0 ; row < 5 ; row++ ) {
      makeGap( rowgap , tabletext ) ;
      std::ostringstream oss ;
      tabletext += strv ;
      oss << row ;
      tabletext += oss.str( ) ;
      for ( int col = 0 ; col < 3 ; col++ ) {
	 oss.str( strv ) ;
	 int randnumber = rand( ) % 10000 ;
	 oss << randnumber ;
	 tabletext += strv ;
	 tabletext.append( oss.str( ) ) ;
	 tabletext += strv ;
      }
      tabletext += ""</tr>"" ;
   }
   makeGap( tablegap + 1 , tabletext ) ;
   tabletext += ""</tbody>"" ;
   makeGap( tablegap , tabletext ) ;
   tabletext += ""</table>"" ;
   makeGap( bodygap , tabletext ) ;
   tabletext += ""</body>"" ;
   tabletext += ""</html>"" ;
   std::ofstream htmltable( strv , std::ios::out | std::ios::trunc ) ;
   htmltable << tabletext ;
   htmltable.close( ) ;
   return 0 ;
}"
"#include <iostream>
#include <string>
 
int main( ) {
   std::string original (strv);
   std::string my_copy = original;
   std::cout << strv << my_copy << std::endl;
   original = strv;
   std::cout << strv << my_copy << std::endl;
}"
" 
#include <iostream>
#include <sstream>
#include <iomanip>
using namespace std;
 
void getPrimeFactors( int li )
{
    int f = 2; string res;
    if( li == 1 ) res = strv;
    else
    {
	while( true )
	{
	    if( !( li % f ) ) 
	    {
		stringstream ss; ss << f;
		res += ss.str();
		li /= f; if( li == 1 ) break;
		res += strv;
	    }
	    else f++;
	}
    }
    cout << res << """";
}
 
int main( int argc, char* argv[] )
{
    for( int x = 1; x < 101; x++ )
    {
	cout << right << setw( 4 ) << x << strv; 
	getPrimeFactors( x );
    }
    cout << 2144 << strv; getPrimeFactors( 2144 );
    cout << """";
    return system( strv );
}
 "
"/* Interface for all matrixNG classes   Nigel Galloway, February 10th., 2013.*/
class matrixNG {
  private:
  virtual void consumeTerm(){}
  virtual void consumeTerm(int n){}
  virtual const bool needTerm(){}
  protected: int cfn = 0, thisTerm;
             bool haveTerm = false;
  friend class NG;
};
/* Implement the babyNG matrix   Nigel Galloway, February 10th., 2013.*/
class NG_4 : public matrixNG {
  private: int a1, a, b1, b, t;
  const bool needTerm() {
    if (b1==0 and b==0) return false;
    if (b1==0 or b==0) return true; else thisTerm = a/b;
    if (thisTerm==(int)(a1/b1)){
      t=a; a=b; b=t-b*thisTerm; t=a1; a1=b1; b1=t-b1*thisTerm;
      haveTerm=true; return false;
    }
    return true;
  }
  void consumeTerm(){a=a1; b=b1;}
  void consumeTerm(int n){t=a; a=a1; a1=t+a1*n; t=b; b=b1; b1=t+b1*n;}
  public:
  NG_4(int a1, int a, int b1, int b): a1(a1), a(a), b1(b1), b(b){}
};
/* Implement a Continued Fraction which returns the result of an arithmetic operation on   1 or more Continued Fractions (Currently 1 or 2).   Nigel Galloway, February 10th., 2013.*/
class NG : public ContinuedFraction {
  private:
   matrixNG* ng;
   ContinuedFraction* n[2];
  public:
  NG(NG_4* ng, ContinuedFraction* n1): ng(ng){n[0] = n1;}
  NG(NG_8* ng, ContinuedFraction* n1, ContinuedFraction* n2): ng(ng){n[0] = n1; n[1] = n2;}
  const int nextTerm() {ng->haveTerm = false; return ng->thisTerm;}
  const bool moreTerms(){
    while(ng->needTerm()) if(n[ng->cfn]->moreTerms()) ng->consumeTerm(n[ng->cfn]->nextTerm()); else ng->consumeTerm();
    return ng->haveTerm;
  }
};int main() {
  NG_4 a1(2,1,0,2);
  r2cf n1(13,11);
  for(NG n(&a1, &n1); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  NG_4 a2(7,0,0,22);
  r2cf n2(22,7);
  for(NG n(&a2, &n2); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  NG_4 a3(2,1,0,2);
  r2cf n3(22,7);
  for(NG n(&a3, &n3); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  NG_4 a4(1,0,0,4);
  r2cf n4(22,7);
  for(NG n(&a4, &n4); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  NG_4 a5(0,1,1,0);
  SQRT2 n5;
  int i = 0;
  for(NG n(&a5, &n5); n.moreTerms() and i++ < 20; std::cout << n.nextTerm() << strv);
  std::cout << strv << std::endl;
  for(r2cf cf(10000000, 14142136); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  int i = 0;
  NG_4 a6(1,1,0,2);
  SQRT2 n6;
  for(NG n(&a6, &n6); n.moreTerms() and i++ < 20; std::cout << n.nextTerm() << strv);
  std::cout << strv << std::endl;
  for(r2cf cf(24142136, 20000000); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}"
" 
#include <algorithm>
#include <vector>
#include <iostream>
#include <string>
 
typedef unsigned char byte; 
 
class world {
public:
    world( int x, int y ) : _wid( x ), _hei( y ) {
        int s = _wid * _hei * sizeof( byte );
        _cells = new byte[s];
        memset( _cells, 0, s );
    }
    ~world() {
        delete [] _cells;
    }
    int wid() const {
        return _wid;
    }
    int hei() const {
        return _hei;
    }
    byte at( int x, int y ) const {
        return _cells[x + y * _wid];
    }
    void set( int x, int y, byte c ) {
        _cells[x + y * _wid] = c;
    }
    void swap( world* w ) {
        memcpy( _cells, w->_cells, _wid * _hei * sizeof( byte ) );
    }
private:
    int _wid, _hei;
    byte* _cells;
};
class rule {
public:
    rule( world* w ) : wrd( w ) {
        wid = wrd->wid();
        hei = wrd->hei();
        wrdT = new world( wid, hei );
    }
    ~rule() {
        if( wrdT ) delete wrdT;
    }
    bool hasLivingCells() {
        for( int y = 0; y < hei; y++ )
            for( int x = 0; x < wid; x++ )
                if( wrd->at( x, y ) ) return true;
        std::cout << ""*** All cells are dead!!! ***"";
        return false;
    }
    void swapWrds() {
        wrd->swap( wrdT );
    }
    void setRuleB( std::vector<int>& birth ) {
        _birth = birth;
    }
    void setRuleS( std::vector<int>& stay ) {
        _stay = stay;
    }
    void applyRules() {
        int n;
        for( int y = 0; y < hei; y++ ) {
            for( int x = 0; x < wid; x++ ) {
                n = neighbours( x, y );
                if( wrd->at( x, y ) ) {
                    wrdT->set( x, y, inStay( n ) ? 1 : 0 );
                } else {
                    wrdT->set( x, y, inBirth( n ) ? 1 : 0 );
                }
            }
        }
    }
private:
    int neighbours( int xx, int yy ) {
        int n = 0, nx, ny;
        for( int y = -1; y < 2; y++ ) {
            for( int x = -1; x < 2; x++ ) {
                if( !x && !y ) continue;
                nx = ( wid + xx + x ) % wid;
                ny = ( hei + yy + y ) % hei;
                n += wrd->at( nx, ny ) > 0 ? 1 : 0;
            }
        }
        return n;
    }
    bool inStay( int n ) {
        return( _stay.end() != find( _stay.begin(), _stay.end(), n ) );
    }
    bool inBirth( int n ) {
        return( _birth.end() != find( _birth.begin(), _birth.end(), n ) );
    }
    int wid, hei;
    world *wrd, *wrdT;
    std::vector<int> _stay, _birth;
};
class cellular {
public:
    cellular( int w, int h ) : rl( 0 ) {
        wrd = new world( w, h );
    }
    ~cellular() {
        if( rl ) delete rl;
        delete wrd;
    }
    void start( int r ) {
        rl = new rule( wrd );
        gen = 1;
        std::vector<int> t;
        switch( r ) {
            case 1: 

                t.push_back( 2 ); t.push_back( 3 ); rl->setRuleS( t );
                t.clear(); t.push_back( 3 ); rl->setRuleB( t );
                break;
            case 2: 

                t.push_back( 1 ); t.push_back( 3 ); t.push_back( 5 ); t.push_back( 8 ); rl->setRuleS( t );
                t.clear(); t.push_back( 3 ); t.push_back( 5 ); t.push_back( 7 ); rl->setRuleB( t );
                break;
            case 3: 

                t.push_back( 3 ); t.push_back( 4 ); rl->setRuleS( t );
                rl->setRuleB( t );
                break;
            case 4: 

                t.push_back( 1 ); t.push_back( 2 ); t.push_back( 3 ); t.push_back( 4 ); t.push_back( 5 ); rl->setRuleS( t );
                t.clear(); t.push_back( 3 ); rl->setRuleB( t );
                break;
        }
 
        /* just for test - shoud read from a file */
        /* GLIDER */
        wrd->set( 6, 1, 1 ); wrd->set( 7, 2, 1 );
        wrd->set( 5, 3, 1 ); wrd->set( 6, 3, 1 );
        wrd->set( 7, 3, 1 );
        /* BLINKER */
        wrd->set( 1, 3, 1 ); wrd->set( 2, 3, 1 );
        wrd->set( 3, 3, 1 );
        /******************************************/
        generation();
    }
private:
    void display() {
        system( strv );
        int wid = wrd->wid(),
            hei = wrd->hei();
        std::cout << strv << std::string( wid, '-' ) << ""+"";
        for( int y = 0; y < hei; y++ ) {
            std::cout << strv;
            for( int x = 0; x < wid; x++ ) {
                if( wrd->at( x, y ) ) std::cout << strv;
                else std::cout << strv;
            }
            std::cout << ""|"";
        }
        std::cout << strv << std::string( wid, '-' ) << ""+"";
        std::cout << strv << gen << ""Press [RETURN] for the next generation..."";
        std::cin.get();
    }
    void generation() {
        do {
            display();
            rl->applyRules();
            rl->swapWrds();
            gen++;
        }
        while ( rl->hasLivingCells() );
    }
    rule* rl;
    world* wrd;
    int gen; 
};
 
int main( int argc, char* argv[] ) {
    cellular c( 20, 12 );
    std::cout << ""*** CELLULAR AUTOMATA ***"" << "" Which one you want to run?"";
    std::cout << "" [1]Conway's Life [2]Amoeba [3]Life 34 [4]Maze > "";
    int o; 
    do {
        std::cin >> o;
    } 
    while( o < 1 || o > 4 );
    std::cin.ignore();
    c.start( o );
    return system( strv );
}
 julia> Pkg.add(strv)
INFO: Installing CellularAutomata v0.1.2
INFO: Package database updated
 
julia> using CellularAutomata
 
julia> gameOfLife{T<:Int}(n::T, m::T, gen::T) = CA2d([3], [2,3], int(randbool(n, m)), gen)
gameOfLife (generic function with 1 method)
 
julia> gameOfLife(15, 30, 5)
30x15x5 Cellular Automaton"
"/* Implement matrix NG   Nigel Galloway, February 12., 2013*/
class NG_8 : public matrixNG {
  private: int a12, a1, a2, a, b12, b1, b2, b, t;
           double ab, a1b1, a2b2, a12b12;
  const int chooseCFN(){return fabs(a1b1-ab) > fabs(a2b2-ab)? 0 : 1;}
  const bool needTerm() {
    if (b1==0 and b==0 and b2==0 and b12==0) return false;
    if (b==0){cfn = b2==0? 0:1; return true;} else ab = ((double)a)/b;
    if (b2==0){cfn = 1; return true;} else a2b2 = ((double)a2)/b2;
    if (b1==0){cfn = 0; return true;} else a1b1 = ((double)a1)/b1;
    if (b12==0){cfn = chooseCFN(); return true;} else a12b12 = ((double)a12)/b12;
    thisTerm = (int)ab;
    if (thisTerm==(int)a1b1 and thisTerm==(int)a2b2 and thisTerm==(int)a12b12){
      t=a; a=b; b=t-b*thisTerm; t=a1; a1=b1; b1=t-b1*thisTerm; t=a2; a2=b2; b2=t-b2*thisTerm; t=a12; a12=b12; b12=t-b12*thisTerm;
      haveTerm = true; return false;
    }
    cfn = chooseCFN();
    return true;
  }
  void consumeTerm(){if(cfn==0){a=a1; a2=a12; b=b1; b2=b12;} else{a=a2; a1=a12; b=b2; b1=b12;}}
  void consumeTerm(int n){
    if(cfn==0){t=a; a=a1; a1=t+a1*n; t=a2; a2=a12; a12=t+a12*n; t=b; b=b1; b1=t+b1*n; t=b2; b2=b12; b12=t+b12*n;}
    else{t=a; a=a2; a2=t+a2*n; t=a1; a1=a12; a12=t+a12*n; t=b; b=b2; b2=t+b2*n; t=b1; b1=b12; b12=t+b12*n;}
  }
  public:
  NG_8(int a12, int a1, int a2, int a, int b12, int b1, int b2, int b): a12(a12), a1(a1), a2(a2), a(a), b12(b12), b1(b1), b2(b2), b(b){
}};int main() {
  NG_8 a(0,1,1,0,0,0,0,1);
  r2cf n2(22,7);
  r2cf n1(1,2);
  for(NG n(&a, &n1, &n2); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
 
  NG_4 a3(2,1,0,2);
  r2cf n3(22,7);
  for(NG n(&a3, &n3); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  NG_8 b(1,0,0,0,0,0,0,1);
  r2cf b1(13,11);
  r2cf b2(22,7);
  for(NG n(&b, &b1, &b2); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(NG n(&a, &b2, &b1); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf cf(286,77); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  NG_8 c(0,1,-1,0,0,0,0,1);
  r2cf c1(13,11);
  r2cf c2(22,7);
  for(NG n(&c, &c1, &c2); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf cf(-151,77); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  NG_8 d(0,1,0,0,0,0,1,0);
  r2cf d1(22*22,7*7);
  r2cf d2(22,7);
  for(NG n(&d, &d1, &d2); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}int main() {
  r2cf a1(2,7);
  r2cf a2(13,11);
  NG_8 na(0,1,1,0,0,0,0,1);
  NG A(&na, &a1, &a2); //[0;3,2] + [1;5,2]
  r2cf b1(2,7);
  r2cf b2(13,11);
  NG_8 nb(0,1,-1,0,0,0,0,1);
  NG B(&nb, &b1, &b2); //[0;3,2] - [1;5,2]
  NG_8 nc(1,0,0,0,0,0,0,1); //A*B
  for(NG n(&nc, &A, &B); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf cf(2,7); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf cf(13,11); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf cf(-7797,5929); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}"
" 
#include <iostream>
#include <vector>
 
using entry = std::pair<int, const char*>;
 
void print(const std::vector<entry>& entries, std::ostream& out = std::cout)
{
    bool first = true;
    for(const auto& e: entries) {
        if(!first) out << strv;
        first = false;
        out << e.first << strv << e.second;
    }
    out << '';
}
 
std::vector<entry> convert(int seconds)
{
    static const entry time_table[] = {
        {7*24*60*60, strv}, {24*60*60, strv}, {60*60, strv}, {60, strv}, {1, strv}
    };
    std::vector<entry> result;
    for(const auto& e: time_table) {
        int time = seconds / e.first;
        if(time != 0) result.emplace_back(time, e.second);
        seconds %= e.first;
    }
    return result;
}
 
int main()
{
    std::cout << strv; print(convert(   7259));
    std::cout << strv; print(convert(  86400));
    std::cout << strv; print(convert(6000000));
}"
"#include <iostream>
/* Interface for all Continued Fractions   Nigel Galloway, February 9th., 2013.*/
class ContinuedFraction {
	public:
	virtual const int nextTerm(){};
	virtual const bool moreTerms(){};
};
/* Create a continued fraction from a rational number   Nigel Galloway, February 9th., 2013.*/
class r2cf : public ContinuedFraction {
	private: int n1, n2;
	public:
	r2cf(const int numerator, const int denominator): n1(numerator), n2(denominator){}
	const int nextTerm() {
		const int thisTerm = n1/n2;
		const int t2 = n2; n2 = n1 - thisTerm * n2; n1 = t2;
		return thisTerm;
	}
	const bool moreTerms() {return fabs(n2) > 0;}
};
/* Generate a continued fraction for sqrt of 2   Nigel Galloway, February 9th., 2013.*/
class SQRT2 : public ContinuedFraction {
	private: bool first=true;
	public:
	const int nextTerm() {if (first) {first = false; return 1;} else return 2;}
	const bool moreTerms() {return true;}
};int main() {
	for(r2cf n(1,2); n.moreTerms(); std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	for(r2cf n(3,1); n.moreTerms(); std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	for(r2cf n(23,8); n.moreTerms(); std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	for(r2cf n(13,11); n.moreTerms(); std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	for(r2cf n(22,7); n.moreTerms(); std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	for(r2cf cf(-151,77); cf.moreTerms(); std::cout << cf.nextTerm() << strv);
	std::cout << std::endl;
	return 0;
}int main() {
	int i = 0;
	for(SQRT2 n; i++ < 20; std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	for(r2cf n(14142,10000); n.moreTerms(); std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	for(r2cf n(14142136,10000000); n.moreTerms(); std::cout << n.nextTerm() << strv);
	std::cout << std::endl;
	return 0;
}int main() {
  for(r2cf n(31,10); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf n(314,100); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf n(3142,1000); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf n(31428,10000); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf n(314285,100000); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf n(3142857,1000000); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf n(31428571,10000000); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  for(r2cf n(314285714,100000000); n.moreTerms(); std::cout << n.nextTerm() << strv);
  std::cout << std::endl;
  return 0;
}"
"#include <iomanip>
#include <iostream>
#include <tuple>
 
typedef std::tuple<double,double> coeff_t; 

typedef coeff_t (*func_t)(int); 

 
double calc(func_t func, int n)
{
    double a, b, temp = 0;
    for (; n > 0; --n) {
        std::tie(a, b) = func(n);
        temp = b / (a + temp);
    }
    std::tie(a, b) = func(0);
    return a + temp;
}
 
coeff_t sqrt2(int n)
{
    return coeff_t(n > 0 ? 2 : 1, 1);
}
 
coeff_t napier(int n)
{
    return coeff_t(n > 0 ? n : 2, n > 1 ? n - 1 : 1);
}
 
coeff_t pi(int n)
{
    return coeff_t(n > 0 ? 6 : 3, (2 * n - 1) * (2 * n - 1));
}
 
int main()
{
    std::streamsize old_prec = std::cout.precision(15); 

    std::cout 
        << calc(sqrt2, 20) << ''
        << calc(napier, 15) << ''
        << calc(pi, 10000) << ''
        << std::setprecision(old_prec); 

}"
" 
#include <windows.h>
#include <list>
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
class point
{
public:
    int x, y;
    point()                  { x = y = 0; }
    point( int a, int b )    { x = a; y = b; }
    void set( int a, int b ) { x = a; y = b; }
};
//--------------------------------------------------------------------------------------------------
class rndCircle
{
public:
    void draw()
    {
	createPoints();
	drawPoints();
    }
 
private:
    void createPoints()
    {
	point pt;
	for( int x = 0; x < 200; x++ )
	{
	    int a, b, c;
	    while( true )
	    {
		a = rand() % 31 - 15;
		b = rand() % 31 - 15;
		c = a * a + b * b;
		if( c >= 100 && c <= 225 ) break;
	    }
	    pt.set( a, b );
	    _ptList.push_back( pt );
	}
    }
 
    void drawPoints()
    {
	HDC dc = GetDC( GetConsoleWindow() );
	for( list<point>::iterator it = _ptList.begin(); it != _ptList.end(); it++ )
	    SetPixel( dc, 300 + 10 * ( *it ).x, 300 + 10 * ( *it ).y, RGB( 255, 255, 0 ) );
    }
 
    list<point> _ptList;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );
    srand( GetTickCount() );
    rndCircle c;
    c.draw();
    system( strv );
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <thread>
#include <iostream>
#include <vector>
#include <random>
#include <chrono> 
 
int main()
{
  std::random_device rd;
  std::mt19937 eng(rd()); 

  std::uniform_int_distribution<> dist(1,1000);
  std::vector<std::thread> threads;
 
  for(const auto& str: {""Enjoy"", ""Rosetta"", ""Code""}) {
    

    std::chrono::milliseconds duration(dist(eng)); 
 
    threads.emplace_back([str, duration](){                                                                    
      std::this_thread::sleep_for(duration);
      std::cout << str;
    });
  }
 
  for(auto& t: threads) t.join(); 
 
  return 0;
}#include <iostream>
#include <ppl.h> // MSVC++
 
void a(void) { std::cout << ""Eat"";   }
void b(void) { std::cout << ""At"";    }
void c(void) { std::cout << ""Joe's""; }
 
int main()
{
    

    Concurrency::parallel_invoke(&a, &b, &c);
 
    

    Concurrency::parallel_invoke(
        []{ std::cout << ""Enjoy"";   },
        []{ std::cout << ""Rosetta""; },
        []{ std::cout << ""Code"";    }
    );
    return 0;
}"
"struct Point
{
  int x;
  int y;
};struct Point
{
  int x;
  int y;
  Point(int ax, int ay): x(ax), y(ax) {}
};template<typename Coordinate> struct point
{
  Coordinate x, y;
};
 


Point<int> point1 = { 3, 5 };
 


Point<float> point2 = { 1.7, 3.6 };"
"template<bool Condition, typename ThenType, typename Elsetype> struct ifthenelse;
 
template<typename ThenType, typename ElseType> struct ifthenelse<true, ThenType, ElseType>
{
  typedef ThenType type;
};
 
template<typename ThenType, typename ElseType> struct ifthenelse<false, ThenType, ElseType>
{
  typedef ElseType type;
};
 


ifthenelse<INT_MAX == 32767, 

           long int,         

           int>              

  ::type myvar;              
"
"#include <iostream>
 
template<int i> struct Fac
{
    static const int result = i * Fac<i-1>::result;
};
 
template<> struct Fac<1>
{
    static const int result = 1;
};
 
 
int main()
{
    std::cout << strv << Fac<10>::result << """";
    return 0;
}#include <stdio.h>
 
constexpr int factorial(int n) {
    return n ? (n * factorial(n - 1)) : 1;
}
 
constexpr int f10 = factorial(10);
 
int main() {
    printf(""%d"", f10);
    return 0;
}"
"#include <algorithm>
#include <string>
 
std::all_of( ++(strings.begin()), strings.end(),
             [&](std::string a){ return a == strings.front(); } )  

 
std::is_sorted( strings.begin(), strings.end(),
                [](std::string a, std::string b){ return !(b < a); }) )  
"
"

#define FOO \  (macro text) // comment
  (no more macro text)"
"#include <iostream>
 
int main(int argc, char* argv[])
{
  std::cout << strv << argv[0] << std::endl;
  std::cout << strv << argc-1 << strv << std::endl;
  for (int i = 1; i < argc; ++i)
    std::cout << strv << i << strv << argv[i] << std::endl;
 
  return 0;
}"
" 
#include <windows.h>
 
//--------------------------------------------------------------------------------------------------
class pinstripe
{
public:
    pinstripe()                        { createColors(); }
    void setDimensions( int x, int y ) { _mw = x; _mh = y; }
    void createColors()
    {
	colors[0] = 0; colors[1] = 255; colors[2] = RGB( 0, 255, 0 );
	colors[3] = RGB( 0, 0, 255 ); colors[4] = RGB( 255, 0, 255 ); 
	colors[5] = RGB( 0, 255, 255 ); colors[6] = RGB( 255, 255, 0 ); 
	colors[7] = RGB( 255, 255, 255 );
    }
 
    void draw( HDC dc )
    {
        HPEN pen;
	int lh = _mh / 4, row, cp;
	for( int lw = 1; lw < 5; lw++ )
	{
	    cp = 0;
            row = ( lw - 1 ) * lh;
	    for( int x = 0 + lw > 1 ? lw > 3 ? 2 : 1 : 0; x < _mw; x += lw )
	    {
		pen = CreatePen( PS_SOLID, lw, colors[cp] );
	        ++cp %= 8;
 
		SelectObject( dc, pen );
		MoveToEx( dc, x, row, NULL );
		LineTo( dc, x, row + lh );
		DeleteObject( pen );
	    }
	}
    }
 
private:
    int _mw, _mh;
    DWORD colors[8];
};
//--------------------------------------------------------------------------------------------------
pinstripe pin;
 
//--------------------------------------------------------------------------------------------------
void PaintWnd( HWND hWnd )
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint( hWnd, &ps );
    pin.draw( hdc );
    EndPaint( hWnd, &ps );
}
//--------------------------------------------------------------------------------------------------
LRESULT CALLBACK WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
	case WM_DESTROY: PostQuitMessage( 0 ); break;
	case WM_PAINT: PaintWnd( hWnd ); break;
	default:
	    return DefWindowProc( hWnd, msg, wParam, lParam );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
HWND InitAll( HINSTANCE hInstance )
{
    WNDCLASSEX wcex;
    ZeroMemory( &wcex, sizeof( wcex ) );
 
    wcex.cbSize	       = sizeof( WNDCLASSEX );
    wcex.style	       = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc   = WndProc;
    wcex.hInstance     = hInstance;
    wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
    wcex.lpszClassName = strv;
 
    RegisterClassEx( &wcex ); 
    return CreateWindow( strv, strv, WS_POPUP, CW_USEDEFAULT, 0, 200, 200, NULL, NULL, hInstance, NULL );
}
//--------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    srand( GetTickCount() );
 
    HWND hwnd = InitAll( hInstance );
    if( !hwnd ) return -1;
 
    int mw = GetSystemMetrics( SM_CXSCREEN ),
	mh = GetSystemMetrics( SM_CYSCREEN );
 
    pin.setDimensions( mw, mh );
 
    RECT rc = { 0, 0, mw, mh };
 
    AdjustWindowRectEx( &rc, WS_POPUP, FALSE, 0 );
    int w = rc.right  - rc.left, 
	h = rc.bottom - rc.top;
 
    int posX = ( GetSystemMetrics( SM_CXSCREEN ) >> 1 ) - ( w >> 1 ),
	posY = ( GetSystemMetrics( SM_CYSCREEN ) >> 1 ) - ( h >> 1 );
 
    SetWindowPos( hwnd, HWND_TOP, posX, posY, w, h, SWP_NOZORDER );
    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );
 
    MSG msg;
    ZeroMemory( &msg, sizeof( msg ) );
    while( msg.message != WM_QUIT )
    {
	if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
	{
	    TranslateMessage( &msg );
	    DispatchMessage( &msg );
	}
    }
    return UnregisterClass( strv, hInstance );
}
//--------------------------------------------------------------------------------------------------
 "
"#include <iostream>
 
template<class T>
void quibble(std::ostream& o, T i, T e) {
  o << strv;
  if (e != i) {
    T n = i++;
    const char* more = strv;
    while (e != i) {
      o << more << *n;
      more = strv;
      n = i++;
    }
    o << (*more?strv:strv) << *n;
  }
  o << strv;
}
 
int main(int argc, char** argv) {
  char const* a[] = {strv,strv,strv,strv};
  for (int i=0; i<5; i++) {
    quibble(std::cout, a, a+i);
    std::cout << std::endl;
  }
  return 0;
}"
"#ifndef MYWIDGET_H
#define MYWIDGET_H
#include <QWidget>
 
class QPaintEvent ;
 
class MyWidget : public QWidget {
public :
   MyWidget( ) ;
 
protected :
   void paintEvent( QPaintEvent * ) ;
private :
   int width ;
   int height ;
   const int colornumber ;
} ;
#endif#include <QtGui>
#include strv
 
MyWidget::MyWidget( ) :
   width( 640 ) ,
   height( 240 ) ,
   colornumber( 8 ) {
      setGeometry( 0, 0 , width , height ) ;
}
 
void MyWidget::paintEvent ( QPaintEvent * ) {
   int rgbtriplets[ ] = { 0 , 0 , 0 , 255 , 0 , 0 , 0 , 255 , 0 , 
      0 , 0 , 255 , 255 , 0 , 255 , 0 , 255 , 255 , 255 , 255 , 0 ,
      255 , 255 , 255 } ; 
   QPainter myPaint( this ) ;
   int rectwidth = width / colornumber ; //width of one rectangle
   int xstart = 1 ; //x coordinate of the first rectangle
   int offset = -1  ; //to allow for ++offset to define the red value even in the first run of the loop below
   for ( int i = 0 ; i < colornumber ; i++ ) {
      QColor rectColor ;
      rectColor.setRed( rgbtriplets[ ++offset ] ) ;
      rectColor.setGreen( rgbtriplets[ ++offset ] ) ;
      rectColor.setBlue( rgbtriplets[ ++offset ] ) ;
      myPaint.fillRect( xstart , 0 , rectwidth , height - 1 , rectColor ) ;
      xstart += rectwidth + 1 ;
   }
}#include <QApplication>
#include strv
 
int main( int argc, char * argv[ ] ) {
   QApplication app( argc , argv ) ;
   MyWidget window ;
   window.setWindowTitle( QApplication::translate( strv , strv ) ) ;
   window.show( ) ;
   return app.exec( ) ;
}"
"#include <algorithm>
#include <iostream>
#include <string>
 
void comb(int N, int K)
{
    std::string bitmask(K, 1); 

    bitmask.resize(N, 0); 

 
    

    do {
        for (int i = 0; i < N; ++i) 

        {
            if (bitmask[i]) std::cout << strv << i;
        }
        std::cout << std::endl;
    } while (std::prev_permutation(bitmask.begin(), bitmask.end()));
}
 
int main()
{
    comb(5, 3);
}"
"#include <iostream>
#include <functional>
#include <vector>
 
int main() {
  std::vector<std::function<int()> > funcs;
  for (int i = 0; i < 10; i++)
    funcs.push_back([=]() { return i * i; });
  for ( std::function<int( )> f : funcs ) 
    std::cout << f( ) << std::endl ; 
  return 0;
}"
"int a[5]; 

a[0] = 1; 

 
int primes[10] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; 

 
#include <string>
std::string strings[4]; 

                        
#include <vector>
 
std::vector<int> v;       

v.push_back(5);           

v.insert(v.begin(), 7);   
#include <deque>
 
std::deque<int> d;        

d.push_back(5);           

d.push_front(7);          

d.insert(v.begin()+1, 6); 
#include <list>
 
std::list<int> l;         

l.push_back(5);           

l.push_front(7);          

std::list::iterator i = l.begin();
++l;
l.insert(i, 6);           
#include <set>
 
std::set<int> s;          

s.insert(5);              

s.insert(7);              

s.insert(5);              
#include <multiset>
 
std::multiset<int> m;     

m.insert(5);              

m.insert(7);              

m.insert(5);              
"
"/*	Author: Kevin Bacon	Date: 04/03/2014	Task: Closest-pair problem*/
 
#include <iostream>
#include <vector>
#include <utility>
#include <cmath>
#include <random>
#include <chrono>
#include <algorithm>
#include <iterator>
 
typedef std::pair<double, double> point_t;
typedef std::pair<point_t, point_t> points_t;
 
double distance_between(const point_t& a, const point_t& b) {
	return std::sqrt(std::pow(b.first - a.first, 2)
		+ std::pow(b.second - a.second, 2));
}
 
std::pair<double, points_t> find_closest_brute(const std::vector<point_t>& points) {
	if (points.size() < 2) {
		return { -1, { { 0, 0 }, { 0, 0 } } };
	}
	auto minDistance = std::abs(distance_between(points.at(0), points.at(1)));
	points_t minPoints = { points.at(0), points.at(1) };
	for (auto i = std::begin(points); i != (std::end(points) - 1); ++i) {
		for (auto j = i + 1; j < std::end(points); ++j) {
			auto newDistance = std::abs(distance_between(*i, *j));
			if (newDistance < minDistance) {
				minDistance = newDistance;
				minPoints.first = *i;
				minPoints.second = *j;
			}
		}
	}
	return { minDistance, minPoints };
}
 
std::pair<double, points_t> find_closest_optimized(const std::vector<point_t>& xP,
	const std::vector<point_t>& yP) {
	if (xP.size() <= 3) {
		return find_closest_brute(xP);
	}
	auto N = xP.size();
	auto xL = std::vector<point_t>();
	auto xR = std::vector<point_t>();
	std::copy(std::begin(xP), std::begin(xP) + (N / 2), std::back_inserter(xL));
	std::copy(std::begin(xP) + (N / 2), std::end(xP), std::back_inserter(xR));
	auto xM = xP.at(N / 2).first;
	auto yL = std::vector<point_t>();
	auto yR = std::vector<point_t>();
	std::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {
		return p.first <= xM;
	});
	std::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {
		return p.first > xM;
	});
	auto p1 = find_closest_optimized(xL, yL);
	auto p2 = find_closest_optimized(xR, yR);
	auto minPair = (p1.first <= p2.first) ? p1 : p2;
	auto yS = std::vector<point_t>();
	std::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minPair, &xM](const point_t& p) {
		return std::abs(xM - p.first) < minPair.first;
	});
	auto result = minPair;
	for (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {
		for (auto k = i + 1; k != std::end(yS) &&
		 ((k->second - i->second) < minPair.first); ++k) {
			auto newDistance = std::abs(distance_between(*k, *i));
			if (newDistance < result.first) {
				result = { newDistance, { *k, *i } };
			}
		}
	}
	return result;
}
 
void print_point(const point_t& point) {
	std::cout << strv << point.first
		<< strv << point.second
		<< strv;
}
 
int main(int argc, char * argv[]) {
	std::default_random_engine re(std::chrono::system_clock::to_time_t(
		std::chrono::system_clock::now()));
	std::uniform_real_distribution<double> urd(-500.0, 500.0);
	std::vector<point_t> points(100);
	std::generate(std::begin(points), std::end(points), [&urd, &re]() {
                return point_t { 1000 + urd(re), 1000 + urd(re) };
        });
	auto answer = find_closest_brute(points);
	std::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {
		return a.first < b.first;
	});
	auto xP = points;
	std::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {
		return a.second < b.second;
	});
	auto yP = points;
	std::cout << strv << answer.first << strv;
	print_point(answer.second.first);
	std::cout << strv;
	print_point(answer.second.second);
	answer = find_closest_optimized(xP, yP);
	std::cout << ""Min distance (optimized): "" << answer.first << strv;
	print_point(answer.second.first);
	std::cout << strv;
	print_point(answer.second.second);
	return 0;
}"
" 
#include <iostream>
#include <cmath>
#include <tuple>
 
struct point { double x, y; };
 
bool operator==(const point& lhs, const point& rhs)
{ return std::tie(lhs.x, lhs.y) == std::tie(rhs.x, rhs.y); }
 
enum result_category { NONE, ONE_COINCEDENT, ONE_DIAMETER, TWO, INFINITE };
 
using result_t = std::tuple<result_category, point, point>;
 
double distance(point l, point r)
{ return std::hypot(l.x - r.x, l.y - r.y); }
 
result_t find_circles(point p1, point p2, double r)
{
    point ans1 { 1/0., 1/0.}, ans2 { 1/0., 1/0.};
    if (p1 == p2) {
        if(r == 0.) return std::make_tuple(ONE_COINCEDENT, p1,   p2  );
        else        return std::make_tuple(INFINITE,       ans1, ans2);
    }
    point center { p1.x/2 + p2.x/2, p1.y/2 + p2.y/2};
    double half_distance = distance(center, p1);
    if(half_distance > r)      return std::make_tuple(NONE,         ans1,   ans2);
    if(half_distance - r == 0) return std::make_tuple(ONE_DIAMETER, center, ans2);
    double root = std::hypot(r, half_distance) / distance(p1, p2);
    ans1.x = center.x + root * (p1.y - p2.y);
    ans1.y = center.y + root * (p2.x - p1.x);
    ans2.x = center.x - root * (p1.y - p2.y);
    ans2.y = center.y - root * (p2.x - p1.x);
    return std::make_tuple(TWO, ans1, ans2);
}
 
void print(result_t result, std::ostream& out = std::cout)
{
    point r1, r2; result_category res;
    std::tie(res, r1, r2) = result;
    switch(res) {
      case NONE:
        out << ""There are no solutions, points are too far away""; break;
      case ONE_COINCEDENT: case ONE_DIAMETER:
        out << strv << r1.x << ' ' << r1.y << ''; break;
      case INFINITE:
        out << ""Infinitely many circles can be drawn""; break;
      case TWO:
        out << strv << r1.x << ' ' << r1.y << strv << r2.x << ' ' << r2.y << ''; break;
    }
}
 
int main()
{
    constexpr int size = 5;
    const point points[size*2] = {
        {0.1234, 0.9876}, {0.8765, 0.2345}, {0.0000, 2.0000}, {0.0000, 0.0000},
        {0.1234, 0.9876}, {0.1234, 0.9876}, {0.1234, 0.9876}, {0.8765, 0.2345},
        {0.1234, 0.9876}, {0.1234, 0.9876}
    };
    const double radius[size] = {2., 1., 2., .5, 0.};
 
    for(int i = 0; i < size; ++i)
        print(find_circles(points[i*2], points[i*2 + 1], radius[i]));
}"
"class MyClass
{
public:
  void someMethod(); 

  MyClass(); 

private:
  int variable; 

};
 


MyClass::MyClass():
  variable(0)
{
  

}
 


void MyClass::someMethod()
{
  variable = 1; 

}
 


MyClass instance;
 


MyClass* pInstance = new MyClass;


delete pInstance;class MyClass
{
public:
  MyClass(): variable(0) {}
  void someMethod() { variable = 1; }
private:
  int variable;
};class MyClass
{
public:
  virtual void someMethod(); 

  virtual ~MyClass(); 

};"
"#include <iostream>
#include <chrono>
#include <atomic>
#include <mutex>
#include <random>
#include <thread>
 
std::mutex cout_lock;
 
class Latch
{
    std::atomic<int> semafor;
  public:
    Latch(int limit) : semafor(limit) {}
 
    void wait()
    {
        semafor.fetch_sub(1);
        while(semafor.load() > 0)
            std::this_thread::yield();
    }
};
 
struct Worker
{
    static void do_work(int how_long, Latch& barrier, std::string name)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(how_long));
        {   std::lock_guard<std::mutex> lock(cout_lock);
            std::cout << strv << name << "" finished work"";   }
        barrier.wait();
        {   std::lock_guard<std::mutex> lock(cout_lock);
            std::cout << strv << name << "" finished assembly"";   }
    }
};
 
int main()
{
    Latch latch(5);
    std::mt19937 rng(std::random_device{}());
    std::uniform_int_distribution<> dist(300, 3000);
    std::thread threads[] {
        std::thread(&Worker::do_work, dist(rng), std::ref(latch), strv),
        std::thread{&Worker::do_work, dist(rng), std::ref(latch), strv},
        std::thread{&Worker::do_work, dist(rng), std::ref(latch), strv},
        std::thread{&Worker::do_work, dist(rng), std::ref(latch), strv},
        std::thread{&Worker::do_work, dist(rng), std::ref(latch), strv},
    };
    for(auto& t: threads) t.join();
    std::cout << strv;
}"
" 
#include <iostream>
#include <iomanip>
#include <string>
#include <cmath>
#include <utility>
#include <vector>
 
using namespace std;
 
static const double PI = acos(-1.0);
 
double affine_remap(const pair<double, double>& from, double x, const pair<double, double>& to)
{
	return to.first + (x - from.first) * (to.second - to.first) / (from.second - from.first);
}
 
vector<double> cheb_coef(const vector<double>& f_vals)
{
	const int n = f_vals.size();
	const double theta = PI / n;
	vector<double> retval(n, 0.0);
	for (int ii = 0; ii < n; ++ii)
	{
		double f = f_vals[ii] * 2.0 / n;
		const double phi = (ii + 0.5) * theta;
		double c1 = cos(phi), s1 = sin(phi);
		double c = 1.0, s = 0.0;
		for (int j = 0; j < n; j++)
		{
			retval[j] += f * c;
			

			const double cNext = c * c1 - s * s1;
			s = c * s1 + s * c1;
			c = cNext;
		}
	}
	return retval;
}
 
template<class F_> vector<double> cheb_coef(const F_& func, int n, const pair<double, double>& domain)
{
	auto remap = [&](double x){return affine_remap({ -1.0, 1.0 }, x, domain); };
	const double theta = PI / n;
	vector<double> fVals(n);
	for (int ii = 0; ii < n; ++ii)
		fVals[ii] = func(remap(cos((ii + 0.5) * theta)));
	return cheb_coef(fVals);
}
 
double cheb_eval(const vector<double>& coef, double x)
{
	double a = 1.0, b = x, c;
	double retval = 0.5 * coef[0] + b * coef[1];
	for (auto pc = coef.begin() + 2; pc != coef.end(); a = b, b = c, ++pc)
	{
		c = 2.0 * b * x - a;
		retval += (*pc) * c;
	}
	return retval;
}
double cheb_eval(const vector<double>& coef, const pair<double, double>& domain, double x)
{
	return cheb_eval(coef, affine_remap(domain, x, { -1.0, 1.0 }));
}
 
struct ChebyshevApprox_
{
	vector<double> coeffs_;
	pair<double, double> domain_;
 
	double operator()(double x) const { return cheb_eval(coeffs_, domain_, x); }
 
	template<class F_> ChebyshevApprox_
		(const F_& func,
		int n,
		const pair<double, double>& domain)
		:
		coeffs_(cheb_coef(func, n, domain)),
		domain_(domain)
	{ }
};
 
 
int main(void)
{
	static const int N = 10;
	ChebyshevApprox_ fApprox(cos, N, { 0.0, 1.0 });
	cout << strv << setprecision(14);
	for (const auto& c : fApprox.coeffs_)
		cout << """" << c << """";
 
	for (;;)
	{
		cout << ""Enter x, or non-numeric value to quit:"";
		double x;
		if (!(cin >> x))
			return 0;
		cout << ""True value: "" << cos(x) << """";
		cout << ""Approximate: "" << fApprox(x) << """";
	}
}
 "
"#include strv
#include <string>
#include <iostream>
 
void testfile(std::string name)
{
  boost::filesystem::path file(name);
  if (exists(file))
  {
    if (is_directory(file))
      std::cout << name << "" is a directory."";
    else
      std::cout << name << "" is a non-directory file."";
  }
  else
    std::cout << name << "" does not exist."";
}
 
int main()
{
  testfile(strv);
  testfile(strv);
  testfile(strv);
  testfile(strv);
}"
" 
#include <windows.h>
#include <ctime>
#include <string>
#include <iostream>
 
const int BMP_SIZE = 600;
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
 
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
 
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
 
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    void saveBitmap( std::string path ) {
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
 
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
 
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
 
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC    hdc;
    HPEN    pen; HBRUSH brush;
    void    *pBits; int    width, height, wid;
    DWORD    clr;
};
class chaos {
public:
    void start() {
        POINT org;
        fillPts(); initialPoint( org ); initColors();
        int cnt = 0, i;
        bmp.create( BMP_SIZE, BMP_SIZE );
        bmp.clear( 255 );
 
        while( cnt++ < 1000000 ) {
            switch( rand() % 6 ) {
                case 0: case 3: i = 0; break;
                case 1: case 5: i = 1; break;
                case 2: case 4: i = 2;
            }
            setPoint( org, myPoints[i], i );
        }
        

        bmp.saveBitmap( strv );
    }
private:
    void setPoint( POINT &o, POINT v, int i ) {
        POINT z;
        o.x = ( o.x + v.x ) >> 1; o.y = ( o.y + v.y ) >> 1;
        SetPixel( bmp.getDC(), o.x, o.y, colors[i] );
    }
    void fillPts() {
        int a = BMP_SIZE - 1;
        myPoints[0].x = BMP_SIZE >> 1; myPoints[0].y = 0;
        myPoints[1].x = 0; myPoints[1].y = myPoints[2].x = myPoints[2].y = a;
    }
    void initialPoint( POINT& p ) {
        p.x = ( BMP_SIZE >> 1 ) + rand() % 2 ? rand() % 30 + 10 : -( rand() % 30 + 10 );
        p.y = ( BMP_SIZE >> 1 ) + rand() % 2 ? rand() % 30 + 10 : -( rand() % 30 + 10 );
    }
    void initColors() {
        colors[0] = RGB( 255, 0, 0 );
        colors[1] = RGB( 0, 255, 0 );
        colors[2] = RGB( 0, 0, 255 );
    }
 
    myBitmap bmp;
    POINT myPoints[3];
    COLORREF colors[3];
};
int main( int argc, char* argv[] ) {
    srand( ( unsigned )time( 0 ) );
    chaos c; c.start();
    return 0;
}
 "
"#include <iostream>
 
int main() {
  std::cout << (int)'a' << std::endl; 

  std::cout << (char)97 << std::endl; 

  return 0;
}"
"#include <iostream>
#include <numeric>
#include <functional>
#include <vector>
 
int main() {
	std::vector<int> nums = { 1, 2, 3, 4, 5 };
	auto nums_added = std::accumulate(std::begin(nums), std::end(nums), 0, std::plus<int>());
	auto nums_other = std::accumulate(std::begin(nums), std::end(nums), 0, [](const int& a, const int& b) {
		return a + 2 * b;
	});
	std::cout << strv << nums_added << std::endl;
	std::cout << strv << nums_other << std::endl;
}"
"

//


//
#include <iostream>
int main() {
  const int N = 15;
  int t[N+2] = {0,1};
  for(int i = 1; i<=N; i++){
    for(int j = i; j>1; j--) t[j] = t[j] + t[j-1];
    t[i+1] = t[i];
    for(int j = i+1; j>1; j--) t[j] = t[j] + t[j-1];
    std::cout << t[i+1] - t[i] << strv;
  }
  return 0;
}"
"

//


//
#include <iostream>
int main() {
	int Base = 10;
	const int N = 2;
	int c1 = 0;
	int c2 = 0;
	for (int k=1; k<pow((double)Base,N); k++){
		c1++;
		if (k%(Base-1) == (k*k)%(Base-1)){
			c2++;
			std::cout << k << strv;
		}
	}
	std::cout << ""Trying "" << c2 << strv << c1 << strv << 100 - ((double)c2/c1)*100 << strv <<std::endl;
	return 0;
}

//


//
#include <iostream>
#include <vector>
struct ran {
	const int base;
	std::vector<int> rs;
	ran(const int base) : base(base) { for (int nz=0; nz<base-1; nz++) if(nz*(nz-1)%(base-1) == 0) rs.push_back(nz); }
};
class co9 {
private:
	const ran* _ran;
	const int _end;
	int _r,_x,_next;
public:
	bool operator!=(const co9& other) const {return operator*() <= _end;}
	co9 begin() const {return *this;}
        co9 end() const {return *this;}
	int operator*() const {return _next;}
	co9(const int start, const int end, const ran* r)
	:_ran(r)
	,_end(end)
	,_r(1)
	,_x(start/_ran->base)
	,_next((_ran->base-1)*_x + _ran->rs[_r])
	{
		while (operator*() < start) operator++();
	}
	const co9& operator++() {
		const int oldr = _r;
		_r = ++_r%_ran->rs.size();
		if (_r<oldr) _x++;
		_next = (_ran->base-1)*_x + _ran->rs[_r];
		return *this;
	}
};
 
int main() {
	ran r(10);
	for (int i : co9(1,99,&r)) { std::cout << i << ' '; }
	return 0;
}struct ran {
	const int base;
	std::vector<int> rs;
	ran(const int base) : base(base) { for (int nz=0; nz<base-1; nz++) if(SumDigits(nz) == SumDigits(nz*nz)) rs.push_back(nz); }
};int main() {
	ran r(16);
	for (int i : co9(1,255,&r)) { std::cout << i << ' '; }
	return 0;
}int main() {
	ran r(17);
	for (int i : co9(1,288,&r)) { std::cout << i << ' '; }
	return 0;
}"
"#if !defined __ALGORITHMS_H__
#define __ALGORITHMS_H__
 
namespace rosetta
  {
  namespace catalanNumbers
    {
    namespace detail
      {
 
      class Factorial
        {
        public:
          unsigned long long operator()(unsigned n)const;
        };
 
      class BinomialCoefficient
        {
        public:
          unsigned long long operator()(unsigned n, unsigned k)const;
        };
 
      } //namespace detail
 
    class CatalanNumbersDirectFactorial
      {
      public:
        CatalanNumbersDirectFactorial();
        unsigned long long operator()(unsigned n)const;
      private:
        detail::Factorial factorial;
      };
 
    class CatalanNumbersDirectBinomialCoefficient
      {
      public:
        CatalanNumbersDirectBinomialCoefficient();
        unsigned long long operator()(unsigned n)const;
      private:
        detail::BinomialCoefficient binomialCoefficient;
      };
 
    class CatalanNumbersRecursiveSum
      {
      public:
        CatalanNumbersRecursiveSum();
        unsigned long long operator()(unsigned n)const;
      };
 
    class CatalanNumbersRecursiveFraction
      {
      public:
        CatalanNumbersRecursiveFraction();
        unsigned long long operator()(unsigned n)const;
      };
 
    }   //namespace catalanNumbers
  }     //namespace rosetta
 
#endif //!defined __ALGORITHMS_H__#include <iostream>
using std::cout;
using std::endl;
#include <cmath>
using std::floor;
 
#include strv
using namespace rosetta::catalanNumbers;
 
 
CatalanNumbersDirectFactorial::CatalanNumbersDirectFactorial()
  {
  cout<<strv<<endl;
  }
 
unsigned long long CatalanNumbersDirectFactorial::operator()(unsigned n)const
  {
  if(n>1)
    {
    unsigned long long nFac = factorial(n);
    return factorial(2 * n) / ((n + 1) * nFac * nFac);
    }
  else
    {
    return 1;
    }
  }
 
 
CatalanNumbersDirectBinomialCoefficient::CatalanNumbersDirectBinomialCoefficient()
  {
  cout<<strv<<endl;
  }
 
unsigned long long CatalanNumbersDirectBinomialCoefficient::operator()(unsigned n)const
  {
  if(n>1)
    return double(1) / (n + 1) * binomialCoefficient(2 * n, n);
  else
    return 1;
  }
 
 
CatalanNumbersRecursiveSum::CatalanNumbersRecursiveSum()
  {
  cout<<strv<<endl;
  }
 
unsigned long long CatalanNumbersRecursiveSum::operator()(unsigned n)const
  {
  if(n>1)
    {
    const unsigned n_ = n - 1;
    unsigned long long sum = 0;
    for(unsigned i = 0; i <= n_; i++)
      sum += operator()(i) * operator()(n_ - i);
    return sum;
    }
  else
    {
    return 1;
    }
  }
 
 
CatalanNumbersRecursiveFraction::CatalanNumbersRecursiveFraction()
  {
  cout<<strv<<endl;
  }
 
unsigned long long CatalanNumbersRecursiveFraction::operator()(unsigned n)const
  {
  if(n>1)
    return (double(2 * (2 * n - 1)) / (n + 1)) * operator()(n-1);
  else
    return 1;
  }
 
 
unsigned long long detail::Factorial::operator()(unsigned n)const
  {
  if(n>1)
    return n * operator()(n-1);
  else
    return 1;
  }
 
 
unsigned long long detail::BinomialCoefficient::operator()(unsigned n, unsigned k)const
  {
  if(k == 0)
    return 1;
 
  if(n == 0)
    return 0;
 
  double product = 1;
  for(unsigned i = 1; i <= k; i++)
    product *= (double(n - (k - i)) / i);
  return (unsigned long long)(floor(product + 0.5));
  }#if !defined __TESTER_H__
#define __TESTER_H__
 
#include <iostream>
 
namespace rosetta
  {
  namespace catalanNumbers
    {
 
    template <int N, typename A>
    class Test
      {
      public:
        static void Do()
          {
          A algorithm;
          for(int i = 0; i <= N; i++)
            std::cout<<strv<<i<<"")= ""<<algorithm(i)<<std::endl;
          }
      };
 
    } //namespace catalanNumbers
  }   //namespace rosetta
 
#endif //!defined __TESTER_H__#include strv
#include strv
using namespace rosetta::catalanNumbers;
 
int main(int argc, char* argv[])
  {
  Test<10, CatalanNumbersDirectFactorial>::Do();
  Test<15, CatalanNumbersDirectBinomialCoefficient>::Do();
  Test<15, CatalanNumbersRecursiveFraction>::Do();
  Test<15, CatalanNumbersRecursiveSum>::Do();
  return 0;
  }"
"#include <iostream>
#include <string>
using namespace std;
 
int main() {
    string dog = strv, Dog = strv, DOG = strv;
 
    cout << strv << dog << strv << Dog << strv << DOG << endl;
}"
" 
#include <time.h>
#include <algorithm>
#include <iostream>
#include <string>
#include <deque>
 
 
class riffle
{
public:
    void shuffle( std::deque<int>* v, int tm )
    {
        std::deque<int> tmp;
	bool fl;
	size_t len;
	std::deque<int>::iterator it;
 
	copyTo( v, &tmp );
 
	for( int t = 0; t < tm; t++ )
	{
	    std::deque<int> lHand( rand() % ( tmp.size() / 3 ) + ( tmp.size() >> 1 ) ), rHand( tmp.size() - lHand.size() );
 
	    std::copy( tmp.begin(), tmp.begin() + lHand.size(), lHand.begin() );
	    std::copy( tmp.begin() + lHand.size(), tmp.end(), rHand.begin() );
	    tmp.clear();
 
	    while( lHand.size() && rHand.size() )
	    {
		fl = rand() % 10 < 5;
		if( fl )
    		    len = 1 + lHand.size() > 3 ? rand() % 3 + 1 : rand() % ( lHand.size() ) + 1;
		else
		    len = 1 + rHand.size() > 3 ? rand() % 3 + 1 : rand() % ( rHand.size() ) + 1;
 
		while( len )
		{
		    if( fl ) 
		    {
			tmp.push_front( *lHand.begin() );
			lHand.erase( lHand.begin() );
		    }
		    else 
		    {
			tmp.push_front( *rHand.begin() );
			rHand.erase( rHand.begin() );
		    }
		    len--;
		}
	    }
 
	    if( lHand.size() < 1 ) 
	    {
		for( std::deque<int>::iterator x = rHand.begin(); x != rHand.end(); x++ )
		    tmp.push_front( *x );
	    }
	    if( rHand.size() < 1 ) 
	    {
		for( std::deque<int>::iterator x = lHand.begin(); x != lHand.end(); x++ )
		    tmp.push_front( *x );
	    }
	}
	copyTo( &tmp, v );
    }
private:
    void copyTo( std::deque<int>* a, std::deque<int>* b )
    {
	for( std::deque<int>::iterator x = a->begin(); x != a->end(); x++ )
	    b->push_back( *x );
	a->clear();
    }
};
 
class overhand
{
public:
    void shuffle( std::deque<int>* v, int tm )
    {
	std::deque<int> tmp;
	bool top;
	for( int t = 0; t < tm; t++ )
	{
	    while( v->size() )
	    {
		size_t len = rand() % ( v->size() ) + 1;
		top = rand() % 10 < 5;
		while( len )
		{
		    if( top ) tmp.push_back( *v->begin() );
		    else tmp.push_front( *v->begin() );
		    v->erase( v->begin() );
		    len--;
		}
	    }
	    for( std::deque<int>::iterator x = tmp.begin(); x != tmp.end(); x++ )
		v->push_back( *x );
 
	    tmp.clear();
	}
    }
};
 


std::deque<int> cards;
 
void fill()
{
    cards.clear();
    for( int x = 0; x < 20; x++ )
	cards.push_back( x + 1 );
}
 
void display( std::string t )
{
    std::cout << t << """";
    for( std::deque<int>::iterator x = cards.begin(); x != cards.end(); x++ )
	std::cout << *x << strv;
    std::cout << """";
}
 
int main( int argc, char* argv[] )
{
    srand( static_cast<unsigned>( time( NULL ) ) );
    riffle r; overhand o;	
 
    fill(); r.shuffle( &cards, 10 ); display( strv );
    fill(); o.shuffle( &cards, 10 ); display( strv );
    fill(); std::random_shuffle( cards.begin(), cards.end() ); display( strv );
 
    return 0;
}
 "
"

MyClass::method(someParameter);
 


myInstance.method(someParameter);"
"FUNCTION MULTIPLY(X, Y)
DOUBLE PRECISION MULTIPLY, X, Y#include <cstdlib>  // for C memory management
#include <string>   // for C++ strings
#include <iostream> // for output
 


extern strv char* strdup1(char const*);
 












extern strv double multiply_(double* x, double* y);
 




inline double multiply(double x, double y)
{
  return multiply_(&x, &y);
}
 
int main()
{
  std::string msg = strv;
 
  

  

  

  char* msg2 = strdup1(msg.c_str());
 
  

  

  std::cout << msg2;
 
  

  std::cout << multiply(3, 5) << std::endl;
 
  

  

  std::free(msg2);
}#include strv
#include <string.h>
 
OZ_BI_define(c_strdup,1,1)
{
  OZ_declareVirtualString(0, s1);
  char* s2 = strdup(s1);
  OZ_Term s3 = OZ_string(s2);
  free( s2 );
  OZ_RETURN( s3 );
}
OZ_BI_end
 
OZ_C_proc_interface * oz_init_module(void)
{
  static OZ_C_proc_interface table[] = {
    {strv,1,1,c_strdup},
    {0,0,0,0}
  };
  return table;
}"
" 
#include <windows.h>
#include <iostream>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
 
//--------------------------------------------------------------------------------------------------
class calender
{
public:
    void drawCalender( int y )
    {
	year = y;
	for( int i = 0; i < 12; i++ )
	    firstdays[i] = getfirstday( i );
 
	isleapyear();
	build();
    }
 
private:
    void isleapyear()
    {
	isleap = false;
 
	if( !( year % 4 ) )
	{
	    if( year % 100 ) isleap = true;
	    else if( !( year % 400 ) ) isleap = true;
	}
    }
 
    int getfirstday( int m )
    {
	int y = year;
 
	int f = y + 1 + 3 * m - 1;
	m++;
	if( m < 3 ) y--;
	else f -= int( .4 * m + 2.3 );
 
	f += int( y / 4 ) - int( ( y / 100 + 1 ) * 0.75 );
	f %= 7;
 
	return f;
    }
 
    void build()
    {
	int days[] = { 31, isleap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
	int lc = 0, lco = 0, ystr = 7, start = 2, fd = 0, m = 0;
	HANDLE h = GetStdHandle( STD_OUTPUT_HANDLE );
	COORD pos = { 0, ystr };
	draw();
 
	for( int i = 0; i < 4; i++ )
	{
	    for( int j = 0; j < 3; j++ )
	    {
		int d = firstdays[fd++], dm = days[m++];
		pos.X = d * 3 + start;
		SetConsoleCursorPosition( h, pos );
 
		for( int dd = 0; dd < dm; dd++ )
		{
		    if( dd < 9 ) cout << 0 << dd + 1 << strv;
		    else cout << dd + 1 << strv;
 
		    pos.X += 3;
		    if( pos.X - start > 20 )
		    {
			pos.X = start; pos.Y++;
			SetConsoleCursorPosition( h, pos );
		    }
		}
 
		start += 23;
		pos.X = start; pos.Y = ystr;
		SetConsoleCursorPosition( h, pos );
	    }
	    ystr += 9; start = 2;
	    pos.Y = ystr;
	}
    }
 
    void draw()
    {
	system( strv );
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << year << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
	cout << strv << endl;
    }
 
    int firstdays[12], year;
    bool isleap;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    int y;
    calender cal;
 
    while( true )
    {
	system( strv );
	cout << strv; 
	cin >> y;
	if( !y ) return 0;
 
	cal.drawCalender( y );
	cout << endl << endl << endl << endl << endl << endl << endl << endl;
 
	system( strv );
    }
    return 0;
}
//--------------------------------------------------------------------------------------------------
 "
"#include <string>
#include <iostream>
#include <algorithm>
#include <cctype>
 
class MyTransform {
private : 
   int shift ;
public :
   MyTransform( int s ) : shift( s ) { } 
 
  char operator( )( char c ) {
      if ( isspace( c ) ) 
	 return ' ' ;
      else {
	 static std::string letters( strv ) ;
	 std::string::size_type found = letters.find(tolower( c )) ;
	 int shiftedpos = ( static_cast<int>( found ) + shift ) % 26 ;
	 if ( shiftedpos < 0 ) //in case of decryption possibly
	    shiftedpos = 26 + shiftedpos ;
	 char shifted = letters[shiftedpos] ;
	 return shifted ;
      }
  }
} ;
 
int main( ) {
   std::string input ;
   std::cout << ""Which text is to be encrypted ?"" ;
   getline( std::cin , input ) ;
   std::cout << ""shift ?"" ;
   int myshift = 0 ;
   std::cin >> myshift ;
   std::cout << ""Before encryption:"" << input << std::endl ;
   std::transform ( input.begin( ) , input.end( ) , input.begin( ) ,
	 MyTransform( myshift ) ) ;
   std::cout << ""encrypted:"" ;
   std::cout << input << std::endl ;
   myshift *= -1 ; //decrypting again
   std::transform ( input.begin( ) , input.end( ) , input.begin( ) ,
	 MyTransform( myshift ) ) ;
   std::cout << ""Decrypted again:"" ;
   std::cout << input << std::endl ;
   return 0 ;
}"
" 
#include <iostream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <vector>
#include <time.h>
 
//--------------------------------------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------------------------------------
const unsigned int LEN = 4;
 
//--------------------------------------------------------------------------------------------------
class CowsAndBulls_Player
{
public:
    CowsAndBulls_Player() { fillPool(); }
    void play() { secret = createSecret(); guess(); }
 
private:
    void guess()
    {
	pair<int, int> res; int cc = 1;
	cout << endl << strv << secret << endl << strv << endl;
	cout << ""+-----------+---------+--------+|   GUESS   |  BULLS  |  COWS  |+-----------+---------+--------+"";
	while( true )
	{
	    string gs = gimmeANumber();
	    if( gs.empty() ) { cout << endl << strv << endl << strv << endl; return; }
	    if( scoreIt( gs, res ) ) { cout << endl << strv << endl << strv << gs << endl; return; }
	    cout << strv << gs << strv << setw( 3 ) << res.first << strv << setw( 3 ) << res.second << ""   |+-----------+---------+--------+"";
	    clearPool( gs, res );
        }
    }
 
    void clearPool( string gs, pair<int, int>& r )
    {
	vector<string>::iterator pi = pool.begin();
	while( pi != pool.end() )
	{
	    if( removeIt( gs, ( *pi ), r ) ) pi = pool.erase( pi );
	    else  pi++;
	}
    }
 
    string gimmeANumber()
    {
	if( pool.empty() ) return strv;
	return pool[rand() % pool.size()];
    }
 
    void fillPool()
    {
	for( int x = 1234; x < 9877; x++ )
	{
	    ostringstream oss; oss << x;
	    if( check( oss.str() ) ) pool.push_back( oss.str() );
	}
    }
 
    bool check( string s )
    {
	for( string::iterator si = s.begin(); si != s.end(); si++ )
	{
	    if( ( *si ) == '0' ) return false;
	    if( count( s.begin(), s.end(), ( *si ) ) > 1 ) return false;
	}
	return true;
    }
 
    bool removeIt( string gs, string ts, pair<int, int>& res )
    {
	pair<int, int> tp; getScore( gs, ts, tp );
	return tp != res;
    }
 
    bool scoreIt( string gs, pair<int, int>& res )
    {
	getScore( gs, secret, res );
	return res.first == LEN;
    }
 
    void getScore( string gs, string st, pair<int, int>& pr )
    {
	pr.first = pr.second = 0;
	for( unsigned int ui = 0; ui < LEN; ui++ )
	{
	    if( gs[ui] == st[ui] ) pr.first++;
	    else
	    {
		for( unsigned int vi = 0; vi < LEN; vi++ )
		    if( gs[ui] == st[vi] ) pr.second++;
	    }
	}
    }
 
    string createSecret()
    {
	string n = strv, rs = strv;
	while( rs.length() < LEN )
	{
	    int r = rand() % n.length();
	    rs += n[r]; n.erase( r, 1 );
	}
	return rs;
    }
 
    string secret;
    vector<string> pool;
};
//--------------------------------------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    srand( static_cast<unsigned int>( time( NULL ) ) ); CowsAndBulls_Player cb;
    cb.play(); cout << endl << endl;
    return system( strv );
}
//--------------------------------------------------------------------------------------------------
 "
"#include <windows.h>
#include <iostream>
#include <string>
 
//--------------------------------------------------------------------
using namespace std;
 
//--------------------------------------------------------------------
enum states { SEED, GROWING, MOVING, REST };
enum treeStates { NONE, MOVER, TREE };
const int MAX_SIDE = 480, MAX_MOVERS = 511, MAX_CELLS = 15137;
 
//--------------------------------------------------------------------
class point
{
public:
    point()                  { x = y = 0; }
    point( int a, int b )    { x = a; y = b; }
    void set( int a, int b ) { x = a; y = b; }
 
    int x, y;
};
//--------------------------------------------------------------------
class movers
{
public:
    point pos;
    bool moving;
    movers() : moving( false ){}
};
//--------------------------------------------------------------------
class myBitmap
{
public:
    myBitmap() : pen( NULL ) {}
    ~myBitmap()
    {
	DeleteObject( pen );
	DeleteDC( hdc );
	DeleteObject( bmp );
    }
 
    bool create( int w, int h )
    {
	BITMAPINFO	bi;
	ZeroMemory( &bi, sizeof( bi ) );
 
	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biPlanes	   = 1;
	bi.bmiHeader.biWidth	   =  w;
	bi.bmiHeader.biHeight	   = -h;
 
	HDC dc = GetDC( GetConsoleWindow() );
	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
	if( !bmp ) return false;
 
	hdc = CreateCompatibleDC( dc );
	SelectObject( hdc, bmp );
	ReleaseDC( GetConsoleWindow(), dc ); 
 
	width = w; height = h;
 
	return true;
    }
 
    void clear()
    {
	ZeroMemory( pBits, width * height * sizeof( DWORD ) );
    }
 
    void setPenColor( DWORD clr )
    {
	if( pen ) DeleteObject( pen );
	pen = CreatePen( PS_SOLID, 1, clr );
	SelectObject( hdc, pen );
    }
 
    void saveBitmap( string path )
    {
	BITMAPFILEHEADER fileheader;
	BITMAPINFO	 infoheader;
	BITMAP		 bitmap;
	DWORD*		 dwpBits;
	DWORD		 wb;
	HANDLE		 file;
 
	GetObject( bmp, sizeof( bitmap ), &bitmap );
 
	dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
 
	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
	infoheader.bmiHeader.biHeight = bitmap.bmHeight;
	infoheader.bmiHeader.biWidth = bitmap.bmWidth;
	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
 
	fileheader.bfType    = 0x4D42;
	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
 
	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
 
	file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL,
                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
	CloseHandle( file );
 
	delete [] dwpBits;
    }
 
    HDC getDC()     { return hdc; }
    int getWidth()  { return width; }
    int getHeight() { return height; }
 
private:
    HBITMAP bmp;
    HDC	    hdc;
    HPEN    pen;
    void    *pBits;
    int	    width, height;
};
//--------------------------------------------------------------------
class brownianTree
{
public:
    brownianTree()         
    { 
	_bmp.create( MAX_SIDE, MAX_SIDE );
	init(); 
    }
 
    void init()
    {
	_cellCount = 0;
	ZeroMemory( _grid, sizeof( _grid ) );
	_bmp.clear();
	_state = SEED;
    }
 
bool mainLoop()
    {
	switch( _state )
	{
	    case REST:    saveTree(); return false;
	    case SEED:    doSeed(); break;
	    case GROWING: startMovers(); break;
	    case MOVING:  moveMovers();
	}
	    return true;
	}
 
    myBitmap* getBmp() { return &_bmp; }
 
private:
    void saveTree()
    {
	for( int y = 0; y < MAX_SIDE; y++ )
	    for( int x = 0; x < MAX_SIDE; x++ )
		if( _grid[x][y] == TREE )
		    SetPixel( _bmp.getDC(), x, y, RGB( 255, 120, 0 ) );
 
        _bmp.saveBitmap( ""f:rctree.bmp"" );
    }
 
    void doSeed()
    {
	int x = MAX_SIDE - MAX_SIDE / 2, y = MAX_SIDE / 4;
	_grid[rand() % x + y][rand() % x + y] = TREE;
	_cellCount++;
	_state = GROWING;
    }
 
    void addMover( movers* m )
    {
	m->moving = true;
	int x = MAX_SIDE - MAX_SIDE / 2, y = MAX_SIDE / 4, a, b;
	while( true )
	{
	    a = rand() % x + y; b = rand() % x + y;
	    if( _grid[a][b] == NONE ) break;
	}
 
	m->pos.set( a, b );
	_grid[a][b] = MOVER;
    }
 
    void startMovers()
    {
	movers* m;
	for( int c = 0; c < MAX_MOVERS; c++ )
	{
	    m = &_movers[c];
	    addMover( m );
	}
	_state = MOVING;
    }
 
    void addToTree( movers* m )
    {
	m->moving = false;
	_grid[m->pos.x][m->pos.y] = TREE;
	if( ++_cellCount >= MAX_CELLS ) _state = REST;
 
	COORD c = { 0, 1 };
	SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), c );
	cout << strv << _cellCount
             << strv << MAX_CELLS << strv
             <<  static_cast<float>( 100 * _cellCount ) /
                 static_cast<float>( MAX_CELLS )
             << strv;
    }
 
    bool moveIt( movers* m )
    {
	point f[8]; int ff = 0;
	for( int y = -1; y < 2; y++ )
	{
	    for( int x = -1; x < 2; x++ )
	    {
		if( !x && !y ) continue;
		int a = m->pos.x + x, b = m->pos.y + y;
		if( a < 0 || b < 0 || a >= MAX_SIDE || b >= MAX_SIDE )
		{
		    addToTree( m );
		    return true;
		}
		switch( _grid[a][b] )
		{
		    case TREE:
			addToTree( m );
			return true;
		    case NONE:
			f[ff++].set( a, b );
		}
	    }
        }
 
	if( ff < 1 ) return false;
 
	_grid[m->pos.x][m->pos.y] = NONE;
	m->pos = f[rand() % ff];
	_grid[m->pos.x][m->pos.y] = MOVER;
 
	return false;
    }
 
    void moveMovers()
    {
	movers* mm;
	for( int m = 0; m < MAX_MOVERS; m++ )
	{
	    mm = &_movers[m];
	    if( !mm->moving ) continue;
	    if( moveIt( mm ) && _cellCount < MAX_CELLS ) addMover( mm );
	}
    }
 
    states   _state;
    BYTE     _grid[MAX_SIDE][MAX_SIDE];
    myBitmap _bmp;
    int      _cellCount;
    movers   _movers[MAX_MOVERS];
};
//--------------------------------------------------------------------
int main( int argc, char* argv[] )
{
    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );
    srand( GetTickCount() );
 
    brownianTree tree;
 
    DWORD now = GetTickCount();
    while( tree.mainLoop() );
 
    now = GetTickCount() - now;
    cout << endl << endl << strv
         << now / 1000
         << strv << endl << endl;
 
    BitBlt( GetDC( GetConsoleWindow() ), 20, 90, MAX_SIDE, MAX_SIDE,
            tree.getBmp()->getDC(), 0, 0, SRCCOPY );
 
    system( strv );
    return 0;
}
//--------------------------------------------------------------------"
"#include <iostream>
 
class CWidget; 

 
class CFactory
{
  friend class CWidget;
private:
  unsigned int m_uiCount;
public:
  CFactory();
  ~CFactory();
  CWidget* GetWidget();
};
 
class CWidget
{
private:
  CFactory& m_parent;
 
private:
  CWidget(); 

  CWidget(const CWidget&); 

  CWidget& operator=(const CWidget&); 

public:
  CWidget(CFactory& parent);
  ~CWidget();
};
 


CFactory::CFactory() : m_uiCount(0) {}
CFactory::~CFactory() {}
 


CWidget* CFactory::GetWidget()
{
  

  return new CWidget(*this);
}
 


CWidget::CWidget(CFactory& parent) : m_parent(parent)
{
  ++m_parent.m_uiCount;
 
  std::cout << strv << m_parent.m_uiCount << strv << std::endl;
}
 
CWidget::~CWidget()
{
  --m_parent.m_uiCount;
 
  std::cout << strv << m_parent.m_uiCount << strv << std::endl;
}
 
int main()
{
  CFactory factory;
 
  CWidget* pWidget1 = factory.GetWidget();
  CWidget* pWidget2 = factory.GetWidget();
  delete pWidget1;
 
  CWidget* pWidget3 = factory.GetWidget();
  delete pWidget3;
  delete pWidget2;
}#include <iostream>
 
class CWidget; 

 
class CFactory
{
private:
  unsigned int m_uiCount;
public:
  CFactory();
  ~CFactory();
  CWidget* GetWidget();
};
 
class CWidget
{
private:
  unsigned int* m_pCounter;
 
private:
  CWidget(); 

  CWidget(const CWidget&); 

  CWidget& operator=(const CWidget&); 

public:
  CWidget(unsigned int* pCounter);
  ~CWidget();
};
 


CFactory::CFactory() : m_uiCount(0) {}
CFactory::~CFactory() {}
 


CWidget* CFactory::GetWidget()
{
  

  return new CWidget(&m_uiCount);
}
 


CWidget::CWidget(unsigned int* pCounter) : m_pCounter(pCounter)
{
  ++*m_pCounter;
 
  std::cout << strv << *m_pCounter<< strv << std::endl;
}
 
CWidget::~CWidget()
{
  --*m_pCounter;
 
  std::cout << strv << *m_pCounter<< strv << std::endl;
}
 
int main()
{
  CFactory factory;
 
  CWidget* pWidget1 = factory.GetWidget();
  CWidget* pWidget2 = factory.GetWidget();
  delete pWidget1;
 
  CWidget* pWidget3 = factory.GetWidget();
  delete pWidget3;
  delete pWidget2;
}"
"#include <iostream>
#include <iterator>
#include <string>
#include <utility>
#include <vector>
 
namespace detail {
 
template <typename ForwardIterator>
class tokenizer
{
 
	ForwardIterator _tbegin, _tend, _end;
 
public:
 
	tokenizer(ForwardIterator begin, ForwardIterator end)
		: _tbegin(begin), _tend(begin), _end(end)
	{ }
 
	template <typename Lambda>
	bool next(Lambda istoken)
	{
		if (_tbegin == _end) {
			return false;
		}
		_tbegin = _tend;
		for (; _tend != _end && !istoken(*_tend); ++_tend) {
			if (*_tend == '' && std::next(_tend) != _end) {
				++_tend;
			}
		}
		if (_tend == _tbegin) {
			_tend++;
		}
		return _tbegin != _end;
	}
 
	ForwardIterator begin() const { return _tbegin; }
	ForwardIterator end()   const { return _tend; }
	bool operator==(char c) { return *_tbegin == c; }
 
};
 
template <typename List>
void append_all(List & lista, const List & listb)
{
	if (listb.size() == 1) {
		for (auto & a : lista) {
			a += listb.back();
		}
	} else {
		List tmp;
		for (auto & a : lista) {
			for (auto & b : listb) {
				tmp.push_back(a + b);
			}
		}
		lista = std::move(tmp);
	}
}
 
template <typename String, typename List, typename Tokenizer>
List expand(Tokenizer & token)
{
 
	std::vector<List> alts{ { String() } };
 
	while (token.next([](char c) { return c == '{' || c == ',' || c == '}'; })) {
 
		if (token == '{') {
			append_all(alts.back(), expand<String, List>(token));
		} else if (token == ',') {
			alts.push_back({ String() });
		} else if (token == '}') {
			if (alts.size() == 1) {
				for (auto & a : alts.back()) {
					a = '{' + a + '}';
				}
				return alts.back();
			} else {
				for (std::size_t i = 1; i < alts.size(); i++) {
					alts.front().insert(alts.front().end(),
						std::make_move_iterator(std::begin(alts[i])),
						std::make_move_iterator(std::end(alts[i])));
				}
				return std::move(alts.front());
			}
		} else {
			for (auto & a : alts.back()) {
				a.append(token.begin(), token.end());
			}
		}
 
	}
 
	List result{ String{ '{' } };
	append_all(result, alts.front());
	for (std::size_t i = 1; i < alts.size(); i++) {
		for (auto & a : result) {
			a += ',';
		}
		append_all(result, alts[i]);
	}
	return result;
}
 
} 

 
template <
	typename ForwardIterator,
	typename String = std::basic_string<
		typename std::iterator_traits<ForwardIterator>::value_type
	>,
	typename List = std::vector<String>
>
List expand(ForwardIterator begin, ForwardIterator end)
{
	detail::tokenizer<ForwardIterator> token(begin, end);
	List list{ String() };
	while (token.next([](char c) { return c == '{'; })) {
		if (token == '{') {
			detail::append_all(list, detail::expand<String, List>(token));
		} else {
			for (auto & a : list) {
				a.append(token.begin(), token.end());
			}
		}
	}
	return list;
}
 
template <
	typename Range,
	typename String = std::basic_string<typename Range::value_type>,
	typename List = std::vector<String>
>
List expand(const Range & range)
{
	using Iterator = typename Range::const_iterator;
	return expand<Iterator, String, List>(std::begin(range), std::end(range));
}
 
int main()
{
 
	for (std::string string : {
		Rstrv,
		Rstrv,
		Rstrv,
		R""({}} some {{edge,edgy} }{ cases, here\})"",
		Rstrv,
		Rstrv,
		Rstrv,
		Rstrv,
		Rstrv,
		Rstrv,
		Rstrv,
		Rstrv,
		Rstrv,
		Rstrv,
		R""({}} some }{,{{ edge, edge} \,}{ cases, {here} \})"",
		Rstrv,
	}) {
		std::cout << string << '';
		for (auto expansion : expand(string)) {
			std::cout << strv << expansion << '';
		}
		std::cout << '';
	}
 
	return 0;
}"
"#include <string>
#include <boost/array.hpp>
#include <boost/assign/list_of.hpp>
#include <boost/format.hpp>
#include <boost/foreach.hpp>
#include <iostream>
#include <math.h>
using std::string;
using namespace boost::assign;
 
int get_Index(float angle)
{
   return static_cast<int>(floor(angle / 11.25 +0.5 )) % 32 + 1;
}
 
string get_Abbr_From_Index(int i)
{
    static boost::array<std::string, 32> points(list_of
            (strv)(strv)(strv)(strv)(strv)(strv)(strv)(strv)
            (strv)(strv)(strv)(strv)(strv)(strv)(strv)(strv)
            (strv)(strv)(strv)(strv)(strv)(strv)(strv)(strv)
            (strv)(strv)(strv)(strv)(strv)(strv)(strv)(strv));
    return points[i-1];
}
 
string Build_Name_From_Abbreviation(string a)
{
    string retval;
    for (int i = 0; i < a.size(); ++i){
        if ((1 == i) && (a[i] != 'b') && (a.size() == 3)) retval += strv;
        switch (a[i]){
            case 'N' : retval += strv; break; 
            case 'S' : retval += strv; break; 
            case 'E' : retval += strv;  break; 
            case 'W' : retval += strv;  break; 
            case 'b' : retval += strv;  break;
        }
    }
    retval[0] = toupper(retval[0]);
    return retval;
}
 
int main()
{
    boost::array<float,33> headings(list_of
            (0.0)(16.87)(16.88)(33.75)(50.62)(50.63)(67.5)(84.37)(84.38)(101.25)
            (118.12)(118.13)(135.0)(151.87)(151.88)(168.75)(185.62)(185.63)(202.5)
            (219.37)(219.38)(236.25)(253.12)(253.13)(270.0)(286.87)(286.88)(303.75)
            (320.62)(320.63)(337.5)(354.37)(354.38));
    int i;
    boost::format f(strv);
 
    BOOST_FOREACH(float a, headings)
    {
        i = get_Index(a);
        std::cout << f % i %  Build_Name_From_Abbreviation(get_Abbr_From_Index(i)) % a << std::endl;
    }
    return 0;
}"
"#include <iostream>
#include <string>
#include <algorithm>
#include <cstdlib>
 
bool contains_duplicates(std::string s)
{
  std::sort(s.begin(), s.end());
  return std::adjacent_find(s.begin(), s.end()) != s.end();
}
 
void game()
{
  typedef std::string::size_type index;
 
  std::string symbols = strv;
  unsigned int const selection_length = 4;
 
  std::random_shuffle(symbols.begin(), symbols.end());
  std::string selection = symbols.substr(0, selection_length);
  std::string guess;
  while (std::cout << strv, std::getline(std::cin, guess))
  {
    if (guess.length() != selection_length
        || guess.find_first_not_of(symbols) != std::string::npos
        || contains_duplicates(guess))
    {
      std::cout << guess << strv;
      continue;
    }
 
    unsigned int bulls = 0;
    unsigned int cows = 0;
    for (index i = 0; i != selection_length; ++i)
    {
      index pos = selection.find(guess[i]);
      if (pos == i)
        ++bulls;
      else if (pos != std::string::npos)
        ++cows;
    }
    std::cout << bulls << strv << cows << "" cows."";
    if (bulls == selection_length)
    {
      std::cout << ""Congratulations! You have won!"";
      return;
    }
  }
  std::cerr << ""Oops! Something went wrong with input, or you've entered end-of-file!Exiting ..."";
  std::exit(EXIT_FAILURE);
}
 
int main()
{
  std::cout << ""Welcome to bulls and cows!Do you want to play? "";
  std::string answer;
  while (true)
  {
    while (true)
    {
      if (!std::getline(std::cin, answer))
      {
        std::cout << ""I can't get an answer. Exiting."";
        return EXIT_FAILURE;
      }
      if (answer == strv || answer == strv || answer == strv || answer == strv)
        break;
      if (answer == strv || answer == strv || answer == strv || answer == strv)
      {
        std::cout << ""Ok. Goodbye."";
        return EXIT_SUCCESS;
      }
      std::cout << strv;
    }
    game(); 
    std::cout << strv;
  }
}"
"#include <iostream>
 
void bitwise(int a, int b)
{
  std::cout << strv << (a & b)  << ''; 

  std::cout << strv << (a | b)  << '';
  std::cout << strv << (a ^ b)  << '';
  std::cout << strv << ~a       << '';
  std::cout << strv << (a << b) << ''; 

  std::cout << strv << (a >> b) << ''; 

  unsigned int c = a;
  std::cout << strv << (c >> b) << ''; 

  

}"
"#ifndef PROCESSING_FLOODFILLALGORITHM_H_
#define PROCESSING_FLOODFILLALGORITHM_H_
 
#include <opencv2/opencv.hpp>
#include <string.h>
#include <queue>
 
using namespace cv;
using namespace std;
 
class FloodFillAlgorithm {
public:
    FloodFillAlgorithm(Mat* image) :
        image(image) {
    }
    virtual ~FloodFillAlgorithm();
 
    void flood(Point startPoint, Scalar tgtColor, Scalar loDiff);
    void flood(Point startPoint, Mat* tgtMat);
 
protected:
    Mat* image;
private:
    bool insideImage(Point p);
};
 
#endif /* PROCESSING_FLOODFILLALGORITHM_H_ */
 #include strv
 
FloodFillAlgorithm::~FloodFillAlgorithm() {
}
 
void FloodFillAlgorithm::flood(Point startPoint, Scalar tgtColor, Scalar loDiff) {
    floodFill(*image, startPoint, tgtColor, 0, loDiff);
}
 
void FloodFillAlgorithm::flood(Point startPoint, Mat* tgtMat) {
    if (!insideImage(startPoint))
        return;
 
    Vec3b srcColor = image->at<Vec3b>(startPoint);
 
    if (image->at<Vec3b>(startPoint) == srcColor) {
 
        queue<Point> pointQueue;
	pointQueue.push(startPoint);
 
	while (!pointQueue.empty()) {
	    Point p = pointQueue.front();
	    pointQueue.pop();
 
	    if (insideImage(p)) {
 
		if ((image->at<Vec3b>(p) == srcColor)) {
		    image->at<Vec3b>(p) = tgtMat->at<Vec3b>(p);
 
		    pointQueue.push(Point(p.x + 1, p.y));
		    pointQueue.push(Point(p.x - 1, p.y));
		    pointQueue.push(Point(p.x, p.y + 1));
		    pointQueue.push(Point(p.x, p.y - 1));
		}
	    }
 
	}
    }
}
 
bool FloodFillAlgorithm::insideImage(Point p) {
    return (p.x >= 0) && (p.x < image->size().width) && (p.y >= 0) && (p.y < image->size().height);
}
 
 "
" 
void Line( const float x1, const float y1, const float x2, const float y2, const Color& color )
{
        

  const bool steep = (fabs(y2 - y1) > fabs(x2 - x1));
  if(steep)
  {
    std::swap(x1, y1);
    std::swap(x2, y2);
  }
 
  if(x1 > x2)
  {
    std::swap(x1, x2);
    std::swap(y1, y2);
  }
 
  const float dx = x2 - x1;
  const float dy = fabs(y2 - y1);
 
  float error = dx / 2.0f;
  const int ystep = (y1 < y2) ? 1 : -1;
  int y = (int)y1;
 
  const int maxX = (int)x2;
 
  for(int x=(int)x1; x<maxX; x++)
  {
    if(steep)
    {
        SetPixel(y,x, color);
    }
    else
    {
        SetPixel(x,y, color);
    }
 
    error -= dy;
    if(error < 0)
    {
        y += ystep;
        error += dx;
    }
  }
}
 "
"template <class T>
int binsearch(const T array[], int len, T what)
{
  if (len == 0) return -1;
  int mid = len / 2;
  if (array[mid] == what) return mid;
  if (array[mid] < what) {
    int result = binsearch(array+mid+1, len-(mid+1), what);
    if (result == -1) return -1;
    else return result + mid+1;
  }
  if (array[mid] > what)
    return binsearch(array, mid, what);
}
 
#include <iostream>
int main()
{
  int array[] = {2, 3, 5, 6, 8};
  int result1 = binsearch(array, sizeof(array)/sizeof(int), 4),
      result2 = binsearch(array, sizeof(array)/sizeof(int), 8);
  if (result1 == -1) std::cout << strv << std::endl;
  else std::cout << strv << result1 << std::endl;
  if (result2 == -1) std::cout << strv << std::endl;
  else std::cout << strv << result2 << std::endl;
 
  return 0;
}template <class T>
int binSearch(const T arr[], int len, T what) {
  int low = 0;
  int high = len - 1;
  while (low <= high) {
    int mid = (low + high) / 2;
    if (arr[mid] > what)
      high = mid - 1;
    else if (arr[mid] < what)
      low = mid + 1;
    else
      return mid;
  }
  return -1; 

}#include <algorithm>int *ptr = std::lower_bound(array, array+len, what); 
int *ptr = std::upper_bound(array, array+len, what); 
std::pair<int *, int *> bounds = std::equal_range(array, array+len, what); 
bool found = std::binary_search(array, array+len, what); 
"
"#include <iostream>
#include <boost/gil/gil_all.hpp>
int main()
{
    using namespace boost::gil;
    

    rgb8_image_t img(30, 40);
 
    

    rgb8_pixel_t red(255, 0, 0);
    fill_pixels(view(img), red);
 
    

    rgb8_pixel_t blue(0, 0, 255);
    view(img)(10, 20) = blue;
 
    

    rgb8_pixel_t px = const_view(img)(11, 20);
    std::cout << strv << (unsigned)px[0] << ':' << (unsigned)px[1] << ':' << (unsigned)px[2]  << '';
}"
"#include <bitset>
#include <iostream>
#include <limits>
#include <string>
 
void print_bin(unsigned int n) {
  std::string str = strv;
 
  if (n > 0) {
    str = std::bitset<std::numeric_limits<unsigned int>::digits>(n).to_string();
    str = str.substr(str.find('1')); 

  } 
 
  std::cout << str << '';
}
 
int main() {
  print_bin(0);
  print_bin(5);
  print_bin(50);
  print_bin(9000);
} 
 #include <iostream>
#include <bitset>
void printBits(int n) {                     

  int iExp = 0;                             

  while (n >> iExp) ++iExp;                 

  for (int at = iExp - 1; at >= 0; at--)    

    std::cout << std::bitset<32>(n)[at];    

  std::cout << '';
}
int main(int argc, char* argv[]) {
  printBits(5);
  printBits(50);
  printBits(9000);
} 
#include <iostream>
int main(int argc, char* argv[]) {
  unsigned int in[] = {5, 50, 9000};        

  for (int i = 0; i < 3; i++)               

    for (int at = 31; at >= 0; at--)        

      if (int b = (in[i] >> at))            

         std::cout << ('0' + b & 1) << (!at ? """": strv);	

}
 #include <iostream>
int main(int argc, char* argv[]) {                        

  for (int i = 1; i < argc; i++)                          

    for (int at = 31; at >= 0; at--)                      

      if (int b = (atoi(argv[i]) >> at))                  

         std::cout << ('0' + b & 1) << (!at ? """": strv);  

}
  
#include <iostream>
 
std::string binary(int n) {
  return n == 0 ? strv : binary(n >> 1) + std::to_string(n & 1);
}
 
int main(int argc, char* argv[]) {
  for (int i = 1; i < argc; ++i) {
    std::cout << binary(std::stoi(argv[i])) << std::endl;
  }
}
 "
"//to cope with the big numbers , I used the Class Library for Numbers( CLN ) 
//if used prepackaged you can compile writing strv
#include <cln/integer.h>
#include <cln/integer_io.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <sstream>
#include <string>
#include <cstdlib>
#include <cmath>
#include <map>
using namespace cln ;
 
class NextNum {
public :
   NextNum ( cl_I & a , cl_I & b ) : first( a ) , second ( b ) { }
   cl_I operator( )( ) {
      cl_I result = first + second ;
      first = second ;
      second = result ;
      return result ;
   }
private :
   cl_I first ;
   cl_I second ;
} ;
 
void findFrequencies( const std::vector<cl_I> & fibos , std::map<int , int> &numberfrequencies  ) {
   for ( cl_I bignumber : fibos ) {
      std::ostringstream os ;
      fprintdecimal ( os , bignumber ) ;//from header file cln/integer_io.h
      int firstdigit = std::atoi( os.str( ).substr( 0 , 1 ).c_str( )) ;
      auto result = numberfrequencies.insert( std::make_pair( firstdigit , 1 ) ) ;
      if ( ! result.second ) 
	 numberfrequencies[ firstdigit ]++ ;
   }
}
 
int main( ) {
   std::vector<cl_I> fibonaccis( 1000 ) ;
   fibonaccis[ 0 ] = 0 ;
   fibonaccis[ 1 ] = 1 ;
   cl_I a = 0 ;
   cl_I b = 1 ;
   //since a and b are passed as references to the generator's constructor
   //they are constantly changed !
   std::generate_n( fibonaccis.begin( ) + 2 , 998 , NextNum( a , b ) ) ;
   std::cout << std::endl ;
   std::map<int , int> frequencies ;
   findFrequencies( fibonaccis , frequencies ) ;
   std::cout << ""                found                    expected"" ;
   for ( int i = 1 ; i < 10 ; i++ ) {
      double found = static_cast<double>( frequencies[ i ] ) / 1000 ;
      double expected = std::log10( 1 + 1 / static_cast<double>( i )) ;
      std::cout << i << strv << std::setw( 16 ) << std::right << found * 100 << strv ;
      std::cout.precision( 3 ) ;
      std::cout << std::setw( 26 ) << std::right << expected * 100 << "" %"" ;
   }
   return 0 ;
}
 "
" 
#include <iostream>
#include <fstream>
#include <vector>
 
typedef unsigned char byte;
using namespace std;
 
const unsigned m1 = 63 << 18, m2 = 63 << 12, m3 = 63 << 6;
 
class base64
{
public:
    base64() { char_set = strv; }
    string encode( vector<byte> v )
    {
	string res;
	unsigned d, a = 0, l = static_cast<unsigned>( v.size() );
	while( l > 2 )
	{
	    d = v[a++] << 16 | v[a++] << 8 | v[a++];	
	    res.append( 1, char_set.at( ( d & m1 ) >> 18 ) );	
	    res.append( 1, char_set.at( ( d & m2 ) >> 12 ) );	
	    res.append( 1, char_set.at( ( d & m3 ) >>  6 ) );
	    res.append( 1, char_set.at( d & 63 ) );
	    l -= 3;
	}
	if( l == 2 )
	{
	    d = v[a++] << 16 | v[a++] << 8;
	    res.append( 1, char_set.at( ( d & m1 ) >> 18 ) );	
	    res.append( 1, char_set.at( ( d & m2 ) >> 12 ) );	
	    res.append( 1, char_set.at( ( d & m3 ) >>  6 ) );
	    res.append( 1, '=' );
	}
	else if( l == 1 )
	{
	    d = v[a++] << 16;
	    res.append( 1, char_set.at( ( d & m1 ) >> 18 ) );	
	    res.append( 1, char_set.at( ( d & m2 ) >> 12 ) );	
	    res.append( strv, 2 );
	}
	return res;
    }
 
private:
    string char_set;
};
 
int main( int argc, char* argv[] )
{
    base64 b;
    basic_ifstream<byte> f( strv, ios::binary );
    string r = b.encode( vector<byte>( ( istreambuf_iterator<byte>( f ) ), istreambuf_iterator<byte>() ) );
    copy( r.begin(), r.end(), ostream_iterator<char>( cout ) );
    return 0;
}
 "
"#include <iostream>
#include <sstream>
#include <algorithm>
 
using namespace std;
 
template <class S>
class BestShuffle {
public:
    BestShuffle() : rd(), g(rd()) {}
 
    S operator()(const S& s1) {
        S s2 = s1;
        shuffle(s2.begin(), s2.end(), g);
        for (unsigned i = 0; i < s2.length(); i++)
            if (s2[i] == s1[i])
                for (unsigned j = 0; j < s2.length(); j++)
                    if (s2[i] != s2[j] && s2[i] != s1[j] && s2[j] != s1[i]) {
                        swap(s2[i], s2[j]);
                        break;
                    }
        ostringstream os;
        os << s1 << endl << s2 << strv << count(s2, s1) << ']';
        return os.str();
    }
 
private:
    static int count(const S& s1, const S& s2) {
        auto count = 0;
        for (unsigned i = 0; i < s1.length(); i++)
            if (s1[i] == s2[i])
                count++;
        return count;
    }
 
    random_device rd;
    mt19937 g;
};
 
int main(int argc, char* arguments[]) {
    BestShuffle<basic_string<char>> bs;
    for (auto i = 1; i < argc; i++)
        cout << bs(basic_string<char>(arguments[i])) << endl;
    return 0;
}"
" 
#include <windows.h>
#include <ctime>
#include <string>
 
const int BMP_SIZE = 600, ITERATIONS = static_cast<int>( 15e5 );
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    void saveBitmap( std::string path ) {
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
            FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC    hdc;
    HPEN    pen; HBRUSH brush;
    void    *pBits; int    width, height, wid;
    DWORD    clr;
};
class fern {
public:
    void draw() {
        bmp.create( BMP_SIZE, BMP_SIZE );
        float x = 0, y = 0; HDC dc = bmp.getDC();
        int hs = BMP_SIZE >> 1;
        for( int f = 0; f < ITERATIONS; f++ ) {
            SetPixel( dc, hs + static_cast<int>( x * 55.f ), 
                      BMP_SIZE - 15 - static_cast<int>( y * 55.f ), 
                      RGB( static_cast<int>( rnd() * 80.f ) + 20, 
                           static_cast<int>( rnd() * 128.f ) + 128, 
                           static_cast<int>( rnd() * 80.f ) + 30 ) ); 
            getXY( x, y );
        }
        bmp.saveBitmap( strv );
    }
private:
    void getXY( float& x, float& y ) {
        float g, xl, yl;
        g = rnd();
        if( g < .01f ) { xl = 0; yl = .16f * y; } 
        else if( g < .07f ) {
            xl = .2f * x - .26f * y;
            yl = .23f * x + .22f * y + 1.6f;
        } else if( g < .14f ) {
            xl = -.15f * x + .28f * y;
            yl = .26f * x + .24f * y + .44f;
        } else {
            xl = .85f * x + .04f * y;
            yl = -.04f * x + .85f * y + 1.6f;
        }
        x = xl; y = yl;
    }
    float rnd() {
        return static_cast<float>( rand() ) / static_cast<float>( RAND_MAX );
    }
    myBitmap bmp;
};
int main( int argc, char* argv[]) {
    srand( static_cast<unsigned>( time( 0 ) ) );
    fern f; f.draw(); return 0;    
}
 "
" 
#include <iostream>
#include <string>
#include <climits>
using namespace std;
 
class BalancedTernary {
protected:
	

	string value;
 
	

	int charToInt(char c) const {
		if (c == '0')
			return 0;
		return 44 - c;
	}
 
	

	string negate(string s) const {
		for (int i = 0; i < s.length(); ++i) {
			if (s[i] == '+')
				s[i] = '-';
			else if (s[i] == '-')
				s[i] = '+';
		}
		return s;
	}
 
public:
	

	BalancedTernary() {
		value = strv;
	}
 
	

	BalancedTernary(string s) {
		value = string(s.rbegin(), s.rend());
	}
 
	

	BalancedTernary(long long n) {
		if (n == 0) {
			value = strv;
			return;
		}
 
		bool neg = n < 0;
		if (neg) 
			n = -n;
 
		value = strv;
		while (n != 0) {
			int r = n % 3;
			if (r == 0)
				value += strv;
			else if (r == 1)
				value += strv;
			else {
				value += strv;
				++n;
			}
 
			n /= 3;
		}
 
		if (neg)
			value = negate(value);
	}
 
	

	BalancedTernary(const BalancedTernary &n) {
		value = n.value;
	}
 
	

	BalancedTernary operator+(BalancedTernary n) const {
		n += *this;
		return n;
	}
 
	BalancedTernary& operator+=(const BalancedTernary &n) {
		static char *add = strv;
		static char *carry = strv;
 
		int lastNonZero = 0;
		char c = '0';
		for (int i = 0; i < value.length() || i < n.value.length(); ++i) {
			char a = i < value.length() ? value[i] : '0';
			char b = i < n.value.length() ? n.value[i] : '0';
 
			int sum = charToInt(a) + charToInt(b) + charToInt(c) + 3;
			c = carry[sum];
 
			if (i < value.length())
				value[i] = add[sum];
			else
				value += add[sum];
 
			if (add[sum] != '0')
				lastNonZero = i;
		}
 
		if (c != '0')
			value += c;
		else
			value = value.substr(0, lastNonZero + 1); 

 
		return *this;
	}
 
	

	BalancedTernary operator-() const {
		BalancedTernary result;
		result.value = negate(value);
		return result;
	}
 
	

	BalancedTernary operator-(const BalancedTernary &n) const {
		return operator+(-n);
	}
 
	BalancedTernary& operator-=(const BalancedTernary &n) {
		return operator+=(-n);
	}
 
	

	BalancedTernary operator*(BalancedTernary n) const {
		n *= *this;
		return n;
	}
 
	BalancedTernary& operator*=(const BalancedTernary &n) {
		BalancedTernary pos = *this;
		BalancedTernary neg = -pos; 

		value = strv;
 
		for (int i = 0; i < n.value.length(); ++i) {
			if (n.value[i] == '+')
				operator+=(pos);
			else if (n.value[i] == '-')
				operator+=(neg);
			pos.value = '0' + pos.value;
			neg.value = '0' + neg.value;
		}
 
		return *this;
	}
 
	

	friend ostream& operator<<(ostream &out, const BalancedTernary &n) {
		out << n.toString();
		return out;
	}
 
	

	string toString() const {
		return string(value.rbegin(), value.rend());
	}
 
	

	long long toInt() const {
		long long result = 0;
		for (long long i = 0, pow = 1; i < value.length(); ++i, pow *= 3)
			result += pow * charToInt(value[i]);
		return result;
	}
 
	

	bool tryInt(long long &out) const {
		long long result = 0;
		bool ok = true;
 
		for (long long i = 0, pow = 1; i < value.length() && ok; ++i, pow *= 3) {
			if (value[i] == '+') {
				ok &= LLONG_MAX - pow >= result; 

				result += pow;
			} else if (value[i] == '-') {
				ok &= LLONG_MIN + pow <= result; 

				result -= pow;
			}
		}
 
		if (ok)
			out = result;
		return ok;
	}
};
 
int main() {
	BalancedTernary a(strv);
	BalancedTernary b(-436);
	BalancedTernary c(strv);
 
	cout << strv << a << strv << a.toInt() << endl;
	cout << strv << b << strv << b.toInt() << endl;
	cout << strv << c << strv << c.toInt() << endl;
 
	BalancedTernary d = a * (b - c);
 
	cout << strv << d << strv << d.toInt() << endl;
 
	BalancedTernary e(strv);
 
	long long n;
	if (e.tryInt(n))
		cout << strv << e << strv << n << endl;
	else
		cout << strv << e << strv << endl;
 
	return 0;
}
 "
"#include <iostream>
 
int main( ) {
   int current = 0 ;
   while ( ( current * current ) % 1000000 != 269696 ) 
      current++ ;
   std::cout << strv << current << strv << (current * current) << "" !"" ;
   return 0 ;
}"
" 
#include <iostream>
#include <algorithm>
#include <vector>
#include <bitset>
#include <string>
 
class bacon {
public:
    bacon() {
        int x = 0;
        for( ; x < 9; x++ )
            bAlphabet.push_back( std::bitset<5>( x ).to_string() );
        bAlphabet.push_back( bAlphabet.back() );
 
        for( ; x < 20; x++ )
            bAlphabet.push_back( std::bitset<5>( x ).to_string() );
        bAlphabet.push_back( bAlphabet.back() );
 
        for( ; x < 24; x++ )
            bAlphabet.push_back( std::bitset<5>( x ).to_string() );
    }
 
    std::string encode( std::string txt ) {
        std::string r;
        size_t z;
        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {
            z = toupper( *i );
            if( z < 'A' || z > 'Z' ) continue;
            r.append( bAlphabet.at( ( *i & 31 ) - 1 ) );
        }
        return r;
    }
 
    std::string decode( std::string txt ) {
        size_t len = txt.length();
        while( len % 5 != 0 ) len--;
        if( len != txt.length() ) txt = txt.substr( 0, len );
        std::string r;
        for( size_t i = 0; i < len; i += 5 ) {
            r.append( 1, 'A' + std::distance( bAlphabet.begin(), std::find( bAlphabet.begin(), bAlphabet.end(), txt.substr( i, 5 ) ) ) );
        }
        return r;
    }
 
private:
    std::vector<std::string> bAlphabet;
};
  
class cipherI {
public:
    std::string encode( std::string txt ) {
        txt = b.encode( txt );
        std::string e, d = strv
        strv
        strv;
        size_t r = 0; 
        char t;
        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {
            t = d.at( r );
            while( t < 'a' || t > 'z' ) {
                e.append( 1, t );
                r++;
                t = d.at( r );
            }
            r++;
            e.append( 1, *i == '1' ? t - 32 : t );
        }
 
        return e;
    }
 
    std::string decode( std::string txt ) {
        std::string h;
        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {
            if( *i < 'a' && ( *i < 'A' || *i > 'Z' ) || *i > 'z' ) continue;
            h.append( 1, *i & 32 ? '0' : '1' );
        }
        return b.decode( h );
    }
 
private:
    bacon b;
};
 
class cipherII {
public:
    std::string encode( std::string txt ) {
        txt = b.encode( txt );
        std::string e;
        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ )
            e.append( 1, *i == '0' ? 0xf9 : 0xfa );
        return e;
    }
 
    std::string decode( std::string txt ) {
        std::string h;
        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {
            h.append( 1, *i == ( char )0xf9 ? '0' : '1' );
        }
        return b.decode( h );
    }
 
private:
    bacon b;
};
 
int main( int argc, char* argv[] ) {
    cipherI c1;
    cipherII c2;
    std::string s = strv;
 
    std::string h1 = c1.encode( s ),
                h2 = c2.encode( s );
 
    std::cout << h1 << std::endl << std::endl << c1.decode( h1 ) << std::endl << std::endl;
    std::cout << h2 << std::endl << std::endl << c2.decode( h2 ) << std::endl << std::endl;
 
    return 0;
}
 "
" 
#include <algorithm>
#include <iostream>
 
/* AVL node */
template <class T>
class AVLnode {
public:
    T key;
    int balance;
    AVLnode *left, *right, *parent;
 
    AVLnode(T k, AVLnode *p) : key(k), balance(0), parent(p),
                        left(NULL), right(NULL) {}
 
    ~AVLnode() {
        delete left;
        delete right;
    }
};
 
/* AVL tree */
template <class T>
class AVLtree {
public:
    AVLtree(void);
    ~AVLtree(void);
    bool insert(T key);
    void deleteKey(const T key);
    void printBalance();
 
private:
    AVLnode<T> *root;
 
    AVLnode<T>* rotateLeft          ( AVLnode<T> *a );
    AVLnode<T>* rotateRight         ( AVLnode<T> *a );
    AVLnode<T>* rotateLeftThenRight ( AVLnode<T> *n );
    AVLnode<T>* rotateRightThenLeft ( AVLnode<T> *n );
    void rebalance                  ( AVLnode<T> *n );
    int height                      ( AVLnode<T> *n );
    void setBalance                 ( AVLnode<T> *n );
    void printBalance               ( AVLnode<T> *n );
    void clearNode                  ( AVLnode<T> *n );
};
 
/* AVL class definition */
template <class T>
void AVLtree<T>::rebalance(AVLnode<T> *n) {
    setBalance(n);
 
    if (n->balance == -2) {
        if (height(n->left->left) >= height(n->left->right))
            n = rotateRight(n);
        else
            n = rotateLeftThenRight(n);
    }
    else if (n->balance == 2) {
        if (height(n->right->right) >= height(n->right->left))
            n = rotateLeft(n);
        else
            n = rotateRightThenLeft(n);
    }
 
    if (n->parent != NULL) {
        rebalance(n->parent);
    }
    else {
        root = n;
    }
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateLeft(AVLnode<T> *a) {
    AVLnode<T> *b = a->right;
    b->parent = a->parent;
    a->right = b->left;
 
    if (a->right != NULL)
        a->right->parent = a;
 
    b->left = a;
    a->parent = b;
 
    if (b->parent != NULL) {
        if (b->parent->right == a) {
            b->parent->right = b;
        }
        else {
            b->parent->left = b;
        }
    }
 
    setBalance(a);
    setBalance(b);
    return b;
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateRight(AVLnode<T> *a) {
    AVLnode<T> *b = a->left;
    b->parent = a->parent;
    a->left = b->right;
 
    if (a->left != NULL)
        a->left->parent = a;
 
    b->right = a;
    a->parent = b;
 
    if (b->parent != NULL) {
        if (b->parent->right == a) {
            b->parent->right = b;
        }
        else {
            b->parent->left = b;
        }
    }
 
    setBalance(a);
    setBalance(b);
    return b;
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateLeftThenRight(AVLnode<T> *n) {
    n->left = rotateLeft(n->left);
    return rotateRight(n);
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateRightThenLeft(AVLnode<T> *n) {
    n->right = rotateRight(n->right);
    return rotateLeft(n);
}
 
template <class T>
int AVLtree<T>::height(AVLnode<T> *n) {
    if (n == NULL)
        return -1;
    return 1 + std::max(height(n->left), height(n->right));
}
 
template <class T>
void AVLtree<T>::setBalance(AVLnode<T> *n) {
    n->balance = height(n->right) - height(n->left);
}
 
template <class T>
void AVLtree<T>::printBalance(AVLnode<T> *n) {
    if (n != NULL) {
        printBalance(n->left);
        std::cout << n->balance << strv;
        printBalance(n->right);
    }
}
 
template <class T>
AVLtree<T>::AVLtree(void) : root(NULL) {}
 
template <class T>
AVLtree<T>::~AVLtree(void) {
    delete root;
}
 
template <class T>
bool AVLtree<T>::insert(T key) {
    if (root == NULL) {
        root = new AVLnode<T>(key, NULL);
    }
    else {
        AVLnode<T>
            *n = root,
            *parent;
 
        while (true) {
            if (n->key == key)
                return false;
 
            parent = n;
 
            bool goLeft = n->key > key;
            n = goLeft ? n->left : n->right;
 
            if (n == NULL) {
                if (goLeft) {
                    parent->left = new AVLnode<T>(key, parent);
                }
                else {
                    parent->right = new AVLnode<T>(key, parent);
                }
 
                rebalance(parent);
                break;
            }
        }
    }
 
    return true;
}
 
template <class T>
void AVLtree<T>::deleteKey(const T delKey) {
    if (root == NULL)
        return;
 
    AVLnode<T>
        *n       = root,
        *parent  = root,
        *delNode = NULL,
        *child   = root;
 
    while (child != NULL) {
        parent = n;
        n = child;
        child = delKey >= n->key ? n->right : n->left;
        if (delKey == n->key)
            delNode = n;
    }
 
    if (delNode != NULL) {
        delNode->key = n->key;
 
        child = n->left != NULL ? n->left : n->right;
 
        if (root->key == delKey) {
            root = child;
        }
        else {
            if (parent->left == n) {
                parent->left = child;
            }
            else {
                parent->right = child;
            }
 
            rebalance(parent);
        }
    }
}
 
template <class T>
void AVLtree<T>::printBalance() {
    printBalance(root);
    std::cout << std::endl;
}
 
int main(void)
{
    AVLtree<int> t;
 
    std::cout << strv << std::endl;
    for (int i = 1; i <= 10; ++i)
        t.insert(i);
 
    std::cout << strv;
    t.printBalance();
}
 "
"#include <iostream>
#include <vector>
#include <cmath>
#include <numeric>
 
int main( ) {
  std::vector<int> numbers ;
  for ( int i = 1 ; i < 11 ; i++ )
    numbers.push_back( i ) ;
  double meansquare = sqrt( ( std::inner_product( numbers.begin(), numbers.end(), numbers.begin(), 0 ) ) / static_cast<double>( numbers.size() ) );
  std::cout << strv << numbers.size() << strv << meansquare << "" !"" ;
  return 0 ;
}"
" 
#include <iostream>
#include <stddef.h>
#include <assert.h>
 
using std::cout;
using std::endl;
 
class SMA {
public:
	SMA(unsigned int period) :
		period(period), window(new double[period]), head(NULL), tail(NULL),
				total(0) {
		assert(period >= 1);
	}
	~SMA() {
		delete[] window;
	}
 
	

	void add(double val) {
		

		if (head == NULL) {
			head = window;
			*head = val;
			tail = head;
			inc(tail);
			total = val;
			return;
		}
 
		

		if (head == tail) {
			

			total -= *head;
			

			inc(head);
		}
 
		

		*tail = val;
		inc(tail);
 
		

		total += val;
	}
 
	

	

	double avg() const {
		ptrdiff_t size = this->size();
		if (size == 0) {
			return 0; 

		}
		return total / (double) size; 

	}
 
private:
	unsigned int period;
	double * window; 

 
	

	double * head; 

	double * tail; 

 
	double total; 

 
	

	

	void inc(double * & p) {
		if (++p >= window + period) {
			p = window;
		}
	}
 
	

	ptrdiff_t size() const {
		if (head == NULL)
			return 0;
		if (head == tail)
			return period;
		return (period + tail - head) % period;
	}
};
 
int main(int argc, char * * argv) {
	SMA foo(3);
	SMA bar(5);
 
	int data[] = { 1, 2, 3, 4, 5, 5, 4, 3, 2, 1 };
	for (int * itr = data; itr < data + 10; itr++) {
		foo.add(*itr);
		cout << strv << *itr << strv << foo.avg() << endl;
	}
	cout << endl;
	for (int * itr = data; itr < data + 10; itr++) {
		bar.add(*itr);
		cout << strv << *itr << strv << bar.avg() << endl;
	}
 
	return 0;
}
 "
"#include <algorithm>
#include <iostream>
#include <string>
 
std::string generate(int n, char left = '[', char right = ']')
{
    std::string str(std::string(n, left) + std::string(n, right));
    std::random_shuffle(str.begin(), str.end());
    return str;
}
 
bool balanced(const std::string &str, char left = '[', char right = ']')
{
    int count = 0;
    for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)
    {
        if (*it == left)
            count++;
        else if (*it == right)
            if (--count < 0) return false;
    }
    return count == 0;
}
 
int main()
{
    srand(time(NULL)); 

    for (int i = 0; i < 9; ++i)
    {
        std::string s(generate(i));
        std::cout << (balanced(s) ? strv : strv) << s << """";
    }
}"
"#include <vector>
#include <iostream>
#include <numeric>
#include <cmath>
#include <algorithm>
 
double toInverse ( int i ) {
   return  1.0 / i  ;
}
 
int main( ) {
   std::vector<int> numbers ;
   for ( int i = 1 ; i < 11 ; i++ ) 
      numbers.push_back( i ) ;
   double arithmetic_mean = std::accumulate( numbers.begin( ) , numbers.end( ) , 0 ) / 10.0 ;
   double geometric_mean =
      pow( std::accumulate( numbers.begin( ) , numbers.end( ) , 1 , std::multiplies<int>( ) ), 0.1 ) ;
   std::vector<double> inverses ;
   inverses.resize( numbers.size( ) ) ;
   std::transform( numbers.begin( ) , numbers.end( ) , inverses.begin( ) , toInverse ) ;  
   double harmonic_mean = 10 / std::accumulate( inverses.begin( ) , inverses.end( ) , 0.0 ); //initial value of accumulate must be a double!
   std::cout << strv << arithmetic_mean << strv 
      << geometric_mean << strv << harmonic_mean << "" !"" ;
   return 0 ;
}"
"#include <algorithm>
#include <array>
#include <chrono>
#include <iomanip>
#include <iostream>
#include <mutex>
#include <random>
#include <thread>
 
using namespace std;
 
constexpr int bucket_count = 15;
 
void equalizer(array<int, bucket_count>& buckets,
               array<mutex, bucket_count>& bucket_mutex) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);
 
    while (true) {
        int from = dist_bucket(gen);
        int to = dist_bucket(gen);
        if (from != to) {
            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);
            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);
            int diff = buckets[from] - buckets[to];
            int amount = abs(diff / 2);
            if (diff < 0) {
                swap(from, to);
            }
            buckets[from] -= amount;
            buckets[to] += amount;
        }
    }
}
 
void randomizer(array<int, bucket_count>& buckets,
                array<mutex, bucket_count>& bucket_mutex) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);
 
    while (true) {
        int from = dist_bucket(gen);
        int to = dist_bucket(gen);
        if (from != to) {
            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);
            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);
            uniform_int_distribution<> dist_amount(0, buckets[from]);
            int amount = dist_amount(gen);
            buckets[from] -= amount;
            buckets[to] += amount;
        }
    }
}
 
void print_buckets(const array<int, bucket_count>& buckets) {
    int total = 0;
    for (const int& bucket : buckets) {
        total += bucket;
        cout << setw(3) << bucket << ' ';
    }
    cout << strv << setw(3) << total << endl;
}
 
int main() {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dist(0, 99);
 
    array<int, bucket_count> buckets;
    array<mutex, bucket_count> bucket_mutex;
    for (int& bucket : buckets) {
        bucket = dist(gen);
    }
    print_buckets(buckets);
 
    thread t_eq(equalizer, ref(buckets), ref(bucket_mutex));
    thread t_rd(randomizer, ref(buckets), ref(bucket_mutex));
 
    while (true) {
        this_thread::sleep_for(chrono::seconds(1));
        for (mutex& mutex : bucket_mutex) {
            mutex.lock();
        }
        print_buckets(buckets);
        for (mutex& mutex : bucket_mutex) {
            mutex.unlock();
        }
    }
    return 0;
}"
"#include <algorithm>
 




template <typename Iterator>
double median(Iterator begin, Iterator end) {
  

  Iterator middle = begin + (end - begin) / 2;
 
  

  std::nth_element(begin, middle, end);
 
  if ((end - begin) % 2 != 0) { 

    return *middle;
  } else { 

    

    Iterator lower_middle = std::max_element(begin, middle);
    return (*middle + *lower_middle) / 2.0;
  }
}
 
#include <iostream>
 
int main() {
  double a[] = {4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2};
  double b[] = {4.1, 7.2, 1.7, 9.3, 4.4, 3.2};
 
  std::cout << median(a+0, a + sizeof(a)/sizeof(a[0])) << std::endl; 

  std::cout << median(b+0, b + sizeof(b)/sizeof(b[0])) << std::endl; 

 
  return 0;
}"
"#include <iterator>
#include <utility>
#include <algorithm>
#include <list>
#include <iostream>
 


template<typename T> struct referring
{
  referring(T const& t): value(t) {}
  template<typename Iter>
   bool operator()(std::pair<Iter, int> const& p) const
  {
    return *p.first == value;
  }
  T const& value;
};
 
















template<typename FwdIterator, typename OutIterator>
 void mode(FwdIterator first, FwdIterator last, OutIterator result)
{
  typedef typename std::iterator_traits<FwdIterator>::value_type value_type;
  typedef std::list<std::pair<FwdIterator, int> > count_type;
  typedef typename count_type::iterator count_iterator;
 
  

  count_type counts;
 
  while (first != last)
  {
    count_iterator element = std::find_if(counts.begin(), counts.end(),
                                          referring<value_type>(*first));
    if (element == counts.end())
      counts.push_back(std::make_pair(first, 1));
    else
      ++element->second;
    ++first;
  }
 
  

  int max = 0;
  for (count_iterator i = counts.begin(); i != counts.end(); ++i)
    if (i->second > max)
      max = i->second;
 
  

  for (count_iterator i = counts.begin(); i != counts.end(); ++i)
    if (i->second == max)
      *result++ = *i->first;
}
 


int main()
{
  int values[] = { 1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6 };
  median(values, values + sizeof(values)/sizeof(int),
         std::ostream_iterator<int>(std::cout, strv));
  std::cout << std::endl;
  return 0;
}"
"#include <cassert> // assert.h also works
 
int main()
{
  int a;
  

 
  assert(a == 42); 

                    

}"
"#include <map>std::map<A, B> exampleMapstd::map<int, double> exampleMapexampleMap[7] = 3.14int myKey = 7;
double myValue = 3.14;
exampleMap[myKey] = myValue;exampleMap.insert(std::pair<int, double>(7,3.14));exampleMap.insert(std::make_pair(7,3.14));myValue = exampleMap[myKey]double myValue = 0.0;
std::map<int, double>::iterator myIterator = exampleMap.find(myKey);
if(exampleMap.end() != myIterator)
{
  

  myValue = myIterator->second;
}#include <map>
#include <iostreams>
 
int main()
{
  

  std::map<int, double> exampleMap;
 
  

  int myKey = 7;
 
  

  double myValue = 3.14;
 
  

  exampleMap[myKey] = myValue;
 
  

  double myRetrievedValue = exampleMap[myKey];
 
  

  std::cout << myRetrievedValue << std::endl;
 
  

  return 0;
}"
"#include <iostream>
#include <map>
#include <string>
 
int main() {
  std::map<std::string, int> dict {
    {strv, 1},
    {strv, 2},
    {strv, 7}
  };
 
  dict[strv] = 3;
 
  std::cout << strv << dict[strv] << std::endl;
  std::cout << strv << std::endl;
  for(auto& kv: dict) {
    std::cout << strv << kv.first << strv << kv.second << std::endl;
  }
 
  return 0;
}std::map<std::string, int> myDict;
myDict[strv] = 1;
myDict[strv] = 2;
myDict[strv] = 3;
 


for (std::map<std::string, int>::iterator it = myDict.begin(); it != myDict.end(); ++it) {
    

    const std::string& key = it->first;
    int& value = it->second;
    std::cout << strv << key << strv << value << std::endl;
}"
"#include <vector>
 
double mean(const std::vector<double>& numbers)
{
     if (numbers.size() == 0)
          return 0;
 
     double sum = 0;
     for (std::vector<double>::iterator i = numbers.begin(); i != numbers.end(); i++)
          sum += *i;
     return sum / numbers.size();
}#include <vector>
#include <algorithm>
 
double mean(const std::vector<double>& numbers)
{
    if (numbers.empty())
        return 0;
    return std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();
}#include <iterator>
#include <algorithm>
 
template <typename Iterator>
double mean(Iterator begin, Iterator end)
{
    if (begin == end)
        return 0;
    return std::accumulate(begin, end, 0.0) / std::distance(begin, end);
}"
" 
#include <array>
#include <iostream>
#include <string>
 
int main() 
{
    std::array<std::string, 2> fruit { strv, strv };
    std::cout << fruit.size();
    return 0;
}
  
    std::vector<std::string> fruitV({ strv, strv });
    std::list<std::string> fruitL({ strv, strv });
    std::deque<std::string> fruitD({ strv, strv });
    std::cout << fruitV.size() << fruitL.size() << fruitD.size() << std::endl;
 "
"#include <array>
#include <vector>
 


#include <algorithm>
#include <iostream>
#include <iterator>
#include <string>
 


template <typename Array>
void demonstrate(Array& array)
{
  

  array[2] = strv;  

                       

  array.at(1) = strv; 

                       

 
  

  std::reverse(begin(array), end(array));
  std::for_each(begin(array), end(array),
    [](typename Array::value_type const& element) 

    {
      std::cout << element << ' ';
    });
 
  std::cout << '';
}
 
int main()
{
  

  auto fixed_size_array = std::array<std::string, 3>{ strv, strv, strv };
  

 
  

  auto dynamic_array = std::vector<std::string>{ strv, strv };
  dynamic_array.push_back(strv); 

 
  

  demonstrate(fixed_size_array);
  demonstrate(dynamic_array);
}"
"#include <vector>
#include <iostream>
 
int main()
{
  std::vector<int> a(3), b(4);
  a[0] = 11; a[1] = 12; a[2] = 13;
  b[0] = 21; b[1] = 22; b[2] = 23; b[3] = 24;
 
  a.insert(a.end(), b.begin(), b.end());
 
  for (int i = 0; i < a.size(); ++i)
    std::cout << strv << i << strv << a[i] << """";
}#include <vector>                                                                                                       
#include <iostream>
 
int main() {
  std::vector<int> a {1, 2, 3, 4};
  std::vector<int> b {5, 6, 7, 8, 9};
 
  a.insert(a.end(), b.begin(), b.end());
 
  for(int& i: a) std::cout << i << strv;
  std::cout << std::endl;
  return 0;
}"
"#include <iostream>
 
int main()
{
  int a, b;
  std::cin >> a >> b;
  std::cout << strv << a+b << """";
  std::cout << strv << a-b << """";
  std::cout << strv << a*b << """";
  std::cout << strv << a/b << strv << a%b << """";
  return 0;
}"
"#include <iostream>
#include <complex>
using std::complex;
 
void complex_operations() {
  complex<double> a(1.0, 1.0);
  complex<double> b(3.14159, 1.25);
 
  

  std::cout << a + b << std::endl;
  

  std::cout << a * b << std::endl;
  

  std::cout << 1.0 / a << std::endl;
  

  std::cout << -a << std::endl;
  

  std::cout << std::conj(a) << std::endl;
}"
" 
#include <gmpxx.h>
 
void agm(mpf_class& rop1, mpf_class& rop2, const mpf_class& op1,
        const mpf_class& op2)
{
    rop1 = (op1 + op2) / 2;
    rop2 = op1 * op2;
    mpf_sqrt(rop2.get_mpf_t(), rop2.get_mpf_t());
}
 
int main(void)
{
    mpf_set_default_prec(300000);
    mpf_class x0, y0, resA, resB, Z;
 
    x0 = 1;
    y0 = 0.5;
    Z  = 0.25;
    mpf_sqrt(y0.get_mpf_t(), y0.get_mpf_t());
 
    int n = 1;
    for (int i = 0; i < 8; i++) {
        agm(resA, resB, x0, y0);
        Z -= n * (resA - x0) * (resA - x0);
        n *= 2;
 
        agm(x0, y0, resA, resB);
        Z -= n * (x0 - resA) * (x0 - resA);
        n *= 2;
    }
 
    x0 = x0 * x0 / Z;
    gmp_printf (""%.100000Ff"", x0.get_mpf_t());
    return 0;
}
 "
"/*Arithmetic Geometric Mean of 1 and 1/sqrt(2)   Nigel_Galloway  February 7th., 2012.*/
 
#include strv
 
void agm (const mpf_t in1, const mpf_t in2, mpf_t out1, mpf_t out2) {
	mpf_add (out1, in1, in2);
	mpf_div_ui (out1, out1, 2);
	mpf_mul (out2, in1, in2);
	mpf_sqrt (out2, out2);
}
 
int main (void) {
	mpf_set_default_prec (65568);
	mpf_t x0, y0, resA, resB;
 
	mpf_init_set_ui (y0, 1);
	mpf_init_set_d (x0, 0.5);
	mpf_sqrt (x0, x0);
	mpf_init (resA);
	mpf_init (resB);
 
	for(int i=0; i<7; i++){
		agm(x0, y0, resA, resB);
		agm(resA, resB, x0, y0);
	}
	gmp_printf (""%.20000Ff"", x0);
	gmp_printf (""%.20000Ff"", y0);
 
	return 0;
}"
"#include <iostream>
#include strv
#include strv
 
typedef  boost::rational<int> frac;
 
bool is_perfect(int c)
{
    frac sum(1, c);
    for (int f = 2;f < sqrt(static_cast<float>(c)); ++f){
 
        if (c % f == 0) sum += frac(1,f) + frac(1, c/f);
    }
    if (sum.denominator() == 1){
 	return (sum == 1);
    }
    return false;
}
 
int main()
{
    for (int candidate = 2; candidate < 0x80000; ++candidate){
        if (is_perfect(candidate)) 
	        std::cout << candidate << strv << std::endl;
    }
    return 0;
}"
" #include <boost/spirit.hpp>
 #include <boost/spirit/tree/ast.hpp>
 #include <string>
 #include <cassert>
 #include <iostream>
 #include <istream>
 #include <ostream>
 
 using boost::spirit::rule;
 using boost::spirit::parser_tag;
 using boost::spirit::ch_p;
 using boost::spirit::real_p;
 
 using boost::spirit::tree_node;
 using boost::spirit::node_val_data;
 
 

 struct parser: public boost::spirit::grammar<parser>
 {
   enum rule_ids { addsub_id, multdiv_id, value_id, real_id };
 
   struct set_value
   {
     set_value(parser const& p): self(p) {}
     void operator()(tree_node<node_val_data<std::string::iterator,
                                             double> >& node,
                     std::string::iterator begin,
                     std::string::iterator end) const
     {
       node.value.value(self.tmp);
     }
     parser const& self;
   };
 
   mutable double tmp;
 
   template<typename Scanner> struct definition
   {
     rule<Scanner, parser_tag<addsub_id> > addsub;
     rule<Scanner, parser_tag<multdiv_id> > multdiv;
     rule<Scanner, parser_tag<value_id> > value;
     rule<Scanner, parser_tag<real_id> > real;
 
     definition(parser const& self)
     {
       using namespace boost::spirit;
       addsub = multdiv
         >> *((root_node_d[ch_p('+')] | root_node_d[ch_p('-')]) >> multdiv);
       multdiv = value
         >> *((root_node_d[ch_p('*')] | root_node_d[ch_p('/')]) >> value);
       value = real | inner_node_d[('(' >> addsub >> ')')];
       real = leaf_node_d[access_node_d[real_p[assign_a(self.tmp)]][set_value(self)]];
     }
 
     rule<Scanner, parser_tag<addsub_id> > const& start() const
     {
       return addsub;
     }
   };
 };
 
 template<typename TreeIter>
 double evaluate(TreeIter const& i)
 {
   double op1, op2;
   switch (i->value.id().to_long())
   {
   case parser::real_id:
     return i->value.value();
   case parser::value_id:
   case parser::addsub_id:
   case parser::multdiv_id:
     op1 = evaluate(i->children.begin());
     op2 = evaluate(i->children.begin()+1);
     switch(*i->value.begin())
     {
     case '+':
       return op1 + op2;
     case '-':
       return op1 - op2;
     case '*':
       return op1 * op2;
     case '/':
       return op1 / op2;
     default:
       assert(!strv);
     }
   default:
     assert(!strv);
   }
   return 0;
 }
 
 

 int main()
 {
   parser eval;
   std::string line;
   while (std::cout << strv
          && std::getline(std::cin, line)
          && !line.empty())
   {
     typedef boost::spirit::node_val_data_factory<double> factory_t;
     boost::spirit::tree_parse_info<std::string::iterator, factory_t> info =
       boost::spirit::ast_parse<factory_t>(line.begin(), line.end(),
                                           eval, boost::spirit::space_p);
     if (info.full)
     {
       std::cout << strv << evaluate(info.trees.begin()) << std::endl;
     }
     else
     {
       std::cout << strv << std::endl;
     }
   }
 };"
"#include <vector>
#include <iostream>
using namespace std;
 
void Filter(const vector<float> &b, const vector<float> &a, const vector<float> &in, vector<float> &out)
{
 
	out.resize(0);
	out.resize(in.size());
 
	for(int i=0; i < in.size(); i++)
	{
		float tmp = 0.;
		int j=0;
		out[i] = 0.f;
		for(j=0; j < b.size(); j++)
		{
			if(i - j < 0) continue;
			tmp += b[j] * in[i-j];
		}
 
		for(j=1; j < a.size(); j++)
		{
			if(i - j < 0) continue;
			tmp -= a[j]*out[i-j];
		}
 
		tmp /= a[0];
		out[i] = tmp;
	}
}
 
int main()
{
	vector<float> sig = {-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,\
		-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,\
		0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,\
		0.0259303398477,0.490105989562,0.549391221511,0.9047198589};
 
	//Constants for a Butterworth filter (order 3, low pass)
	vector<float> a = {1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17};
	vector<float> b = {0.16666667, 0.5, 0.5, 0.16666667};
 
	vector<float> result;
	Filter(b, a, sig, result);
 
	for(size_t i=0;i<result.size();i++)
		cout << result[i] << strv;
	cout << endl;			
 
	return 0;
}"
"T* foo = new(arena) T;#include <cstdlib>
#include <cassert>
#include <new>
 




class Pool
{
public:
  Pool(std::size_type sz);
  ~Pool();
  static Pool& current() { return *cur; }
  void* allocate(std::size_type sz, std::size_t alignment);
private:
  char* memory; 

  char* free;
  char* end;
  Pool* prev;
  static Pool* cur;
 
  

  Pool(Pool const&); 

  Pool& operator=(Pool const&); 

};
 
Pool* pool::cur = 0;
 
Pool::Pool(std::size_type size):
  memory(static_cast<char*>(::operator new(size))),
  free(memory),
  end(memory + size))
{
  prev = cur;
  cur = this;
}
 
Pool::~Pool()
{
  ::operator delete(memory);
  cur = prev;
}
 
void* Pool::allocate(std::size_t size, std::size_t alignment)
{
  char* start = free;
 
  

  std::size_t extra = (start - memory) % aligment;
  if (extra != 0)
  {
    extra = alignment - extra;
  }
 
  

  if (end - free < size + extra)
    throw std::bad_alloc();
 
  

  free = start + size + extra;
  return start;
}
 


struct X
{
  int member;
  void* operator new(std::size_t);
  void operator delete(void*) {} 

};
 
void* X::operator new(std::size_t size)
{
  

  

  return Pool::current().allocate(size, size);
}
 


int main()
{
  Pool my_pool(3*sizeof(X));
  X* p1 = new X; 

  X* p2 = new X;
  X* p3 = new X;
  delete p3; 

 
  try
  {
    X* p4 = new X; 

    assert(false);
  }
  catch(...)
  {
  }
 
  X* p5 = new X[10]; 

  delete[] p5; 

 
  Pool* my_second_pool(1000); 

  X* p6 = new X; 

  X* p7 = new X;
  delete my_second_pool 

 
} 
"
" 
#include <windows.h>
#include <string>
#include <iostream>
 
const int BMP_SIZE = 600;
 
class myBitmap {
public:
    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}
    ~myBitmap() {
        DeleteObject( pen ); DeleteObject( brush );
        DeleteDC( hdc ); DeleteObject( bmp );
    }
    bool create( int w, int h ) {
        BITMAPINFO bi;
        ZeroMemory( &bi, sizeof( bi ) );
        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );
        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biWidth       =  w;
        bi.bmiHeader.biHeight      = -h;
        HDC dc = GetDC( GetConsoleWindow() );
        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );
        if( !bmp ) return false;
        hdc = CreateCompatibleDC( dc );
        SelectObject( hdc, bmp );
        ReleaseDC( GetConsoleWindow(), dc );
        width = w; height = h;
        return true;
    }
    void clear( BYTE clr = 0 ) {
        memset( pBits, clr, width * height * sizeof( DWORD ) );
    }
    void setBrushColor( DWORD bClr ) {
        if( brush ) DeleteObject( brush );
        brush = CreateSolidBrush( bClr );
        SelectObject( hdc, brush );
    }
    void setPenColor( DWORD c ) {
        clr = c; createPen();
    }
    void setPenWidth( int w ) {
        wid = w; createPen();
    }
    void saveBitmap( std::string path ) {
        BITMAPFILEHEADER fileheader;
        BITMAPINFO       infoheader;
        BITMAP           bitmap;
        DWORD            wb;
        GetObject( bmp, sizeof( bitmap ), &bitmap );
        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];
        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );
        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );
        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );
        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;
        infoheader.bmiHeader.biCompression = BI_RGB;
        infoheader.bmiHeader.biPlanes = 1;
        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );
        infoheader.bmiHeader.biHeight = bitmap.bmHeight;
        infoheader.bmiHeader.biWidth = bitmap.bmWidth;
        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );
        fileheader.bfType    = 0x4D42;
        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );
        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;
        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );
        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
                                  FILE_ATTRIBUTE_NORMAL, NULL );
        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );
        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );
        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );
        CloseHandle( file );
        delete [] dwpBits;
    }
    HDC getDC() const     { return hdc; }
    int getWidth() const  { return width; }
    int getHeight() const { return height; }
private:
    void createPen() {
        if( pen ) DeleteObject( pen );
        pen = CreatePen( PS_SOLID, wid, clr );
        SelectObject( hdc, pen );
    }
    HBITMAP bmp; HDC    hdc;
    HPEN    pen; HBRUSH brush;
    void    *pBits; int    width, height, wid;
    DWORD    clr;
};
class spiral {
public:
    spiral() {
        bmp.create( BMP_SIZE, BMP_SIZE );
    }
    void draw( int c, int s ) {
        double a = .2, b = .3, r, x, y;
        int w = BMP_SIZE >> 1;
        HDC dc = bmp.getDC();
        for( double d = 0; d < c * 6.28318530718; d += .002 ) {
            r = a + b * d; x = r * cos( d ); y = r * sin( d );
            SetPixel( dc, ( int )( s * x + w ), ( int )( s * y + w ), 255 );
        }
        

        bmp.saveBitmap( strv );
    }
private:
    myBitmap bmp;
};
int main(int argc, char* argv[]) {
    spiral s; s.draw( 16, 8 ); return 0;
}
 "
"#include <iostream> //cout for printing
#include <algorithm> //for_each defined here
 
//create the function (print the square)
void print_square(int i) {
  std::cout << i*i << strv;
}
 
int main() {
  //create the array
  int ary[]={1,2,3,4,5};
  //stl for_each
  std::for_each(ary,ary+5,print_square);
  return 0;
}
//prints 1 4 9 16 25#include <iostream>  // cout for printing
#include <algorithm> // for_each defined here
#include <vector>    // stl vector class
 


void print_square(int i) {
  std::cout << i*i << strv;
}
 
int main() {
  

  std::vector<int> ary;
  ary.push_back(1);
  ary.push_back(2);
  ary.push_back(3);
  ary.push_back(4);
  ary.push_back(5);
  

  std::for_each(ary.begin(),ary.end(),print_square);
  return 0;
}
//prints 1 4 9 16 25#include <iostream>   // cout for printing
#include <algorithm>  // for_each defined here
#include <vector>     // stl vector class
#include <functional> // bind and ptr_fun
 


template<class type1,class type2>
void print_juxtaposed(type1 x, type2 y) {
  std::cout << x << y;
}
 
int main() {
  

  std::vector<int> ary;
  ary.push_back(1);
  ary.push_back(2);
  ary.push_back(3);
  ary.push_back(4);
  ary.push_back(5);
  

  std::for_each(ary.begin(),ary.end(),std::bind2nd(std::ptr_fun(print_juxtaposed<int,std::string>),strv));
  return 0;
}
//prints 1x 2x 3x 4x 5xusing namespace std;
using namespace boost::lambda;
vector<int> ary(10);
int i = 0;
for_each(ary.begin(), ary.end(), _1 = ++var(i)); 

transform(ary.begin(), ary.end(), ostream_iterator<int>(cout, strv), _1 * _1); 
#include <vector>
#include <iostream>
#include <algorithm>
#include <iterator>
 
int main() {
   std::vector<int> intVec(10);
   std::iota(std::begin(intVec), std::end(intVec), 1 ); 

   std::transform(std::begin(intVec) , std::end(intVec), std::begin(intVec),
	 [](int i) { return i * i ; } ); 

   std::copy(std::begin(intVec), end(intVec) ,
	 std::ostream_iterator<int>(std::cout, strv));
   std::cout << std::endl;
   return 0;
}"
"#include <cmath>
#include <iostream>
using namespace std;
 
double getDifference(double b1, double b2) {
	double r = fmod(b2 - b1, 360.0);
	if (r < -180.0)
		r += 360.0;
	if (r >= 180.0)
		r -= 360.0;
	return r;
}
 
int main()
{
	cout << strv << endl;
	cout << getDifference(20.0, 45.0) << endl;
	cout << getDifference(-45.0, 45.0) << endl;
	cout << getDifference(-85.0, 90.0) << endl;
	cout << getDifference(-95.0, 90.0) << endl;
	cout << getDifference(-45.0, 125.0) << endl;
	cout << getDifference(-45.0, 145.0) << endl;
	cout << getDifference(-45.0, 125.0) << endl;
	cout << getDifference(-45.0, 145.0) << endl;
	cout << getDifference(29.4803, -88.6381) << endl;
	cout << getDifference(-78.3251, -159.036) << endl;
 
	cout << strv << endl;
	cout << getDifference(-70099.74233810938, 29840.67437876723) << endl;
	cout << getDifference(-165313.6666297357, 33693.9894517456) << endl;
	cout << getDifference(1174.8380510598456, -154146.66490124757) << endl;
	cout << getDifference(60175.77306795546, 42213.07192354373) << endl;
 
	return 0;
}"
"double fib(double n)
{
  if(n < 0)
  {
    throw strv;
  }
  else
  {
    struct actual_fib
    {
        static double calc(double n)
        {
          if(n < 2)
          {
            return n;
          }
          else
          {
            return calc(n-1) + calc(n-2);
          }
        }
    };
 
    return actual_fib::calc(n);
  }
}#include <functional>
using namespace std;
 
double fib(double n)
{
  if(n < 0)
    throw strv;
 
  function<double(double)> actual_fib = [&](double n)
  {
    if(n < 2) return n;
    return actual_fib(n-1) + actual_fib(n-2);
  };
 
  return actual_fib(n);
}double fib(double n)
{
  if(n < 0)
  {
    throw strv;
  }
  else
  {
    struct actual_fib
    {
      double operator()(double n)
      {
        if(n < 2)
        {
          return n;
        }
        else
        {
          return (*this)(n-1) + (*this)(n-2);
        }
      }
    };
 
    return actual_fib()(n);
  }
}"
"#include <algorithm>
#include <fstream>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <set>
#include <string>
 
bool is_deranged(const std::string& left, const std::string& right)
{
    return (left.size() == right.size()) &&
        (std::inner_product(left.begin(), left.end(), right.begin(), 0, std::plus<int>(), std::equal_to<char>()) == 0);
}
 
int main()
{
    std::ifstream input(strv);
    if (!input) {
        std::cerr << ""can't open input file"";
        return EXIT_FAILURE;
    }
 
    typedef std::set<std::string> WordList;
    typedef std::map<std::string, WordList> AnagraMap;
    AnagraMap anagrams;
 
    std::pair<std::string, std::string> result;
    size_t longest = 0;
 
    for (std::string value; input >> value; /**/) {
        std::string key(value);
        std::sort(key.begin(), key.end());
 
        if (longest < value.length()) { 

            if (0 < anagrams.count(key)) { 

                for (const auto& prior : anagrams[key]) {
                    if (is_deranged(prior, value)) { 

                        result = std::make_pair(prior, value);
                        longest = value.length();
                    }
                }
            }
        }
        anagrams[key].insert(value);
    }
 
    std::cout << result.first << ' ' << result.second << '';
    return EXIT_SUCCESS;
}"
"#include <cstdlib>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <list>
 
bool k_prime(unsigned n, unsigned k) {
    unsigned f = 0;
    for (unsigned p = 2; f < k && p * p <= n; p++)
        while (0 == n % p) { n /= p; f++; }
    return f + (n > 1 ? 1 : 0) == k;
}
 
std::list<unsigned> primes(unsigned k, unsigned n)  {
    std::list<unsigned> list;
    for (unsigned i = 2;list.size() < n;i++)
        if (k_prime(i, k)) list.push_back(i);
    return list;
}
 
int main(const int argc, const char* argv[]) {
    using namespace std;
    for (unsigned k = 1; k <= 5; k++) {
        ostringstream os(strv);
        const list<unsigned> l = primes(k, 10);
        for (list<unsigned>::const_iterator i = l.begin(); i != l.end(); i++)
            os << setw(4) << *i;
        cout << strv << k << ':' << os.str() << endl;
    }
 
	return EXIT_SUCCESS;
}"
"#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <vector>
#include <algorithm>
#include <iterator>
 
int main() {
  std::ifstream in(strv);
  typedef  std::map<std::string, std::vector<std::string> > AnagramMap;
  AnagramMap anagrams;
 
  std::string word;
  size_t count = 0;
  while (std::getline(in, word)) {
    std::string key = word;
    std::sort(key.begin(), key.end());
    

    AnagramMap::mapped_type & v = anagrams[key];
    v.push_back(word);
    count = std::max(count, v.size());
  }
 
  in.close();
 
  for (AnagramMap::const_iterator it = anagrams.begin(), e = anagrams.end();
       it != e; it++)
    if (it->second.size() >= count) {
      std::copy(it->second.begin(), it->second.end(),
                std::ostream_iterator<std::string>(std::cout, strv));
      std::cout << std::endl;
    }
  return 0;
}"
"int i;
void* address_of_i = &i;int& i = *(int*)0xA100;static union
{
  int i;
  int j;
};int i;
int& j = i;"
" 
#include <vector>
#include <unordered_map>
#include <iostream>
 
int main() {
    std::vector<int> alreadyDiscovered;
    std::unordered_map<int, int> divsumMap; 
    int count = 0;
 
    for (int N = 1; N <= 20000; ++N)
    {      
        int divSumN = 0;
 
        for (int i = 1; i <= N / 2; ++i)
        {
            if (fmod(N, i) == 0)
            {
                divSumN += i;
            }
        }
 
        

        if (divSumN != 1) 

            divsumMap[N] = divSumN;
 
        for (std::unordered_map<int, int>::iterator it = divsumMap.begin(); it != divsumMap.end(); ++it)
        {
            int M = it->first;
            int divSumM = it->second;
            int divSumN = divsumMap[N];
 
            if (N != M && divSumM == N && divSumN == M)
            {
                

                if (std::find(alreadyDiscovered.begin(), alreadyDiscovered.end(), N) != alreadyDiscovered.end())
                    break;
 
                std::cout << strv << M << strv << N << strv << std::endl;
 
                alreadyDiscovered.push_back(M);
                alreadyDiscovered.push_back(N);
                count++;
            }
        }
    }
 
    std::cout << count << strv << std::endl;
}
 "
"#include <atomic>
#include <chrono>
#include <cmath>
#include <iostream>
#include <mutex>
#include <thread>
 
using namespace std::chrono_literals;
 
class Integrator
{
  public:
    using clock_type = std::chrono::high_resolution_clock;
    using dur_t      = std::chrono::duration<double>;
    using func_t     = double(*)(double);
 
    explicit Integrator(func_t f = nullptr);
    ~Integrator();
    void input(func_t new_input);
    double output() { return integrate(); }
 
  private:
    std::atomic_flag continue_;
    std::mutex       mutex;
    std::thread      worker;
 
    func_t                       func;
    double                       state = 0;
    //Improves precision by reducing sin result error on large values
    clock_type::time_point const beginning = clock_type::now();
    clock_type::time_point       t_prev = beginning;
 
    void do_work();
    double integrate();
};
 
Integrator::Integrator(func_t f) : func(f)
{
    continue_.test_and_set();
    worker = std::thread(&Integrator::do_work, this);
}
 
Integrator::~Integrator()
{
    continue_.clear();
    worker.join();
}
 
void Integrator::input(func_t new_input)
{
    integrate();
    std::lock_guard<std::mutex> lock(mutex);
    func = new_input;
}
 
void Integrator::do_work()
{
    while(continue_.test_and_set()) {
        integrate();
        std::this_thread::sleep_for(1ms);
    }
}
 
double Integrator::integrate()
{
    std::lock_guard<std::mutex> lock(mutex);
    auto now = clock_type::now();
    dur_t start = t_prev - beginning;
    dur_t fin   =    now - beginning;
    if(func)
        state += (func(start.count()) + func(fin.count())) * (fin - start).count() / 2;
    t_prev = now;
    return state;
}
 
double sine(double time)
{
    constexpr double PI = 3.1415926535897932;
    return std::sin(2 * PI * 0.5 * time);
}
 
int main()
{
    Integrator foo(sine);
    std::this_thread::sleep_for(2s);
    foo.input(nullptr);
    std::this_thread::sleep_for(500ms);
    std::cout << foo.output();
}"
"#include <iostream>
 
class Acc
{
public:
    Acc(int init)
        : _type(intType)
        , _intVal(init)
    {}
 
    Acc(float init)
        : _type(floatType)
        , _floatVal(init)
    {}
 
    int operator()(int x)
    {
        if( _type == intType )
        {
            _intVal += x;
            return _intVal;
        }
        else
        {
            _floatVal += x;
            return static_cast<int>(_floatVal);
        }
    }
 
    float operator()(float x)
    {
        if( _type == intType )
        {
            _floatVal = _intVal + x;
            _type = floatType;
            return _floatVal;
        }
        else
        {
            _floatVal += x;
            return _floatVal;
        }
    }
private:
    enum {floatType, intType} _type;
    float _floatVal;
    int _intVal;
};
 
int main()
{
    Acc a(1);
    a(5);
    Acc(3);
    std::cout << a(2.3f);
    return 0;
}#include <iostream>
#include <functional>
 
template <typename T>
std::function<T(T)> makeAccumulator(T sum) {
	return [=](T increment) mutable {
		return sum += increment;
	};
}
 
int main() {
	auto acc = makeAccumulator<float>(1);
	acc(5);
	makeAccumulator(3);
	std::cout << acc(2.3) << std::endl;
	return 0;
}struct CumulantBase_
{
   virtual ~CumulantBase_();
   virtual std::ostream& Write(std::ostream& dst) const = 0;
};
 
template<class T_> struct Cumulant_ : CumulantBase_
{
   T_ val_;
   Cumulant_(const T_& val) : val_(val) {}
   std::ostream& Write(std::ostream& dst) const override 
   {
      return dst << val_;
   }
};
 
struct Accumulator_
{
   std::unique_ptr<CumulantBase_> val_;
   template<class T_> Accumulator_(const T_& val) { Set(val); }
   template<class T_> void Set(const T_& val) { val_.reset(new Cumulant_<T_>(val)); }
 

	

	Accumulator_& operator()(int more)
	{
		if (auto i = CoerceInt(*val_))
			Set(+i + more);
		else if (auto d = CoerceDouble(*val_))
			Set(+d + more);
		else
			THROW(strv);
		return *this;
	}
	Accumulator_& operator()(double more)
	{
		if (auto d = CoerceDouble(*val_))
			Set(+d + more);
		else
			THROW(strv);
		return *this;
	}
	Accumulator_& operator()(const String_& more)
	{
		if (auto s = CoerceString(*val_))
			Set(+s + more);
		else
			THROW(strv);
		return *this;
	}
};
 

boost::optional<int> CoerceInt(const CumulantBase_& c)
{
	if (auto p = dynamic_cast<const Cumulant_<int>*>(&c))
		return p->val_;
	return boost::optional<int>();
}
boost::optional<double> CoerceDouble(const CumulantBase_& c)
{
	if (auto p = dynamic_cast<const Cumulant_<double>*>(&c))
		return p->val_;
	if (auto i = CoerceInt(c))
		return boost::optional<double>(i);
	return boost::optional<double>();
}
boost::optional<String_> CoerceString(const CumulantBase_& c)
{
	if (auto p = dynamic_cast<const Cumulant_<String_>*>(&c))
		return p->val_;
	return boost::optional<String_>();
}
 std::ostream& operator<<(std::ostream& dst, const Accumulator_& acc)
{
	return acc.val_->Write(dst);
}
 "
"class Abs {
public:
	virtual int method1(double value) = 0;
	virtual int add(int a, int b){
		return a+b;
	}
};"
"#include <iostream>
 
unsigned int ackermann(unsigned int m, unsigned int n) {
  if (m == 0) {
    return n + 1;
  }
  if (n == 0) {
    return ackermann(m - 1, 1);
  }
  return ackermann(m - 1, ackermann(m, n - 1));
}
 
int main() {
  for (unsigned int m = 0; m < 4; ++m) {
    for (unsigned int n = 0; n < 10; ++n) {
      std::cout << strv << m << strv << n << strv << ackermann(m, n) << """";
    }
  }
}
 #include <iostream>
#include <sstream>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
 
using big_int = boost::multiprecision::cpp_int;
 
big_int ipow(big_int base, big_int exp) {
  big_int result(1);
  while (exp) {
    if (exp & 1) {
      result *= base;
    }
    exp >>= 1;
    base *= base;
  }
  return result;
}
 
big_int ackermann(unsigned m, unsigned n) {
  static big_int (*ack)(unsigned, big_int) =
      [](unsigned m, big_int n)->big_int {
    switch (m) {
    case 0:
      return n + 1;
    case 1:
      return n + 2;
    case 2:
      return 3 + 2 * n;
    case 3:
      return 5 + 8 * (ipow(big_int(2), n) - 1);
    default:
      return n == 0 ? ack(m - 1, big_int(1)) : ack(m - 1, ack(m, n - 1));
    }
  };
  return ack(m, big_int(n));
}
 
int main() {
  for (unsigned m = 0; m < 4; ++m) {
    for (unsigned n = 0; n < 10; ++n) {
      std::cout << strv << m << strv << n << strv << ackermann(m, n) << """";
    }
  }
 
  std::cout << strv << ackermann(4, 1) << """";
 
  std::stringstream ss;
  ss << ackermann(4, 2);
  auto text = ss.str();
  std::cout << strv << text.length() << "" digits)""
            << text.substr(0, 80) << ""...""
            << text.substr(text.length() - 80) << """";
}"
"#include <iostream>
#include <algorithm>
#include <vector>
 
std::vector<int> findProperDivisors ( int n ) {
   std::vector<int> divisors ;
   for ( int i = 1 ; i < n / 2 + 1 ; i++ ) {
      if ( n % i == 0 ) 
	 divisors.push_back( i ) ;
   }
   return divisors  ;
}
 
int main( ) {
   std::vector<int> deficients , perfects , abundants , divisors ;
   for ( int n = 1 ; n < 20001 ; n++ ) {
      divisors = findProperDivisors( n ) ;
      int sum = std::accumulate( divisors.begin( ) , divisors.end( ) , 0 ) ;
      if ( sum < n ) {
	 deficients.push_back( n ) ;
      }
      if ( sum == n ) {
	 perfects.push_back( n ) ;
      }
      if ( sum > n ) {
	 abundants.push_back( n ) ;
      }
   }
   std::cout << strv << deficients.size( ) << std::endl ;
   std::cout << strv << perfects.size( ) << std::endl ;
   std::cout << strv << abundants.size( ) << std::endl ;
   return 0 ;
}"
" 
#include <list>
#include <algorithm>
#include <iostream>
 
class point {
public:
    point( int a = 0, int b = 0 ) { x = a; y = b; }
    bool operator ==( const point& o ) { return o.x == x && o.y == y; }
    point operator +( const point& o ) { return point( o.x + x, o.y + y ); }
    int x, y;
};
 
class map {
public:
    map() {
        char t[8][8] = {
            {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 0}, {0, 0, 1, 0, 0, 0, 1, 0},
            {0, 0, 1, 0, 0, 0, 1, 0}, {0, 0, 1, 1, 1, 1, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}
        };
        w = h = 8;
        for( int r = 0; r < h; r++ )
            for( int s = 0; s < w; s++ )
                m[s][r] = t[r][s];
    }
    int operator() ( int x, int y ) { return m[x][y]; }
    char m[8][8];
    int w, h;
};
 
class node {
public:
    bool operator == (const node& o ) { return pos == o.pos; }
    bool operator == (const point& o ) { return pos == o; }
    bool operator < (const node& o ) { return dist + cost < o.dist + o.cost; }
    point pos, parent;
    int dist, cost;
};
 
class aStar {
public:
    aStar() {
        neighbours[0] = point( -1, -1 ); neighbours[1] = point(  1, -1 );
        neighbours[2] = point( -1,  1 ); neighbours[3] = point(  1,  1 );
        neighbours[4] = point(  0, -1 ); neighbours[5] = point( -1,  0 );
        neighbours[6] = point(  0,  1 ); neighbours[7] = point(  1,  0 );
    }
 
    int calcDist( point& p ){
        

        int x = end.x - p.x, y = end.y - p.y;
        return( x * x + y * y );
    }
 
    bool isValid( point& p ) {
        return ( p.x >-1 && p.y > -1 && p.x < m.w && p.y < m.h );
    }
 
    bool existPoint( point& p, int cost ) {
        std::list<node>::iterator i;
        i = std::find( closed.begin(), closed.end(), p );
        if( i != closed.end() ) {
            if( ( *i ).cost + ( *i ).dist < cost ) return true;
            else { closed.erase( i ); return false; }
        }
        i = std::find( open.begin(), open.end(), p );
        if( i != open.end() ) {
            if( ( *i ).cost + ( *i ).dist < cost ) return true;
            else { open.erase( i ); return false; }
        }
        return false;
    }
 
    bool fillOpen( node& n ) {
        int stepCost, nc, dist;
        point neighbour;
 
        for( int x = 0; x < 8; x++ ) {
            

            stepCost = x < 4 ? 1 : 1;
            neighbour = n.pos + neighbours[x];
            if( neighbour == end ) return true;
 
            if( isValid( neighbour ) && m( neighbour.x, neighbour.y ) != 1 ) {
                nc = stepCost + n.cost;
                dist = calcDist( neighbour );
                if( !existPoint( neighbour, nc + dist ) ) {
                    node m;
                    m.cost = nc; m.dist = dist;
                    m.pos = neighbour; 
                    m.parent = n.pos;
                    open.push_back( m );
                }
            }
        }
        return false;
    }
 
    bool search( point& s, point& e, map& mp ) {
        node n; end = e; start = s; m = mp;
        n.cost = 0; n.pos = s; n.parent = 0; n.dist = calcDist( s ); 
        open.push_back( n );
        while( !open.empty() ) {
            //open.sort();
            node n = open.front();
            open.pop_front();
            closed.push_back( n );
            if( fillOpen( n ) ) return true;
        }
        return false;
    }
 
    int path( std::list<point>& path ) {
        path.push_front( end );
        int cost = 1 + closed.back().cost; 
        path.push_front( closed.back().pos );
        point parent = closed.back().parent;
 
        for( std::list<node>::reverse_iterator i = closed.rbegin(); i != closed.rend(); i++ ) {
            if( ( *i ).pos == parent && !( ( *i ).pos == start ) ) {
                path.push_front( ( *i ).pos );
                parent = ( *i ).parent;
            }
        }
        path.push_front( start );
        return cost;
    }
 
    map m; point end, start;
    point neighbours[8];
    std::list<node> open;
    std::list<node> closed;
};
 
int main( int argc, char* argv[] ) {
    map m;
    point s, e( 7, 7 );
    aStar as;
 
    if( as.search( s, e, m ) ) {
        std::list<point> path;
        int c = as.path( path );
        for( int y = -1; y < 9; y++ ) {
            for( int x = -1; x < 9; x++ ) {
                if( x < 0 || y < 0 || x > 7 || y > 7 || m( x, y ) == 1 )
                    std::cout << char(0xdb);
                else {
                    if( std::find( path.begin(), path.end(), point( x, y ) )!= path.end() )
                        std::cout << strv;
                    else std::cout << strv;
                }
            }
            std::cout << """";
        }
 
        std::cout << ""Path cost "" << c << strv;
        for( std::list<point>::iterator i = path.begin(); i != path.end(); i++ ) {
            std::cout<< strv << ( *i ).x << strv << ( *i ).y << strv;
        }
    }
    std::cout << """";
    return 0;
}
 "
"#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <cctype>
 
 
typedef std::pair<char,char> item_t;
typedef std::vector<item_t> list_t;
 
bool can_make_word(const std::string& w, const list_t& vals) {
    std::set<uint32_t> used;
    while (used.size() < w.size()) {
        const char c = toupper(w[used.size()]);
        uint32_t x = used.size();
        for (uint32_t i = 0, ii = vals.size(); i < ii; ++i) {
            if (used.find(i) == used.end()) {
                if (toupper(vals[i].first) == c || toupper(vals[i].second) == c) {
                    used.insert(i);
                    break;
                }
            }
        }
        if (x == used.size()) break;
    }
    return used.size() == w.size();
}
 
 
int main() {
    list_t vals{ {'B','O'}, {'X','K'}, {'D','Q'}, {'C','P'}, {'N','A'}, {'G','T'}, {'R','E'}, {'T','G'}, {'Q','D'}, {'F','S'}, {'J','W'}, {'H','U'}, {'V','I'}, {'A','N'}, {'O','B'}, {'E','R'}, {'F','S'}, {'L','Y'}, {'P','C'}, {'Z','M'} };
    std::vector<std::string> words{strv,strv,strv,strv,strv,strv,strv};
    for (const std::string& w : words) {
        std::cout << w << strv << std::boolalpha << can_make_word(w,vals) << ""."";
    }
 
}"
"

#include <iostream>
using namespace std;
int main()
{
   int a, b;
   cin >> a >> b;
   cout << a + b << endl;
}



#include <fstream>
using namespace std;
int main()
{
   ifstream in(strv);
   ofstream out(strv);
   int a, b;
   in >> a >> b;
   out << a + b << endl;
   return 0;
}"
" 




#include <gmpxx.h>
int N{123456};
mpz_class hyp[N-3];
const mpz_class G(const int n,const int g){return g>n?0:(g==1 or n-g<2)?1:hyp[n-g-2];};
void G_hyp(const int n){for(int i=0;i<N-2*n-1;i++) n==1?hyp[n-1+i]=1+G(i+n+1,n+1):hyp[n-1+i]+=G(i+n+1,n+1);}
}
  
#include <iostream>
#include <iomanip>
int main(){
  N=25;
  for (int n=1; n<N/2; n++){
    G_hyp(n);
    for (int g=0; g<N-3; g++) std::cout << std::setw(4) << hyp[g];
    std::cout << std::endl;
  }
}
  
int main(){
  N = 25;
  std::cout << std::setw(N+52) << strv << std::endl;
  std::cout << std::setw(N+55) << strv << std::endl;
  std::cout << std::setw(N+58) << strv << std::endl;
  std::string ott[N-3];
  for (int n=1; n<N/2; n++) {
    G_hyp(n);
    for (int g=(n-1)*2; g<N-3; g++) {
      std::string t = hyp[g-(n-1)].get_str();
      //if (t.size()==1) t.insert(t.begin(),1,' ');
      ott[g].append(t);
      ott[g].append(6-t.size(),' ');
    }
  }
  for(int n = 0; n<N-3; n++) {
    std::cout <<std::setw(N+43-3*n) << 1 << strv << ott[n];
    for (int g = (n+1)/2; g>0; g--) {
      std::string t{hyp[g-1].get_str()};
      t.append(6-t.size(),' ');
      std::cout << t;
    }
    std::cout << strv << std::endl; 
  }
  
#include <iostream>
int main(){
  for (int n=1; n<N/2; n++) G_hyp(n);
  std::cout << strv << hyp[21] << std::endl;
  std::cout << strv << hyp[121] << std::endl;
  std::cout << strv << hyp[1232] << std::endl;
  std::cout << strv << hyp[12343] << std::endl;
  mpz_class r{3};
  for (int i = 0; i<N-3; i++) r += hyp[i];
  std::cout << strv << r << std::endl;
}
 "
" 
#include <iostream>
#include <ratio>
#include <array>
#include <algorithm>
#include <random>
 
typedef short int Digit;  

 
constexpr Digit nDigits{4};      

constexpr Digit maximumDigit{9}; 

constexpr short int gameGoal{24};    

 
typedef std::array<Digit, nDigits> digitSet; 

digitSet d;
 
void printTrivialOperation(std::string operation) { 

	bool printOperation(false);
	for(const Digit& number : d) {
		if(printOperation)
			std::cout << operation;
		else
			printOperation = true;
		std::cout << number;
	}
	std::cout << std::endl;
}
 
void printOperation(std::string prefix, std::string operation1, std::string operation2, std::string operation3, std::string suffix = strv) {
	std::cout << prefix << d[0] << operation1 << d[1] << operation2 << d[2] << operation3 << d[3] << suffix << std::endl;
}
 
int main() {
	std::mt19937_64 randomGenerator;
	std::uniform_int_distribution<Digit> digitDistro{1, maximumDigit};
	

	for(int trial{10}; trial; --trial) {
		for(Digit& digit : d) {
			digit = digitDistro(randomGenerator);
			std::cout << digit << strv;
		}
		std::cout << std::endl;
		std::sort(d.begin(), d.end());
		

		if(std::accumulate(d.cbegin(), d.cend(), 0) == gameGoal)
			printTrivialOperation(strv);
		if(std::accumulate(d.cbegin(), d.cend(), 1, std::multiplies<Digit>{}) == gameGoal)
			printTrivialOperation(strv);
		

		do {
			

			if(d[0] + d[1] + d[2] - d[3] == gameGoal) printOperation(strv, strv, strv, strv); 

			

			if(d[0] * d[1] + d[2] + d[3] == gameGoal) printOperation(strv, strv, strv, strv);
			if(d[0] * (d[1] + d[2]) + d[3] == gameGoal) printOperation(strv, strv, strv, strv);
			if(d[0] * (d[1] + d[2] + d[3]) == gameGoal) printOperation(strv, strv, strv, strv, strv);
			

			if((d[0] * d[1] * d[2]) + d[3] == gameGoal) printOperation(strv, strv, strv, strv);
			if(d[0] * d[1] * (d[2] + d[3]) == gameGoal) printOperation(strv, strv, strv, strv, strv);
			if((d[0] * d[1]) + (d[2] * d[3]) == gameGoal) printOperation(strv, strv, strv, strv, strv);
			

			if((d[0] * d[1] * d[2]) - d[3] == gameGoal) printOperation(strv, strv, strv, strv);
			if(d[0] * d[1] * (d[2] - d[3]) == gameGoal) printOperation(strv, strv, strv, strv, strv);
			if((d[0] * d[1]) - (d[2] * d[3]) == gameGoal) printOperation(strv, strv, strv, strv, strv);
			

			if(d[0] * d[1] + d[2] - d[3] == gameGoal) printOperation(strv, strv, strv, strv);
			if(d[0] * (d[1] + d[2]) - d[3] == gameGoal) printOperation(strv, strv, strv, strv);
			if(d[0] * (d[1] - d[2]) + d[3] == gameGoal) printOperation(strv, strv, strv, strv);
			if(d[0] * (d[1] + d[2] - d[3]) == gameGoal) printOperation(strv, strv, strv, strv, strv);
			if(d[0] * d[1] - (d[2] + d[3]) == gameGoal) printOperation(strv, strv, strv, strv, strv);
			

			if(d[0] * d[1] == (gameGoal - d[3]) * d[2]) printOperation(strv, strv, strv, strv);
			if(((d[0] * d[1]) + d[2]) == gameGoal * d[3]) printOperation(strv, strv, strv, strv);
			if((d[0] + d[1]) * d[2] == gameGoal * d[3]) printOperation(strv, strv, strv, strv);
			if(d[0] * d[1] == gameGoal * (d[2] + d[3])) printOperation(strv, strv, strv, strv, strv);
			

			if(d[0] * d[1] == (gameGoal + d[3]) * d[2]) printOperation(strv, strv, strv, strv);
			if(((d[0] * d[1]) - d[2]) == gameGoal * d[3]) printOperation(strv, strv, strv, strv);
			if((d[0] - d[1]) * d[2] == gameGoal * d[3]) printOperation(strv, strv, strv, strv);
			if(d[0] * d[1] == gameGoal * (d[2] - d[3])) printOperation(strv, strv, strv, strv, strv);
			

			if(d[0] * d[1] * d[2] == gameGoal * d[3]) printOperation(strv, strv, strv, strv);
			if(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(strv, strv, strv, strv, strv);
			

			if(d[0] * d[3] == gameGoal * (d[1] * d[3] - d[2])) printOperation(strv, strv, strv, strv, strv);
			

			if(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(strv, strv, strv, strv, strv);
		} while(std::next_permutation(d.begin(), d.end())); 

	}
	return 0;
}
 "
"#include <iostream>
using std::cout;
 
int main() 
{
  for(int bottles(99); bottles > 0; bottles -= 1){
    cout << bottles << "" bottles of beer on the wall""
         << bottles << "" bottles of beer""
         << ""Take one down, pass it around""
         << bottles - 1 << "" bottles of beer on the wall"";
  }
}#include <iostream>
 
template<int max, int min> struct bottle_countdown
{
  static const int middle = (min + max)/2;
  static void print()
  {
    bottle_countdown<max, middle+1>::print();
    bottle_countdown<middle, min>::print();
  }
};
 
template<int value> struct bottle_countdown<value, value>
{
  static void print()
  {
    std::cout << value << "" bottles of beer on the wall""
              << value << "" bottles of beer""
              << ""Take one down, pass it around""
              << value-1 << "" bottles of beer"";
  }
};
 
int main()
{
  bottle_countdown<100, 1>::print();
  return 0;
}#include <iostream>
using namespace std;
void rec(int bottles)
{
if ( bottles!=0)    
 {    
     cout << bottles << strv << endl; 
        cout << bottles << strv << endl;
        cout << strv << endl; 
        cout << --bottles << "" bottles of beer on the wall"" << endl;    
    rec(bottles);
 }  
}
 
int main() 
 {   
rec(99);
system(strv);
return 0;
}
 #include <iostream>
#include <ostream>
 
#define BOTTLE(nstr) nstr strv
 
#define WALL(nstr) BOTTLE(nstr) strv
 
#define PART1(nstr) WALL(nstr) strv BOTTLE(nstr) \                    strv
 
#define PART2(nstr) WALL(nstr) strv
 
#define MIDDLE(nstr) PART2(nstr) PART1(nstr)
 
#define SONG PART1(strv)
 
#define CD2 CD3(strv) \        CD3(strv)
 
#define CD3(pre) CD4(pre) MIDDLE(pre strv)
 
#define CD4(pre) MIDDLE(pre strv) \ MIDDLE(pre strv) \ MIDDLE(pre strv)
 
int main()
{
  std::cout << SONG;
  return 0;
}                          //>,_
                        //Beer Song>,_
                       #include <iostream>
                      using namespace std;
                     int main(){ for( int
                    b=-1; b<99;  cout <<
                   '') for ( int w=0;
                  w<3; cout << "".""){ 
                 if (w==2) cout << ((
                b--) ?strv
               strv
              strv:strv
             strv
            strv); if (b<0) b=99
           ; do{ if (w) cout <<
          strv; if (b) cout <<
          b;  else  cout << (
         (w) ? 'n' : 'N') <<
         strv; cout <<
         strv ;  if
        (b!=1) cout <<
       's' ; cout <<
       strv;
      if (w!=1)
     cout  <<
    strv
   strv
  ;} while
 (!w++);}
  return
       0
       ;
       }
      //
  

     

            
"
" 
#include <time.h>
#include <iostream>
#include <string>
#include <iomanip>
#include <cstdlib>
 
typedef unsigned int uint;
using namespace std;
enum movDir { UP, DOWN, LEFT, RIGHT };
 
class tile
{
public:
    tile() : val( 0 ), blocked( false ) {}
    uint val;
    bool blocked;
};
 
class g2048
{
public:
    g2048() : done( false ), win( false ), moved( true ), score( 0 ) {}
    void loop()
    {
	addTile(); 
	while( true )
	{
	    if( moved ) addTile();
	    drawBoard(); 
	    if( done ) break;
	    waitKey();
	}
	string s = strv;
	if( win ) s = strv;
	cout << s << endl << endl;
    }
private:
    void drawBoard()
    {
	system( strv );
	cout << strv << score << endl << endl;
	for( int y = 0; y < 4; y++ )
	{
	    cout << strv << endl << strv;
	    for( int x = 0; x < 4; x++ )
	    {
		if( !board[x][y].val ) cout << setw( 4 ) << strv;
		else cout << setw( 4 ) << board[x][y].val;
		cout << strv;
	    }
	    cout << endl;
	}
	cout << strv << endl << endl;
    }
    void waitKey()
    {
	moved = false; char c; 
	cout << strv; cin >> c; c &= 0x5F;
	switch( c )
	{
	    case 'W': move( UP );break;
	    case 'A': move( LEFT ); break;
	    case 'S': move( DOWN ); break;
	    case 'D': move( RIGHT );
	}
	for( int y = 0; y < 4; y++ )
	    for( int x = 0; x < 4; x++ )
		board[x][y].blocked = false;
    }
    void addTile()
    {
	for( int y = 0; y < 4; y++ )
	    for( int x = 0; x < 4; x++ )
		if( !board[x][y].val )
		{
		    uint a, b;
		    do
		    { a = rand() % 4; b = rand() % 4; }
		    while( board[a][b].val );
 
		    int s = rand() % 100;
		    if( s > 89 ) board[a][b].val = 4;
		    else board[a][b].val = 2;
		    if( canMove() ) return;
		}
	done = true;
    }
    bool canMove()
    {
	for( int y = 0; y < 4; y++ )
	    for( int x = 0; x < 4; x++ )
		if( !board[x][y].val ) return true;
 
	for( int y = 0; y < 4; y++ )
	    for( int x = 0; x < 4; x++ )
	    {
		if( testAdd( x + 1, y, board[x][y].val ) ) return true;
		if( testAdd( x - 1, y, board[x][y].val ) ) return true;
		if( testAdd( x, y + 1, board[x][y].val ) ) return true;
		if( testAdd( x, y - 1, board[x][y].val ) ) return true;
	    }
	return false;
    }
    bool testAdd( int x, int y, uint v )
    {
	if( x < 0 || x > 3 || y < 0 || y > 3 ) return false;
	return board[x][y].val == v;
    }
    void moveVert( int x, int y, int d )
    {
	if( board[x][y + d].val && board[x][y + d].val == board[x][y].val && !board[x][y].blocked && !board[x][y + d].blocked  )
	{
	    board[x][y].val = 0;
	    board[x][y + d].val *= 2;
	    score += board[x][y + d].val;
	    board[x][y + d].blocked = true;
	    moved = true;
	}
	else if( !board[x][y + d].val && board[x][y].val )
	{
	    board[x][y + d].val = board[x][y].val;
	    board[x][y].val = 0;
	    moved = true;
	}
	if( d > 0 ) { if( y + d < 3 ) moveVert( x, y + d,  1 ); }
	else        { if( y + d > 0 ) moveVert( x, y + d, -1 ); }
    }
    void moveHori( int x, int y, int d )
    {
	if( board[x + d][y].val && board[x + d][y].val == board[x][y].val && !board[x][y].blocked && !board[x + d][y].blocked  )
	{
	    board[x][y].val = 0;
	    board[x + d][y].val *= 2;
	    score += board[x + d][y].val;
	    board[x + d][y].blocked = true;
	    moved = true;
	}
	else if( !board[x + d][y].val && board[x][y].val )
	{
	    board[x + d][y].val = board[x][y].val;
	    board[x][y].val = 0;
	    moved = true;
	}
	if( d > 0 ) { if( x + d < 3 ) moveHori( x + d, y,  1 ); }
	else        { if( x + d > 0 ) moveHori( x + d, y, -1 ); }
    }
    void move( movDir d )
    {
	switch( d )
	{
	    case UP:
	    	for( int x = 0; x < 4; x++ )
		{
		    int y = 1;
		    while( y < 4 )
		    { if( board[x][y].val ) moveVert( x, y, -1 ); y++;}
		}
		break;
	    case DOWN:
		for( int x = 0; x < 4; x++ )
		{
		    int y = 2;
		    while( y >= 0 )
		    { if( board[x][y].val ) moveVert( x, y, 1 ); y--;}
		}
		break;
	    case LEFT:
		for( int y = 0; y < 4; y++ )
		{
		    int x = 1;
		    while( x < 4 )
		    { if( board[x][y].val ) moveHori( x, y, -1 ); x++;}
		}
		break;
	    case RIGHT:
		for( int y = 0; y < 4; y++ )
		{
		    int x = 2;
		    while( x >= 0 )
		    { if( board[x][y].val ) moveHori( x, y, 1 ); x--;}
		}
	}
    }
    tile board[4][4];
    bool win, done, moved;
    uint score;
};
int main( int argc, char* argv[] )
{
    srand( static_cast<uint>( time( NULL ) ) );
    g2048 g; g.loop();
    return system( strv );
}
 "
"#include <random>
#include <iostream>
#include <stack>
#include <set>
#include <string>
#include <functional>
using namespace std;
 
class RPNParse
{
public:
  stack<double> stk;
  multiset<int> digits;
 
  void op(function<double(double,double)> f)
  {
    if(stk.size() < 2)
      throw strv;
    int b = stk.top(); stk.pop();
    int a = stk.top(); stk.pop();
    stk.push(f(a, b));
  }
 
  void parse(char c)
  {
    if(c >= '0' && c <= '9')
    {
      stk.push(c - '0');
      digits.insert(c - '0');
    }
    else if(c == '+')
      op([](double a, double b) {return a+b;});
    else if(c == '-')
      op([](double a, double b) {return a-b;});
    else if(c == '*')
      op([](double a, double b) {return a*b;});
    else if(c == '/')
      op([](double a, double b) {return a/b;});
  }
 
  void parse(string s)
  {
    for(int i = 0; i < s.size(); ++i)
      parse(s[i]);
  }
 
  double getResult()
  {
    if(stk.size() != 1)
      throw strv;
    return stk.top();
  }
};
 
int main()
{
  random_device seed;
  mt19937 engine(seed());
  uniform_int_distribution<> distribution(1, 9);
  auto rnd = bind(distribution, engine);
 
  multiset<int> digits;
  cout << strv;
  for(int i = 0; i < 4; ++i)
  {
    int n = rnd();
    cout << strv << n;
    digits.insert(n);
  }
  cout << endl;
 
  RPNParse parser;
 
  try
  {
    string input;
    getline(cin, input);
    parser.parse(input);
 
    if(digits != parser.digits)
      cout << strv << endl;
    else
    {
      double r = parser.getResult();
      cout << strv << r << endl;
 
      if(r > 23.999 && r < 24.001)
        cout << strv << endl;
      else
        cout << strv << endl;
    }
  }
  catch(char* e)
  {
    cout << strv << e << endl;
  }
  return 0;
}"
" 
#include <time.h>
#include <vector>
#include <string>
#include <iostream>
class p15 {
public :
    void play() {
        bool p = true;
        std::string a;
        while( p ) {
            createBrd();
            while( !isDone() ) { drawBrd();getMove(); }
            drawBrd();
            std::cout << ""Congratulations!Play again (Y/N)?"";
            std::cin >> a; if( a != strv && a != strv ) break;
        }
    }
private:
    void createBrd() {
        int i = 1; std::vector<int> v;
        for( ; i < 16; i++ ) { brd[i - 1] = i; }
        brd[15] = 0; x = y = 3;
        for( i = 0; i < 1000; i++ ) {
            getCandidates( v );
            move( v[rand() % v.size()] );
            v.clear();
        }
    }
    void move( int d ) {
        int t = x + y * 4;
        switch( d ) {
            case 1: y--; break;
            case 2: x++; break;
            case 4: y++; break;
            case 8: x--;
        }
        brd[t] = brd[x + y * 4];
        brd[x + y * 4] = 0;
    }
    void getCandidates( std::vector<int>& v ) {
        if( x < 3 ) v.push_back( 2 ); if( x > 0 ) v.push_back( 8 );
        if( y < 3 ) v.push_back( 4 ); if( y > 0 ) v.push_back( 1 );
    }
    void drawBrd() {
        int r; std::cout << """";
        for( int y = 0; y < 4; y++ ) {
            std::cout << ""+----+----+----+----+"";
            for( int x = 0; x < 4; x++ ) {
                r = brd[x + y * 4];
                std::cout << strv;
                if( r < 10 ) std::cout << strv;
                if( !r ) std::cout << strv;
                else std::cout << r << strv;
            }
            std::cout << ""|"";
        }
        std::cout << ""+----+----+----+----+"";
    }
    void getMove() {
        std::vector<int> v; getCandidates( v );
        std::vector<int> p; getTiles( p, v ); unsigned int i;
        while( true ) {
            std::cout << ""Possible moves: "";
            for( i = 0; i < p.size(); i++ ) std::cout << p[i] << strv;
            int z; std::cin >> z;
            for( i = 0; i < p.size(); i++ )
                if( z == p[i] ) { move( v[i] ); return; }
        }
    }
    void getTiles( std::vector<int>& p, std::vector<int>& v ) {
        for( unsigned int t = 0; t < v.size(); t++ ) {
            int xx = x, yy = y;
            switch( v[t] ) {
                case 1: yy--; break;
                case 2: xx++; break;
                case 4: yy++; break;
                case 8: xx--;
            }
            p.push_back( brd[xx + yy * 4] );
        }
    }
    bool isDone() {
        for( int i = 0; i < 15; i++ ) {
            if( brd[i] != i + 1 ) return false;
        }
        return true;
    }
    int brd[16], x, y;
};
int main( int argc, char* argv[] ) {
    srand( ( unsigned )time( 0 ) );
    p15 p; p.play(); return 0;
}
 "
