code
"import React from react;import TimerMixin from react-timer-mixin;import {  ListView,  LayoutAnimation,  View,  Animated,  Dimensions,  PanResponder,  TouchableWithoutFeedback} from react-native;
let HEIGHT = Dimensions.get(window).height;var Row = React.createClass({  _data: {},  shouldComponentUpdate: function(props) {    if (props.hovering !== this.props.hovering) return true;    if (props.active !== this.props.active) return true;    if (props.rowData.data !== this.props.rowData.data) return true;    if (props.rowHasChanged) return props.rowHasChanged(props.rowData.data, this._data);    return false;  },  handleLongPress: function(e) {    this.refs.view.measure((frameX, frameY, frameWidth, frameHeight, pageX, pageY) => {      let layout = {frameX, frameY, frameWidth, frameHeight, pageX, pageY};      this.props.onRowActive({        layout: layout,        touch: e.nativeEvent,        rowData: this.props.rowData      });    });  },  componentDidUpdate: function(props) {    Take a shallow copy of the active data. So we can do manual comparisons of rows if needed.    if (props.rowHasChanged) {      this._data = (typeof props.rowData.data === object) ? Object.assign({}, props.rowData.data) : props.rowData.data;    }  },  measure: function() {    return this.refs.view.measure.apply(this, Array.from(arguments));  },  render: function() {    let layout = this.props.list.layoutMap[this.props.rowData.index];    let activeData = this.props.list.state.active;
    let activeIndex = activeData ? activeData.rowData.index : -5;    let shouldDisplayHovering = activeIndex !== this.props.rowData.index;    let Row = React.cloneElement(this.props.renderRow(this.props.rowData.data, this.props.rowData.section, this.props.rowData.index, null, this.props.active), {sortHandlers: {onLongPress: this.handleLongPress, onPressOut: this.props.list.cancel}, onLongPress: this.handleLongPress, onPressOut: this.props.list.cancel});    return <View onLayout={this.props.onRowLayout}                 style={[ this.props.active && !this.props.hovering ? {height: 0.01}:null,                          this.props.active && this.props.hovering ? {opacity: 0.0}: null,]} ref=view>          {this.props.hovering && shouldDisplayHovering ? this.props.activeDivider : null}          {Row}        </View>  }});
var SortRow = React.createClass({  getInitialState: function() {    let layout = this.props.list.state.active.layout;    let wrapperLayout = this.props.list.wrapperLayout;
    return {      style: {        position: absolute,        left: 0,        right: 0,        opacity: .2,        height: layout.frameHeight,        overflow: hidden,        backgroundColor: transparent,        marginTop: layout.pageY - wrapperLayout.pageY Account for top bar spacing      }    }  },  render: function() {    let handlers = this.props.panResponder.panHandlers;    return (      <Animated.View ref=view style={[this.state.style, this.props.sortRowStyle, this.props.list.state.pan.getLayout()]}>        {this.props.renderRow(this.props.rowData.data, this.props.rowData.section, this.props.rowData.index, null, true)}      </Animated.View>    );  }});
var SortableListView = React.createClass({  mixins: [TimerMixin],  getInitialState:function() {
    let currentPanValue = {x: 0, y: 0};
    this.state = {      ds: new ListView.DataSource({rowHasChanged: (r1, r2) => {        if (this.props.rowHasChanged) return this.props.rowHasChanged(r1, r2);        return false;      }}),      active: false,      hovering: false,      pan: new Animated.ValueXY(currentPanValue)    };    this.listener = this.state.pan.addListener(e => this.panY = e.y);    let onPanResponderMoveCb = Animated.event([null, {           dx: this.state.pan.x,  x,y are Animated.Value           dy: this.state.pan.y,      }]);
    this.state.panResponder = PanResponder.create({      onStartShouldSetPanResponder: (e) => true,      onMoveShouldSetPanResponderCapture: (e, a) => {        Only capture when moving vertically, this helps for child swiper rows.        let vy = Math.abs(a.vy);        let vx = Math.abs(a.vx);
        return (vy) > vx  && this.state.active;      },      onPanResponderMove: (evt, gestureState) => {        gestureState.dx = 0;        this.moveY = gestureState.moveY;        onPanResponderMoveCb(evt, gestureState);       },
       onPanResponderGrant: (e, gestureState) => {          this.moved = true;          this.props.onMoveStart &&  this.props.onMoveStart();          this.state.pan.setOffset(currentPanValue);          this.state.pan.setValue(currentPanValue);      },      onPanResponderRelease: (e) => {
        this.moved = false;        this.props.onMoveEnd && this.props.onMoveEnd();        if (!this.state.active) {          if (this.state.hovering) this.setState({hovering: false});          this.moveY = null;          return;        }        let itemHeight = this.state.active.layout.frameHeight;        let fromIndex = this.order.indexOf(this.state.active.rowData.index);        let toIndex = this.state.hovering === false ?  fromIndex : Number(this.state.hovering);        let up = toIndex > fromIndex;        if (up) {          toIndex--;        }        if (toIndex === fromIndex) return this.setState({active: false, hovering: false});        let args = {          row: this.state.active.rowData,          from: fromIndex,          to: toIndex        };
        this.props.onRowMoved && this.props.onRowMoved(args);        if (this.props._legacySupport) { rely on parent data changes to set state changes          LayoutAnimation.easeInEaseOut()          this.state.active = false;          this.state.hovering = false;        } else {          this.setState({            active: false,            hovering: false          });        }
        let MAX_HEIGHT = Math.max(0, this.scrollContainerHeight - this.listLayout.height + itemHeight);        if (this.scrollValue > MAX_HEIGHT) {          this.scrollResponder.scrollTo({y: MAX_HEIGHT});        }
        this.state.active = false;        this.state.hovering = false;        this.moveY = null;      }     });
    return this.state;  },  cancel: function() {    if (!this.moved) {      this.setState({        active: false,        hovering: false      });    }  },  componentDidMount: function() {    setTimeout(()=>{      this.scrollResponder = this.refs.list.getScrollResponder();    }, 1);  },  measureWrapper: function() {    if (this.refs.wrapper) {      this.refs.wrapper.measure((frameX, frameY, frameWidth, frameHeight, pageX, pageY) => {
        let layout = {frameX, frameY, frameWidth, frameHeight, pageX, pageY};        this.wrapperLayout = layout;      });    }  },  scrollValue: 0,  scrollContainerHeight: HEIGHT * 1.2, Gets calculated on scroll, but if you havent scrolled needs an initial value  scrollAnimation: function() {    if (this.isMounted() /* deprecated and unnecessary: using TimerMixin */ && this.state.active) {      if (this.moveY == undefined) return this.requestAnimationFrame(this.scrollAnimation);
      let SCROLL_OFFSET = this.wrapperLayout.pageY;      let moveY = this.moveY - SCROLL_OFFSET;      let SCROLL_LOWER_BOUND = 80;      let SCROLL_HIGHER_BOUND = this.listLayout.height - SCROLL_LOWER_BOUND;      let NORMAL_SCROLL_MAX = this.scrollContainerHeight - this.listLayout.height;      let MAX_SCROLL_VALUE = NORMAL_SCROLL_MAX + (this.state.active.layout.frameHeight * 2 );      let currentScrollValue = this.scrollValue;      let newScrollValue = null;      let SCROLL_MAX_CHANGE = 20;
      if (moveY < SCROLL_LOWER_BOUND && currentScrollValue > 0) {        let PERCENTAGE_CHANGE = 1 - (moveY / SCROLL_LOWER_BOUND);        newScrollValue = currentScrollValue - (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);        if (newScrollValue < 0) newScrollValue = 0;      }      if (moveY > SCROLL_HIGHER_BOUND && currentScrollValue < MAX_SCROLL_VALUE) {        let PERCENTAGE_CHANGE = 1 - ((this.listLayout.height - moveY) / SCROLL_LOWER_BOUND);        newScrollValue = currentScrollValue + (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);        if (newScrollValue > MAX_SCROLL_VALUE) newScrollValue = MAX_SCROLL_VALUE;      }      if (moveY < SCROLL_HIGHER_BOUND && currentScrollValue > NORMAL_SCROLL_MAX           && NORMAL_SCROLL_MAX > 0) {        let PERCENTAGE_CHANGE = 1 - ((this.listLayout.height - moveY) / SCROLL_LOWER_BOUND);        pc = PERCENTAGE_CHANGE;
        newScrollValue = currentScrollValue + (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);      }      if (newScrollValue !== null) {        this.scrollValue = newScrollValue;         this.scrollResponder.scrollWithoutAnimationTo(this.scrollValue, 0);         this.scrollResponder.scrollTo({y: this.scrollValue, x: 0, animated: false});      }      this.checkTargetElement();      this.requestAnimationFrame(this.scrollAnimation);    }  },  checkTargetElement() {    let SLOP = 1.0  assume rows will be > 1 pixel high    let scrollValue = this.scrollValue;
    let moveY = this.moveY - this.wrapperLayout.pageY;
    let activeRowY = scrollValue + moveY - this.firstRowY;
    let indexHeight = 0.0;    let i = 0;    let row;    let order = this.order;    let isLast = false;    while (indexHeight < activeRowY + SLOP) {      let key = order[i];      row = this.layoutMap[key];      if (!row) {        isLast = true;        break;      }      indexHeight += row.height;      i++;    }    if (!isLast) i--;        if (i != this.state.hovering && i >= 0) {      LayoutAnimation.easeInEaseOut();      this._previouslyHovering = this.state.hovering;      this.__activeY = this.panY;      this.setState({        hovering: String(i)      })    }
  },  firstRowY: undefined,  layoutMap: {},  _rowRefs: {},  handleRowActive: function(row) {    if (this.props.disableSorting) return;    this.state.pan.setValue({x: 0, y: 0});    LayoutAnimation.easeInEaseOut();    this.moveY = row.layout.pageY;    this.setState({      active: row,      hovering: row.rowData.index,    },  this.scrollAnimation);
  },  renderActiveDivider: function() {    let height = this.state.active ? this.state.active.layout.frameHeight : null    if (this.props.renderActiveDivider) return this.props.renderActiveDivider(height);    return <View style={{height: height}} />  },  renderRow: function(data, section, index, highlightfn, active) {
    let Component = active ? SortRow : Row;    let isActiveRow = (!active && this.state.active && this.state.active.rowData.index === index);    if (!active && isActiveRow) {      active = {active: true};    }    let hoveringIndex = this.order[this.state.hovering] || this.state.hovering;    return (<Component      {...this.props}      activeDivider={this.renderActiveDivider()}      key={index}      active={active}      list={this}      ref={view => { this._rowRefs[active ? ghost : index] = view; }}      hovering={hoveringIndex == index}      panResponder={this.state.panResponder}      rowData={{data, section, index}}      onRowActive={this.handleRowActive}      onRowLayout={layout => this._updateLayoutMap(index, layout.nativeEvent.layout)}      />);  },  _updateLayoutMap(index, layout) {      if (this.firstRowY === undefined || layout.y < this.firstRowY) {          this.firstRowY = layout.y;      }      this.layoutMap[index] = layout;  },  renderActive: function() {    if (!this.state.active) return;    let index = this.state.active.rowData.index;    return this.renderRow(this.props.data[index], s1, index, () => {}, {active: true, thumb: true});  },  componentWillMount: function() {    this.setOrder(this.props);  },  componentWillReceiveProps: function(props) {    this.setOrder(props);  },  setOrder: function(props) {    this.order = props.order || Object.keys(props.data) || [];  },  getScrollResponder: function() {    return this.scrollResponder;  },  render: function() {    let dataSource = this.state.ds.cloneWithRows(this.props.data, this.props.order);
    return <View ref=wrapper style={{flex: 1}} onLayout={()=>{this.measureWrapper()}}>      <ListView        enableEmptySections={true}        {...this.props}        {...this.state.panResponder.panHandlers}        ref=list        dataSource={dataSource}        onScroll={e => {          this.scrollValue = e.nativeEvent.contentOffset.y;          if (this.props.onScroll) this.props.onScroll(e);        }}        onContentSizeChange={(width, height) => {          this.scrollContainerHeight = height;        }}        onLayout={(e) => this.listLayout = e.nativeEvent.layout}        scrollEnabled={!this.state.active && (this.props.scrollEnabled !== false)}        renderRow={this.renderRow}      />      {this.renderActive()}    </View>  },  scrollTo: function(...args) {    this.scrollResponder.scrollTo.apply(this.scrollResponder, args);  }});
module.exports = SortableListView;"
"var path = require(path)var webpack = require(webpack)
module.exports = {  entry: ./demo/main.js,  output: {    path: path.resolve(__dirname, ./demo/dist),    publicPath: /demo/dist/,    filename: build.js  },  resolveLoader: {    root: path.join(__dirname, node_modules),  },  module: {    loaders: [      {        test: vue,        loader: vue      },      {        test: js,        loader: babel,        exclude: node_modules      },      {        test: json,        loader: json      },      {        test: html,        loader: vue-html      },      {        test: scss,        loaders: [style, css, sass]      },      {        test: (pngjpggifsvg),        loader: url,        query: {          limit: 10000,          name: [name].[ext]?[hash]        }      }    ]  },  devServer: {    historyApiFallback: true,    noInfo: true  },  devtool: eval-source-map}
if (process.env.NODE_ENV === production) {  module.exports.devtool = source-map   http://vuejs.github.io/vue-loader/workflow/production.html  module.exports.plugins = (module.exports.plugins || []).concat([    new webpack.DefinePlugin({      process.env: {        NODE_ENV: ""production""      }    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    }),    new webpack.optimize.OccurenceOrderPlugin()  ])}"
";(function () {
  var vSortable = {}  var Sortable = typeof require === function      ? require(sortablejs)      : window.Sortable
  if (!Sortable) {    throw new Error([vue-sortable] cannot locate Sortable.js.)  }
   exposed global options  vSortable.config = {}
  vSortable.install = function (Vue) {    Vue.directive(sortable, function (options) {      options = options || {}
      var sortable = new Sortable(this.el, options)
      if (this.arg && !this.vm.sortable) {        this.vm.sortable = {}      }
        Throw an error if the given ID is not unique      if (this.arg && this.vm.sortable[this.arg]) {        console.warn([vue-sortable] cannot set already defined sortable id:  + this.arg + )      } else if( this.arg ) {        this.vm.sortable[this.arg] = sortable      }    })  }
  if (typeof exports == object) {    module.exports = vSortable  } else if (typeof define == function && define.amd) {    define([], function () {      return vSortable    })  } else if (window.Vue) {    window.vSortable = vSortable    Vue.use(vSortable)  }
})()"
"module.exports = function(grunt){	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-uglify);	 grunt.loadNpmTasks('grunt-karma');
	grunt.initConfig({		uglify: {			target: {				files: {					src/angular-sortable-view.min.js: [src/angular-sortable-view.js]				}			},			options: {				banner: /*Copyright Kamil Pękala http://github.com/kamilkp +						angular-sortable-view v0.0.13 2015/01/13*/			}		},		jshint: {			all: [				src/angular-sortable-view.js,				Gruntfile.js			]		},		 karma: {		 	unit: {		 		configFile: 'karma.conf.js',		 		singleRun: true,		 	},		 	travis: {		 		configFile: 'karma.conf.js',		 		singleRun: true,		 		browsers: [		 			'Firefox'		 		]		 	}		 }	});
	grunt.registerTask(min, Minify javascript source code, uglify);	 grunt.registerTask('test', 'Run unit tests', ['jshint', 'min', 'karma:unit']);	 grunt.registerTask('default', ['test']);	 grunt.registerTask('travis', ['jshint', 'min', 'karma:travis']);};"
"/*! * Muuri v0.2.0 * https://github.com/haltu/muuri * Copyright (c) 2015, Haltu Oy * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the ""Software""), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */!function(t,e){var i=""Muuri"",n=""function""==typeof jQuery?jQuery.Velocity:t.Velocity,r=t.Hammer;t[i]=e(t,n,r)}(this,function(t,e,n,r){""use strict"";function o(){}function s(t){var e=this,i=[],n=!!t.fillGaps,r=!!t.horizontal,o=!!t.alignRight,a=!!t.alignBottom;if(e.width=Math.round(e.width),e.height=Math.round(e.height),r?(e.setWidth=!0,e.width=0):(e.setHeight=!0,e.height=0),e.items.length){for(var l=0;l<e.items.length;l++){var h=e.items[l],u=s.getSlot(e,i,h._width,h._height,!r,n);r?e.width=Math.max(e.width,u.left+u.width):e.height=Math.max(e.height,u.top+u.height),e.slots[h._id]=u}if(o||a)for(var f in e.slots){var u=e.slots[f];o&&(u.left=e.width-(u.left+u.width)),a&&(u.top=e.height-(u.top+u.height))}}}function a(e){var i=this,n=i._settings=m({},a.defaultSettings,e||{});if(!document.body.contains(n.container))throw new Error(""Container must be an existing DOM element"");i._element=n.container,y(n.container,n.containerClass),i._id=++k,i._animQueue=""muuri-""+i._id,i._emitter=new o,i._itemShow=""function""==typeof n.show?n.show():M(n.show,!0),i._itemHide=""function""==typeof n.hide?n.hide():M(n.hide),i._items=[];for(var r=0,s=n.items.length;r<s;r++)i._items[i._items.length]=new a.Item(i,n.items[r]);if(n.layoutOnResize||0===n.layoutOnResize){var l=d(function(){i.refresh(),i.layout()},n.layoutOnResize);i._resizeHandler=function(){l()},t.addEventListener(""resize"",i._resizeHandler)}n.layoutOnInit&&i.layout(!0)}function l(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function h(t,e,i){t.splice(i,0,t.splice(e,1)[0])}function u(t){for(var e=[],i=0,n=t.length;i<n;i++)e.indexOf(t[i])===-1&&(e[e.length]=t[i]);return e}function f(t){return""object""==typeof t&&""[object Object]""===Object.prototype.toString.call(t)}function m(t){for(var e=Array.prototype.slice.call(arguments,1),i=0;i<e.length;i++){var n=e[i];for(var r in n)n.hasOwnProperty(r)&&(f(t[r])&&f(n[r])?m(t[r],n[r]):t[r]=n[r])}return t}function d(e,i){var n,o=""cancel"",s=""finish"";return function(a){n!==r&&(n=t.clearTimeout(n),a===s&&e()),a!==o&&a!==s&&(n=t.setTimeout(function(){n=r,e()},i))}}function c(t,e){var i=null,n={left:t.left-e.left,right:e.left+e.width-(t.left+t.width),top:t.top-e.top,bottom:e.top+e.height-(t.top+t.height)},r=Math.max(t.width+Math.min(n.left,0)+Math.min(n.right,0),0),o=Math.max(t.height+Math.min(n.top,0)+Math.min(n.bottom,0),0),s=r>0&&o>0;return s&&(i={},i.width=r,i.height=o,i.left=t.left+Math.abs(Math.min(n.left,0)),i.right=i.left+i.width,i.top=t.top+Math.abs(Math.min(n.top,0)),i.bottom=i.top+i.height),i}function _(e,i){return t.getComputedStyle(e,null).getPropertyValue(i)}function g(t,e){for(var i in e)t.style[i]=e[i]}function p(t,i){for(var n in i)e.hook(t,n,i[n])}function v(t,e){return("" ""+t.className).indexOf("" ""+e)>-1}function y(t,e){t.classList?t.classList.add(e):v(t,e)&&(t.className+="" ""+e)}function w(t,e){t.classList?t.classList.remove(e):v(t,e)&&(t.className=("" ""+t.className+"" "").replace("" ""+e+"" "","" "").trim())}function C(e,i,n){var o=e.getBoundingClientRect()[i],s=""height""===i,a=s?""Height"":""Width"",l=""inner""+a,h=""client""+a,u=s?""top"":""left"",f=s?""bottom"":""right"";if(n){var m=parseFloat(_(e,""margin-""+u)),d=parseFloat(_(e,""margin-""+f));o+=m>0?m:0,o+=d>0?d:0}else{var c,g;e===document.documentElement?o-=t[l]-document.documentElement[h]:(c=parseFloat(_(e,""border-""+u+""-width"")),g=parseFloat(_(e,""border-""+f+""-width"")),o-=Math.round(o)-e[h]-c-g),o-=c!==r?c:parseFloat(_(e,""border-""+u+""-width"")),o-=g!==r?g:parseFloat(_(e,""border-""+f+""-width""))}return o}function b(e){var i=0,n=0,r=parseFloat(t.pageXOffset),o=parseFloat(t.pageYOffset);if(e.self===t.self)i=r,n=o;else if(e!==document){var s=e.getBoundingClientRect();i+=s.left+r+parseFloat(_(e,""border-left-width"")),n+=s.top+o+parseFloat(_(e,""border-top-width""))}return{left:i,top:n}}function D(e){var i=""fixed""===_(e,""position"");if(i&&rt)return t;var n=e===document.documentElement||e===t?document:e.parentElement||null;if(i){for(;n&&n!==document&&!x(n);)n=n.parentElement||document;return n===document?t:n}for(;n&&n!==document&&""static""===_(n,""position"")&&!x(n);)n=n.parentElement||document;return n}function x(t){var e=_(t,nt.style),i=_(t,""display"");return""none""!==e&&""inline""!==i&&""none""!==i}function S(t,e){var i=b(e),n=b(D(t)||doc);return n.left-=Math.abs(Math.min(parseFloat(_(t,""margin-left"")),0)),n.top-=Math.abs(Math.min(parseFloat(_(t,""margin-top"")),0)),{left:i.left-n.left,top:i.top-n.top}}function R(e){var i=[],n=/(auto|scroll)/,r=e.parentNode;if(rt){if(""fixed""===_(e,""position""))return i;for(;r&&r!==document&&r!==document.documentElement;)n.test(_(r,""overflow"")+_(r,""overflow-y"")+_(r,""overflow-x""))&&(i[i.length]=r),r=""fixed""===_(r,""position"")?null:r.parentNode;null!==r&&(i[i.length]=t)}else{for(;r&&r!==document;)""fixed""!==_(e,""position"")||x(r)?(n.test(_(r,""overflow"")+_(r,""overflow-y"")+_(r,""overflow-x""))&&(i[i.length]=r),e=r,r=r.parentNode):r=r.parentNode;i.length&&i[i.length-1]===document.documentElement&&(i[i.length-1]=t)}return i}function I(t,e){var i=c(t,e);if(!i)return 0;var n={width:t.width,height:t.height,left:0,top:0},r={width:e.width,height:e.height,left:0,top:0},o=c(n,r);return i.width*i.height/(o.width*o.height)*100}function O(t,e,i){return{type:t,event:e,currentLeft:i.left,currentTop:i.top,gridLeft:i.gridX,gridTop:i.gridY}}function X(t,e,i){this.isResolved||(this.isResolved=!0,i(t))}function Y(t){if(!t.elementStyles){var e=[""width"",""height"",""padding"",""margin""];t.elementStyles={};for(var i=0;i<4;i++){var n=e[i],r=t.element.style[n];t.elementStyles[n]=r||""""}for(var i=0;i<4;i++){var n=e[i];t.element.style[n]=_(t.element,n)}}}function L(t){if(t.elementStyles)for(var e in t.elementStyles)t.element.style[e]=t.elementStyles[e]}function E(t,e,i,n,r){i=t.get(i),r=""function""==typeof n?n:r;var o=i.length;if(o){var s=""show""===e,a=s?A:W,l=s?j:B,h=n===!0,u=[],f=!1,m=[];t._emitter.emit(a,i);for(var d=0,c=i.length;d<c;d++){var _=i[d];(s&&!_._active||!s&&_._active)&&(f=!0,s&&(_._noLayoutAnimation=!0,m[m.length]=_)),_[""_""+e](h,function(e,i){e||(u[u.length]=i),--o<1&&(""function""==typeof r&&r(u),t._emitter.emit(l,u))})}f&&(m.length&&t.refresh(m),t.layout())}else""function""==typeof r&&r(i)}function M(t,i){var n=t&&t.duration||0,r=t&&t.easing||""ease-out"";if(n){var o=i?{opacity:1,scale:1}:{opacity:0,scale:.5};return{start:function(t,i,s){i?p(t._child,o):(e(t._child,o,{duration:n,easing:r,queue:t._muuri._animQueue,complete:s}),e.Utilities.dequeue(t._child,t._muuri._animQueue))},stop:function(t){e(t._child,""stop"",t._muuri._animQueue)}}}return{start:P,stop:P}}function Q(t,e,i){for(var n=t.splice(0,t.length),r=0,o=n.length;r<o;r++)n[r](e,i)}if(!document.body)throw Error(""Muuri needs access to document.body to work."");var k=0,P=function(){},F=""function""==typeof t.requestAnimationFrame?t.requestAnimationFrame:null,H=""refresh"",N=""synchronize"",T=""layoutstart"",z=""layoutend"",A=""showstart"",j=""showend"",W=""hidestart"",B=""hideend"",q=""move"",V=""swap"",U=""add"",G=""remove"",Z=""dragstart"",J=""dragmove"",K=""dragscroll"",$=""dragend"",tt=""releasestart"",et=""releaseend"",it=""destroy"",nt=function(){for(var t=[""transform"",""WebkitTransform"",""MozTransform"",""OTransform"",""msTransform""],e=0;e<t.length;e++)if(document.documentElement.style[t[e]]!==r){var i=t[e],n=i.toLowerCase().split(""transform"")[0];return{prefix:n,prop:i,style:n?""-""+n+""-transform"":i}}return null}(),rt=function(){if(!nt)return!0;var t,e,i=document.body,n=document.createElement(""div""),r=document.createElement(""div"");return g(n,{display:""block"",visibility:""hidden"",position:""absolute"",width:""1px"",height:""1px"",left:""1px"",top:""0"",margin:""0""}),g(r,{display:""block"",position:""fixed"",width:""1px"",height:""1px"",left:""0"",top:""0"",margin:""0""}),n.appendChild(r),i.appendChild(n),t=r.getBoundingClientRect().left,n.style[nt.prop]=""translateZ(0)"",e=r.getBoundingClientRect().left,i.removeChild(n),e===t}();return o.prototype.on=function(t,e){var i=this._events=this._events||{},n=i[t]||[];return n[n.length]=e,i[t]=n,this},o.prototype.off=function(t,e){var n=this._events=this._events||{},r=n[t]||[],o=r.length;if(o)for(;o--;)e===r[i]&&r.splice(o,1);return this},o.prototype.emit=function(t,e,i,n){var r=this._events=this._events||{},o=r[t]||[],s=o.length;if(s){var a=arguments.length-1;o=o.concat();for(var l=0;l<s;l++)0===a?o[l]():1===a?o[l](e):2===a?o[l](e,i):o[l](e,i,n)}return this},s.getSlot=function(t,e,i,n,r,o){var a,l,h,u,f,m=e[0]||[],d=[],c={left:null,top:null,width:i,height:n};for(a=0;a<m.length;a++)if(h=m[a],c.width<=h.width&&c.height<=h.height){c.left=h.left,c.top=h.top;break}for(null===c.left&&(c.left=r?0:t.width,c.top=r?t.height:0,o||(f=!0)),r&&c.top+c.height>t.height&&(c.left>0&&(d[d.length]={left:0,top:t.height,width:c.left,height:1/0}),c.left+c.width<t.width&&(d[d.length]={left:c.left+c.width,top:t.height,width:t.width-c.left-c.width,height:1/0}),t.height=c.top+c.height),!r&&c.left+c.width>t.width&&(c.top>0&&(d[d.length]={left:t.width,top:0,width:1/0,height:c.top}),c.top+c.height<t.height&&(d[d.length]={left:t.width,top:c.top+c.height,width:1/0,height:t.height-c.top-c.height}),t.width=c.left+c.width),a=o?0:f?m.length:a;a<m.length;a++)for(u=s.splitRect(m[a],c),l=0;l<u.length;l++)h=u[l],h.width>0&&h.height>0&&(r&&h.top<t.height||!r&&h.left<t.width)&&(d[d.length]=h);return s.purgeSlots(d).sort(r?s.sortRectsTopLeft:s.sortRectsLeftTop),e[0]=d,c},s.sortRectsTopLeft=function(t,e){return t.top<e.top?-1:t.top>e.top?1:t.left<e.left?-1:t.left>e.left?1:0},s.sortRectsLeftTop=function(t,e){return t.left<e.left?-1:t.left>e.left?1:t.top<e.top?-1:t.top>e.top?1:0},s.isRectWithinRect=function(t,e){return t.left>=e.left&&t.top>=e.top&&t.left+t.width<=e.left+e.width&&t.top+t.height<=e.top+e.height},s.purgeSlots=function(t){for(var e=t.length;e--;)for(var i=t[e],n=t.length;n--;){var r=t[n];if(e!==n&&s.isRectWithinRect(i,r)){t.splice(e,1);break}}return t},s.splitRect=function(t,e){var i=[],n=!(e.left>t.left+t.width||e.left+e.width<t.left||e.top>t.top+t.height||e.top+e.height<t.top);return n?(t.left<e.left&&(i[i.length]={left:t.left,top:t.top,width:e.left-t.left,height:t.height}),t.left+t.width>e.left+e.width&&(i[i.length]={left:e.left+e.width,top:t.top,width:t.left+t.width-(e.left+e.width),height:t.height}),t.top<e.top&&(i[i.length]={left:t.left,top:t.top,width:t.width,height:e.top-t.top}),t.top+t.height>e.top+e.height&&(i[i.length]={left:t.left,top:e.top+e.height,width:t.width,height:t.top+t.height-(e.top+e.height)})):i[0]=t,i},a.prototype._getItem=function(t){if(t){if(t instanceof a.Item)return t._muuri===this?t:null;if(""number""==typeof t)return t=t>-1?t:this._items.length+t,this._items[t]||null;for(var e=null,i=0,n=this._items.length;i<n;i++){var r=this._items[i];if(r._element===t){e=r;break}}return e}return this._items[0]||null},a.prototype.on=function(t,e){return this._emitter.on(t,e),this},a.prototype.off=function(t,e){return this._emitter.off(t,e),this},a.prototype.refresh=function(t){t=t?this.get(t):this.get(""active"");for(var e=0,i=t.length;e<i;e++)t[e]._refresh();this._emitter.emit(H,t)},a.prototype.get=function(t,e){var i=t&&""string""!=typeof t;if(e=i?e:t,e=""string""==typeof e?e:null,t=i?[].concat(t):null,e||t){for(var n=t||this._items,r=[],o=""active""===e,s=""inactive""===e,a=0,l=n.length;a<l;a++){var h=i?this._getItem(n[a]):n[a];h&&(!e||o&&h._active||s&&!h._active)&&(r[r.length]=h)}return r}return this._items.concat()},a.prototype.add=function(t,e){var i=[],n=!1;t=[].concat(t);for(var r=0,o=this._items.length;r<o;r++){var s=this._items[r],e=t.indexOf(s._element);e>-1&&t.splice(e,1)}if(!t.length)return i;for(var r=0,o=t.length;r<o;r++){var s=new a.Item(this,t[r]);i[i.length]=s,s._active&&(n=!0,s._noLayoutAnimation=!0)}return e=e<0?this._items.length-e+1:e,this._items.splice.apply(this._items,[e,0].concat(i)),n&&this.layout(),this._emitter.emit(U,i),i},a.prototype.remove=function(t,e){var i=[],n=!1;t=this.get(t);for(var r=0,o=t.length;r<o;r++){var s=t[r];s._active&&(n=!0),i[i.length]=s._destroy(e)}return n&&this.layout(),this._emitter.emit(G,i),i},a.prototype.synchronize=function(){for(var t=0,e=this._items.length;t<e;t++){var i=this._items[t];i._element.parentNode===this._element&&this._element.appendChild(i._element)}this._emitter.emit(N)},a.prototype.layout=function(t,e){var i=this,n=i._emitter,e=""function""==typeof t?t:e,r=t===!0,o=new a.Layout(i),s=-1,l=o.items.length,h=[],u=function(t,i){t||(h[h.length]=i),++s===l&&(""function""==typeof e&&e(h,o),n.emit(z,h,o))};if(n.emit(T,o.items,o),o.setHeight&&g(i._element,{height:o.height+""px""}),o.setWidth&&g(i._element,{width:o.width+""px""}),l)for(var f=0,m=o.items.length;f<m;f++){var d=o.items[f],c=o.slots[d._id];d._left=c.left,d._top=c.top,d._drag.active?u(!1,d):d._layout(r,u)}else u(!0)},a.prototype.show=function(t,e,i){E(this,""show"",t,e,i)},a.prototype.hide=function(t,e,i){E(this,""hide"",t,e,i)},a.prototype.indexOf=function(t){if(""number""==typeof t)return t<=this._items.length-1?t:null;if(t instanceof a.Item){var e=this._items.indexOf(t);return e>-1?e:null}for(var e=null,i=0,n=this._items.length;i<n;i++)if(this._items[i]._element===t){e=i;break}return e},a.prototype.move=function(t,e){t=this._getItem(t),e=this._getItem(e),t&&e&&t!==e&&(h(this._items,this._items.indexOf(t),this._items.indexOf(e)),this._emitter.emit(q,t,e))},a.prototype.swap=function(t,e){t=this._getItem(t),e=this._getItem(e),t&&e&&t!==e&&(l(this._items,this._items.indexOf(t),this._items.indexOf(e)),this._emitter.emit(V,t,e))},a.prototype.destroy=function(){this._resizeHandler&&t.removeEventListener(""resize"",this._resizeHandler);for(var e=this._items.concat(),i=0,n=e.length;i<n;i++)e[i]._destroy();w(this._element,this._settings.containerClass),g(this._element,{height:""""}),this._emitter.emit(it);var r=this._emitter._events;if(r)for(var o=Object.keys(this._emitter._events),i=0,n=o.length;i<n;i++)r[o[i]].length=0;for(var s=Object.keys(this).concat(Object.keys(a.prototype)),i=0;i<s.length;i++)this[s[i]]=null},a.Item=function(t,e){if(e.contains(t._element))throw new Error(""Item element must not be a parent of the grid container element"");e.parentNode!==t._element&&t._element.appendChild(e);var i=t._settings,n=""none""===_(e,""display"");this._id=++k,this._muuri=t,this._element=e,this._child=e.children[0],y(e,i.itemClass),this._active=!n,this._positioning=!1,this._hidden=n,this._hiding=!1,this._showing=!1,this._visibiliyQueue=[],this._layoutQueue=[],p(this._element,{left:""0"",top:""0"",translateX:""0px"",translateY:""0px""}),y(e,n?i.hiddenClass:i.shownClass),p(this._child,{scale:n?0:1,opacity:n?0:1}),n||g(this._element,{display:""block""}),this._refresh(),this._left=0,this._top=0,this._drag={active:!1},this._release={active:!1},t._settings.dragEnabled&&this._initDrag()},a.Item.prototype.inspect=function(){return{element:this._element,width:this._width,height:this._height,left:this._left,top:this._top,active:this._active,positioning:this._positioning,dragging:this._drag.active,releasing:this._release.active,visibility:this._hiding?""hiding"":this._showing?""showing"":this._hidden?""hidden"":""shown""}},a.Item.prototype._initDrag=function(){var t=this,e=t._muuri._settings,i=t._hammer=new n.Manager(t._element);i.add(new n.Pan({event:""drag"",pointers:1,threshold:0,direction:n.DIRECTION_ALL})),i.add(new n.Press({event:""draginit"",pointers:1,threshold:100,time:0})),i.set({touchAction:""none""}),t._resetReleaseData();var r=t._drag;t._resetDragData(),r.checkOverlap=d(function(){r.active&&t._checkOverlap()},e.dragSortInterval);var o=!1;r.predicate=""function""==typeof e.dragPredicate?e.dragPredicate:X,r.predicateData={},r.isPredicateResolved=function(){return o},r.resolvePredicate=function(e){o||""draginitup""===e.type||""dragend""===e.type||""dragcancel""===e.type||(o=!0,t._onDragStart(e))},r.onScroll=function(e){F?F(function(){t._onDragScroll(e)}):t._onDragScroll(e)},i.on(""draginit"",function(e){r.predicateData={},o=!1,r.predicate.call(r.predicateData,e,t,r.resolvePredicate)}).on(""dragstart dragmove"",function(e){o&&r.active&&t._onDragMove(e),r.predicate.call(r.predicateData,e,t,r.resolvePredicate)}).on(""dragend dragcancel draginitup"",function(e){o&&r.active&&t._onDragEnd(e),r.predicate.call(r.predicateData,e,t,r.resolvePredicate)})},a.Item.prototype._resetDragData=function(){var t=this._drag;t.active=!1,t.start=null,t.move=null,t.element=null,t.elemWidth=0,t.elemHeight=0,t.elementStyles=null,t.scrollParents=[],t.left=0,t.top=0,t.gridX=0,t.gridY=0,t.elemClientX=0,t.elemClientY=0,t.containerDiffX=0,t.containerDiffY=0},a.Item.prototype._onDragStart=function(t){var i=this._drag,n=this._muuri._settings,r=this._release.active;if(this._active){this._positioning&&this._stopLayout(),r&&(i.elementStyles=this._release.elementStyles,w(this._element,n.releasingClass),this._resetReleaseData()),i.active=!0,i.start=t,i.move=t,i.element=this._element,i.elemWidth=this._width,i.elemHeight=this._height;var o=parseFloat(e.hook(i.element,""translateX""))||0,s=parseFloat(e.hook(i.element,""translateY""))||0,a=this._muuri._element,l=n.dragContainer;if(i.left=i.gridX=o,i.top=i.gridY=s,l&&l!==a)if(i.element.parentNode===l){var h=S(i.element,a);i.containerDiffX=h.left,i.containerDiffY=h.top,i.gridX=o-i.containerDiffX,i.gridY=s-i.containerDiffY}else{Y(i),l.appendChild(i.element);var h=S(i.element,a);i.containerDiffX=h.left,i.containerDiffY=h.top,i.left=o+i.containerDiffX,i.top=s+i.containerDiffY,p(i.element,{translateX:i.left+""px"",translateY:i.top+""px""})}var f=i.element.getBoundingClientRect();i.elemClientX=f.left,i.elemClientY=f.top,i.scrollParents=R(i.element),l&&l!==a&&(i.scrollParents=u(i.scrollParents.concat(R(a))));for(var m=0,d=i.scrollParents.length;m<d;m++)i.scrollParents[m].addEventListener(""scroll"",i.onScroll);y(i.element,n.draggingClass),this._muuri._emitter.emit(Z,this,O(""dragstart"",t,i))}},a.Item.prototype._onDragMove=function(t){var e=this._drag,i=this._muuri._settings;if(!this._active)return void this._resetDrag();var n=t.deltaX-e.move.deltaX,r=t.deltaY-e.move.deltaY;e.move=t,e.left+=n,e.top+=r,e.gridX+=n,e.gridY+=r,e.elemClientX+=n,e.elemClientY+=r,p(e.element,{translateX:e.left+""px"",translateY:e.top+""px""}),i.dragSort&&e.checkOverlap(),this._muuri._emitter.emit(J,this,O(""dragmove"",t,e))},a.Item.prototype._onDragScroll=function(t){var e=this._drag,i=this._muuri._settings,n=this._muuri._element,r=i.dragContainer,o=e.element.getBoundingClientRect(),s=e.elemClientX-o.left,a=e.elemClientY-o.top;if(r&&r!==n){var l=S(e.element,n);e.containerDiffX=l.left,e.containerDiffY=l.top}e.left+=s,e.top+=a,e.gridX=e.left-e.containerDiffX,e.gridY=e.top-e.containerDiffY,p(e.element,{translateX:e.left+""px"",translateY:e.top+""px""}),i.dragSort&&e.checkOverlap(),this._muuri._emitter.emit(K,this,O(""dragscroll"",t,e))},a.Item.prototype._onDragEnd=function(t){var e=this._drag,i=this._muuri._settings,n=this._release;if(!this._active)return void this._resetDrag();i.dragSort&&e.checkOverlap(""finish"");for(var r=0,o=e.scrollParents.length;r<o;r++)e.scrollParents[r].removeEventListener(""scroll"",e.onScroll);w(e.element,i.draggingClass),e.active=!1,this._muuri._emitter.emit($,this,O(""dragend"",t,e)),n.containerDiffX=e.containerDiffX,n.containerDiffY=e.containerDiffY,n.element=e.element,n.elementStyles=e.elementStyles,this._resetDragData(),this._startRelease()},a.Item.prototype._resetDrag=function(t){for(var e=this._drag,i=this._muuri._settings,n=0,r=e.scrollParents.length;n<r;n++)e.scrollParents[n].removeEventListener(""scroll"",e.onScroll);e.checkOverlap(""cancel""),w(e.element,i.draggingClass),L(e),this._resetDragData()},a.Item.prototype._resetReleaseData=function(){var t=this._release;t.active=!1,t.positioningStarted=!1,t.containerDiffX=0,t.containerDiffY=0,t.element=null,t.elementStyles=null},a.Item.prototype._startRelease=function(){var t=this._muuri._settings,e=this._release;e.active=!0,y(e.element,t.releasingClass),this._muuri._emitter.emit(tt,this),this._layout(!1)},a.Item.prototype._endRelease=function(){var t=this._muuri._settings,e=this._release;w(e.element,t.releasingClass),e.element.parentNode!==this._muuri._element&&(this._muuri._element.appendChild(e.element),p(e.element,{translateX:this._left+""px"",translateY:this._top+""px""})),L(e),this._resetReleaseData(),this._muuri._emitter.emit(et,this)},a.Item.prototype._checkOverlap=function(){for(var t=this._muuri._settings,e=t.dragSortTolerance,i=t.dragSortAction,n=this._muuri._items,r=null,o=0,s={width:this._drag.elemWidth,height:this._drag.elemHeight,left:this._drag.gridX,top:this._drag.gridY},a=0,u=n.length;a<u;a++){var f=n[a];if(f===this)o=a;else if(f._active){var m=I(s,{width:f._width,height:f._height,left:f._left,top:f._top});(!r||m>r.score)&&(r={item:f,score:m,index:a})}}r&&r.score>=e&&(""swap""===i?(l(n,o,r.index),this._muuri._emitter.emit(V,this,r.item)):(h(n,o,r.index),this._muuri._emitter.emit(q,this,r.item)),this._muuri.layout())},a.Item.prototype._stopLayout=function(){var t=this._muuri._settings;this._positioning&&(e(this._element,""stop"",this._muuri._animQueue),w(this._element,t.positioningClass),this._positioning=!1,Q(this._layoutQueue,!0,this))},a.Item.prototype._refresh=function(){this._hidden||(this._width=Math.round(C(this._element,""width"",!0)),this._height=Math.round(C(this._element,""height"",!0)))},a.Item.prototype._layout=function(t,i){var n=this,r=n._muuri._settings,o=n._release,s=o.active&&o.positioningStarted===!1,a=s?r.dragReleaseDuration:r.positionDuration,l=s?r.dragReleaseEasing:r.positionEasing,h=t!==!0&&!n._noLayoutAnimation&&a>0,u=n._positioning,f=function(){w(n._element,r.positioningClass),n._positioning=!1,o.active&&n._endRelease(),Q(n._layoutQueue,!1,n)};n._stopLayout(),""function""==typeof i&&(n._layoutQueue[n._layoutQueue.length]=i),s&&(o.positioningStarted=!0);var m=n._release.active?n._release.containerDiffX:0,d=n._release.active?n._release.containerDiffY:0;if(h){var c=(parseFloat(e.hook(n._element,""translateX""))||0)-m,_=(parseFloat(e.hook(n._element,""translateY""))||0)-d;if(n._left===c&&n._top===_)return void f();n._positioning=!0,u||y(n._element,r.positioningClass),e(n._element,{translateX:n._left+m,translateY:n._top+d},{duration:a,easing:l,complete:f,queue:n._muuri._animQueue}),e.Utilities.dequeue(n._element,n._muuri._animQueue)}else n._noLayoutAnimation&&(n._noLayoutAnimation=!1),p(n._element,{translateX:n._left+m+""px"",translateY:n._top+d+""px""}),f()},a.Item.prototype._show=function(t,e){var i=this,n=i._muuri._settings;if(i._hidden||i._showing)if(i._hidden){i._hiding;i._muuri._itemHide.stop(i),i._active=!0,i._hidden=!1,i._showing=i._hiding=!1,y(i._element,n.shownClass),w(i._element,n.hiddenClass),g(i._element,{display:""block""}),Q(i._visibiliyQueue,!0,i),i._showing=!0,""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e),i._muuri._itemShow.start(i,t,function(){Q(i._visibiliyQueue,!1,i)})}else""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e);else""function""==typeof e&&e(!1,i)},a.Item.prototype._hide=function(t,e){var i=this,n=i._muuri._settings;if(i._hidden&&!i._hiding)""function""==typeof e&&e(!1,i);else if(i._hidden)""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e);else{i._showing;i._muuri._itemShow.stop(i),i._active=!1,i._hidden=!0,i._showing=i._hiding=!1,y(i._element,n.hiddenClass),w(i._element,n.shownClass),Q(i._visibiliyQueue,!0,i),i._hiding=!0,""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e),i._muuri._itemHide.start(i,t,function(){g(i._element,{display:""none""}),Q(i._visibiliyQueue,!1,i)})}},a.Item.prototype._destroy=function(t){var e=(this._muuri,this._muuri._settings),i=this._element,n=this._muuri._items.indexOf(this);this._stopLayout(),this._muuri._itemShow.stop(this),this._muuri._itemHide.stop(this),this._release.active&&(i.parentNode!==this._muuri._element&&this._muuri._element.appendChild(i),this._resetReleaseData()),this._drag.active&&(i.parentNode!==this._muuri._element&&this._muuri._element.appendChild(i),this._resetDrag()),this._hammer&&this._hammer.destroy(),i.removeAttribute(""style""),this._child.removeAttribute(""style""),Q(this._visibiliyQueue,!0,this),w(i,e.positioningClass),w(i,e.draggingClass),w(i,e.releasingClass),w(i,e.itemClass),w(i,e.shownClass),w(i,e.hiddenClass),n>-1&&this._muuri._items.splice(n,1),t&&i.parentNode.removeChild(i);for(var r=Object.keys(this).concat(Object.keys(a.Item.prototype)),o=0;o<r.length;o++)this[r[o]]=null},a.Layout=function(t,e){var i=t._settings.layout;if(this.muuri=t,this.items=e?e.concat():t.get(""active""),this.slots={},this.width=0,this.height=0,this.setWidth=!1,this.setHeight=!1,this.width=C(t._element,""width""),this.height=C(t._element,""height""),""function""==typeof i)i.call(this);else{var n=""string""==typeof i,r=n?i:i[0];if(""function""!=typeof a.Layout.methods[r])throw new Error('Layout method ""'+method+'"" does not exist.');typeof a.Layout.methods[r].call(this,n?{}:i[1])}},a.Layout.methods={firstFit:s},a.defaultSettings={container:null,items:[],positionDuration:300,positionEasing:""ease-out"",show:{duration:300,easing:""ease-out""},hide:{duration:300,easing:""ease-out""},layout:""firstFit"",layoutOnResize:100,layoutOnInit:!0,dragEnabled:!1,dragContainer:null,dragPredicate:null,dragSort:!0,dragSortInterval:50,dragSortTolerance:50,dragSortAction:""move"",dragReleaseDuration:300,dragReleaseEasing:""ease-out"",containerClass:""muuri"",itemClass:""muuri-item"",shownClass:""muuri-shown"",hiddenClass:""muuri-hidden"",positioningClass:""muuri-positioning"",draggingClass:""muuri-dragging"",releasingClass:""muuri-releasing""},a});"
"module.exports = function (config) {    var configuration = {
         base path that will be used to resolve all patterns (eg. files, exclude)        basePath: ,

         frameworks to use         available frameworks: https://npmjs.org/browse/keyword/karma-adapter        frameworks: [jasmine],

         list of files / patterns to load in the browser        files: [            node_modules/jquery/dist/jquery.js,            node_modules/jasmine-jquery/lib/jasmine-jquery.js,            node_modules/jasmine2-custom-message/jasmine2-custom-message.js,            { pattern: Tests/*.html, included: true },            { pattern: Tests/*.js, included: true },            Scripts/moment.min.js,            Scripts/bootstrap-sortable.js        ],

         list of files to exclude        exclude: [        ],

         preprocess matching files before serving them to the browser         available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor        preprocessors: {        },

         test results reporter to use         possible values: 'dots', 'progress'         available reporters: https://npmjs.org/browse/keyword/karma-reporter        reporters: [mocha],

         enable / disable colors in the output (reporters and logs)        colors: true,

         level of logging         possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG        logLevel: config.LOG_INFO,

         enable / disable watching file and executing tests whenever any file changes        autoWatch: false,

         start these browsers         available browser launchers: https://npmjs.org/browse/keyword/karma-launcher        browsers: [PhantomJS],
         Continuous Integration mode         if true, Karma captures browsers, runs the tests and exits        singleRun: true    };
    config.set(configuration);}
"
"/** * Created by lijun on 2016/12/14. */var webpack = require(webpack)var path = require(path)var projectRoot = path.resolve(__dirname, ./)
module.exports = {  entry: ./docs/index.js,  output: {    path: ./build,    publicPath: build/,    filename: build-docs.js  },  resolve: {    root: path.resolve(./),    extensions: [, .js],    fallback: [path.join(__dirname, ../node_modules)],  },  resolveLoader: {    fallback: [path.join(__dirname, ../node_modules)]  },  module: {    preLoaders: [      {        test: js,        loader: eslint,        include: projectRoot,        exclude: node_modules      }    ],    loaders: [      {        test: js,        loader: babel,        include: projectRoot,        exclude: node_modules      },      { test: css, loader: style-loader!css-loader }    ]  },  eslint: {    formatter: require(eslint-friendly-formatter)  },  babel: {    presets: [      es2015,      stage-2    ],    plugins: [transform-runtime]  },  devtool: source-map};

if (process.env.NODE_ENV === production) {  delete module.exports.devtool;  module.exports.plugins = [    new webpack.DefinePlugin({      process.env: {        NODE_ENV: ""production""      }    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    })  ];}"
"/** * Created by lijun on 2016/12/14. */var config = require(./webpack.build.js)var webpack = require(webpack)

config.output.filename = config.output.filename.replace(js, .min.js)
delete config.devtool
config.plugins = [  new webpack.optimize.UglifyJsPlugin({    sourceMap: false,    drop_console: true,    compress: {      warnings: false    }  })]
module.exports = config"
"var path = require(path);var webpack = require(webpack);
module.exports = [{  entry: ./src/index.js,
  output: {    filename: ./lib/standalone/react-sortable.js,    libraryTarget: umd,    library: Sortable  },
  module: {    loaders: [{      test: js,      loader: babel,      include: [        path.join(__dirname, src)      ]    }]  },
  externals: {    react: React  }}, {  entry: ./src/index.js,
  output: {    filename: ./lib/standalone/react-sortable.min.js,    libraryTarget: umd,    library: Sortable  },
  module: {    loaders: [{      test: js,      loader: babel,      include: [        path.join(__dirname, src)      ]    }]  },
  externals: {    react: React  },
  plugins: [    new webpack.DefinePlugin({      process.env: {        NODE_ENV: JSON.stringify(production)      }    }),    new webpack.optimize.UglifyJsPlugin({      output: {        comments: false      },      compress: {        warnings: false      }    })  ]}];"
"use strict;
import React from react;import {  AppRegistry,} from react-native;
import Root from ./App/Root;AppRegistry.registerComponent(Sample, () => Root);"
"module.exports = function(grunt) {
     Project configuration.    grunt.initConfig({        pkg: grunt.file.readJSON(package.json),        concat: {            options: {                separator: ,                stripBanners: true,                banner: // <%= pkg.name %> <%= pkg.version %> | (c) <%= grunt.template.today(""yyyy"") %> Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license            },            dist: {                src: src/*.js,                dest: build/<%= pkg.name %>.js            }        },        uglify: {            options: {                stripBanners: true,                banner: // <%= pkg.name %> <%= pkg.version %> | (c) <%= grunt.template.today(""yyyy"") %> Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license            },            build: {                src: build/<%= pkg.name %>.js,                dest: build/<%= pkg.name %>.min.js            }        },        jshint: {            files: src/*.js,            options: {                ""-W030"": false,                force: true            }        },        watch: {            scripts: {                files: [src/*.*],                tasks: [default],                options: {                    nospawn: true                }            }        },        jasmine : {            src : src/*.js,            options : {                specs : spec/*.js,                vendor: ext/*.js,                template : require(grunt-template-jasmine-istanbul),                templateOptions: {                    coverage: reports/coverage.json,                    report: reports/coverage                }            }        }    });
    grunt.loadNpmTasks(grunt-contrib-concat);    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-watch);    grunt.loadNpmTasks(grunt-contrib-jshint);    grunt.loadNpmTasks(grunt-contrib-jasmine);
     Default task(s).    grunt.registerTask(default, [jshint, concat, uglify, jasmine]);
};"
"var assert = require(assert)var ulid = require(./)
describe(ulid, function() {
  describe(prng, function() {
    it(should produce a number, function() {      assert.strictEqual(false, isNaN(ulid.prng()))    })
    it(should be between 0 and 1, function() {      var num = ulid.prng()      assert(num > 0 && num < 1)    })
  })
  describe(encodeTime, function() {
    it(should return expected encoded result, function() {      assert.strictEqual(01ARYZ6S41, ulid.encodeTime(1469918176385, 10))    })
    it(should change length properly, function() {      assert.strictEqual(0001AS99AA60, ulid.encodeTime(1470264322240, 12))    })
    it(should truncate time if not enough length, function() {      assert.strictEqual(AS4Y1E11, ulid.encodeTime(1470118279201, 8))    })
    it(should throw if time greater than (2 ^ 48) - 1, function() {      assert.throws(() => ulid.encodeTime(Math.pow(2, 48), 8), Error)    })
  })
  describe(encodeRandom, function() {
    it(should return correct length, function() {      assert.strictEqual(12, ulid.encodeRandom(12).length)    })
  })
  describe(ulid, function() {
    it(should return correct length, function() {      assert.strictEqual(26, ulid().length)    })
    it(should return expected encoded time component result, function() {      assert.strictEqual(01ARYZ6S41, ulid(1469918176385).substring(0, 10))    })
    it(should throw an error if seed is not a number, function() {      assert.throws(() => ulid(test), Error)    })
  })
})"
"(function(c){c.fn.stupidtable=function(b){return this.each(function(){var a=c(this);b=b||{};b=c.extend({},c.fn.stupidtable.default_sort_fns,b);a.data(sortFns,b);a.on(click.stupidtable,thead th,function(){c(this).stupidsort()})})};c.fn.stupidsort=function(b){var a=c(this),g=0,f=c.fn.stupidtable.dir,e=a.closest(table),k=a.data(sort)||null;if(null!==k){a.parents(tr).find(th).slice(0,c(this).index()).each(function(){var a=c(this).attr(colspan)||1;g+=parseInt(a,10)});var d;1==arguments.length?d=b:(d=b||a.data(sort-default)||f.ASC,a.data(sort-dir)&&(d=a.data(sort-dir)===f.ASC?f.DESC:f.ASC));if(a.data(sort-dir)!==d)return a.data(sort-dir,d),e.trigger(beforetablesort,{column:g,direction:d}),e.css(display),setTimeout(function(){var b=[],l=e.data(sortFns)[k],h=e.children(tbody).children(tr);h.each(function(a,d){var e=c(d).children().eq(g),f=e.data(sort-value);undefined===typeof f&&(f=e.text(),e.data(sort-value,f));b.push([f,d])});b.sort(function(a,b){return l(a[0],b[0])});d!=f.ASC&&b.reverse();h=c.map(b,function(a){return a[1]});e.children(tbody).append(h);e.find(th).data(sort-dir,null).removeClass(sorting-desc sorting-asc);a.data(sort-dir,d).addClass(sorting-+d);e.trigger(aftertablesort,{column:g,direction:d});e.css(display)},10),a}};c.fn.updateSortVal=function(b){var a=c(this);a.is([data-sort-value])&&a.attr(data-sort-value,b);a.data(sort-value,b);return a};c.fn.stupidtable.dir={ASC:asc,DESC:desc};c.fn.stupidtable.default_sort_fns={:function(b,a){return parseInt(b,10)-parseInt(a,10)},:function(b,a){return parseFloat(b)-parseFloat(a)},string:function(b,a){return b.toString().localeCompare(a.toString())},:function(b,a){b=b.toString().toLocaleLowerCase();a=a.toString().toLocaleLowerCase();return b.localeCompare(a)}}})(jQuery);"
module.exports = require(./lib/AbsoluteGrid.jsx);
"import path from path;import webpack from webpack;import autoprefixer from autoprefixer;import packageObj from ./package.json;
 Get the external packages used by the projectconst externals = {};[ dependencies, peerDependencies ].forEach(depGroup => {    if (packageObj[depGroup]) {        Object.keys(packageObj[depGroup]).forEach(dep => {            externals[dep] = dep;        });    }});
module.exports = {    entry: {        react-sortable-tree: ./src/index,    },    output: {        path: path.join(__dirname, dist, umd),        filename: [name].js,        libraryTarget: umd,        library: ReactSortableTree,    },    resolve: {        extensions: [, .js]    },    devtool: source-map,    plugins: [        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.optimize.OccurenceOrderPlugin(),        new webpack.optimize.UglifyJsPlugin({            compress: {                warnings: false            },            mangle: false,            beautify: true,            comments: true,        }),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    externals,    module: {        loaders: [            {                test: jsx,                loaders: [babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },        ]    }};"
"module.exports = function( grunt ) {	use strict;
	require(load-grunt-tasks)(grunt);
	var banner = /* https://github.com/micmro/performance-bookmarklet by Michael Mrowetz @MicMro   build:<%= grunt.template.today(dd/mm/yyyy) %> */;
	grunt.initConfig({		copy : {			distBookmarklet: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:chromeExtensionfirefoxAddon)js);					},					ext: .js				}]			},			distFirefoxAddon: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:bookmarkletchromeExtension)js);					},					ext: .js				}]			},			distChromeExtension: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:bookmarkletfirefoxAddon)js);					},					ext: .js				}]			}		},		babel: {			options: {				returnUsedHelpers: true			},			dist: {				files: [{					expand: true,					cwd: dist/tempCollect,					src: [**/*.js],					dest: dist/tempEs5,					ext: .js				}]			}		},		browserify: {			options: {				banner: banner			},			distBookmarklet: {				files: {					dist/performanceBookmarklet.js: [dist/tempEs5/**/*.js],				}			},			distFirefoxAddon: {				files: {					dist/performanceBookmarklet.ff.js: [dist/tempEs5/**/*.js],				}			},			distChromeExtension: {				files: {					dist/performanceBookmarklet.chrome.js: [dist/tempEs5/**/*.js],				}			}		},		uglify : {			options: {				compress: {					global_defs: {						DEBUG: false					},					dead_code: true				},				banner: banner			},			distBookmarklet: {				files: {					dist/performanceBookmarklet.min.js: [dist/performanceBookmarklet.js]				}			},			distFirefoxAddon: {				files: {					dist/performanceBookmarklet.ff.min.js: [dist/performanceBookmarklet.ff.js]				}			},			distChromeExtension: {				files: {					dist/performanceBookmarklet.chrome.min.js: [dist/performanceBookmarklet.chrome.js]				}			}		},		watch: {			babelBookmarklet: {				files: [src/**/*, Gruntfile.js],				tasks: [distBookmarklet],				options: {					spawn: false,					interrupt: true				},			},			babelFirefoxAddon: {				files: [src/**/*, Gruntfile.js],				tasks: [distFirefoxAddon],				options: {					spawn: false,					interrupt: true				},			},			babelChromeExtension: {				files: [src/**/*, Gruntfile.js],				tasks: [distChromeExtension],				options: {					spawn: false,					interrupt: true				},			},		}	});

	transform CSS file to JS variable	grunt.registerTask(inlineCssToJs, function() {		var cssFile = src/style.css;		var cssFileDestination = dist/tempCollect/helpers/style.js;		var varName = style;
		var cssContent = grunt.file.read(cssFile);
		clean CSS content		cssContent = cssContent.replace( (?:(?!))g, ).replace(g,  ).replace(g,  ).replace(g,);
		make JS Var and export as module		cssContent = export const  + varName +  =  + cssContent.trim() + ;;
		grunt.log.writeln(cssFile +  transformed to  + cssFileDestination);
		grunt.file.write(cssFileDestination, cssContent);	});
	grunt.registerTask(distBookmarklet, [inlineCssToJs, copy:distBookmarklet, babel, browserify:distBookmarklet, uglify:distBookmarklet]);	grunt.registerTask(distFirefoxAddon, [inlineCssToJs, copy:distFirefoxAddon, babel, browserify:distFirefoxAddon, uglify:distFirefoxAddon]);	grunt.registerTask(distChromeExtension, [inlineCssToJs, copy:distChromeExtension, babel, browserify:distChromeExtension, uglify:distChromeExtension]);	grunt.registerTask(distAll, [distBookmarklet, distFirefoxAddon, distChromeExtension]);
	grunt.registerTask(watchDistBookmarklet, [distBookmarklet, watch:babelBookmarklet]);	grunt.registerTask(watchDistFirefoxAddon, [distFirefoxAddon, watch:babelFirefoxAddon]);	grunt.registerTask(watchDistChromeExtension, [distChromeExtension, watch:babelChromeExtension]);


	grunt.registerTask(default, [watchDistBookmarklet]);};"
"use strict/* ---------- *//* setup */var gulp = require(gulp)var rename = require(gulp-rename)var uglify = require(gulp-uglify)var sourcemaps = require(gulp-sourcemaps)var umd = require(gulp-umd)var strip = require(gulp-strip-code)
/* ---------- *//* convert to umd */gulp.task(umd, function () {  return gulp.src(src/html.sortable.js)    .pipe(strip({       jscs:disable      start_comment: start-testing,      end_comment: end-testing       jscs:enable    }))    .pipe(umd({      exports: function () {        return sortable      },      namespace: function () {        return sortable      }    }))    .pipe(gulp.dest(dist/))})/* ---------- *//* build */gulp.task(minify, [umd], function () {   copy files to dist  gulp.src([dist/html.sortable.js])    .pipe(sourcemaps.init({loadMaps: true}))    .pipe(uglify())    .pipe(rename({      suffix: .min    }))    .pipe(sourcemaps.write(./))    .pipe(gulp.dest(./dist))    .pipe(gulp.dest(./docs))})/* ---------- *//* tasks */gulp.task(default, [umd, minify])"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: eval,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        preLoaders: [            {                test: jsx,                loader: eslint-loader,                include: path.join(__dirname, src)            },        ],        loaders: [            {                test: jsx,                loaders: [react-hot, babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },            { test: json, loader: json },  For the cheerio dependency of enzyme        ],    },    externals: {  All of these are for enzyme        react/addons: true,        react/lib/ExecutionEnvironment: true,        react/lib/ReactContext: true,    },    devServer: {        contentBase: build,        port: 3001    },};"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: source-map,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.NoErrorsPlugin(),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        loaders: [            {                test: jsx,                loaders: [react-hot, babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },        ],    },    devServer: {        contentBase: build,        port: 3001,        stats: {            chunks: false,            hash: false,            version: false,            assets: false,            children: false,        },    },};"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: source-map,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html,        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.optimize.UglifyJsPlugin({            compress: {                warnings: false            },        }),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        loaders: [            {                test: jsx,                loaders: [babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },        ],    }};"
require(babel-core/register);module.exports = require(./karma.conf.babel).default;
"import KarmaJasmine from karma-jasmine;import KarmaWebpack from karma-webpack;import KarmaJasmineDiffReporter from karma-jasmine-diff-reporter;import KarmaJasmineHtmlReporter from karma-jasmine-html-reporter;import KarmaNotifyReporter from karma-notify-reporter;import KarmaSourcemapLoader from karma-sourcemap-loader;import KarmaPhantomjsLauncher from karma-phantomjs-launcher;import webpackConfig from ./webpack.config.test.babel;
export default function setConfig(config) {    config.set({        browsers: [PhantomJS],        frameworks: [jasmine],        files: [src/tests.js],        preprocessors: {            src/tests.js: [webpack, sourcemap]        },        plugins: [            KarmaJasmine,            KarmaWebpack,            KarmaJasmineDiffReporter,            KarmaJasmineHtmlReporter,            KarmaNotifyReporter,            KarmaSourcemapLoader,            KarmaPhantomjsLauncher,        ],        reporters: [            jasmine-diff,            progress,            kjhtml,            notify,        ],        jasmineDiffReporter: {            pretty: 4,            json: true,            multiline: {                before: 2,  2 newlines                after:  2,  2 newlines                indent: 4,  4 spaces            },            color: {                actualFg: red,                expectedFg: green,                actualBg: inverse,                expectedBg: inverse,                actualWhitespaceBg: ,                expectedWhitespaceBg: ,            },        },        webpack: webpackConfig,        webpackMiddleware: {            stats: {                chunks: false,                hash: false,                version: false,                assets: false,                children: false,            },        },        notifyReporter: {            reportEachFailure: false,  Default: false, Will notify on every failed spec            reportSuccess: false,  Default: true, Will notify when a suite was successful        },    });}"
"use strict;
import React from react;import ReactDOM from react-dom; import Perf from 'react-addons-perf';import createAbsoluteGrid from ./index.js;import SampleDisplay from ./demo/SampleDisplay.jsx;import * as data from ./demo/sampleData.js;import * as _ from lodash;
demo();
/** * This demo is meant to show you all of the things that are possible with ReactAbsoluteGrid * If implemented in a Flux project, the grid would be in a render method with the * event handlers calling Actions which would update a Store. For the sake of brevity, * the ""store"" is implemented locally and the changes re-rendered manually * * TODO: implement inside a react component rather than doing this all manually **/
function demo() {
  let sampleItems = data.screens;  let render;  let zoom = 0.7;
  We set a property on each item to let the grid know not to show it  var onFilter = function(event){    var search = new RegExp(event.target.value, i);    sampleItems = sampleItems.map(function(item){      const isMatched = !item.name.match(search);      if(!item.filtered || isMatched !== item.filtered) {        return {          ...item,          filtered: isMatched        }      }      return item;    });    render();  };
  Change the item's sort order  var onMove = function(source, target){    source = _.find(sampleItems, {key: parseInt(source, 10)});    target = _.find(sampleItems, {key: parseInt(target, 10)});
    const targetSort = target.sort;
    CAREFUL, For maximum performance we must maintain the array's order, but change sort    sampleItems = sampleItems.map(function(item){      Decrement sorts between positions when target is greater      if(item.key === source.key) {        return {          ...item,          sort: targetSort        }      } else if(target.sort > source.sort && (item.sort <= target.sort && item.sort > source.sort)){        return {          ...item,          sort: item.sort - 1        };      Increment sorts between positions when source is greater      } else if (item.sort >= target.sort && item.sort < source.sort){        return {          ...item,          sort: item.sort + 1        };      }      return item;    });    Perf.start();    render();    Perf.stop();    Perf.printWasted();  };
  var onMoveDebounced = _.debounce(onMove, 40);
  var unMountTest = function(){    if(ReactDOM.unmountComponentAtNode(document.getElementById(Demo))){      ReactDOM.render(<button onClick={unMountTest}>Remount</button>, document.getElementById(UnmountButton));    }else{      render();      ReactDOM.render(<button onClick={unMountTest}>Test Unmount</button>, document.getElementById(UnmountButton));    }  };
  const AbsoluteGrid = createAbsoluteGrid(SampleDisplay);  render = function(){    ReactDOM.render(<AbsoluteGrid items={sampleItems}                               onMove={onMoveDebounced}                               dragEnabled={true}                               zoom={zoom}                               responsive={true}                               verticalMargin={42}                               itemWidth={230}                               itemHeight={409}/>, document.getElementById(Demo));  };
  var renderDebounced = _.debounce(render, 150);
  Update the zoom value  var onZoom = function(event){    zoom = parseFloat(event.target.value);    renderDebounced();  };
  ReactDOM.render(<input onChange={onZoom} type=range min=0.3 max=1.5 step=0.1 defaultValue={zoom}/>, document.getElementById(Zoom));  ReactDOM.render(<input placeholder=Filter eg: calendar onChange={onFilter} type=text/>, document.getElementById(Filter));  ReactDOM.render(<button onClick={unMountTest}>Test Unmount</button>, document.getElementById(UnmountButton));  render();}"
" Stupid jQuery table plugin.
(function($) {  $.fn.stupidtable = function(sortFns) {    return this.each(function() {      var $table = $(this);      sortFns = sortFns || {};      sortFns = $.extend({}, $.fn.stupidtable.default_sort_fns, sortFns);      $table.data(sortFns, sortFns);
      $table.on(click.stupidtable, thead th, function() {          $(this).stupidsort();      });    });  };

   Expects $(""#mytable"").stupidtable() to have already been called.   Call on a table header.  $.fn.stupidsort = function(force_direction){    var $this_th = $(this);    var th_index = 0;  we'll increment this soon    var dir = $.fn.stupidtable.dir;    var $table = $this_th.closest(table);    var datatype = $this_th.data(sort) || null;
     No datatype? Nothing to do.    if (datatype === null) {      return;    }
     Account for colspans    $this_th.parents(tr).find(th).slice(0, $(this).index()).each(function() {      var cols = $(this).attr(colspan) || 1;      th_index += parseInt(cols,10);    });
    var sort_dir;    if(arguments.length == 1){        sort_dir = force_direction;    }    else{        sort_dir = force_direction || $this_th.data(sort-default) || dir.ASC;        if ($this_th.data(sort-dir))           sort_dir = $this_th.data(sort-dir) === dir.ASC ? dir.DESC : dir.ASC;    }
     Bail if already sorted in this direction    if ($this_th.data(sort-dir) === sort_dir) {      return;    }     Go ahead and set sort-dir.  If immediately subsequent calls have same sort-dir they will bail    $this_th.data(sort-dir, sort_dir);
    $table.trigger(beforetablesort, {column: th_index, direction: sort_dir});
     More reliable method of forcing a redraw    $table.css(display);
     Run sorting asynchronously on a timout to force browser redraw after     `beforetablesort` callback. Also avoids locking up the browser too much.    setTimeout(function() {       Gather the elements for this column      var column = [];      var sortFns = $table.data(sortFns);      var sortMethod = sortFns[datatype];      var trs = $table.children(tbody).children(tr);
       Extract the data for the column that needs to be sorted and pair it up       with the TR itself into a tuple. This way sorting the values will       incidentally sort the trs.      trs.each(function(index,tr) {        var $e = $(tr).children().eq(th_index);        var sort_val = $e.data(sort-value);
         Store and read from the .data cache for display text only sorts         instead of looking through the DOM every time        if(typeof(sort_val) === undefined){          var txt = $e.text();          $e.data(sort-value, txt);          sort_val = txt;        }        column.push([sort_val, tr]);      });
       Sort by the data-order-by value      column.sort(function(a, b) { return sortMethod(a[0], b[0]); });      if (sort_dir != dir.ASC)        column.reverse();
       Replace the content of tbody with the sorted rows. Strangely       enough, .append accomplishes this for us.      trs = $.map(column, function(kv) { return kv[1]; });      $table.children(tbody).append(trs);
       Reset siblings      $table.find(th).data(sort-dir, null).removeClass(sorting-desc sorting-asc);      $this_th.data(sort-dir, sort_dir).addClass(sorting-+sort_dir);
      $table.trigger(aftertablesort, {column: th_index, direction: sort_dir});      $table.css(display);    }, 10);
    return $this_th;  };
   Call on a sortable td to update its value in the sort. This should be the   only mechanism used to update a cell's sort value. If your display value is   different from your sort value, use jQuery's .text() or .html() to update   the td contents, Assumes stupidtable has already been called for the table.  $.fn.updateSortVal = function(new_sort_val){  var $this_td = $(this);    if($this_td.is([data-sort-value])){       For visual consistency with the .data cache      $this_td.attr(data-sort-value, new_sort_val);    }    $this_td.data(sort-value, new_sort_val);    return $this_td;  };
   ------------------------------------------------------------------   Default settings   ------------------------------------------------------------------  $.fn.stupidtable.dir = {ASC: asc, DESC: desc};  $.fn.stupidtable.default_sort_fns = {    : function(a, b) {      return parseInt(a, 10) - parseInt(b, 10);    },    : function(a, b) {      return parseFloat(a) - parseFloat(b);    },    : function(a, b) {      return a.toString().localeCompare(b.toString());    },    : function(a, b) {      a = a.toString().toLocaleLowerCase();      b = b.toString().toLocaleLowerCase();      return a.localeCompare(b);    }  };})(jQuery);"
"var ulid = require(./)
suite(ulid, function() {
  set(iterations, 100000);
  bench(encodeTime, function() {    ulid.encodeTime()  })
  bench(encodeRandom, function() {    ulid.encodeRandom()  })
  bench(generate, function() {    ulid()  })
})"
"use strict;
function factory(prng) {
   Crockford's Base32   https://en.wikipedia.org/wiki/Base32  var ENCODING = 0123456789ABCDEFGHJKMNPQRSTVWXYZ  var ENCODING_LEN = ENCODING.length  var TIME_MAX = 281474976710655  var TIME_LEN = 10  var RANDOM_LEN = 16
  function encodeTime(time, len) {    if (time > TIME_MAX) {      throw new Error(cannot encode time greater than  + TIME_MAX)    }    var mod    var time    var str =     for (var x = len; x > 0; x--) {      mod = time % ENCODING_LEN      str = ENCODING.charAt(mod) + str      time = (time - mod) / ENCODING_LEN    }    return str  }
  function encodeRandom(len) {    var rand    var str =     for (var x = 0; x < len; x++) {      rand = Math.floor(ENCODING_LEN * prng())      str = ENCODING.charAt(rand) + str    }    return str  }
  function ulid(seedTime) {    if(!seedTime) {      seedTime = Date.now();    } else if(isNaN(seedTime) || typeof seedTime !== number) {      throw new Error(seedTime +  must be a number);    }        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN)  }
  ulid.prng = prng  ulid.encodeTime = encodeTime  ulid.encodeRandom = encodeRandom
  return ulid
}
/* istanbul ignore next */function _prng(root) {
  if (root) {    try {      var crypto = root.crypto || root.msCrypto      return function() {        return crypto.getRandomValues(new Uint16Array(1))[0] / 0xFFFF      }    }    catch (e) {}  }  else {    try {      var crypto = require(crypto)      return function() {        return crypto.randomBytes(2).readUInt16LE() / 0xFFFF      }    }    catch (e) {}  }
  if (typeof prng !== function) {    if (typeof console !== undefined && console.warn) {      console.warn([ulid] crypto not usable, falling back to insecure Math.random());    }    return function() {      return Math.random()    }  }
}
/* istanbul ignore next */(function(root, fn) {
  var prng = _prng(root)  var ulid = fn(prng)
  if ((undefined !== typeof module) && module.exports) {    module.exports = ulid  }  else if (typeof define === function && define.amd) {    define(function() {      return ulid    })  }  else {    root.ulid = ulid  }
})(typeof window !== undefined ? window : null, factory)"
"use strict;
import React from react;import {  AppRegistry,} from react-native;
import Root from ./App/Root;AppRegistry.registerComponent(Sample, () => Root);"
"/** * Created by lijun on 2016/12/14. */var config = require(./webpack.config.js)
config.entry = {  table-dragger: ./src/index.js,}
config.output = {  filename: ./dist/[name].js,  library: tableDragger,  libraryTarget: umd}
module.exports = config"
"module.exports = {  root: true,  parser: babel-eslint,  parserOptions: {    sourceType: module  },  extends: airbnb-base,  env: {    browser: true,    node: true  },  plugins: [    html  ],   add your custom rules here  rules: {    no-use-before-define: [error, { functions: false, classes: false }],    import/extensions: [error, always, {      js: never,      vue: never    }],    no-nested-ternary: 0,    space-before-function-paren: 0,    no-underscore-dangle: [error, { allowAfterThis: true }],     allow debugger during development    no-debugger: process.env.NODE_ENV === production ? 2 : 0  }}"
"/*! * Muuri v0.2.0 * https://github.com/haltu/muuri * Copyright (c) 2015, Haltu Oy * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the ""Software""), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */
(function (global, factory) {
  var libName = Muuri;  var depVelocity = typeof jQuery === function ? jQuery.Velocity : global.Velocity;  var depHammer = global.Hammer;
  global[libName] = factory(global, depVelocity, depHammer);
}(this, function (global, Velocity, Hammer, undefined) {
  use strict;
   Document body needs to be ready for tests.  if (!document.body) {    throw Error(Muuri needs access to document.body to work.);  }
  var uuid = 0;  var noop = function () {};  var raf = typeof global.requestAnimationFrame === function ? global.requestAnimationFrame : null;
   Event names.  var evRefresh = refresh;  var evSynchronize = synchronize;  var evLayoutStart = layoutstart;  var evLayoutEnd = layoutend;  var evShowStart = showstart;  var evShowEnd = showend;  var evHideStart = hidestart;  var evHideEnd = hideend;  var evMove = move;  var evSwap = swap;  var evAdd = add;  var evRemove = remove;  var evDragStart = dragstart;  var evDragMove = dragmove;  var evDragScroll = dragscroll;  var evDragEnd = dragend;  var evReleaseStart = releasestart;  var evReleaseEnd = releaseend;  var evDestroy = destroy;
   Get the primary supported transform property.  var supportedTransform = (function () {    var all = [transform, WebkitTransform, MozTransform, OTransform, msTransform];    for (var i = 0; i < all.length; i++) {      if (document.documentElement.style[all[i]] !== undefined) {        var prop = all[i];        var prefix = prop.toLowerCase().split(transform)[0];        return {          prefix: prefix,          prop: prop,          style: prefix ? - + prefix + -transform : prop        };      }    }    return null;  })();
   Detect if current browser positions fixed elements relative to the nearest   ancestor transformed element instead of the window.   https://bugs.chromium.org/p/chromium/issues/detail?id=20574     Borrowed from Mezr library:   https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L95-L113   https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L247-L300  var hasBrokenW3CTELCS = (function () {
     If the browser does not support transforms we can deduct that the     W3C TELCS is broken (non-existent).    if (!supportedTransform) {      return true;    }
    var body = document.body;    var outer = document.createElement(div);    var inner = document.createElement(div);    var leftUntransformed;    var leftTransformed;
    setStyles(outer, {      display: block,      visibility: hidden,      position: absolute,      width: 1px,      height: 1px,      left: 1px,      top: 0,      margin: 0    });
    setStyles(inner, {      display: block,      position: fixed,      width: 1px,      height: 1px,      left: 0,      top: 0,      margin: 0    });
    outer.appendChild(inner);    body.appendChild(outer);    leftUntransformed = inner.getBoundingClientRect().left;    outer.style[supportedTransform.prop] = translateZ(0);    leftTransformed = inner.getBoundingClientRect().left;    body.removeChild(outer);
    return leftTransformed === leftUntransformed;
  })();
  /**   * Emitter   * *******   */
  /**   * Event emitter constructor.   *   * This is a simplified version of jvent.js event emitter library:   * https://github.com/pazguille/jvent/blob/0.2.0/dist/jvent.js   *   *    */  function Emitter() {}
  /**   * Bind an event listener.   *   *    *     *      *      *   returns the Emitter instance.   */  Emitter.prototype.on = function (event, listener) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    listeners[listeners.length] = listener;    events[event] = listeners;
    return this;
  };
  /**   * Unbind all event listeners that match the provided listener function.   *   *    *     *      *      *   returns the Emitter instance.   */  Emitter.prototype.off = function (event, listener) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    var counter = listeners.length;
    if (counter) {      while (counter--) {        if (listener === listeners[i]) {          listeners.splice(counter, 1);        }      }    }
    return this;
  };
  /**   * Emit all listeners in a specified event with the provided arguments.   *   *    *     *      *      *      *      *   returns the Emitter instance.   */  Emitter.prototype.emit = function (event, arg1, arg2, arg3) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    var listenersLength = listeners.length;
    if (listenersLength) {
      var argsLength = arguments.length - 1;      listeners = listeners.concat();
      for (var i = 0; i < listenersLength; i++) {        argsLength === 0 ? listeners[i]() :        argsLength === 1 ? listeners[i](arg1) :        argsLength === 2 ? listeners[i](arg1, arg2) :                           listeners[i](arg1, arg2, arg3);      }
    }
    return this;
  };
  /**   * LayoutFirstFit v0.2.0   * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>   * Released under the MIT license   *   * The default Muuri layout method.   *   *    *      */  function LayoutFirstFit(settings) {
    var layout = this;
     Empty slots data.    var emptySlots = [];
     Normalize settings.    var fillGaps = settings.fillGaps ? true : false;    var isHorizontal = settings.horizontal ? true : false;    var alignRight = settings.alignRight ? true : false;    var alignBottom = settings.alignBottom ? true : false;
     Round container width and height.    layout.width = Math.round(layout.width);    layout.height = Math.round(layout.height);
     Set horizontal/vertical mode.    if (isHorizontal) {      layout.setWidth = true;      layout.width = 0;    }    else {      layout.setHeight = true;      layout.height = 0;    }
     No need to go further if items do not exist.    if (!layout.items.length) {      return;    }
     Find slots for items.    for (var i = 0; i < layout.items.length; i++) {
      var item = layout.items[i];      var slot = LayoutFirstFit.getSlot(layout, emptySlots, item._width, item._height, !isHorizontal, fillGaps);
       Update layout height.      if (isHorizontal) {        layout.width = Math.max(layout.width, slot.left + slot.width);      }      else {        layout.height = Math.max(layout.height, slot.top + slot.height);      }
       Add slot to slots data.      layout.slots[item._id] = slot;
    }
     If the alignment is set to right or bottom, we need to adjust the     results.    if (alignRight || alignBottom) {      for (var id in layout.slots) {        var slot = layout.slots[id];        if (alignRight) {          slot.left = layout.width - (slot.left + slot.width);        }        if (alignBottom) {          slot.top = layout.height - (slot.top + slot.height);        }      }    }
  }
  /**   * Calculate position for the layout item. Returns the left and top position   * of the item in pixels.   *   *    *     *      *      *      *      *      *      *     */  LayoutFirstFit.getSlot = function (layout, slots, itemWidth, itemHeight, vertical, fillGaps) {
    var currentSlots = slots[0] || [];    var newSlots = [];    var item = {      left: null,      top: null,      width: itemWidth,      height: itemHeight    };    var i;    var ii;    var slot;    var potentialSlots;    var ignoreCurrentSlots;
     Try to find a slot for the item.    for (i = 0; i < currentSlots.length; i++) {      slot = currentSlots[i];      if (item.width <= slot.width && item.height <= slot.height) {        item.left = slot.left;        item.top = slot.top;        break;      }    }
     If no slot was found for the item.    if (item.left === null) {
       Position the item in to the bottom left (vertical mode) or top right       (horizontal mode) of the grid.      item.left = vertical ? 0 : layout.width;      item.top = vertical ? layout.height : 0;
       If gaps don't needs filling do not add any current slots to the new       slots array.      if (!fillGaps) {        ignoreCurrentSlots = true;      }
    }
     In vertical mode, if the item's bottom overlaps the grid's bottom.    if (vertical && (item.top + item.height) > layout.height) {
       If item is not aligned to the left edge, create a new slot.      if (item.left > 0) {        newSlots[newSlots.length] = {          left: 0,          top: layout.height,          width: item.left,          height: Infinity        };      }
       If item is not aligned to the right edge, create a new slot.      if ((item.left + item.width) < layout.width) {        newSlots[newSlots.length] = {          left: item.left + item.width,          top: layout.height,          width: layout.width - item.left - item.width,          height: Infinity        };      }
       Update grid height.      layout.height = item.top + item.height;
    }
     In horizontal mode, if the item's right overlaps the grid's right edge.    if (!vertical && (item.left + item.width) > layout.width) {
       If item is not aligned to the top, create a new slot.      if (item.top > 0) {        newSlots[newSlots.length] = {          left: layout.width,          top: 0,          width: Infinity,          height: item.top        };      }
       If item is not aligned to the bottom, create a new slot.      if ((item.top + item.height) < layout.height) {        newSlots[newSlots.length] = {          left: layout.width,          top: item.top + item.height,          width: Infinity,          height: layout.height - item.top - item.height        };      }
       Update grid width.      layout.width = item.left + item.width;
    }
     Clean up the current slots making sure there are no old slots that     overlap with the item. If an old slot overlaps with the item, split it     into smaller slots if necessary.    for (i = fillGaps ? 0 : ignoreCurrentSlots ? currentSlots.length : i; i < currentSlots.length; i++) {      potentialSlots = LayoutFirstFit.splitRect(currentSlots[i], item);      for (ii = 0; ii < potentialSlots.length; ii++) {        slot = potentialSlots[ii];        if (slot.width > 0 && slot.height > 0 && ((vertical && slot.top < layout.height) || (!vertical && slot.left < layout.width))) {          newSlots[newSlots.length] = slot;        }      }    }
     Remove redundant slots and sort the new slots.    LayoutFirstFit.purgeSlots(newSlots).sort(vertical ? LayoutFirstFit.sortRectsTopLeft : LayoutFirstFit.sortRectsLeftTop);
     Update the slots data.    slots[0] = newSlots;
     Return the item.    return item;
  };
  /**   * Sort rectangles with top-left gravity. Assumes that objects with   * properties left, top, width and height are being sorted.   *   *    *     *      *      *     */  LayoutFirstFit.sortRectsTopLeft = function (a, b) {
    return a.top < b.top ? -1 : (a.top > b.top ? 1 : (a.left < b.left ? -1 : (a.left > b.left ? 1 : 0)));
  };
  /**   * Sort rectangles with left-top gravity. Assumes that objects with   * properties left, top, width and height are being sorted.   *   *    *     *      *      *     */  LayoutFirstFit.sortRectsLeftTop = function (a, b) {
    return a.left < b.left ? -1 : (a.left > b.left ? 1 : (a.top < b.top ? -1 : (a.top > b.top ? 1 : 0)));
  };
  /**   * Check if a rectabgle is fully within another rectangle. Assumes that the   * rectangle object has the following properties: left, top, width and height.   *   *    *     *      *      *     */  LayoutFirstFit.isRectWithinRect = function (a, b) {
    return a.left >= b.left && a.top >= b.top && (a.left + a.width) <= (b.left + b.width) && (a.top + a.height) <= (b.top + b.height);
  };
  /**   * Loops through an array of slots and removes all slots that are fully within   * another slot in the array.   *   *    *     *      */  LayoutFirstFit.purgeSlots = function (slots) {
    var i = slots.length;    while (i--) {      var slotA = slots[i];      var ii = slots.length;      while (ii--) {        var slotB = slots[ii];        if (i !== ii && LayoutFirstFit.isRectWithinRect(slotA, slotB)) {          slots.splice(i, 1);          break;        }      }    }
    return slots;
  };
  /**   * Compares a rectangle to another and splits it to smaller pieces (the parts   * that exceed the other rectangles edges). At maximum generates four smaller   * rectangles.   *   *    *     *      *      * returns {Array}   */  LayoutFirstFit.splitRect = function (a, b) {
    var ret = [];    var overlap = !(b.left > (a.left + a.width) || (b.left + b.width) < a.left || b.top > (a.top + a.height) || (b.top + b.height) < a.top);
     If rect a does not overlap with rect b add rect a to the return data as     is.    if (!overlap) {
      ret[0] = a;
    }     If rect a overlaps with rect b split rect a into smaller rectangles and     add them to the return data.    else {
       Left split.      if (a.left < b.left) {        ret[ret.length] = {          left: a.left,          top: a.top,          width: b.left - a.left,          height: a.height        };      }
       Right split.      if ((a.left + a.width) > (b.left + b.width)) {        ret[ret.length] = {          left: b.left + b.width,          top: a.top,          width: (a.left + a.width) - (b.left + b.width),          height: a.height        };      }
       Top split.      if (a.top < b.top) {        ret[ret.length] = {          left: a.left,          top: a.top,          width: a.width,          height: b.top - a.top        };      }
       Bottom split.      if ((a.top + a.height) > (b.top + b.height)) {        ret[ret.length] = {          left: a.left,          top: b.top + b.height,          width: a.width,          height: (a.top + a.height) - (b.top + b.height)        };      }
    }
    return ret;
  };
  /**   * Muuri   * *****   */
  /**   * Creates a new Muuri instance.   *   *    *    *      *   *    *    *      *      *    */  function Muuri(settings) {
    var inst = this;
     Merge user settings with default settings.    var stn = inst._settings = mergeObjects({}, Muuri.defaultSettings, settings || {});
     Make sure a valid container element is provided before going continuing.    if (!document.body.contains(stn.container)) {      throw new Error(Container must be an existing DOM element);    }
     Setup container element.    inst._element = stn.container;    addClass(stn.container, stn.containerClass);
     Instance id.    inst._id = ++uuid;
     Unique animation queue name.    inst._animQueue = muuri- + inst._id;
     Create private eventize instance.    inst._emitter = new Emitter();
     Setup show and hide animations for items.    inst._itemShow = typeof stn.show === function ? stn.show() : showHideAnimation(stn.show, true);    inst._itemHide = typeof stn.hide === function ? stn.hide() : showHideAnimation(stn.hide);
     Setup initial items.    inst._items = [];    for (var i = 0, len = stn.items.length; i < len; i++) {      inst._items[inst._items.length] = new Muuri.Item(inst, stn.items[i]);    }
     Relayout on window resize if enabled.    if (stn.layoutOnResize || stn.layoutOnResize === 0) {      var debounced = debounce(function () {        inst.refresh();        inst.layout();      }, stn.layoutOnResize);      inst._resizeHandler = function () {        debounced();      };      global.addEventListener(resize, inst._resizeHandler);    }
     Layout on init if enabled.    if (stn.layoutOnInit) {      inst.layout(true);    }
  }
  /**   * Get instance's item by element or by index. Target can also be a   * Muuri item instance in which case the function returns the item if it   * exists within related Muuri instance. If nothing is found with the   * provided target null is returned.   *   *    *     *      *     */  Muuri.prototype._getItem = function (target) {
    if (!target) {
      return this._items[0] || null;
    }    else if (target instanceof Muuri.Item) {
      return target._muuri === this ? target : null;
    }    else if (typeof target === number) {
      target = target > -1 ? target : this._items.length + target;      return this._items[target] || null;
    }    else {
      var ret = null;      for (var i = 0, len = this._items.length; i < len; i++) {        var item = this._items[i];        if (item._element === target) {          ret = item;          break;        }      }      return ret;
    }
  };
  /**   * Bind an event listener.   *   *    *     *      *      *   returns the Muuri instance.   */  Muuri.prototype.on = function (event, listener) {
    this._emitter.on(event, listener);    return this;
  };
  /**   * Unbind an event listener.   *   *    *     *      *      *   returns the Muuri instance.   */  Muuri.prototype.off = function (event, listener) {
    this._emitter.off(event, listener);    return this;
  };
  /**   * Recalculate the width and height of the provided targets. If no targets are   * provided all active items will be refreshed.   *   *    *     *      */  Muuri.prototype.refresh = function (items) {
     Get items.    items = items ? this.get(items) : this.get(active);
     Refresh dimensions.    for (var i = 0, len = items.length; i < len; i++) {      items[i]._refresh();    }
     Emit refresh event.    this._emitter.emit(evRefresh, items);
  };
  /**   * Get all items. Optionally you can provide specific targets (indices or   * elements) and filter the results by the items' state (active/inactive).   * Note that the returned array is not the same object used by the instance so   * modifying it will not affect instance's items. All items that are not found   * are omitted from the returned array.   *   *    *     *      *      *   Array of Muuri item instances.   */  Muuri.prototype.get = function (targets, state) {
    var hasTargets = targets && typeof targets !== string;
    state = !hasTargets ? targets : state;    state = typeof state === string ? state : null;    targets = hasTargets ? [].concat(targets) : null;
    if (state || targets) {
      var items = targets || this._items;      var ret = [];      var isActive = state === active;      var isInactive = state === inactive;
      for (var i = 0, len = items.length; i < len; i++) {        var item = hasTargets ? this._getItem(items[i]) : items[i];        if (item && (!state || (isActive && item._active) || (isInactive && !item._active))) {          ret[ret.length] = item;        }      }
      return ret;
    }    else {
      return this._items.concat();
    }
  };
  /**   * Add new items by providing the elements you wish to add to the instance and   * optionally provide the index where you want the items to be inserted into.   * All elements that are not already children of the container element will be   * automatically appended to the container. If an element has it's CSS display   * property set to none it will be marked as inactive during the initiation   * process. As long as the item is inactive it will not be part of the layout,   * but it will retain it's index. You can activate items at any point   * with muuri.show() method. This method will automatically call   * muuri.layout() if one or more of the added elements are visible. If only   * hidden items are added no layout will be called. All the new visible items   * are positioned without animation during their first layout.   *   *    *     *      *      *     */  Muuri.prototype.add = function (elements, index) {
    var newItems = [];    var needsRelayout = false;
     Make sure elements is an array.    elements = [].concat(elements);
     Filter out all elements that exist already in current instance.    for (var i = 0, len = this._items.length; i < len; i++) {      var item = this._items[i];      var index = elements.indexOf(item._element);      if (index > -1) {        elements.splice(index, 1);      }    }
     Return early if there are no valid items.    if (!elements.length) {      return newItems;    }
     Create new items.    for (var i = 0, len = elements.length; i < len; i++) {      var item = new Muuri.Item(this, elements[i]);      newItems[newItems.length] = item;      if (item._active) {        needsRelayout = true;        item._noLayoutAnimation = true;      }    }
     Normalize the index for the splice apply hackery so that value of -1     prepends the new items to the current items.    index = index < 0 ? this._items.length - index + 1 : index;
     Add the new items to the items collection to correct index.    this._items.splice.apply(this._items, [index, 0].concat(newItems));
     If relayout is needed.    if (needsRelayout) {      this.layout();    }
     Emit add event.    this._emitter.emit(evAdd, newItems);
     Return new items    return newItems;
  };
  /**   * Remove items from muuri instances.   *   *    *     *      *      *   The indices of removed items.   */  Muuri.prototype.remove = function (items, removeElement) {
    var indices = [];    var needsRelayout = false;
    items = this.get(items);
    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
       Check it refresh is needed.      if (item._active) {        needsRelayout = true;      }
       Remove item.      indices[indices.length] = item._destroy(removeElement);
    }
     If relayout is needed.    if (needsRelayout) {      this.layout();    }
    this._emitter.emit(evRemove, indices);
    return indices;
  };
  /**   * Order the item elements to match the order of the items. If the item's   * element is not a child of the container it is ignored and left untouched.   * This comes handy if you need to keep the DOM structure matched with the   * order of the items.   *   *    *     */  Muuri.prototype.synchronize = function () {
    for (var i = 0, len = this._items.length; i < len; i++) {      var item = this._items[i];      if (item._element.parentNode === this._element) {        this._element.appendChild(item._element);      }    }
    this._emitter.emit(evSynchronize);
  };
  /**   * Calculate and apply Muuri instance's item positions.   *   *    *     *      *      */  Muuri.prototype.layout = function (instant, callback) {
    var inst = this;    var emitter = inst._emitter;    var callback = typeof instant === function ? instant : callback;    var isInstant = instant === true;    var layout = new Muuri.Layout(inst);    var counter = -1;    var itemsLength = layout.items.length;    var completed = [];    var tryFinish = function (interrupted, item) {
       Push all items to the completed items array which were not interrupted.      if (!interrupted) {        completed[completed.length] = item;      }
       If container and all items have finished their animations (if any).      if (++counter === itemsLength) {
         Call callback.        if (typeof callback === function) {          callback(completed, layout);        }
         Emit layoutend event.        emitter.emit(evLayoutEnd, completed, layout);
      }
    };
     Emit layoutstart event.    emitter.emit(evLayoutStart, layout.items, layout);
     Set container's height if needed.    if (layout.setHeight) {      setStyles(inst._element, {        height: layout.height + px      });    }
     Set container's width if needed.    if (layout.setWidth) {      setStyles(inst._element, {        width: layout.width + px      });    }
     If there are now items let's finish quickly.    if (!itemsLength) {
      tryFinish(true);
    }     If there are items let's position them.    else {
      for (var i = 0, len = layout.items.length; i < len; i++) {
        var item = layout.items[i];        var pos = layout.slots[item._id];
         Update item's position.        item._left = pos.left;        item._top = pos.top;
         Layout non-dragged items.        item._drag.active ? tryFinish(false, item) : item._layout(isInstant, tryFinish);
      }
    }
  };
  /**   * Show instance items.   *   *    *     *      *      *      */  Muuri.prototype.show = function (items, instant, callback) {
    showHideHandler(this, show, items, instant, callback);
  };
  /**   * Hide instance items.   *   *    *     *      *      *      */  Muuri.prototype.hide = function (items, instant, callback) {
    showHideHandler(this, hide, items, instant, callback);
  };
  /**   * Get item's index.   *   *    *     *      *     */  Muuri.prototype.indexOf = function (item) {
    if (typeof item === number) {
      return item <= (this._items.length - 1) ? item : null;
    }    else if (item instanceof Muuri.Item) {
      var index = this._items.indexOf(item);      return index > -1 ? index : null;
    }    else {
      var index = null;      for (var i = 0, len = this._items.length; i < len; i++) {        if (this._items[i]._element === item) {          index = i;          break;        }      }      return index;
    }
  };
  /**   * Move item to another index or in place of another item.   *   *    *     *      *      */  Muuri.prototype.move = function (targetFrom, targetTo) {
    targetFrom = this._getItem(targetFrom);    targetTo = this._getItem(targetTo);
    if (targetFrom && targetTo && (targetFrom !== targetTo)) {      arrayMove(this._items, this._items.indexOf(targetFrom), this._items.indexOf(targetTo));      this._emitter.emit(evMove, targetFrom, targetTo);    }
  };
  /**   * Swap positions of two items.   *   *    *     *      *      */  Muuri.prototype.swap = function (targetA, targetB) {
    targetA = this._getItem(targetA);    targetB = this._getItem(targetB);
    if (targetA && targetB && (targetA !== targetB)) {      arraySwap(this._items, this._items.indexOf(targetA), this._items.indexOf(targetB));      this._emitter.emit(evSwap, targetA, targetB);    }
  };
  /**   * Destroy the instance.   *   *    *     */  Muuri.prototype.destroy = function () {
     Unbind window resize event listener.    if (this._resizeHandler) {      global.removeEventListener(resize, this._resizeHandler);    }
     Destroy items.    var items = this._items.concat();    for (var i = 0, len = items.length; i < len; i++) {      items[i]._destroy();    }
     Restore container.    removeClass(this._element, this._settings.containerClass);    setStyles(this._element, {      height:     });
     Emit destroy event.    this._emitter.emit(evDestroy);
     Remove all event listeners.    var events = this._emitter._events;    if (events) {      var eventNames = Object.keys(this._emitter._events);      for (var i = 0, len = eventNames.length; i < len; i++) {        events[eventNames[i]].length = 0;      }    }
     Render the instance unusable -> nullify all Muuri related properties.    var props = Object.keys(this).concat(Object.keys(Muuri.prototype));    for (var i = 0; i < props.length; i++) {      this[props[i]] = null;    }
  };
  /**   * Muuri - Item   * ************   */
  /**   * Creates a new Muuri Item instance.   *   *    *    *     *      *      */  Muuri.Item = function (muuri, element) {
     Make sure the item element is not a parent of the grid container element.    if (element.contains(muuri._element)) {      throw new Error(Item element must not be a parent of the grid container element);    }
     If the provided item element is not a direct child of the grid container     element, append it to the grid container.    if (element.parentNode !== muuri._element) {      muuri._element.appendChild(element);    }
    var stn = muuri._settings;    var isHidden = getStyle(element, display) === none;
     Instance id.    this._id = ++uuid;    this._muuri = muuri;    this._element = element;    this._child = element.children[0];
     Set item class.    addClass(element, stn.itemClass);
     Set up active state (defines if the item is considered part of the layout     or not).    this._active = isHidden ? false : true;
     Set up positioning state (defines if the item is currently animating     it's position).    this._positioning = false;
     Set up visibility states.    this._hidden = isHidden;    this._hiding = false;    this._showing = false;
     Visibility animation callback queue. Whenever a callback is provided for     show/hide methods and animation is enabled the callback is stored     temporarily to this array. The callbacks are called with the first     argument as false if the animation succeeded without interruptions and     with the first argument as true if the animation was interrupted.    this._visibiliyQueue = [];
     Layout animation callback queue. Whenever a callback is provided for     layout method and animation is enabled the callback is stored temporarily     to this array. The callbacks are called with the first argument as false     if the animation succeeded without interruptions and with the first     argument as true if the animation was interrupted.    this._layoutQueue = [];
     Set element's initial position.    hookStyles(this._element, {      left: 0,      top: 0,      translateX: 0px,      translateY: 0px    });
     Set hidden/shown class.    addClass(element, isHidden ? stn.hiddenClass : stn.shownClass);
     Set hidden/shown styles for the child element.    hookStyles(this._child, {      scale: isHidden ? 0 : 1,      opacity: isHidden ? 0 : 1    });
     Enforce display ""block"" if element is visible.    if (!isHidden) {      setStyles(this._element, {        display: block      });    }
     Set up initial dimensions and positions.    this._refresh();    this._left = 0;    this._top = 0;
     Set up drag & drop.    this._drag = {active: false};    this._release = {active: false};    if (muuri._settings.dragEnabled) {      this._initDrag();    }
  };
  /**   * Inspect instance's data.   *   *    *     */  Muuri.Item.prototype.inspect = function () {
    return {      element: this._element,      width: this._width,      height: this._height,      left: this._left,      top: this._top,      active: this._active,      positioning: this._positioning,      dragging: this._drag.active,      releasing: this._release.active,      visibility: this._hiding  ? hiding : this._showing ? showing : this._hidden  ? hidden : shown    };
  };
  /**   * Make the item draggable with Hammer.js.   *   *    *     */  Muuri.Item.prototype._initDrag = function () {
    var inst = this;    var stn = inst._muuri._settings;
     Initiate Hammer.    var hammer = inst._hammer = new Hammer.Manager(inst._element);
     Add drag recognizer to hammer.    hammer.add(new Hammer.Pan({      event: drag,      pointers: 1,      threshold: 0,      direction: Hammer.DIRECTION_ALL    }));
     Add draginit recognizer to hammer.    hammer.add(new Hammer.Press({      event: draginit,      pointers: 1,      threshold: 100,      time: 0    }));
     This is not ideal, but saves us from a LOT of hacks. Let's try to keep     the default drag setup consistent across devices.    hammer.set({ touchAction: none });
     Setup initial release data.    inst._resetReleaseData();
     Setup initial drag data.    var drag = inst._drag;    inst._resetDragData();
     Add overlap checker function to drag data.    drag.checkOverlap = debounce(function () {      if (drag.active) {        inst._checkOverlap();      }    }, stn.dragSortInterval);
     Add predicate related data to drag data.    var predicateResolved = false;    drag.predicate = typeof stn.dragPredicate === function ? stn.dragPredicate : dragPredicate;    drag.predicateData = {};    drag.isPredicateResolved = function () {      return predicateResolved;    };    drag.resolvePredicate = function (e) {      if (!predicateResolved && e.type !== draginitup && e.type !== dragend && e.type !== dragcancel) {        predicateResolved = true;        inst._onDragStart(e);      }    };
     Add drag sroll handler.    drag.onScroll = function (e) {      if (raf) {        raf(function () {          inst._onDragScroll(e);        });      }      else {        inst._onDragScroll(e);      }    };
     Bind drag events.    hammer    .on(draginit, function (e) {      drag.predicateData = {};      predicateResolved = false;      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    })    .on(dragstart dragmove, function (e) {      if (predicateResolved && drag.active) {        inst._onDragMove(e);      }      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    })    .on(dragend dragcancel draginitup, function (e) {      if (predicateResolved && drag.active) {        inst._onDragEnd(e);      }      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    });
  };
  /**   * Reset drag data.   *   *    *     */  Muuri.Item.prototype._resetDragData = function () {
    var drag = this._drag;
     Is the drag active or not?    drag.active = false;
     Hammer dragstart/dragend event data.    drag.start = null;    drag.move = null;
     The element that is currently dragged (instance element or it's clone).    drag.element = null;
     The curently dragged element's width and height.    drag.elemWidth = 0;    drag.elemHeight = 0;
     Dragged element's inline styles stored for graceful teardown.    drag.elementStyles = null;
     Scroll parents of the dragged element and muuri container.    drag.scrollParents = [];
     The current translateX/translateY position.    drag.left = 0;    drag.top = 0;
     Dragged element's current position within the grid.    drag.gridX = 0;    drag.gridY = 0;
     Dragged element's current offset from window's northwest corner. Does not     account for element's margins.    drag.elemClientX = 0;    drag.elemClientY = 0;
     Offset difference between the dragged element's temporary drag container     and it's original container.    drag.containerDiffX = 0;    drag.containerDiffY = 0;
  };
  /**   * Drag start handler.   *   *    *     */  Muuri.Item.prototype._onDragStart = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;    var isReleased = this._release.active;
     If item is not active, don't start the drag.    if (!this._active) {      return;    }
     Stop current positioning animation.    if (this._positioning) {      this._stopLayout();    }
     If item is being released reset release data, remove release class and     import the current elementStyles to drag object.    if (isReleased) {      drag.elementStyles = this._release.elementStyles;      removeClass(this._element, stn.releasingClass);      this._resetReleaseData();    }
     Setup drag data.    drag.active = true;    drag.start = e;    drag.move = e;    drag.element = this._element;    drag.elemWidth = this._width;    drag.elemHeight = this._height;
     Get element's current position.    var currentLeft = parseFloat(Velocity.hook(drag.element, translateX)) || 0;    var currentTop = parseFloat(Velocity.hook(drag.element, translateY)) || 0;
     Get container references.    var muuriContainer = this._muuri._element;    var dragContainer = stn.dragContainer;
     Set initial left/top drag value.    drag.left = drag.gridX = currentLeft;    drag.top = drag.gridY = currentTop;
     If a specific drag container is set and it is different from the     default muuri container we need to cast some extra spells.    if (dragContainer && dragContainer !== muuriContainer) {
       If dragged element is already in drag container.      if (drag.element.parentNode === dragContainer) {
         Get offset diff.        var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
         Store the container offset diffs to drag data.        drag.containerDiffX = offsetDiff.left;        drag.containerDiffY = offsetDiff.top;
         Set up relative drag position data.        drag.gridX = currentLeft - drag.containerDiffX;        drag.gridY = currentTop - drag.containerDiffY;
      }
       If dragged element is not within the correct container.      else {
         Lock element's width, height, padding and margin before appending         to the temporary container because otherwise the element might         enlarge or shrink after the append procedure if the some of the         properties are defined in relative sizes.        lockElementSize(drag);
         Append element into correct container.        dragContainer.appendChild(drag.element);
         Get offset diff.        var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
         Store the container offset diffs to drag data.        drag.containerDiffX = offsetDiff.left;        drag.containerDiffY = offsetDiff.top;
         Set up drag position data.        drag.left = currentLeft + drag.containerDiffX;        drag.top = currentTop + drag.containerDiffY;
         Fix position to account for the append procedure.        hookStyles(drag.element, {          translateX: drag.left + px,          translateY: drag.top + px        });
      }
    }
     Get and store element's current offset from window's northwest corner.    var elemGbcr = drag.element.getBoundingClientRect();    drag.elemClientX = elemGbcr.left;    drag.elemClientY = elemGbcr.top;
     Get drag scroll parents.    drag.scrollParents = getScrollParents(drag.element);    if (dragContainer && dragContainer !== muuriContainer) {      drag.scrollParents = arrayUnique(drag.scrollParents.concat(getScrollParents(muuriContainer)));    }
     Bind scroll listeners.    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].addEventListener(scroll, drag.onScroll);    }
     Set drag class.    addClass(drag.element, stn.draggingClass);
     Emit dragstart event.    this._muuri._emitter.emit(evDragStart, this, generateDragEvent(dragstart, e, drag));
  };
  /**   * Drag move handler.   *   *    *     */  Muuri.Item.prototype._onDragMove = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     If item is not active, reset drag.    if (!this._active) {      this._resetDrag();      return;    }
     Get delta difference from last dragmove event.    var xDiff = e.deltaX - drag.move.deltaX;    var yDiff = e.deltaY - drag.move.deltaY;
     Update move event.    drag.move = e;
     Update position data.    drag.left += xDiff;    drag.top += yDiff;    drag.gridX += xDiff;    drag.gridY += yDiff;    drag.elemClientX += xDiff;    drag.elemClientY += yDiff;
     Update element's translateX/Y values.    hookStyles(drag.element, {      translateX: drag.left + px,      translateY: drag.top + px    });
     Overlap handling.    if (stn.dragSort) {      drag.checkOverlap();    }
     Emit item-dragmove event.    this._muuri._emitter.emit(evDragMove, this, generateDragEvent(dragmove, e, drag));
  };
  /**   * Drag scroll handler.   *   *    *     */  Muuri.Item.prototype._onDragScroll = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     Get containers.    var muuriContainer = this._muuri._element;    var dragContainer = stn.dragContainer;
     Get offset diff.    var elemGbcr = drag.element.getBoundingClientRect();    var xDiff = drag.elemClientX - elemGbcr.left;    var yDiff = drag.elemClientY - elemGbcr.top;
     Update container diff.    if (dragContainer && dragContainer !== muuriContainer) {
       Get offset diff.      var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
       Store the container offset diffs to drag data.      drag.containerDiffX = offsetDiff.left;      drag.containerDiffY = offsetDiff.top;
    }
     Update position data.    drag.left += xDiff;    drag.top += yDiff;    drag.gridX = drag.left - drag.containerDiffX;    drag.gridY = drag.top - drag.containerDiffY;
     Update element's translateX/Y values.    hookStyles(drag.element, {      translateX: drag.left + px,      translateY: drag.top + px    });
     Overlap handling.    if (stn.dragSort) {      drag.checkOverlap();    }
     Emit item-dragscroll event.    this._muuri._emitter.emit(evDragScroll, this, generateDragEvent(dragscroll, e, drag));
  };
  /**   * Drag end handler.   *   *    *     */  Muuri.Item.prototype._onDragEnd = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;    var release = this._release;
     If item is not active, reset drag.    if (!this._active) {      this._resetDrag();      return;    }
     Finish currently queued overlap check.    if (stn.dragSort) {      drag.checkOverlap(finish);    }
     Remove scroll listeners    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].removeEventListener(scroll, drag.onScroll);    }
     Remove drag classname from element.    removeClass(drag.element, stn.draggingClass);
     Flag drag as inactive.    drag.active = false;
     Emit item-dragend event.    this._muuri._emitter.emit(evDragEnd, this, generateDragEvent(dragend, e, drag));
     Setup release data.    release.containerDiffX = drag.containerDiffX;    release.containerDiffY = drag.containerDiffY;    release.element = drag.element;    release.elementStyles = drag.elementStyles;
     Reset drag data.    this._resetDragData();
     Start the release process.    this._startRelease();
  };
  /**   * Reset drag data and cancel any ongoing drag activity.   *   *    *     */  Muuri.Item.prototype._resetDrag = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     Remove scroll listeners    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].removeEventListener(scroll, drag.onScroll);    }
     Cancel overlap check.    drag.checkOverlap(cancel);
     Remove draggin class.    removeClass(drag.element, stn.draggingClass);
     Remove dragged element's inline styles.    unlockElementSize(drag);
    this._resetDragData();
  };
  /**   * Reset release data.   *   *    *     */  Muuri.Item.prototype._resetReleaseData = function () {
    var release = this._release;    release.active = false;    release.positioningStarted = false;    release.containerDiffX = 0;    release.containerDiffY = 0;    release.element = null;    release.elementStyles = null;
  };
  /**   * Start the release process of an item.   *   *    *     */  Muuri.Item.prototype._startRelease = function () {
    var stn = this._muuri._settings;    var release = this._release;
     Flag release as active.    release.active = true;
     Add release classname to released element.    addClass(release.element, stn.releasingClass);
     Emit releasestart event.    this._muuri._emitter.emit(evReleaseStart, this);
     Position the released item.    this._layout(false);
  };
  /**   * End the release process of an item.   *   *    *     */  Muuri.Item.prototype._endRelease = function () {
    var stn = this._muuri._settings;    var release = this._release;
     Remove release classname from the released element.    removeClass(release.element, stn.releasingClass);
     If the released element is outside the muuri container put it back there     and adjust position accordingly.    if (release.element.parentNode !== this._muuri._element) {      this._muuri._element.appendChild(release.element);      hookStyles(release.element, {        translateX: this._left + px,        translateY: this._top + px      });    }
     Unlock temporary inlined styles.    unlockElementSize(release);
     Reset release data.    this._resetReleaseData();
     Emit releaseend event.    this._muuri._emitter.emit(evReleaseEnd, this);
  };
  /**   * Check (during drag) if an item is overlapping other items and based on   * the configuration do a relayout.   *   *    *     */  Muuri.Item.prototype._checkOverlap = function () {
    var stn = this._muuri._settings;    var overlapTolerance = stn.dragSortTolerance;    var overlapAction = stn.dragSortAction;    var items = this._muuri._items;    var bestMatch = null;    var instIndex = 0;    var instData = {      width: this._drag.elemWidth,      height: this._drag.elemHeight,      left: this._drag.gridX,      top: this._drag.gridY    };
     Find best match (the element with most overlap).    for (var i = 0, len = items.length; i < len; i++) {      var item = items[i];      if (item === this) {        instIndex = i;      }      else if (item._active) {        var overlapScore = getOverlapScore(instData, {          width: item._width,          height: item._height,          left: item._left,          top: item._top        });        if (!bestMatch || overlapScore > bestMatch.score) {          bestMatch = {            item: item,            score: overlapScore,            index: i          };        }      }    }
     Check if the best match overlaps enough to justify a placement switch.    if (bestMatch && bestMatch.score >= overlapTolerance) {      if (overlapAction === swap) {        arraySwap(items, instIndex, bestMatch.index);        this._muuri._emitter.emit(evSwap, this, bestMatch.item);      }      else {        arrayMove(items, instIndex, bestMatch.index);        this._muuri._emitter.emit(evMove, this, bestMatch.item);      }      this._muuri.layout();    }
  };
  /**   * Stop item's position animation if it is currently animating.   *   *    *     */  Muuri.Item.prototype._stopLayout = function () {
    var stn = this._muuri._settings;
    if (this._positioning) {
       Stop animation.      Velocity(this._element, stop, this._muuri._animQueue);
       Remove visibility classes.      removeClass(this._element, stn.positioningClass);
       Reset state.      this._positioning = false;
       Process callback queue.      processQueue(this._layoutQueue, true, this);
    }
  };
  /**   * Recalculate item's dimensions.   *   *    *     */  Muuri.Item.prototype._refresh = function () {
    if (!this._hidden) {      this._width = Math.round(getDimension(this._element, width, true));      this._height = Math.round(getDimension(this._element, height, true));    }
  };
  /**   * Position item based on it's current data.   *   *    *     *      *      */  Muuri.Item.prototype._layout = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;    var release = inst._release;    var isJustReleased = release.active && release.positioningStarted === false;    var animDuration = isJustReleased ? stn.dragReleaseDuration : stn.positionDuration;    var animEasing = isJustReleased ? stn.dragReleaseEasing : stn.positionEasing;    var animEnabled = instant === true || inst._noLayoutAnimation ? false : animDuration > 0;    var isPositioning = inst._positioning;    var finish = function () {
       Remove positioning classes.      removeClass(inst._element, stn.positioningClass);
       Mark the item as not positioning.      inst._positioning = false;
       Finish up release.      if (release.active) {        inst._endRelease();      }
       Process the callback queue.      processQueue(inst._layoutQueue, false, inst);
    };
     Stop currently running animation, if any.    inst._stopLayout();
     Push the callback to the callback queue.    if (typeof callback === function) {      inst._layoutQueue[inst._layoutQueue.length] = callback;    }
     Mark release positiong as started.    if (isJustReleased) {      release.positioningStarted = true;    }
     Get item container offset. This applies only for release handling in the     scenario where the released element is not currently within the muuri     container.    var offsetLeft = inst._release.active ? inst._release.containerDiffX : 0;    var offsetTop = inst._release.active ? inst._release.containerDiffY : 0;
     If no animations are needed, easy peasy!    if (!animEnabled) {
      if (inst._noLayoutAnimation) {        inst._noLayoutAnimation = false;      }
      hookStyles(inst._element, {        translateX: (inst._left + offsetLeft) + px,        translateY: (inst._top + offsetTop) + px      });
      finish();
    }
     If animations are needed, let's dive in.    else {
       Get current (relative) left and top position. Meaning that the       drga container's offset (if applicable) is subtracted from the current       translate values.      var currentLeft = (parseFloat(Velocity.hook(inst._element, translateX)) || 0) - offsetLeft;      var currentTop =  (parseFloat(Velocity.hook(inst._element, translateY)) || 0) - offsetTop;
       If the item is already in correct position there's no need to animate       it.      if (inst._left === currentLeft && inst._top === currentTop) {        finish();        return;      }
       Mark as positioning.      inst._positioning = true;
       Add positioning class if necessary.      if (!isPositioning) {        addClass(inst._element, stn.positioningClass);      }
       Set up the animation.      Velocity(inst._element, {        translateX: inst._left + offsetLeft,        translateY: inst._top + offsetTop      }, {        duration: animDuration,        easing: animEasing,        complete: finish,        queue: inst._muuri._animQueue      });
       Start the animation.      Velocity.Utilities.dequeue(inst._element, inst._muuri._animQueue);
    }
  };
  /**   * Show item.   *   *    *     *      *      */  Muuri.Item.prototype._show = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;
     If item is visible.    if (!inst._hidden && !inst._showing) {
       Call the callback and be done with it.      if (typeof callback === function) {        callback(false, inst);      }
    }
     If item is animating to visible.    else if (!inst._hidden) {
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
    }
     If item is hidden or animating to hidden.    else {
      var isHiding = inst._hiding;
       Stop animation.      inst._muuri._itemHide.stop(inst);
       Update states.      inst._active = true;      inst._hidden = false;      inst._showing = inst._hiding = false;
       Update classes.      addClass(inst._element, stn.shownClass);      removeClass(inst._element, stn.hiddenClass);
       Set element's display style.      setStyles(inst._element, {        display: block      });
       Process current callback queue.      processQueue(inst._visibiliyQueue, true, inst);
       Update state.      inst._showing = true;
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
       Animate child element.      inst._muuri._itemShow.start(inst, instant, function () {
         Process callback queue.        processQueue(inst._visibiliyQueue, false, inst);
      });
    }
  };
  /**   * Hide item.   *   *    *     *      *      */  Muuri.Item.prototype._hide = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;
     If item is hidden.    if (inst._hidden && !inst._hiding) {
       Call the callback and be done with it.      if (typeof callback === function) {        callback(false, inst);      }
    }
     If item is animating to hidden.    else if (inst._hidden) {
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
    }
     If item is visible or animating to visible.    else {
      var isShowing = inst._showing;
       Stop animation.      inst._muuri._itemShow.stop(inst);
       Update states.      inst._active = false;      inst._hidden = true;      inst._showing = inst._hiding = false;
       Update classes.      addClass(inst._element, stn.hiddenClass);      removeClass(inst._element, stn.shownClass);
       Process current callback queue.      processQueue(inst._visibiliyQueue, true, inst);
       Update state.      inst._hiding = true;
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
       Animate child element.      inst._muuri._itemHide.start(inst, instant, function () {
         Hide element.        setStyles(inst._element, {          display: none        });
         Process callback queue.        processQueue(inst._visibiliyQueue, false, inst);
      });
    }
  };
  /**   * Destroy item instance.   *   *    *     *      */  Muuri.Item.prototype._destroy = function (removeElement) {
    var muuri = this._muuri;    var stn = this._muuri._settings;    var element = this._element;    var index = this._muuri._items.indexOf(this);
     Stop animations.    this._stopLayout();    this._muuri._itemShow.stop(this);    this._muuri._itemHide.stop(this);
     If item is being released, stop it gracefully.    if (this._release.active) {      if (element.parentNode !== this._muuri._element) {        this._muuri._element.appendChild(element);      }      this._resetReleaseData();    }
     If item is being dragged, stop it gracefully.    if (this._drag.active) {      if (element.parentNode !== this._muuri._element) {        this._muuri._element.appendChild(element);      }      this._resetDrag();    }
     Destroy Hammer instance and custom touch listeners.    if (this._hammer) {      this._hammer.destroy();    }
     Remove all inline styles.    element.removeAttribute(style);    this._child.removeAttribute(style);
     Handle visibility callback queue, fire all uncompleted callbacks with     interrupted flag.    processQueue(this._visibiliyQueue, true, this);
     Remove Muuri specific classes.    removeClass(element, stn.positioningClass);    removeClass(element, stn.draggingClass);    removeClass(element, stn.releasingClass);    removeClass(element, stn.itemClass);    removeClass(element, stn.shownClass);    removeClass(element, stn.hiddenClass);
     Remove item from Muuri instance if it still exists there.    if (index > -1) {      this._muuri._items.splice(index, 1);    }
     Remove element from DOM.    if (removeElement) {      element.parentNode.removeChild(element);    }
     Render the instance unusable -> nullify all Muuri related properties.    var props = Object.keys(this).concat(Object.keys(Muuri.Item.prototype));    for (var i = 0; i < props.length; i++) {      this[props[i]] = null;    }
  };
  /**   * Creates a new Muuri Layout instance.   *   *    *    *     *      *      */  Muuri.Layout = function (muuri, items) {
    var stn = muuri._settings.layout;
    this.muuri = muuri;    this.items = items ? items.concat() : muuri.get(active);    this.slots = {};    this.width = 0;    this.height = 0;    this.setWidth = false;    this.setHeight = false;
     Calculate the current width and height of the container.    this.width = getDimension(muuri._element, width);    this.height = getDimension(muuri._element, height);
     If the user has provided custom function as a layout method invoke it.    if (typeof stn === function) {
      stn.call(this);
    }     Otherwise parse the layout mode and settings from provided options and     do the calculations.    else {
       Parse the layout method name and settings from muuri settings.      var useDefaults = typeof stn === string;      var methodName = useDefaults ? stn : stn[0];
       Make sure the provided layout method exists.      if (typeof Muuri.Layout.methods[methodName] !== function) {        throw new Error(Layout method "" + method +  "" does not exist.);      }
       Invoke the layout method.      typeof Muuri.Layout.methods[methodName].call(this, useDefaults ? {} : stn[1]);
    }
  };
  /**   * Available layout methods.   *   *    *     */  Muuri.Layout.methods = {    firstFit: LayoutFirstFit  };
  /**   * Muuri - Settings   * ****************   */
  /**   * Default settings.   *   *    *     *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      */  Muuri.defaultSettings = {
     Container    container: null,
     Items    items: [],    positionDuration: 300,    positionEasing: ease-out,    show: {      duration: 300,      easing: ease-out    },    hide: {      duration: 300,      easing: ease-out    },
     Layout    layout: firstFit,    layoutOnResize: 100,    layoutOnInit: true,
     Drag & Drop    dragEnabled: false,    dragContainer: null,    dragPredicate: null,    dragSort: true,    dragSortInterval: 50,    dragSortTolerance: 50,    dragSortAction: move,    dragReleaseDuration: 300,    dragReleaseEasing: ease-out,
     Classnames    containerClass: muuri,    itemClass: muuri-item,    shownClass: muuri-shown,    hiddenClass: muuri-hidden,    positioningClass: muuri-positioning,    draggingClass: muuri-dragging,    releasingClass: muuri-releasing
  };
  /**   * Helpers - Generic   * *****************   */
  /**   * Swap array items.   *   *      *      *      */  function arraySwap(array, indexA, indexB) {
    var temp = array[indexA];    array[indexA] = array[indexB];    array[indexB] = temp;
  }
  /**   * Move array item to another index.   *   *      *      *      */  function arrayMove(array, fromIndex, toIndex) {
    array.splice(toIndex, 0, array.splice(fromIndex, 1)[0]);
  }
  /**   * Returns a new duplicate free version of the provided array.   *   *      *     */  function arrayUnique(array) {
    var ret = [];    for (var i = 0, len = array.length; i < len; i++) {      if (ret.indexOf(array[i]) === -1) {        ret[ret.length] = array[i];      }    }    return ret;
  }
  /**   * Check if a value is a plain object.   *   *      *     */  function isPlainObject(val) {
    return typeof val === object && Object.prototype.toString.call(val) === [object Object];
  }
  /**   * Merge properties of provided objects. The first argument is considered as   * the destination object which inherits the properties of the   * following argument objects. Merges object properties recursively if the   * property's type is object in destination object and the source object.   *   *      *      *   Returns the destination object.   */  function mergeObjects(dest) {
    var sources = Array.prototype.slice.call(arguments, 1);
    for (var i = 0; i < sources.length; i++) {      var source = sources[i];      for (var prop in source) {        if (source.hasOwnProperty(prop)) {          if (isPlainObject(dest[prop]) && isPlainObject(source[prop])) {            mergeObjects(dest[prop], source[prop]);          }          else {            dest[prop] = source[prop];          }        }      }    }
    return dest;
  }
  /**   * Returns a function, that, as long as it continues to be invoked, will not   * be triggered. The function will be called after it stops being called for   * N milliseconds. The returned function accepts one argument which, when   * being ""finish"", calls the debounced function immediately if it is currently   * waiting to be called, and when being ""cancel"" cancels the currently queued   * function call.   *   *      *      *     */  function debounce(fn, wait) {
    var timeout;    var actionCancel = cancel;    var actionFinish = finish;
    return function (action) {
      if (timeout !== undefined) {        timeout = global.clearTimeout(timeout);        if (action === actionFinish) {          fn();        }      }
      if (action !== actionCancel && action !== actionFinish) {        timeout = global.setTimeout(function () {          timeout = undefined;          fn();        }, wait);      }
    };
  }
  /**   * Get intersection area dimensions and position between two rectangles in 2d   * space.   *   *      *      *     */  function getIntersection(a, b) {
    var ret = null;    var overlap = {      left: a.left - b.left,      right: (b.left + b.width) - (a.left + a.width),      top: a.top - b.top,      bottom: (b.top + b.height) - (a.top + a.height)    };    var intersectionWidth = Math.max(a.width + Math.min(overlap.left, 0) + Math.min(overlap.right, 0), 0);    var intersectionHeight = Math.max(a.height + Math.min(overlap.top, 0) + Math.min(overlap.bottom, 0), 0);    var hasIntersection = intersectionWidth > 0 && intersectionHeight > 0;
    if (hasIntersection) {      ret = {};      ret.width = intersectionWidth;      ret.height = intersectionHeight;      ret.left = a.left + Math.abs(Math.min(overlap.left, 0));      ret.right = ret.left + ret.width;      ret.top = a.top + Math.abs(Math.min(overlap.top, 0));      ret.bottom = ret.top + ret.height;    }
    return ret;
  }
  /**   * Helpers - DOM utils   * *******************   */
  /**   * Returns the computed value of an element's style property as a string.   *   *      *      *     */  function getStyle(element, style) {
    return global.getComputedStyle(element, null).getPropertyValue(style);
  }
  /**   * Set inline styles to an element.   *   *      *      */  function setStyles(element, styles) {
    for (var prop in styles) {      element.style[prop] = styles[prop];    }
  }
  /**   * Set inline styles to an element with Velocity's hook method.   *   *      *      */  function hookStyles(element, styles) {
    for (var prop in styles) {      Velocity.hook(element, prop, styles[prop]);    }
  }
  /**   * Check if an element has a specific class name.   *   *      *      *     */  function hasClass(el, className) {
    return (  + el.className).indexOf(  + className) > -1;
  }
  /**   * Add class to an element.   *   *      *      */  function addClass(el, className) {
    if (el.classList) {      el.classList.add(className);    }    else if (hasClass(el, className)) {      el.className +=   + className;    }
  }
  /**   * Remove class name from an element.   *   *      */  function removeClass(el, className) {
    if (el.classList) {      el.classList.remove(className);    }    else if (hasClass(el, className)) {      el.className = (  + el.className +  ).replace(  + className +  ,  ).trim();    }
  }
  /**   * Get element's width/height with padding or with padding, border and margin.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L511-L609   *   *      *      *      */  function getDimension(el, dimension, withMargin) {
    var ret = el.getBoundingClientRect()[dimension];    var isHeight = dimension === height;    var dimensionCapitalized = isHeight ? Height : Width;    var innerDimension = inner + dimensionCapitalized;    var clientDimension = client + dimensionCapitalized;    var edgeA = isHeight ? top : left;    var edgeB = isHeight ? bottom : right;
    if (withMargin) {
      var marginA = parseFloat(getStyle(el, margin- + edgeA));      var marginB = parseFloat(getStyle(el, margin- + edgeB));      ret += marginA > 0 ? marginA : 0;      ret += marginB > 0 ? marginB : 0;
    }    else {
      var borderA;      var borderB;
      if (el === document.documentElement) {        ret -= global[innerDimension] - document.documentElement[clientDimension];      }      else {        borderA = parseFloat(getStyle(el, border- + edgeA + -width));        borderB = parseFloat(getStyle(el, border- + edgeB + -width));        ret -= Math.round(ret) - el[clientDimension] - borderA - borderB;      }
      ret -= borderA !== undefined ? borderA : parseFloat(getStyle(el, border- + edgeA + -width));      ret -= borderB !== undefined ? borderB : parseFloat(getStyle(el, border- + edgeB + -width));
    }
    return ret;
  }
  /**   * Returns the element's offset, which in practice means the vertical and   * horizontal distance between the element's northwest corner and the   * document's northwest corner. This method is a stripped down version of   * Mezr's offset method and tailored for Muuri specifically. By default the   * element's ""dimension edge"" is considered to be the element's padding layer.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L643-L714   *   *      *     */  function getOffset(el) {
    var offsetLeft = 0;    var offsetTop = 0;    var viewportScrollLeft = parseFloat(global.pageXOffset);    var viewportScrollTop = parseFloat(global.pageYOffset);
     For window we just need to get viewport's scroll distance.    if (el.self === global.self) {      offsetLeft = viewportScrollLeft;      offsetTop = viewportScrollTop;    }
     For all elements except the document and window we can use the combination of gbcr and     viewport's scroll distance.    else if (el !== document) {      var gbcr = el.getBoundingClientRect();      offsetLeft += gbcr.left + viewportScrollLeft + parseFloat(getStyle(el, border-left-width));      offsetTop += gbcr.top + viewportScrollTop + parseFloat(getStyle(el, border-top-width));    }
    return {      left: offsetLeft,      top: offsetTop    };
  }
  /**   * Returns the element's offset parent.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L808-L859   *   *      *     */  function getOffsetParent(el) {
    var isFixed = getStyle(el, position) === fixed;
    if (isFixed && hasBrokenW3CTELCS) {      return global;    }
    var offsetParent = el === document.documentElement || el === global ? document : el.parentElement || null;
    if (isFixed) {      while (offsetParent && offsetParent !== document && !isTransformed(offsetParent)) {        offsetParent = offsetParent.parentElement || document;      }      return offsetParent === document ? global : offsetParent;    }    else {      while (offsetParent && offsetParent !== document && getStyle(offsetParent, position) === static && !isTransformed(offsetParent)) {        offsetParent = offsetParent.parentElement || document;      }      return offsetParent;    }
  }
  /**   * Returns true if element is transformed, false if not. In practice the   * element's display value must be anything else than ""none"" or ""inline"" as   * well as have a valid transform value applied in order to be counted as a   * transformed element.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L302-L317   *   *      *     */  function isTransformed(el) {
    var transform = getStyle(el, supportedTransform.style);    var display = getStyle(el, display);
    return transform !== none && display !== inline && display !== none;
  }
  /**   * Calculate the offset difference of two elements. The target element is is   * always considered to be Muuri item's element which means that it's margins   * are considered to be part of it's width and height. The anchor element's   * width and height however always consist of the core and the padding only.   *   *      *      *     */  function getOffsetDiff(target, anchor) {
    var anchorOffset = getOffset(anchor);    var targetZeroPosition = getOffset(getOffsetParent(target) || doc);    targetZeroPosition.left -= Math.abs(Math.min(parseFloat(getStyle(target, margin-left)), 0));    targetZeroPosition.top -= Math.abs(Math.min(parseFloat(getStyle(target, margin-top)), 0));
    return {      left: anchorOffset.left - targetZeroPosition.left,      top: anchorOffset.top - targetZeroPosition.top    };
  }
  /**   * Get element's scroll parents.   *   * Borrowed from jQuery UI library (and heavily modified):   * https://github.com/jquery/jquery-ui/blob/63448148a217da7e64c04b21a04982f0d64aabaa/ui/scroll-parent.js   *   *      *     */  function getScrollParents(element) {
    var ret = [];    var overflowRegex = (autoscroll);    var parent = element.parentNode;
     If positioning of fixed elements is broken (according to W3C spec).    if (hasBrokenW3CTELCS) {
       If the element is fixed it can not have any scroll parents.      if (getStyle(element, position) === fixed) {        return ret;      }
       Find scroll parents.      while (parent && parent !== document && parent !== document.documentElement) {        if (overflowRegex.test(getStyle(parent, overflow) + getStyle(parent, overflow-y) + getStyle(parent, overflow-x))) {          ret[ret.length] = parent;        }        parent = getStyle(parent, position) === fixed ? null : parent.parentNode;      }
       If parent is not fixed element, add window object as the last scroll       parent.      if (parent !== null) {        ret[ret.length] = global;      }
    }     If fixed elements behave as defined in the W3C specification.    else {
       Find scroll parents.      while (parent && parent !== document) {
         If the currently looped element is fixed ignore all parents that are         not transformed.        if (getStyle(element, position) === fixed && !isTransformed(parent)) {          parent = parent.parentNode;          continue;        }
         Add the parent element to return items if it is scrollable.        if (overflowRegex.test(getStyle(parent, overflow) + getStyle(parent, overflow-y) + getStyle(parent, overflow-x))) {          ret[ret.length] = parent;        }
         Update element and parent references.        element = parent;        parent = parent.parentNode;
      }
       Replace reference of possible root element to window object.      if (ret.length && ret[ret.length - 1] === document.documentElement) {        ret[ret.length - 1] = global;      }
    }
    return ret;
  }
  /**   * Helpers - Muuri   * ***************   */
  /**   * Calculate how many percent the intersection area of two items is from the   * maximum potential intersection area between the items.   *   *      *      *   A number between 0-100.   */  function getOverlapScore(a, b) {
    var intersection = getIntersection(a, b);
    if (!intersection) {      return 0;    }
    var aUnpos = {      width: a.width,      height: a.height,      left: 0,      top: 0    };
    var bUnpos = {      width: b.width,      height: b.height,      left: 0,      top: 0    };
    var maxIntersection = getIntersection(aUnpos, bUnpos);
    return (intersection.width * intersection.height) / (maxIntersection.width * maxIntersection.height) * 100;
  }
  /**   * Return parsed drag event data.   *   *      *      *      *     */  function generateDragEvent(type, event, drag) {
    return {      type: type,      event: event,      currentLeft: drag.left,      currentTop: drag.top,      gridLeft: drag.gridX,      gridTop: drag.gridY    };
  }
  /**   * Default drag start predicate handler. The context of the function is   * always a temporary object which is gets reset on each draginit event.   *   *      *      *      */  function dragPredicate(e, item, resolve) {
    if (!this.isResolved) {      this.isResolved = true;      resolve(e);    }
  }
  /**   * Lock dragged element's dimensions.   *   *      */  function lockElementSize(data) {
     Don't override existing element styles.    if (!data.elementStyles) {
      var styles = [width, height, padding, margin];
       Reset element styles.      data.elementStyles = {};
       Store current inline style values.      for (var i = 0; i < 4; i++) {        var style = styles[i];        var value = data.element.style[style];        data.elementStyles[style] = value || ;      }
       Set effective values as inline styles.      for (var i = 0; i < 4; i++) {        var style = styles[i];        data.element.style[style] = getStyle(data.element, style);      }
    }
  }
  /**   * Unlock dragged element's dimensions.   *   *      */  function unlockElementSize(data) {
    if (data.elementStyles) {      for (var style in data.elementStyles) {        data.element.style[style] = data.elementStyles[style];      }    }
  }
  /**   * Show/hide Muuri instance's items.   *   *    *      *    - ""show"" or ""hide"".   *      *      *      */  function showHideHandler(inst, method, items, instant, callback) {
     Sanitize items.    items = inst.get(items);
     Sanitize callback.    callback = typeof instant === function ? instant : callback;
    var counter = items.length;
     If there are no items call the callback, but don't emit any events.    if (!counter) {
      if (typeof callback === function) {        callback(items);      }
    }     If we have some items let's dig in.    else {
      var isShow = method === show;      var startEvent = isShow ? evShowStart : evHideStart;      var endEvent = isShow ? evShowEnd : evHideEnd;      var isInstant = instant === true;      var completed = [];      var needsRelayout = false;      var hiddenItems = [];
       Emit showstart event.      inst._emitter.emit(startEvent, items);
       Show/hide items. The loop cycle must be wrapped in a function in order       to keep the correct reference of the item for the asynchronous callback       of the item's private show/hide method.      for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
         Check if relayout or refresh is needed.        if ((isShow && !item._active) || (!isShow && item._active)) {          needsRelayout = true;          if (isShow) {            item._noLayoutAnimation = true;            hiddenItems[hiddenItems.length] = item;          }        }
         Hide/show the item.        item[_ + method](isInstant, function (interrupted, item) {
           If the current item's animation was not interrupted add it to the           completed set.          if (!interrupted) {            completed[completed.length] = item;          }
           If all items have finished their animations call the callback           and emit the event.          if (--counter < 1) {            if (typeof callback === function) {              callback(completed);            }            inst._emitter.emit(endEvent, completed);          }
        });
      }
       Relayout only if needed.      if (needsRelayout) {        if (hiddenItems.length) {          inst.refresh(hiddenItems);        }        inst.layout();      }
    }
  }
  /**   * Default item show/hide animation flow. Returns and object that contains   * the animation start and stop method.   *   *      *      *     */  function showHideAnimation(opts, isShow) {
    var duration = (opts && opts.duration) || 0;    var easing = (opts && opts.easing) || ease-out;
    if (!duration) {      return {        start: noop,        stop: noop      };    }    else {      var targetStyles = isShow ? {opacity: 1, scale: 1} : {opacity: 0, scale: 0.5};      return {        start: function (item, instant, animDone) {          if (instant) {            hookStyles(item._child, targetStyles);          }          else {            Velocity(item._child, targetStyles, {              duration: duration,              easing: easing,              queue: item._muuri._animQueue,              complete: animDone            });            Velocity.Utilities.dequeue(item._child, item._muuri._animQueue);          }        },        stop: function (item) {          Velocity(item._child, stop, item._muuri._animQueue);        }      };    }
  }
  /**   * Process item's callback queue.   *   *    *      *      *      */  function processQueue(queue, interrupted, instance) {
    var snapshot = queue.splice(0, queue.length);    for (var i = 0, len = snapshot.length; i < len; i++) {      snapshot[i](interrupted, instance);    }
  }
  /**   * Init   */
  return Muuri;
}));"
"module.exports = function (config) {
  var package = require(./package.json);
     Define Sauce Labs browsers.  
  var browsers = [     IE    [Windows 7, internet explorer, 9.0],    [Windows 8, internet explorer, 10.0],    [Windows 8.1, internet explorer, 11.0],     Edge    [Windows 10, MicrosoftEdge, 13.10586],     Firefox    [Windows 10, firefox, 48.0],    [OS X 10.11, firefox, 48.0],     Chrome    [Windows 10, chrome, 53.0],    [OS X 10.11, chrome, 53.0],     Safari    [OS X 10.8, safari, 6.0],    [OS X 10.9, safari, 7.0],    [OS X 10.10, safari, 8.0],    [OS X 10.11, safari, 9.0]  ];
     Generate Sauce Labs launchers.  
  var launchers = {};  browsers.forEach(function (browser) {
    var launcher = {      base: SauceLabs,      platform: browser[0],      browserName: browser[1],      version: browser[2]    };    var key = launcher.platform +  -  + launcher.browserName + (launcher.version ?  -  + launcher.version : );
    if (launcher.browserName === iphone) {      launcher.deviceName = iPhone Simulator;      launcher.deviceOrientation = portrait;    }
    if (launcher.browserName === android) {      launcher.deviceName = Android Emulator;      launcher.deviceOrientation = portrait;    }
    launchers[key] = launcher;
  });
     Karma settings.  
  var stn = {};
  stn.basePath = ;
   https://npmjs.org/browse/keyword/karma-adapter  stn.frameworks = [    qunit  ];
   plugins to use  stn.plugins = [    karma-qunit,    karma-sauce-launcher,    karma-story-reporter  ];
   list of files / patterns to load in the browser  stn.files = [    package.main,    ./tests/tests.js  ];
   list of files to exclude  stn.exclude = [];
   preprocess matching files before serving them to the browser   https://npmjs.org/browse/keyword/karma-preprocessor  stn.preprocessors = {};  stn.preprocessors[package.main] = ['coverage'];
   possible values: 'dots', 'progress', 'story'   https://npmjs.org/browse/keyword/karma-reporter  stn.reporters = [    story,    saucelabs  ];
   enable / disable colors in the output (reporters and logs)  stn.colors = true;
   level of logging   possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG  stn.logLevel = config.LOG_INFO;
  stn.autoWatch = false;
  stn.customLaunchers = launchers;
  stn.browsers = Object.keys(launchers);
  stn.captureTimeout = 240000;
  stn.browserDisconnectTimeout = 5000;
  stn.browserDisconnectTolerance = 4;
  stn.singleRun = true;
  stn.sauceLabs = {    testName: package.name +  -  + package.version +  - unit tests  };
  stn.hostname = 127.0.0.1;
  config.set(stn);
};"
"var package = require(./package.json);var fs = require(fs);var gulp = require(gulp);var jscs = require(gulp-jscs);var karma = require(karma);var uglify = require(gulp-uglify);var rename = require(gulp-rename);var size = require(gulp-size);var rimraf = require(rimraf);var runSequence = require(run-sequence);var fileExists = function (filePath) {  try {    return fs.statSync(filePath).isFile();  } catch (err) {    return false;  }};
 Load environment variables if .env file existsif (fileExists(./.env)) {  require(dotenv).load();}
gulp.task(validate, function () {
  return gulp  .src(package.main)  .pipe(jscs())  .pipe(jscs.reporter());
});
gulp.task(compress, function() {
  var mainMinified = package.main.replace(./, ).replace(.js, .min.js);
  return gulp  .src(package.main)  .pipe(size({title: development}))  .pipe(uglify({    preserveComments: some  }))  .pipe(size({title: minified}))  .pipe(size({title: gzipped, gzip: true}))  .pipe(rename(mainMinified))  .pipe(gulp.dest(./));
});
gulp.task(test, function (done) {
  (new karma.Server({    configFile: __dirname + /karma.conf.js,    action: run  }, function (exitCode) {    done(exitCode);  })).start();
});
gulp.task(clean, function (cb) {
  rimraf(./*.log, function () {    rimraf(./coverage, cb);  });
});
gulp.task(default, function (done) {
  if (process.env.CI) {    runSequence(validate, compress, test, clean, done);  }  else {    runSequence(validate, compress, test, done);  }
});"
"module.exports = function (config) {  config.set({    browsers: [PhantomJS],    frameworks: [jasmine],    files: [test/**/*.js],    reporters: [spec],    preprocessors: {      test/*.js: [webpack]    },    singleRun: true,
    webpack: {       karma watches the test entry points       (you don't need to specify the entry option)      module: {        loaders: [          {            test: js,            loader: babel,            exclude: node_modules          },        ]      }    },
    webpackMiddleware: {      noInfo: true    }  });};"
"let SortableListView = require(./index);let React = require(react);let {  View,  Text,  TouchableHighlight} = require(react-native);

let data = {  hello: {text: world},  how: {text: are you},  test: {text: 123},  this: {text: is},  a: {text: a},  real: {text: real},  drag: {text: drag and drop},  bb: {text: bb},  cc: {text: cc},  dd: {text: dd},  ee: {text: ee},  ff: {text: ff},  gg: {text: gg},  hh: {text: hh},  ii: {text: ii},  jj: {text: jj},  kk: {text: kk}}
let order = Object.keys(data); Array of keys
let RowComponent = React.createClass({  render: function() {    return <TouchableHighlight underlayColor={#eee} style={{padding: 25, backgroundColor: #F8F8F8, borderBottomWidth:1, borderColor: #eee}} {...this.props.sortHandlers}>        <Text>{this.props.data.text}</Text>      </TouchableHighlight>  }})
let MyComponent = React.createClass({  render: function() {    return <SortableListView          style={{flex: 1}}          data={data}          order={order}          onRowMoved={e => {            order.splice(e.to, 0, order.splice(e.from, 1)[0]);            this.forceUpdate();          }}          renderRow={row => <RowComponent data={row} />}        />  }});
module.exports = MyComponent;"
"use strict; generated on 2015-04-04 using generator-gulp-webapp 0.1.0
var gulp = require(gulp);
 load pluginsvar $ = require(gulp-load-plugins)();const babel = require(gulp-babel);
gulp.task(scripts, function () {    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))        .pipe($.jshint())        .pipe($.jshint.reporter(require(jshint-stylish)))        .pipe($.size());});

var rename = require(gulp-rename);
gulp.task(buildjs, [scripts], function () {    var jsFilter = $.filter(**/*.js, {restore: true});
    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))            .pipe(gulp.dest(dist))        .pipe($.size());});
gulp.task(js, [buildjs], function () {    var jsFilter = $.filter(**/*.js, {restore: true});
    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))            .pipe($.uglify())        .pipe(rename({            suffix: .min        }))        .pipe(gulp.dest(dist))        .pipe($.size());});
gulp.task(clean, function () {    return gulp.src([.tmp, dist], { read: false }).pipe($.clean());});
gulp.task(build, [js, copy-js, main-bower-files],function(){        return gulp.src(./bower_components/vue/dist/vue.js)        .pipe(gulp.dest(./examples/libs/vue/dist));        });
gulp.task(default, [clean], function () {    gulp.start(build);});
gulp.task(connect, function () {    var connect = require(connect);    var serveStatic = require(serve-static);    var serveIndex  = require(serve-index);    var app = connect()        .use(require(connect-livereload)({ port: 35729 }))        .use(serveStatic(.tmp))        .use(serveStatic(examples))        .use(serveIndex(examples));
    require(http).createServer(app)        .listen(9000)        .on(listening, function () {            console.log(Started connect web server on http://localhost:9000);        });});
gulp.task(serve, [connect], function () {    require(opn)(http://localhost:9000);});
var mainBowerFiles = require(gulp-main-bower-files);
gulp.task(main-bower-files, function() {    return gulp.src(./bower.json)        .pipe(mainBowerFiles())        .pipe(gulp.dest(./examples/libs));});
gulp.task(copy-js, function() {    return gulp.src(src/**/*.js)                .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))           .pipe(gulp.dest(./examples/src));});
var jip = require(jasmine-istanbul-phantom);var changedSpec = null
gulp.task(test, function(done) {  var options = { callback: done, lib : [bower_components/**/*.js] }
  if (changedSpec)    options.spec = changedSpec
  jip(options)
  changedSpec = null}); gulp.task(watch, [connect, serve], function () {    var server = $.livereload;    server.listen();     watch for changes    gulp.watch([        examples/*.html,        src/**/*.js,        examples/**/*.js,    ]).on(change, server.changed);

    gulp.watch(./bower.json).on(change, function() {        gulp.start(main-bower-files)    });     gulp.watch(src/**/*.js, [scripts]);
    gulp.watch(src/**/*.js).on(change, function() {        gulp.start(copy-js);        gulp.start(test);    });
    gulp.watch(test/spec/*.js).on(change, function(event){        changedSpec = event.path        gulp.start(test)    });
});"
"
(function($){$.extend({tablesorter:newfunction(){var parsers=[],widgets=[];this.defaults={cssHeader:""header"",cssAsc:""headerSortUp"",cssDesc:""headerSortDown"",cssChildRow:""expand-child"",sortInitialOrder:""asc"",sortMultiSortKey:""shiftKey"",sortForce:null,sortAppend:null,sortLocaleCompare:true,textExtraction:""simple"",parsers:{},widgets:[],widgetZebra:{css:[""even"",""odd""]},headers:{},widthFixed:false,cancelSelection:true,sortList:[],headerList:[],dateFormat:""us"",decimal:'/\.|\,/g',onRenderHeader:null,selectorHeaders:'thead th',debug:false};function benchmark(s,d){log(s+"",""+(new Date().getTime()-d.getTime())+""ms"");}this.benchmark=benchmark;function log(s){if(typeof console!=""undefined""&&typeof console.debug!=""undefined""){console.log(s);}else{alert(s);}}function buildParserCache(table,$headers){if(table.config.debug){var parsersDebug="""";}if(table.tBodies.length==0)return;var rows=table.tBodies[0].rows;if(rows[0]){var list=[],cells=rows[0].cells,l=cells.length;for(var i=0;i<l;i++){var p=false;if($.metadata&&($($headers[i]).metadata()&&$($headers[i]).metadata().sorter)){p=getParserById($($headers[i]).metadata().sorter);}else if((table.config.headers[i]&&table.config.headers[i].sorter)){p=getParserById(table.config.headers[i].sorter);}if(!p){p=detectParserForColumn(table,rows,-1,i);}if(table.config.debug){parsersDebug+=""column:""+i+"" parser:""+p.id+""\n"";}list.push(p);}}if(table.config.debug){log(parsersDebug);}return list;};function detectParserForColumn(table,rows,rowIndex,cellIndex){var l=parsers.length,node=false,nodeValue=false,keepLooking=true;while(nodeValue==''&&keepLooking){rowIndex++;if(rows[rowIndex]){node=getNodeFromRowAndCellIndex(rows,rowIndex,cellIndex);nodeValue=trimAndGetNodeText(table.config,node);if(table.config.debug){log('Checking if value was empty on row:'+rowIndex);}}else{keepLooking=false;}}for(var i=1;i<l;i++){if(parsers[i].is(nodeValue,table,node)){return parsers[i];}}return parsers[0];}function getNodeFromRowAndCellIndex(rows,rowIndex,cellIndex){return rows[rowIndex].cells[cellIndex];}function trimAndGetNodeText(config,node){return $.trim(getElementText(config,node));}function getParserById(name){var l=parsers.length;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==name.toLowerCase()){return parsers[i];}}return false;}function buildCache(table){if(table.config.debug){var cacheTime=new Date();}var totalRows=(table.tBodies[0]&&table.tBodies[0].rows.length)||0,totalCells=(table.tBodies[0].rows[0]&&table.tBodies[0].rows[0].cells.length)||0,parsers=table.config.parsers,cache={row:[],normalized:[]};for(var i=0;i<totalRows;++i){var c=$(table.tBodies[0].rows[i]),cols=[];if(c.hasClass(table.config.cssChildRow)){cache.row[cache.row.length-1]=cache.row[cache.row.length-1].add(c);continue;}cache.row.push(c);for(var j=0;j<totalCells;++j){cols.push(parsers[j].format(getElementText(table.config,c[0].cells[j]),table,c[0].cells[j]));}cols.push(cache.normalized.length);cache.normalized.push(cols);cols=null;};if(table.config.debug){benchmark(""Building cache for ""+totalRows+"" rows:"",cacheTime);}return cache;};function getElementText(config,node){var text="""";if(!node)return"""";if(!config.supportsTextContent)config.supportsTextContent=node.textContent||false;if(config.textExtraction==""simple""){if(config.supportsTextContent){text=node.textContent;}else{if(node.childNodes[0]&&node.childNodes[0].hasChildNodes()){text=node.childNodes[0].innerHTML;}else{text=node.innerHTML;}}}else{if(typeof(config.textExtraction)==""function""){text=config.textExtraction(node);}else{text=$(node).text();}}return text;}function appendToTable(table,cache){if(table.config.debug){var appendTime=new Date()}var c=cache,r=c.row,n=c.normalized,totalRows=n.length,checkCell=(n[0].length-1),tableBody=$(table.tBodies[0]),rows=[];for(var i=0;i<totalRows;i++){var pos=n[i][checkCell];rows.push(r[pos]);if(!table.config.appender){var l=r[pos].length;for(var j=0;j<l;j++){tableBody[0].appendChild(r[pos][j]);}}}if(table.config.appender){table.config.appender(table,rows);}rows=null;if(table.config.debug){benchmark(""Rebuilt table:"",appendTime);}applyWidget(table);setTimeout(function(){$(table).trigger(""sortEnd"");},0);};function buildHeaders(table){if(table.config.debug){var time=new Date();}var meta=($.metadata)?true:false;var header_index=computeTableHeaderCellIndexes(table);$tableHeaders=$(table.config.selectorHeaders,table).each(function(index){this.column=header_index[this.parentNode.rowIndex+""-""+this.cellIndex];this.order=formatSortingOrder(table.config.sortInitialOrder);this.count=this.order;if(checkHeaderMetadata(this)||checkHeaderOptions(table,index))this.sortDisabled=true;if(checkHeaderOptionsSortingLocked(table,index))this.order=this.lockedOrder=checkHeaderOptionsSortingLocked(table,index);if(!this.sortDisabled){var $th=$(this).addClass(table.config.cssHeader);if(table.config.onRenderHeader)table.config.onRenderHeader.apply($th);}table.config.headerList[index]=this;});if(table.config.debug){benchmark(""Built headers:"",time);log($tableHeaders);}return $tableHeaders;};function computeTableHeaderCellIndexes(t){var matrix=[];var lookup={};var thead=t.getElementsByTagName('THEAD')[0];var trs=thead.getElementsByTagName('TR');for(var i=0;i<trs.length;i++){var cells=trs[i].cells;for(var j=0;j<cells.length;j++){var c=cells[j];var rowIndex=c.parentNode.rowIndex;var cellId=rowIndex+""-""+c.cellIndex;var rowSpan=c.rowSpan||1;var colSpan=c.colSpan||1var firstAvailCol;if(typeof(matrix[rowIndex])==""undefined""){matrix[rowIndex]=[];}for(var k=0;k<matrix[rowIndex].length+1;k++){if(typeof(matrix[rowIndex][k])==""undefined""){firstAvailCol=k;break;}}lookup[cellId]=firstAvailCol;for(var k=rowIndex;k<rowIndex+rowSpan;k++){if(typeof(matrix[k])==""undefined""){matrix[k]=[];}var matrixrow=matrix[k];for(var l=firstAvailCol;l<firstAvailCol+colSpan;l++){matrixrow[l]=""x"";}}}}return lookup;}function checkCellColSpan(table,rows,row){var arr=[],r=table.tHead.rows,c=r[row].cells;for(var i=0;i<c.length;i++){var cell=c[i];if(cell.colSpan>1){arr=arr.concat(checkCellColSpan(table,headerArr,row++));}else{if(table.tHead.length==1||(cell.rowSpan>1||!r[row+1])){arr.push(cell);}}}return arr;};function checkHeaderMetadata(cell){if(($.metadata)&&($(cell).metadata().sorter===false)){return true;};return false;}function checkHeaderOptions(table,i){if((table.config.headers[i])&&(table.config.headers[i].sorter===false)){return true;};return false;}function checkHeaderOptionsSortingLocked(table,i){if((table.config.headers[i])&&(table.config.headers[i].lockedOrder))return table.config.headers[i].lockedOrder;return false;}function applyWidget(table){var c=table.config.widgets;var l=c.length;for(var i=0;i<l;i++){getWidgetById(c[i]).format(table);}}function getWidgetById(name){var l=widgets.length;for(var i=0;i<l;i++){if(widgets[i].id.toLowerCase()==name.toLowerCase()){return widgets[i];}}};function formatSortingOrder(v){if(typeof(v)!=""Number""){return(v.toLowerCase()==""desc"")?1:0;}else{return(v==1)?1:0;}}function isValueInArray(v,a){var l=a.length;for(var i=0;i<l;i++){if(a[i][0]==v){return true;}}return false;}function setHeadersCss(table,$headers,list,css){$headers.removeClass(css[0]).removeClass(css[1]);var h=[];$headers.each(function(offset){if(!this.sortDisabled){h[this.column]=$(this);}});var l=list.length;for(var i=0;i<l;i++){h[list[i][0]].addClass(css[list[i][1]]);}}function fixColumnWidth(table,$headers){var c=table.config;if(c.widthFixed){var colgroup=$('<colgroup>');$(""tr:first td"",table.tBodies[0]).each(function(){colgroup.append($('<col>').css('width',$(this).width()));});$(table).prepend(colgroup);};}function updateHeaderSortCount(table,sortList){var c=table.config,l=sortList.length;for(var i=0;i<l;i++){var s=sortList[i],o=c.headerList[s[0]];o.count=s[1];o.count++;}}function multisort(table,sortList,cache){if(table.config.debug){var sortTime=new Date();}var dynamicExp=""var sortWrapper = function(a,b) {"",l=sortList.length;for(var i=0;i<l;i++){var c=sortList[i][0];var order=sortList[i][1];var s=(table.config.parsers[c].type==""text"")?((order==0)?makeSortFunction(""text"",""asc"",c):makeSortFunction(""text"",""desc"",c)):((order==0)?makeSortFunction(""numeric"",""asc"",c):makeSortFunction(""numeric"",""desc"",c));var e=""e""+i;dynamicExp+=""var ""+e+"" = ""+s;dynamicExp+=""if(""+e+"") { return ""+e+""; } "";dynamicExp+=""else { "";}var orgOrderCol=cache.normalized[0].length-1;dynamicExp+=""return a[""+orgOrderCol+""]-b[""+orgOrderCol+""];"";for(var i=0;i<l;i++){dynamicExp+=""}; "";}dynamicExp+=""return 0; "";dynamicExp+=""}; "";if(table.config.debug){benchmark(""Evaling expression:""+dynamicExp,new Date());}eval(dynamicExp);cache.normalized.sort(sortWrapper);if(table.config.debug){benchmark(""Sorting on ""+sortList.toString()+"" and dir ""+order+"" time:"",sortTime);}return cache;};function makeSortFunction(type,direction,index){var a=""a[""+index+""]"",b=""b[""+index+""]"";if(type=='text'&&direction=='asc'){return""(""+a+"" == ""+b+"" ? 0 : (""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : (""+a+"" < ""+b+"") ? -1 : 1 )));"";}else if(type=='text'&&direction=='desc'){return""(""+a+"" == ""+b+"" ? 0 : (""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : (""+b+"" < ""+a+"") ? -1 : 1 )));"";}else if(type=='numeric'&&direction=='asc'){return""(""+a+"" === null && ""+b+"" === null) ? 0 :(""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : ""+a+"" - ""+b+""));"";}else if(type=='numeric'&&direction=='desc'){return""(""+a+"" === null && ""+b+"" === null) ? 0 :(""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : ""+b+"" - ""+a+""));"";}};function makeSortText(i){return""((a[""+i+""] < b[""+i+""]) ? -1 : ((a[""+i+""] > b[""+i+""]) ? 1 : 0));"";};function makeSortTextDesc(i){return""((b[""+i+""] < a[""+i+""]) ? -1 : ((b[""+i+""] > a[""+i+""]) ? 1 : 0));"";};function makeSortNumeric(i){return""a[""+i+""]-b[""+i+""];"";};function makeSortNumericDesc(i){return""b[""+i+""]-a[""+i+""];"";};function sortText(a,b){if(table.config.sortLocaleCompare)return a.localeCompare(b);return((a<b)?-1:((a>b)?1:0));};function sortTextDesc(a,b){if(table.config.sortLocaleCompare)return b.localeCompare(a);return((b<a)?-1:((b>a)?1:0));};function sortNumeric(a,b){return a-b;};function sortNumericDesc(a,b){return b-a;};function getCachedSortType(parsers,i){return parsers[i].type;};this.construct=function(settings){return this.each(function(){if(!this.tHead||!this.tBodies)return;var $this,$document,$headers,cache,config,shiftDown=0,sortOrder;this.config={};config=$.extend(this.config,$.tablesorter.defaults,settings);$this=$(this);$.data(this,""tablesorter"",config);$headers=buildHeaders(this);this.config.parsers=buildParserCache(this,$headers);cache=buildCache(this);var sortCSS=[config.cssDesc,config.cssAsc];fixColumnWidth(this);$headers.click(function(e){var totalRows=($this[0].tBodies[0]&&$this[0].tBodies[0].rows.length)||0;if(!this.sortDisabled&&totalRows>0){$this.trigger(""sortStart"");var $cell=$(this);var i=this.column;this.order=this.count++%2;if(this.lockedOrder)this.order=this.lockedOrder;if(!e[config.sortMultiSortKey]){config.sortList=[];if(config.sortForce!=null){var a=config.sortForce;for(var j=0;j<a.length;j++){if(a[j][0]!=i){config.sortList.push(a[j]);}}}config.sortList.push([i,this.order]);}else{if(isValueInArray(i,config.sortList)){for(var j=0;j<config.sortList.length;j++){var s=config.sortList[j],o=config.headerList[s[0]];if(s[0]==i){o.count=s[1];o.count++;s[1]=o.count%2;}}}else{config.sortList.push([i,this.order]);}};setTimeout(function(){setHeadersCss($this[0],$headers,config.sortList,sortCSS);appendToTable($this[0],multisort($this[0],config.sortList,cache));},1);return false;}}).mousedown(function(){if(config.cancelSelection){this.onselectstart=function(){return false};return false;}});$this.bind(""update"",function(){var me=this;setTimeout(function(){me.config.parsers=buildParserCache(me,$headers);cache=buildCache(me);},1);}).bind(""updateCell"",function(e,cell){var config=this.config;var pos=[(cell.parentNode.rowIndex-1),cell.cellIndex];cache.normalized[pos[0]][pos[1]]=config.parsers[pos[1]].format(getElementText(config,cell),cell);}).bind(""sorton"",function(e,list){$(this).trigger(""sortStart"");config.sortList=list;var sortList=config.sortList;updateHeaderSortCount(this,sortList);setHeadersCss(this,$headers,sortList,sortCSS);appendToTable(this,multisort(this,sortList,cache));}).bind(""appendCache"",function(){appendToTable(this,cache);}).bind(""applyWidgetId"",function(e,id){getWidgetById(id).format(this);}).bind(""applyWidgets"",function(){applyWidget(this);});if($.metadata&&($(this).metadata()&&$(this).metadata().sortlist)){config.sortList=$(this).metadata().sortlist;}if(config.sortList.length>0){$this.trigger(""sorton"",[config.sortList]);}applyWidget(this);});};this.addParser=function(parser){var l=parsers.length,a=true;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==parser.id.toLowerCase()){a=false;}}if(a){parsers.push(parser);};};this.addWidget=function(widget){widgets.push(widget);};this.formatFloat=function(s){var i=parseFloat(s);return(isNaN(i))?0:i;};this.formatInt=function(s){var i=parseInt(s);return(isNaN(i))?0:i;};this.isDigit=function(s,config){return/^[-+]?\d*$/.test($.trim(s.replace(/[,.']/g,'')));};this.clearTableBody=function(table){if($.browser.msie){function empty(){while(this.firstChild)this.removeChild(this.firstChild);}empty.apply(table.tBodies[0]);}else{table.tBodies[0].innerHTML="""";}};}});$.fn.extend({tablesorter:$.tablesorter.construct});var ts=$.tablesorter;ts.addParser({id:""text"",is:function(s){return true;},format:function(s){return $.trim(s.toLocaleLowerCase());},type:""text""});ts.addParser({id:""digit"",is:function(s,table){var c=table.config;return $.tablesorter.isDigit(s,c);},format:function(s){return $.tablesorter.formatFloat(s);},type:""numeric""});ts.addParser({id:""currency"",is:function(s){return/^[£$€?.]/.test(s);},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/[£$€]/g),""""));},type:""numeric""});ts.addParser({id:""ipAddress"",is:function(s){return/^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);},format:function(s){var a=s.split("".""),r="""",l=a.length;for(var i=0;i<l;i++){var item=a[i];if(item.length==2){r+=""0""+item;}else{r+=item;}}return $.tablesorter.formatFloat(r);},type:""numeric""});ts.addParser({id:""url"",is:function(s){return/^(https?|ftp|file):\/\/$/.test(s);},format:function(s){return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//),''));},type:""text""});ts.addParser({id:""isoDate"",is:function(s){return/^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);},format:function(s){return $.tablesorter.formatFloat((s!="""")?new Date(s.replace(new RegExp(/-/g),""/"")).getTime():""0"");},type:""numeric""});ts.addParser({id:""percent"",is:function(s){return/\%$/.test($.trim(s));},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g),""""));},type:""numeric""});ts.addParser({id:""usLongDate"",is:function(s){return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));},format:function(s){return $.tablesorter.formatFloat(new Date(s).getTime());},type:""numeric""});ts.addParser({id:""shortDate"",is:function(s){return/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);},format:function(s,table){var c=table.config;s=s.replace(/\-/g,""/"");if(c.dateFormat==""us""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,""$3/$1/$2"");}else if (c.dateFormat == ""pt"") {s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, ""$3/$2/$1"");} else if(c.dateFormat==""uk""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,""$3/$2/$1"");}else if(c.dateFormat==""dd/mm/yy""||c.dateFormat==""dd-mm-yy""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/,""$1/$2/$3"");}return $.tablesorter.formatFloat(new Date(s).getTime());},type:""numeric""});ts.addParser({id:""time"",is:function(s){return/^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);},format:function(s){return $.tablesorter.formatFloat(new Date(""2000/01/01 ""+s).getTime());},type:""numeric""});ts.addParser({id:""metadata"",is:function(s){return false;},format:function(s,table,cell){var c=table.config,p=(!c.parserMetadataName)?'sortValue':c.parserMetadataName;return $(cell).metadata()[p];},type:""numeric""});ts.addWidget({id:""zebra"",format:function(table){if(table.config.debug){var time=new Date();}var $tr,row=-1,odd;$(""tr:visible"",table.tBodies[0]).each(function(i){$tr=$(this);if(!$tr.hasClass(table.config.cssChildRow))row++;odd=(row%2==0);$tr.removeClass(table.config.widgetZebra.css[odd?0:1]).addClass(table.config.widgetZebra.css[odd?1:0])});if(table.config.debug){$.tablesorter.benchmark(""Applying Zebra widget"",time);}}});})(jQuery);"
"/* *  * TableSorter 2.0 - Client-side table sorting with ease! * Version 2.0.5b * @requires jQuery v1.2.3 *  * Copyright (c) 2007 Christian Bach * Examples and docs at: http://tablesorter.com * Dual licensed under the MIT and GPL licenses: * http://www.opensource.org/licenses/mit-license.php * http://www.gnu.org/licenses/gpl.html *  *//** *  *  Create a sortable table with multi-column sorting capabilitys *  *   *  Create a simple tablesorter interface. *  *   *  Create a tablesorter interface and sort on the first and secound column column headers. *  *   *           *  Create a tablesorter interface and disableing the first and second  column headers. *       *  *   *  *  Create a tablesorter interface and set a column parser for the first *       and second column. *  *  *   *            settings An object literal containing key/value pairs to provide *            optional settings. *  *  * @option String cssHeader (optional) A string of the class name to be appended *         to sortable tr elements in the thead of the table. Default value: *         ""header"" *  * @option String cssAsc (optional) A string of the class name to be appended to *         sortable tr elements in the thead on a ascending sort. Default value: *         ""headerSortUp"" *  * @option String cssDesc (optional) A string of the class name to be appended *         to sortable tr elements in the thead on a descending sort. Default *         value: ""headerSortDown"" *  * @option String sortInitialOrder (optional) A string of the inital sorting *         order can be asc or desc. Default value: ""asc"" *  * @option String sortMultisortKey (optional) A string of the multi-column sort *         key. Default value: ""shiftKey"" *  * @option String textExtraction (optional) A string of the text-extraction *         method to use. For complex html structures inside td cell set this *         option to ""complex"", on large tables the complex option can be slow. *         Default value: ""simple"" *  * @option Object headers (optional) An object of instructions for per-column *         controls in the format: headers: { 0: { option: setting }, ... }. For  *         example, to disable sorting on the first two columns of a table: *         headers: { 0: { sorter: false}, 1: {sorter: false} }. *         Default value: null. *  * @option Array sortList (optional) An array of instructions for per-column sorting  *         and direction in the format: [[columnIndex, sortDirection], ... ] where  *         columnIndex is a zero-based index for your columns left-to-right and  *         sortDirection is 0 for Ascending and 1 for Descending. A valid argument  *         that sorts ascending first by column 1 and then column 2 looks like:  *         [[0,0],[1,0]]. Default value: null. *  * @option Array sortForce (optional) An array containing forced sorting rules. *         Use to add an additional forced sort that will be appended to the dynamic *         selections by the user. For example, can be used to sort people alphabetically *         after some other user-selected sort that results in rows with the same value  *         like dates or money due. It can help prevent data from appearing as though it  *         has a random secondary sort. Default value: null. *  * @option Boolean sortLocaleCompare (optional) Boolean flag indicating whatever *         to use String.localeCampare method or not. Default set to true. *  *  * @option Array sortAppend (optional) An array containing forced sorting rules. *         This option let's you specify a default sorting rule, which is *         appended to user-selected rules. Default value: null *  * @option Boolean widthFixed (optional) Boolean flag indicating if tablesorter *         should apply fixed widths to the table columns. This is usefull when *         using the pager companion plugin. This options requires the dimension *         jquery plugin. Default value: false *  * @option Boolean cancelSelection (optional) Boolean flag indicating if *         tablesorter should cancel selection of the table headers text. *         Default value: true *  * @option Boolean debug (optional) Boolean flag indicating if tablesorter *         should display debuging information usefull for development. *  *  jQuery *  *   *  * @cat Plugins/Tablesorter *  *  /christian.bach@polyester.se */
(function ($) {    $.extend({        tablesorter: new        function () {
            var parsers = [],                widgets = [];
            this.defaults = {                cssHeader: header,                cssAsc: headerSortUp,                cssDesc: headerSortDown,                cssChildRow: expand-child,                sortInitialOrder: asc,                sortMultiSortKey: shiftKey,                sortForce: null,                sortAppend: null,                sortLocaleCompare: true,                textExtraction: simple,                parsers: {}, widgets: [],                widgetZebra: {                    css: [even, odd]                }, headers: {}, widthFixed: false,                cancelSelection: true,                sortList: [],                headerList: [],                dateFormat: us,                decimal: /|/g,                onRenderHeader: null,                selectorHeaders: thead th,                debug: false            };
            /* debuging utils */
            function benchmark(s, d) {                log(s + , + (new Date().getTime() - d.getTime()) + ms);            }
            this.benchmark = benchmark;
            function log(s) {                if (typeof console != undefined && typeof console.debug != undefined) {                    console.log(s);                } else {                    alert(s);                }            }
            /* parsers utils */
            function buildParserCache(table, $headers) {
                if (table.config.debug) {                    var parsersDebug = ;                }
                if (table.tBodies.length == 0) return;  In the case of empty tables                var rows = table.tBodies[0].rows;
                if (rows[0]) {
                    var list = [],                        cells = rows[0].cells,                        l = cells.length;
                    for (var i = 0; i < l; i++) {
                        var p = false;
                        if ($.metadata && ($($headers[i]).metadata() && $($headers[i]).metadata().sorter)) {
                            p = getParserById($($headers[i]).metadata().sorter);
                        } else if ((table.config.headers[i] && table.config.headers[i].sorter)) {
                            p = getParserById(table.config.headers[i].sorter);                        }                        if (!p) {
                            p = detectParserForColumn(table, rows, -1, i);                        }
                        if (table.config.debug) {                            parsersDebug += column: + i +  parser: + p.id + ;                        }
                        list.push(p);                    }                }
                if (table.config.debug) {                    log(parsersDebug);                }
                return list;            };
            function detectParserForColumn(table, rows, rowIndex, cellIndex) {                var l = parsers.length,                    node = false,                    nodeValue = false,                    keepLooking = true;                while (nodeValue ==  && keepLooking) {                    rowIndex++;                    if (rows[rowIndex]) {                        node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);                        nodeValue = trimAndGetNodeText(table.config, node);                        if (table.config.debug) {                            log(Checking if value was empty on row: + rowIndex);                        }                    } else {                        keepLooking = false;                    }                }                for (var i = 1; i < l; i++) {                    if (parsers[i].is(nodeValue, table, node)) {                        return parsers[i];                    }                }                 0 is always the generic parser (text)                return parsers[0];            }
            function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {                return rows[rowIndex].cells[cellIndex];            }
            function trimAndGetNodeText(config, node) {                return $.trim(getElementText(config, node));            }
            function getParserById(name) {                var l = parsers.length;                for (var i = 0; i < l; i++) {                    if (parsers[i].id.toLowerCase() == name.toLowerCase()) {                        return parsers[i];                    }                }                return false;            }
            /* utils */
            function buildCache(table) {
                if (table.config.debug) {                    var cacheTime = new Date();                }
                var totalRows = (table.tBodies[0] && table.tBodies[0].rows.length) || 0,                    totalCells = (table.tBodies[0].rows[0] && table.tBodies[0].rows[0].cells.length) || 0,                    parsers = table.config.parsers,                    cache = {                        row: [],                        normalized: []                    };
                for (var i = 0; i < totalRows; ++i) {
                                        var c = $(table.tBodies[0].rows[i]),                        cols = [];
                     if this is a child row, add it to the last row's children and                     continue to the next row                    if (c.hasClass(table.config.cssChildRow)) {                        cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);                         go to the next for loop                        continue;                    }
                    cache.row.push(c);
                    for (var j = 0; j < totalCells; ++j) {                        cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));                    }
                    cols.push(cache.normalized.length);  add position for rowCache                    cache.normalized.push(cols);                    cols = null;                };
                if (table.config.debug) {                    benchmark(Building cache for  + totalRows +  rows:, cacheTime);                }
                return cache;            };
            function getElementText(config, node) {            	                if (!node) return ;                		        var $node = $(node),		            data = $node.attr(data-sort-value);		        if (data !== undefined) return data;
                var text = ;
                if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;
                if (config.textExtraction == simple) {                    if (config.supportsTextContent) {                        text = node.textContent;                    } else {                        if (node.childNodes[0] && node.childNodes[0].hasChildNodes()) {                            text = node.childNodes[0].innerHTML;                        } else {                            text = node.innerHTML;                        }                    }                } else {                    if (typeof(config.textExtraction) == function) {                        text = config.textExtraction(node);                    } else {                        text = $(node).text();                    }                }                return text;            }
            function appendToTable(table, cache) {
                if (table.config.debug) {                    var appendTime = new Date()                }
                var c = cache,                    r = c.row,                    n = c.normalized,                    totalRows = n.length,                    checkCell = (n[0].length - 1),                    tableBody = $(table.tBodies[0]),                    rows = [];

                for (var i = 0; i < totalRows; i++) {                    var pos = n[i][checkCell];
                    rows.push(r[pos]);
                    if (!table.config.appender) {
                        var o = ;                        var l = r[pos].length;                        for (var j = 0; j < l; j++) {                            tableBody[0].appendChild(r[pos][j]);                        }
                                             }                }


                if (table.config.appender) {
                    table.config.appender(table, rows);                }
                rows = null;
                if (table.config.debug) {                    benchmark(Rebuilt table:, appendTime);                }
                 apply table widgets                applyWidget(table);
                 trigger sortend                setTimeout(function () {                    $(table).trigger(sortEnd);                }, 0);
            };
            function buildHeaders(table) {
                if (table.config.debug) {                    var time = new Date();                }
                var meta = ($.metadata) ? true : false;                                var header_index = computeTableHeaderCellIndexes(table);
                var $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {
                    this.column = header_index[this.parentNode.rowIndex + - + this.cellIndex];                     this.column = index;                    this.order = formatSortingOrder(table.config.sortInitialOrder);                    										this.count = this.order;
                    if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;					if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);
                    if (!this.sortDisabled) {                        var $th = $(this).addClass(table.config.cssHeader);                        if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);                    }
                     add cell to headerList                    table.config.headerList[index] = this;                });
                if (table.config.debug) {                    benchmark(Built headers:, time);                    log($tableHeaders);                }
                return $tableHeaders;
            };
             from:             http://www.javascripttoolbox.com/lib/table/examples.php             http://www.javascripttoolbox.com/temp/table_cellindex.html

            function computeTableHeaderCellIndexes(t) {                var matrix = [];                var lookup = {};                var thead = t.getElementsByTagName(THEAD)[0];                var trs = thead.getElementsByTagName(TR);
                for (var i = 0; i < trs.length; i++) {                    var cells = trs[i].cells;                    for (var j = 0; j < cells.length; j++) {                        var c = cells[j];
                        var rowIndex = c.parentNode.rowIndex;                        var cellId = rowIndex + - + c.cellIndex;                        var rowSpan = c.rowSpan || 1;                        var colSpan = c.colSpan || 1                        var firstAvailCol;                        if (typeof(matrix[rowIndex]) == undefined) {                            matrix[rowIndex] = [];                        }                         Find first available column in the first row                        for (var k = 0; k < matrix[rowIndex].length + 1; k++) {                            if (typeof(matrix[rowIndex][k]) == undefined) {                                firstAvailCol = k;                                break;                            }                        }                        lookup[cellId] = firstAvailCol;                        for (var k = rowIndex; k < rowIndex + rowSpan; k++) {                            if (typeof(matrix[k]) == undefined) {                                matrix[k] = [];                            }                            var matrixrow = matrix[k];                            for (var l = firstAvailCol; l < firstAvailCol + colSpan; l++) {                                matrixrow[l] = x;                            }                        }                    }                }                return lookup;            }
            function checkCellColSpan(table, rows, row) {                var arr = [],                    r = table.tHead.rows,                    c = r[row].cells;
                for (var i = 0; i < c.length; i++) {                    var cell = c[i];
                    if (cell.colSpan > 1) {                        arr = arr.concat(checkCellColSpan(table, headerArr, row++));                    } else {                        if (table.tHead.length == 1 || (cell.rowSpan > 1 || !r[row + 1])) {                            arr.push(cell);                        }                         headerArr[row] = (i+row);                    }                }                return arr;            };
            function checkHeaderMetadata(cell) {                if (($.metadata) && ($(cell).metadata().sorter === false)) {                    return true;                };                return false;            }
            function checkHeaderOptions(table, i) {                if ((table.config.headers[i]) && (table.config.headers[i].sorter === false)) {                    return true;                };                return false;            }						 function checkHeaderOptionsSortingLocked(table, i) {                if ((table.config.headers[i]) && (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder;                return false;            }			            function applyWidget(table) {                var c = table.config.widgets;                var l = c.length;                for (var i = 0; i < l; i++) {
                    getWidgetById(c[i]).format(table);                }
            }
            function getWidgetById(name) {                var l = widgets.length;                for (var i = 0; i < l; i++) {                    if (widgets[i].id.toLowerCase() == name.toLowerCase()) {                        return widgets[i];                    }                }            };
            function formatSortingOrder(v) {                if (typeof(v) != Number) {                    return (v.toLowerCase() == desc) ? 1 : 0;                } else {                    return (v == 1) ? 1 : 0;                }            }
            function isValueInArray(v, a) {                var l = a.length;                for (var i = 0; i < l; i++) {                    if (a[i][0] == v) {                        return true;                    }                }                return false;            }
            function setHeadersCss(table, $headers, list, css) {                 remove all header information                $headers.removeClass(css[0]).removeClass(css[1]);
                var h = [];                $headers.each(function (offset) {                    if (!this.sortDisabled) {                        h[this.column] = $(this);                    }                });
                var l = list.length;                for (var i = 0; i < l; i++) {                    h[list[i][0]].addClass(css[list[i][1]]);                }            }
            function fixColumnWidth(table, $headers) {                var c = table.config;                if (c.widthFixed) {                    var colgroup = $(<colgroup>);                    $(tr:first td, table.tBodies[0]).each(function () {                        colgroup.append($(<col>).css(width, $(this).width()));                    });                    $(table).prepend(colgroup);                };            }
            function updateHeaderSortCount(table, sortList) {                var c = table.config,                    l = sortList.length;                for (var i = 0; i < l; i++) {                    var s = sortList[i],                        o = c.headerList[s[0]];                    o.count = s[1];                    o.count++;                }            }
            /* sorting methods */                        var sortWrapper;
            function multisort(table, sortList, cache) {
                if (table.config.debug) {                    var sortTime = new Date();                }
                var dynamicExp = sortWrapper = function(a,b) {,                    l = sortList.length;
                 TODO: inline functions.                for (var i = 0; i < l; i++) {
                    var c = sortList[i][0];                    var order = sortList[i][1];                     var s = (getCachedSortType(table.config.parsers,c) == ""text"") ?                     ((order == 0) ? ""sortText"" : ""sortTextDesc"") : ((order == 0) ?                     ""sortNumeric"" : ""sortNumericDesc"");                     var s = (table.config.parsers[c].type == ""text"") ? ((order == 0)                     ? makeSortText(c) : makeSortTextDesc(c)) : ((order == 0) ?                     makeSortNumeric(c) : makeSortNumericDesc(c));                    var s = (table.config.parsers[c].type == text) ? ((order == 0) ? makeSortFunction(text, asc, c) : makeSortFunction(text, desc, c)) : ((order == 0) ? makeSortFunction(numeric, asc, c) : makeSortFunction(numeric, desc, c));                    var e = e + i;
                    dynamicExp += var  + e +  =  + s;  + ""(a["" + c + ""],b["" + c                     + ""]); "";                    dynamicExp += if( + e + ) { return  + e + ; } ;                    dynamicExp += else { ;
                }
                 if value is the same keep orignal order                var orgOrderCol = cache.normalized[0].length - 1;                dynamicExp += return a[ + orgOrderCol + ]-b[ + orgOrderCol + ];;
                for (var i = 0; i < l; i++) {                    dynamicExp += }; ;                }
                dynamicExp += return 0; ;                dynamicExp += }; ;
                if (table.config.debug) {                    benchmark(Evaling expression: + dynamicExp, new Date());                }
                eval(dynamicExp);
                cache.normalized.sort(sortWrapper);
                if (table.config.debug) {                    benchmark(Sorting on  + sortList.toString() +  and dir  + order +  time:, sortTime);                }
                return cache;            };
            function makeSortFunction(type, direction, index) {                var a = a[ + index + ],                    b = b[ + index + ];                if (type == text && direction == asc) {                    return ( + a +  ==  + b +  ? 0 : ( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY : ( + a +  <  + b + ) ? -1 : 1 )));;                } else if (type == text && direction == desc) {                    return ( + a +  ==  + b +  ? 0 : ( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY : ( + b +  <  + a + ) ? -1 : 1 )));;                } else if (type == numeric && direction == asc) {                    return ( + a +  === null &&  + b +  === null) ? 0 :( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY :  + a +  -  + b + ));;                } else if (type == numeric && direction == desc) {                    return ( + a +  === null &&  + b +  === null) ? 0 :( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY :  + b +  -  + a + ));;                }            };
            function makeSortText(i) {                return ((a[ + i + ] < b[ + i + ]) ? -1 : ((a[ + i + ] > b[ + i + ]) ? 1 : 0));;            };
            function makeSortTextDesc(i) {                return ((b[ + i + ] < a[ + i + ]) ? -1 : ((b[ + i + ] > a[ + i + ]) ? 1 : 0));;            };
            function makeSortNumeric(i) {                return a[ + i + ]-b[ + i + ];;            };
            function makeSortNumericDesc(i) {                return b[ + i + ]-a[ + i + ];;            };
            function sortText(a, b) {                if (table.config.sortLocaleCompare) return a.localeCompare(b);                return ((a < b) ? -1 : ((a > b) ? 1 : 0));            };
            function sortTextDesc(a, b) {                if (table.config.sortLocaleCompare) return b.localeCompare(a);                return ((b < a) ? -1 : ((b > a) ? 1 : 0));            };
            function sortNumeric(a, b) {                return a - b;            };
            function sortNumericDesc(a, b) {                return b - a;            };
            function getCachedSortType(parsers, i) {                return parsers[i].type;            }; /* public methods */            this.construct = function (settings) {                return this.each(function () {                     if no thead or tbody quit.                    if (!this.tHead || !this.tBodies) return;                     declare                    var $this, $document, $headers, cache, config, shiftDown = 0,                        sortOrder;                     new blank config object                    this.config = {};                     merge and extend.                    config = $.extend(this.config, $.tablesorter.defaults, settings);                     store common expression for speed                    $this = $(this);                     save the settings where they read                    $.data(this, tablesorter, config);                     build headers                    $headers = buildHeaders(this);                     try to auto detect column type, and store in tables config                    this.config.parsers = buildParserCache(this, $headers);                     build the cache for the tbody cells                    cache = buildCache(this);                     get the css class names, could be done else where.                    var sortCSS = [config.cssDesc, config.cssAsc];                     fixate columns if the users supplies the fixedWidth option                    fixColumnWidth(this);                     apply event handling to headers                     this is to big, perhaps break it out?                    $headers.click(
                    function (e) {                        var totalRows = ($this[0].tBodies[0] && $this[0].tBodies[0].rows.length) || 0;                        if (!this.sortDisabled && totalRows > 0) {                             Only call sortStart if sorting is                             enabled.                            $this.trigger(sortStart);                             store exp, for speed                            var $cell = $(this);                             get current column index                            var i = this.column;                             get current column sort order                            this.order = this.count++ % 2;							 always sort on the locked order.							if(this.lockedOrder) this.order = this.lockedOrder;														 user only whants to sort on one                             column                            if (!e[config.sortMultiSortKey]) {                                 flush the sort list                                config.sortList = [];                                if (config.sortForce != null) {                                    var a = config.sortForce;                                    for (var j = 0; j < a.length; j++) {                                        if (a[j][0] != i) {                                            config.sortList.push(a[j]);                                        }                                    }                                }                                 add column to sort list                                config.sortList.push([i, this.order]);                                 multi column sorting                            } else {                                 the user has clicked on an all                                 ready sortet column.                                if (isValueInArray(i, config.sortList)) {                                     revers the sorting direction                                     for all tables.                                    for (var j = 0; j < config.sortList.length; j++) {                                        var s = config.sortList[j],                                            o = config.headerList[s[0]];                                        if (s[0] == i) {                                            o.count = s[1];                                            o.count++;                                            s[1] = o.count % 2;                                        }                                    }                                } else {                                     add column to sort list array                                    config.sortList.push([i, this.order]);                                }                            };                            setTimeout(function () {                                 set css for headers                                setHeadersCss($this[0], $headers, config.sortList, sortCSS);                                appendToTable(	                                $this[0], multisort(	                                $this[0], config.sortList, cache)								);                            }, 1);                             stop normal event by returning false                            return false;                        }                         cancel selection                    }).mousedown(function () {                        if (config.cancelSelection) {                            this.onselectstart = function () {                                return false                            };                            return false;                        }                    });                     apply easy methods that trigger binded events                    $this.bind(update, function () {                        var me = this;                        setTimeout(function () {                             rebuild parsers.                            me.config.parsers = buildParserCache(                            me, $headers);                             rebuild the cache map                            cache = buildCache(me);                        }, 1);                    }).bind(updateCell, function (e, cell) {                        var config = this.config;                         get position from the dom.                        var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex];                         update cache                        cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(                        getElementText(config, cell), cell);                    }).bind(sorton, function (e, list) {                        $(this).trigger(sortStart);                        config.sortList = list;                         update and store the sortlist                        var sortList = config.sortList;                         update header count index                        updateHeaderSortCount(this, sortList);                         set css for headers                        setHeadersCss(this, $headers, sortList, sortCSS);                         sort the table and append it to the dom                        appendToTable(this, multisort(this, sortList, cache));                    }).bind(appendCache, function () {                        appendToTable(this, cache);                    }).bind(applyWidgetId, function (e, id) {                        getWidgetById(id).format(this);                    }).bind(applyWidgets, function () {                         apply widgets                        applyWidget(this);                    });                    if ($.metadata && ($(this).metadata() && $(this).metadata().sortlist)) {                        config.sortList = $(this).metadata().sortlist;                    }                     if user has supplied a sort list to constructor.                    if (config.sortList.length > 0) {                        $this.trigger(sorton, [config.sortList]);                    }                     apply widgets                    applyWidget(this);                });            };            this.addParser = function (parser) {                var l = parsers.length,                    a = true;                for (var i = 0; i < l; i++) {                    if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {                        a = false;                    }                }                if (a) {                    parsers.push(parser);                };            };            this.addWidget = function (widget) {                widgets.push(widget);            };            this.formatFloat = function (s) {                var i = parseFloat(s);                return (isNaN(i)) ? 0 : i;            };            this.formatInt = function (s) {                var i = parseInt(s);                return (isNaN(i)) ? 0 : i;            };            this.isDigit = function (s, config) {                 replace all an wanted chars and match.                return .test($.trim(s.replace(g, )));            };            this.clearTableBody = function (table) {                if ($.browser.msie) {                    while (table.tBodies[0].firstChild) {                        table.tBodies[0].removeChild(table.tBodies[0].firstChild);                    }                } else {                    table.tBodies[0].innerHTML = ;                }            };        }    });
     extend plugin scope    $.fn.extend({        tablesorter: $.tablesorter.construct    });
     make shortcut    var ts = $.tablesorter;
     add default parsers    ts.addParser({        id: text,        is: function (s) {            return true;        }, format: function (s) {            return $.trim(s.toLocaleLowerCase());        }, type: text    });
    ts.addParser({        id: digit,        is: function (s, table) {            var c = table.config;            return $.tablesorter.isDigit(s, c);        }, format: function (s) {            return $.tablesorter.formatFloat(s);        }, type: numeric    });
    ts.addParser({        id: currency,        is: function (s) {            return .test(s);        }, format: function (s) {            return $.tablesorter.formatFloat(s.replace(new RegExp(g), ));        }, type: numeric    });
    ts.addParser({        id: ipAddress,        is: function (s) {            return .test(s);        }, format: function (s) {            var a = s.split(.),                r = ,                l = a.length;            for (var i = 0; i < l; i++) {                var item = a[i];                if (item.length == 2) {                    r += 0 + item;                } else {                    r += item;                }            }            return $.tablesorter.formatFloat(r);        }, type: numeric    });
    ts.addParser({        id: url,        is: function (s) {            return (httpsftpfile):.test(s);        }, format: function (s) {            return jQuery.trim(s.replace(new RegExp((httpsftpfile):), ));        }, type: text    });
    ts.addParser({        id: isoDate,        is: function (s) {            return .test(s);        }, format: function (s) {            return $.tablesorter.formatFloat((s != ) ? new Date(s.replace(            new RegExp(-g), /)).getTime() : 0);        }, type: numeric    });
    ts.addParser({        id: percent,        is: function (s) {            return .test($.trim(s));        }, format: function (s) {            return $.tablesorter.formatFloat(s.replace(new RegExp(%g), ));        }, type: numeric    });
    ts.addParser({        id: usLongDate,        is: function (s) {            return s.match(new RegExp( , (') ((:)(:(AMPM)))));        }, format: function (s) {            return $.tablesorter.formatFloat(new Date(s).getTime());        }, type: numeric    });
    ts.addParser({        id: shortDate,        is: function (s) {            return .test(s);        }, format: function (s, table) {            var c = table.config;            s = s.replace(g, /);            if (c.dateFormat == us) {                 reformat the string in ISO format                s = s.replace(()()(), $3/$1/$2);            }                if (c.dateFormat == pt) {                s = s.replace(()()(), $3/$2/$1);               } else if (c.dateFormat == uk) {                 reformat the string in ISO format                s = s.replace(()()(), $3/$2/$1);            } else if (c.dateFormat == dd/mm/yy || c.dateFormat == dd-mm-yy) {                s = s.replace(()()(), $1/$2/$3);            }            return $.tablesorter.formatFloat(new Date(s).getTime());        }, type: numeric    });    ts.addParser({        id: time,        is: function (s) {            return ((:)(:(ampm))).test(s);        }, format: function (s) {            return $.tablesorter.formatFloat(new Date(2000/01/01  + s).getTime());        }, type: numeric    });    ts.addParser({        id: metadata,        is: function (s) {            return false;        }, format: function (s, table, cell) {            var c = table.config,                p = (!c.parserMetadataName) ? sortValue : c.parserMetadataName;            return $(cell).metadata()[p];        }, type: numeric    });     add default widgets    ts.addWidget({        id: zebra,        format: function (table) {            if (table.config.debug) {                var time = new Date();            }            var $tr, row = -1,                odd;             loop through the visible rows            $(tr:visible, table.tBodies[0]).each(function (i) {                $tr = $(this);                 style children rows the same way the parent                 row was styled                if (!$tr.hasClass(table.config.cssChildRow)) row++;                odd = (row % 2 == 0);                $tr.removeClass(                table.config.widgetZebra.css[odd ? 0 : 1]).addClass(                table.config.widgetZebra.css[odd ? 1 : 0])            });            if (table.config.debug) {                $.tablesorter.benchmark(Applying Zebra widget, time);            }        }    });})(jQuery);"
"/* * Metadata - jQuery plugin for parsing metadata from elements * * Copyright (c) 2006 John Resig, Yehuda Katz, J�örn Zaefferer, Paul McLanahan * * Dual licensed under the MIT and GPL licenses: *   http://www.opensource.org/licenses/mit-license.php *   http://www.gnu.org/licenses/gpl.html * * Revision: $Id$ * */
/** * Sets the type of metadata to use. Metadata is encoded in JSON, and each property * in the JSON will become a property of the element itself. * * There are three supported types of metadata storage: * *   attr:  Inside an attribute. The name parameter indicates *which* attribute. *           *   class: Inside the class attribute, wrapped in curly braces: { } *    *   elem:  Inside a child element (e.g. a script tag). The *          name parameter indicates *which* element. *           * The metadata for an element is loaded the first time the element is accessed via jQuery. * * As a result, you can define the metadata type, use $(expr) to load the metadata into the elements * matched by expr, then redefine the metadata type and run another $(expr) for other elements. *  *   * *   * @before $.metadata.setType(""class"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from the class attribute *  *   * @before $.metadata.setType(""attr"", ""data"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from a ""data"" attribute *  *   * @before $.metadata.setType(""elem"", ""script"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from a nested script element *  *   type The encoding type *   name The name of the attribute to be used to get metadata (optional) * @cat Plugins/Metadata * @descr Sets the type of encoding to be used when loading metadata for the first time *  undefined *   */
(function($) {
$.extend({	metadata : {		defaults : {			type: class,			name: metadata,			cre: ({}),			single: metadata		},		setType: function( type, name ){			this.defaults.type = type;			this.defaults.name = name;		},		get: function( elem, opts ){			var settings = $.extend({},this.defaults,opts);			 check for empty string in single property			if ( !settings.single.length ) settings.single = metadata;						var data = $.data(elem, settings.single);			 returned cached data if it already exists			if ( data ) return data;						data = {};						if ( settings.type == class ) {				var m = settings.cre.exec( elem.className );				if ( m )					data = m[1];			} else if ( settings.type == elem ) {				if( !elem.getElementsByTagName )					return undefined;				var e = elem.getElementsByTagName(settings.name);				if ( e.length )					data = $.trim(e[0].innerHTML);			} else if ( elem.getAttribute != undefined ) {				var attr = elem.getAttribute( settings.name );				if ( attr )					data = attr;			}						if ( data.indexOf( { ) <0 )			data = { + data + };						data = eval(( + data + ));						$.data( elem, settings.single, data );			return data;		}	}});
/** * Returns the metadata object for the first member of the jQuery object. * *   * @descr Returns element's metadata object *   opts An object contianing settings to override the defaults *  jQuery * @cat Plugins/Metadata */$.fn.metadata = function( opts ){	return $.metadata.get( this[0], opts );};
})(jQuery);"
"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll(left)}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:""script""}):c.globalEval(b.text||b.textContent||b.innerHTML||"""");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b===""object""){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,""events"");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type===""click"")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"""")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType===mouseenter||i.preType===mouseleave)f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return""live.""+(a&&a!==""*""?a+""."":"""")+b.replace(/\./g,""`"").replace(/ /g,&)}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]===""string""&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return""scrollTo""in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,Wa=(00A0)(00A0)g,Xa=<()>(?:<>),P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a===body&&!b){this.context=s;this[0]=s.body;this.selector=body;this.length=1;return this}if(typeof a===string)if((d=Ta.exec(a))&&(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:,jquery:1.4.2,length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===find)f.selector=this.selector+(this.selector? :)+d;else if(b)f.selector=this.selector+.+b+(+d+);return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),slice,R.call(arguments).join(,))},map:function(a){return this.pushStack(c.map(this,function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a===boolean){f=a;a=arguments[1]||{};b=2}if(typeof a!==object&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler(ready)}},bindReady:function(){if(!xa){xa=true;if(s.readyState===complete)return c.ready();if(s.addEventListener){s.addEventListener(DOMContentLoaded,L,false);A.addEventListener(load,c.ready,false)}else if(s.attachEvent){s.attachEvent(onreadystatechange,L);A.attachEvent(onload,c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)===[object Function]},isArray:function(a){return $.call(a)===[object Array]},isPlainObject:function(a){if(!a||$.call(a)!==[object Object]||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,constructor)&&!aa.call(a.constructor.prototype,isPrototypeOf))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!==string||!a)return null;a=c.trim(a);if(.test(a.replace((?:u)g,@).replace(""""truefalsenull-(?:)(?:)g,]).replace((?::,)(?:)g,)))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function(return +a))();else c.error(Invalid JSON: +a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName(head)[0]||s.documentElement,d=s.createElement(script);d.type=text/javascript;if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||).replace(Wa,)},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a===string||c.isFunction(a)||typeof a!==function&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length===number)for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b===string){d=a;a=d[b];b=w}else if(b&&!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=(webkit)().exec(a)||(opera)(?:version)().exec(a)||(msie) ().exec(a)||!compatible.test(a)&&(mozilla)(?: rv:()).exec(a)||[];return{browser:a[1]||,version:a[2]||0}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener(DOMContentLoaded,L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState===complete){s.detachEvent(onreadystatechange,L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement(script),d=s.createElement(div),f=script+J();d.style.display=none;d.innerHTML=   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>;var e=d.getElementsByTagName(*),j=d.getElementsByTagName(a)[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName(tbody).length,htmlSerialize:!!d.getElementsByTagName(link).length,style:red.test(j.getAttribute(style)),hrefNormalized:j.getAttribute(href)===/a,opacity:055.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName(input)[0].value===on,optSelected:s.createElement(select).appendChild(s.createElement(option)).selected,parentNode:d.removeChild(d.appendChild(s.createElement(div))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type=text/javascript;try{b.appendChild(s.createTextNode(window.+f+=1;))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent(onclick,function k(){c.support.noCloneEvent=false;d.detachEvent(onclick,k)});d.cloneNode(true).fireEvent(onclick)}d=s.createElement(div);d.innerHTML=<input type='radio' name='radiotest' checked='checked'/>;a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement(div);k.style.width=k.style.paddingLeft=1px;s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display=none});a=function(k){var n=s.createElement(div);k=on+k;var r=k in n;if(!r){n.setAttribute(k,return;);r=typeof n[k]===function}return r};c.support.submitBubbles=a(submit);c.support.changeBubbles=a(change);a=b=d=e=j=null}})();c.props={for:htmlFor,class:className,readonly:readOnly,maxlength:maxLength,cellspacing:cellSpacing,rowspan:rowSpan,colspan:colSpan,tabindex:tabIndex,usemap:useMap,frameborder:frameBorder};var G=jQuery+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b===string&&d===w)return null;f||(f=++Ya);if(typeof b===object){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b===string?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a===undefined&&this.length)return c.data(this[0]);else if(typeof a===object)return this.each(function(){c.data(this,a)});var d=a.split(.);d[1]=d[1]?.+d[1]:;if(b===w){var f=this.triggerHandler(getData+d[1]+!,[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger(setData+d[1]+!,[d[0],b]).each(function(){c.data(this,a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||fx)+queue;var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||fx;var d=c.queue(a,b),f=d.shift();if(f===inprogress)f=d.shift();if(f){b===fx&&d.unshift(inprogress);f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!==string){b=a;a=fx}if(b===w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a===fx&&d[0]!==inprogress&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||fx;return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||fx,[])}});var Aa=g,ca=,Za=g,$a=hrefsrcstyle,ab=(buttoninput)i,bb=(buttoninputobjectselecttextarea)i,cb=(aarea)i,Ba=radiocheckbox;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,);this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr(class)))});if(a&&typeof a===string)for(var b=(a||).split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j= +e.className+ ,i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf( +b[o]+ )<0)i+= +b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr(class)))});if(a&&typeof a===string||a===w)for(var b=(a||).split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=( +e.className+ ).replace(Aa, ),i=0,o=b.length;i<o;i++)j=j.replace( +b[i]+ , );e.className=c.trim(j)}else e.className=}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b===boolean;if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr(class),b),b)});return this.each(function(){if(d===string)for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?addClass:removeClass](e)}else if(d===undefined||d===boolean){this.className&&c.data(this,__className__,this.className);this.className=this.className||a===false?:c.data(this,__className__)||}})},hasClass:function(a){a= +a+ ;for(var b=0,d=this.length;b<d;b++)if(( +this[b].className+ ).replace(Aa, ).indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,option))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,select)){var d=b.selectedIndex,f=[],e=b.options;b=b.type===select-one;if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute(value)===null?on:b.value;return(b.value||).replace(Za,)}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r===number)r+=;if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,select)){var u=c.makeArray(r);c(option,this).each(function(){this.selected=c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b===type&&ab.test(a.nodeName)&&a.parentNode&&c.error(type property can't be changed);a[b]=d}if(c.nodeName(a,form)&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b===tabIndex)return(b=a.getAttributeNode(tabIndex))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b===style){if(e)a.style.cssText=+d;return a.style.cssText}e&&a.setAttribute(b,+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=(),db=function(a){return a.replace(g,function(b){return+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!==undefined&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split( );for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(.)>-1){r=k.split(.);k=r.shift();j.namespace=r.slice(0).sort().join(.)}else{r=[];j.namespace=}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent(on+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b===string&&b.charAt(0)===.){b=b||;for(e in C)c.event.remove(a,e+b)}else{for(b=b.split( );e=b[j++];){n=e;i=e.indexOf(.)<0;o=[];if(!i){o=e.split(.);e=o.shift();k=new RegExp((^|.)+c.map(o.slice(0).sort(),db).join(.(?:.*.)?)+(.|$))}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a===object?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf(!)>=0){a.type=e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,handle))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d[on+e]&&d[on+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,a)&&e===click,k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f[on+e])f[on+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f[on+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(.)<0&&!a.exclusive;if(!b){d=a.type.split(.);a.type=d.shift();f=new RegExp((^|.)+d.slice(0).sort().join(.(?:.*.)?)+(.|$))}e=c.data(this,events);d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which.split( ),fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,);c.each(c.data(this,events).live||[],function(){if(d===this.origType.replace(O,))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent(on+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:mouseover,mouseleave:mouseout},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==form){c.event.add(this,click.specialSubmit,function(a){var b=a.target,d=b.type;if((d===submit||d===image)&&c(b).closest(form).length)return na(submit,this,arguments)});c.event.add(this,keypress.specialSubmit,function(a){var b=a.target,d=b.type;if((d===text||d===password)&&c(b).closest(form).length&&a.keyCode===13)return na(submit,this,arguments)})}else return false},teardown:function(){c.event.remove(this,.specialSubmit)}};if(!c.support.changeBubbles){var da=textareainputselecti,ea,Fa=function(a){var b=a.type,d=a.value;if(b===radio||b===checkbox)d=a.checked;else if(b===select-multiple)d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join(-):;else if(a.nodeName.toLowerCase()===select)d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,_change_data);e=Fa(d);if(a.type!==focusout||d.type!==radio)c.data(d,_change_data,e);if(!(f===w||e===f))if(f!=null||e){a.type=change;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d===radio||d===checkbox||b.nodeName.toLowerCase()===select)return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!==textarea||a.keyCode===32&&(d===checkbox||d===radio)||d===select-multiple)return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,_change_data,Fa(a))}},setup:function(){if(this.type===file)return false;for(var a in ea)c.event.add(this,a+.specialChange,ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,.specialChange);return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:focusin,blur:focusout},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each([bind,one],function(a,b){c.fn[b]=function(d,f,e){if(typeof d===object){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b===one?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d===unload&&b!==one)this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a===object&&!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind(live):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,lastToggle+a.guid)||0)%d;c.data(this,lastToggle+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:focusin,blur:focusout,mouseenter:mouseover,mouseleave:mouseout};c.each([live,die],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||).split( );(i=d[o++])!=null;){j=O.exec(i);k=;if(j){k=j[0];i=i.replace(O,)}if(i===hover)d.push(mouseenter+k,mouseleave+k);else{n=i;if(i===focus||i===blur){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b===live?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each(blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error.split( ),function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent(onunload,function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h=,l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!==""string""){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['""][^'""]*['""]|[^[\]'""]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!==string)return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]===~||p[0]===+)&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D=;if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||g);if(j.call(y)===[object Array])if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!==){q[1]=(q[1]||).replace(g,);m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],);break}}}}m||(m=h.getElementsByTagName(*));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-1)!==){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],);if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throwSyntax error, unrecognized expression: +g;};var n=k.selectors={order:[ID,NAME,TAG],match:{ID:#((?:)),CLASS:((?:)),NAME:name=((?:)),ATTR:((?:))(?:(=)()()),TAG:((?:)),CHILD::(onlynthlastfirst)-child(?:(evenodd)),POS::(ntheqgtltfirstlastevenodd)(?:())(?=),PSEUDO::((?:))(?:()((?:)))},leftMatch:{},attrMap:{class:className,for:htmlFor},attrHandle:{href:function(g){return g.getAttribute(href)}},relative:{:function(g,h){var l=typeof h===string,m=l&&!.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},:function(g,h){var l=typeof h===string;if(l&&!.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},:function(g,h,l){var m=e++,q=d;if(typeof h===string&&!.test(h)){var p=h=h.toLowerCase();q=b}q(parentNode,h,m,g,p,l)},:function(g,h,l){var m=e++,q=d;if(typeof h===string&&!.test(h)){var p=h=h.toLowerCase();q=b}q(previousSibling,h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!==undefined&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!==undefined){var l=[];h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute(name)===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g= +g[1].replace(g,)+ ;if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&( +v.className+ ).replace(g, ).indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(g,)},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]===nth){var h=(-)()n((?:-)).exec(g[2]===even&&2n||g[2]===odd&&2n+1||!.test(g[2])&&0n++g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(g,);if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]===~=)g[4]= +g[4]+ ;return g},PSEUDO:function(g,h,l,m,q){if(g[1]===not)if((f.exec(g[3])||).length>1||.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!==hidden},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){returnhi.test(g.nodeName)},text:function(g){returntext===g.type},radio:function(g){returnradio===g.type},checkbox:function(g){returncheckbox===g.type},file:function(g){returnfile===g.type},password:function(g){returnpassword===g.type},submit:function(g){returnsubmit===g.type},image:function(g){returnimage===g.type},reset:function(g){returnreset===g.type},button:function(g){returnbutton===g.type||g.nodeName.toLowerCase()===button},input:function(g){returninputselecttextareabuttoni.test(g.nodeName)}},setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q===contains)return(g.textContent||g.innerText||a([g])||).indexOf(h[3])>=0;else if(q===not){h=h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error(Syntax error, unrecognized expression: +q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case only:case first:for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l===first)return true;m=g;case last:for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case nth:l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute(id)===h},TAG:function(g,h){return h===*&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return( +(g.className||g.getAttribute(class))+ ).indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+;var m=h[2];h=h[4];return g==null?m===!=:m====?l===h:m===*=?l.indexOf(h)>=0:m===~=?( +l+ ).indexOf(h)>=0:!h?l&&g!==false:m===!=?l!==h:m===^=?l.indexOf(h)===0:m===$=?l.substr(l.length-h.length)===h:m===|=?l===h||l.substr(0,h.length+1)===h+-:false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+(?!)(?!).source);n.leftMatch[u]=new RegExp(((?:)).source+n.match[u].source.replace(()g,function(g,h){return+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)===[object Array])Array.prototype.push.apply(h,g);else if(typeof g.length===number)for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if(sourceIndexin s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement(div),h=script+(new Date).getTime();g.innerHTML=<a name='+h+'/>;var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!==undefined&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!==undefined&&q.getAttributeNode(id).nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!==undefined&&m.getAttributeNode(id);return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement(div);g.appendChild(s.createComment());if(g.getElementsByTagName(*).length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]===*){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML=<a href='#'></a>;if(g.firstChild&&typeof g.firstChild.getAttribute!==undefined&&g.firstChild.getAttribute(href)!==#)n.attrHandle.href=function(h){return h.getAttribute(href,2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement(div);h.innerHTML=<p class='TEST'></p>;if(!(h.querySelectorAll&&h.querySelectorAll(.TEST).length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();(function(){var g=s.createElement(div);g.innerHTML=<div class='test e'></div><div class='test'></div>;if(!(!g.getElementsByClassName||g.getElementsByClassName(e).length===0)){g.lastChild.className=e;if(g.getElementsByClassName(e).length!==1){n.order.splice(1,0,CLASS);n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!==undefined&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!==HTML:false},ga=function(g,h){var l=[],m=,q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,)}g=n.relative[g]?g+*:g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[:]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=Until,fb=(?:parentsprevUntilprevAll),gb=,;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b===string){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack(,find,a),d=0,f=0,e=this.length;f<e;f++){d=b.length;c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),not,a)},filter:function(a){return this.pushStack(Ia(this,a,true),filter,a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j={},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===string)return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a===string?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,parentNode)},parentsUntil:function(a,b,d){return c.dir(a,parentNode,d)},next:function(a){return c.nth(a,2,nextSibling)},prev:function(a){return c.nth(a,2,previousSibling)},nextAll:function(a){return c.dir(a,nextSibling)},prevAll:function(a){return c.dir(a,previousSibling)},nextUntil:function(a,b,d){return c.dir(a,nextSibling,d)},prevUntil:function(a,b,d){return c.dir(a,previousSibling,d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,iframe)?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f===string)e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(,))}});c.extend({filter:function(a,b,d){if(d)a=:not(+a+);return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja= jQuery=""(?:null)""g,V=,Ka=(<())>g,hb=(?:areabrcolembedhrimginputlinkmetaparam)i,La=<(),ib=<tbodyi,jb=<&#;,ta=<script<object<embed<option<stylei,ua=checked(?:=checked)i,Ma=function(a,b,d){return hb.test(d)?a:b+></+d+>},F={option:[1,<select multiple='multiple'>,</select>],legend:[1,<fieldset>,</fieldset>],thead:[1,<table>,</table>],tr:[2,<table><tbody>,</tbody></table>],td:[3,<table><tbody><tr>,</tr></tbody></table>],col:[2,<table><tbody></tbody><colgroup>,</colgroup></table>],area:[1,<map>,</map>],_default:[0,,]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,div<div>,</div>];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=c(this);d.text(a.call(this,b,d.text()))});if(typeof a!==object&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,body)||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,before,arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,after,arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName(*));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName(*));b.firstChild;)b.removeChild(b.firstChild);return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement(div);d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,).replace(=()>g,=""$1"">).replace(V,)],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find(*),b.find(*))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,):null;else if(typeof a===string&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||[,])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName(*));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!==string)a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),replaceWith,a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,table)?u.getElementsByTagName(tbody)[0]||u.appendChild(u.ownerDocument.createElement(tbody)):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i===string&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,tr);for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:append,prependTo:prepend,insertBefore:before,insertAfter:after,replaceAll:replaceWith},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement===undefined)b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i===number)i+=;if(i){if(typeof i===string&&!jb.test(i))i=b.createTextNode(i);else if(typeof i===string){i=i.replace(Ka,Ma);var o=(La.exec(i)||[,])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement(div);for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o===table&&!n?r.firstChild&&r.firstChild.childNodes:k[1]===<table>&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],tbody)&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],script)&&(!e[j].type||e[j].type.toLowerCase()===text/javascript))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName(script))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=z-indexfont-weightopacityzoomline-heighti,Na=alpha,Oa=opacity=(),ha=floati,ia=-()ig,lb=()g,mb=-(?:px)i,nb=-,ob={position:absolute,visibility:hidden,display:block},pb=[Left,Right],qb=[Top,Bottom],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?cssFloat:styleFloat,ja=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e===number&&!kb.test(f))e+=px;c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b===width||b===height)&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b===opacity){if(e){f.zoom=1;b=parseInt(d,10)+===NaN?:alpha(opacity=+d*100+);a=f.filter||c.curCSS(a,filter)||;f.filter=Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf(opacity=)>=0?parseFloat(Oa.exec(f.filter)[1])/100+:}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b===width||b===height){var e,j=b===width?pb:qb;function i(){e=b===width?a.offsetWidth:a.offsetHeight;f!==border&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,padding+this,true))||0);if(f===margin)e+=parseFloat(c.curCSS(a,margin+this,true))||0;else e-=parseFloat(c.curCSS(a,border+this+Width,true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b===opacity&&a.currentStyle){f=Oa.test(a.currentStyle.filter||)?parseFloat(RegExp.$1)/100+:;return f===?1:f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b=float;b=b.replace(lb,-$1).toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=a.getPropertyValue(b);if(b===opacity&&f===)f=1}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d===fontSize?1em:f||0;f=e.pixelLeft+px;e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()===tr;return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,display)===none};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=<script()script>gi,ub=selecttextareai,vb=colordatedatetimeemailhiddenmonthnumberpasswordrangesearchteltexttimeurlweeki,N==(&),ka=,wb=(&)_=(&),xb=(:)(),yb=%20g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==string)return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf( );if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f=GET;if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===object){b=c.param(b,c.ajaxSettings.traditional);f=POST}var j=this;c.ajax({url:a,type:f,dataType:html,data:b,complete:function(i,o){if(o===success||o===notmodified)j.html(e?c(<div />).append(i.responseText.replace(tb,)).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each(ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend.split( ),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:GET,url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,script)},getJSON:function(a,b,d){return c.get(a,b,d,json)},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:POST,url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:GET,contentType:application/x-www-form-urlencoded,processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!==file:||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject(Microsoft.XMLHTTP)}catch(a){}},accepts:{xml:application/xml, text/xml,html:text/html,script:text/javascript, application/javascript,json:application/json, text/javascript,text:text/plain,_default:*/*}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&e.success.call(k,o,i,x);e.global&&f(ajaxSuccess,[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f(""ajaxComplete"",[x,e]);e.global&&!--c.active&&c.event.trigger(""ajaxStop"")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!==""string"")e.data=c.param(e.data,e.traditional);if(e.dataType===""jsonp""){if(n===""GET"")N.test(e.url)||(e.url+=(ka.test(e.url)?&:?)+(e.jsonp||callback)+=?);else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+&:)+(e.jsonp||callback)+=?;e.dataType=json}if(e.dataType===json&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||jsonp+sb++;if(e.data)e.data=(e.data+).replace(N,=+j+$1);e.url=e.url.replace(N,=+j+$1);e.dataType=script;A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType===script&&e.cache===null)e.cache=false;if(e.cache===false&&n===GET){var r=J(),u=e.url.replace(wb,$1_=+r+$2);e.url=u+(u===e.url?(ka.test(e.url)?&:?)+_=+r:)}if(e.data&&n===GET)e.url+=(ka.test(e.url)?&:?)+e.data;e.global&&!c.active++&&c.event.trigger(ajaxStart);r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType===script&&n===GET&&r){var z=s.getElementsByTagName(head)[0]||s.documentElement,C=s.createElement(script);C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState===loaded||this.readyState===complete)){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader(Content-Type,e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader(If-Modified-Since,c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader(If-None-Match,c.etag[e.url])}r||x.setRequestHeader(X-Requested-With,XMLHttpRequest);x.setRequestHeader(Accept,e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+, */*:e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger(ajaxStop);x.abort();return false}e.global&&f(ajaxSend,[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q===abort){E||d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q===timeout)){E=true;x.onreadystatechange=c.noop;i=q===timeout?timeout:!c.httpSuccess(x)?error:e.ifModified&&c.httpNotModified(x,e.url)?notmodified:success;var p;if(i===success)try{o=c.httpData(x,e.dataType,e)}catch(v){i=parsererror;p=v}if(i===success||i===notmodified)j||b();else c.handleError(e,x,i,p);d();q===timeout&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);g(abort)}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g(timeout)},e.timeout);try{x.send(n===POST||n===PUT||n===DELETE?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger(ajaxError,[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol===file:||a.status>=200&&a.status<300||a.status===304||a.status===1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader(Last-Modified),f=a.getResponseHeader(Etag);if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader(content-type)||,e=b===xml||!b&&f.indexOf(xml)>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName===parsererror&&c.error(parsererror);if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a===string)if(b===json||!b&&f.indexOf(json)>=0)a=c.parseJSON(a);else if(b===script||!b&&f.indexOf(javascript)>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||.test(i)?f(i,n):d(i+[+(typeof n===object||c.isArray(n)?k:)+],n)});else!b&&o!=null&&typeof o===object?c.each(o,function(k,n){d(i+[+k+],n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+""=""+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join(&).replace(yb,+)}});var la={},Ab=toggleshowhide,Bb=(=)()(),W,va=[[height,marginTop,marginBottom,paddingTop,paddingBottom],[width,marginLeft,marginRight,paddingLeft,paddingRight],[opacity]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K(show,3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],olddisplay);this[a].style.display=d||;if(c.css(this[a],display)===none){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c(<+d+ />).appendTo(body);f=e.css(display);if(f===none)f=block;e.remove();la[d]=f}c.data(this[a],olddisplay,f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],olddisplay)||;return this}},hide:function(a,b){if(a||a===0)return this.animate(K(hide,3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],olddisplay);!d&&d!==none&&c.data(this[a],olddisplay,c.css(this[a],display))}a=0;for(b=this.length;a<b;a++)this[a].style.display=none;return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a===boolean;if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(:hidden);c(this)[f?show:hide]()}):this.animate(K(toggle,3),a,b);return this},fadeTo:function(a,b,d){return this.filter(:hidden).css(opacity,0).show().end().animate({opacity:b},a,d)},animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?each:queue](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(:hidden),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]===hide&&o||a[i]===show&&!o)return j.complete.call(this);if((i===height||i===width)&&this.style){j.display=c.css(this,display);j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow=hidden;j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u===toggle?o?show:hide:u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||px;if(E!==px){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]===-=?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,)}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K(show,1),slideUp:K(hide,1),slideToggle:K(toggle,1),fadeIn:{opacity:show},fadeOut:{opacity:hide}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a===object?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===number?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this);if((this.prop===height||this.prop===width)&&this.elem.style)this.elem.style.display=block},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||px;this.now=this.start;this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop===width||this.prop===height?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,olddisplay);this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,display)===none)this.elem.style.display=block}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?swing:linear);this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,opacity,a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop===width||a.prop===height?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset=getBoundingClientRectin s.documentElement?function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position===fixed)break;j=e?e.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&t(abledh)i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!==visible){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position===relative||f.position===static){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&f.position===fixed){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement(div),d,f,e,j=parseFloat(c.curCSS(a,marginTop,true))||0;c.extend(b.style,{position:absolute,top:0,left:0,margin:0,border:0,width:1px,height:1px,visibility:hidden});b.innerHTML=<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>;a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position=fixed;f.style.top=20px;this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top=;d.style.overflow=hidden;d.style.position=relative;this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,marginTop,true))||0;d+=parseFloat(c.curCSS(a,marginLeft,true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(static.test(c.curCSS(a,position)))a.style.position=relative;var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,top,true),10)||0,i=parseInt(c.curCSS(a,left,true),10)||0;if(c.isFunction(b))b=b.call(a,d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};usingin b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=bodyhtmli.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,marginTop,true))||0;d.left-=parseFloat(c.curCSS(a,marginLeft,true))||0;f.top+=parseFloat(c.curCSS(b[0],borderTopWidth,true))||0;f.left+=parseFloat(c.curCSS(b[0],borderLeftWidth,true))||0;return{top:d.top-f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!bodyhtmli.test(a.nodeName)&&c.css(a,position)===static;)a=a.offsetParent;return a})}});c.each([Left,Top],function(a,b){var d=scroll+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?pageXOffsetin j?j[a?pageYOffset:pageXOffset]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each([Height,Width],function(a,b){var d=b.toLowerCase();c.fn[inner+b]=function(){return this[0]?c.css(this[0],d,false,padding):null};c.fn[outer+b]=function(f){return this[0]?c.css(this[0],d,false,f?margin:border):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});returnscrollToine&&e.document?e.document.compatMode===CSS1Compat&&e.document.documentElement[client+b]||e.document.body[client+b]:e.nodeType===9?Math.max(e.documentElement[client+b],e.body[scroll+b],e.documentElement[scroll+b],e.body[offset+b],e.documentElement[offset+b]):f===w?c.css(e,d):this.css(d,typeof f===string?f:f+px)}});A.jQuery=A.$=c})(window);"
"/* * jQuery UI Nested Sortable * v 1.3.5 / 21 jun 2012 * http://mjsarfatti.com/code/nestedSortable * * Depends on: *	 jquery.ui.sortable.js 1.8+ * * Copyright (c) 2010-2012 Manuele J Sarfatti * Licensed under the MIT License * http://www.opensource.org/licenses/mit-license.php */
(function($) {
	$.widget(mjs.nestedSortable, $.extend({}, $.ui.sortable.prototype, {
		options: {			tabSize: 20,			disableNesting: mjs-nestedSortable-no-nesting,			errorClass: mjs-nestedSortable-error,			doNotClear: false,			listType: ol,			maxLevels: 0,			protectRoot: false,			rootID: null,			rtl: false,			isAllowed: function(item, parent) { return true; }		},
		_create: function() {			this.element.data(sortable, this.element.data(nestedSortable));
			if (!this.element.is(this.options.listType))				throw new Error(nestedSortable: Please check the listType option is set to your actual list type);
			return $.ui.sortable.prototype._create.apply(this, arguments);		},
		destroy: function() {			this.element				.removeData(nestedSortable)				.unbind(.nestedSortable);			return $.ui.sortable.prototype.destroy.apply(this, arguments);		},
		_mouseDrag: function(event) {
			Compute the helpers position			this.position = this._generatePosition(event);			this.positionAbs = this._convertPositionTo(absolute);
			if (!this.lastPositionAbs) {				this.lastPositionAbs = this.positionAbs;			}
			var o = this.options;
			Do scrolling			if(this.options.scroll) {				var scrolled = false;				if(this.scrollParent[0] != document && this.scrollParent[0].tagName != HTML) {
					if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;					else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;					else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				} else {
					if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);					else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);					else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
				if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)					$.ui.ddmanager.prepareOffsets(this, event);			}
			Regenerate the absolute position used for position checks			this.positionAbs = this._convertPositionTo(absolute);
       Find the top offset before rearrangement,      var previousTopOffset = this.placeholder.offset().top;
			Set the helper position			if(!this.options.axis || this.options.axis != y) this.helper[0].style.left = this.position.left+px;			if(!this.options.axis || this.options.axis != x) this.helper[0].style.top = this.position.top+px;
			Rearrange			for (var i = this.items.length - 1; i >= 0; i--) {
				Cache variables and intersection, continue if no intersection				var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);				if (!intersection) continue;
				if(itemElement != this.currentItem[0] cannot intersect with itself					&&	this.placeholder[intersection == 1 ? next : prev]()[0] != itemElement no useless actions that have been done before					&&	!$.contains(this.placeholder[0], itemElement) no action if the item moved is the parent of the item checked					&& (this.options.type == semi-dynamic ? !$.contains(this.element[0], itemElement) : true)					&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container				) {
					$(itemElement).mouseenter();
					this.direction = intersection == 1 ? down : up;
					if (this.options.tolerance == pointer || this._intersectsWithSides(item)) {						$(itemElement).mouseleave();						this._rearrange(event, item);					} else {						break;					}
					 Clear emtpy ul's/ol's					this._clearEmpty(itemElement);
					this._trigger(change, event, this._uiHash());					break;				}			}
			var parentItem = (this.placeholder[0].parentNode.parentNode &&							 $(this.placeholder[0].parentNode.parentNode).closest(.ui-sortable).length)				       			? $(this.placeholder[0].parentNode.parentNode)				       			: null,			    level = this._getLevel(this.placeholder),			    childLevels = this._getChildLevels(this.helper);
       To find the previous sibling in the list, keep backtracking until we hit a valid list item.			var previousItem = this.placeholder[0].previousSibling ? $(this.placeholder[0].previousSibling) : null;			if (previousItem != null) {				while (previousItem[0].nodeName.toLowerCase() != li || previousItem[0] == this.currentItem[0] || previousItem[0] == this.helper[0]) {					if (previousItem[0].previousSibling) {						previousItem = $(previousItem[0].previousSibling);					} else {						previousItem = null;						break;					}				}			}
       To find the next sibling in the list, keep stepping forward until we hit a valid list item.      var nextItem = this.placeholder[0].nextSibling ? $(this.placeholder[0].nextSibling) : null;      if (nextItem != null) {        while (nextItem[0].nodeName.toLowerCase() != li || nextItem[0] == this.currentItem[0] || nextItem[0] == this.helper[0]) {          if (nextItem[0].nextSibling) {            nextItem = $(nextItem[0].nextSibling);          } else {            nextItem = null;            break;          }        }      }
			var newList = document.createElement(o.listType);
			this.beyondMaxLevels = 0;						 If the item is moved to the left, send it to its parent's level unless there are siblings below it.			if (parentItem != null && nextItem == null &&					(o.rtl && (this.positionAbs.left + this.helper.outerWidth() > parentItem.offset().left + parentItem.outerWidth()) ||					!o.rtl && (this.positionAbs.left < parentItem.offset().left))) {				parentItem.after(this.placeholder[0]);				this._clearEmpty(parentItem[0]);				this._trigger(change, event, this._uiHash());			}			 If the item is below a sibling and is moved to the right, make it a child of that sibling.			else if (previousItem != null &&						(o.rtl && (this.positionAbs.left + this.helper.outerWidth() < previousItem.offset().left + previousItem.outerWidth() - o.tabSize) ||						!o.rtl && (this.positionAbs.left > previousItem.offset().left + o.tabSize))) {				this._isAllowed(previousItem, level, level+childLevels+1);				if (!previousItem.children(o.listType).length) {					previousItem[0].appendChild(newList);				}         If this item is being moved from the top, add it to the top of the list.        if (previousTopOffset && (previousTopOffset <= previousItem.offset().top)) {          previousItem.children(o.listType).prepend(this.placeholder);        }         Otherwise, add it to the bottom of the list.        else {				  previousItem.children(o.listType)[0].appendChild(this.placeholder[0]);        }				this._trigger(change, event, this._uiHash());			}			else {				this._isAllowed(parentItem, level, level+childLevels);			}
			Post events to containers			this._contactContainers(event);
			Interconnect with droppables			if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);
			Call callbacks			this._trigger(sort, event, this._uiHash());
			this.lastPositionAbs = this.positionAbs;			return false;
		},
		_mouseStop: function(event, noPropagation) {
			 If the item is in a position not allowed, send it back			if (this.beyondMaxLevels) {
				this.placeholder.removeClass(this.options.errorClass);
				if (this.domPosition.prev) {					$(this.domPosition.prev).after(this.placeholder);				} else {					$(this.domPosition.parent).prepend(this.placeholder);				}
				this._trigger(revert, event, this._uiHash());
			}
			 Clean last empty ul/ol			for (var i = this.items.length - 1; i >= 0; i--) {				var item = this.items[i].item[0];				this._clearEmpty(item);			}
			$.ui.sortable.prototype._mouseStop.apply(this, arguments);
		},
		serialize: function(options) {
			var o = $.extend({}, this.options, options),				items = this._getItemsAsjQuery(o && o.connected),			    str = [];
			$(items).each(function() {				var res = ($(o.item || this).attr(o.attribute || id) || )						.match(o.expression || (()())),				    pid = ($(o.item || this).parent(o.listType)						.parent(o.items)						.attr(o.attribute || id) || )						.match(o.expression || (()()));
				if (res) {					str.push(((o.key || res[1]) + [ + (o.key && o.expression ? res[1] : res[2]) + ])						+ =						+ (pid ? (o.key && o.expression ? pid[1] : pid[2]) : o.rootID));				}			});
			if(!str.length && o.key) {				str.push(o.key + =);			}
			return str.join(&);
		},
		toHierarchy: function(options) {
			var o = $.extend({}, this.options, options),				sDepth = o.startDepthCount || 0,			    ret = [];
			$(this.element).children(o.items).each(function () {				var level = _recursiveItems(this);				ret.push(level);			});
			return ret;
			function _recursiveItems(item) {				var id = ($(item).attr(o.attribute || id) || ).match(o.expression || (()()));				if (id) {					var currentItem = {id : id[2]};					if ($(item).children(o.listType).children(o.items).length > 0) {						currentItem.children = [];						$(item).children(o.listType).children(o.items).each(function() {							var level = _recursiveItems(this);							currentItem.children.push(level);						});					}					return currentItem;				}			}		},
		toArray: function(options) {
			var o = $.extend({}, this.options, options),				sDepth = o.startDepthCount || 0,			    ret = [],			    left = 2;
			ret.push({				item_id: o.rootID,				parent_id: none,				depth: sDepth,				left: 1,				right: ($(o.items, this.element).length + 1) * 2			});
			$(this.element).children(o.items).each(function () {				left = _recursiveArray(this, sDepth + 1, left);			});
			ret = ret.sort(function(a,b){ return (a.left - b.left); });
			return ret;
			function _recursiveArray(item, depth, left) {
				var right = left + 1,				    id,				    pid;
				if ($(item).children(o.listType).children(o.items).length > 0) {					depth ++;					$(item).children(o.listType).children(o.items).each(function () {						right = _recursiveArray($(this), depth, right);					});					depth --;				}
				id = ($(item).attr(o.attribute || id)).match(o.expression || (()()));
				if (depth === sDepth + 1) {					pid = o.rootID;				} else {					var parentItem = ($(item).parent(o.listType)											 .parent(o.items)											 .attr(o.attribute || id))											 .match(o.expression || (()()));					pid = parentItem[2];				}
				if (id) {						ret.push({item_id: id[2], parent_id: pid, depth: depth, left: left, right: right});				}
				left = right + 1;				return left;			}
		},
		_clearEmpty: function(item) {
			var emptyList = $(item).children(this.options.listType);			if (emptyList.length && !emptyList.children().length && !this.options.doNotClear) {				emptyList.remove();			}
		},
		_getLevel: function(item) {
			var level = 1;
			if (this.options.listType) {				var list = item.closest(this.options.listType);				while (list && list.length > 0 &&                     	!list.is(.ui-sortable)) {					level++;					list = list.parent().closest(this.options.listType);				}			}
			return level;		},
		_getChildLevels: function(parent, depth) {			var self = this,			    o = this.options,			    result = 0;			depth = depth || 0;
			$(parent).children(o.listType).children(o.items).each(function (index, child) {					result = Math.max(self._getChildLevels(child, depth + 1), result);			});
			return depth ? result + 1 : result;		},
		_isAllowed: function(parentItem, level, levels) {			var o = this.options,				isRoot = $(this.domPosition.parent).hasClass(ui-sortable) ? true : false,				maxLevels = this.placeholder.closest(.ui-sortable).nestedSortable(option, maxLevels);  this takes into account the maxLevels set to the recipient list
			 Is the root protected?			 Are we trying to nest under a no-nest?			 Are we nesting too deep?			if (!o.isAllowed(this.currentItem, parentItem) ||				parentItem && parentItem.hasClass(o.disableNesting) ||				o.protectRoot && (parentItem == null && !isRoot || isRoot && level > 1)) {					this.placeholder.addClass(o.errorClass);					if (maxLevels < levels && maxLevels != 0) {						this.beyondMaxLevels = levels - maxLevels;					} else {						this.beyondMaxLevels = 1;					}			} else {				if (maxLevels < levels && maxLevels != 0) {					this.placeholder.addClass(o.errorClass);					this.beyondMaxLevels = levels - maxLevels;				} else {					this.placeholder.removeClass(o.errorClass);					this.beyondMaxLevels = 0;				}			}		}
	}));
	$.mjs.nestedSortable.prototype.options = $.extend({}, $.ui.sortable.prototype.options, $.mjs.nestedSortable.prototype.options);})(jQuery);"
"const gulp = require(gulp);
gulp.task(scripts, require(./gulp/tasks/scripts));gulp.task(set-watching, require(./gulp/tasks/set-watching));gulp.task(css, require(./gulp/tasks/css));gulp.task(jekyll, require(./gulp/tasks/jekyll));gulp.task(test, require(./gulp/tasks/test));
gulp.task(watch, gulp.series(  set-watching,  gulp.parallel(css, scripts),  jekyll));
gulp.task(default, gulp.series(scripts, test));"
"module.exports = {  extends: @odopod,};
"
"module.exports = function (config) {  use strict;
  var cfg = {    bowerComponents: demo/bower_components  };
  config.set({    basePath: ,    frameworks: [jasmine],
     files to load in the browser    files: [       components      cfg.bowerComponents + /angular/angular.js,      cfg.bowerComponents + /angular-mocks/angular-mocks.js,
       source files      source/**/*main.js,      source/**/*.js,
       tests      test/**/*.spec.js    ],
     generate js files from html templates to expose them during testing    preprocessors: {      **/*.html: ng-html2js    },
     https://github.com/karma-runner/karma-ng-html2js-preprocessor#configuration    ngHtml2JsPreprocessor: {       setting this option will create only a single module that contains templates       from all the files, so you can load them all with module('foo')    },
     files to exclude    exclude: [],
     level of logging     possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG    logLevel: config.LOG_INFO,
    port: 9876,    reporters: dots  });};"
"/* jshint node:true */
use strict;
var fs = require(fs);var path = require(path);
module.exports = function() {  var wiredep = require(wiredep);
  var bower_dependencies = wiredep({ cwd: __dirname });
  var js_dependencies = []    .concat(bower_dependencies.packages[jquery].main)    .concat(bower_dependencies.packages[jquery-ui].main)    .map(function(p) {      return p.replace(path.join(__dirname, /), );    });
  var css_dependencies = [    bower_components/jquery-ui/themes/smoothness/jquery-ui.css  ];
  function putThemInVendorDir (filepath) {    return vendor/ + path.basename(filepath);  }
  return {    humaName : UI.Sortable,    repoName : ui-sortable,    inlineHTML : fs.readFileSync(__dirname + /demo/demo.html),    inlineJS : fs.readFileSync(__dirname + /demo/demo.js),    css: css_dependencies.map(putThemInVendorDir).concat([demo/demo.css]),    js : function(defaultJsFiles){       HACK TO LOAD JQUERY BEFORE ANGULAR      return [vendor/jquery.js].concat(defaultJsFiles, js_dependencies.slice(1).map(putThemInVendorDir).concat([dist/sortable.js]));    },    bowerData: { main : ./sortable.js },    tocopy : css_dependencies.concat(js_dependencies)  };};"
"/** * angular-drag-and-drop-lists v2.1.0 * * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc * Copyright (c) 2014-2017 Google Inc. * https://github.com/marceljuenemann/angular-drag-and-drop-lists * * License: MIT */!function(e){function n(e,n){returnall==n?e:e.filter(function(e){return-1!=n.toLowerCase().indexOf(e)})}var a=application/x-dnd,r=application/json,t=Text,d=[move,copy,link]e.directive(dndDraggable,[$parse,$timeout,function(e,i){return function(l,f,c){f.attr(draggable,true),c.dndDisableIf&&l.$watch(c.dndDisableIf,function(e){f.attr(draggable,!e)}),f.on(dragstart,function(s){if(s=s.originalEvent||s,false==f.attr(draggable))return!0o.isDragging=!0,o.itemType=c.dndType&&l.$eval(c.dndType).toLowerCase(),o.dropEffect=none,o.effectAllowed=c.dndEffectAllowed||d[0],s.dataTransfer.effectAllowed=o.effectAllowedvar g=l.$eval(c.dndDraggable),u=a+(o.itemType?-+o.itemType:)try{s.dataTransfer.setData(u,angular.toJson(g))}catch(p){var v=angular.toJson({item:g,type:o.itemType})try{s.dataTransfer.setData(r,v)}catch(p){var D=n(d,o.effectAllowed)s.dataTransfer.effectAllowed=D[0],s.dataTransfer.setData(t,v)}}if(f.addClass(dndDragging),i(function(){f.addClass(dndDraggingSource)},0),s._dndHandle&&s.dataTransfer.setDragImage&&s.dataTransfer.setDragImage(f[0],0,0),e(c.dndDragstart)(l,{event:s}),c.dndCallback){var y=e(c.dndCallback)o.callback=function(e){return y(l,e||{})}}s.stopPropagation()}),f.on(dragend,function(n){n=n.originalEvent||n,l.$apply(function(){var a=o.dropEffect,r={copy:dndCopied,link:dndLinked,move:dndMoved,none:dndCanceled}e(c[r[a]])(l,{event:n}),e(c.dndDragend)(l,{event:n,dropEffect:a})}),o.isDragging=!1,o.callback=void 0,f.removeClass(dndDragging),f.removeClass(dndDraggingSource),n.stopPropagation(),i(function(){f.removeClass(dndDraggingSource)},0)}),f.on(click,function(n){c.dndSelected&&(n=n.originalEvent||n,l.$apply(function(){e(c.dndSelected)(l,{event:n})}),n.stopPropagation())}),f.on(selectstart,function(){this.dragDrop&&this.dragDrop()})}}]),e.directive(dndList,[$parse,function(e){return function(i,l,f){function c(e){if(!e)return tfor(var n=0;n<e.length;n++)if(e[n]==t||e[n]==r||e[n].substr(0,a.length)==a)return e[n]return null}function s(e){return o.isDragging?o.itemType||void 0:e==t||e==r?null:e&&e.substr(a.length+1)||void 0}function g(e){return E.disabled?!1:E.externalSources||o.isDragging?E.allowedTypes&&null!==e?e&&-1!=E.allowedTypes.indexOf(e):!0:!1}function u(e,a){var r=dreturn a||(r=n(r,e.dataTransfer.effectAllowed)),o.isDragging&&(r=n(r,o.effectAllowed)),f.dndEffectAllowed&&(r=n(r,f.dndEffectAllowed)),r.length?e.ctrlKey&&-1!=r.indexOf(copy)?copy:e.altKey&&-1!=r.indexOf(link)?link:r[0]:none}function p(){return T.remove(),l.removeClass(""dndDragover""),!0}function v(n,a,r,t,d,l){return e(n)(i,{callback:o.callback,dropEffect:r,event:a,external:!o.isDragging,index:void 0!==d?d:D(),item:l||void 0,type:t})}function D(){return Array.prototype.indexOf.call(m.children,h)}function y(){var ereturn angular.forEach(l.children(),function(n){var a=angular.element(n)a.hasClass(dndPlaceholder)&&(e=a)}),e||angular.element(<li class='dndPlaceholder'></li>)}var T=y()T.remove()var h=T[0],m=l[0],E={}l.on(dragenter,function(e){e=e.originalEvent||evar n=f.dndAllowedTypes&&i.$eval(f.dndAllowedTypes)E={allowedTypes:angular.isArray(n)&&n.join(|).toLowerCase().split(|),disabled:f.dndDisableIf&&i.$eval(f.dndDisableIf),externalSources:f.dndExternalSources&&i.$eval(f.dndExternalSources),horizontal:f.dndHorizontalList&&i.$eval(f.dndHorizontalList)}var a=c(e.dataTransfer.types)return a&&g(s(a))?void e.preventDefault():!0}),l.on(dragover,function(e){e=e.originalEvent||evar n=c(e.dataTransfer.types),a=s(n)if(!n||!g(a))return!0if(h.parentNode!=m&&l.append(T),e.target!=m){for(var r=e.target;r.parentNode!=m&&r.parentNode;)r=r.parentNodeif(r.parentNode==m&&r!=h){var d=r.getBoundingClientRect()if(E.horizontal)var o=e.clientX<d.left+d.width/2else var o=e.clientY<d.top+d.height/2m.insertBefore(h,o?r:r.nextSibling)}}var i=n==t,D=u(e,i)returnnone==D?p():f.dndDragover&&!v(f.dndDragover,e,D,a)?p():(e.preventDefault(),i||(e.dataTransfer.dropEffect=D),l.addClass(dndDragover),e.stopPropagation(),!1)}),l.on(drop,function(e){e=e.originalEvent||evar n=c(e.dataTransfer.types),a=s(n)if(!n||!g(a))return!0e.preventDefault()try{var d=JSON.parse(e.dataTransfer.getData(n))}catch(l){return p()}if((n==t||n==r)&&(a=d.type||void 0,d=d.item,!g(a)))return p()var y=n==t,T=u(e,y)if(none==T)return p()var h=D()return f.dndDrop&&(d=v(f.dndDrop,e,T,a,h,d),!d)?p():(o.dropEffect=T,y||(e.dataTransfer.dropEffect=T),d!==!0&&i.$apply(function(){i.$eval(f.dndList).splice(h,0,d)}),v(f.dndInserted,e,T,a,h,d),p(),e.stopPropagation(),!1)}),l.on(dragleave,function(e){e=e.originalEvent||evar n=document.elementFromPoint(e.clientX,e.clientY)m.contains(n)&&!e._dndPhShown?e._dndPhShown=!0:p()})}}]),e.directive(dndNodrag,function(){return function(e,n,a){n.attr(draggable,true),n.on(dragstart,function(e){e=e.originalEvent||e,e._dndHandle||(e.dataTransfer.types&&e.dataTransfer.types.length||e.preventDefault(),e.stopPropagation())}),n.on(dragend,function(e){e=e.originalEvent||e,e._dndHandle||e.stopPropagation()})}}),e.directive(dndHandle,function(){return function(e,n,a){n.attr(draggable,true),n.on(dragstart dragend,function(e){e=e.originalEvent||e,e._dndHandle=!0})}})var o={}}(angular.module(dndLists,[]));"
"var path = require(path);var webpack = require(webpack);var autoprefixer = require(autoprefixer);var ExtractTextPlugin = require(extract-text-webpack-plugin);var argv = require(yargs).argv;var minify = Boolean(argv.minify);var outputName = react-sortable-hoc;var plugins = {    default: [        new ExtractTextPlugin(../../styles.css)    ],    minify: [        new webpack.optimize.UglifyJsPlugin({            beautify: false,            comments: false,            mangle: false        }),        new ExtractTextPlugin(../../styles.min.css)    ]}
module.exports = {    devtool: (minify) ? source-map : null,    entry: [        ./src/index    ],    output: {        path: path.join(__dirname, dist/umd),        filename: (minify) ? outputName + .min.js : outputName + .js,        library: SortableHOC,        libraryTarget: umd    },    externals: {        react: {            commonjs: react,            commonjs2: react,            amd: react,            root: React        },        react-dom: {            commonjs: react-dom,            commonjs2: react-dom,            amd: react-dom,            root: ReactDOM        }    },    plugins: (minify) ? plugins.minify : plugins.default,    resolve: {		extensions: [, .js, .jsx, .scss]    },    module: {        loaders: [            {                test: jsx,                loaders: [babel],                exclude: node_modules,                include: path.join(__dirname, src)            },            {				test: (scsscss),				loader: ExtractTextPlugin.extract(style, css?-minimize&modules&importLoaders=1&localIdentName=Cal__[name]__[local]!postcss!sass?output=nested),                include: path.join(__dirname, src)            }        ]    },    postcss: [autoprefixer]}"
"var path = require(path);var webpack = require(webpack);var autoprefixer = require(autoprefixer);var HtmlWebpackPlugin = require(html-webpack-plugin);var DashboardPlugin = require(webpack-dashboard/plugin);
module.exports = {    devtool: cheap-module-eval-source-map,    entry: [        webpack-hot-middleware/client,        ./index    ],    output: {        path: path.join(__dirname, dist),        filename: bundle.js,        publicPath: /static/    },    plugins: [        new DashboardPlugin(),        new HtmlWebpackPlugin({			template: ./index.html,			inject: body  Inject all scripts into the body		}),        new webpack.optimize.OccurenceOrderPlugin(),        new webpack.HotModuleReplacementPlugin()    ],    resolve: {		extensions: [, .js, .jsx, .scss]    },    module: {        loaders: [            {                test: jsx,                loaders: [babel],                exclude: node_modules,                include: __dirname            },            {                test: (scss),                loaders: [style, css?sourceMap&modules&importLoaders=1&localIdentName=Cal__[name]__[local]!postcss!sass?sourceMap]            },            {                test: (css),                loaders: [style, css]            }        ]    },    postcss: [autoprefixer]}"
"use strict;
const gulp            = require(gulp);const jshint          = require(gulp-jshint);const stylish         = require(jshint-stylish);const rename          = require(gulp-rename);const jscs            = require(gulp-jscs);const uglify          = require(gulp-uglify);const livereload      = require(gulp-livereload);const exec            = require(child_process).exec;
gulp.task(default, [watch]);
gulp.task(watch, () => {    livereload.listen(35730);
    gulp.watch([        ./src/*.js,        ./src/*.hbs    ], [reload-js])        .on(change, function(e) {            console.log(                [gulp-watch] file  +                e.path +                 was  +                e.type +                , building            );        });});
gulp.task(reload-js, [build-dist], () => {    return livereload.changed();});
gulp.task(prod, [uglify]);
gulp.task(uglify, [build], () => {    return gulp.src([        ./dist/mixitup.js    ])        .pipe(uglify({            preserveComments: license        }))        .pipe(rename(mixitup.min.js))        .on(error, e => console.error([uglify]  + e.message))        .pipe(gulp.dest(./dist/))        .pipe(gulp.dest(./demos/));});
gulp.task(build, [build-dist], done => {    exec(node node_modules/mixitup-build/docs.js -s mixitup.js, (e, out) => {        if (out) {            console.log(out);        }
        done(e);    });});
gulp.task(build-dist, [lint, code-style], done => {    exec(node node_modules/mixitup-build/dist.js -o mixitup.js, (e, out) => {        if (out) {            console.log(out);        }
        done(e);    });});
gulp.task(lint, () => {    return gulp.src([        ./src/*.js    ], {        base: /    })        .pipe(jshint(./.jshintrc))        .pipe(jshint.reporter(stylish))        .pipe(jshint.reporter(fail));});
gulp.task(code-style, () => {    return gulp.src([        ./src/*.js    ], {        base: /    })        .pipe(jscs())        .pipe(jscs.reporter());});"
"use strict;
var fs = require(fs);
module.exports = function(grunt) {
     Project configuration.    grunt.initConfig({         Metadata.        pkg: grunt.file.readJSON(bootstrap-table.jquery.json),        banner: /* +                * <%= pkg.name %> - v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %> +                <%= pkg.homepage ? ""* "" + pkg.homepage : """" %> +                * Copyright (c) <%= grunt.template.today(""yyyy"") %> <%= pkg.author.name %> +                * Licensed <%= _.pluck(pkg.licenses, ""type"").join("", "") %> +                */,         Task configuration.        clean: [dist, docs/dist],        concat: {            basic_target: {                src: ['src/<%= pkg.name %>.js', 'src/extensions/**/*.js'],                dest: 'dist/<%= pkg.name %>-all.js'            },            locale_target: {                src: [src/locale/**/*.js],                dest: dist/<%= pkg.name %>-locale-all.js            }        },        uglify: {            options: {                banner: <%= banner %>            },            basic_target: {                files: {                    dist/<%= pkg.name %>.min.js: [src/<%=pkg.name %>.js],                    'dist/<%= pkg.name %>-all.min.js': ['dist/<%=pkg.name %>-all.js'],                    dist/<%= pkg.name %>-locale-all.min.js: [dist/<%=pkg.name %>-locale-all.js]                }            },            locale_target: {                files: [{                    expand: true,                    cwd: src/locale,                    src: **/*.js,                    dest: dist/locale,                    ext: .min.js  replace .js to .min.js                }]            },            extensions_target: {                files: [{                    expand: true,                    cwd: src/extensions,                    src: **/*.js,                    dest: dist/extensions,                    ext: .min.js  replace .js to .min.js                }]            }        },        cssmin: {            add_banner: {                options: {                    banner: <%= banner %>                },                files: {                    dist/<%= pkg.name %>.min.css: [src/<%=pkg.name %>.css]                }            }        },        copy: {            source: {                cwd: src,                      set working folder / root to copy                src: [**/*.js, **/*.css],    copy all files and subfolders                dest: dist,                    destination folder                expand: true                     required when using cwd            },            files: {                cwd: dist,             set working folder / root to copy                src: **/*,             copy all files and subfolders                dest: docs/dist,       destination folder                expand: true             required when using cwd            }        },        release: {            options: {                additionalFiles: [bootstrap-table.jquery.json],                beforeRelease: [docs, default]            }        }    });
    var bumpVersion = function (path, version, startWith) {        var lines = fs.readFileSync(path, utf8).split();        lines.forEach(function (line, i) {            if (line.indexOf(startWith) === 0) {                lines[i] = startWith + version;            }        });        fs.writeFileSync(path, lines.join(), utf8);
        grunt.log.ok(bumped version of  + path +  to  + version);    };
    grunt.registerTask(docs, build the docs, function () {        var version = require(./package.json).version;        bumpVersion(./_config.yml, version, current_version: );        bumpVersion(./src/bootstrap-table.js, version,  * version: );        bumpVersion(./src/bootstrap-table.css, version,  * version: );
        var changeLog = fs.readFileSync(./CHANGELOG.md, utf8);        var latestLogs = changeLog.split(### )[1];        var date = new Date();
        var lines = [            ### Latest release ( +            [date.getFullYear(), date.getMonth() + 1, date.getDate()].join(-) + ),            ,            #### v + latestLogs        ];        fs.writeFileSync(./docs/_includes/latest-release.md, lines.join(), utf8);
        grunt.log.ok(updated the latest-release.md to  + version);    });
    grunt.loadNpmTasks(grunt-contrib-clean);    grunt.loadNpmTasks(grunt-contrib-concat);    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-cssmin);    grunt.loadNpmTasks(grunt-contrib-copy);    grunt.loadNpmTasks(grunt-release);
    grunt.registerTask(default, [clean, concat, uglify, cssmin, copy]);};"
"const webpack = require(webpack),      PACKAGE = require(./package.json);
module.exports = {  entry: {    list: ./src/index.js,    list.min: ./src/index.js  },  output: {    path: __dirname + /dist,    filename: [name].js,    library: List  },  module: {    rules: [{      enforce: pre,      test: js,      exclude: (node_modulessrcutilsextendjs),      loader: jshint-loader    }]  },  devServer: {    inline: true  },  plugins: [    new webpack.optimize.UglifyJsPlugin({      include: minjs,      minimize: true    }),    new webpack.BannerPlugin({      banner: List.js v + PACKAGE.version +  ( + PACKAGE.homepage + ) by  + PACKAGE.author.name +  ( + PACKAGE.author.url + )    })  ]};"
"/** * jQuery plugin for Sortable * 	<> *   */(function (factory) {	use strict;
	if (typeof define === function && define.amd) {		define([jquery], factory);	}	else {		/* jshint sub:true */		factory(jQuery);	}})(function ($) {	use strict;

	/* CODE */

	/**	 * jQuery plugin for Sortable	 *     	 *               	 *  	 */	$.fn.sortable = function (options) {		var retVal,			args = arguments;
		this.each(function () {			var $el = $(this),				sortable = $el.data(sortable);
			if (!sortable && (options instanceof Object || !options)) {				sortable = new Sortable(this, options);				$el.data(sortable, sortable);			}
			if (sortable) {				if (options === widget) {					retVal = sortable;				}				else if (options === destroy) {					sortable.destroy();					$el.removeData(sortable);				}				else if (typeof sortable[options] === function) {					retVal = sortable[options].apply(sortable, [].slice.call(args, 1));				}				else if (options in sortable.options) {					retVal = sortable.option.apply(sortable, args);				}			}		});
		return (retVal === void 0) ? this : retVal;	};});"
"/*! Sortable 1.5.1 - MIT | git://github.com/rubaxa/Sortable.git */!function(a){""use strict"";""function""==typeof define&&define.amd?define(a):""undefined""!=typeof module&&""undefined""!=typeof module.exports?module.exports=a():window.Sortable=a()}(function(){""use strict"";function a(a,b){if(!a||!a.nodeType||1!==a.nodeType)throw""Sortable: `el` must be HTMLElement, and not ""+{}.toString.call(a);this.el=a,this.options=b=t({},b),a[T]=this;var c={group:Math.random(),sort:!0,disabled:!1,store:null,handle:null,scroll:!0,scrollSensitivity:30,scrollSpeed:10,draggable:/[uo]l/i.test(a.nodeName)?""li"":"">*"",ghostClass:""sortable-ghost"",chosenClass:""sortable-chosen"",dragClass:""sortable-drag"",ignore:""a, img"",filter:null,preventOnFilter:!0,animation:0,setData:function(a,b){a.setData(""Text"",b.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:""data-id"",delay:0,forceFallback:!1,fallbackClass:""sortable-fallback"",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0}};for(var d in c)!(d in b)&&(b[d]=c[d]);ga(b);for(var e in this)""_""===e.charAt(0)&&""function""==typeof this[e]&&(this[e]=this[e].bind(this));this.nativeDraggable=!b.forceFallback&&$,f(a,""mousedown"",this._onTapStart),f(a,""touchstart"",this._onTapStart),f(a,""pointerdown"",this._onTapStart),this.nativeDraggable&&(f(a,""dragover"",this),f(a,""dragenter"",this)),ea.push(this._onDragOver),b.store&&this.sort(b.store.get(this))}function b(a,b){""clone""!==a.lastPullMode&&(b=!0),z&&z.state!==b&&(i(z,""display"",b?""none"":""""),b||z.state&&(a.options.group.revertClone?(A.insertBefore(z,B),a._animate(w,z)):A.insertBefore(z,w)),z.state=b)}function c(a,b,c){if(a){c=c||V;do if("">*""===b&&a.parentNode===c||r(a,b))return a;while(a=d(a))}return null}function d(a){var b=a.host;return b&&b.nodeType?b:a.parentNode}function e(a){a.dataTransfer&&(a.dataTransfer.dropEffect=""move""),a.preventDefault()}function f(a,b,c){a.addEventListener(b,c,Z)}function g(a,b,c){a.removeEventListener(b,c,Z)}function h(a,b,c){if(a)if(a.classList)a.classList[c?""add"":""remove""](b);else{var d=("" ""+a.className+"" "").replace(R,"" "").replace("" ""+b+"" "","" "");a.className=(d+(c?"" ""+b:"""")).replace(R,"" "")}}function i(a,b,c){var d=a&&a.style;if(d){if(void 0===c)return V.defaultView&&V.defaultView.getComputedStyle?c=V.defaultView.getComputedStyle(a,""""):a.currentStyle&&(c=a.currentStyle),void 0===b?c:c[b];b in d||(b=""-webkit-""+b),d[b]=c+(""string""==typeof c?"""":""px"")}}function j(a,b,c){if(a){var d=a.getElementsByTagName(b),e=0,f=d.length;if(c)for(;e<f;e++)c(d[e],e);return d}return[]}function k(a,b,c,d,e,f,g){a=a||b[T];var h=V.createEvent(""Event""),i=a.options,j=""on""+c.charAt(0).toUpperCase()+c.substr(1);h.initEvent(c,!0,!0),h.to=b,h.from=e||b,h.item=d||b,h.clone=z,h.oldIndex=f,h.newIndex=g,b.dispatchEvent(h),i[j]&&i[j].call(a,h)}function l(a,b,c,d,e,f,g){var h,i,j=a[T],k=j.options.onMove;return h=V.createEvent(""Event""),h.initEvent(""move"",!0,!0),h.to=b,h.from=a,h.dragged=c,h.draggedRect=d,h.related=e||b,h.relatedRect=f||b.getBoundingClientRect(),a.dispatchEvent(h),k&&(i=k.call(j,h,g)),i}function m(a){a.draggable=!1}function n(){aa=!1}function o(a,b){var c=a.lastElementChild,d=c.getBoundingClientRect();return(b.clientY-(d.top+d.height)>5||b.clientX-(d.right+d.width)>5)&&c}function p(a){for(var b=a.tagName+a.className+a.src+a.href+a.textContent,c=b.length,d=0;c--;)d+=b.charCodeAt(c);return d.toString(36)}function q(a,b){var c=0;if(!a||!a.parentNode)return-1;for(;a&&(a=a.previousElementSibling);)""TEMPLATE""===a.nodeName.toUpperCase()||"">*""!==b&&!r(a,b)||c++;return c}function r(a,b){if(a){b=b.split(""."");var c=b.shift().toUpperCase(),d=new RegExp(""\\s(""+b.join(""|"")+"")(?=\\s)"",""g"");return!(""""!==c&&a.nodeName.toUpperCase()!=c||b.length&&(("" ""+a.className+"" "").match(d)||[]).length!=b.length)}return!1}function s(a,b){var c,d;return function(){void 0===c&&(c=arguments,d=this,setTimeout(function(){1===c.length?a.call(d,c[0]):a.apply(d,c),c=void 0},b))}}function t(a,b){if(a&&b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function u(a){return X?X(a).clone(!0)[0]:Y&&Y.dom?Y.dom(a).cloneNode(!0):a.cloneNode(!0)}function v(a){for(var b=a.getElementsByTagName(""input""),c=b.length;c--;){var d=b[c];d.checked&&da.push(d)}}if(""undefined""==typeof window||!window.document)return function(){throw new Error(""Sortable.js requires a window with a document"")};var w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q={},R=/\s+/g,S=/left|right|inline/,T=""Sortable""+(new Date).getTime(),U=window,V=U.document,W=U.parseInt,X=U.jQuery||U.Zepto,Y=U.Polymer,Z=!1,$=!!(""draggable""in V.createElement(""div"")),_=function(a){return!navigator.userAgent.match(/Trident.*rv[ :]?11\./)&&(a=V.createElement(""x""),a.style.cssText=""pointer-events:auto"",""auto""===a.style.pointerEvents)}(),aa=!1,ba=Math.abs,ca=Math.min,da=[],ea=[],fa=s(function(a,b,c){if(c&&b.scroll){var d,e,f,g,h,i,j=c[T],k=b.scrollSensitivity,l=b.scrollSpeed,m=a.clientX,n=a.clientY,o=window.innerWidth,p=window.innerHeight;if(E!==c&&(D=b.scroll,E=c,F=b.scrollFn,D===!0)){D=c;do if(D.offsetWidth<D.scrollWidth||D.offsetHeight<D.scrollHeight)break;while(D=D.parentNode)}D&&(d=D,e=D.getBoundingClientRect(),f=(ba(e.right-m)<=k)-(ba(e.left-m)<=k),g=(ba(e.bottom-n)<=k)-(ba(e.top-n)<=k)),f||g||(f=(o-m<=k)-(m<=k),g=(p-n<=k)-(n<=k),(f||g)&&(d=U)),Q.vx===f&&Q.vy===g&&Q.el===d||(Q.el=d,Q.vx=f,Q.vy=g,clearInterval(Q.pid),d&&(Q.pid=setInterval(function(){return i=g?g*l:0,h=f?f*l:0,""function""==typeof F?F.call(j,h,i,a):void(d===U?U.scrollTo(U.pageXOffset+h,U.pageYOffset+i):(d.scrollTop+=i,d.scrollLeft+=h))},24)))}},30),ga=function(a){function b(a,b){return void 0!==a&&a!==!0||(a=c.name),""function""==typeof a?a:function(c,d){var e=d.options.group.name;return b?a:a&&(a.join?a.indexOf(e)>-1:e==a)}}var c={},d=a.group;d&&""object""==typeof d||(d={name:d}),c.name=d.name,c.checkPull=b(d.pull,!0),c.checkPut=b(d.put),c.revertClone=d.revertClone,a.group=c};a.prototype={constructor:a,_onTapStart:function(a){var b,d=this,e=this.el,f=this.options,g=f.preventOnFilter,h=a.type,i=a.touches&&a.touches[0],j=(i||a).target,l=a.target.shadowRoot&&a.path[0]||j,m=f.filter;if(v(e),!w&&!(""mousedown""===h&&0!==a.button||f.disabled)&&(j=c(j,f.draggable,e),j&&C!==j)){if(b=q(j,f.draggable),""function""==typeof m){if(m.call(this,a,j,this))return k(d,l,""filter"",j,e,b),void(g&&a.preventDefault())}else if(m&&(m=m.split("","").some(function(a){if(a=c(l,a.trim(),e))return k(d,a,""filter"",j,e,b),!0})))return void(g&&a.preventDefault());f.handle&&!c(l,f.handle,e)||this._prepareDragStart(a,i,j,b)}},_prepareDragStart:function(a,b,c,d){var e,g=this,i=g.el,l=g.options,n=i.ownerDocument;c&&!w&&c.parentNode===i&&(N=a,A=i,w=c,x=w.parentNode,B=w.nextSibling,C=c,L=l.group,J=d,this._lastX=(b||a).clientX,this._lastY=(b||a).clientY,w.style[""will-change""]=""transform"",e=function(){g._disableDelayedDrag(),w.draggable=g.nativeDraggable,h(w,l.chosenClass,!0),g._triggerDragStart(a,b),k(g,A,""choose"",w,A,J)},l.ignore.split("","").forEach(function(a){j(w,a.trim(),m)}),f(n,""mouseup"",g._onDrop),f(n,""touchend"",g._onDrop),f(n,""touchcancel"",g._onDrop),f(n,""pointercancel"",g._onDrop),f(n,""selectstart"",g),l.delay?(f(n,""mouseup"",g._disableDelayedDrag),f(n,""touchend"",g._disableDelayedDrag),f(n,""touchcancel"",g._disableDelayedDrag),f(n,""mousemove"",g._disableDelayedDrag),f(n,""touchmove"",g._disableDelayedDrag),f(n,""pointermove"",g._disableDelayedDrag),g._dragStartTimer=setTimeout(e,l.delay)):e())},_disableDelayedDrag:function(){var a=this.el.ownerDocument;clearTimeout(this._dragStartTimer),g(a,""mouseup"",this._disableDelayedDrag),g(a,""touchend"",this._disableDelayedDrag),g(a,""touchcancel"",this._disableDelayedDrag),g(a,""mousemove"",this._disableDelayedDrag),g(a,""touchmove"",this._disableDelayedDrag),g(a,""pointermove"",this._disableDelayedDrag)},_triggerDragStart:function(a,b){b=b||(""touch""==a.pointerType?a:null),b?(N={target:w,clientX:b.clientX,clientY:b.clientY},this._onDragStart(N,""touch"")):this.nativeDraggable?(f(w,""dragend"",this),f(A,""dragstart"",this._onDragStart)):this._onDragStart(N,!0);try{V.selection?setTimeout(function(){V.selection.empty()}):window.getSelection().removeAllRanges()}catch(a){}},_dragStarted:function(){if(A&&w){var b=this.options;h(w,b.ghostClass,!0),h(w,b.dragClass,!1),a.active=this,k(this,A,""start"",w,A,J)}else this._nulling()},_emulateDragOver:function(){if(O){if(this._lastX===O.clientX&&this._lastY===O.clientY)return;this._lastX=O.clientX,this._lastY=O.clientY,_||i(y,""display"",""none"");var a=V.elementFromPoint(O.clientX,O.clientY),b=a,c=ea.length;if(b)do{if(b[T]){for(;c--;)ea[c]({clientX:O.clientX,clientY:O.clientY,target:a,rootEl:b});break}a=b}while(b=b.parentNode);_||i(y,""display"","""")}},_onTouchMove:function(b){if(N){var c=this.options,d=c.fallbackTolerance,e=c.fallbackOffset,f=b.touches?b.touches[0]:b,g=f.clientX-N.clientX+e.x,h=f.clientY-N.clientY+e.y,j=b.touches?""translate3d(""+g+""px,""+h+""px,0)"":""translate(""+g+""px,""+h+""px)"";if(!a.active){if(d&&ca(ba(f.clientX-this._lastX),ba(f.clientY-this._lastY))<d)return;this._dragStarted()}this._appendGhost(),P=!0,O=f,i(y,""webkitTransform"",j),i(y,""mozTransform"",j),i(y,""msTransform"",j),i(y,""transform"",j),b.preventDefault()}},_appendGhost:function(){if(!y){var a,b=w.getBoundingClientRect(),c=i(w),d=this.options;y=w.cloneNode(!0),h(y,d.ghostClass,!1),h(y,d.fallbackClass,!0),h(y,d.dragClass,!0),i(y,""top"",b.top-W(c.marginTop,10)),i(y,""left"",b.left-W(c.marginLeft,10)),i(y,""width"",b.width),i(y,""height"",b.height),i(y,""opacity"",""0.8""),i(y,""position"",""fixed""),i(y,""zIndex"",""100000""),i(y,""pointerEvents"",""none""),d.fallbackOnBody&&V.body.appendChild(y)||A.appendChild(y),a=y.getBoundingClientRect(),i(y,""width"",2*b.width-a.width),i(y,""height"",2*b.height-a.height)}},_onDragStart:function(a,b){var c=a.dataTransfer,d=this.options;this._offUpEvents(),L.checkPull(this,this,w,a)&&(z=u(w),z.draggable=!1,z.style[""will-change""]="""",i(z,""display"",""none""),h(z,this.options.chosenClass,!1),A.insertBefore(z,w),k(this,A,""clone"",w)),h(w,d.dragClass,!0),b?(""touch""===b?(f(V,""touchmove"",this._onTouchMove),f(V,""touchend"",this._onDrop),f(V,""touchcancel"",this._onDrop),f(V,""pointermove"",this._onTouchMove),f(V,""pointerup"",this._onDrop)):(f(V,""mousemove"",this._onTouchMove),f(V,""mouseup"",this._onDrop)),this._loopId=setInterval(this._emulateDragOver,50)):(c&&(c.effectAllowed=""move"",d.setData&&d.setData.call(this,c,w)),f(V,""drop"",this),setTimeout(this._dragStarted,0))},_onDragOver:function(d){var e,f,g,h,j=this.el,k=this.options,m=k.group,p=a.active,q=L===m,r=!1,s=k.sort;if(void 0!==d.preventDefault&&(d.preventDefault(),!k.dragoverBubble&&d.stopPropagation()),!w.animated&&(P=!0,p&&!k.disabled&&(q?s||(h=!A.contains(w)):M===this||(p.lastPullMode=L.checkPull(this,p,w,d))&&m.checkPut(this,p,w,d))&&(void 0===d.rootEl||d.rootEl===this.el))){if(fa(d,k,this.el),aa)return;if(e=c(d.target,k.draggable,j),f=w.getBoundingClientRect(),M!==this&&(M=this,r=!0),h)return b(p,!0),x=A,void(z||B?A.insertBefore(w,z||B):s||A.appendChild(w));if(0===j.children.length||j.children[0]===y||j===d.target&&(e=o(j,d))){if(e){if(e.animated)return;g=e.getBoundingClientRect()}b(p,q),l(A,j,w,f,e,g,d)!==!1&&(w.contains(j)||(j.appendChild(w),x=j),this._animate(f,w),e&&this._animate(g,e))}else if(e&&!e.animated&&e!==w&&void 0!==e.parentNode[T]){G!==e&&(G=e,H=i(e),I=i(e.parentNode)),g=e.getBoundingClientRect();var t=g.right-g.left,u=g.bottom-g.top,v=S.test(H.cssFloat+H.display)||""flex""==I.display&&0===I[""flex-direction""].indexOf(""row""),C=e.offsetWidth>w.offsetWidth,D=e.offsetHeight>w.offsetHeight,E=(v?(d.clientX-g.left)/t:(d.clientY-g.top)/u)>.5,F=e.nextElementSibling,J=l(A,j,w,f,e,g,d),K=!1;if(J!==!1){if(aa=!0,setTimeout(n,30),b(p,q),1===J||J===-1)K=1===J;else if(v){var N=w.offsetTop,O=e.offsetTop;K=N===O?e.previousElementSibling===w&&!C||E&&C:e.previousElementSibling===w||w.previousElementSibling===e?(d.clientY-g.top)/u>.5:O>N}else r||(K=F!==w&&!D||E&&D);w.contains(j)||(K&&!F?j.appendChild(w):e.parentNode.insertBefore(w,K?F:e)),x=w.parentNode,this._animate(f,w),this._animate(g,e)}}}},_animate:function(a,b){var c=this.options.animation;if(c){var d=b.getBoundingClientRect();1===a.nodeType&&(a=a.getBoundingClientRect()),i(b,""transition"",""none""),i(b,""transform"",""translate3d(""+(a.left-d.left)+""px,""+(a.top-d.top)+""px,0)""),b.offsetWidth,i(b,""transition"",""all ""+c+""ms""),i(b,""transform"",""translate3d(0,0,0)""),clearTimeout(b.animated),b.animated=setTimeout(function(){i(b,""transition"",""""),i(b,""transform"",""""),b.animated=!1},c)}},_offUpEvents:function(){var a=this.el.ownerDocument;g(V,""touchmove"",this._onTouchMove),g(V,""pointermove"",this._onTouchMove),g(a,""mouseup"",this._onDrop),g(a,""touchend"",this._onDrop),g(a,""pointerup"",this._onDrop),g(a,""touchcancel"",this._onDrop),g(a,""selectstart"",this)},_onDrop:function(b){var c=this.el,d=this.options;clearInterval(this._loopId),clearInterval(Q.pid),clearTimeout(this._dragStartTimer),g(V,""mousemove"",this._onTouchMove),this.nativeDraggable&&(g(V,""drop"",this),g(c,""dragstart"",this._onDragStart)),this._offUpEvents(),b&&(P&&(b.preventDefault(),!d.dropBubble&&b.stopPropagation()),y&&y.parentNode.removeChild(y),A!==x&&""clone""===a.active.lastPullMode||z&&z.parentNode.removeChild(z),w&&(this.nativeDraggable&&g(w,""dragend"",this),m(w),w.style[""will-change""]="""",h(w,this.options.ghostClass,!1),h(w,this.options.chosenClass,!1),A!==x?(K=q(w,d.draggable),K>=0&&(k(null,x,""add"",w,A,J,K),k(this,A,""remove"",w,A,J,K),k(null,x,""sort"",w,A,J,K),k(this,A,""sort"",w,A,J,K))):w.nextSibling!==B&&(K=q(w,d.draggable),K>=0&&(k(this,A,""update"",w,A,J,K),k(this,A,""sort"",w,A,J,K))),a.active&&(null!=K&&K!==-1||(K=J),k(this,A,""end"",w,A,J,K),this.save()))),this._nulling()},_nulling:function(){A=w=x=y=B=z=C=D=E=N=O=P=K=G=H=M=L=a.active=null,da.forEach(function(a){a.checked=!0}),da.length=0},handleEvent:function(a){switch(a.type){case""drop"":case""dragend"":this._onDrop(a);break;case""dragover"":case""dragenter"":w&&(this._onDragOver(a),e(a));break;case""selectstart"":a.preventDefault()}},toArray:function(){for(var a,b=[],d=this.el.children,e=0,f=d.length,g=this.options;e<f;e++)a=d[e],c(a,g.draggable,this.el)&&b.push(a.getAttribute(g.dataIdAttr)||p(a));return b},sort:function(a){var b={},d=this.el;this.toArray().forEach(function(a,e){var f=d.children[e];c(f,this.options.draggable,d)&&(b[a]=f)},this),a.forEach(function(a){b[a]&&(d.removeChild(b[a]),d.appendChild(b[a]))})},save:function(){var a=this.options.store;a&&a.set(this)},closest:function(a,b){return c(a,b||this.options.draggable,this.el)},option:function(a,b){var c=this.options;return void 0===b?c[a]:(c[a]=b,void(""group""===a&&ga(c)))},destroy:function(){var a=this.el;a[T]=null,g(a,""mousedown"",this._onTapStart),g(a,""touchstart"",this._onTapStart),g(a,""pointerdown"",this._onTapStart),this.nativeDraggable&&(g(a,""dragover"",this),g(a,""dragenter"",this)),Array.prototype.forEach.call(a.querySelectorAll(""[draggable]""),function(a){a.removeAttribute(""draggable"")}),ea.splice(ea.indexOf(this._onDragOver),1),this._onDrop(),this.el=a=null}},f(V,""touchmove"",function(b){a.active&&b.preventDefault()});try{window.addEventListener(""test"",null,Object.defineProperty({},""passive"",{get:function(){Z={capture:!1,passive:!1}}}))}catch(a){}return a.utils={on:f,off:g,css:i,find:j,is:function(a,b){return!!c(a,b,a)},extend:t,throttle:s,closest:c,toggleClass:h,clone:u,index:q},a.create=function(b,c){return new a(b,c)},a.version=""1.5.1"",a});"
"/**! * Sortable * 	<> *   */
(function sortableModule(factory) {	use strict;
	if (typeof define === function && define.amd) {		define(factory);	}	else if (typeof module != undefined && typeof module.exports != undefined) {		module.exports = factory();	}	else {		/* jshint sub:true */		window[Sortable] = factory();	}})(function sortableFactory() {	use strict;
	if (typeof window == undefined || !window.document) {		return function sortableError() {			throw new Error(Sortable.js requires a window with a document);		};	}
	var dragEl,		parentEl,		ghostEl,		cloneEl,		rootEl,		nextEl,		lastDownEl,
		scrollEl,		scrollParentEl,		scrollCustomFn,
		lastEl,		lastCSS,		lastParentCSS,
		oldIndex,		newIndex,
		activeGroup,		putSortable,
		autoScroll = {},
		tapEvt,		touchEvt,
		moved,
		 */		R_SPACE = g,		R_FLOAT = leftrightinline,
		expando = Sortable + (new Date).getTime(),
		win = window,		document = win.document,		parseInt = win.parseInt,
		$ = win.jQuery || win.Zepto,		Polymer = win.Polymer,
		captureMode = false,
		supportDraggable = !!(draggable in document.createElement(div)),		supportCssPointerEvents = (function (el) {			 false when IE11			if (!!navigator.userAgent.match(Tridentrv11)) {				return false;			}			el = document.createElement(x);			el.style.cssText = pointer-events:auto;			return el.style.pointerEvents === auto;		})(),
		_silent = false,
		abs = Math.abs,		min = Math.min,
		savedInputChecked = [],		touchDragOverListeners = [],
		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {			 Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521			if (rootEl && options.scroll) {				var _this = rootEl[expando],					el,					rect,					sens = options.scrollSensitivity,					speed = options.scrollSpeed,
					x = evt.clientX,					y = evt.clientY,
					winWidth = window.innerWidth,					winHeight = window.innerHeight,
					vx,					vy,
					scrollOffsetX,					scrollOffsetY				;
				 Delect scrollEl				if (scrollParentEl !== rootEl) {					scrollEl = options.scroll;					scrollParentEl = rootEl;					scrollCustomFn = options.scrollFn;
					if (scrollEl === true) {						scrollEl = rootEl;
						do {							if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||								(scrollEl.offsetHeight < scrollEl.scrollHeight)							) {								break;							}							/* jshint boss:true */						} while (scrollEl = scrollEl.parentNode);					}				}
				if (scrollEl) {					el = scrollEl;					rect = scrollEl.getBoundingClientRect();					vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);					vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);				}

				if (!(vx || vy)) {					vx = (winWidth - x <= sens) - (x <= sens);					vy = (winHeight - y <= sens) - (y <= sens);
					/* jshint expr:true */					(vx || vy) && (el = win);				}

				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {					autoScroll.el = el;					autoScroll.vx = vx;					autoScroll.vy = vy;
					clearInterval(autoScroll.pid);
					if (el) {						autoScroll.pid = setInterval(function () {							scrollOffsetY = vy ? vy * speed : 0;							scrollOffsetX = vx ? vx * speed : 0;
							if (function === typeof(scrollCustomFn)) {								return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);							}
							if (el === win) {								win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);							} else {								el.scrollTop += scrollOffsetY;								el.scrollLeft += scrollOffsetX;							}						}, 24);					}				}			}		}, 30),
		_prepareGroup = function (options) {			function toFn(value, pull) {				if (value === void 0 || value === true) {					value = group.name;				}
				if (typeof value === function) {					return value;				} else {					return function (to, from) {						var fromGroup = from.options.group.name;
						return pull							? value							: value && (value.join								? value.indexOf(fromGroup) > -1								: (fromGroup == value)							);					};				}			}
			var group = {};			var originalGroup = options.group;
			if (!originalGroup || typeof originalGroup != object) {				originalGroup = {name: originalGroup};			}
			group.name = originalGroup.name;			group.checkPull = toFn(originalGroup.pull, true);			group.checkPut = toFn(originalGroup.put);			group.revertClone = originalGroup.revertClone;
			options.group = group;		}	;

	/**	 *   Sortable	 *     	 *          	 */	function Sortable(el, options) {		if (!(el && el.nodeType && el.nodeType === 1)) {			throw Sortable: `el` must be HTMLElement, and not  + {}.toString.call(el);		}
		this.el = el;  root element		this.options = options = _extend({}, options);

		 Export instance		el[expando] = this;
		 Default options		var defaults = {			group: Math.random(),			sort: true,			disabled: false,			store: null,			handle: null,			scroll: true,			scrollSensitivity: 30,			scrollSpeed: 10,			draggable: li.test(el.nodeName) ? li : >*,			ghostClass: sortable-ghost,			chosenClass: sortable-chosen,			dragClass: sortable-drag,			ignore: a, img,			filter: null,			preventOnFilter: true,			animation: 0,			setData: function (dataTransfer, dragEl) {				dataTransfer.setData(Text, dragEl.textContent);			},			dropBubble: false,			dragoverBubble: false,			dataIdAttr: data-id,			delay: 0,			forceFallback: false,			fallbackClass: sortable-fallback,			fallbackOnBody: false,			fallbackTolerance: 0,			fallbackOffset: {x: 0, y: 0}		};

		 Set default options		for (var name in defaults) {			!(name in options) && (options[name] = defaults[name]);		}
		_prepareGroup(options);
		 Bind all private methods		for (var fn in this) {			if (fn.charAt(0) === _ && typeof this[fn] === function) {				this[fn] = this[fn].bind(this);			}		}
		 Setup drag mode		this.nativeDraggable = options.forceFallback ? false : supportDraggable;
		 Bind events		_on(el, mousedown, this._onTapStart);		_on(el, touchstart, this._onTapStart);		_on(el, pointerdown, this._onTapStart);
		if (this.nativeDraggable) {			_on(el, dragover, this);			_on(el, dragenter, this);		}
		touchDragOverListeners.push(this._onDragOver);
		 Restore sorting		options.store && this.sort(options.store.get(this));	}

	Sortable.prototype =   */ {		constructor: Sortable,
		_onTapStart: function (evt) {			var _this = this,				el = this.el,				options = this.options,				preventOnFilter = options.preventOnFilter,				type = evt.type,				touch = evt.touches && evt.touches[0],				target = (touch || evt).target,				originalTarget = evt.target.shadowRoot && evt.path[0] || target,				filter = options.filter,				startIndex;
			_saveInputCheckedState(el);

			 Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.			if (dragEl) {				return;			}
			if (type === mousedown && evt.button !== 0 || options.disabled) {				return;  only left button or enabled			}

			target = _closest(target, options.draggable, el);
			if (!target) {				return;			}
			if (lastDownEl === target) {				 Ignoring duplicate `down`				return;			}
			 Get the index of the dragged element within its parent			startIndex = _index(target, options.draggable);
			 Check filter			if (typeof filter === function) {				if (filter.call(this, evt, target, this)) {					_dispatchEvent(_this, originalTarget, filter, target, el, startIndex);					preventOnFilter && evt.preventDefault();					return;  cancel dnd				}			}			else if (filter) {				filter = filter.split(,).some(function (criteria) {					criteria = _closest(originalTarget, criteria.trim(), el);
					if (criteria) {						_dispatchEvent(_this, criteria, filter, target, el, startIndex);						return true;					}				});
				if (filter) {					preventOnFilter && evt.preventDefault();					return;  cancel dnd				}			}
			if (options.handle && !_closest(originalTarget, options.handle, el)) {				return;			}
			 Prepare `dragstart`			this._prepareDragStart(evt, touch, target, startIndex);		},
		_prepareDragStart: function (evt, touch, target, startIndex) {			var _this = this,				el = _this.el,				options = _this.options,				ownerDocument = el.ownerDocument,				dragStartFn;
			if (target && !dragEl && (target.parentNode === el)) {				tapEvt = evt;
				rootEl = el;				dragEl = target;				parentEl = dragEl.parentNode;				nextEl = dragEl.nextSibling;				lastDownEl = target;				activeGroup = options.group;				oldIndex = startIndex;
				this._lastX = (touch || evt).clientX;				this._lastY = (touch || evt).clientY;
				dragEl.style[will-change] = transform;
				dragStartFn = function () {					 Delayed drag has been triggered					 we can re-enable the events: touchmove/mousemove					_this._disableDelayedDrag();
					 Make the element draggable					dragEl.draggable = _this.nativeDraggable;
					 Chosen item					_toggleClass(dragEl, options.chosenClass, true);
					 Bind the events: dragstart/dragend					_this._triggerDragStart(evt, touch);
					 Drag start event					_dispatchEvent(_this, rootEl, choose, dragEl, rootEl, oldIndex);				};
				 Disable ""draggable""				options.ignore.split(,).forEach(function (criteria) {					_find(dragEl, criteria.trim(), _disableDraggable);				});
				_on(ownerDocument, mouseup, _this._onDrop);				_on(ownerDocument, touchend, _this._onDrop);				_on(ownerDocument, touchcancel, _this._onDrop);				_on(ownerDocument, pointercancel, _this._onDrop);				_on(ownerDocument, selectstart, _this);
				if (options.delay) {					 If the user moves the pointer or let go the click or touch					 before the delay has been reached:					 disable the delayed drag					_on(ownerDocument, mouseup, _this._disableDelayedDrag);					_on(ownerDocument, touchend, _this._disableDelayedDrag);					_on(ownerDocument, touchcancel, _this._disableDelayedDrag);					_on(ownerDocument, mousemove, _this._disableDelayedDrag);					_on(ownerDocument, touchmove, _this._disableDelayedDrag);					_on(ownerDocument, pointermove, _this._disableDelayedDrag);
					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);				} else {					dragStartFn();				}

			}		},
		_disableDelayedDrag: function () {			var ownerDocument = this.el.ownerDocument;
			clearTimeout(this._dragStartTimer);			_off(ownerDocument, mouseup, this._disableDelayedDrag);			_off(ownerDocument, touchend, this._disableDelayedDrag);			_off(ownerDocument, touchcancel, this._disableDelayedDrag);			_off(ownerDocument, mousemove, this._disableDelayedDrag);			_off(ownerDocument, touchmove, this._disableDelayedDrag);			_off(ownerDocument, pointermove, this._disableDelayedDrag);		},
		_triggerDragStart: function (evt, touch) {			touch = touch || (evt.pointerType == touch ? evt : null);
			if (touch) {				 Touch device support				tapEvt = {					target: dragEl,					clientX: touch.clientX,					clientY: touch.clientY				};
				this._onDragStart(tapEvt, touch);			}			else if (!this.nativeDraggable) {				this._onDragStart(tapEvt, true);			}			else {				_on(dragEl, dragend, this);				_on(rootEl, dragstart, this._onDragStart);			}
			try {				if (document.selection) {										 Timeout neccessary for IE9										setTimeout(function () {						document.selection.empty();					});									} else {					window.getSelection().removeAllRanges();				}			} catch (err) {			}		},
		_dragStarted: function () {			if (rootEl && dragEl) {				var options = this.options;
				 Apply effect				_toggleClass(dragEl, options.ghostClass, true);				_toggleClass(dragEl, options.dragClass, false);
				Sortable.active = this;
				 Drag start event				_dispatchEvent(this, rootEl, start, dragEl, rootEl, oldIndex);			} else {				this._nulling();			}		},
		_emulateDragOver: function () {			if (touchEvt) {				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {					return;				}
				this._lastX = touchEvt.clientX;				this._lastY = touchEvt.clientY;
				if (!supportCssPointerEvents) {					_css(ghostEl, display, none);				}
				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),					parent = target,					i = touchDragOverListeners.length;
				if (parent) {					do {						if (parent[expando]) {							while (i--) {								touchDragOverListeners[i]({									clientX: touchEvt.clientX,									clientY: touchEvt.clientY,									target: target,									rootEl: parent								});							}
							break;						}
						target = parent;  store last element					}					/* jshint boss:true */					while (parent = parent.parentNode);				}
				if (!supportCssPointerEvents) {					_css(ghostEl, display, );				}			}		},

		_onTouchMove: function (/**TouchEvent*/evt) {			if (tapEvt) {				var	options = this.options,					fallbackTolerance = options.fallbackTolerance,					fallbackOffset = options.fallbackOffset,					touch = evt.touches ? evt.touches[0] : evt,					dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,					dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,					translate3d = evt.touches ? translate3d( + dx + px, + dy + px,0) : translate( + dx + px, + dy + px);
				 only set the status to dragging, when we are actually dragging				if (!Sortable.active) {					if (fallbackTolerance &&						min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance					) {						return;					}
					this._dragStarted();				}
				 as well as creating the ghost element on the document body				this._appendGhost();
				moved = true;				touchEvt = touch;
				_css(ghostEl, webkitTransform, translate3d);				_css(ghostEl, mozTransform, translate3d);				_css(ghostEl, msTransform, translate3d);				_css(ghostEl, transform, translate3d);
				evt.preventDefault();			}		},
		_appendGhost: function () {			if (!ghostEl) {				var rect = dragEl.getBoundingClientRect(),					css = _css(dragEl),					options = this.options,					ghostRect;
				ghostEl = dragEl.cloneNode(true);
				_toggleClass(ghostEl, options.ghostClass, false);				_toggleClass(ghostEl, options.fallbackClass, true);				_toggleClass(ghostEl, options.dragClass, true);
				_css(ghostEl, top, rect.top - parseInt(css.marginTop, 10));				_css(ghostEl, left, rect.left - parseInt(css.marginLeft, 10));				_css(ghostEl, width, rect.width);				_css(ghostEl, height, rect.height);				_css(ghostEl, opacity, 0.8);				_css(ghostEl, position, fixed);				_css(ghostEl, zIndex, 100000);				_css(ghostEl, pointerEvents, none);
				options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
				 Fixing dimensions.				ghostRect = ghostEl.getBoundingClientRect();				_css(ghostEl, width, rect.width * 2 - ghostRect.width);				_css(ghostEl, height, rect.height * 2 - ghostRect.height);			}		},
		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {			var dataTransfer = evt.dataTransfer,				options = this.options;
			this._offUpEvents();
			if (activeGroup.checkPull(this, this, dragEl, evt)) {				cloneEl = _clone(dragEl);
				cloneEl.draggable = false;				cloneEl.style[will-change] = ;
				_css(cloneEl, display, none);				_toggleClass(cloneEl, this.options.chosenClass, false);
				rootEl.insertBefore(cloneEl, dragEl);				_dispatchEvent(this, rootEl, clone, dragEl);			}
			_toggleClass(dragEl, options.dragClass, true);
			if (useFallback) {				if (useFallback === touch) {					 Bind touch events					_on(document, touchmove, this._onTouchMove);					_on(document, touchend, this._onDrop);					_on(document, touchcancel, this._onDrop);					_on(document, pointermove, this._onTouchMove);					_on(document, pointerup, this._onDrop);				} else {					 Old brwoser					_on(document, mousemove, this._onTouchMove);					_on(document, mouseup, this._onDrop);				}
				this._loopId = setInterval(this._emulateDragOver, 50);			}			else {				if (dataTransfer) {					dataTransfer.effectAllowed = move;					options.setData && options.setData.call(this, dataTransfer, dragEl);				}
				_on(document, drop, this);				setTimeout(this._dragStarted, 0);			}		},
		_onDragOver: function (/**Event*/evt) {			var el = this.el,				target,				dragRect,				targetRect,				revert,				options = this.options,				group = options.group,				activeSortable = Sortable.active,				isOwner = (activeGroup === group),				isMovingBetweenSortable = false,				canSort = options.sort;
			if (evt.preventDefault !== void 0) {				evt.preventDefault();				!options.dragoverBubble && evt.stopPropagation();			}
			if (dragEl.animated) {				return;			}
			moved = true;
			if (activeSortable && !options.disabled &&				(isOwner					? canSort || (revert = !rootEl.contains(dragEl))  Reverting item into the original list					: (						putSortable === this ||						(							(activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&							group.checkPut(this, activeSortable, dragEl, evt)						)					)				) &&				(evt.rootEl === void 0 || evt.rootEl === this.el)  touch fallback			) {				 Smart auto-scrolling				_autoScroll(evt, options, this.el);
				if (_silent) {					return;				}
				target = _closest(evt.target, options.draggable, el);				dragRect = dragEl.getBoundingClientRect();
				if (putSortable !== this) {					putSortable = this;					isMovingBetweenSortable = true;				}
				if (revert) {					_cloneHide(activeSortable, true);					parentEl = rootEl;  actualization
					if (cloneEl || nextEl) {						rootEl.insertBefore(dragEl, cloneEl || nextEl);					}					else if (!canSort) {						rootEl.appendChild(dragEl);					}
					return;				}

				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||					(el === evt.target) && (target = _ghostIsLast(el, evt))				) {					if (target) {						if (target.animated) {							return;						}
						targetRect = target.getBoundingClientRect();					}
					_cloneHide(activeSortable, isOwner);
					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {						if (!dragEl.contains(el)) {							el.appendChild(dragEl);							parentEl = el;  actualization						}
						this._animate(dragRect, dragEl);						target && this._animate(targetRect, target);					}				}				else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {					if (lastEl !== target) {						lastEl = target;						lastCSS = _css(target);						lastParentCSS = _css(target.parentNode);					}
					targetRect = target.getBoundingClientRect();
					var width = targetRect.right - targetRect.left,						height = targetRect.bottom - targetRect.top,						floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)							|| (lastParentCSS.display == flex && lastParentCSS[flex-direction].indexOf(row) === 0),						isWide = (target.offsetWidth > dragEl.offsetWidth),						isLong = (target.offsetHeight > dragEl.offsetHeight),						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,						nextSibling = target.nextElementSibling,						moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt),						after = false					;
					if (moveVector !== false) {						_silent = true;						setTimeout(_unsilent, 30);
						_cloneHide(activeSortable, isOwner);
						if (moveVector === 1 || moveVector === -1) {							after = (moveVector === 1);						}						else if (floating) {							var elTop = dragEl.offsetTop,								tgTop = target.offsetTop;
							if (elTop === tgTop) {								after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;							}							else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {								after = (evt.clientY - targetRect.top) / height > 0.5;							} else {								after = tgTop > elTop;							}						} else if (!isMovingBetweenSortable) {							after = (nextSibling !== dragEl) && !isLong || halfway && isLong;						}
						if (!dragEl.contains(el)) {							if (after && !nextSibling) {								el.appendChild(dragEl);							} else {								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);							}						}
						parentEl = dragEl.parentNode;  actualization
						this._animate(dragRect, dragEl);						this._animate(targetRect, target);					}				}			}		},
		_animate: function (prevRect, target) {			var ms = this.options.animation;
			if (ms) {				var currentRect = target.getBoundingClientRect();
				if (prevRect.nodeType === 1) {					prevRect = prevRect.getBoundingClientRect();				}
				_css(target, transition, none);				_css(target, transform, translate3d(					+ (prevRect.left - currentRect.left) + px,					+ (prevRect.top - currentRect.top) + px,0)				);
				target.offsetWidth;  repaint
				_css(target, transition, all  + ms + ms);				_css(target, transform, translate3d(0,0,0));
				clearTimeout(target.animated);				target.animated = setTimeout(function () {					_css(target, transition, );					_css(target, transform, );					target.animated = false;				}, ms);			}		},
		_offUpEvents: function () {			var ownerDocument = this.el.ownerDocument;
			_off(document, touchmove, this._onTouchMove);			_off(document, pointermove, this._onTouchMove);			_off(ownerDocument, mouseup, this._onDrop);			_off(ownerDocument, touchend, this._onDrop);			_off(ownerDocument, pointerup, this._onDrop);			_off(ownerDocument, touchcancel, this._onDrop);			_off(ownerDocument, selectstart, this);		},
		_onDrop: function (/**Event*/evt) {			var el = this.el,				options = this.options;
			clearInterval(this._loopId);			clearInterval(autoScroll.pid);			clearTimeout(this._dragStartTimer);
			 Unbind events			_off(document, mousemove, this._onTouchMove);
			if (this.nativeDraggable) {				_off(document, drop, this);				_off(el, dragstart, this._onDragStart);			}
			this._offUpEvents();
			if (evt) {				if (moved) {					evt.preventDefault();					!options.dropBubble && evt.stopPropagation();				}
				ghostEl && ghostEl.parentNode.removeChild(ghostEl);
				if (rootEl === parentEl || Sortable.active.lastPullMode !== clone) {					 Remove clone					cloneEl && cloneEl.parentNode.removeChild(cloneEl);				}
				if (dragEl) {					if (this.nativeDraggable) {						_off(dragEl, dragend, this);					}
					_disableDraggable(dragEl);					dragEl.style[will-change] = ;
					 Remove class's					_toggleClass(dragEl, this.options.ghostClass, false);					_toggleClass(dragEl, this.options.chosenClass, false);
					if (rootEl !== parentEl) {						newIndex = _index(dragEl, options.draggable);
						if (newIndex >= 0) {							 Add event							_dispatchEvent(null, parentEl, add, dragEl, rootEl, oldIndex, newIndex);
							 Remove event							_dispatchEvent(this, rootEl, remove, dragEl, rootEl, oldIndex, newIndex);
							 drag from one list and drop into another							_dispatchEvent(null, parentEl, sort, dragEl, rootEl, oldIndex, newIndex);							_dispatchEvent(this, rootEl, sort, dragEl, rootEl, oldIndex, newIndex);						}					}					else {						if (dragEl.nextSibling !== nextEl) {							 Get the index of the dragged element within its parent							newIndex = _index(dragEl, options.draggable);
							if (newIndex >= 0) {								 drag & drop within the same list								_dispatchEvent(this, rootEl, update, dragEl, rootEl, oldIndex, newIndex);								_dispatchEvent(this, rootEl, sort, dragEl, rootEl, oldIndex, newIndex);							}						}					}
					if (Sortable.active) {						/* jshint eqnull:true */						if (newIndex == null || newIndex === -1) {							newIndex = oldIndex;						}
						_dispatchEvent(this, rootEl, end, dragEl, rootEl, oldIndex, newIndex);
						 Save sorting						this.save();					}				}
			}
			this._nulling();		},
		_nulling: function() {			rootEl =			dragEl =			parentEl =			ghostEl =			nextEl =			cloneEl =			lastDownEl =
			scrollEl =			scrollParentEl =
			tapEvt =			touchEvt =
			moved =			newIndex =
			lastEl =			lastCSS =
			putSortable =			activeGroup =			Sortable.active = null;
			savedInputChecked.forEach(function (el) {				el.checked = true;			});			savedInputChecked.length = 0;		},
		handleEvent: function (/**Event*/evt) {			switch (evt.type) {				case drop:				case dragend:					this._onDrop(evt);					break;
				case dragover:				case dragenter:					if (dragEl) {						this._onDragOver(evt);						_globalDragOver(evt);					}					break;
				case selectstart:					evt.preventDefault();					break;			}		},

		/**		 * Serializes the item into an array of string.		 *  		 */		toArray: function () {			var order = [],				el,				children = this.el.children,				i = 0,				n = children.length,				options = this.options;
			for (; i < n; i++) {				el = children[i];				if (_closest(el, options.draggable, this.el)) {					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));				}			}
			return order;		},

		/**		 * Sorts the elements according to the array.		 *       order of the items		 */		sort: function (order) {			var items = {}, rootEl = this.el;
			this.toArray().forEach(function (id, i) {				var el = rootEl.children[i];
				if (_closest(el, this.options.draggable, rootEl)) {					items[id] = el;				}			}, this);
			order.forEach(function (id) {				if (items[id]) {					rootEl.removeChild(items[id]);					rootEl.appendChild(items[id]);				}			});		},

		/**		 * Save the current sorting		 */		save: function () {			var store = this.options.store;			store && store.set(this);		},

		/**		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.		 *      		 *             default: `options.draggable`		 *  		 */		closest: function (el, selector) {			return _closest(el, selector || this.options.draggable, this.el);		},

		/**		 * Set/get option		 *     		 *          		 *  		 */		option: function (name, value) {			var options = this.options;
			if (value === void 0) {				return options[name];			} else {				options[name] = value;
				if (name === group) {					_prepareGroup(options);				}			}		},

		/**		 * Destroy		 */		destroy: function () {			var el = this.el;
			el[expando] = null;
			_off(el, mousedown, this._onTapStart);			_off(el, touchstart, this._onTapStart);			_off(el, pointerdown, this._onTapStart);
			if (this.nativeDraggable) {				_off(el, dragover, this);				_off(el, dragenter, this);			}
			 Remove draggable attributes			Array.prototype.forEach.call(el.querySelectorAll([draggable]), function (el) {				el.removeAttribute(draggable);			});
			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);
			this._onDrop();
			this.el = el = null;		}	};

	function _cloneHide(sortable, state) {		if (sortable.lastPullMode !== clone) {			state = true;		}
		if (cloneEl && (cloneEl.state !== state)) {			_css(cloneEl, display, state ? none : );
			if (!state) {				if (cloneEl.state) {					if (sortable.options.group.revertClone) {						rootEl.insertBefore(cloneEl, nextEl);						sortable._animate(dragEl, cloneEl);					} else {						rootEl.insertBefore(cloneEl, dragEl);					}				}			}
			cloneEl.state = state;		}	}

	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {		if (el) {			ctx = ctx || document;
			do {				if ((selector === >* && el.parentNode === ctx) || _matches(el, selector)) {					return el;				}				/* jshint boss:true */			} while (el = _getParentOrHost(el));		}
		return null;	}

	function _getParentOrHost(el) {		var parent = el.host;
		return (parent && parent.nodeType) ? parent : el.parentNode;	}

	function _globalDragOver(/**Event*/evt) {		if (evt.dataTransfer) {			evt.dataTransfer.dropEffect = move;		}		evt.preventDefault();	}

	function _on(el, event, fn) {		el.addEventListener(event, fn, captureMode);	}

	function _off(el, event, fn) {		el.removeEventListener(event, fn, captureMode);	}

	function _toggleClass(el, name, state) {		if (el) {			if (el.classList) {				el.classList[state ? add : remove](name);			}			else {				var className = (  + el.className +  ).replace(R_SPACE,  ).replace(  + name +  ,  );				el.className = (className + (state ?   + name : )).replace(R_SPACE,  );			}		}	}

	function _css(el, prop, val) {		var style = el && el.style;
		if (style) {			if (val === void 0) {				if (document.defaultView && document.defaultView.getComputedStyle) {					val = document.defaultView.getComputedStyle(el, );				}				else if (el.currentStyle) {					val = el.currentStyle;				}
				return prop === void 0 ? val : val[prop];			}			else {				if (!(prop in style)) {					prop = -webkit- + prop;				}
				style[prop] = val + (typeof val === string ?  : px);			}		}	}

	function _find(ctx, tagName, iterator) {		if (ctx) {			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
			if (iterator) {				for (; i < n; i++) {					iterator(list[i], i);				}			}
			return list;		}
		return [];	}


	function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {		sortable = (sortable || rootEl[expando]);
		var evt = document.createEvent(Event),			options = sortable.options,			onName = on + name.charAt(0).toUpperCase() + name.substr(1);
		evt.initEvent(name, true, true);
		evt.to = rootEl;		evt.from = fromEl || rootEl;		evt.item = targetEl || rootEl;		evt.clone = cloneEl;
		evt.oldIndex = startIndex;		evt.newIndex = newIndex;
		rootEl.dispatchEvent(evt);
		if (options[onName]) {			options[onName].call(sortable, evt);		}	}

	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt) {		var evt,			sortable = fromEl[expando],			onMoveFn = sortable.options.onMove,			retVal;
		evt = document.createEvent(Event);		evt.initEvent(move, true, true);
		evt.to = toEl;		evt.from = fromEl;		evt.dragged = dragEl;		evt.draggedRect = dragRect;		evt.related = targetEl || toEl;		evt.relatedRect = targetRect || toEl.getBoundingClientRect();
		fromEl.dispatchEvent(evt);
		if (onMoveFn) {			retVal = onMoveFn.call(sortable, evt, originalEvt);		}
		return retVal;	}

	function _disableDraggable(el) {		el.draggable = false;	}

	function _unsilent() {		_silent = false;	}

	  */	function _ghostIsLast(el, evt) {		var lastEl = el.lastElementChild,			rect = lastEl.getBoundingClientRect();
		 5 — min delta		 abs — нельзя добавлять, а то глюки при наведении сверху		return (			(evt.clientY - (rect.top + rect.height) > 5) ||			(evt.clientX - (rect.right + rect.width) > 5)		) && lastEl;	}

	/**	 * Generate id	 *     	 *  	 * 	 */	function _generateId(el) {		var str = el.tagName + el.className + el.src + el.href + el.textContent,			i = str.length,			sum = 0;
		while (i--) {			sum += str.charCodeAt(i);		}
		return sum.toString(36);	}
	/**	 * Returns the index of an element within its parent for a selected set of	 * elements	 *    	 *    	 *  	 */	function _index(el, selector) {		var index = 0;
		if (!el || !el.parentNode) {			return -1;		}
		while (el && (el = el.previousElementSibling)) {			if ((el.nodeName.toUpperCase() !== TEMPLATE) && (selector === >* || _matches(el, selector))) {				index++;			}		}
		return index;	}
	function _matches(/**HTMLElement*/el, /**String*/selector) {		if (el) {			selector = selector.split(.);
			var tag = selector.shift().toUpperCase(),				re = new RegExp(s( + selector.join(|) + )(?=s), g);
			return (				(tag ===  || el.nodeName.toUpperCase() == tag) &&				(!selector.length || ((  + el.className +  ).match(re) || []).length == selector.length)			);		}
		return false;	}
	function _throttle(callback, ms) {		var args, _this;
		return function () {			if (args === void 0) {				args = arguments;				_this = this;
				setTimeout(function () {					if (args.length === 1) {						callback.call(_this, args[0]);					} else {						callback.apply(_this, args);					}
					args = void 0;				}, ms);			}		};	}
	function _extend(dst, src) {		if (dst && src) {			for (var key in src) {				if (src.hasOwnProperty(key)) {					dst[key] = src[key];				}			}		}
		return dst;	}
	function _clone(el) {		return $			? $(el).clone(true)[0]			: (Polymer && Polymer.dom				? Polymer.dom(el).cloneNode(true)				: el.cloneNode(true)			);	}
	function _saveInputCheckedState(root) {		var inputs = root.getElementsByTagName(input);		var idx = inputs.length;
		while (idx--) {			var el = inputs[idx];			el.checked && savedInputChecked.push(el);		}	}
	 Fixed #973: 	_on(document, touchmove, function (evt) {		if (Sortable.active) {			evt.preventDefault();		}	});
	try {		window.addEventListener(test, null, Object.defineProperty({}, passive, {			get: function () {				captureMode = {					capture: false,					passive: false				};			}		}));	} catch (err) {}
	 Export utils	Sortable.utils = {		on: _on,		off: _off,		css: _css,		find: _find,		is: function (el, selector) {			return !!_closest(el, selector, el);		},		extend: _extend,		throttle: _throttle,		closest: _closest,		toggleClass: _toggleClass,		clone: _clone,		index: _index	};

	/**	 * Create sortable instance	 *    	 *        	 */	Sortable.create = function (el, options) {		return new Sortable(el, options);	};

	 Export	Sortable.version = 1.5.1;	return Sortable;});"
"module.exports = function (grunt) {	use strict;
	grunt.initConfig({		pkg: grunt.file.readJSON(package.json),
		version: {			js: {				src: [<%= pkg.exportName %>.js, *.json]			},			cdn: {				options: {					prefix: (cdnjs.cloudflare.com/ajax/libs/Sortable|cdn.jsdelivr.net/sortable)/,					replace: [0-9.]+				},				src: [README.md]			}		},
		jshint: {			all: [*.js, !*.min.js],
			options: {				jshintrc: true			}		},
		uglify: {			options: {				banner: /*! <%= pkg.exportName %> <%= pkg.version %> - <%= pkg.license %> | <%= pkg.repository.url %> */			},			dist: {				files: {					<%= pkg.exportName %>.min.js: [<%= pkg.exportName %>.js]				}			},			jquery: {				files: {}			}		},
		jquery: {}	});

	grunt.registerTask(jquery, function (exportName, uglify) {		if (exportName == min) {			exportName = null;			uglify = min;		}
		if (!exportName) {			exportName = sortable;		}
		var fs = require(fs),			filename = jquery.fn. + exportName + .js;
		grunt.log.oklns(filename);
		fs.writeFileSync(			filename,			(fs.readFileSync(jquery.binding.js) + )				.replace($.fn.sortable, $.fn. + exportName)				.replace(/* CODE */,					(fs.readFileSync(Sortable.js) + )						.replace(function(var)Export, $1)				)		);
		if (uglify) {			var opts = {};
			opts[jquery.fn. + exportName + .min.js] = filename;			grunt.config.set(uglify.jquery.files, opts);
			grunt.task.run(uglify:jquery);		}	});

	grunt.loadNpmTasks(grunt-version);	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-uglify);
	grunt.registerTask(tests, [jshint]);	grunt.registerTask(default, [tests, version, uglify:dist]);};"
"var webpack = require(webpack)var webpackDevMiddleware = require(webpack-dev-middleware)var webpackHotMiddleware = require(webpack-hot-middleware)var config = require(./webpack.config.dev)
var app = new (require(express))()var port = 3001
var compiler = webpack(config)app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }))app.use(webpackHotMiddleware(compiler))
app.get(/, function(req, res) {  res.sendFile(__dirname + /index.html)})
app.listen(port, function(error) {  if (error) {    console.error(error)  } else {    console.info(==> 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser., port, port)  }})"
"import babel-polyfill;import React, {Component} from react;import {render} from react-dom;import {SortableContainer, SortableElement, arrayMove} from ./src/index;import range from lodash/range;import random from lodash/random;
const SortableItem = SortableElement(({height, value}) => (    <div style={{        position: relative,        width: 100%,        display: block,        padding: 20,        backgroundColor: #FFF,        borderBottom: 1px solid #EFEFEF,        boxSizing: border-box,        WebkitUserSelect: none,        height: height    }}>        Item {value}    </div>));
const SortableList = SortableContainer(({items}) => (    <div style={{        width: 80%,        height: 80vh,        maxWidth: 500px,        margin: 0 auto,        overflow: auto,        backgroundColor: #f3f3f3,        border: 1px solid #EFEFEF,        borderRadius: 3    }}>        {items.map(({height, value}, index) => <SortableItem key={item-} index={index} value={value} height={height}/>)}    </div>));
class Example extends Component {    state = {        items: range(100).map((value) => {            return {                value,                height: random(49, 120)            };        })    };    onSortEnd = ({oldIndex, newIndex}) => {        let {items} = this.state;
        this.setState({            items: arrayMove(items, oldIndex, newIndex)        });    };    render() {        const {items} = this.state;
        return <SortableList items={items} onSortEnd={this.onSortEnd} />;    }}
render(<Example />,  document.getElementById(root))"
"var sass = require(node-sass);
module.exports = function processSass(data, filename) {    var result;    result = sass.renderSync({        data: data,        file: filename    }).css;    return result.toString(utf8);};"
"/** * angular-drag-and-drop-lists v2.1.0 * * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc * Copyright (c) 2014-2017 Google Inc. * https://github.com/marceljuenemann/angular-drag-and-drop-lists * * License: MIT */(function(dndLists) {
   In standard-compliant browsers we use a custom mime type and also encode the dnd-type in it.   However, IE and Edge only support a limited number of mime types. The workarounds are described   in https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design  var MIME_TYPE = application/x-dnd;  var EDGE_MIME_TYPE = application/json;  var MSIE_MIME_TYPE = Text;
   All valid HTML5 drop effects, in the order in which we prefer to use them.  var ALL_EFFECTS = [move, copy, link];
  /**   * Use the dnd-draggable attribute to make your element draggable   *   * Attributes:   * - dnd-draggable      Required attribute. The value has to be an object that represents the data   *                      of the element. In case of a drag and drop operation the object will be   *                      serialized and unserialized on the receiving end.   * - dnd-effect-allowed Use this attribute to limit the operations that can be performed. Valid   *                      options are ""move"", ""copy"" and ""link"", as well as ""all"", ""copyMove"",   *                      ""copyLink"" and ""linkMove"". The semantics of these operations are up to you   *                      and have to be implemented using the callbacks described below. If you   *                      allow multiple options, the user can choose between them by using the   *                      modifier keys (OS specific). The cursor will be changed accordingly,   *                      expect for IE and Edge, where this is not supported.   * - dnd-type           Use this attribute if you have different kinds of items in your   *                      application and you want to limit which items can be dropped into which   *                      lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute   *                      must be a lower case string. Upper case characters can be used, but will   *                      be converted to lower case automatically.   * - dnd-disable-if     You can use this attribute to dynamically disable the draggability of the   *                      element. This is useful if you have certain list items that you don't want   *                      to be draggable, or if you want to disable drag & drop completely without   *                      having two different code branches (e.g. only allow for admins).   *   * Callbacks:   * - dnd-dragstart      Callback that is invoked when the element was dragged. The original   *                      dragstart event will be provided in the local event variable.   * - dnd-moved          Callback that is invoked when the element was moved. Usually you will   *                      remove your element from the original list in this callback, since the   *                      directive is not doing that for you automatically. The original dragend   *                      event will be provided in the local event variable.   * - dnd-copied         Same as dnd-moved, just that it is called when the element was copied   *                      instead of moved, so you probably want to implement a different logic.   * - dnd-linked         Same as dnd-moved, just that it is called when the element was linked   *                      instead of moved, so you probably want to implement a different logic.   * - dnd-canceled       Callback that is invoked if the element was dragged, but the operation was   *                      canceled and the element was not dropped. The original dragend event will   *                      be provided in the local event variable.   * - dnd-dragend        Callback that is invoked when the drag operation ended. Available local   *                      variables are event and dropEffect.   * - dnd-selected       Callback that is invoked when the element was clicked but not dragged.   *                      The original click event will be provided in the local event variable.   * - dnd-callback       Custom callback that is passed to dropzone callbacks and can be used to   *                      communicate between source and target scopes. The dropzone can pass user   *                      defined variables to this callback.   *   * CSS classes:   * - dndDragging        This class will be added to the element while the element is being   *                      dragged. It will affect both the element you see while dragging and the   *                      source element that stays at it's position. Do not try to hide the source   *                      element with this class, because that will abort the drag operation.   * - dndDraggingSource  This class will be added to the element after the drag operation was   *                      started, meaning it only affects the original element that is still at   *                      it's source position, and not the ""element"" that the user is dragging with   *                      his mouse pointer.   */  dndLists.directive(dndDraggable, [$parse, $timeout, function($parse, $timeout) {    return function(scope, element, attr) {       Set the HTML5 draggable attribute on the element.      element.attr(draggable, true);
       If the dnd-disable-if attribute is set, we have to watch that.      if (attr.dndDisableIf) {        scope.$watch(attr.dndDisableIf, function(disabled) {          element.attr(draggable, !disabled);        });      }
      /**       * When the drag operation is started we have to prepare the dataTransfer object,       * which is the primary way we communicate with the target element       */      element.on(dragstart, function(event) {        event = event.originalEvent || event;
         Check whether the element is draggable, since dragstart might be triggered on a child.        if (element.attr(draggable) == false) return true;
         Initialize global state.        dndState.isDragging = true;        dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase();
         Set the allowed drop effects. See below for special IE handling.        dndState.dropEffect = none;        dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0];        event.dataTransfer.effectAllowed = dndState.effectAllowed;
         Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:         https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design        var item = scope.$eval(attr.dndDraggable);        var mimeType = MIME_TYPE + (dndState.itemType ? (- + dndState.itemType) : );        try {          event.dataTransfer.setData(mimeType, angular.toJson(item));        } catch (e) {           Setting a custom MIME type did not work, we are probably in IE or Edge.          var data = angular.toJson({item: item, type: dndState.itemType});          try {            event.dataTransfer.setData(EDGE_MIME_TYPE, data);          } catch (e) {             We are in Internet Explorer and can only use the Text MIME type. Also note that IE             does not allow changing the cursor in the dragover event, therefore we have to choose             the one we want to display now by setting effectAllowed.            var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);            event.dataTransfer.effectAllowed = effectsAllowed[0];            event.dataTransfer.setData(MSIE_MIME_TYPE, data);          }        }
         Add CSS classes. See documentation above.        element.addClass(dndDragging);        $timeout(function() { element.addClass(dndDraggingSource); }, 0);
         Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).        if (event._dndHandle && event.dataTransfer.setDragImage) {          event.dataTransfer.setDragImage(element[0], 0, 0);        }
         Invoke dragstart callback and prepare extra callback for dropzone.        $parse(attr.dndDragstart)(scope, {event: event});        if (attr.dndCallback) {          var callback = $parse(attr.dndCallback);          dndState.callback = function(params) { return callback(scope, params || {}); };        }
        event.stopPropagation();      });
      /**       * The dragend event is triggered when the element was dropped or when the drag       * operation was aborted (e.g. hit escape button). Depending on the executed action       * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.       */      element.on(dragend, function(event) {        event = event.originalEvent || event;
         Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine         the used effect, but Chrome has not implemented that field correctly. On Windows         it always sets it to 'none', while Chrome on Linux sometimes sets it to something         else when it's supposed to send 'none' (drag operation aborted).        scope.$apply(function() {          var dropEffect = dndState.dropEffect;          var cb = {copy: dndCopied, link: dndLinked, move: dndMoved, none: dndCanceled};          $parse(attr[cb[dropEffect]])(scope, {event: event});          $parse(attr.dndDragend)(scope, {event: event, dropEffect: dropEffect});        });
         Clean up        dndState.isDragging = false;        dndState.callback = undefined;        element.removeClass(dndDragging);        element.removeClass(dndDraggingSource);        event.stopPropagation();
         In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.        $timeout(function() { element.removeClass(dndDraggingSource); }, 0);      });
      /**       * When the element is clicked we invoke the callback function       * specified with the dnd-selected attribute.       */      element.on(click, function(event) {        if (!attr.dndSelected) return;
        event = event.originalEvent || event;        scope.$apply(function() {          $parse(attr.dndSelected)(scope, {event: event});        });
         Prevent triggering dndSelected in parent elements.        event.stopPropagation();      });
      /**       * Workaround to make element draggable in IE9       */      element.on(selectstart, function() {        if (this.dragDrop) this.dragDrop();      });    };  }]);
  /**   * Use the dnd-list attribute to make your list element a dropzone. Usually you will add a single   * li element as child with the ng-repeat directive. If you don't do that, we will not be able to   * position the dropped element correctly. If you want your list to be sortable, also add the   * dnd-draggable directive to your li element(s).   *   * Attributes:   * - dnd-list             Required attribute. The value has to be the array in which the data of   *                        the dropped element should be inserted. The value can be blank if used   *                        with a custom dnd-drop handler that always returns true.   * - dnd-allowed-types    Optional array of allowed item types. When used, only items that had a   *                        matching dnd-type attribute will be dropable. Upper case characters will   *                        automatically be converted to lower case.   * - dnd-effect-allowed   Optional string expression that limits the drop effects that can be   *                        performed in the list. See dnd-effect-allowed on dnd-draggable for more   *                        details on allowed options. The default value is all.   * - dnd-disable-if       Optional boolean expresssion. When it evaluates to true, no dropping   *                        into the list is possible. Note that this also disables rearranging   *                        items inside the list.   * - dnd-horizontal-list  Optional boolean expresssion. When it evaluates to true, the positioning   *                        algorithm will use the left and right halfs of the list items instead of   *                        the upper and lower halfs.   * - dnd-external-sources Optional boolean expression. When it evaluates to true, the list accepts   *                        drops from sources outside of the current browser tab. This allows to   *                        drag and drop accross different browser tabs. The only major browser   *                        that does not support this is currently Microsoft Edge.   *   * Callbacks:   * - dnd-dragover         Optional expression that is invoked when an element is dragged over the   *                        list. If the expression is set, but does not return true, the element is   *                        not allowed to be dropped. The following variables will be available:   *                        - event: The original dragover event sent by the browser.   *                        - index: The position in the list at which the element would be dropped.   *                        - type: The dnd-type set on the dnd-draggable, or undefined if non was   *                          set. Will be null for drops from external sources in IE and Edge,   *                          since we don't know the type in those cases.   *                        - dropEffect: One of move, copy or link, see dnd-effect-allowed.   *                        - external: Whether the element was dragged from an external source.   *                        - callback: If dnd-callback was set on the source element, this is a   *                          function reference to the callback. The callback can be invoked with   *                          custom variables like this: callback({var1: value1, var2: value2}).   *                          The callback will be executed on the scope of the source element. If   *                          dnd-external-sources was set and external is true, this callback will   *                          not be available.   * - dnd-drop             Optional expression that is invoked when an element is dropped on the   *                        list. The same variables as for dnd-dragover will be available, with the   *                        exception that type is always known and therefore never null. There   *                        will also be an item variable, which is the transferred object. The   *                        return value determines the further handling of the drop:   *                        - falsy: The drop will be canceled and the element won't be inserted.   *                        - true: Signalises that the drop is allowed, but the dnd-drop   *                          callback already took care of inserting the element.   *                        - otherwise: All other return values will be treated as the object to   *                          insert into the array. In most cases you want to simply return the   *                          item parameter, but there are no restrictions on what you can return.   * - dnd-inserted         Optional expression that is invoked after a drop if the element was   *                        actually inserted into the list. The same local variables as for   *                        dnd-drop will be available. Note that for reorderings inside the same   *                        list the old element will still be in the list due to the fact that   *                        dnd-moved was not called yet.   *   * CSS classes:   * - dndPlaceholder       When an element is dragged over the list, a new placeholder child   *                        element will be added. This element is of type li and has the class   *                        dndPlaceholder set. Alternatively, you can define your own placeholder   *                        by creating a child element with dndPlaceholder class.   * - dndDragover          Will be added to the list while an element is dragged over the list.   */  dndLists.directive(dndList, [$parse, function($parse) {    return function(scope, element, attr) {       While an element is dragged over the list, this placeholder element is inserted       at the location where the element would be inserted after dropping.      var placeholder = getPlaceholderElement();      placeholder.remove();
      var placeholderNode = placeholder[0];      var listNode = element[0];      var listSettings = {};
      /**       * The dragenter event is fired when a dragged element or text selection enters a valid drop       * target. According to the spec, we either need to have a dropzone attribute or listen on       * dragenter events and call preventDefault(). It should be noted though that no browser seems       * to enforce this behaviour.       */      element.on(dragenter, function (event) {        event = event.originalEvent || event;
         Calculate list properties, so that we don't have to repeat this on every dragover event.        var types = attr.dndAllowedTypes && scope.$eval(attr.dndAllowedTypes);        listSettings = {          allowedTypes: angular.isArray(types) && types.join(|).toLowerCase().split(|),          disabled: attr.dndDisableIf && scope.$eval(attr.dndDisableIf),          externalSources: attr.dndExternalSources && scope.$eval(attr.dndExternalSources),          horizontal: attr.dndHorizontalList && scope.$eval(attr.dndHorizontalList)        };
        var mimeType = getMimeType(event.dataTransfer.types);        if (!mimeType || !isDropAllowed(getItemType(mimeType))) return true;        event.preventDefault();      });
      /**       * The dragover event is triggered ""every few hundred milliseconds"" while an element       * is being dragged over our list, or over an child element.       */      element.on(dragover, function(event) {        event = event.originalEvent || event;
         Check whether the drop is allowed and determine mime type.        var mimeType = getMimeType(event.dataTransfer.types);        var itemType = getItemType(mimeType);        if (!mimeType || !isDropAllowed(itemType)) return true;
         Make sure the placeholder is shown, which is especially important if the list is empty.        if (placeholderNode.parentNode != listNode) {          element.append(placeholder);        }
        if (event.target != listNode) {           Try to find the node direct directly below the list node.          var listItemNode = event.target;          while (listItemNode.parentNode != listNode && listItemNode.parentNode) {            listItemNode = listItemNode.parentNode;          }
          if (listItemNode.parentNode == listNode && listItemNode != placeholderNode) {             If the mouse pointer is in the upper half of the list item element,             we position the placeholder before the list item, otherwise after it.            var rect = listItemNode.getBoundingClientRect();            if (listSettings.horizontal) {              var isFirstHalf = event.clientX < rect.left + rect.width / 2;            } else {              var isFirstHalf = event.clientY < rect.top + rect.height / 2;            }            listNode.insertBefore(placeholderNode,                isFirstHalf ? listItemNode : listItemNode.nextSibling);          }        }
         In IE we set a fake effectAllowed in dragstart to get the correct cursor, we therefore         ignore the effectAllowed passed in dataTransfer. We must also not access dataTransfer for         drops from external sources, as that throws an exception.        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;        var dropEffect = getDropEffect(event, ignoreDataTransfer);        if (dropEffect == none) return stopDragover();
         At this point we invoke the callback, which still can disallow the drop.         We can't do this earlier because we want to pass the index of the placeholder.        if (attr.dndDragover && !invokeCallback(attr.dndDragover, event, dropEffect, itemType)) {          return stopDragover();        }
         Set dropEffect to modify the cursor shown by the browser, unless we're in IE, where this         is not supported. This must be done after preventDefault in Firefox.        event.preventDefault();        if (!ignoreDataTransfer) {          event.dataTransfer.dropEffect = dropEffect;        }
        element.addClass(dndDragover);        event.stopPropagation();        return false;      });
      /**       * When the element is dropped, we use the position of the placeholder element as the       * position where we insert the transferred data. This assumes that the list has exactly       * one child element per array element.       */      element.on(drop, function(event) {        event = event.originalEvent || event;
         Check whether the drop is allowed and determine mime type.        var mimeType = getMimeType(event.dataTransfer.types);        var itemType = getItemType(mimeType);        if (!mimeType || !isDropAllowed(itemType)) return true;
         The default behavior in Firefox is to interpret the dropped element as URL and         forward to it. We want to prevent that even if our drop is aborted.        event.preventDefault();
         Unserialize the data that was serialized in dragstart.        try {          var data = JSON.parse(event.dataTransfer.getData(mimeType));        } catch(e) {          return stopDragover();        }
         Drops with invalid types from external sources might not have been filtered out yet.        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) {          itemType = data.type || undefined;          data = data.item;          if (!isDropAllowed(itemType)) return stopDragover();        }
         Special handling for internal IE drops, see dragover handler.        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;        var dropEffect = getDropEffect(event, ignoreDataTransfer);        if (dropEffect == none) return stopDragover();
         Invoke the callback, which can transform the transferredObject and even abort the drop.        var index = getPlaceholderIndex();        if (attr.dndDrop) {          data = invokeCallback(attr.dndDrop, event, dropEffect, itemType, index, data);          if (!data) return stopDragover();        }
         The drop is definitely going to happen now, store the dropEffect.        dndState.dropEffect = dropEffect;        if (!ignoreDataTransfer) {          event.dataTransfer.dropEffect = dropEffect;        }
         Insert the object into the array, unless dnd-drop took care of that (returned true).        if (data !== true) {          scope.$apply(function() {            scope.$eval(attr.dndList).splice(index, 0, data);          });        }        invokeCallback(attr.dndInserted, event, dropEffect, itemType, index, data);
         Clean up        stopDragover();        event.stopPropagation();        return false;      });
      /**       * We have to remove the placeholder when the element is no longer dragged over our list. The       * problem is that the dragleave event is not only fired when the element leaves our list,       * but also when it leaves a child element. Therefore, we determine whether the mouse cursor       * is still pointing to an element inside the list or not.       */      element.on(dragleave, function(event) {        event = event.originalEvent || event;
        var newTarget = document.elementFromPoint(event.clientX, event.clientY);        if (listNode.contains(newTarget) && !event._dndPhShown) {           Signalize to potential parent lists that a placeholder is already shown.          event._dndPhShown = true;        } else {          stopDragover();        }      });
      /**       * Given the types array from the DataTransfer object, returns the first valid mime type.       * A type is valid if it starts with MIME_TYPE, or it equals MSIE_MIME_TYPE or EDGE_MIME_TYPE.       */      function getMimeType(types) {        if (!types) return MSIE_MIME_TYPE;  IE 9 workaround.        for (var i = 0; i < types.length; i++) {          if (types[i] == MSIE_MIME_TYPE || types[i] == EDGE_MIME_TYPE ||              types[i].substr(0, MIME_TYPE.length) == MIME_TYPE) {            return types[i];          }        }        return null;      }
      /**       * Determines the type of the item from the dndState, or from the mime type for items from       * external sources. Returns undefined if no item type was set and null if the item type could       * not be determined.       */      function getItemType(mimeType) {        if (dndState.isDragging) return dndState.itemType || undefined;        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) return null;        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;      }
      /**       * Checks various conditions that must be fulfilled for a drop to be allowed, including the       * dnd-allowed-types attribute. If the item Type is unknown (null), the drop will be allowed.       */      function isDropAllowed(itemType) {        if (listSettings.disabled) return false;        if (!listSettings.externalSources && !dndState.isDragging) return false;        if (!listSettings.allowedTypes || itemType === null) return true;        return itemType && listSettings.allowedTypes.indexOf(itemType) != -1;      }
      /**       * Determines which drop effect to use for the given event. In Internet Explorer we have to       * ignore the effectAllowed field on dataTransfer, since we set a fake value in dragstart.       * In those cases we rely on dndState to filter effects. Read the design doc for more details:       * https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design       */      function getDropEffect(event, ignoreDataTransfer) {        var effects = ALL_EFFECTS;        if (!ignoreDataTransfer) {          effects = filterEffects(effects, event.dataTransfer.effectAllowed);        }        if (dndState.isDragging) {          effects = filterEffects(effects, dndState.effectAllowed);        }        if (attr.dndEffectAllowed) {          effects = filterEffects(effects, attr.dndEffectAllowed);        }         MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,         therefore the following modifier keys will only affect other operating systems.        if (!effects.length) {          return none;        } else if (event.ctrlKey && effects.indexOf(copy) != -1) {          return copy;        } else if (event.altKey && effects.indexOf(link) != -1) {          return link;        } else {          return effects[0];        }      }
      /**       * Small helper function that cleans up if we aborted a drop.       */      function stopDragover() {        placeholder.remove();        element.removeClass(dndDragover);        return true;      }
      /**       * Invokes a callback with some interesting parameters and returns the callbacks return value.       */      function invokeCallback(expression, event, dropEffect, itemType, index, item) {        return $parse(expression)(scope, {          callback: dndState.callback,          dropEffect: dropEffect,          event: event,          external: !dndState.isDragging,          index: index !== undefined ? index : getPlaceholderIndex(),          item: item || undefined,          type: itemType        });      }
      /**       * We use the position of the placeholder node to determine at which position of the array the       * object needs to be inserted       */      function getPlaceholderIndex() {        return Array.prototype.indexOf.call(listNode.children, placeholderNode);      }
      /**       * Tries to find a child element that has the dndPlaceholder class set. If none was found, a       * new li element is created.       */      function getPlaceholderElement() {        var placeholder;        angular.forEach(element.children(), function(childNode) {          var child = angular.element(childNode);          if (child.hasClass(dndPlaceholder)) {            placeholder = child;          }        });        return placeholder || angular.element(<li class='dndPlaceholder'></li>);      }    };  }]);
  /**   * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting   * drag operations. This is especially useful if you want to use input elements inside of   * dnd-draggable elements or create specific handle elements. Note: This directive does not work   * in Internet Explorer 9.   */  dndLists.directive(dndNodrag, function() {    return function(scope, element, attr) {       Set as draggable so that we can cancel the events explicitly      element.attr(draggable, true);
      /**       * Since the element is draggable, the browser's default operation is to drag it on dragstart.       * We will prevent that and also stop the event from bubbling up.       */      element.on(dragstart, function(event) {        event = event.originalEvent || event;
        if (!event._dndHandle) {           If a child element already reacted to dragstart and set a dataTransfer object, we will           allow that. For example, this is the case for user selections inside of input elements.          if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {            event.preventDefault();          }          event.stopPropagation();        }      });
      /**       * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element       * would be removed.       */      element.on(dragend, function(event) {        event = event.originalEvent || event;        if (!event._dndHandle) {          event.stopPropagation();        }      });    };  });
  /**   * Use the dnd-handle directive within a dnd-nodrag element in order to allow dragging with that   * element after all. Therefore, by combining dnd-nodrag and dnd-handle you can allow   * dnd-draggable elements to only be dragged via specific ""handle"" elements. Note that Internet   * Explorer will show the handle element as drag image instead of the dnd-draggable element. You   * can work around this by styling the handle element differently when it is being dragged. Use   * the CSS selector .dndDragging:not(.dndDraggingSource) [dnd-handle] for that.   */  dndLists.directive(dndHandle, function() {    return function(scope, element, attr) {      element.attr(draggable, true);
      element.on(dragstart dragend, function(event) {        event = event.originalEvent || event;        event._dndHandle = true;      });    };  });
  /**   * Filters an array of drop effects using a HTML5 effectAllowed string.   */  function filterEffects(effects, effectAllowed) {    if (effectAllowed == all) return effects;    return effects.filter(function(effect) {      return effectAllowed.toLowerCase().indexOf(effect) != -1;    });  }
  /**   * For some features we need to maintain global state. This is done here, with these fields:   * - callback: A callback function set at dragstart that is passed to internal dropzone handlers.   * - dropEffect: Set in dragstart to ""none"" and to the actual value in the drop handler. We don't   *   rely on the dropEffect passed by the browser, since there are various bugs in Chrome and   *   Safari, and Internet Explorer defaults to copy if effectAllowed is copyMove.   * - effectAllowed: Set in dragstart based on dnd-effect-allowed. This is needed for IE because   *   setting effectAllowed on dataTransfer might result in an undesired cursor.   * - isDragging: True between dragstart and dragend. Falsy for drops from external sources.   * - itemType: The item type of the dragged element set via dnd-type. This is needed because IE   *   and Edge don't support custom mime types that we can use to transfer this information.   */  var dndState = {};
})(angular.module(dndLists, []));"
"/* jshint node:true */
use strict;
module.exports = function(grunt) {
  require(load-grunt-tasks)(grunt);
   Default task.  grunt.registerTask(default, [test]);  grunt.registerTask(test, [jshint, karma:unit]);  grunt.registerTask(serve, [karma:continuous, dist, build:gh-pages, connect:continuous, watch]);  grunt.registerTask(dist, [ngmin, surround:main, uglify, surround:banner ]);  grunt.registerTask(coverage, [jshint, karma:coverage]);  grunt.registerTask(junit, [jshint, karma:junit]);

   HACK TO ACCESS TO THE COMPONENT PUBLISHER  function fakeTargetTask(prefix){    return function(){
      if (this.args.length !== 1) {        return grunt.log.fail(Just give the name of the  + prefix +  you want like :grunt  + prefix + :bower);      }
      var done = this.async();      var spawn = require(child_process).spawn;      spawn(./node_modules/.bin/gulp, [ prefix, --branch=+this.args[0] ].concat(grunt.option.flags()), {        cwd : ./node_modules/angular-ui-publisher,        stdio: inherit      }).on(close, done);    };  }
  grunt.registerTask(build, fakeTargetTask(build));  grunt.registerTask(publish, fakeTargetTask(publish));  

   HACK TO MAKE TRAVIS WORK  var testConfig = function(configFile, customOptions) {    var options = { configFile: configFile, singleRun: true };    var travisOptions = process.env.TRAVIS && {      browsers: [Chrome, Firefox],      reporters: [dots, coverage, coveralls],      preprocessors: { src/*.js: [coverage] },      coverageReporter: {        reporters: [{          type: text        }, {          type: lcov,          dir: coverage/        }]      },    };    return grunt.util._.extend(options, customOptions, travisOptions);  };  

   Project configuration.  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),    meta: {      banner: [/**,         * <%= pkg.name %> - <%= pkg.description %>,         * @version v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %>,         * @link <%= pkg.homepage %>,         * @license <%= pkg.license %>,         */,        ].join()    },
    connect: {      options: {        base : out/built/gh-pages,        open: true,        livereload: true      },      server: { options: { keepalive: true } },      continuous: { options: { keepalive: false } }    },
    coveralls: {      options: {        coverage_dir: coverage/,         debug: true         dryRun: true,         force: true,         recursive: true      }    },
    karma: {      unit: testConfig(test/karma.conf.js),      server: {configFile: test/karma.conf.js},      continuous: {configFile: test/karma.conf.js,  background: true },      coverage: {        configFile: test/karma.conf.js,        reporters: [progress, coverage],        preprocessors: { src/*.js: [coverage] },        coverageReporter: {          reporters: [{            type: text          }, {            type: lcov,            dir: coverage/          }]        },        singleRun: true      },      junit: {        configFile: test/karma.conf.js,        reporters: [progress, junit],        junitReporter: {          outputFile: junit/unit.xml,          suite: unit        },        singleRun: true      }    },
    jshint: {      src: {        files:{ src : [src/**/*.js, demo/**/*.js] },        options: { jshintrc: .jshintrc }      },      test: {        files:{ src : [ test/*.js, gruntFile.js] },        options: grunt.util._.extend({}, grunt.file.readJSON(.jshintrc), grunt.file.readJSON(test/.jshintrc))      }    },
    uglify: {      build: {        expand: true,        cwd: dist,        src: [*.js, !*.min.js],        ext: .min.js,        dest: dist      }    },
    surround: {      main: {        expand: true,        cwd: src,        src: [*.js],        dest: dist,        options: {          prepend: [(function(window, angular, undefined) {,                    use strict;].join(),          append: })(window, window.angular);        }      },      banner: {        expand: true,        cwd: dist,        src: [*.js],        dest: dist,        options: {          prepend: <%= meta.banner %>        }      }    },
    ngmin: {      main: {        expand: true,        cwd: src,        src: [*.js],        dest: dist      }    },
    changelog: {      options: {        dest: CHANGELOG.md      }    },
    watch: {      src: {        files: [src/*],        tasks: [jshint:src, karma:unit:run, dist, build:gh-pages]      },      test: {        files: [test/*.js],        tasks: [jshint:test, karma:unit:run]      },      demo: {        files: [demo/*, publish.js],        tasks: [jshint, build:gh-pages]      },      livereload: {        files: [out/built/gh-pages/**/*],        options: { livereload: true }      }    }  });
};"
require(./dist/ng-sortable);module.exports = as.sortable;
"/*jshint undef: false, unused: false, indent: 2*/
module.exports = function (grunt) {  use strict;   load all grunt tasks automatically  require(load-grunt-tasks)(grunt);
  var mountFolder = function (connect, dir) {    return connect.static(require(path).resolve(dir));  };
  var cfg = {    srcDir: source,    buildDir: dist,    demoDir: demo  };
   project configuration  grunt.initConfig({    cfg: cfg,
     watch    watch: {      livereload: {        files: [          <%= cfg.demoDir %>/**/*.js,          <%= cfg.demoDir %>/**/*.css,          <%= cfg.demoDir %>/**/*.html,          !<%= cfg.buildDir %>/*.js,          !<%= cfg.demoDir %>/dist/*.js,          !<%= cfg.demoDir %>/bower_components/**/*        ],        options: {          livereload: true        }      },      build: {        files: [          <%= cfg.srcDir %>/**/*.*,          !<%= cfg.buildDir %>/*.*        ],        tasks: [jshint:source, clean:build, concat:build, uglify:build, cssmin, copy]      },      cssmin: {        files: [          <%= cfg.srcDir %>/**/*.css        ],        tasks: [cssmin, copy]      }    },
     clean up files as part of other tasks    clean: {      build: {        src: [<%= cfg.buildDir %>/**]      },      demo: {        src: [<%= cfg.demoDir %>/dist/**]      }    },
     prepare files for demo    copy: {      build: {        expand: true,        cwd: <%= cfg.srcDir %>/,        src: [*.css],        dest: <%= cfg.buildDir %>/      },      demo: {        files: [          {            expand: true,            src: [<%= cfg.buildDir %>/*.*],            dest: <%= cfg.demoDir %>/          }        ]      }    },
    jshint: {      options: {        jshintrc: true,        reporter: require(jshint-stylish)      },      source: {        files: {          src: [<%= cfg.srcDir %>/**/*.js]        }      },      demo: {        files: {          src: [            <%= cfg.demoDir %>/**/*.js,            !<%= cfg.demoDir %>/bower_components/**/*          ]        }      }    },
     concat    concat: {      build: {        src: [          <%= cfg.srcDir %>/sortable-main.js,          <%= cfg.srcDir %>/sortable-helper.js,          <%= cfg.srcDir %>/sortable.js,          <%= cfg.srcDir %>/sortable-item-handle.js,          <%= cfg.srcDir %>/sortable-item.js        ],        dest: <%= cfg.buildDir %>/ng-sortable.js      }    },
     uglify    uglify: {      options: {        preserveComments: some,        mangle: false      },      build: {        files: {          <%= cfg.buildDir %>/ng-sortable.min.js: [<%= cfg.buildDir %>/ng-sortable.js]        }      }    },
    cssmin: {      add_banner: {        options: {          banner: /* ng-sortable css file */        },        files: {          <%= cfg.buildDir %>/ng-sortable.min.css: [<%= cfg.srcDir %>/ng-sortable.css],          <%= cfg.buildDir %>/ng-sortable.style.min.css: [<%= cfg.srcDir %>/ng-sortable.style.css]        }      }    },
     connect    connect: {      options: {        port: 9009,        livereload: 93729,        hostname: 0.0.0.0      },      demo: {        options: {          middleware: function (connect) {            return [              mountFolder(connect, )            ];          }        }      }    },
     open    open: {      server: {        path: http://localhost:<%= connect.options.port %>/<%= cfg.demoDir %>/      }    },
     karma    karma: {      options: {        configFile: karma.conf.js,        autoWatch: true      },
      single: {        singleRun: true,        browsers: [Chrome]      },
      continuous: {        singleRun: false,        browsers: [Chrome]      }    },
     available tasks    tasks_list: {      options: {},      project: {        options: {          tasks: [            {              name: build,              info: Create a build of (tested) the source files            },            {              name: serve,              info: Build the project, watch file changes and start a web server            },            {              name: test,              info: Runt tests            },            {              name: test:continuous,              info: Runt tests continuously            }          ]        }      }    }  });
   default  grunt.registerTask(default, [tasks_list:project]);  grunt.registerTask(build, [jshint:source, clean:build, concat:build, cssmin, uglify:build, copy]);  grunt.registerTask(serve, [open, connect:demo, watch]);  grunt.registerTask(test, [karma:single]);  grunt.registerTask(test:continuous, [karma:continuous]);};

"
code
"/** * This file/module contains all configuration for the build process. */module.exports = {  /**   * The `build_dir` folder is where our projects are compiled during   * development and the `compile_dir` folder is where our app resides once it's   * completely built.   */  build_dir: build,  compile_dir: bin,  vendor_dir: vendor,
  /**   * This is a collection of file patterns that refer to our app code (the   * stuff in `src/`). These file paths are used in the configuration of   * build tasks. `js` is all project javascript, less tests. `ctpl` contains   * our reusable components' (`src/common`) template HTML files, while   * `atpl` contains the same, but for our app's code. `html` is just our   * main HTML file, `less` is our main stylesheet, and `unit` contains our   * app's unit tests.   */  app_files: {    js: [ src/**/*.module.js,src/**/*.js, !src/**/*.spec.js, !src/assets/**/*.js ],    jsunit: [ src/**/*.spec.js ],
    atpl: [ src/app/**/*.tpl.html ],    ctpl: [ src/common/**/*.tpl.html ],
    html: [ src/index.html ]  },
  build_files: {    css: [<%= build_dir %>/css/sass/*.css, <%= build_dir %>/css/**/*.css]  },
  /**   * This is a collection of files used during testing only.   */  test_files: {    js: [      vendor/angular-mocks/angular-mocks.js    ],    mocks: [      mocks/**/*.json    ]  },
  /**   * This is the same as `app_files`, except it contains patterns that   * reference vendor code (`vendor/`) that we need to place into the build   * process somewhere. While the `app_files` property ensures all   * standardized files are collected for compilation, it is the user's job   * to ensure non-standardized (i.e. vendor-related) files are handled   * appropriately in `vendor_files.js`.   *   * The `vendor_files.js` property holds files to be automatically   * concatenated and minified with our project source files.   *   * The `vendor_files.css` property holds any CSS files to be automatically   * included in our app.   *   * The `vendor_files.assets` property holds any assets to be copied along   * with our app's assets. This structure is flattened, so it is not   * recommended that you use wildcards.   */  vendor_files: {    js: [      vendor/jquery/dist/jquery.js,      vendor/angular/angular.js,      vendor/angular-route/angular-route.js,      vendor/lodash/dist/lodash.min.js,      vendor/reveal.js/js/reveal.js    ],    css: [      vendor/animate.css/animate.css,      vendor/reveal.js/css/reveal.min.css    ],    assets: [    ]  }};"
"(function(){	var hasFrame = window.parent!=window,		scripts = document.getElementsByTagName(script),		current = scripts[scripts.length-1],		config = current.getAttribute(data-config),		head = document.getElementsByTagName(head)[0],		dest = location.href.replace(scmplayertrueg, scmplayer=false),		destHost = dest.substr(0,dest.indexOf(/,10)),		scm = current.getAttribute(src).replace(scriptjsg,scm.html?03022013)+#+dest,		scmHost = scm.substr(0,scm.indexOf(/,10)),		isOutside = !hasFrame || location.href.indexOf(scmplayer=true)>0,		postMessage = function(msg){			return window.top.document.getElementById(scmframe)				.contentWindow.postMessage(msg,scmHost);		},		postFactory = function(obj,keys){			var keys = keys.split(,),				post = function(key){					return function(arg){						var argStr = ;						if(typeof(arg)!=undefined)							argStr = (key.match((playqueue)) ? new Song(:() +								JSON.stringify(arg)+);						postMessage(SCM.+key+(+argStr+));					}				};			for(var i=0;i<keys.length;i++){				var key = keys[i];				obj[key] = post(key);			}		},		postConfig = function(config){			if(!isOutside)			postMessage(SCM.config(+config+));		},
		addEvent = function(elm, evType, fn) {			if(elm.addEventListener) 				elm.addEventListener(evType, fn);			else if (elm.attachEvent) 				elm.attachEvent(on + evType, fn);			else				elm[on + evType] = fn;		},		isIE = (function(){			var undef,v = 3,div = document.createElement(div),			all = div.getElementsByTagName(i);			while (				div.innerHTML = <!--[if gt IE  + (++v) + ]><i></i><![endif]-->,				all[0] );			return v > 4 ? v : undef;		})(),		isMobile = navigator.userAgent.match(iPadiPhoneAndroidBlackberryi),
		init = function(){			if(!document.body){ 				setTimeout(init,10); 				return;			}			if(isOutside) outside(); else inside();		},
		outside = function(){			var css = html,body{overflow:hidden;} body{margin:0;padding:0;border:0;} img,a,embed,object,div,address,table,iframe,p,span,form,header,section,footer{ display:none;border:0;margin:0;padding:0; } #tumblr_controls{display:none;} #scmframe{display:block; background-color:transparent; position:fixed; top:0px; left:0px; width:100%; height:100%; z-index:1667;} ;			var style = document.createElement(style);			style.type = text/css;			style.id = scmcss;
			if(style.styleSheet) style.styleSheet.cssText = css;			else style.appendChild(document.createTextNode(css));
			head.appendChild(style);			/*			while(head.firstChild.id!=""scmcss"")				head.removeChild(head.firstChild);			*/						var scmframe = document.createElement(iframe);			scmframe.frameBorder = 0;			scmframe.id = scmframe;			scmframe.allowTransparency = true;			scmframe.src = scm;						document.body.insertBefore(scmframe,document.body.firstChild);
			addEvent(window,load,function() {				setTimeout(function(){					while(document.body.firstChild!=scmframe)						document.body.removeChild(document.body.firstChild);					while(document.body.lastChild!=scmframe)						document.body.removeChild(document.body.lastChild);				},0);			});
			fix frame height in IE			addEvent(window,resize,function(){				scmframe.style.height = (function(){					if( typeof( window.innerHeight ) == number )						return window.innerHeight; 					else if( document.documentElement && document.documentElement.clientHeight ) 						return document.documentElement.clientHeight; 					else if( document.body && document.body.clientHeight ) 						return document.body.clientHeight; 				})();			});			pushState and hash change detection			var getPath = function(){					return location.href.replace(#,);				},				path = getPath(),				hash = location.hash;			setInterval(function(){				if(getPath()!=path){					path = getPath();					window.scminside.location.replace(path);				}				if(location.hash != hash){					hash = location.hash;					window.scminside.location.hash = hash;				}			},100);		},		inside = function(){			change title			window.top.document.title = document.title;			fix links			var filter = function(host){					host = host.replace(blogspoti,blogspot.com);					host = host.replace((http(s):)(www)i,);					return host;				};			addEvent(document.body,click,function(e){				var tar = e.target;				var ext = (tar.target == _blank);				while(!tar.tagName.match((aarea)i) && tar!=document.body)					tar = tar.parentNode;				if(tar.tagName.match((aarea)i) && 					!tar.href.match((jpgpng)i) && ignore picture link					!tar.href.match(javascript:) ignore javascript link				){ 					if(tar.href.indexOf(#)==0){						hash						if(tar.href != #){							window.top.scminside = window;							window.top.location.hash = location.hash;							e.preventDefault();						}					}else if(tar.title.match((SCM:SCM)i)){						SCM Play link						var title = tar.title.replace((SCM:SCM)( )i,);						var url = tar.href;						SCM.play({title:title,url:url});						e.preventDefault();					}else if(tar.href.match(css)){						auto add skin						window.open(http://scmplayer.net/#skin=+tar.href,_blank);						window.focus();						e.preventDefault();					}else if(ext || filter(tar.href).indexOf(filter(location.host))==-1 ){						if(tar.href.match(http(s))){							external links							window.open(tar.href,_blank);							window.focus();							e.preventDefault();						}					}else if(history.pushState){						internal link & has pushState						change address bar href						var url = filter(tar.href).replace(filter(destHost),);						window.top.scminside = window;						window.top.history.pushState(null,null,url);						e.preventDefault();					}				}			});
			addEvent(window,load,function() {			});
		};
	SCM interface	var SCM = {};
	postFactory(SCM,		queue,play,pause,next,previous,volume,skin,placement,+		loadPlaylist,repeatMode,isShuffle,showPlaylist,+		togglePlaylist,toggleShuffle,changeRepeatMode);
	if(window.SCM && window.SCMMusicPlayer) return;
	if(!isMobile) init();
	send config	if(config) postConfig(config);	SCM.init = postConfig;
	window.SCMMusicPlayer = window.SCMMusicPlayer || SCM;	window.SCM = window.SCM || SCM;})();"
module.exports = require(./dist/preview)
"/** * Created by andrewhurst on 10/5/15. */import React, { Component, PropTypes } from react;import {  Keyboard,  LayoutAnimation,  View,  Dimensions,  Platform,  StyleSheet} from react-native;
const styles = StyleSheet.create({  container: {    left: 0,    right: 0,    bottom: 0,  },});
 From: https://medium.com/man-moon/writing-modern-react-native-ui-e317ff956f02const defaultAnimation = {  duration: 500,  create: {    duration: 300,    type: LayoutAnimation.Types.easeInEaseOut,    property: LayoutAnimation.Properties.opacity  },  update: {    type: LayoutAnimation.Types.spring,    springDamping: 200  }};
export default class KeyboardSpacer extends Component {  static propTypes = {    topSpacing: PropTypes.number,    onToggle: PropTypes.func,    style: View.propTypes.style,  };
  static defaultProps = {    topSpacing: 0,    onToggle: () => null,  };
  constructor(props, context) {    super(props, context);    this.state = {      keyboardSpace: 0,      isKeyboardOpened: false    };    this._listeners = null;    this.updateKeyboardSpace = this.updateKeyboardSpace.bind(this);    this.resetKeyboardSpace = this.resetKeyboardSpace.bind(this);  }
  componentDidMount() {    const updateListener = Platform.OS === android ? keyboardDidShow : keyboardWillShow;    const resetListener = Platform.OS === android ? keyboardDidHide : keyboardWillHide;    this._listeners = [      Keyboard.addListener(updateListener, this.updateKeyboardSpace),      Keyboard.addListener(resetListener, this.resetKeyboardSpace)    ];  }
  componentWillUnmount() {    this._listeners.forEach(listener => listener.remove());  }
  updateKeyboardSpace(event) {    if (!event.endCoordinates) {      return;    }
    let animationConfig = defaultAnimation;    if (Platform.OS === ios) {      animationConfig = LayoutAnimation.create(        event.duration,        LayoutAnimation.Types[event.easing],        LayoutAnimation.Properties.opacity,      );    }    LayoutAnimation.configureNext(animationConfig);
     get updated on rotation    const screenHeight = Dimensions.get(window).height;     when external physical keyboard is connected     event.endCoordinates.height still equals virtual keyboard height     however only the keyboard toolbar is showing if there should be one    const keyboardSpace = (screenHeight - event.endCoordinates.screenY) + this.props.topSpacing;    this.setState({      keyboardSpace,      isKeyboardOpened: true    }, this.props.onToggle(true, keyboardSpace));  }
  resetKeyboardSpace(event) {    let animationConfig = defaultAnimation;    if (Platform.OS === ios) {      animationConfig = LayoutAnimation.create(        event.duration,        LayoutAnimation.Types[event.easing],        LayoutAnimation.Properties.opacity,      );    }    LayoutAnimation.configureNext(animationConfig);
    this.setState({      keyboardSpace: 0,      isKeyboardOpened: false    }, this.props.onToggle(false, 0));  }
  render() {    return (      <View style={[styles.container, { height: this.state.keyboardSpace }, this.props.style]} />);  }}"
"use strict;/** * Webpack frontend test configuration. */var path = require(path);var merge = require(lodash/merge);var prodCfg = require(./webpack.config);var webpack = require(webpack);
module.exports = {  cache: true,  context: path.join(__dirname, test/client),  entry: ./main,  output: {    path: __dirname,    filename: main.js,    publicPath: /assets/  },  resolve: merge({}, prodCfg.resolve, {    alias: {       Allow root import of `src/FOO` from ROOT/src.      src: path.join(__dirname, src)    }  }),  plugins: [    new webpack.ProvidePlugin({      CodeMirror: codemirror,      window.CodeMirror: codemirror    })  ],  module: prodCfg.module,  devtool: #source-map};"
"use strict;
var webpack = require(webpack);var path = require(path);
module.exports = {  cache: true,  entry: path.join(__dirname, src/index.js),  externals: [    {      react: {        root: React,        commonjs2: react,        commonjs: react,        amd: react      },      react-dom: {        root: ReactDom,        commonjs2: react-dom,        commonjs: react-dom,        amd: react-dom      }    }  ],  output: {    path: path.join(__dirname, dist),    filename: component-playground.min.js,    library: ComponentPlayground,    libraryTarget: umd  },  resolve: {    extensions: [, .js, .jsx]  },  module: {    loaders: [      {        test: jsx,        exclude: (node_modules),        loader: babel-loader      }, {        test: css,        loader: style-loader!css-loader      }, {        test: (pngjpg),        loader: url-loader?limit=8192      }    ]  },  plugins: [    new webpack.optimize.DedupePlugin(),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    }),    new webpack.DefinePlugin({       Signal production, so that webpack removes non-production code that       is in condtionals like: `if (process.env.NODE_ENV === ""production"")`      process.env.NODE_ENV: JSON.stringify(production)    }),    new webpack.SourceMapDevToolPlugin([file].map)  ]};"
"var gulp = require(gulp);
var PATHS = {    src: src/**/*.ts};
gulp.task(clean, function (done) {    var del = require(del);    del([dist], done);});
gulp.task(ts2js, function () {    var typescript = require(gulp-typescript);    var tscConfig = require(./tsconfig.json);
    var tsResult = gulp        .src([PATHS.src, node_modules/angular2/typings/browser.d.ts])        .pipe(typescript(tscConfig.compilerOptions));
    return tsResult.js.pipe(gulp.dest(dist));});
gulp.task(play, [ts2js], function () {    var http = require(http);    var connect = require(connect);    var serveStatic = require(serve-static);    var open = require(open);
    var port = 9000, app;
    gulp.watch(PATHS.src, [ts2js]);
    app = connect().use(serveStatic(__dirname));    http.createServer(app).listen(port, function () {        open(http://localhost: + port);    });});
gulp.task(default, [play]);"
"use strict;
var webpack = require(webpack);var config = require(./webpack.config);
 **WARNING**: Mutates base configuration. We do this because lodash isn't available in `production` mode.config.output.filename = component-playground.js;config.plugins = [  new webpack.SourceMapDevToolPlugin([file].map)];
 Export mutated base.module.exports = config;"
"use strict;/** * Webpack frontend test (w/ coverage) configuration. */var merge = require(lodash/merge);var testCfg = require(./webpack.config.test);
module.exports = merge({}, testCfg, {  isparta: {    babel: {      presets: [es2015, stage-1, react]    }  },  module: {    preLoaders: [       Manually instrument client code for code coverage.       https://github.com/deepsweet/isparta-loader handles ES6 + normal JS.      {        test: srcjsx,        exclude: (testnode_modules),        loader: isparta      }    ]  }});"
"(function(){	if(!window.videoId){		return false;	}	var coverCss = [		,		position:fixed,		top:0,		left:0,		bottom:0,		right:0,		background-color:rgba(255,255,255,0),		z-index:999999999999,		-webkit-transition:background-color 0.2s ease;,		-moz-transition:background-color 0.2s ease;,		-o-transition:background-color 0.2s ease;,		transition:background-color 0.2s ease;,		pointer-events:none,			];	var videoCss = [		,		position:absolute,		width:610px,		height:458px,		top:-500px,		left:50%,		margin-left:-306px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		-webkit-transition:top 1s ease;,		-moz-transition:top 1s ease;,		-o-transition:top 1s ease;,		transition:top 1s ease;,			];	var aCss = [		,		position:absolute,		bottom:0,		left:0,		right:0,		height:30px;,		text-align:center,		font-size:14px,		pointer-events:auto,			];		var btnCss = [		,		position:absolute,		top:0,		height:30px;,		line-height:30px,		width:60px,		text-align:center,		font-size:14px,		letter-spacing:-1px,		color:#014CCC,		cursor:pointer,		pointer-events:auto,			];		var changeBtnCss = [		,		position:absolute,		width:500px,		height:40px,		top:470px,		left:50%,		margin-left:-250px,		z-index:1000000000000,		background:#000,		background-image: -webkit-linear-gradient(top,#333,#000),		background-image: -moz-linear-gradient(top,#333,#000),		background-image: -ms-linear-gradient(top,#333,#000),		background-image: -o-linear-gradient(top,#333,#000),		background-image: linear-gradient(top,#333,#000),		box-shadow:0 0 5px #333,		text-align:center,		color:#eee,		border-radius:150px,		overflow:hidden,			];		var changeBtnItemCss = [		,		display:inline-block,		width:90px,		height:40px,		line-height:40px,		font-size:20px,				cursor:pointer,			];			var HTML5Player = function(){			var hd2Src= /player/getM3U8/vid/+videoId+/type/hd2/ts/+(((new Date()).getTime()/1000).toString()|0)+/v.m3u8;		var mp4Src= /player/getM3U8/vid/+videoId+/type/mp4/ts/+(((new Date()).getTime()/1000).toString()|0)+/v.m3u8;		var flvSrc= /player/getM3U8/vid/+videoId+/type/flv/ts/+(((new Date()).getTime()/1000).toString()|0)+/v.m3u8;		var mp4Src2 = http://3g.youku.com/pvs?id=+videoId2+&format=3gphd;		var m3u8Src= '/player/getM3U8/vid/'+videoId+'/type/mp4/flv/ts/'+(new Date()).getTime()+'/v.m3u8';		var cover = document.createElement(div);		cover.style.cssText += coverCss.join(;);
		var v = document.createElement(video);		v.setAttribute(height,458);		v.setAttribute(width,610);		v.setAttribute(controls,true);		v.setAttribute(autoplay,true);		v.style.cssText += videoCss.join(;);		v.src = hd2Src;						var a = document.createElement(a);				a.setAttribute(href,mp4Src);		a.innerHTML = &#x4E0D;&#x80FD;&#x76F4;&#x63A5;&#x89C2;&#x770B;&#xFF0C;&#x70B9;&#x51FB;&#x8FD9;&#x91CC;&#xFF1A;+mp4Src;		a.style.cssText += aCss.join(;);		cover.appendChild(a);				var off = document.createElement(div);		off.innerHTML = &#x9000;&#x51FA;;		off.style.cssText += btnCss.join(;)+;right:0;;		cover.appendChild(off);		var nocover = document.createElement(div);		nocover.innerHTML = &#x6253;&#x5F00;&#x8FF7;&#x96FE;;		nocover.style.cssText += btnCss.join(;)+;right:60px;;;		cover.appendChild(nocover);				off.addEventListener(click,function(){			y.HTML5.remove();			y.flash.add();			y.flag = false;		},false);				nocover.addEventListener(click,function(){			cover.style.backgroundColor = rgba(255,255,255,0);		},false);					var changeBtn = document.createElement(div);		changeBtn.style.cssText += changeBtnCss.join(;);								var hd2btn = document.createElement(div);		hd2btn.style.cssText += changeBtnItemCss.join(;);		hd2btn.style.backgroundColor = #666;		hd2btn.style.boxShadow = 0 0 3px #000 inset;		hd2btn.innerHTML = &#x8D85;&#x6E05;;		changeBtn.appendChild(hd2btn);						var mp4btn = document.createElement(div);		mp4btn.style.cssText += changeBtnItemCss.join(;);		mp4btn.innerHTML = &#x9AD8;&#x6E05;;		changeBtn.appendChild(mp4btn);				var flvbtn = document.createElement(div);		flvbtn.style.cssText += changeBtnItemCss.join(;);		flvbtn.innerHTML = &#x6807;&#x6E05;;		changeBtn.appendChild(flvbtn);				var mp4btn2 = document.createElement(div);		mp4btn2.style.cssText += changeBtnItemCss.join(;);		mp4btn2.innerHTML = mp4;		changeBtn.appendChild(mp4btn2);				hd2btn.addEventListener(click,function(){			v.src = hd2Src;			hd2btn.style.backgroundColor = #666;						hd2btn.style.boxShadow = 0 0 3px #000 inset;			mp4btn.style.backgroundColor = transparent;			mp4btn.style.boxShadow = none;			flvbtn.style.backgroundColor = transparent;			flvbtn.style.boxShadow = none;			mp4btn2.style.backgroundColor = transparent;			mp4btn2.style.boxShadow = none;		},false);				mp4btn.addEventListener(click,function(){			v.src = mp4Src;			mp4btn.style.backgroundColor = #666;			mp4btn.style.boxShadow = 0 0 3px #000 inset;			hd2btn.style.backgroundColor = transparent;			hd2btn.style.boxShadow = none;			flvbtn.style.backgroundColor = transparent;			flvbtn.style.boxShadow = none;			mp4btn2.style.backgroundColor = transparent;			mp4btn2.style.boxShadow = none;		},false);				flvbtn.addEventListener(click,function(){			v.src = flvSrc;			flvbtn.style.backgroundColor = #666;			flvbtn.style.boxShadow = 0 0 3px #000 inset;			hd2btn.style.backgroundColor = transparent;			hd2btn.style.boxShadow = none;			mp4btn.style.backgroundColor = transparent;			mp4btn.style.boxShadow = none;			mp4btn2.style.backgroundColor = transparent;			mp4btn2.style.boxShadow = none;		},false);				mp4btn2.addEventListener(click,function(){			v.src = mp4Src2;						mp4btn2.style.backgroundColor = #666;			mp4btn2.style.boxShadow = 0 0 3px #000 inset;			hd2btn.style.backgroundColor = transparent;			hd2btn.style.boxShadow = none;			flvbtn.style.backgroundColor = transparent;			flvbtn.style.boxShadow = none;			mp4btn.style.backgroundColor = transparent;			mp4btn.style.boxShadow = none;		},false);				return {			add : function(){				document.body.appendChild(cover);				document.body.appendChild(changeBtn);				document.body.appendChild(v);								v.addEventListener(canplay,v.play);				setTimeout(function(){					cover.style.backgroundColor = rgba(255,255,255,0.6);					v.style.top = -1px;				},100);			},			remove : function(){				v.pause();				cover.style.backgroundColor = rgba(255,255,255,0);				v.style.top = -500px;				setTimeout(function(){					cover.parentNode && document.body.removeChild(cover);					v.parentNode && document.body.removeChild(v);					changeBtn.parentNode && document.body.removeChild(changeBtn);				},1100);			}		}	}
	var flashPlayer = function(){		var flash = document.getElementById(movie_player);		var flashOut = flash.parentNode;		return {			add : function(){				flashOut.appendChild(flash);			},			remove : function(){				flashOut.parentNode && flashOut.removeChild(flash);			}		}	}			window.isYoukuHTML5PlayerBookMarkCodeByZythum = window.isYoukuHTML5PlayerBookMarkCodeByZythum || {};	var y = window.isYoukuHTML5PlayerBookMarkCodeByZythum;	y.HTML5  = y.HTML5 || HTML5Player();	y.flash = y.flash || flashPlayer();	y.flag = y.flag || false;	if(y.flag === false){		y.HTML5.add();		y.flash.remove();		y.flag = true;	}else if(y.flag === true){		y.HTML5.remove();		y.flash.add();		y.flag = false;	}
})();"
"/** * * Copyright 2015 Google Inc. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the ""License""); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an ""AS IS"" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
var isProd = false;var gulp = require(gulp),    fs = require(fs),    del = require(del),    watch = require(gulp-watch)    watchify = require(watchify),    browserify = require(browserify),    source = require(vinyl-source-stream),    gutil = require(gulp-util),    babelify = require(babelify),    minifycss = require(gulp-minify-css),    uglify = require(gulp-uglify),    sass = require(gulp-sass),    streamify = require(gulp-streamify),    runSequence = require(run-sequence),    license = require(gulp-license),    replace = require(gulp-replace),    bump = require(gulp-bump);var version = null;
function createBundle(url) {  return browserify({    entries: [url],    debug: !isProd  }).transform(babelify);}
function watchBundles() {  var bundleKeys = Object.keys(bundles);  var watch = null;  var key = null;  for (var b = 0; b < bundleKeys.length; b++) {    key = bundleKeys[b];    watch = watchify(bundles[key].bundle);    watch.on(update, buildBundle.bind(this, key));  }}
function buildBundle(bundleName) {
  var job = bundles[bundleName];  var bundle = job.bundle;  var name = job.name;
  var b = bundle.bundle()      .on(log, gutil.log.bind(gutil, Browserify Log))      .on(error, gutil.log.bind(gutil, Browserify Error))      .pipe(source(name));
  if (isProd) {    b = b.pipe(streamify(uglify()));  }
  return b.pipe(license(Apache, {      organization: Google Inc. All rights reserved.    }))    .pipe(gulp.dest(./dist/scripts))}
var bundles = {  core: {    url: ./src/scripts/voicememo-core.js,    name: voicememo-core.js,    bundle: null  },  list: {    url: ./src/scripts/voicememo-list.js,    name: voicememo-list.js,    bundle: null  },  record: {    url: ./src/scripts/voicememo-record.js,    name: voicememo-record.js,    bundle: null  },  details: {    url: ./src/scripts/voicememo-details.js,    name: voicememo-details.js,    bundle: null  }};
gulp.task(clean, function(done) {  del([dist], done);});
gulp.task(styles, function() {  gulp.src(./src/styles/*.scss)      .pipe(sass())      .pipe(minifycss())      .pipe(license(Apache, {        organization: Google Inc. All rights reserved.      }))      .pipe(gulp.dest(./dist/styles))});
gulp.task(scripts, function() {  var bundleKeys = Object.keys(bundles);  for (var b = 0; b < bundleKeys.length; b++) {    buildBundle(bundleKeys[b]);  }})
gulp.task(root, function() {  gulp.src(./src/*.*)    .pipe(replace(@VERSION@g, version))    .pipe(gulp.dest(./dist/))
  gulp.src(./src/favicon.ico)    .pipe(gulp.dest(./dist/))});
gulp.task(html, function() {
  gulp.src(./src/**/*.html)    .pipe(replace(@VERSION@g, version))    .pipe(gulp.dest(./dist/))});
gulp.task(images, function() {  gulp.src(./src/images/**/*.*)    .pipe(gulp.dest(./dist/images))});
gulp.task(third_party, function() {  gulp.src(./src/third_party/**/*.*)    .pipe(gulp.dest(./dist/third_party))});
gulp.task(serviceworker, function() {  gulp.src(./src/scripts/sw.js)    .pipe(replace(@VERSION@g, version))    .pipe(gulp.dest(./dist/scripts))});
gulp.task(watch, function() {  gulp.watch(./src/**/*.scss, [styles]);  gulp.watch(./src/*.*, [root]);  gulp.watch(./src/**/*.html, [html]);  gulp.watch(./src/images/**/*.*, [images]);  gulp.watch(./src/third_party/**/*.*, [third_party]);  gulp.watch(./src/scripts/sw.js, [serviceworker]);
  watchBundles();});
gulp.task(getversion, function() {  version = JSON.parse(fs.readFileSync(./package.json, utf8)).version;});

(function () {  var bundleKeys = Object.keys(bundles);  var key = null;  for (var b = 0; b < bundleKeys.length; b++) {    key = bundleKeys[b];    bundles[key].bundle = createBundle(bundles[key].url);  }})();
var allTasks = [styles, scripts, root, html, images,    third_party, serviceworker];
gulp.task(bump, function() {  return gulp.src(./package.json)    .pipe(bump({type:patch}))    .pipe(gulp.dest(./));});
gulp.task(default, function() {  isProd = true;  return runSequence(clean, bump, getversion, allTasks);})
gulp.task(dev, function() {  return runSequence(clean, getversion, allTasks, watch);});
"
"(function(){	if(!window.iid){		return false;	}	var coverCss = [		,		position:fixed,		top:0,		left:0,		bottom:0,		right:0,		background-color:rgba(255,255,255,0),		z-index:999999999999,		-webkit-transition:background-color 0.2s ease;,		-moz-transition:background-color 0.2s ease;,		-o-transition:background-color 0.2s ease;,		transition:background-color 0.2s ease;,		pointer-events:none,			];	var videoCss = [		,		position:absolute,		width:610px,		height:458px,		top:-500px,		left:50%,		margin-left:-306px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		-webkit-transition:top 1s ease;,		-moz-transition:top 1s ease;,		-o-transition:top 1s ease;,		transition:top 1s ease;,			];	var aCss = [		,		position:absolute,		bottom:0,		left:0,		right:0,		height:30px;,		text-align:center,		font-size:14px,		pointer-events:auto,			];		var btnCss = [		,		position:absolute,		top:0,		height:30px;,		line-height:30px,		width:60px,		text-align:center,		font-size:14px,		letter-spacing:-1px,		color:#014CCC,		cursor:pointer,		pointer-events:auto,			];		var changeBtnCss = [		,		position:absolute,		width:500px,		height:40px,		top:470px,		left:50%,		margin-left:-250px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		text-align:center,		color:#eee,		border-radius:150px,		overflow:hidden,			];		var changeBtnItemCss = [		,		display:inline-block,		width:150px,		height:40px,		line-height:40px,		font-size:20px,				cursor:pointer,			];
	var pad = function(num, n) {        return (new Array(n >(+num).length ? (n - (+num).length+1) : 0).join(0) + num);	}		var HTML5Player = function(){		123/554/149/3		iidStr = iid.toString().match(/(\d{3})(\d{3})(\d{3})/);		iidStr = pad(iid,9).match(()()());		var idEncodeed = iidStr[1] + / + iidStr[2] + / + iidStr[3];
		var t_yuanhuaSrc = http://m3u8.tdimg.com/+idEncodeed+/+99.m3u8;		var t_360Src = http://m3u8.tdimg.com/+idEncodeed+/+3.m3u8;		var t_256Src = http://m3u8.tdimg.com/+idEncodeed+/+2.m3u8;
		var cover = document.createElement(div);		cover.style.cssText += coverCss.join(;);
		var v = document.createElement(video);		v.setAttribute(height,458);		v.setAttribute(width,610);		v.setAttribute(controls,true);		v.setAttribute(autoplay,true);		v.style.cssText += videoCss.join(;);		v.src = t_yuanhuaSrc;						var a = document.createElement(span);				a.innerHTML = 目前只有m3u8格式的支持,貌似只有safair才能播放。;		a.style.cssText += aCss.join(;);		cover.appendChild(a);				var off = document.createElement(div);		off.innerHTML = 退出;		off.style.cssText += btnCss.join(;)+;right:0;;		cover.appendChild(off);		var nocover = document.createElement(div);		nocover.innerHTML = 打开迷雾;		nocover.style.cssText += btnCss.join(;)+;right:60px;;		cover.appendChild(nocover);				off.addEventListener(click,function(){			y.HTML5.remove();			y.flash.add();			y.flag = false;		},false);				nocover.addEventListener(click,function(){			cover.style.backgroundColor = rgba(255,255,255,0);		},false);				var changeBtn = document.createElement(div);		changeBtn.style.cssText += changeBtnCss.join(;);				var t_yuanhua = document.createElement(div);		t_yuanhua.style.cssText += changeBtnItemCss.join(;);		t_yuanhua.style.backgroundColor = #666;		t_yuanhua.style.boxShadow = 0 0 3px #000 inset;		t_yuanhua.innerHTML = 原画;		changeBtn.appendChild(t_yuanhua);				var t_360 = document.createElement(div);		t_360.style.cssText += changeBtnItemCss.join(;);		t_360.innerHTML = 360P;		changeBtn.appendChild(t_360);				var t_256 = document.createElement(div);		t_256.style.cssText += changeBtnItemCss.join(;);		t_256.innerHTML = 256P;		changeBtn.appendChild(t_256);
		t_yuanhua.addEventListener(click,function(){			v.src = t_yuanhuaSrc;			t_yuanhua.style.backgroundColor = #666;			t_360.style.backgroundColor = transparent;			t_256.style.backgroundColor = transparent;			t_yuanhua.style.boxShadow = 0 0 3px #000 inset;			t_360.style.boxShadow = none;			t_256.style.boxShadow = none;		},false);				t_360.addEventListener(click,function(){			v.src = t_360Src;			t_360.style.backgroundColor = #666;			t_yuanhua.style.backgroundColor = transparent;			t_256.style.backgroundColor = transparent;			t_360.style.boxShadow = 0 0 3px #000 inset;			t_yuanhua.style.boxShadow = none;			t_256.style.boxShadow = none;		},false);				t_256.addEventListener(click,function(){			v.src = t_360Src;			t_256.style.backgroundColor = #666;			t_yuanhua.style.backgroundColor = transparent;			t_360.style.backgroundColor = transparent;			t_256.style.boxShadow = 0 0 3px #000 inset;			t_yuanhua.style.boxShadow = none;			t_360.style.boxShadow = none;		},false);


		return {			add : function(){				document.body.appendChild(cover);				document.body.appendChild(changeBtn);				document.body.appendChild(v);								v.addEventListener(canplay,v.play);				setTimeout(function(){					cover.style.backgroundColor = rgba(255,255,255,0.6);					v.style.top = -1px;				},100);			},			remove : function(){				v.pause();				cover.style.backgroundColor = rgba(255,255,255,0);				v.style.top = -500px;				setTimeout(function(){					cover.parentNode && document.body.removeChild(cover);					v.parentNode && document.body.removeChild(v);					changeBtn.parentNode && document.body.removeChild(changeBtn);				},1100);			}		}	}
	var flashPlayer = function(){		var flashOut = document.getElementById(player);		var flash = document.getElementById(playerObject);		return {			add : function(){				flashOut.appendChild(flash);			},			remove : function(){				flashOut.parentNode && flashOut.removeChild(flash);			}		}	}			window.isTudouHTML5PlayerBookMarkCodeByZythum = window.isTudouHTML5PlayerBookMarkCodeByZythum || {};	var y = window.isTudouHTML5PlayerBookMarkCodeByZythum;	y.HTML5  = y.HTML5 || HTML5Player();	y.flash = y.flash || flashPlayer();	y.flag = y.flag || false;	if(y.flag === false){		y.HTML5.add();		y.flash.remove();		y.flag = true;	}else if(y.flag === true){		y.HTML5.remove();		y.flash.add();		y.flag = false;	}
})();"
"module.exports = function(grunt) {    var comments = /* +                    * Name: SewisePlayer framework 2.5.2 +                    * Author: Jack Zhang +                    * Website: http://player.sewise.com +                    * Date: December 26, 2014 +                    * Copyright: 2013-2014, Sewise +                    * Mail: jackzhang1204@gmail.com +                    * QQ: 237432172 +                    *  */;
    var srcFiles = [                    src/com/sewise/base/core/Base.js,                    src/com/sewise/interfaces/player/IVodPlayer.js,                    src/com/sewise/interfaces/skin/IVodSkin.js,                    src/com/sewise/interfaces/player/ILivePlayer.js,                    src/com/sewise/interfaces/skin/ILiveSkin.js,                    src/com/sewise/base/globals/GlobalConst.js,                    src/com/sewise/base/globals/GlobalVars.js,                    src/com/sewise/base/events/CommandDispatcher.js,                    src/com/sewise/base/events/Events.js,                    src/com/sewise/base/utils/Utils.js,                    src/com/sewise/base/params/GlobalParams.js,                    src/com/sewise/base/params/H5Params.js,                    src/com/sewise/base/medias/PlayerSkinLoader.js,                    src/com/sewise/base/medias/vod/VodVideo.js,                    src/com/sewise/base/medias/vod/VodAudio.js,                    src/com/sewise/base/medias/vod/VodMediaConsole.js,                    src/com/sewise/base/medias/vod/VodMediaStreams.js,                    src/com/sewise/base/medias/live/LiveVideo.js,                    src/com/sewise/base/medias/live/LiveMediaConsole.js,                    src/com/sewise/base/medias/live/LiveMediaStreams.js,                    src/com/sewise/base/medias/PlayerCommon.js,                    src/com/sewise/base/external/FlashExternalInterface.js,                    src/com/sewise/base/external/Html5ExternalInterface.js,                    src/com/sewise/base/dom/ContextMenu.js,                    src/com/sewise/base/SewisePlayer.js                ];
    grunt.initConfig({        pkg: grunt.file.readJSON(package.json),        /*concat: {            options: {                banner: comments,                stripBanners: true,                separator: '\n\n'            },            dist: {                src: srcFiles,                dest: 'bin/<%= pkg.name %>.js'            }        },*/        uglify: {            options: {                banner: comments,                compress: {                    drop_console: true                }            },            my_target: {                files: {                    bin/<%= pkg.name %>.min.js: srcFiles                }            }        },        jshint: {            files: [gruntfile.js, srcFiles],            options: {                globals: {                    jQuery: true,                    console: true,                    module: true                }            }        },        watch: {            files: [<%= jshint.files %>],            tasks: [jshint]        }                    });        grunt.loadNpmTasks('grunt-contrib-concat');    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-jshint);    grunt.loadNpmTasks(grunt-contrib-watch);        grunt.registerTask(test, [jshint]);    grunt.registerTask('default', ['uglify', 'concat', 'jshint']);    grunt.registerTask(default, [uglify, jshint]);    };"
"(function(root, factory) {    if (typeof module !== undefined && module.exports) {        module.exports = factory();    } else if (typeof define === function && define.amd) {        define([], factory);    } else {        root.canvid = factory();    }}(this, function() {
    function canvid(params) {        var defaultOptions = {                width : 800,                height : 450,                selector: .canvid-wrapper            },            firstPlay = true,            control = {                play: function() {                    console.log(Cannot play before images are loaded);                }            },            _opts = merge(defaultOptions, params),            el = typeof _opts.selector === string ? document.querySelector(_opts.selector) : _opts.selector;
        if (!el) {            return console.warn(Error. No element found for selector, _opts.selector);        }
        if (!_opts.videos) {            return console.warn(Error. You need to define at least one video object);        }
        if (hasCanvas()) {
            loadImages(_opts.videos, function(err, images) {                if (err) return console.warn(Error while loading video sources., err);
                var ctx = initCanvas(),                    requestAnimationFrame = reqAnimFrame();
                control.play = function(key, reverse, fps) {                    if (control.pause) control.pause();  pause current vid
                    var img = images[key],                        opts = _opts.videos[key],                        frameWidth = img.width / opts.cols,                        frameHeight = img.height / Math.ceil(opts.frames / opts.cols);
                    var curFps = fps || opts.fps || 15,                        curFrame = reverse ? opts.frames - 1 : 0,                        wait = 0,                        playing = true,                        loops = 0,                        delay = 60 / curFps;
                    requestAnimationFrame(frame);
                    control.resume = function() {                        playing = true;                        requestAnimationFrame(frame);                    };
                    control.pause = function() {                        playing = false;                        requestAnimationFrame(frame);                    };
                    control.isPlaying = function() {                        return playing;                    };
                    control.destroy = function(){                        control.pause();                        removeCanvid();                    };
                    control.getCurrentFrame = function(){                        return curFrame;                    };
                    control.setCurrentFrame = function(frameNumber){                        if(frameNumber < 0 || frameNumber >= opts.frames){                            return false;                        }
                        if(!control.isPlaying()){                            drawFrame(frameNumber);                        }
                        curFrame = frameNumber;                    };
                    if (firstPlay) {                        firstPlay = false;                        hideChildren();                    }
                    function frame() {                        if (!wait) {                            drawFrame(curFrame);                            curFrame = (+curFrame + (reverse ? -1 : 1));                            if (curFrame < 0) curFrame += +opts.frames;                            if (curFrame >= opts.frames) curFrame = 0;                            if (reverse ? curFrame == opts.frames - 1 : !curFrame) loops++;                            if (opts.loops && loops >= opts.loops){                                playing = false;                                if(opts.onEnd && isFunction(opts.onEnd)){                                    opts.onEnd();                                }                            }                        }                        wait = (wait + 1) % delay;                        if (playing && opts.frames > 1) requestAnimationFrame(frame);                    }
                    function drawFrame(f) {                        var fx = Math.floor(f % opts.cols) * frameWidth,                            fy = Math.floor(f / opts.cols) * frameHeight;
                        ctx.clearRect(0, 0, _opts.width, _opts.height);  clear frame                        ctx.drawImage(img, fx, fy, frameWidth, frameHeight, 0, 0, _opts.width, _opts.height);                    }
                };  end control.play
                if (isFunction(_opts.loaded)) {                    _opts.loaded(control);                }
            });  end loadImages
        } else if (opts.srcGif) {            var fallbackImage = new Image();            fallbackImage.src = opts.srcGif;
            el.appendChild(fallbackImage);        }
        function loadImages(imageList, callback) {            var images = {},                imagesToLoad = Object.keys(imageList).length;
            if(imagesToLoad === 0) {                return callback(You need to define at least one video object.);            }
            for (var key in imageList) {                images[key] = new Image();                images[key].onload = checkCallback;                images[key].onerror = callback;                images[key].src = imageList[key].src;            }
            function checkCallback() {                imagesToLoad--;                if (imagesToLoad === 0) {                    callback(null, images);                }            }        }
        function initCanvas() {            var canvas = document.createElement(canvas);            canvas.width = _opts.width;            canvas.height = _opts.height;            canvas.classList.add(canvid);
            el.appendChild(canvas);
            return canvas.getContext(2d);        }
        function hideChildren() {            [].forEach.call(el.children, function(child){                if(!child.classList.contains(canvid) ){                    child.style.display = none;                }            });        }
        function removeCanvid(){            [].forEach.call(el.children, function(child){                if(child.classList.contains(canvid) ){                    el.removeChild(child);                }            });        }
        function reqAnimFrame() {            return window.requestAnimationFrame                || window.webkitRequestAnimationFrame                || window.mozRequestAnimationFrame                || window.msRequestAnimationFrame                || function(callback) {                    return setTimeout(callback, 1000 / 60);                };        }
        function hasCanvas() {             taken from Modernizr            var elem = document.createElement(canvas);            return !!(elem.getContext && elem.getContext(2d));        }
        function isFunction(obj) {             taken from jQuery            return typeof obj === function || !!(obj && obj.constructor && obj.call && obj.apply);        }
        function merge() {            var obj = {},                key;
            for (var i = 0; i < arguments.length; i++) {                for (key in arguments[i]) {                    if (arguments[i].hasOwnProperty(key)) {                        obj[key] = arguments[i][key];                    }                }            }            return obj;        }
        return control;    };  end canvid function
    return canvid;}));  end factory function"
" CONSTGITHUB_ID = process.env.GITHUB_IDGITHUB_TOKEN = process.env.GITHUB_TOKENGITHUB_ACCESS_TOKEN = process.env.GITHUB_ACCESS_TOKENSECRETS = [process.env.SECRET]PORT = process.env.PORT || +process.argv[2] || 80
 core libsfs    = require(fs)url   = require(url)http  = require(http)https = require(https)
request = require(request)
 file servernode_static = require(node-static)fileserver = new node_static.Server(.)
 cookiesCookies = require(cookies)
Keygrip = require(keygrip)keys    = new Keygrip(SECRETS)
 oauthOAuth2 = require(oauth).OAuth2github = new OAuth2(  GITHUB_ID,  GITHUB_TOKEN,  https://github.com/login/oauth/,  authorize,  access_token)
 index datavar index = {}
 routesroutes = [  api             , apiHandler    ,
  login          , loginHandler  ,  logout         , logoutHandler ,  oauth_redirect , authHandler   ,
  faviconico   , staticHandler ,  static          , staticHandler ,
                   , defaultHandler]
apiRoutes = [  apime              , currentUser,  apiusers() , user,  apikeywords() , keyword,  api                , currentEntries]
 handlersfunction staticHandler(req, res) {  req.addListener(end, function() {    fileserver      .serve(req, res)      .addListener(error, function(err) {        console.log(Error serving  + req.url, err.message)      })  })}
function authHandler(req, res) {  var next = req.url.query.next || url.format(url.resolve(req.url, /))    , code = req.url.query.code
	github.getOAuthAccessToken(code, {}, function(err, access, refresh) {		github.get(			https://api.github.com/user,			access,			function(err, data, response) {			  if (err) return res.end()
			  var user = JSON.parse(data)
				req.cookies.set(id, user.login, {signed: true})				res.writeHead(307, {Location: next})				res.end()			}		)	})}
function loginHandler(req, res) {	var next = github.getAuthorizeUrl()
	res.writeHead(307, {Location: next})	res.end()}
function logoutHandler(req, res) {  var next = req.url.query.next || url.format(url.resolve(req.url, /))
  req.cookies.set(id, null, {signed: true})  res.writeHead(307, {Location: next})  res.end()}
function apiHandler(req, res) {  var callback = req.url.query.callback    , handler    , i = 0    , route
  for (; route = apiRoutes[i++]; i++) {    if (route.test(req.url.pathname)) {      handler = apiRoutes[i]      req.url.captures = req.url.pathname.match(route)      break    }  }
  if (!callback || .test(callback)) callback = alert
	handler || (handler = function(cb){ cb(404, Not found.) })
  handler(req, function(err, data) {    if (err) {      res.writeHead(404)      return res.end({error: ""Not found.""})    }
    var ret = callback + ( + JSON.stringify(data) + )
    res.writeHead(200, {      Content-Type:   text/javascript,      Content-Length: Buffer.byteLength(ret)    })
    res.end(ret)  })}
function defaultHandler(req, res) {  req.url = /static/index.html  staticHandler(req, res)}
function currentUser(req, cb) {  var id = req.cookies.get(id, {signed: true})
  cb(null, id && {id: id})}
function currentEntries(req, cb) {  var ids = Object.keys(index.entries.byId)    , randomEntries = []    , i = 4
  while (i--) randomEntries[i] = index.entries.byId[    ids.splice(0|Math.random()*ids.length, 1)[0]  ]
  cb(null, {    entries:  randomEntries,    keywords: index.keywords.list,    users:    index.users.list  })}
function user(req, cb) {  var data = index.users.byName[req.url.captures[1]]    , ret = {}
  for (var name in data) ret[name] = data[name]  ret.entries = data.entries.map(function(id){ return index.entries.byId[id] })
  data ? cb(null, ret) : cb(404)}
function keyword(req, cb) {  var data = Object    .keys(index.keywords.byWord[req.url.captures[1]])    .map(function(id){ return index.entries.byId[id] })
  cb(null, data)}
 setuphttp.createServer(function listener(req, res) {  req.url = url.parse(req.url, true)  req.cookies = new Cookies(req, res, keys)
  for (var i = 0, route; route = routes[i++]; i++) {    if (route.test(req.url.pathname)) return routes[i](req, res)  }}).listen(PORT)
console.log(140byt.es now running on port  + PORT)
gistEndpoint = url.format({  protocol: https:,  hostname: api.github.com,  pathname: /gists/starred,  query: {    access_token: GITHUB_ACCESS_TOKEN,    per_page: 100  }})
function getEntries(entries, uri) {  entries || (entries = [])  uri || (uri = gistEndpoint)
  console.log(fetching entries at  + uri)
  request({uri: uri}, function(err, response, body) {    if (err) console.log(entries could not be fetched:  + err.message)
    else {      var link = response.headers.link
      uri = (link && link.match(<()>; rel=""next"") || 0)[1]      entries = entries.concat(JSON.parse(body))
      if (uri) return getEntries(entries, uri)
      else {        console.log(entries.length +  entries found. checking freshness...)        updateEntries(entries)      }    }  })}



function updateEntries(entries) {  var remote = entries[0], local, path
  if (!remote) return indexEntries()
  path = ./data/entries/ + remote.id + .json
  fs.readFile(path, utf8, function(err, body) {    local = body && JSON.parse(body)
    if (err || remote.updated_at != local.updated_at) {      console.log(fetching entry  + remote.id + ...)      remote.url += ?access_token= + GITHUB_ACCESS_TOKEN      request({uri: remote.url }, function(err, response, body) {        if (err) console.log(entry could not be fetched:  + err.message)        else fs.writeFile(path, body, utf8, function(err) {          if (err) {            console.log(entry could not be written:  + err.message)          } else {            updated = true            updateEntries(entries)          }        })      })    }
    else {      console.log(entry  + remote.id +  is up to date.)      updateEntries(entries.slice(1))    }  })}
function indexEntries() {  index = {    entries: {      byId: {}    },
    keywords: {      byWord: {},      list: []    },
    users: {      byId: {},      byName: {},      list: []    }  }
   from @atk's entry at https://gist.github.com/1102380  var cleanJSON = function j(a,b,c){return c?(b?""+b+"":):JSON.stringify(JSON.parse(a.replace(,(?=)'()'g,j)))}
  console.log(indexing entries...)
  fs.readdir(./data/entries, function(err, entries) {    !function loop(entries) {      var entry = entries.shift()
      if (!entry) {        for (var word in index.keywords.byWord) {          index.keywords.list.push([word, Object.keys(index.keywords.byWord[word]) ])        }
        for (var name in index.users.byId) {          index.users.list.push(index.users.byId[name])        }
        index.users.list.sort(function(a, b){ return b.entries.length - a .entries.length })        index.keywords.list.sort(function(a, b){ return b[1].length - a[1].length })      }
      else fs.readFile(./data/entries/ + entry, utf8, function(err, data) {        var meta, data
        try {          data = JSON.parse(data)
          try {            meta = JSON.parse(data.files[package.json].content)          }
          catch(e) {            meta = cleanJSON(data.files[package.json].content)            meta = JSON.parse(meta)          }
          meta.keywords = meta.keywords.map(function(word) {            word = word.toLowerCase().replace(g,)            index.keywords.byWord[word] || (index.keywords.byWord[word] = {})            index.keywords.byWord[word][data.id] = 1            return word          })
          user = index.users.byId[data.user.id] || (index.users.byId[data.user.id] = data.user)          user.entries || (user.entries = [])          index.users.byName[data.user.login] = user          user.entries.push(data.id)          index.entries.byId[data.id] = {            id: data.id,            name: meta.name,            code: data.files[index.js].content,            description: meta.description || data.description,            author: user.login,            keywords: meta.keywords          }        }
        catch (e) {          console.log(package.json malformed for  + entry)        }
        loop(entries)      })    }(entries)  })}
 uncomment to fetch new onesgetEntries()
indexEntries()setInterval(getEntries, 1000 * 60 * 60)
process.on(uncaughtException, function(e){ console.log(e.stack) })"
module.exports = require(./lib);
"(function(){	if(!window.vid){		return false;	}	var coverCss = [		,		position:fixed,		top:0,		left:0,		bottom:0,		right:0,		background-color:rgba(255,255,255,0),		z-index:999999999999,		-webkit-transition:background-color 0.2s ease;,		-moz-transition:background-color 0.2s ease;,		-o-transition:background-color 0.2s ease;,		transition:background-color 0.2s ease;,		pointer-events:none,			];	var videoCss = [		,		position:absolute,		width:610px,		height:458px,		top:-500px,		left:50%,		margin-left:-306px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		-webkit-transition:top 1s ease;,		-moz-transition:top 1s ease;,		-o-transition:top 1s ease;,		transition:top 1s ease;,			];	var aCss = [		,		position:absolute,		bottom:0,		left:0,		right:0,		height:30px;,		text-align:center,		font-size:14px,		pointer-events:auto,			];		var btnCss = [		,		position:absolute,		top:0,		height:30px;,		line-height:30px,		width:60px,		text-align:center,		font-size:14px,		letter-spacing:-1px,		color:#014CCC,		cursor:pointer,		pointer-events:auto,			];		var changeBtnCss = [		,		position:absolute,		width:500px,		height:40px,		top:470px,		left:50%,		margin-left:-250px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		text-align:center,		color:#eee,		border-radius:150px,		overflow:hidden,			];		var changeBtnItemCss = [		,		display:inline-block,		width:150px,		height:40px,		line-height:40px,		font-size:20px,				cursor:pointer,			];
	var pad = function(num, n) {        return (new Array(n >(+num).length ? (n - (+num).length+1) : 0).join(0) + num);	}		var HTML5Player = function(){
		var m3u8 = vid || ;		m3u8 = m3u8 ? http://hot.vrs.sohu.com/ipad+m3u8+.m3u8 : 0;		var cover = document.createElement(div);		cover.style.cssText += coverCss.join(;);
		var v = document.createElement(video);		v.setAttribute(height,458);		v.setAttribute(width,610);		v.setAttribute(controls,true);		v.setAttribute(autoplay,true);		v.style.cssText += videoCss.join(;);		v.src = m3u8;						var a = document.createElement(span);				a.innerHTML = 目前只有m3u8格式的支持,貌似只有safair才能播放。;		a.style.cssText += aCss.join(;);		cover.appendChild(a);				var off = document.createElement(div);		off.innerHTML = 退出;		off.style.cssText += btnCss.join(;)+;right:0;;		cover.appendChild(off);		var nocover = document.createElement(div);		nocover.innerHTML = 打开迷雾;		nocover.style.cssText += btnCss.join(;)+;right:60px;;		cover.appendChild(nocover);				off.addEventListener(click,function(){			y.HTML5.remove();			y.flash.add();			y.flag = false;		},false);				nocover.addEventListener(click,function(){			cover.style.backgroundColor = rgba(255,255,255,0);		},false);				var changeBtn = document.createElement(div);		changeBtn.style.cssText += changeBtnCss.join(;);				 var t_yuanhua = document.createElement('div');		 t_yuanhua.style.cssText += changeBtnItemCss.join(';');		 t_yuanhua.style.backgroundColor = '#666';		 t_yuanhua.style.boxShadow = '0 0 3px #000 inset';		 t_yuanhua.innerHTML = '原画';		 changeBtn.appendChild(t_yuanhua);				 var t_360 = document.createElement('div');		 t_360.style.cssText += changeBtnItemCss.join(';');		 t_360.innerHTML = '360P';		 changeBtn.appendChild(t_360);				 var t_256 = document.createElement('div');		 t_256.style.cssText += changeBtnItemCss.join(';');		 t_256.innerHTML = '256P';		 changeBtn.appendChild(t_256);
		 t_yuanhua.addEventListener('click',function(){		 	v.src = t_yuanhuaSrc;		 	t_yuanhua.style.backgroundColor = '#666';		 	t_360.style.backgroundColor = 'transparent';		 	t_256.style.backgroundColor = 'transparent';		 	t_yuanhua.style.boxShadow = '0 0 3px #000 inset';		 	t_360.style.boxShadow = 'none';		 	t_256.style.boxShadow = 'none';		 },false);				 t_360.addEventListener('click',function(){		 	v.src = t_360Src;		 	t_360.style.backgroundColor = '#666';		 	t_yuanhua.style.backgroundColor = 'transparent';		 	t_256.style.backgroundColor = 'transparent';		 	t_360.style.boxShadow = '0 0 3px #000 inset';		 	t_yuanhua.style.boxShadow = 'none';		 	t_256.style.boxShadow = 'none';		 },false);				 t_256.addEventListener('click',function(){		 	v.src = t_360Src;		 	t_256.style.backgroundColor = '#666';		 	t_yuanhua.style.backgroundColor = 'transparent';		 	t_360.style.backgroundColor = 'transparent';		 	t_256.style.boxShadow = '0 0 3px #000 inset';		 	t_yuanhua.style.boxShadow = 'none';		 	t_360.style.boxShadow = 'none';		 },false);


		return {			add : function(){				document.body.appendChild(cover);				 document.body.appendChild(changeBtn);				document.body.appendChild(v);								v.addEventListener(canplay,v.play);				setTimeout(function(){					cover.style.backgroundColor = rgba(255,255,255,0.6);					v.style.top = -1px;				},100);			},			remove : function(){				v.pause();				cover.style.backgroundColor = rgba(255,255,255,0);				v.style.top = -500px;				setTimeout(function(){					cover.parentNode && document.body.removeChild(cover);					v.parentNode && document.body.removeChild(v);					changeBtn.parentNode && document.body.removeChild(changeBtn);				},1100);			}		}	}
	var flashPlayer = function(){		var flashOut = document.getElementById(sohuplayer);		var flash = document.getElementById(player);		return {			add : function(){				flashOut.appendChild(flash);			},			remove : function(){				flashOut.parentNode && flashOut.removeChild(flash);			}		}	}			window.isSohuHTML5PlayerBookMarkCodeByZythum = window.isSohuHTML5PlayerBookMarkCodeByZythum || {};	var y = window.isSohuHTML5PlayerBookMarkCodeByZythum;	y.HTML5  = y.HTML5 || HTML5Player();	y.flash = y.flash || flashPlayer();	y.flag = y.flag || false;	if(y.flag === false){		y.HTML5.add();		y.flash.remove();		y.flag = true;	}else if(y.flag === true){		y.HTML5.remove();		y.flash.add();		y.flag = false;	}
})();"
" ==UserScript== @name        AposLoader @namespace   AposLoader @description Grabs latest versions of the bot scripts automatically. @include     http://agar.io/ @version     1.3 @grant       none @author      http://www.twitch.tv/apostolique ==/UserScript==var aposLoaderVersion = 1.3;var sha = efde0488cc2cc176db48dd23b28a20b90314352b;
function getLatestCommit() {	window.jQuery.ajax({		url: https://api.github.com/repos/apostolique/Agar.io-bot/git/refs/heads/master,		cache: false,		dataType: jsonp	}).done(function(data) {		console.dir(data[data])		console.log(hmm:  + data[data][object][sha]);		sha = data[data][object][sha];;		window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/launcher.user.js? + Math.floor((Math.random() * 1000000) + 1), function(data) {			var latestVersion = data.replace(()gm, );			latestVersion = latestVersion.substring(latestVersion.indexOf(// @version) + 11, latestVersion.indexOf(// @grant));			latestVersion = parseFloat(latestVersion + 0.0000);			var script1 = https://cdn.rawgit.com/Apostolique/Agar.io-bot/ + sha + /launcher.user.js;			console.log(Script:  + script1);			window.jQuery(body).append(<script type=""text/javascript"" src="" + script1 + ""></script>);		});		window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/bot.user.js? + Math.floor((Math.random() * 1000000) + 1), function(data) {			var latestVersion = data.replace(()gm, );			latestVersion = latestVersion.substring(latestVersion.indexOf(// @version) + 11, latestVersion.indexOf(// @grant));			latestVersion = parseFloat(latestVersion + 0.0000);			var script2 = https://cdn.rawgit.com/Apostolique/Agar.io-bot/ + sha + /bot.user.js;			console.log(Script:  + script2);			window.jQuery(body).append(<script type=""text/javascript"" src="" + script2 + ""></script>);		});
		function update(prefix, name, url) {			window.jQuery(document.body).prepend(<div id=' + prefix + Dialog' style='position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 100; display: none;'>);			window.jQuery(# + prefix + Dialog).append(<div id=' + prefix + Message' style='width: 350px; background-color: #FFFFFF; margin: 100px auto; border-radius: 15px; padding: 5px 15px 5px 15px;'>);			window.jQuery(# + prefix + Message).append(<h2>UPDATE TIME!!!</h2>);			window.jQuery(# + prefix + Message).append(<p>Grab the update for: <a id=' + prefix + Link' href=' + url + ' target=_blank> + name + </a></p>);			window.jQuery(# + prefix + Link).on(click, function() {				window.jQuery(# + prefix + Dialog).hide();				window.jQuery(# + prefix + Dialog).remove();			});			window.jQuery(# + prefix + Dialog).show();		}		window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/loader.user.js? + Math.floor((Math.random() * 1000000) + 1), function(data) {			var latestVersion = data.replace(()gm, );			latestVersion = latestVersion.substring(latestVersion.indexOf(// @version) + 11, latestVersion.indexOf(// @grant));			latestVersion = parseFloat(latestVersion + 0.0000);			var myVersion = parseFloat(aposLoaderVersion + 0.0000);			if (latestVersion > myVersion) {				update(aposLoader, loader.user.js, https://github.com/Apostolique/Agar.io-bot/blob/master/loader.user.js/);			}			console.log(Current loader.user.js Version:  + myVersion +  on Github:  + latestVersion);		});	}).fail(function() {});}getLatestCommit();"
"/*The MIT License (MIT)Copyright (c) 2015 ApostoliquePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the ""Software""), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.*/ ==UserScript== @name        AposLauncher @namespace   AposLauncher @include     http://agar.io/* @version     5.041 @grant       none @author      http://www.twitch.tv/apostolique ==/UserScript==var aposLauncherVersion = 5.041;
var showAd = true;
Number.prototype.mod = function(n) {    return ((this % n) + n) % n;};
window.logDebugging = falsewindow.log = function(message){    if(window.logDebugging === true){        console.log.apply(console, arguments);    }}
Array.prototype.peek = function() {    return this[this.length - 1];};var sha = efde0488cc2cc176db48dd23b28a20b90314352b;
function getLatestCommit() {    window.jQuery.ajax({        url: https://api.github.com/repos/apostolique/Agar.io-bot/git/refs/heads/master,        cache: false,        dataType: jsonp    }).done(function(data) {        console.dir(data.data);        window.log(hmm:  + data.data.object.sha);        sha = data.data.object.sha;
        function update(prefix, name, url) {            window.jQuery(document.body).prepend(<div id=' + prefix + Dialog' style='position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 100; display: none;'>);            window.jQuery(# + prefix + Dialog).append(<div id=' + prefix + Message' style='width: 350px; background-color: #FFFFFF; margin: 100px auto; border-radius: 15px; padding: 5px 15px 5px 15px;'>);            window.jQuery(# + prefix + Message).append(<h2>UPDATE TIME!!!</h2>);            window.jQuery(# + prefix + Message).append(<p>Grab the update for: <a id=' + prefix + Link' href=' + url + ' target=_blank> + name + </a></p>);            window.jQuery(# + prefix + Link).on(click, function() {                window.jQuery(# + prefix + Dialog).hide();                window.jQuery(# + prefix + Dialog).remove();            });            window.jQuery(# + prefix + Dialog).show();        }
        window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/launcher.user.js? + Math.floor((Math.random() * 1000000) + 1), function(data) {            var latestVersion = data.replace(()gm, );            latestVersion = latestVersion.substring(latestVersion.indexOf(// @version) + 11, latestVersion.indexOf(// @grant));
            latestVersion = parseFloat(latestVersion + 0.0000);            var myVersion = parseFloat(aposLauncherVersion + 0.0000);
            if (latestVersion > myVersion) {                update(aposLauncher, launcher.user.js, https://github.com/Apostolique/Agar.io-bot/blob/ + sha + /launcher.user.js/);            }            window.log(Current launcher.user.js Version:  + myVersion +  on Github:  + latestVersion);        });
    }).fail(function() {});}getLatestCommit();
function addAd() {    window.google_ad_client = ca-pub-5878021809689194;    window.google_ad_slot = 1479874665;    window.google_ad_width = 300;    window.google_ad_height = 250;
    window.jQuery(.side-container:last).append(<div class='agario-panel'><center id='aposAd'></center></div>);    var aposAd = document.getElementById(aposAd);    var w = document.write;    document.write = function(content) {        aposAd.innerHTML = content;        document.write = w;    };
    var script = document.createElement(script);    script.type = text/javascript;    script.src = //pagead2.googlesyndication.com/pagead/show_ads.js;    document.body.appendChild(script);}
if (showAd) {    addAd();}
(function(c, e) {    function vc() {        for (var a = document.cookie.split(;), b = 0; b < a.length; b++) {            for (var d = a[b];                  == d.charAt(0);) d = d.substring(1, d.length);            if (0 == d.indexOf(agario_redirect=)) return d.substring(16, d.length)        }        return null    }
    function qa(a, b) {        if (b) {            var d = new Date;            d.setTime(d.getTime() + 864E5 * b);            d = ; expires= + d.toGMTString()        } else d = ;        document.cookie = agario_redirect= + a + d + ; path=/    }    UPDATE    function keyAction(e) {        if (84 == e.keyCode) {            window.log(Toggle);            toggle = !toggle;        }        if (82 == e.keyCode) {            window.log(ToggleDraw);            toggleDraw = !toggleDraw;        }        if (68 == e.keyCode) {            window.setDarkTheme(!getDarkBool());        }        if (70 == e.keyCode) {            window.setShowMass(!getMassBool());        }        window.botList[botIndex].keyAction(e);    }    UPDATE    function humanPlayer() {        Don't need to do anything.        return [getPointX(), getPointY()];    }

    function Lb() {        UPDATE
        window.botList = window.botList || [];
        window.jQuery(#nick).val(originalName);
        function HumanPlayerObject() {            this.name = Human;            this.keyAction = function(key) {};            this.displayText = function() {                return [];            };            this.mainLoop = humanPlayer;        }
        var hpo = new HumanPlayerObject();
        window.botList.push(hpo);
        window.updateBotList();
        ab = !0;        Ob();        setInterval(Ob, 18E4);
        var father = window.jQuery(#canvas).parent();        window.jQuery(#canvas).remove();        father.prepend(<canvas id='canvas1'>);        $b();
        O = Ab = document.getElementById(canvas1);        f = O.getContext(2d);        UPDATE        O.onmousedown = function(a) {            if (gc) {                var b = a.clientX - (5 + q / 5 / 2),                    c = a.clientY - (5 + q / 5 / 2);                if (Math.sqrt(b * b + c * c) <= q / 5 / 2) {                    Ka();                    H(17);                    return                }            }            Y = 1 * a.clientX;            Z = 1 * a.clientY;            $a();            Ka();        };        UPDATE        O.onmousemove = function(a) {            Xa = !1;            Y = 1 * a.clientX;            Z = 1 * a.clientY;            $a()        };        O.onmouseup = function() {};        firefoxi.test(navigator.userAgent) ? document.addEventListener(DOMMouseScroll, Nb, !1) : document.body.onmousewheel = Nb        c.onkeydown = function(a) {            UPDATE            if (!window.jQuery(#nick).is(:focus)) {                32 != a.keyCode || ra || (nick != a.target.id && a.preventDefault(), Za(), ra = !0);                81 == a.keyCode && (X(18), sa = !0);                87 != a.keyCode || ta || (Mb(), ta = !0);                27 == a.keyCode && (a.preventDefault(), ua(300), e(#oferwallContainer).is(:visible) && c.closeOfferwall(), e(#videoContainer).is(:visible) && c.closeVideoContainer())                    UPDATE                keyAction(a);            }        };        c.onkeyup = function(a) {            32 == a.keyCode && (ra = !1);            87 == a.keyCode && (ta = !1);            81 == a.keyCode && sa && (X(19), sa = !1)        }    }
    function Nb(a) {        a.preventDefault();        P *= Math.pow(.9, a.wheelDelta / -120 || a.detail || 0);        window.log(P:  + P)            UPDATE        0.07 > P && (P = 0.07);        P > 4 / r && (P = 4 / r)    }
    function wc() {        if (.4 > r) ia = null;        else {            for (var a = Number.POSITIVE_INFINITY, b = Number.POSITIVE_INFINITY, d = Number.NEGATIVE_INFINITY, c = Number.NEGATIVE_INFINITY, g = 0; g < z.length; g++) {                var e = z[g];                !e.P() || e.V || 20 >= e.size * r || (a = Math.min(e.x - e.size, a), b = Math.min(e.y - e.size, b), d = Math.max(e.x + e.size, d), c = Math.max(e.y + e.size, c))            }            ia = xc.init({                Ba: a - 10,                Ca: b - 10,                za: d + 10,                Aa: c + 10,                Ja: 2,                Ka: 4            });            for (g = 0; g < z.length; g++)                if (e = z[g], e.P() && !(20 >= e.size * r))                    for (a = 0; a < e.a.length; ++a) b = e.a[a].x, d = e.a[a].y, b < A - q / 2 / r || d < B - u / 2 / r || b > A + q / 2 / r || d > B + u / 2 / r || ia.va(e.a[a])        }    }
    function $a() {        UPDATE        if (toggle || window.botList[botIndex].name == Human) {            setPoint((Y - q / 2) / r + A, (Z - u / 2) / r + B);        }    }
    function Ob() {        null == xa && (xa = {}, e(#region).children().each(function() {            var a = e(this),                b = a.val();            b && (xa[b] = a.text())        }));        e.get(ya + info, function(a) {            var b = {},                d;            for (d in a.regions) {                var c = d.split(:)[0];                b[c] = b[c] || 0;                b[c] += a.regions[d].numPlayers            }            for (d in b) e(#region option[value="" + d + ""]).text(xa[d] +  ( + b[d] +  players))        }, json)    }
    function Pb() {        e(#adsBottom).hide();        e(#overlays).hide();        e(#stats).hide();        e(#mainPanel).hide();        aa = ja = !1;        Qb();        c.destroyAd(c.adSlots.aa);        c.destroyAd(c.adSlots.ac)    }
    function za(a) {        a && (a == K ? e(.btn-needs-server).prop(disabled, !1) : (e(#region).val() != a && e(#region).val(a), K = c.localStorage.location = a, e(.region-message).hide(), e(.region-message. + a).show(), e(.btn-needs-server).prop(disabled, !1), ab && Q()))    }
    function ua(a) {        ja || aa || (Aa ? e(.btn-spectate).prop(disabled, !0) : e(.btn-spectate).prop(disabled, !1), Ba = !1, N = null, bb || (e(#adsBottom).show(), e(#g300x250).hide(), e(#a300x250).show(), e(#g728x90).hide(), e(#a728x90).show()), c.refreshAd(bb ? c.adSlots.ac : c.adSlots.aa), bb = !1, 1E3 > a && (C = 1), ja = !0, e(#mainPanel).show(), 0 < a ? e(#overlays).fadeIn(a) : e(#overlays).show())    }
    function ka(a) {        e(#helloContainer).attr(data-gamemode, a);        Ca = a;        e(#gamemode).val(a)    }
    function Qb() {        e(#region).val() ? c.localStorage.location = e(#region).val() : c.localStorage.location && e(#region).val(c.localStorage.location);        e(#region).val() ? e(#locationKnown).append(e(#region)) : e(#locationUnknown).append(e(#region))    }
    function cb(a) {        env_local in EnvConfig ? true == EnvConfig.load_local_configuration ? c.MC.updateConfigurationID(base) : c.MC.updateConfigurationID(EnvConfig.configID) : c.MC.updateConfigurationID(a)    }
    function yc() {        configID in E ? cb(E.configID) : e.get(ya + getLatestID, function(a) {            cb(a);            c.localStorage.last_config_id = a        }).fail(function() {            var a;            if (a = last_config_id in c.localStorage) a = c.localStorage.last_config_id, a = !(null == a || void 0 == a ||  === a);            a && (a = c.localStorage.last_config_id, window.log(Fallback to stored configID:  + a), cb(a))        })    }
    function zc() {        e.get(db + //gc.agar.io, function(a) {            var b = a.split( );            a = b[0];            b = b[1] || ; - 1 == [UA].indexOf(a) && Rb.push(ussr);            la.hasOwnProperty(a) && (string == typeof la[a] ? K || za(la[a]) : la[a].hasOwnProperty(b) && (K || za(la[a][b])))        }, text)    }
    function R(a) {        return c.i18n[a] || c.i18n_dict.en[a] || a    }
    function Sb() {        var a = ++eb;        Tb();        e.ajax(ya + findServer, {            error: function() {                window.log(Failed to get server. Will retry in 30 seconds);                setTimeout(Sb, 3E4)            },            success: function(b) {                if (a == eb) {                    b.alert && alert(b.alert);                    var d = b.ip;                    game_server_port in EnvConfig && (d = c.location.hostname + : + EnvConfig.game_server_port);                    fb(ws + (gb ? s : ) + :// + d, b.token)                }            },            dataType: json,            method: POST,            cache: !1,            crossDomain: !0,            data: (K + Ca || ?) + 154669603        })    }
    function Q() {        ab && K && (e(#connecting).show(), Sb())    }
    function Tb() {        if (x) {            x.onopen = null;            x.onmessage = null;            x.onclose = null;            try {                x.close()            } catch (a) {}            x = null        }    }
    function fb(a, b) {        Tb();        E.ip && (a = ws + (gb ? s : ) + :// + E.ip);        if (null != S) {            var d = S;            S = function() {                d(b)            }        }        if (gb && !EnvConfig.env_development && !EnvConfig.env_local) {            var c = a.split(:);            a = wss://ip- + c[1].replace(g, -).replace(g, ) + .tech.agar.io: + +c[2]        }        G = [];        t = [];        L = {};        z = [];        ba = [];        D = [];        H = I = null;        T = 0;        ma = !1;        m.cache.sentGameServerLogin = !1;        UPDATE        window.log(Connecting to  + a);        serverIP = a;        x = new WebSocket(a);        x.binaryType = arraybuffer;        x.onopen = function() {            var a;            Da = y = Date.now();            na = 120;            Ea = 0;            window.log(socket open);            a = U(5);            a.setUint8(0, 254);            a.setUint32(1, 5, !0);            V(a);            a = U(5);            a.setUint8(0, 255);            a.setUint32(1, 154669603, !0);            V(a);            a = U(1 + b.length);            a.setUint8(0, 80);            for (var d = 0; d < b.length; ++d) a.setUint8(d + 1, b.charCodeAt(d));            V(a);            m.core.proxy.onSocketOpen()        };        x.onmessage = Ac;        x.onclose = Bc;        x.onerror = function() {            window.log(hb.la() +  socket error, arguments)        }    }
    function U(a) {        return new DataView(new ArrayBuffer(a))    }
    function V(a) {        x.send(a.buffer)    }
    function Bc() {        ma && (Fa = 500);        m.core.proxy.onSocketClosed();        window.log(hb.la() +  socket close);        setTimeout(Q, Fa);        Fa *= 2    }
    function Ac(a) {        Cc(new DataView(a.data))    }
    function Cc(a) {        function b() {            for (var b = ;;) {                var c = a.getUint16(d, !0);                d += 2;                if (0 == c) break;                b += String.fromCharCode(c)            }            return b        }        var d = 0;        if (240 == a.getUint8(d)) Ga();        else switch (a.getUint8(d++)) {            case 16:                Dc(a, d);                break;            case 17:                ib = a.getFloat32(d, !0);                d += 4;                jb = a.getFloat32(d, !0);                d += 4;                kb = a.getFloat32(d, !0);                d += 4;                break;            case 18:                G = [];                t = [];                L = {};                z = [];                break;            case 20:                t = [];                G = [];                break;            case 21:                lb = a.getInt16(d, !0);                d += 2;                mb = a.getInt16(d, !0);                d += 2;                nb || (nb = !0, Ha = lb, Ia = mb);                break;            case 32:                G.push(a.getUint32(d, !0));                d += 4;                break;            case 49:                if (null != I) break;                var v = a.getUint32(d, !0),                    d = d + 4;                D = [];                for (var g = 0; g < v; ++g) {                    var e = a.getUint32(d, !0),                        d = d + 4;                    D.push({                        id: e,                        name: b()                    })                }                Ub();                break;            case 50:                I = [];                v = a.getUint32(d, !0);                d += 4;                for (g = 0; g < v; ++g) I.push(a.getFloat32(d, !0)), d += 4;                Ub();                break;            case 64:                ob = a.getFloat64(d, !0);                d += 8;                pb = a.getFloat64(d, !0);                d += 8;                qb = a.getFloat64(d, !0);                d += 8;                rb = a.getFloat64(d, !0);                d += 8;                a.byteLength > d && (v = a.getUint32(d, !0), d += 4, sb = !!(v & 1), tb = b(), c.MC.updateServerVersion(tb), window.log(Server version  + tb));                break;            case 102:                v = a.buffer.slice(d);                m.core.proxy.forwardProtoMessage(v);                break;            case 104:                c.logout()        }    }
    function Dc(a, b) {        function d() {            for (var d = ;;) {                var c = a.getUint16(b, !0);                b += 2;                if (0 == c) break;                d += String.fromCharCode(c)            }            return d        }
        function v() {            for (var d = ;;) {                var c = a.getUint8(b++);                if (0 == c) break;                d += String.fromCharCode(c)            }            return d        }        y = Date.now();        var g = y - Da;        Da = y;        na = Ec * na + Fc * g;        Ea = Gc * Ea + Hc * Math.abs(g - na);        m.core.debug && (m.debug.updateChart(networkUpdate, y, g), m.debug.updateChart(rttMean, y, na), m.debug.updateChart(rttSDev, y, Ea));        ma || (ma = !0, e(#connecting).hide(), Vb(), S && (S(), S = null));        ub = !1;        g = a.getUint16(b, !0);        b += 2;        for (var p = 0; p < g; ++p) {            var M = L[a.getUint32(b, !0)],                l = L[a.getUint32(b + 4, !0)];            b += 8;            M && l && (l.ca(), l.s = l.x, l.u = l.y, l.o = l.size, l.pa(M.x, M.y), l.g = l.size, l.T = y, Ic(M, l))        }        for (p = 0;;) {            g = a.getUint32(b, !0);            b += 4;            if (0 == g) break;            ++p;            var vb, M = a.getInt32(b, !0);            b += 4;            l = a.getInt32(b, !0);            b += 4;            vb = a.getInt16(b, !0);            b += 2;            var n = a.getUint8(b++),                f = a.getUint8(b++),                h = a.getUint8(b++),                f = Jc(n << 16 | f << 8 | h),                h = a.getUint8(b++),                k = !!(h & 1),                r = !!(h & 16),                q = null;            h & 2 && (b += 4 + a.getUint32(b, !0));            h & 4 && (q = v());            var u = d(),                n = null;            L.hasOwnProperty(g) ? (n = L[g], n.S(), n.s = n.x, n.u = n.y, n.o = n.size, n.color = f) : (n = new ca(g, M, l, vb, f, u), z.push(n), L[g] = n);            n.c = k;            n.h = r;            n.pa(M, l);            n.g = vb;            n.T = y;            n.ea = h;            q && (n.C = q);            UPDATE            u && n.A(u); - 1 != G.indexOf(g) && -1 == t.indexOf(n) && (t.push(n), n.birth = getLastUpdate(), n.birthMass = (n.size * n.size / 100), n.I = !0, 1 == t.length && (n.wa = !0, A = n.x, B = n.y, Wb(), document.getElementById(overlays).style.display = none, F = [], wb = 0, xb = t[0].color, Aa = !0, Ja = Date.now(), W = yb = zb = 0))                UPDATE            interNodes[g] = window.getCells()[g];        }        UPDATE        Object.keys(interNodes).forEach(function(element, index) {            window.log(""start: "" + interNodes[element].updateTime + "" current: "" + h.detail + "" life: "" + (h.detail - interNodes[element].updateTime));            var isRemoved = !window.getCells().hasOwnProperty(element);
            window.log(""Time not updated: "" + (window.getLastUpdate() - interNodes[element].getUptimeTime()));            if (isRemoved && (window.getLastUpdate() - interNodes[element].getUptimeTime()) > 3000) {                delete interNodes[element];            } else {                if (isRemoved &&                    interNodes[element].x > (getX() - (1920 / 2) / getZoomlessRatio()) &&                    interNodes[element].x < (getX() + (1920 / 2) / getZoomlessRatio()) &&                    interNodes[element].y > getY() - (1080 / 2) / getZoomlessRatio() &&                    interNodes[element].y < getY() + (1080 / 2) / getZoomlessRatio()) {
                    delete interNodes[element];                }            }        });        M = a.getUint32(b, !0);        b += 4;        for (p = 0; p < M; p++) g = a.getUint32(b, !0), b += 4, n = L[g], null != n && n.ca();        ub && 0 == t.length && (0 == c.MC.isUserLoggedIn() ? Ga() : Xb = setTimeout(Ga, 2E3))    }
    UPDATE    function computeDistance(x1, y1, x2, y2) {        var xdis = x1 - x2;  <--- FAKE AmS OF COURSE!        var ydis = y1 - y2;        var distance = Math.sqrt(xdis * xdis + ydis * ydis);
        return distance;    }    UPDATE    /**     * Some horse shit of some sort.     *  Horse Shit     */    function screenDistance() {        return Math.min(computeDistance(getOffsetX(), getOffsetY(), screenToGameX(getWidth()), getOffsetY()), computeDistance(getOffsetX(), getOffsetY(), getOffsetX(), screenToGameY(getHeight())));    }
    window.verticalDistance = function() {        return computeDistance(screenToGameX(0), screenToGameY(0), screenToGameX(getWidth()), screenToGameY(getHeight()));    }
    /**     * A conversion from the screen's horizontal coordinate system     * to the game's horizontal coordinate system.     *   in the screen's coordinate system     *  x in the game's coordinate system     */    window.screenToGameX = function(x) {        return (x - getWidth() / 2) / getRatio() + getX();    }
    /**     * A conversion from the screen's vertical coordinate system     * to the game's vertical coordinate system.     *   in the screen's coordinate system     *  y in the game's coordinate system     */    window.screenToGameY = function(y) {        return (y - getHeight() / 2) / getRatio() + getY();    }
    window.drawPoint = function(x_1, y_1, drawColor, text) {        if (!toggleDraw) {            dPoints.push([x_1, y_1, drawColor]);            dText.push(text);        }    }
    window.drawArc = function(x_1, y_1, x_2, y_2, x_3, y_3, drawColor) {        if (!toggleDraw) {            var radius = computeDistance(x_1, y_1, x_3, y_3);            dArc.push([x_1, y_1, x_2, y_2, x_3, y_3, radius, drawColor]);        }    }
    window.drawLine = function(x_1, y_1, x_2, y_2, drawColor) {        if (!toggleDraw) {            lines.push([x_1, y_1, x_2, y_2, drawColor]);        }    }
    window.drawCircle = function(x_1, y_1, radius, drawColor) {        if (!toggleDraw) {            circles.push([x_1, y_1, radius, drawColor]);        }    }
    function Ka() {        UPDATE        if (firstStart) {            Uc(false);        }
        if (getPlayer().length == 0 && !reviving && ~~(getCurrentScore() / 100) > 0) {            window.log(Dead:  + ~~(getCurrentScore() / 100));            apos(send, pageview);        }
        if (getPlayer().length == 0 && !firstStart) {            window.log(Revive);            setNick(originalName);            reviving = true;        } else if (getPlayer().length > 0 && reviving) {            reviving = false;            window.log(Done Reviving!);        }
        if (da()) {            var a = Y - q / 2,                b = Z - u / 2;            64 > a * a + b * b || .01 > Math.abs(Yb - va) && .01 > Math.abs(Zb - wa) || (Yb = va, Zb = wa, a = U(13), a.setUint8(0, 16), a.setInt32(1, va, !0), a.setInt32(5, wa, !0), a.setUint32(9, 0, !0), V(a))        }    }
    function Vb() {        if (da() && ma && null != N) {            var a = U(1 + 2 * N.length);            a.setUint8(0, 0);            for (var b = 0; b < N.length; ++b) a.setUint16(1 + 2 * b, N.charCodeAt(b), !0);            V(a);            N = null;            Ba = !0        }    }
    function Za() {        Ka();        X(17)    }
    function Mb() {        Ka();        X(21)    }
    function da() {        return null != x && x.readyState == x.OPEN    }
    function X(a) {        if (da()) {            var b = U(1);            b.setUint8(0, a);            V(b)        }    }
    function Kc(a) {        auto == a.toLowerCase() ? h.auto = !0 : (m.renderSettings.selected = m.renderSettings[a.toLowerCase()], h.auto = !1)    }
    function $b() {        q = 1 * c.innerWidth;        u = 1 * c.innerHeight;        Ab.width = O.width = q;        Ab.height = O.height = u;        var a = e(#helloContainer);        a.css(transform, none);        var b = a.height(),            d = c.innerHeight;        0 != b / 2 % 2 && (b++, a.height(b));        b > d / 1.1 ? a.css(transform, translate(-50%, -50%) scale( + d / b / 1.1 + )) : a.css(transform, translate(-50%, -50%));        ac()    }
    function bc() {        var a;        a = 1 * Math.max(u / 1080, q / 1920);        return a *= P    }
    UPDATE    function bc2() {        var a;        a = 1 * Math.max(u / 1080, q / 1920);        return a;    }
    function Lc() {        if (0 != t.length) {            for (var a = 0, b = 0; b < t.length; b++) a += t[b].size;            r = (9 * r + Math.pow(Math.min(64 / a, 1), .4) * bc()) /                10;            UPDATE            var r2 = (9 * r + Math.pow(Math.min(64 / a, 1), .4) * bc2()) / 10;        }    }
    function ac() {        UPDATE        window.log(Update rendering);        dPoints = [];        circles = [];        dArc = [];        dText = [];        lines = [];        var a, b = Date.now();        ++Mc;        cc && (++La, 180 < La && (La = 0));        y = b;        if (0 < t.length) {            Lc();            for (var d = a = 0, c = 0; c < t.length; c++) t[c].S(), a += t[c].x / t.length, d += t[c].y / t.length;            ib = a;            jb = d;            kb = r;            A = (A + a) / 2;            B = (B + d) / 2                UPDATE        } else A = (5 * A + ib) / 6, B = (5 * B + jb) / 6, r = (9 * r + kb * bc()) / 10, r2 = (9 * r + kb * bc2()) / 10;        wc();        $a();        Bb || f.clearRect(0, 0, q, u);        Bb ? (f.fillStyle = ea ? #111111 : #F2FBFF, f.globalAlpha = .05, f.fillRect(0, 0, q, u), f.globalAlpha = 1) : Nc();        z.sort(function(a, b) {            return a.size == b.size ? a.id - b.id : a.size - b.size        });        f.save();        f.translate(q / 2, u / 2);        f.scale(r, r);        f.translate(-A, -B);        UPDATE        f.save();        f.beginPath();        f.lineWidth = 5;        f.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);        f.moveTo(getMapStartX(), getMapStartY());        f.lineTo(getMapStartX(), getMapEndY());        f.stroke();        f.moveTo(getMapStartX(), getMapStartY());        f.lineTo(getMapEndX(), getMapStartY());        f.stroke();        f.moveTo(getMapEndX(), getMapStartY());        f.lineTo(getMapEndX(), getMapEndY());        f.stroke();        f.moveTo(getMapStartX(), getMapEndY());        f.lineTo(getMapEndX(), getMapEndY());        f.stroke();        f.restore();        for (c = 0; c < ba.length; c++) ba[c].w(f);        for (c = 0; c < z.length; c++) z[c].w(f);        UPDATE        if (getPlayer().length > 0) {            var moveLoc = window.botList[botIndex].mainLoop();            if (!toggle) {                setPoint(moveLoc[0], moveLoc[1]);            }        }        customRender(f);        if (nb) {            Ha = (3 * Ha + lb) / 4;            Ia = (3 * Ia + mb) / 4;            f.save();            f.strokeStyle = #FFAAAA;            f.lineWidth = 10;            f.lineCap = round;            f.lineJoin = round;            f.globalAlpha = .5;            f.beginPath();            for (c = 0; c < t.length; c++) f.moveTo(t[c].x, t[c].y), f.lineTo(Ha, Ia);            f.stroke();            f.restore()        }        f.restore();        H && H.width && f.drawImage(H, q - H.width - 10, 10);        T = Math.max(T, dc());        UPDATE
        var currentDate = new Date();
        var nbSeconds = 0;        if (getPlayer().length > 0) {            nbSeconds = currentDate.getSeconds() + currentDate.getMinutes() * 60 + currentDate.getHours() * 3600 - lifeTimer.getSeconds() - lifeTimer.getMinutes() * 60 - lifeTimer.getHours() * 3600;            nbSeconds = (currentDate.getTime() - lifeTimer.getTime()) / 1000;        }
        bestTime = Math.max(nbSeconds, bestTime);
        var displayText = Score:  + ~~(T / 100) +  Current Time:  + nbSeconds +  seconds.;
        0 != T && (null == Ma && (Ma = new Na(24, #FFFFFF)), Ma.B(displayText), d = Ma.N(), a = d.width, f.globalAlpha =            .2, f.fillStyle = #000000, f.fillRect(10, u - 10 - 24 - 10, a + 10, 34), f.globalAlpha = 1, f.drawImage(d, 15, u - 10 - 24 - 5));        Oc();        b = Date.now() - b;        b > 1E3 / 60 ? h.detail -= .01 : b < 1E3 / 65 && (h.detail += .001);        h.detail < h.selected.minDetail && (h.auto && h.downgrade(), h.detail = h.selected.minDetail);        h.detail > h.selected.maxDetail && (h.auto && h.upgrade(), h.detail = h.selected.maxDetail);        b = y - ec;        !da() || ja || aa ? (C += b / 2E3, 1 < C && (C = 1)) : (C -= b / 300, 0 > C && (C = 0));        0 < C ? (f.fillStyle = #000000, fc ? (f.globalAlpha = C, f.fillRect(0, 0, q, u), J.complete && J.width && (J.width /            J.height < q / u ? (b = q, a = J.height * q / J.width) : (b = J.width * u / J.height, a = u), f.drawImage(J, (q - b) / 2, (u - a) / 2, b, a), f.globalAlpha = .5 * C, f.fillRect(0, 0, q, u))) : (f.globalAlpha = .5 * C, f.fillRect(0, 0, q, u)), f.globalAlpha = 1) : fc = !1;        h.selected.ma && Ba && (Oa++, Oa > 10 * h.selected.warnFps ? (h.selected.ma = !1, Oa = -1, Pa = 0) : Pc());        ec = y            UPDATE        drawStats(f);    }    UPDATE    function customRender(d) {        d.save();        for (var i = 0; i < lines.length; i++) {            d.beginPath();
            d.lineWidth = 5;
            if (lines[i][4] == 0) {                d.strokeStyle = #FF0000;            } else if (lines[i][4] == 1) {                d.strokeStyle = #00FF00;            } else if (lines[i][4] == 2) {                d.strokeStyle = #0000FF;            } else if (lines[i][4] == 3) {                d.strokeStyle = #FF8000;            } else if (lines[i][4] == 4) {                d.strokeStyle = #8A2BE2;            } else if (lines[i][4] == 5) {                d.strokeStyle = #FF69B4;            } else if (lines[i][4] == 6) {                d.strokeStyle = #008080;            } else if (lines[i][4] == 7) {                d.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);            } else {                d.strokeStyle = #000000;            }
            d.moveTo(lines[i][0], lines[i][1]);            d.lineTo(lines[i][2], lines[i][3]);
            d.stroke();        }        d.restore();        d.save();        for (var i = 0; i < circles.length; i++) {            if (circles[i][3] == 0) {                d.strokeStyle = #FF0000;            } else if (circles[i][3] == 1) {                d.strokeStyle = #00FF00;            } else if (circles[i][3] == 2) {                d.strokeStyle = #0000FF;            } else if (circles[i][3] == 3) {                d.strokeStyle = #FF8000;            } else if (circles[i][3] == 4) {                d.strokeStyle = #8A2BE2;            } else if (circles[i][3] == 5) {                d.strokeStyle = #FF69B4;            } else if (circles[i][3] == 6) {                d.strokeStyle = #008080;            } else if (circles[i][3] == 7) {                d.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);            } else {                d.strokeStyle = #000000;            }            d.beginPath();
            d.lineWidth = 10;            d.setLineDash([5]);            d.globalAlpha = 0.3;
            d.arc(circles[i][0], circles[i][1], circles[i][2], 0, 2 * Math.PI, false);
            d.stroke();        }        d.restore();        d.save();        for (var i = 0; i < dArc.length; i++) {            if (dArc[i][7] == 0) {                d.strokeStyle = #FF0000;            } else if (dArc[i][7] == 1) {                d.strokeStyle = #00FF00;            } else if (dArc[i][7] == 2) {                d.strokeStyle = #0000FF;            } else if (dArc[i][7] == 3) {                d.strokeStyle = #FF8000;            } else if (dArc[i][7] == 4) {                d.strokeStyle = #8A2BE2;            } else if (dArc[i][7] == 5) {                d.strokeStyle = #FF69B4;            } else if (dArc[i][7] == 6) {                d.strokeStyle = #008080;            } else if (dArc[i][7] == 7) {                d.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);            } else {                d.strokeStyle = #000000;            }
            d.beginPath();
            d.lineWidth = 5;
            var ang1 = Math.atan2(dArc[i][1] - dArc[i][5], dArc[i][0] - dArc[i][4]);            var ang2 = Math.atan2(dArc[i][3] - dArc[i][5], dArc[i][2] - dArc[i][4]);
            d.arc(dArc[i][4], dArc[i][5], dArc[i][6], ang1, ang2, false);
            d.stroke();        }        d.restore();        d.save();        for (var i = 0; i < dPoints.length; i++) {            if (dText[i] == ) {                var radius = 10;
                d.beginPath();                d.arc(dPoints[i][0], dPoints[i][1], radius, 0, 2 * Math.PI, false);
                if (dPoints[i][2] == 0) {                    d.fillStyle = black;                } else if (dPoints[i][2] == 1) {                    d.fillStyle = yellow;                } else if (dPoints[i][2] == 2) {                    d.fillStyle = blue;                } else if (dPoints[i][2] == 3) {                    d.fillStyle = red;                } else if (dPoints[i][2] == 4) {                    d.fillStyle = #008080;                } else if (dPoints[i][2] == 5) {                    d.fillStyle = #FF69B4;                } else {                    d.fillStyle = #000000;                }
                d.fill();                d.lineWidth = 2;                d.strokeStyle = #003300;                d.stroke();            } else {                var text = new Na(18, (getDarkBool() ? #F2FBFF : #111111), true, (getDarkBool() ? #111111 : #F2FBFF));
                text.B(dText[i]);                var textRender = text.N();                d.drawImage(textRender, dPoints[i][0] - (textRender.width / 2), dPoints[i][1] - (textRender.height / 2));            }
        }        d.restore();    }    UPDATE    function drawStats(d) {        d.save()
        sessionScore = Math.max(getCurrentScore(), sessionScore);
        var botString = window.botList[botIndex].displayText();
        var debugStrings = [];        debugStrings.push(Bot:  + window.botList[botIndex].name);        debugStrings.push(Launcher: AposLauncher  + aposLauncherVersion);        debugStrings.push(T - Bot:  + (!toggle ? On : Off));        debugStrings.push(R - Lines:  + (!toggleDraw ? On : Off));
        for (var i = 0; i < botString.length; i++) {            debugStrings.push(botString[i]);        }
        debugStrings.push();        debugStrings.push(Best Score:  + ~~(sessionScore / 100));        debugStrings.push(Best Time:  + bestTime +  seconds);        debugStrings.push();        debugStrings.push(serverIP);
        if (getPlayer().length > 0) {            var offsetX = -getMapStartX();            var offsetY = -getMapStartY();            debugStrings.push(Location:  + Math.floor(getPlayer()[0].x + offsetX) + ,  + Math.floor(getPlayer()[0].y + offsetY));        }
        var offsetValue = 20;        var text = new Na(18, (getDarkBool() ? #F2FBFF : #111111));
        for (var i = 0; i < debugStrings.length; i++) {            text.B(debugStrings[i]);            var textRender = text.N();            d.drawImage(textRender, 20, offsetValue);            offsetValue += textRender.height;        }
        if (message.length > 0) {            var mRender = [];            var mWidth = 0;            var mHeight = 0;
            for (var i = 0; i < message.length; i++) {                var mText = new Na(28, #FF0000, true, #000000);                mText.B(message[i]);                mRender.push(mText.N());
                if (mRender[i].width > mWidth) {                    mWidth = mRender[i].width;                }                mHeight += mRender[i].height;            }
            var mX = getWidth() / 2 - mWidth / 2;            var mY = 20;
            d.globalAlpha = 0.4;            d.fillStyle = #000000;            d.fillRect(mX - 10, mY - 10, mWidth + 20, mHeight + 20);            d.globalAlpha = 1;
            var mOffset = mY;            for (var i = 0; i < mRender.length; i++) {                d.drawImage(mRender[i], getWidth() / 2 - mRender[i].width / 2, mOffset);                mOffset += mRender[i].height;            }        }
        d.restore();    }
    function Pc() {        var a = document.createElement(canvas),            b = a.getContext(2d),            d = Math.min(800, .6 * q) / 800;        a.width = 800 * d;        a.height = 60 * d;        b.globalAlpha = .3;        b.fillStyle = #000000;        b.fillRect(0, 0, 800, 60);        b.globalAlpha =            1;        b.fillStyle = #FFFFFF;        b.scale(d, d);        d = null;        d = Your computer is running slow,;        b.font = 18px Ubuntu;        b.fillText(d, 400 - b.measureText(d).width / 2, 25);        d = please close other applications or tabs in your browser for better game performance.;        b.fillText(d, 400 - b.measureText(d).width / 2, 45);        f.drawImage(a, (q - a.width) / 2, u - a.height - 10)    }
    function Nc() {        f.fillStyle = ea ? #111111 : #F2FBFF;        f.fillRect(0, 0, q, u);        f.save();        f.strokeStyle = ea ? #AAAAAA : #000000;        f.globalAlpha = .2 * r;        for (var a = q / r, b = u / r, d = (-A + a / 2) % 50; d < a; d += 50) f.beginPath(),            f.moveTo(d * r - .5, 0), f.lineTo(d * r - .5, b * r), f.stroke();        for (d = (-B + b / 2) % 50; d < b; d += 50) f.beginPath(), f.moveTo(0, d * r - .5), f.lineTo(a * r, d * r - .5), f.stroke();        f.restore()    }
    function Oc() {        if (gc && Cb.width) {            var a = q / 5;            f.drawImage(Cb, 5, 5, a, a)        }    }
    function dc() {        for (var a = 0, b = 0; b < t.length; b++) a += t[b].g * t[b].g;        return a    }
    function Ub() {        H = null;        if (null != I || 0 != D.length)            if (null != I || fa) {                H = document.createElement(canvas);                var a = H.getContext(2d),                    b = 60,                    b = null == I ? b + 24 * D.length : b + 180,                    d = Math.min(200, .3 * q) / 200;                H.width = 200 * d;                H.height = b * d;                a.scale(d, d);                a.globalAlpha = .4;                a.fillStyle = #000000;                a.fillRect(0, 0, 200, b);                a.globalAlpha = 1;                a.fillStyle = #FFFFFF;                d = null;                d = R(leaderboard);                a.font = 30px Ubuntu;                a.fillText(d, 100 - a.measureText(d).width / 2, 40);                var c, e;                if (null == I)                    for (a.font = 20px Ubuntu, b = 0; b < D.length; ++b) d = D[b].name || R(unnamed_cell), fa || (d = R(unnamed_cell)), 1 == D[b].id || -1 != G.indexOf(D[b].id) ? (t[0].name && (d = t[0].name), a.fillStyle = #FFAAAA) : a.fillStyle = #FFFFFF, d = b + 1 + .  + d, e = a.measureText(d).width, c = 70 + 24 * b, 200 < e ? a.fillText(d, 10, c) : a.fillText(d, (200 - e) / 2, c);                else                    for (b = d = 0; b < I.length; ++b) c = d + I[b] * Math.PI * 2, a.fillStyle = Qc[b + 1], a.beginPath(), a.moveTo(100, 140), a.arc(100, 140, 80, d, c, !1), a.fill(), d = c            }    }
    function Rc(a) {        if (null == a || 0 == a.length) return null;        if (% == a[0]) {            if (!c.MC || !c.MC.getSkinInfo) return null;            a = c.MC.getSkinInfo(skin_ + a.slice(1));            if (null == a) return null;            for (a = (+a.color).toString(16); 6 > a.length;) a = 0 + a;            return # + a        }        return null    }
    function hc(a) {        if (null == a || 0 == a.length) return null;        if (!oa.hasOwnProperty(a)) {            var b = new Image;            if (: == a[0]) b.src = a.slice(1);            else if (% == a[0]) {                if (!c.MC || !c.MC.getSkinInfo) return null;                var d = c.MC.getSkinInfo(skin_ + a.slice(1));                if (null == d) return null;                b.src = c.ASSETS_ROOT + d.url            }            oa[a] = b        }        return 0 != oa[a].width && oa[a].complete ? oa[a] : null    }
    function Db(a, b, d, c, e) {        this.$ = a;        this.x = b;        this.y = d;        this.f = c;        this.b = e    }
    function ca(a, b, d, c, e, p) {        this.id = a;        this.s = this.x = this.L = this.J = b;        this.u = this.y = this.M = this.K = d;        this.o = this.size = c;        this.color = e;        this.a = [];        this.ba();        this.A(p)    }
    function Jc(a) {        for (a = a.toString(16); 6 > a.length;) a = 0 + a;        return # + a    }
    function Na(a, b, d, c) {        a && (this.v = a);        b && (this.W = b);        this.Y = !!d;        c && (this.Z = c)    }
    function Sc(a) {        for (var b = a.length, d, c; 0 < b;) c = Math.floor(Math.random() * b), b--, d = a[b], a[b] = a[c], a[c] = d    }
    function Tc() {        k = Qa    }
    function ic(a) {        k.context = google == a ? google : facebook;        Ra()    }
    function Ra() {        c.localStorage.storeObjectInfo = JSON.stringify(k);        k = JSON.parse(c.localStorage.storeObjectInfo);        c.storageInfo = k;        google == k.context ? (e(#gPlusShare).show(), e(#fbShare).hide()) : (e(#gPlusShare).hide(), e(#fbShare).show())    }
    function jc(a) {        e(#helloContainer).attr(data-has-account-data);         != a.displayName && (a.name = a.displayName);        if (null == a.name || void 0 == a.name) a.name = ;        var b = a.name.lastIndexOf(_); - 1 != b && (a.name = a.name.substring(0, b));        e(#helloContainer).attr(data-has-account-data, 1);        e(#helloContainer).attr(data-logged-in, 1);        e(.agario-profile-panel .progress-bar-star).text(a.level);        e(.agario-exp-bar .progress-bar-text).text(a.xp + / + a.xpNeeded +  XP);        e(.agario-exp-bar .progress-bar).css(width, (88 * a.xp / a.xpNeeded).toFixed(2) + %);        e(.agario-profile-name).text(a.name);         != a.picture && e(.agario-profile-picture).attr(src, a.picture);        Eb();        k.userInfo.level = a.level;        k.userInfo.xp = a.xp;        k.userInfo.xpNeeded = a.xpNeeded;        k.userInfo.displayName = a.name;        k.userInfo.loggedIn = 1;        c.updateStorage()    }
    function ga(a, b) {        var d = a;        if (k.userInfo.loggedIn) {            var v = e(#helloContainer).is(:visible) && 1 == e(#helloContainer).attr(data-has-account-data);            if (null == d || void 0 == d) d = k.userInfo;            if (v) {                var g = +e(.agario-exp-bar .progress-bar-text).first().text().split(/)[0],                    v = +e(.agario-exp-bar .progress-bar-text).first().text().split(/)[1].split( )[0],                    p = e(.agario-profile-panel .progress-bar-star).first().text();                if (p != d.level) ga({                    xp: v,                    xpNeeded: v,                    level: p                }, function() {                    e(.agario-profile-panel .progress-bar-star).text(d.level);                    e(.agario-exp-bar .progress-bar).css(width, 100%);                    e(.progress-bar-star).addClass(animated tada).one(webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend, function() {                        e(.progress-bar-star).removeClass(animated tada)                    });                    setTimeout(function() {                        e(.agario-exp-bar .progress-bar-text).text(d.xpNeeded + / + d.xpNeeded +  XP);                        ga({                            xp: 0,                            xpNeeded: d.xpNeeded,                            level: d.level                        }, function() {                            ga(d)                        })                    }, 1E3)                });                else {                    var f = Date.now(),                        l = function() {                            var a;                            a = (Date.now() - f) / 1E3;                            a = 0 > a ? 0 : 1 < a ? 1 : a;                            a = a * a * (3 - 2 * a);                            e(.agario-exp-bar .progress-bar-text).text(~~(g + (d.xp - g) * a) + / + d.xpNeeded +  XP);                            e(.agario-exp-bar .progress-bar).css(width, (88 * (g + (d.xp - g) * a) / d.xpNeeded).toFixed(2) + %);                            b && b();                            1 > a && c.requestAnimationFrame(l)                        };                    c.requestAnimationFrame(l)                }            }        }    }
    function Eb() {        var a;        (undefined !== typeof a && a || none == e(#settings).css(display) && none == e(#socialLoginContainer).css(display)) && e(#instructions).show()    }
    function kc(a) {        if (connected == a.status) {            var b = a.authResponse.accessToken;            null == b || undefined == b ||  == b ? (3 > lc && (lc++, c.facebookRelogin()), c.logout()) : (c.MC.doLoginWithFB(b), m.cache.login_info = [b, facebook], c.FB.api(/me/picture?width=180&height=180, function(b) {                k.userInfo.picture = b.data.url;                c.updateStorage();                e(.agario-profile-picture).attr(src, b.data.url);                k.userInfo.socialId = a.authResponse.userID;                Sa()            }), e(#helloContainer).attr(data-logged-in, 1), k.context = facebook, k.loginIntent = 1, c.updateStorage())        }    }
    function mc(a) {        ka(:party);        e(#helloContainer).attr(data-party-state, 4);        a = decodeURIComponent(a).replace(#gim, );        Fb(# + c.encodeURIComponent(a));        e.ajax(ya + getToken, {            error: function() {                e(#helloContainer).attr(data-party-state, 6)            },            success: function(b) {                b = b.split();                e(.partyToken).val(agar.io/# + c.encodeURIComponent(a));                e(#helloContainer).attr(data-party-state, 5);                ka(:party);                fb(ws:// + b[0], a)            },            dataType: text,            method: POST,            cache: !1,            crossDomain: !0,            data: a        })    }
    function Fb(a) {        c.history && c.history.replaceState && c.history.replaceState({}, c.document.title, a)    }
    function Ga() {        Ba = !1;        clearTimeout(Xb);        null == c.storageInfo && c.createDefaultStorage();        Gb = Date.now();        0 >= Ja && (Ja = Gb);        Aa = !1;        Uc()    }
    function Ic(a, b) {        var d = -1 != G.indexOf(a.id),            c = -1 != G.indexOf(b.id),            e = 30 > b.size;        d && e && ++wb;        e || !d || c || b.ea & 32 || ++yb    }
    function nc(a) {        a = ~~a;        var b = (a % 60).toString();        a = (~~(a / 60)).toString();        2 > b.length && (b = 0 + b);        return a + : + b    }
    function Vc() {        if (null == D) return 0;        for (var a = 0; a < D.length; ++a)            if (D[a].id & 1) return a + 1;        return 0    }
    function Wc() {        e(.stats-food-eaten).text(wb);        e(.stats-time-alive).text(nc((Gb - Ja) / 1E3));        e(.stats-leaderboard-time).text(nc(zb));        e(.stats-highest-mass).text(~~(T / 100));        e(.stats-cells-eaten).text(yb);        e(.stats-top-position).text(0 == W ? :( : W);        var a = document.getElementById(statsGraph);        if (a) {            var b = a.getContext(2d),                d = a.width,                a = a.height;            b.clearRect(0, 0, d, a);            if (2 < F.length) {                for (var c = 200, g = 0; g < F.length; g++) c = Math.max(F[g], c);                b.lineWidth = 3;                b.lineCap = round;                b.lineJoin = round;                b.strokeStyle = xb;                b.fillStyle = xb;                b.beginPath();                b.moveTo(0, a - F[0] / c * (a - 10) + 10);                for (g = 1; g < F.length; g += Math.max(~~(F.length / d), 1)) {                    for (var p = g / (F.length - 1) * d, f = [], l = -20; 20 >= l; ++l) 0 > g + l || g + l >= F.length || f.push(F[g + l]);                    f = f.reduce(function(a, b) {                        return a + b                    }) / f.length / c;                    b.lineTo(p, a - f * (a - 10) + 10)                }                b.stroke();                b.globalAlpha = .5;                b.lineTo(d, a);                b.lineTo(0, a);                b.fill();                b.globalAlpha = 1            }        }    }
    function Uc() {        ja || aa || (Ta ? (c.refreshAd(c.adSlots.ab), Wc(), aa = !0, setTimeout(function() {            e(#overlays).fadeIn(500, function() {                ga()            });            e(#stats).show();            var a = oc(g_plus_share_stats);            c.fillSocialValues(a, gPlusShare)        }, 1500)) : ua(500))    }
    function oc(a) {        var b = e(.stats-time-alive).text();        return c.parseString(a, %@, [b.split(:)[0], b.split(:)[1], e(.stats-highest-mass).text()])    }
    function Xc() {        c.open(https://plus.google.com/share?url=www.agar.io&hl=en-US, Agar.io, width=484,height=580,menubar=no,toolbar=no,resizable=yes,scrollbars=no,left= +            (c.screenX + c.innerWidth / 2 - 242) + ,top= + (c.innerHeight - 580) / 2)    }    var pc = document.createElement(canvas);    if (undefined == typeof console || undefined == typeof DataView || undefined == typeof WebSocket || null == pc || null == pc.getContext || null == c.localStorage) alert(You browser does not support this game, we recommend you to use Firefox to play this);    else {        var E = {};        (function() {            var a = c.location.search;            ? == a.charAt(0) && (a = a.slice(1));            for (var a = a.split(&), b = 0; b < a.length; b++) {                var d = a[b].split(=);                E[d[0]] = d[1]            }        })();        c.queryString = E;        var qc = fb in E,            Yc = miniclip in E,            w = {                skinsEnabled: 0,                namesEnabled: 0,                noColors: 0,                blackTheme: 0,                showMass: 0,                statsEnabled: 0            },            Zc = function() {                qa(, -1)            },            rc = http: != c.location.protocol,            $c = 1 == vc(),            sc = !1;        qc || Yc || (rc && !$c ? (qa(1, 1), c.location.href = http: + c.location.href.substring(c.location.protocol.length), sc = !0) : qa(, -1));        rc || qa(, -1);        sc || setTimeout(Zc, 3E3);        if (!c.agarioNoInit) {            var db = c.location.protocol,                gb = https: == db;            E.master && (EnvConfig.master_url = E.master);            var ya = db + // +                EnvConfig.master_url + /,                Ua = c.navigator.userAgent;            if (-1 != Ua.indexOf(Android)) c.ga && c.ga(send, event, MobileRedirect, PlayStore), setTimeout(function() {                c.location.href = https://play.google.com/store/apps/details?id=com.miniclip.agar.io            }, 1E3);            else if (-1 != Ua.indexOf(iPhone) || -1 != Ua.indexOf(iPad) || -1 != Ua.indexOf(iPod)) c.ga && c.ga(send, event, MobileRedirect, AppStore), setTimeout(function() {                c.location.href = https://itunes.apple.com/app/agar.io/id995999703?mt=8&at=1l3vajp            }, 1E3);            else {                var m = {};                c.agarApp = m;                var Ab, f, O, q, u, ia = null,                    UPDATE                    toggle = false,                    toggleDraw = false,                    shootTime = 0,                    splitTime = 0,                    shootCooldown = 100,                    splitCooldown = 100,                    tempPoint = [0, 0, 1],                    dPoints = [],                    circles = [],                    dArc = [],                    dText = [],                    lines = [],                    names = [NotReallyABot],                    firstStart = true;                originalName = names[Math.floor(Math.random() * names.length)],                    sessionScore = 0,                    serverIP = ,                    interNodes = [],                    lifeTimer = new Date(),                    bestTime = 0,                    botIndex = 0,                    reviving = false,                    message = [],
                    x = null,                    A = 0,                    B = 0,                    G = [],                    t = [],                    L = {},                    z = [],                    ba = [],                    D = [],                    Y = 0,                    Z = 0,                    va = -1,                    wa = -1,                    Mc = 0,                    y = 0,                    ec = 0,                    N = null,                    ob = 0,                    pb = 0,                    qb = 1E4,                    rb = 1E4,                    r = 1,                    K = null,                    Va = !0,                    fa = !0,                    pa = !1,                    ub = !1,                    T = 0,                    ea = !1,                    Wa = !1,                    ib = A = ~~((ob + qb) / 2),                    jb = B = ~~((pb + rb) / 2),                    kb = 1,                    Ca = ,                    I = null,                    ab = !1,                    nb = !1,                    lb = 0,                    mb = 0,                    Ha = 0,                    Ia = 0,                    Qc = [#333333, #FF3333, #33FF33, #3333FF],                    Bb = !1,                    ma = !1,                    Da = 0,                    P = 1,                    C = 1,                    ja = !1,                    eb = 0,                    fc = !0,                    tb = null,                    sb = !1,                    J = new Image;                J.src = /img/background.png;                var gc = ontouchstart in c && AndroidwebOSiPhoneiPadiPodBlackBerryIEMobileOpera Minii.test(c.navigator.userAgent),                    Cb = new Image;                Cb.src = /img/split.png;                var ra = !1,                    sa = !1,                    ta = !1,                    Xa = !1,                    Hb, Ib;                gamepad in E && setInterval(function() {                    Xa && (Y = Ya.ha(Y, Hb), Z = Ya.ha(Z, Ib))                }, 25);                c.gamepadAxisUpdate = function(a, b) {                    var d = .1 > b * b;                    0 == a && (d ? Hb = q / 2 : (Hb = (b + 1) / 2 * q, Xa = !0));                    1 == a && (d ? Ib = u / 2 : (Ib = (b + 1) / 2 * u, Xa = !0))                };                c.agarioInit = function() {                    ab = !0;                    zc();                    yc();                    m.core.init();                    null != c.localStorage.settings && (w = JSON.parse(c.localStorage.settings), Wa = w.showMass, ea = w.blackTheme, fa = w.namesEnabled, pa = w.noColors, Ta = w.statsEnabled, Va = w.skinsEnabled);                    e(#showMass).prop(checked,                        w.showMass);                    e(#noSkins).prop(checked, !w.skinsEnabled);                    e(#skipStats).prop(checked, !w.statsEnabled);                    e(#noColors).prop(checked, w.noColors);                    e(#noNames).prop(checked, !w.namesEnabled);                    e(#darkTheme).prop(checked, w.blackTheme);                    Ob();                    setInterval(Ob, 18E4);                    O = Ab = document.getElementById(canvas);                    null != O && (f = O.getContext(2d), O.onmousedown = function(a) {                        if (gc) {                            var b = a.clientX - (5 + q / 5 / 2),                                d = a.clientY - (5 + q / 5 / 2);                            if (Math.sqrt(b * b + d * d) <= q / 5 / 2) {                                Za();                                return                            }                        }                        Y = 1 * a.clientX;                        Z = 1 * a.clientY;                        $a();                        Ka()                    }, O.onmousemove = function(a) {                        Xa = !1;                        Y = 1 * a.clientX;                        Z = 1 * a.clientY;                        $a()                    }, O.onmouseup = function() {}, firefoxi.test(navigator.userAgent) ? document.addEventListener(DOMMouseScroll, Nb, !1) : document.body.onmousewheel = Nb, c.onblur = function() {                        X(19);                        ta = sa = ra = !1                    }, c.onresize = $b, c.requestAnimationFrame(tc), setInterval(Ka, 40), K && e(#region).val(K), Qb(), za(e(#region).val()), 0 == eb && K && Q(), ua(0), $b(), c.location.hash && 6 <= c.location.hash.length && mc(c.location.hash))                };                var xa = null;                c.setNick = function(a) {                    UPDATE                    firstStart = false;                    originalName = a;                    if (getPlayer().length == 0) {                        lifeTimer = new Date();                    }
                    c.ga && c.ga(send, event, Nick, a.toLowerCase());                    Pb();                    N = a;                    Vb();                    T = 0;                    w.skinsEnabled = Va;                    w.namesEnabled = fa;                    w.noColors = pa;                    w.blackTheme = ea;                    w.showMass = Wa;                    w.statsEnabled = Ta;                    c.localStorage.settings = JSON.stringify(w);                    Lb()                };                c.setSkins = function(a) {                    Va = a                };                c.setNames = function(a) {                    fa = a                };                c.setDarkTheme = function(a) {                    ea = a                };                c.setColors = function(a) {                    pa = a                };                c.setShowMass = function(a) {                    Wa = a                };                c.spectate = function() {                    N = null;                    Lb();                    X(1);                    Pb()                };                c.setRegion = za;                var bb = !0;                c.setGameMode = function(a) {                    a != Ca && (:party == Ca && e(#helloContainer).attr(data-party-state, 0), ka(a), :party != a && Q())                };                c.setAcid = function(a) {                    Bb = a                };                var ad = function(a) {                    var b = {},                        d = !1,                        v = {                            skipDraw: !0,                            predictionModifier: 1.1                        };                    a.init = function() {                        m.account.init();                        m.google.xa();                        m.fa.init();                        (d = debug in c.queryString) && m.debug.showDebug()                    };                    a.bind = function(a, d) {                        e(b).bind(a, d)                    };                    a.unbind = function(a, d) {                        e(b).unbind(a, d)                    };                    a.trigger = function(a, d) {                        e(b).trigger(a, d)                    };                    a.__defineGetter__(debug, function() {                        return d                    });                    a.__defineSetter__(debug, function(a) {                        return d = a                    });                    a.__defineGetter__(proxy, function() {                        return c.MC                    });                    a.__defineGetter__(config, function() {                        return v                    });                    return a                }({});                m.core = ad;                m.cache = {};                var bd = function(a) {                    function b(a, b, d, c) {                        a = a + Canvas;                        var g = e(<canvas>, {                            id: a                        });                        p.append(g);                        d = new SmoothieChart(d);                        for (g = 0; g < b.length; g++) {                            var v = b[g],                                f = _.extend(h, c[g]);                            d.addTimeSeries(v, f)                        }                        d.streamTo(document.getElementById(a), 0)                    }
                    function d(a, d) {                        l[a] = c();                        b(a, [l[a]], d, [{                            strokeStyle: rgba(0, 255, 0, 1),                            fillStyle: rgba(0, 255, 0, 0.2),                            lineWidth: 2                        }])                    }
                    function c() {                        return new TimeSeries({                            Ma: !1                        })                    }                    var g = !1,                        p, f = !1,                        l = {},                        h = {                            strokeStyle: rgba(0, 255, 0, 1),                            fillStyle: rgba(0, 255, 0, 0.2),                            lineWidth: 2                        };                    a.showDebug = function() {                        g || (p = e(#debug-overlay), d(networkUpdate, {                            name: network updates,                            minValue: 0,                            maxValue: 120                        }), d(fps, {                            name: fps,                            minValue: 0,                            maxValue: 120                        }), l.rttSDev = c(), l.rttMean = c(), b(rttMean, [l.rttSDev, l.rttMean], {                            name: rtt,                            minValue: 0,                            maxValue: 120                        }, [{                            strokeStyle: rgba(255, 0, 0, 1),                            fillStyle: rgba(0, 255, 0, 0.2),                            lineWidth: 2                        }, {                            strokeStyle: rgba(0, 255, 0, 1),                            fillStyle: rgba(0, 255, 0, 0),                            lineWidth: 2                        }]), g = !0);                        m.core.debug = !0;                        p.show()                    };                    a.hideDebug = function() {                        p.hide();                        m.core.debug = !1                    };                    a.updateChart = function(a, b, d) {                        g && a in l && l[a].append(b, d)                    };                    a.__defineGetter__(showPrediction, function() {                        return f                    });                    a.__defineSetter__(showPrediction, function(a) {                        return f = a                    });                    return a                }({});                m.debug = bd;                var la = {                        AF: JP-Tokyo,                        AX: EU-London,                        AL: EU-London,                        DZ: EU-London,                        AS: SG-Singapore,                        AD: EU-London,                        AO: EU-London,                        AI: US-Atlanta,                        AG: US-Atlanta,                        AR: BR-Brazil,                        AM: JP-Tokyo,                        AW: US-Atlanta,                        AU: SG-Singapore,                        AT: EU-London,                        AZ: JP-Tokyo,                        BS: US-Atlanta,                        BH: JP-Tokyo,                        BD: JP-Tokyo,                        BB: US-Atlanta,                        BY: EU-London,                        BE: EU-London,                        BZ: US-Atlanta,                        BJ: EU-London,                        BM: US-Atlanta,                        BT: JP-Tokyo,                        BO: BR-Brazil,                        BQ: US-Atlanta,                        BA: EU-London,                        BW: EU-London,                        BR: BR-Brazil,                        IO: JP-Tokyo,                        VG: US-Atlanta,                        BN: JP-Tokyo,                        BG: EU-London,                        BF: EU-London,                        BI: EU-London,                        KH: JP-Tokyo,                        CM: EU-London,                        CA: US-Atlanta,                        CV: EU-London,                        KY: US-Atlanta,                        CF: EU-London,                        TD: EU-London,                        CL: BR-Brazil,                        CN: CN-China,                        CX: JP-Tokyo,                        CC: JP-Tokyo,                        CO: BR-Brazil,                        KM: EU-London,                        CD: EU-London,                        CG: EU-London,                        CK: SG-Singapore,                        CR: US-Atlanta,                        CI: EU-London,                        HR: EU-London,                        CU: US-Atlanta,                        CW: US-Atlanta,                        CY: JP-Tokyo,                        CZ: EU-London,                        DK: EU-London,                        DJ: EU-London,                        DM: US-Atlanta,                        DO: US-Atlanta,                        EC: BR-Brazil,                        EG: EU-London,                        SV: US-Atlanta,                        GQ: EU-London,                        ER: EU-London,                        EE: EU-London,                        ET: EU-London,                        FO: EU-London,                        FK: BR-Brazil,                        FJ: SG-Singapore,                        FI: EU-London,                        FR: EU-London,                        GF: BR-Brazil,                        PF: SG-Singapore,                        GA: EU-London,                        GM: EU-London,                        GE: JP-Tokyo,                        DE: EU-London,                        GH: EU-London,                        GI: EU-London,                        GR: EU-London,                        GL: US-Atlanta,                        GD: US-Atlanta,                        GP: US-Atlanta,                        GU: SG-Singapore,                        GT: US-Atlanta,                        GG: EU-London,                        GN: EU-London,                        GW: EU-London,                        GY: BR-Brazil,                        HT: US-Atlanta,                        VA: EU-London,                        HN: US-Atlanta,                        HK: JP-Tokyo,                        HU: EU-London,                        IS: EU-London,                        IN: JP-Tokyo,                        ID: JP-Tokyo,                        IR: JP-Tokyo,                        IQ: JP-Tokyo,                        IE: EU-London,                        IM: EU-London,                        IL: JP-Tokyo,                        IT: EU-London,                        JM: US-Atlanta,                        JP: JP-Tokyo,                        JE: EU-London,                        JO: JP-Tokyo,                        KZ: JP-Tokyo,                        KE: EU-London,                        KI: SG-Singapore,                        KP: JP-Tokyo,                        KR: JP-Tokyo,                        KW: JP-Tokyo,                        KG: JP-Tokyo,                        LA: JP-Tokyo,                        LV: EU-London,                        LB: JP-Tokyo,                        LS: EU-London,                        LR: EU-London,                        LY: EU-London,                        LI: EU-London,                        LT: EU-London,                        LU: EU-London,                        MO: JP-Tokyo,                        MK: EU-London,                        MG: EU-London,                        MW: EU-London,                        MY: JP-Tokyo,                        MV: JP-Tokyo,                        ML: EU-London,                        MT: EU-London,                        MH: SG-Singapore,                        MQ: US-Atlanta,                        MR: EU-London,                        MU: EU-London,                        YT: EU-London,                        MX: US-Atlanta,                        FM: SG-Singapore,                        MD: EU-London,                        MC: EU-London,                        MN: JP-Tokyo,                        ME: EU-London,                        MS: US-Atlanta,                        MA: EU-London,                        MZ: EU-London,                        MM: JP-Tokyo,                        NA: EU-London,                        NR: SG-Singapore,                        NP: JP-Tokyo,                        NL: EU-London,                        NC: SG-Singapore,                        NZ: SG-Singapore,                        NI: US-Atlanta,                        NE: EU-London,                        NG: EU-London,                        NU: SG-Singapore,                        NF: SG-Singapore,                        MP: SG-Singapore,                        NO: EU-London,                        OM: JP-Tokyo,                        PK: JP-Tokyo,                        PW: SG-Singapore,                        PS: JP-Tokyo,                        PA: US-Atlanta,                        PG: SG-Singapore,                        PY: BR-Brazil,                        PE: BR-Brazil,                        PH: JP-Tokyo,                        PN: SG-Singapore,                        PL: EU-London,                        PT: EU-London,                        PR: US-Atlanta,                        QA: JP-Tokyo,                        RE: EU-London,                        RO: EU-London,                        RU: RU-Russia,                        RW: EU-London,                        BL: US-Atlanta,                        SH: EU-London,                        KN: US-Atlanta,                        LC: US-Atlanta,                        MF: US-Atlanta,                        PM: US-Atlanta,                        VC: US-Atlanta,                        WS: SG-Singapore,                        SM: EU-London,                        ST: EU-London,                        SA: EU-London,                        SN: EU-London,                        RS: EU-London,                        SC: EU-London,                        SL: EU-London,                        SG: JP-Tokyo,                        SX: US-Atlanta,                        SK: EU-London,                        SI: EU-London,                        SB: SG-Singapore,                        SO: EU-London,                        ZA: EU-London,                        SS: EU-London,                        ES: EU-London,                        LK: JP-Tokyo,                        SD: EU-London,                        SR: BR-Brazil,                        SJ: EU-London,                        SZ: EU-London,                        SE: EU-London,                        CH: EU-London,                        SY: EU-London,                        TW: JP-Tokyo,                        TJ: JP-Tokyo,                        TZ: EU-London,                        TH: JP-Tokyo,                        TL: JP-Tokyo,                        TG: EU-London,                        TK: SG-Singapore,                        TO: SG-Singapore,                        TT: US-Atlanta,                        TN: EU-London,                        TR: TK-Turkey,                        TM: JP-Tokyo,                        TC: US-Atlanta,                        TV: SG-Singapore,                        UG: EU-London,                        UA: EU-London,                        AE: EU-London,                        GB: EU-London,                        US: US-Atlanta,                        UM: SG-Singapore,                        VI: US-Atlanta,                        UY: BR-Brazil,                        UZ: JP-Tokyo,                        VU: SG-Singapore,                        VE: BR-Brazil,                        VN: JP-Tokyo,                        WF: SG-Singapore,                        EH: EU-London,                        YE: JP-Tokyo,                        ZM: EU-London,                        ZW: EU-London                    },                    na = 0,                    Ea = 0,                    S = null,                    Ba = !1,                    Xb;                c.connect = fb;                var Fa = 500,                    Ec = .875,                    Gc = .75,                    Hc = .25,                    Fc = .125,                    Yb = -1,                    Zb = -1;                c.sendMitosis = Za;                c.sendEject = Mb;                m.networking = function(a) {                    a.loginRealm = {                        GG: google,                        FB: facebook                    };                    a.sendMessage = function(a) {                        if (da()) {                            var d = a.byteView;                            if (null != d) {                                a = U(1 + a.length);                                a.setUint8(0, 102);                                for (var c = 0; c < d.length; ++c) a.setUint8(1 + c, d[c]);                                V(a)                            }                        }                    };                    return a                }({});                var H = null,                    Ma = null,                    h = m.renderSettings = {                        high: {                            warnFps: 30,                            simpleDraw: !1,                            maxDetail: 1,                            minDetail: .6,                            U: 30                        },                        medium: {                            warnFps: 30,                            simpleDraw: !1,                            maxDetail: .5,                            minDetail: .3,                            U: 25                        },                        low: {                            warnFps: 30,                            simpleDraw: !0,                            maxDetail: .3,                            minDetail: .2,                            U: 25                        },                        upgrade: function() {                            h.selected == h.low ? (h.selected = h.medium, h.detail = h.medium.maxDetail) : h.selected == h.medium && (h.selected = h.high, h.detail = h.high.maxDetail)                        },                        downgrade: function() {                            h.selected == h.high ? h.selected = h.medium : h.selected == h.medium && (h.selected = h.low)                        }                    };                h.selected = h.high;                h.detail = 1;                h.auto = !1;                UPDATE                /**                 * Tells you if the game is in Dark mode.                 *  Boolean for dark mode.                 */                window.getDarkBool = function() {                    return ea;                }
                /**                 * Tells you if the mass is shown.                 *  Boolean for player's mass.                 */                window.getMassBool = function() {                    return Wa;                }
                /**                 * This is a copy of everything that is shown on screen.                 * Normally stuff will time out when off the screen, this                 * memorizes everything that leaves the screen for a little                 * while longer.                 *  The memory object.                 */                window.getMemoryCells = function() {                    return interNodes;                }
                /**                 * [getCellsArray description]                 *   [description]                 */                window.getCellsArray = function() {                    return z;                }
                /**                 * [getCellsArray description]                 *   [description]                 */                window.getCells = function() {                    return L;                }
                /**                 * Returns an array with all the player's cells.                 *  Player's cells                 */                window.getPlayer = function() {                    return t;                }
                /**                 * The canvas' width.                 *  Integer Width                 */                window.getWidth = function() {                    return q;                }
                /**                 * The canvas' height                 *  Integer Height                 */                window.getHeight = function() {                    return u;                }
                /**                 * Scaling ratio of the canvas. The bigger this ratio,                 * the further that you see.                 *  Screen scaling ratio.                 */                window.getRatio = function() {                    return r;                }
                window.getZoomlessRatio = function() {                    return r2;                }
                /**                 * [getOffsetX description]                 *   [description]                 */                window.getOffsetX = function() {                    return ib;                }
                window.getOffsetY = function() {                    return jb;                }
                window.getX = function() {                    return A;                }
                window.getY = function() {                    return B;                }
                window.getPointX = function() {                    return va;                }
                window.getPointY = function() {                    return wa;                }
                /**                 * The X location of the mouse.                 *  Integer X                 */                window.getMouseX = function() {                    return Y;                }
                /**                 * The Y location of the mouse.                 *  Integer Y                 */                window.getMouseY = function() {                    return Z;                }
                window.getMapStartX = function() {                    return ob;                }
                window.getMapStartY = function() {                    return pb;                }
                window.getMapEndX = function() {                    return qb;                }
                window.getMapEndY = function() {                    return rb;                }
                window.getScreenDistance = function() {                    var temp = screenDistance();                    return temp;                }
                /**                 * A timestamp since the last time the server sent any data.                 *  Last update timestamp                 */                window.getLastUpdate = function() {                    return y;                }
                window.getCurrentScore = function() {                    return T;                }
                /**                 * The game's current mode. ("":ffa"", "":experimental"", "":teams"". "":party"")                 *   [description]                 */                window.getMode = function() {                    return Ca;                }
                window.getServer = function() {                    return serverIP;                }
                window.setPoint = function(x, y) {                    va = x;                    wa = y;                }
                window.setScore = function(a) {                    sessionScore = a * 100;                }
                window.setBestTime = function(a) {                    bestTime = a;                }
                window.best = function(a, b) {                    setScore(a);                    setBestTime(b);                }
                window.setBotIndex = function(a) {                    window.log(Changing bot);                    botIndex = a;                    setLauncherCustomParameters(window.botList[a]);                }
                window.setLauncherCustomParameterOnChange = function(a, b, c) {                    a.on(change input, function() {                        var val = window.jQuery(this).val();                        c.value = val;                        b.text(val);                    });                }
                window.setLauncherCustomParameters = function(a) {                    window.jQuery(#launcher-custom-params).remove();                    window.jQuery(#launcher-wrapper).append(window.jQuery(<div id=""launcher-custom-params"">));
                     If no custom parameters are defined, abort                    if (a.customParameters === undefined) {                        return;                    }
                    for (var param in a.customParameters) {                        var form = window.jQuery(<div class=""form-group"">);                        var label = window.jQuery(<label>);                        var value = window.jQuery(<span style=""float: right; display: none;"">);                        var input = window.jQuery(<input class=""form-control"">);
                        if (a.customParameters[param].label !== undefined) {                            label.text(a.customParameters[param].label);                        } else {                            label.text(param);                        }
                        for (var paramKey in a.customParameters[param]) {                            if (paramKey == label) {                                continue;                            }
                            if (paramKey == value) {                                value.text(a.customParameters[param][paramKey]);                            } else if (paramKey == type && a.customParameters[param][paramKey] == range) {                                input.removeClass(form-control);                                value.show();                            }
                            input.attr(paramKey, a.customParameters[param][paramKey]);                        }
                        setLauncherCustomParameterOnChange(input, value, a.customParameters[param]);
                        form.append(label);                        form.append(value);                        form.append(input);                        form.appendTo(window.jQuery(#launcher-custom-params));                    }                }
                window.setLauncherBotList = function() {                    window.jQuery(#launcher-bot-list).remove();                    window.jQuery(#launcher-wrapper).append(window.jQuery(<div id=""launcher-bot-list"" class=""form-group"">));                    var select = window.jQuery(<select id=""bList"" class=""form-control"" onchange=""setBotIndex(window.jQuery(this).val());"" />);
                    for (var i = 0; i < window.botList.length; i++) {                        if (window.botList[i].name == Human && window.botList.length > 1) {                            if (botIndex == i) {                                botIndex = (botIndex + 1).mod(window.botList.length);                            }                            continue;                        }
                        window.jQuery(<option />, {                            value: i,                            text: window.botList[i].name                        }).appendTo(select);                    }
                    select.appendTo(window.jQuery(#launcher-bot-list));                }
                window.setMessage = function(a) {                    message = a;                }
                window.shoot = function() {                    if (!toggle && shootTime + shootCooldown < new Date().getTime()) {                        shootTime = new Date().getTime();                        opCode(21);                    }                }
                window.split = function() {
                    if (!toggle && splitTime + splitCooldown < new Date().getTime()) {                        splitTime = new Date().getTime();                        opCode(17);                    }                }
                window.updateBotList = function() {                    window.botList = window.botList || [];
                     Create wrapper for launcher controls                    window.jQuery(#launcher-wrapper).remove();                    window.jQuery(<div id=""launcher-wrapper"">).insertBefore(#agario-main-buttons);
                    setLauncherBotList();
                     Show initial custom parameters                    setLauncherCustomParameters(window.botList[window.jQuery(#bList).val()]);                }
                var Jb = 0,                    Pa = 0,                    Oa = 0,                    tc = function() {                        var a = Date.now(),                            b = 1E3 / 60;                        return function() {                            c.requestAnimationFrame(tc);                            var d = Date.now(),                                e = d - a;                            if (e > b) {                                a = d - e % b;                                var g = Date.now();                                !da() || 240 > g - Da || !m.core.config.skipDraw ? ac() : window.log(Skipping draw);                                cd();                                Jb = 1E3 / e;                                m.debug.updateChart(fps, d, Jb);                                Jb < h.selected.warnFps ? 0 == Oa && (Pa++, Pa > 2 * h.selected.warnFps && (h.selected.ma = !0)) : Pa = 0                            }                        }                    }();                c.setQuality = Kc;                var ha = {},                    Rb = ""poland;usa;china;russia;canada;australia;spain;brazil;germany;ukraine;france;sweden;chaplin;north korea;south korea;japan;united kingdom;earth;greece;latvia;lithuania;estonia;finland;norway;cia;maldivas;austria;nigeria;reddit;yaranaika;confederate;9gag;indiana;4chan;italy;bulgaria;tumblr;2ch.hk;hong kong;portugal;jamaica;german empire;mexico;sanik;switzerland;croatia;chile;indonesia;bangladesh;thailand;iran;iraq;peru;moon;botswana;bosnia;netherlands;european union;taiwan;pakistan;hungary;satanist;qing dynasty;matriarchy;patriarchy;feminism;ireland;texas;facepunch;prodota;cambodia;steam;piccolo;ea;india;kc;denmark;quebec;ayy lmao;sealand;bait;tsarist russia;origin;vinesauce;stalin;belgium;luxembourg;stussy;prussia;8ch;argentina;scotland;sir;romania;wojak;doge;nasa;byzantium;imperial japan;french kingdom;somalia;turkey;mars;pokerface;8;irs;receita federal;facebook;putin;merkel;tsipras;obama;kim jong-un;dilma;hollande;berlusconi;cameron;clinton;hillary;venezuela;blatter;chavez;cuba;fidel;merkel;palin;queen;boris;bush;trump;underwood"".split("";""),                    dd = 8;nasa;putin;merkel;tsipras;obama;kim jong-un;dilma;hollande;berlusconi;cameron;clinton;hillary;blatter;chavez;fidel;merkel;palin;queen;boris;bush;trump;underwood.split(;),                    oa = {};                Db.prototype = {                    $: null,                    x: 0,                    y: 0,                    f: 0,                    b: 0                };                var La = -1,                    cc = !1;                ca.prototype = {                    id: 0,                    a: null,                    name: null,                    i: null,                    R: null,                    x: 0,                    y: 0,                    size: 0,                    s: 0,                    u: 0,                    o: 0,                    ja: 0,                    ka: 0,                    g: 0,                    L: 0,                    M: 0,                    J: 0,                    K: 0,                    ea: 0,                    T: 0,                    ta: 0,                    G: !1,                    c: !1,                    h: !1,                    V: !0,                    da: 0,                    UPDATE                    updateCode: 0,                    danger: false,                    dangerTimeOut: 0,                    isNotMoving: function() {                        return (this.x == this.s && this.y == this.u);                    },                    isVirus: function() {                        return this.c;                    },                    getUptimeTime: function() {                        return this.T;                    },
                    C: null,                    ia: 0,                    wa: !1,                    I: !1,                    ca: function() {                        var a;                        for (a = 0; a < z.length; a++)                            if (z[a] == this) {                                z.splice(a, 1);                                break                            }                        delete L[this.id];                        a = t.indexOf(this); - 1 != a && (ub = !0, t.splice(a, 1));                        a = G.indexOf(this.id); - 1 != a && G.splice(a, 1);                        this.G = !0;                        0 < this.da && ba.push(this)                    },                    m: function() {                        return Math.max(~~(.3 * this.size), 24)                    },                    A: function(a) {                        if (this.name = a) null == this.i ? this.i = new Na(this.m(), #FFFFFF, !0, #000000) : this.i.O(this.m()), this.i.B(this.name)                    },                    ba: function() {                        for (var a = this.H(); this.a.length > a;) {                            var b = ~~(Math.random() * this.a.length);                            this.a.splice(b, 1)                        }                        for (0 == this.a.length && 0 < a && this.a.push(new Db(this, this.x, this.y, this.size, Math.random() - .5)); this.a.length < a;) b = ~~(Math.random() * this.a.length), b = this.a[b], this.a.push(new Db(this, b.x, b.y, b.f, b.b))                    },                    H: function() {                        var a = 10;                        20 > this.size && (a = 0);                        this.c && (a = m.renderSettings.selected.U);                        var b = this.size;                        this.c || (b *= r);                        b *= h.detail;                        return ~~Math.max(b, a)                    },                    Da: function() {                        this.ba();                        for (var a = this.a, b = a.length, d = this, c = this.c ? 0 : (this.id / 1E3 + y / 1E4) % (2 * Math.PI), e = 0, p = 0; p < b; ++p) {                            var f = a[(p - 1 + b) % b].b,                                l = a[(p + 1) % b].b,                                h = a[p];                            h.b += (Math.random() - .5) * (this.h ? 3 : 1);                            h.b *= .7;                            10 < h.b && (h.b = 10); - 10 > h.b && (h.b = -10);                            h.b = (f + l + 8 * h.b) / 10;                            var n = h.f,                                f = a[(p - 1 + b) % b].f,                                l = a[(p + 1) % b].f;                            if (15 < this.size && null != ia && 20 < this.size * r && 0 < this.id) {                                var k = !1,                                    m = h.x,                                    q = h.y;                                ia.Ga(m - 5, q - 5, 10, 10, function(a) {                                    a.$ != d && 25 > (m - a.x) * (m - a.x) + (q - a.y) * (q - a.y) && (k = !0)                                });                                !k && (h.x < ob || h.y < pb || h.x > qb || h.y > rb) && (k = !0);                                k && (0 < h.b && (h.b = 0), --h.b)                            }                            n += h.b;                            0 > n && (n = 0);                            n = this.h ? (19 * n + this.size) / 20 : (12 * n + this.size) / 13;                            h.f = (f + l + 8 * n) / 10;                            f = 2 * Math.PI / b;                            l = h.f;                            this.c && 0 == p % 2 && (l += 5);                            h.x = this.x + Math.cos(f * p + c) * l;                            h.y = this.y + Math.sin(f * p + c) * l;                            e = Math.max(e, l)                        }                        this.ia =                            e                    },                    pa: function(a, b) {                        this.L = a;                        this.M = b;                        this.J = a;                        this.K = b;                        this.ja = a;                        this.ka = b                    },                    S: function() {                        if (0 >= this.id) return 1;                        var a = Ya.ra((y - this.T) / 120, 0, 1);                        if (this.G && 1 <= a) {                            var b = ba.indexOf(this); - 1 != b && ba.splice(b, 1)                        }                        this.x = a * (this.ja - this.s) + this.s;                        this.y = a * (this.ka - this.u) + this.u;                        this.size = a * (this.g - this.o) + this.o;                        .01 > Math.abs(this.size - this.g) && (this.size = this.g);                        return a                    },                    P: function() {                        return 0 >= this.id ? !0 : this.x + this.size + 40 < A - q / 2 / r || this.y + this.size + 40 < B - u / 2 / r || this.x - this.size - 40 > A + q / 2 / r || this.y - this.size -                            40 > B + u / 2 / r ? !1 : !0                    },                    sa: function(a) {                        a.beginPath();                        var b = this.H();                        a.moveTo(this.a[0].x, this.a[0].y);                        for (var d = 1; d <= b; ++d) {                            var c = d % b;                            a.lineTo(this.a[c].x, this.a[c].y)                        }                        a.closePath();                        a.stroke()                    },                    w: function(a) {                        if (this.P()) {                            ++this.da;                            var b = 0 < this.id && !this.c && !this.h && .4 > r || h.selected.simpleDraw && !this.c;                            5 > this.H() && 0 < this.id && (b = !0);                            if (this.V && !b)                                for (var d = 0; d < this.a.length; d++) this.a[d].f = this.size;                            this.V = b;                            a.save();                            this.ta = y;                            d = this.S();                            this.G && (a.globalAlpha *= 1 - d);                            a.lineWidth = 10;                            a.lineCap = round;                            a.lineJoin = this.c ? miter : round;                            var e = this.name.toLowerCase(),                                g = null,                                p = null,                                d = !1,                                f = this.color,                                l = !1;                            this.h || !Va || sb || (-1 != Rb.indexOf(e) ? (ha.hasOwnProperty(e) || (ha[e] = new Image, ha[e].src = c.ASSETS_ROOT + skins/ + e + .png), g = 0 != ha[e].width && ha[e].complete ? ha[e] : null) : g = null, null != g ? -1 != dd.indexOf(e) && (d = !0) : (this.I && %starball == this.C && shenron == e && 7 <= t.length && (cc = d = !0, p = hc(%starball1)), g = hc(this.C), null != g && (l = !0, f = Rc(this.C) || f)));                            m.core.debug && m.debug.showPrediction && this.I && (a.strokeStyle = #0000FF, a.beginPath(), a.arc(this.L, this.M, this.size + 5, 0, 2 * Math.PI, !1), a.closePath(), a.stroke(), a.strokeStyle = #00FF00, a.beginPath(), a.arc(this.J, this.K, this.size + 5, 0, 2 * Math.PI, !1), a.closePath(), a.stroke());                            pa && !sb ? (a.fillStyle = #FFFFFF, a.strokeStyle = #AAAAAA) : (a.fillStyle = f, a.strokeStyle = f);                            b ? (a.beginPath(), a.arc(this.x, this.y, this.size + 5, 0, 2 * Math.PI, !1), a.closePath()) : (this.Da(), this.sa(a));                            l || a.fill();                            null != g && (this.na(a, g), null != p && this.na(a, p, {                                alpha: Math.sin(.0174 * La)                            }));                            (pa || 20 < this.size) && !b && (a.strokeStyle = #000000, a.globalAlpha *= .1, a.stroke());                            a.globalAlpha = 1;                            e = -1 != t.indexOf(this);                            b = ~~this.y;                            0 != this.id && (fa || e) && this.name && this.i && !d && (g = this.i, g.B(this.name), g.O(this.m()), d = 0 >= this.id ? 1 : Math.ceil(10 * r) / 10, g.oa(d), g = g.N(), p = Math.ceil(g.width / d), f = Math.ceil(g.height / d), a.drawImage(g, ~~this.x - ~~(p / 2), b - ~~(f / 2), p, f), b += g.height / 2 / d + 4);                            0 < this.id && Wa && (e || 0 == t.length && (!this.c || this.h) && 20 < this.size) && (null == this.R && (this.R = new Na(this.m() / 2, #FFFFFF, !0, #000000)), e = this.R, e.O(this.m() / 2), e.B(~~(this.size * this.size /                                100)), d = Math.ceil(10 * r) / 10, e.oa(d), g = e.N(), p = Math.ceil(g.width / d), f = Math.ceil(g.height / d), a.drawImage(g, ~~this.x - ~~(p / 2), b - ~~(f / 2), p, f));                            a.restore()                        }                    },                    na: function(a, b, d) {                        a.save();                        a.clip();                        var c = Math.max(this.size, this.ia);                        null != d && null != d.alpha && (a.globalAlpha = d.alpha);                        a.drawImage(b, this.x - c - 5, this.y - c - 5, 2 * c + 10, 2 * c + 10);                        a.restore()                    }                };                var Ya = function(a) {                    function b(a, b, c) {                        return a < b ? b : a > c ? c : a                    }                    a.ha = function(a, c) {                        var e;                        e = b(.5, 0, 1);                        return a + e * (c - a)                    };                    a.ra = b;                    a.fixed = function(a, b) {                        var c = Math.pow(10, b);                        return ~~(a *                            c) / c                    };                    return a                }({});                c.Maths = Ya;                var hb = function(a) {                    a.la = function() {                        for (var a = new Date, d = [a.getMonth() + 1, a.getDate(), a.getFullYear()], a = [a.getHours(), a.getMinutes(), a.getSeconds()], c = 1; 3 > c; c++) 10 > a[c] && (a[c] = 0 + a[c]);                        return [ + d.join(/) +   + a.join(:) + ]                    };                    return a                }({});                c.Utils = hb;                Na.prototype = {                    F: ,                    W: #000000,                    Y: !1,                    Z: #000000,                    v: 16,                    j: null,                    X: null,                    l: !1,                    D: 1,                    O: function(a) {                        this.v != a && (this.v = a, this.l = !0)                    },                    oa: function(a) {                        this.D != a && (this.D = a, this.l = !0)                    },                    B: function(a) {                        a != this.F && (this.F = a, this.l = !0)                    },                    N: function() {                        null == this.j && (this.j = document.createElement(canvas), this.X = this.j.getContext(2d));                        if (this.l) {                            this.l = !1;                            var a = this.j,                                b = this.X,                                c = this.F,                                e = this.D,                                g = this.v,                                f = g + px Ubuntu;                            b.font = f;                            var h = ~~(.2 * g);                            a.width = (b.measureText(c).width + 6) * e;                            a.height = (g + h) * e;                            b.font = f;                            b.scale(e, e);                            b.globalAlpha = 1;                            b.lineWidth = 3;                            b.strokeStyle = this.Z;                            b.fillStyle = this.W;                            this.Y && b.strokeText(c, 3, g - h / 2);                            b.fillText(c, 3, g - h / 2)                        }                        return this.j                    }                };                Date.now || (Date.now = function() {                    return (new Date).getTime()                });                (function() {                    for (var a = [ms, moz, webkit, o], b = 0; b < a.length && !c.requestAnimationFrame; ++b) c.requestAnimationFrame = c[a[b] + RequestAnimationFrame], c.cancelAnimationFrame = c[a[b] + CancelAnimationFrame] || c[a[b] + CancelRequestAnimationFrame];                    c.requestAnimationFrame || (c.requestAnimationFrame = function(a) {                        return setTimeout(a, 1E3 / 60)                    }, c.cancelAnimationFrame = function(a) {                        clearTimeout(a)                    })                })();                var xc = {                        init: function(a) {                            function b(a) {                                a < e && (a = e);                                a > f && (a = f);                                return ~~((a - e) / 32)                            }
                            function c(a) {                                a < g && (a = g);                                a > h && (a = h);                                return ~~((a - g) / 32)                            }                            var e = a.Ba,                                g = a.Ca,                                f = a.za,                                h = a.Aa,                                l = ~~((f - e) / 32) + 1,                                k = ~~((h - g) / 32) + 1,                                n = Array(l * k);                            return {                                va: function(a) {                                    var e = b(a.x) + c(a.y) * l;                                    null == n[e] ? n[e] = a : Array.isArray(n[e]) ? n[e].push(a) : n[e] = [n[e], a]                                },                                Ga: function(a, e, g, f, h) {                                    var p = b(a),                                        v = c(e);                                    a = b(a + g);                                    e = c(e + f);                                    if (0 > p || p >= l || 0 > v || v >= k) debugger;                                    for (; v <= e; ++v)                                        for (f = p; f <= a; ++f)                                            if (g = n[f + v * l], null != g)                                                if (Array.isArray(g))                                                    for (var m = 0; m < g.length; m++) h(g[m]);                                                else h(g)                                }                            }                        }                    },                    Wb = function() {                        var a = new ca(0, 0, 0, 32, #ED1C24, ),                            b = document.createElement(canvas);                        b.width = 32;                        b.height =                            32;                        var c = b.getContext(2d);                        return function() {                            0 < t.length && (a.color = t[0].color, a.A(t[0].name));                            c.clearRect(0, 0, 32, 32);                            c.save();                            c.translate(16, 16);                            c.scale(.4, .4);                            a.w(c);                            c.restore();                            var e = document.getElementById(favicon),                                g = e.cloneNode(!0);                            g.setAttribute(href, b.toDataURL(image/png));                            UPDATE -- ?????                            e.setAttribute(""href"", b.toDataURL(""image/png""));                            e.parentNode.replaceChild(g, e)                        }                    }();                e(function() {                    Wb()                });                var Qa = {                        context: null,                        defaultProvider: facebook,                        loginIntent: 0,                        userInfo: {                            socialToken: null,                            tokenExpires: ,                            level: ,                            xp: ,                            xpNeeded: ,                            name: ,                            picture: ,                            displayName: ,                            loggedIn: 0,                            socialId:                         }                    },                    k = c.defaultSt = Qa;                c.storageInfo = k;                c.createDefaultStorage = Tc;                c.updateStorage = Ra;                e(function() {                    null != c.localStorage.storeObjectInfo && (k = JSON.parse(c.localStorage.storeObjectInfo));                    1 == k.loginIntent && ic(k.context);                     == k.userInfo.name &&  == k.userInfo.displayName || jc(k.userInfo)                });                c.checkLoginStatus = function() {                    1 == k.loginIntent && (Sa(), ic(k.context))                };                var Sa = function() {                    c.MC.setProfilePicture(k.userInfo.picture);                    c.MC.setSocialId(k.userInfo.socialId)                };                c.logout = function() {                    k = Qa;                    delete c.localStorage.storeObjectInfo;                    c.localStorage.storeObjectInfo = JSON.stringify(Qa);                    Ra();                    uc();                    m.cache.sentGameServerLogin = !1;                    delete m.cache.login_info;                    e(#helloContainer).attr(data-logged-in, 0);                    e(#helloContainer).attr(data-has-account-data, 0);                    e(.timer).text();                    e(#gPlusShare).hide();                    e(#fbShare).show();                    e(#user-id-tag).text();                    Q();                    c.MC.doLogout()                };                c.toggleSocialLogin = function() {                    e(#socialLoginContainer).toggle();                    e(#settings).hide();                    e(#instructions).hide();                    Eb()                };                c.toggleSettings = function() {                    e(#settings).toggle();                    e(#socialLoginContainer).hide();                    e(#instructions).hide();                    Eb()                };                m.account = function(a) {                    function b() {}
                    function d(a, b) {                        if (null == f || f.id != b.id) f = b, null != c.ssa_json && (c.ssa_json.applicationUserId =  + b.id, c.ssa_json.custom_user_id =  + b.id), undefined != typeof SSA_CORE && SSA_CORE.start()                    }                    var f = null;                    a.init = function() {                        m.core.bind(user_login, d);                        m.core.bind(user_logout, b)                    };                    a.setUserData = function(a) {                        jc(a)                    };                    a.setAccountData = function(a, b) {                        var c = e(#helloContainer).attr(data-has-account-data, 1);                        k.userInfo.xp = a.xp;                        k.userInfo.xpNeeded = a.xpNeeded;                        k.userInfo.level = a.level;                        Ra();                        c && b ? ga(a) : (e(.agario-profile-panel .progress-bar-star).text(a.level), e(.agario-exp-bar .progress-bar-text).text(a.xp + / + a.xpNeeded +  XP), e(.agario-exp-bar .progress-bar).css(width, (88 * a.xp / a.xpNeeded).toFixed(2) + %))                    };                    a.Ia = function(a) {                        ga(a)                    };                    return a                }({});                var lc = 0;                c.fbAsyncInit = function() {                    function a() {                        null == c.FB ? alert(You seem to have something blocking Facebook on your browser, please check for any extensions) : (k.loginIntent = 1, c.updateStorage(), c.FB.login(function(a) {                            kc(a)                        }, {                            scope: public_profile, email                        }))                    }                    c.FB.init({                        appId: EnvConfig.fb_app_id,                        cookie: !0,                        xfbml: !0,                        status: !0,                        version: v2.2                    });                    (1 == c.storageInfo.loginIntent && facebook == c.storageInfo.context || qc) && c.FB.getLoginStatus(function(b) {                        connected === b.status ? kc(b) : not_authorized === b.status ? (c.logout(), a()) : c.logout()                    });                    c.facebookRelogin = a;                    c.facebookLogin = a                };                var Kb = !1;                (function(a) {                    function b() {                        var a = document.createElement(script);                        a.type = text/javascript;                        a.async = !0;                        a.src = //apis.google.com/js/client:platform.js?onload=gapiAsyncInit;                        var b = document.getElementsByTagName(script)[0];                        b.parentNode.insertBefore(a, b);                        f = !0                    }                    var d = {},                        f = !1;                    c.gapiAsyncInit = function() {                        e(d).trigger(initialized)                    };                    a.google = {                        xa: function() {                            b()                        },                        ua: function(a, b) {                            c.gapi.client.load(plus, v1, function() {                                window.log(fetching me profile);                                gapi.client.plus.people.get({                                    userId: me                                }).execute(function(a) {                                    b(a)                                })                            })                        }                    };                    a.Fa = function(a) {                        f || b();                        undefined !== typeof gapi ? a() : e(d).bind(initialized, a)                    };                    return a                })(m);                var ed = function(a) {                    function b(a) {                        c.MC.doLoginWithGPlus(a);                        m.cache.login_info = [a, google]                    }
                    function d(a) {                        k.userInfo.picture = a;                        e(.agario-profile-picture).attr(src, a)                    }                    var f = null,                        g = {                            client_id: EnvConfig.gplus_client_id,                            cookie_policy: single_host_origin,                            scope: profile email                        };                    a.fa = {                        qa: function() {                            return f                        },                        init: function() {                            var a = this,                                b = k && 1 == k.loginIntent && google == k.context;                            m.Fa(function() {                                c.gapi.ytsubscribe.go(agarYoutube);                                c.gapi.load(auth2, function() {                                    f = c.gapi.auth2.init(g);                                    f.attachClickHandler(document.getElementById(gplusLogin), {}, function(a) {                                        window.log(googleUser :  + a)                                    }, function(a) {                                        window.log(failed to login in google plus: , JSON.stringify(a, void 0, 2))                                    });                                    f.currentUser.listen(_.bind(a.Ea, a));                                    b && 1 == f.isSignedIn.get() && f.signIn()                                })                            })                        },                        Ea: function(a) {                            if (f && a && f.isSignedIn.get() && !Kb) {                                Kb = !0;                                k.loginIntent = 1;                                var e = a.getAuthResponse(),                                    g = e.access_token;                                c.qa = e;                                window.log(loggedIn with G+!);                                var h = a.getBasicProfile();                                a = h.getImageUrl();                                void 0 == a ? m.google.ua(e, function(a) {                                    a.result.isPlusUser ? (a && d(a.image.url), b(g), a && (k.userInfo.picture = a.image.url), k.userInfo.socialId = h.getId(), Sa()) : (alert(Please add Google+ to your Google account and try again.Or you can login with another account.), c.logout())                                }) : (d(a), k.userInfo.picture = a, k.userInfo.socialId = h.getId(), Sa(), b(g));                                k.context = google;                                c.updateStorage()                            }                        },                        ya: function() {                            f && (f.signOut(), Kb = !1)                        }                    };                    return a                }(m);                c.gplusModule = ed;                var uc = function() {                    m.fa.ya()                };                c.logoutGooglePlus = uc;                var cd = function() {                    function a(a, b, c, d, e) {                        var f = b.getContext(2d),                            g = b.width;                        b = b.height;                        a.color = e;                        a.A(c);                        a.size = d;                        f.save();                        f.translate(g / 2, b / 2);                        a.w(f);                        f.restore()                    }                    for (var b = new ca(-1, 0, 0, 32, #5bc0de, ), c = new ca(-1, 0, 0, 32, #5bc0de, ), f = #0791ff #5a07ff #ff07fe #ffa507 #ff0774 #077fff #3aff07 #ff07ed #07a8ff #ff076e #3fff07 #ff0734 #07ff20 #ff07a2 #ff8207 #07ff0e.split( ), g = [], h = 0; h < f.length; ++h) {                        var k = h / f.length * 12,                            l = 30 * Math.sqrt(h / f.length);                        g.push(new ca(-1, Math.cos(k) * l, Math.sin(k) * l, 10, f[h], ))                    }                    Sc(g);                    var m = document.createElement(canvas);                    m.getContext(2d);                    m.width = m.height = 70;                    a(c, m, , 26, #ebc0de);                    return function() {                        e(.cell-spinner).filter(:visible).each(function() {                            var c = e(this),                                d = Date.now(),                                f = this.width,                                g = this.height,                                h = this.getContext(2d);                            h.clearRect(0, 0, f, g);                            h.save();                            h.translate(f / 2, g / 2);                            for (var k = 0; 10 > k; ++k) h.drawImage(m, (.1 * d + 80 * k) % (f + 140) - f / 2 - 70 - 35, g / 2 * Math.sin((.001 * d + k) % Math.PI * 2) - 35, 70, 70);                            h.restore();                            (c = c.attr(data-itr)) && (c = R(c));                            a(b, this, c || , +e(this).attr(data-size), #5bc0de)                        });                        e(#statsPellets).filter(:visible).each(function() {                            e(this);                            var b = this.width,                                c = this.height;                            this.getContext(2d).clearRect(0, 0, b, c);                            for (b = 0; b < g.length; b++) a(g[b], this, , g[b].size, g[b].color)                        })                    }                }();                c.createParty = function() {                    ka(:party);                    S = function(a) {                        Fb(/# + c.encodeURIComponent(a));                        e(.partyToken).val(agar.io/# + c.encodeURIComponent(a));                        e(#helloContainer).attr(data-party-state, 1)                    };                    Q()                };                c.joinParty = mc;                c.cancelParty = function() {                    Fb(/);                    e(#helloContainer).attr(data-party-state, 0);                    ka();                    Q()                };                var F = [],                    wb = 0,                    xb = #000000,                    aa = !1,                    Aa = !1,                    Ja = 0,                    Gb = 0,                    zb = 0,                    yb = 0,                    W = 0,                    Ta = !0;                c.onPlayerDeath = Ga;                setInterval(function() {                    Aa && F.push(dc() / 100)                }, 1E3 / 60);                setInterval(function() {                    var a = Vc();                    0 != a && (++zb, 0 == W && (W = a), W = Math.min(W, a))                }, 1E3);                c.closeStats = function() {                    aa = !1;                    e(#stats).hide();                    c.destroyAd(c.adSlots.ab);                    ua(0)                };                c.setSkipStats = function(a) {                    Ta = !a                };                c.getStatsString = oc;                c.gPlusShare = Xc;                c.twitterShareStats = function() {                    var a = c.getStatsString(tt_share_stats);                    c.open(https://twitter.com/intent/tweet?text= + a, Agar.io, width=660,height=310,menubar=no,toolbar=no,resizable=yes,scrollbars=no,left= +                        (c.screenX + c.innerWidth / 2 - 330) + ,top= + (c.innerHeight - 310) / 2)                };                c.fbShareStats = function() {                    var a = c.getStatsString(fb_matchresults_subtitle);                    c.FB.ui({                        method: feed,                        display: iframe,                        name: R(fb_matchresults_title),                        caption: R(fb_matchresults_description),                        description: a,                        link: http://agar.io,                        La: http://static2.miniclipcdn.com/mobile/agar/Agar.io_matchresults_fb_1200x630.png,                        Ha: {                            name: play now!,                            link: http://agar.io                        }                    })                };                c.fillSocialValues = function(a, b) {                    1 == c.isChrome && google == c.storageInfo.context &&                        c.gapi.interactivepost.render(b, {                            contenturl: EnvConfig.game_url,                            clientid: EnvConfig.gplus_client_id,                            cookiepolicy: http://agar.io,                            prefilltext: a,                            calltoactionlabel: BEAT,                            calltoactionurl: EnvConfig.game_url                        })                };                e(function() {                    MAsyncInit in c && c.MAsyncInit()                })            }        }    }})(window, window.jQuery);UPDATE(function(i, s, o, g, r, a, m) {    i[GoogleAnalyticsObject] = r;    i[r] = i[r] || function() {        (i[r].q = i[r].q || []).push(arguments)    }, i[r].l = 1 * new Date();    a = s.createElement(o),        m = s.getElementsByTagName(o)[0];    a.async = 1;    a.src = g;    m.parentNode.insertBefore(a, m)})(window, document, script, //www.google-analytics.com/analytics.js, apos);
apos(create, UA-64394184-1, auto);apos(send, pageview);
window.ignoreStream = false;window.refreshTwitch = function() {    window.jQuery.ajax({        url: https://api.twitch.tv/kraken/streams/apostolique,        cache: false,        dataType: jsonp    }).done(function(data) {        if (data[stream] == null) {            console.log(""Apostolique is not online!"");            window.setMessage([]);            window.onmouseup = function() {};            window.ignoreStream = false;        } else {            console.log(""Apostolique is online!"");            if (!window.ignoreStream) {                window.setMessage([twitch.tv/apostolique is online right now!, Click the screen to open the stream!, Press E to ignore.]);                window.onmouseup = function() {                    window.open(http://www.twitch.tv/apostolique);                };            }        }    }).fail(function() {});}setInterval(window.refreshTwitch, 60000);window.refreshTwitch();"
"/*The MIT License (MIT)Copyright (c) 2015 ApostoliquePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the ""Software""), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.*/
 ==UserScript== @name        AposBot @namespace   AposBot @include     http://agar.io/* @version     3.651 @grant       none @author      http://www.twitch.tv/apostolique ==/UserScript==
var aposBotVersion = 3.651;
TODO: Team mode      Detect when people are merging      Split to catch smaller targets      Angle based cluster code      Better wall code      In team mode, make allies be obstacles.
/*Number.prototype.mod = function(n) {    return ((this % n) + n) % n;};*/
Array.prototype.peek = function() {    return this[this.length - 1];};
Load it from the two file in case one is not loadedwindow.log = function(message){    if(window.logDebugging === true){        console.log.apply(console, arguments);    }}
var sha = efde0488cc2cc176db48dd23b28a20b90314352b;(function () {    window.jQuery.ajax({            url: https://api.github.com/repos/apostolique/Agar.io-bot/git/refs/heads/master,            cache: false,            dataType: jsonp        }).done(function(data) {            console.dir(data.data);            window.log(hmm:  + data.data.object.sha);            sha = data.data.object.sha;
            function update(prefix, name, url) {                window.jQuery(document.body).prepend(<div id=' + prefix + Dialog' style='position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 100; display: none;'>);                window.jQuery(# + prefix + Dialog).append(<div id=' + prefix + Message' style='width: 350px; background-color: #FFFFFF; margin: 100px auto; border-radius: 15px; padding: 5px 15px 5px 15px;'>);                window.jQuery(# + prefix + Message).append(<h2>UPDATE TIME!!!</h2>);                window.jQuery(# + prefix + Message).append(<p>Grab the update for: <a id=' + prefix + Link' href=' + url + ' target=_blank> + name + </a></p>);                window.jQuery(# + prefix + Link).on(click, function() {                    window.jQuery(# + prefix + Dialog).hide();                    window.jQuery(# + prefix + Dialog).remove();                });                window.jQuery(# + prefix + Dialog).show();            }
            $.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/bot.user.js? + Math.floor((Math.random() * 1000000) + 1), function(data) {                var latestVersion = data.replace(()gm,);                latestVersion = latestVersion.substring(latestVersion.indexOf(// @version)+11,latestVersion.indexOf(// @grant));
                latestVersion = parseFloat(latestVersion + 0.0000);                var myVersion = parseFloat(aposBotVersion + 0.0000);
                if(latestVersion > myVersion)                {                    update(aposBot, bot.user.js, https://github.com/Apostolique/Agar.io-bot/blob/ + sha + /bot.user.js/);                }                window.log(Current bot.user.js Version:  + myVersion +  on Github:  + latestVersion);            });
        }).fail(function() {});})();
window.log(Running Apos Bot!);
var f = window;var g = window.jQuery;

window.log(Apos Bot!);
window.botList = window.botList || [];
/*function QuickBot() {    this.name = ""QuickBot V1"";    this.customParameters = {};    this.keyAction = function(key) {};    this.displayText = function() {return [];};    this.mainLoop = function() {        return [screenToGameX(getMouseX()),                screenToGameY(getMouseY())];    };}window.botList.push(new QuickBot());*/
function AposBot() {    this.name = AposBot  + aposBotVersion;
    this.toggleFollow = false;    this.keyAction = function(key) {        if (key.keyCode === 81) {            window.log(Toggle Follow Mouse!);            this.toggleFollow = !this.toggleFollow;        }    };
    this.displayText = function() {        return [Q - Follow Mouse:  + (this.toggleFollow ? On : Off)];    };
     Using mod function instead the prototype directly as it is very slow    this.mod = function(num, mod) {        if (mod & (mod - 1) === 0 && mod !== 0) {            return num & (mod - 1);        }        return num < 0 ? ((num % mod) + mod) % mod : num % mod;    };    this.splitDistance = 710;
    this.isMerging = function(cell1, cell2) {        var dist = this.computeDistance(cell1.x, cell1.y, cell2.x, cell2.y, cell1.size, cell2.size);
        debug logging		window.log(Merge:, [cell1.x, cell1.y, cell2.x, cell2.y, cell1.size, cell2.size, dist].join(, ))
        return dist <= -50;    };
    Given an angle value that was gotten from valueAndleBased(),    returns a new value that scales it appropriately.    this.paraAngleValue = function(angleValue, range) {        return (15 / (range[1])) * (angleValue * angleValue) - (range[1] / 6);    };
    this.getMass = function(size) {        return Math.pow(size / 10, 2);    };
    this.valueAngleBased = function(angle, range) {        var leftValue = this.mod(angle - range[0], 360);        var rightValue = this.mod(this.rangeToAngle(range) - angle, 360);
        var bestValue = Math.min(leftValue, rightValue);
        if (bestValue <= range[1]) {            return this.paraAngleValue(bestValue, range);        }        return -1;    };
    this.computeDistance = function(x1, y1, x2, y2, s1, s2) {         Make sure there are no null optional params.        s1 = s1 || 0;        s2 = s2 || 0;        var xdis = x1 - x2;  <--- FAKE AmS OF COURSE!        var ydis = y1 - y2;        var distance = Math.sqrt(xdis * xdis + ydis * ydis) - (s1 + s2);
        return distance;    };
     Get a distance that is Inexpensive on the cpu for various purpaces    this.computeInexpensiveDistance = function(x1, y1, x2, y2, s1, s2) {         Make sure there are no null optional params.        s1 = s1 || 0;        s2 = s2 || 0;        var xdis = x1 - x2;        var ydis = y1 - y2;         Get abs quickly        xdis = xdis < 0 ? xdis * -1 : xdis;        ydis = ydis < 0 ? ydis * -1 : ydis;
        var distance = xdis + ydis;
        return distance;    };
    this.computeDistanceFromCircleEdgeDeprecated = function(x1, y1, x2, y2, s2) {        var tempD = this.computeDistance(x1, y1, x2, y2);
        var offsetX = 0;        var offsetY = 0;
        var ratioX = tempD / (x1 - x2);        var ratioY = tempD / (y1 - y2);
        offsetX = x1 - (s2 / ratioX);        offsetY = y1 - (s2 / ratioY);
        drawPoint(offsetX, offsetY, 5, );
        return this.computeDistance(x2, y2, offsetX, offsetY);    };
    this.compareSize = function(player1, player2, ratio) {        if (player1.size * player1.size * ratio < player2.size * player2.size) {            return true;        }        return false;    },
    this.canSplit = function(player1, player2) {        return this.compareSize(player1, player2, 2.8) && !this.compareSize(player1, player2, 20);    };
    this.isItMe = function(player, cell) {        if (getMode() == :teams) {            var currentColor = player[0].color;            var currentRed = currentColor.substring(1,3);            var currentGreen = currentColor.substring(3,5);            var currentBlue = currentColor.substring(5,7);
            var currentTeam = this.getTeam(currentRed, currentGreen, currentBlue);
            var cellColor = cell.color;
            var cellRed = cellColor.substring(1,3);            var cellGreen = cellColor.substring(3,5);            var cellBlue = cellColor.substring(5,7);
            var cellTeam = this.getTeam(cellRed, cellGreen, cellBlue);
            if (currentTeam == cellTeam && !cell.isVirus()) {                return true;            }
            window.log(COLOR:  + color);
        } else {            for (var i = 0; i < player.length; i++) {                if (cell.id == player[i].id) {                    return true;                }            }        }        return false;    };
    this.getTeam = function(red, green, blue) {        if (red == ff) {            return 0;        } else if (green == ff) {            return 1;        }        return 2;    };
    this.isFood = function(blob, cell) {        if (!cell.isVirus() && this.compareSize(cell, blob, 1.33) || (cell.size <= 13)) {            return true;        }        return false;    };
    this.isThreat = function(blob, cell) {
        if (!cell.isVirus() && this.compareSize(blob, cell, 1.30)) {            return true;        }        return false;    };
    this.isVirus = function(blob, cell) {    if (blob == null) {        if (cell.isVirus()) {            return true;        } else {            return false;        }    }    if (cell.isVirus() && this.compareSize(cell, blob, 1.1)) {        return true;    } else if (cell.isVirus() && cell.color.substring(3, 5).toLowerCase() != ff) {        return true;    }    return false;};
    this.isSplitTarget = function(that, blob, cell) {        if (that.canSplit(cell, blob)) {            return true;        }        return false;    };
    this.getTimeToRemerge = function(mass){        return Math.max(30, Math.floor(mass*0.02));        return ((mass*0.02) + 30);    };
    this.separateListBasedOnFunction = function(that, listToUse, blob) {        var foodElementList = [];        var threatList = [];        var virusList = [];        var splitTargetList = [];
        var player = getPlayer();
        var mergeList = [];
        Object.keys(listToUse).forEach(function(element, index) {            var isMe = that.isItMe(player, listToUse[element]);
            if (!isMe) {                if (that.isFood(blob, listToUse[element]) && listToUse[element].isNotMoving()) {                    IT'S FOOD!                    foodElementList.push(listToUse[element]);

                } else if (that.isThreat(blob, listToUse[element])) {                    IT'S DANGER!                    threatList.push(listToUse[element]);                    mergeList.push(listToUse[element]);                } else if (that.isVirus(blob, listToUse[element])) {                    IT'S VIRUS!                    virusList.push(listToUse[element]);                }                else if (that.isSplitTarget(that, blob, listToUse[element])) {                        drawCircle(listToUse[element].x, listToUse[element].y, listToUse[element].size + 50, 7);                        splitTargetList.push(listToUse[element]);                        foodElementList.push(listToUse[element]);                        mergeList.push(listToUse[element]);                }                else {if (that.isVirus(null, listToUse[element])==false) {mergeList.push(listToUse[element]);}                    }            }/*else if(isMe && (getBlobCount(getPlayer()) > 0)){                //Attempt to make the other cell follow the mother one                foodElementList.push(listToUse[element]);            }*/        });
        foodList = [];        for (var i = 0; i < foodElementList.length; i++) {            foodList.push([foodElementList[i].x, foodElementList[i].y, foodElementList[i].size]);        }
        window.log(Merglist length:  +  mergeList.length)        cell merging        for (var i = 0; i < mergeList.length; i++) {            for (var z = 0; z < mergeList.length; z++) {                if (z != i && that.isMerging(mergeList[i], mergeList[z])) { z != i &&                        found cells that appear to be merging - if they constitute a threat add them to the theatlist
                        clone us a new cell                        var newThreat = {};                        var prop;
                        for (prop in mergeList[i]) {                            newThreat[prop] = mergeList[i][prop];                        }
                        average distance and sum the size                        newThreat.x = (mergeList[i].x + mergeList[z].x)/2;                        newThreat.y = (mergeList[i].y + mergeList[z].y)/2;                        newThreat.size = (mergeList[i].size + mergeList[z].size);                        newThreat.nopredict = true;                        check its a threat                        if (that.isThreat(blob, newThreat)) {                             IT'S DANGER!                            threatList.push(newThreat);                        }
                }            }        }
        return [foodList, threatList, virusList, splitTargetList];    };
    this.getAll = function(blob) {        var dotList = [];        var player = getPlayer();        var interNodes = getMemoryCells();
        dotList = this.separateListBasedOnFunction(this, interNodes, blob);
        return dotList;    };
    this.clusterFood = function(foodList, blobSize) {        var clusters = [];        var addedCluster = false;
        1: x        2: y        3: size or value        4: Angle, not set here.
        for (var i = 0; i < foodList.length; i++) {            for (var j = 0; j < clusters.length; j++) {                if (this.computeInexpensiveDistance(foodList[i][0], foodList[i][1], clusters[j][0], clusters[j][1]) < blobSize * 2) {                    clusters[j][0] = (foodList[i][0] + clusters[j][0]) / 2;                    clusters[j][1] = (foodList[i][1] + clusters[j][1]) / 2;                    clusters[j][2] += foodList[i][2];                    addedCluster = true;                    break;                }            }            if (!addedCluster) {                clusters.push([foodList[i][0], foodList[i][1], foodList[i][2], 0]);            }            addedCluster = false;        }        return clusters;    };
    this.getAngle = function(x1, y1, x2, y2) {        Handle vertical and horizontal lines.
        if (x1 == x2) {            if (y1 < y2) {                return 271;                return 89;            } else {                return 89;            }        }
        return (Math.round(Math.atan2(-(y1 - y2), -(x1 - x2)) / Math.PI * 180 + 180));    };
    this.slope = function(x1, y1, x2, y2) {        var m = (y1 - y2) / (x1 - x2);
        return m;    };
    this.slopeFromAngle = function(degree) {        if (degree == 270) {            degree = 271;        } else if (degree == 90) {            degree = 91;        }        return Math.tan((degree - 180) / 180 * Math.PI);    };
    Given two points on a line, finds the slope of a perpendicular line crossing it.    this.inverseSlope = function(x1, y1, x2, y2) {        var m = this.slope(x1, y1, x2, y2);        return (-1) / m;    };
    Given a slope and an offset, returns two points on that line.    this.pointsOnLine = function(slope, useX, useY, distance) {        var b = useY - slope * useX;        var r = Math.sqrt(1 + slope * slope);
        var newX1 = (useX + (distance / r));        var newY1 = (useY + ((distance * slope) / r));        var newX2 = (useX + ((-distance) / r));        var newY2 = (useY + (((-distance) * slope) / r));
        return [            [newX1, newY1],            [newX2, newY2]        ];    };
    this.followAngle = function(angle, useX, useY, distance) {        var slope = this.slopeFromAngle(angle);        var coords = this.pointsOnLine(slope, useX, useY, distance);
        var side = this.mod(angle - 90, 360);        if (side < 180) {            return coords[1];        } else {            return coords[0];        }    };
    Using a line formed from point a to b, tells if point c is on S side of that line.    this.isSideLine = function(a, b, c) {        if ((b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0) {            return true;        }        return false;    };
    angle range2 is within angle range2    an Angle is a point and a distance between an other point [5, 40]    this.angleRangeIsWithin = function(range1, range2) {        if (range2[0] == this.mod(range2[0] + range2[1], 360)) {            return true;        }        window.log(r1:  + range1[0] + ,  + range1[1] +  ... r2:  + range2[0] + ,  + range2[1]);
        var distanceFrom0 = this.mod(range1[0] - range2[0], 360);        var distanceFrom1 = this.mod(range1[1] - range2[0], 360);
        if (distanceFrom0 < range2[1] && distanceFrom1 < range2[1] && distanceFrom0 < distanceFrom1) {            return true;        }        return false;    };
    this.angleRangeIsWithinInverted = function(range1, range2) {        var distanceFrom0 = this.mod(range1[0] - range2[0], 360);        var distanceFrom1 = this.mod(range1[1] - range2[0], 360);
        if (distanceFrom0 < range2[1] && distanceFrom1 < range2[1] && distanceFrom0 > distanceFrom1) {            return true;        }        return false;    };
    this.angleIsWithin = function(angle, range) {        var diff = this.mod(this.rangeToAngle(range) - angle, 360);        if (diff >= 0 && diff <= range[1]) {            return true;        }        return false;    };
    this.rangeToAngle = function(range) {        return this.mod(range[0] + range[1], 360);    };
    this.anglePair = function(range) {        return (range[0] + ,  + this.rangeToAngle(range) +  range:  + range[1]);    };
    this.computeAngleRanges = function(blob1, blob2) {        var mainAngle = this.getAngle(blob1.x, blob1.y, blob2.x, blob2.y);        var leftAngle = this.mod(mainAngle - 90, 360);        var rightAngle = this.mod(mainAngle + 90, 360);
        var blob1Left = this.followAngle(leftAngle, blob1.x, blob1.y, blob1.size);        var blob1Right = this.followAngle(rightAngle, blob1.x, blob1.y, blob1.size);
        var blob2Left = this.followAngle(rightAngle, blob2.x, blob2.y, blob2.size);        var blob2Right = this.followAngle(leftAngle, blob2.x, blob2.y, blob2.size);
        var blob1AngleLeft = this.getAngle(blob2.x, blob2.y, blob1Left[0], blob1Left[1]);        var blob1AngleRight = this.getAngle(blob2.x, blob2.y, blob1Right[0], blob1Right[1]);
        var blob2AngleLeft = this.getAngle(blob1.x, blob1.y, blob2Left[0], blob2Left[1]);        var blob2AngleRight = this.getAngle(blob1.x, blob1.y, blob2Right[0], blob2Right[1]);
        var blob1Range = this.mod(blob1AngleRight - blob1AngleLeft, 360);        var blob2Range = this.mod(blob2AngleRight - blob2AngleLeft, 360);
        var tempLine = this.followAngle(blob2AngleLeft, blob2Left[0], blob2Left[1], 400);        drawLine(blob2Left[0], blob2Left[1], tempLine[0], tempLine[1], 0);
        if ((blob1Range / blob2Range) > 1) {            drawPoint(blob1Left[0], blob1Left[1], 3, );            drawPoint(blob1Right[0], blob1Right[1], 3, );            drawPoint(blob1.x, blob1.y, 3,  + blob1Range + ,  + blob2Range +  R:  + (Math.round((blob1Range / blob2Range) * 1000) / 1000));        }
        drawPoint(blob2.x, blob2.y, 3, """" + blob1Range);    };
    this.debugAngle = function(angle, text) {        var player = getPlayer();        var line1 = this.followAngle(angle, player[0].x, player[0].y, 300);        drawLine(player[0].x, player[0].y, line1[0], line1[1], 5);        drawPoint(line1[0], line1[1], 5,  + text);    };
    TODO: Don't let this function do the radius math.    this.getEdgeLinesFromPoint = function(blob1, blob2, radius) {        var px = blob1.x;        var py = blob1.y;
        var cx = blob2.x;        var cy = blob2.y;
        var radius = blob2.size;
        /*if (blob2.isVirus()) {            radius = blob1.size;        } else if(canSplit(blob1, blob2)) {            radius += splitDistance;        } else {            radius += blob1.size * 2;        }*/
        var shouldInvert = false;
        var tempRadius = this.computeDistance(px, py, cx, cy);        if (tempRadius <= radius) {            radius = tempRadius - 5;            shouldInvert = true;        }
        var dx = cx - px;        var dy = cy - py;        var dd = Math.sqrt(dx * dx + dy * dy);        var a = Math.asin(radius / dd);        var b = Math.atan2(dy, dx);
        var t = b - a;        var ta = {            x: radius * Math.sin(t),            y: radius * -Math.cos(t)        };
        t = b + a;        var tb = {            x: radius * -Math.sin(t),            y: radius * Math.cos(t)        };
        var angleLeft = this.getAngle(cx + ta.x, cy + ta.y, px, py);        var angleRight = this.getAngle(cx + tb.x, cy + tb.y, px, py);        var angleDistance = this.mod(angleRight - angleLeft, 360);
        /*if (shouldInvert) {            var temp = angleLeft;            angleLeft = this.mod(angleRight + 180, 360);            angleRight = this.mod(temp + 180, 360);            angleDistance = this.mod(angleRight - angleLeft, 360);        }*/
        return [angleLeft, angleDistance, [cx + tb.x, cy + tb.y],            [cx + ta.x, cy + ta.y]        ];    };
    this.addWall = function(listToUse, blob) {        var mapSizeX = Math.abs(f.getMapStartX - f.getMapEndX);        var mapSizeY = Math.abs(f.getMapStartY - f.getMapEndY);        var distanceFromWallX = mapSizeX/3;        var distanceFromWallY = mapSizeY/3;        var distanceFromWallY = 1000;        var distanceFromWallX = 1000;        if (blob.x < getMapStartX() + distanceFromWallX) {            LEFT            window.log(Left);            listToUse.push([                [115, true],                [245, false], this.computeInexpensiveDistance(getMapStartX(), blob.y, blob.x, blob.y)            ]);            var lineLeft = this.followAngle(115, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(245, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        if (blob.y < getMapStartY() + distanceFromWallY) {            TOP            window.log(TOP);            listToUse.push([                [205, true],                [335, false], this.computeInexpensiveDistance(blob.x, getMapStartY(), blob.x, blob.y)            ]);            var lineLeft = this.followAngle(205, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(335, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        if (blob.x > getMapEndX() - distanceFromWallX) {            RIGHT            window.log(RIGHT);            listToUse.push([                [295, true],                [65, false], this.computeInexpensiveDistance(getMapEndX(), blob.y, blob.x, blob.y)            ]);            var lineLeft = this.followAngle(295, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(65, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        if (blob.y > getMapEndY() - distanceFromWallY) {            BOTTOM            window.log(BOTTOM);            listToUse.push([                [25, true],                [155, false], this.computeInexpensiveDistance(blob.x, getMapEndY(), blob.x, blob.y)            ]);            var lineLeft = this.followAngle(25, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(155, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        return listToUse;    };
    listToUse contains angles in the form of [angle, boolean].    boolean is true when the range is starting. False when it's ending.    range = [[angle1, true], [angle2, false]]
    this.getAngleIndex = function(listToUse, angle) {        if (listToUse.length === 0) {            return 0;        }
        for (var i = 0; i < listToUse.length; i++) {            if (angle <= listToUse[i][0]) {                return i;            }        }
        return listToUse.length;    };
    this.addAngle = function(listToUse, range) {        #1 Find first open element        #2 Try to add range1 to the list. If it is within other range, don't add it, set a boolean.        #3 Try to add range2 to the list. If it is withing other range, don't add it, set a boolean.
        TODO: Only add the new range at the end after the right stuff has been removed.
        var newListToUse = listToUse.slice();
        var startIndex = 1;
        if (newListToUse.length > 0 && !newListToUse[0][1]) {            startIndex = 0;        }
        var startMark = this.getAngleIndex(newListToUse, range[0][0]);        var startBool = this.mod(startMark, 2) != startIndex;
        var endMark = this.getAngleIndex(newListToUse, range[1][0]);        var endBool = this.mod(endMark, 2) != startIndex;
        var removeList = [];
        if (startMark != endMark) {            Note: If there is still an error, this would be it.            var biggerList = 0;            if (endMark == newListToUse.length) {                biggerList = 1;            }
            for (var i = startMark; i < startMark + this.mod(endMark - startMark, newListToUse.length + biggerList); i++) {                removeList.push(this.mod(i, newListToUse.length));            }        } else if (startMark < newListToUse.length && endMark < newListToUse.length) {            var startDist = this.mod(newListToUse[startMark][0] - range[0][0], 360);            var endDist = this.mod(newListToUse[endMark][0] - range[1][0], 360);
            if (startDist < endDist) {                for (var i = 0; i < newListToUse.length; i++) {                    removeList.push(i);                }            }        }
        removeList.sort(function(a, b){return b-a;});
        for (var i = 0; i < removeList.length; i++) {            newListToUse.splice(removeList[i], 1);        }
        if (startBool) {            newListToUse.splice(this.getAngleIndex(newListToUse, range[0][0]), 0, range[0]);        }        if (endBool) {            newListToUse.splice(this.getAngleIndex(newListToUse, range[1][0]), 0, range[1]);        }
        return newListToUse;    };
    this.getAngleRange = function(blob1, blob2, index, radius) {        var angleStuff = this.getEdgeLinesFromPoint(blob1, blob2, radius);
        var leftAngle = angleStuff[0];        var rightAngle = this.rangeToAngle(angleStuff);        var difference = angleStuff[1];
        drawPoint(angleStuff[2][0], angleStuff[2][1], 3, );        drawPoint(angleStuff[3][0], angleStuff[3][1], 3, );
        window.log(Adding badAngles:  + leftAngle + ,  + rightAngle +  diff:  + difference);
        var lineLeft = this.followAngle(leftAngle, blob1.x, blob1.y, 150 + blob1.size - index * 10);        var lineRight = this.followAngle(rightAngle, blob1.x, blob1.y, 150 + blob1.size - index * 10);
        if (blob2.isVirus()) {            drawLine(blob1.x, blob1.y, lineLeft[0], lineLeft[1], 6);            drawLine(blob1.x, blob1.y, lineRight[0], lineRight[1], 6);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob1.x, blob1.y, 6);        } else if(getCells().hasOwnProperty(blob2.id)) {            drawLine(blob1.x, blob1.y, lineLeft[0], lineLeft[1], 0);            drawLine(blob1.x, blob1.y, lineRight[0], lineRight[1], 0);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob1.x, blob1.y, 0);        } else {            drawLine(blob1.x, blob1.y, lineLeft[0], lineLeft[1], 3);            drawLine(blob1.x, blob1.y, lineRight[0], lineRight[1], 3);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob1.x, blob1.y, 3);        }
        return [leftAngle, difference];    };
    Given a list of conditions, shift the angle to the closest available spot respecting the range given.    this.shiftAngle = function(listToUse, angle, range) {        TODO: shiftAngle needs to respect the range! DONE?        for (var i = 0; i < listToUse.length; i++) {            if (this.angleIsWithin(angle, listToUse[i])) {                window.log(Shifting needed!);
                var angle1 = listToUse[i][0];                var angle2 = this.rangeToAngle(listToUse[i]);
                var dist1 = this.mod(angle - angle1, 360);                var dist2 = this.mod(angle2 - angle, 360);
                if (dist1 < dist2) {                    if (this.angleIsWithin(angle1, range)) {                        return angle1;                    } else {                        return angle2;                    }                } else {                    if (this.angleIsWithin(angle2, range)) {                        return angle2;                    } else {                        return angle1;                    }                }            }        }        window.log(No Shifting Was needed!);        return angle;    };
    /**     * This is the main bot logic. This is called quite often.     *  A 2 dimensional array with coordinates for every cells.  [[x, y], [x, y]]     */    this.mainLoop = function() {        var player = getPlayer();        var interNodes = getMemoryCells();
        if ( /*!toggle*/ 1) {            The following code converts the mouse position into an            absolute game coordinate.            var useMouseX = screenToGameX(getMouseX());            var useMouseY = screenToGameY(getMouseY());            tempPoint = [useMouseX, useMouseY, 1];
            The current destination that the cells were going towards.            var tempMoveX = getPointX();            var tempMoveY = getPointY();
            drawLine(getX() - (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), getX() + (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), 7);            drawLine(getX() - (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), getX() + (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), 7);            drawLine(getX() - (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), getX() - (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), 7);            drawLine(getX() + (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), getX() + (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), 7);
            This variable will be returned at the end.            It will contain the destination choices for all the cells.            BTW!!! ERROR ERROR ABORT MISSION!!!!!!! READ BELOW -----------                        SINCE IT'S STUPID NOW TO ASK EACH CELL WHERE THEY WANT TO GO,            THE BOT SHOULD SIMPLY PICK ONE AND THAT'S IT, I MEAN WTF....            var destinationChoices = []; destination, size, danger
            Just to make sure the player is alive.            if (player.length > 0) {
                Loop through all the player's cells.                for (var k = 0; k < player.length; k++) {                    if (true) {                        drawPoint(player[k].x, player[k].y + player[k].size, 0,  + (getLastUpdate() - player[k].birth) +  /  + parseInt((30000 + (player[k].birthMass * 57) - (getLastUpdate() - player[k].birth))) +  /  + player[k].birthMass);                    }                }

                Loops only for one cell for now.                for (var k = 0; /*k < player.length*/ k < 1; k++) {
                    window.log(Working on blob:  + k);
                    drawCircle(player[k].x, player[k].y, player[k].size + this.splitDistance, 5);                    drawPoint(player[0].x, player[0].y - player[0].size, 3, """" + Math.floor(player[0].x) + "", "" + Math.floor(player[0].y));
                    var allDots = processEverything(interNodes);
                    loop through everything that is on the screen and                    separate everything in it's own category.                    var allIsAll = this.getAll(player[k]);
                    The food stored in element 0 of allIsAll                    var allPossibleFood = allIsAll[0];                    The threats are stored in element 1 of allIsAll                    var allPossibleThreats = allIsAll[1];                    The viruses are stored in element 2 of allIsAll                    var allPossibleViruses = allIsAll[2];
                    The bot works by removing angles in which it is too                    dangerous to travel towards to.                    var badAngles = [];                    var obstacleList = [];
                    var isSafeSpot = true;                    var isMouseSafe = true;
                    var clusterAllFood = this.clusterFood(allPossibleFood, player[k].size);
                    window.log(Looking for enemies!);
                    Loop through all the cells that were identified as threats.                    for (var i = 0; i < allPossibleThreats.length; i++) {
                        var enemyDistance = this.computeDistance(allPossibleThreats[i].x, allPossibleThreats[i].y, player[k].x, player[k].y, allPossibleThreats[i].size);
                        allPossibleThreats[i].enemyDist = enemyDistance;                    }
                    /*allPossibleThreats.sort(function(a, b){                        return a.enemyDist-b.enemyDist;                    })*/
                    for (var i = 0; i < allPossibleThreats.length; i++) {
                        var enemyDistance = this.computeDistance(allPossibleThreats[i].x, allPossibleThreats[i].y, player[k].x, player[k].y);
                        var splitDangerDistance = allPossibleThreats[i].size + this.splitDistance + 150;
                        var normalDangerDistance = allPossibleThreats[i].size + 150;
                        var shiftDistance = player[k].size;
                        window.log(Found distance.);
                        var enemyCanSplit = this.canSplit(player[k], allPossibleThreats[i]);                        var secureDistance = (enemyCanSplit ? splitDangerDistance : normalDangerDistance);
                        for (var j = clusterAllFood.length - 1; j >= 0 ; j--) {                            if (this.computeDistance(allPossibleThreats[i].x, allPossibleThreats[i].y, clusterAllFood[j][0], clusterAllFood[j][1]) < secureDistance + shiftDistance)                                clusterAllFood.splice(j, 1);                        }
                        window.log(Removed some food.);
                        if (enemyCanSplit) {                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, splitDangerDistance, 0);                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, splitDangerDistance + shiftDistance, 6);                        } else {                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, normalDangerDistance, 3);                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, normalDangerDistance + shiftDistance, 6);                        }
                        if (allPossibleThreats[i].danger && getLastUpdate() - allPossibleThreats[i].dangerTimeOut > 1000) {
                            allPossibleThreats[i].danger = false;                        }
                        /*if ((enemyCanSplit && enemyDistance < splitDangerDistance) ||                            (!enemyCanSplit && enemyDistance < normalDangerDistance)) {                            allPossibleThreats[i].danger = true;                            allPossibleThreats[i].dangerTimeOut = f.getLastUpdate();                        }*/
                        window.log(Figured out who was important.);
                        if ((enemyCanSplit && enemyDistance < splitDangerDistance) || (enemyCanSplit && allPossibleThreats[i].danger)) {
                            badAngles.push(this.getAngleRange(player[k], allPossibleThreats[i], i, splitDangerDistance).concat(allPossibleThreats[i].enemyDist));
                        } else if ((!enemyCanSplit && enemyDistance < normalDangerDistance) || (!enemyCanSplit && allPossibleThreats[i].danger)) {
                            badAngles.push(this.getAngleRange(player[k], allPossibleThreats[i], i, normalDangerDistance).concat(allPossibleThreats[i].enemyDist));
                        } else if (enemyCanSplit && enemyDistance < splitDangerDistance + shiftDistance) {                            var tempOb = this.getAngleRange(player[k], allPossibleThreats[i], i, splitDangerDistance + shiftDistance);                            var angle1 = tempOb[0];                            var angle2 = this.rangeToAngle(tempOb);
                            obstacleList.push([[angle1, true], [angle2, false]]);                        } else if (!enemyCanSplit && enemyDistance < normalDangerDistance + shiftDistance) {                            var tempOb = this.getAngleRange(player[k], allPossibleThreats[i], i, normalDangerDistance + shiftDistance);                            var angle1 = tempOb[0];                            var angle2 = this.rangeToAngle(tempOb);
                            obstacleList.push([[angle1, true], [angle2, false]]);                        }                        window.log(Done with enemy:  + i);                    }
                    window.log(Done looking for enemies!);
                    var goodAngles = [];                    var stupidList = [];
                    for (var i = 0; i < allPossibleViruses.length; i++) {                        if (player[k].size < allPossibleViruses[i].size) {                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, allPossibleViruses[i].size + 10, 3);                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, allPossibleViruses[i].size * 2, 6);
                        } else {                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, player[k].size + 50, 3);                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, player[k].size * 2, 6);                        }                    }
                    for (var i = 0; i < allPossibleViruses.length; i++) {                        var virusDistance = this.computeDistance(allPossibleViruses[i].x, allPossibleViruses[i].y, player[k].x, player[k].y);                        if (player[k].size < allPossibleViruses[i].size) {                            if (virusDistance < (allPossibleViruses[i].size * 2)) {                                var tempOb = this.getAngleRange(player[k], allPossibleViruses[i], i, allPossibleViruses[i].size + 10);                                var angle1 = tempOb[0];                                var angle2 = this.rangeToAngle(tempOb);                                obstacleList.push([[angle1, true], [angle2, false]]);                            }                        } else {                            if (virusDistance < (player[k].size * 2)) {                                var tempOb = this.getAngleRange(player[k], allPossibleViruses[i], i, player[k].size + 50);                                var angle1 = tempOb[0];                                var angle2 = this.rangeToAngle(tempOb);                                obstacleList.push([[angle1, true], [angle2, false]]);                            }                        }                    }
                    if (badAngles.length > 0) {                        NOTE: This is only bandaid wall code. It's not the best way to do it.                        stupidList = this.addWall(stupidList, player[k]);                    }
                    for (var i = 0; i < badAngles.length; i++) {                        var angle1 = badAngles[i][0];                        var angle2 = this.rangeToAngle(badAngles[i]);                        stupidList.push([[angle1, true], [angle2, false], badAngles[i][2]]);                    }
                    stupidList.push([[45, true], [135, false]]);                    stupidList.push([[10, true], [200, false]]);
                    stupidList.sort(function(a, b){                        window.log(Distance:  + a[2] + ,  + b[2]);                        return a[2]-b[2];                    });
                    window.log(Added random noob stuff.);
                    var sortedInterList = [];                    var sortedObList = [];
                    for (var i = 0; i < stupidList.length; i++) {                        window.log(Adding to sorted:  + stupidList[i][0][0] + ,  + stupidList[i][1][0]);                        var tempList = this.addAngle(sortedInterList, stupidList[i]);
                        if (tempList.length === 0) {                            window.log(MAYDAY IT'S HAPPENING!);                            break;                        } else {                            sortedInterList = tempList;                        }                    }
                    for (var i = 0; i < obstacleList.length; i++) {                        sortedObList = this.addAngle(sortedObList, obstacleList[i]);
                        if (sortedObList.length === 0) {                            break;                        }                    }
                    var offsetI = 0;                    var obOffsetI = 1;
                    if (sortedInterList.length > 0 && sortedInterList[0][1]) {                        offsetI = 1;                    }                    if (sortedObList.length > 0 && sortedObList[0][1]) {                        obOffsetI = 0;                    }
                    var goodAngles = [];                    var obstacleAngles = [];
                    for (var i = 0; i < sortedInterList.length; i += 2) {                        var angle1 = sortedInterList[this.mod(i + offsetI, sortedInterList.length)][0];                        var angle2 = sortedInterList[this.mod(i + 1 + offsetI, sortedInterList.length)][0];                        var diff = this.mod(angle2 - angle1, 360);                        goodAngles.push([angle1, diff]);                    }
                    for (var i = 0; i < sortedObList.length; i += 2) {                        var angle1 = sortedObList[this.mod(i + obOffsetI, sortedObList.length)][0];                        var angle2 = sortedObList[this.mod(i + 1 + obOffsetI, sortedObList.length)][0];                        var diff = this.mod(angle2 - angle1, 360);                        obstacleAngles.push([angle1, diff]);                    }
                    for (var i = 0; i < goodAngles.length; i++) {                        var line1 = this.followAngle(goodAngles[i][0], player[k].x, player[k].y, 100 + player[k].size);                        var line2 = this.followAngle(this.mod(goodAngles[i][0] + goodAngles[i][1], 360), player[k].x, player[k].y, 100 + player[k].size);                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 1);                        drawLine(player[k].x, player[k].y, line2[0], line2[1], 1);
                        drawArc(line1[0], line1[1], line2[0], line2[1], player[k].x, player[k].y, 1);
                        drawPoint(player[0].x, player[0].y, 2, """");
                        drawPoint(line1[0], line1[1], 0,  + i + : 0);                        drawPoint(line2[0], line2[1], 0,  + i + : 1);                    }
                    for (var i = 0; i < obstacleAngles.length; i++) {                        var line1 = this.followAngle(obstacleAngles[i][0], player[k].x, player[k].y, 50 + player[k].size);                        var line2 = this.followAngle(this.mod(obstacleAngles[i][0] + obstacleAngles[i][1], 360), player[k].x, player[k].y, 50 + player[k].size);                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 6);                        drawLine(player[k].x, player[k].y, line2[0], line2[1], 6);
                        drawArc(line1[0], line1[1], line2[0], line2[1], player[k].x, player[k].y, 6);
                        drawPoint(player[0].x, player[0].y, 2, """");
                        drawPoint(line1[0], line1[1], 0,  + i + : 0);                        drawPoint(line2[0], line2[1], 0,  + i + : 1);                    }
                    if (this.toggleFollow && goodAngles.length === 0) {                        This is the follow the mouse mode                        var distance = this.computeDistance(player[k].x, player[k].y, tempPoint[0], tempPoint[1]);
                        var shiftedAngle = this.shiftAngle(obstacleAngles, this.getAngle(tempPoint[0], tempPoint[1], player[k].x, player[k].y), [0, 360]);
                        var destination = this.followAngle(shiftedAngle, player[k].x, player[k].y, distance);
                        destinationChoices = destination;                        drawLine(player[k].x, player[k].y, destination[0], destination[1], 1);                        tempMoveX = destination[0];                        tempMoveY = destination[1];
                    } else if (goodAngles.length > 0) {                        var bIndex = goodAngles[0];                        var biggest = goodAngles[0][1];                        for (var i = 1; i < goodAngles.length; i++) {                            var size = goodAngles[i][1];                            if (size > biggest) {                                biggest = size;                                bIndex = goodAngles[i];                            }                        }                        var perfectAngle = this.mod(bIndex[0] + bIndex[1] / 2, 360);
                        perfectAngle = this.shiftAngle(obstacleAngles, perfectAngle, bIndex);
                        var line1 = this.followAngle(perfectAngle, player[k].x, player[k].y, verticalDistance());
                        destinationChoices = line1;                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 7);                        tempMoveX = line1[0];                        tempMoveY = line1[1];                    } else if (badAngles.length > 0 && goodAngles.length === 0) {                        When there are enemies around but no good angles                        You're likely screwed. (This should never happen.)
                        window.log(Failed);                        destinationChoices = [tempMoveX, tempMoveY];                        /*var angleWeights = [] //Put weights on the angles according to enemy distance                        for (var i = 0; i < allPossibleThreats.length; i++){                            var dist = this.computeDistance(player[k].x, player[k].y, allPossibleThreats[i].x, allPossibleThreats[i].y);                            var angle = this.getAngle(allPossibleThreats[i].x, allPossibleThreats[i].y, player[k].x, player[k].y);                            angleWeights.push([angle,dist]);                        }                        var maxDist = 0;                        var finalAngle = 0;                        for (var i = 0; i < angleWeights.length; i++){                            if (angleWeights[i][1] > maxDist){                                maxDist = angleWeights[i][1];                                finalAngle = this.mod(angleWeights[i][0] + 180, 360);                            }                        }                        var line1 = this.followAngle(finalAngle,player[k].x,player[k].y,f.verticalDistance());                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 2);                        destinationChoices.push(line1);*/                    } else if (clusterAllFood.length > 0) {                        for (var i = 0; i < clusterAllFood.length; i++) {                            window.log(mefore:  + clusterAllFood[i][2]);                            This is the cost function. Higher is better.
                                var clusterAngle = this.getAngle(clusterAllFood[i][0], clusterAllFood[i][1], player[k].x, player[k].y);
                                clusterAllFood[i][2] = clusterAllFood[i][2] * 6 - this.computeDistance(clusterAllFood[i][0], clusterAllFood[i][1], player[k].x, player[k].y);                                window.log(Current Value:  + clusterAllFood[i][2]);
                                (goodAngles[bIndex][1] / 2 - (Math.abs(perfectAngle - clusterAngle)));
                                clusterAllFood[i][3] = clusterAngle;
                                drawPoint(clusterAllFood[i][0], clusterAllFood[i][1], 1, );                                window.log(After:  + clusterAllFood[i][2]);                        }
                        var bestFoodI = 0;                        var bestFood = clusterAllFood[0][2];                        for (var i = 1; i < clusterAllFood.length; i++) {                            if (bestFood < clusterAllFood[i][2]) {                                bestFood = clusterAllFood[i][2];                                bestFoodI = i;                            }                        }
                        window.log(Best Value:  + clusterAllFood[bestFoodI][2]);
                        var distance = this.computeDistance(player[k].x, player[k].y, clusterAllFood[bestFoodI][0], clusterAllFood[bestFoodI][1]);
                        var shiftedAngle = this.shiftAngle(obstacleAngles, this.getAngle(clusterAllFood[bestFoodI][0], clusterAllFood[bestFoodI][1], player[k].x, player[k].y), [0, 360]);
                        var destination = this.followAngle(shiftedAngle, player[k].x, player[k].y, distance);
                        destinationChoices = destination;                        tempMoveX = destination[0];                        tempMoveY = destination[1];                        drawLine(player[k].x, player[k].y, destination[0], destination[1], 1);                    } else {                        If there are no enemies around and no food to eat.                        destinationChoices = [tempMoveX, tempMoveY];                    }
                    drawPoint(tempPoint[0], tempPoint[1], tempPoint[2], );                    drawPoint(tempPoint[0], tempPoint[1], tempPoint[2], """" + Math.floor(this.computeDistance(tempPoint[0], tempPoint[1], I, J)));                    drawLine(tempPoint[0], tempPoint[1], player[0].x, player[0].y, 6);                    window.log(""Slope: "" + slope(tempPoint[0], tempPoint[1], player[0].x, player[0].y) + "" Angle: "" + getAngle(tempPoint[0], tempPoint[1], player[0].x, player[0].y) + "" Side: "" + this.mod(getAngle(tempPoint[0], tempPoint[1], player[0].x, player[0].y) - 90, 360));                    tempPoint[2] = 1;
                    window.log(Done working on blob:  + i);                }
                TODO: Find where to go based on destinationChoices.                /*var dangerFound = false;                for (var i = 0; i < destinationChoices.length; i++) {                    if (destinationChoices[i][2]) {                        dangerFound = true;                        break;                    }                }                destinationChoices.sort(function(a, b){return b[1] - a[1]});                if (dangerFound) {                    for (var i = 0; i < destinationChoices.length; i++) {                        if (destinationChoices[i][2]) {                            tempMoveX = destinationChoices[i][0][0];                            tempMoveY = destinationChoices[i][0][1];                            break;                        }                    }                } else {                    tempMoveX = destinationChoices.peek()[0][0];                    tempMoveY = destinationChoices.peek()[0][1];                    //window.log(""Done "" + tempMoveX + "", "" + tempMoveY);                }*/            }            window.log(MOVING RIGHT NOW!);
            window.log(______Never lied ever in my life.);
            return destinationChoices;        }    };};window.botList.push(new AposBot());
if ( typeof window.updateBotList == function ) {    window.updateBotList(); This function might not exist yet.} else {    window.log(The launcher is not yet started.);}"

"use strict;/* * Karma Configuration: ""full"" version. * * This configuration runs a temporary `webpack-dev-server` and builds * the test files one-off for just a single run. This is appropriate for a * CI environment or if you're not otherwise running `npm run dev|hot`. */var webpackCfg = require(./webpack.config.test);
 BUG: Karma 0.13 is broken for circular imports TODO: Upgrade Karma to 0.13 when upstream bug is fixed. https://github.com/FormidableLabs/        formidable-react-component-boilerplate/issues/25
module.exports = function (config) {   Start with the ""dev"" (webpack-dev-server is already running) config   and add in the webpack stuff.  require(./karma.conf.dev)(config);
   Overrides.  config.set({    preprocessors: {      test/client/main.js: [webpack]    },    files: [       Sinon has issues with webpack. Do global include.      node_modules/sinon/pkg/sinon.js,
       Test bundle (created via local webpack-dev-server in this config).      test/client/main.js    ],    webpack: webpackCfg,    webpackServer: {      port: 3002,  Choose a non-conflicting port (3000 app, 3001 test dev)      quiet: false,      noInfo: true,      stats: {        assets: false,        colors: true,        version: false,        hash: false,        timings: false,        chunks: false,        chunkModules: false      }    }  });};"
"use strict;/* * Karma Configuration: ""dev"" version. * * This configuration relies on a `webpack-dev-server` already running and * bundling `webpack.config.test.js` on port 3001. If this is not running, * then the alternate `karma.conf.js` file will _also_ run the webpack dev * server during the test run. */module.exports = function (config) {  config.set({    frameworks: [mocha, phantomjs-shim],    reporters: [spec],    browsers: [PhantomJS],    basePath: .,  repository root.    files: [       Sinon has issues with webpack. Do global include.      node_modules/sinon/pkg/sinon.js,
       Test bundle (must be created via `npm run dev|hot|server-test`)      http://127.0.0.1:3001/assets/main.js    ],    port: 9999,    singleRun: true,    client: {      mocha: {        ui: bdd      }    }  });};"
"use strict;/* * Karma Configuration: ""coverage"" version. * * This configuration is the same as basic one-shot version, just with coverage. */var webpackCovCfg = require(./webpack.config.coverage);
module.exports = function (config) {  require(./karma.conf)(config);  config.set({    reporters: [spec, coverage],    webpack: webpackCovCfg,    coverageReporter: {      reporters: [        { type: json, file: coverage.json },        { type: lcov },        { type: text-summary }      ],      dir: coverage/client    }  });};"
module.exports = require(./dist/play)
require(./dist/app.css)module.exports = require(./dist/app)
"var requirejs = ({	shim: {		underscore: {exports: _},		jquery.ui: {deps: [jquery],exports: jQuery},		jquery.scrollto: {deps: [jquery],exports: jQuery}	},	paths: {		jquery: http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min,		jquery.ui: http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.23/jquery-ui.min,		jquery.scrollto: lib/jquery/jquery.scrollTo.min,		underscore: http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.1/underscore-min,		knockout:http://cdnjs.cloudflare.com/ajax/libs/knockout/2.1.0/knockout-min,
		text: lib/require/text,		domready: lib/require/domready	},	config:{		scm:{			playback:{				youtube:(youtube.com|youtu.be),				soundcloud:^http(s)?soundcloud.com,				exfm: ^( *)(http(s)?://)?(www.)?ex.fm,				soundmanager:.*			},			playlist:{				youtube:(youtube.com|youtu.be),				soundcloud:^http(s)?soundcloud.com,				rss:.*			}		}	},	waitSeconds: 900,	baseUrl: js/});
soundManager.preferFlash = false;soundManager.useHTML5Audio = true;soundManager.url = swf/;soundManager.allowScriptAccess = always;"
"module.exports = function ( grunt ) {
  /**   * Load required Grunt tasks. These are installed based on the versions listed   * in `package.json` when you do `npm install` in this directory.   */  require(load-grunt-tasks)(grunt);  require(time-grunt)(grunt);
  /**   * Load in our build configuration file.   */  var userConfig = require( ./build.config.js );
  /**   * This is the configuration object Grunt uses to give each plugin its   * instructions.   */  var taskConfig = {    /**     * We read in our `package.json` file so we can access the package name and     * version. It's already there, so we don't repeat ourselves here.     */    pkg: grunt.file.readJSON(package.json),
    /**     * The banner is the comment that is placed at the top of our compiled     * source files. It is first processed as a Grunt template, where the `<%=`     * pairs are evaluated based on this very configuration object.     */    meta: {      banner:        /** +         * <%= pkg.name %> - v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %> +         * +         * Copyright (c) <%= grunt.template.today(""yyyy"") %> <%= pkg.name %> +         */    },
    /**     * Creates a changelog on a new version.     */    changelog: {      options: {        dest: CHANGELOG.md,        templateFile: misc/changelog.tpl.md      }    },
    /**     * Increments the version number, etc.     */    bump: {      options: {        files: [          package.json,          bower.json        ],        commit: false,        commitMessage: chore(release): v%VERSION%,        commitFiles: [          package.json,          client/bower.json        ],        createTag: false,        tagName: v%VERSION%,        tagMessage: Version %VERSION%,        push: false,        pushTo: origin      }    },
    /**     * The directories to delete when `grunt clean` is executed.     */    clean: {      all: {        files: [{          dot: true,          src: [            <%= build_dir %>,            <%= compile_dir %>,            .tmp          ]        }]      }    },
    /**     * The `copy` task just copies files from A to B. We use it here to copy     * our project assets (images, fonts, etc.) and javascripts into     * `build_dir`, and then to copy the assets to `compile_dir`.     */    copy: {      build_app_assets: {        files: [          {            src: [ ** ],            dest: <%= build_dir %>/assets/,            cwd: src/assets,            expand: true          }        ]      },      build_vendor_assets: {        files: [          {            src: [ <%= vendor_files.assets %> ],            dest: <%= build_dir %>/assets/,            cwd: .,            expand: true,            flatten: true          }        ]      },      build_appjs: {        files: [          {            src: [ <%= app_files.js %> ],            dest: <%= build_dir %>/,            cwd: .,            expand: true          }        ]      },      build_vendorjs: {        files: [          {            src: [ <%= vendor_files.js %> ],            dest: <%= build_dir %>/,            cwd: .,            expand: true          }        ]      },      build_vendorcss: {        files: [          {            src: [ <%= vendor_files.css %> ],            dest: <%= build_dir %>/,            cwd: .,            expand: true          }        ]      },      compile_assets: {        files: [          {            src: [ ** ],            dest: <%= compile_dir %>/assets,            cwd: <%= build_dir %>/assets,            expand: true          }        ]      },      mario: {        files: [          {            src: [ ** ],            dest: <%= build_dir %>/assets/FullScreenMario,            cwd: <%= vendor_dir %>/FullScreenMario,            expand: true          }        ]      }
    },
    /**     * `grunt concat` concatenates multiple source files into a single file.     */    concat: {      /**       * The `build_css` target concatenates compiled CSS and vendor CSS       * together.       */      build_css: {        src: [          <%= vendor_files.css %>,          <%= build_files.css %>        ],        dest: <%= build_dir %>/assets/<%= pkg.name %>-<%= pkg.version %>.css      },      /**       * The `compile_js` target is the concatenation of our application source       * code and all specified vendor source code into a single file.       */      compile_js: {        options: {          banner: <%= meta.banner %>        },        src: [          <%= vendor_files.js %>,          module.prefix,          <%= build_dir %>/src/**/*.module.js,          <%= build_dir %>/src/**/*.js,          <%= html2js.app.dest %>,          <%= html2js.common.dest %>,          module.suffix        ],        dest: <%= compile_dir %>/assets/<%= pkg.name %>-<%= pkg.version %>.js      }    },
    /**     * `ng-annotate` annotates the sources before minifying. That is, it allows us     * to code without the array syntax.     */    ngAnnotate: {      compile: {        files: [          {            src: [ <%= app_files.js %> ],            cwd: <%= build_dir %>,            dest: <%= build_dir %>,            expand: true          }        ]      }    },
    /**     * Minify the sources!     */    uglify: {      compile: {        options: {          banner: <%= meta.banner %>        },        files: {          <%= concat.compile_js.dest %>: <%= concat.compile_js.dest %>        }      }    },
    /**     * `grunt-contrib-compass` handles our SASS compilation and uglification automatically.     */    compass: {      options: {        sassDir: src,        cssDir: <%= build_dir %>/css,        outputStyle: compressed,        force: true      },      build: {        options: {          outputStyle: expanded,          force: false        }      },      compile: {        options: {}      }    },
    /**     * `jshint` defines the rules of our linter as well as which files we     * should check. This file, all javascript sources, and all our unit tests     * are linted based on the policies listed in `options`. But we can also     * specify exclusionary patterns by prefixing them with an exclamation     * point (!); this is useful when code comes from a third party but is     * nonetheless inside `src/`.     */    jshint: {      src: {        options: {          jshintrc: .jshintrc        },        files: {          src: [<%= app_files.js %>]        }      },      test: [        <%= app_files.jsunit %>      ],      gruntfile: [        Gruntfile.js      ],      options: {        curly: true,        immed: true,        newcap: true,        noarg: true,        sub: true,        boss: true,        eqnull: true      }    },
    jscs: {      src: [<%= app_files.js %>],      options: {        force: true,        config: .jscsrc      }    },
    /**     * HTML2JS is a Grunt plugin that takes all of your template files and     * places them into JavaScript files as strings that are added to     * AngularJS's template cache. This means that the templates too become     * part of the initial payload as one JavaScript file. Neat!     */    html2js: {      /**       * These are the templates from `src/app`.       */      app: {        options: {          base: src/app        },        src: [ <%= app_files.atpl %> ],        dest: <%= build_dir %>/templates-app.js      },
      /**       * These are the templates from `src/common`.       */      common: {        options: {          base: src/common        },        src: [ <%= app_files.ctpl %> ],        dest: <%= build_dir %>/templates-common.js      }    },
    /**     * The Karma configurations.     */    karma: {      options: {        configFile: <%= build_dir %>/karma-unit.js      },      unit: {        port: 9019,        background: true      },      continuous: {        singleRun: true      }    },
    /**     * The `index` task compiles the `index.html` file as a Grunt template. CSS     * and JS files co-exist here but they get split apart later.     */    index: {
      /**       * During development, we don't want to have wait for compilation,       * concatenation, minification, etc. So to avoid these steps, we simply       * add all script files directly to the `<head>` of `index.html`. The       * `src` property contains the list of included files.       */      build: {        dir: <%= build_dir %>,        src: [          <%= vendor_files.js %>,          <%= build_dir %>/src/**/*.module.js,          <%= build_dir %>/src/**/*.js,          <%= html2js.common.dest %>,          <%= html2js.app.dest %>,          <%= vendor_files.css %>,          <%= build_files.css %>        ]      },
      /**       * When it is time to have a completely compiled application, we can       * alter the above to include only a single JavaScript and a single CSS       * file. Now we're back!       */      compile: {        dir: <%= compile_dir %>,        src: [          <%= concat.compile_js.dest %>,          <%= vendor_files.css %>,          <%= build_dir %>/assets/<%= pkg.name %>-<%= pkg.version %>.css        ]      }    },
    /**     * This task compiles the karma template so that changes to its file array     * don't have to be managed manually.     */    karmaconfig: {      unit: {        dir: <%= build_dir %>,        src: [          <%= vendor_files.js %>,          <%= html2js.app.dest %>,          <%= html2js.common.dest %>,          <%= test_files.js %>        ]      }    },
    /**     * And for rapid development, we have a watch set up that checks to see if     * any of the files listed below change, and then to execute the listed     * tasks when they do. This just saves us from having to type ""grunt"" into     * the command-line every time we want to see what we're working on; we can     * instead just leave ""grunt watch"" running in a background terminal. Set it     * and forget it, as Ron Popeil used to tell us.     *     * But we don't need the same thing to happen for all the files.     */    delta: {      /**       * By default, we want the Live Reload to work for all tasks; this is       * overridden in some tasks (like this file) where browser resources are       * unaffected. It runs by default on port 35729, which your browser       * plugin should auto-detect.       */      options: {        livereload: true      },
      /**       * When the Gruntfile changes, we just want to lint it. In fact, when       * your Gruntfile changes, it will automatically be reloaded!       */      gruntfile: {        files: Gruntfile.js,        tasks: [ jshint:gruntfile ],        options: {          livereload: false        }      },
      /**       * When our JavaScript source files change, we want to run lint them and       * run our unit tests.       */      jssrc: {        files: [          <%= app_files.js %>        ],        tasks: [ jshint:src, karma:unit:run, beep:error, copy:build_appjs ]      },
      /**       * When assets are changed, copy them. Note that this will *not* copy new       * files, so this is probably not very useful.       */      assets: {        files: [          src/assets/**/*        ],        tasks: [ copy:build_app_assets, copy:build_vendor_assets ]      },
      mario: {        files: [          vendor/FullScreenMario/**/*        ],        tasks: [ copy:mario ]      },
      /**       * When index.html changes, we need to compile it.       */      html: {        files: [ <%= app_files.html %> ],        tasks: [ index:build, beep:error ]      },
      /**       * When our templates change, we only rewrite the template cache.       */      tpls: {        files: [          <%= app_files.atpl %>,          <%= app_files.ctpl %>        ],        tasks: [ html2js, beep:error ]      },
      /**       * When the CSS files change, we need to compile and minify them.       */      compass: {        files: [ src/sass/*.scss ],        tasks: [ compass:build, concat:build_css, beep:error ]      },
      /**       * When a JavaScript unit test file changes, we only want to lint it and       * run the unit tests. We don't want to do any live reloading.       */      jsunit: {        files: [          <%= app_files.jsunit %>        ],        tasks: [ jshint:test, karma:unit:run, beep:error ],        options: {          livereload: false        }      }    }
  };
  grunt.initConfig( grunt.util._.extend( taskConfig, userConfig ) );
  /**   * In order to make it safe to just compile or copy *only* what was changed,   * we need to ensure we are starting from a clean, fresh build. So we rename   * the `watch` task to `delta` (that's why the configuration var above is   * `delta`) and then add a new task called `watch` that does a clean build   * before watching for changes.   */  grunt.renameTask( watch, delta );  grunt.registerTask( watch, [ build, karma:unit, delta ]);
  /**   * The default task is to build and compile.   */  grunt.registerTask( default, [ build, compile ] );
  /**   * The `build` task gets your app ready to run for development and testing.   */  grunt.registerTask( build, [    gitHooks, clean:all, html2js, jshint, compass:build,    copy:build_app_assets, copy:build_vendor_assets,    copy:build_appjs, copy:build_vendorjs, copy:build_vendorcss, concat:build_css, copy:mario, index:build, karmaconfig,    karma:continuous  ]);
  /**   * The `compile` task gets your app ready for deployment by concatenating and   * minifying your code.   */  grunt.registerTask( compile, [    compass:compile, concat:build_css, copy:compile_assets, ngAnnotate, concat:compile_js, uglify, index:compile  ]);
  /**   * A utility function to get all app JavaScript sources.   */  function filterForJS ( files ) {    return files.filter( function ( file ) {      return file.match( js );    });  }
  /**   * A utility function to get all app CSS sources.   */  function filterForCSS ( files ) {    return files.filter( function ( file ) {      return file.match( css );    });  }
  /**   * The index.html template includes the stylesheet and javascript sources   * based on dynamic names calculated in this Gruntfile. This task assembles   * the list into variables for the template to use and then runs the   * compilation.   */  grunt.registerMultiTask( index, Process index.html template, function () {    var dirRE = new RegExp( ^(+grunt.config(build_dir)+|+grunt.config(compile_dir)+), g );    var jsFiles = filterForJS( this.filesSrc ).map( function ( file ) {      return file.replace( dirRE,  );    });    var cssFiles = filterForCSS( this.filesSrc ).map( function ( file ) {      return file.replace( dirRE,  );    });
    grunt.file.copy(src/index.html, this.data.dir + /index.html, {      process: function ( contents, path ) {        return grunt.template.process( contents, {          data: {            scripts: jsFiles,            styles: cssFiles,            name: grunt.config( pkg.name ),            version: grunt.config( pkg.version )          }        });      }    });  });
  /**   * In order to avoid having to specify manually the files needed for karma to   * run, we use grunt to manage the list for us. The `karma/*` files are   * compiled as grunt templates for use by Karma. Yay!   */  grunt.registerMultiTask( karmaconfig, Process karma config templates, function () {    var jsFiles = filterForJS( this.filesSrc );
    grunt.file.copy( karma/karma-unit.tpl.js, grunt.config( build_dir ) + /karma-unit.js, {      process: function ( contents, path ) {        return grunt.template.process( contents, {          data: {            scripts: jsFiles          }        });      }    });  });
  /**   * Install Git Hooks   */  grunt.registerTask(gitHooks, Install commit message enforce script if it doesnt exist, function() {    if (!grunt.file.exists(.git/hooks/commit-msg)) {      grunt.file.copy(misc/validate-commit-msg.js, .git/hooks/commit-msg);      require(fs).chmodSync(.git/hooks/commit-msg, 0755);    }  });
};"
" vim: set et sw=4 ts=4 sts=4 ft=javascript fdm=marker ff=unix fenc=utf8 nobomb:/** *  <> * @date   2013-03-27 * @link   http://www.gracecode.com/ */
~function() {     http://developer.chrome.com/extensions/content_scripts.html    var flags = [videoId, iid, $SCOPE, vid, info, COVER_INFO, XL_CLOUD_FX_INSTANCE, _page_, aid, system];
    for(var i = 0; i < flags.length; i++) {            var flag = flags[i], value = window[flag];
            if (flag == $SCOPE && window[flag]) {                value = window[flag][video][vid];                flag = SCOPE;            }
        try {            document.body.setAttribute(data- + flag, value || );        }catch(e) {             ...        }    }}();

 vim: set et sw=4 ts=4 sts=4 ft=javascript fdm=marker ff=unix fenc=utf8 nobomb:/** *  <> * @date   2013-03-27 * @link   http://www.gracecode.com/ */
~function(cscope) {    var ATTR_VIDEO_ADDRESS = data-video-url;    var isSupportM3U8 = (document.createElement(video).canPlayType(application/x-mpegURL)) ? true : false;    var PLAYER_SCRIPT_URL = http://vjs.zencdn.net/c/video.js, PLAYER_CSS_URL = http://vjs.zencdn.net/c/video-js.css;    var replacedElement, orgialHTML;
    var flagElement = document.createElement(z);        flagElement.setAttribute(id, html5-player);        flagElement.setAttribute(title, Click to resume original player.);        flagElement.innerHTML = Embedded HTML5 Player;
    var segElement = document.createElement(z);        segElement.setAttribute(id, html5-player-seg);        segElement.innerHTML = 选择分段： ;
    flagElement.addEventListener(click, function(e) {        if (replacedElement) {            replacedElement.innerHTML = orgialHTML;        }
        flagElement.parentNode.removeChild(flagElement);        replacedElement.parentNode.removeChild(replacedElement);    });
    function getScript(url, success, error) {         var script = document.createElement(script);         script.setAttribute(src, url);         script.addEventListener(load,  success);         script.addEventListener(error, error);         document.body.appendChild(script);    };
    function loadCSS(url) {        var head  = document.getElementsByTagName(head)[0];        var link  = document.createElement(link);            link.rel  = stylesheet;            link.type = text/css;            link.href = url;            link.media = all;        head.appendChild(link);    };
    function log(message) {        console.log([HTML5 Player]  + message);    };
    function markVideoUrl(url) {        log(HTML5 Video Founded, The address is  + url);        <z id=""html5-player"">正在使用 HTML5 播放器</z>
        flagElement.setAttribute(ATTR_VIDEO_ADDRESS, url);        document.body.appendChild(flagElement);        document.body.setAttribute(ATTR_VIDEO_ADDRESS, url);    };
    var markSegs = function (index, callback) {        var b = function(index, callback) {            var link = document.createElement(a), call = callback;            link.innerHTML = index; link.title = 选择播放第+index +段视频;            link.onclick = function(e) {                var links = segElement.getElementsByTagName(a);
                for (var i = 0, len = links.length; i < len; i++) {                    links[i].className = ;                }
                links[index-1].className = current;                call();            };            segElement.appendChild(link);        }
        b(index, callback);        document.body.appendChild(segElement);        markSegs = b;    }
    var selectSegs = function(index) {        var links = segElement.getElementsByTagName(a);        links[index].onclick();    }
    function launchPlayer(element, url, success) {        var width = element.clientWidth, height = element.clientHeight;        var html  =         <video id=""my_video_1"" autoplay=""autoplay"" class=""video-js vjs-default-skin"" controls=""controls"" +              preload=""auto"" width=""+ width +"" height=""+ height +""> +            <source src=""+ url +"" type=""video/mp4"" /> +        </video>;
        if (!element || !url.length) {return;}
        replacedElement = element;        orgialHTML = element.innerHTML;
        element.innerHTML = html;        markVideoUrl(url);
		document.getElementById(my_video_1).addEventListener(ended, 			function(e) {				idSeg = document.getElementById(html5-player-seg);				var cur = parseInt(idSeg.getElementsByClassName(current)[0].innerHTML);				var len = idSeg.getElementsByTagName(a).length;				log(Event ended comes: cur= + cur +  len= + len);				if (cur < len) {					idSeg.getElementsByTagName(a)[cur].click();				}			}		);		        loadCSS(PLAYER_CSS_URL);        getScript(PLAYER_SCRIPT_URL, success);    };
    if (cscope.HTML5PlayerToolKit) { return; }    cscope.HTML5PlayerToolKit = {        getScript: getScript,        isSupportM3U8: isSupportM3U8,        launchPlayer: launchPlayer,        log: log,        markVideoUrl: markVideoUrl,        markSegs: markSegs,        selectSegs: selectSegs,        getVideoUrl: function() {             var body  = document.body, value = body.getAttribute(ATTR_VIDEO_ADDRESS);             if (!value) {                 return false;             }             return value;         },         getUniqString: function() {            return _ + Math.round(+new Date() * Math.random());         }    }}(window);
"
" vim: set et sw=4 ts=4 sts=4 ft=javascript fdm=marker ff=unix fenc=utf8 nobomb:/** *  <> * @date   2013-03-27 * @link   http://www.gracecode.com/ */
~function() {     var Toolkit = HTML5PlayerToolKit, getScript = Toolkit.getScript, log = Toolkit.log;
     var getExtensionUrl = function(url) {        return chrome.extension.getURL(url);     };
     var getVideoFlag = function (flag) {         var body  = document.body, value = body.getAttribute(data- + flag);         if (!value) {             return false;         }         return value;     };
     var init = function(e) {         var type = false, host = location.host;
         if(youkucom.test(host) && getVideoFlag(videoId))                         type = youku;         if(tudoucom.test(host) && getVideoFlag(iid))                             type = tudou;         if(sohucom.test(host)  && getVideoFlag(vid))                             type = sohu;         if(iqiyicom.test(host) && getVideoFlag(info))                            type = iqiyi;         if(letvcom.test(host)  && document.getElementById(fla_box))              type = letv;         if(videosinacomcn.test(host) && getVideoFlag(SCOPE))                 type = sina;         if(vqqcom.test(host) && getVideoFlag(COVER_INFO))                      type = qq;         if(getVideoFlag(XL_CLOUD_FX_INSTANCE))                                       type = xunlei;         if(56com.test(host) && getVideoFlag(_page_))                             type = 56;         if(/bilibili\.tv/.test(host) && getVideoFlag('aid'))                           type = 'bilibili';         if(/acfun\.tv/.test(host) && getVideoFlag('system'))                           type = 'acfun';
         if(!type) {             log(Not found any video, ignore.);             return false;         }         log(Found  + type.toUpperCase() +  video tag, continue.);
         getScript(getExtensionUrl(sites/ + type + .js));     };
     window.addEventListener(load, function() {        getScript(getExtensionUrl(seed.js), init);     });} ();
"

"/** *  * Copyright 2016 Google Inc. * * Licensed under the Apache License, Version 2.0 (the ""License""); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an ""AS IS"" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
/** *  Require all exported classes an app might use. *   */
goog.require(shaka.Player);goog.require(shaka.abr.SimpleAbrManager);goog.require(shaka.cast.CastProxy);goog.require(shaka.cast.CastReceiver);goog.require(shaka.dash.DashParser);goog.require(shaka.hls.HlsParser);goog.require(shaka.log);goog.require(shaka.media.InitSegmentReference);goog.require(shaka.media.ManifestParser);goog.require(shaka.media.Mp4TtmlParser);goog.require(shaka.media.Mp4VttParser);goog.require(shaka.media.PresentationTimeline);goog.require(shaka.media.SegmentIndex);goog.require(shaka.media.SegmentReference);goog.require(shaka.media.TextEngine);goog.require(shaka.media.TtmlTextParser);goog.require(shaka.media.VttTextParser);goog.require(shaka.net.DataUriPlugin);goog.require(shaka.net.HttpPlugin);goog.require(shaka.offline.OfflineManifestParser);goog.require(shaka.offline.OfflineScheme);goog.require(shaka.offline.Storage);goog.require(shaka.polyfill.Fullscreen);goog.require(shaka.polyfill.IndexedDB);goog.require(shaka.polyfill.MediaKeys);goog.require(shaka.polyfill.MediaSource);goog.require(shaka.polyfill.Promise);goog.require(shaka.polyfill.VTTCue);goog.require(shaka.polyfill.VideoPlaybackQuality);goog.require(shaka.polyfill.installAll);goog.require(shaka.util.Error);"
"/** *  * Copyright 2016 Google Inc. * * Licensed under the Apache License, Version 2.0 (the ""License""); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an ""AS IS"" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
 Karma configuration Install required modules by running ""npm install""
module.exports = function(config) {  config.set({     base path that will be used to resolve all patterns (eg. files, exclude)    basePath: .,
     frameworks to use     available frameworks: https://npmjs.org/browse/keyword/karma-adapter    frameworks: [      jasmine-ajax, jasmine,      sprintf-js,    ],
    plugins: [      karma-*,   default      frameworkPluginForModule(sprintf-js),    ],
     list of files / patterns to load in the browser    files: [       closure base first      third_party/closure/goog/base.js,
       deps next      dist/deps.js,      shaka-player.uncompiled.js,
       requirejs next      node_modules/requirejs/require.js,
       bootstrapping for the test suite      test/test/boot.js,
       test utils next      test/test/util/*.js,
       list of test assets next      demo/assets.js,
       unit tests last      test/**/*_unit.js,
       if --quick is not present, we will add integration tests.
       source files - these are only watched and served      {pattern: lib/**/*.js, included: false},      {pattern: third_party/closure/goog/**/*.js, included: false},      {pattern: test/test/assets/*, included: false},      {pattern: dist/shaka-player.compiled.js, included: false},    ],
     NOTE: Do not use proxies at all!  They cannot be used with the --hostname     option, which is necessary for some of our lab testing.    proxies: {},
    preprocessors: {       Don't compute coverage over lib/debug/ or lib/polyfill/      lib/!(debug|polyfill)/*.js: coverage,       Player is not matched by the above, so add it explicitly      lib/player.js: coverage,    },
     to avoid DISCONNECTED messages on Safari:    browserDisconnectTimeout: 10 * 1000,   10s to reconnect    browserDisconnectTolerance: 1,   max of 1 disconnect is OK    browserNoActivityTimeout: 5 * 60 * 1000,   disconnect after 5m silence    captureTimeout: 1 * 60 * 1000,   give up if startup takes 1m     https://support.saucelabs.com/customer/en/portal/articles/2440724
    client: {       don't capture the client's console logs      captureConsole: false,       |args| must be an array; pass a key-value map as the sole client       argument.      args: [{}],    },
     enable / disable colors in the output (reporters and logs)    colors: true,
     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR ||                      config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_WARN,
     do not execute tests whenever any file changes    autoWatch: false,
     do a single run of the tests on captured browsers and then quit    singleRun: true,
    coverageReporter: {      includeAllSources: true,      reporters: [        { type: text },      ],    },
    specReporter: {      suppressSkipped: true,    },  });
  if (flagPresent(html-coverage-report)) {     Wipe out any old coverage reports to avoid confusion.    var rimraf = require(rimraf);    rimraf.sync(coverage, {});   Like rm -rf
    config.set({      reporters: [ coverage, progress ],      coverageReporter: {        reporters: [          { type: html, dir: coverage },          { type: cobertura, dir: coverage, file: coverage.xml },        ],      },    });  }
  if (!flagPresent(quick)) {     If --quick is present, we don't serve integration tests.    var files = config.files;    files.push(test/**/*_integration.js);     We just modified the config in-place.  No need for config.set().  }
  var logLevel = getFlagValue(enable-logging);  if (logLevel !== null) {    if (logLevel === )      logLevel = 3;   INFO
    config.set({      reporters: [spec],    });     Setting |config.client| using config.set will remove the     |config.client.args| member.    config.client.captureConsole = true;    setClientArg(config, logLevel, logLevel);  }
  if (flagPresent(external)) {     Run Player integration tests against external assets.     Skipped by default.    setClientArg(config, external, true);  }
  if (flagPresent(drm)) {     Run Player integration tests against DRM license servers.     Skipped by default.    setClientArg(config, drm, true);  }
  if (flagPresent(quarantined)) {     Run quarantined tests which do not consistently pass.     Skipped by default.    setClientArg(config, quarantined, true);  }
  if (flagPresent(uncompiled)) {     Run Player integration tests with uncompiled code for debugging.    setClientArg(config, uncompiled, true);  }
  if (flagPresent(random)) {     Run tests in a random order.    setClientArg(config, random, true);
     If --seed was specified use that value, else generate a seed so that the     exact order can be reproduced if it catches an issue.    var seed = getFlagValue(seed) || new Date().getTime();    setClientArg(config, seed, seed);
    console.log(Using a random test order (--random) with --seed= + seed);  }
  if (flagPresent(specFilter)) {    setClientArg(config, specFilter, getFlagValue(specFilter));  }};
 Sets the value of an argument passed to the client.function setClientArg(config, name, value) {  config.client.args[0][name] = value;}
 Find a custom command-line flag that has a value (e.g. --option=12). Returns: * string value  --option=12 * empty string  --option= or --option * null          not presentfunction getFlagValue(name) {  var re = --()(?:=());  for (var i = 0; i < process.argv.length; i++) {    var match = re.exec(process.argv[i]);    if (match && match[1] == name) {      if (match[2] !== undefined)        return match[2];      else        return ;    }  }
  return null;}
 Find custom command-line flags.function flagPresent(name) {  return getFlagValue(name) !== null;}
 Construct framework plugins on-the-fly for arbitrary node modules. A call to this must be placed in the config in the 'plugins' array, and the module name must be added to the config in the 'frameworks' array.function frameworkPluginForModule(name) {   The framework injects files into the client which runs the tests.  var framework = function(files) {     Locate the main file for the node module.    var path = require(path);    var mainFile = path.resolve(require.resolve(name));
     Add a file entry to the list of files to be served.     This follows the same syntax as above in config.set({files: ...}).    files.unshift({      pattern: mainFile, included: true, served: true, watched: false    });  };
   The framework factory function takes one argument, which is the list of   files from the karma config.  framework.$inject = [config.files];
   This is the plugin interface to register a new framework.  Adding this to   the list of plugins makes the named module available as a framework.  That   framework then injects the module into the client.  var obj = {};  obj[framework: + name] = [factory, framework];  return obj;}"
"var torrents = require(webtorrent)var request = require(request)var duplex = require(duplexify)var ytdl = require(ytdl-core)var events = require(events)var path = require(path)var fs = require(fs)var vtt = require(srt-to-vtt)var concat = require(concat-stream)
var noop = function () {}
module.exports = function () {  var that = new events.EventEmitter()
  that.entries = []
  var onmagnet = function (link, cb) {    console.log(torrent  + link)
    var engine = torrents()    var subtitles = {}
    engine.add(link, {      announce: [ wss://tracker.webtorrent.io ]    }, function (torrent) {      console.log(torrent ready)
      torrent.files.forEach(function (f) {        if ((vttsrt)i.test(f.name)) {          subtitles[f.name] = f;        }      })
      torrent.files.forEach(function (f) {        f.downloadSpeed = torrent.downloadSpeed()        if ((mp4mkvmp3)i.test(f.name)) {          f.select()          f.id = that.entries.push(f) - 1
          var basename = f.name.substr(0, f.name.lastIndexOf(.))          var subtitle = subtitles[basename + .srt] || subtitles[basename + .vtt]          if (subtitle) {             subtitle.createReadStream().pipe(vtt()).pipe(concat(function(data) {               f.subtitles = data            }))          }        }
      })
      setInterval(function () {        console.log(torrent.downloadSpeed() +  ( + torrent.swarm.wires.length + ))      }, 1000)
      that.emit(update)      cb()    })  }
  var ontorrent = function (link, cb) {    fs.readFile(link, function (err, buf) {      if (err) return cb(err)      onmagnet(buf, cb)    })  }
  var onyoutube = function (link, cb) {    var file = {}    var url = https:.test(link) ? link : https: + link
    getYoutubeData(function (err, data) {      if (err) return cb(err)      var fmt = data.fmt      var info = data.info      request({method: HEAD, url: fmt.url}, function (err, resp, body) {        if (err) return cb(err)        var len = resp.headers[content-length]        if (!len) return cb(new Error(no content-length on response))        file.length = +len        file.name = info.title
        file.createReadStream = function (opts) {          if (!opts) opts = {}           fetch this for every range request           TODO try and avoid doing this call twice the first time          getYoutubeData(function (err, data) {            if (err) return cb(err)            var vidUrl = data.fmt.url            if (opts.start || opts.end) vidUrl += &range= + ([opts.start || 0, opts.end || len].join(-))            stream.setReadable(request(vidUrl))          })
          var stream = duplex()          return stream        }        file.id = that.entries.push(file) - 1        that.emit(update)        cb()      })    })
    function getYoutubeData (cb) {      ytdl.getInfo(url, function (err, info) {        if (err) return cb(err)
        var vidFmt        var formats = info.formats
        formats.sort(function sort (a, b) {          return +a.itag - +b.itag        })
        var vidFmt        formats.forEach(function (fmt) {           prefer webm          if (fmt.itag === 46) return vidFmt = fmt          if (fmt.itag === 45) return vidFmt = fmt          if (fmt.itag === 44) return vidFmt = fmt          if (fmt.itag === 43) return vidFmt = fmt
           otherwise h264          if (fmt.itag === 38) return vidFmt = fmt          if (fmt.itag === 37) return vidFmt = fmt          if (fmt.itag === 22) return vidFmt = fmt          if (fmt.itag === 18) return vidFmt = fmt        })
        if (!vidFmt) return cb (new Error(No suitable video format found))
        cb(null, {info: info, fmt: vidFmt})      })    }  }
  var onfile = function (link, cb) {    var file = {}
    fs.stat(link, function (err, st) {      if (err) return cb(err)
      file.length = st.size      file.name = path.basename(link)      file.createReadStream = function (opts) {        return fs.createReadStream(link, opts)      }
      file.id = that.entries.push(file) - 1
      var ondone = function () {        that.emit(update)        cb()      }      var basename = link.substr(0, link.lastIndexOf(.))      var extensions = [srt, vtt]      var next = function () {        var ext = extensions.shift()        if (!ext) return ondone()
        fs.exists(basename + . + ext, function(exists) {          if (!exists) return next()          fs.createReadStream(basename + . + ext).pipe(vtt()).pipe(concat(function(data) {            file.subtitles = data            ondone()          }))        })      }      next()    })  }
  var onhttplink = function (link, cb) {    var file = {}
    file.name = link.lastIndexOf(/) > -1 ? link.split(/).pop() : link
    file.createReadStream = function (opts) {      if (!opts) opts = {}
      if (opts && (opts.start || opts.end)) {        var rs = bytes= + (opts.start || 0) + - + (opts.end || file.length || )        return request(link, {headers: {Range: rs}})      }
      return request(link)    }
     first, get the head for the content length.     IMPORTANT: servers without HEAD will not work.    request.head(link, function (err, response) {      if (err) return cb(err)      if (!2.test(response.statusCode)) return cb(new Error(request failed))
      file.length = Number(response.headers[content-length])      file.id = that.entries.push(file) - 1      that.emit(update)      cb()    })  }
  var onipfslink = function (link, cb) {    if (link[0] != /) link = / + link  / may be stripped in add
    var local = localhost:8080  todo: make this configurable    var gateway = gateway.ipfs.io    var file = {}
     first, try the local http gateway    var u = http:// + local + link    console.log(trying local ipfs gateway:  + u)    onhttplink(u, function (err) {      if (!err) return cb()  done.
       error? ok try fuse... maybe the gateway's broken.      console.log(trying mounted ipfs fs (just in case))      onfile(link, function (err) {        if (!err) return cb()  done.
         worst case, try global ipfs gateway.        var u = http:// + gateway + link        console.log(trying local ipfs gateway:  + u)        onhttplink(u, cb)      })    })  }
  that.selected = null
  that.deselect = function () {    that.selected = null    that.emit(deselect)  }
  that.selectNext = function (loop) {    if (!that.entries.length) return null    if (!that.selected) return that.select(0)    if (that.repeatingOne && !loop) return that.select(that.selected.id)    if (that.selected.id === that.entries.length - 1) {      if (that.repeating || loop) return that.select(0)      else return null    }    return that.select(that.selected.id + 1)  }
  that.selectPrevious = function (loop) {    if (!that.entries.length) return null    if (!that.selected) return that.select(that.entries.length - 1)    if (that.selected.id === 0) {      if (that.repeating || loop) return that.select(that.entries.length - 1)      else return null    }    return that.select(that.selected.id - 1)  }
  that.select = function (id) {    that.selected = that.get(id)    that.emit(select)    return that.selected  }
  that.get = function (id) {    return that.entries[id]  }
  that.add = function (link, cb) {    link = link.replace(playback://, ).replace(playback:, )  strip playback protocol    if (!cb) cb = noop    if (magnet:.test(link)) return onmagnet(link, cb)    if (torrenti.test(link)) return ontorrent(link, cb)    if (youtubecomwatchyoutubei.test(link)) return onyoutube(link, cb)    if ((ipfsipns)i.test(link)) return onipfslink(link, cb)    if (https:i.test(link)) return onhttplink(link, cb)    onfile(link, cb)  }
  that.repeating = false  that.repeatingOne = false
  that.repeat = function () {    that.repeating = true    that.repeatingOne = false  }
  that.repeatOne = function () {    that.repeating = true    that.repeatingOne = true  }
  that.unrepeat = function () {    that.repeating = false    that.repeatingOne = false  }
  return that}"
"var events = require(events)var network = require(network-address)
module.exports = function ($video) {  var that = new events.EventEmitter()  var atEnd = false  var lastUrl = null
  that.setMaxListeners(0)
  that.width = 0  that.height = 0  that.element = $video
  var chromecast = null  var chromecastTime = 0  var chromecastOffset = 0  var chromecastSubtitles = 1  var interval = null
  var onerror = function () {    if (chromecast) chromecast.removeListener(error, onerror)    that.chromecast(null)  }
  var onmetadata = function (err, status) {    if (err) return onerror(err)    if (chromecastTime) chromecastOffset = 0    chromecastTime = status.currentTime    chromecastSubtitles = 1    that.duration = status.media.duration    that.emit(metadata)
    clearInterval(interval)    interval = setInterval(function () {      chromecast.status(function (err, status) {        if (err) return onerror(err)
        if (!status) {          chromecastOffset = 0          clearInterval(interval)          atEnd = true          that.playing = false          that.emit(pause)          that.emit(end)          return        }
        if (chromecastTime) chromecastOffset = 0        chromecastTime = status.currentTime      })    }, 1000)  }
  that.casting = false  that.chromecast = function (player) {    chromecastOffset = chromecast ? 0 : $video.currentTime    clearInterval(interval)    if (chromecast && that.playing) chromecast.stop()    chromecast = player    that.casting = player    if (chromecast) chromecast.on(error, onerror)    if (!that.playing) return    media.play(lastUrl, that.casting ? chromecastOffset : chromecastTime)  }
  $video.addEventListener(seeked, function () {    if (chromecast) return    that.emit(seek)  }, false)
  $video.addEventListener(ended, function () {    if (chromecast) return    atEnd = true    that.playing = false    that.emit(pause)    that.emit(end)  }, false)
  $video.addEventListener(loadedmetadata, function () {    if (chromecast) return    that.width = $video.videoWidth    that.height =  $video.videoHeight    that.ratio = that.width / that.height    that.duration = $video.duration    that.emit(metadata)  }, false)
  that.time = function (time) {    atEnd = false    if (chromecast) {      if (arguments.length) {        chromecastOffset = 0        chromecast.seek(time)      }      return chromecastOffset || chromecastTime    }    if (arguments.length) $video.currentTime = time    return $video.currentTime  }
  that.playing = false
  that.play = function (url, time) {    if (!url && !lastUrl) return    var changed = url && lastUrl !== url    if (changed) subs = null    if (chromecast) {      $video.innerHTML =   clear      $video.pause()      $video.load()      if (url) lastUrl = url      else url = lastUrl      atEnd = false      if (url) {        var mediaUrl = url.replace(127.0.0.1, network())        var subsUrl = mediaUrl.replace((:), $1/subtitles)        var subsList = []        for (var i = 0; i < 100; i++) subsList.push(subsUrl)        chromecast.play(mediaUrl, {title: Playback, seek: time || 0, subtitles: subsList, autoSubtitles: !!subs }, onmetadata)      } else {        chromecast.resume()      }    } else {      if (atEnd && url === lastUrl) that.time(0)      if (!url) {        $video.play()      } else {        lastUrl = url        atEnd = false        $video.innerHTML =   clear        var $src = document.createElement(source)        $src.setAttribute(src, url)        $src.setAttribute(type, video/mp4)        $video.appendChild($src)        if (changed) $video.load()        $video.play()        if (time) $video.currentTime = time      }    }    that.playing = true    that.emit(play)  }
  that.pause = function () {    if (chromecast) chromecast.pause()    else $video.pause()    that.playing = false    that.emit(pause)  }
  var subs = null  that.subtitles = function (buf) {    if (!arguments.length) return subs    subs = buf
    if (chromecast) {      if (!buf) chromecast.subtitles(false)      else chromecast.subtitles(++chromecastSubtitles)      return    }
    if ($video.querySelector(track)) $video.removeChild($video.querySelector(track))    if (!buf) return null    var $track = document.createElement(track)    $track.setAttribute(default, default)    $track.setAttribute(src, data:text/vtt;base64,+buf.toString(base64))    $track.setAttribute(label, Subtitles)    $track.setAttribute(kind, subtitles)    $video.appendChild($track)    that.emit(subtitles, buf)    return buf  }
  that.volume = function (value) {    $video.volume = value  }
  that.playbackRate = function (value) {    $video.playbackRate = value  }
  return that}"
"var $ = require(dombo)
module.exports = function (elem, timeout, className) {  var max = (timeout / 250) | 0  var overMovie = false  var hiding = false  var moving = 0  var tick = 0  var mousedown = false
  var update = function () {    if (hiding) {      $(body).removeClass(className)      hiding = false    }  }
  $(elem).on(mouseover, function () {    overMovie = true    update()  })
  $(elem).on(mouseout, function () {    overMovie = false  })
  $(elem).on(mousedown, function (e) {    mousedown = true    moving = tick    update()  })
  $(elem).on(mouseup, function (e) {    mousedown = false    moving = tick  })
  $(window).on(mousemove, function (e) {    moving = tick    update()  })
  setInterval(function () {    tick++    if (!overMovie) return    if (tick - moving < max || mousedown) return    hiding = true    $(body).addClass(className)  }, 250)}"
"var request = require(request)var drop = require(drag-and-drop-files)var mdns = require(multicast-dns)()var concat = require(concat-stream)var vtt = require(srt-to-vtt)var ipc = require(electron).ipcRenderervar remote = require(remote)var Menu = remote.require(menu)var MenuItem = remote.require(menu-item)var http = require(http)var rangeParser = require(range-parser)var pump = require(pump)var fs = require(fs)var eos = require(end-of-stream)var minimist = require(minimist)var JSONStream = require(JSONStream)var network = require(network-address)var chromecasts = require(chromecasts)()var $ = require(dombo)var titlebar = require(titlebar)()var clipboard = require(clipboard)var player = require(./player)var playlist = require(./playlist)var mouseidle = require(./mouseidle)
var argv = minimist(JSON.parse(window.location.toString().split(#)[1]), {  alias: {follow: f},  boolean: [follow]})
var printError = function (err) {  if (err) console.log(err)}
var onsubs = function (data) {  media.subtitles(data)}
ipc.on(add-to-playlist, function (event, links) {  links.forEach(function (link) {    if ((vttsrt)i.test(link)) {      fs.createReadStream(link).pipe(vtt()).pipe(concat(onsubs))      return    }
    list.add(link, printError)  })})
$(document).on(paste, function (e) {  ipc.emit(add-to-playlist, e.clipboardData.getData(text).split())})
var media = player($(#player)[0])var list = playlist()
if (process.platform !== win32) {  titlebar.appendTo(#titlebar)}
drop($(body)[0], function (files) {  for (var i = 0; i < files.length; i++) {    if ((vttsrt)i.test(files[i].path)) {      fs.createReadStream(files[i].path).pipe(vtt()).pipe(concat(onsubs))      return    }
    list.add(files[i].path, printError)  }})
var videoDown = falsevar videoOffsets = [0, 0]
$(#idle).on(mousedown, function (e) {  videoDown = true  videoOffsets = [e.clientX, e.clientY]})
$(#idle).on(mouseup, function () {  videoDown = false})
$(#idle).on(mousemove, function (e) {  if (videoDown) remote.getCurrentWindow().setPosition(e.screenX - videoOffsets[0], e.screenY - videoOffsets[1])})
var onTop = false
$(window).on(contextmenu, function (e) {  e.preventDefault()  videoDown = false
  var menu = new Menu()
  menu.append(new MenuItem({    label: Always on top,    type: checkbox,    checked: onTop,    click: function () {      onTop = !onTop      remote.getCurrentWindow().setAlwaysOnTop(onTop)    }  }))
  menu.append(new MenuItem({    label: Paste link,    click: function () {      ipc.emit(add-to-playlist, clipboard.readText().split())    }  }))
  if (media.subtitles()) {    menu.append(new MenuItem({      label: Remove subtitles,      click: function () {        media.subtitles(null)      }    }))  }
  menu.popup(remote.getCurrentWindow())})
$(body).on(mouseover, function () {  if (onTop) ipc.send(focus)})
var isFullscreen = false
var onfullscreentoggle = function (e) {  if (!isFullscreen && e.shiftKey) {    ipc.send(resize, {      width: media.width,      height: media.height,      ratio: media.ratio    })    return  }
  var $icon = $(#controls-fullscreen .js-icon)  if (isFullscreen) {    isFullscreen = false    $(#titlebar)[0].style.display = block    $icon.removeClass(ion-arrow-shrink)    $icon.addClass(ion-arrow-expand)    ipc.send(exit-full-screen)  } else {    isFullscreen = true    $(#titlebar)[0].style.display = none    $icon.removeClass(ion-arrow-expand)    $icon.addClass(ion-arrow-shrink)    ipc.send(enter-full-screen)  }}
var onplaytoggle = function () {  if (media.playing) media.pause()  else media.play()}
var onnexttrack = function () {  var shouldLoop = true  list.selectNext(shouldLoop)}
var onprevioustrack = function () {  var shouldLoop = true  list.selectPrevious(shouldLoop)}
var onrepeatcycle = function () {  var $controlsRepeat = $(#controls-repeat)  if (!list.repeating) {    $controlsRepeat.addClass(repeating)    list.repeat()    return  }
  if (!list.repeatingOne) {    $controlsRepeat.addClass(one)    list.repeatOne()    return  }
  $controlsRepeat.removeClass(repeating)  $controlsRepeat.removeClass(one)  list.unrepeat()}
$(#idle).on(dblclick, onfullscreentoggle)$(#controls-fullscreen).on(click, onfullscreentoggle)
$(#controls-timeline).on(click, function (e) {  var time = e.pageX / $(#controls-timeline)[0].offsetWidth * media.duration  media.time(time)})
function updateTimelineTooltip(e) {  var tooltip = $(#controls-timeline-tooltip)[0]  var percentage = e.pageX / $(#controls-timeline)[0].offsetWidth  var time =  formatTime(percentage * media.duration)  tooltip.innerHTML = time  tooltip.style.left = (e.pageX - tooltip.offsetWidth / 2) + px}
$(#controls-timeline).on(mousemove, function (e) {  updateTimelineTooltip(e)})
$(#controls-timeline).on(mouseover, function (e) {  var tooltip = $(#controls-timeline-tooltip)[0]  tooltip.style.opacity = 1  updateTimelineTooltip(e)})
$(#controls-timeline).on(mouseout, function (e) {  var tooltip = $(#controls-timeline-tooltip)[0]  tooltip.style.opacity = 0})
var isVolumeSliderClicked = falsevar isPbrateSliderClicked = false
function updateAudioVolume(value) {  media.volume(value)}
function updateVolumeSlider(volume) {  var val = volume.value * 100  volume.style.background = -webkit-gradient(linear, left top, right top, color-stop( + val.toString() + %, #31A357), color-stop( + val.toString() + %, #727374))}
function updatePlaybackRate(value) {  media.playbackRate(value)}
function updatePlaybackRateSlider(volume) {  var min = 0.5  var max = 4  var scaled = (volume.value - min) / (max - min)  var val = scaled * 100  volume.style.background = -webkit-gradient(linear, left top, right top, color-stop( + val.toString() + %, #31A357), color-stop( + val.toString() + %, #727374))}
$(#controls-volume-slider).on(mousemove, function (e) {  if (isVolumeSliderClicked) {    var volume = $(#controls-volume-slider)[0]    updateAudioVolume(volume.value)    updateVolumeSlider(volume)  }})
$(#controls-volume-slider).on(mousedown, function (e) {  isVolumeSliderClicked = true})
$(#controls-volume-slider).on(mouseup, function (e) {  var volume = $(#controls-volume-slider)[0]  updateAudioVolume(volume.value)  updateVolumeSlider(volume)  isVolumeSliderClicked = false})
$(#controls-pbrate-slider).on(mousemove, function (e) {  if (isPbrateSliderClicked) {    var volume = $(#controls-pbrate-slider)[0]    updatePlaybackRate(volume.value)    updatePlaybackRateSlider(volume)  }})
$(#controls-pbrate-slider).on(mousedown, function (e) {  isPbrateSliderClicked = true})
$(#controls-pbrate-slider).on(mouseup, function (e) {  var volume = $(#controls-pbrate-slider)[0]  updatePlaybackRate(volume.value)  updatePlaybackRateSlider(volume)  isPbrateSliderClicked = false})
$(document).on(keydown, function (e) {  if (e.keyCode === 27 && isFullscreen) return onfullscreentoggle(e)  if (e.keyCode === 13 && e.metaKey) return onfullscreentoggle(e)  if (e.keyCode === 13 && e.shiftKey) return onfullscreentoggle(e)  if (e.keyCode === 32) return onplaytoggle(e)
  if ($(#controls-playlist).hasClass(selected)) $(#controls-playlist).trigger(click)  if ($(#controls-chromecast).hasClass(selected)) $(#controls-chromecast).trigger(click)})
mouseidle($(#idle)[0], 3000, hide-cursor)
list.on(select, function () {  $(#controls-name)[0].innerText = list.selected.name  media.play(http://127.0.0.1: + server.address().port + / + list.selected.id)  if (list.selected.subtitles) onsubs(list.selected.subtitles)  updatePlaylist()})
var updatePlaylist = function () {  var html = 
  list.entries.forEach(function (entry, i) {    html += <div class=""playlist-entry  + (i % 2 ? odd  : ) + (list.selected === entry ? selected  : ) + "" data-index="" + i + "" data-id="" + entry.id + ""> +      <span> + entry.name + </span><span class=""status""></span></div>  })
  $(#playlist-entries)[0].innerHTML = html}
var updateChromecast = function () {  var html = 
  chromecasts.players.forEach(function (player, i) {    html += <div class=""chromecast-entry  + (i % 2 ? odd  : ) + (media.casting === player ? selected  : ) + "" data-index="" + i + "" data-id="" + i + ""> +      <span> + player.name + </span>  })
  $(#chromecast-entries)[0].innerHTML = html}
chromecasts.on(update, updateChromecast)
var updateSpeeds = function () {  $(#player-downloadspeed)[0].innerText =   list.entries.forEach(function (entry, i) {    if (!entry.downloadSpeed) return
    $(.playlist-entry[data-index="" + i + ""] .status).addClass(ion-loop)
    var kilobytes = entry.downloadSpeed() / 1024    var megabytes = kilobytes / 1024    var text = megabytes > 1 ? megabytes.toFixed(1) +  mb/s : Math.floor(kilobytes) +  kb/s
    if (list.selected === entry) $(#player-downloadspeed)[0].innerText = text  })}setInterval(updateSpeeds, 750)
list.on(update, updatePlaylist)
list.once(update, function () {  list.select(0)})
var popupSelected = function () {  return $(#controls-playlist).hasClass(selected) || $(#controls-chromecast).hasClass(selected)}
var closePopup = function (e) {  if (e && (e.target === $(#controls-playlist .js-icon)[0] || e.target === $(#controls-chromecast .chromecast)[0])) return  $(#popup)[0].style.opacity = 0  $(#controls-playlist).removeClass(selected)  $(#controls-chromecast).removeClass(selected)}
$(#controls).on(click, closePopup)$(#idle).on(click, closePopup)
$(#playlist-entries).on(click, .playlist-entry, function (e) {  var id = Number(this.getAttribute(data-id))  list.select(id)})
$(#chromecast-entries).on(click, .chromecast-entry, function (e) {  var id = Number(this.getAttribute(data-id))  var player = chromecasts.players[id]
  if (media.casting === player) {    $(body).removeClass(chromecasting)    media.chromecast(null)    return updateChromecast()  }
  $(body).addClass(chromecasting)  media.chromecast(player)  updateChromecast()})
var updatePopup = function () {  if (popupSelected()) {    $(#popup)[0].style.display = block    $(#popup)[0].style.opacity = 1  } else {    $(#popup)[0].style.opacity = 0  }}
$(#controls-chromecast).on(click, function (e) {  if ($(#controls-chromecast).hasClass(selected)) {    closePopup()    return  }
  $(#popup)[0].className = chromecast  $(#controls .controls-secondary .selected).removeClass(selected)  $(#controls-chromecast).addClass(selected)  chromecasts.update()  updatePopup()})
$(#controls-playlist).on(click, function (e) {  if ($(#controls-playlist).hasClass(selected)) {    closePopup()    return  }
  $(#popup)[0].className = playlist  $(#controls .controls-secondary .selected).removeClass(selected)  $(#controls-playlist).addClass(selected)  updatePopup()})
$(#playlist-add-media).on(click, function () {  ipc.send(open-file-dialog)})
$(#popup).on(transitionend, function () {  if (!popupSelected()) $(#popup)[0].style.display = none})
titlebar.on(close, function () {  ipc.send(close)})
titlebar.on(minimize, function () {  ipc.send(minimize)})
titlebar.on(maximize, function () {  ipc.send(maximize)})
titlebar.on(fullscreen, onfullscreentoggle)
var appmenu_template = [  {    label: Playback,    submenu: [      {        label: About Playback,        click: function() { ipc.send(open-url-in-external, https://mafintosh.github.io/playback/) }      },      {        type: separator      },      {        label: Quit,        accelerator: Command+Q,        click: function() { ipc.send(close) }      }    ]  },  {    label: File,    submenu: [      {        label: Add media,        accelerator: Command+O,        click: function() { ipc.send(open-file-dialog) }      },      {        label: Add link from clipboard,        accelerator: CommandOrControl+V,        click: function () { ipc.emit(add-to-playlist, clipboard.readText().split()) }      }    ]  },  {    label: Window,    submenu: [      {        label: Minimize,        accelerator: Command+M,        click: function() { ipc.send(minimize) }      },      {        label: Toggle Full Screen,        accelerator: Command+Enter,        click: onfullscreentoggle      }    ]  },  {    label: Help,    submenu: [      {        label: Report Issue,        click: function() { ipc.send(open-url-in-external, https://github.com/mafintosh/playback/issues) }      },      {        label: View Source Code on GitHub,        click: function() { ipc.send(open-url-in-external, https://github.com/mafintosh/playback) }      },      {        type: separator      },      {        label: Releases,        click: function() { ipc.send(open-url-in-external, https://github.com/mafintosh/playback/releases) }      }    ]  }]var appmenu = Menu.buildFromTemplate(appmenu_template)Menu.setApplicationMenu(appmenu)
var formatTime = function (secs) {  var hours = (secs / 3600) | 0  var mins = ((secs - hours * 3600) / 60) | 0  secs = (secs - (3600 * hours + 60 * mins)) | 0  if (mins < 10) mins = 0 + mins  if (secs < 10) secs = 0 + secs  return (hours ? hours + : : ) + mins + : + secs}
var updateIntervalmedia.on(metadata, function () {   TODO: comment in again when not quirky   if (!isFullscreen) {     ipc.send('resize', {       width: media.width,       height: media.height,       ratio: media.ratio     })   }
  $(#controls-main)[0].style.display = block  $(#controls-time-total)[0].innerText = formatTime(media.duration)  $(#controls-time-current)[0].innerText = formatTime(media.time())
  clearInterval(updateInterval)  updateInterval = setInterval(function () {    $(#controls-timeline-position)[0].style.width = (100 * (media.time() / media.duration)) + %    $(#controls-time-current)[0].innerText = formatTime(media.time())  }, 250)})
$(#controls-play).on(click, onplaytoggle)$(#controls-repeat).on(click, onrepeatcycle)ipc.on(media-play-pause, onplaytoggle)ipc.on(media-next-track, onnexttrack)ipc.on(media-previous-track, onprevioustrack)
media.on(end, function () {  ipc.send(allow-sleep)  list.selectNext()})
media.on(play, function () {  ipc.send(prevent-sleep)  $(#splash).toggleClass(hidden, !media.casting)  $(#player).toggleClass(hidden, media.casting)  $(#controls-play .js-icon).removeClass(ion-play)  $(#controls-play .js-icon).addClass(ion-pause)})
media.on(pause, function () {  ipc.send(allow-sleep)  $(#controls-play .js-icon).removeClass(ion-pause)  $(#controls-play .js-icon).addClass(ion-play)})
var server = http.createServer(function (req, res) {  if (req.headers.origin) res.setHeader(Access-Control-Allow-Origin, req.headers.origin)
  if (req.url === /subtitles) {    var buf = media.subtitles()
    if (buf) {      res.setHeader(Content-Type, text/vtt; charset=utf-8)      res.setHeader(Content-Length, buf.length)      res.end(buf)    } else {      res.statusCode = 404      res.end()    }  }
  if (req.url === /follow) {  TODO: do not hardcode /0    if (!list.selected) return res.end()    var stringify = JSONStream.stringify()
    var onseek = function () {      stringify.write({type: seek, time: media.time() })    }
    var onsubs = function (data) {      stringify.write({type: subtitles, data: data.toString(base64)})    }
    stringify.pipe(res)    stringify.write({type: open, url: http:// + network() + : + server.address().port + / + list.selected.id, time: media.time() })
    media.on(subtitles, onsubs)    media.on(seek, onseek)    eos(res, function () {      media.removeListener(subtitles, onsubs)      media.removeListener(seek, onseek)    })    return  }
  var id = Number(req.url.slice(1))  var file = list.get(id)
  if (!file) {    res.statusCode = 404    res.end()    return  }
  var range = req.headers.range && rangeParser(file.length, req.headers.range)[0]
  res.setHeader(Accept-Ranges, bytes)  res.setHeader(Content-Type, video/mp4)
  if (!range) {    res.setHeader(Content-Length, file.length)    if (req.method === HEAD) return res.end()    pump(file.createReadStream(), res)    return  }
  res.statusCode = 206  res.setHeader(Content-Length, range.end - range.start + 1)  res.setHeader(Content-Range, bytes  + range.start + - + range.end + / + file.length)  if (req.method === HEAD) return res.end()  pump(file.createReadStream(range), res)})
server.listen(0, function () {  console.log(Playback server running on port  + server.address().port)
  argv._.forEach(function (file) {    if (file) list.add(file, printError)  })
  if (argv.follow) {    mdns.on(response, function onresponse(response) {      response.answers.forEach(function (a) {        if (a.name !== playback) return        clearInterval(interval)        mdns.removeListener(response, onresponse)
        var host = a.data.target + : + a.data.port
        request(http:// + host + /follow).pipe(JSONStream.parse(*)).on(data, function (data) {          if (data.type === open) {            media.play(data.url)            media.time(data.time)          }
          if (data.type === seek) {            media.time(data.time)          }
          if (data.type === subtitles) {            media.subtitles(data.data)          }        })      })    })
    var query = function () {      mdns.query({        questions: [{          name: playback,          type: SRV        }]      })    }
    var interval = setInterval(query, 5000)    query()  } else {    mdns.on(query, function (query) {      var valid = query.questions.some(function (q) {        return q.name === playback      })
      if (!valid) return
      mdns.respond({        answers: [{          type: SRV,          ttl: 5,          name: playback,          data: {port: server.address().port, target: network()}        }]      })    })  }
  setTimeout(function () {    ipc.send(ready)  }, 10)})
var volumeSlider = $(#controls-volume-slider)[0]volumeSlider.setAttribute(value, 0.5)volumeSlider.setAttribute(min, 0)volumeSlider.setAttribute(max, 1)volumeSlider.setAttribute(step, 0.05)updateAudioVolume(0.5)updateVolumeSlider(volumeSlider)
var pbrateSlider = $(#controls-pbrate-slider)[0]pbrateSlider.setAttribute(value, 1)pbrateSlider.setAttribute(min, 0.5)pbrateSlider.setAttribute(max, 4)pbrateSlider.setAttribute(step, 0.25)updatePlaybackRate(1)updatePlaybackRateSlider(pbrateSlider)"
"#!/usr/bin/env electron
var app = require(app)var BrowserWindow = require(browser-window)var path = require(path)var ipc = require(electron).ipcMainvar dialog = require(dialog)var shell = require(shell)var powerSaveBlocker = require(electron).powerSaveBlockervar globalShortcut = require(electron).globalShortcut
var winvar linkvar ready = false
var onopen = function (e, lnk) {  e.preventDefault()
  if (ready) {    win.send(add-to-playlist, [].concat(lnk))    return  }
  link = lnk}
app.on(open-file, onopen)app.on(open-url, onopen)
var frame = process.platform === win32
app.on(ready, function () {  win = new BrowserWindow({    title: playback,    width: 860,    height: 470,    frame: frame,    show: false,    transparent: true  })
  win.loadURL(file:// + path.join(__dirname, index.html# + JSON.stringify(process.argv.slice(2))))
  ipc.on(close, function () {    app.quit()  })
  ipc.on(open-file-dialog, function () {    var files = dialog.showOpenDialog({ properties: [ openFile, multiSelections ]})    if (files) {      files.forEach(app.addRecentDocument)      win.send(add-to-playlist, files)    }  })
  ipc.on(open-url-in-external, function (event, url) {    shell.openExternal(url)  })
  ipc.on(focus, function () {    win.focus()  })
  ipc.on(minimize, function () {    win.minimize()  })
  ipc.on(maximize, function () {    win.maximize()  })
  ipc.on(resize, function (e, message) {    if (win.isMaximized()) return    var wid = win.getSize()[0]    var hei = (wid / message.ratio) | 0    win.setSize(wid, hei)  })
  ipc.on(enter-full-screen, function () {    win.setFullScreen(true)  })
  ipc.on(exit-full-screen, function () {    win.setFullScreen(false)    win.show()  })
  ipc.on(ready, function () {    ready = true    if (link) win.send(add-to-playlist, [].concat(link))    win.show()  })
  ipc.on(prevent-sleep, function () {    app.sleepId = powerSaveBlocker.start(prevent-display-sleep)  })
  ipc.on(allow-sleep, function () {    powerSaveBlocker.stop(app.sleepId)  })
  globalShortcut.register(MediaPlayPause, function () {    win.send(media-play-pause)  })
  globalShortcut.register(MediaNextTrack, function () {    win.send(media-next-track)  })
  globalShortcut.register(MediaPreviousTrack, function () {    win.send(media-previous-track)  })
})
app.on(will-quit, function () {
  globalShortcut.unregisterAll()
})"
"import webpack from webpack
export default {  entry: [    babel-polyfill,    ./src/index.js  ],
  output: {    path: ./dist,    filename: index.js,    chunkFilename: [name].js  },
  module: {    rules: [      { test: js, exclude: node_modules, loader: babel-loader },      { test: css, loader: style-loader!css-loader!postcss-loader },      { test: json, loader: json }    ]  },
  plugins: [     https://github.com/postcss/postcss-loader/issues/99    new webpack.LoaderOptionsPlugin({      test: css,      options: {        postcss: (webpackInstance) => [          require(postcss-import)({ addDependencyTo: webpackInstance }),          require(precss)()        ],        context: __dirname,      },    }),    ...process.env.NODE_ENV === production ? [      new webpack.LoaderOptionsPlugin({ minimize: false, debug: false }),      new webpack.optimize.DedupePlugin(),      new webpack.optimize.UglifyJsPlugin({        compress: {          warnings: false,          screw_ie8: true,          sequences: true,          dead_code: true,          drop_debugger: true,          comparisons: true,          conditionals: true,          evaluate: true,          booleans: true,          loops: true,          unused: true,          hoist_funs: true,          if_return: true,          join_vars: true,          cascade: true,          drop_console: true        },        output: {          comments: false        }      })    ] : [],  ]}"
"const electron = require(electron)const { resolve } = require(path)const { execSync } = require(child_process)
const tryCatch = require(./src/try-catch)
const { app } = electronconst { BrowserWindow } = electron
 enable chrome dev-tools when builded require('electron-debug')({ enabled: true, showDevTools: true })
let win
const createWindow = () => {  win = new BrowserWindow({ width: 800, height: 800 })  win.maximize()  win.loadURL(file:///index.html)
   open external URLs into default browser  win.webContents.on(new-window, (e, url) => {    e.preventDefault()    execSync(open )  })
  win.on(closed, () => { win = null })}
app.on(ready, () => {  const tmp = require(tmp)
  tmp.dir((err, path) => {    if (err) throw err
    global.tmpProjectPath = path    createWindow()
    execSync(cp -R  )    execSync(open )
     quit xcode && remove tmp directory on exit    app.on(before-quit, () => {      tryCatch(() => execSync(killall Xcode))      tryCatch(() => execSync(rm -rf ))    })  })})
app.on(window-all-closed, () => (process.platform !== darwin) && app.quit())app.on(activate, () => (win === null) && createWindow())"
"(function() {	var timeouts = [];	var messageName = zero-timeout-message;
	function setZeroTimeout(fn) {		timeouts.push(fn);		window.postMessage(messageName, *);	}
	function handleMessage(event) {		if (event.source == window && event.data == messageName) {			event.stopPropagation();			if (timeouts.length > 0) {				var fn = timeouts.shift();				fn();			}		}	}
	window.addEventListener(message, handleMessage, true);
	window.setZeroTimeout = setZeroTimeout;})();
var Neuvol;var game;var FPS = 60;var maxScore=0;
var images = {};
var speed = function(fps){	FPS = parseInt(fps);}
var loadImages = function(sources, callback){	var nb = 0;	var loaded = 0;	var imgs = {};	for(var i in sources){		nb++;		imgs[i] = new Image();		imgs[i].src = sources[i];		imgs[i].onload = function(){			loaded++;			if(loaded == nb){				callback(imgs);			}		}	}}
var Bird = function(json){	this.x = 80;	this.y = 250;	this.width = 40;	this.height = 30;
	this.alive = true;	this.gravity = 0;	this.velocity = 0.3;	this.jump = -6;
	this.init(json);}
Bird.prototype.init = function(json){	for(var i in json){		this[i] = json[i];	}}
Bird.prototype.flap = function(){	this.gravity = this.jump;}
Bird.prototype.update = function(){	this.gravity += this.velocity;	this.y += this.gravity;}
Bird.prototype.isDead = function(height, pipes){	if(this.y >= height || this.y + this.height <= 0){		return true;	}	for(var i in pipes){		if(!(			this.x > pipes[i].x + pipes[i].width ||			this.x + this.width < pipes[i].x || 			this.y > pipes[i].y + pipes[i].height ||			this.y + this.height < pipes[i].y			)){			return true;	}}}
var Pipe = function(json){	this.x = 0;	this.y = 0;	this.width = 50;	this.height = 40;	this.speed = 3;
	this.init(json);}
Pipe.prototype.init = function(json){	for(var i in json){		this[i] = json[i];	}}
Pipe.prototype.update = function(){	this.x -= this.speed;}
Pipe.prototype.isOut = function(){	if(this.x + this.width < 0){		return true;	}}
var Game = function(){	this.pipes = [];	this.birds = [];	this.score = 0;	this.canvas = document.querySelector(#flappy);	this.ctx = this.canvas.getContext(2d);	this.width = this.canvas.width;	this.height = this.canvas.height;	this.spawnInterval = 90;	this.interval = 0;	this.gen = [];	this.alives = 0;	this.generation = 0;	this.backgroundSpeed = 0.5;	this.backgroundx = 0;	this.maxScore = 0;}
Game.prototype.start = function(){	this.interval = 0;	this.score = 0;	this.pipes = [];	this.birds = [];
	this.gen = Neuvol.nextGeneration();	for(var i in this.gen){		var b = new Bird();		this.birds.push(b)	}	this.generation++;	this.alives = this.birds.length;}
Game.prototype.update = function(){	this.backgroundx += this.backgroundSpeed;	var nextHoll = 0;	if(this.birds.length > 0){		for(var i = 0; i < this.pipes.length; i+=2){			if(this.pipes[i].x + this.pipes[i].width > this.birds[0].x){				nextHoll = this.pipes[i].height/this.height;				break;			}		}	}
	for(var i in this.birds){		if(this.birds[i].alive){
			var inputs = [			this.birds[i].y / this.height,			nextHoll			];
			var res = this.gen[i].compute(inputs);			if(res > 0.5){				this.birds[i].flap();			}
			this.birds[i].update();			if(this.birds[i].isDead(this.height, this.pipes)){				this.birds[i].alive = false;				this.alives--;				console.log(this.alives);				Neuvol.networkScore(this.gen[i], this.score);				if(this.isItEnd()){					this.start();				}			}		}	}
	for(var i = 0; i < this.pipes.length; i++){		this.pipes[i].update();		if(this.pipes[i].isOut()){			this.pipes.splice(i, 1);			i--;		}	}
	if(this.interval == 0){		var deltaBord = 50;		var pipeHoll = 120;		var hollPosition = Math.round(Math.random() * (this.height - deltaBord * 2 - pipeHoll)) +  deltaBord;		this.pipes.push(new Pipe({x:this.width, y:0, height:hollPosition}));		this.pipes.push(new Pipe({x:this.width, y:hollPosition+pipeHoll, height:this.height}));	}
	this.interval++;	if(this.interval == this.spawnInterval){		this.interval = 0;	}
	this.score++;	this.maxScore = (this.score > this.maxScore) ? this.score : this.maxScore;	var self = this;
	if(FPS == 0){		setZeroTimeout(function(){			self.update();		});	}else{		setTimeout(function(){			self.update();		}, 1000/FPS);	}}

Game.prototype.isItEnd = function(){	for(var i in this.birds){		if(this.birds[i].alive){			return false;		}	}	return true;}
Game.prototype.display = function(){	this.ctx.clearRect(0, 0, this.width, this.height);	for(var i = 0; i < Math.ceil(this.width / images.background.width) + 1; i++){		this.ctx.drawImage(images.background, i * images.background.width - Math.floor(this.backgroundx%images.background.width), 0)	}
	for(var i in this.pipes){		if(i%2 == 0){			this.ctx.drawImage(images.pipetop, this.pipes[i].x, this.pipes[i].y + this.pipes[i].height - images.pipetop.height, this.pipes[i].width, images.pipetop.height);		}else{			this.ctx.drawImage(images.pipebottom, this.pipes[i].x, this.pipes[i].y, this.pipes[i].width, images.pipetop.height);		}	}
	this.ctx.fillStyle = #FFC600;	this.ctx.strokeStyle = #CE9E00;	for(var i in this.birds){		if(this.birds[i].alive){			this.ctx.save(); 			this.ctx.translate(this.birds[i].x + this.birds[i].width/2, this.birds[i].y + this.birds[i].height/2);			this.ctx.rotate(Math.PI/2 * this.birds[i].gravity/20);			this.ctx.drawImage(images.bird, -this.birds[i].width/2, -this.birds[i].height/2, this.birds[i].width, this.birds[i].height);			this.ctx.restore();		}	}
	this.ctx.fillStyle = white;	this.ctx.font=20px Oswald, sans-serif;	this.ctx.fillText(Score : + this.score, 10, 25);	this.ctx.fillText(Max Score : +this.maxScore, 10, 50);	this.ctx.fillText(Generation : +this.generation, 10, 75);	this.ctx.fillText(Alive : +this.alives+ / +Neuvol.options.population, 10, 100);
	var self = this;	requestAnimationFrame(function(){		self.display();	});}
window.onload = function(){	var sprites = {		bird:./img/bird.png,		background:./img/background.png,		pipetop:./img/pipetop.png,		pipebottom:./img/pipebottom.png	}
	var start = function(){		Neuvol = new Neuroevolution({			population:50,			network:[2, [2], 1],		});		game = new Game();		game.start();		game.update();		game.display();	}

	loadImages(sprites, function(imgs){		images = imgs;		start();	})
}"
"/** * Provides a set of classes and methods for handling Neuroevolution and * genetic algorithms. * *    object of options for Neuroevolution. */var Neuroevolution = function(options){	var self = this;   reference to the top scope of this module
 	 Declaration of module parameters (options) and default values	self.options = {    	/**     	 * Logistic activation function.     	 *	 *    value.	 *  Logistic function output.	 */		activation: function(a){			ap = (-a)/1;			return (1/(1 + Math.exp(ap)))		},
		/**		 * Returns a random value between -1 and 1.		 *		 *  Random value.		 */		randomClamped: function(){			return Math.random() * 2 - 1;		},
		 various factors and parameters (along with default values).		network:[1, [1], 1],     Perceptron network structure (1 hidden					 layer).		population:50,           Population by generation.		elitism:0.2,             Best networks kepts unchanged for the next				         generation (rate).		randomBehaviour:0.2,     New random networks for the next generation				         (rate).		mutationRate:0.1,        Mutation rate on the weights of synapses.		mutationRange:0.5,       Interval of the mutation changes on the				         synapse weight.		historic:0,              Latest generations saved.		lowHistoric:false,       Only save score (not the network).		scoreSort:-1,            Sort order (-1 = desc, 1 = asc).		nbChild:1                Number of children by breeding.
	}
	/**	 * Override default options.	 *	 *    object of Neuroevolution options.	 *  void	 */	self.set = function(options){		for(var i in options){      			if(this.options[i] != undefined){  Only override if the passed in value                        	                  	   is actually defined.				self.options[i] = options[i];			}		}	}
	 Overriding default options with the pass in options	self.set(options);

/*NEURON**********************************************************************/	/**	 * Artificial Neuron class	 *	 * 	 */	var Neuron = function(){		this.value = 0;		this.weights = [];	}
	/**	 * Initialize number of neuron weights to random clamped values.	 *	 *    of neuron weights (number of inputs).	 *  void	 */	Neuron.prototype.populate = function(nb){		this.weights = [];		for(var i = 0; i < nb; i++){			this.weights.push(self.options.randomClamped());		}	}

/*LAYER***********************************************************************/	/**	 * Neural Network Layer class.	 *	 * 	 *    of this Layer in the Network.	 */	var Layer = function(index){		this.id = index || 0;		this.neurons = [];	}
	/**	 * Populate the Layer with a set of randomly weighted Neurons.	 *	 * Each Neuron be initialied with nbInputs inputs with a random clamped	 * value.	 *	 *    of neurons.	 *    of inputs.	 *  void	 */	Layer.prototype.populate = function(nbNeurons, nbInputs){		this.neurons = [];		for(var i = 0; i < nbNeurons; i++){			var n = new Neuron();			n.populate(nbInputs);			this.neurons.push(n);		}	}

/*NEURAL NETWORK**************************************************************/	/**	 * Neural Network class	 *	 * Composed of Neuron Layers.	 *	 * 	 */	var Network = function(){		this.layers = [];	}
	/**	 * Generate the Network layers.	 *	 *    of Neurons in Input layer.	 *    of Neurons per Hidden layer.	 *    of Neurons in Output layer.	 *  void	 */	Network.prototype.perceptronGeneration = function(input, hiddens, output){		var index = 0;		var previousNeurons = 0;		var layer = new Layer(index);    		layer.populate(input, previousNeurons);  Number of Inputs will be set to                	                                 0 since it is an input layer.		previousNeurons = input;   number of input is size of previous layer.		this.layers.push(layer);		index++;		for(var i in hiddens){			 Repeat same process as first layer for each hidden layer.			var layer = new Layer(index);			layer.populate(hiddens[i], previousNeurons);			previousNeurons = hiddens[i];			this.layers.push(layer);			index++;		}		var layer = new Layer(index);		layer.populate(output, previousNeurons);   Number of input is equal to                        	                           the size of the last hidden							   layer.		this.layers.push(layer);	}
	/**	 * Create a copy of the Network (neurons and weights).	 *	 * Returns number of neurons per layer and a flat array of all weights.	 *	 *  Network data.	 */	Network.prototype.getSave = function(){		var datas = {			neurons:[],  Number of Neurons per layer.			weights:[]   Weights of each Neuron's inputs.		};
		for(var i in this.layers){			datas.neurons.push(this.layers[i].neurons.length);			for(var j in this.layers[i].neurons){				for(var k in this.layers[i].neurons[j].weights){	  				 push all input weights of each Neuron of each Layer into a flat	  				 array.					datas.weights.push(this.layers[i].neurons[j].weights[k]);				}			}		}		return datas;	}
	/**	 * Apply network data (neurons and weights).	 *	 *    of network data (neurons and weights).	 *  void	 */	Network.prototype.setSave = function(save){		var previousNeurons = 0;		var index = 0;		var indexWeights = 0;		this.layers = [];		for(var i in save.neurons){			 Create and populate layers.			var layer = new Layer(index);			layer.populate(save.neurons[i], previousNeurons);			for(var j in layer.neurons){				for(var k in layer.neurons[j].weights){	  				 Apply neurons weights to each Neuron.					layer.neurons[j].weights[k] = save.weights[indexWeights];
					indexWeights++;  Increment index of flat array.				}			}			previousNeurons = save.neurons[i];			index++;			this.layers.push(layer);		}	}
	/**	 * Compute the output of an input.	 *	 *    of inputs.	 *  Network output.	 */	Network.prototype.compute = function(inputs){		 Set the value of each Neuron in the input layer.		for(var i in inputs){			if(this.layers[0] && this.layers[0].neurons[i]){				this.layers[0].neurons[i].value = inputs[i];			}		}
		var prevLayer = this.layers[0];  Previous layer is input layer.		for(var i = 1; i < this.layers.length; i++){			for(var j in this.layers[i].neurons){				 For each Neuron in each layer.				var sum = 0;				for(var k in prevLayer.neurons){	  				 Every Neuron in the previous layer is an input to each Neuron in	  				 the next layer.					sum += prevLayer.neurons[k].value	       						* this.layers[i].neurons[j].weights[k];				}
				 Compute the activation of the Neuron.				this.layers[i].neurons[j].value = self.options.activation(sum);			}			prevLayer = this.layers[i];		}
		 All outputs of the Network.		var out = [];		var lastLayer = this.layers[this.layers.length - 1];		for(var i in lastLayer.neurons){			out.push(lastLayer.neurons[i].value);		}		return out;	}

/*GENOME**********************************************************************/	/**	 * Genome class.	 *	 * Composed of a score and a Neural Network.	 *	 * 	 *	 *  	 *  	 */	var Genome = function(score, network){		this.score = score || 0;		this.network = network || null;	}

/*GENERATION******************************************************************/	/**	 * Generation class.	 *	 * Composed of a set of Genomes.	 *	 * 	 */	var Generation = function(){		this.genomes = [];	}
	/**	 * Add a genome to the generation.	 *	 *    to add.	 *  void.	 */	Generation.prototype.addGenome = function(genome){    		 Locate position to insert Genome into.    		 The gnomes should remain sorted.		for(var i = 0; i < this.genomes.length; i++){      			 Sort in descending order.			if(self.options.scoreSort < 0){				if(genome.score > this.genomes[i].score){					break;				}			 Sort in ascending order.			}else{				if(genome.score < this.genomes[i].score){					break;				}			}
		}
		 Insert genome into correct position.		this.genomes.splice(i, 0, genome);	}
	/**	 * Breed to genomes to produce offspring(s).	 *	 *    1.	 *    2.	 *    of offspring (children).	 */	Generation.prototype.breed = function(g1, g2, nbChilds){		var datas = [];		for(var nb = 0; nb < nbChilds; nb++){			 Deep clone of genome 1.			var data = JSON.parse(JSON.stringify(g1));			for(var i in g2.network.weights){				 Genetic crossover				 0.5 is the crossover factor.				 FIXME Really should be a predefined constant.				if(Math.random() <= 0.5){					data.network.weights[i] = g2.network.weights[i];				}			}
			 Perform mutation on some weights.			for(var i in data.network.weights){				if(Math.random() <= self.options.mutationRate){					data.network.weights[i] += Math.random()						* self.options.mutationRange				   		* 2				   		- self.options.mutationRange;				}			}			datas.push(data);		}
		return datas;	}
	/**	 * Generate the next generation.	 *	 *  Next generation data array.	 */	Generation.prototype.generateNextGeneration = function(){		var nexts = [];
		for(var i = 0; i < Math.round(self.options.elitism                                 * self.options.population); i++){			if(nexts.length < self.options.population){        			 Push a deep copy of ith Genome's Nethwork.				nexts.push(JSON.parse(JSON.stringify(this.genomes[i].network)));			}		}
		for(var i = 0; i < Math.round(self.options.randomBehaviour                                 * self.options.population); i++){			var n = JSON.parse(JSON.stringify(this.genomes[0].network));			for(var k in n.weights){				n.weights[k] = self.options.randomClamped();			}			if(nexts.length < self.options.population){				nexts.push(n);			}		}
		var max = 0;		while(true){			for(var i = 0; i < max; i++){        			 Create the children and push them to the nexts array.        			var childs = this.breed(this.genomes[i], this.genomes[max],                     		(self.options.nbChild > 0 ? self.options.nbChild : 1) );				for(var c in childs){					nexts.push(childs[c].network);					if(nexts.length >= self.options.population){						 Return once number of children is equal to the						 population by generatino value.						return nexts;					}				}			}			max++;			if(max >= this.genomes.length - 1){				max = 0;			}		}	}

/*GENERATIONS*****************************************************************/	/**	 * Generations class.	 *	 * Hold's previous Generations and current Generation.	 *	 * 	 */	var Generations = function(){		this.generations = [];		var currentGeneration = new Generation();	}
	/**	 * Create the first generation.	 *	 *    layer.	 *    layer(s).	 *    layer.	 *  First Generation.	 */	Generations.prototype.firstGeneration = function(input, hiddens, output){    		 FIXME input, hiddens, output unused.
		var out = [];		for(var i = 0; i < self.options.population; i++){      			 Generate the Network and save it.			var nn = new Network();			nn.perceptronGeneration(self.options.network[0],						self.options.network[1],                              			self.options.network[2]);			out.push(nn.getSave());		}
		this.generations.push(new Generation());		return out;	}
	/**	 * Create the next Generation.	 *	 *  Next Generation.	 */	Generations.prototype.nextGeneration = function(){		if(this.generations.length == 0){			 Need to create first generation.			return false;		}
		var gen = this.generations[this.generations.length - 1]				.generateNextGeneration();		this.generations.push(new Generation());		return gen;	}
	/**	 * Add a genome to the Generations.	 *	 *  	 *  False if no Generations to add to.	 */	Generations.prototype.addGenome = function(genome){    		 Can't add to a Generation if there are no Generations.		if(this.generations.length == 0) return false;
   		  FIXME addGenome returns void.		return this.generations[this.generations.length - 1].addGenome(genome);	}

/*SELF************************************************************************/	self.generations = new Generations();
	/**	 * Reset and create a new Generations object.	 *	 *  void.	 */	self.restart = function(){		self.generations = new Generations();	}
	/**	 * Create the next generation.	 *	 *  Neural Network array for next Generation.	 */	self.nextGeneration = function(){		var networks = [];
		if(self.generations.generations.length == 0){      			 If no Generations, create first.			networks = self.generations.firstGeneration();		}else{      			 Otherwise, create next one.			networks = self.generations.nextGeneration();		}
    		 Create Networks from the current Generation.		var nns = [];		for(var i in networks){			var nn = new Network();			nn.setSave(networks[i]);			nns.push(nn);		}
		if(self.options.lowHistoric){      			 Remove old Networks.			if(self.generations.generations.length >= 2){				var genomes =					self.generations						.generations[self.generations.generations.length - 2]              					.genomes;				for(var i in genomes){					delete genomes[i].network;				}			}		}
		if(self.options.historic != -1){      			 Remove older generations.			if(self.generations.generations.length > self.options.historic + 1){        			self.generations.generations.splice(0,            			self.generations.generations.length - (self.options.historic + 1));			}		}
		return nns;	}
	/**	 * Adds a new Genome with specified Neural Network and score.	 *	 *    Network.	 *    value.	 *  void.	 */	self.networkScore = function(network, score){		self.generations.addGenome(new Genome(score, network.getSave()));	}}"
"module.exports = function(grunt) {
	grunt.initConfig({		pkg: grunt.file.readJSON(package.json),
		 Using concat to copy the source. In future, we plan to split the source up, making the concat more appropriate.
		concat: {			jplayer: {				files: {					dist/jplayer/jquery.jplayer.js: [src/javascript/jplayer/jquery.jplayer.js]				}			},			playlist: {				files: {					dist/add-on/jplayer.playlist.js: [src/javascript/add-on/jplayer.playlist.js]				}			},			inspector: {				files: {					dist/add-on/jquery.jplayer.inspector.js: [src/javascript/add-on/jquery.jplayer.inspector.js]				}			},			popcorn: {				files: {					dist/popcorn/popcorn.jplayer.js: [src/javascript/popcorn/popcorn.jplayer.js]				}			}		},
		uglify: {			options: {				 maxLineLen:  0 // Generates the output on a single line			},			jplayer: {				options: {					banner: /*! jPlayer <%= pkg.version %> for jQuery ~ (c) 2009-<%= grunt.template.today(""yyyy"") %> <%= pkg.organization %> ~ <%= pkg.license %> License */				},				files: {					dist/jplayer/jquery.jplayer.min.js: [dist/jplayer/jquery.jplayer.js]				}			},			playlist: {				options: {					banner: /*! jPlayerPlaylist for jPlayer <%= pkg.version %> ~ (c) 2009-<%= grunt.template.today(""yyyy"") %> <%= pkg.organization %> ~ <%= pkg.license %> License */				},				files: {					dist/add-on/jplayer.playlist.min.js: [dist/add-on/jplayer.playlist.js]				}			},			inspector: {				options: {					banner: /*! jPlayerInspector for jPlayer <%= pkg.version %> ~ (c) 2009-<%= grunt.template.today(""yyyy"") %> <%= pkg.organization %> ~ <%= pkg.license %> License */				},				files: {					dist/add-on/jquery.jplayer.inspector.min.js: [dist/add-on/jquery.jplayer.inspector.js]				}			},			popcorn: {				options: {					banner: /*! Popcorn Player for jPlayer <%= pkg.version %> ~ (c) 2009-<%= grunt.template.today(""yyyy"") %> <%= pkg.organization %> ~ <%= pkg.license %> License */				},				files: {					dist/popcorn/popcorn.jplayer.min.js: [dist/popcorn/popcorn.jplayer.js]				}			}		},
		sass: {			options: {				sourcemap: none,				style: nested			},			blue.monday: {				options: {					banner: /*! Blue Monday Skin for jPlayer <%= pkg.version %> ~ (c) 2009-<%= grunt.template.today(""yyyy"") %> <%= pkg.organization %> ~ <%= pkg.license %> License */				},				files: {					dist/skin/blue.monday/css/jplayer.blue.monday.css: src/skin/blue.monday/scss/jplayer.blue.monday.scss				}			},			pink.flag: {				options: {					banner: /*! Pink Flag Skin for jPlayer <%= pkg.version %> ~ (c) 2009-<%= grunt.template.today(""yyyy"") %> <%= pkg.organization %> ~ <%= pkg.license %> License */				},				files: {					dist/skin/pink.flag/css/jplayer.pink.flag.css: src/skin/pink.flag/scss/jplayer.pink.flag.scss				}			}		},
		cssmin: {			skins: {				files: {					dist/skin/blue.monday/css/jplayer.blue.monday.min.css: [dist/skin/blue.monday/css/jplayer.blue.monday.css],					dist/skin/pink.flag/css/jplayer.pink.flag.min.css: [dist/skin/pink.flag/css/jplayer.pink.flag.css]				}			},		},
		copy: {			skins: {				files: [					{expand: true, cwd: src/skin/blue.monday/, src: [image/**, mustache/**], dest: dist/skin/blue.monday/},					{expand: true, cwd: src/skin/pink.flag/, src: [image/**, mustache/**], dest: dist/skin/pink.flag/}				]			},		},
		jshint: {
			test: {				src: [					Gruntfile.js,					*.json,					src/javascript/**/*.js,					!**/jquery.jplayer.inspector.js  The inspector does not pass jshint, and this will be addressed in due course.				]			},
			 jQuery linting guide http://contribute.jquery.org/style-guide/js/#linting			 docs http://www/jshint.com/docs/			options: {				 Using .jshintrc files for the options.				jshintrc: true			}		},
		mxmlc: {			options: {				rawConfig: -static-link-runtime-shared-libraries=true			},			jplayer: {				files: {					 Compile and give the SWF a filename like the JavaScript filenames. Important as it is the jPlayer code.					dist/jplayer/jquery.jplayer.swf: [src/actionscript/Jplayer.as]				}			}		}	});
	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-concat);	grunt.loadNpmTasks(grunt-contrib-copy);	grunt.loadNpmTasks(grunt-contrib-cssmin);	grunt.loadNpmTasks(grunt-contrib-uglify);	grunt.loadNpmTasks(grunt-contrib-sass);	grunt.loadNpmTasks(grunt-mxmlc);
	grunt.registerTask(default, [test, build]);
	grunt.registerTask(test, [jshint]);	grunt.registerTask(build, [js, swf, css]);	grunt.registerTask(js, [concat, uglify]);	grunt.registerTask(swf, [mxmlc]);	grunt.registerTask(css, [sass, cssmin, copy:skins]);};"
"/* eslint arrow-body-style: 0 */
import gulp from gulp;
import { spawn, exec } from child_process;import _ from lodash;import babel from gulp-babel;import clean from gulp-clean;import concat from gulp-concat;import cssmin from gulp-cssmin;import { createWindowsInstaller as electronInstaller } from gpmdp-electron-winstaller;import fs from fs;import globber from glob;import header from gulp-header;import less from gulp-less;import packager from electron-packager;import nodePath from path;import replace from gulp-replace;import runSequence from run-sequence;import electronWindowsStore from electron-windows-store; import uglify from 'gulp-uglify';import rebuild from electron-rebuild;import rasterImages from ./vendor/svg_raster;
const paths = {  internalScripts: [src/**/*.js],  utilityScripts: [node_modules/jquery/dist/jquery.min.js,                    node_modules/materialize-css/dist/js/materialize.min.js,                    node_modules/materialize-css/extras/noUiSlider/nouislider.min.js],  html: src/public_html/**/*.html,  less: src/assets/less/**/*.less,  fonts: [node_modules/materialize-css/dist/fonts/**/*,          !node_modules/materialize-css/dist/font/material-design-icons/*,          node_modules/material-design-icons-iconfont/dist/fonts/**/*],  images: [src/assets/img/**/*, src/assets/icons/*],  locales: [src/_locales/*.json],};
const packageJSON = require(./package.json);
let version = packageJSON.dependencies.electron;if (version.substr(0, 1) !== 0 && version.substr(0, 1) !== 1) {  version = version.substr(1);}
const defaultPackageConf = {  appBundleId: packageJSON.name,  appCategoryType: public.app-category.music,  appCopyright: Copyright ©  , All rights reserved.,  eslint-disable-line  appVersion: packageJSON.version,  afterCopy: [    (buildPath, electronVersion, pPlatform, pArch, done) => rebuild(buildPath, electronVersion, pArch).then(() => done()).catch(done),    (buildPath, electronVersion, pPlatform, pArch, done) => {      const files = globber.sync(nodePath.resolve(buildPath, **, *.pdb))        .concat(globber.sync(nodePath.resolve(buildPath, **, *.obj)))        .concat(globber.sync(nodePath.resolve(buildPath, **, .bin, **, *)));      files.forEach(filePath => fs.unlinkSync(filePath));      done();    },  ],  arch: all,  asar: true,  buildVersion: packageJSON.version,  dir: __dirname,  icon: ./build/assets/img/main,  ignore: (path) => {    const tests = [       Ignore git directory      () => gitg,       Ignore uwp directory      () => wpg,       Ignore electron-packager on Docker machines      () => electron-packagerg,       Ignore electron      () => node_moduleselectrong,      () => node_moduleselectrong,       Ignore debug files      () => node_modulespdbg,       Ignore native module obj files      () => node_modulesobjg,       Ignore optional dev modules      () => node_modulesappdmgg,      () => node_moduleselectron-installer-debiang,      () => node_moduleselectron-installer-redhatg,       Ignore symlinks in the bin directory      () => node_modulesbing,       Ignore root dev FileDescription      () => (vendordistsigdocssrctestcertpfxeditorconfigeslintignoreeslintrcgitignoretravisymlappveyorymlcircleymlCONTRIBUTINGmdGruntfilejsgulpfilejsISSUE_TEMPLATEmdLICENSEREADMEmd)()g,  eslint-disable-line    ];    for (let i = 0; i < tests.length; i++) {      if (tests[i]().test(path)) {        return true;      }    }    return false;  },  name: packageJSON.productName,  out: ./dist/,  overwrite: true,  platform: all,  prune: true,  electronVersion: version,  win32metadata: {    CompanyName: packageJSON.author.name,    FileDescription: packageJSON.productName,    ProductName: packageJSON.productName,    InternalName: packageJSON.productName,  },};
const winstallerConfig = {  appDirectory: dist/-win32-ia32,  outputDirectory: dist/installers/win32,  authors: packageJSON.author.name,  exe: .exe,  description: packageJSON.productName,  title: packageJSON.productName,  owners: packageJSON.author.name,  name: GPMDP_3,  noMsi: true,  certificateFile: .cert.pfx,  certificatePassword: process.env.SIGN_CERT_PASS,   DEV: When in master we should change this to point to github raw url  iconUrl: https://www.samuelattard.com/img/gpmdp_setup.ico,  setupIcon: build/assets/img/main.ico,  loadingGif: build/assets/img/installing.gif,};
if (!process.env.GPMDP_DONT_BUILD_DELTAS) {  winstallerConfig.remoteReleases = https://github.com/MarshallOfSound/Google-Play-Music-Desktop-Player-UNOFFICIAL-;}
if (process.env.APPVEYOR) {  delete winstallerConfig.remoteReleases;}
const appdmgConf = {  target: dist/-darwin-x64/.dmg,  basepath: __dirname,  specification: {    title: GPMDP,    icon: .icns,    background: src/assets/img/dmg.png,    window: {      size: {        width: 600,        height: 400,      },    },    contents: [      {        x: 490, y: 252, type: link, path: /Applications,      },      {        x: 106, y: 252, type: file, path: dist/-darwin-x64/.app,      },    ],  },};
const cleanGlob = (glob) => {  return () => {    return gulp.src(glob, { read: false })      .pipe(clean({ force: true }));  };};
const windowsSignFile = (filePath, signDigest) =>  new Promise((resolve) => {    console.log(Signing file: """"With digest: );    exec(      vendorsigntool sign /f "".cert.pfx"" /p  /fd  /tr ""http://timestamp.geotrust.com/tsa"" /v /as """",      {},      () => {        setTimeout(() => {          setTimeout(resolve, 500);        });      }    );  });
gulp.task(clean, cleanGlob([./build, ./dist]));gulp.task(clean-dist-win, cleanGlob(./dist/-win32-ia32));gulp.task(clean-dist-darwin, cleanGlob(./dist/-darwin-ia32));gulp.task(clean-dist-linux-32, cleanGlob(./dist/-linux-ia32));gulp.task(clean-dist-linux-64, cleanGlob(./dist/-linux-x64));gulp.task(clean-material, cleanGlob(./build/assets/material));gulp.task(clean-utility, cleanGlob(./build/assets/util));gulp.task(clean-html, cleanGlob(./build/public_html));gulp.task(clean-internal, cleanGlob([./build/*.js, ./build/**/*.js, !./build/assets/**/*]));gulp.task(clean-fonts, cleanGlob(./build/assets/fonts));gulp.task(clean-less, cleanGlob(./build/assets/css));gulp.task(clean-images, cleanGlob(./build/assets/img));gulp.task(clean-locales, cleanGlob(./build/_locales/*.json));
gulp.task(materialize-js, [clean-material], () => {  return gulp.src(node_modules/materialize-css/dist/js/materialize.min.js)    .pipe(gulp.dest(./build/assets/material));});
gulp.task(utility-js, [clean-utility], () => {  return gulp.src(paths.utilityScripts)    .pipe(gulp.dest(./build/assets/util));});
gulp.task(html, [clean-html], () => {  return gulp.src(paths.html)    .pipe(gulp.dest(./build/public_html));});
gulp.task(transpile, [clean-internal], () => {  return gulp.src(paths.internalScripts)    .pipe(babel())    .on(error, (err) => { console.error(err); })  eslint-disable-line    .pipe(replace(processenv()( ,;)gi, (envCall, envKey, closer) => {      return '';    }))    .pipe(gulp.dest(./build/));});
gulp.task(locales, [clean-locales], () => {  return gulp.src(paths.locales)    .pipe(gulp.dest(./build/_locales));});
gulp.task(fonts, [clean-fonts], () => {  return gulp.src(paths.fonts)    .pipe(gulp.dest(./build/assets/fonts));});
gulp.task(less, [clean-less], () => {  return gulp.src(paths.less)    .pipe(less())    .on(error, (err) => { console.error(err); })  eslint-disable-line    .pipe(cssmin())    .pipe(concat(core.css))    .pipe(gulp.dest(./build/assets/css));});
 Copy all static imagesgulp.task(copy-static-images, [clean-images], () => {  return gulp.src(paths.images)    .pipe(gulp.dest(./build/assets/img/));});
gulp.task(images, [copy-static-images], (done) => {  rasterImages(done);});
gulp.task(build-release, [build], () => {  return gulp.src(./build/**/*.js)     .pipe(uglify())    .pipe(header(/*!Version: vAPI Version: vCompiled: Copyright (C)  This software may be modified and distributed under the terms of the MIT license. */    ))    .pipe(gulp.dest(./build));});
 Rerun the task when a file changesgulp.task(watch, [build], () => {  gulp.watch(paths.internalScripts, [transpile]);  gulp.watch(paths.html, [html]);  gulp.watch(paths.images, [images]);  gulp.watch(paths.less, [less]);  gulp.watch(paths.locales, [locales]);});
gulp.task(package:win, [clean-dist-win, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: win32, arch: ia32 }), (err) => {    if (err) return done(err);    setTimeout(() => {      const packageExePath = dist/-win32-ia32/.exe;      windowsSignFile(packageExePath, sha1)      .then(() => windowsSignFile(packageExePath, sha256))      .then(() => done());    }, 1000);  });});
gulp.task(make:win, [package:win], (done) => {  electronInstaller(winstallerConfig)    .then(() => {      const installerExePath = dist/installers/win32/Setup.exe;      windowsSignFile(installerExePath, sha1)      .then(() => windowsSignFile(installerExePath, sha256))      .then(() => done());    })    .catch((err) => done(err));});
gulp.task(make:win:uwp, [package:win], (done) => {  electronWindowsStore({    containerVirtualization: false,    inputDirectory: nodePath.resolve(__dirname, dist/-win32-ia32),    outputDirectory: nodePath.resolve(__dirname, dist/uwp),    flatten: true,    packageVersion: .0,    packageName: GPMDP,    packageDisplayName: GPMDP,    packageDescription: packageJSON.description,    packageExecutable: app.exe,    publisher: CN=E800FCD7-1562-414E-A4AC-F1BA78F4A060,    publisherDisplayName: Samuel Attard,    assets: buildassetsimgassets,    devCert: nodePath.resolve(__dirname, .uwp.pfx),    signtoolParams: [/p, process.env.SIGN_CERT_PASS],    finalSay: () => new Promise((resolve) => {      const manifestPath = nodePath.resolve(__dirname, dist/uwp/pre-appx/appxmanifest.xml);      const manifest = fs.readFileSync(manifestPath, utf8).replace(<Identity Name=""GPMDP"", <Identity Name=""24619SamuelAttard.GPMDP"");      fs.writeFileSync(manifestPath, manifest);      resolve();    }),  }).then(() => done()).catch(done);});
gulp.task(package:darwin, [clean-dist-darwin, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: darwin, osxSign: { identity: Developer ID Application: Samuel Attard (S7WPQ45ZU2) } }), done);  eslint-disable-line});
gulp.task(make:darwin, [package:darwin], (done) => {  const pathEscapedName = packageJSON.productName.replace( gi,  );  const child = spawn(zip, [-r, -y, .zip, .app],    {      cwd: ./dist/-darwin-x64,    });
  console.log(Zipping "".app"");  eslint-disable-line
  child.stdout.on(data, () => {});
  child.stderr.on(data, () => {});
  child.on(close, (code) => {    console.log(Finished zipping with code  + code);  eslint-disable-line
    done();  });});
gulp.task(dmg:darwin, [package:darwin], (done) => {  if (fs.existsSync(nodePath.resolve(__dirname, appdmgConf.target))) {    fs.unlinkSync(nodePath.resolve(__dirname, appdmgConf.target));  }  const dmg = require(appdmg)(appdmgConf);
  dmg.on(finish, () => done());  dmg.on(error, done);});
gulp.task(package:linux:32, [clean-dist-linux-32, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: linux, arch: ia32 }), done);});
gulp.task(package:linux:64, [clean-dist-linux-64, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: linux, arch: x64 }), done);});
gulp.task(package:linux, (done) => {  runSequence(package:linux:32, package:linux:64, done);});
const generateGulpLinuxDistroTask = (prefix, name, arch) => {  gulp.task(:linux:, [package:linux:], (done) => {    const tool = require(electron-installer-);
    const defaults = {      bin: packageJSON.productName,      dest: dist/installers/,      depends: [libappindicator1, avahi-daemon],      maintainer:  <>,      homepage: packageJSON.homepage,      icon: build/assets/img/main.png,      categories: [AudioVideo, Audio],      section: sound,    };
    let pkgArch = i386;    if (arch === 64) {      pkgArch = (prefix === rpm ? x86_64 : amd64);    }
    tool(_.extend({}, defaults, {      src: dist/-linux-,      arch: pkgArch,    }), (err) => {      console.log(bit  package built);  eslint-disable-line      if (err) return done(err);      done();    });  });};
generateGulpLinuxDistroTask(rpm, redhat, 32);generateGulpLinuxDistroTask(rpm, redhat, 64);generateGulpLinuxDistroTask(deb, debian, 32);generateGulpLinuxDistroTask(deb, debian, 64);
gulp.task(rpm:linux, (done) => {  runSequence(rpm:linux:32, rpm:linux:64, done);});
gulp.task(deb:linux, (done) => {  runSequence(deb:linux:32, deb:linux:64, done);});
const zipTask = (makeName, deps, cwd, what) => {  gulp.task(make:, deps, (done) => {    const child = spawn(zip, [-r, -y, installers.zip, .], { cwd });
    console.log(Zipping );  eslint-disable-line
     spit stdout to screen    child.stdout.on(data, () => {});
     Send stderr to the main console    child.stderr.on(data, () => {});
    child.on(close, (code) => {      console.log(Finished zipping  with code: );  eslint-disable-line      done();    });  });};
gulp.task(make:linux, (done) => {  runSequence(deb:linux, rpm:linux, make:linux:both, done);});
zipTask(linux:both, [], ./dist/installers, all the Linux Installers);zipTask(linux:deb, [deb:linux], ./dist/installers/debian, the Debian Packages);zipTask(linux:rpm, [rpm:linux], ./dist/installers/redhat, the Redhat (Fedora) Packages);
 The default task (called when you run `gulp` from cli)gulp.task(default, [watch, transpile, images]);gulp.task(build, [materialize-js, utility-js, transpile, images, less,                    fonts, html, locales]);gulp.task(package, [package:win, package:darwin, package:linux]);"
"/*global module:false*/require(babel-register);var _ = require(lodash);module.exports = function(grunt) {
   Project configuration.  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),
    karma: {      unit: {        configFile: test/client-old/spec/karma.conf.js      },      continuous: {        configFile: test/client-old/spec/karma.conf.js,        singleRun: true,        autoWatch: false      }    },
    clean: {      build: [website/build]    },
    cssmin: {      dist: {        options: {          report: gzip        },        files:{          website/client-old/css/habitrpg-shared.css: [            website/assets/sprites/dist/spritesmith*.css,            website/assets/sprites/css/backer.css,            website/assets/sprites/css/Mounts.css,            website/assets/sprites/css/index.css          ]        }      }    },
    stylus: {      build: {        options: {          compress: false,  AFTER          include css: true,          paths: [website/client-old]        },        files: {          website/build/app.css: [website/client-old/css/index.styl],          website/build/static.css: [website/client-old/css/static.styl]        }      }    },
    copy: {      build: {        files: [          {expand: true, cwd: website/client-old/, src: favicon.ico, dest: website/build/},          {expand: true, cwd: website/client-old/, src: favicon_192x192.png, dest: website/build/},          {expand: true, cwd: website/assets/sprites/dist/, src: spritesmith*.png, dest: website/build/static/sprites},          {expand: true, cwd: website/assets/sprites/, src: backer-only/*.gif, dest: website/build/},          {expand: true, cwd: website/assets/sprites/, src: npc_ian.gif, dest: website/build/},          {expand: true, cwd: website/assets/sprites/, src: quest_*.gif, dest: website/build/},          {expand: true, cwd: website/client-old/, src: bower_components/bootstrap/dist/fonts/*, dest: website/build/}        ]      }    },
     UPDATE IT WHEN YOU ADD SOME FILES NOT ALREADY MATCHED!    hashres: {      build: {        options: {          fileNameFormat: ${name}-${hash}.${ext}        },        src: [          website/build/*.js,          website/build/*.css,          website/build/favicon.ico,          website/build/favicon_192x192.png,          website/build/*.png,          website/build/static/sprites/*.png,          website/build/*.gif,          website/build/bower_components/bootstrap/dist/fonts/*        ],        dest: website/build/*.css      }    }  });
  Load build files from client-old/manifest.json  grunt.registerTask(loadManifestFiles, Load all build files from client-old/manifest.json, function(){    var files = grunt.file.readJSON(./website/client-old/manifest.json);    var uglify = {};    var cssmin = {};
    _.each(files, function(val, key){
      var js = uglify[website/build/ + key + .js] = [];
      _.each(files[key].js, function(val){        var path = ./;        if( val.indexOf(common/) == -1)          path = ./website/client-old/;        js.push(path + val);      });
      var css = cssmin[website/build/ + key + .css] = [];
      _.each(files[key].css, function(val){        var path = ./;        if( val.indexOf(common/) == -1) {          path = (val == app.css || val == static.css) ?  ./website/build/ : ./website/client-old/;        }        css.push(path + val)      });
    });
    grunt.config.set(uglify.build.files, uglify);    grunt.config.set(uglify.build.options, {compress: false});
    grunt.config.set(cssmin.build.files, cssmin);     Rewrite urls to relative path    grunt.config.set(cssmin.build.options, {target: website/client-old/css/whatever-css.css});  });
   Register tasks.  grunt.registerTask(build:prod, [loadManifestFiles, clean:build, uglify, stylus, cssmin, copy:build, hashres]);  grunt.registerTask(build:dev, [cssmin, stylus]);  grunt.registerTask(build:test, [build:dev]);
   Load tasks  grunt.loadNpmTasks(grunt-contrib-uglify);  grunt.loadNpmTasks(grunt-contrib-clean);  grunt.loadNpmTasks(grunt-contrib-stylus);  grunt.loadNpmTasks(grunt-contrib-cssmin);  grunt.loadNpmTasks(grunt-contrib-copy);  grunt.loadNpmTasks(grunt-contrib-watch);  grunt.loadNpmTasks(grunt-hashres);  if (process.env.NODE_ENV !== production) grunt.loadNpmTasks(grunt-karma);
};"
"/* * Note: You probably don't need to edit this file. Instead, add your gulp * tasks with the ./tasks directory, where tasks are grouped by their * particular purpose. If you feel like your task doesn't fit within the * existing files, feel free to create a ""gulp-thing.js"" file within that * directory, and it will automatically be included. */
require(babel-register);
if (process.env.NODE_ENV === production) {  require(./gulp/gulp-apidoc);  require(./gulp/gulp-newstuff);  require(./gulp/gulp-build);  require(./gulp/gulp-babelify);} else {  require(glob).sync(./gulp/gulp-*).forEach(require);  require(gulp).task(default, [test]);}"
code
"import React from react;import TimerMixin from react-timer-mixin;import {  ListView,  LayoutAnimation,  View,  Animated,  Dimensions,  PanResponder,  TouchableWithoutFeedback} from react-native;
let HEIGHT = Dimensions.get(window).height;var Row = React.createClass({  _data: {},  shouldComponentUpdate: function(props) {    if (props.hovering !== this.props.hovering) return true;    if (props.active !== this.props.active) return true;    if (props.rowData.data !== this.props.rowData.data) return true;    if (props.rowHasChanged) return props.rowHasChanged(props.rowData.data, this._data);    return false;  },  handleLongPress: function(e) {    this.refs.view.measure((frameX, frameY, frameWidth, frameHeight, pageX, pageY) => {      let layout = {frameX, frameY, frameWidth, frameHeight, pageX, pageY};      this.props.onRowActive({        layout: layout,        touch: e.nativeEvent,        rowData: this.props.rowData      });    });  },  componentDidUpdate: function(props) {    Take a shallow copy of the active data. So we can do manual comparisons of rows if needed.    if (props.rowHasChanged) {      this._data = (typeof props.rowData.data === object) ? Object.assign({}, props.rowData.data) : props.rowData.data;    }  },  measure: function() {    return this.refs.view.measure.apply(this, Array.from(arguments));  },  render: function() {    let layout = this.props.list.layoutMap[this.props.rowData.index];    let activeData = this.props.list.state.active;
    let activeIndex = activeData ? activeData.rowData.index : -5;    let shouldDisplayHovering = activeIndex !== this.props.rowData.index;    let Row = React.cloneElement(this.props.renderRow(this.props.rowData.data, this.props.rowData.section, this.props.rowData.index, null, this.props.active), {sortHandlers: {onLongPress: this.handleLongPress, onPressOut: this.props.list.cancel}, onLongPress: this.handleLongPress, onPressOut: this.props.list.cancel});    return <View onLayout={this.props.onRowLayout}                 style={[ this.props.active && !this.props.hovering ? {height: 0.01}:null,                          this.props.active && this.props.hovering ? {opacity: 0.0}: null,]} ref=view>          {this.props.hovering && shouldDisplayHovering ? this.props.activeDivider : null}          {Row}        </View>  }});
var SortRow = React.createClass({  getInitialState: function() {    let layout = this.props.list.state.active.layout;    let wrapperLayout = this.props.list.wrapperLayout;
    return {      style: {        position: absolute,        left: 0,        right: 0,        opacity: .2,        height: layout.frameHeight,        overflow: hidden,        backgroundColor: transparent,        marginTop: layout.pageY - wrapperLayout.pageY Account for top bar spacing      }    }  },  render: function() {    let handlers = this.props.panResponder.panHandlers;    return (      <Animated.View ref=view style={[this.state.style, this.props.sortRowStyle, this.props.list.state.pan.getLayout()]}>        {this.props.renderRow(this.props.rowData.data, this.props.rowData.section, this.props.rowData.index, null, true)}      </Animated.View>    );  }});
var SortableListView = React.createClass({  mixins: [TimerMixin],  getInitialState:function() {
    let currentPanValue = {x: 0, y: 0};
    this.state = {      ds: new ListView.DataSource({rowHasChanged: (r1, r2) => {        if (this.props.rowHasChanged) return this.props.rowHasChanged(r1, r2);        return false;      }}),      active: false,      hovering: false,      pan: new Animated.ValueXY(currentPanValue)    };    this.listener = this.state.pan.addListener(e => this.panY = e.y);    let onPanResponderMoveCb = Animated.event([null, {           dx: this.state.pan.x,  x,y are Animated.Value           dy: this.state.pan.y,      }]);
    this.state.panResponder = PanResponder.create({      onStartShouldSetPanResponder: (e) => true,      onMoveShouldSetPanResponderCapture: (e, a) => {        Only capture when moving vertically, this helps for child swiper rows.        let vy = Math.abs(a.vy);        let vx = Math.abs(a.vx);
        return (vy) > vx  && this.state.active;      },      onPanResponderMove: (evt, gestureState) => {        gestureState.dx = 0;        this.moveY = gestureState.moveY;        onPanResponderMoveCb(evt, gestureState);       },
       onPanResponderGrant: (e, gestureState) => {          this.moved = true;          this.props.onMoveStart &&  this.props.onMoveStart();          this.state.pan.setOffset(currentPanValue);          this.state.pan.setValue(currentPanValue);      },      onPanResponderRelease: (e) => {
        this.moved = false;        this.props.onMoveEnd && this.props.onMoveEnd();        if (!this.state.active) {          if (this.state.hovering) this.setState({hovering: false});          this.moveY = null;          return;        }        let itemHeight = this.state.active.layout.frameHeight;        let fromIndex = this.order.indexOf(this.state.active.rowData.index);        let toIndex = this.state.hovering === false ?  fromIndex : Number(this.state.hovering);        let up = toIndex > fromIndex;        if (up) {          toIndex--;        }        if (toIndex === fromIndex) return this.setState({active: false, hovering: false});        let args = {          row: this.state.active.rowData,          from: fromIndex,          to: toIndex        };
        this.props.onRowMoved && this.props.onRowMoved(args);        if (this.props._legacySupport) { rely on parent data changes to set state changes          LayoutAnimation.easeInEaseOut()          this.state.active = false;          this.state.hovering = false;        } else {          this.setState({            active: false,            hovering: false          });        }
        let MAX_HEIGHT = Math.max(0, this.scrollContainerHeight - this.listLayout.height + itemHeight);        if (this.scrollValue > MAX_HEIGHT) {          this.scrollResponder.scrollTo({y: MAX_HEIGHT});        }
        this.state.active = false;        this.state.hovering = false;        this.moveY = null;      }     });
    return this.state;  },  cancel: function() {    if (!this.moved) {      this.setState({        active: false,        hovering: false      });    }  },  componentDidMount: function() {    setTimeout(()=>{      this.scrollResponder = this.refs.list.getScrollResponder();    }, 1);  },  measureWrapper: function() {    if (this.refs.wrapper) {      this.refs.wrapper.measure((frameX, frameY, frameWidth, frameHeight, pageX, pageY) => {
        let layout = {frameX, frameY, frameWidth, frameHeight, pageX, pageY};        this.wrapperLayout = layout;      });    }  },  scrollValue: 0,  scrollContainerHeight: HEIGHT * 1.2, Gets calculated on scroll, but if you havent scrolled needs an initial value  scrollAnimation: function() {    if (this.isMounted() /* deprecated and unnecessary: using TimerMixin */ && this.state.active) {      if (this.moveY == undefined) return this.requestAnimationFrame(this.scrollAnimation);
      let SCROLL_OFFSET = this.wrapperLayout.pageY;      let moveY = this.moveY - SCROLL_OFFSET;      let SCROLL_LOWER_BOUND = 80;      let SCROLL_HIGHER_BOUND = this.listLayout.height - SCROLL_LOWER_BOUND;      let NORMAL_SCROLL_MAX = this.scrollContainerHeight - this.listLayout.height;      let MAX_SCROLL_VALUE = NORMAL_SCROLL_MAX + (this.state.active.layout.frameHeight * 2 );      let currentScrollValue = this.scrollValue;      let newScrollValue = null;      let SCROLL_MAX_CHANGE = 20;
      if (moveY < SCROLL_LOWER_BOUND && currentScrollValue > 0) {        let PERCENTAGE_CHANGE = 1 - (moveY / SCROLL_LOWER_BOUND);        newScrollValue = currentScrollValue - (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);        if (newScrollValue < 0) newScrollValue = 0;      }      if (moveY > SCROLL_HIGHER_BOUND && currentScrollValue < MAX_SCROLL_VALUE) {        let PERCENTAGE_CHANGE = 1 - ((this.listLayout.height - moveY) / SCROLL_LOWER_BOUND);        newScrollValue = currentScrollValue + (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);        if (newScrollValue > MAX_SCROLL_VALUE) newScrollValue = MAX_SCROLL_VALUE;      }      if (moveY < SCROLL_HIGHER_BOUND && currentScrollValue > NORMAL_SCROLL_MAX           && NORMAL_SCROLL_MAX > 0) {        let PERCENTAGE_CHANGE = 1 - ((this.listLayout.height - moveY) / SCROLL_LOWER_BOUND);        pc = PERCENTAGE_CHANGE;
        newScrollValue = currentScrollValue + (PERCENTAGE_CHANGE * SCROLL_MAX_CHANGE);      }      if (newScrollValue !== null) {        this.scrollValue = newScrollValue;         this.scrollResponder.scrollWithoutAnimationTo(this.scrollValue, 0);         this.scrollResponder.scrollTo({y: this.scrollValue, x: 0, animated: false});      }      this.checkTargetElement();      this.requestAnimationFrame(this.scrollAnimation);    }  },  checkTargetElement() {    let SLOP = 1.0  assume rows will be > 1 pixel high    let scrollValue = this.scrollValue;
    let moveY = this.moveY - this.wrapperLayout.pageY;
    let activeRowY = scrollValue + moveY - this.firstRowY;
    let indexHeight = 0.0;    let i = 0;    let row;    let order = this.order;    let isLast = false;    while (indexHeight < activeRowY + SLOP) {      let key = order[i];      row = this.layoutMap[key];      if (!row) {        isLast = true;        break;      }      indexHeight += row.height;      i++;    }    if (!isLast) i--;        if (i != this.state.hovering && i >= 0) {      LayoutAnimation.easeInEaseOut();      this._previouslyHovering = this.state.hovering;      this.__activeY = this.panY;      this.setState({        hovering: String(i)      })    }
  },  firstRowY: undefined,  layoutMap: {},  _rowRefs: {},  handleRowActive: function(row) {    if (this.props.disableSorting) return;    this.state.pan.setValue({x: 0, y: 0});    LayoutAnimation.easeInEaseOut();    this.moveY = row.layout.pageY;    this.setState({      active: row,      hovering: row.rowData.index,    },  this.scrollAnimation);
  },  renderActiveDivider: function() {    let height = this.state.active ? this.state.active.layout.frameHeight : null    if (this.props.renderActiveDivider) return this.props.renderActiveDivider(height);    return <View style={{height: height}} />  },  renderRow: function(data, section, index, highlightfn, active) {
    let Component = active ? SortRow : Row;    let isActiveRow = (!active && this.state.active && this.state.active.rowData.index === index);    if (!active && isActiveRow) {      active = {active: true};    }    let hoveringIndex = this.order[this.state.hovering] || this.state.hovering;    return (<Component      {...this.props}      activeDivider={this.renderActiveDivider()}      key={index}      active={active}      list={this}      ref={view => { this._rowRefs[active ? ghost : index] = view; }}      hovering={hoveringIndex == index}      panResponder={this.state.panResponder}      rowData={{data, section, index}}      onRowActive={this.handleRowActive}      onRowLayout={layout => this._updateLayoutMap(index, layout.nativeEvent.layout)}      />);  },  _updateLayoutMap(index, layout) {      if (this.firstRowY === undefined || layout.y < this.firstRowY) {          this.firstRowY = layout.y;      }      this.layoutMap[index] = layout;  },  renderActive: function() {    if (!this.state.active) return;    let index = this.state.active.rowData.index;    return this.renderRow(this.props.data[index], s1, index, () => {}, {active: true, thumb: true});  },  componentWillMount: function() {    this.setOrder(this.props);  },  componentWillReceiveProps: function(props) {    this.setOrder(props);  },  setOrder: function(props) {    this.order = props.order || Object.keys(props.data) || [];  },  getScrollResponder: function() {    return this.scrollResponder;  },  render: function() {    let dataSource = this.state.ds.cloneWithRows(this.props.data, this.props.order);
    return <View ref=wrapper style={{flex: 1}} onLayout={()=>{this.measureWrapper()}}>      <ListView        enableEmptySections={true}        {...this.props}        {...this.state.panResponder.panHandlers}        ref=list        dataSource={dataSource}        onScroll={e => {          this.scrollValue = e.nativeEvent.contentOffset.y;          if (this.props.onScroll) this.props.onScroll(e);        }}        onContentSizeChange={(width, height) => {          this.scrollContainerHeight = height;        }}        onLayout={(e) => this.listLayout = e.nativeEvent.layout}        scrollEnabled={!this.state.active && (this.props.scrollEnabled !== false)}        renderRow={this.renderRow}      />      {this.renderActive()}    </View>  },  scrollTo: function(...args) {    this.scrollResponder.scrollTo.apply(this.scrollResponder, args);  }});
module.exports = SortableListView;"
"var path = require(path)var webpack = require(webpack)
module.exports = {  entry: ./demo/main.js,  output: {    path: path.resolve(__dirname, ./demo/dist),    publicPath: /demo/dist/,    filename: build.js  },  resolveLoader: {    root: path.join(__dirname, node_modules),  },  module: {    loaders: [      {        test: vue,        loader: vue      },      {        test: js,        loader: babel,        exclude: node_modules      },      {        test: json,        loader: json      },      {        test: html,        loader: vue-html      },      {        test: scss,        loaders: [style, css, sass]      },      {        test: (pngjpggifsvg),        loader: url,        query: {          limit: 10000,          name: [name].[ext]?[hash]        }      }    ]  },  devServer: {    historyApiFallback: true,    noInfo: true  },  devtool: eval-source-map}
if (process.env.NODE_ENV === production) {  module.exports.devtool = source-map   http://vuejs.github.io/vue-loader/workflow/production.html  module.exports.plugins = (module.exports.plugins || []).concat([    new webpack.DefinePlugin({      process.env: {        NODE_ENV: ""production""      }    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    }),    new webpack.optimize.OccurenceOrderPlugin()  ])}"
";(function () {
  var vSortable = {}  var Sortable = typeof require === function      ? require(sortablejs)      : window.Sortable
  if (!Sortable) {    throw new Error([vue-sortable] cannot locate Sortable.js.)  }
   exposed global options  vSortable.config = {}
  vSortable.install = function (Vue) {    Vue.directive(sortable, function (options) {      options = options || {}
      var sortable = new Sortable(this.el, options)
      if (this.arg && !this.vm.sortable) {        this.vm.sortable = {}      }
        Throw an error if the given ID is not unique      if (this.arg && this.vm.sortable[this.arg]) {        console.warn([vue-sortable] cannot set already defined sortable id:  + this.arg + )      } else if( this.arg ) {        this.vm.sortable[this.arg] = sortable      }    })  }
  if (typeof exports == object) {    module.exports = vSortable  } else if (typeof define == function && define.amd) {    define([], function () {      return vSortable    })  } else if (window.Vue) {    window.vSortable = vSortable    Vue.use(vSortable)  }
})()"
"module.exports = function(grunt){	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-uglify);	 grunt.loadNpmTasks('grunt-karma');
	grunt.initConfig({		uglify: {			target: {				files: {					src/angular-sortable-view.min.js: [src/angular-sortable-view.js]				}			},			options: {				banner: /*Copyright Kamil Pękala http://github.com/kamilkp +						angular-sortable-view v0.0.13 2015/01/13*/			}		},		jshint: {			all: [				src/angular-sortable-view.js,				Gruntfile.js			]		},		 karma: {		 	unit: {		 		configFile: 'karma.conf.js',		 		singleRun: true,		 	},		 	travis: {		 		configFile: 'karma.conf.js',		 		singleRun: true,		 		browsers: [		 			'Firefox'		 		]		 	}		 }	});
	grunt.registerTask(min, Minify javascript source code, uglify);	 grunt.registerTask('test', 'Run unit tests', ['jshint', 'min', 'karma:unit']);	 grunt.registerTask('default', ['test']);	 grunt.registerTask('travis', ['jshint', 'min', 'karma:travis']);};"
"/*! * Muuri v0.2.0 * https://github.com/haltu/muuri * Copyright (c) 2015, Haltu Oy * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the ""Software""), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */!function(t,e){var i=""Muuri"",n=""function""==typeof jQuery?jQuery.Velocity:t.Velocity,r=t.Hammer;t[i]=e(t,n,r)}(this,function(t,e,n,r){""use strict"";function o(){}function s(t){var e=this,i=[],n=!!t.fillGaps,r=!!t.horizontal,o=!!t.alignRight,a=!!t.alignBottom;if(e.width=Math.round(e.width),e.height=Math.round(e.height),r?(e.setWidth=!0,e.width=0):(e.setHeight=!0,e.height=0),e.items.length){for(var l=0;l<e.items.length;l++){var h=e.items[l],u=s.getSlot(e,i,h._width,h._height,!r,n);r?e.width=Math.max(e.width,u.left+u.width):e.height=Math.max(e.height,u.top+u.height),e.slots[h._id]=u}if(o||a)for(var f in e.slots){var u=e.slots[f];o&&(u.left=e.width-(u.left+u.width)),a&&(u.top=e.height-(u.top+u.height))}}}function a(e){var i=this,n=i._settings=m({},a.defaultSettings,e||{});if(!document.body.contains(n.container))throw new Error(""Container must be an existing DOM element"");i._element=n.container,y(n.container,n.containerClass),i._id=++k,i._animQueue=""muuri-""+i._id,i._emitter=new o,i._itemShow=""function""==typeof n.show?n.show():M(n.show,!0),i._itemHide=""function""==typeof n.hide?n.hide():M(n.hide),i._items=[];for(var r=0,s=n.items.length;r<s;r++)i._items[i._items.length]=new a.Item(i,n.items[r]);if(n.layoutOnResize||0===n.layoutOnResize){var l=d(function(){i.refresh(),i.layout()},n.layoutOnResize);i._resizeHandler=function(){l()},t.addEventListener(""resize"",i._resizeHandler)}n.layoutOnInit&&i.layout(!0)}function l(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function h(t,e,i){t.splice(i,0,t.splice(e,1)[0])}function u(t){for(var e=[],i=0,n=t.length;i<n;i++)e.indexOf(t[i])===-1&&(e[e.length]=t[i]);return e}function f(t){return""object""==typeof t&&""[object Object]""===Object.prototype.toString.call(t)}function m(t){for(var e=Array.prototype.slice.call(arguments,1),i=0;i<e.length;i++){var n=e[i];for(var r in n)n.hasOwnProperty(r)&&(f(t[r])&&f(n[r])?m(t[r],n[r]):t[r]=n[r])}return t}function d(e,i){var n,o=""cancel"",s=""finish"";return function(a){n!==r&&(n=t.clearTimeout(n),a===s&&e()),a!==o&&a!==s&&(n=t.setTimeout(function(){n=r,e()},i))}}function c(t,e){var i=null,n={left:t.left-e.left,right:e.left+e.width-(t.left+t.width),top:t.top-e.top,bottom:e.top+e.height-(t.top+t.height)},r=Math.max(t.width+Math.min(n.left,0)+Math.min(n.right,0),0),o=Math.max(t.height+Math.min(n.top,0)+Math.min(n.bottom,0),0),s=r>0&&o>0;return s&&(i={},i.width=r,i.height=o,i.left=t.left+Math.abs(Math.min(n.left,0)),i.right=i.left+i.width,i.top=t.top+Math.abs(Math.min(n.top,0)),i.bottom=i.top+i.height),i}function _(e,i){return t.getComputedStyle(e,null).getPropertyValue(i)}function g(t,e){for(var i in e)t.style[i]=e[i]}function p(t,i){for(var n in i)e.hook(t,n,i[n])}function v(t,e){return("" ""+t.className).indexOf("" ""+e)>-1}function y(t,e){t.classList?t.classList.add(e):v(t,e)&&(t.className+="" ""+e)}function w(t,e){t.classList?t.classList.remove(e):v(t,e)&&(t.className=("" ""+t.className+"" "").replace("" ""+e+"" "","" "").trim())}function C(e,i,n){var o=e.getBoundingClientRect()[i],s=""height""===i,a=s?""Height"":""Width"",l=""inner""+a,h=""client""+a,u=s?""top"":""left"",f=s?""bottom"":""right"";if(n){var m=parseFloat(_(e,""margin-""+u)),d=parseFloat(_(e,""margin-""+f));o+=m>0?m:0,o+=d>0?d:0}else{var c,g;e===document.documentElement?o-=t[l]-document.documentElement[h]:(c=parseFloat(_(e,""border-""+u+""-width"")),g=parseFloat(_(e,""border-""+f+""-width"")),o-=Math.round(o)-e[h]-c-g),o-=c!==r?c:parseFloat(_(e,""border-""+u+""-width"")),o-=g!==r?g:parseFloat(_(e,""border-""+f+""-width""))}return o}function b(e){var i=0,n=0,r=parseFloat(t.pageXOffset),o=parseFloat(t.pageYOffset);if(e.self===t.self)i=r,n=o;else if(e!==document){var s=e.getBoundingClientRect();i+=s.left+r+parseFloat(_(e,""border-left-width"")),n+=s.top+o+parseFloat(_(e,""border-top-width""))}return{left:i,top:n}}function D(e){var i=""fixed""===_(e,""position"");if(i&&rt)return t;var n=e===document.documentElement||e===t?document:e.parentElement||null;if(i){for(;n&&n!==document&&!x(n);)n=n.parentElement||document;return n===document?t:n}for(;n&&n!==document&&""static""===_(n,""position"")&&!x(n);)n=n.parentElement||document;return n}function x(t){var e=_(t,nt.style),i=_(t,""display"");return""none""!==e&&""inline""!==i&&""none""!==i}function S(t,e){var i=b(e),n=b(D(t)||doc);return n.left-=Math.abs(Math.min(parseFloat(_(t,""margin-left"")),0)),n.top-=Math.abs(Math.min(parseFloat(_(t,""margin-top"")),0)),{left:i.left-n.left,top:i.top-n.top}}function R(e){var i=[],n=/(auto|scroll)/,r=e.parentNode;if(rt){if(""fixed""===_(e,""position""))return i;for(;r&&r!==document&&r!==document.documentElement;)n.test(_(r,""overflow"")+_(r,""overflow-y"")+_(r,""overflow-x""))&&(i[i.length]=r),r=""fixed""===_(r,""position"")?null:r.parentNode;null!==r&&(i[i.length]=t)}else{for(;r&&r!==document;)""fixed""!==_(e,""position"")||x(r)?(n.test(_(r,""overflow"")+_(r,""overflow-y"")+_(r,""overflow-x""))&&(i[i.length]=r),e=r,r=r.parentNode):r=r.parentNode;i.length&&i[i.length-1]===document.documentElement&&(i[i.length-1]=t)}return i}function I(t,e){var i=c(t,e);if(!i)return 0;var n={width:t.width,height:t.height,left:0,top:0},r={width:e.width,height:e.height,left:0,top:0},o=c(n,r);return i.width*i.height/(o.width*o.height)*100}function O(t,e,i){return{type:t,event:e,currentLeft:i.left,currentTop:i.top,gridLeft:i.gridX,gridTop:i.gridY}}function X(t,e,i){this.isResolved||(this.isResolved=!0,i(t))}function Y(t){if(!t.elementStyles){var e=[""width"",""height"",""padding"",""margin""];t.elementStyles={};for(var i=0;i<4;i++){var n=e[i],r=t.element.style[n];t.elementStyles[n]=r||""""}for(var i=0;i<4;i++){var n=e[i];t.element.style[n]=_(t.element,n)}}}function L(t){if(t.elementStyles)for(var e in t.elementStyles)t.element.style[e]=t.elementStyles[e]}function E(t,e,i,n,r){i=t.get(i),r=""function""==typeof n?n:r;var o=i.length;if(o){var s=""show""===e,a=s?A:W,l=s?j:B,h=n===!0,u=[],f=!1,m=[];t._emitter.emit(a,i);for(var d=0,c=i.length;d<c;d++){var _=i[d];(s&&!_._active||!s&&_._active)&&(f=!0,s&&(_._noLayoutAnimation=!0,m[m.length]=_)),_[""_""+e](h,function(e,i){e||(u[u.length]=i),--o<1&&(""function""==typeof r&&r(u),t._emitter.emit(l,u))})}f&&(m.length&&t.refresh(m),t.layout())}else""function""==typeof r&&r(i)}function M(t,i){var n=t&&t.duration||0,r=t&&t.easing||""ease-out"";if(n){var o=i?{opacity:1,scale:1}:{opacity:0,scale:.5};return{start:function(t,i,s){i?p(t._child,o):(e(t._child,o,{duration:n,easing:r,queue:t._muuri._animQueue,complete:s}),e.Utilities.dequeue(t._child,t._muuri._animQueue))},stop:function(t){e(t._child,""stop"",t._muuri._animQueue)}}}return{start:P,stop:P}}function Q(t,e,i){for(var n=t.splice(0,t.length),r=0,o=n.length;r<o;r++)n[r](e,i)}if(!document.body)throw Error(""Muuri needs access to document.body to work."");var k=0,P=function(){},F=""function""==typeof t.requestAnimationFrame?t.requestAnimationFrame:null,H=""refresh"",N=""synchronize"",T=""layoutstart"",z=""layoutend"",A=""showstart"",j=""showend"",W=""hidestart"",B=""hideend"",q=""move"",V=""swap"",U=""add"",G=""remove"",Z=""dragstart"",J=""dragmove"",K=""dragscroll"",$=""dragend"",tt=""releasestart"",et=""releaseend"",it=""destroy"",nt=function(){for(var t=[""transform"",""WebkitTransform"",""MozTransform"",""OTransform"",""msTransform""],e=0;e<t.length;e++)if(document.documentElement.style[t[e]]!==r){var i=t[e],n=i.toLowerCase().split(""transform"")[0];return{prefix:n,prop:i,style:n?""-""+n+""-transform"":i}}return null}(),rt=function(){if(!nt)return!0;var t,e,i=document.body,n=document.createElement(""div""),r=document.createElement(""div"");return g(n,{display:""block"",visibility:""hidden"",position:""absolute"",width:""1px"",height:""1px"",left:""1px"",top:""0"",margin:""0""}),g(r,{display:""block"",position:""fixed"",width:""1px"",height:""1px"",left:""0"",top:""0"",margin:""0""}),n.appendChild(r),i.appendChild(n),t=r.getBoundingClientRect().left,n.style[nt.prop]=""translateZ(0)"",e=r.getBoundingClientRect().left,i.removeChild(n),e===t}();return o.prototype.on=function(t,e){var i=this._events=this._events||{},n=i[t]||[];return n[n.length]=e,i[t]=n,this},o.prototype.off=function(t,e){var n=this._events=this._events||{},r=n[t]||[],o=r.length;if(o)for(;o--;)e===r[i]&&r.splice(o,1);return this},o.prototype.emit=function(t,e,i,n){var r=this._events=this._events||{},o=r[t]||[],s=o.length;if(s){var a=arguments.length-1;o=o.concat();for(var l=0;l<s;l++)0===a?o[l]():1===a?o[l](e):2===a?o[l](e,i):o[l](e,i,n)}return this},s.getSlot=function(t,e,i,n,r,o){var a,l,h,u,f,m=e[0]||[],d=[],c={left:null,top:null,width:i,height:n};for(a=0;a<m.length;a++)if(h=m[a],c.width<=h.width&&c.height<=h.height){c.left=h.left,c.top=h.top;break}for(null===c.left&&(c.left=r?0:t.width,c.top=r?t.height:0,o||(f=!0)),r&&c.top+c.height>t.height&&(c.left>0&&(d[d.length]={left:0,top:t.height,width:c.left,height:1/0}),c.left+c.width<t.width&&(d[d.length]={left:c.left+c.width,top:t.height,width:t.width-c.left-c.width,height:1/0}),t.height=c.top+c.height),!r&&c.left+c.width>t.width&&(c.top>0&&(d[d.length]={left:t.width,top:0,width:1/0,height:c.top}),c.top+c.height<t.height&&(d[d.length]={left:t.width,top:c.top+c.height,width:1/0,height:t.height-c.top-c.height}),t.width=c.left+c.width),a=o?0:f?m.length:a;a<m.length;a++)for(u=s.splitRect(m[a],c),l=0;l<u.length;l++)h=u[l],h.width>0&&h.height>0&&(r&&h.top<t.height||!r&&h.left<t.width)&&(d[d.length]=h);return s.purgeSlots(d).sort(r?s.sortRectsTopLeft:s.sortRectsLeftTop),e[0]=d,c},s.sortRectsTopLeft=function(t,e){return t.top<e.top?-1:t.top>e.top?1:t.left<e.left?-1:t.left>e.left?1:0},s.sortRectsLeftTop=function(t,e){return t.left<e.left?-1:t.left>e.left?1:t.top<e.top?-1:t.top>e.top?1:0},s.isRectWithinRect=function(t,e){return t.left>=e.left&&t.top>=e.top&&t.left+t.width<=e.left+e.width&&t.top+t.height<=e.top+e.height},s.purgeSlots=function(t){for(var e=t.length;e--;)for(var i=t[e],n=t.length;n--;){var r=t[n];if(e!==n&&s.isRectWithinRect(i,r)){t.splice(e,1);break}}return t},s.splitRect=function(t,e){var i=[],n=!(e.left>t.left+t.width||e.left+e.width<t.left||e.top>t.top+t.height||e.top+e.height<t.top);return n?(t.left<e.left&&(i[i.length]={left:t.left,top:t.top,width:e.left-t.left,height:t.height}),t.left+t.width>e.left+e.width&&(i[i.length]={left:e.left+e.width,top:t.top,width:t.left+t.width-(e.left+e.width),height:t.height}),t.top<e.top&&(i[i.length]={left:t.left,top:t.top,width:t.width,height:e.top-t.top}),t.top+t.height>e.top+e.height&&(i[i.length]={left:t.left,top:e.top+e.height,width:t.width,height:t.top+t.height-(e.top+e.height)})):i[0]=t,i},a.prototype._getItem=function(t){if(t){if(t instanceof a.Item)return t._muuri===this?t:null;if(""number""==typeof t)return t=t>-1?t:this._items.length+t,this._items[t]||null;for(var e=null,i=0,n=this._items.length;i<n;i++){var r=this._items[i];if(r._element===t){e=r;break}}return e}return this._items[0]||null},a.prototype.on=function(t,e){return this._emitter.on(t,e),this},a.prototype.off=function(t,e){return this._emitter.off(t,e),this},a.prototype.refresh=function(t){t=t?this.get(t):this.get(""active"");for(var e=0,i=t.length;e<i;e++)t[e]._refresh();this._emitter.emit(H,t)},a.prototype.get=function(t,e){var i=t&&""string""!=typeof t;if(e=i?e:t,e=""string""==typeof e?e:null,t=i?[].concat(t):null,e||t){for(var n=t||this._items,r=[],o=""active""===e,s=""inactive""===e,a=0,l=n.length;a<l;a++){var h=i?this._getItem(n[a]):n[a];h&&(!e||o&&h._active||s&&!h._active)&&(r[r.length]=h)}return r}return this._items.concat()},a.prototype.add=function(t,e){var i=[],n=!1;t=[].concat(t);for(var r=0,o=this._items.length;r<o;r++){var s=this._items[r],e=t.indexOf(s._element);e>-1&&t.splice(e,1)}if(!t.length)return i;for(var r=0,o=t.length;r<o;r++){var s=new a.Item(this,t[r]);i[i.length]=s,s._active&&(n=!0,s._noLayoutAnimation=!0)}return e=e<0?this._items.length-e+1:e,this._items.splice.apply(this._items,[e,0].concat(i)),n&&this.layout(),this._emitter.emit(U,i),i},a.prototype.remove=function(t,e){var i=[],n=!1;t=this.get(t);for(var r=0,o=t.length;r<o;r++){var s=t[r];s._active&&(n=!0),i[i.length]=s._destroy(e)}return n&&this.layout(),this._emitter.emit(G,i),i},a.prototype.synchronize=function(){for(var t=0,e=this._items.length;t<e;t++){var i=this._items[t];i._element.parentNode===this._element&&this._element.appendChild(i._element)}this._emitter.emit(N)},a.prototype.layout=function(t,e){var i=this,n=i._emitter,e=""function""==typeof t?t:e,r=t===!0,o=new a.Layout(i),s=-1,l=o.items.length,h=[],u=function(t,i){t||(h[h.length]=i),++s===l&&(""function""==typeof e&&e(h,o),n.emit(z,h,o))};if(n.emit(T,o.items,o),o.setHeight&&g(i._element,{height:o.height+""px""}),o.setWidth&&g(i._element,{width:o.width+""px""}),l)for(var f=0,m=o.items.length;f<m;f++){var d=o.items[f],c=o.slots[d._id];d._left=c.left,d._top=c.top,d._drag.active?u(!1,d):d._layout(r,u)}else u(!0)},a.prototype.show=function(t,e,i){E(this,""show"",t,e,i)},a.prototype.hide=function(t,e,i){E(this,""hide"",t,e,i)},a.prototype.indexOf=function(t){if(""number""==typeof t)return t<=this._items.length-1?t:null;if(t instanceof a.Item){var e=this._items.indexOf(t);return e>-1?e:null}for(var e=null,i=0,n=this._items.length;i<n;i++)if(this._items[i]._element===t){e=i;break}return e},a.prototype.move=function(t,e){t=this._getItem(t),e=this._getItem(e),t&&e&&t!==e&&(h(this._items,this._items.indexOf(t),this._items.indexOf(e)),this._emitter.emit(q,t,e))},a.prototype.swap=function(t,e){t=this._getItem(t),e=this._getItem(e),t&&e&&t!==e&&(l(this._items,this._items.indexOf(t),this._items.indexOf(e)),this._emitter.emit(V,t,e))},a.prototype.destroy=function(){this._resizeHandler&&t.removeEventListener(""resize"",this._resizeHandler);for(var e=this._items.concat(),i=0,n=e.length;i<n;i++)e[i]._destroy();w(this._element,this._settings.containerClass),g(this._element,{height:""""}),this._emitter.emit(it);var r=this._emitter._events;if(r)for(var o=Object.keys(this._emitter._events),i=0,n=o.length;i<n;i++)r[o[i]].length=0;for(var s=Object.keys(this).concat(Object.keys(a.prototype)),i=0;i<s.length;i++)this[s[i]]=null},a.Item=function(t,e){if(e.contains(t._element))throw new Error(""Item element must not be a parent of the grid container element"");e.parentNode!==t._element&&t._element.appendChild(e);var i=t._settings,n=""none""===_(e,""display"");this._id=++k,this._muuri=t,this._element=e,this._child=e.children[0],y(e,i.itemClass),this._active=!n,this._positioning=!1,this._hidden=n,this._hiding=!1,this._showing=!1,this._visibiliyQueue=[],this._layoutQueue=[],p(this._element,{left:""0"",top:""0"",translateX:""0px"",translateY:""0px""}),y(e,n?i.hiddenClass:i.shownClass),p(this._child,{scale:n?0:1,opacity:n?0:1}),n||g(this._element,{display:""block""}),this._refresh(),this._left=0,this._top=0,this._drag={active:!1},this._release={active:!1},t._settings.dragEnabled&&this._initDrag()},a.Item.prototype.inspect=function(){return{element:this._element,width:this._width,height:this._height,left:this._left,top:this._top,active:this._active,positioning:this._positioning,dragging:this._drag.active,releasing:this._release.active,visibility:this._hiding?""hiding"":this._showing?""showing"":this._hidden?""hidden"":""shown""}},a.Item.prototype._initDrag=function(){var t=this,e=t._muuri._settings,i=t._hammer=new n.Manager(t._element);i.add(new n.Pan({event:""drag"",pointers:1,threshold:0,direction:n.DIRECTION_ALL})),i.add(new n.Press({event:""draginit"",pointers:1,threshold:100,time:0})),i.set({touchAction:""none""}),t._resetReleaseData();var r=t._drag;t._resetDragData(),r.checkOverlap=d(function(){r.active&&t._checkOverlap()},e.dragSortInterval);var o=!1;r.predicate=""function""==typeof e.dragPredicate?e.dragPredicate:X,r.predicateData={},r.isPredicateResolved=function(){return o},r.resolvePredicate=function(e){o||""draginitup""===e.type||""dragend""===e.type||""dragcancel""===e.type||(o=!0,t._onDragStart(e))},r.onScroll=function(e){F?F(function(){t._onDragScroll(e)}):t._onDragScroll(e)},i.on(""draginit"",function(e){r.predicateData={},o=!1,r.predicate.call(r.predicateData,e,t,r.resolvePredicate)}).on(""dragstart dragmove"",function(e){o&&r.active&&t._onDragMove(e),r.predicate.call(r.predicateData,e,t,r.resolvePredicate)}).on(""dragend dragcancel draginitup"",function(e){o&&r.active&&t._onDragEnd(e),r.predicate.call(r.predicateData,e,t,r.resolvePredicate)})},a.Item.prototype._resetDragData=function(){var t=this._drag;t.active=!1,t.start=null,t.move=null,t.element=null,t.elemWidth=0,t.elemHeight=0,t.elementStyles=null,t.scrollParents=[],t.left=0,t.top=0,t.gridX=0,t.gridY=0,t.elemClientX=0,t.elemClientY=0,t.containerDiffX=0,t.containerDiffY=0},a.Item.prototype._onDragStart=function(t){var i=this._drag,n=this._muuri._settings,r=this._release.active;if(this._active){this._positioning&&this._stopLayout(),r&&(i.elementStyles=this._release.elementStyles,w(this._element,n.releasingClass),this._resetReleaseData()),i.active=!0,i.start=t,i.move=t,i.element=this._element,i.elemWidth=this._width,i.elemHeight=this._height;var o=parseFloat(e.hook(i.element,""translateX""))||0,s=parseFloat(e.hook(i.element,""translateY""))||0,a=this._muuri._element,l=n.dragContainer;if(i.left=i.gridX=o,i.top=i.gridY=s,l&&l!==a)if(i.element.parentNode===l){var h=S(i.element,a);i.containerDiffX=h.left,i.containerDiffY=h.top,i.gridX=o-i.containerDiffX,i.gridY=s-i.containerDiffY}else{Y(i),l.appendChild(i.element);var h=S(i.element,a);i.containerDiffX=h.left,i.containerDiffY=h.top,i.left=o+i.containerDiffX,i.top=s+i.containerDiffY,p(i.element,{translateX:i.left+""px"",translateY:i.top+""px""})}var f=i.element.getBoundingClientRect();i.elemClientX=f.left,i.elemClientY=f.top,i.scrollParents=R(i.element),l&&l!==a&&(i.scrollParents=u(i.scrollParents.concat(R(a))));for(var m=0,d=i.scrollParents.length;m<d;m++)i.scrollParents[m].addEventListener(""scroll"",i.onScroll);y(i.element,n.draggingClass),this._muuri._emitter.emit(Z,this,O(""dragstart"",t,i))}},a.Item.prototype._onDragMove=function(t){var e=this._drag,i=this._muuri._settings;if(!this._active)return void this._resetDrag();var n=t.deltaX-e.move.deltaX,r=t.deltaY-e.move.deltaY;e.move=t,e.left+=n,e.top+=r,e.gridX+=n,e.gridY+=r,e.elemClientX+=n,e.elemClientY+=r,p(e.element,{translateX:e.left+""px"",translateY:e.top+""px""}),i.dragSort&&e.checkOverlap(),this._muuri._emitter.emit(J,this,O(""dragmove"",t,e))},a.Item.prototype._onDragScroll=function(t){var e=this._drag,i=this._muuri._settings,n=this._muuri._element,r=i.dragContainer,o=e.element.getBoundingClientRect(),s=e.elemClientX-o.left,a=e.elemClientY-o.top;if(r&&r!==n){var l=S(e.element,n);e.containerDiffX=l.left,e.containerDiffY=l.top}e.left+=s,e.top+=a,e.gridX=e.left-e.containerDiffX,e.gridY=e.top-e.containerDiffY,p(e.element,{translateX:e.left+""px"",translateY:e.top+""px""}),i.dragSort&&e.checkOverlap(),this._muuri._emitter.emit(K,this,O(""dragscroll"",t,e))},a.Item.prototype._onDragEnd=function(t){var e=this._drag,i=this._muuri._settings,n=this._release;if(!this._active)return void this._resetDrag();i.dragSort&&e.checkOverlap(""finish"");for(var r=0,o=e.scrollParents.length;r<o;r++)e.scrollParents[r].removeEventListener(""scroll"",e.onScroll);w(e.element,i.draggingClass),e.active=!1,this._muuri._emitter.emit($,this,O(""dragend"",t,e)),n.containerDiffX=e.containerDiffX,n.containerDiffY=e.containerDiffY,n.element=e.element,n.elementStyles=e.elementStyles,this._resetDragData(),this._startRelease()},a.Item.prototype._resetDrag=function(t){for(var e=this._drag,i=this._muuri._settings,n=0,r=e.scrollParents.length;n<r;n++)e.scrollParents[n].removeEventListener(""scroll"",e.onScroll);e.checkOverlap(""cancel""),w(e.element,i.draggingClass),L(e),this._resetDragData()},a.Item.prototype._resetReleaseData=function(){var t=this._release;t.active=!1,t.positioningStarted=!1,t.containerDiffX=0,t.containerDiffY=0,t.element=null,t.elementStyles=null},a.Item.prototype._startRelease=function(){var t=this._muuri._settings,e=this._release;e.active=!0,y(e.element,t.releasingClass),this._muuri._emitter.emit(tt,this),this._layout(!1)},a.Item.prototype._endRelease=function(){var t=this._muuri._settings,e=this._release;w(e.element,t.releasingClass),e.element.parentNode!==this._muuri._element&&(this._muuri._element.appendChild(e.element),p(e.element,{translateX:this._left+""px"",translateY:this._top+""px""})),L(e),this._resetReleaseData(),this._muuri._emitter.emit(et,this)},a.Item.prototype._checkOverlap=function(){for(var t=this._muuri._settings,e=t.dragSortTolerance,i=t.dragSortAction,n=this._muuri._items,r=null,o=0,s={width:this._drag.elemWidth,height:this._drag.elemHeight,left:this._drag.gridX,top:this._drag.gridY},a=0,u=n.length;a<u;a++){var f=n[a];if(f===this)o=a;else if(f._active){var m=I(s,{width:f._width,height:f._height,left:f._left,top:f._top});(!r||m>r.score)&&(r={item:f,score:m,index:a})}}r&&r.score>=e&&(""swap""===i?(l(n,o,r.index),this._muuri._emitter.emit(V,this,r.item)):(h(n,o,r.index),this._muuri._emitter.emit(q,this,r.item)),this._muuri.layout())},a.Item.prototype._stopLayout=function(){var t=this._muuri._settings;this._positioning&&(e(this._element,""stop"",this._muuri._animQueue),w(this._element,t.positioningClass),this._positioning=!1,Q(this._layoutQueue,!0,this))},a.Item.prototype._refresh=function(){this._hidden||(this._width=Math.round(C(this._element,""width"",!0)),this._height=Math.round(C(this._element,""height"",!0)))},a.Item.prototype._layout=function(t,i){var n=this,r=n._muuri._settings,o=n._release,s=o.active&&o.positioningStarted===!1,a=s?r.dragReleaseDuration:r.positionDuration,l=s?r.dragReleaseEasing:r.positionEasing,h=t!==!0&&!n._noLayoutAnimation&&a>0,u=n._positioning,f=function(){w(n._element,r.positioningClass),n._positioning=!1,o.active&&n._endRelease(),Q(n._layoutQueue,!1,n)};n._stopLayout(),""function""==typeof i&&(n._layoutQueue[n._layoutQueue.length]=i),s&&(o.positioningStarted=!0);var m=n._release.active?n._release.containerDiffX:0,d=n._release.active?n._release.containerDiffY:0;if(h){var c=(parseFloat(e.hook(n._element,""translateX""))||0)-m,_=(parseFloat(e.hook(n._element,""translateY""))||0)-d;if(n._left===c&&n._top===_)return void f();n._positioning=!0,u||y(n._element,r.positioningClass),e(n._element,{translateX:n._left+m,translateY:n._top+d},{duration:a,easing:l,complete:f,queue:n._muuri._animQueue}),e.Utilities.dequeue(n._element,n._muuri._animQueue)}else n._noLayoutAnimation&&(n._noLayoutAnimation=!1),p(n._element,{translateX:n._left+m+""px"",translateY:n._top+d+""px""}),f()},a.Item.prototype._show=function(t,e){var i=this,n=i._muuri._settings;if(i._hidden||i._showing)if(i._hidden){i._hiding;i._muuri._itemHide.stop(i),i._active=!0,i._hidden=!1,i._showing=i._hiding=!1,y(i._element,n.shownClass),w(i._element,n.hiddenClass),g(i._element,{display:""block""}),Q(i._visibiliyQueue,!0,i),i._showing=!0,""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e),i._muuri._itemShow.start(i,t,function(){Q(i._visibiliyQueue,!1,i)})}else""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e);else""function""==typeof e&&e(!1,i)},a.Item.prototype._hide=function(t,e){var i=this,n=i._muuri._settings;if(i._hidden&&!i._hiding)""function""==typeof e&&e(!1,i);else if(i._hidden)""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e);else{i._showing;i._muuri._itemShow.stop(i),i._active=!1,i._hidden=!0,i._showing=i._hiding=!1,y(i._element,n.hiddenClass),w(i._element,n.shownClass),Q(i._visibiliyQueue,!0,i),i._hiding=!0,""function""==typeof e&&(i._visibiliyQueue[i._visibiliyQueue.length]=e),i._muuri._itemHide.start(i,t,function(){g(i._element,{display:""none""}),Q(i._visibiliyQueue,!1,i)})}},a.Item.prototype._destroy=function(t){var e=(this._muuri,this._muuri._settings),i=this._element,n=this._muuri._items.indexOf(this);this._stopLayout(),this._muuri._itemShow.stop(this),this._muuri._itemHide.stop(this),this._release.active&&(i.parentNode!==this._muuri._element&&this._muuri._element.appendChild(i),this._resetReleaseData()),this._drag.active&&(i.parentNode!==this._muuri._element&&this._muuri._element.appendChild(i),this._resetDrag()),this._hammer&&this._hammer.destroy(),i.removeAttribute(""style""),this._child.removeAttribute(""style""),Q(this._visibiliyQueue,!0,this),w(i,e.positioningClass),w(i,e.draggingClass),w(i,e.releasingClass),w(i,e.itemClass),w(i,e.shownClass),w(i,e.hiddenClass),n>-1&&this._muuri._items.splice(n,1),t&&i.parentNode.removeChild(i);for(var r=Object.keys(this).concat(Object.keys(a.Item.prototype)),o=0;o<r.length;o++)this[r[o]]=null},a.Layout=function(t,e){var i=t._settings.layout;if(this.muuri=t,this.items=e?e.concat():t.get(""active""),this.slots={},this.width=0,this.height=0,this.setWidth=!1,this.setHeight=!1,this.width=C(t._element,""width""),this.height=C(t._element,""height""),""function""==typeof i)i.call(this);else{var n=""string""==typeof i,r=n?i:i[0];if(""function""!=typeof a.Layout.methods[r])throw new Error('Layout method ""'+method+'"" does not exist.');typeof a.Layout.methods[r].call(this,n?{}:i[1])}},a.Layout.methods={firstFit:s},a.defaultSettings={container:null,items:[],positionDuration:300,positionEasing:""ease-out"",show:{duration:300,easing:""ease-out""},hide:{duration:300,easing:""ease-out""},layout:""firstFit"",layoutOnResize:100,layoutOnInit:!0,dragEnabled:!1,dragContainer:null,dragPredicate:null,dragSort:!0,dragSortInterval:50,dragSortTolerance:50,dragSortAction:""move"",dragReleaseDuration:300,dragReleaseEasing:""ease-out"",containerClass:""muuri"",itemClass:""muuri-item"",shownClass:""muuri-shown"",hiddenClass:""muuri-hidden"",positioningClass:""muuri-positioning"",draggingClass:""muuri-dragging"",releasingClass:""muuri-releasing""},a});"
"module.exports = function (config) {    var configuration = {
         base path that will be used to resolve all patterns (eg. files, exclude)        basePath: ,

         frameworks to use         available frameworks: https://npmjs.org/browse/keyword/karma-adapter        frameworks: [jasmine],

         list of files / patterns to load in the browser        files: [            node_modules/jquery/dist/jquery.js,            node_modules/jasmine-jquery/lib/jasmine-jquery.js,            node_modules/jasmine2-custom-message/jasmine2-custom-message.js,            { pattern: Tests/*.html, included: true },            { pattern: Tests/*.js, included: true },            Scripts/moment.min.js,            Scripts/bootstrap-sortable.js        ],

         list of files to exclude        exclude: [        ],

         preprocess matching files before serving them to the browser         available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor        preprocessors: {        },

         test results reporter to use         possible values: 'dots', 'progress'         available reporters: https://npmjs.org/browse/keyword/karma-reporter        reporters: [mocha],

         enable / disable colors in the output (reporters and logs)        colors: true,

         level of logging         possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG        logLevel: config.LOG_INFO,

         enable / disable watching file and executing tests whenever any file changes        autoWatch: false,

         start these browsers         available browser launchers: https://npmjs.org/browse/keyword/karma-launcher        browsers: [PhantomJS],
         Continuous Integration mode         if true, Karma captures browsers, runs the tests and exits        singleRun: true    };
    config.set(configuration);}
"
"/** * Created by lijun on 2016/12/14. */var webpack = require(webpack)var path = require(path)var projectRoot = path.resolve(__dirname, ./)
module.exports = {  entry: ./docs/index.js,  output: {    path: ./build,    publicPath: build/,    filename: build-docs.js  },  resolve: {    root: path.resolve(./),    extensions: [, .js],    fallback: [path.join(__dirname, ../node_modules)],  },  resolveLoader: {    fallback: [path.join(__dirname, ../node_modules)]  },  module: {    preLoaders: [      {        test: js,        loader: eslint,        include: projectRoot,        exclude: node_modules      }    ],    loaders: [      {        test: js,        loader: babel,        include: projectRoot,        exclude: node_modules      },      { test: css, loader: style-loader!css-loader }    ]  },  eslint: {    formatter: require(eslint-friendly-formatter)  },  babel: {    presets: [      es2015,      stage-2    ],    plugins: [transform-runtime]  },  devtool: source-map};

if (process.env.NODE_ENV === production) {  delete module.exports.devtool;  module.exports.plugins = [    new webpack.DefinePlugin({      process.env: {        NODE_ENV: ""production""      }    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    })  ];}"
"/** * Created by lijun on 2016/12/14. */var config = require(./webpack.build.js)var webpack = require(webpack)

config.output.filename = config.output.filename.replace(js, .min.js)
delete config.devtool
config.plugins = [  new webpack.optimize.UglifyJsPlugin({    sourceMap: false,    drop_console: true,    compress: {      warnings: false    }  })]
module.exports = config"
"var path = require(path);var webpack = require(webpack);
module.exports = [{  entry: ./src/index.js,
  output: {    filename: ./lib/standalone/react-sortable.js,    libraryTarget: umd,    library: Sortable  },
  module: {    loaders: [{      test: js,      loader: babel,      include: [        path.join(__dirname, src)      ]    }]  },
  externals: {    react: React  }}, {  entry: ./src/index.js,
  output: {    filename: ./lib/standalone/react-sortable.min.js,    libraryTarget: umd,    library: Sortable  },
  module: {    loaders: [{      test: js,      loader: babel,      include: [        path.join(__dirname, src)      ]    }]  },
  externals: {    react: React  },
  plugins: [    new webpack.DefinePlugin({      process.env: {        NODE_ENV: JSON.stringify(production)      }    }),    new webpack.optimize.UglifyJsPlugin({      output: {        comments: false      },      compress: {        warnings: false      }    })  ]}];"
"use strict;
import React from react;import {  AppRegistry,} from react-native;
import Root from ./App/Root;AppRegistry.registerComponent(Sample, () => Root);"
"module.exports = function(grunt) {
     Project configuration.    grunt.initConfig({        pkg: grunt.file.readJSON(package.json),        concat: {            options: {                separator: ,                stripBanners: true,                banner: // <%= pkg.name %> <%= pkg.version %> | (c) <%= grunt.template.today(""yyyy"") %> Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license            },            dist: {                src: src/*.js,                dest: build/<%= pkg.name %>.js            }        },        uglify: {            options: {                stripBanners: true,                banner: // <%= pkg.name %> <%= pkg.version %> | (c) <%= grunt.template.today(""yyyy"") %> Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license            },            build: {                src: build/<%= pkg.name %>.js,                dest: build/<%= pkg.name %>.min.js            }        },        jshint: {            files: src/*.js,            options: {                ""-W030"": false,                force: true            }        },        watch: {            scripts: {                files: [src/*.*],                tasks: [default],                options: {                    nospawn: true                }            }        },        jasmine : {            src : src/*.js,            options : {                specs : spec/*.js,                vendor: ext/*.js,                template : require(grunt-template-jasmine-istanbul),                templateOptions: {                    coverage: reports/coverage.json,                    report: reports/coverage                }            }        }    });
    grunt.loadNpmTasks(grunt-contrib-concat);    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-watch);    grunt.loadNpmTasks(grunt-contrib-jshint);    grunt.loadNpmTasks(grunt-contrib-jasmine);
     Default task(s).    grunt.registerTask(default, [jshint, concat, uglify, jasmine]);
};"
"var assert = require(assert)var ulid = require(./)
describe(ulid, function() {
  describe(prng, function() {
    it(should produce a number, function() {      assert.strictEqual(false, isNaN(ulid.prng()))    })
    it(should be between 0 and 1, function() {      var num = ulid.prng()      assert(num > 0 && num < 1)    })
  })
  describe(encodeTime, function() {
    it(should return expected encoded result, function() {      assert.strictEqual(01ARYZ6S41, ulid.encodeTime(1469918176385, 10))    })
    it(should change length properly, function() {      assert.strictEqual(0001AS99AA60, ulid.encodeTime(1470264322240, 12))    })
    it(should truncate time if not enough length, function() {      assert.strictEqual(AS4Y1E11, ulid.encodeTime(1470118279201, 8))    })
    it(should throw if time greater than (2 ^ 48) - 1, function() {      assert.throws(() => ulid.encodeTime(Math.pow(2, 48), 8), Error)    })
  })
  describe(encodeRandom, function() {
    it(should return correct length, function() {      assert.strictEqual(12, ulid.encodeRandom(12).length)    })
  })
  describe(ulid, function() {
    it(should return correct length, function() {      assert.strictEqual(26, ulid().length)    })
    it(should return expected encoded time component result, function() {      assert.strictEqual(01ARYZ6S41, ulid(1469918176385).substring(0, 10))    })
    it(should throw an error if seed is not a number, function() {      assert.throws(() => ulid(test), Error)    })
  })
})"
"(function(c){c.fn.stupidtable=function(b){return this.each(function(){var a=c(this);b=b||{};b=c.extend({},c.fn.stupidtable.default_sort_fns,b);a.data(sortFns,b);a.on(click.stupidtable,thead th,function(){c(this).stupidsort()})})};c.fn.stupidsort=function(b){var a=c(this),g=0,f=c.fn.stupidtable.dir,e=a.closest(table),k=a.data(sort)||null;if(null!==k){a.parents(tr).find(th).slice(0,c(this).index()).each(function(){var a=c(this).attr(colspan)||1;g+=parseInt(a,10)});var d;1==arguments.length?d=b:(d=b||a.data(sort-default)||f.ASC,a.data(sort-dir)&&(d=a.data(sort-dir)===f.ASC?f.DESC:f.ASC));if(a.data(sort-dir)!==d)return a.data(sort-dir,d),e.trigger(beforetablesort,{column:g,direction:d}),e.css(display),setTimeout(function(){var b=[],l=e.data(sortFns)[k],h=e.children(tbody).children(tr);h.each(function(a,d){var e=c(d).children().eq(g),f=e.data(sort-value);undefined===typeof f&&(f=e.text(),e.data(sort-value,f));b.push([f,d])});b.sort(function(a,b){return l(a[0],b[0])});d!=f.ASC&&b.reverse();h=c.map(b,function(a){return a[1]});e.children(tbody).append(h);e.find(th).data(sort-dir,null).removeClass(sorting-desc sorting-asc);a.data(sort-dir,d).addClass(sorting-+d);e.trigger(aftertablesort,{column:g,direction:d});e.css(display)},10),a}};c.fn.updateSortVal=function(b){var a=c(this);a.is([data-sort-value])&&a.attr(data-sort-value,b);a.data(sort-value,b);return a};c.fn.stupidtable.dir={ASC:asc,DESC:desc};c.fn.stupidtable.default_sort_fns={:function(b,a){return parseInt(b,10)-parseInt(a,10)},:function(b,a){return parseFloat(b)-parseFloat(a)},string:function(b,a){return b.toString().localeCompare(a.toString())},:function(b,a){b=b.toString().toLocaleLowerCase();a=a.toString().toLocaleLowerCase();return b.localeCompare(a)}}})(jQuery);"
module.exports = require(./lib/AbsoluteGrid.jsx);
"import path from path;import webpack from webpack;import autoprefixer from autoprefixer;import packageObj from ./package.json;
 Get the external packages used by the projectconst externals = {};[ dependencies, peerDependencies ].forEach(depGroup => {    if (packageObj[depGroup]) {        Object.keys(packageObj[depGroup]).forEach(dep => {            externals[dep] = dep;        });    }});
module.exports = {    entry: {        react-sortable-tree: ./src/index,    },    output: {        path: path.join(__dirname, dist, umd),        filename: [name].js,        libraryTarget: umd,        library: ReactSortableTree,    },    resolve: {        extensions: [, .js]    },    devtool: source-map,    plugins: [        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.optimize.OccurenceOrderPlugin(),        new webpack.optimize.UglifyJsPlugin({            compress: {                warnings: false            },            mangle: false,            beautify: true,            comments: true,        }),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    externals,    module: {        loaders: [            {                test: jsx,                loaders: [babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },        ]    }};"
"module.exports = function( grunt ) {	use strict;
	require(load-grunt-tasks)(grunt);
	var banner = /* https://github.com/micmro/performance-bookmarklet by Michael Mrowetz @MicMro   build:<%= grunt.template.today(dd/mm/yyyy) %> */;
	grunt.initConfig({		copy : {			distBookmarklet: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:chromeExtensionfirefoxAddon)js);					},					ext: .js				}]			},			distFirefoxAddon: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:bookmarkletchromeExtension)js);					},					ext: .js				}]			},			distChromeExtension: {				files: [{					expand: true,					cwd: src/,					src: [**/*.js],					dest: dist/tempCollect,					filter: function(fileName){						return !fileName.match((?:bookmarkletfirefoxAddon)js);					},					ext: .js				}]			}		},		babel: {			options: {				returnUsedHelpers: true			},			dist: {				files: [{					expand: true,					cwd: dist/tempCollect,					src: [**/*.js],					dest: dist/tempEs5,					ext: .js				}]			}		},		browserify: {			options: {				banner: banner			},			distBookmarklet: {				files: {					dist/performanceBookmarklet.js: [dist/tempEs5/**/*.js],				}			},			distFirefoxAddon: {				files: {					dist/performanceBookmarklet.ff.js: [dist/tempEs5/**/*.js],				}			},			distChromeExtension: {				files: {					dist/performanceBookmarklet.chrome.js: [dist/tempEs5/**/*.js],				}			}		},		uglify : {			options: {				compress: {					global_defs: {						DEBUG: false					},					dead_code: true				},				banner: banner			},			distBookmarklet: {				files: {					dist/performanceBookmarklet.min.js: [dist/performanceBookmarklet.js]				}			},			distFirefoxAddon: {				files: {					dist/performanceBookmarklet.ff.min.js: [dist/performanceBookmarklet.ff.js]				}			},			distChromeExtension: {				files: {					dist/performanceBookmarklet.chrome.min.js: [dist/performanceBookmarklet.chrome.js]				}			}		},		watch: {			babelBookmarklet: {				files: [src/**/*, Gruntfile.js],				tasks: [distBookmarklet],				options: {					spawn: false,					interrupt: true				},			},			babelFirefoxAddon: {				files: [src/**/*, Gruntfile.js],				tasks: [distFirefoxAddon],				options: {					spawn: false,					interrupt: true				},			},			babelChromeExtension: {				files: [src/**/*, Gruntfile.js],				tasks: [distChromeExtension],				options: {					spawn: false,					interrupt: true				},			},		}	});

	transform CSS file to JS variable	grunt.registerTask(inlineCssToJs, function() {		var cssFile = src/style.css;		var cssFileDestination = dist/tempCollect/helpers/style.js;		var varName = style;
		var cssContent = grunt.file.read(cssFile);
		clean CSS content		cssContent = cssContent.replace( (?:(?!))g, ).replace(g,  ).replace(g,  ).replace(g,);
		make JS Var and export as module		cssContent = export const  + varName +  =  + cssContent.trim() + ;;
		grunt.log.writeln(cssFile +  transformed to  + cssFileDestination);
		grunt.file.write(cssFileDestination, cssContent);	});
	grunt.registerTask(distBookmarklet, [inlineCssToJs, copy:distBookmarklet, babel, browserify:distBookmarklet, uglify:distBookmarklet]);	grunt.registerTask(distFirefoxAddon, [inlineCssToJs, copy:distFirefoxAddon, babel, browserify:distFirefoxAddon, uglify:distFirefoxAddon]);	grunt.registerTask(distChromeExtension, [inlineCssToJs, copy:distChromeExtension, babel, browserify:distChromeExtension, uglify:distChromeExtension]);	grunt.registerTask(distAll, [distBookmarklet, distFirefoxAddon, distChromeExtension]);
	grunt.registerTask(watchDistBookmarklet, [distBookmarklet, watch:babelBookmarklet]);	grunt.registerTask(watchDistFirefoxAddon, [distFirefoxAddon, watch:babelFirefoxAddon]);	grunt.registerTask(watchDistChromeExtension, [distChromeExtension, watch:babelChromeExtension]);


	grunt.registerTask(default, [watchDistBookmarklet]);};"
"use strict/* ---------- *//* setup */var gulp = require(gulp)var rename = require(gulp-rename)var uglify = require(gulp-uglify)var sourcemaps = require(gulp-sourcemaps)var umd = require(gulp-umd)var strip = require(gulp-strip-code)
/* ---------- *//* convert to umd */gulp.task(umd, function () {  return gulp.src(src/html.sortable.js)    .pipe(strip({       jscs:disable      start_comment: start-testing,      end_comment: end-testing       jscs:enable    }))    .pipe(umd({      exports: function () {        return sortable      },      namespace: function () {        return sortable      }    }))    .pipe(gulp.dest(dist/))})/* ---------- *//* build */gulp.task(minify, [umd], function () {   copy files to dist  gulp.src([dist/html.sortable.js])    .pipe(sourcemaps.init({loadMaps: true}))    .pipe(uglify())    .pipe(rename({      suffix: .min    }))    .pipe(sourcemaps.write(./))    .pipe(gulp.dest(./dist))    .pipe(gulp.dest(./docs))})/* ---------- *//* tasks */gulp.task(default, [umd, minify])"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: eval,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        preLoaders: [            {                test: jsx,                loader: eslint-loader,                include: path.join(__dirname, src)            },        ],        loaders: [            {                test: jsx,                loaders: [react-hot, babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },            { test: json, loader: json },  For the cheerio dependency of enzyme        ],    },    externals: {  All of these are for enzyme        react/addons: true,        react/lib/ExecutionEnvironment: true,        react/lib/ReactContext: true,    },    devServer: {        contentBase: build,        port: 3001    },};"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: source-map,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.NoErrorsPlugin(),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        loaders: [            {                test: jsx,                loaders: [react-hot, babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },        ],    },    devServer: {        contentBase: build,        port: 3001,        stats: {            chunks: false,            hash: false,            version: false,            assets: false,            children: false,        },    },};"
"import HtmlWebpackPlugin from html-webpack-plugin;import path from path;import webpack from webpack;import autoprefixer from autoprefixer;
module.exports = {    devtool: source-map,    entry: {        demo: ./src/examples/basicExample/app,    },    output: {        path: build,        filename: static/[name].js,    },    plugins: [        new HtmlWebpackPlugin({            filename: index.html,            inject: true,            template: ./src/examples/basicExample/index.html,        }),        new webpack.EnvironmentPlugin([            NODE_ENV,        ]),        new webpack.optimize.UglifyJsPlugin({            compress: {                warnings: false            },        }),    ],    postcss: [        autoprefixer({ browsers: [IE >= 9, last 2 versions, > 1%] }),    ],    module: {        loaders: [            {                test: jsx,                loaders: [babel],                include: path.join(__dirname, src)            },            {                test: scss,                loaders: [                    style-loader?insertAt=top,                    css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local],                    postcss-loader,                    sass-loader,                ],                include: path.join(__dirname, src)            },            {                test: css,                loaders: [                    style-loader?insertAt=top,                    css-loader?-autoprefixer,                    postcss-loader,                ],            },            {                test: (jpegpnggificosvg),                loaders: [                    file-loader?name=static/[name].[ext],                ],                include: path.join(__dirname, src)            },        ],    }};"
require(babel-core/register);module.exports = require(./karma.conf.babel).default;
"import KarmaJasmine from karma-jasmine;import KarmaWebpack from karma-webpack;import KarmaJasmineDiffReporter from karma-jasmine-diff-reporter;import KarmaJasmineHtmlReporter from karma-jasmine-html-reporter;import KarmaNotifyReporter from karma-notify-reporter;import KarmaSourcemapLoader from karma-sourcemap-loader;import KarmaPhantomjsLauncher from karma-phantomjs-launcher;import webpackConfig from ./webpack.config.test.babel;
export default function setConfig(config) {    config.set({        browsers: [PhantomJS],        frameworks: [jasmine],        files: [src/tests.js],        preprocessors: {            src/tests.js: [webpack, sourcemap]        },        plugins: [            KarmaJasmine,            KarmaWebpack,            KarmaJasmineDiffReporter,            KarmaJasmineHtmlReporter,            KarmaNotifyReporter,            KarmaSourcemapLoader,            KarmaPhantomjsLauncher,        ],        reporters: [            jasmine-diff,            progress,            kjhtml,            notify,        ],        jasmineDiffReporter: {            pretty: 4,            json: true,            multiline: {                before: 2,  2 newlines                after:  2,  2 newlines                indent: 4,  4 spaces            },            color: {                actualFg: red,                expectedFg: green,                actualBg: inverse,                expectedBg: inverse,                actualWhitespaceBg: ,                expectedWhitespaceBg: ,            },        },        webpack: webpackConfig,        webpackMiddleware: {            stats: {                chunks: false,                hash: false,                version: false,                assets: false,                children: false,            },        },        notifyReporter: {            reportEachFailure: false,  Default: false, Will notify on every failed spec            reportSuccess: false,  Default: true, Will notify when a suite was successful        },    });}"
"use strict;
import React from react;import ReactDOM from react-dom; import Perf from 'react-addons-perf';import createAbsoluteGrid from ./index.js;import SampleDisplay from ./demo/SampleDisplay.jsx;import * as data from ./demo/sampleData.js;import * as _ from lodash;
demo();
/** * This demo is meant to show you all of the things that are possible with ReactAbsoluteGrid * If implemented in a Flux project, the grid would be in a render method with the * event handlers calling Actions which would update a Store. For the sake of brevity, * the ""store"" is implemented locally and the changes re-rendered manually * * TODO: implement inside a react component rather than doing this all manually **/
function demo() {
  let sampleItems = data.screens;  let render;  let zoom = 0.7;
  We set a property on each item to let the grid know not to show it  var onFilter = function(event){    var search = new RegExp(event.target.value, i);    sampleItems = sampleItems.map(function(item){      const isMatched = !item.name.match(search);      if(!item.filtered || isMatched !== item.filtered) {        return {          ...item,          filtered: isMatched        }      }      return item;    });    render();  };
  Change the item's sort order  var onMove = function(source, target){    source = _.find(sampleItems, {key: parseInt(source, 10)});    target = _.find(sampleItems, {key: parseInt(target, 10)});
    const targetSort = target.sort;
    CAREFUL, For maximum performance we must maintain the array's order, but change sort    sampleItems = sampleItems.map(function(item){      Decrement sorts between positions when target is greater      if(item.key === source.key) {        return {          ...item,          sort: targetSort        }      } else if(target.sort > source.sort && (item.sort <= target.sort && item.sort > source.sort)){        return {          ...item,          sort: item.sort - 1        };      Increment sorts between positions when source is greater      } else if (item.sort >= target.sort && item.sort < source.sort){        return {          ...item,          sort: item.sort + 1        };      }      return item;    });    Perf.start();    render();    Perf.stop();    Perf.printWasted();  };
  var onMoveDebounced = _.debounce(onMove, 40);
  var unMountTest = function(){    if(ReactDOM.unmountComponentAtNode(document.getElementById(Demo))){      ReactDOM.render(<button onClick={unMountTest}>Remount</button>, document.getElementById(UnmountButton));    }else{      render();      ReactDOM.render(<button onClick={unMountTest}>Test Unmount</button>, document.getElementById(UnmountButton));    }  };
  const AbsoluteGrid = createAbsoluteGrid(SampleDisplay);  render = function(){    ReactDOM.render(<AbsoluteGrid items={sampleItems}                               onMove={onMoveDebounced}                               dragEnabled={true}                               zoom={zoom}                               responsive={true}                               verticalMargin={42}                               itemWidth={230}                               itemHeight={409}/>, document.getElementById(Demo));  };
  var renderDebounced = _.debounce(render, 150);
  Update the zoom value  var onZoom = function(event){    zoom = parseFloat(event.target.value);    renderDebounced();  };
  ReactDOM.render(<input onChange={onZoom} type=range min=0.3 max=1.5 step=0.1 defaultValue={zoom}/>, document.getElementById(Zoom));  ReactDOM.render(<input placeholder=Filter eg: calendar onChange={onFilter} type=text/>, document.getElementById(Filter));  ReactDOM.render(<button onClick={unMountTest}>Test Unmount</button>, document.getElementById(UnmountButton));  render();}"
" Stupid jQuery table plugin.
(function($) {  $.fn.stupidtable = function(sortFns) {    return this.each(function() {      var $table = $(this);      sortFns = sortFns || {};      sortFns = $.extend({}, $.fn.stupidtable.default_sort_fns, sortFns);      $table.data(sortFns, sortFns);
      $table.on(click.stupidtable, thead th, function() {          $(this).stupidsort();      });    });  };

   Expects $(""#mytable"").stupidtable() to have already been called.   Call on a table header.  $.fn.stupidsort = function(force_direction){    var $this_th = $(this);    var th_index = 0;  we'll increment this soon    var dir = $.fn.stupidtable.dir;    var $table = $this_th.closest(table);    var datatype = $this_th.data(sort) || null;
     No datatype? Nothing to do.    if (datatype === null) {      return;    }
     Account for colspans    $this_th.parents(tr).find(th).slice(0, $(this).index()).each(function() {      var cols = $(this).attr(colspan) || 1;      th_index += parseInt(cols,10);    });
    var sort_dir;    if(arguments.length == 1){        sort_dir = force_direction;    }    else{        sort_dir = force_direction || $this_th.data(sort-default) || dir.ASC;        if ($this_th.data(sort-dir))           sort_dir = $this_th.data(sort-dir) === dir.ASC ? dir.DESC : dir.ASC;    }
     Bail if already sorted in this direction    if ($this_th.data(sort-dir) === sort_dir) {      return;    }     Go ahead and set sort-dir.  If immediately subsequent calls have same sort-dir they will bail    $this_th.data(sort-dir, sort_dir);
    $table.trigger(beforetablesort, {column: th_index, direction: sort_dir});
     More reliable method of forcing a redraw    $table.css(display);
     Run sorting asynchronously on a timout to force browser redraw after     `beforetablesort` callback. Also avoids locking up the browser too much.    setTimeout(function() {       Gather the elements for this column      var column = [];      var sortFns = $table.data(sortFns);      var sortMethod = sortFns[datatype];      var trs = $table.children(tbody).children(tr);
       Extract the data for the column that needs to be sorted and pair it up       with the TR itself into a tuple. This way sorting the values will       incidentally sort the trs.      trs.each(function(index,tr) {        var $e = $(tr).children().eq(th_index);        var sort_val = $e.data(sort-value);
         Store and read from the .data cache for display text only sorts         instead of looking through the DOM every time        if(typeof(sort_val) === undefined){          var txt = $e.text();          $e.data(sort-value, txt);          sort_val = txt;        }        column.push([sort_val, tr]);      });
       Sort by the data-order-by value      column.sort(function(a, b) { return sortMethod(a[0], b[0]); });      if (sort_dir != dir.ASC)        column.reverse();
       Replace the content of tbody with the sorted rows. Strangely       enough, .append accomplishes this for us.      trs = $.map(column, function(kv) { return kv[1]; });      $table.children(tbody).append(trs);
       Reset siblings      $table.find(th).data(sort-dir, null).removeClass(sorting-desc sorting-asc);      $this_th.data(sort-dir, sort_dir).addClass(sorting-+sort_dir);
      $table.trigger(aftertablesort, {column: th_index, direction: sort_dir});      $table.css(display);    }, 10);
    return $this_th;  };
   Call on a sortable td to update its value in the sort. This should be the   only mechanism used to update a cell's sort value. If your display value is   different from your sort value, use jQuery's .text() or .html() to update   the td contents, Assumes stupidtable has already been called for the table.  $.fn.updateSortVal = function(new_sort_val){  var $this_td = $(this);    if($this_td.is([data-sort-value])){       For visual consistency with the .data cache      $this_td.attr(data-sort-value, new_sort_val);    }    $this_td.data(sort-value, new_sort_val);    return $this_td;  };
   ------------------------------------------------------------------   Default settings   ------------------------------------------------------------------  $.fn.stupidtable.dir = {ASC: asc, DESC: desc};  $.fn.stupidtable.default_sort_fns = {    : function(a, b) {      return parseInt(a, 10) - parseInt(b, 10);    },    : function(a, b) {      return parseFloat(a) - parseFloat(b);    },    : function(a, b) {      return a.toString().localeCompare(b.toString());    },    : function(a, b) {      a = a.toString().toLocaleLowerCase();      b = b.toString().toLocaleLowerCase();      return a.localeCompare(b);    }  };})(jQuery);"
"var ulid = require(./)
suite(ulid, function() {
  set(iterations, 100000);
  bench(encodeTime, function() {    ulid.encodeTime()  })
  bench(encodeRandom, function() {    ulid.encodeRandom()  })
  bench(generate, function() {    ulid()  })
})"
"use strict;
function factory(prng) {
   Crockford's Base32   https://en.wikipedia.org/wiki/Base32  var ENCODING = 0123456789ABCDEFGHJKMNPQRSTVWXYZ  var ENCODING_LEN = ENCODING.length  var TIME_MAX = 281474976710655  var TIME_LEN = 10  var RANDOM_LEN = 16
  function encodeTime(time, len) {    if (time > TIME_MAX) {      throw new Error(cannot encode time greater than  + TIME_MAX)    }    var mod    var time    var str =     for (var x = len; x > 0; x--) {      mod = time % ENCODING_LEN      str = ENCODING.charAt(mod) + str      time = (time - mod) / ENCODING_LEN    }    return str  }
  function encodeRandom(len) {    var rand    var str =     for (var x = 0; x < len; x++) {      rand = Math.floor(ENCODING_LEN * prng())      str = ENCODING.charAt(rand) + str    }    return str  }
  function ulid(seedTime) {    if(!seedTime) {      seedTime = Date.now();    } else if(isNaN(seedTime) || typeof seedTime !== number) {      throw new Error(seedTime +  must be a number);    }        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN)  }
  ulid.prng = prng  ulid.encodeTime = encodeTime  ulid.encodeRandom = encodeRandom
  return ulid
}
/* istanbul ignore next */function _prng(root) {
  if (root) {    try {      var crypto = root.crypto || root.msCrypto      return function() {        return crypto.getRandomValues(new Uint16Array(1))[0] / 0xFFFF      }    }    catch (e) {}  }  else {    try {      var crypto = require(crypto)      return function() {        return crypto.randomBytes(2).readUInt16LE() / 0xFFFF      }    }    catch (e) {}  }
  if (typeof prng !== function) {    if (typeof console !== undefined && console.warn) {      console.warn([ulid] crypto not usable, falling back to insecure Math.random());    }    return function() {      return Math.random()    }  }
}
/* istanbul ignore next */(function(root, fn) {
  var prng = _prng(root)  var ulid = fn(prng)
  if ((undefined !== typeof module) && module.exports) {    module.exports = ulid  }  else if (typeof define === function && define.amd) {    define(function() {      return ulid    })  }  else {    root.ulid = ulid  }
})(typeof window !== undefined ? window : null, factory)"
"use strict;
import React from react;import {  AppRegistry,} from react-native;
import Root from ./App/Root;AppRegistry.registerComponent(Sample, () => Root);"
"/** * Created by lijun on 2016/12/14. */var config = require(./webpack.config.js)
config.entry = {  table-dragger: ./src/index.js,}
config.output = {  filename: ./dist/[name].js,  library: tableDragger,  libraryTarget: umd}
module.exports = config"
"module.exports = {  root: true,  parser: babel-eslint,  parserOptions: {    sourceType: module  },  extends: airbnb-base,  env: {    browser: true,    node: true  },  plugins: [    html  ],   add your custom rules here  rules: {    no-use-before-define: [error, { functions: false, classes: false }],    import/extensions: [error, always, {      js: never,      vue: never    }],    no-nested-ternary: 0,    space-before-function-paren: 0,    no-underscore-dangle: [error, { allowAfterThis: true }],     allow debugger during development    no-debugger: process.env.NODE_ENV === production ? 2 : 0  }}"
"/*! * Muuri v0.2.0 * https://github.com/haltu/muuri * Copyright (c) 2015, Haltu Oy * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the ""Software""), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */
(function (global, factory) {
  var libName = Muuri;  var depVelocity = typeof jQuery === function ? jQuery.Velocity : global.Velocity;  var depHammer = global.Hammer;
  global[libName] = factory(global, depVelocity, depHammer);
}(this, function (global, Velocity, Hammer, undefined) {
  use strict;
   Document body needs to be ready for tests.  if (!document.body) {    throw Error(Muuri needs access to document.body to work.);  }
  var uuid = 0;  var noop = function () {};  var raf = typeof global.requestAnimationFrame === function ? global.requestAnimationFrame : null;
   Event names.  var evRefresh = refresh;  var evSynchronize = synchronize;  var evLayoutStart = layoutstart;  var evLayoutEnd = layoutend;  var evShowStart = showstart;  var evShowEnd = showend;  var evHideStart = hidestart;  var evHideEnd = hideend;  var evMove = move;  var evSwap = swap;  var evAdd = add;  var evRemove = remove;  var evDragStart = dragstart;  var evDragMove = dragmove;  var evDragScroll = dragscroll;  var evDragEnd = dragend;  var evReleaseStart = releasestart;  var evReleaseEnd = releaseend;  var evDestroy = destroy;
   Get the primary supported transform property.  var supportedTransform = (function () {    var all = [transform, WebkitTransform, MozTransform, OTransform, msTransform];    for (var i = 0; i < all.length; i++) {      if (document.documentElement.style[all[i]] !== undefined) {        var prop = all[i];        var prefix = prop.toLowerCase().split(transform)[0];        return {          prefix: prefix,          prop: prop,          style: prefix ? - + prefix + -transform : prop        };      }    }    return null;  })();
   Detect if current browser positions fixed elements relative to the nearest   ancestor transformed element instead of the window.   https://bugs.chromium.org/p/chromium/issues/detail?id=20574     Borrowed from Mezr library:   https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L95-L113   https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L247-L300  var hasBrokenW3CTELCS = (function () {
     If the browser does not support transforms we can deduct that the     W3C TELCS is broken (non-existent).    if (!supportedTransform) {      return true;    }
    var body = document.body;    var outer = document.createElement(div);    var inner = document.createElement(div);    var leftUntransformed;    var leftTransformed;
    setStyles(outer, {      display: block,      visibility: hidden,      position: absolute,      width: 1px,      height: 1px,      left: 1px,      top: 0,      margin: 0    });
    setStyles(inner, {      display: block,      position: fixed,      width: 1px,      height: 1px,      left: 0,      top: 0,      margin: 0    });
    outer.appendChild(inner);    body.appendChild(outer);    leftUntransformed = inner.getBoundingClientRect().left;    outer.style[supportedTransform.prop] = translateZ(0);    leftTransformed = inner.getBoundingClientRect().left;    body.removeChild(outer);
    return leftTransformed === leftUntransformed;
  })();
  /**   * Emitter   * *******   */
  /**   * Event emitter constructor.   *   * This is a simplified version of jvent.js event emitter library:   * https://github.com/pazguille/jvent/blob/0.2.0/dist/jvent.js   *   *    */  function Emitter() {}
  /**   * Bind an event listener.   *   *    *     *      *      *   returns the Emitter instance.   */  Emitter.prototype.on = function (event, listener) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    listeners[listeners.length] = listener;    events[event] = listeners;
    return this;
  };
  /**   * Unbind all event listeners that match the provided listener function.   *   *    *     *      *      *   returns the Emitter instance.   */  Emitter.prototype.off = function (event, listener) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    var counter = listeners.length;
    if (counter) {      while (counter--) {        if (listener === listeners[i]) {          listeners.splice(counter, 1);        }      }    }
    return this;
  };
  /**   * Emit all listeners in a specified event with the provided arguments.   *   *    *     *      *      *      *      *   returns the Emitter instance.   */  Emitter.prototype.emit = function (event, arg1, arg2, arg3) {
    var events = this._events = this._events || {};    var listeners = events[event] || [];    var listenersLength = listeners.length;
    if (listenersLength) {
      var argsLength = arguments.length - 1;      listeners = listeners.concat();
      for (var i = 0; i < listenersLength; i++) {        argsLength === 0 ? listeners[i]() :        argsLength === 1 ? listeners[i](arg1) :        argsLength === 2 ? listeners[i](arg1, arg2) :                           listeners[i](arg1, arg2, arg3);      }
    }
    return this;
  };
  /**   * LayoutFirstFit v0.2.0   * Copyright (c) 2016 Niklas Rämö <inramo@gmail.com>   * Released under the MIT license   *   * The default Muuri layout method.   *   *    *      */  function LayoutFirstFit(settings) {
    var layout = this;
     Empty slots data.    var emptySlots = [];
     Normalize settings.    var fillGaps = settings.fillGaps ? true : false;    var isHorizontal = settings.horizontal ? true : false;    var alignRight = settings.alignRight ? true : false;    var alignBottom = settings.alignBottom ? true : false;
     Round container width and height.    layout.width = Math.round(layout.width);    layout.height = Math.round(layout.height);
     Set horizontal/vertical mode.    if (isHorizontal) {      layout.setWidth = true;      layout.width = 0;    }    else {      layout.setHeight = true;      layout.height = 0;    }
     No need to go further if items do not exist.    if (!layout.items.length) {      return;    }
     Find slots for items.    for (var i = 0; i < layout.items.length; i++) {
      var item = layout.items[i];      var slot = LayoutFirstFit.getSlot(layout, emptySlots, item._width, item._height, !isHorizontal, fillGaps);
       Update layout height.      if (isHorizontal) {        layout.width = Math.max(layout.width, slot.left + slot.width);      }      else {        layout.height = Math.max(layout.height, slot.top + slot.height);      }
       Add slot to slots data.      layout.slots[item._id] = slot;
    }
     If the alignment is set to right or bottom, we need to adjust the     results.    if (alignRight || alignBottom) {      for (var id in layout.slots) {        var slot = layout.slots[id];        if (alignRight) {          slot.left = layout.width - (slot.left + slot.width);        }        if (alignBottom) {          slot.top = layout.height - (slot.top + slot.height);        }      }    }
  }
  /**   * Calculate position for the layout item. Returns the left and top position   * of the item in pixels.   *   *    *     *      *      *      *      *      *      *     */  LayoutFirstFit.getSlot = function (layout, slots, itemWidth, itemHeight, vertical, fillGaps) {
    var currentSlots = slots[0] || [];    var newSlots = [];    var item = {      left: null,      top: null,      width: itemWidth,      height: itemHeight    };    var i;    var ii;    var slot;    var potentialSlots;    var ignoreCurrentSlots;
     Try to find a slot for the item.    for (i = 0; i < currentSlots.length; i++) {      slot = currentSlots[i];      if (item.width <= slot.width && item.height <= slot.height) {        item.left = slot.left;        item.top = slot.top;        break;      }    }
     If no slot was found for the item.    if (item.left === null) {
       Position the item in to the bottom left (vertical mode) or top right       (horizontal mode) of the grid.      item.left = vertical ? 0 : layout.width;      item.top = vertical ? layout.height : 0;
       If gaps don't needs filling do not add any current slots to the new       slots array.      if (!fillGaps) {        ignoreCurrentSlots = true;      }
    }
     In vertical mode, if the item's bottom overlaps the grid's bottom.    if (vertical && (item.top + item.height) > layout.height) {
       If item is not aligned to the left edge, create a new slot.      if (item.left > 0) {        newSlots[newSlots.length] = {          left: 0,          top: layout.height,          width: item.left,          height: Infinity        };      }
       If item is not aligned to the right edge, create a new slot.      if ((item.left + item.width) < layout.width) {        newSlots[newSlots.length] = {          left: item.left + item.width,          top: layout.height,          width: layout.width - item.left - item.width,          height: Infinity        };      }
       Update grid height.      layout.height = item.top + item.height;
    }
     In horizontal mode, if the item's right overlaps the grid's right edge.    if (!vertical && (item.left + item.width) > layout.width) {
       If item is not aligned to the top, create a new slot.      if (item.top > 0) {        newSlots[newSlots.length] = {          left: layout.width,          top: 0,          width: Infinity,          height: item.top        };      }
       If item is not aligned to the bottom, create a new slot.      if ((item.top + item.height) < layout.height) {        newSlots[newSlots.length] = {          left: layout.width,          top: item.top + item.height,          width: Infinity,          height: layout.height - item.top - item.height        };      }
       Update grid width.      layout.width = item.left + item.width;
    }
     Clean up the current slots making sure there are no old slots that     overlap with the item. If an old slot overlaps with the item, split it     into smaller slots if necessary.    for (i = fillGaps ? 0 : ignoreCurrentSlots ? currentSlots.length : i; i < currentSlots.length; i++) {      potentialSlots = LayoutFirstFit.splitRect(currentSlots[i], item);      for (ii = 0; ii < potentialSlots.length; ii++) {        slot = potentialSlots[ii];        if (slot.width > 0 && slot.height > 0 && ((vertical && slot.top < layout.height) || (!vertical && slot.left < layout.width))) {          newSlots[newSlots.length] = slot;        }      }    }
     Remove redundant slots and sort the new slots.    LayoutFirstFit.purgeSlots(newSlots).sort(vertical ? LayoutFirstFit.sortRectsTopLeft : LayoutFirstFit.sortRectsLeftTop);
     Update the slots data.    slots[0] = newSlots;
     Return the item.    return item;
  };
  /**   * Sort rectangles with top-left gravity. Assumes that objects with   * properties left, top, width and height are being sorted.   *   *    *     *      *      *     */  LayoutFirstFit.sortRectsTopLeft = function (a, b) {
    return a.top < b.top ? -1 : (a.top > b.top ? 1 : (a.left < b.left ? -1 : (a.left > b.left ? 1 : 0)));
  };
  /**   * Sort rectangles with left-top gravity. Assumes that objects with   * properties left, top, width and height are being sorted.   *   *    *     *      *      *     */  LayoutFirstFit.sortRectsLeftTop = function (a, b) {
    return a.left < b.left ? -1 : (a.left > b.left ? 1 : (a.top < b.top ? -1 : (a.top > b.top ? 1 : 0)));
  };
  /**   * Check if a rectabgle is fully within another rectangle. Assumes that the   * rectangle object has the following properties: left, top, width and height.   *   *    *     *      *      *     */  LayoutFirstFit.isRectWithinRect = function (a, b) {
    return a.left >= b.left && a.top >= b.top && (a.left + a.width) <= (b.left + b.width) && (a.top + a.height) <= (b.top + b.height);
  };
  /**   * Loops through an array of slots and removes all slots that are fully within   * another slot in the array.   *   *    *     *      */  LayoutFirstFit.purgeSlots = function (slots) {
    var i = slots.length;    while (i--) {      var slotA = slots[i];      var ii = slots.length;      while (ii--) {        var slotB = slots[ii];        if (i !== ii && LayoutFirstFit.isRectWithinRect(slotA, slotB)) {          slots.splice(i, 1);          break;        }      }    }
    return slots;
  };
  /**   * Compares a rectangle to another and splits it to smaller pieces (the parts   * that exceed the other rectangles edges). At maximum generates four smaller   * rectangles.   *   *    *     *      *      * returns {Array}   */  LayoutFirstFit.splitRect = function (a, b) {
    var ret = [];    var overlap = !(b.left > (a.left + a.width) || (b.left + b.width) < a.left || b.top > (a.top + a.height) || (b.top + b.height) < a.top);
     If rect a does not overlap with rect b add rect a to the return data as     is.    if (!overlap) {
      ret[0] = a;
    }     If rect a overlaps with rect b split rect a into smaller rectangles and     add them to the return data.    else {
       Left split.      if (a.left < b.left) {        ret[ret.length] = {          left: a.left,          top: a.top,          width: b.left - a.left,          height: a.height        };      }
       Right split.      if ((a.left + a.width) > (b.left + b.width)) {        ret[ret.length] = {          left: b.left + b.width,          top: a.top,          width: (a.left + a.width) - (b.left + b.width),          height: a.height        };      }
       Top split.      if (a.top < b.top) {        ret[ret.length] = {          left: a.left,          top: a.top,          width: a.width,          height: b.top - a.top        };      }
       Bottom split.      if ((a.top + a.height) > (b.top + b.height)) {        ret[ret.length] = {          left: a.left,          top: b.top + b.height,          width: a.width,          height: (a.top + a.height) - (b.top + b.height)        };      }
    }
    return ret;
  };
  /**   * Muuri   * *****   */
  /**   * Creates a new Muuri instance.   *   *    *    *      *   *    *    *      *      *    */  function Muuri(settings) {
    var inst = this;
     Merge user settings with default settings.    var stn = inst._settings = mergeObjects({}, Muuri.defaultSettings, settings || {});
     Make sure a valid container element is provided before going continuing.    if (!document.body.contains(stn.container)) {      throw new Error(Container must be an existing DOM element);    }
     Setup container element.    inst._element = stn.container;    addClass(stn.container, stn.containerClass);
     Instance id.    inst._id = ++uuid;
     Unique animation queue name.    inst._animQueue = muuri- + inst._id;
     Create private eventize instance.    inst._emitter = new Emitter();
     Setup show and hide animations for items.    inst._itemShow = typeof stn.show === function ? stn.show() : showHideAnimation(stn.show, true);    inst._itemHide = typeof stn.hide === function ? stn.hide() : showHideAnimation(stn.hide);
     Setup initial items.    inst._items = [];    for (var i = 0, len = stn.items.length; i < len; i++) {      inst._items[inst._items.length] = new Muuri.Item(inst, stn.items[i]);    }
     Relayout on window resize if enabled.    if (stn.layoutOnResize || stn.layoutOnResize === 0) {      var debounced = debounce(function () {        inst.refresh();        inst.layout();      }, stn.layoutOnResize);      inst._resizeHandler = function () {        debounced();      };      global.addEventListener(resize, inst._resizeHandler);    }
     Layout on init if enabled.    if (stn.layoutOnInit) {      inst.layout(true);    }
  }
  /**   * Get instance's item by element or by index. Target can also be a   * Muuri item instance in which case the function returns the item if it   * exists within related Muuri instance. If nothing is found with the   * provided target null is returned.   *   *    *     *      *     */  Muuri.prototype._getItem = function (target) {
    if (!target) {
      return this._items[0] || null;
    }    else if (target instanceof Muuri.Item) {
      return target._muuri === this ? target : null;
    }    else if (typeof target === number) {
      target = target > -1 ? target : this._items.length + target;      return this._items[target] || null;
    }    else {
      var ret = null;      for (var i = 0, len = this._items.length; i < len; i++) {        var item = this._items[i];        if (item._element === target) {          ret = item;          break;        }      }      return ret;
    }
  };
  /**   * Bind an event listener.   *   *    *     *      *      *   returns the Muuri instance.   */  Muuri.prototype.on = function (event, listener) {
    this._emitter.on(event, listener);    return this;
  };
  /**   * Unbind an event listener.   *   *    *     *      *      *   returns the Muuri instance.   */  Muuri.prototype.off = function (event, listener) {
    this._emitter.off(event, listener);    return this;
  };
  /**   * Recalculate the width and height of the provided targets. If no targets are   * provided all active items will be refreshed.   *   *    *     *      */  Muuri.prototype.refresh = function (items) {
     Get items.    items = items ? this.get(items) : this.get(active);
     Refresh dimensions.    for (var i = 0, len = items.length; i < len; i++) {      items[i]._refresh();    }
     Emit refresh event.    this._emitter.emit(evRefresh, items);
  };
  /**   * Get all items. Optionally you can provide specific targets (indices or   * elements) and filter the results by the items' state (active/inactive).   * Note that the returned array is not the same object used by the instance so   * modifying it will not affect instance's items. All items that are not found   * are omitted from the returned array.   *   *    *     *      *      *   Array of Muuri item instances.   */  Muuri.prototype.get = function (targets, state) {
    var hasTargets = targets && typeof targets !== string;
    state = !hasTargets ? targets : state;    state = typeof state === string ? state : null;    targets = hasTargets ? [].concat(targets) : null;
    if (state || targets) {
      var items = targets || this._items;      var ret = [];      var isActive = state === active;      var isInactive = state === inactive;
      for (var i = 0, len = items.length; i < len; i++) {        var item = hasTargets ? this._getItem(items[i]) : items[i];        if (item && (!state || (isActive && item._active) || (isInactive && !item._active))) {          ret[ret.length] = item;        }      }
      return ret;
    }    else {
      return this._items.concat();
    }
  };
  /**   * Add new items by providing the elements you wish to add to the instance and   * optionally provide the index where you want the items to be inserted into.   * All elements that are not already children of the container element will be   * automatically appended to the container. If an element has it's CSS display   * property set to none it will be marked as inactive during the initiation   * process. As long as the item is inactive it will not be part of the layout,   * but it will retain it's index. You can activate items at any point   * with muuri.show() method. This method will automatically call   * muuri.layout() if one or more of the added elements are visible. If only   * hidden items are added no layout will be called. All the new visible items   * are positioned without animation during their first layout.   *   *    *     *      *      *     */  Muuri.prototype.add = function (elements, index) {
    var newItems = [];    var needsRelayout = false;
     Make sure elements is an array.    elements = [].concat(elements);
     Filter out all elements that exist already in current instance.    for (var i = 0, len = this._items.length; i < len; i++) {      var item = this._items[i];      var index = elements.indexOf(item._element);      if (index > -1) {        elements.splice(index, 1);      }    }
     Return early if there are no valid items.    if (!elements.length) {      return newItems;    }
     Create new items.    for (var i = 0, len = elements.length; i < len; i++) {      var item = new Muuri.Item(this, elements[i]);      newItems[newItems.length] = item;      if (item._active) {        needsRelayout = true;        item._noLayoutAnimation = true;      }    }
     Normalize the index for the splice apply hackery so that value of -1     prepends the new items to the current items.    index = index < 0 ? this._items.length - index + 1 : index;
     Add the new items to the items collection to correct index.    this._items.splice.apply(this._items, [index, 0].concat(newItems));
     If relayout is needed.    if (needsRelayout) {      this.layout();    }
     Emit add event.    this._emitter.emit(evAdd, newItems);
     Return new items    return newItems;
  };
  /**   * Remove items from muuri instances.   *   *    *     *      *      *   The indices of removed items.   */  Muuri.prototype.remove = function (items, removeElement) {
    var indices = [];    var needsRelayout = false;
    items = this.get(items);
    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
       Check it refresh is needed.      if (item._active) {        needsRelayout = true;      }
       Remove item.      indices[indices.length] = item._destroy(removeElement);
    }
     If relayout is needed.    if (needsRelayout) {      this.layout();    }
    this._emitter.emit(evRemove, indices);
    return indices;
  };
  /**   * Order the item elements to match the order of the items. If the item's   * element is not a child of the container it is ignored and left untouched.   * This comes handy if you need to keep the DOM structure matched with the   * order of the items.   *   *    *     */  Muuri.prototype.synchronize = function () {
    for (var i = 0, len = this._items.length; i < len; i++) {      var item = this._items[i];      if (item._element.parentNode === this._element) {        this._element.appendChild(item._element);      }    }
    this._emitter.emit(evSynchronize);
  };
  /**   * Calculate and apply Muuri instance's item positions.   *   *    *     *      *      */  Muuri.prototype.layout = function (instant, callback) {
    var inst = this;    var emitter = inst._emitter;    var callback = typeof instant === function ? instant : callback;    var isInstant = instant === true;    var layout = new Muuri.Layout(inst);    var counter = -1;    var itemsLength = layout.items.length;    var completed = [];    var tryFinish = function (interrupted, item) {
       Push all items to the completed items array which were not interrupted.      if (!interrupted) {        completed[completed.length] = item;      }
       If container and all items have finished their animations (if any).      if (++counter === itemsLength) {
         Call callback.        if (typeof callback === function) {          callback(completed, layout);        }
         Emit layoutend event.        emitter.emit(evLayoutEnd, completed, layout);
      }
    };
     Emit layoutstart event.    emitter.emit(evLayoutStart, layout.items, layout);
     Set container's height if needed.    if (layout.setHeight) {      setStyles(inst._element, {        height: layout.height + px      });    }
     Set container's width if needed.    if (layout.setWidth) {      setStyles(inst._element, {        width: layout.width + px      });    }
     If there are now items let's finish quickly.    if (!itemsLength) {
      tryFinish(true);
    }     If there are items let's position them.    else {
      for (var i = 0, len = layout.items.length; i < len; i++) {
        var item = layout.items[i];        var pos = layout.slots[item._id];
         Update item's position.        item._left = pos.left;        item._top = pos.top;
         Layout non-dragged items.        item._drag.active ? tryFinish(false, item) : item._layout(isInstant, tryFinish);
      }
    }
  };
  /**   * Show instance items.   *   *    *     *      *      *      */  Muuri.prototype.show = function (items, instant, callback) {
    showHideHandler(this, show, items, instant, callback);
  };
  /**   * Hide instance items.   *   *    *     *      *      *      */  Muuri.prototype.hide = function (items, instant, callback) {
    showHideHandler(this, hide, items, instant, callback);
  };
  /**   * Get item's index.   *   *    *     *      *     */  Muuri.prototype.indexOf = function (item) {
    if (typeof item === number) {
      return item <= (this._items.length - 1) ? item : null;
    }    else if (item instanceof Muuri.Item) {
      var index = this._items.indexOf(item);      return index > -1 ? index : null;
    }    else {
      var index = null;      for (var i = 0, len = this._items.length; i < len; i++) {        if (this._items[i]._element === item) {          index = i;          break;        }      }      return index;
    }
  };
  /**   * Move item to another index or in place of another item.   *   *    *     *      *      */  Muuri.prototype.move = function (targetFrom, targetTo) {
    targetFrom = this._getItem(targetFrom);    targetTo = this._getItem(targetTo);
    if (targetFrom && targetTo && (targetFrom !== targetTo)) {      arrayMove(this._items, this._items.indexOf(targetFrom), this._items.indexOf(targetTo));      this._emitter.emit(evMove, targetFrom, targetTo);    }
  };
  /**   * Swap positions of two items.   *   *    *     *      *      */  Muuri.prototype.swap = function (targetA, targetB) {
    targetA = this._getItem(targetA);    targetB = this._getItem(targetB);
    if (targetA && targetB && (targetA !== targetB)) {      arraySwap(this._items, this._items.indexOf(targetA), this._items.indexOf(targetB));      this._emitter.emit(evSwap, targetA, targetB);    }
  };
  /**   * Destroy the instance.   *   *    *     */  Muuri.prototype.destroy = function () {
     Unbind window resize event listener.    if (this._resizeHandler) {      global.removeEventListener(resize, this._resizeHandler);    }
     Destroy items.    var items = this._items.concat();    for (var i = 0, len = items.length; i < len; i++) {      items[i]._destroy();    }
     Restore container.    removeClass(this._element, this._settings.containerClass);    setStyles(this._element, {      height:     });
     Emit destroy event.    this._emitter.emit(evDestroy);
     Remove all event listeners.    var events = this._emitter._events;    if (events) {      var eventNames = Object.keys(this._emitter._events);      for (var i = 0, len = eventNames.length; i < len; i++) {        events[eventNames[i]].length = 0;      }    }
     Render the instance unusable -> nullify all Muuri related properties.    var props = Object.keys(this).concat(Object.keys(Muuri.prototype));    for (var i = 0; i < props.length; i++) {      this[props[i]] = null;    }
  };
  /**   * Muuri - Item   * ************   */
  /**   * Creates a new Muuri Item instance.   *   *    *    *     *      *      */  Muuri.Item = function (muuri, element) {
     Make sure the item element is not a parent of the grid container element.    if (element.contains(muuri._element)) {      throw new Error(Item element must not be a parent of the grid container element);    }
     If the provided item element is not a direct child of the grid container     element, append it to the grid container.    if (element.parentNode !== muuri._element) {      muuri._element.appendChild(element);    }
    var stn = muuri._settings;    var isHidden = getStyle(element, display) === none;
     Instance id.    this._id = ++uuid;    this._muuri = muuri;    this._element = element;    this._child = element.children[0];
     Set item class.    addClass(element, stn.itemClass);
     Set up active state (defines if the item is considered part of the layout     or not).    this._active = isHidden ? false : true;
     Set up positioning state (defines if the item is currently animating     it's position).    this._positioning = false;
     Set up visibility states.    this._hidden = isHidden;    this._hiding = false;    this._showing = false;
     Visibility animation callback queue. Whenever a callback is provided for     show/hide methods and animation is enabled the callback is stored     temporarily to this array. The callbacks are called with the first     argument as false if the animation succeeded without interruptions and     with the first argument as true if the animation was interrupted.    this._visibiliyQueue = [];
     Layout animation callback queue. Whenever a callback is provided for     layout method and animation is enabled the callback is stored temporarily     to this array. The callbacks are called with the first argument as false     if the animation succeeded without interruptions and with the first     argument as true if the animation was interrupted.    this._layoutQueue = [];
     Set element's initial position.    hookStyles(this._element, {      left: 0,      top: 0,      translateX: 0px,      translateY: 0px    });
     Set hidden/shown class.    addClass(element, isHidden ? stn.hiddenClass : stn.shownClass);
     Set hidden/shown styles for the child element.    hookStyles(this._child, {      scale: isHidden ? 0 : 1,      opacity: isHidden ? 0 : 1    });
     Enforce display ""block"" if element is visible.    if (!isHidden) {      setStyles(this._element, {        display: block      });    }
     Set up initial dimensions and positions.    this._refresh();    this._left = 0;    this._top = 0;
     Set up drag & drop.    this._drag = {active: false};    this._release = {active: false};    if (muuri._settings.dragEnabled) {      this._initDrag();    }
  };
  /**   * Inspect instance's data.   *   *    *     */  Muuri.Item.prototype.inspect = function () {
    return {      element: this._element,      width: this._width,      height: this._height,      left: this._left,      top: this._top,      active: this._active,      positioning: this._positioning,      dragging: this._drag.active,      releasing: this._release.active,      visibility: this._hiding  ? hiding : this._showing ? showing : this._hidden  ? hidden : shown    };
  };
  /**   * Make the item draggable with Hammer.js.   *   *    *     */  Muuri.Item.prototype._initDrag = function () {
    var inst = this;    var stn = inst._muuri._settings;
     Initiate Hammer.    var hammer = inst._hammer = new Hammer.Manager(inst._element);
     Add drag recognizer to hammer.    hammer.add(new Hammer.Pan({      event: drag,      pointers: 1,      threshold: 0,      direction: Hammer.DIRECTION_ALL    }));
     Add draginit recognizer to hammer.    hammer.add(new Hammer.Press({      event: draginit,      pointers: 1,      threshold: 100,      time: 0    }));
     This is not ideal, but saves us from a LOT of hacks. Let's try to keep     the default drag setup consistent across devices.    hammer.set({ touchAction: none });
     Setup initial release data.    inst._resetReleaseData();
     Setup initial drag data.    var drag = inst._drag;    inst._resetDragData();
     Add overlap checker function to drag data.    drag.checkOverlap = debounce(function () {      if (drag.active) {        inst._checkOverlap();      }    }, stn.dragSortInterval);
     Add predicate related data to drag data.    var predicateResolved = false;    drag.predicate = typeof stn.dragPredicate === function ? stn.dragPredicate : dragPredicate;    drag.predicateData = {};    drag.isPredicateResolved = function () {      return predicateResolved;    };    drag.resolvePredicate = function (e) {      if (!predicateResolved && e.type !== draginitup && e.type !== dragend && e.type !== dragcancel) {        predicateResolved = true;        inst._onDragStart(e);      }    };
     Add drag sroll handler.    drag.onScroll = function (e) {      if (raf) {        raf(function () {          inst._onDragScroll(e);        });      }      else {        inst._onDragScroll(e);      }    };
     Bind drag events.    hammer    .on(draginit, function (e) {      drag.predicateData = {};      predicateResolved = false;      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    })    .on(dragstart dragmove, function (e) {      if (predicateResolved && drag.active) {        inst._onDragMove(e);      }      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    })    .on(dragend dragcancel draginitup, function (e) {      if (predicateResolved && drag.active) {        inst._onDragEnd(e);      }      drag.predicate.call(drag.predicateData, e, inst, drag.resolvePredicate);    });
  };
  /**   * Reset drag data.   *   *    *     */  Muuri.Item.prototype._resetDragData = function () {
    var drag = this._drag;
     Is the drag active or not?    drag.active = false;
     Hammer dragstart/dragend event data.    drag.start = null;    drag.move = null;
     The element that is currently dragged (instance element or it's clone).    drag.element = null;
     The curently dragged element's width and height.    drag.elemWidth = 0;    drag.elemHeight = 0;
     Dragged element's inline styles stored for graceful teardown.    drag.elementStyles = null;
     Scroll parents of the dragged element and muuri container.    drag.scrollParents = [];
     The current translateX/translateY position.    drag.left = 0;    drag.top = 0;
     Dragged element's current position within the grid.    drag.gridX = 0;    drag.gridY = 0;
     Dragged element's current offset from window's northwest corner. Does not     account for element's margins.    drag.elemClientX = 0;    drag.elemClientY = 0;
     Offset difference between the dragged element's temporary drag container     and it's original container.    drag.containerDiffX = 0;    drag.containerDiffY = 0;
  };
  /**   * Drag start handler.   *   *    *     */  Muuri.Item.prototype._onDragStart = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;    var isReleased = this._release.active;
     If item is not active, don't start the drag.    if (!this._active) {      return;    }
     Stop current positioning animation.    if (this._positioning) {      this._stopLayout();    }
     If item is being released reset release data, remove release class and     import the current elementStyles to drag object.    if (isReleased) {      drag.elementStyles = this._release.elementStyles;      removeClass(this._element, stn.releasingClass);      this._resetReleaseData();    }
     Setup drag data.    drag.active = true;    drag.start = e;    drag.move = e;    drag.element = this._element;    drag.elemWidth = this._width;    drag.elemHeight = this._height;
     Get element's current position.    var currentLeft = parseFloat(Velocity.hook(drag.element, translateX)) || 0;    var currentTop = parseFloat(Velocity.hook(drag.element, translateY)) || 0;
     Get container references.    var muuriContainer = this._muuri._element;    var dragContainer = stn.dragContainer;
     Set initial left/top drag value.    drag.left = drag.gridX = currentLeft;    drag.top = drag.gridY = currentTop;
     If a specific drag container is set and it is different from the     default muuri container we need to cast some extra spells.    if (dragContainer && dragContainer !== muuriContainer) {
       If dragged element is already in drag container.      if (drag.element.parentNode === dragContainer) {
         Get offset diff.        var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
         Store the container offset diffs to drag data.        drag.containerDiffX = offsetDiff.left;        drag.containerDiffY = offsetDiff.top;
         Set up relative drag position data.        drag.gridX = currentLeft - drag.containerDiffX;        drag.gridY = currentTop - drag.containerDiffY;
      }
       If dragged element is not within the correct container.      else {
         Lock element's width, height, padding and margin before appending         to the temporary container because otherwise the element might         enlarge or shrink after the append procedure if the some of the         properties are defined in relative sizes.        lockElementSize(drag);
         Append element into correct container.        dragContainer.appendChild(drag.element);
         Get offset diff.        var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
         Store the container offset diffs to drag data.        drag.containerDiffX = offsetDiff.left;        drag.containerDiffY = offsetDiff.top;
         Set up drag position data.        drag.left = currentLeft + drag.containerDiffX;        drag.top = currentTop + drag.containerDiffY;
         Fix position to account for the append procedure.        hookStyles(drag.element, {          translateX: drag.left + px,          translateY: drag.top + px        });
      }
    }
     Get and store element's current offset from window's northwest corner.    var elemGbcr = drag.element.getBoundingClientRect();    drag.elemClientX = elemGbcr.left;    drag.elemClientY = elemGbcr.top;
     Get drag scroll parents.    drag.scrollParents = getScrollParents(drag.element);    if (dragContainer && dragContainer !== muuriContainer) {      drag.scrollParents = arrayUnique(drag.scrollParents.concat(getScrollParents(muuriContainer)));    }
     Bind scroll listeners.    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].addEventListener(scroll, drag.onScroll);    }
     Set drag class.    addClass(drag.element, stn.draggingClass);
     Emit dragstart event.    this._muuri._emitter.emit(evDragStart, this, generateDragEvent(dragstart, e, drag));
  };
  /**   * Drag move handler.   *   *    *     */  Muuri.Item.prototype._onDragMove = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     If item is not active, reset drag.    if (!this._active) {      this._resetDrag();      return;    }
     Get delta difference from last dragmove event.    var xDiff = e.deltaX - drag.move.deltaX;    var yDiff = e.deltaY - drag.move.deltaY;
     Update move event.    drag.move = e;
     Update position data.    drag.left += xDiff;    drag.top += yDiff;    drag.gridX += xDiff;    drag.gridY += yDiff;    drag.elemClientX += xDiff;    drag.elemClientY += yDiff;
     Update element's translateX/Y values.    hookStyles(drag.element, {      translateX: drag.left + px,      translateY: drag.top + px    });
     Overlap handling.    if (stn.dragSort) {      drag.checkOverlap();    }
     Emit item-dragmove event.    this._muuri._emitter.emit(evDragMove, this, generateDragEvent(dragmove, e, drag));
  };
  /**   * Drag scroll handler.   *   *    *     */  Muuri.Item.prototype._onDragScroll = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     Get containers.    var muuriContainer = this._muuri._element;    var dragContainer = stn.dragContainer;
     Get offset diff.    var elemGbcr = drag.element.getBoundingClientRect();    var xDiff = drag.elemClientX - elemGbcr.left;    var yDiff = drag.elemClientY - elemGbcr.top;
     Update container diff.    if (dragContainer && dragContainer !== muuriContainer) {
       Get offset diff.      var offsetDiff = getOffsetDiff(drag.element, muuriContainer);
       Store the container offset diffs to drag data.      drag.containerDiffX = offsetDiff.left;      drag.containerDiffY = offsetDiff.top;
    }
     Update position data.    drag.left += xDiff;    drag.top += yDiff;    drag.gridX = drag.left - drag.containerDiffX;    drag.gridY = drag.top - drag.containerDiffY;
     Update element's translateX/Y values.    hookStyles(drag.element, {      translateX: drag.left + px,      translateY: drag.top + px    });
     Overlap handling.    if (stn.dragSort) {      drag.checkOverlap();    }
     Emit item-dragscroll event.    this._muuri._emitter.emit(evDragScroll, this, generateDragEvent(dragscroll, e, drag));
  };
  /**   * Drag end handler.   *   *    *     */  Muuri.Item.prototype._onDragEnd = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;    var release = this._release;
     If item is not active, reset drag.    if (!this._active) {      this._resetDrag();      return;    }
     Finish currently queued overlap check.    if (stn.dragSort) {      drag.checkOverlap(finish);    }
     Remove scroll listeners    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].removeEventListener(scroll, drag.onScroll);    }
     Remove drag classname from element.    removeClass(drag.element, stn.draggingClass);
     Flag drag as inactive.    drag.active = false;
     Emit item-dragend event.    this._muuri._emitter.emit(evDragEnd, this, generateDragEvent(dragend, e, drag));
     Setup release data.    release.containerDiffX = drag.containerDiffX;    release.containerDiffY = drag.containerDiffY;    release.element = drag.element;    release.elementStyles = drag.elementStyles;
     Reset drag data.    this._resetDragData();
     Start the release process.    this._startRelease();
  };
  /**   * Reset drag data and cancel any ongoing drag activity.   *   *    *     */  Muuri.Item.prototype._resetDrag = function (e) {
    var drag = this._drag;    var stn = this._muuri._settings;
     Remove scroll listeners    for (var i = 0, len = drag.scrollParents.length; i < len; i++) {      drag.scrollParents[i].removeEventListener(scroll, drag.onScroll);    }
     Cancel overlap check.    drag.checkOverlap(cancel);
     Remove draggin class.    removeClass(drag.element, stn.draggingClass);
     Remove dragged element's inline styles.    unlockElementSize(drag);
    this._resetDragData();
  };
  /**   * Reset release data.   *   *    *     */  Muuri.Item.prototype._resetReleaseData = function () {
    var release = this._release;    release.active = false;    release.positioningStarted = false;    release.containerDiffX = 0;    release.containerDiffY = 0;    release.element = null;    release.elementStyles = null;
  };
  /**   * Start the release process of an item.   *   *    *     */  Muuri.Item.prototype._startRelease = function () {
    var stn = this._muuri._settings;    var release = this._release;
     Flag release as active.    release.active = true;
     Add release classname to released element.    addClass(release.element, stn.releasingClass);
     Emit releasestart event.    this._muuri._emitter.emit(evReleaseStart, this);
     Position the released item.    this._layout(false);
  };
  /**   * End the release process of an item.   *   *    *     */  Muuri.Item.prototype._endRelease = function () {
    var stn = this._muuri._settings;    var release = this._release;
     Remove release classname from the released element.    removeClass(release.element, stn.releasingClass);
     If the released element is outside the muuri container put it back there     and adjust position accordingly.    if (release.element.parentNode !== this._muuri._element) {      this._muuri._element.appendChild(release.element);      hookStyles(release.element, {        translateX: this._left + px,        translateY: this._top + px      });    }
     Unlock temporary inlined styles.    unlockElementSize(release);
     Reset release data.    this._resetReleaseData();
     Emit releaseend event.    this._muuri._emitter.emit(evReleaseEnd, this);
  };
  /**   * Check (during drag) if an item is overlapping other items and based on   * the configuration do a relayout.   *   *    *     */  Muuri.Item.prototype._checkOverlap = function () {
    var stn = this._muuri._settings;    var overlapTolerance = stn.dragSortTolerance;    var overlapAction = stn.dragSortAction;    var items = this._muuri._items;    var bestMatch = null;    var instIndex = 0;    var instData = {      width: this._drag.elemWidth,      height: this._drag.elemHeight,      left: this._drag.gridX,      top: this._drag.gridY    };
     Find best match (the element with most overlap).    for (var i = 0, len = items.length; i < len; i++) {      var item = items[i];      if (item === this) {        instIndex = i;      }      else if (item._active) {        var overlapScore = getOverlapScore(instData, {          width: item._width,          height: item._height,          left: item._left,          top: item._top        });        if (!bestMatch || overlapScore > bestMatch.score) {          bestMatch = {            item: item,            score: overlapScore,            index: i          };        }      }    }
     Check if the best match overlaps enough to justify a placement switch.    if (bestMatch && bestMatch.score >= overlapTolerance) {      if (overlapAction === swap) {        arraySwap(items, instIndex, bestMatch.index);        this._muuri._emitter.emit(evSwap, this, bestMatch.item);      }      else {        arrayMove(items, instIndex, bestMatch.index);        this._muuri._emitter.emit(evMove, this, bestMatch.item);      }      this._muuri.layout();    }
  };
  /**   * Stop item's position animation if it is currently animating.   *   *    *     */  Muuri.Item.prototype._stopLayout = function () {
    var stn = this._muuri._settings;
    if (this._positioning) {
       Stop animation.      Velocity(this._element, stop, this._muuri._animQueue);
       Remove visibility classes.      removeClass(this._element, stn.positioningClass);
       Reset state.      this._positioning = false;
       Process callback queue.      processQueue(this._layoutQueue, true, this);
    }
  };
  /**   * Recalculate item's dimensions.   *   *    *     */  Muuri.Item.prototype._refresh = function () {
    if (!this._hidden) {      this._width = Math.round(getDimension(this._element, width, true));      this._height = Math.round(getDimension(this._element, height, true));    }
  };
  /**   * Position item based on it's current data.   *   *    *     *      *      */  Muuri.Item.prototype._layout = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;    var release = inst._release;    var isJustReleased = release.active && release.positioningStarted === false;    var animDuration = isJustReleased ? stn.dragReleaseDuration : stn.positionDuration;    var animEasing = isJustReleased ? stn.dragReleaseEasing : stn.positionEasing;    var animEnabled = instant === true || inst._noLayoutAnimation ? false : animDuration > 0;    var isPositioning = inst._positioning;    var finish = function () {
       Remove positioning classes.      removeClass(inst._element, stn.positioningClass);
       Mark the item as not positioning.      inst._positioning = false;
       Finish up release.      if (release.active) {        inst._endRelease();      }
       Process the callback queue.      processQueue(inst._layoutQueue, false, inst);
    };
     Stop currently running animation, if any.    inst._stopLayout();
     Push the callback to the callback queue.    if (typeof callback === function) {      inst._layoutQueue[inst._layoutQueue.length] = callback;    }
     Mark release positiong as started.    if (isJustReleased) {      release.positioningStarted = true;    }
     Get item container offset. This applies only for release handling in the     scenario where the released element is not currently within the muuri     container.    var offsetLeft = inst._release.active ? inst._release.containerDiffX : 0;    var offsetTop = inst._release.active ? inst._release.containerDiffY : 0;
     If no animations are needed, easy peasy!    if (!animEnabled) {
      if (inst._noLayoutAnimation) {        inst._noLayoutAnimation = false;      }
      hookStyles(inst._element, {        translateX: (inst._left + offsetLeft) + px,        translateY: (inst._top + offsetTop) + px      });
      finish();
    }
     If animations are needed, let's dive in.    else {
       Get current (relative) left and top position. Meaning that the       drga container's offset (if applicable) is subtracted from the current       translate values.      var currentLeft = (parseFloat(Velocity.hook(inst._element, translateX)) || 0) - offsetLeft;      var currentTop =  (parseFloat(Velocity.hook(inst._element, translateY)) || 0) - offsetTop;
       If the item is already in correct position there's no need to animate       it.      if (inst._left === currentLeft && inst._top === currentTop) {        finish();        return;      }
       Mark as positioning.      inst._positioning = true;
       Add positioning class if necessary.      if (!isPositioning) {        addClass(inst._element, stn.positioningClass);      }
       Set up the animation.      Velocity(inst._element, {        translateX: inst._left + offsetLeft,        translateY: inst._top + offsetTop      }, {        duration: animDuration,        easing: animEasing,        complete: finish,        queue: inst._muuri._animQueue      });
       Start the animation.      Velocity.Utilities.dequeue(inst._element, inst._muuri._animQueue);
    }
  };
  /**   * Show item.   *   *    *     *      *      */  Muuri.Item.prototype._show = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;
     If item is visible.    if (!inst._hidden && !inst._showing) {
       Call the callback and be done with it.      if (typeof callback === function) {        callback(false, inst);      }
    }
     If item is animating to visible.    else if (!inst._hidden) {
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
    }
     If item is hidden or animating to hidden.    else {
      var isHiding = inst._hiding;
       Stop animation.      inst._muuri._itemHide.stop(inst);
       Update states.      inst._active = true;      inst._hidden = false;      inst._showing = inst._hiding = false;
       Update classes.      addClass(inst._element, stn.shownClass);      removeClass(inst._element, stn.hiddenClass);
       Set element's display style.      setStyles(inst._element, {        display: block      });
       Process current callback queue.      processQueue(inst._visibiliyQueue, true, inst);
       Update state.      inst._showing = true;
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
       Animate child element.      inst._muuri._itemShow.start(inst, instant, function () {
         Process callback queue.        processQueue(inst._visibiliyQueue, false, inst);
      });
    }
  };
  /**   * Hide item.   *   *    *     *      *      */  Muuri.Item.prototype._hide = function (instant, callback) {
    var inst = this;    var stn = inst._muuri._settings;
     If item is hidden.    if (inst._hidden && !inst._hiding) {
       Call the callback and be done with it.      if (typeof callback === function) {        callback(false, inst);      }
    }
     If item is animating to hidden.    else if (inst._hidden) {
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
    }
     If item is visible or animating to visible.    else {
      var isShowing = inst._showing;
       Stop animation.      inst._muuri._itemShow.stop(inst);
       Update states.      inst._active = false;      inst._hidden = true;      inst._showing = inst._hiding = false;
       Update classes.      addClass(inst._element, stn.hiddenClass);      removeClass(inst._element, stn.shownClass);
       Process current callback queue.      processQueue(inst._visibiliyQueue, true, inst);
       Update state.      inst._hiding = true;
       Push the callback to callback queue.      if (typeof callback === function) {        inst._visibiliyQueue[inst._visibiliyQueue.length] = callback;      }
       Animate child element.      inst._muuri._itemHide.start(inst, instant, function () {
         Hide element.        setStyles(inst._element, {          display: none        });
         Process callback queue.        processQueue(inst._visibiliyQueue, false, inst);
      });
    }
  };
  /**   * Destroy item instance.   *   *    *     *      */  Muuri.Item.prototype._destroy = function (removeElement) {
    var muuri = this._muuri;    var stn = this._muuri._settings;    var element = this._element;    var index = this._muuri._items.indexOf(this);
     Stop animations.    this._stopLayout();    this._muuri._itemShow.stop(this);    this._muuri._itemHide.stop(this);
     If item is being released, stop it gracefully.    if (this._release.active) {      if (element.parentNode !== this._muuri._element) {        this._muuri._element.appendChild(element);      }      this._resetReleaseData();    }
     If item is being dragged, stop it gracefully.    if (this._drag.active) {      if (element.parentNode !== this._muuri._element) {        this._muuri._element.appendChild(element);      }      this._resetDrag();    }
     Destroy Hammer instance and custom touch listeners.    if (this._hammer) {      this._hammer.destroy();    }
     Remove all inline styles.    element.removeAttribute(style);    this._child.removeAttribute(style);
     Handle visibility callback queue, fire all uncompleted callbacks with     interrupted flag.    processQueue(this._visibiliyQueue, true, this);
     Remove Muuri specific classes.    removeClass(element, stn.positioningClass);    removeClass(element, stn.draggingClass);    removeClass(element, stn.releasingClass);    removeClass(element, stn.itemClass);    removeClass(element, stn.shownClass);    removeClass(element, stn.hiddenClass);
     Remove item from Muuri instance if it still exists there.    if (index > -1) {      this._muuri._items.splice(index, 1);    }
     Remove element from DOM.    if (removeElement) {      element.parentNode.removeChild(element);    }
     Render the instance unusable -> nullify all Muuri related properties.    var props = Object.keys(this).concat(Object.keys(Muuri.Item.prototype));    for (var i = 0; i < props.length; i++) {      this[props[i]] = null;    }
  };
  /**   * Creates a new Muuri Layout instance.   *   *    *    *     *      *      */  Muuri.Layout = function (muuri, items) {
    var stn = muuri._settings.layout;
    this.muuri = muuri;    this.items = items ? items.concat() : muuri.get(active);    this.slots = {};    this.width = 0;    this.height = 0;    this.setWidth = false;    this.setHeight = false;
     Calculate the current width and height of the container.    this.width = getDimension(muuri._element, width);    this.height = getDimension(muuri._element, height);
     If the user has provided custom function as a layout method invoke it.    if (typeof stn === function) {
      stn.call(this);
    }     Otherwise parse the layout mode and settings from provided options and     do the calculations.    else {
       Parse the layout method name and settings from muuri settings.      var useDefaults = typeof stn === string;      var methodName = useDefaults ? stn : stn[0];
       Make sure the provided layout method exists.      if (typeof Muuri.Layout.methods[methodName] !== function) {        throw new Error(Layout method "" + method +  "" does not exist.);      }
       Invoke the layout method.      typeof Muuri.Layout.methods[methodName].call(this, useDefaults ? {} : stn[1]);
    }
  };
  /**   * Available layout methods.   *   *    *     */  Muuri.Layout.methods = {    firstFit: LayoutFirstFit  };
  /**   * Muuri - Settings   * ****************   */
  /**   * Default settings.   *   *    *     *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      */  Muuri.defaultSettings = {
     Container    container: null,
     Items    items: [],    positionDuration: 300,    positionEasing: ease-out,    show: {      duration: 300,      easing: ease-out    },    hide: {      duration: 300,      easing: ease-out    },
     Layout    layout: firstFit,    layoutOnResize: 100,    layoutOnInit: true,
     Drag & Drop    dragEnabled: false,    dragContainer: null,    dragPredicate: null,    dragSort: true,    dragSortInterval: 50,    dragSortTolerance: 50,    dragSortAction: move,    dragReleaseDuration: 300,    dragReleaseEasing: ease-out,
     Classnames    containerClass: muuri,    itemClass: muuri-item,    shownClass: muuri-shown,    hiddenClass: muuri-hidden,    positioningClass: muuri-positioning,    draggingClass: muuri-dragging,    releasingClass: muuri-releasing
  };
  /**   * Helpers - Generic   * *****************   */
  /**   * Swap array items.   *   *      *      *      */  function arraySwap(array, indexA, indexB) {
    var temp = array[indexA];    array[indexA] = array[indexB];    array[indexB] = temp;
  }
  /**   * Move array item to another index.   *   *      *      *      */  function arrayMove(array, fromIndex, toIndex) {
    array.splice(toIndex, 0, array.splice(fromIndex, 1)[0]);
  }
  /**   * Returns a new duplicate free version of the provided array.   *   *      *     */  function arrayUnique(array) {
    var ret = [];    for (var i = 0, len = array.length; i < len; i++) {      if (ret.indexOf(array[i]) === -1) {        ret[ret.length] = array[i];      }    }    return ret;
  }
  /**   * Check if a value is a plain object.   *   *      *     */  function isPlainObject(val) {
    return typeof val === object && Object.prototype.toString.call(val) === [object Object];
  }
  /**   * Merge properties of provided objects. The first argument is considered as   * the destination object which inherits the properties of the   * following argument objects. Merges object properties recursively if the   * property's type is object in destination object and the source object.   *   *      *      *   Returns the destination object.   */  function mergeObjects(dest) {
    var sources = Array.prototype.slice.call(arguments, 1);
    for (var i = 0; i < sources.length; i++) {      var source = sources[i];      for (var prop in source) {        if (source.hasOwnProperty(prop)) {          if (isPlainObject(dest[prop]) && isPlainObject(source[prop])) {            mergeObjects(dest[prop], source[prop]);          }          else {            dest[prop] = source[prop];          }        }      }    }
    return dest;
  }
  /**   * Returns a function, that, as long as it continues to be invoked, will not   * be triggered. The function will be called after it stops being called for   * N milliseconds. The returned function accepts one argument which, when   * being ""finish"", calls the debounced function immediately if it is currently   * waiting to be called, and when being ""cancel"" cancels the currently queued   * function call.   *   *      *      *     */  function debounce(fn, wait) {
    var timeout;    var actionCancel = cancel;    var actionFinish = finish;
    return function (action) {
      if (timeout !== undefined) {        timeout = global.clearTimeout(timeout);        if (action === actionFinish) {          fn();        }      }
      if (action !== actionCancel && action !== actionFinish) {        timeout = global.setTimeout(function () {          timeout = undefined;          fn();        }, wait);      }
    };
  }
  /**   * Get intersection area dimensions and position between two rectangles in 2d   * space.   *   *      *      *     */  function getIntersection(a, b) {
    var ret = null;    var overlap = {      left: a.left - b.left,      right: (b.left + b.width) - (a.left + a.width),      top: a.top - b.top,      bottom: (b.top + b.height) - (a.top + a.height)    };    var intersectionWidth = Math.max(a.width + Math.min(overlap.left, 0) + Math.min(overlap.right, 0), 0);    var intersectionHeight = Math.max(a.height + Math.min(overlap.top, 0) + Math.min(overlap.bottom, 0), 0);    var hasIntersection = intersectionWidth > 0 && intersectionHeight > 0;
    if (hasIntersection) {      ret = {};      ret.width = intersectionWidth;      ret.height = intersectionHeight;      ret.left = a.left + Math.abs(Math.min(overlap.left, 0));      ret.right = ret.left + ret.width;      ret.top = a.top + Math.abs(Math.min(overlap.top, 0));      ret.bottom = ret.top + ret.height;    }
    return ret;
  }
  /**   * Helpers - DOM utils   * *******************   */
  /**   * Returns the computed value of an element's style property as a string.   *   *      *      *     */  function getStyle(element, style) {
    return global.getComputedStyle(element, null).getPropertyValue(style);
  }
  /**   * Set inline styles to an element.   *   *      *      */  function setStyles(element, styles) {
    for (var prop in styles) {      element.style[prop] = styles[prop];    }
  }
  /**   * Set inline styles to an element with Velocity's hook method.   *   *      *      */  function hookStyles(element, styles) {
    for (var prop in styles) {      Velocity.hook(element, prop, styles[prop]);    }
  }
  /**   * Check if an element has a specific class name.   *   *      *      *     */  function hasClass(el, className) {
    return (  + el.className).indexOf(  + className) > -1;
  }
  /**   * Add class to an element.   *   *      *      */  function addClass(el, className) {
    if (el.classList) {      el.classList.add(className);    }    else if (hasClass(el, className)) {      el.className +=   + className;    }
  }
  /**   * Remove class name from an element.   *   *      */  function removeClass(el, className) {
    if (el.classList) {      el.classList.remove(className);    }    else if (hasClass(el, className)) {      el.className = (  + el.className +  ).replace(  + className +  ,  ).trim();    }
  }
  /**   * Get element's width/height with padding or with padding, border and margin.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L511-L609   *   *      *      *      */  function getDimension(el, dimension, withMargin) {
    var ret = el.getBoundingClientRect()[dimension];    var isHeight = dimension === height;    var dimensionCapitalized = isHeight ? Height : Width;    var innerDimension = inner + dimensionCapitalized;    var clientDimension = client + dimensionCapitalized;    var edgeA = isHeight ? top : left;    var edgeB = isHeight ? bottom : right;
    if (withMargin) {
      var marginA = parseFloat(getStyle(el, margin- + edgeA));      var marginB = parseFloat(getStyle(el, margin- + edgeB));      ret += marginA > 0 ? marginA : 0;      ret += marginB > 0 ? marginB : 0;
    }    else {
      var borderA;      var borderB;
      if (el === document.documentElement) {        ret -= global[innerDimension] - document.documentElement[clientDimension];      }      else {        borderA = parseFloat(getStyle(el, border- + edgeA + -width));        borderB = parseFloat(getStyle(el, border- + edgeB + -width));        ret -= Math.round(ret) - el[clientDimension] - borderA - borderB;      }
      ret -= borderA !== undefined ? borderA : parseFloat(getStyle(el, border- + edgeA + -width));      ret -= borderB !== undefined ? borderB : parseFloat(getStyle(el, border- + edgeB + -width));
    }
    return ret;
  }
  /**   * Returns the element's offset, which in practice means the vertical and   * horizontal distance between the element's northwest corner and the   * document's northwest corner. This method is a stripped down version of   * Mezr's offset method and tailored for Muuri specifically. By default the   * element's ""dimension edge"" is considered to be the element's padding layer.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L643-L714   *   *      *     */  function getOffset(el) {
    var offsetLeft = 0;    var offsetTop = 0;    var viewportScrollLeft = parseFloat(global.pageXOffset);    var viewportScrollTop = parseFloat(global.pageYOffset);
     For window we just need to get viewport's scroll distance.    if (el.self === global.self) {      offsetLeft = viewportScrollLeft;      offsetTop = viewportScrollTop;    }
     For all elements except the document and window we can use the combination of gbcr and     viewport's scroll distance.    else if (el !== document) {      var gbcr = el.getBoundingClientRect();      offsetLeft += gbcr.left + viewportScrollLeft + parseFloat(getStyle(el, border-left-width));      offsetTop += gbcr.top + viewportScrollTop + parseFloat(getStyle(el, border-top-width));    }
    return {      left: offsetLeft,      top: offsetTop    };
  }
  /**   * Returns the element's offset parent.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L808-L859   *   *      *     */  function getOffsetParent(el) {
    var isFixed = getStyle(el, position) === fixed;
    if (isFixed && hasBrokenW3CTELCS) {      return global;    }
    var offsetParent = el === document.documentElement || el === global ? document : el.parentElement || null;
    if (isFixed) {      while (offsetParent && offsetParent !== document && !isTransformed(offsetParent)) {        offsetParent = offsetParent.parentElement || document;      }      return offsetParent === document ? global : offsetParent;    }    else {      while (offsetParent && offsetParent !== document && getStyle(offsetParent, position) === static && !isTransformed(offsetParent)) {        offsetParent = offsetParent.parentElement || document;      }      return offsetParent;    }
  }
  /**   * Returns true if element is transformed, false if not. In practice the   * element's display value must be anything else than ""none"" or ""inline"" as   * well as have a valid transform value applied in order to be counted as a   * transformed element.   *   * Borrowed from Mezr library:   * https://github.com/niklasramo/mezr/blob/732cb1f5810b948b4fe8ffd85132d29543ece831/mezr.js#L302-L317   *   *      *     */  function isTransformed(el) {
    var transform = getStyle(el, supportedTransform.style);    var display = getStyle(el, display);
    return transform !== none && display !== inline && display !== none;
  }
  /**   * Calculate the offset difference of two elements. The target element is is   * always considered to be Muuri item's element which means that it's margins   * are considered to be part of it's width and height. The anchor element's   * width and height however always consist of the core and the padding only.   *   *      *      *     */  function getOffsetDiff(target, anchor) {
    var anchorOffset = getOffset(anchor);    var targetZeroPosition = getOffset(getOffsetParent(target) || doc);    targetZeroPosition.left -= Math.abs(Math.min(parseFloat(getStyle(target, margin-left)), 0));    targetZeroPosition.top -= Math.abs(Math.min(parseFloat(getStyle(target, margin-top)), 0));
    return {      left: anchorOffset.left - targetZeroPosition.left,      top: anchorOffset.top - targetZeroPosition.top    };
  }
  /**   * Get element's scroll parents.   *   * Borrowed from jQuery UI library (and heavily modified):   * https://github.com/jquery/jquery-ui/blob/63448148a217da7e64c04b21a04982f0d64aabaa/ui/scroll-parent.js   *   *      *     */  function getScrollParents(element) {
    var ret = [];    var overflowRegex = (autoscroll);    var parent = element.parentNode;
     If positioning of fixed elements is broken (according to W3C spec).    if (hasBrokenW3CTELCS) {
       If the element is fixed it can not have any scroll parents.      if (getStyle(element, position) === fixed) {        return ret;      }
       Find scroll parents.      while (parent && parent !== document && parent !== document.documentElement) {        if (overflowRegex.test(getStyle(parent, overflow) + getStyle(parent, overflow-y) + getStyle(parent, overflow-x))) {          ret[ret.length] = parent;        }        parent = getStyle(parent, position) === fixed ? null : parent.parentNode;      }
       If parent is not fixed element, add window object as the last scroll       parent.      if (parent !== null) {        ret[ret.length] = global;      }
    }     If fixed elements behave as defined in the W3C specification.    else {
       Find scroll parents.      while (parent && parent !== document) {
         If the currently looped element is fixed ignore all parents that are         not transformed.        if (getStyle(element, position) === fixed && !isTransformed(parent)) {          parent = parent.parentNode;          continue;        }
         Add the parent element to return items if it is scrollable.        if (overflowRegex.test(getStyle(parent, overflow) + getStyle(parent, overflow-y) + getStyle(parent, overflow-x))) {          ret[ret.length] = parent;        }
         Update element and parent references.        element = parent;        parent = parent.parentNode;
      }
       Replace reference of possible root element to window object.      if (ret.length && ret[ret.length - 1] === document.documentElement) {        ret[ret.length - 1] = global;      }
    }
    return ret;
  }
  /**   * Helpers - Muuri   * ***************   */
  /**   * Calculate how many percent the intersection area of two items is from the   * maximum potential intersection area between the items.   *   *      *      *   A number between 0-100.   */  function getOverlapScore(a, b) {
    var intersection = getIntersection(a, b);
    if (!intersection) {      return 0;    }
    var aUnpos = {      width: a.width,      height: a.height,      left: 0,      top: 0    };
    var bUnpos = {      width: b.width,      height: b.height,      left: 0,      top: 0    };
    var maxIntersection = getIntersection(aUnpos, bUnpos);
    return (intersection.width * intersection.height) / (maxIntersection.width * maxIntersection.height) * 100;
  }
  /**   * Return parsed drag event data.   *   *      *      *      *     */  function generateDragEvent(type, event, drag) {
    return {      type: type,      event: event,      currentLeft: drag.left,      currentTop: drag.top,      gridLeft: drag.gridX,      gridTop: drag.gridY    };
  }
  /**   * Default drag start predicate handler. The context of the function is   * always a temporary object which is gets reset on each draginit event.   *   *      *      *      */  function dragPredicate(e, item, resolve) {
    if (!this.isResolved) {      this.isResolved = true;      resolve(e);    }
  }
  /**   * Lock dragged element's dimensions.   *   *      */  function lockElementSize(data) {
     Don't override existing element styles.    if (!data.elementStyles) {
      var styles = [width, height, padding, margin];
       Reset element styles.      data.elementStyles = {};
       Store current inline style values.      for (var i = 0; i < 4; i++) {        var style = styles[i];        var value = data.element.style[style];        data.elementStyles[style] = value || ;      }
       Set effective values as inline styles.      for (var i = 0; i < 4; i++) {        var style = styles[i];        data.element.style[style] = getStyle(data.element, style);      }
    }
  }
  /**   * Unlock dragged element's dimensions.   *   *      */  function unlockElementSize(data) {
    if (data.elementStyles) {      for (var style in data.elementStyles) {        data.element.style[style] = data.elementStyles[style];      }    }
  }
  /**   * Show/hide Muuri instance's items.   *   *    *      *    - ""show"" or ""hide"".   *      *      *      */  function showHideHandler(inst, method, items, instant, callback) {
     Sanitize items.    items = inst.get(items);
     Sanitize callback.    callback = typeof instant === function ? instant : callback;
    var counter = items.length;
     If there are no items call the callback, but don't emit any events.    if (!counter) {
      if (typeof callback === function) {        callback(items);      }
    }     If we have some items let's dig in.    else {
      var isShow = method === show;      var startEvent = isShow ? evShowStart : evHideStart;      var endEvent = isShow ? evShowEnd : evHideEnd;      var isInstant = instant === true;      var completed = [];      var needsRelayout = false;      var hiddenItems = [];
       Emit showstart event.      inst._emitter.emit(startEvent, items);
       Show/hide items. The loop cycle must be wrapped in a function in order       to keep the correct reference of the item for the asynchronous callback       of the item's private show/hide method.      for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
         Check if relayout or refresh is needed.        if ((isShow && !item._active) || (!isShow && item._active)) {          needsRelayout = true;          if (isShow) {            item._noLayoutAnimation = true;            hiddenItems[hiddenItems.length] = item;          }        }
         Hide/show the item.        item[_ + method](isInstant, function (interrupted, item) {
           If the current item's animation was not interrupted add it to the           completed set.          if (!interrupted) {            completed[completed.length] = item;          }
           If all items have finished their animations call the callback           and emit the event.          if (--counter < 1) {            if (typeof callback === function) {              callback(completed);            }            inst._emitter.emit(endEvent, completed);          }
        });
      }
       Relayout only if needed.      if (needsRelayout) {        if (hiddenItems.length) {          inst.refresh(hiddenItems);        }        inst.layout();      }
    }
  }
  /**   * Default item show/hide animation flow. Returns and object that contains   * the animation start and stop method.   *   *      *      *     */  function showHideAnimation(opts, isShow) {
    var duration = (opts && opts.duration) || 0;    var easing = (opts && opts.easing) || ease-out;
    if (!duration) {      return {        start: noop,        stop: noop      };    }    else {      var targetStyles = isShow ? {opacity: 1, scale: 1} : {opacity: 0, scale: 0.5};      return {        start: function (item, instant, animDone) {          if (instant) {            hookStyles(item._child, targetStyles);          }          else {            Velocity(item._child, targetStyles, {              duration: duration,              easing: easing,              queue: item._muuri._animQueue,              complete: animDone            });            Velocity.Utilities.dequeue(item._child, item._muuri._animQueue);          }        },        stop: function (item) {          Velocity(item._child, stop, item._muuri._animQueue);        }      };    }
  }
  /**   * Process item's callback queue.   *   *    *      *      *      */  function processQueue(queue, interrupted, instance) {
    var snapshot = queue.splice(0, queue.length);    for (var i = 0, len = snapshot.length; i < len; i++) {      snapshot[i](interrupted, instance);    }
  }
  /**   * Init   */
  return Muuri;
}));"
"module.exports = function (config) {
  var package = require(./package.json);
     Define Sauce Labs browsers.  
  var browsers = [     IE    [Windows 7, internet explorer, 9.0],    [Windows 8, internet explorer, 10.0],    [Windows 8.1, internet explorer, 11.0],     Edge    [Windows 10, MicrosoftEdge, 13.10586],     Firefox    [Windows 10, firefox, 48.0],    [OS X 10.11, firefox, 48.0],     Chrome    [Windows 10, chrome, 53.0],    [OS X 10.11, chrome, 53.0],     Safari    [OS X 10.8, safari, 6.0],    [OS X 10.9, safari, 7.0],    [OS X 10.10, safari, 8.0],    [OS X 10.11, safari, 9.0]  ];
     Generate Sauce Labs launchers.  
  var launchers = {};  browsers.forEach(function (browser) {
    var launcher = {      base: SauceLabs,      platform: browser[0],      browserName: browser[1],      version: browser[2]    };    var key = launcher.platform +  -  + launcher.browserName + (launcher.version ?  -  + launcher.version : );
    if (launcher.browserName === iphone) {      launcher.deviceName = iPhone Simulator;      launcher.deviceOrientation = portrait;    }
    if (launcher.browserName === android) {      launcher.deviceName = Android Emulator;      launcher.deviceOrientation = portrait;    }
    launchers[key] = launcher;
  });
     Karma settings.  
  var stn = {};
  stn.basePath = ;
   https://npmjs.org/browse/keyword/karma-adapter  stn.frameworks = [    qunit  ];
   plugins to use  stn.plugins = [    karma-qunit,    karma-sauce-launcher,    karma-story-reporter  ];
   list of files / patterns to load in the browser  stn.files = [    package.main,    ./tests/tests.js  ];
   list of files to exclude  stn.exclude = [];
   preprocess matching files before serving them to the browser   https://npmjs.org/browse/keyword/karma-preprocessor  stn.preprocessors = {};  stn.preprocessors[package.main] = ['coverage'];
   possible values: 'dots', 'progress', 'story'   https://npmjs.org/browse/keyword/karma-reporter  stn.reporters = [    story,    saucelabs  ];
   enable / disable colors in the output (reporters and logs)  stn.colors = true;
   level of logging   possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG  stn.logLevel = config.LOG_INFO;
  stn.autoWatch = false;
  stn.customLaunchers = launchers;
  stn.browsers = Object.keys(launchers);
  stn.captureTimeout = 240000;
  stn.browserDisconnectTimeout = 5000;
  stn.browserDisconnectTolerance = 4;
  stn.singleRun = true;
  stn.sauceLabs = {    testName: package.name +  -  + package.version +  - unit tests  };
  stn.hostname = 127.0.0.1;
  config.set(stn);
};"
"var package = require(./package.json);var fs = require(fs);var gulp = require(gulp);var jscs = require(gulp-jscs);var karma = require(karma);var uglify = require(gulp-uglify);var rename = require(gulp-rename);var size = require(gulp-size);var rimraf = require(rimraf);var runSequence = require(run-sequence);var fileExists = function (filePath) {  try {    return fs.statSync(filePath).isFile();  } catch (err) {    return false;  }};
 Load environment variables if .env file existsif (fileExists(./.env)) {  require(dotenv).load();}
gulp.task(validate, function () {
  return gulp  .src(package.main)  .pipe(jscs())  .pipe(jscs.reporter());
});
gulp.task(compress, function() {
  var mainMinified = package.main.replace(./, ).replace(.js, .min.js);
  return gulp  .src(package.main)  .pipe(size({title: development}))  .pipe(uglify({    preserveComments: some  }))  .pipe(size({title: minified}))  .pipe(size({title: gzipped, gzip: true}))  .pipe(rename(mainMinified))  .pipe(gulp.dest(./));
});
gulp.task(test, function (done) {
  (new karma.Server({    configFile: __dirname + /karma.conf.js,    action: run  }, function (exitCode) {    done(exitCode);  })).start();
});
gulp.task(clean, function (cb) {
  rimraf(./*.log, function () {    rimraf(./coverage, cb);  });
});
gulp.task(default, function (done) {
  if (process.env.CI) {    runSequence(validate, compress, test, clean, done);  }  else {    runSequence(validate, compress, test, done);  }
});"
"module.exports = function (config) {  config.set({    browsers: [PhantomJS],    frameworks: [jasmine],    files: [test/**/*.js],    reporters: [spec],    preprocessors: {      test/*.js: [webpack]    },    singleRun: true,
    webpack: {       karma watches the test entry points       (you don't need to specify the entry option)      module: {        loaders: [          {            test: js,            loader: babel,            exclude: node_modules          },        ]      }    },
    webpackMiddleware: {      noInfo: true    }  });};"
"let SortableListView = require(./index);let React = require(react);let {  View,  Text,  TouchableHighlight} = require(react-native);

let data = {  hello: {text: world},  how: {text: are you},  test: {text: 123},  this: {text: is},  a: {text: a},  real: {text: real},  drag: {text: drag and drop},  bb: {text: bb},  cc: {text: cc},  dd: {text: dd},  ee: {text: ee},  ff: {text: ff},  gg: {text: gg},  hh: {text: hh},  ii: {text: ii},  jj: {text: jj},  kk: {text: kk}}
let order = Object.keys(data); Array of keys
let RowComponent = React.createClass({  render: function() {    return <TouchableHighlight underlayColor={#eee} style={{padding: 25, backgroundColor: #F8F8F8, borderBottomWidth:1, borderColor: #eee}} {...this.props.sortHandlers}>        <Text>{this.props.data.text}</Text>      </TouchableHighlight>  }})
let MyComponent = React.createClass({  render: function() {    return <SortableListView          style={{flex: 1}}          data={data}          order={order}          onRowMoved={e => {            order.splice(e.to, 0, order.splice(e.from, 1)[0]);            this.forceUpdate();          }}          renderRow={row => <RowComponent data={row} />}        />  }});
module.exports = MyComponent;"
"use strict; generated on 2015-04-04 using generator-gulp-webapp 0.1.0
var gulp = require(gulp);
 load pluginsvar $ = require(gulp-load-plugins)();const babel = require(gulp-babel);
gulp.task(scripts, function () {    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))        .pipe($.jshint())        .pipe($.jshint.reporter(require(jshint-stylish)))        .pipe($.size());});

var rename = require(gulp-rename);
gulp.task(buildjs, [scripts], function () {    var jsFilter = $.filter(**/*.js, {restore: true});
    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))            .pipe(gulp.dest(dist))        .pipe($.size());});
gulp.task(js, [buildjs], function () {    var jsFilter = $.filter(**/*.js, {restore: true});
    return gulp.src(src/**/*.js)        .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))            .pipe($.uglify())        .pipe(rename({            suffix: .min        }))        .pipe(gulp.dest(dist))        .pipe($.size());});
gulp.task(clean, function () {    return gulp.src([.tmp, dist], { read: false }).pipe($.clean());});
gulp.task(build, [js, copy-js, main-bower-files],function(){        return gulp.src(./bower_components/vue/dist/vue.js)        .pipe(gulp.dest(./examples/libs/vue/dist));        });
gulp.task(default, [clean], function () {    gulp.start(build);});
gulp.task(connect, function () {    var connect = require(connect);    var serveStatic = require(serve-static);    var serveIndex  = require(serve-index);    var app = connect()        .use(require(connect-livereload)({ port: 35729 }))        .use(serveStatic(.tmp))        .use(serveStatic(examples))        .use(serveIndex(examples));
    require(http).createServer(app)        .listen(9000)        .on(listening, function () {            console.log(Started connect web server on http://localhost:9000);        });});
gulp.task(serve, [connect], function () {    require(opn)(http://localhost:9000);});
var mainBowerFiles = require(gulp-main-bower-files);
gulp.task(main-bower-files, function() {    return gulp.src(./bower.json)        .pipe(mainBowerFiles())        .pipe(gulp.dest(./examples/libs));});
gulp.task(copy-js, function() {    return gulp.src(src/**/*.js)                .pipe(babel({            presets: [es2015],            plugins: [transform-object-assign]        }))           .pipe(gulp.dest(./examples/src));});
var jip = require(jasmine-istanbul-phantom);var changedSpec = null
gulp.task(test, function(done) {  var options = { callback: done, lib : [bower_components/**/*.js] }
  if (changedSpec)    options.spec = changedSpec
  jip(options)
  changedSpec = null}); gulp.task(watch, [connect, serve], function () {    var server = $.livereload;    server.listen();     watch for changes    gulp.watch([        examples/*.html,        src/**/*.js,        examples/**/*.js,    ]).on(change, server.changed);

    gulp.watch(./bower.json).on(change, function() {        gulp.start(main-bower-files)    });     gulp.watch(src/**/*.js, [scripts]);
    gulp.watch(src/**/*.js).on(change, function() {        gulp.start(copy-js);        gulp.start(test);    });
    gulp.watch(test/spec/*.js).on(change, function(event){        changedSpec = event.path        gulp.start(test)    });
});"
"
(function($){$.extend({tablesorter:newfunction(){var parsers=[],widgets=[];this.defaults={cssHeader:""header"",cssAsc:""headerSortUp"",cssDesc:""headerSortDown"",cssChildRow:""expand-child"",sortInitialOrder:""asc"",sortMultiSortKey:""shiftKey"",sortForce:null,sortAppend:null,sortLocaleCompare:true,textExtraction:""simple"",parsers:{},widgets:[],widgetZebra:{css:[""even"",""odd""]},headers:{},widthFixed:false,cancelSelection:true,sortList:[],headerList:[],dateFormat:""us"",decimal:'/\.|\,/g',onRenderHeader:null,selectorHeaders:'thead th',debug:false};function benchmark(s,d){log(s+"",""+(new Date().getTime()-d.getTime())+""ms"");}this.benchmark=benchmark;function log(s){if(typeof console!=""undefined""&&typeof console.debug!=""undefined""){console.log(s);}else{alert(s);}}function buildParserCache(table,$headers){if(table.config.debug){var parsersDebug="""";}if(table.tBodies.length==0)return;var rows=table.tBodies[0].rows;if(rows[0]){var list=[],cells=rows[0].cells,l=cells.length;for(var i=0;i<l;i++){var p=false;if($.metadata&&($($headers[i]).metadata()&&$($headers[i]).metadata().sorter)){p=getParserById($($headers[i]).metadata().sorter);}else if((table.config.headers[i]&&table.config.headers[i].sorter)){p=getParserById(table.config.headers[i].sorter);}if(!p){p=detectParserForColumn(table,rows,-1,i);}if(table.config.debug){parsersDebug+=""column:""+i+"" parser:""+p.id+""\n"";}list.push(p);}}if(table.config.debug){log(parsersDebug);}return list;};function detectParserForColumn(table,rows,rowIndex,cellIndex){var l=parsers.length,node=false,nodeValue=false,keepLooking=true;while(nodeValue==''&&keepLooking){rowIndex++;if(rows[rowIndex]){node=getNodeFromRowAndCellIndex(rows,rowIndex,cellIndex);nodeValue=trimAndGetNodeText(table.config,node);if(table.config.debug){log('Checking if value was empty on row:'+rowIndex);}}else{keepLooking=false;}}for(var i=1;i<l;i++){if(parsers[i].is(nodeValue,table,node)){return parsers[i];}}return parsers[0];}function getNodeFromRowAndCellIndex(rows,rowIndex,cellIndex){return rows[rowIndex].cells[cellIndex];}function trimAndGetNodeText(config,node){return $.trim(getElementText(config,node));}function getParserById(name){var l=parsers.length;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==name.toLowerCase()){return parsers[i];}}return false;}function buildCache(table){if(table.config.debug){var cacheTime=new Date();}var totalRows=(table.tBodies[0]&&table.tBodies[0].rows.length)||0,totalCells=(table.tBodies[0].rows[0]&&table.tBodies[0].rows[0].cells.length)||0,parsers=table.config.parsers,cache={row:[],normalized:[]};for(var i=0;i<totalRows;++i){var c=$(table.tBodies[0].rows[i]),cols=[];if(c.hasClass(table.config.cssChildRow)){cache.row[cache.row.length-1]=cache.row[cache.row.length-1].add(c);continue;}cache.row.push(c);for(var j=0;j<totalCells;++j){cols.push(parsers[j].format(getElementText(table.config,c[0].cells[j]),table,c[0].cells[j]));}cols.push(cache.normalized.length);cache.normalized.push(cols);cols=null;};if(table.config.debug){benchmark(""Building cache for ""+totalRows+"" rows:"",cacheTime);}return cache;};function getElementText(config,node){var text="""";if(!node)return"""";if(!config.supportsTextContent)config.supportsTextContent=node.textContent||false;if(config.textExtraction==""simple""){if(config.supportsTextContent){text=node.textContent;}else{if(node.childNodes[0]&&node.childNodes[0].hasChildNodes()){text=node.childNodes[0].innerHTML;}else{text=node.innerHTML;}}}else{if(typeof(config.textExtraction)==""function""){text=config.textExtraction(node);}else{text=$(node).text();}}return text;}function appendToTable(table,cache){if(table.config.debug){var appendTime=new Date()}var c=cache,r=c.row,n=c.normalized,totalRows=n.length,checkCell=(n[0].length-1),tableBody=$(table.tBodies[0]),rows=[];for(var i=0;i<totalRows;i++){var pos=n[i][checkCell];rows.push(r[pos]);if(!table.config.appender){var l=r[pos].length;for(var j=0;j<l;j++){tableBody[0].appendChild(r[pos][j]);}}}if(table.config.appender){table.config.appender(table,rows);}rows=null;if(table.config.debug){benchmark(""Rebuilt table:"",appendTime);}applyWidget(table);setTimeout(function(){$(table).trigger(""sortEnd"");},0);};function buildHeaders(table){if(table.config.debug){var time=new Date();}var meta=($.metadata)?true:false;var header_index=computeTableHeaderCellIndexes(table);$tableHeaders=$(table.config.selectorHeaders,table).each(function(index){this.column=header_index[this.parentNode.rowIndex+""-""+this.cellIndex];this.order=formatSortingOrder(table.config.sortInitialOrder);this.count=this.order;if(checkHeaderMetadata(this)||checkHeaderOptions(table,index))this.sortDisabled=true;if(checkHeaderOptionsSortingLocked(table,index))this.order=this.lockedOrder=checkHeaderOptionsSortingLocked(table,index);if(!this.sortDisabled){var $th=$(this).addClass(table.config.cssHeader);if(table.config.onRenderHeader)table.config.onRenderHeader.apply($th);}table.config.headerList[index]=this;});if(table.config.debug){benchmark(""Built headers:"",time);log($tableHeaders);}return $tableHeaders;};function computeTableHeaderCellIndexes(t){var matrix=[];var lookup={};var thead=t.getElementsByTagName('THEAD')[0];var trs=thead.getElementsByTagName('TR');for(var i=0;i<trs.length;i++){var cells=trs[i].cells;for(var j=0;j<cells.length;j++){var c=cells[j];var rowIndex=c.parentNode.rowIndex;var cellId=rowIndex+""-""+c.cellIndex;var rowSpan=c.rowSpan||1;var colSpan=c.colSpan||1var firstAvailCol;if(typeof(matrix[rowIndex])==""undefined""){matrix[rowIndex]=[];}for(var k=0;k<matrix[rowIndex].length+1;k++){if(typeof(matrix[rowIndex][k])==""undefined""){firstAvailCol=k;break;}}lookup[cellId]=firstAvailCol;for(var k=rowIndex;k<rowIndex+rowSpan;k++){if(typeof(matrix[k])==""undefined""){matrix[k]=[];}var matrixrow=matrix[k];for(var l=firstAvailCol;l<firstAvailCol+colSpan;l++){matrixrow[l]=""x"";}}}}return lookup;}function checkCellColSpan(table,rows,row){var arr=[],r=table.tHead.rows,c=r[row].cells;for(var i=0;i<c.length;i++){var cell=c[i];if(cell.colSpan>1){arr=arr.concat(checkCellColSpan(table,headerArr,row++));}else{if(table.tHead.length==1||(cell.rowSpan>1||!r[row+1])){arr.push(cell);}}}return arr;};function checkHeaderMetadata(cell){if(($.metadata)&&($(cell).metadata().sorter===false)){return true;};return false;}function checkHeaderOptions(table,i){if((table.config.headers[i])&&(table.config.headers[i].sorter===false)){return true;};return false;}function checkHeaderOptionsSortingLocked(table,i){if((table.config.headers[i])&&(table.config.headers[i].lockedOrder))return table.config.headers[i].lockedOrder;return false;}function applyWidget(table){var c=table.config.widgets;var l=c.length;for(var i=0;i<l;i++){getWidgetById(c[i]).format(table);}}function getWidgetById(name){var l=widgets.length;for(var i=0;i<l;i++){if(widgets[i].id.toLowerCase()==name.toLowerCase()){return widgets[i];}}};function formatSortingOrder(v){if(typeof(v)!=""Number""){return(v.toLowerCase()==""desc"")?1:0;}else{return(v==1)?1:0;}}function isValueInArray(v,a){var l=a.length;for(var i=0;i<l;i++){if(a[i][0]==v){return true;}}return false;}function setHeadersCss(table,$headers,list,css){$headers.removeClass(css[0]).removeClass(css[1]);var h=[];$headers.each(function(offset){if(!this.sortDisabled){h[this.column]=$(this);}});var l=list.length;for(var i=0;i<l;i++){h[list[i][0]].addClass(css[list[i][1]]);}}function fixColumnWidth(table,$headers){var c=table.config;if(c.widthFixed){var colgroup=$('<colgroup>');$(""tr:first td"",table.tBodies[0]).each(function(){colgroup.append($('<col>').css('width',$(this).width()));});$(table).prepend(colgroup);};}function updateHeaderSortCount(table,sortList){var c=table.config,l=sortList.length;for(var i=0;i<l;i++){var s=sortList[i],o=c.headerList[s[0]];o.count=s[1];o.count++;}}function multisort(table,sortList,cache){if(table.config.debug){var sortTime=new Date();}var dynamicExp=""var sortWrapper = function(a,b) {"",l=sortList.length;for(var i=0;i<l;i++){var c=sortList[i][0];var order=sortList[i][1];var s=(table.config.parsers[c].type==""text"")?((order==0)?makeSortFunction(""text"",""asc"",c):makeSortFunction(""text"",""desc"",c)):((order==0)?makeSortFunction(""numeric"",""asc"",c):makeSortFunction(""numeric"",""desc"",c));var e=""e""+i;dynamicExp+=""var ""+e+"" = ""+s;dynamicExp+=""if(""+e+"") { return ""+e+""; } "";dynamicExp+=""else { "";}var orgOrderCol=cache.normalized[0].length-1;dynamicExp+=""return a[""+orgOrderCol+""]-b[""+orgOrderCol+""];"";for(var i=0;i<l;i++){dynamicExp+=""}; "";}dynamicExp+=""return 0; "";dynamicExp+=""}; "";if(table.config.debug){benchmark(""Evaling expression:""+dynamicExp,new Date());}eval(dynamicExp);cache.normalized.sort(sortWrapper);if(table.config.debug){benchmark(""Sorting on ""+sortList.toString()+"" and dir ""+order+"" time:"",sortTime);}return cache;};function makeSortFunction(type,direction,index){var a=""a[""+index+""]"",b=""b[""+index+""]"";if(type=='text'&&direction=='asc'){return""(""+a+"" == ""+b+"" ? 0 : (""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : (""+a+"" < ""+b+"") ? -1 : 1 )));"";}else if(type=='text'&&direction=='desc'){return""(""+a+"" == ""+b+"" ? 0 : (""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : (""+b+"" < ""+a+"") ? -1 : 1 )));"";}else if(type=='numeric'&&direction=='asc'){return""(""+a+"" === null && ""+b+"" === null) ? 0 :(""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : ""+a+"" - ""+b+""));"";}else if(type=='numeric'&&direction=='desc'){return""(""+a+"" === null && ""+b+"" === null) ? 0 :(""+a+"" === null ? Number.POSITIVE_INFINITY : (""+b+"" === null ? Number.NEGATIVE_INFINITY : ""+b+"" - ""+a+""));"";}};function makeSortText(i){return""((a[""+i+""] < b[""+i+""]) ? -1 : ((a[""+i+""] > b[""+i+""]) ? 1 : 0));"";};function makeSortTextDesc(i){return""((b[""+i+""] < a[""+i+""]) ? -1 : ((b[""+i+""] > a[""+i+""]) ? 1 : 0));"";};function makeSortNumeric(i){return""a[""+i+""]-b[""+i+""];"";};function makeSortNumericDesc(i){return""b[""+i+""]-a[""+i+""];"";};function sortText(a,b){if(table.config.sortLocaleCompare)return a.localeCompare(b);return((a<b)?-1:((a>b)?1:0));};function sortTextDesc(a,b){if(table.config.sortLocaleCompare)return b.localeCompare(a);return((b<a)?-1:((b>a)?1:0));};function sortNumeric(a,b){return a-b;};function sortNumericDesc(a,b){return b-a;};function getCachedSortType(parsers,i){return parsers[i].type;};this.construct=function(settings){return this.each(function(){if(!this.tHead||!this.tBodies)return;var $this,$document,$headers,cache,config,shiftDown=0,sortOrder;this.config={};config=$.extend(this.config,$.tablesorter.defaults,settings);$this=$(this);$.data(this,""tablesorter"",config);$headers=buildHeaders(this);this.config.parsers=buildParserCache(this,$headers);cache=buildCache(this);var sortCSS=[config.cssDesc,config.cssAsc];fixColumnWidth(this);$headers.click(function(e){var totalRows=($this[0].tBodies[0]&&$this[0].tBodies[0].rows.length)||0;if(!this.sortDisabled&&totalRows>0){$this.trigger(""sortStart"");var $cell=$(this);var i=this.column;this.order=this.count++%2;if(this.lockedOrder)this.order=this.lockedOrder;if(!e[config.sortMultiSortKey]){config.sortList=[];if(config.sortForce!=null){var a=config.sortForce;for(var j=0;j<a.length;j++){if(a[j][0]!=i){config.sortList.push(a[j]);}}}config.sortList.push([i,this.order]);}else{if(isValueInArray(i,config.sortList)){for(var j=0;j<config.sortList.length;j++){var s=config.sortList[j],o=config.headerList[s[0]];if(s[0]==i){o.count=s[1];o.count++;s[1]=o.count%2;}}}else{config.sortList.push([i,this.order]);}};setTimeout(function(){setHeadersCss($this[0],$headers,config.sortList,sortCSS);appendToTable($this[0],multisort($this[0],config.sortList,cache));},1);return false;}}).mousedown(function(){if(config.cancelSelection){this.onselectstart=function(){return false};return false;}});$this.bind(""update"",function(){var me=this;setTimeout(function(){me.config.parsers=buildParserCache(me,$headers);cache=buildCache(me);},1);}).bind(""updateCell"",function(e,cell){var config=this.config;var pos=[(cell.parentNode.rowIndex-1),cell.cellIndex];cache.normalized[pos[0]][pos[1]]=config.parsers[pos[1]].format(getElementText(config,cell),cell);}).bind(""sorton"",function(e,list){$(this).trigger(""sortStart"");config.sortList=list;var sortList=config.sortList;updateHeaderSortCount(this,sortList);setHeadersCss(this,$headers,sortList,sortCSS);appendToTable(this,multisort(this,sortList,cache));}).bind(""appendCache"",function(){appendToTable(this,cache);}).bind(""applyWidgetId"",function(e,id){getWidgetById(id).format(this);}).bind(""applyWidgets"",function(){applyWidget(this);});if($.metadata&&($(this).metadata()&&$(this).metadata().sortlist)){config.sortList=$(this).metadata().sortlist;}if(config.sortList.length>0){$this.trigger(""sorton"",[config.sortList]);}applyWidget(this);});};this.addParser=function(parser){var l=parsers.length,a=true;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==parser.id.toLowerCase()){a=false;}}if(a){parsers.push(parser);};};this.addWidget=function(widget){widgets.push(widget);};this.formatFloat=function(s){var i=parseFloat(s);return(isNaN(i))?0:i;};this.formatInt=function(s){var i=parseInt(s);return(isNaN(i))?0:i;};this.isDigit=function(s,config){return/^[-+]?\d*$/.test($.trim(s.replace(/[,.']/g,'')));};this.clearTableBody=function(table){if($.browser.msie){function empty(){while(this.firstChild)this.removeChild(this.firstChild);}empty.apply(table.tBodies[0]);}else{table.tBodies[0].innerHTML="""";}};}});$.fn.extend({tablesorter:$.tablesorter.construct});var ts=$.tablesorter;ts.addParser({id:""text"",is:function(s){return true;},format:function(s){return $.trim(s.toLocaleLowerCase());},type:""text""});ts.addParser({id:""digit"",is:function(s,table){var c=table.config;return $.tablesorter.isDigit(s,c);},format:function(s){return $.tablesorter.formatFloat(s);},type:""numeric""});ts.addParser({id:""currency"",is:function(s){return/^[£$€?.]/.test(s);},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/[£$€]/g),""""));},type:""numeric""});ts.addParser({id:""ipAddress"",is:function(s){return/^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);},format:function(s){var a=s.split("".""),r="""",l=a.length;for(var i=0;i<l;i++){var item=a[i];if(item.length==2){r+=""0""+item;}else{r+=item;}}return $.tablesorter.formatFloat(r);},type:""numeric""});ts.addParser({id:""url"",is:function(s){return/^(https?|ftp|file):\/\/$/.test(s);},format:function(s){return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//),''));},type:""text""});ts.addParser({id:""isoDate"",is:function(s){return/^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);},format:function(s){return $.tablesorter.formatFloat((s!="""")?new Date(s.replace(new RegExp(/-/g),""/"")).getTime():""0"");},type:""numeric""});ts.addParser({id:""percent"",is:function(s){return/\%$/.test($.trim(s));},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g),""""));},type:""numeric""});ts.addParser({id:""usLongDate"",is:function(s){return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));},format:function(s){return $.tablesorter.formatFloat(new Date(s).getTime());},type:""numeric""});ts.addParser({id:""shortDate"",is:function(s){return/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);},format:function(s,table){var c=table.config;s=s.replace(/\-/g,""/"");if(c.dateFormat==""us""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,""$3/$1/$2"");}else if (c.dateFormat == ""pt"") {s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, ""$3/$2/$1"");} else if(c.dateFormat==""uk""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,""$3/$2/$1"");}else if(c.dateFormat==""dd/mm/yy""||c.dateFormat==""dd-mm-yy""){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/,""$1/$2/$3"");}return $.tablesorter.formatFloat(new Date(s).getTime());},type:""numeric""});ts.addParser({id:""time"",is:function(s){return/^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);},format:function(s){return $.tablesorter.formatFloat(new Date(""2000/01/01 ""+s).getTime());},type:""numeric""});ts.addParser({id:""metadata"",is:function(s){return false;},format:function(s,table,cell){var c=table.config,p=(!c.parserMetadataName)?'sortValue':c.parserMetadataName;return $(cell).metadata()[p];},type:""numeric""});ts.addWidget({id:""zebra"",format:function(table){if(table.config.debug){var time=new Date();}var $tr,row=-1,odd;$(""tr:visible"",table.tBodies[0]).each(function(i){$tr=$(this);if(!$tr.hasClass(table.config.cssChildRow))row++;odd=(row%2==0);$tr.removeClass(table.config.widgetZebra.css[odd?0:1]).addClass(table.config.widgetZebra.css[odd?1:0])});if(table.config.debug){$.tablesorter.benchmark(""Applying Zebra widget"",time);}}});})(jQuery);"
"/* *  * TableSorter 2.0 - Client-side table sorting with ease! * Version 2.0.5b * @requires jQuery v1.2.3 *  * Copyright (c) 2007 Christian Bach * Examples and docs at: http://tablesorter.com * Dual licensed under the MIT and GPL licenses: * http://www.opensource.org/licenses/mit-license.php * http://www.gnu.org/licenses/gpl.html *  *//** *  *  Create a sortable table with multi-column sorting capabilitys *  *   *  Create a simple tablesorter interface. *  *   *  Create a tablesorter interface and sort on the first and secound column column headers. *  *   *           *  Create a tablesorter interface and disableing the first and second  column headers. *       *  *   *  *  Create a tablesorter interface and set a column parser for the first *       and second column. *  *  *   *            settings An object literal containing key/value pairs to provide *            optional settings. *  *  * @option String cssHeader (optional) A string of the class name to be appended *         to sortable tr elements in the thead of the table. Default value: *         ""header"" *  * @option String cssAsc (optional) A string of the class name to be appended to *         sortable tr elements in the thead on a ascending sort. Default value: *         ""headerSortUp"" *  * @option String cssDesc (optional) A string of the class name to be appended *         to sortable tr elements in the thead on a descending sort. Default *         value: ""headerSortDown"" *  * @option String sortInitialOrder (optional) A string of the inital sorting *         order can be asc or desc. Default value: ""asc"" *  * @option String sortMultisortKey (optional) A string of the multi-column sort *         key. Default value: ""shiftKey"" *  * @option String textExtraction (optional) A string of the text-extraction *         method to use. For complex html structures inside td cell set this *         option to ""complex"", on large tables the complex option can be slow. *         Default value: ""simple"" *  * @option Object headers (optional) An object of instructions for per-column *         controls in the format: headers: { 0: { option: setting }, ... }. For  *         example, to disable sorting on the first two columns of a table: *         headers: { 0: { sorter: false}, 1: {sorter: false} }. *         Default value: null. *  * @option Array sortList (optional) An array of instructions for per-column sorting  *         and direction in the format: [[columnIndex, sortDirection], ... ] where  *         columnIndex is a zero-based index for your columns left-to-right and  *         sortDirection is 0 for Ascending and 1 for Descending. A valid argument  *         that sorts ascending first by column 1 and then column 2 looks like:  *         [[0,0],[1,0]]. Default value: null. *  * @option Array sortForce (optional) An array containing forced sorting rules. *         Use to add an additional forced sort that will be appended to the dynamic *         selections by the user. For example, can be used to sort people alphabetically *         after some other user-selected sort that results in rows with the same value  *         like dates or money due. It can help prevent data from appearing as though it  *         has a random secondary sort. Default value: null. *  * @option Boolean sortLocaleCompare (optional) Boolean flag indicating whatever *         to use String.localeCampare method or not. Default set to true. *  *  * @option Array sortAppend (optional) An array containing forced sorting rules. *         This option let's you specify a default sorting rule, which is *         appended to user-selected rules. Default value: null *  * @option Boolean widthFixed (optional) Boolean flag indicating if tablesorter *         should apply fixed widths to the table columns. This is usefull when *         using the pager companion plugin. This options requires the dimension *         jquery plugin. Default value: false *  * @option Boolean cancelSelection (optional) Boolean flag indicating if *         tablesorter should cancel selection of the table headers text. *         Default value: true *  * @option Boolean debug (optional) Boolean flag indicating if tablesorter *         should display debuging information usefull for development. *  *  jQuery *  *   *  * @cat Plugins/Tablesorter *  *  /christian.bach@polyester.se */
(function ($) {    $.extend({        tablesorter: new        function () {
            var parsers = [],                widgets = [];
            this.defaults = {                cssHeader: header,                cssAsc: headerSortUp,                cssDesc: headerSortDown,                cssChildRow: expand-child,                sortInitialOrder: asc,                sortMultiSortKey: shiftKey,                sortForce: null,                sortAppend: null,                sortLocaleCompare: true,                textExtraction: simple,                parsers: {}, widgets: [],                widgetZebra: {                    css: [even, odd]                }, headers: {}, widthFixed: false,                cancelSelection: true,                sortList: [],                headerList: [],                dateFormat: us,                decimal: /|/g,                onRenderHeader: null,                selectorHeaders: thead th,                debug: false            };
            /* debuging utils */
            function benchmark(s, d) {                log(s + , + (new Date().getTime() - d.getTime()) + ms);            }
            this.benchmark = benchmark;
            function log(s) {                if (typeof console != undefined && typeof console.debug != undefined) {                    console.log(s);                } else {                    alert(s);                }            }
            /* parsers utils */
            function buildParserCache(table, $headers) {
                if (table.config.debug) {                    var parsersDebug = ;                }
                if (table.tBodies.length == 0) return;  In the case of empty tables                var rows = table.tBodies[0].rows;
                if (rows[0]) {
                    var list = [],                        cells = rows[0].cells,                        l = cells.length;
                    for (var i = 0; i < l; i++) {
                        var p = false;
                        if ($.metadata && ($($headers[i]).metadata() && $($headers[i]).metadata().sorter)) {
                            p = getParserById($($headers[i]).metadata().sorter);
                        } else if ((table.config.headers[i] && table.config.headers[i].sorter)) {
                            p = getParserById(table.config.headers[i].sorter);                        }                        if (!p) {
                            p = detectParserForColumn(table, rows, -1, i);                        }
                        if (table.config.debug) {                            parsersDebug += column: + i +  parser: + p.id + ;                        }
                        list.push(p);                    }                }
                if (table.config.debug) {                    log(parsersDebug);                }
                return list;            };
            function detectParserForColumn(table, rows, rowIndex, cellIndex) {                var l = parsers.length,                    node = false,                    nodeValue = false,                    keepLooking = true;                while (nodeValue ==  && keepLooking) {                    rowIndex++;                    if (rows[rowIndex]) {                        node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);                        nodeValue = trimAndGetNodeText(table.config, node);                        if (table.config.debug) {                            log(Checking if value was empty on row: + rowIndex);                        }                    } else {                        keepLooking = false;                    }                }                for (var i = 1; i < l; i++) {                    if (parsers[i].is(nodeValue, table, node)) {                        return parsers[i];                    }                }                 0 is always the generic parser (text)                return parsers[0];            }
            function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {                return rows[rowIndex].cells[cellIndex];            }
            function trimAndGetNodeText(config, node) {                return $.trim(getElementText(config, node));            }
            function getParserById(name) {                var l = parsers.length;                for (var i = 0; i < l; i++) {                    if (parsers[i].id.toLowerCase() == name.toLowerCase()) {                        return parsers[i];                    }                }                return false;            }
            /* utils */
            function buildCache(table) {
                if (table.config.debug) {                    var cacheTime = new Date();                }
                var totalRows = (table.tBodies[0] && table.tBodies[0].rows.length) || 0,                    totalCells = (table.tBodies[0].rows[0] && table.tBodies[0].rows[0].cells.length) || 0,                    parsers = table.config.parsers,                    cache = {                        row: [],                        normalized: []                    };
                for (var i = 0; i < totalRows; ++i) {
                                        var c = $(table.tBodies[0].rows[i]),                        cols = [];
                     if this is a child row, add it to the last row's children and                     continue to the next row                    if (c.hasClass(table.config.cssChildRow)) {                        cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);                         go to the next for loop                        continue;                    }
                    cache.row.push(c);
                    for (var j = 0; j < totalCells; ++j) {                        cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));                    }
                    cols.push(cache.normalized.length);  add position for rowCache                    cache.normalized.push(cols);                    cols = null;                };
                if (table.config.debug) {                    benchmark(Building cache for  + totalRows +  rows:, cacheTime);                }
                return cache;            };
            function getElementText(config, node) {            	                if (!node) return ;                		        var $node = $(node),		            data = $node.attr(data-sort-value);		        if (data !== undefined) return data;
                var text = ;
                if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;
                if (config.textExtraction == simple) {                    if (config.supportsTextContent) {                        text = node.textContent;                    } else {                        if (node.childNodes[0] && node.childNodes[0].hasChildNodes()) {                            text = node.childNodes[0].innerHTML;                        } else {                            text = node.innerHTML;                        }                    }                } else {                    if (typeof(config.textExtraction) == function) {                        text = config.textExtraction(node);                    } else {                        text = $(node).text();                    }                }                return text;            }
            function appendToTable(table, cache) {
                if (table.config.debug) {                    var appendTime = new Date()                }
                var c = cache,                    r = c.row,                    n = c.normalized,                    totalRows = n.length,                    checkCell = (n[0].length - 1),                    tableBody = $(table.tBodies[0]),                    rows = [];

                for (var i = 0; i < totalRows; i++) {                    var pos = n[i][checkCell];
                    rows.push(r[pos]);
                    if (!table.config.appender) {
                        var o = ;                        var l = r[pos].length;                        for (var j = 0; j < l; j++) {                            tableBody[0].appendChild(r[pos][j]);                        }
                                             }                }


                if (table.config.appender) {
                    table.config.appender(table, rows);                }
                rows = null;
                if (table.config.debug) {                    benchmark(Rebuilt table:, appendTime);                }
                 apply table widgets                applyWidget(table);
                 trigger sortend                setTimeout(function () {                    $(table).trigger(sortEnd);                }, 0);
            };
            function buildHeaders(table) {
                if (table.config.debug) {                    var time = new Date();                }
                var meta = ($.metadata) ? true : false;                                var header_index = computeTableHeaderCellIndexes(table);
                var $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {
                    this.column = header_index[this.parentNode.rowIndex + - + this.cellIndex];                     this.column = index;                    this.order = formatSortingOrder(table.config.sortInitialOrder);                    										this.count = this.order;
                    if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;					if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);
                    if (!this.sortDisabled) {                        var $th = $(this).addClass(table.config.cssHeader);                        if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);                    }
                     add cell to headerList                    table.config.headerList[index] = this;                });
                if (table.config.debug) {                    benchmark(Built headers:, time);                    log($tableHeaders);                }
                return $tableHeaders;
            };
             from:             http://www.javascripttoolbox.com/lib/table/examples.php             http://www.javascripttoolbox.com/temp/table_cellindex.html

            function computeTableHeaderCellIndexes(t) {                var matrix = [];                var lookup = {};                var thead = t.getElementsByTagName(THEAD)[0];                var trs = thead.getElementsByTagName(TR);
                for (var i = 0; i < trs.length; i++) {                    var cells = trs[i].cells;                    for (var j = 0; j < cells.length; j++) {                        var c = cells[j];
                        var rowIndex = c.parentNode.rowIndex;                        var cellId = rowIndex + - + c.cellIndex;                        var rowSpan = c.rowSpan || 1;                        var colSpan = c.colSpan || 1                        var firstAvailCol;                        if (typeof(matrix[rowIndex]) == undefined) {                            matrix[rowIndex] = [];                        }                         Find first available column in the first row                        for (var k = 0; k < matrix[rowIndex].length + 1; k++) {                            if (typeof(matrix[rowIndex][k]) == undefined) {                                firstAvailCol = k;                                break;                            }                        }                        lookup[cellId] = firstAvailCol;                        for (var k = rowIndex; k < rowIndex + rowSpan; k++) {                            if (typeof(matrix[k]) == undefined) {                                matrix[k] = [];                            }                            var matrixrow = matrix[k];                            for (var l = firstAvailCol; l < firstAvailCol + colSpan; l++) {                                matrixrow[l] = x;                            }                        }                    }                }                return lookup;            }
            function checkCellColSpan(table, rows, row) {                var arr = [],                    r = table.tHead.rows,                    c = r[row].cells;
                for (var i = 0; i < c.length; i++) {                    var cell = c[i];
                    if (cell.colSpan > 1) {                        arr = arr.concat(checkCellColSpan(table, headerArr, row++));                    } else {                        if (table.tHead.length == 1 || (cell.rowSpan > 1 || !r[row + 1])) {                            arr.push(cell);                        }                         headerArr[row] = (i+row);                    }                }                return arr;            };
            function checkHeaderMetadata(cell) {                if (($.metadata) && ($(cell).metadata().sorter === false)) {                    return true;                };                return false;            }
            function checkHeaderOptions(table, i) {                if ((table.config.headers[i]) && (table.config.headers[i].sorter === false)) {                    return true;                };                return false;            }						 function checkHeaderOptionsSortingLocked(table, i) {                if ((table.config.headers[i]) && (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder;                return false;            }			            function applyWidget(table) {                var c = table.config.widgets;                var l = c.length;                for (var i = 0; i < l; i++) {
                    getWidgetById(c[i]).format(table);                }
            }
            function getWidgetById(name) {                var l = widgets.length;                for (var i = 0; i < l; i++) {                    if (widgets[i].id.toLowerCase() == name.toLowerCase()) {                        return widgets[i];                    }                }            };
            function formatSortingOrder(v) {                if (typeof(v) != Number) {                    return (v.toLowerCase() == desc) ? 1 : 0;                } else {                    return (v == 1) ? 1 : 0;                }            }
            function isValueInArray(v, a) {                var l = a.length;                for (var i = 0; i < l; i++) {                    if (a[i][0] == v) {                        return true;                    }                }                return false;            }
            function setHeadersCss(table, $headers, list, css) {                 remove all header information                $headers.removeClass(css[0]).removeClass(css[1]);
                var h = [];                $headers.each(function (offset) {                    if (!this.sortDisabled) {                        h[this.column] = $(this);                    }                });
                var l = list.length;                for (var i = 0; i < l; i++) {                    h[list[i][0]].addClass(css[list[i][1]]);                }            }
            function fixColumnWidth(table, $headers) {                var c = table.config;                if (c.widthFixed) {                    var colgroup = $(<colgroup>);                    $(tr:first td, table.tBodies[0]).each(function () {                        colgroup.append($(<col>).css(width, $(this).width()));                    });                    $(table).prepend(colgroup);                };            }
            function updateHeaderSortCount(table, sortList) {                var c = table.config,                    l = sortList.length;                for (var i = 0; i < l; i++) {                    var s = sortList[i],                        o = c.headerList[s[0]];                    o.count = s[1];                    o.count++;                }            }
            /* sorting methods */                        var sortWrapper;
            function multisort(table, sortList, cache) {
                if (table.config.debug) {                    var sortTime = new Date();                }
                var dynamicExp = sortWrapper = function(a,b) {,                    l = sortList.length;
                 TODO: inline functions.                for (var i = 0; i < l; i++) {
                    var c = sortList[i][0];                    var order = sortList[i][1];                     var s = (getCachedSortType(table.config.parsers,c) == ""text"") ?                     ((order == 0) ? ""sortText"" : ""sortTextDesc"") : ((order == 0) ?                     ""sortNumeric"" : ""sortNumericDesc"");                     var s = (table.config.parsers[c].type == ""text"") ? ((order == 0)                     ? makeSortText(c) : makeSortTextDesc(c)) : ((order == 0) ?                     makeSortNumeric(c) : makeSortNumericDesc(c));                    var s = (table.config.parsers[c].type == text) ? ((order == 0) ? makeSortFunction(text, asc, c) : makeSortFunction(text, desc, c)) : ((order == 0) ? makeSortFunction(numeric, asc, c) : makeSortFunction(numeric, desc, c));                    var e = e + i;
                    dynamicExp += var  + e +  =  + s;  + ""(a["" + c + ""],b["" + c                     + ""]); "";                    dynamicExp += if( + e + ) { return  + e + ; } ;                    dynamicExp += else { ;
                }
                 if value is the same keep orignal order                var orgOrderCol = cache.normalized[0].length - 1;                dynamicExp += return a[ + orgOrderCol + ]-b[ + orgOrderCol + ];;
                for (var i = 0; i < l; i++) {                    dynamicExp += }; ;                }
                dynamicExp += return 0; ;                dynamicExp += }; ;
                if (table.config.debug) {                    benchmark(Evaling expression: + dynamicExp, new Date());                }
                eval(dynamicExp);
                cache.normalized.sort(sortWrapper);
                if (table.config.debug) {                    benchmark(Sorting on  + sortList.toString() +  and dir  + order +  time:, sortTime);                }
                return cache;            };
            function makeSortFunction(type, direction, index) {                var a = a[ + index + ],                    b = b[ + index + ];                if (type == text && direction == asc) {                    return ( + a +  ==  + b +  ? 0 : ( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY : ( + a +  <  + b + ) ? -1 : 1 )));;                } else if (type == text && direction == desc) {                    return ( + a +  ==  + b +  ? 0 : ( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY : ( + b +  <  + a + ) ? -1 : 1 )));;                } else if (type == numeric && direction == asc) {                    return ( + a +  === null &&  + b +  === null) ? 0 :( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY :  + a +  -  + b + ));;                } else if (type == numeric && direction == desc) {                    return ( + a +  === null &&  + b +  === null) ? 0 :( + a +  === null ? Number.POSITIVE_INFINITY : ( + b +  === null ? Number.NEGATIVE_INFINITY :  + b +  -  + a + ));;                }            };
            function makeSortText(i) {                return ((a[ + i + ] < b[ + i + ]) ? -1 : ((a[ + i + ] > b[ + i + ]) ? 1 : 0));;            };
            function makeSortTextDesc(i) {                return ((b[ + i + ] < a[ + i + ]) ? -1 : ((b[ + i + ] > a[ + i + ]) ? 1 : 0));;            };
            function makeSortNumeric(i) {                return a[ + i + ]-b[ + i + ];;            };
            function makeSortNumericDesc(i) {                return b[ + i + ]-a[ + i + ];;            };
            function sortText(a, b) {                if (table.config.sortLocaleCompare) return a.localeCompare(b);                return ((a < b) ? -1 : ((a > b) ? 1 : 0));            };
            function sortTextDesc(a, b) {                if (table.config.sortLocaleCompare) return b.localeCompare(a);                return ((b < a) ? -1 : ((b > a) ? 1 : 0));            };
            function sortNumeric(a, b) {                return a - b;            };
            function sortNumericDesc(a, b) {                return b - a;            };
            function getCachedSortType(parsers, i) {                return parsers[i].type;            }; /* public methods */            this.construct = function (settings) {                return this.each(function () {                     if no thead or tbody quit.                    if (!this.tHead || !this.tBodies) return;                     declare                    var $this, $document, $headers, cache, config, shiftDown = 0,                        sortOrder;                     new blank config object                    this.config = {};                     merge and extend.                    config = $.extend(this.config, $.tablesorter.defaults, settings);                     store common expression for speed                    $this = $(this);                     save the settings where they read                    $.data(this, tablesorter, config);                     build headers                    $headers = buildHeaders(this);                     try to auto detect column type, and store in tables config                    this.config.parsers = buildParserCache(this, $headers);                     build the cache for the tbody cells                    cache = buildCache(this);                     get the css class names, could be done else where.                    var sortCSS = [config.cssDesc, config.cssAsc];                     fixate columns if the users supplies the fixedWidth option                    fixColumnWidth(this);                     apply event handling to headers                     this is to big, perhaps break it out?                    $headers.click(
                    function (e) {                        var totalRows = ($this[0].tBodies[0] && $this[0].tBodies[0].rows.length) || 0;                        if (!this.sortDisabled && totalRows > 0) {                             Only call sortStart if sorting is                             enabled.                            $this.trigger(sortStart);                             store exp, for speed                            var $cell = $(this);                             get current column index                            var i = this.column;                             get current column sort order                            this.order = this.count++ % 2;							 always sort on the locked order.							if(this.lockedOrder) this.order = this.lockedOrder;														 user only whants to sort on one                             column                            if (!e[config.sortMultiSortKey]) {                                 flush the sort list                                config.sortList = [];                                if (config.sortForce != null) {                                    var a = config.sortForce;                                    for (var j = 0; j < a.length; j++) {                                        if (a[j][0] != i) {                                            config.sortList.push(a[j]);                                        }                                    }                                }                                 add column to sort list                                config.sortList.push([i, this.order]);                                 multi column sorting                            } else {                                 the user has clicked on an all                                 ready sortet column.                                if (isValueInArray(i, config.sortList)) {                                     revers the sorting direction                                     for all tables.                                    for (var j = 0; j < config.sortList.length; j++) {                                        var s = config.sortList[j],                                            o = config.headerList[s[0]];                                        if (s[0] == i) {                                            o.count = s[1];                                            o.count++;                                            s[1] = o.count % 2;                                        }                                    }                                } else {                                     add column to sort list array                                    config.sortList.push([i, this.order]);                                }                            };                            setTimeout(function () {                                 set css for headers                                setHeadersCss($this[0], $headers, config.sortList, sortCSS);                                appendToTable(	                                $this[0], multisort(	                                $this[0], config.sortList, cache)								);                            }, 1);                             stop normal event by returning false                            return false;                        }                         cancel selection                    }).mousedown(function () {                        if (config.cancelSelection) {                            this.onselectstart = function () {                                return false                            };                            return false;                        }                    });                     apply easy methods that trigger binded events                    $this.bind(update, function () {                        var me = this;                        setTimeout(function () {                             rebuild parsers.                            me.config.parsers = buildParserCache(                            me, $headers);                             rebuild the cache map                            cache = buildCache(me);                        }, 1);                    }).bind(updateCell, function (e, cell) {                        var config = this.config;                         get position from the dom.                        var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex];                         update cache                        cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(                        getElementText(config, cell), cell);                    }).bind(sorton, function (e, list) {                        $(this).trigger(sortStart);                        config.sortList = list;                         update and store the sortlist                        var sortList = config.sortList;                         update header count index                        updateHeaderSortCount(this, sortList);                         set css for headers                        setHeadersCss(this, $headers, sortList, sortCSS);                         sort the table and append it to the dom                        appendToTable(this, multisort(this, sortList, cache));                    }).bind(appendCache, function () {                        appendToTable(this, cache);                    }).bind(applyWidgetId, function (e, id) {                        getWidgetById(id).format(this);                    }).bind(applyWidgets, function () {                         apply widgets                        applyWidget(this);                    });                    if ($.metadata && ($(this).metadata() && $(this).metadata().sortlist)) {                        config.sortList = $(this).metadata().sortlist;                    }                     if user has supplied a sort list to constructor.                    if (config.sortList.length > 0) {                        $this.trigger(sorton, [config.sortList]);                    }                     apply widgets                    applyWidget(this);                });            };            this.addParser = function (parser) {                var l = parsers.length,                    a = true;                for (var i = 0; i < l; i++) {                    if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {                        a = false;                    }                }                if (a) {                    parsers.push(parser);                };            };            this.addWidget = function (widget) {                widgets.push(widget);            };            this.formatFloat = function (s) {                var i = parseFloat(s);                return (isNaN(i)) ? 0 : i;            };            this.formatInt = function (s) {                var i = parseInt(s);                return (isNaN(i)) ? 0 : i;            };            this.isDigit = function (s, config) {                 replace all an wanted chars and match.                return .test($.trim(s.replace(g, )));            };            this.clearTableBody = function (table) {                if ($.browser.msie) {                    while (table.tBodies[0].firstChild) {                        table.tBodies[0].removeChild(table.tBodies[0].firstChild);                    }                } else {                    table.tBodies[0].innerHTML = ;                }            };        }    });
     extend plugin scope    $.fn.extend({        tablesorter: $.tablesorter.construct    });
     make shortcut    var ts = $.tablesorter;
     add default parsers    ts.addParser({        id: text,        is: function (s) {            return true;        }, format: function (s) {            return $.trim(s.toLocaleLowerCase());        }, type: text    });
    ts.addParser({        id: digit,        is: function (s, table) {            var c = table.config;            return $.tablesorter.isDigit(s, c);        }, format: function (s) {            return $.tablesorter.formatFloat(s);        }, type: numeric    });
    ts.addParser({        id: currency,        is: function (s) {            return .test(s);        }, format: function (s) {            return $.tablesorter.formatFloat(s.replace(new RegExp(g), ));        }, type: numeric    });
    ts.addParser({        id: ipAddress,        is: function (s) {            return .test(s);        }, format: function (s) {            var a = s.split(.),                r = ,                l = a.length;            for (var i = 0; i < l; i++) {                var item = a[i];                if (item.length == 2) {                    r += 0 + item;                } else {                    r += item;                }            }            return $.tablesorter.formatFloat(r);        }, type: numeric    });
    ts.addParser({        id: url,        is: function (s) {            return (httpsftpfile):.test(s);        }, format: function (s) {            return jQuery.trim(s.replace(new RegExp((httpsftpfile):), ));        }, type: text    });
    ts.addParser({        id: isoDate,        is: function (s) {            return .test(s);        }, format: function (s) {            return $.tablesorter.formatFloat((s != ) ? new Date(s.replace(            new RegExp(-g), /)).getTime() : 0);        }, type: numeric    });
    ts.addParser({        id: percent,        is: function (s) {            return .test($.trim(s));        }, format: function (s) {            return $.tablesorter.formatFloat(s.replace(new RegExp(%g), ));        }, type: numeric    });
    ts.addParser({        id: usLongDate,        is: function (s) {            return s.match(new RegExp( , (') ((:)(:(AMPM)))));        }, format: function (s) {            return $.tablesorter.formatFloat(new Date(s).getTime());        }, type: numeric    });
    ts.addParser({        id: shortDate,        is: function (s) {            return .test(s);        }, format: function (s, table) {            var c = table.config;            s = s.replace(g, /);            if (c.dateFormat == us) {                 reformat the string in ISO format                s = s.replace(()()(), $3/$1/$2);            }                if (c.dateFormat == pt) {                s = s.replace(()()(), $3/$2/$1);               } else if (c.dateFormat == uk) {                 reformat the string in ISO format                s = s.replace(()()(), $3/$2/$1);            } else if (c.dateFormat == dd/mm/yy || c.dateFormat == dd-mm-yy) {                s = s.replace(()()(), $1/$2/$3);            }            return $.tablesorter.formatFloat(new Date(s).getTime());        }, type: numeric    });    ts.addParser({        id: time,        is: function (s) {            return ((:)(:(ampm))).test(s);        }, format: function (s) {            return $.tablesorter.formatFloat(new Date(2000/01/01  + s).getTime());        }, type: numeric    });    ts.addParser({        id: metadata,        is: function (s) {            return false;        }, format: function (s, table, cell) {            var c = table.config,                p = (!c.parserMetadataName) ? sortValue : c.parserMetadataName;            return $(cell).metadata()[p];        }, type: numeric    });     add default widgets    ts.addWidget({        id: zebra,        format: function (table) {            if (table.config.debug) {                var time = new Date();            }            var $tr, row = -1,                odd;             loop through the visible rows            $(tr:visible, table.tBodies[0]).each(function (i) {                $tr = $(this);                 style children rows the same way the parent                 row was styled                if (!$tr.hasClass(table.config.cssChildRow)) row++;                odd = (row % 2 == 0);                $tr.removeClass(                table.config.widgetZebra.css[odd ? 0 : 1]).addClass(                table.config.widgetZebra.css[odd ? 1 : 0])            });            if (table.config.debug) {                $.tablesorter.benchmark(Applying Zebra widget, time);            }        }    });})(jQuery);"
"/* * Metadata - jQuery plugin for parsing metadata from elements * * Copyright (c) 2006 John Resig, Yehuda Katz, J�örn Zaefferer, Paul McLanahan * * Dual licensed under the MIT and GPL licenses: *   http://www.opensource.org/licenses/mit-license.php *   http://www.gnu.org/licenses/gpl.html * * Revision: $Id$ * */
/** * Sets the type of metadata to use. Metadata is encoded in JSON, and each property * in the JSON will become a property of the element itself. * * There are three supported types of metadata storage: * *   attr:  Inside an attribute. The name parameter indicates *which* attribute. *           *   class: Inside the class attribute, wrapped in curly braces: { } *    *   elem:  Inside a child element (e.g. a script tag). The *          name parameter indicates *which* element. *           * The metadata for an element is loaded the first time the element is accessed via jQuery. * * As a result, you can define the metadata type, use $(expr) to load the metadata into the elements * matched by expr, then redefine the metadata type and run another $(expr) for other elements. *  *   * *   * @before $.metadata.setType(""class"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from the class attribute *  *   * @before $.metadata.setType(""attr"", ""data"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from a ""data"" attribute *  *   * @before $.metadata.setType(""elem"", ""script"") * @after $(""#one"").metadata().item_id == 1; $(""#one"").metadata().item_label == ""Label"" *  Reads metadata from a nested script element *  *   type The encoding type *   name The name of the attribute to be used to get metadata (optional) * @cat Plugins/Metadata * @descr Sets the type of encoding to be used when loading metadata for the first time *  undefined *   */
(function($) {
$.extend({	metadata : {		defaults : {			type: class,			name: metadata,			cre: ({}),			single: metadata		},		setType: function( type, name ){			this.defaults.type = type;			this.defaults.name = name;		},		get: function( elem, opts ){			var settings = $.extend({},this.defaults,opts);			 check for empty string in single property			if ( !settings.single.length ) settings.single = metadata;						var data = $.data(elem, settings.single);			 returned cached data if it already exists			if ( data ) return data;						data = {};						if ( settings.type == class ) {				var m = settings.cre.exec( elem.className );				if ( m )					data = m[1];			} else if ( settings.type == elem ) {				if( !elem.getElementsByTagName )					return undefined;				var e = elem.getElementsByTagName(settings.name);				if ( e.length )					data = $.trim(e[0].innerHTML);			} else if ( elem.getAttribute != undefined ) {				var attr = elem.getAttribute( settings.name );				if ( attr )					data = attr;			}						if ( data.indexOf( { ) <0 )			data = { + data + };						data = eval(( + data + ));						$.data( elem, settings.single, data );			return data;		}	}});
/** * Returns the metadata object for the first member of the jQuery object. * *   * @descr Returns element's metadata object *   opts An object contianing settings to override the defaults *  jQuery * @cat Plugins/Metadata */$.fn.metadata = function( opts ){	return $.metadata.get( this[0], opts );};
})(jQuery);"
"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll(left)}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:""script""}):c.globalEval(b.text||b.textContent||b.innerHTML||"""");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b===""object""){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,""events"");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type===""click"")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"""")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType===mouseenter||i.preType===mouseleave)f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return""live.""+(a&&a!==""*""?a+""."":"""")+b.replace(/\./g,""`"").replace(/ /g,&)}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]===""string""&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return""scrollTo""in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,Wa=(00A0)(00A0)g,Xa=<()>(?:<>),P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a===body&&!b){this.context=s;this[0]=s.body;this.selector=body;this.length=1;return this}if(typeof a===string)if((d=Ta.exec(a))&&(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:,jquery:1.4.2,length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===find)f.selector=this.selector+(this.selector? :)+d;else if(b)f.selector=this.selector+.+b+(+d+);return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),slice,R.call(arguments).join(,))},map:function(a){return this.pushStack(c.map(this,function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a===boolean){f=a;a=arguments[1]||{};b=2}if(typeof a!==object&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler(ready)}},bindReady:function(){if(!xa){xa=true;if(s.readyState===complete)return c.ready();if(s.addEventListener){s.addEventListener(DOMContentLoaded,L,false);A.addEventListener(load,c.ready,false)}else if(s.attachEvent){s.attachEvent(onreadystatechange,L);A.attachEvent(onload,c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)===[object Function]},isArray:function(a){return $.call(a)===[object Array]},isPlainObject:function(a){if(!a||$.call(a)!==[object Object]||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,constructor)&&!aa.call(a.constructor.prototype,isPrototypeOf))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!==string||!a)return null;a=c.trim(a);if(.test(a.replace((?:u)g,@).replace(""""truefalsenull-(?:)(?:)g,]).replace((?::,)(?:)g,)))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function(return +a))();else c.error(Invalid JSON: +a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName(head)[0]||s.documentElement,d=s.createElement(script);d.type=text/javascript;if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||).replace(Wa,)},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a===string||c.isFunction(a)||typeof a!==function&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length===number)for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b===string){d=a;a=d[b];b=w}else if(b&&!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=(webkit)().exec(a)||(opera)(?:version)().exec(a)||(msie) ().exec(a)||!compatible.test(a)&&(mozilla)(?: rv:()).exec(a)||[];return{browser:a[1]||,version:a[2]||0}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener(DOMContentLoaded,L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState===complete){s.detachEvent(onreadystatechange,L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement(script),d=s.createElement(div),f=script+J();d.style.display=none;d.innerHTML=   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>;var e=d.getElementsByTagName(*),j=d.getElementsByTagName(a)[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName(tbody).length,htmlSerialize:!!d.getElementsByTagName(link).length,style:red.test(j.getAttribute(style)),hrefNormalized:j.getAttribute(href)===/a,opacity:055.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName(input)[0].value===on,optSelected:s.createElement(select).appendChild(s.createElement(option)).selected,parentNode:d.removeChild(d.appendChild(s.createElement(div))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type=text/javascript;try{b.appendChild(s.createTextNode(window.+f+=1;))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent(onclick,function k(){c.support.noCloneEvent=false;d.detachEvent(onclick,k)});d.cloneNode(true).fireEvent(onclick)}d=s.createElement(div);d.innerHTML=<input type='radio' name='radiotest' checked='checked'/>;a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement(div);k.style.width=k.style.paddingLeft=1px;s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display=none});a=function(k){var n=s.createElement(div);k=on+k;var r=k in n;if(!r){n.setAttribute(k,return;);r=typeof n[k]===function}return r};c.support.submitBubbles=a(submit);c.support.changeBubbles=a(change);a=b=d=e=j=null}})();c.props={for:htmlFor,class:className,readonly:readOnly,maxlength:maxLength,cellspacing:cellSpacing,rowspan:rowSpan,colspan:colSpan,tabindex:tabIndex,usemap:useMap,frameborder:frameBorder};var G=jQuery+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b===string&&d===w)return null;f||(f=++Ya);if(typeof b===object){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b===string?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a===undefined&&this.length)return c.data(this[0]);else if(typeof a===object)return this.each(function(){c.data(this,a)});var d=a.split(.);d[1]=d[1]?.+d[1]:;if(b===w){var f=this.triggerHandler(getData+d[1]+!,[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger(setData+d[1]+!,[d[0],b]).each(function(){c.data(this,a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||fx)+queue;var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||fx;var d=c.queue(a,b),f=d.shift();if(f===inprogress)f=d.shift();if(f){b===fx&&d.unshift(inprogress);f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!==string){b=a;a=fx}if(b===w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a===fx&&d[0]!==inprogress&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||fx;return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||fx,[])}});var Aa=g,ca=,Za=g,$a=hrefsrcstyle,ab=(buttoninput)i,bb=(buttoninputobjectselecttextarea)i,cb=(aarea)i,Ba=radiocheckbox;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,);this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr(class)))});if(a&&typeof a===string)for(var b=(a||).split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j= +e.className+ ,i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf( +b[o]+ )<0)i+= +b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr(class)))});if(a&&typeof a===string||a===w)for(var b=(a||).split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=( +e.className+ ).replace(Aa, ),i=0,o=b.length;i<o;i++)j=j.replace( +b[i]+ , );e.className=c.trim(j)}else e.className=}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b===boolean;if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr(class),b),b)});return this.each(function(){if(d===string)for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?addClass:removeClass](e)}else if(d===undefined||d===boolean){this.className&&c.data(this,__className__,this.className);this.className=this.className||a===false?:c.data(this,__className__)||}})},hasClass:function(a){a= +a+ ;for(var b=0,d=this.length;b<d;b++)if(( +this[b].className+ ).replace(Aa, ).indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,option))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,select)){var d=b.selectedIndex,f=[],e=b.options;b=b.type===select-one;if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute(value)===null?on:b.value;return(b.value||).replace(Za,)}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r===number)r+=;if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,select)){var u=c.makeArray(r);c(option,this).each(function(){this.selected=c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b===type&&ab.test(a.nodeName)&&a.parentNode&&c.error(type property can't be changed);a[b]=d}if(c.nodeName(a,form)&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b===tabIndex)return(b=a.getAttributeNode(tabIndex))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b===style){if(e)a.style.cssText=+d;return a.style.cssText}e&&a.setAttribute(b,+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=(),db=function(a){return a.replace(g,function(b){return+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!==undefined&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split( );for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(.)>-1){r=k.split(.);k=r.shift();j.namespace=r.slice(0).sort().join(.)}else{r=[];j.namespace=}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent(on+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b===string&&b.charAt(0)===.){b=b||;for(e in C)c.event.remove(a,e+b)}else{for(b=b.split( );e=b[j++];){n=e;i=e.indexOf(.)<0;o=[];if(!i){o=e.split(.);e=o.shift();k=new RegExp((^|.)+c.map(o.slice(0).sort(),db).join(.(?:.*.)?)+(.|$))}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a===object?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf(!)>=0){a.type=e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,handle))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d[on+e]&&d[on+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,a)&&e===click,k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f[on+e])f[on+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f[on+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(.)<0&&!a.exclusive;if(!b){d=a.type.split(.);a.type=d.shift();f=new RegExp((^|.)+d.slice(0).sort().join(.(?:.*.)?)+(.|$))}e=c.data(this,events);d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which.split( ),fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,);c.each(c.data(this,events).live||[],function(){if(d===this.origType.replace(O,))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent(on+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:mouseover,mouseleave:mouseout},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==form){c.event.add(this,click.specialSubmit,function(a){var b=a.target,d=b.type;if((d===submit||d===image)&&c(b).closest(form).length)return na(submit,this,arguments)});c.event.add(this,keypress.specialSubmit,function(a){var b=a.target,d=b.type;if((d===text||d===password)&&c(b).closest(form).length&&a.keyCode===13)return na(submit,this,arguments)})}else return false},teardown:function(){c.event.remove(this,.specialSubmit)}};if(!c.support.changeBubbles){var da=textareainputselecti,ea,Fa=function(a){var b=a.type,d=a.value;if(b===radio||b===checkbox)d=a.checked;else if(b===select-multiple)d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join(-):;else if(a.nodeName.toLowerCase()===select)d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,_change_data);e=Fa(d);if(a.type!==focusout||d.type!==radio)c.data(d,_change_data,e);if(!(f===w||e===f))if(f!=null||e){a.type=change;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d===radio||d===checkbox||b.nodeName.toLowerCase()===select)return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!==textarea||a.keyCode===32&&(d===checkbox||d===radio)||d===select-multiple)return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,_change_data,Fa(a))}},setup:function(){if(this.type===file)return false;for(var a in ea)c.event.add(this,a+.specialChange,ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,.specialChange);return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:focusin,blur:focusout},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each([bind,one],function(a,b){c.fn[b]=function(d,f,e){if(typeof d===object){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b===one?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d===unload&&b!==one)this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a===object&&!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind(live):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,lastToggle+a.guid)||0)%d;c.data(this,lastToggle+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:focusin,blur:focusout,mouseenter:mouseover,mouseleave:mouseout};c.each([live,die],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||).split( );(i=d[o++])!=null;){j=O.exec(i);k=;if(j){k=j[0];i=i.replace(O,)}if(i===hover)d.push(mouseenter+k,mouseleave+k);else{n=i;if(i===focus||i===blur){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b===live?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each(blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error.split( ),function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent(onunload,function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h=,l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!==""string""){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['""][^'""]*['""]|[^[\]'""]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!==string)return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]===~||p[0]===+)&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D=;if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||g);if(j.call(y)===[object Array])if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!==){q[1]=(q[1]||).replace(g,);m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],);break}}}}m||(m=h.getElementsByTagName(*));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-1)!==){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],);if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throwSyntax error, unrecognized expression: +g;};var n=k.selectors={order:[ID,NAME,TAG],match:{ID:#((?:)),CLASS:((?:)),NAME:name=((?:)),ATTR:((?:))(?:(=)()()),TAG:((?:)),CHILD::(onlynthlastfirst)-child(?:(evenodd)),POS::(ntheqgtltfirstlastevenodd)(?:())(?=),PSEUDO::((?:))(?:()((?:)))},leftMatch:{},attrMap:{class:className,for:htmlFor},attrHandle:{href:function(g){return g.getAttribute(href)}},relative:{:function(g,h){var l=typeof h===string,m=l&&!.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},:function(g,h){var l=typeof h===string;if(l&&!.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},:function(g,h,l){var m=e++,q=d;if(typeof h===string&&!.test(h)){var p=h=h.toLowerCase();q=b}q(parentNode,h,m,g,p,l)},:function(g,h,l){var m=e++,q=d;if(typeof h===string&&!.test(h)){var p=h=h.toLowerCase();q=b}q(previousSibling,h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!==undefined&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!==undefined){var l=[];h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute(name)===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g= +g[1].replace(g,)+ ;if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&( +v.className+ ).replace(g, ).indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(g,)},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]===nth){var h=(-)()n((?:-)).exec(g[2]===even&&2n||g[2]===odd&&2n+1||!.test(g[2])&&0n++g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(g,);if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]===~=)g[4]= +g[4]+ ;return g},PSEUDO:function(g,h,l,m,q){if(g[1]===not)if((f.exec(g[3])||).length>1||.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!==hidden},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){returnhi.test(g.nodeName)},text:function(g){returntext===g.type},radio:function(g){returnradio===g.type},checkbox:function(g){returncheckbox===g.type},file:function(g){returnfile===g.type},password:function(g){returnpassword===g.type},submit:function(g){returnsubmit===g.type},image:function(g){returnimage===g.type},reset:function(g){returnreset===g.type},button:function(g){returnbutton===g.type||g.nodeName.toLowerCase()===button},input:function(g){returninputselecttextareabuttoni.test(g.nodeName)}},setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q===contains)return(g.textContent||g.innerText||a([g])||).indexOf(h[3])>=0;else if(q===not){h=h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error(Syntax error, unrecognized expression: +q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case only:case first:for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l===first)return true;m=g;case last:for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case nth:l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute(id)===h},TAG:function(g,h){return h===*&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return( +(g.className||g.getAttribute(class))+ ).indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+;var m=h[2];h=h[4];return g==null?m===!=:m====?l===h:m===*=?l.indexOf(h)>=0:m===~=?( +l+ ).indexOf(h)>=0:!h?l&&g!==false:m===!=?l!==h:m===^=?l.indexOf(h)===0:m===$=?l.substr(l.length-h.length)===h:m===|=?l===h||l.substr(0,h.length+1)===h+-:false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+(?!)(?!).source);n.leftMatch[u]=new RegExp(((?:)).source+n.match[u].source.replace(()g,function(g,h){return+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)===[object Array])Array.prototype.push.apply(h,g);else if(typeof g.length===number)for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if(sourceIndexin s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement(div),h=script+(new Date).getTime();g.innerHTML=<a name='+h+'/>;var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!==undefined&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!==undefined&&q.getAttributeNode(id).nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!==undefined&&m.getAttributeNode(id);return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement(div);g.appendChild(s.createComment());if(g.getElementsByTagName(*).length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]===*){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML=<a href='#'></a>;if(g.firstChild&&typeof g.firstChild.getAttribute!==undefined&&g.firstChild.getAttribute(href)!==#)n.attrHandle.href=function(h){return h.getAttribute(href,2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement(div);h.innerHTML=<p class='TEST'></p>;if(!(h.querySelectorAll&&h.querySelectorAll(.TEST).length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();(function(){var g=s.createElement(div);g.innerHTML=<div class='test e'></div><div class='test'></div>;if(!(!g.getElementsByClassName||g.getElementsByClassName(e).length===0)){g.lastChild.className=e;if(g.getElementsByClassName(e).length!==1){n.order.splice(1,0,CLASS);n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!==undefined&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!==HTML:false},ga=function(g,h){var l=[],m=,q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,)}g=n.relative[g]?g+*:g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[:]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=Until,fb=(?:parentsprevUntilprevAll),gb=,;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b===string){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack(,find,a),d=0,f=0,e=this.length;f<e;f++){d=b.length;c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),not,a)},filter:function(a){return this.pushStack(Ia(this,a,true),filter,a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j={},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===string)return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a===string?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,parentNode)},parentsUntil:function(a,b,d){return c.dir(a,parentNode,d)},next:function(a){return c.nth(a,2,nextSibling)},prev:function(a){return c.nth(a,2,previousSibling)},nextAll:function(a){return c.dir(a,nextSibling)},prevAll:function(a){return c.dir(a,previousSibling)},nextUntil:function(a,b,d){return c.dir(a,nextSibling,d)},prevUntil:function(a,b,d){return c.dir(a,previousSibling,d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,iframe)?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f===string)e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(,))}});c.extend({filter:function(a,b,d){if(d)a=:not(+a+);return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja= jQuery=""(?:null)""g,V=,Ka=(<())>g,hb=(?:areabrcolembedhrimginputlinkmetaparam)i,La=<(),ib=<tbodyi,jb=<&#;,ta=<script<object<embed<option<stylei,ua=checked(?:=checked)i,Ma=function(a,b,d){return hb.test(d)?a:b+></+d+>},F={option:[1,<select multiple='multiple'>,</select>],legend:[1,<fieldset>,</fieldset>],thead:[1,<table>,</table>],tr:[2,<table><tbody>,</tbody></table>],td:[3,<table><tbody><tr>,</tr></tbody></table>],col:[2,<table><tbody></tbody><colgroup>,</colgroup></table>],area:[1,<map>,</map>],_default:[0,,]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,div<div>,</div>];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=c(this);d.text(a.call(this,b,d.text()))});if(typeof a!==object&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,body)||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,before,arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,after,arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName(*));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName(*));b.firstChild;)b.removeChild(b.firstChild);return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement(div);d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,).replace(=()>g,=""$1"">).replace(V,)],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find(*),b.find(*))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,):null;else if(typeof a===string&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||[,])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName(*));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!==string)a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),replaceWith,a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,table)?u.getElementsByTagName(tbody)[0]||u.appendChild(u.ownerDocument.createElement(tbody)):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i===string&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,tr);for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:append,prependTo:prepend,insertBefore:before,insertAfter:after,replaceAll:replaceWith},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement===undefined)b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i===number)i+=;if(i){if(typeof i===string&&!jb.test(i))i=b.createTextNode(i);else if(typeof i===string){i=i.replace(Ka,Ma);var o=(La.exec(i)||[,])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement(div);for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o===table&&!n?r.firstChild&&r.firstChild.childNodes:k[1]===<table>&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],tbody)&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],script)&&(!e[j].type||e[j].type.toLowerCase()===text/javascript))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName(script))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=z-indexfont-weightopacityzoomline-heighti,Na=alpha,Oa=opacity=(),ha=floati,ia=-()ig,lb=()g,mb=-(?:px)i,nb=-,ob={position:absolute,visibility:hidden,display:block},pb=[Left,Right],qb=[Top,Bottom],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?cssFloat:styleFloat,ja=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e===number&&!kb.test(f))e+=px;c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b===width||b===height)&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b===opacity){if(e){f.zoom=1;b=parseInt(d,10)+===NaN?:alpha(opacity=+d*100+);a=f.filter||c.curCSS(a,filter)||;f.filter=Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf(opacity=)>=0?parseFloat(Oa.exec(f.filter)[1])/100+:}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b===width||b===height){var e,j=b===width?pb:qb;function i(){e=b===width?a.offsetWidth:a.offsetHeight;f!==border&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,padding+this,true))||0);if(f===margin)e+=parseFloat(c.curCSS(a,margin+this,true))||0;else e-=parseFloat(c.curCSS(a,border+this+Width,true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b===opacity&&a.currentStyle){f=Oa.test(a.currentStyle.filter||)?parseFloat(RegExp.$1)/100+:;return f===?1:f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b=float;b=b.replace(lb,-$1).toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=a.getPropertyValue(b);if(b===opacity&&f===)f=1}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d===fontSize?1em:f||0;f=e.pixelLeft+px;e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()===tr;return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,display)===none};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=<script()script>gi,ub=selecttextareai,vb=colordatedatetimeemailhiddenmonthnumberpasswordrangesearchteltexttimeurlweeki,N==(&),ka=,wb=(&)_=(&),xb=(:)(),yb=%20g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==string)return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf( );if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f=GET;if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===object){b=c.param(b,c.ajaxSettings.traditional);f=POST}var j=this;c.ajax({url:a,type:f,dataType:html,data:b,complete:function(i,o){if(o===success||o===notmodified)j.html(e?c(<div />).append(i.responseText.replace(tb,)).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each(ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend.split( ),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:GET,url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,script)},getJSON:function(a,b,d){return c.get(a,b,d,json)},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:POST,url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:GET,contentType:application/x-www-form-urlencoded,processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!==file:||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject(Microsoft.XMLHTTP)}catch(a){}},accepts:{xml:application/xml, text/xml,html:text/html,script:text/javascript, application/javascript,json:application/json, text/javascript,text:text/plain,_default:*/*}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&e.success.call(k,o,i,x);e.global&&f(ajaxSuccess,[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f(""ajaxComplete"",[x,e]);e.global&&!--c.active&&c.event.trigger(""ajaxStop"")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!==""string"")e.data=c.param(e.data,e.traditional);if(e.dataType===""jsonp""){if(n===""GET"")N.test(e.url)||(e.url+=(ka.test(e.url)?&:?)+(e.jsonp||callback)+=?);else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+&:)+(e.jsonp||callback)+=?;e.dataType=json}if(e.dataType===json&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||jsonp+sb++;if(e.data)e.data=(e.data+).replace(N,=+j+$1);e.url=e.url.replace(N,=+j+$1);e.dataType=script;A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType===script&&e.cache===null)e.cache=false;if(e.cache===false&&n===GET){var r=J(),u=e.url.replace(wb,$1_=+r+$2);e.url=u+(u===e.url?(ka.test(e.url)?&:?)+_=+r:)}if(e.data&&n===GET)e.url+=(ka.test(e.url)?&:?)+e.data;e.global&&!c.active++&&c.event.trigger(ajaxStart);r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType===script&&n===GET&&r){var z=s.getElementsByTagName(head)[0]||s.documentElement,C=s.createElement(script);C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState===loaded||this.readyState===complete)){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader(Content-Type,e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader(If-Modified-Since,c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader(If-None-Match,c.etag[e.url])}r||x.setRequestHeader(X-Requested-With,XMLHttpRequest);x.setRequestHeader(Accept,e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+, */*:e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger(ajaxStop);x.abort();return false}e.global&&f(ajaxSend,[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q===abort){E||d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q===timeout)){E=true;x.onreadystatechange=c.noop;i=q===timeout?timeout:!c.httpSuccess(x)?error:e.ifModified&&c.httpNotModified(x,e.url)?notmodified:success;var p;if(i===success)try{o=c.httpData(x,e.dataType,e)}catch(v){i=parsererror;p=v}if(i===success||i===notmodified)j||b();else c.handleError(e,x,i,p);d();q===timeout&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);g(abort)}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g(timeout)},e.timeout);try{x.send(n===POST||n===PUT||n===DELETE?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger(ajaxError,[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol===file:||a.status>=200&&a.status<300||a.status===304||a.status===1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader(Last-Modified),f=a.getResponseHeader(Etag);if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader(content-type)||,e=b===xml||!b&&f.indexOf(xml)>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName===parsererror&&c.error(parsererror);if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a===string)if(b===json||!b&&f.indexOf(json)>=0)a=c.parseJSON(a);else if(b===script||!b&&f.indexOf(javascript)>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||.test(i)?f(i,n):d(i+[+(typeof n===object||c.isArray(n)?k:)+],n)});else!b&&o!=null&&typeof o===object?c.each(o,function(k,n){d(i+[+k+],n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+""=""+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join(&).replace(yb,+)}});var la={},Ab=toggleshowhide,Bb=(=)()(),W,va=[[height,marginTop,marginBottom,paddingTop,paddingBottom],[width,marginLeft,marginRight,paddingLeft,paddingRight],[opacity]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K(show,3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],olddisplay);this[a].style.display=d||;if(c.css(this[a],display)===none){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c(<+d+ />).appendTo(body);f=e.css(display);if(f===none)f=block;e.remove();la[d]=f}c.data(this[a],olddisplay,f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],olddisplay)||;return this}},hide:function(a,b){if(a||a===0)return this.animate(K(hide,3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],olddisplay);!d&&d!==none&&c.data(this[a],olddisplay,c.css(this[a],display))}a=0;for(b=this.length;a<b;a++)this[a].style.display=none;return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a===boolean;if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(:hidden);c(this)[f?show:hide]()}):this.animate(K(toggle,3),a,b);return this},fadeTo:function(a,b,d){return this.filter(:hidden).css(opacity,0).show().end().animate({opacity:b},a,d)},animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?each:queue](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(:hidden),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]===hide&&o||a[i]===show&&!o)return j.complete.call(this);if((i===height||i===width)&&this.style){j.display=c.css(this,display);j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow=hidden;j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u===toggle?o?show:hide:u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||px;if(E!==px){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]===-=?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,)}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K(show,1),slideUp:K(hide,1),slideToggle:K(toggle,1),fadeIn:{opacity:show},fadeOut:{opacity:hide}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a===object?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===number?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this);if((this.prop===height||this.prop===width)&&this.elem.style)this.elem.style.display=block},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||px;this.now=this.start;this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop===width||this.prop===height?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,olddisplay);this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,display)===none)this.elem.style.display=block}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?swing:linear);this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,opacity,a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop===width||a.prop===height?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset=getBoundingClientRectin s.documentElement?function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position===fixed)break;j=e?e.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&t(abledh)i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!==visible){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position===relative||f.position===static){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&f.position===fixed){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement(div),d,f,e,j=parseFloat(c.curCSS(a,marginTop,true))||0;c.extend(b.style,{position:absolute,top:0,left:0,margin:0,border:0,width:1px,height:1px,visibility:hidden});b.innerHTML=<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>;a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position=fixed;f.style.top=20px;this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top=;d.style.overflow=hidden;d.style.position=relative;this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,marginTop,true))||0;d+=parseFloat(c.curCSS(a,marginLeft,true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(static.test(c.curCSS(a,position)))a.style.position=relative;var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,top,true),10)||0,i=parseInt(c.curCSS(a,left,true),10)||0;if(c.isFunction(b))b=b.call(a,d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};usingin b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=bodyhtmli.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,marginTop,true))||0;d.left-=parseFloat(c.curCSS(a,marginLeft,true))||0;f.top+=parseFloat(c.curCSS(b[0],borderTopWidth,true))||0;f.left+=parseFloat(c.curCSS(b[0],borderLeftWidth,true))||0;return{top:d.top-f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!bodyhtmli.test(a.nodeName)&&c.css(a,position)===static;)a=a.offsetParent;return a})}});c.each([Left,Top],function(a,b){var d=scroll+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?pageXOffsetin j?j[a?pageYOffset:pageXOffset]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each([Height,Width],function(a,b){var d=b.toLowerCase();c.fn[inner+b]=function(){return this[0]?c.css(this[0],d,false,padding):null};c.fn[outer+b]=function(f){return this[0]?c.css(this[0],d,false,f?margin:border):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});returnscrollToine&&e.document?e.document.compatMode===CSS1Compat&&e.document.documentElement[client+b]||e.document.body[client+b]:e.nodeType===9?Math.max(e.documentElement[client+b],e.body[scroll+b],e.documentElement[scroll+b],e.body[offset+b],e.documentElement[offset+b]):f===w?c.css(e,d):this.css(d,typeof f===string?f:f+px)}});A.jQuery=A.$=c})(window);"
"/* * jQuery UI Nested Sortable * v 1.3.5 / 21 jun 2012 * http://mjsarfatti.com/code/nestedSortable * * Depends on: *	 jquery.ui.sortable.js 1.8+ * * Copyright (c) 2010-2012 Manuele J Sarfatti * Licensed under the MIT License * http://www.opensource.org/licenses/mit-license.php */
(function($) {
	$.widget(mjs.nestedSortable, $.extend({}, $.ui.sortable.prototype, {
		options: {			tabSize: 20,			disableNesting: mjs-nestedSortable-no-nesting,			errorClass: mjs-nestedSortable-error,			doNotClear: false,			listType: ol,			maxLevels: 0,			protectRoot: false,			rootID: null,			rtl: false,			isAllowed: function(item, parent) { return true; }		},
		_create: function() {			this.element.data(sortable, this.element.data(nestedSortable));
			if (!this.element.is(this.options.listType))				throw new Error(nestedSortable: Please check the listType option is set to your actual list type);
			return $.ui.sortable.prototype._create.apply(this, arguments);		},
		destroy: function() {			this.element				.removeData(nestedSortable)				.unbind(.nestedSortable);			return $.ui.sortable.prototype.destroy.apply(this, arguments);		},
		_mouseDrag: function(event) {
			Compute the helpers position			this.position = this._generatePosition(event);			this.positionAbs = this._convertPositionTo(absolute);
			if (!this.lastPositionAbs) {				this.lastPositionAbs = this.positionAbs;			}
			var o = this.options;
			Do scrolling			if(this.options.scroll) {				var scrolled = false;				if(this.scrollParent[0] != document && this.scrollParent[0].tagName != HTML) {
					if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;					else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;					else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				} else {
					if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);					else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);					else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
				if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)					$.ui.ddmanager.prepareOffsets(this, event);			}
			Regenerate the absolute position used for position checks			this.positionAbs = this._convertPositionTo(absolute);
       Find the top offset before rearrangement,      var previousTopOffset = this.placeholder.offset().top;
			Set the helper position			if(!this.options.axis || this.options.axis != y) this.helper[0].style.left = this.position.left+px;			if(!this.options.axis || this.options.axis != x) this.helper[0].style.top = this.position.top+px;
			Rearrange			for (var i = this.items.length - 1; i >= 0; i--) {
				Cache variables and intersection, continue if no intersection				var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);				if (!intersection) continue;
				if(itemElement != this.currentItem[0] cannot intersect with itself					&&	this.placeholder[intersection == 1 ? next : prev]()[0] != itemElement no useless actions that have been done before					&&	!$.contains(this.placeholder[0], itemElement) no action if the item moved is the parent of the item checked					&& (this.options.type == semi-dynamic ? !$.contains(this.element[0], itemElement) : true)					&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container				) {
					$(itemElement).mouseenter();
					this.direction = intersection == 1 ? down : up;
					if (this.options.tolerance == pointer || this._intersectsWithSides(item)) {						$(itemElement).mouseleave();						this._rearrange(event, item);					} else {						break;					}
					 Clear emtpy ul's/ol's					this._clearEmpty(itemElement);
					this._trigger(change, event, this._uiHash());					break;				}			}
			var parentItem = (this.placeholder[0].parentNode.parentNode &&							 $(this.placeholder[0].parentNode.parentNode).closest(.ui-sortable).length)				       			? $(this.placeholder[0].parentNode.parentNode)				       			: null,			    level = this._getLevel(this.placeholder),			    childLevels = this._getChildLevels(this.helper);
       To find the previous sibling in the list, keep backtracking until we hit a valid list item.			var previousItem = this.placeholder[0].previousSibling ? $(this.placeholder[0].previousSibling) : null;			if (previousItem != null) {				while (previousItem[0].nodeName.toLowerCase() != li || previousItem[0] == this.currentItem[0] || previousItem[0] == this.helper[0]) {					if (previousItem[0].previousSibling) {						previousItem = $(previousItem[0].previousSibling);					} else {						previousItem = null;						break;					}				}			}
       To find the next sibling in the list, keep stepping forward until we hit a valid list item.      var nextItem = this.placeholder[0].nextSibling ? $(this.placeholder[0].nextSibling) : null;      if (nextItem != null) {        while (nextItem[0].nodeName.toLowerCase() != li || nextItem[0] == this.currentItem[0] || nextItem[0] == this.helper[0]) {          if (nextItem[0].nextSibling) {            nextItem = $(nextItem[0].nextSibling);          } else {            nextItem = null;            break;          }        }      }
			var newList = document.createElement(o.listType);
			this.beyondMaxLevels = 0;						 If the item is moved to the left, send it to its parent's level unless there are siblings below it.			if (parentItem != null && nextItem == null &&					(o.rtl && (this.positionAbs.left + this.helper.outerWidth() > parentItem.offset().left + parentItem.outerWidth()) ||					!o.rtl && (this.positionAbs.left < parentItem.offset().left))) {				parentItem.after(this.placeholder[0]);				this._clearEmpty(parentItem[0]);				this._trigger(change, event, this._uiHash());			}			 If the item is below a sibling and is moved to the right, make it a child of that sibling.			else if (previousItem != null &&						(o.rtl && (this.positionAbs.left + this.helper.outerWidth() < previousItem.offset().left + previousItem.outerWidth() - o.tabSize) ||						!o.rtl && (this.positionAbs.left > previousItem.offset().left + o.tabSize))) {				this._isAllowed(previousItem, level, level+childLevels+1);				if (!previousItem.children(o.listType).length) {					previousItem[0].appendChild(newList);				}         If this item is being moved from the top, add it to the top of the list.        if (previousTopOffset && (previousTopOffset <= previousItem.offset().top)) {          previousItem.children(o.listType).prepend(this.placeholder);        }         Otherwise, add it to the bottom of the list.        else {				  previousItem.children(o.listType)[0].appendChild(this.placeholder[0]);        }				this._trigger(change, event, this._uiHash());			}			else {				this._isAllowed(parentItem, level, level+childLevels);			}
			Post events to containers			this._contactContainers(event);
			Interconnect with droppables			if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);
			Call callbacks			this._trigger(sort, event, this._uiHash());
			this.lastPositionAbs = this.positionAbs;			return false;
		},
		_mouseStop: function(event, noPropagation) {
			 If the item is in a position not allowed, send it back			if (this.beyondMaxLevels) {
				this.placeholder.removeClass(this.options.errorClass);
				if (this.domPosition.prev) {					$(this.domPosition.prev).after(this.placeholder);				} else {					$(this.domPosition.parent).prepend(this.placeholder);				}
				this._trigger(revert, event, this._uiHash());
			}
			 Clean last empty ul/ol			for (var i = this.items.length - 1; i >= 0; i--) {				var item = this.items[i].item[0];				this._clearEmpty(item);			}
			$.ui.sortable.prototype._mouseStop.apply(this, arguments);
		},
		serialize: function(options) {
			var o = $.extend({}, this.options, options),				items = this._getItemsAsjQuery(o && o.connected),			    str = [];
			$(items).each(function() {				var res = ($(o.item || this).attr(o.attribute || id) || )						.match(o.expression || (()())),				    pid = ($(o.item || this).parent(o.listType)						.parent(o.items)						.attr(o.attribute || id) || )						.match(o.expression || (()()));
				if (res) {					str.push(((o.key || res[1]) + [ + (o.key && o.expression ? res[1] : res[2]) + ])						+ =						+ (pid ? (o.key && o.expression ? pid[1] : pid[2]) : o.rootID));				}			});
			if(!str.length && o.key) {				str.push(o.key + =);			}
			return str.join(&);
		},
		toHierarchy: function(options) {
			var o = $.extend({}, this.options, options),				sDepth = o.startDepthCount || 0,			    ret = [];
			$(this.element).children(o.items).each(function () {				var level = _recursiveItems(this);				ret.push(level);			});
			return ret;
			function _recursiveItems(item) {				var id = ($(item).attr(o.attribute || id) || ).match(o.expression || (()()));				if (id) {					var currentItem = {id : id[2]};					if ($(item).children(o.listType).children(o.items).length > 0) {						currentItem.children = [];						$(item).children(o.listType).children(o.items).each(function() {							var level = _recursiveItems(this);							currentItem.children.push(level);						});					}					return currentItem;				}			}		},
		toArray: function(options) {
			var o = $.extend({}, this.options, options),				sDepth = o.startDepthCount || 0,			    ret = [],			    left = 2;
			ret.push({				item_id: o.rootID,				parent_id: none,				depth: sDepth,				left: 1,				right: ($(o.items, this.element).length + 1) * 2			});
			$(this.element).children(o.items).each(function () {				left = _recursiveArray(this, sDepth + 1, left);			});
			ret = ret.sort(function(a,b){ return (a.left - b.left); });
			return ret;
			function _recursiveArray(item, depth, left) {
				var right = left + 1,				    id,				    pid;
				if ($(item).children(o.listType).children(o.items).length > 0) {					depth ++;					$(item).children(o.listType).children(o.items).each(function () {						right = _recursiveArray($(this), depth, right);					});					depth --;				}
				id = ($(item).attr(o.attribute || id)).match(o.expression || (()()));
				if (depth === sDepth + 1) {					pid = o.rootID;				} else {					var parentItem = ($(item).parent(o.listType)											 .parent(o.items)											 .attr(o.attribute || id))											 .match(o.expression || (()()));					pid = parentItem[2];				}
				if (id) {						ret.push({item_id: id[2], parent_id: pid, depth: depth, left: left, right: right});				}
				left = right + 1;				return left;			}
		},
		_clearEmpty: function(item) {
			var emptyList = $(item).children(this.options.listType);			if (emptyList.length && !emptyList.children().length && !this.options.doNotClear) {				emptyList.remove();			}
		},
		_getLevel: function(item) {
			var level = 1;
			if (this.options.listType) {				var list = item.closest(this.options.listType);				while (list && list.length > 0 &&                     	!list.is(.ui-sortable)) {					level++;					list = list.parent().closest(this.options.listType);				}			}
			return level;		},
		_getChildLevels: function(parent, depth) {			var self = this,			    o = this.options,			    result = 0;			depth = depth || 0;
			$(parent).children(o.listType).children(o.items).each(function (index, child) {					result = Math.max(self._getChildLevels(child, depth + 1), result);			});
			return depth ? result + 1 : result;		},
		_isAllowed: function(parentItem, level, levels) {			var o = this.options,				isRoot = $(this.domPosition.parent).hasClass(ui-sortable) ? true : false,				maxLevels = this.placeholder.closest(.ui-sortable).nestedSortable(option, maxLevels);  this takes into account the maxLevels set to the recipient list
			 Is the root protected?			 Are we trying to nest under a no-nest?			 Are we nesting too deep?			if (!o.isAllowed(this.currentItem, parentItem) ||				parentItem && parentItem.hasClass(o.disableNesting) ||				o.protectRoot && (parentItem == null && !isRoot || isRoot && level > 1)) {					this.placeholder.addClass(o.errorClass);					if (maxLevels < levels && maxLevels != 0) {						this.beyondMaxLevels = levels - maxLevels;					} else {						this.beyondMaxLevels = 1;					}			} else {				if (maxLevels < levels && maxLevels != 0) {					this.placeholder.addClass(o.errorClass);					this.beyondMaxLevels = levels - maxLevels;				} else {					this.placeholder.removeClass(o.errorClass);					this.beyondMaxLevels = 0;				}			}		}
	}));
	$.mjs.nestedSortable.prototype.options = $.extend({}, $.ui.sortable.prototype.options, $.mjs.nestedSortable.prototype.options);})(jQuery);"
"const gulp = require(gulp);
gulp.task(scripts, require(./gulp/tasks/scripts));gulp.task(set-watching, require(./gulp/tasks/set-watching));gulp.task(css, require(./gulp/tasks/css));gulp.task(jekyll, require(./gulp/tasks/jekyll));gulp.task(test, require(./gulp/tasks/test));
gulp.task(watch, gulp.series(  set-watching,  gulp.parallel(css, scripts),  jekyll));
gulp.task(default, gulp.series(scripts, test));"
"module.exports = {  extends: @odopod,};
"
"module.exports = function (config) {  use strict;
  var cfg = {    bowerComponents: demo/bower_components  };
  config.set({    basePath: ,    frameworks: [jasmine],
     files to load in the browser    files: [       components      cfg.bowerComponents + /angular/angular.js,      cfg.bowerComponents + /angular-mocks/angular-mocks.js,
       source files      source/**/*main.js,      source/**/*.js,
       tests      test/**/*.spec.js    ],
     generate js files from html templates to expose them during testing    preprocessors: {      **/*.html: ng-html2js    },
     https://github.com/karma-runner/karma-ng-html2js-preprocessor#configuration    ngHtml2JsPreprocessor: {       setting this option will create only a single module that contains templates       from all the files, so you can load them all with module('foo')    },
     files to exclude    exclude: [],
     level of logging     possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG    logLevel: config.LOG_INFO,
    port: 9876,    reporters: dots  });};"
"/* jshint node:true */
use strict;
var fs = require(fs);var path = require(path);
module.exports = function() {  var wiredep = require(wiredep);
  var bower_dependencies = wiredep({ cwd: __dirname });
  var js_dependencies = []    .concat(bower_dependencies.packages[jquery].main)    .concat(bower_dependencies.packages[jquery-ui].main)    .map(function(p) {      return p.replace(path.join(__dirname, /), );    });
  var css_dependencies = [    bower_components/jquery-ui/themes/smoothness/jquery-ui.css  ];
  function putThemInVendorDir (filepath) {    return vendor/ + path.basename(filepath);  }
  return {    humaName : UI.Sortable,    repoName : ui-sortable,    inlineHTML : fs.readFileSync(__dirname + /demo/demo.html),    inlineJS : fs.readFileSync(__dirname + /demo/demo.js),    css: css_dependencies.map(putThemInVendorDir).concat([demo/demo.css]),    js : function(defaultJsFiles){       HACK TO LOAD JQUERY BEFORE ANGULAR      return [vendor/jquery.js].concat(defaultJsFiles, js_dependencies.slice(1).map(putThemInVendorDir).concat([dist/sortable.js]));    },    bowerData: { main : ./sortable.js },    tocopy : css_dependencies.concat(js_dependencies)  };};"
"/** * angular-drag-and-drop-lists v2.1.0 * * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc * Copyright (c) 2014-2017 Google Inc. * https://github.com/marceljuenemann/angular-drag-and-drop-lists * * License: MIT */!function(e){function n(e,n){returnall==n?e:e.filter(function(e){return-1!=n.toLowerCase().indexOf(e)})}var a=application/x-dnd,r=application/json,t=Text,d=[move,copy,link]e.directive(dndDraggable,[$parse,$timeout,function(e,i){return function(l,f,c){f.attr(draggable,true),c.dndDisableIf&&l.$watch(c.dndDisableIf,function(e){f.attr(draggable,!e)}),f.on(dragstart,function(s){if(s=s.originalEvent||s,false==f.attr(draggable))return!0o.isDragging=!0,o.itemType=c.dndType&&l.$eval(c.dndType).toLowerCase(),o.dropEffect=none,o.effectAllowed=c.dndEffectAllowed||d[0],s.dataTransfer.effectAllowed=o.effectAllowedvar g=l.$eval(c.dndDraggable),u=a+(o.itemType?-+o.itemType:)try{s.dataTransfer.setData(u,angular.toJson(g))}catch(p){var v=angular.toJson({item:g,type:o.itemType})try{s.dataTransfer.setData(r,v)}catch(p){var D=n(d,o.effectAllowed)s.dataTransfer.effectAllowed=D[0],s.dataTransfer.setData(t,v)}}if(f.addClass(dndDragging),i(function(){f.addClass(dndDraggingSource)},0),s._dndHandle&&s.dataTransfer.setDragImage&&s.dataTransfer.setDragImage(f[0],0,0),e(c.dndDragstart)(l,{event:s}),c.dndCallback){var y=e(c.dndCallback)o.callback=function(e){return y(l,e||{})}}s.stopPropagation()}),f.on(dragend,function(n){n=n.originalEvent||n,l.$apply(function(){var a=o.dropEffect,r={copy:dndCopied,link:dndLinked,move:dndMoved,none:dndCanceled}e(c[r[a]])(l,{event:n}),e(c.dndDragend)(l,{event:n,dropEffect:a})}),o.isDragging=!1,o.callback=void 0,f.removeClass(dndDragging),f.removeClass(dndDraggingSource),n.stopPropagation(),i(function(){f.removeClass(dndDraggingSource)},0)}),f.on(click,function(n){c.dndSelected&&(n=n.originalEvent||n,l.$apply(function(){e(c.dndSelected)(l,{event:n})}),n.stopPropagation())}),f.on(selectstart,function(){this.dragDrop&&this.dragDrop()})}}]),e.directive(dndList,[$parse,function(e){return function(i,l,f){function c(e){if(!e)return tfor(var n=0;n<e.length;n++)if(e[n]==t||e[n]==r||e[n].substr(0,a.length)==a)return e[n]return null}function s(e){return o.isDragging?o.itemType||void 0:e==t||e==r?null:e&&e.substr(a.length+1)||void 0}function g(e){return E.disabled?!1:E.externalSources||o.isDragging?E.allowedTypes&&null!==e?e&&-1!=E.allowedTypes.indexOf(e):!0:!1}function u(e,a){var r=dreturn a||(r=n(r,e.dataTransfer.effectAllowed)),o.isDragging&&(r=n(r,o.effectAllowed)),f.dndEffectAllowed&&(r=n(r,f.dndEffectAllowed)),r.length?e.ctrlKey&&-1!=r.indexOf(copy)?copy:e.altKey&&-1!=r.indexOf(link)?link:r[0]:none}function p(){return T.remove(),l.removeClass(""dndDragover""),!0}function v(n,a,r,t,d,l){return e(n)(i,{callback:o.callback,dropEffect:r,event:a,external:!o.isDragging,index:void 0!==d?d:D(),item:l||void 0,type:t})}function D(){return Array.prototype.indexOf.call(m.children,h)}function y(){var ereturn angular.forEach(l.children(),function(n){var a=angular.element(n)a.hasClass(dndPlaceholder)&&(e=a)}),e||angular.element(<li class='dndPlaceholder'></li>)}var T=y()T.remove()var h=T[0],m=l[0],E={}l.on(dragenter,function(e){e=e.originalEvent||evar n=f.dndAllowedTypes&&i.$eval(f.dndAllowedTypes)E={allowedTypes:angular.isArray(n)&&n.join(|).toLowerCase().split(|),disabled:f.dndDisableIf&&i.$eval(f.dndDisableIf),externalSources:f.dndExternalSources&&i.$eval(f.dndExternalSources),horizontal:f.dndHorizontalList&&i.$eval(f.dndHorizontalList)}var a=c(e.dataTransfer.types)return a&&g(s(a))?void e.preventDefault():!0}),l.on(dragover,function(e){e=e.originalEvent||evar n=c(e.dataTransfer.types),a=s(n)if(!n||!g(a))return!0if(h.parentNode!=m&&l.append(T),e.target!=m){for(var r=e.target;r.parentNode!=m&&r.parentNode;)r=r.parentNodeif(r.parentNode==m&&r!=h){var d=r.getBoundingClientRect()if(E.horizontal)var o=e.clientX<d.left+d.width/2else var o=e.clientY<d.top+d.height/2m.insertBefore(h,o?r:r.nextSibling)}}var i=n==t,D=u(e,i)returnnone==D?p():f.dndDragover&&!v(f.dndDragover,e,D,a)?p():(e.preventDefault(),i||(e.dataTransfer.dropEffect=D),l.addClass(dndDragover),e.stopPropagation(),!1)}),l.on(drop,function(e){e=e.originalEvent||evar n=c(e.dataTransfer.types),a=s(n)if(!n||!g(a))return!0e.preventDefault()try{var d=JSON.parse(e.dataTransfer.getData(n))}catch(l){return p()}if((n==t||n==r)&&(a=d.type||void 0,d=d.item,!g(a)))return p()var y=n==t,T=u(e,y)if(none==T)return p()var h=D()return f.dndDrop&&(d=v(f.dndDrop,e,T,a,h,d),!d)?p():(o.dropEffect=T,y||(e.dataTransfer.dropEffect=T),d!==!0&&i.$apply(function(){i.$eval(f.dndList).splice(h,0,d)}),v(f.dndInserted,e,T,a,h,d),p(),e.stopPropagation(),!1)}),l.on(dragleave,function(e){e=e.originalEvent||evar n=document.elementFromPoint(e.clientX,e.clientY)m.contains(n)&&!e._dndPhShown?e._dndPhShown=!0:p()})}}]),e.directive(dndNodrag,function(){return function(e,n,a){n.attr(draggable,true),n.on(dragstart,function(e){e=e.originalEvent||e,e._dndHandle||(e.dataTransfer.types&&e.dataTransfer.types.length||e.preventDefault(),e.stopPropagation())}),n.on(dragend,function(e){e=e.originalEvent||e,e._dndHandle||e.stopPropagation()})}}),e.directive(dndHandle,function(){return function(e,n,a){n.attr(draggable,true),n.on(dragstart dragend,function(e){e=e.originalEvent||e,e._dndHandle=!0})}})var o={}}(angular.module(dndLists,[]));"
"var path = require(path);var webpack = require(webpack);var autoprefixer = require(autoprefixer);var ExtractTextPlugin = require(extract-text-webpack-plugin);var argv = require(yargs).argv;var minify = Boolean(argv.minify);var outputName = react-sortable-hoc;var plugins = {    default: [        new ExtractTextPlugin(../../styles.css)    ],    minify: [        new webpack.optimize.UglifyJsPlugin({            beautify: false,            comments: false,            mangle: false        }),        new ExtractTextPlugin(../../styles.min.css)    ]}
module.exports = {    devtool: (minify) ? source-map : null,    entry: [        ./src/index    ],    output: {        path: path.join(__dirname, dist/umd),        filename: (minify) ? outputName + .min.js : outputName + .js,        library: SortableHOC,        libraryTarget: umd    },    externals: {        react: {            commonjs: react,            commonjs2: react,            amd: react,            root: React        },        react-dom: {            commonjs: react-dom,            commonjs2: react-dom,            amd: react-dom,            root: ReactDOM        }    },    plugins: (minify) ? plugins.minify : plugins.default,    resolve: {		extensions: [, .js, .jsx, .scss]    },    module: {        loaders: [            {                test: jsx,                loaders: [babel],                exclude: node_modules,                include: path.join(__dirname, src)            },            {				test: (scsscss),				loader: ExtractTextPlugin.extract(style, css?-minimize&modules&importLoaders=1&localIdentName=Cal__[name]__[local]!postcss!sass?output=nested),                include: path.join(__dirname, src)            }        ]    },    postcss: [autoprefixer]}"
"var path = require(path);var webpack = require(webpack);var autoprefixer = require(autoprefixer);var HtmlWebpackPlugin = require(html-webpack-plugin);var DashboardPlugin = require(webpack-dashboard/plugin);
module.exports = {    devtool: cheap-module-eval-source-map,    entry: [        webpack-hot-middleware/client,        ./index    ],    output: {        path: path.join(__dirname, dist),        filename: bundle.js,        publicPath: /static/    },    plugins: [        new DashboardPlugin(),        new HtmlWebpackPlugin({			template: ./index.html,			inject: body  Inject all scripts into the body		}),        new webpack.optimize.OccurenceOrderPlugin(),        new webpack.HotModuleReplacementPlugin()    ],    resolve: {		extensions: [, .js, .jsx, .scss]    },    module: {        loaders: [            {                test: jsx,                loaders: [babel],                exclude: node_modules,                include: __dirname            },            {                test: (scss),                loaders: [style, css?sourceMap&modules&importLoaders=1&localIdentName=Cal__[name]__[local]!postcss!sass?sourceMap]            },            {                test: (css),                loaders: [style, css]            }        ]    },    postcss: [autoprefixer]}"
"use strict;
const gulp            = require(gulp);const jshint          = require(gulp-jshint);const stylish         = require(jshint-stylish);const rename          = require(gulp-rename);const jscs            = require(gulp-jscs);const uglify          = require(gulp-uglify);const livereload      = require(gulp-livereload);const exec            = require(child_process).exec;
gulp.task(default, [watch]);
gulp.task(watch, () => {    livereload.listen(35730);
    gulp.watch([        ./src/*.js,        ./src/*.hbs    ], [reload-js])        .on(change, function(e) {            console.log(                [gulp-watch] file  +                e.path +                 was  +                e.type +                , building            );        });});
gulp.task(reload-js, [build-dist], () => {    return livereload.changed();});
gulp.task(prod, [uglify]);
gulp.task(uglify, [build], () => {    return gulp.src([        ./dist/mixitup.js    ])        .pipe(uglify({            preserveComments: license        }))        .pipe(rename(mixitup.min.js))        .on(error, e => console.error([uglify]  + e.message))        .pipe(gulp.dest(./dist/))        .pipe(gulp.dest(./demos/));});
gulp.task(build, [build-dist], done => {    exec(node node_modules/mixitup-build/docs.js -s mixitup.js, (e, out) => {        if (out) {            console.log(out);        }
        done(e);    });});
gulp.task(build-dist, [lint, code-style], done => {    exec(node node_modules/mixitup-build/dist.js -o mixitup.js, (e, out) => {        if (out) {            console.log(out);        }
        done(e);    });});
gulp.task(lint, () => {    return gulp.src([        ./src/*.js    ], {        base: /    })        .pipe(jshint(./.jshintrc))        .pipe(jshint.reporter(stylish))        .pipe(jshint.reporter(fail));});
gulp.task(code-style, () => {    return gulp.src([        ./src/*.js    ], {        base: /    })        .pipe(jscs())        .pipe(jscs.reporter());});"
"use strict;
var fs = require(fs);
module.exports = function(grunt) {
     Project configuration.    grunt.initConfig({         Metadata.        pkg: grunt.file.readJSON(bootstrap-table.jquery.json),        banner: /* +                * <%= pkg.name %> - v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %> +                <%= pkg.homepage ? ""* "" + pkg.homepage : """" %> +                * Copyright (c) <%= grunt.template.today(""yyyy"") %> <%= pkg.author.name %> +                * Licensed <%= _.pluck(pkg.licenses, ""type"").join("", "") %> +                */,         Task configuration.        clean: [dist, docs/dist],        concat: {            basic_target: {                src: ['src/<%= pkg.name %>.js', 'src/extensions/**/*.js'],                dest: 'dist/<%= pkg.name %>-all.js'            },            locale_target: {                src: [src/locale/**/*.js],                dest: dist/<%= pkg.name %>-locale-all.js            }        },        uglify: {            options: {                banner: <%= banner %>            },            basic_target: {                files: {                    dist/<%= pkg.name %>.min.js: [src/<%=pkg.name %>.js],                    'dist/<%= pkg.name %>-all.min.js': ['dist/<%=pkg.name %>-all.js'],                    dist/<%= pkg.name %>-locale-all.min.js: [dist/<%=pkg.name %>-locale-all.js]                }            },            locale_target: {                files: [{                    expand: true,                    cwd: src/locale,                    src: **/*.js,                    dest: dist/locale,                    ext: .min.js  replace .js to .min.js                }]            },            extensions_target: {                files: [{                    expand: true,                    cwd: src/extensions,                    src: **/*.js,                    dest: dist/extensions,                    ext: .min.js  replace .js to .min.js                }]            }        },        cssmin: {            add_banner: {                options: {                    banner: <%= banner %>                },                files: {                    dist/<%= pkg.name %>.min.css: [src/<%=pkg.name %>.css]                }            }        },        copy: {            source: {                cwd: src,                      set working folder / root to copy                src: [**/*.js, **/*.css],    copy all files and subfolders                dest: dist,                    destination folder                expand: true                     required when using cwd            },            files: {                cwd: dist,             set working folder / root to copy                src: **/*,             copy all files and subfolders                dest: docs/dist,       destination folder                expand: true             required when using cwd            }        },        release: {            options: {                additionalFiles: [bootstrap-table.jquery.json],                beforeRelease: [docs, default]            }        }    });
    var bumpVersion = function (path, version, startWith) {        var lines = fs.readFileSync(path, utf8).split();        lines.forEach(function (line, i) {            if (line.indexOf(startWith) === 0) {                lines[i] = startWith + version;            }        });        fs.writeFileSync(path, lines.join(), utf8);
        grunt.log.ok(bumped version of  + path +  to  + version);    };
    grunt.registerTask(docs, build the docs, function () {        var version = require(./package.json).version;        bumpVersion(./_config.yml, version, current_version: );        bumpVersion(./src/bootstrap-table.js, version,  * version: );        bumpVersion(./src/bootstrap-table.css, version,  * version: );
        var changeLog = fs.readFileSync(./CHANGELOG.md, utf8);        var latestLogs = changeLog.split(### )[1];        var date = new Date();
        var lines = [            ### Latest release ( +            [date.getFullYear(), date.getMonth() + 1, date.getDate()].join(-) + ),            ,            #### v + latestLogs        ];        fs.writeFileSync(./docs/_includes/latest-release.md, lines.join(), utf8);
        grunt.log.ok(updated the latest-release.md to  + version);    });
    grunt.loadNpmTasks(grunt-contrib-clean);    grunt.loadNpmTasks(grunt-contrib-concat);    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-cssmin);    grunt.loadNpmTasks(grunt-contrib-copy);    grunt.loadNpmTasks(grunt-release);
    grunt.registerTask(default, [clean, concat, uglify, cssmin, copy]);};"
"const webpack = require(webpack),      PACKAGE = require(./package.json);
module.exports = {  entry: {    list: ./src/index.js,    list.min: ./src/index.js  },  output: {    path: __dirname + /dist,    filename: [name].js,    library: List  },  module: {    rules: [{      enforce: pre,      test: js,      exclude: (node_modulessrcutilsextendjs),      loader: jshint-loader    }]  },  devServer: {    inline: true  },  plugins: [    new webpack.optimize.UglifyJsPlugin({      include: minjs,      minimize: true    }),    new webpack.BannerPlugin({      banner: List.js v + PACKAGE.version +  ( + PACKAGE.homepage + ) by  + PACKAGE.author.name +  ( + PACKAGE.author.url + )    })  ]};"
"/** * jQuery plugin for Sortable * 	<> *   */(function (factory) {	use strict;
	if (typeof define === function && define.amd) {		define([jquery], factory);	}	else {		/* jshint sub:true */		factory(jQuery);	}})(function ($) {	use strict;

	/* CODE */

	/**	 * jQuery plugin for Sortable	 *     	 *               	 *  	 */	$.fn.sortable = function (options) {		var retVal,			args = arguments;
		this.each(function () {			var $el = $(this),				sortable = $el.data(sortable);
			if (!sortable && (options instanceof Object || !options)) {				sortable = new Sortable(this, options);				$el.data(sortable, sortable);			}
			if (sortable) {				if (options === widget) {					retVal = sortable;				}				else if (options === destroy) {					sortable.destroy();					$el.removeData(sortable);				}				else if (typeof sortable[options] === function) {					retVal = sortable[options].apply(sortable, [].slice.call(args, 1));				}				else if (options in sortable.options) {					retVal = sortable.option.apply(sortable, args);				}			}		});
		return (retVal === void 0) ? this : retVal;	};});"
"/*! Sortable 1.5.1 - MIT | git://github.com/rubaxa/Sortable.git */!function(a){""use strict"";""function""==typeof define&&define.amd?define(a):""undefined""!=typeof module&&""undefined""!=typeof module.exports?module.exports=a():window.Sortable=a()}(function(){""use strict"";function a(a,b){if(!a||!a.nodeType||1!==a.nodeType)throw""Sortable: `el` must be HTMLElement, and not ""+{}.toString.call(a);this.el=a,this.options=b=t({},b),a[T]=this;var c={group:Math.random(),sort:!0,disabled:!1,store:null,handle:null,scroll:!0,scrollSensitivity:30,scrollSpeed:10,draggable:/[uo]l/i.test(a.nodeName)?""li"":"">*"",ghostClass:""sortable-ghost"",chosenClass:""sortable-chosen"",dragClass:""sortable-drag"",ignore:""a, img"",filter:null,preventOnFilter:!0,animation:0,setData:function(a,b){a.setData(""Text"",b.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:""data-id"",delay:0,forceFallback:!1,fallbackClass:""sortable-fallback"",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0}};for(var d in c)!(d in b)&&(b[d]=c[d]);ga(b);for(var e in this)""_""===e.charAt(0)&&""function""==typeof this[e]&&(this[e]=this[e].bind(this));this.nativeDraggable=!b.forceFallback&&$,f(a,""mousedown"",this._onTapStart),f(a,""touchstart"",this._onTapStart),f(a,""pointerdown"",this._onTapStart),this.nativeDraggable&&(f(a,""dragover"",this),f(a,""dragenter"",this)),ea.push(this._onDragOver),b.store&&this.sort(b.store.get(this))}function b(a,b){""clone""!==a.lastPullMode&&(b=!0),z&&z.state!==b&&(i(z,""display"",b?""none"":""""),b||z.state&&(a.options.group.revertClone?(A.insertBefore(z,B),a._animate(w,z)):A.insertBefore(z,w)),z.state=b)}function c(a,b,c){if(a){c=c||V;do if("">*""===b&&a.parentNode===c||r(a,b))return a;while(a=d(a))}return null}function d(a){var b=a.host;return b&&b.nodeType?b:a.parentNode}function e(a){a.dataTransfer&&(a.dataTransfer.dropEffect=""move""),a.preventDefault()}function f(a,b,c){a.addEventListener(b,c,Z)}function g(a,b,c){a.removeEventListener(b,c,Z)}function h(a,b,c){if(a)if(a.classList)a.classList[c?""add"":""remove""](b);else{var d=("" ""+a.className+"" "").replace(R,"" "").replace("" ""+b+"" "","" "");a.className=(d+(c?"" ""+b:"""")).replace(R,"" "")}}function i(a,b,c){var d=a&&a.style;if(d){if(void 0===c)return V.defaultView&&V.defaultView.getComputedStyle?c=V.defaultView.getComputedStyle(a,""""):a.currentStyle&&(c=a.currentStyle),void 0===b?c:c[b];b in d||(b=""-webkit-""+b),d[b]=c+(""string""==typeof c?"""":""px"")}}function j(a,b,c){if(a){var d=a.getElementsByTagName(b),e=0,f=d.length;if(c)for(;e<f;e++)c(d[e],e);return d}return[]}function k(a,b,c,d,e,f,g){a=a||b[T];var h=V.createEvent(""Event""),i=a.options,j=""on""+c.charAt(0).toUpperCase()+c.substr(1);h.initEvent(c,!0,!0),h.to=b,h.from=e||b,h.item=d||b,h.clone=z,h.oldIndex=f,h.newIndex=g,b.dispatchEvent(h),i[j]&&i[j].call(a,h)}function l(a,b,c,d,e,f,g){var h,i,j=a[T],k=j.options.onMove;return h=V.createEvent(""Event""),h.initEvent(""move"",!0,!0),h.to=b,h.from=a,h.dragged=c,h.draggedRect=d,h.related=e||b,h.relatedRect=f||b.getBoundingClientRect(),a.dispatchEvent(h),k&&(i=k.call(j,h,g)),i}function m(a){a.draggable=!1}function n(){aa=!1}function o(a,b){var c=a.lastElementChild,d=c.getBoundingClientRect();return(b.clientY-(d.top+d.height)>5||b.clientX-(d.right+d.width)>5)&&c}function p(a){for(var b=a.tagName+a.className+a.src+a.href+a.textContent,c=b.length,d=0;c--;)d+=b.charCodeAt(c);return d.toString(36)}function q(a,b){var c=0;if(!a||!a.parentNode)return-1;for(;a&&(a=a.previousElementSibling);)""TEMPLATE""===a.nodeName.toUpperCase()||"">*""!==b&&!r(a,b)||c++;return c}function r(a,b){if(a){b=b.split(""."");var c=b.shift().toUpperCase(),d=new RegExp(""\\s(""+b.join(""|"")+"")(?=\\s)"",""g"");return!(""""!==c&&a.nodeName.toUpperCase()!=c||b.length&&(("" ""+a.className+"" "").match(d)||[]).length!=b.length)}return!1}function s(a,b){var c,d;return function(){void 0===c&&(c=arguments,d=this,setTimeout(function(){1===c.length?a.call(d,c[0]):a.apply(d,c),c=void 0},b))}}function t(a,b){if(a&&b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function u(a){return X?X(a).clone(!0)[0]:Y&&Y.dom?Y.dom(a).cloneNode(!0):a.cloneNode(!0)}function v(a){for(var b=a.getElementsByTagName(""input""),c=b.length;c--;){var d=b[c];d.checked&&da.push(d)}}if(""undefined""==typeof window||!window.document)return function(){throw new Error(""Sortable.js requires a window with a document"")};var w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q={},R=/\s+/g,S=/left|right|inline/,T=""Sortable""+(new Date).getTime(),U=window,V=U.document,W=U.parseInt,X=U.jQuery||U.Zepto,Y=U.Polymer,Z=!1,$=!!(""draggable""in V.createElement(""div"")),_=function(a){return!navigator.userAgent.match(/Trident.*rv[ :]?11\./)&&(a=V.createElement(""x""),a.style.cssText=""pointer-events:auto"",""auto""===a.style.pointerEvents)}(),aa=!1,ba=Math.abs,ca=Math.min,da=[],ea=[],fa=s(function(a,b,c){if(c&&b.scroll){var d,e,f,g,h,i,j=c[T],k=b.scrollSensitivity,l=b.scrollSpeed,m=a.clientX,n=a.clientY,o=window.innerWidth,p=window.innerHeight;if(E!==c&&(D=b.scroll,E=c,F=b.scrollFn,D===!0)){D=c;do if(D.offsetWidth<D.scrollWidth||D.offsetHeight<D.scrollHeight)break;while(D=D.parentNode)}D&&(d=D,e=D.getBoundingClientRect(),f=(ba(e.right-m)<=k)-(ba(e.left-m)<=k),g=(ba(e.bottom-n)<=k)-(ba(e.top-n)<=k)),f||g||(f=(o-m<=k)-(m<=k),g=(p-n<=k)-(n<=k),(f||g)&&(d=U)),Q.vx===f&&Q.vy===g&&Q.el===d||(Q.el=d,Q.vx=f,Q.vy=g,clearInterval(Q.pid),d&&(Q.pid=setInterval(function(){return i=g?g*l:0,h=f?f*l:0,""function""==typeof F?F.call(j,h,i,a):void(d===U?U.scrollTo(U.pageXOffset+h,U.pageYOffset+i):(d.scrollTop+=i,d.scrollLeft+=h))},24)))}},30),ga=function(a){function b(a,b){return void 0!==a&&a!==!0||(a=c.name),""function""==typeof a?a:function(c,d){var e=d.options.group.name;return b?a:a&&(a.join?a.indexOf(e)>-1:e==a)}}var c={},d=a.group;d&&""object""==typeof d||(d={name:d}),c.name=d.name,c.checkPull=b(d.pull,!0),c.checkPut=b(d.put),c.revertClone=d.revertClone,a.group=c};a.prototype={constructor:a,_onTapStart:function(a){var b,d=this,e=this.el,f=this.options,g=f.preventOnFilter,h=a.type,i=a.touches&&a.touches[0],j=(i||a).target,l=a.target.shadowRoot&&a.path[0]||j,m=f.filter;if(v(e),!w&&!(""mousedown""===h&&0!==a.button||f.disabled)&&(j=c(j,f.draggable,e),j&&C!==j)){if(b=q(j,f.draggable),""function""==typeof m){if(m.call(this,a,j,this))return k(d,l,""filter"",j,e,b),void(g&&a.preventDefault())}else if(m&&(m=m.split("","").some(function(a){if(a=c(l,a.trim(),e))return k(d,a,""filter"",j,e,b),!0})))return void(g&&a.preventDefault());f.handle&&!c(l,f.handle,e)||this._prepareDragStart(a,i,j,b)}},_prepareDragStart:function(a,b,c,d){var e,g=this,i=g.el,l=g.options,n=i.ownerDocument;c&&!w&&c.parentNode===i&&(N=a,A=i,w=c,x=w.parentNode,B=w.nextSibling,C=c,L=l.group,J=d,this._lastX=(b||a).clientX,this._lastY=(b||a).clientY,w.style[""will-change""]=""transform"",e=function(){g._disableDelayedDrag(),w.draggable=g.nativeDraggable,h(w,l.chosenClass,!0),g._triggerDragStart(a,b),k(g,A,""choose"",w,A,J)},l.ignore.split("","").forEach(function(a){j(w,a.trim(),m)}),f(n,""mouseup"",g._onDrop),f(n,""touchend"",g._onDrop),f(n,""touchcancel"",g._onDrop),f(n,""pointercancel"",g._onDrop),f(n,""selectstart"",g),l.delay?(f(n,""mouseup"",g._disableDelayedDrag),f(n,""touchend"",g._disableDelayedDrag),f(n,""touchcancel"",g._disableDelayedDrag),f(n,""mousemove"",g._disableDelayedDrag),f(n,""touchmove"",g._disableDelayedDrag),f(n,""pointermove"",g._disableDelayedDrag),g._dragStartTimer=setTimeout(e,l.delay)):e())},_disableDelayedDrag:function(){var a=this.el.ownerDocument;clearTimeout(this._dragStartTimer),g(a,""mouseup"",this._disableDelayedDrag),g(a,""touchend"",this._disableDelayedDrag),g(a,""touchcancel"",this._disableDelayedDrag),g(a,""mousemove"",this._disableDelayedDrag),g(a,""touchmove"",this._disableDelayedDrag),g(a,""pointermove"",this._disableDelayedDrag)},_triggerDragStart:function(a,b){b=b||(""touch""==a.pointerType?a:null),b?(N={target:w,clientX:b.clientX,clientY:b.clientY},this._onDragStart(N,""touch"")):this.nativeDraggable?(f(w,""dragend"",this),f(A,""dragstart"",this._onDragStart)):this._onDragStart(N,!0);try{V.selection?setTimeout(function(){V.selection.empty()}):window.getSelection().removeAllRanges()}catch(a){}},_dragStarted:function(){if(A&&w){var b=this.options;h(w,b.ghostClass,!0),h(w,b.dragClass,!1),a.active=this,k(this,A,""start"",w,A,J)}else this._nulling()},_emulateDragOver:function(){if(O){if(this._lastX===O.clientX&&this._lastY===O.clientY)return;this._lastX=O.clientX,this._lastY=O.clientY,_||i(y,""display"",""none"");var a=V.elementFromPoint(O.clientX,O.clientY),b=a,c=ea.length;if(b)do{if(b[T]){for(;c--;)ea[c]({clientX:O.clientX,clientY:O.clientY,target:a,rootEl:b});break}a=b}while(b=b.parentNode);_||i(y,""display"","""")}},_onTouchMove:function(b){if(N){var c=this.options,d=c.fallbackTolerance,e=c.fallbackOffset,f=b.touches?b.touches[0]:b,g=f.clientX-N.clientX+e.x,h=f.clientY-N.clientY+e.y,j=b.touches?""translate3d(""+g+""px,""+h+""px,0)"":""translate(""+g+""px,""+h+""px)"";if(!a.active){if(d&&ca(ba(f.clientX-this._lastX),ba(f.clientY-this._lastY))<d)return;this._dragStarted()}this._appendGhost(),P=!0,O=f,i(y,""webkitTransform"",j),i(y,""mozTransform"",j),i(y,""msTransform"",j),i(y,""transform"",j),b.preventDefault()}},_appendGhost:function(){if(!y){var a,b=w.getBoundingClientRect(),c=i(w),d=this.options;y=w.cloneNode(!0),h(y,d.ghostClass,!1),h(y,d.fallbackClass,!0),h(y,d.dragClass,!0),i(y,""top"",b.top-W(c.marginTop,10)),i(y,""left"",b.left-W(c.marginLeft,10)),i(y,""width"",b.width),i(y,""height"",b.height),i(y,""opacity"",""0.8""),i(y,""position"",""fixed""),i(y,""zIndex"",""100000""),i(y,""pointerEvents"",""none""),d.fallbackOnBody&&V.body.appendChild(y)||A.appendChild(y),a=y.getBoundingClientRect(),i(y,""width"",2*b.width-a.width),i(y,""height"",2*b.height-a.height)}},_onDragStart:function(a,b){var c=a.dataTransfer,d=this.options;this._offUpEvents(),L.checkPull(this,this,w,a)&&(z=u(w),z.draggable=!1,z.style[""will-change""]="""",i(z,""display"",""none""),h(z,this.options.chosenClass,!1),A.insertBefore(z,w),k(this,A,""clone"",w)),h(w,d.dragClass,!0),b?(""touch""===b?(f(V,""touchmove"",this._onTouchMove),f(V,""touchend"",this._onDrop),f(V,""touchcancel"",this._onDrop),f(V,""pointermove"",this._onTouchMove),f(V,""pointerup"",this._onDrop)):(f(V,""mousemove"",this._onTouchMove),f(V,""mouseup"",this._onDrop)),this._loopId=setInterval(this._emulateDragOver,50)):(c&&(c.effectAllowed=""move"",d.setData&&d.setData.call(this,c,w)),f(V,""drop"",this),setTimeout(this._dragStarted,0))},_onDragOver:function(d){var e,f,g,h,j=this.el,k=this.options,m=k.group,p=a.active,q=L===m,r=!1,s=k.sort;if(void 0!==d.preventDefault&&(d.preventDefault(),!k.dragoverBubble&&d.stopPropagation()),!w.animated&&(P=!0,p&&!k.disabled&&(q?s||(h=!A.contains(w)):M===this||(p.lastPullMode=L.checkPull(this,p,w,d))&&m.checkPut(this,p,w,d))&&(void 0===d.rootEl||d.rootEl===this.el))){if(fa(d,k,this.el),aa)return;if(e=c(d.target,k.draggable,j),f=w.getBoundingClientRect(),M!==this&&(M=this,r=!0),h)return b(p,!0),x=A,void(z||B?A.insertBefore(w,z||B):s||A.appendChild(w));if(0===j.children.length||j.children[0]===y||j===d.target&&(e=o(j,d))){if(e){if(e.animated)return;g=e.getBoundingClientRect()}b(p,q),l(A,j,w,f,e,g,d)!==!1&&(w.contains(j)||(j.appendChild(w),x=j),this._animate(f,w),e&&this._animate(g,e))}else if(e&&!e.animated&&e!==w&&void 0!==e.parentNode[T]){G!==e&&(G=e,H=i(e),I=i(e.parentNode)),g=e.getBoundingClientRect();var t=g.right-g.left,u=g.bottom-g.top,v=S.test(H.cssFloat+H.display)||""flex""==I.display&&0===I[""flex-direction""].indexOf(""row""),C=e.offsetWidth>w.offsetWidth,D=e.offsetHeight>w.offsetHeight,E=(v?(d.clientX-g.left)/t:(d.clientY-g.top)/u)>.5,F=e.nextElementSibling,J=l(A,j,w,f,e,g,d),K=!1;if(J!==!1){if(aa=!0,setTimeout(n,30),b(p,q),1===J||J===-1)K=1===J;else if(v){var N=w.offsetTop,O=e.offsetTop;K=N===O?e.previousElementSibling===w&&!C||E&&C:e.previousElementSibling===w||w.previousElementSibling===e?(d.clientY-g.top)/u>.5:O>N}else r||(K=F!==w&&!D||E&&D);w.contains(j)||(K&&!F?j.appendChild(w):e.parentNode.insertBefore(w,K?F:e)),x=w.parentNode,this._animate(f,w),this._animate(g,e)}}}},_animate:function(a,b){var c=this.options.animation;if(c){var d=b.getBoundingClientRect();1===a.nodeType&&(a=a.getBoundingClientRect()),i(b,""transition"",""none""),i(b,""transform"",""translate3d(""+(a.left-d.left)+""px,""+(a.top-d.top)+""px,0)""),b.offsetWidth,i(b,""transition"",""all ""+c+""ms""),i(b,""transform"",""translate3d(0,0,0)""),clearTimeout(b.animated),b.animated=setTimeout(function(){i(b,""transition"",""""),i(b,""transform"",""""),b.animated=!1},c)}},_offUpEvents:function(){var a=this.el.ownerDocument;g(V,""touchmove"",this._onTouchMove),g(V,""pointermove"",this._onTouchMove),g(a,""mouseup"",this._onDrop),g(a,""touchend"",this._onDrop),g(a,""pointerup"",this._onDrop),g(a,""touchcancel"",this._onDrop),g(a,""selectstart"",this)},_onDrop:function(b){var c=this.el,d=this.options;clearInterval(this._loopId),clearInterval(Q.pid),clearTimeout(this._dragStartTimer),g(V,""mousemove"",this._onTouchMove),this.nativeDraggable&&(g(V,""drop"",this),g(c,""dragstart"",this._onDragStart)),this._offUpEvents(),b&&(P&&(b.preventDefault(),!d.dropBubble&&b.stopPropagation()),y&&y.parentNode.removeChild(y),A!==x&&""clone""===a.active.lastPullMode||z&&z.parentNode.removeChild(z),w&&(this.nativeDraggable&&g(w,""dragend"",this),m(w),w.style[""will-change""]="""",h(w,this.options.ghostClass,!1),h(w,this.options.chosenClass,!1),A!==x?(K=q(w,d.draggable),K>=0&&(k(null,x,""add"",w,A,J,K),k(this,A,""remove"",w,A,J,K),k(null,x,""sort"",w,A,J,K),k(this,A,""sort"",w,A,J,K))):w.nextSibling!==B&&(K=q(w,d.draggable),K>=0&&(k(this,A,""update"",w,A,J,K),k(this,A,""sort"",w,A,J,K))),a.active&&(null!=K&&K!==-1||(K=J),k(this,A,""end"",w,A,J,K),this.save()))),this._nulling()},_nulling:function(){A=w=x=y=B=z=C=D=E=N=O=P=K=G=H=M=L=a.active=null,da.forEach(function(a){a.checked=!0}),da.length=0},handleEvent:function(a){switch(a.type){case""drop"":case""dragend"":this._onDrop(a);break;case""dragover"":case""dragenter"":w&&(this._onDragOver(a),e(a));break;case""selectstart"":a.preventDefault()}},toArray:function(){for(var a,b=[],d=this.el.children,e=0,f=d.length,g=this.options;e<f;e++)a=d[e],c(a,g.draggable,this.el)&&b.push(a.getAttribute(g.dataIdAttr)||p(a));return b},sort:function(a){var b={},d=this.el;this.toArray().forEach(function(a,e){var f=d.children[e];c(f,this.options.draggable,d)&&(b[a]=f)},this),a.forEach(function(a){b[a]&&(d.removeChild(b[a]),d.appendChild(b[a]))})},save:function(){var a=this.options.store;a&&a.set(this)},closest:function(a,b){return c(a,b||this.options.draggable,this.el)},option:function(a,b){var c=this.options;return void 0===b?c[a]:(c[a]=b,void(""group""===a&&ga(c)))},destroy:function(){var a=this.el;a[T]=null,g(a,""mousedown"",this._onTapStart),g(a,""touchstart"",this._onTapStart),g(a,""pointerdown"",this._onTapStart),this.nativeDraggable&&(g(a,""dragover"",this),g(a,""dragenter"",this)),Array.prototype.forEach.call(a.querySelectorAll(""[draggable]""),function(a){a.removeAttribute(""draggable"")}),ea.splice(ea.indexOf(this._onDragOver),1),this._onDrop(),this.el=a=null}},f(V,""touchmove"",function(b){a.active&&b.preventDefault()});try{window.addEventListener(""test"",null,Object.defineProperty({},""passive"",{get:function(){Z={capture:!1,passive:!1}}}))}catch(a){}return a.utils={on:f,off:g,css:i,find:j,is:function(a,b){return!!c(a,b,a)},extend:t,throttle:s,closest:c,toggleClass:h,clone:u,index:q},a.create=function(b,c){return new a(b,c)},a.version=""1.5.1"",a});"
"/**! * Sortable * 	<> *   */
(function sortableModule(factory) {	use strict;
	if (typeof define === function && define.amd) {		define(factory);	}	else if (typeof module != undefined && typeof module.exports != undefined) {		module.exports = factory();	}	else {		/* jshint sub:true */		window[Sortable] = factory();	}})(function sortableFactory() {	use strict;
	if (typeof window == undefined || !window.document) {		return function sortableError() {			throw new Error(Sortable.js requires a window with a document);		};	}
	var dragEl,		parentEl,		ghostEl,		cloneEl,		rootEl,		nextEl,		lastDownEl,
		scrollEl,		scrollParentEl,		scrollCustomFn,
		lastEl,		lastCSS,		lastParentCSS,
		oldIndex,		newIndex,
		activeGroup,		putSortable,
		autoScroll = {},
		tapEvt,		touchEvt,
		moved,
		 */		R_SPACE = g,		R_FLOAT = leftrightinline,
		expando = Sortable + (new Date).getTime(),
		win = window,		document = win.document,		parseInt = win.parseInt,
		$ = win.jQuery || win.Zepto,		Polymer = win.Polymer,
		captureMode = false,
		supportDraggable = !!(draggable in document.createElement(div)),		supportCssPointerEvents = (function (el) {			 false when IE11			if (!!navigator.userAgent.match(Tridentrv11)) {				return false;			}			el = document.createElement(x);			el.style.cssText = pointer-events:auto;			return el.style.pointerEvents === auto;		})(),
		_silent = false,
		abs = Math.abs,		min = Math.min,
		savedInputChecked = [],		touchDragOverListeners = [],
		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {			 Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521			if (rootEl && options.scroll) {				var _this = rootEl[expando],					el,					rect,					sens = options.scrollSensitivity,					speed = options.scrollSpeed,
					x = evt.clientX,					y = evt.clientY,
					winWidth = window.innerWidth,					winHeight = window.innerHeight,
					vx,					vy,
					scrollOffsetX,					scrollOffsetY				;
				 Delect scrollEl				if (scrollParentEl !== rootEl) {					scrollEl = options.scroll;					scrollParentEl = rootEl;					scrollCustomFn = options.scrollFn;
					if (scrollEl === true) {						scrollEl = rootEl;
						do {							if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||								(scrollEl.offsetHeight < scrollEl.scrollHeight)							) {								break;							}							/* jshint boss:true */						} while (scrollEl = scrollEl.parentNode);					}				}
				if (scrollEl) {					el = scrollEl;					rect = scrollEl.getBoundingClientRect();					vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);					vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);				}

				if (!(vx || vy)) {					vx = (winWidth - x <= sens) - (x <= sens);					vy = (winHeight - y <= sens) - (y <= sens);
					/* jshint expr:true */					(vx || vy) && (el = win);				}

				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {					autoScroll.el = el;					autoScroll.vx = vx;					autoScroll.vy = vy;
					clearInterval(autoScroll.pid);
					if (el) {						autoScroll.pid = setInterval(function () {							scrollOffsetY = vy ? vy * speed : 0;							scrollOffsetX = vx ? vx * speed : 0;
							if (function === typeof(scrollCustomFn)) {								return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);							}
							if (el === win) {								win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);							} else {								el.scrollTop += scrollOffsetY;								el.scrollLeft += scrollOffsetX;							}						}, 24);					}				}			}		}, 30),
		_prepareGroup = function (options) {			function toFn(value, pull) {				if (value === void 0 || value === true) {					value = group.name;				}
				if (typeof value === function) {					return value;				} else {					return function (to, from) {						var fromGroup = from.options.group.name;
						return pull							? value							: value && (value.join								? value.indexOf(fromGroup) > -1								: (fromGroup == value)							);					};				}			}
			var group = {};			var originalGroup = options.group;
			if (!originalGroup || typeof originalGroup != object) {				originalGroup = {name: originalGroup};			}
			group.name = originalGroup.name;			group.checkPull = toFn(originalGroup.pull, true);			group.checkPut = toFn(originalGroup.put);			group.revertClone = originalGroup.revertClone;
			options.group = group;		}	;

	/**	 *   Sortable	 *     	 *          	 */	function Sortable(el, options) {		if (!(el && el.nodeType && el.nodeType === 1)) {			throw Sortable: `el` must be HTMLElement, and not  + {}.toString.call(el);		}
		this.el = el;  root element		this.options = options = _extend({}, options);

		 Export instance		el[expando] = this;
		 Default options		var defaults = {			group: Math.random(),			sort: true,			disabled: false,			store: null,			handle: null,			scroll: true,			scrollSensitivity: 30,			scrollSpeed: 10,			draggable: li.test(el.nodeName) ? li : >*,			ghostClass: sortable-ghost,			chosenClass: sortable-chosen,			dragClass: sortable-drag,			ignore: a, img,			filter: null,			preventOnFilter: true,			animation: 0,			setData: function (dataTransfer, dragEl) {				dataTransfer.setData(Text, dragEl.textContent);			},			dropBubble: false,			dragoverBubble: false,			dataIdAttr: data-id,			delay: 0,			forceFallback: false,			fallbackClass: sortable-fallback,			fallbackOnBody: false,			fallbackTolerance: 0,			fallbackOffset: {x: 0, y: 0}		};

		 Set default options		for (var name in defaults) {			!(name in options) && (options[name] = defaults[name]);		}
		_prepareGroup(options);
		 Bind all private methods		for (var fn in this) {			if (fn.charAt(0) === _ && typeof this[fn] === function) {				this[fn] = this[fn].bind(this);			}		}
		 Setup drag mode		this.nativeDraggable = options.forceFallback ? false : supportDraggable;
		 Bind events		_on(el, mousedown, this._onTapStart);		_on(el, touchstart, this._onTapStart);		_on(el, pointerdown, this._onTapStart);
		if (this.nativeDraggable) {			_on(el, dragover, this);			_on(el, dragenter, this);		}
		touchDragOverListeners.push(this._onDragOver);
		 Restore sorting		options.store && this.sort(options.store.get(this));	}

	Sortable.prototype =   */ {		constructor: Sortable,
		_onTapStart: function (evt) {			var _this = this,				el = this.el,				options = this.options,				preventOnFilter = options.preventOnFilter,				type = evt.type,				touch = evt.touches && evt.touches[0],				target = (touch || evt).target,				originalTarget = evt.target.shadowRoot && evt.path[0] || target,				filter = options.filter,				startIndex;
			_saveInputCheckedState(el);

			 Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.			if (dragEl) {				return;			}
			if (type === mousedown && evt.button !== 0 || options.disabled) {				return;  only left button or enabled			}

			target = _closest(target, options.draggable, el);
			if (!target) {				return;			}
			if (lastDownEl === target) {				 Ignoring duplicate `down`				return;			}
			 Get the index of the dragged element within its parent			startIndex = _index(target, options.draggable);
			 Check filter			if (typeof filter === function) {				if (filter.call(this, evt, target, this)) {					_dispatchEvent(_this, originalTarget, filter, target, el, startIndex);					preventOnFilter && evt.preventDefault();					return;  cancel dnd				}			}			else if (filter) {				filter = filter.split(,).some(function (criteria) {					criteria = _closest(originalTarget, criteria.trim(), el);
					if (criteria) {						_dispatchEvent(_this, criteria, filter, target, el, startIndex);						return true;					}				});
				if (filter) {					preventOnFilter && evt.preventDefault();					return;  cancel dnd				}			}
			if (options.handle && !_closest(originalTarget, options.handle, el)) {				return;			}
			 Prepare `dragstart`			this._prepareDragStart(evt, touch, target, startIndex);		},
		_prepareDragStart: function (evt, touch, target, startIndex) {			var _this = this,				el = _this.el,				options = _this.options,				ownerDocument = el.ownerDocument,				dragStartFn;
			if (target && !dragEl && (target.parentNode === el)) {				tapEvt = evt;
				rootEl = el;				dragEl = target;				parentEl = dragEl.parentNode;				nextEl = dragEl.nextSibling;				lastDownEl = target;				activeGroup = options.group;				oldIndex = startIndex;
				this._lastX = (touch || evt).clientX;				this._lastY = (touch || evt).clientY;
				dragEl.style[will-change] = transform;
				dragStartFn = function () {					 Delayed drag has been triggered					 we can re-enable the events: touchmove/mousemove					_this._disableDelayedDrag();
					 Make the element draggable					dragEl.draggable = _this.nativeDraggable;
					 Chosen item					_toggleClass(dragEl, options.chosenClass, true);
					 Bind the events: dragstart/dragend					_this._triggerDragStart(evt, touch);
					 Drag start event					_dispatchEvent(_this, rootEl, choose, dragEl, rootEl, oldIndex);				};
				 Disable ""draggable""				options.ignore.split(,).forEach(function (criteria) {					_find(dragEl, criteria.trim(), _disableDraggable);				});
				_on(ownerDocument, mouseup, _this._onDrop);				_on(ownerDocument, touchend, _this._onDrop);				_on(ownerDocument, touchcancel, _this._onDrop);				_on(ownerDocument, pointercancel, _this._onDrop);				_on(ownerDocument, selectstart, _this);
				if (options.delay) {					 If the user moves the pointer or let go the click or touch					 before the delay has been reached:					 disable the delayed drag					_on(ownerDocument, mouseup, _this._disableDelayedDrag);					_on(ownerDocument, touchend, _this._disableDelayedDrag);					_on(ownerDocument, touchcancel, _this._disableDelayedDrag);					_on(ownerDocument, mousemove, _this._disableDelayedDrag);					_on(ownerDocument, touchmove, _this._disableDelayedDrag);					_on(ownerDocument, pointermove, _this._disableDelayedDrag);
					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);				} else {					dragStartFn();				}

			}		},
		_disableDelayedDrag: function () {			var ownerDocument = this.el.ownerDocument;
			clearTimeout(this._dragStartTimer);			_off(ownerDocument, mouseup, this._disableDelayedDrag);			_off(ownerDocument, touchend, this._disableDelayedDrag);			_off(ownerDocument, touchcancel, this._disableDelayedDrag);			_off(ownerDocument, mousemove, this._disableDelayedDrag);			_off(ownerDocument, touchmove, this._disableDelayedDrag);			_off(ownerDocument, pointermove, this._disableDelayedDrag);		},
		_triggerDragStart: function (evt, touch) {			touch = touch || (evt.pointerType == touch ? evt : null);
			if (touch) {				 Touch device support				tapEvt = {					target: dragEl,					clientX: touch.clientX,					clientY: touch.clientY				};
				this._onDragStart(tapEvt, touch);			}			else if (!this.nativeDraggable) {				this._onDragStart(tapEvt, true);			}			else {				_on(dragEl, dragend, this);				_on(rootEl, dragstart, this._onDragStart);			}
			try {				if (document.selection) {										 Timeout neccessary for IE9										setTimeout(function () {						document.selection.empty();					});									} else {					window.getSelection().removeAllRanges();				}			} catch (err) {			}		},
		_dragStarted: function () {			if (rootEl && dragEl) {				var options = this.options;
				 Apply effect				_toggleClass(dragEl, options.ghostClass, true);				_toggleClass(dragEl, options.dragClass, false);
				Sortable.active = this;
				 Drag start event				_dispatchEvent(this, rootEl, start, dragEl, rootEl, oldIndex);			} else {				this._nulling();			}		},
		_emulateDragOver: function () {			if (touchEvt) {				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {					return;				}
				this._lastX = touchEvt.clientX;				this._lastY = touchEvt.clientY;
				if (!supportCssPointerEvents) {					_css(ghostEl, display, none);				}
				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),					parent = target,					i = touchDragOverListeners.length;
				if (parent) {					do {						if (parent[expando]) {							while (i--) {								touchDragOverListeners[i]({									clientX: touchEvt.clientX,									clientY: touchEvt.clientY,									target: target,									rootEl: parent								});							}
							break;						}
						target = parent;  store last element					}					/* jshint boss:true */					while (parent = parent.parentNode);				}
				if (!supportCssPointerEvents) {					_css(ghostEl, display, );				}			}		},

		_onTouchMove: function (/**TouchEvent*/evt) {			if (tapEvt) {				var	options = this.options,					fallbackTolerance = options.fallbackTolerance,					fallbackOffset = options.fallbackOffset,					touch = evt.touches ? evt.touches[0] : evt,					dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,					dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,					translate3d = evt.touches ? translate3d( + dx + px, + dy + px,0) : translate( + dx + px, + dy + px);
				 only set the status to dragging, when we are actually dragging				if (!Sortable.active) {					if (fallbackTolerance &&						min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance					) {						return;					}
					this._dragStarted();				}
				 as well as creating the ghost element on the document body				this._appendGhost();
				moved = true;				touchEvt = touch;
				_css(ghostEl, webkitTransform, translate3d);				_css(ghostEl, mozTransform, translate3d);				_css(ghostEl, msTransform, translate3d);				_css(ghostEl, transform, translate3d);
				evt.preventDefault();			}		},
		_appendGhost: function () {			if (!ghostEl) {				var rect = dragEl.getBoundingClientRect(),					css = _css(dragEl),					options = this.options,					ghostRect;
				ghostEl = dragEl.cloneNode(true);
				_toggleClass(ghostEl, options.ghostClass, false);				_toggleClass(ghostEl, options.fallbackClass, true);				_toggleClass(ghostEl, options.dragClass, true);
				_css(ghostEl, top, rect.top - parseInt(css.marginTop, 10));				_css(ghostEl, left, rect.left - parseInt(css.marginLeft, 10));				_css(ghostEl, width, rect.width);				_css(ghostEl, height, rect.height);				_css(ghostEl, opacity, 0.8);				_css(ghostEl, position, fixed);				_css(ghostEl, zIndex, 100000);				_css(ghostEl, pointerEvents, none);
				options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
				 Fixing dimensions.				ghostRect = ghostEl.getBoundingClientRect();				_css(ghostEl, width, rect.width * 2 - ghostRect.width);				_css(ghostEl, height, rect.height * 2 - ghostRect.height);			}		},
		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {			var dataTransfer = evt.dataTransfer,				options = this.options;
			this._offUpEvents();
			if (activeGroup.checkPull(this, this, dragEl, evt)) {				cloneEl = _clone(dragEl);
				cloneEl.draggable = false;				cloneEl.style[will-change] = ;
				_css(cloneEl, display, none);				_toggleClass(cloneEl, this.options.chosenClass, false);
				rootEl.insertBefore(cloneEl, dragEl);				_dispatchEvent(this, rootEl, clone, dragEl);			}
			_toggleClass(dragEl, options.dragClass, true);
			if (useFallback) {				if (useFallback === touch) {					 Bind touch events					_on(document, touchmove, this._onTouchMove);					_on(document, touchend, this._onDrop);					_on(document, touchcancel, this._onDrop);					_on(document, pointermove, this._onTouchMove);					_on(document, pointerup, this._onDrop);				} else {					 Old brwoser					_on(document, mousemove, this._onTouchMove);					_on(document, mouseup, this._onDrop);				}
				this._loopId = setInterval(this._emulateDragOver, 50);			}			else {				if (dataTransfer) {					dataTransfer.effectAllowed = move;					options.setData && options.setData.call(this, dataTransfer, dragEl);				}
				_on(document, drop, this);				setTimeout(this._dragStarted, 0);			}		},
		_onDragOver: function (/**Event*/evt) {			var el = this.el,				target,				dragRect,				targetRect,				revert,				options = this.options,				group = options.group,				activeSortable = Sortable.active,				isOwner = (activeGroup === group),				isMovingBetweenSortable = false,				canSort = options.sort;
			if (evt.preventDefault !== void 0) {				evt.preventDefault();				!options.dragoverBubble && evt.stopPropagation();			}
			if (dragEl.animated) {				return;			}
			moved = true;
			if (activeSortable && !options.disabled &&				(isOwner					? canSort || (revert = !rootEl.contains(dragEl))  Reverting item into the original list					: (						putSortable === this ||						(							(activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&							group.checkPut(this, activeSortable, dragEl, evt)						)					)				) &&				(evt.rootEl === void 0 || evt.rootEl === this.el)  touch fallback			) {				 Smart auto-scrolling				_autoScroll(evt, options, this.el);
				if (_silent) {					return;				}
				target = _closest(evt.target, options.draggable, el);				dragRect = dragEl.getBoundingClientRect();
				if (putSortable !== this) {					putSortable = this;					isMovingBetweenSortable = true;				}
				if (revert) {					_cloneHide(activeSortable, true);					parentEl = rootEl;  actualization
					if (cloneEl || nextEl) {						rootEl.insertBefore(dragEl, cloneEl || nextEl);					}					else if (!canSort) {						rootEl.appendChild(dragEl);					}
					return;				}

				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||					(el === evt.target) && (target = _ghostIsLast(el, evt))				) {					if (target) {						if (target.animated) {							return;						}
						targetRect = target.getBoundingClientRect();					}
					_cloneHide(activeSortable, isOwner);
					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {						if (!dragEl.contains(el)) {							el.appendChild(dragEl);							parentEl = el;  actualization						}
						this._animate(dragRect, dragEl);						target && this._animate(targetRect, target);					}				}				else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {					if (lastEl !== target) {						lastEl = target;						lastCSS = _css(target);						lastParentCSS = _css(target.parentNode);					}
					targetRect = target.getBoundingClientRect();
					var width = targetRect.right - targetRect.left,						height = targetRect.bottom - targetRect.top,						floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)							|| (lastParentCSS.display == flex && lastParentCSS[flex-direction].indexOf(row) === 0),						isWide = (target.offsetWidth > dragEl.offsetWidth),						isLong = (target.offsetHeight > dragEl.offsetHeight),						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,						nextSibling = target.nextElementSibling,						moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt),						after = false					;
					if (moveVector !== false) {						_silent = true;						setTimeout(_unsilent, 30);
						_cloneHide(activeSortable, isOwner);
						if (moveVector === 1 || moveVector === -1) {							after = (moveVector === 1);						}						else if (floating) {							var elTop = dragEl.offsetTop,								tgTop = target.offsetTop;
							if (elTop === tgTop) {								after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;							}							else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {								after = (evt.clientY - targetRect.top) / height > 0.5;							} else {								after = tgTop > elTop;							}						} else if (!isMovingBetweenSortable) {							after = (nextSibling !== dragEl) && !isLong || halfway && isLong;						}
						if (!dragEl.contains(el)) {							if (after && !nextSibling) {								el.appendChild(dragEl);							} else {								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);							}						}
						parentEl = dragEl.parentNode;  actualization
						this._animate(dragRect, dragEl);						this._animate(targetRect, target);					}				}			}		},
		_animate: function (prevRect, target) {			var ms = this.options.animation;
			if (ms) {				var currentRect = target.getBoundingClientRect();
				if (prevRect.nodeType === 1) {					prevRect = prevRect.getBoundingClientRect();				}
				_css(target, transition, none);				_css(target, transform, translate3d(					+ (prevRect.left - currentRect.left) + px,					+ (prevRect.top - currentRect.top) + px,0)				);
				target.offsetWidth;  repaint
				_css(target, transition, all  + ms + ms);				_css(target, transform, translate3d(0,0,0));
				clearTimeout(target.animated);				target.animated = setTimeout(function () {					_css(target, transition, );					_css(target, transform, );					target.animated = false;				}, ms);			}		},
		_offUpEvents: function () {			var ownerDocument = this.el.ownerDocument;
			_off(document, touchmove, this._onTouchMove);			_off(document, pointermove, this._onTouchMove);			_off(ownerDocument, mouseup, this._onDrop);			_off(ownerDocument, touchend, this._onDrop);			_off(ownerDocument, pointerup, this._onDrop);			_off(ownerDocument, touchcancel, this._onDrop);			_off(ownerDocument, selectstart, this);		},
		_onDrop: function (/**Event*/evt) {			var el = this.el,				options = this.options;
			clearInterval(this._loopId);			clearInterval(autoScroll.pid);			clearTimeout(this._dragStartTimer);
			 Unbind events			_off(document, mousemove, this._onTouchMove);
			if (this.nativeDraggable) {				_off(document, drop, this);				_off(el, dragstart, this._onDragStart);			}
			this._offUpEvents();
			if (evt) {				if (moved) {					evt.preventDefault();					!options.dropBubble && evt.stopPropagation();				}
				ghostEl && ghostEl.parentNode.removeChild(ghostEl);
				if (rootEl === parentEl || Sortable.active.lastPullMode !== clone) {					 Remove clone					cloneEl && cloneEl.parentNode.removeChild(cloneEl);				}
				if (dragEl) {					if (this.nativeDraggable) {						_off(dragEl, dragend, this);					}
					_disableDraggable(dragEl);					dragEl.style[will-change] = ;
					 Remove class's					_toggleClass(dragEl, this.options.ghostClass, false);					_toggleClass(dragEl, this.options.chosenClass, false);
					if (rootEl !== parentEl) {						newIndex = _index(dragEl, options.draggable);
						if (newIndex >= 0) {							 Add event							_dispatchEvent(null, parentEl, add, dragEl, rootEl, oldIndex, newIndex);
							 Remove event							_dispatchEvent(this, rootEl, remove, dragEl, rootEl, oldIndex, newIndex);
							 drag from one list and drop into another							_dispatchEvent(null, parentEl, sort, dragEl, rootEl, oldIndex, newIndex);							_dispatchEvent(this, rootEl, sort, dragEl, rootEl, oldIndex, newIndex);						}					}					else {						if (dragEl.nextSibling !== nextEl) {							 Get the index of the dragged element within its parent							newIndex = _index(dragEl, options.draggable);
							if (newIndex >= 0) {								 drag & drop within the same list								_dispatchEvent(this, rootEl, update, dragEl, rootEl, oldIndex, newIndex);								_dispatchEvent(this, rootEl, sort, dragEl, rootEl, oldIndex, newIndex);							}						}					}
					if (Sortable.active) {						/* jshint eqnull:true */						if (newIndex == null || newIndex === -1) {							newIndex = oldIndex;						}
						_dispatchEvent(this, rootEl, end, dragEl, rootEl, oldIndex, newIndex);
						 Save sorting						this.save();					}				}
			}
			this._nulling();		},
		_nulling: function() {			rootEl =			dragEl =			parentEl =			ghostEl =			nextEl =			cloneEl =			lastDownEl =
			scrollEl =			scrollParentEl =
			tapEvt =			touchEvt =
			moved =			newIndex =
			lastEl =			lastCSS =
			putSortable =			activeGroup =			Sortable.active = null;
			savedInputChecked.forEach(function (el) {				el.checked = true;			});			savedInputChecked.length = 0;		},
		handleEvent: function (/**Event*/evt) {			switch (evt.type) {				case drop:				case dragend:					this._onDrop(evt);					break;
				case dragover:				case dragenter:					if (dragEl) {						this._onDragOver(evt);						_globalDragOver(evt);					}					break;
				case selectstart:					evt.preventDefault();					break;			}		},

		/**		 * Serializes the item into an array of string.		 *  		 */		toArray: function () {			var order = [],				el,				children = this.el.children,				i = 0,				n = children.length,				options = this.options;
			for (; i < n; i++) {				el = children[i];				if (_closest(el, options.draggable, this.el)) {					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));				}			}
			return order;		},

		/**		 * Sorts the elements according to the array.		 *       order of the items		 */		sort: function (order) {			var items = {}, rootEl = this.el;
			this.toArray().forEach(function (id, i) {				var el = rootEl.children[i];
				if (_closest(el, this.options.draggable, rootEl)) {					items[id] = el;				}			}, this);
			order.forEach(function (id) {				if (items[id]) {					rootEl.removeChild(items[id]);					rootEl.appendChild(items[id]);				}			});		},

		/**		 * Save the current sorting		 */		save: function () {			var store = this.options.store;			store && store.set(this);		},

		/**		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.		 *      		 *             default: `options.draggable`		 *  		 */		closest: function (el, selector) {			return _closest(el, selector || this.options.draggable, this.el);		},

		/**		 * Set/get option		 *     		 *          		 *  		 */		option: function (name, value) {			var options = this.options;
			if (value === void 0) {				return options[name];			} else {				options[name] = value;
				if (name === group) {					_prepareGroup(options);				}			}		},

		/**		 * Destroy		 */		destroy: function () {			var el = this.el;
			el[expando] = null;
			_off(el, mousedown, this._onTapStart);			_off(el, touchstart, this._onTapStart);			_off(el, pointerdown, this._onTapStart);
			if (this.nativeDraggable) {				_off(el, dragover, this);				_off(el, dragenter, this);			}
			 Remove draggable attributes			Array.prototype.forEach.call(el.querySelectorAll([draggable]), function (el) {				el.removeAttribute(draggable);			});
			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);
			this._onDrop();
			this.el = el = null;		}	};

	function _cloneHide(sortable, state) {		if (sortable.lastPullMode !== clone) {			state = true;		}
		if (cloneEl && (cloneEl.state !== state)) {			_css(cloneEl, display, state ? none : );
			if (!state) {				if (cloneEl.state) {					if (sortable.options.group.revertClone) {						rootEl.insertBefore(cloneEl, nextEl);						sortable._animate(dragEl, cloneEl);					} else {						rootEl.insertBefore(cloneEl, dragEl);					}				}			}
			cloneEl.state = state;		}	}

	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {		if (el) {			ctx = ctx || document;
			do {				if ((selector === >* && el.parentNode === ctx) || _matches(el, selector)) {					return el;				}				/* jshint boss:true */			} while (el = _getParentOrHost(el));		}
		return null;	}

	function _getParentOrHost(el) {		var parent = el.host;
		return (parent && parent.nodeType) ? parent : el.parentNode;	}

	function _globalDragOver(/**Event*/evt) {		if (evt.dataTransfer) {			evt.dataTransfer.dropEffect = move;		}		evt.preventDefault();	}

	function _on(el, event, fn) {		el.addEventListener(event, fn, captureMode);	}

	function _off(el, event, fn) {		el.removeEventListener(event, fn, captureMode);	}

	function _toggleClass(el, name, state) {		if (el) {			if (el.classList) {				el.classList[state ? add : remove](name);			}			else {				var className = (  + el.className +  ).replace(R_SPACE,  ).replace(  + name +  ,  );				el.className = (className + (state ?   + name : )).replace(R_SPACE,  );			}		}	}

	function _css(el, prop, val) {		var style = el && el.style;
		if (style) {			if (val === void 0) {				if (document.defaultView && document.defaultView.getComputedStyle) {					val = document.defaultView.getComputedStyle(el, );				}				else if (el.currentStyle) {					val = el.currentStyle;				}
				return prop === void 0 ? val : val[prop];			}			else {				if (!(prop in style)) {					prop = -webkit- + prop;				}
				style[prop] = val + (typeof val === string ?  : px);			}		}	}

	function _find(ctx, tagName, iterator) {		if (ctx) {			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
			if (iterator) {				for (; i < n; i++) {					iterator(list[i], i);				}			}
			return list;		}
		return [];	}


	function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {		sortable = (sortable || rootEl[expando]);
		var evt = document.createEvent(Event),			options = sortable.options,			onName = on + name.charAt(0).toUpperCase() + name.substr(1);
		evt.initEvent(name, true, true);
		evt.to = rootEl;		evt.from = fromEl || rootEl;		evt.item = targetEl || rootEl;		evt.clone = cloneEl;
		evt.oldIndex = startIndex;		evt.newIndex = newIndex;
		rootEl.dispatchEvent(evt);
		if (options[onName]) {			options[onName].call(sortable, evt);		}	}

	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt) {		var evt,			sortable = fromEl[expando],			onMoveFn = sortable.options.onMove,			retVal;
		evt = document.createEvent(Event);		evt.initEvent(move, true, true);
		evt.to = toEl;		evt.from = fromEl;		evt.dragged = dragEl;		evt.draggedRect = dragRect;		evt.related = targetEl || toEl;		evt.relatedRect = targetRect || toEl.getBoundingClientRect();
		fromEl.dispatchEvent(evt);
		if (onMoveFn) {			retVal = onMoveFn.call(sortable, evt, originalEvt);		}
		return retVal;	}

	function _disableDraggable(el) {		el.draggable = false;	}

	function _unsilent() {		_silent = false;	}

	  */	function _ghostIsLast(el, evt) {		var lastEl = el.lastElementChild,			rect = lastEl.getBoundingClientRect();
		 5 — min delta		 abs — нельзя добавлять, а то глюки при наведении сверху		return (			(evt.clientY - (rect.top + rect.height) > 5) ||			(evt.clientX - (rect.right + rect.width) > 5)		) && lastEl;	}

	/**	 * Generate id	 *     	 *  	 * 	 */	function _generateId(el) {		var str = el.tagName + el.className + el.src + el.href + el.textContent,			i = str.length,			sum = 0;
		while (i--) {			sum += str.charCodeAt(i);		}
		return sum.toString(36);	}
	/**	 * Returns the index of an element within its parent for a selected set of	 * elements	 *    	 *    	 *  	 */	function _index(el, selector) {		var index = 0;
		if (!el || !el.parentNode) {			return -1;		}
		while (el && (el = el.previousElementSibling)) {			if ((el.nodeName.toUpperCase() !== TEMPLATE) && (selector === >* || _matches(el, selector))) {				index++;			}		}
		return index;	}
	function _matches(/**HTMLElement*/el, /**String*/selector) {		if (el) {			selector = selector.split(.);
			var tag = selector.shift().toUpperCase(),				re = new RegExp(s( + selector.join(|) + )(?=s), g);
			return (				(tag ===  || el.nodeName.toUpperCase() == tag) &&				(!selector.length || ((  + el.className +  ).match(re) || []).length == selector.length)			);		}
		return false;	}
	function _throttle(callback, ms) {		var args, _this;
		return function () {			if (args === void 0) {				args = arguments;				_this = this;
				setTimeout(function () {					if (args.length === 1) {						callback.call(_this, args[0]);					} else {						callback.apply(_this, args);					}
					args = void 0;				}, ms);			}		};	}
	function _extend(dst, src) {		if (dst && src) {			for (var key in src) {				if (src.hasOwnProperty(key)) {					dst[key] = src[key];				}			}		}
		return dst;	}
	function _clone(el) {		return $			? $(el).clone(true)[0]			: (Polymer && Polymer.dom				? Polymer.dom(el).cloneNode(true)				: el.cloneNode(true)			);	}
	function _saveInputCheckedState(root) {		var inputs = root.getElementsByTagName(input);		var idx = inputs.length;
		while (idx--) {			var el = inputs[idx];			el.checked && savedInputChecked.push(el);		}	}
	 Fixed #973: 	_on(document, touchmove, function (evt) {		if (Sortable.active) {			evt.preventDefault();		}	});
	try {		window.addEventListener(test, null, Object.defineProperty({}, passive, {			get: function () {				captureMode = {					capture: false,					passive: false				};			}		}));	} catch (err) {}
	 Export utils	Sortable.utils = {		on: _on,		off: _off,		css: _css,		find: _find,		is: function (el, selector) {			return !!_closest(el, selector, el);		},		extend: _extend,		throttle: _throttle,		closest: _closest,		toggleClass: _toggleClass,		clone: _clone,		index: _index	};

	/**	 * Create sortable instance	 *    	 *        	 */	Sortable.create = function (el, options) {		return new Sortable(el, options);	};

	 Export	Sortable.version = 1.5.1;	return Sortable;});"
"module.exports = function (grunt) {	use strict;
	grunt.initConfig({		pkg: grunt.file.readJSON(package.json),
		version: {			js: {				src: [<%= pkg.exportName %>.js, *.json]			},			cdn: {				options: {					prefix: (cdnjs.cloudflare.com/ajax/libs/Sortable|cdn.jsdelivr.net/sortable)/,					replace: [0-9.]+				},				src: [README.md]			}		},
		jshint: {			all: [*.js, !*.min.js],
			options: {				jshintrc: true			}		},
		uglify: {			options: {				banner: /*! <%= pkg.exportName %> <%= pkg.version %> - <%= pkg.license %> | <%= pkg.repository.url %> */			},			dist: {				files: {					<%= pkg.exportName %>.min.js: [<%= pkg.exportName %>.js]				}			},			jquery: {				files: {}			}		},
		jquery: {}	});

	grunt.registerTask(jquery, function (exportName, uglify) {		if (exportName == min) {			exportName = null;			uglify = min;		}
		if (!exportName) {			exportName = sortable;		}
		var fs = require(fs),			filename = jquery.fn. + exportName + .js;
		grunt.log.oklns(filename);
		fs.writeFileSync(			filename,			(fs.readFileSync(jquery.binding.js) + )				.replace($.fn.sortable, $.fn. + exportName)				.replace(/* CODE */,					(fs.readFileSync(Sortable.js) + )						.replace(function(var)Export, $1)				)		);
		if (uglify) {			var opts = {};
			opts[jquery.fn. + exportName + .min.js] = filename;			grunt.config.set(uglify.jquery.files, opts);
			grunt.task.run(uglify:jquery);		}	});

	grunt.loadNpmTasks(grunt-version);	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-uglify);
	grunt.registerTask(tests, [jshint]);	grunt.registerTask(default, [tests, version, uglify:dist]);};"
"var webpack = require(webpack)var webpackDevMiddleware = require(webpack-dev-middleware)var webpackHotMiddleware = require(webpack-hot-middleware)var config = require(./webpack.config.dev)
var app = new (require(express))()var port = 3001
var compiler = webpack(config)app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }))app.use(webpackHotMiddleware(compiler))
app.get(/, function(req, res) {  res.sendFile(__dirname + /index.html)})
app.listen(port, function(error) {  if (error) {    console.error(error)  } else {    console.info(==> 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser., port, port)  }})"
"import babel-polyfill;import React, {Component} from react;import {render} from react-dom;import {SortableContainer, SortableElement, arrayMove} from ./src/index;import range from lodash/range;import random from lodash/random;
const SortableItem = SortableElement(({height, value}) => (    <div style={{        position: relative,        width: 100%,        display: block,        padding: 20,        backgroundColor: #FFF,        borderBottom: 1px solid #EFEFEF,        boxSizing: border-box,        WebkitUserSelect: none,        height: height    }}>        Item {value}    </div>));
const SortableList = SortableContainer(({items}) => (    <div style={{        width: 80%,        height: 80vh,        maxWidth: 500px,        margin: 0 auto,        overflow: auto,        backgroundColor: #f3f3f3,        border: 1px solid #EFEFEF,        borderRadius: 3    }}>        {items.map(({height, value}, index) => <SortableItem key={item-} index={index} value={value} height={height}/>)}    </div>));
class Example extends Component {    state = {        items: range(100).map((value) => {            return {                value,                height: random(49, 120)            };        })    };    onSortEnd = ({oldIndex, newIndex}) => {        let {items} = this.state;
        this.setState({            items: arrayMove(items, oldIndex, newIndex)        });    };    render() {        const {items} = this.state;
        return <SortableList items={items} onSortEnd={this.onSortEnd} />;    }}
render(<Example />,  document.getElementById(root))"
"var sass = require(node-sass);
module.exports = function processSass(data, filename) {    var result;    result = sass.renderSync({        data: data,        file: filename    }).css;    return result.toString(utf8);};"
"/** * angular-drag-and-drop-lists v2.1.0 * * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc * Copyright (c) 2014-2017 Google Inc. * https://github.com/marceljuenemann/angular-drag-and-drop-lists * * License: MIT */(function(dndLists) {
   In standard-compliant browsers we use a custom mime type and also encode the dnd-type in it.   However, IE and Edge only support a limited number of mime types. The workarounds are described   in https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design  var MIME_TYPE = application/x-dnd;  var EDGE_MIME_TYPE = application/json;  var MSIE_MIME_TYPE = Text;
   All valid HTML5 drop effects, in the order in which we prefer to use them.  var ALL_EFFECTS = [move, copy, link];
  /**   * Use the dnd-draggable attribute to make your element draggable   *   * Attributes:   * - dnd-draggable      Required attribute. The value has to be an object that represents the data   *                      of the element. In case of a drag and drop operation the object will be   *                      serialized and unserialized on the receiving end.   * - dnd-effect-allowed Use this attribute to limit the operations that can be performed. Valid   *                      options are ""move"", ""copy"" and ""link"", as well as ""all"", ""copyMove"",   *                      ""copyLink"" and ""linkMove"". The semantics of these operations are up to you   *                      and have to be implemented using the callbacks described below. If you   *                      allow multiple options, the user can choose between them by using the   *                      modifier keys (OS specific). The cursor will be changed accordingly,   *                      expect for IE and Edge, where this is not supported.   * - dnd-type           Use this attribute if you have different kinds of items in your   *                      application and you want to limit which items can be dropped into which   *                      lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute   *                      must be a lower case string. Upper case characters can be used, but will   *                      be converted to lower case automatically.   * - dnd-disable-if     You can use this attribute to dynamically disable the draggability of the   *                      element. This is useful if you have certain list items that you don't want   *                      to be draggable, or if you want to disable drag & drop completely without   *                      having two different code branches (e.g. only allow for admins).   *   * Callbacks:   * - dnd-dragstart      Callback that is invoked when the element was dragged. The original   *                      dragstart event will be provided in the local event variable.   * - dnd-moved          Callback that is invoked when the element was moved. Usually you will   *                      remove your element from the original list in this callback, since the   *                      directive is not doing that for you automatically. The original dragend   *                      event will be provided in the local event variable.   * - dnd-copied         Same as dnd-moved, just that it is called when the element was copied   *                      instead of moved, so you probably want to implement a different logic.   * - dnd-linked         Same as dnd-moved, just that it is called when the element was linked   *                      instead of moved, so you probably want to implement a different logic.   * - dnd-canceled       Callback that is invoked if the element was dragged, but the operation was   *                      canceled and the element was not dropped. The original dragend event will   *                      be provided in the local event variable.   * - dnd-dragend        Callback that is invoked when the drag operation ended. Available local   *                      variables are event and dropEffect.   * - dnd-selected       Callback that is invoked when the element was clicked but not dragged.   *                      The original click event will be provided in the local event variable.   * - dnd-callback       Custom callback that is passed to dropzone callbacks and can be used to   *                      communicate between source and target scopes. The dropzone can pass user   *                      defined variables to this callback.   *   * CSS classes:   * - dndDragging        This class will be added to the element while the element is being   *                      dragged. It will affect both the element you see while dragging and the   *                      source element that stays at it's position. Do not try to hide the source   *                      element with this class, because that will abort the drag operation.   * - dndDraggingSource  This class will be added to the element after the drag operation was   *                      started, meaning it only affects the original element that is still at   *                      it's source position, and not the ""element"" that the user is dragging with   *                      his mouse pointer.   */  dndLists.directive(dndDraggable, [$parse, $timeout, function($parse, $timeout) {    return function(scope, element, attr) {       Set the HTML5 draggable attribute on the element.      element.attr(draggable, true);
       If the dnd-disable-if attribute is set, we have to watch that.      if (attr.dndDisableIf) {        scope.$watch(attr.dndDisableIf, function(disabled) {          element.attr(draggable, !disabled);        });      }
      /**       * When the drag operation is started we have to prepare the dataTransfer object,       * which is the primary way we communicate with the target element       */      element.on(dragstart, function(event) {        event = event.originalEvent || event;
         Check whether the element is draggable, since dragstart might be triggered on a child.        if (element.attr(draggable) == false) return true;
         Initialize global state.        dndState.isDragging = true;        dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase();
         Set the allowed drop effects. See below for special IE handling.        dndState.dropEffect = none;        dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0];        event.dataTransfer.effectAllowed = dndState.effectAllowed;
         Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:         https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design        var item = scope.$eval(attr.dndDraggable);        var mimeType = MIME_TYPE + (dndState.itemType ? (- + dndState.itemType) : );        try {          event.dataTransfer.setData(mimeType, angular.toJson(item));        } catch (e) {           Setting a custom MIME type did not work, we are probably in IE or Edge.          var data = angular.toJson({item: item, type: dndState.itemType});          try {            event.dataTransfer.setData(EDGE_MIME_TYPE, data);          } catch (e) {             We are in Internet Explorer and can only use the Text MIME type. Also note that IE             does not allow changing the cursor in the dragover event, therefore we have to choose             the one we want to display now by setting effectAllowed.            var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);            event.dataTransfer.effectAllowed = effectsAllowed[0];            event.dataTransfer.setData(MSIE_MIME_TYPE, data);          }        }
         Add CSS classes. See documentation above.        element.addClass(dndDragging);        $timeout(function() { element.addClass(dndDraggingSource); }, 0);
         Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).        if (event._dndHandle && event.dataTransfer.setDragImage) {          event.dataTransfer.setDragImage(element[0], 0, 0);        }
         Invoke dragstart callback and prepare extra callback for dropzone.        $parse(attr.dndDragstart)(scope, {event: event});        if (attr.dndCallback) {          var callback = $parse(attr.dndCallback);          dndState.callback = function(params) { return callback(scope, params || {}); };        }
        event.stopPropagation();      });
      /**       * The dragend event is triggered when the element was dropped or when the drag       * operation was aborted (e.g. hit escape button). Depending on the executed action       * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.       */      element.on(dragend, function(event) {        event = event.originalEvent || event;
         Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine         the used effect, but Chrome has not implemented that field correctly. On Windows         it always sets it to 'none', while Chrome on Linux sometimes sets it to something         else when it's supposed to send 'none' (drag operation aborted).        scope.$apply(function() {          var dropEffect = dndState.dropEffect;          var cb = {copy: dndCopied, link: dndLinked, move: dndMoved, none: dndCanceled};          $parse(attr[cb[dropEffect]])(scope, {event: event});          $parse(attr.dndDragend)(scope, {event: event, dropEffect: dropEffect});        });
         Clean up        dndState.isDragging = false;        dndState.callback = undefined;        element.removeClass(dndDragging);        element.removeClass(dndDraggingSource);        event.stopPropagation();
         In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.        $timeout(function() { element.removeClass(dndDraggingSource); }, 0);      });
      /**       * When the element is clicked we invoke the callback function       * specified with the dnd-selected attribute.       */      element.on(click, function(event) {        if (!attr.dndSelected) return;
        event = event.originalEvent || event;        scope.$apply(function() {          $parse(attr.dndSelected)(scope, {event: event});        });
         Prevent triggering dndSelected in parent elements.        event.stopPropagation();      });
      /**       * Workaround to make element draggable in IE9       */      element.on(selectstart, function() {        if (this.dragDrop) this.dragDrop();      });    };  }]);
  /**   * Use the dnd-list attribute to make your list element a dropzone. Usually you will add a single   * li element as child with the ng-repeat directive. If you don't do that, we will not be able to   * position the dropped element correctly. If you want your list to be sortable, also add the   * dnd-draggable directive to your li element(s).   *   * Attributes:   * - dnd-list             Required attribute. The value has to be the array in which the data of   *                        the dropped element should be inserted. The value can be blank if used   *                        with a custom dnd-drop handler that always returns true.   * - dnd-allowed-types    Optional array of allowed item types. When used, only items that had a   *                        matching dnd-type attribute will be dropable. Upper case characters will   *                        automatically be converted to lower case.   * - dnd-effect-allowed   Optional string expression that limits the drop effects that can be   *                        performed in the list. See dnd-effect-allowed on dnd-draggable for more   *                        details on allowed options. The default value is all.   * - dnd-disable-if       Optional boolean expresssion. When it evaluates to true, no dropping   *                        into the list is possible. Note that this also disables rearranging   *                        items inside the list.   * - dnd-horizontal-list  Optional boolean expresssion. When it evaluates to true, the positioning   *                        algorithm will use the left and right halfs of the list items instead of   *                        the upper and lower halfs.   * - dnd-external-sources Optional boolean expression. When it evaluates to true, the list accepts   *                        drops from sources outside of the current browser tab. This allows to   *                        drag and drop accross different browser tabs. The only major browser   *                        that does not support this is currently Microsoft Edge.   *   * Callbacks:   * - dnd-dragover         Optional expression that is invoked when an element is dragged over the   *                        list. If the expression is set, but does not return true, the element is   *                        not allowed to be dropped. The following variables will be available:   *                        - event: The original dragover event sent by the browser.   *                        - index: The position in the list at which the element would be dropped.   *                        - type: The dnd-type set on the dnd-draggable, or undefined if non was   *                          set. Will be null for drops from external sources in IE and Edge,   *                          since we don't know the type in those cases.   *                        - dropEffect: One of move, copy or link, see dnd-effect-allowed.   *                        - external: Whether the element was dragged from an external source.   *                        - callback: If dnd-callback was set on the source element, this is a   *                          function reference to the callback. The callback can be invoked with   *                          custom variables like this: callback({var1: value1, var2: value2}).   *                          The callback will be executed on the scope of the source element. If   *                          dnd-external-sources was set and external is true, this callback will   *                          not be available.   * - dnd-drop             Optional expression that is invoked when an element is dropped on the   *                        list. The same variables as for dnd-dragover will be available, with the   *                        exception that type is always known and therefore never null. There   *                        will also be an item variable, which is the transferred object. The   *                        return value determines the further handling of the drop:   *                        - falsy: The drop will be canceled and the element won't be inserted.   *                        - true: Signalises that the drop is allowed, but the dnd-drop   *                          callback already took care of inserting the element.   *                        - otherwise: All other return values will be treated as the object to   *                          insert into the array. In most cases you want to simply return the   *                          item parameter, but there are no restrictions on what you can return.   * - dnd-inserted         Optional expression that is invoked after a drop if the element was   *                        actually inserted into the list. The same local variables as for   *                        dnd-drop will be available. Note that for reorderings inside the same   *                        list the old element will still be in the list due to the fact that   *                        dnd-moved was not called yet.   *   * CSS classes:   * - dndPlaceholder       When an element is dragged over the list, a new placeholder child   *                        element will be added. This element is of type li and has the class   *                        dndPlaceholder set. Alternatively, you can define your own placeholder   *                        by creating a child element with dndPlaceholder class.   * - dndDragover          Will be added to the list while an element is dragged over the list.   */  dndLists.directive(dndList, [$parse, function($parse) {    return function(scope, element, attr) {       While an element is dragged over the list, this placeholder element is inserted       at the location where the element would be inserted after dropping.      var placeholder = getPlaceholderElement();      placeholder.remove();
      var placeholderNode = placeholder[0];      var listNode = element[0];      var listSettings = {};
      /**       * The dragenter event is fired when a dragged element or text selection enters a valid drop       * target. According to the spec, we either need to have a dropzone attribute or listen on       * dragenter events and call preventDefault(). It should be noted though that no browser seems       * to enforce this behaviour.       */      element.on(dragenter, function (event) {        event = event.originalEvent || event;
         Calculate list properties, so that we don't have to repeat this on every dragover event.        var types = attr.dndAllowedTypes && scope.$eval(attr.dndAllowedTypes);        listSettings = {          allowedTypes: angular.isArray(types) && types.join(|).toLowerCase().split(|),          disabled: attr.dndDisableIf && scope.$eval(attr.dndDisableIf),          externalSources: attr.dndExternalSources && scope.$eval(attr.dndExternalSources),          horizontal: attr.dndHorizontalList && scope.$eval(attr.dndHorizontalList)        };
        var mimeType = getMimeType(event.dataTransfer.types);        if (!mimeType || !isDropAllowed(getItemType(mimeType))) return true;        event.preventDefault();      });
      /**       * The dragover event is triggered ""every few hundred milliseconds"" while an element       * is being dragged over our list, or over an child element.       */      element.on(dragover, function(event) {        event = event.originalEvent || event;
         Check whether the drop is allowed and determine mime type.        var mimeType = getMimeType(event.dataTransfer.types);        var itemType = getItemType(mimeType);        if (!mimeType || !isDropAllowed(itemType)) return true;
         Make sure the placeholder is shown, which is especially important if the list is empty.        if (placeholderNode.parentNode != listNode) {          element.append(placeholder);        }
        if (event.target != listNode) {           Try to find the node direct directly below the list node.          var listItemNode = event.target;          while (listItemNode.parentNode != listNode && listItemNode.parentNode) {            listItemNode = listItemNode.parentNode;          }
          if (listItemNode.parentNode == listNode && listItemNode != placeholderNode) {             If the mouse pointer is in the upper half of the list item element,             we position the placeholder before the list item, otherwise after it.            var rect = listItemNode.getBoundingClientRect();            if (listSettings.horizontal) {              var isFirstHalf = event.clientX < rect.left + rect.width / 2;            } else {              var isFirstHalf = event.clientY < rect.top + rect.height / 2;            }            listNode.insertBefore(placeholderNode,                isFirstHalf ? listItemNode : listItemNode.nextSibling);          }        }
         In IE we set a fake effectAllowed in dragstart to get the correct cursor, we therefore         ignore the effectAllowed passed in dataTransfer. We must also not access dataTransfer for         drops from external sources, as that throws an exception.        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;        var dropEffect = getDropEffect(event, ignoreDataTransfer);        if (dropEffect == none) return stopDragover();
         At this point we invoke the callback, which still can disallow the drop.         We can't do this earlier because we want to pass the index of the placeholder.        if (attr.dndDragover && !invokeCallback(attr.dndDragover, event, dropEffect, itemType)) {          return stopDragover();        }
         Set dropEffect to modify the cursor shown by the browser, unless we're in IE, where this         is not supported. This must be done after preventDefault in Firefox.        event.preventDefault();        if (!ignoreDataTransfer) {          event.dataTransfer.dropEffect = dropEffect;        }
        element.addClass(dndDragover);        event.stopPropagation();        return false;      });
      /**       * When the element is dropped, we use the position of the placeholder element as the       * position where we insert the transferred data. This assumes that the list has exactly       * one child element per array element.       */      element.on(drop, function(event) {        event = event.originalEvent || event;
         Check whether the drop is allowed and determine mime type.        var mimeType = getMimeType(event.dataTransfer.types);        var itemType = getItemType(mimeType);        if (!mimeType || !isDropAllowed(itemType)) return true;
         The default behavior in Firefox is to interpret the dropped element as URL and         forward to it. We want to prevent that even if our drop is aborted.        event.preventDefault();
         Unserialize the data that was serialized in dragstart.        try {          var data = JSON.parse(event.dataTransfer.getData(mimeType));        } catch(e) {          return stopDragover();        }
         Drops with invalid types from external sources might not have been filtered out yet.        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) {          itemType = data.type || undefined;          data = data.item;          if (!isDropAllowed(itemType)) return stopDragover();        }
         Special handling for internal IE drops, see dragover handler.        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;        var dropEffect = getDropEffect(event, ignoreDataTransfer);        if (dropEffect == none) return stopDragover();
         Invoke the callback, which can transform the transferredObject and even abort the drop.        var index = getPlaceholderIndex();        if (attr.dndDrop) {          data = invokeCallback(attr.dndDrop, event, dropEffect, itemType, index, data);          if (!data) return stopDragover();        }
         The drop is definitely going to happen now, store the dropEffect.        dndState.dropEffect = dropEffect;        if (!ignoreDataTransfer) {          event.dataTransfer.dropEffect = dropEffect;        }
         Insert the object into the array, unless dnd-drop took care of that (returned true).        if (data !== true) {          scope.$apply(function() {            scope.$eval(attr.dndList).splice(index, 0, data);          });        }        invokeCallback(attr.dndInserted, event, dropEffect, itemType, index, data);
         Clean up        stopDragover();        event.stopPropagation();        return false;      });
      /**       * We have to remove the placeholder when the element is no longer dragged over our list. The       * problem is that the dragleave event is not only fired when the element leaves our list,       * but also when it leaves a child element. Therefore, we determine whether the mouse cursor       * is still pointing to an element inside the list or not.       */      element.on(dragleave, function(event) {        event = event.originalEvent || event;
        var newTarget = document.elementFromPoint(event.clientX, event.clientY);        if (listNode.contains(newTarget) && !event._dndPhShown) {           Signalize to potential parent lists that a placeholder is already shown.          event._dndPhShown = true;        } else {          stopDragover();        }      });
      /**       * Given the types array from the DataTransfer object, returns the first valid mime type.       * A type is valid if it starts with MIME_TYPE, or it equals MSIE_MIME_TYPE or EDGE_MIME_TYPE.       */      function getMimeType(types) {        if (!types) return MSIE_MIME_TYPE;  IE 9 workaround.        for (var i = 0; i < types.length; i++) {          if (types[i] == MSIE_MIME_TYPE || types[i] == EDGE_MIME_TYPE ||              types[i].substr(0, MIME_TYPE.length) == MIME_TYPE) {            return types[i];          }        }        return null;      }
      /**       * Determines the type of the item from the dndState, or from the mime type for items from       * external sources. Returns undefined if no item type was set and null if the item type could       * not be determined.       */      function getItemType(mimeType) {        if (dndState.isDragging) return dndState.itemType || undefined;        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) return null;        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;      }
      /**       * Checks various conditions that must be fulfilled for a drop to be allowed, including the       * dnd-allowed-types attribute. If the item Type is unknown (null), the drop will be allowed.       */      function isDropAllowed(itemType) {        if (listSettings.disabled) return false;        if (!listSettings.externalSources && !dndState.isDragging) return false;        if (!listSettings.allowedTypes || itemType === null) return true;        return itemType && listSettings.allowedTypes.indexOf(itemType) != -1;      }
      /**       * Determines which drop effect to use for the given event. In Internet Explorer we have to       * ignore the effectAllowed field on dataTransfer, since we set a fake value in dragstart.       * In those cases we rely on dndState to filter effects. Read the design doc for more details:       * https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design       */      function getDropEffect(event, ignoreDataTransfer) {        var effects = ALL_EFFECTS;        if (!ignoreDataTransfer) {          effects = filterEffects(effects, event.dataTransfer.effectAllowed);        }        if (dndState.isDragging) {          effects = filterEffects(effects, dndState.effectAllowed);        }        if (attr.dndEffectAllowed) {          effects = filterEffects(effects, attr.dndEffectAllowed);        }         MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,         therefore the following modifier keys will only affect other operating systems.        if (!effects.length) {          return none;        } else if (event.ctrlKey && effects.indexOf(copy) != -1) {          return copy;        } else if (event.altKey && effects.indexOf(link) != -1) {          return link;        } else {          return effects[0];        }      }
      /**       * Small helper function that cleans up if we aborted a drop.       */      function stopDragover() {        placeholder.remove();        element.removeClass(dndDragover);        return true;      }
      /**       * Invokes a callback with some interesting parameters and returns the callbacks return value.       */      function invokeCallback(expression, event, dropEffect, itemType, index, item) {        return $parse(expression)(scope, {          callback: dndState.callback,          dropEffect: dropEffect,          event: event,          external: !dndState.isDragging,          index: index !== undefined ? index : getPlaceholderIndex(),          item: item || undefined,          type: itemType        });      }
      /**       * We use the position of the placeholder node to determine at which position of the array the       * object needs to be inserted       */      function getPlaceholderIndex() {        return Array.prototype.indexOf.call(listNode.children, placeholderNode);      }
      /**       * Tries to find a child element that has the dndPlaceholder class set. If none was found, a       * new li element is created.       */      function getPlaceholderElement() {        var placeholder;        angular.forEach(element.children(), function(childNode) {          var child = angular.element(childNode);          if (child.hasClass(dndPlaceholder)) {            placeholder = child;          }        });        return placeholder || angular.element(<li class='dndPlaceholder'></li>);      }    };  }]);
  /**   * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting   * drag operations. This is especially useful if you want to use input elements inside of   * dnd-draggable elements or create specific handle elements. Note: This directive does not work   * in Internet Explorer 9.   */  dndLists.directive(dndNodrag, function() {    return function(scope, element, attr) {       Set as draggable so that we can cancel the events explicitly      element.attr(draggable, true);
      /**       * Since the element is draggable, the browser's default operation is to drag it on dragstart.       * We will prevent that and also stop the event from bubbling up.       */      element.on(dragstart, function(event) {        event = event.originalEvent || event;
        if (!event._dndHandle) {           If a child element already reacted to dragstart and set a dataTransfer object, we will           allow that. For example, this is the case for user selections inside of input elements.          if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {            event.preventDefault();          }          event.stopPropagation();        }      });
      /**       * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element       * would be removed.       */      element.on(dragend, function(event) {        event = event.originalEvent || event;        if (!event._dndHandle) {          event.stopPropagation();        }      });    };  });
  /**   * Use the dnd-handle directive within a dnd-nodrag element in order to allow dragging with that   * element after all. Therefore, by combining dnd-nodrag and dnd-handle you can allow   * dnd-draggable elements to only be dragged via specific ""handle"" elements. Note that Internet   * Explorer will show the handle element as drag image instead of the dnd-draggable element. You   * can work around this by styling the handle element differently when it is being dragged. Use   * the CSS selector .dndDragging:not(.dndDraggingSource) [dnd-handle] for that.   */  dndLists.directive(dndHandle, function() {    return function(scope, element, attr) {      element.attr(draggable, true);
      element.on(dragstart dragend, function(event) {        event = event.originalEvent || event;        event._dndHandle = true;      });    };  });
  /**   * Filters an array of drop effects using a HTML5 effectAllowed string.   */  function filterEffects(effects, effectAllowed) {    if (effectAllowed == all) return effects;    return effects.filter(function(effect) {      return effectAllowed.toLowerCase().indexOf(effect) != -1;    });  }
  /**   * For some features we need to maintain global state. This is done here, with these fields:   * - callback: A callback function set at dragstart that is passed to internal dropzone handlers.   * - dropEffect: Set in dragstart to ""none"" and to the actual value in the drop handler. We don't   *   rely on the dropEffect passed by the browser, since there are various bugs in Chrome and   *   Safari, and Internet Explorer defaults to copy if effectAllowed is copyMove.   * - effectAllowed: Set in dragstart based on dnd-effect-allowed. This is needed for IE because   *   setting effectAllowed on dataTransfer might result in an undesired cursor.   * - isDragging: True between dragstart and dragend. Falsy for drops from external sources.   * - itemType: The item type of the dragged element set via dnd-type. This is needed because IE   *   and Edge don't support custom mime types that we can use to transfer this information.   */  var dndState = {};
})(angular.module(dndLists, []));"
"/* jshint node:true */
use strict;
module.exports = function(grunt) {
  require(load-grunt-tasks)(grunt);
   Default task.  grunt.registerTask(default, [test]);  grunt.registerTask(test, [jshint, karma:unit]);  grunt.registerTask(serve, [karma:continuous, dist, build:gh-pages, connect:continuous, watch]);  grunt.registerTask(dist, [ngmin, surround:main, uglify, surround:banner ]);  grunt.registerTask(coverage, [jshint, karma:coverage]);  grunt.registerTask(junit, [jshint, karma:junit]);

   HACK TO ACCESS TO THE COMPONENT PUBLISHER  function fakeTargetTask(prefix){    return function(){
      if (this.args.length !== 1) {        return grunt.log.fail(Just give the name of the  + prefix +  you want like :grunt  + prefix + :bower);      }
      var done = this.async();      var spawn = require(child_process).spawn;      spawn(./node_modules/.bin/gulp, [ prefix, --branch=+this.args[0] ].concat(grunt.option.flags()), {        cwd : ./node_modules/angular-ui-publisher,        stdio: inherit      }).on(close, done);    };  }
  grunt.registerTask(build, fakeTargetTask(build));  grunt.registerTask(publish, fakeTargetTask(publish));  

   HACK TO MAKE TRAVIS WORK  var testConfig = function(configFile, customOptions) {    var options = { configFile: configFile, singleRun: true };    var travisOptions = process.env.TRAVIS && {      browsers: [Chrome, Firefox],      reporters: [dots, coverage, coveralls],      preprocessors: { src/*.js: [coverage] },      coverageReporter: {        reporters: [{          type: text        }, {          type: lcov,          dir: coverage/        }]      },    };    return grunt.util._.extend(options, customOptions, travisOptions);  };  

   Project configuration.  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),    meta: {      banner: [/**,         * <%= pkg.name %> - <%= pkg.description %>,         * @version v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %>,         * @link <%= pkg.homepage %>,         * @license <%= pkg.license %>,         */,        ].join()    },
    connect: {      options: {        base : out/built/gh-pages,        open: true,        livereload: true      },      server: { options: { keepalive: true } },      continuous: { options: { keepalive: false } }    },
    coveralls: {      options: {        coverage_dir: coverage/,         debug: true         dryRun: true,         force: true,         recursive: true      }    },
    karma: {      unit: testConfig(test/karma.conf.js),      server: {configFile: test/karma.conf.js},      continuous: {configFile: test/karma.conf.js,  background: true },      coverage: {        configFile: test/karma.conf.js,        reporters: [progress, coverage],        preprocessors: { src/*.js: [coverage] },        coverageReporter: {          reporters: [{            type: text          }, {            type: lcov,            dir: coverage/          }]        },        singleRun: true      },      junit: {        configFile: test/karma.conf.js,        reporters: [progress, junit],        junitReporter: {          outputFile: junit/unit.xml,          suite: unit        },        singleRun: true      }    },
    jshint: {      src: {        files:{ src : [src/**/*.js, demo/**/*.js] },        options: { jshintrc: .jshintrc }      },      test: {        files:{ src : [ test/*.js, gruntFile.js] },        options: grunt.util._.extend({}, grunt.file.readJSON(.jshintrc), grunt.file.readJSON(test/.jshintrc))      }    },
    uglify: {      build: {        expand: true,        cwd: dist,        src: [*.js, !*.min.js],        ext: .min.js,        dest: dist      }    },
    surround: {      main: {        expand: true,        cwd: src,        src: [*.js],        dest: dist,        options: {          prepend: [(function(window, angular, undefined) {,                    use strict;].join(),          append: })(window, window.angular);        }      },      banner: {        expand: true,        cwd: dist,        src: [*.js],        dest: dist,        options: {          prepend: <%= meta.banner %>        }      }    },
    ngmin: {      main: {        expand: true,        cwd: src,        src: [*.js],        dest: dist      }    },
    changelog: {      options: {        dest: CHANGELOG.md      }    },
    watch: {      src: {        files: [src/*],        tasks: [jshint:src, karma:unit:run, dist, build:gh-pages]      },      test: {        files: [test/*.js],        tasks: [jshint:test, karma:unit:run]      },      demo: {        files: [demo/*, publish.js],        tasks: [jshint, build:gh-pages]      },      livereload: {        files: [out/built/gh-pages/**/*],        options: { livereload: true }      }    }  });
};"
require(./dist/ng-sortable);module.exports = as.sortable;
"/*jshint undef: false, unused: false, indent: 2*/
module.exports = function (grunt) {  use strict;   load all grunt tasks automatically  require(load-grunt-tasks)(grunt);
  var mountFolder = function (connect, dir) {    return connect.static(require(path).resolve(dir));  };
  var cfg = {    srcDir: source,    buildDir: dist,    demoDir: demo  };
   project configuration  grunt.initConfig({    cfg: cfg,
     watch    watch: {      livereload: {        files: [          <%= cfg.demoDir %>/**/*.js,          <%= cfg.demoDir %>/**/*.css,          <%= cfg.demoDir %>/**/*.html,          !<%= cfg.buildDir %>/*.js,          !<%= cfg.demoDir %>/dist/*.js,          !<%= cfg.demoDir %>/bower_components/**/*        ],        options: {          livereload: true        }      },      build: {        files: [          <%= cfg.srcDir %>/**/*.*,          !<%= cfg.buildDir %>/*.*        ],        tasks: [jshint:source, clean:build, concat:build, uglify:build, cssmin, copy]      },      cssmin: {        files: [          <%= cfg.srcDir %>/**/*.css        ],        tasks: [cssmin, copy]      }    },
     clean up files as part of other tasks    clean: {      build: {        src: [<%= cfg.buildDir %>/**]      },      demo: {        src: [<%= cfg.demoDir %>/dist/**]      }    },
     prepare files for demo    copy: {      build: {        expand: true,        cwd: <%= cfg.srcDir %>/,        src: [*.css],        dest: <%= cfg.buildDir %>/      },      demo: {        files: [          {            expand: true,            src: [<%= cfg.buildDir %>/*.*],            dest: <%= cfg.demoDir %>/          }        ]      }    },
    jshint: {      options: {        jshintrc: true,        reporter: require(jshint-stylish)      },      source: {        files: {          src: [<%= cfg.srcDir %>/**/*.js]        }      },      demo: {        files: {          src: [            <%= cfg.demoDir %>/**/*.js,            !<%= cfg.demoDir %>/bower_components/**/*          ]        }      }    },
     concat    concat: {      build: {        src: [          <%= cfg.srcDir %>/sortable-main.js,          <%= cfg.srcDir %>/sortable-helper.js,          <%= cfg.srcDir %>/sortable.js,          <%= cfg.srcDir %>/sortable-item-handle.js,          <%= cfg.srcDir %>/sortable-item.js        ],        dest: <%= cfg.buildDir %>/ng-sortable.js      }    },
     uglify    uglify: {      options: {        preserveComments: some,        mangle: false      },      build: {        files: {          <%= cfg.buildDir %>/ng-sortable.min.js: [<%= cfg.buildDir %>/ng-sortable.js]        }      }    },
    cssmin: {      add_banner: {        options: {          banner: /* ng-sortable css file */        },        files: {          <%= cfg.buildDir %>/ng-sortable.min.css: [<%= cfg.srcDir %>/ng-sortable.css],          <%= cfg.buildDir %>/ng-sortable.style.min.css: [<%= cfg.srcDir %>/ng-sortable.style.css]        }      }    },
     connect    connect: {      options: {        port: 9009,        livereload: 93729,        hostname: 0.0.0.0      },      demo: {        options: {          middleware: function (connect) {            return [              mountFolder(connect, )            ];          }        }      }    },
     open    open: {      server: {        path: http://localhost:<%= connect.options.port %>/<%= cfg.demoDir %>/      }    },
     karma    karma: {      options: {        configFile: karma.conf.js,        autoWatch: true      },
      single: {        singleRun: true,        browsers: [Chrome]      },
      continuous: {        singleRun: false,        browsers: [Chrome]      }    },
     available tasks    tasks_list: {      options: {},      project: {        options: {          tasks: [            {              name: build,              info: Create a build of (tested) the source files            },            {              name: serve,              info: Build the project, watch file changes and start a web server            },            {              name: test,              info: Runt tests            },            {              name: test:continuous,              info: Runt tests continuously            }          ]        }      }    }  });
   default  grunt.registerTask(default, [tasks_list:project]);  grunt.registerTask(build, [jshint:source, clean:build, concat:build, cssmin, uglify:build, copy]);  grunt.registerTask(serve, [open, connect:demo, watch]);  grunt.registerTask(test, [karma:single]);  grunt.registerTask(test:continuous, [karma:continuous]);};

"
code
"/** * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var spawn = require(child_process).spawn;var readlink = require(graceful-readlink).readlinkSync;var path = require(path);var dirname = path.dirname;var basename = path.basename;var fs = require(fs);
/** * Expose the root command. */
exports = module.exports = new Command();
/** * Expose `Command`. */
exports.Command = Command;
/** * Expose `Option`. */
exports.Option = Option;
/** * Initialize a new `Option` with the given `flags` and `description`. * *    *    * @api public */
function Option(flags, description) {  this.flags = flags;  this.required = ~flags.indexOf(<);  this.optional = ~flags.indexOf([);  this.bool = !~flags.indexOf(-no-);  flags = flags.split();  if (flags.length > 1 && !.test(flags[1])) this.short = flags.shift();  this.long = flags.shift();  this.description = description || ;}
/** * Return option name. * *   * @api private */
Option.prototype.name = function() {  return this.long    .replace(--, )    .replace(no-, );};
/** * Check if `arg` matches the short or long flag. * *    *   * @api private */
Option.prototype.is = function(arg) {  return arg == this.short || arg == this.long;};
/** * Initialize a new `Command`. * *    * @api public */
function Command(name) {  this.commands = [];  this.options = [];  this._execs = {};  this._allowUnknownOption = false;  this._args = [];  this._name = name || ;}
/** * Inherit from `EventEmitter.prototype`. */
Command.prototype.__proto__ = EventEmitter.prototype;
/** * Add command `name`. * * The `.action()` callback is invoked when the * command `name` is specified via __ARGV__, * and the remaining arguments are applied to the * function for access. * * When the `name` is ""*"" an un-matched command * will be passed as the first arg, followed by * the rest of __ARGV__ remaining. * * Examples: * *      program *        .version('0.0.1') *        .option('-C, --chdir <path>', 'change the working directory') *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf') *        .option('-T, --no-tests', 'ignore test hook') * *      program *        .command('setup') *        .description('run remote setup commands') *        .action(function() { *          console.log('setup'); *        }); * *      program *        .command('exec <cmd>') *        .description('run the given remote command') *        .action(function(cmd) { *          console.log('exec ""%s""', cmd); *        }); * *      program *        .command('teardown <dir> [otherDirs...]') *        .description('run teardown commands') *        .action(function(dir, otherDirs) { *          console.log('dir ""%s""', dir); *          if (otherDirs) { *            otherDirs.forEach(function (oDir) { *              console.log('dir ""%s""', oDir); *            }); *          } *        }); * *      program *        .command('*') *        .description('deploy the given env') *        .action(function(env) { *          console.log('deploying ""%s""', env); *        }); * *      program.parse(process.argv);  * *    *    for git-style sub-commands *   the new command * @api public */
Command.prototype.command = function(name, desc, opts) {  opts = opts || {};  var args = name.split( );  var cmd = new Command(args.shift());
  if (desc) {    cmd.description(desc);    this.executables = true;    this._execs[cmd._name] = true;    if (opts.isDefault) this.defaultExecutable = cmd._name;  }
  cmd._noHelp = !!opts.noHelp;  this.commands.push(cmd);  cmd.parseExpectedArgs(args);  cmd.parent = this;
  if (desc) return this;  return cmd;};
/** * Define argument syntax for the top-level command. * * @api public */
Command.prototype.arguments = function (desc) {  return this.parseExpectedArgs(desc.split( ));};
/** * Add an implicit `help [cmd]` subcommand * which invokes `--help` for the given command. * * @api private */
Command.prototype.addImplicitHelpCommand = function() {  this.command(help [cmd], display help for [cmd]);};
/** * Parse expected `args`. * * For example `[""[type]""]` becomes `[{ required: false, name: 'type' }]`. * *    *   for chaining * @api public */
Command.prototype.parseExpectedArgs = function(args) {  if (!args.length) return;  var self = this;  args.forEach(function(arg) {    var argDetails = {      required: false,      name: ,      variadic: false    };
    switch (arg[0]) {      case <:        argDetails.required = true;        argDetails.name = arg.slice(1, -1);        break;      case [:        argDetails.name = arg.slice(1, -1);        break;    }
    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === ...) {      argDetails.variadic = true;      argDetails.name = argDetails.name.slice(0, -3);    }    if (argDetails.name) {      self._args.push(argDetails);    }  });  return this;};
/** * Register callback `fn` for the command. * * Examples: * *      program *        .command('help') *        .description('display verbose help') *        .action(function() { *           // output help here *        }); * *    *   for chaining * @api public */
Command.prototype.action = function(fn) {  var self = this;  var listener = function(args, unknown) {     Parse any so-far unknown options    args = args || [];    unknown = unknown || [];
    var parsed = self.parseOptions(unknown);
     Output help if necessary    outputHelpIfNecessary(self, parsed.unknown);
     If there are still any unknown options, then we simply     die, unless someone asked for help, in which case we give it     to them, and then we die.    if (parsed.unknown.length > 0) {      self.unknownOption(parsed.unknown[0]);    }
     Leftover arguments need to be pushed back. Fixes issue #56    if (parsed.args.length) args = parsed.args.concat(args);
    self._args.forEach(function(arg, i) {      if (arg.required && null == args[i]) {        self.missingArgument(arg.name);      } else if (arg.variadic) {        if (i !== self._args.length - 1) {          self.variadicArgNotLast(arg.name);        }
        args[i] = args.splice(i);      }    });
     Always append ourselves to the end of the arguments,     to make sure we match the number of arguments the user     expects    if (self._args.length) {      args[self._args.length] = self;    } else {      args.push(self);    }
    fn.apply(self, args);  };  var parent = this.parent || this;  var name = parent === this ? * : this._name;  parent.on(name, listener);  if (this._alias) parent.on(this._alias, listener);  return this;};
/** * Define option with `flags`, `description` and optional * coercion `fn`. * * The `flags` string should contain both the short and long flags, * separated by comma, a pipe or space. The following are all valid * all will output this way when `--help` is used. * *    ""-p, --pepper"" *    ""-p|--pepper"" *    ""-p --pepper"" * * Examples: * *     // simple boolean defaulting to false *     program.option('-p, --pepper', 'add pepper'); * *     --pepper *     program.pepper *     // => Boolean * *     // simple boolean defaulting to true *     program.option('-C, --no-cheese', 'remove cheese'); * *     program.cheese *     // => true * *     --no-cheese *     program.cheese *     // => false * *     // required argument *     program.option('-C, --chdir <path>', 'change the working directory'); * *     --chdir /tmp *     program.chdir *     // => ""/tmp"" * *     // optional argument *     program.option('-c, --cheese [type]', 'add cheese [marble]'); * *    *    *    or default *    *   for chaining * @api public */
Command.prototype.option = function(flags, description, fn, defaultValue) {  var self = this    , option = new Option(flags, description)    , oname = option.name()    , name = camelcase(oname);
   default as 3rd arg  if (typeof fn != function) {    if (fn instanceof RegExp) {      var regex = fn;      fn = function(val, def) {        var m = regex.exec(val);        return m ? m[0] : def;      }    }    else {      defaultValue = fn;      fn = null;    }  }
   preassign default value only for --no-*, [optional], or <required>  if (false == option.bool || option.optional || option.required) {     when --no-* we make sure default is true    if (false == option.bool) defaultValue = true;     preassign only if we have a default    if (undefined !== defaultValue) self[name] = defaultValue;  }
   register the option  this.options.push(option);
   when it's passed assign the value   and conditionally invoke the callback  this.on(oname, function(val) {     coercion    if (null !== val && fn) val = fn(val, undefined === self[name]      ? defaultValue      : self[name]);
     unassigned or bool    if (boolean == typeof self[name] || undefined == typeof self[name]) {       if no value, bool true, and we have a default, then use it!      if (null == val) {        self[name] = option.bool          ? defaultValue || true          : false;      } else {        self[name] = val;      }    } else if (null !== val) {       reassign      self[name] = val;    }  });
  return this;};
/** * Allow unknown options on the command line. * *    if `true` or omitted, no error will be thrown * for unknown options. * @api public */Command.prototype.allowUnknownOption = function(arg) {    this._allowUnknownOption = arguments.length === 0 || arg;    return this;};
/** * Parse `argv`, settings options and invoking commands when defined. * *    *   for chaining * @api public */
Command.prototype.parse = function(argv) {   implicit help  if (this.executables) this.addImplicitHelpCommand();
   store raw args  this.rawArgs = argv;
   guess name  this._name = this._name || basename(argv[1], .js);
   github-style sub-commands with no sub-command  if (this.executables && argv.length < 3 && !this.defaultExecutable) {     this user needs help    argv.push(--help);  }
   process argv  var parsed = this.parseOptions(this.normalize(argv.slice(2)));  var args = this.args = parsed.args;
  var result = this.parseArgs(this.args, parsed.unknown);
   executable sub-commands  var name = result.args[0];
  var aliasCommand = null;   check alias of sub commands  if (name) {    aliasCommand = this.commands.filter(function(command) {      return command.alias() === name;    })[0];  }
  if (this._execs[name] && typeof this._execs[name] != function) {    return this.executeSubCommand(argv, args, parsed.unknown);  } else if (aliasCommand) {     is alias of a subCommand    args[0] = aliasCommand._name;    return this.executeSubCommand(argv, args, parsed.unknown);  } else if (this.defaultExecutable) {     use the default subcommand    args.unshift(this.defaultExecutable);    return this.executeSubCommand(argv, args, parsed.unknown);  }
  return result;};
/** * Execute a sub-command executable. * *    *    *    * @api private */
Command.prototype.executeSubCommand = function(argv, args, unknown) {  args = args.concat(unknown);
  if (!args.length) this.help();  if (help == args[0] && 1 == args.length) this.help();
   <cmd> --help  if (help == args[0]) {    args[0] = args[1];    args[1] = --help;  }
   executable  var f = argv[1];   name of the subcommand, link `pm-install`  var bin = basename(f, .js) + - + args[0];

   In case of globally installed, get the base dir where executable    subcommand file should be located at  var baseDir    , link = readlink(f);
   when symbolink is relative path  if (link !== f && link.charAt(0) !== /) {    link = path.join(dirname(f), link)  }  baseDir = dirname(link);
   prefer local `./<bin>` to bin in the $PATH  var localBin = path.join(baseDir, bin);
   whether bin file is a js script with explicit `.js` extension  var isExplicitJS = false;  if (exists(localBin + .js)) {    bin = localBin + .js;    isExplicitJS = true;  } else if (exists(localBin)) {    bin = localBin;  }
  args = args.slice(1);
  var proc;  if (process.platform !== win32) {    if (isExplicitJS) {      args.unshift(bin);       add executable arguments to spawn      args = (process.execArgv || []).concat(args);
      proc = spawn(node, args, { stdio: inherit, customFds: [0, 1, 2] });    } else {      proc = spawn(bin, args, { stdio: inherit, customFds: [0, 1, 2] });    }  } else {    args.unshift(bin);    proc = spawn(process.execPath, args, { stdio: inherit});  }
  proc.on(close, process.exit.bind(process));  proc.on(error, function(err) {    if (err.code == ENOENT) {      console.error(  %s(1) does not exist, try --help, bin);    } else if (err.code == EACCES) {      console.error(  %s(1) not executable. try chmod or run with root, bin);    }    process.exit(1);  });
   Store the reference to the child process  this.runningCommand = proc;};
/** * Normalize `args`, splitting joined short flags. For example * the arg ""-abc"" is equivalent to ""-a -b -c"". * This also normalizes equal sign and splits ""--abc=def"" into ""--abc def"". * *    *   * @api private */
Command.prototype.normalize = function(args) {  var ret = []    , arg    , lastOpt    , index;
  for (var i = 0, len = args.length; i < len; ++i) {    arg = args[i];    if (i > 0) {      lastOpt = this.optionFor(args[i-1]);    }
    if (arg === --) {       Honor option terminator      ret = ret.concat(args.slice(i));      break;    } else if (lastOpt && lastOpt.required) {      ret.push(arg);    } else if (arg.length > 1 && - == arg[0] && - != arg[1]) {      arg.slice(1).split().forEach(function(c) {        ret.push(- + c);      });    } else if (--.test(arg) && ~(index = arg.indexOf(=))) {      ret.push(arg.slice(0, index), arg.slice(index + 1));    } else {      ret.push(arg);    }  }
  return ret;};
/** * Parse command `args`. * * When listener(s) are available those * callbacks are invoked, otherwise the ""*"" * event is emitted and those actions are invoked. * *    *   for chaining * @api private */
Command.prototype.parseArgs = function(args, unknown) {  var name;
  if (args.length) {    name = args[0];    if (this.listeners(name).length) {      this.emit(args.shift(), args, unknown);    } else {      this.emit(*, args);    }  } else {    outputHelpIfNecessary(this, unknown);
     If there were no args and we have unknown options,     then they are extraneous and we need to error.    if (unknown.length > 0) {      this.unknownOption(unknown[0]);    }  }
  return this;};
/** * Return an option matching `arg` if any. * *    *   * @api private */
Command.prototype.optionFor = function(arg) {  for (var i = 0, len = this.options.length; i < len; ++i) {    if (this.options[i].is(arg)) {      return this.options[i];    }  }};
/** * Parse options from `argv` returning `argv` * void of these options. * *    *   * @api public */
Command.prototype.parseOptions = function(argv) {  var args = []    , len = argv.length    , literal    , option    , arg;
  var unknownOptions = [];
   parse options  for (var i = 0; i < len; ++i) {    arg = argv[i];
     literal args after --    if (literal) {      args.push(arg);      continue;    }
    if (-- == arg) {      literal = true;      continue;    }
     find matching Option    option = this.optionFor(arg);
     option is defined    if (option) {       requires arg      if (option.required) {        arg = argv[++i];        if (null == arg) return this.optionMissingArgument(option);        this.emit(option.name(), arg);       optional arg      } else if (option.optional) {        arg = argv[i+1];        if (null == arg || (- == arg[0] && - != arg)) {          arg = null;        } else {          ++i;        }        this.emit(option.name(), arg);       bool      } else {        this.emit(option.name());      }      continue;    }
     looks like an option    if (arg.length > 1 && - == arg[0]) {      unknownOptions.push(arg);
       If the next argument looks like it might be       an argument for this option, we pass it on.       If it isn't, then it'll simply be ignored      if (argv[i+1] && - != argv[i+1][0]) {        unknownOptions.push(argv[++i]);      }      continue;    }
     arg    args.push(arg);  }
  return { args: args, unknown: unknownOptions };};
/** * Return an object containing options as key-value pairs * *   * @api public */Command.prototype.opts = function() {  var result = {}    , len = this.options.length;
  for (var i = 0 ; i < len; i++) {    var key = camelcase(this.options[i].name());    result[key] = key === version ? this._version : this[key];  }  return result;};
/** * Argument `name` is missing. * *    * @api private */
Command.prototype.missingArgument = function(name) {  console.error();  console.error(  error: missing required argument `%s', name);  console.error();  process.exit(1);};
/** * `Option` is missing an argument, but received `flag` or nothing. * *    *    * @api private */
Command.prototype.optionMissingArgument = function(option, flag) {  console.error();  if (flag) {    console.error(  error: option `%s' argument missing, got `%s', option.flags, flag);  } else {    console.error(  error: option `%s' argument missing, option.flags);  }  console.error();  process.exit(1);};
/** * Unknown option `flag`. * *    * @api private */
Command.prototype.unknownOption = function(flag) {  if (this._allowUnknownOption) return;  console.error();  console.error(  error: unknown option `%s', flag);  console.error();  process.exit(1);};
/** * Variadic argument with `name` is not the last argument as required. * *    * @api private */
Command.prototype.variadicArgNotLast = function(name) {  console.error();  console.error(  error: variadic arguments must be last `%s', name);  console.error();  process.exit(1);};
/** * Set the program version to `str`. * * This method auto-registers the ""-V, --version"" flag * which will print the version number when passed. * *    *    *   for chaining * @api public */
Command.prototype.version = function(str, flags) {  if (0 == arguments.length) return this._version;  this._version = str;  flags = flags || -V, --version;  this.option(flags, output the version number);  this.on(version, function() {    process.stdout.write(str + );    process.exit(0);  });  return this;};
/** * Set the description to `str`. * *    *   * @api public */
Command.prototype.description = function(str) {  if (0 === arguments.length) return this._description;  this._description = str;  return this;};
/** * Set an alias for the command * *    *   * @api public */
Command.prototype.alias = function(alias) {  var command = this;  if(this.commands.length !== 0) {    command = this.commands[this.commands.length - 1]  }
  if (arguments.length === 0) return command._alias;
  command._alias = alias;  return this;};
/** * Set / get the command usage `str`. * *    *   * @api public */
Command.prototype.usage = function(str) {  var args = this._args.map(function(arg) {    return humanReadableArgName(arg);  });
  var usage = [options]    + (this.commands.length ?  [command] : )    + (this._args.length ?   + args.join( ) : );
  if (0 == arguments.length) return this._usage || usage;  this._usage = str;
  return this;};
/** * Get the name of the command * *    *   * @api public */
Command.prototype.name = function() {  return this._name;};
/** * Return the largest option length. * *   * @api private */
Command.prototype.largestOptionLength = function() {  return this.options.reduce(function(max, option) {    return Math.max(max, option.flags.length);  }, 0);};
/** * Return help for options. * *   * @api private */
Command.prototype.optionHelp = function() {  var width = this.largestOptionLength();
   Prepend the help information  return [pad(-h, --help, width) +    + output usage information]      .concat(this.options.map(function(option) {        return pad(option.flags, width) +    + option.description;      }))      .join();};
/** * Return command help documentation. * *   * @api private */
Command.prototype.commandHelp = function() {  if (!this.commands.length) return ;
  var commands = this.commands.filter(function(cmd) {    return !cmd._noHelp;  }).map(function(cmd) {    var args = cmd._args.map(function(arg) {      return humanReadableArgName(arg);    }).join( );
    return [      cmd._name        + (cmd._alias ? | + cmd._alias : )        + (cmd.options.length ?  [options] : )        +   + args      , cmd._description    ];  });
  var width = commands.reduce(function(max, command) {    return Math.max(max, command[0].length);  }, 0);
  return [        ,   Commands:    ,     , commands.map(function(cmd) {      var desc = cmd[1] ?    + cmd[1] : ;      return pad(cmd[0], width) + desc;    }).join().replace(gm,     )    ,   ].join();};
/** * Return program help documentation. * *   * @api private */
Command.prototype.helpInformation = function() {  var desc = [];  if (this._description) {    desc = [         + this._description      ,     ];  }
  var cmdName = this._name;  if (this._alias) {    cmdName = cmdName + | + this._alias;  }  var usage = [        ,  Usage:  + cmdName +   + this.usage()    ,   ];
  var cmds = [];  var commandHelp = this.commandHelp();  if (commandHelp) cmds = [commandHelp];
  var options = [      Options:    ,     ,  + this.optionHelp().replace(gm,     )    ,     ,   ];
  return usage    .concat(cmds)    .concat(desc)    .concat(options)    .join();};
/** * Output help information for this command * * @api public */
Command.prototype.outputHelp = function(cb) {  if (!cb) {    cb = function(passthru) {      return passthru;    }  }  process.stdout.write(cb(this.helpInformation()));  this.emit(--help);};
/** * Output help information and exit. * * @api public */
Command.prototype.help = function(cb) {  this.outputHelp(cb);  process.exit();};
/** * Camel-case the given `flag` * *    *   * @api private */
function camelcase(flag) {  return flag.split(-).reduce(function(str, word) {    return str + word[0].toUpperCase() + word.slice(1);  });}
/** * Pad `str` to `width`. * *    *    *   * @api private */
function pad(str, width) {  var len = Math.max(0, width - str.length);  return str + Array(len + 1).join( );}
/** * Output help information if necessary * *    to output help for *    of options to search for -h or --help * @api private */
function outputHelpIfNecessary(cmd, options) {  options = options || [];  for (var i = 0; i < options.length; i++) {    if (options[i] == --help || options[i] == -h) {      cmd.outputHelp();      process.exit(0);    }  }}
/** * Takes an argument an returns its human readable equivalent for help usage. * *    *   * @api private */
function humanReadableArgName(arg) {  var nameOutput = arg.name + (arg.variadic === true ? ... : );
  return arg.required    ? < + nameOutput + >    : [ + nameOutput + ]}
 for versions before node v0.8 when there weren't `fs.existsSync`function exists(file) {  try {    if (fs.statSync(file).isFile()) {      return true;    }  } catch (e) {    return false;  }}
"
"var Classes = Object.create(null);
/** * Create a new Connection instance. *    Configuration or connection string for new MySQL connection *   A new MySQL connection *  */exports.createConnection = function createConnection(config) {  var Connection       = loadClass(Connection);  var ConnectionConfig = loadClass(ConnectionConfig);
  return new Connection({config: new ConnectionConfig(config)});};
/** * Create a new Pool instance. *    Configuration or connection string for new MySQL connections *   A new MySQL pool *  */exports.createPool = function createPool(config) {  var Pool       = loadClass(Pool);  var PoolConfig = loadClass(PoolConfig);
  return new Pool({config: new PoolConfig(config)});};
/** * Create a new PoolCluster instance. *    Configuration for pool cluster *   New MySQL pool cluster *  */exports.createPoolCluster = function createPoolCluster(config) {  var PoolCluster = loadClass(PoolCluster);
  return new PoolCluster(config);};
/** * Create a new Query instance. *    The SQL for the query *    Any values to insert into placeholders in sql *    The callback to use when query is complete *   New query object *  */exports.createQuery = function createQuery(sql, values, callback) {  var Connection = loadClass(Connection);
  return Connection.createQuery(sql, values, callback);};
/** * Escape a value for SQL. *    The value to escape *    Setting if objects should be stringified *    Setting for time zone to use for Date conversion *   Escaped string value *  */exports.escape = function escape(value, stringifyObjects, timeZone) {  var SqlString = loadClass(SqlString);
  return SqlString.escape(value, stringifyObjects, timeZone);};
/** * Escape an identifier for SQL. *    The value to escape *    Setting to treat '.' as part of identifier *   Escaped string value *  */exports.escapeId = function escapeId(value, forbidQualified) {  var SqlString = loadClass(SqlString);
  return SqlString.escapeId(value, forbidQualified);};
/** * Format SQL and replacement values into a SQL string. *    The SQL for the query *    Any values to insert into placeholders in sql *    Setting if objects should be stringified *    Setting for time zone to use for Date conversion *   Formatted SQL string *  */exports.format = function format(sql, values, stringifyObjects, timeZone) {  var SqlString = loadClass(SqlString);
  return SqlString.format(sql, values, stringifyObjects, timeZone);};
/** * The type constants. *  */Object.defineProperty(exports, Types, {  get: loadClass.bind(null, Types)});
/** * Load the given class. *    Name of class to default *   Class constructor or exports *  */function loadClass(className) {  var Class = Classes[className];
  if (Class !== undefined) {    return Class;  }
   This uses a switch for static require analysis  switch (className) {    case Connection:      Class = require(./lib/Connection);      break;    case ConnectionConfig:      Class = require(./lib/ConnectionConfig);      break;    case Pool:      Class = require(./lib/Pool);      break;    case PoolCluster:      Class = require(./lib/PoolCluster);      break;    case PoolConfig:      Class = require(./lib/PoolConfig);      break;    case SqlString:      Class = require(./lib/protocol/SqlString);      break;    case Types:      Class = require(./lib/protocol/constants/types);      break;    default:      throw new Error(Cannot find class  + className + );  }
   Store to prevent invoking require()  Classes[className] = Class;
  return Class;}"
"use strict;
/* * Copy this file to ./sscce.js * Add code from issue * npm run sscce-{dialect} */
const Sequelize = require(./index);const sequelize = require(./test/support).createSequelizeInstance();"
"var _ = require(lodash);var express = require(express);var grappling = require(grappling-hook);var path = require(path);var utils = require(keystone-utils);var importer = require(./lib/core/importer);
/** * Don't use process.cwd() as it breaks module encapsulation * Instead, let's use module.parent if it's present, or the module itself if there is no parent (probably testing keystone directly if that's the case) * This way, the consuming app/module can be an embedded node_module and path resolutions will still work * (process.cwd() breaks module encapsulation if the consuming app/module is itself a node_module) */var moduleRoot = (function (_rootPath) {	var parts = _rootPath.split(path.sep);	parts.pop();  get rid of /node_modules from the end of the path	return parts.join(path.sep);})(module.parent ? module.parent.paths[0] : module.paths[0]);

/** * Keystone Class */var Keystone = function () {	grappling.mixin(this).allowHooks(pre:static, pre:bodyparser, pre:session, pre:logger, pre:admin, pre:routes, pre:render, updates, signin, signout);	this.lists = {};	this.fieldTypes = {};	this.paths = {};	this._options = {		name: Keystone,		brand: Keystone,		admin path: keystone,		compress: true,		headless: false,		logger: :method :url :status :response-time ms,		auto update: false,		model prefix: null,		module root: moduleRoot,		frame guard: sameorigin,		cache admin bundles: true,	};	this._redirects = {};
	 expose express	this.express = express;
	 init environment defaults	this.set(env, process.env.NODE_ENV || development);
	this.set(port, process.env.PORT || process.env.OPENSHIFT_NODEJS_PORT || 3000);	this.set(host, process.env.HOST || process.env.IP || process.env.OPENSHIFT_NODEJS_IP || 0.0.0.0);	this.set(listen, process.env.LISTEN);
	this.set(ssl, process.env.SSL);	this.set(ssl port, process.env.SSL_PORT || 3001);	this.set(ssl host, process.env.SSL_HOST || process.env.SSL_IP);	this.set(ssl key, process.env.SSL_KEY);	this.set(ssl cert, process.env.SSL_CERT);
	this.set(cookie secret, process.env.COOKIE_SECRET);	this.set(cookie signin, (this.get(env) === development) ? true : false);
	this.set(embedly api key, process.env.EMBEDLY_API_KEY || process.env.EMBEDLY_APIKEY);	this.set(mandrill api key, process.env.MANDRILL_API_KEY || process.env.MANDRILL_APIKEY);	this.set(mandrill username, process.env.MANDRILL_USERNAME);	this.set(google api key, process.env.GOOGLE_BROWSER_KEY);	this.set(google server api key, process.env.GOOGLE_SERVER_KEY);	this.set(ga property, process.env.GA_PROPERTY);	this.set(ga domain, process.env.GA_DOMAIN);	this.set(chartbeat property, process.env.CHARTBEAT_PROPERTY);	this.set(chartbeat domain, process.env.CHARTBEAT_DOMAIN);	this.set(allowed ip ranges, process.env.ALLOWED_IP_RANGES);
	if (process.env.S3_BUCKET && process.env.S3_KEY && process.env.S3_SECRET) {		this.set(s3 config, { bucket: process.env.S3_BUCKET, key: process.env.S3_KEY, secret: process.env.S3_SECRET, region: process.env.S3_REGION });	}
	if (process.env.AZURE_STORAGE_ACCOUNT && process.env.AZURE_STORAGE_ACCESS_KEY) {		this.set(azurefile config, { account: process.env.AZURE_STORAGE_ACCOUNT, key: process.env.AZURE_STORAGE_ACCESS_KEY });	}
	if (process.env.CLOUDINARY_URL) {		 process.env.CLOUDINARY_URL is processed by the cloudinary package when this is set		this.set(cloudinary config, true);	}
	 init mongoose	this.set(mongoose, require(mongoose));	this.mongoose.Promise = require(es6-promise).Promise;
	 Attach middleware packages, bound to this instance	this.middleware = {		api: require(./lib/middleware/api)(this),		cors: require(./lib/middleware/cors)(this),	};};
_.extend(Keystone.prototype, require(./lib/core/options));

Keystone.prototype.prefixModel = function (key) {	var modelPrefix = this.get(model prefix);
	if (modelPrefix) {		key = modelPrefix + _ + key;	}
	return require(mongoose/lib/utils).toCollectionName(key);};
/* Attach core functionality to Keystone.prototype */Keystone.prototype.createItems = require(./lib/core/createItems);Keystone.prototype.createRouter = require(./lib/core/createRouter);Keystone.prototype.getOrphanedLists = require(./lib/core/getOrphanedLists);Keystone.prototype.importer = importer;Keystone.prototype.init = require(./lib/core/init);Keystone.prototype.initDatabaseConfig = require(./lib/core/initDatabaseConfig);Keystone.prototype.initExpressApp = require(./lib/core/initExpressApp);Keystone.prototype.initExpressSession = require(./lib/core/initExpressSession);Keystone.prototype.initNav = require(./lib/core/initNav);Keystone.prototype.list = require(./lib/core/list);Keystone.prototype.openDatabaseConnection = require(./lib/core/openDatabaseConnection);Keystone.prototype.closeDatabaseConnection = require(./lib/core/closeDatabaseConnection);Keystone.prototype.populateRelated = require(./lib/core/populateRelated);Keystone.prototype.redirect = require(./lib/core/redirect);Keystone.prototype.start = require(./lib/core/start);Keystone.prototype.wrapHTMLError = require(./lib/core/wrapHTMLError);Keystone.prototype.createKeystoneHash = require(./lib/core/createKeystoneHash);
/* Deprecation / Change warnings for 0.4 */Keystone.prototype.routes = function () {	throw new Error(keystone.routes(fn) has been removed, use keystone.set(routes, fn));};

/** * The exports object is an instance of Keystone. */var keystone = module.exports = new Keystone();
/*	Note: until #1777 is complete, the order of execution here with the requires	(specifically, they happen _after_ the module.exports above) is really	important. As soon as the circular dependencies are sorted out to get their	keystone instance from a closure or reference on {this} we can move these	bindings into the Keystone constructor.*/
 Expose modules and Classeskeystone.Admin = {	Server: require(./admin/server),};keystone.Email = require(./lib/email);keystone.Field = require(./fields/types/Type);keystone.Field.Types = require(./lib/fieldTypes);keystone.Keystone = Keystone;keystone.List = require(./lib/list)(keystone);keystone.Storage = require(./lib/storage);keystone.View = require(./lib/view);
keystone.content = require(./lib/content);keystone.security = {	csrf: require(./lib/security/csrf),};keystone.utils = utils;
/** * returns all .js modules (recursively) in the path specified, relative * to the module root (where the keystone project is being consumed from). * * ####Example: *     var models = keystone.import('models'); */
Keystone.prototype.import = function (dirname) {	return importer(this.get(module root))(dirname);};

/** * Applies Application updates */
Keystone.prototype.applyUpdates = function (callback) {	var self = this;	self.callHook(pre:updates, function (err) {		if (err) return callback(err);		require(./lib/updates).apply(function (err) {			if (err) return callback(err);			self.callHook(post:updates, callback);		});	});};

/** * Logs a configuration error to the console */
Keystone.prototype.console = {};Keystone.prototype.console.err = function (type, msg) {	if (keystone.get(logger)) {		var dashes = ------------------------------------------------;		console.log(dashes + KeystoneJS:  + type + : + msg + dashes);	}};
/** * Keystone version */
keystone.version = require(./package.json).version;

 Expose Moduleskeystone.session = require(./lib/session);"
"use strict;
 Iron-node does not work with forked processes This cli command will run a single file in the current process. Intended to be used with iron-node for profiling purposes.
const path = require(path);const EventEmitter = require(events);const meow = require(meow);const Promise = require(bluebird);const pkgConf = require(pkg-conf);const findCacheDir = require(find-cache-dir);const uniqueTempDir = require(unique-temp-dir);const arrify = require(arrify);const resolveCwd = require(resolve-cwd);const babelConfigHelper = require(./lib/babel-config);const CachingPrecompiler = require(./lib/caching-precompiler);const globals = require(./lib/globals);
function resolveModules(modules) {	return arrify(modules).map(name => {		const modulePath = resolveCwd(name);
		if (modulePath === null) {			throw new Error(Could not resolve required module '');		}
		return modulePath;	});}
 Chrome gets upset when the `this` value is non-null for these functionsglobals.setTimeout = setTimeout.bind(null);globals.clearTimeout = clearTimeout.bind(null);
Promise.longStackTraces();
const conf = pkgConf.sync(ava, {	defaults: {		babel: default	}});
 Define a minimal set of options from the main CLIconst cli = meow(	Usage	  $ iron-node node_modules/ava/profile.js <test-file>	Options	  --fail-fast   Stop after first test failure	  --serial, -s  Run tests serially, {	string: [		_	],	boolean: [		fail-fast,		verbose,		serial,		tap	],	default: conf,	alias: {		s: serial	}});
if (cli.input.length !== 1) {	throw new Error(Specify a test file);}
const file = path.resolve(cli.input[0]);const cacheDir = findCacheDir({	name: ava,	files: [file]}) || uniqueTempDir();
babelConfigHelper.build(process.cwd(), cacheDir, conf.babel, true)	.then(result => {		const precompiler = new CachingPrecompiler({			path: cacheDir,			getBabelOptions: result.getOptions,			babelCacheKeys: result.cacheKeys		});
		const precompiled = {};		precompiled[file] = precompiler.precompileFile(file);
		const opts = {			file,			failFast: cli.flags.failFast,			serial: cli.flags.serial,			tty: false,			cacheDir,			precompiled,			require: resolveModules(conf.require)		};
		const events = new EventEmitter();		let uncaughtExceptionCount = 0;
		 Mock the behavior of a parent process		process.channel = {ref() {}, unref() {}};		process.send = data => {			if (data && data.ava) {				const name = data.name.replace(ava-, );
				if (events.listeners(name).length > 0) {					events.emit(name, data.data);				} else {					console.log(UNHANDLED AVA EVENT:, name, data.data);				}
				return;			}
			console.log(NON AVA EVENT:, data);		};
		events.on(test, data => {			console.log(TEST:, data.title, data.error);		});
		events.on(results, data => {			if (console.profileEnd) {				console.profileEnd();			}
			console.log(RESULTS:, data.stats);
			if (process.exit) {				process.exit(data.stats.failCount + uncaughtExceptionCount);  eslint-disable-line unicorn/no-process-exit			}		});
		events.on(stats, () => {			setImmediate(() => {				process.emit(ava-run, {});			});		});
		events.on(uncaughtException, data => {			uncaughtExceptionCount++;			let stack = data && data.exception && data.exception.stack;			stack = stack || data;			console.log(stack);		});
		 `test-worker` will read process.argv[2] for options		process.argv[2] = JSON.stringify(opts);		process.argv.length = 3;
		if (console.profile) {			console.profile(AVA test-worker process);		}
		setImmediate(() => {			require(./lib/test-worker);  eslint-disable-line import/no-unassigned-import		});	});"
"use strict
module.exports = {  module: {    loaders: [{      test: css,      loader: style-loader!css-loader    },{      test: scss,      loaders: [style, css?sourceMap, sass?sourceMap]    }, {      test: js,      exclude: (node_modulesbower_componentslib),      loader: babel?presets[]=es2015&presets[]=stage-1    }, {      test: (pngwoffwoff2eotttfsvg)(v=),      loader: url    }]  },  resolve: {    modulesDirectories: [bower_components, node_modules]  }}"
"use strict
var webpack = require(webpack)var config = require(./webpack.config)var merge = require(lodash).merge
module.exports = merge(config, {  entry: [./app.js, webpack-hot-middleware/client?reload=true],  output: {    publicPath: /bundle/  },  plugins: [    new webpack.optimize.OccurenceOrderPlugin(),    new webpack.HotModuleReplacementPlugin(),    new webpack.NoErrorsPlugin()  ]});"
"Npm.depends({    faker: 3.0.1});

Package.describe({  summary: Generate massive amounts of fake data in node.js and in the browser.,  name: practicalmeteor:faker,  version: 3.0.1_1,  git: https://github.com/practicalmeteor/meteor-faker.git,  documentation: Readme.md});

Package.onUse(function (api) {  api.versionsFrom(1.0);
  api.addFiles(meteor/npm-require.js, server);
  api.addFiles(build/build/faker.js, client);
  api.export(faker, server);});

Package.onTest(function(api) {  api.use([practicalmeteor:faker, coffeescript, tinytest, practicalmeteor:chai]);
  api.addFiles(meteor/tests/faker-export-test.coffee);});"
" since we are requiring the top level of faker, load all locales by defaultvar Faker = require(./lib);var faker = new Faker({ locales: require(./lib/locales) });module[exports] = faker;"
"use strict
var path = require(path)
 var ngAnnotatePlugin = require('ng-annotate-webpack-plugin')
module.exports = {  context: __dirname,  entry: ./app.js,  output: {    path: path.join(__dirname, ./bundle),    publicPath: /,    filename: app.js  },  module: {    loaders: [{      test: css,      loaders: [style, css?sourceMap]    }, {      test: scss,      loaders: [style, css?sourceMap, sass?sourceMap]    }, {      test: less,      loaders: [style, css?sourceMap, less?sourceMap]    }, {      test: js,      exclude: (node_modulesbower_componentslib),      loader: babel?presets[]=es2015&presets[]=stage-1    }, {      test: ()(eotsvgttfwoffwoff2),      loader: url-loader    }]  },  resolve: {    modulesDirectories: [node_modules]  },  plugins: [     new ngAnnotatePlugin({       add: true,       // other ng-annotate options here     })  ]}"
"use strict
/*var cl = console.logconsole.log = function(){  console.trace()  cl.apply(console,arguments)}*/
process.env.NODE_CONFIG_DIR = ./config/env
 Requires meanio .var mean = require(meanio)var cluster = require(cluster)var deferred = require(q).defer()var debug = require(debug)(cluster)
 Code to run if we're in the master process or if we are not in debug mode/ running tests
if ((cluster.isMaster) &&  (process.execArgv.indexOf(--debug) < 0) &&  (process.env.NODE_ENV !== test) && (process.env.NODE_ENV !== development) &&  (process.execArgv.indexOf(--singleProcess) < 0)) {   if (cluster.isMaster) {
  debug(Production Environment)   Count the machine's CPUs  var cpuCount = process.env.CPU_COUNT || require(os).cpus().length
   Create a worker for each CPU  for (var i = 0; i < cpuCount; i += 1) {    debug(forking )    cluster.fork()  }
   Listen for dying workers  cluster.on(exit, function (worker) {     Replace the dead worker, we're not sentimental    debug(Worker  died :()    cluster.fork()  })
 Code to run if we're in a worker process} else {  var workerId = 0  if (!cluster.isMaster) {    workerId = cluster.worker.id  }   Creates and serves mean application  mean.serve({ workerid: workerId }, function (app) {    var config = app.getConfig()    var port = config.https && config.https.port ? config.https.port : config.http.port    debug(MEAN app started on port  () with cluster worker id )
    deferred.resolve(app)  })}
module.exports = deferred.promise"
"var mdeps = require(module-deps);var depsSort = require(deps-sort);var bpack = require(browser-pack);var insertGlobals = require(insert-module-globals);var syntaxError = require(syntax-error);
var builtins = require(./lib/builtins.js);
var splicer = require(labeled-stream-splicer);var through = require(through2);var concat = require(concat-stream);
var inherits = require(inherits);var EventEmitter = require(events).EventEmitter;var xtend = require(xtend);var isArray = Array.isArray;var defined = require(defined);var has = require(has);var sanitize = require(htmlescape).sanitize;var shasum = require(shasum);
var bresolve = require(browser-resolve);var resolve = require(resolve);
var readonly = require(read-only-stream);
module.exports = Browserify;inherits(Browserify, EventEmitter);
var fs = require(fs);var path = require(path);var relativePath = require(cached-path-relative)var paths = {    empty: path.join(__dirname, lib/_empty.js)};
function Browserify (files, opts) {    var self = this;    if (!(this instanceof Browserify)) return new Browserify(files, opts);    if (!opts) opts = {};        if (typeof files === string || isArray(files) || isStream(files)) {        opts = xtend(opts, { entries: [].concat(opts.entries || [], files) });    }    else opts = xtend(files, opts);        self._options = opts;    if (opts.noparse) opts.noParse = opts.noparse;        if (opts.basedir !== undefined && typeof opts.basedir !== string) {        throw new Error(opts.basedir must be either undefined or a string.);    }
    opts.dedupe = opts.dedupe === false ? false : true;
    self._external = [];    self._exclude = [];    self._ignore = [];    self._expose = {};    self._hashes = {};    self._pending = 0;    self._transformOrder = 0;    self._transformPending = 0;    self._transforms = [];    self._entryOrder = 0;    self._ticked = false;    self._bresolve = opts.browserField === false        ? function (id, opts, cb) {            if (!opts.basedir) opts.basedir = path.dirname(opts.filename)            resolve(id, opts, cb)        }        : bresolve    ;    self._syntaxCache = {};
    var ignoreTransform = [].concat(opts.ignoreTransform).filter(Boolean);    self._filterTransform = function (tr) {        if (isArray(tr)) {            return ignoreTransform.indexOf(tr[0]) === -1;        }        return ignoreTransform.indexOf(tr) === -1;    };
    self.pipeline = self._createPipeline(opts);        [].concat(opts.transform).filter(Boolean).filter(self._filterTransform)    .forEach(function (tr) {        self.transform(tr);    });        [].concat(opts.entries).filter(Boolean).forEach(function (file) {        self.add(file, { basedir: opts.basedir });    });        [].concat(opts.require).filter(Boolean).forEach(function (file) {        self.require(file, { basedir: opts.basedir });    });        [].concat(opts.plugin).filter(Boolean).forEach(function (p) {        self.plugin(p, { basedir: opts.basedir });    });}
Browserify.prototype.require = function (file, opts) {    var self = this;    if (isArray(file)) {        file.forEach(function (x) {            if (typeof x === object) {                self.require(x.file, xtend(opts, x));            }            else self.require(x, opts);        });        return this;    }        if (!opts) opts = {};    var basedir = defined(opts.basedir, self._options.basedir, process.cwd());    var expose = opts.expose;    if (file === expose && .test(expose)) {        expose = / + relativePath(basedir, expose);        expose = expose.replace(g, /);    }    if (expose === undefined && this._options.exposeAll) {        expose = true;    }    if (expose === true) {        expose = / + relativePath(basedir, file);        expose = expose.replace(g, /);    }        if (isStream(file)) {        self._pending ++;        var order = self._entryOrder ++;        file.pipe(concat(function (buf) {            var filename = opts.file || file.file || path.join(                basedir,                _stream_ + order + .js            );            var id = file.id || expose || filename;            if (expose || opts.entry === false) {                self._expose[id] = filename;            }            if (!opts.entry && self._options.exports === undefined) {                self._bpack.hasExports = true;            }            var rec = {                source: buf.toString(utf8),                entry: defined(opts.entry, false),                file: filename,                id: id            };            if (rec.entry) rec.order = order;            if (rec.transform === false) rec.transform = false;            self.pipeline.write(rec);                        if (-- self._pending === 0) self.emit(_ready);        }));        return this;    }        var row;    if (typeof file === object) {        row = xtend(file, opts);    }    else if (!opts.entry && isExternalModule(file)) {         external module or builtin        row = xtend(opts, { id: expose || file, file: file });    }    else {        row = xtend(opts, { file: path.resolve(basedir, file) });    }        if (!row.id) {        row.id = expose || row.file;    }    if (expose || !row.entry) {         Make this available to mdeps so that it can assign the value when it         resolves the pathname.        row.expose = row.id;    }        if (opts.external) return self.external(file, opts);    if (row.entry === undefined) row.entry = false;        if (!row.entry && self._options.exports === undefined) {        self._bpack.hasExports = true;    }        if (row.entry) row.order = self._entryOrder ++;        if (opts.transform === false) row.transform = false;    self.pipeline.write(row);    return self;};
Browserify.prototype.add = function (file, opts) {    var self = this;    if (!opts) opts = {};    if (isArray(file)) {        file.forEach(function (x) { self.add(x, opts) });        return this;    }    return this.require(file, xtend({ entry: true, expose: false }, opts));};
Browserify.prototype.external = function (file, opts) {    var self = this;    if (isArray(file)) {        file.forEach(function (f) {            if (typeof f === object) {                self.external(f, xtend(opts, f));            }            else self.external(f, opts)        });        return this;    }    if (file && typeof file === object && typeof file.bundle === function) {        var b = file;        self._pending ++;
        var bdeps = {};        var blabels = {};
        b.on(label, function (prev, id) {            self._external.push(id);
            if (prev !== id) {                blabels[prev] = id;                self._external.push(prev);            }        });
        b.pipeline.get(deps).push(through.obj(function (row, enc, next) {            bdeps = xtend(bdeps, row.deps);            this.push(row);            next();        }));
        self.on(dep, function (row) {            Object.keys(row.deps).forEach(function (key) {                var prev = bdeps[key];                if (prev) {                    var id = blabels[prev];                    if (id) {                        row.indexDeps[key] = id;                    }                }            });        });
        b.pipeline.get(label).once(end, function () {            if (-- self._pending === 0) self.emit(_ready);        });        return this;    }        if (!opts) opts = {};    var basedir = defined(opts.basedir, process.cwd());    this._external.push(file);    this._external.push(/ + relativePath(basedir, file));    return this;};
Browserify.prototype.exclude = function (file, opts) {    if (!opts) opts = {};    var basedir = defined(opts.basedir, process.cwd());    this._exclude.push(file);    this._exclude.push(/ + relativePath(basedir, file));    return this;};
Browserify.prototype.ignore = function (file, opts) {    if (!opts) opts = {};    var basedir = defined(opts.basedir, process.cwd());
     Handle relative paths    if (file[0] === .) {        this._ignore.push(path.resolve(basedir, file));    }    else {        this._ignore.push(file);    }    return this;};
Browserify.prototype.transform = function (tr, opts) {    var self = this;    if (typeof opts === function || typeof opts === string) {        tr = [ opts, tr ];    }    if (isArray(tr)) {        opts = tr[1];        tr = tr[0];    }        if the bundler is ignoring this transform    if (typeof tr === string && !self._filterTransform(tr)) {        return this;    }
    function resolved () {      self._transforms[order] = rec;      -- self._pending;      if (-- self._transformPending === 0) {          self._transforms.forEach(function (transform) {            self.pipeline.write(transform);          });
          if (self._pending === 0) {            self.emit(_ready);          }      }    }        if (!opts) opts = {};    opts._flags = _flags in opts ? opts._flags : self._options;        var basedir = defined(opts.basedir, this._options.basedir, process.cwd());    var order = self._transformOrder ++;    self._pending ++;    self._transformPending ++;
    var rec = {        transform: tr,        options: opts,        global: opts.global    };
    if (typeof tr === string) {        var topts = {            basedir: basedir,            paths: (self._options.paths || []).map(function (p) {                return path.resolve(basedir, p);            })        };        resolve(tr, topts, function (err, res) {            if (err) return self.emit(error, err);            rec.transform = res;            resolved();        });    }    else process.nextTick(resolved);    return this;};
Browserify.prototype.plugin = function (p, opts) {    if (isArray(p)) {        opts = p[1];        p = p[0];    }    if (!opts) opts = {};    var basedir = defined(opts.basedir, this._options.basedir, process.cwd());    if (typeof p === function) {        p(this, opts);    }    else {        var pfile = resolve.sync(String(p), { basedir: basedir })        var f = require(pfile);        if (typeof f !== function) {            throw new Error(plugin  + p +  should export a function);        }        f(this, opts);    }    return this;};
Browserify.prototype._createPipeline = function (opts) {    var self = this;    if (!opts) opts = {};    this._mdeps = this._createDeps(opts);    this._mdeps.on(file, function (file, id) {        pipeline.emit(file, file, id);        self.emit(file, file, id);    });    this._mdeps.on(package, function (pkg) {        pipeline.emit(package, pkg);        self.emit(package, pkg);    });    this._mdeps.on(transform, function (tr, file) {        pipeline.emit(transform, tr, file);        self.emit(transform, tr, file);    });        var dopts = {        index: !opts.fullPaths && !opts.exposeAll,        dedupe: opts.dedupe,        expose: this._expose    };    this._bpack = bpack(xtend(opts, { raw: true }));        var pipeline = splicer.obj([        record, [ this._recorder() ],        deps, [ this._mdeps ],        json, [ this._json() ],        unbom, [ this._unbom() ],        unshebang, [ this._unshebang() ],        syntax, [ this._syntax() ],        sort, [ depsSort(dopts) ],        dedupe, [ this._dedupe() ],        label, [ this._label(opts) ],        emit-deps, [ this._emitDeps() ],        debug, [ this._debug(opts) ],        pack, [ this._bpack ],        wrap, []    ]);    if (opts.exposeAll) {        var basedir = defined(opts.basedir, process.cwd());        pipeline.get(deps).push(through.obj(function (row, enc, next) {            if (self._external.indexOf(row.id) >= 0) return next();            if (self._external.indexOf(row.file) >= 0) return next();                        if (isAbsolutePath(row.id)) {                row.id = / + relativePath(basedir, row.file);            }            Object.keys(row.deps || {}).forEach(function (key) {                row.deps[key] = / + relativePath(basedir, row.deps[key]);            });            this.push(row);            next();        }));    }    return pipeline;};
Browserify.prototype._createDeps = function (opts) {    var self = this;    var mopts = xtend(opts);    var basedir = defined(opts.basedir, process.cwd());
     Let mdeps populate these values since it will be resolving file paths     anyway.    mopts.expose = this._expose;    mopts.extensions = [ .js, .json ].concat(mopts.extensions || []);    self._extensions = mopts.extensions;
    mopts.transform = [];    mopts.transformKey = defined(opts.transformKey, [ browserify, transform ]);    mopts.postFilter = function (id, file, pkg) {        if (opts.postFilter && !opts.postFilter(id, file, pkg)) return false;        if (self._external.indexOf(file) >= 0) return false;        if (self._exclude.indexOf(file) >= 0) return false;
        filter transforms on module dependencies        if (pkg && pkg.browserify && pkg.browserify.transform) {            In edge cases it may be a string            pkg.browserify.transform = [].concat(pkg.browserify.transform)                    .filter(Boolean)                    .filter(self._filterTransform);        }        return true;    };    mopts.filter = function (id) {        if (opts.filter && !opts.filter(id)) return false;        if (self._external.indexOf(id) >= 0) return false;        if (self._exclude.indexOf(id) >= 0) return false;        if (opts.bundleExternal === false && isExternalModule(id)) {            return false;        }        return true;    };    mopts.resolve = function (id, parent, cb) {        if (self._ignore.indexOf(id) >= 0) return cb(null, paths.empty, {});                self._bresolve(id, parent, function (err, file, pkg) {            if (file && self._ignore.indexOf(file) >= 0) {                return cb(null, paths.empty, {});            }            if (file && self._ignore.length) {                var nm = file.split(/node_modules/)[1];                if (nm) {                    nm = nm.split(/)[0];                    if (self._ignore.indexOf(nm) >= 0) {                        return cb(null, paths.empty, {});                    }                }            }                        if (file) {                var ex = / + relativePath(basedir, file);                if (self._external.indexOf(ex) >= 0) {                    return cb(null, ex);                }                if (self._exclude.indexOf(ex) >= 0) {                    return cb(null, ex);                }                if (self._ignore.indexOf(ex) >= 0) {                    return cb(null, paths.empty, {});                }            }            if (err) cb(err, file, pkg)            else if (file) fs.realpath(file, function (err, res) {                cb(err, res, pkg, file);            });            else cb(err, null, pkg)        });    };        if (opts.builtins === false) {        mopts.modules = {};        self._exclude.push.apply(self._exclude, Object.keys(builtins));    }    else if (opts.builtins && isArray(opts.builtins)) {        mopts.modules = {};        opts.builtins.forEach(function (key) {            mopts.modules[key] = builtins[key];        });    }    else if (opts.builtins && typeof opts.builtins === object) {        mopts.modules = opts.builtins;    }    else mopts.modules = xtend(builtins);        Object.keys(builtins).forEach(function (key) {        if (!has(mopts.modules, key)) self._exclude.push(key);    });        mopts.globalTransform = [];    if (!this._bundled) {        this.once(bundle, function () {            self.pipeline.write({                transform: globalTr,                global: true,                options: {}            });        });    }        var no = [].concat(opts.noParse).filter(Boolean);    var absno = no.filter(function(x) {        return typeof x === string;    }).map(function (x) {        return path.resolve(basedir, x);    });        function globalTr (file) {        if (opts.detectGlobals === false) return through();                if (opts.noParse === true) return through();        if (no.indexOf(file) >= 0) return through();        if (absno.indexOf(file) >= 0) return through();                var parts = file.split(/node_modules/);        for (var i = 0; i < no.length; i++) {            if (typeof no[i] === function && no[i](file)) {                return through();            }            else if (no[i] === parts[parts.length-1].split(/)[0]) {                return through();            }            else if (no[i] === parts[parts.length-1]) {                return through();            }        }                var vars = xtend({            process: function () { return require('_process') },        }, opts.insertGlobalVars);                if (opts.bundleExternal === false) {            vars.process = undefined;            vars.buffer = undefined;        }                return insertGlobals(file, xtend(opts, {            debug: opts.debug,            always: opts.insertGlobals,            basedir: opts.commondir === false                ? /                : opts.basedir || process.cwd()            ,            vars: vars        }));    }    return mdeps(mopts);};
Browserify.prototype._recorder = function (opts) {    var self = this;    var ended = false;    this._recorded = [];        if (!this._ticked) {        process.nextTick(function () {            self._ticked = true;            self._recorded.forEach(function (row) {                stream.push(row);            });            if (ended) stream.push(null);        });    }        var stream = through.obj(write, end);    return stream;        function write (row, enc, next) {        self._recorded.push(row);        if (self._ticked) this.push(row);        next();    }    function end () {        ended = true;        if (self._ticked) this.push(null);    }};
Browserify.prototype._json = function () {    return through.obj(function (row, enc, next) {        if (json.test(row.file)) {            row.source = module.exports= + sanitize(row.source);        }        this.push(row);        next();    });};
Browserify.prototype._unbom = function () {    return through.obj(function (row, enc, next) {        if (feff.test(row.source)) {            row.source = row.source.replace(feff, );        }        this.push(row);        next();    });};
Browserify.prototype._unshebang = function () {    return through.obj(function (row, enc, next) {        if (#!.test(row.source)) {            row.source = row.source.replace(#!, );        }        this.push(row);        next();    });};
Browserify.prototype._syntax = function () {    var self = this;    return through.obj(function (row, enc, next) {        var h = shasum(row.source);        if (typeof self._syntaxCache[h] === undefined) {            var err = syntaxError(row.source, row.file || row.id);            if (err) return this.emit(error, err);            self._syntaxCache[h] = true;        }        this.push(row);        next();    });};
Browserify.prototype._dedupe = function () {    return through.obj(function (row, enc, next) {        if (!row.dedupeIndex && row.dedupe) {            row.source = arguments[4][                + JSON.stringify(row.dedupe)                + ][0].apply(exports,arguments)            ;            row.nomap = true;        }        else if (row.dedupeIndex) {            row.source = arguments[4][                + JSON.stringify(row.dedupeIndex)                + ][0].apply(exports,arguments)            ;            row.nomap = true;        }        if (row.dedupeIndex && row.indexDeps) {            row.indexDeps.dup = row.dedupeIndex;        }        this.push(row);        next();    });};
Browserify.prototype._label = function (opts) {    var self = this;    var basedir = defined(opts.basedir, process.cwd());        return through.obj(function (row, enc, next) {        var prev = row.id;
        if (self._external.indexOf(row.id) >= 0) return next();        if (self._external.indexOf(/ + relativePath(basedir, row.id)) >= 0) {            return next();        }        if (self._external.indexOf(row.file) >= 0) return next();                if (row.index) row.id = row.index;                self.emit(label, prev, row.id);        if (row.indexDeps) row.deps = row.indexDeps || {};                Object.keys(row.deps).forEach(function (key) {            if (self._expose[key]) {                row.deps[key] = key;                return;            }
            var afile = path.resolve(path.dirname(row.file), key);            var rfile = / + relativePath(basedir, afile);            if (self._external.indexOf(rfile) >= 0) {                row.deps[key] = rfile;            }            if (self._external.indexOf(afile) >= 0) {                row.deps[key] = rfile;            }            if (self._external.indexOf(key) >= 0) {                row.deps[key] = key;                return;            }                        for (var i = 0; i < self._extensions.length; i++) {                var ex = self._extensions[i];                if (self._external.indexOf(rfile + ex) >= 0) {                    row.deps[key] = rfile + ex;                    break;                }            }        });                if (row.entry || row.expose) {            self._bpack.standaloneModule = row.id;        }        this.push(row);        next();    });};
Browserify.prototype._emitDeps = function () {    var self = this;    return through.obj(function (row, enc, next) {        self.emit(dep, row);        this.push(row);        next();    })};
Browserify.prototype._debug = function (opts) {    var basedir = defined(opts.basedir, process.cwd());    return through.obj(function (row, enc, next) {        if (opts.debug) {            row.sourceRoot = file://localhost;            row.sourceFile = relativePath(basedir, row.file)                .replace(g, /);        }        this.push(row);        next();    });};
Browserify.prototype.reset = function (opts) {    if (!opts) opts = {};    var hadExports = this._bpack.hasExports;    this.pipeline = this._createPipeline(xtend(opts, this._options));    this._bpack.hasExports = hadExports;    this._entryOrder = 0;    this._bundled = false;    this.emit(reset);};
Browserify.prototype.bundle = function (cb) {    var self = this;    if (cb && typeof cb === object) {        throw new Error(            bundle() no longer accepts option arguments.            + Move all option arguments to the browserify() constructor.        );    }    if (this._bundled) {        var recorded = this._recorded;        this.reset();        recorded.forEach(function (x) {            self.pipeline.write(x);        });    }    var output = readonly(this.pipeline);    if (cb) {        output.on(error, cb);        output.pipe(concat(function (body) {            cb(null, body);        }));    }
    function ready () {        self.emit(bundle, output);        self.pipeline.end();    }
    if (this._pending === 0) ready();    else this.once(_ready, ready);
    this._bundled = true;    return output;};
function isStream (s) { return s && typeof s.pipe === function }function isAbsolutePath (file) {    var regexp = process.platform === win32 ?        : :        ;    return regexp.test(file);}function isExternalModule (file) {    var regexp = process.platform === win32 ?        (:) :        ;    return !regexp.test(file);}"
" Public API for node-inspector embeddersvar url = require(url);var path = require(path);
exports.buildInspectorUrl = buildInspectorUrl;exports.buildWebSocketUrl = buildWebSocketUrl;
/** * Build a URL for loading inspector UI in the browser. *    as configured via --web-host *    as configured via --web-port *    as configured via --debug in the debugged app *    as configured via --ssl-cert and --ssl-key in the debugged app */function buildInspectorUrl(inspectorHost, inspectorPort, debugPort, isHttps) {  var host = inspectorHost == 0.0.0.0 ? 127.0.0.1 : inspectorHost;  var port = inspectorPort;  var protocol = isHttps ? https : http;
  var isUnixSocket = !.test(port);  if (isUnixSocket) {    host = path.resolve(__dirname, inspectorPort);    port = null;    protocol = unix;  }
  var parts = {    protocol: protocol,    hostname: host,    port: port,    pathname: /,    search: ?port= + debugPort  };
  return url.format(parts);}
/** * Build a URL for the WebSocket endpoint. *    as configured via --web-host *    as configured via --web-port *    as configured via --debug in the debugged app *    as configured via --ssl-cert and --ssl-key in the debugged app */function buildWebSocketUrl(inspectorHost, inspectorPort, debugPort, isSecure) {  var parts = {    protocol: isSecure ? wss: : ws:,    hostname: inspectorHost == 0.0.0.0 ? 127.0.0.1 : inspectorHost,    port: inspectorPort,    pathname: /,    search: ?port= + debugPort,    slashes: true  };
  return url.format(parts);}"
"module.exports = function(grunt) {  var pkg = require(./package.json);  global.jasmineVersion = pkg.version;
  grunt.initConfig({    pkg: pkg,    jshint: require(./grunt/config/jshint.js),    concat: require(./grunt/config/concat.js),    compass: require(./grunt/config/compass.js),    compress: require(./grunt/config/compress.js)  });
  require(load-grunt-tasks)(grunt);
  grunt.loadTasks(grunt/tasks);
  grunt.registerTask(default, [jshint:all]);
  var version = require(./grunt/tasks/version.js);
  grunt.registerTask(build:copyVersionToGem,    Propagates the version from package.json to version.rb,    version.copyToGem);
  grunt.registerTask(buildDistribution,    Builds and lints jasmine.js, jasmine-html.js, jasmine.css,    [      compass,      jshint:beforeConcat,      concat,      jshint:afterConcat,      build:copyVersionToGem    ]  );
  grunt.registerTask(execSpecsInNode,    Run Jasmine core specs in Node.js,    function() {      var done = this.async(),          Jasmine = require(jasmine),          jasmineCore = require(./lib/jasmine-core.js),          jasmine = new Jasmine({jasmineCore: jasmineCore});
      jasmine.loadConfigFile(./spec/support/jasmine.json);      jasmine.onComplete(function(passed) {        done(passed);      });
      jasmine.execute();    }  );
  grunt.registerTask(execSpecsInNode:performance,    Run Jasmine performance specs in Node.js,    function() {      require(shelljs).exec(node_modules/.bin/jasmine JASMINE_CONFIG_PATH=spec/support/jasmine-performance.json);    }  );};"
"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==function&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(Cannot find module '+o+');throw f.code=MODULE_NOT_FOUND,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==function&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){(function (process,global){use strict;
/* eslint no-unused-vars: off *//* eslint-env commonjs */
/** * Shim process.stdout. */
process.stdout = require(browser-stdout)();
var Mocha = require(./lib/mocha);
/** * Create a Mocha instance. * *   */
var mocha = new Mocha({ reporter: html });
/** * Save timer references to avoid Sinon interfering (see GH-237). */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
var uncaughtExceptionHandlers = [];
var originalOnerrorHandler = global.onerror;
/** * Remove uncaughtException listener. * Revert to original onerror handler if previously defined. */
process.removeListener = function (e, fn) {  if (e === uncaughtException) {    if (originalOnerrorHandler) {      global.onerror = originalOnerrorHandler;    } else {      global.onerror = function () {};    }    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);    if (i !== -1) {      uncaughtExceptionHandlers.splice(i, 1);    }  }};
/** * Implements uncaughtException listener. */
process.on = function (e, fn) {  if (e === uncaughtException) {    global.onerror = function (err, url, line) {      fn(new Error(err +  ( + url + : + line + )));      return !mocha.allowUncaught;    };    uncaughtExceptionHandlers.push(fn);  }};
 The BDD UI is registered by default, but no UI will be functional in the browser without an explicit call to the overridden `mocha.ui` (see below). Ensure that this default UI does not expose its methods to the global scope.mocha.suite.removeAllListeners(pre-require);
var immediateQueue = [];var immediateTimeout;
function timeslice () {  var immediateStart = new Date().getTime();  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {    immediateQueue.shift()();  }  if (immediateQueue.length) {    immediateTimeout = setTimeout(timeslice, 0);  } else {    immediateTimeout = null;  }}
/** * High-performance override of Runner.immediately. */
Mocha.Runner.immediately = function (callback) {  immediateQueue.push(callback);  if (!immediateTimeout) {    immediateTimeout = setTimeout(timeslice, 0);  }};
/** * Function to allow assertion libraries to throw errors directly into mocha. * This is useful when running tests in a browser because window.onerror will * only receive the 'message' attribute of the Error. */mocha.throwError = function (err) {  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {    fn(err);  });  throw err;};
/** * Override ui to ensure that the ui functions are initialized. * Normally this would happen in Mocha.prototype.loadFiles. */
mocha.ui = function (ui) {  Mocha.prototype.ui.call(this, ui);  this.suite.emit(pre-require, global, null, this);  return this;};
/** * Setup mocha with the given setting options. */
mocha.setup = function (opts) {  if (typeof opts === string) {    opts = { ui: opts };  }  for (var opt in opts) {    if (opts.hasOwnProperty(opt)) {      this[opt](opts[opt]);    }  }  return this;};
/** * Run mocha, returning the Runner. */
mocha.run = function (fn) {  var options = mocha.options;  mocha.globals(location);
  var query = Mocha.utils.parseQuery(global.location.search || );  if (query.grep) {    mocha.grep(query.grep);  }  if (query.fgrep) {    mocha.fgrep(query.fgrep);  }  if (query.invert) {    mocha.invert();  }
  return Mocha.prototype.run.call(mocha, function (err) {     The DOM Document is not available in Web Workers.    var document = global.document;    if (document && document.getElementById(mocha) && options.noHighlighting !== true) {      Mocha.utils.highlightTags(code);    }    if (fn) {      fn(err);    }  });};
/** * Expose the process shim. * https://github.com/mochajs/mocha/pull/916 */
Mocha.process = process;
/** * Expose mocha. */
global.Mocha = Mocha;global.mocha = mocha;
 this allows test/acceptance/required-tokens.js to pass; thus, you can now do `const describe = require('mocha').describe` in a browser context (assuming browserification).  should fix #880module.exports = global;
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./lib/mocha:14,_process:67,browser-stdout:41}],2:[function(require,module,exports){use strict;
function noop () {}
module.exports = function () {  return noop;};
},{}],3:[function(require,module,exports){use strict;
/** * Module exports. */
exports.EventEmitter = EventEmitter;
/** * Object#toString reference. */var objToString = Object.prototype.toString;
/** * Check if a value is an array. * * @api private *    The value to test. *   true if the value is an array, otherwise false. */function isArray (val) {  return objToString.call(val) === [object Array];}
/** * Event emitter constructor. * * @api public */function EventEmitter () {}
/** * Add a listener. * * @api public *    Event name. *    Event handler. *   Emitter instance. */EventEmitter.prototype.on = function (name, fn) {  if (!this.$events) {    this.$events = {};  }
  if (!this.$events[name]) {    this.$events[name] = fn;  } else if (isArray(this.$events[name])) {    this.$events[name].push(fn);  } else {    this.$events[name] = [this.$events[name], fn];  }
  return this;};
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
/** * Adds a volatile listener. * * @api public *    Event name. *    Event handler. *   Emitter instance. */EventEmitter.prototype.once = function (name, fn) {  var self = this;
  function on () {    self.removeListener(name, on);    fn.apply(this, arguments);  }
  on.listener = fn;  this.on(name, on);
  return this;};
/** * Remove a listener. * * @api public *    Event name. *    Event handler. *   Emitter instance. */EventEmitter.prototype.removeListener = function (name, fn) {  if (this.$events && this.$events[name]) {    var list = this.$events[name];
    if (isArray(list)) {      var pos = -1;
      for (var i = 0, l = list.length; i < l; i++) {        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {          pos = i;          break;        }      }
      if (pos < 0) {        return this;      }
      list.splice(pos, 1);
      if (!list.length) {        delete this.$events[name];      }    } else if (list === fn || (list.listener && list.listener === fn)) {      delete this.$events[name];    }  }
  return this;};
/** * Remove all listeners for an event. * * @api public *    Event name. *   Emitter instance. */EventEmitter.prototype.removeAllListeners = function (name) {  if (name === undefined) {    this.$events = {};    return this;  }
  if (this.$events && this.$events[name]) {    this.$events[name] = null;  }
  return this;};
/** * Get all listeners for a given event. * * @api public *    Event name. *   Emitter instance. */EventEmitter.prototype.listeners = function (name) {  if (!this.$events) {    this.$events = {};  }
  if (!this.$events[name]) {    this.$events[name] = [];  }
  if (!isArray(this.$events[name])) {    this.$events[name] = [this.$events[name]];  }
  return this.$events[name];};
/** * Emit an event. * * @api public *    Event name. *   true if at least one handler was invoked, else false. */EventEmitter.prototype.emit = function (name) {  if (!this.$events) {    return false;  }
  var handler = this.$events[name];
  if (!handler) {    return false;  }
  var args = Array.prototype.slice.call(arguments, 1);
  if (typeof handler === function) {    handler.apply(this, args);  } else if (isArray(handler)) {    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {      listeners[i].apply(this, args);    }  } else {    return false;  }
  return true;};
},{}],4:[function(require,module,exports){use strict;
/** * Expose `Progress`. */
module.exports = Progress;
/** * Initialize a new `Progress` indicator. */function Progress () {  this.percent = 0;  this.size(0);  this.fontSize(11);  this.font(helvetica, arial, sans-serif);}
/** * Set progress size to `size`. * * @api public *    *   Progress instance. */Progress.prototype.size = function (size) {  this._size = size;  return this;};
/** * Set text to `text`. * * @api public *    *   Progress instance. */Progress.prototype.text = function (text) {  this._text = text;  return this;};
/** * Set font size to `size`. * * @api public *    *   Progress instance. */Progress.prototype.fontSize = function (size) {  this._fontSize = size;  return this;};
/** * Set font to `family`. * *    *   Progress instance. */Progress.prototype.font = function (family) {  this._font = family;  return this;};
/** * Update percentage to `n`. * *    *   Progress instance. */Progress.prototype.update = function (n) {  this.percent = n;  return this;};
/** * Draw on `ctx`. * *    *   Progress instance. */Progress.prototype.draw = function (ctx) {  try {    var percent = Math.min(this.percent, 100);    var size = this._size;    var half = size / 2;    var x = half;    var y = half;    var rad = half - 1;    var fontSize = this._fontSize;
    ctx.font = fontSize + px  + this._font;
    var angle = Math.PI * 2 * (percent / 100);    ctx.clearRect(0, 0, size, size);
     outer circle    ctx.strokeStyle = #9f9f9f;    ctx.beginPath();    ctx.arc(x, y, rad, 0, angle, false);    ctx.stroke();
     inner circle    ctx.strokeStyle = #eee;    ctx.beginPath();    ctx.arc(x, y, rad - 1, 0, angle, true);    ctx.stroke();
     text    var text = this._text || (percent | 0) + %;    var w = ctx.measureText(text).width;
    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);  } catch (err) {     don't fail if we can't render progress  }  return this;};
},{}],5:[function(require,module,exports){(function (global){use strict;
exports.isatty = function isatty () {  return true;};
exports.getWindowSize = function getWindowSize () {  if (innerHeight in global) {    return [global.innerHeight, global.innerWidth];  }   In a Web Worker, the DOM Window is not available.  return [640, 480];};
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{}],6:[function(require,module,exports){use strict;
/** * Module dependencies. */
var JSON = require(json3);
/** * Expose `Context`. */
module.exports = Context;
/** * Initialize a new `Context`. * * @api private */function Context () {}
/** * Set or get the context `Runnable` to `runnable`. * * @api private *    *   */Context.prototype.runnable = function (runnable) {  if (!arguments.length) {    return this._runnable;  }  this.test = this._runnable = runnable;  return this;};
/** * Set test timeout `ms`. * * @api private *    *   self */Context.prototype.timeout = function (ms) {  if (!arguments.length) {    return this.runnable().timeout();  }  this.runnable().timeout(ms);  return this;};
/** * Set test timeout `enabled`. * * @api private *    *   self */Context.prototype.enableTimeouts = function (enabled) {  this.runnable().enableTimeouts(enabled);  return this;};
/** * Set test slowness threshold `ms`. * * @api private *    *   self */Context.prototype.slow = function (ms) {  this.runnable().slow(ms);  return this;};
/** * Mark a test as skipped. * * @api private *   self */Context.prototype.skip = function () {  this.runnable().skip();  return this;};
/** * Allow a number of retries on failed tests * * @api private *    *   self */Context.prototype.retries = function (n) {  if (!arguments.length) {    return this.runnable().retries();  }  this.runnable().retries(n);  return this;};
/** * Inspect the context void of `._runnable`. * * @api private *   */Context.prototype.inspect = function () {  return JSON.stringify(this, function (key, val) {    return key === runnable || key === test ? undefined : val;  }, 2);};
},{json3:54}],7:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Runnable = require(./runnable);var inherits = require(./utils).inherits;
/** * Expose `Hook`. */
module.exports = Hook;
/** * Initialize a new `Hook` with the given `title` and callback `fn`. * *    *    * @api private */function Hook (title, fn) {  Runnable.call(this, title, fn);  this.type = hook;}
/** * Inherit from `Runnable.prototype`. */inherits(Hook, Runnable);
/** * Get or set the test `err`. * *    *   * @api public */Hook.prototype.error = function (err) {  if (!arguments.length) {    err = this._error;    this._error = null;    return err;  }
  this._error = err;};
},{./runnable:33,./utils:38}],8:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Test = require(../test);
/** * BDD-style interface: * *      describe('Array', function() { *        describe('#indexOf()', function() { *          it('should return -1 when not present', function() { *            // ... *          }); * *          it('should return the index when present', function() { *            // ... *          }); *        }); *      }); * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(pre-require, function (context, file, mocha) {    var common = require(./common)(suites, context, mocha);
    context.before = common.before;    context.after = common.after;    context.beforeEach = common.beforeEach;    context.afterEach = common.afterEach;    context.run = mocha.options.delay && common.runWithSuite(suite);    /**     * Describe a ""suite"" with the given `title`     * and callback `fn` containing nested suites     * and/or tests.     */
    context.describe = context.context = function (title, fn) {      return common.suite.create({        title: title,        file: file,        fn: fn      });    };
    /**     * Pending describe.     */
    context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {      return common.suite.skip({        title: title,        file: file,        fn: fn      });    };
    /**     * Exclusive suite.     */
    context.describe.only = function (title, fn) {      return common.suite.only({        title: title,        file: file,        fn: fn      });    };
    /**     * Describe a specification or test-case     * with the given `title` and callback `fn`     * acting as a thunk.     */
    context.it = context.specify = function (title, fn) {      var suite = suites[0];      if (suite.isPending()) {        fn = null;      }      var test = new Test(title, fn);      test.file = file;      suite.addTest(test);      return test;    };
    /**     * Exclusive test-case.     */
    context.it.only = function (title, fn) {      return common.test.only(mocha, context.it(title, fn));    };
    /**     * Pending test case.     */
    context.xit = context.xspecify = context.it.skip = function (title) {      context.it(title);    };
    /**     * Number of attempts to retry.     */    context.it.retries = function (n) {      context.retries(n);    };  });};
},{../test:36,./common:9}],9:[function(require,module,exports){use strict;
var Suite = require(../suite);
/** * Functions common to more than one interface. * *    *    *    *   An object containing common functions. */module.exports = function (suites, context, mocha) {  return {    /**     * This is only present if flag --delay is passed into Mocha. It triggers     * root suite execution.     *     *    The root suite.     *   A function which runs the root suite     */    runWithSuite: function runWithSuite (suite) {      return function run () {        suite.run();      };    },
    /**     * Execute before running tests.     *     *        *        */    before: function (name, fn) {      suites[0].beforeAll(name, fn);    },
    /**     * Execute after running tests.     *     *        *        */    after: function (name, fn) {      suites[0].afterAll(name, fn);    },
    /**     * Execute before each test case.     *     *        *        */    beforeEach: function (name, fn) {      suites[0].beforeEach(name, fn);    },
    /**     * Execute after each test case.     *     *        *        */    afterEach: function (name, fn) {      suites[0].afterEach(name, fn);    },
    suite: {      /**       * Create an exclusive Suite; convenience function       * See docstring for create() below.       *       *          *         */      only: function only (opts) {        mocha.options.hasOnly = true;        opts.isOnly = true;        return this.create(opts);      },
      /**       * Create a Suite, but skip it; convenience function       * See docstring for create() below.       *       *          *         */      skip: function skip (opts) {        opts.pending = true;        return this.create(opts);      },
      /**       * Creates a suite.       *    Options       *    Title of Suite       *    Suite Function (not always applicable)       *    Is Suite pending?       *    Filepath where this Suite resides       *    Is Suite exclusive?       *         */      create: function create (opts) {        var suite = Suite.create(suites[0], opts.title);        suite.pending = Boolean(opts.pending);        suite.file = opts.file;        suites.unshift(suite);        if (opts.isOnly) {          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);          mocha.options.hasOnly = true;        }        if (typeof opts.fn === function) {          opts.fn.call(suite);          suites.shift();        } else if (typeof opts.fn === undefined && !suite.pending) {          throw new Error(Suite "" + suite.fullTitle() + "" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.);        }
        return suite;      }    },
    test: {
      /**       * Exclusive test-case.       *       *          *          *         */      only: function (mocha, test) {        test.parent._onlyTests = test.parent._onlyTests.concat(test);        mocha.options.hasOnly = true;        return test;      },
      /**       * Pending test case.       *       *          */      skip: function (title) {        context.test(title);      },
      /**       * Number of retry attempts       *       *          */      retries: function (n) {        context.retries(n);      }    }  };};
},{../suite:35}],10:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Suite = require(../suite);var Test = require(../test);
/** * Exports-style (as Node.js module) interface: * *     exports.Array = { *       '#indexOf()': { *         'should return -1 when the value is not present': function() { * *         }, * *         'should return the correct index when the value is present': function() { * *         } *       } *     }; * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(require, visit);
  function visit (obj, file) {    var suite;    for (var key in obj) {      if (typeof obj[key] === function) {        var fn = obj[key];        switch (key) {          case before:            suites[0].beforeAll(fn);            break;          case after:            suites[0].afterAll(fn);            break;          case beforeEach:            suites[0].beforeEach(fn);            break;          case afterEach:            suites[0].afterEach(fn);            break;          default:            var test = new Test(key, fn);            test.file = file;            suites[0].addTest(test);        }      } else {        suite = Suite.create(suites[0], key);        suites.unshift(suite);        visit(obj[key], file);        suites.shift();      }    }  }};
},{../suite:35,../test:36}],11:[function(require,module,exports){use strict;
exports.bdd = require(./bdd);exports.tdd = require(./tdd);exports.qunit = require(./qunit);exports.exports = require(./exports);
},{./bdd:8,./exports:10,./qunit:12,./tdd:13}],12:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Test = require(../test);
/** * QUnit-style interface: * *     suite('Array'); * *     test('#length', function() { *       var arr = [1,2,3]; *       ok(arr.length == 3); *     }); * *     test('#indexOf()', function() { *       var arr = [1,2,3]; *       ok(arr.indexOf(1) == 0); *       ok(arr.indexOf(2) == 1); *       ok(arr.indexOf(3) == 2); *     }); * *     suite('String'); * *     test('#length', function() { *       ok('foo'.length == 3); *     }); * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(pre-require, function (context, file, mocha) {    var common = require(./common)(suites, context, mocha);
    context.before = common.before;    context.after = common.after;    context.beforeEach = common.beforeEach;    context.afterEach = common.afterEach;    context.run = mocha.options.delay && common.runWithSuite(suite);    /**     * Describe a ""suite"" with the given `title`.     */
    context.suite = function (title) {      if (suites.length > 1) {        suites.shift();      }      return common.suite.create({        title: title,        file: file,        fn: false      });    };
    /**     * Exclusive Suite.     */
    context.suite.only = function (title) {      if (suites.length > 1) {        suites.shift();      }      return common.suite.only({        title: title,        file: file,        fn: false      });    };
    /**     * Describe a specification or test-case     * with the given `title` and callback `fn`     * acting as a thunk.     */
    context.test = function (title, fn) {      var test = new Test(title, fn);      test.file = file;      suites[0].addTest(test);      return test;    };
    /**     * Exclusive test-case.     */
    context.test.only = function (title, fn) {      return common.test.only(mocha, context.test(title, fn));    };
    context.test.skip = common.test.skip;    context.test.retries = common.test.retries;  });};
},{../test:36,./common:9}],13:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Test = require(../test);
/** * TDD-style interface: * *      suite('Array', function() { *        suite('#indexOf()', function() { *          suiteSetup(function() { * *          }); * *          test('should return -1 when not present', function() { * *          }); * *          test('should return the index when present', function() { * *          }); * *          suiteTeardown(function() { * *          }); *        }); *      }); * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(pre-require, function (context, file, mocha) {    var common = require(./common)(suites, context, mocha);
    context.setup = common.beforeEach;    context.teardown = common.afterEach;    context.suiteSetup = common.before;    context.suiteTeardown = common.after;    context.run = mocha.options.delay && common.runWithSuite(suite);
    /**     * Describe a ""suite"" with the given `title` and callback `fn` containing     * nested suites and/or tests.     */    context.suite = function (title, fn) {      return common.suite.create({        title: title,        file: file,        fn: fn      });    };
    /**     * Pending suite.     */    context.suite.skip = function (title, fn) {      return common.suite.skip({        title: title,        file: file,        fn: fn      });    };
    /**     * Exclusive test-case.     */    context.suite.only = function (title, fn) {      return common.suite.only({        title: title,        file: file,        fn: fn      });    };
    /**     * Describe a specification or test-case with the given `title` and     * callback `fn` acting as a thunk.     */    context.test = function (title, fn) {      var suite = suites[0];      if (suite.isPending()) {        fn = null;      }      var test = new Test(title, fn);      test.file = file;      suite.addTest(test);      return test;    };
    /**     * Exclusive test-case.     */
    context.test.only = function (title, fn) {      return common.test.only(mocha, context.test(title, fn));    };
    context.test.skip = common.test.skip;    context.test.retries = common.test.retries;  });};
},{../test:36,./common:9}],14:[function(require,module,exports){(function (process,global,__dirname){use strict;
/*! * mocha * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca> * MIT Licensed */
/** * Module dependencies. */
var escapeRe = require(escape-string-regexp);var path = require(path);var reporters = require(./reporters);var utils = require(./utils);
/** * Expose `Mocha`. */
exports = module.exports = Mocha;
/** * To require local UIs and reporters when running in node. */
if (!process.browser) {  var cwd = process.cwd();  module.paths.push(cwd, path.join(cwd, node_modules));}
/** * Expose internals. */
exports.utils = utils;exports.interfaces = require(./interfaces);exports.reporters = reporters;exports.Runnable = require(./runnable);exports.Context = require(./context);exports.Runner = require(./runner);exports.Suite = require(./suite);exports.Hook = require(./hook);exports.Test = require(./test);
/** * Return image `name` path. * * @api private *    *   */function image (name) {  return path.join(__dirname, ../images, name + .png);}
/** * Set up mocha with `options`. * * Options: * *   - `ui` name ""bdd"", ""tdd"", ""exports"" etc *   - `reporter` reporter instance, defaults to `mocha.reporters.spec` *   - `globals` array of accepted globals *   - `timeout` timeout in milliseconds *   - `retries` number of times to retry failed tests *   - `bail` bail on the first test failure *   - `slow` milliseconds to wait before considering a test slow *   - `ignoreLeaks` ignore global leaks *   - `fullTrace` display the full stack-trace on failing *   - `grep` string or regexp to filter tests with * *    * @api public */function Mocha (options) {  options = options || {};  this.files = [];  this.options = options;  if (options.grep) {    this.grep(new RegExp(options.grep));  }  if (options.fgrep) {    this.fgrep(options.fgrep);  }  this.suite = new exports.Suite(, new exports.Context());  this.ui(options.ui);  this.bail(options.bail);  this.reporter(options.reporter, options.reporterOptions);  if (typeof options.timeout !== undefined && options.timeout !== null) {    this.timeout(options.timeout);  }  if (typeof options.retries !== undefined && options.retries !== null) {    this.retries(options.retries);  }  this.useColors(options.useColors);  if (options.enableTimeouts !== null) {    this.enableTimeouts(options.enableTimeouts);  }  if (options.slow) {    this.slow(options.slow);  }}
/** * Enable or disable bailing on the first failure. * * @api public *    */Mocha.prototype.bail = function (bail) {  if (!arguments.length) {    bail = true;  }  this.suite.bail(bail);  return this;};
/** * Add test `file`. * * @api public *    */Mocha.prototype.addFile = function (file) {  this.files.push(file);  return this;};
/** * Set reporter to `reporter`, defaults to ""spec"". * *    name or constructor *    optional options * @api public *    name or constructor *    optional options */Mocha.prototype.reporter = function (reporter, reporterOptions) {  if (typeof reporter === function) {    this._reporter = reporter;  } else {    reporter = reporter || spec;    var _reporter;     Try to load a built-in reporter.    if (reporters[reporter]) {      _reporter = reporters[reporter];    }     Try to load reporters from process.cwd() and node_modules    if (!_reporter) {      try {        _reporter = require(reporter);      } catch (err) {        err.message.indexOf(Cannot find module) !== -1          ? console.warn("" + reporter + "" reporter not found)          : console.warn("" + reporter + "" reporter blew up with error: + err.stack);      }    }    if (!_reporter && reporter === teamcity) {      console.warn(The Teamcity reporter was moved to a package named  +        mocha-teamcity-reporter  +        (https://npmjs.org/package/mocha-teamcity-reporter).);    }    if (!_reporter) {      throw new Error(invalid reporter "" + reporter + "");    }    this._reporter = _reporter;  }  this.options.reporterOptions = reporterOptions;  return this;};
/** * Set test UI `name`, defaults to ""bdd"". * * @api public *    */Mocha.prototype.ui = function (name) {  name = name || bdd;  this._ui = exports.interfaces[name];  if (!this._ui) {    try {      this._ui = require(name);    } catch (err) {      throw new Error(invalid interface "" + name + "");    }  }  this._ui = this._ui(this.suite);
  this.suite.on(pre-require, function (context) {    exports.afterEach = context.afterEach || context.teardown;    exports.after = context.after || context.suiteTeardown;    exports.beforeEach = context.beforeEach || context.setup;    exports.before = context.before || context.suiteSetup;    exports.describe = context.describe || context.suite;    exports.it = context.it || context.test;    exports.setup = context.setup || context.beforeEach;    exports.suiteSetup = context.suiteSetup || context.before;    exports.suiteTeardown = context.suiteTeardown || context.after;    exports.suite = context.suite || context.describe;    exports.teardown = context.teardown || context.afterEach;    exports.test = context.test || context.it;    exports.run = context.run;  });
  return this;};
/** * Load registered files. * * @api private */Mocha.prototype.loadFiles = function (fn) {  var self = this;  var suite = this.suite;  this.files.forEach(function (file) {    file = path.resolve(file);    suite.emit(pre-require, global, file, self);    suite.emit(require, require(file), file, self);    suite.emit(post-require, global, file, self);  });  fn && fn();};
/** * Enable growl support. * * @api private */Mocha.prototype._growl = function (runner, reporter) {  var notify = require(growl);
  runner.on(end, function () {    var stats = reporter.stats;    if (stats.failures) {      var msg = stats.failures +  of  + runner.total +  tests failed;      notify(msg, { name: mocha, title: Failed, image: image(error) });    } else {      notify(stats.passes +  tests passed in  + stats.duration + ms, {        name: mocha,        title: Passed,        image: image(ok)      });    }  });};
/** * Escape string and add it to grep as a regexp. * * @api public *   *   */Mocha.prototype.fgrep = function (str) {  return this.grep(new RegExp(escapeRe(str)));};
/** * Add regexp to grep, if `re` is a string it is escaped. * *    *   * @api public *    *   */Mocha.prototype.grep = function (re) {  if (utils.isString(re)) {     extract args if it's regex-like, i.e: [string, pattern, flag]    var arg = re.match(()(gi));    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);  } else {    this.options.grep = re;  }  return this;};/** * Invert `.grep()` matches. * *   * @api public */Mocha.prototype.invert = function () {  this.options.invert = true;  return this;};
/** * Ignore global leaks. * *    *   * @api public *    *   */Mocha.prototype.ignoreLeaks = function (ignore) {  this.options.ignoreLeaks = Boolean(ignore);  return this;};
/** * Enable global leak checking. * *   * @api public */Mocha.prototype.checkLeaks = function () {  this.options.ignoreLeaks = false;  return this;};
/** * Display long stack-trace on failing * *   * @api public */Mocha.prototype.fullTrace = function () {  this.options.fullStackTrace = true;  return this;};
/** * Enable growl support. * *   * @api public */Mocha.prototype.growl = function () {  this.options.growl = true;  return this;};
/** * Ignore `globals` array or string. * *    *   * @api public *    *   */Mocha.prototype.globals = function (globals) {  this.options.globals = (this.options.globals || []).concat(globals);  return this;};
/** * Emit color output. * *    *   * @api public *    *   */Mocha.prototype.useColors = function (colors) {  if (colors !== undefined) {    this.options.useColors = colors;  }  return this;};
/** * Use inline diffs rather than +/-. * *    *   * @api public *    *   */Mocha.prototype.useInlineDiffs = function (inlineDiffs) {  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;  return this;};
/** * Set the timeout in milliseconds. * *    *   * @api public *    *   */Mocha.prototype.timeout = function (timeout) {  this.suite.timeout(timeout);  return this;};
/** * Set the number of times to retry failed tests. * *    times *   * @api public */Mocha.prototype.retries = function (n) {  this.suite.retries(n);  return this;};
/** * Set slowness threshold in milliseconds. * *    *   * @api public *    *   */Mocha.prototype.slow = function (slow) {  this.suite.slow(slow);  return this;};
/** * Enable timeouts. * *    *   * @api public *    *   */Mocha.prototype.enableTimeouts = function (enabled) {  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);  return this;};
/** * Makes all tests async (accepting a callback) * *   * @api public */Mocha.prototype.asyncOnly = function () {  this.options.asyncOnly = true;  return this;};
/** * Disable syntax highlighting (in browser). * * @api public */Mocha.prototype.noHighlighting = function () {  this.options.noHighlighting = true;  return this;};
/** * Enable uncaught errors to propagate (in browser). * *   * @api public */Mocha.prototype.allowUncaught = function () {  this.options.allowUncaught = true;  return this;};
/** * Delay root suite execution. *   */Mocha.prototype.delay = function delay () {  this.options.delay = true;  return this;};
/** * Run tests and invoke `fn()` when complete. * * @api public *    *   */Mocha.prototype.run = function (fn) {  if (this.files.length) {    this.loadFiles();  }  var suite = this.suite;  var options = this.options;  options.files = this.files;  var runner = new exports.Runner(suite, options.delay);  var reporter = new this._reporter(runner, options);  runner.ignoreLeaks = options.ignoreLeaks !== false;  runner.fullStackTrace = options.fullStackTrace;  runner.hasOnly = options.hasOnly;  runner.asyncOnly = options.asyncOnly;  runner.allowUncaught = options.allowUncaught;  if (options.grep) {    runner.grep(options.grep, options.invert);  }  if (options.globals) {    runner.globals(options.globals);  }  if (options.growl) {    this._growl(runner, reporter);  }  if (options.useColors !== undefined) {    exports.reporters.Base.useColors = options.useColors;  }  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;
  function done (failures) {    if (reporter.done) {      reporter.done(failures, fn);    } else {      fn && fn(failures);    }  }
  return runner.run(done);};
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {},/lib)},{./context:6,./hook:7,./interfaces:11,./reporters:21,./runnable:33,./runner:34,./suite:35,./test:36,./utils:38,_process:67,escape-string-regexp:47,growl:49,path:42}],15:[function(require,module,exports){use strict;
/** * Helpers. */
var s = 1000;var m = s * 60;var h = m * 60;var d = h * 24;var y = d * 365.25;
/** * Parse or format the given `val`. * * Options: * *  - `long` verbose formatting [false] * * @api public *    *    *   */module.exports = function (val, options) {  options = options || {};  if (typeof val === string) {    return parse(val);  }   https://github.com/mochajs/mocha/pull/1035  return options[long] ? longFormat(val) : shortFormat(val);};
/** * Parse the given `str` and return milliseconds. * * @api private *    *   */function parse (str) {  var match = (((?:)) (mssecondssminutesmhourshdaysdyearsy)i).exec(str);  if (!match) {    return;  }  var n = parseFloat(match[1]);  var type = (match[2] || ms).toLowerCase();  switch (type) {    case years:    case year:    case y:      return n * y;    case days:    case day:    case d:      return n * d;    case hours:    case hour:    case h:      return n * h;    case minutes:    case minute:    case m:      return n * m;    case seconds:    case second:    case s:      return n * s;    case ms:      return n;    default:       No default case  }}
/** * Short format for `ms`. * * @api private *    *   */function shortFormat (ms) {  if (ms >= d) {    return Math.round(ms / d) + d;  }  if (ms >= h) {    return Math.round(ms / h) + h;  }  if (ms >= m) {    return Math.round(ms / m) + m;  }  if (ms >= s) {    return Math.round(ms / s) + s;  }  return ms + ms;}
/** * Long format for `ms`. * * @api private *    *   */function longFormat (ms) {  return plural(ms, d, day) ||    plural(ms, h, hour) ||    plural(ms, m, minute) ||    plural(ms, s, second) ||    ms +  ms;}
/** * Pluralization helper. * * @api private *    *    *    */function plural (ms, n, name) {  if (ms < n) {    return;  }  if (ms < n * 1.5) {    return Math.floor(ms / n) +   + name;  }  return Math.ceil(ms / n) +   + name + s;}
},{}],16:[function(require,module,exports){use strict;
/** * Expose `Pending`. */
module.exports = Pending;
/** * Initialize a new `Pending` error with the given message. * *    */function Pending (message) {  this.message = message;}
},{}],17:[function(require,module,exports){(function (process,global){use strict;
/** * Module dependencies. */
var tty = require(tty);var diff = require(diff);var ms = require(../ms);var utils = require(../utils);var supportsColor = process.browser ? null : require(supports-color);
/** * Expose `Base`. */
exports = module.exports = Base;
/** * Save timer references to avoid Sinon interfering. * See: https://github.com/mochajs/mocha/issues/237 */
/* eslint-disable no-unused-vars, no-native-reassign */var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;/* eslint-enable no-unused-vars, no-native-reassign */
/** * Check if both stdio streams are associated with a tty. */
var isatty = tty.isatty(1) && tty.isatty(2);
/** * Enable coloring by default, except in the browser interface. */
exports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));
/** * Inline diffs instead of +/- */
exports.inlineDiffs = false;
/** * Default color map. */
exports.colors = {  pass: 90,  fail: 31,  bright pass: 92,  bright fail: 91,  bright yellow: 93,  pending: 36,  suite: 0,  error title: 0,  error message: 31,  error stack: 90,  checkmark: 32,  fast: 90,  medium: 33,  slow: 31,  green: 32,  light: 90,  diff gutter: 90,  diff added: 32,  diff removed: 31};
/** * Default symbol map. */
exports.symbols = {  ok: ✓,  err: ✖,  dot: ․,  comma: ,,  bang: !};
 With node.js on Windows: use symbols available in terminal default fontsif (process.platform === win32) {  exports.symbols.ok = ;  exports.symbols.err = ;  exports.symbols.dot = .;}
/** * Color `str` with the given `type`, * allowing colors to be disabled, * as well as user-defined color * schemes. * *    *    *   * @api private */var color = exports.color = function (type, str) {  if (!exports.useColors) {    return String(str);  }  return [ + exports.colors[type] + m + str + [0m;};
/** * Expose term window size, with some defaults for when stderr is not a tty. */
exports.window = {  width: 75};
if (isatty) {  exports.window.width = process.stdout.getWindowSize      ? process.stdout.getWindowSize(1)[0]      : tty.getWindowSize()[1];}
/** * Expose some basic cursor interactions that are common among reporters. */
exports.cursor = {  hide: function () {    isatty && process.stdout.write([?25l);  },
  show: function () {    isatty && process.stdout.write([?25h);  },
  deleteLine: function () {    isatty && process.stdout.write([2K);  },
  beginningOfLine: function () {    isatty && process.stdout.write([0G);  },
  CR: function () {    if (isatty) {      exports.cursor.deleteLine();      exports.cursor.beginningOfLine();    } else {      process.stdout.write();    }  }};
/** * Outut the given `failures` as a list. * *    * @api public */
exports.list = function (failures) {  console.log();  failures.forEach(function (test, i) {     format    var fmt = color(error title,   %s) %s:) +      color(error message,      %s) +      color(error stack, %s);
     msg    var msg;    var err = test.err;    var message;    if (err.message && typeof err.message.toString === function) {      message = err.message + ;    } else if (typeof err.inspect === function) {      message = err.inspect() + ;    } else {      message = ;    }    var stack = err.stack || message;    var index = message ? stack.indexOf(message) : -1;    var actual = err.actual;    var expected = err.expected;    var escape = true;
    if (index === -1) {      msg = message;    } else {      index += message.length;      msg = stack.slice(0, index);       remove msg from stack      stack = stack.slice(index + 1);    }
     uncaught    if (err.uncaught) {      msg = Uncaught  + msg;    }     explicitly show diff    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {      escape = false;      if (!(utils.isString(actual) && utils.isString(expected))) {        err.actual = actual = utils.stringify(actual);        err.expected = expected = utils.stringify(expected);      }
      fmt = color(error title,   %s) %s:%s) + color(error stack, %s);      var match = message.match((): expected);      msg =        + color(error message, match ? match[1] : msg);
      if (exports.inlineDiffs) {        msg += inlineDiff(err, escape);      } else {        msg += unifiedDiff(err, escape);      }    }
     indent stack trace    stack = stack.replace(gm,   );
    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);  });};
/** * Initialize a new `Base` reporter. * * All other reporters generally * inherit from this reporter, providing * stats such as test duration, number * of tests passed / failed etc. * *    * @api public */
function Base (runner) {  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };  var failures = this.failures = [];
  if (!runner) {    return;  }  this.runner = runner;
  runner.stats = stats;
  runner.on(start, function () {    stats.start = new Date();  });
  runner.on(suite, function (suite) {    stats.suites = stats.suites || 0;    suite.root || stats.suites++;  });
  runner.on(test end, function () {    stats.tests = stats.tests || 0;    stats.tests++;  });
  runner.on(pass, function (test) {    stats.passes = stats.passes || 0;
    if (test.duration > test.slow()) {      test.speed = slow;    } else if (test.duration > test.slow() / 2) {      test.speed = medium;    } else {      test.speed = fast;    }
    stats.passes++;  });
  runner.on(fail, function (test, err) {    stats.failures = stats.failures || 0;    stats.failures++;    test.err = err;    failures.push(test);  });
  runner.on(end, function () {    stats.end = new Date();    stats.duration = new Date() - stats.start;  });
  runner.on(pending, function () {    stats.pending++;  });}
/** * Output common epilogue used by many of * the bundled reporters. * * @api public */Base.prototype.epilogue = function () {  var stats = this.stats;  var fmt;
  console.log();
   passes  fmt = color(bright pass,  ) +    color(green,  %d passing) +    color(light,  (%s));
  console.log(fmt,    stats.passes || 0,    ms(stats.duration));
   pending  if (stats.pending) {    fmt = color(pending,  ) +      color(pending,  %d pending);
    console.log(fmt, stats.pending);  }
   failures  if (stats.failures) {    fmt = color(fail,   %d failing);
    console.log(fmt, stats.failures);
    Base.list(this.failures);    console.log();  }
  console.log();};
/** * Pad the given `str` to `len`. * * @api private *    *    *   */function pad (str, len) {  str = String(str);  return Array(len - str.length + 1).join( ) + str;}
/** * Returns an inline diff between 2 strings with coloured ANSI output * * @api private *    with actual/expected *    *   Diff */function inlineDiff (err, escape) {  var msg = errorDiff(err, WordsWithSpace, escape);
   linenos  var lines = msg.split();  if (lines.length > 4) {    var width = String(lines.length).length;    msg = lines.map(function (str, i) {      return pad(++i, width) +  | +   + str;    }).join();  }
   legend  msg =  +    color(diff removed, actual) +      +    color(diff added, expected) +     +    msg +    ;
   indent  msg = msg.replace(gm,       );  return msg;}
/** * Returns a unified diff between two strings. * * @api private *    with actual/expected *    *   The diff. */function unifiedDiff (err, escape) {  var indent =       ;  function cleanUp (line) {    if (escape) {      line = escapeInvisibles(line);    }    if (line[0] === +) {      return indent + colorLines(diff added, line);    }    if (line[0] === -) {      return indent + colorLines(diff removed, line);    }    if (line.match(@@)) {      return null;    }    if (line.match( No newline)) {      return null;    }    return indent + line;  }  function notBlank (line) {    return typeof line !== undefined && line !== null;  }  var msg = diff.createPatch(string, err.actual, err.expected);  var lines = msg.split().splice(4);  return        +    colorLines(diff added, + expected) +   +    colorLines(diff removed, - actual) +     +    lines.map(cleanUp).filter(notBlank).join();}
/** * Return a character diff for `err`. * * @api private *    *    *    *   */function errorDiff (err, type, escape) {  var actual = escape ? escapeInvisibles(err.actual) : err.actual;  var expected = escape ? escapeInvisibles(err.expected) : err.expected;  return diff[diff + type](actual, expected).map(function (str) {    if (str.added) {      return colorLines(diff added, str.value);    }    if (str.removed) {      return colorLines(diff removed, str.value);    }    return str.value;  }).join();}
/** * Returns a string with all invisible characters in plain text * * @api private *    *   */function escapeInvisibles (line) {  return line.replace(g, <tab>)    .replace(g, <CR>)    .replace(g, <LF>);}
/** * Color lines for `str`, using the color `name`. * * @api private *    *    *   */function colorLines (name, str) {  return str.split().map(function (str) {    return color(name, str);  }).join();}
/** * Object#toString reference. */var objToString = Object.prototype.toString;
/** * Check that a / b have the same type. * * @api private *    *    *   */function sameType (a, b) {  return objToString.call(a) === objToString.call(b);}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{../ms:15,../utils:38,_process:67,diff:46,supports-color:42,tty:5}],18:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Base = require(./base);var utils = require(../utils);
/** * Expose `Doc`. */
exports = module.exports = Doc;
/** * Initialize a new `Doc` reporter. * *    * @api public */function Doc (runner) {  Base.call(this, runner);
  var indents = 2;
  function indent () {    return Array(indents).join(  );  }
  runner.on(suite, function (suite) {    if (suite.root) {      return;    }    ++indents;    console.log(%s<section class=""suite"">, indent());    ++indents;    console.log(%s<h1>%s</h1>, indent(), utils.escape(suite.title));    console.log(%s<dl>, indent());  });
  runner.on(suite end, function (suite) {    if (suite.root) {      return;    }    console.log(%s</dl>, indent());    --indents;    console.log(%s</section>, indent());    --indents;  });
  runner.on(pass, function (test) {    console.log(%s  <dt>%s</dt>, indent(), utils.escape(test.title));    var code = utils.escape(utils.clean(test.body));    console.log(%s  <dd><pre><code>%s</code></pre></dd>, indent(), code);  });
  runner.on(fail, function (test, err) {    console.log(%s  <dt class=""error"">%s</dt>, indent(), utils.escape(test.title));    var code = utils.escape(utils.clean(test.body));    console.log(%s  <dd class=""error""><pre><code>%s</code></pre></dd>, indent(), code);    console.log(%s  <dd class=""error"">%s</dd>, indent(), utils.escape(err));  });}
},{../utils:38,./base:17}],19:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;
/** * Expose `Dot`. */
exports = module.exports = Dot;
/** * Initialize a new `Dot` matrix test reporter. * * @api public *    */function Dot (runner) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width * 0.75 | 0;  var n = -1;
  runner.on(start, function () {    process.stdout.write();  });
  runner.on(pending, function () {    if (++n % width === 0) {      process.stdout.write(  );    }    process.stdout.write(color(pending, Base.symbols.comma));  });
  runner.on(pass, function (test) {    if (++n % width === 0) {      process.stdout.write(  );    }    if (test.speed === slow) {      process.stdout.write(color(bright yellow, Base.symbols.dot));    } else {      process.stdout.write(color(test.speed, Base.symbols.dot));    }  });
  runner.on(fail, function () {    if (++n % width === 0) {      process.stdout.write(  );    }    process.stdout.write(color(fail, Base.symbols.bang));  });
  runner.on(end, function () {    console.log();    self.epilogue();  });}
/** * Inherit from `Base.prototype`. */inherits(Dot, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],20:[function(require,module,exports){(function (global){use strict;
/* eslint-env browser */
/** * Module dependencies. */
var Base = require(./base);var utils = require(../utils);var Progress = require(../browser/progress);var escapeRe = require(escape-string-regexp);var escape = utils.escape;
/** * Save timer references to avoid Sinon interfering (see GH-237). */
/* eslint-disable no-unused-vars, no-native-reassign */var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;/* eslint-enable no-unused-vars, no-native-reassign */
/** * Expose `HTML`. */
exports = module.exports = HTML;
/** * Stats template. */
var statsTemplate = <ul id=""mocha-stats""> +  <li class=""progress""><canvas width=""40"" height=""40""></canvas></li> +  <li class=""passes""><a href=""javascript:void(0);"">passes:</a> <em>0</em></li> +  <li class=""failures""><a href=""javascript:void(0);"">failures:</a> <em>0</em></li> +  <li class=""duration"">duration: <em>0</em>s</li> +  </ul>;
/** * Initialize a new `HTML` reporter. * * @api public *    */function HTML (runner) {  Base.call(this, runner);
  var self = this;  var stats = this.stats;  var stat = fragment(statsTemplate);  var items = stat.getElementsByTagName(li);  var passes = items[1].getElementsByTagName(em)[0];  var passesLink = items[1].getElementsByTagName(a)[0];  var failures = items[2].getElementsByTagName(em)[0];  var failuresLink = items[2].getElementsByTagName(a)[0];  var duration = items[3].getElementsByTagName(em)[0];  var canvas = stat.getElementsByTagName(canvas)[0];  var report = fragment(<ul id=""mocha-report""></ul>);  var stack = [report];  var progress;  var ctx;  var root = document.getElementById(mocha);
  if (canvas.getContext) {    var ratio = window.devicePixelRatio || 1;    canvas.style.width = canvas.width;    canvas.style.height = canvas.height;    canvas.width *= ratio;    canvas.height *= ratio;    ctx = canvas.getContext(2d);    ctx.scale(ratio, ratio);    progress = new Progress();  }
  if (!root) {    return error(#mocha div missing, add it to your document);  }
   pass toggle  on(passesLink, click, function (evt) {    evt.preventDefault();    unhide();    var name = (pass).test(report.className) ?  :  pass;    report.className = report.className.replace(failpassg, ) + name;    if (report.className.trim()) {      hideSuitesWithout(test pass);    }  });
   failure toggle  on(failuresLink, click, function (evt) {    evt.preventDefault();    unhide();    var name = (fail).test(report.className) ?  :  fail;    report.className = report.className.replace(failpassg, ) + name;    if (report.className.trim()) {      hideSuitesWithout(test fail);    }  });
  root.appendChild(stat);  root.appendChild(report);
  if (progress) {    progress.size(40);  }
  runner.on(suite, function (suite) {    if (suite.root) {      return;    }
     suite    var url = self.suiteURL(suite);    var el = fragment(<li class=""suite""><h1><a href=""%s"">%s</a></h1></li>, url, escape(suite.title));
     container    stack[0].appendChild(el);    stack.unshift(document.createElement(ul));    el.appendChild(stack[0]);  });
  runner.on(suite end, function (suite) {    if (suite.root) {      updateStats();      return;    }    stack.shift();  });
  runner.on(pass, function (test) {    var url = self.testURL(test);    var markup = <li class=""test pass %e""><h2>%e<span class=""duration"">%ems</span>  +      <a href=""%s"" class=""replay"">&#x2023;</a></h2></li>;    var el = fragment(markup, test.speed, test.title, test.duration, url);    self.addCodeToggle(el, test.body);    appendToStack(el);    updateStats();  });
  runner.on(fail, function (test) {    var el = fragment(<li class=""test fail""><h2>%e <a href=""%e"" class=""replay"">&#x2023;</a></h2></li>,      test.title, self.testURL(test));    var stackString;  Note: Includes leading newline    var message = test.err.toString();
     <=IE7 stringifies to [Object Error]. Since it can be overloaded, we     check for the result of the stringifying.    if (message === [object Error]) {      message = test.err.message;    }
    if (test.err.stack) {      var indexOfMessage = test.err.stack.indexOf(test.err.message);      if (indexOfMessage === -1) {        stackString = test.err.stack;      } else {        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);      }    } else if (test.err.sourceURL && test.err.line !== undefined) {       Safari doesn't give you a stack. Let's at least provide a source line.      stackString = ( + test.err.sourceURL + : + test.err.line + );    }
    stackString = stackString || ;
    if (test.err.htmlMessage && stackString) {      el.appendChild(fragment(<div class=""html-error"">%s<pre class=""error"">%e</pre></div>,        test.err.htmlMessage, stackString));    } else if (test.err.htmlMessage) {      el.appendChild(fragment(<div class=""html-error"">%s</div>, test.err.htmlMessage));    } else {      el.appendChild(fragment(<pre class=""error"">%e%e</pre>, message, stackString));    }
    self.addCodeToggle(el, test.body);    appendToStack(el);    updateStats();  });
  runner.on(pending, function (test) {    var el = fragment(<li class=""test pass pending""><h2>%e</h2></li>, test.title);    appendToStack(el);    updateStats();  });
  function appendToStack (el) {     Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.    if (stack[0]) {      stack[0].appendChild(el);    }  }
  function updateStats () {     TODO: add to stats    var percent = stats.tests / runner.total * 100 | 0;    if (progress) {      progress.update(percent).draw(ctx);    }
     update stats    var ms = new Date() - stats.start;    text(passes, stats.passes);    text(failures, stats.failures);    text(duration, (ms / 1000).toFixed(2));  }}
/** * Makes a URL, preserving querystring (""search"") parameters. * *    *   A new URL. */function makeUrl (s) {  var search = window.location.search;
   Remove previous grep query parameter if present  if (search) {    search = search.replace(grep=g, ).replace(&, ?);  }
  return window.location.pathname + (search ? search + & : ?) + grep= + encodeURIComponent(escapeRe(s));}
/** * Provide suite URL. * *    */HTML.prototype.suiteURL = function (suite) {  return makeUrl(suite.fullTitle());};
/** * Provide test URL. * *    */HTML.prototype.testURL = function (test) {  return makeUrl(test.fullTitle());};
/** * Adds code toggle functionality for the provided test's list element. * *    *    */HTML.prototype.addCodeToggle = function (el, contents) {  var h2 = el.getElementsByTagName(h2)[0];
  on(h2, click, function () {    pre.style.display = pre.style.display === none ? block : none;  });
  var pre = fragment(<pre><code>%e</code></pre>, utils.clean(contents));  el.appendChild(pre);  pre.style.display = none;};
/** * Display error `msg`. * *    */function error (msg) {  document.body.appendChild(fragment(<div id=""mocha-error"">%s</div>, msg));}
/** * Return a DOM fragment from `html`. * *    */function fragment (html) {  var args = arguments;  var div = document.createElement(div);  var i = 1;
  div.innerHTML = html.replace(%()g, function (_, type) {    switch (type) {      case s: return String(args[i++]);      case e: return escape(args[i++]);       no default    }  });
  return div.firstChild;}
/** * Check for suites that do not have elements * with `classname`, and hide them. * *    */function hideSuitesWithout (classname) {  var suites = document.getElementsByClassName(suite);  for (var i = 0; i < suites.length; i++) {    var els = suites[i].getElementsByClassName(classname);    if (!els.length) {      suites[i].className +=  hidden;    }  }}
/** * Unhide .hidden suites. */function unhide () {  var els = document.getElementsByClassName(suite hidden);  for (var i = 0; i < els.length; ++i) {    els[i].className = els[i].className.replace(suite hidden, suite);  }}
/** * Set an element's text contents. * *    *    */function text (el, contents) {  if (el.textContent) {    el.textContent = contents;  } else {    el.innerText = contents;  }}
/** * Listen on `event` with callback `fn`. */function on (el, event, fn) {  if (el.addEventListener) {    el.addEventListener(event, fn, false);  } else {    el.attachEvent(on + event, fn);  }}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{../browser/progress:4,../utils:38,./base:17,escape-string-regexp:47}],21:[function(require,module,exports){use strict;
 Alias exports to a their normalized format Mocha#reporter to prevent a need for dynamic (try/catch) requires, which Browserify doesn't handle.exports.Base = exports.base = require(./base);exports.Dot = exports.dot = require(./dot);exports.Doc = exports.doc = require(./doc);exports.TAP = exports.tap = require(./tap);exports.JSON = exports.json = require(./json);exports.HTML = exports.html = require(./html);exports.List = exports.list = require(./list);exports.Min = exports.min = require(./min);exports.Spec = exports.spec = require(./spec);exports.Nyan = exports.nyan = require(./nyan);exports.XUnit = exports.xunit = require(./xunit);exports.Markdown = exports.markdown = require(./markdown);exports.Progress = exports.progress = require(./progress);exports.Landing = exports.landing = require(./landing);exports.JSONStream = exports[json-stream] = require(./json-stream);
},{./base:17,./doc:18,./dot:19,./html:20,./json:23,./json-stream:22,./landing:24,./list:25,./markdown:26,./min:27,./nyan:28,./progress:29,./spec:30,./tap:31,./xunit:32}],22:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var JSON = require(json3);
/** * Expose `List`. */
exports = module.exports = List;
/** * Initialize a new `List` test reporter. * * @api public *    */function List (runner) {  Base.call(this, runner);
  var self = this;  var total = runner.total;
  runner.on(start, function () {    console.log(JSON.stringify([start, { total: total }]));  });
  runner.on(pass, function (test) {    console.log(JSON.stringify([pass, clean(test)]));  });
  runner.on(fail, function (test, err) {    test = clean(test);    test.err = err.message;    test.stack = err.stack || null;    console.log(JSON.stringify([fail, test]));  });
  runner.on(end, function () {    process.stdout.write(JSON.stringify([end, self.stats]));  });}
/** * Return a plain-object representation of `test` * free of cyclic properties etc. * * @api private *    *   */function clean (test) {  return {    title: test.title,    fullTitle: test.fullTitle(),    duration: test.duration,    currentRetry: test.currentRetry()  };}
}).call(this,require(_process))},{./base:17,_process:67,json3:54}],23:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);
/** * Expose `JSON`. */
exports = module.exports = JSONReporter;
/** * Initialize a new `JSON` reporter. * * @api public *    */function JSONReporter (runner) {  Base.call(this, runner);
  var self = this;  var tests = [];  var pending = [];  var failures = [];  var passes = [];
  runner.on(test end, function (test) {    tests.push(test);  });
  runner.on(pass, function (test) {    passes.push(test);  });
  runner.on(fail, function (test) {    failures.push(test);  });
  runner.on(pending, function (test) {    pending.push(test);  });
  runner.on(end, function () {    var obj = {      stats: self.stats,      tests: tests.map(clean),      pending: pending.map(clean),      failures: failures.map(clean),      passes: passes.map(clean)    };
    runner.testResults = obj;
    process.stdout.write(JSON.stringify(obj, null, 2));  });}
/** * Return a plain-object representation of `test` * free of cyclic properties etc. * * @api private *    *   */function clean (test) {  return {    title: test.title,    fullTitle: test.fullTitle(),    duration: test.duration,    currentRetry: test.currentRetry(),    err: errorJSON(test.err || {})  };}
/** * Transform `error` into a JSON object. * * @api private *    *   */function errorJSON (err) {  var res = {};  Object.getOwnPropertyNames(err).forEach(function (key) {    res[key] = err[key];  }, err);  return res;}
}).call(this,require(_process))},{./base:17,_process:67}],24:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var cursor = Base.cursor;var color = Base.color;
/** * Expose `Landing`. */
exports = module.exports = Landing;
/** * Airplane color. */
Base.colors.plane = 0;
/** * Airplane crash color. */
Base.colors[plane crash] = 31;
/** * Runway color. */
Base.colors.runway = 90;
/** * Initialize a new `Landing` reporter. * * @api public *    */function Landing (runner) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width * 0.75 | 0;  var total = runner.total;  var stream = process.stdout;  var plane = color(plane, ✈);  var crashed = -1;  var n = 0;
  function runway () {    var buf = Array(width).join(-);    return    + color(runway, buf);  }
  runner.on(start, function () {    stream.write(  );    cursor.hide();  });
  runner.on(test end, function (test) {     check if the plane crashed    var col = crashed === -1 ? width * ++n / total | 0 : crashed;
     show the crash    if (test.state === failed) {      plane = color(plane crash, ✈);      crashed = col;    }
     render landing strip    stream.write([ + (width + 1) + D[2A);    stream.write(runway());    stream.write(  );    stream.write(color(runway, Array(col).join(⋅)));    stream.write(plane);    stream.write(color(runway, Array(width - col).join(⋅) + ));    stream.write(runway());    stream.write([0m);  });
  runner.on(end, function () {    cursor.show();    console.log();    self.epilogue();  });}
/** * Inherit from `Base.prototype`. */inherits(Landing, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],25:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;var cursor = Base.cursor;
/** * Expose `List`. */
exports = module.exports = List;
/** * Initialize a new `List` test reporter. * * @api public *    */function List (runner) {  Base.call(this, runner);
  var self = this;  var n = 0;
  runner.on(start, function () {    console.log();  });
  runner.on(test, function (test) {    process.stdout.write(color(pass,      + test.fullTitle() + : ));  });
  runner.on(pending, function (test) {    var fmt = color(checkmark,   -) +      color(pending,  %s);    console.log(fmt, test.fullTitle());  });
  runner.on(pass, function (test) {    var fmt = color(checkmark,    + Base.symbols.ok) +      color(pass,  %s: ) +      color(test.speed, %dms);    cursor.CR();    console.log(fmt, test.fullTitle(), test.duration);  });
  runner.on(fail, function (test) {    cursor.CR();    console.log(color(fail,   %d) %s), ++n, test.fullTitle());  });
  runner.on(end, self.epilogue.bind(self));}
/** * Inherit from `Base.prototype`. */inherits(List, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],26:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var utils = require(../utils);
/** * Constants */
var SUITE_PREFIX = $;
/** * Expose `Markdown`. */
exports = module.exports = Markdown;
/** * Initialize a new `Markdown` reporter. * * @api public *    */function Markdown (runner) {  Base.call(this, runner);
  var level = 0;  var buf = ;
  function title (str) {    return Array(level).join(#) +   + str;  }
  function mapTOC (suite, obj) {    var ret = obj;    var key = SUITE_PREFIX + suite.title;
    obj = obj[key] = obj[key] || { suite: suite };    suite.suites.forEach(function (suite) {      mapTOC(suite, obj);    });
    return ret;  }
  function stringifyTOC (obj, level) {    ++level;    var buf = ;    var link;    for (var key in obj) {      if (key === suite) {        continue;      }      if (key !== SUITE_PREFIX) {        link =  - [ + key.substring(1) + ];        link += (# + utils.slug(obj[key].suite.fullTitle()) + );        buf += Array(level).join(  ) + link;      }      buf += stringifyTOC(obj[key], level);    }    return buf;  }
  function generateTOC (suite) {    var obj = mapTOC(suite, {});    return stringifyTOC(obj, 0);  }
  generateTOC(runner.suite);
  runner.on(suite, function (suite) {    ++level;    var slug = utils.slug(suite.fullTitle());    buf += <a name="" + slug + ""></a> + ;    buf += title(suite.title) + ;  });
  runner.on(suite end, function () {    --level;  });
  runner.on(pass, function (test) {    var code = utils.clean(test.body);    buf += test.title + .;    buf += ```js;    buf += code + ;    buf += ```;  });
  runner.on(end, function () {    process.stdout.write(# TOC);    process.stdout.write(generateTOC(runner.suite));    process.stdout.write(buf);  });}
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],27:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;
/** * Expose `Min`. */
exports = module.exports = Min;
/** * Initialize a new `Min` minimal test reporter (best used with --watch). * * @api public *    */function Min (runner) {  Base.call(this, runner);
  runner.on(start, function () {     clear screen    process.stdout.write([2J);     set cursor position    process.stdout.write([1;3H);  });
  runner.on(end, this.epilogue.bind(this));}
/** * Inherit from `Base.prototype`. */inherits(Min, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],28:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;
/** * Expose `Dot`. */
exports = module.exports = NyanCat;
/** * Initialize a new `Dot` matrix test reporter. * *    * @api public */
function NyanCat (runner) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width * 0.75 | 0;  var nyanCatWidth = this.nyanCatWidth = 11;
  this.colorIndex = 0;  this.numberOfLines = 4;  this.rainbowColors = self.generateColors();  this.scoreboardWidth = 5;  this.tick = 0;  this.trajectories = [[], [], [], []];  this.trajectoryWidthMax = (width - nyanCatWidth);
  runner.on(start, function () {    Base.cursor.hide();    self.draw();  });
  runner.on(pending, function () {    self.draw();  });
  runner.on(pass, function () {    self.draw();  });
  runner.on(fail, function () {    self.draw();  });
  runner.on(end, function () {    Base.cursor.show();    for (var i = 0; i < self.numberOfLines; i++) {      write();    }    self.epilogue();  });}
/** * Inherit from `Base.prototype`. */inherits(NyanCat, Base);
/** * Draw the nyan cat * * @api private */
NyanCat.prototype.draw = function () {  this.appendRainbow();  this.drawScoreboard();  this.drawRainbow();  this.drawNyanCat();  this.tick = !this.tick;};
/** * Draw the ""scoreboard"" showing the number * of passes, failures and pending tests. * * @api private */
NyanCat.prototype.drawScoreboard = function () {  var stats = this.stats;
  function draw (type, n) {    write( );    write(Base.color(type, n));    write();  }
  draw(green, stats.passes);  draw(fail, stats.failures);  draw(pending, stats.pending);  write();
  this.cursorUp(this.numberOfLines);};
/** * Append the rainbow. * * @api private */
NyanCat.prototype.appendRainbow = function () {  var segment = this.tick ? _ : -;  var rainbowified = this.rainbowify(segment);
  for (var index = 0; index < this.numberOfLines; index++) {    var trajectory = this.trajectories[index];    if (trajectory.length >= this.trajectoryWidthMax) {      trajectory.shift();    }    trajectory.push(rainbowified);  }};
/** * Draw the rainbow. * * @api private */
NyanCat.prototype.drawRainbow = function () {  var self = this;
  this.trajectories.forEach(function (line) {    write([ + self.scoreboardWidth + C);    write(line.join());    write();  });
  this.cursorUp(this.numberOfLines);};
/** * Draw the nyan cat * * @api private */NyanCat.prototype.drawNyanCat = function () {  var self = this;  var startWidth = this.scoreboardWidth + this.trajectories[0].length;  var dist = [ + startWidth + C;  var padding = ;
  write(dist);  write(_,------,);  write();
  write(dist);  padding = self.tick ?    :    ;  write(_| + padding + /_/ );  write();
  write(dist);  padding = self.tick ? _ : __;  var tail = self.tick ? ~ : ^;  write(tail + | + padding + this.face() +  );  write();
  write(dist);  padding = self.tick ?   :   ;  write(padding + """"  """" );  write();
  this.cursorUp(this.numberOfLines);};
/** * Draw nyan cat face. * * @api private *   */
NyanCat.prototype.face = function () {  var stats = this.stats;  if (stats.failures) {    return ( x .x);  } else if (stats.pending) {    return ( o .o);  } else if (stats.passes) {    return ( ^ .^);  }  return ( - .-);};
/** * Move cursor up `n`. * * @api private *    */
NyanCat.prototype.cursorUp = function (n) {  write([ + n + A);};
/** * Move cursor down `n`. * * @api private *    */
NyanCat.prototype.cursorDown = function (n) {  write([ + n + B);};
/** * Generate rainbow colors. * * @api private *   */NyanCat.prototype.generateColors = function () {  var colors = [];
  for (var i = 0; i < (6 * 7); i++) {    var pi3 = Math.floor(Math.PI / 3);    var n = (i * (1.0 / 6));    var r = Math.floor(3 * Math.sin(n) + 3);    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);    colors.push(36 * r + 6 * g + b + 16);  }
  return colors;};
/** * Apply rainbow to the given `str`. * * @api private *    *   */NyanCat.prototype.rainbowify = function (str) {  if (!Base.useColors) {    return str;  }  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];  this.colorIndex += 1;  return [38;5; + color + m + str + [0m;};
/** * Stdout helper. * *    A message to write to stdout. */function write (string) {  process.stdout.write(string);}
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],29:[function(require,module,exports){(function (process){use strict;
/** * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;var cursor = Base.cursor;
/** * Expose `Progress`. */
exports = module.exports = Progress;
/** * General progress bar color. */
Base.colors.progress = 90;
/** * Initialize a new `Progress` bar test reporter. * * @api public *    *    */function Progress (runner, options) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width * 0.50 | 0;  var total = runner.total;  var complete = 0;  var lastN = -1;
   default chars  options = options || {};  options.open = options.open || [;  options.complete = options.complete || ▬;  options.incomplete = options.incomplete || Base.symbols.dot;  options.close = options.close || ];  options.verbose = false;
   tests started  runner.on(start, function () {    console.log();    cursor.hide();  });
   tests complete  runner.on(test end, function () {    complete++;
    var percent = complete / total;    var n = width * percent | 0;    var i = width - n;
    if (n === lastN && !options.verbose) {       Don't re-render the line if it hasn't changed      return;    }    lastN = n;
    cursor.CR();    process.stdout.write([J);    process.stdout.write(color(progress,    + options.open));    process.stdout.write(Array(n).join(options.complete));    process.stdout.write(Array(i).join(options.incomplete));    process.stdout.write(color(progress, options.close));    if (options.verbose) {      process.stdout.write(color(progress,   + complete +  of  + total));    }  });
   tests are complete, output some stats   and the failures if any  runner.on(end, function () {    cursor.show();    console.log();    self.epilogue();  });}
/** * Inherit from `Base.prototype`. */inherits(Progress, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],30:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;
/** * Expose `Spec`. */
exports = module.exports = Spec;
/** * Initialize a new `Spec` test reporter. * * @api public *    */function Spec (runner) {  Base.call(this, runner);
  var self = this;  var indents = 0;  var n = 0;
  function indent () {    return Array(indents).join(  );  }
  runner.on(start, function () {    console.log();  });
  runner.on(suite, function (suite) {    ++indents;    console.log(color(suite, %s%s), indent(), suite.title);  });
  runner.on(suite end, function () {    --indents;    if (indents === 1) {      console.log();    }  });
  runner.on(pending, function (test) {    var fmt = indent() + color(pending,   - %s);    console.log(fmt, test.title);  });
  runner.on(pass, function (test) {    var fmt;    if (test.speed === fast) {      fmt = indent() +        color(checkmark,    + Base.symbols.ok) +        color(pass,  %s);      console.log(fmt, test.title);    } else {      fmt = indent() +        color(checkmark,    + Base.symbols.ok) +        color(pass,  %s) +        color(test.speed,  (%dms));      console.log(fmt, test.title, test.duration);    }  });
  runner.on(fail, function (test) {    console.log(indent() + color(fail,   %d) %s), ++n, test.title);  });
  runner.on(end, self.epilogue.bind(self));}
/** * Inherit from `Base.prototype`. */inherits(Spec, Base);
},{../utils:38,./base:17}],31:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Base = require(./base);
/** * Expose `TAP`. */
exports = module.exports = TAP;
/** * Initialize a new `TAP` reporter. * * @api public *    */function TAP (runner) {  Base.call(this, runner);
  var n = 1;  var passes = 0;  var failures = 0;
  runner.on(start, function () {    var total = runner.grepTotal(runner.suite);    console.log(%d..%d, 1, total);  });
  runner.on(test end, function () {    ++n;  });
  runner.on(pending, function (test) {    console.log(ok %d %s # SKIP -, n, title(test));  });
  runner.on(pass, function (test) {    passes++;    console.log(ok %d %s, n, title(test));  });
  runner.on(fail, function (test, err) {    failures++;    console.log(not ok %d %s, n, title(test));    if (err.stack) {      console.log(err.stack.replace(gm,   ));    }  });
  runner.on(end, function () {    console.log(# tests  + (passes + failures));    console.log(# pass  + passes);    console.log(# fail  + failures);  });}
/** * Return a TAP-safe title of `test` * * @api private *    *   */function title (test) {  return test.fullTitle().replace(#g, );}
},{./base:17}],32:[function(require,module,exports){(function (process,global){use strict;
/** * Module dependencies. */
var Base = require(./base);var utils = require(../utils);var inherits = utils.inherits;var fs = require(fs);var escape = utils.escape;var mkdirp = require(mkdirp);var path = require(path);
/** * Save timer references to avoid Sinon interfering (see GH-237). */
/* eslint-disable no-unused-vars, no-native-reassign */var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;/* eslint-enable no-unused-vars, no-native-reassign */
/** * Expose `XUnit`. */
exports = module.exports = XUnit;
/** * Initialize a new `XUnit` reporter. * * @api public *    */function XUnit (runner, options) {  Base.call(this, runner);
  var stats = this.stats;  var tests = [];  var self = this;
  if (options && options.reporterOptions && options.reporterOptions.output) {    if (!fs.createWriteStream) {      throw new Error(file output not supported in browser);    }    mkdirp.sync(path.dirname(options.reporterOptions.output));    self.fileStream = fs.createWriteStream(options.reporterOptions.output);  }
  runner.on(pending, function (test) {    tests.push(test);  });
  runner.on(pass, function (test) {    tests.push(test);  });
  runner.on(fail, function (test) {    tests.push(test);  });
  runner.on(end, function () {    self.write(tag(testsuite, {      name: Mocha Tests,      tests: stats.tests,      failures: stats.failures,      errors: stats.failures,      skipped: stats.tests - stats.failures - stats.passes,      timestamp: (new Date()).toUTCString(),      time: (stats.duration / 1000) || 0    }, false));
    tests.forEach(function (t) {      self.test(t);    });
    self.write(</testsuite>);  });}
/** * Inherit from `Base.prototype`. */inherits(XUnit, Base);
/** * Override done to close the stream (if it's a file). * *   *    */XUnit.prototype.done = function (failures, fn) {  if (this.fileStream) {    this.fileStream.end(function () {      fn(failures);    });  } else {    fn(failures);  }};
/** * Write out the given line. * *    */XUnit.prototype.write = function (line) {  if (this.fileStream) {    this.fileStream.write(line + );  } else if (typeof process === object && process.stdout) {    process.stdout.write(line + );  } else {    console.log(line);  }};
/** * Output tag for the given `test.` * *    */XUnit.prototype.test = function (test) {  var attrs = {    classname: test.parent.fullTitle(),    name: test.title,    time: (test.duration / 1000) || 0  };
  if (test.state === failed) {    var err = test.err;    this.write(tag(testcase, attrs, false, tag(failure, {}, false, escape(err.message) +  + escape(err.stack))));  } else if (test.isPending()) {    this.write(tag(testcase, attrs, false, tag(skipped, {}, true)));  } else {    this.write(tag(testcase, attrs, true));  }};
/** * HTML tag helper. * *   *   *   *   *   */function tag (name, attrs, close, content) {  var end = close ? /> : >;  var pairs = [];  var tag;
  for (var key in attrs) {    if (Object.prototype.hasOwnProperty.call(attrs, key)) {      pairs.push(key + ="" + escape(attrs[key]) + "");    }  }
  tag = < + name + (pairs.length ?   + pairs.join( ) : ) + end;  if (content) {    tag += content + </ + name + end;  }  return tag;}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{../utils:38,./base:17,_process:67,fs:42,mkdirp:64,path:42}],33:[function(require,module,exports){(function (global){use strict;
/** * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var JSON = require(json3);var Pending = require(./pending);var debug = require(debug)(mocha:runnable);var milliseconds = require(./ms);var utils = require(./utils);var create = require(lodash.create);
/** * Save timer references to avoid Sinon interfering (see GH-237). */
/* eslint-disable no-unused-vars, no-native-reassign */var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;/* eslint-enable no-unused-vars, no-native-reassign */
/** * Object#toString(). */
var toString = Object.prototype.toString;
/** * Expose `Runnable`. */
module.exports = Runnable;
/** * Initialize a new `Runnable` with the given `title` and callback `fn`. * *    *    * @api private *    *    */function Runnable (title, fn) {  this.title = title;  this.fn = fn;  this.body = (fn || ).toString();  this.async = fn && fn.length;  this.sync = !this.async;  this._timeout = 2000;  this._slow = 75;  this._enableTimeouts = true;  this.timedOut = false;  this._trace = new Error(done() called multiple times);  this._retries = -1;  this._currentRetry = 0;  this.pending = false;}
/** * Inherit from `EventEmitter.prototype`. */Runnable.prototype = create(EventEmitter.prototype, {  constructor: Runnable});
/** * Set & get timeout `ms`. * * @api private *    *   ms or Runnable instance. */Runnable.prototype.timeout = function (ms) {  if (!arguments.length) {    return this._timeout;  }   see #1652 for reasoning  if (ms === 0 || ms > Math.pow(2, 31)) {    this._enableTimeouts = false;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(timeout %d, ms);  this._timeout = ms;  if (this.timer) {    this.resetTimeout();  }  return this;};
/** * Set & get slow `ms`. * * @api private *    *   ms or Runnable instance. */Runnable.prototype.slow = function (ms) {  if (typeof ms === undefined) {    return this._slow;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(timeout %d, ms);  this._slow = ms;  return this;};
/** * Set and get whether timeout is `enabled`. * * @api private *    *   enabled or Runnable instance. */Runnable.prototype.enableTimeouts = function (enabled) {  if (!arguments.length) {    return this._enableTimeouts;  }  debug(enableTimeouts %s, enabled);  this._enableTimeouts = enabled;  return this;};
/** * Halt and mark as pending. * * @api public */Runnable.prototype.skip = function () {  throw new Pending(sync skip);};
/** * Check if this runnable or its parent suite is marked as pending. * * @api private */Runnable.prototype.isPending = function () {  return this.pending || (this.parent && this.parent.isPending());};
/** * Set number of retries. * * @api private */Runnable.prototype.retries = function (n) {  if (!arguments.length) {    return this._retries;  }  this._retries = n;};
/** * Get current retry * * @api private */Runnable.prototype.currentRetry = function (n) {  if (!arguments.length) {    return this._currentRetry;  }  this._currentRetry = n;};
/** * Return the full title generated by recursively concatenating the parent's * full title. * * @api public *   */Runnable.prototype.fullTitle = function () {  return this.parent.fullTitle() +   + this.title;};
/** * Clear the timeout. * * @api private */Runnable.prototype.clearTimeout = function () {  clearTimeout(this.timer);};
/** * Inspect the runnable void of private properties. * * @api private *   */Runnable.prototype.inspect = function () {  return JSON.stringify(this, function (key, val) {    if (key[0] === _) {      return;    }    if (key === parent) {      return #<Suite>;    }    if (key === ctx) {      return #<Context>;    }    return val;  }, 2);};
/** * Reset the timeout. * * @api private */Runnable.prototype.resetTimeout = function () {  var self = this;  var ms = this.timeout() || 1e9;
  if (!this._enableTimeouts) {    return;  }  this.clearTimeout();  this.timer = setTimeout(function () {    if (!self._enableTimeouts) {      return;    }    self.callback(new Error(Timeout of  + ms +      ms exceeded. For async tests and hooks, ensure ""done()"" is called; if returning a Promise, ensure it resolves.));    self.timedOut = true;  }, ms);};
/** * Whitelist a list of globals for this test run. * * @api private *    */Runnable.prototype.globals = function (globals) {  if (!arguments.length) {    return this._allowedGlobals;  }  this._allowedGlobals = globals;};
/** * Run the test and invoke `fn(err)`. * *    * @api private */Runnable.prototype.run = function (fn) {  var self = this;  var start = new Date();  var ctx = this.ctx;  var finished;  var emitted;
   Sometimes the ctx exists, but it is not runnable  if (ctx && ctx.runnable) {    ctx.runnable(this);  }
   called multiple times  function multiple (err) {    if (emitted) {      return;    }    emitted = true;    self.emit(error, err || new Error(done() called multiple times; stacktrace may be inaccurate));  }
   finished  function done (err) {    var ms = self.timeout();    if (self.timedOut) {      return;    }    if (finished) {      return multiple(err || self._trace);    }
    self.clearTimeout();    self.duration = new Date() - start;    finished = true;    if (!err && self.duration > ms && self._enableTimeouts) {      err = new Error(Timeout of  + ms +      ms exceeded. For async tests and hooks, ensure ""done()"" is called; if returning a Promise, ensure it resolves.);    }    fn(err);  }
   for .resetTimeout()  this.callback = done;
   explicit async with `done` argument  if (this.async) {    this.resetTimeout();
     allows skip() to be used in an explicit async context    this.skip = function asyncSkip () {      done(new Pending(async skip call));       halt execution.  the Runnable will be marked pending       by the previous call, and the uncaught handler will ignore       the failure.      throw new Pending(async skip; aborting execution);    };
    if (this.allowUncaught) {      return callFnAsync(this.fn);    }    try {      callFnAsync(this.fn);    } catch (err) {      emitted = true;      done(utils.getError(err));    }    return;  }
  if (this.allowUncaught) {    callFn(this.fn);    done();    return;  }
   sync or promise-returning  try {    if (this.isPending()) {      done();    } else {      callFn(this.fn);    }  } catch (err) {    emitted = true;    done(utils.getError(err));  }
  function callFn (fn) {    var result = fn.call(ctx);    if (result && typeof result.then === function) {      self.resetTimeout();      result        .then(function () {          done();           Return null so libraries like bluebird do not warn about           subsequently constructed Promises.          return null;        },        function (reason) {          done(reason || new Error(Promise rejected with no or falsy reason));        });    } else {      if (self.asyncOnly) {        return done(new Error(--async-only option in use without declaring `done()` or returning a promise));      }
      done();    }  }
  function callFnAsync (fn) {    var result = fn.call(ctx, function (err) {      if (err instanceof Error || toString.call(err) === [object Error]) {        return done(err);      }      if (err) {        if (Object.prototype.toString.call(err) === [object Object]) {          return done(new Error(done() invoked with non-Error:  +            JSON.stringify(err)));        }        return done(new Error(done() invoked with non-Error:  + err));      }      if (result && utils.isPromise(result)) {        return done(new Error(Resolution method is overspecified. Specify a callback *or* return a Promise; not both.));      }
      done();    });  }};
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./ms:15,./pending:16,./utils:38,debug:2,events:3,json3:54,lodash.create:60}],34:[function(require,module,exports){(function (process,global){use strict;
/** * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var Pending = require(./pending);var utils = require(./utils);var inherits = utils.inherits;var debug = require(debug)(mocha:runner);var Runnable = require(./runnable);var filter = utils.filter;var indexOf = utils.indexOf;var some = utils.some;var keys = utils.keys;var stackFilter = utils.stackTraceFilter();var stringify = utils.stringify;var type = utils.type;var undefinedError = utils.undefinedError;var isArray = utils.isArray;
/** * Non-enumerable globals. */
var globals = [  setTimeout,  clearTimeout,  setInterval,  clearInterval,  XMLHttpRequest,  Date,  setImmediate,  clearImmediate];
/** * Expose `Runner`. */
module.exports = Runner;
/** * Initialize a `Runner` for the given `suite`. * * Events: * *   - `start`  execution started *   - `end`  execution complete *   - `suite`  (suite) test suite execution started *   - `suite end`  (suite) all tests (and sub-suites) have finished *   - `test`  (test) test execution started *   - `test end`  (test) test completed *   - `hook`  (hook) hook execution started *   - `hook end`  (hook) hook complete *   - `pass`  (test) test passed *   - `fail`  (test, err) test failed *   - `pending`  (test) test pending * * @api public *    Root suite *    Whether or not to delay execution of root suite * until ready. */function Runner (suite, delay) {  var self = this;  this._globals = [];  this._abort = false;  this._delay = delay;  this.suite = suite;  this.started = false;  this.total = suite.total();  this.failures = 0;  this.on(test end, function (test) {    self.checkGlobals(test);  });  this.on(hook end, function (hook) {    self.checkGlobals(hook);  });  this._defaultGrep = ;  this.grep(this._defaultGrep);  this.globals(this.globalProps().concat(extraGlobals()));}
/** * Wrapper for setImmediate, process.nextTick, or browser polyfill. * *    * @api private */Runner.immediately = global.setImmediate || process.nextTick;
/** * Inherit from `EventEmitter.prototype`. */inherits(Runner, EventEmitter);
/** * Run tests with full titles matching `re`. Updates runner.total * with number of tests matched. * *    *    *   for chaining * @api public *    *    *   Runner instance. */Runner.prototype.grep = function (re, invert) {  debug(grep %s, re);  this._grep = re;  this._invert = invert;  this.total = this.grepTotal(this.suite);  return this;};
/** * Returns the number of tests matching the grep search for the * given suite. * *    *   * @api public *    *   */Runner.prototype.grepTotal = function (suite) {  var self = this;  var total = 0;
  suite.eachTest(function (test) {    var match = self._grep.test(test.fullTitle());    if (self._invert) {      match = !match;    }    if (match) {      total++;    }  });
  return total;};
/** * Return a list of global properties. * *   * @api private */Runner.prototype.globalProps = function () {  var props = keys(global);
   non-enumerables  for (var i = 0; i < globals.length; ++i) {    if (~indexOf(props, globals[i])) {      continue;    }    props.push(globals[i]);  }
  return props;};
/** * Allow the given `arr` of globals. * *    *   for chaining * @api public *    *   Runner instance. */Runner.prototype.globals = function (arr) {  if (!arguments.length) {    return this._globals;  }  debug(globals %j, arr);  this._globals = this._globals.concat(arr);  return this;};
/** * Check for global variable leaks. * * @api private */Runner.prototype.checkGlobals = function (test) {  if (this.ignoreLeaks) {    return;  }  var ok = this._globals;
  var globals = this.globalProps();  var leaks;
  if (test) {    ok = ok.concat(test._allowedGlobals || []);  }
  if (this.prevGlobalsLength === globals.length) {    return;  }  this.prevGlobalsLength = globals.length;
  leaks = filterLeaks(ok, globals);  this._globals = this._globals.concat(leaks);
  if (leaks.length > 1) {    this.fail(test, new Error(global leaks detected:  + leaks.join(, ) + ));  } else if (leaks.length) {    this.fail(test, new Error(global leak detected:  + leaks[0]));  }};
/** * Fail the given `test`. * * @api private *    *    */Runner.prototype.fail = function (test, err) {  if (test.isPending()) {    return;  }
  ++this.failures;  test.state = failed;
  if (!(err instanceof Error || err && typeof err.message === string)) {    err = new Error(the  + type(err) +   + stringify(err) +  was thrown, throw an Error :));  }
  try {    err.stack = (this.fullStackTrace || !err.stack)      ? err.stack      : stackFilter(err.stack);  } catch (ignored) {     some environments do not take kindly to monkeying with the stack  }
  this.emit(fail, test, err);};
/** * Fail the given `hook` with `err`. * * Hook failures work in the following pattern: * - If bail, then exit * - Failed `before` hook skips all tests in a suite and subsuites, *   but jumps to corresponding `after` hook * - Failed `before each` hook skips remaining tests in a *   suite and jumps to corresponding `after each` hook, *   which is run only once * - Failed `after` hook does not alter *   execution order * - Failed `after each` hook skips remaining tests in a *   suite and subsuites, but executes other `after each` *   hooks * * @api private *    *    */Runner.prototype.failHook = function (hook, err) {  if (hook.ctx && hook.ctx.currentTest) {    hook.originalTitle = hook.originalTitle || hook.title;    hook.title = hook.originalTitle +  for "" + hook.ctx.currentTest.title + "";  }
  this.fail(hook, err);  if (this.suite.bail()) {    this.emit(end);  }};
/** * Run hook `name` callbacks and then invoke `fn()`. * * @api private *    *    */
Runner.prototype.hook = function (name, fn) {  var suite = this.suite;  var hooks = suite[_ + name];  var self = this;
  function next (i) {    var hook = hooks[i];    if (!hook) {      return fn();    }    self.currentRunnable = hook;
    hook.ctx.currentTest = self.test;
    self.emit(hook, hook);
    if (!hook.listeners(error).length) {      hook.on(error, function (err) {        self.failHook(hook, err);      });    }
    hook.run(function (err) {      var testError = hook.error();      if (testError) {        self.fail(self.test, testError);      }      if (err) {        if (err instanceof Pending) {          if (name === beforeEach || name === afterEach) {            self.test.pending = true;          } else {            utils.forEach(suite.tests, function (test) {              test.pending = true;            });             a pending hook won't be executed twice.            hook.pending = true;          }        } else {          self.failHook(hook, err);
           stop executing hooks, notify callee of hook err          return fn(err);        }      }      self.emit(hook end, hook);      delete hook.ctx.currentTest;      next(++i);    });  }
  Runner.immediately(function () {    next(0);  });};
/** * Run hook `name` for the given array of `suites` * in order, and callback `fn(err, errSuite)`. * * @api private *    *    *    */Runner.prototype.hooks = function (name, suites, fn) {  var self = this;  var orig = this.suite;
  function next (suite) {    self.suite = suite;
    if (!suite) {      self.suite = orig;      return fn();    }
    self.hook(name, function (err) {      if (err) {        var errSuite = self.suite;        self.suite = orig;        return fn(err, errSuite);      }
      next(suites.pop());    });  }
  next(suites.pop());};
/** * Run hooks from the top level down. * *    *    * @api private */Runner.prototype.hookUp = function (name, fn) {  var suites = [this.suite].concat(this.parents()).reverse();  this.hooks(name, suites, fn);};
/** * Run hooks from the bottom up. * *    *    * @api private */Runner.prototype.hookDown = function (name, fn) {  var suites = [this.suite].concat(this.parents());  this.hooks(name, suites, fn);};
/** * Return an array of parent Suites from * closest to furthest. * *   * @api private */Runner.prototype.parents = function () {  var suite = this.suite;  var suites = [];  while (suite.parent) {    suite = suite.parent;    suites.push(suite);  }  return suites;};
/** * Run the current test and callback `fn(err)`. * *    * @api private */Runner.prototype.runTest = function (fn) {  var self = this;  var test = this.test;
  if (!test) {    return;  }  if (this.asyncOnly) {    test.asyncOnly = true;  }
  if (this.allowUncaught) {    test.allowUncaught = true;    return test.run(fn);  }  try {    test.on(error, function (err) {      self.fail(test, err);    });    test.run(fn);  } catch (err) {    fn(err);  }};
/** * Run tests in the given `suite` and invoke the callback `fn()` when complete. * * @api private *    *    */Runner.prototype.runTests = function (suite, fn) {  var self = this;  var tests = suite.tests.slice();  var test;
  function hookErr (_, errSuite, after) {     before/after Each hook for errSuite failed:    var orig = self.suite;
     for failed 'after each' hook start from errSuite parent,     otherwise start from errSuite itself    self.suite = after ? errSuite.parent : errSuite;
    if (self.suite) {       call hookUp afterEach      self.hookUp(afterEach, function (err2, errSuite2) {        self.suite = orig;         some hooks may fail even now        if (err2) {          return hookErr(err2, errSuite2, true);        }         report error suite        fn(errSuite);      });    } else {       there is no need calling other 'after each' hooks      self.suite = orig;      fn(errSuite);    }  }
  function next (err, errSuite) {     if we bail after first err    if (self.failures && suite._bail) {      return fn();    }
    if (self._abort) {      return fn();    }
    if (err) {      return hookErr(err, errSuite, true);    }
     next test    test = tests.shift();
     all done    if (!test) {      return fn();    }
     grep    var match = self._grep.test(test.fullTitle());    if (self._invert) {      match = !match;    }    if (!match) {       Run immediately only if we have defined a grep. When we       define a grep — It can cause maximum callstack error if       the grep is doing a large recursive loop by neglecting       all tests. The run immediately function also comes with       a performance cost. So we don't want to run immediately       if we run the whole test suite, because running the whole       test suite don't do any immediate recursive loops. Thus,       allowing a JS runtime to breathe.      if (self._grep !== self._defaultGrep) {        Runner.immediately(next);      } else {        next();      }      return;    }
    if (test.isPending()) {      self.emit(pending, test);      self.emit(test end, test);      return next();    }
     execute test and hook(s)    self.emit(test, self.test = test);    self.hookDown(beforeEach, function (err, errSuite) {      if (test.isPending()) {        self.emit(pending, test);        self.emit(test end, test);        return next();      }      if (err) {        return hookErr(err, errSuite, false);      }      self.currentRunnable = self.test;      self.runTest(function (err) {        test = self.test;        if (err) {          var retry = test.currentRetry();          if (err instanceof Pending) {            test.pending = true;            self.emit(pending, test);          } else if (retry < test.retries()) {            var clonedTest = test.clone();            clonedTest.currentRetry(retry + 1);            tests.unshift(clonedTest);
             Early return + hook trigger so that it doesn't             increment the count wrong            return self.hookUp(afterEach, next);          } else {            self.fail(test, err);          }          self.emit(test end, test);
          if (err instanceof Pending) {            return next();          }
          return self.hookUp(afterEach, next);        }
        test.state = passed;        self.emit(pass, test);        self.emit(test end, test);        self.hookUp(afterEach, next);      });    });  }
  this.next = next;  this.hookErr = hookErr;  next();};
/** * Run the given `suite` and invoke the callback `fn()` when complete. * * @api private *    *    */Runner.prototype.runSuite = function (suite, fn) {  var i = 0;  var self = this;  var total = this.grepTotal(suite);  var afterAllHookCalled = false;
  debug(run suite %s, suite.fullTitle());
  if (!total || (self.failures && suite._bail)) {    return fn();  }
  this.emit(suite, this.suite = suite);
  function next (errSuite) {    if (errSuite) {       current suite failed on a hook from errSuite      if (errSuite === suite) {         if errSuite is current suite         continue to the next sibling suite        return done();      }       errSuite is among the parents of current suite       stop execution of errSuite and all sub-suites      return done(errSuite);    }
    if (self._abort) {      return done();    }
    var curr = suite.suites[i++];    if (!curr) {      return done();    }
     Avoid grep neglecting large number of tests causing a     huge recursive loop and thus a maximum call stack error.     See comment in `this.runTests()` for more information.    if (self._grep !== self._defaultGrep) {      Runner.immediately(function () {        self.runSuite(curr, next);      });    } else {      self.runSuite(curr, next);    }  }
  function done (errSuite) {    self.suite = suite;    self.nextSuite = next;
    if (afterAllHookCalled) {      fn(errSuite);    } else {       mark that the afterAll block has been called once       and so can be skipped if there is an error in it.      afterAllHookCalled = true;
       remove reference to test      delete self.test;
      self.hook(afterAll, function () {        self.emit(suite end, suite);        fn(errSuite);      });    }  }
  this.nextSuite = next;
  this.hook(beforeAll, function (err) {    if (err) {      return done();    }    self.runTests(suite, next);  });};
/** * Handle uncaught exceptions. * *    * @api private */Runner.prototype.uncaught = function (err) {  if (err) {    debug(uncaught exception %s, err !== function () {      return this;    }.call(err) ? err : (err.message || err));  } else {    debug(uncaught undefined exception);    err = undefinedError();  }  err.uncaught = true;
  var runnable = this.currentRunnable;
  if (!runnable) {    runnable = new Runnable(Uncaught error outside test suite);    runnable.parent = this.suite;
    if (this.started) {      this.fail(runnable, err);    } else {       Can't recover from this failure      this.emit(start);      this.fail(runnable, err);      this.emit(end);    }
    return;  }
  runnable.clearTimeout();
   Ignore errors if complete or pending  if (runnable.state || runnable.isPending()) {    return;  }  this.fail(runnable, err);
   recover from test  if (runnable.type === test) {    this.emit(test end, runnable);    this.hookUp(afterEach, this.next);    return;  }
  recover from hooks  if (runnable.type === hook) {    var errSuite = this.suite;     if hook failure is in afterEach block    if (runnable.fullTitle().indexOf(after each) > -1) {      return this.hookErr(err, errSuite, true);    }     if hook failure is in beforeEach block    if (runnable.fullTitle().indexOf(before each) > -1) {      return this.hookErr(err, errSuite, false);    }     if hook failure is in after or before blocks    return this.nextSuite(errSuite);  }
   bail  this.emit(end);};
/** * Cleans up the references to all the deferred functions * (before/after/beforeEach/afterEach) and tests of a Suite. * These must be deleted otherwise a memory leak can happen, * as those functions may reference variables from closures, * thus those variables can never be garbage collected as long * as the deferred functions exist. * *    */function cleanSuiteReferences (suite) {  function cleanArrReferences (arr) {    for (var i = 0; i < arr.length; i++) {      delete arr[i].fn;    }  }
  if (isArray(suite._beforeAll)) {    cleanArrReferences(suite._beforeAll);  }
  if (isArray(suite._beforeEach)) {    cleanArrReferences(suite._beforeEach);  }
  if (isArray(suite._afterAll)) {    cleanArrReferences(suite._afterAll);  }
  if (isArray(suite._afterEach)) {    cleanArrReferences(suite._afterEach);  }
  for (var i = 0; i < suite.tests.length; i++) {    delete suite.tests[i].fn;  }}
/** * Run the root suite and invoke `fn(failures)` * on completion. * *    *   for chaining * @api public *    *   Runner instance. */Runner.prototype.run = function (fn) {  var self = this;  var rootSuite = this.suite;
   If there is an `only` filter  if (this.hasOnly) {    filterOnly(rootSuite);  }
  fn = fn || function () {};
  function uncaught (err) {    self.uncaught(err);  }
  function start () {    self.started = true;    self.emit(start);    self.runSuite(rootSuite, function () {      debug(finished running);      self.emit(end);    });  }
  debug(start);
   references cleanup to avoid memory leaks  this.on(suite end, cleanSuiteReferences);
   callback  this.on(end, function () {    debug(end);    process.removeListener(uncaughtException, uncaught);    fn(self.failures);  });
   uncaught exception  process.on(uncaughtException, uncaught);
  if (this._delay) {     for reporters, I guess.     might be nice to debounce some dots while we wait.    this.emit(waiting, rootSuite);    rootSuite.once(run, start);  } else {    start();  }
  return this;};
/** * Cleanly abort execution. * * @api public *   Runner instance. */Runner.prototype.abort = function () {  debug(aborting);  this._abort = true;
  return this;};
/** * Filter suites based on `isOnly` logic. * *    *   * @api private */function filterOnly (suite) {  if (suite._onlyTests.length) {     If the suite contains `only` tests, run those and ignore any nested suites.    suite.tests = suite._onlyTests;    suite.suites = [];  } else {     Otherwise, do not run any of the tests in this suite.    suite.tests = [];    utils.forEach(suite._onlySuites, function (onlySuite) {       If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.       Otherwise, all of the tests on this `only` suite should be run, so don't filter it.      if (hasOnly(onlySuite)) {        filterOnly(onlySuite);      }    });     Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.    suite.suites = filter(suite.suites, function (childSuite) {      return indexOf(suite._onlySuites, childSuite) !== -1 || filterOnly(childSuite);    });  }   Keep the suite only if there is something to run  return suite.tests.length || suite.suites.length;}
/** * Determines whether a suite has an `only` test or suite as a descendant. * *    *   * @api private */function hasOnly (suite) {  return suite._onlyTests.length || suite._onlySuites.length || some(suite.suites, hasOnly);}
/** * Filter leaks with the given globals flagged as `ok`. * * @api private *    *    *   */function filterLeaks (ok, globals) {  return filter(globals, function (key) {     Firefox and Chrome exposes iframes as index inside the window object    if (.test(key)) {      return false;    }
     in firefox     if runner runs in an iframe, this iframe's window.getInterface method     not init at first it is assigned in some seconds    if (global.navigator && (getInterface).test(key)) {      return false;    }
     an iframe could be approached by window[iframeIndex]     in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak    if (global.navigator && ().test(key)) {      return false;    }
     Opera and IE expose global variables for HTML element IDs (issue #243)    if (mocha-.test(key)) {      return false;    }
    var matched = filter(ok, function (ok) {      if (~ok.indexOf(*)) {        return key.indexOf(ok.split(*)[0]) === 0;      }      return key === ok;    });    return !matched.length && (!global.navigator || key !== onerror);  });}
/** * Array of globals dependent on the environment. * *   * @api private */function extraGlobals () {  if (typeof process === object && typeof process.version === string) {    var parts = process.version.split(.);    var nodeVersion = utils.reduce(parts, function (a, v) {      return a << 8 | v;    });
     'errno' was renamed to process._errno in v0.9.11.
    if (nodeVersion < 0x00090B) {      return [errno];    }  }
  return [];}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./pending:16,./runnable:33,./utils:38,_process:67,debug:2,events:3}],35:[function(require,module,exports){use strict;
/** * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var Hook = require(./hook);var utils = require(./utils);var inherits = utils.inherits;var debug = require(debug)(mocha:suite);var milliseconds = require(./ms);
/** * Expose `Suite`. */
exports = module.exports = Suite;
/** * Create a new `Suite` with the given `title` and parent `Suite`. When a suite * with the same title is already present, that suite is returned to provide * nicer reporter and more flexible meta-testing. * * @api public *    *    *   */exports.create = function (parent, title) {  var suite = new Suite(title, parent.ctx);  suite.parent = parent;  title = suite.fullTitle();  parent.addSuite(suite);  return suite;};
/** * Initialize a new `Suite` with the given `title` and `ctx`. * * @api private *    *    */function Suite (title, parentContext) {  if (!utils.isString(title)) {    throw new Error(Suite `title` should be a ""string"" but "" + typeof title + "" was given instead.);  }  this.title = title;  function Context () {}  Context.prototype = parentContext;  this.ctx = new Context();  this.suites = [];  this.tests = [];  this.pending = false;  this._beforeEach = [];  this._beforeAll = [];  this._afterEach = [];  this._afterAll = [];  this.root = !title;  this._timeout = 2000;  this._enableTimeouts = true;  this._slow = 75;  this._bail = false;  this._retries = -1;  this._onlyTests = [];  this._onlySuites = [];  this.delayed = false;}
/** * Inherit from `EventEmitter.prototype`. */inherits(Suite, EventEmitter);
/** * Return a clone of this `Suite`. * * @api private *   */Suite.prototype.clone = function () {  var suite = new Suite(this.title);  debug(clone);  suite.ctx = this.ctx;  suite.timeout(this.timeout());  suite.retries(this.retries());  suite.enableTimeouts(this.enableTimeouts());  suite.slow(this.slow());  suite.bail(this.bail());  return suite;};
/** * Set timeout `ms` or short-hand such as ""2s"". * * @api private *    *   for chaining */Suite.prototype.timeout = function (ms) {  if (!arguments.length) {    return this._timeout;  }  if (ms.toString() === 0) {    this._enableTimeouts = false;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(timeout %d, ms);  this._timeout = parseInt(ms, 10);  return this;};
/** * Set number of times to retry a failed test. * * @api private *    *   for chaining */Suite.prototype.retries = function (n) {  if (!arguments.length) {    return this._retries;  }  debug(retries %d, n);  this._retries = parseInt(n, 10) || 0;  return this;};
/**  * Set timeout to `enabled`.  *  * @api private  *     *   self or enabled  */Suite.prototype.enableTimeouts = function (enabled) {  if (!arguments.length) {    return this._enableTimeouts;  }  debug(enableTimeouts %s, enabled);  this._enableTimeouts = enabled;  return this;};
/** * Set slow `ms` or short-hand such as ""2s"". * * @api private *    *   for chaining */Suite.prototype.slow = function (ms) {  if (!arguments.length) {    return this._slow;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(slow %d, ms);  this._slow = ms;  return this;};
/** * Sets whether to bail after first error. * * @api private *    *   for chaining */Suite.prototype.bail = function (bail) {  if (!arguments.length) {    return this._bail;  }  debug(bail %s, bail);  this._bail = bail;  return this;};
/** * Check if this suite or its parent suite is marked as pending. * * @api private */Suite.prototype.isPending = function () {  return this.pending || (this.parent && this.parent.isPending());};
/** * Run `fn(test[, done])` before running tests. * * @api private *    *    *   for chaining */Suite.prototype.beforeAll = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""before all"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._beforeAll.push(hook);  this.emit(beforeAll, hook);  return this;};
/** * Run `fn(test[, done])` after running tests. * * @api private *    *    *   for chaining */Suite.prototype.afterAll = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""after all"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._afterAll.push(hook);  this.emit(afterAll, hook);  return this;};
/** * Run `fn(test[, done])` before each test case. * * @api private *    *    *   for chaining */Suite.prototype.beforeEach = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""before each"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._beforeEach.push(hook);  this.emit(beforeEach, hook);  return this;};
/** * Run `fn(test[, done])` after each test case. * * @api private *    *    *   for chaining */Suite.prototype.afterEach = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""after each"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._afterEach.push(hook);  this.emit(afterEach, hook);  return this;};
/** * Add a test `suite`. * * @api private *    *   for chaining */Suite.prototype.addSuite = function (suite) {  suite.parent = this;  suite.timeout(this.timeout());  suite.retries(this.retries());  suite.enableTimeouts(this.enableTimeouts());  suite.slow(this.slow());  suite.bail(this.bail());  this.suites.push(suite);  this.emit(suite, suite);  return this;};
/** * Add a `test` to this suite. * * @api private *    *   for chaining */Suite.prototype.addTest = function (test) {  test.parent = this;  test.timeout(this.timeout());  test.retries(this.retries());  test.enableTimeouts(this.enableTimeouts());  test.slow(this.slow());  test.ctx = this.ctx;  this.tests.push(test);  this.emit(test, test);  return this;};
/** * Return the full title generated by recursively concatenating the parent's * full title. * * @api public *   */Suite.prototype.fullTitle = function () {  if (this.parent) {    var full = this.parent.fullTitle();    if (full) {      return full +   + this.title;    }  }  return this.title;};
/** * Return the total number of tests. * * @api public *   */Suite.prototype.total = function () {  return utils.reduce(this.suites, function (sum, suite) {    return sum + suite.total();  }, 0) + this.tests.length;};
/** * Iterates through each suite recursively to find all tests. Applies a * function in the format `fn(test)`. * * @api private *    *   */Suite.prototype.eachTest = function (fn) {  utils.forEach(this.tests, fn);  utils.forEach(this.suites, function (suite) {    suite.eachTest(fn);  });  return this;};
/** * This will run the root suite if we happen to be running in delayed mode. */Suite.prototype.run = function run () {  if (this.root) {    this.emit(run);  }};
},{./hook:7,./ms:15,./utils:38,debug:2,events:3}],36:[function(require,module,exports){use strict;
/** * Module dependencies. */
var Runnable = require(./runnable);var create = require(lodash.create);var isString = require(./utils).isString;
/** * Expose `Test`. */
module.exports = Test;
/** * Initialize a new `Test` with the given `title` and callback `fn`. * * @api private *    *    */function Test (title, fn) {  if (!isString(title)) {    throw new Error(Test `title` should be a ""string"" but "" + typeof title + "" was given instead.);  }  Runnable.call(this, title, fn);  this.pending = !fn;  this.type = test;}
/** * Inherit from `Runnable.prototype`. */Test.prototype = create(Runnable.prototype, {  constructor: Test});
Test.prototype.clone = function () {  var test = new Test(this.title, this.fn);  test.timeout(this.timeout());  test.slow(this.slow());  test.enableTimeouts(this.enableTimeouts());  test.retries(this.retries());  test.currentRetry(this.currentRetry());  test.globals(this.globals());  test.parent = this.parent;  test.file = this.file;  test.ctx = this.ctx;  return test;};
},{./runnable:33,./utils:38,lodash.create:60}],37:[function(require,module,exports){use strict;
/** * Pad a `number` with a ten's place zero. * *    *   */function pad(number) {  var n = number.toString();  return n.length === 1 ? 0 + n : n;}
/** * Turn a `date` into an ISO string. * * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString * *    *   */function toISOString(date) {  return date.getUTCFullYear()    + - + pad(date.getUTCMonth() + 1)    + - + pad(date.getUTCDate())    + T + pad(date.getUTCHours())    + : + pad(date.getUTCMinutes())    + : + pad(date.getUTCSeconds())    + . + String((date.getUTCMilliseconds()/1000).toFixed(3)).slice(2, 5)    + Z;}
/* * Exports. */
module.exports = toISOString;
},{}],38:[function(require,module,exports){(function (process,Buffer){use strict;
/* eslint-env browser */
/** * Module dependencies. */
var JSON = require(json3);var basename = require(path).basename;var debug = require(debug)(mocha:watch);var exists = require(fs).existsSync || require(path).existsSync;var glob = require(glob);var path = require(path);var join = path.join;var readdirSync = require(fs).readdirSync;var statSync = require(fs).statSync;var watchFile = require(fs).watchFile;var lstatSync = require(fs).lstatSync;var toISOString = require(./to-iso-string);
/** * Ignored directories. */
var ignore = [node_modules, .git];
exports.inherits = require(util).inherits;
/** * Escape special characters in the given string of html. * * @api private *     *   */exports.escape = function (html) {  return String(html)    .replace(&g, &amp;)    .replace(""g, &quot;)    .replace(<g, &lt;)    .replace(>g, &gt;);};
/** * Array#forEach (<=IE8) * * @api private *    *    *    */exports.forEach = function (arr, fn, scope) {  for (var i = 0, l = arr.length; i < l; i++) {    fn.call(scope, arr[i], i);  }};
/** * Test if the given obj is type of string. * * @api private *    *   */exports.isString = function (obj) {  return typeof obj === string;};
/** * Array#map (<=IE8) * * @api private *    *    *    *   */exports.map = function (arr, fn, scope) {  var result = [];  for (var i = 0, l = arr.length; i < l; i++) {    result.push(fn.call(scope, arr[i], i, arr));  }  return result;};
/** * Array#indexOf (<=IE8) * * @api private *    *    to find index of *    *   */var indexOf = exports.indexOf = function (arr, obj, start) {  for (var i = start || 0, l = arr.length; i < l; i++) {    if (arr[i] === obj) {      return i;    }  }  return -1;};
/** * Array#reduce (<=IE8) * * @api private *    *    *    Initial value. *   */var reduce = exports.reduce = function (arr, fn, val) {  var rval = val;
  for (var i = 0, l = arr.length; i < l; i++) {    rval = fn(rval, arr[i], i, arr);  }
  return rval;};
/** * Array#filter (<=IE8) * * @api private *    *    *   */exports.filter = function (arr, fn) {  var ret = [];
  for (var i = 0, l = arr.length; i < l; i++) {    var val = arr[i];    if (fn(val, i, arr)) {      ret.push(val);    }  }
  return ret;};
/** * Array#some (<=IE8) * * @api private *    *    *   */exports.some = function (arr, fn) {  for (var i = 0, l = arr.length; i < l; i++) {    if (fn(arr[i])) {      return true;    }  }  return false;};
/** * Object.keys (<=IE8) * * @api private *    *   keys */exports.keys = typeof Object.keys === function ? Object.keys : function (obj) {  var keys = [];  var has = Object.prototype.hasOwnProperty;  for `window` on <=IE8
  for (var key in obj) {    if (has.call(obj, key)) {      keys.push(key);    }  }
  return keys;};
/** * Watch the given `files` for changes * and invoke `fn(file)` on modification. * * @api private *    *    */exports.watch = function (files, fn) {  var options = { interval: 100 };  files.forEach(function (file) {    debug(file %s, file);    watchFile(file, options, function (curr, prev) {      if (prev.mtime < curr.mtime) {        fn(file);      }    });  });};
/** * Array.isArray (<=IE8) * * @api private *    *   */var isArray = typeof Array.isArray === function ? Array.isArray : function (obj) {  return Object.prototype.toString.call(obj) === [object Array];};
exports.isArray = isArray;
/** * Buffer.prototype.toJSON polyfill. * *   */if (typeof Buffer !== undefined && Buffer.prototype) {  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {    return Array.prototype.slice.call(this, 0);  };}
/** * Ignored files. * * @api private *    *   */function ignored (path) {  return !~ignore.indexOf(path);}
/** * Lookup files in the given `dir`. * * @api private *    *   ] *   ] *   */exports.files = function (dir, ext, ret) {  ret = ret || [];  ext = ext || [js];
  var re = new RegExp(.( + ext.join(|) + )$);
  readdirSync(dir)    .filter(ignored)    .forEach(function (path) {      path = join(dir, path);      if (lstatSync(path).isDirectory()) {        exports.files(path, ext, ret);      } else if (path.match(re)) {        ret.push(path);      }    });
  return ret;};
/** * Compute a slug from the given `str`. * * @api private *    *   */exports.slug = function (str) {  return str    .toLowerCase()    .replace( g, -)    .replace(g, );};
/** * Strip the function definition from `str`, and re-indent for pre whitespace. * *    *   */exports.clean = function (str) {  str = str    .replace(g, ).replace(FEFF, )     (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content    .replace(function(?:)((?:))=>(?:((?:))((?:))), $1$2$3);
  var spaces = str.match(( ))[1].length;  var tabs = str.match(())[1].length;  var re = new RegExp(^? + (tabs ?  :  ) + { + (tabs || spaces) + }, gm);
  str = str.replace(re, );
  return exports.trim(str);};
/** * Trim the given `str`. * * @api private *    *   */exports.trim = function (str) {  return str.replace(g, );};
/** * Parse the given `qs`. * * @api private *    *   */exports.parseQuery = function (qs) {  return reduce(qs.replace(?, ).split(&), function (obj, pair) {    var i = pair.indexOf(=);    var key = pair.slice(0, i);    var val = pair.slice(++i);
    obj[key] = decodeURIComponent(val);    return obj;  }, {});};
/** * Highlight the given string of `js`. * * @api private *    *   */function highlight (js) {  return js    .replace(<g, &lt;)    .replace(>g, &gt;)    .replace(()gm, <span class=""comment"">//$1</span>)    .replace(('')gm, <span class=""string"">$1</span>)    .replace(()gm, <span class=""number"">$1</span>)    .replace(()gm, <span class=""number"">$1</span>)    .replace(new()gm, <span class=""keyword"">new</span> <span class=""init"">$1</span>)    .replace((functionnewthrowreturnvarifelse)gm, <span class=""keyword"">$1</span>);}
/** * Highlight the contents of tag `name`. * * @api private *    */exports.highlightTags = function (name) {  var code = document.getElementById(mocha).getElementsByTagName(name);  for (var i = 0, len = code.length; i < len; ++i) {    code[i].innerHTML = highlight(code[i].innerHTML);  }};
/** * If a value could have properties, and has none, this function is called, * which returns a string representation of the empty value. * * Functions w/ no properties return `'[Function]'` * Arrays w/ length === 0 return `'[]'` * Objects w/ no properties return `'{}'` * All else: return result of `value.toString()` * * @api private *    The value to inspect. *    The type of the value *   */function emptyRepresentation (value, typeHint) {  switch (typeHint) {    case function:      return [Function];    case object:      return {};    case array:      return [];    default:      return value.toString();  }}
/** * Takes some variable and asks `Object.prototype.toString()` what it thinks it * is. * * @api private *   *    The value to test. *   Computed type *  *  *  *  *  *  *  *  *  *  *  *  */var type = exports.type = function type (value) {  if (value === undefined) {    return undefined;  } else if (value === null) {    return null;  } else if (typeof Buffer !== undefined && Buffer.isBuffer(value)) {    return buffer;  }  return Object.prototype.toString.call(value)    .replace((), $1)    .toLowerCase();};
/** * Stringify `value`. Different behavior depending on type of value: * * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively. * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes. * - If `value` is an *empty* object, function, or array, return result of function *   . * - If `value` has properties, call  on it, then return result of *   JSON.stringify(). * * @api private *   *    *   */exports.stringify = function (value) {  var typeHint = type(value);
  if (!~indexOf([object, array, function], typeHint)) {    if (typeHint === buffer) {      var json = value.toJSON();       Based on the toJSON result      return jsonStringify(json.data && json.type ? json.data : json, 2)        .replace(,()g, $1);    }
     IE7/IE8 has a bizarre String constructor; needs to be coerced     into an array and back to obj.    if (typeHint === string && typeof value === object) {      value = reduce(value.split(), function (acc, char, idx) {        acc[idx] = char;        return acc;      }, {});      typeHint = object;    } else {      return jsonStringify(value);    }  }
  for (var prop in value) {    if (Object.prototype.hasOwnProperty.call(value, prop)) {      return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(,()g, $1);    }  }
  return emptyRepresentation(value, typeHint);};
/** * like JSON.stringify but more sense. * * @api private *     *    *    *   */function jsonStringify (object, spaces, depth) {  if (typeof spaces === undefined) {     primitive types    return _stringify(object);  }
  depth = depth || 1;  var space = spaces * depth;  var str = isArray(object) ? [ : {;  var end = isArray(object) ? ] : };  var length = typeof object.length === number ? object.length : exports.keys(object).length;   `.repeat()` polyfill  function repeat (s, n) {    return new Array(n).join(s);  }
  function _stringify (val) {    switch (type(val)) {      case null:      case undefined:        val = [ + val + ];        break;      case array:      case object:        val = jsonStringify(val, spaces, depth + 1);        break;      case boolean:      case regexp:      case symbol:      case number:        val = val === 0 && (1 / val) === -Infinity  `-0`          ? -0          : val.toString();        break;      case date:        var sDate;        if (isNaN(val.getTime())) {  Invalid date          sDate = val.toString();        } else {          sDate = val.toISOString ? val.toISOString() : toISOString(val);        }        val = [Date:  + sDate + ];        break;      case buffer:        var json = val.toJSON();         Based on the toJSON result        json = json.data && json.type ? json.data : json;        val = [Buffer:  + jsonStringify(json, 2, depth + 1) + ];        break;      default:        val = (val === [Function] || val === [Circular])          ? val          : JSON.stringify(val);  string    }    return val;  }
  for (var i in object) {    if (!Object.prototype.hasOwnProperty.call(object, i)) {      continue;  not my business    }    --length;    str +=   + repeat( , space) +      (isArray(object) ?  : "" + i + "": ) +  key      _stringify(object[i]) +                     value      (length ? , : );                        comma  }
  return str +     [], {}    (str.length !== 1 ?  + repeat( , --space) + end : end);}
/** * Test if a value is a buffer. * * @api private *    The value to test. *   True if `value` is a buffer, otherwise false */exports.isBuffer = function (value) {  return typeof Buffer !== undefined && Buffer.isBuffer(value);};
/** * Return a new Thing that has the keys in sorted order. Recursive. * * If the Thing... * - has already been seen, return string `'[Circular]'` * - is `undefined`, return string `'[undefined]'` * - is `null`, return value `null` * - is some other primitive, return the value * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again. * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()` * * @api private *  @link exports.stringify} *    Thing to inspect.  May or may not have properties. *   ] Stack of seen values *    Type hint *   */exports.canonicalize = function canonicalize (value, stack, typeHint) {  var canonicalizedObj;  /* eslint-disable no-unused-vars */  var prop;  /* eslint-enable no-unused-vars */  typeHint = typeHint || type(value);  function withStack (value, fn) {    stack.push(value);    fn();    stack.pop();  }
  stack = stack || [];
  if (indexOf(stack, value) !== -1) {    return [Circular];  }
  switch (typeHint) {    case undefined:    case buffer:    case null:      canonicalizedObj = value;      break;    case array:      withStack(value, function () {        canonicalizedObj = exports.map(value, function (item) {          return exports.canonicalize(item, stack);        });      });      break;    case function:      /* eslint-disable guard-for-in */      for (prop in value) {        canonicalizedObj = {};        break;      }      /* eslint-enable guard-for-in */      if (!canonicalizedObj) {        canonicalizedObj = emptyRepresentation(value, typeHint);        break;      }    /* falls through */    case object:      canonicalizedObj = canonicalizedObj || {};      withStack(value, function () {        exports.forEach(exports.keys(value).sort(), function (key) {          canonicalizedObj[key] = exports.canonicalize(value[key], stack);        });      });      break;    case date:    case number:    case regexp:    case boolean:    case symbol:      canonicalizedObj = value;      break;    default:      canonicalizedObj = value + ;  }
  return canonicalizedObj;};
/** * Lookup file names at the given `path`. * * @api public *    Base path to start searching from. *    File extensions to look for. *    Whether or not to recurse into subdirectories. *   An array of paths. */exports.lookupFiles = function lookupFiles (path, extensions, recursive) {  var files = [];  var re = new RegExp(.( + extensions.join(|) + )$);
  if (!exists(path)) {    if (exists(path + .js)) {      path += .js;    } else {      files = glob.sync(path);      if (!files.length) {        throw new Error(cannot resolve path (or pattern) ' + path + ');      }      return files;    }  }
  try {    var stat = statSync(path);    if (stat.isFile()) {      return path;    }  } catch (err) {     ignore error    return;  }
  readdirSync(path).forEach(function (file) {    file = join(path, file);    try {      var stat = statSync(file);      if (stat.isDirectory()) {        if (recursive) {          files = files.concat(lookupFiles(file, extensions, recursive));        }        return;      }    } catch (err) {       ignore error      return;    }    if (!stat.isFile() || !re.test(file) || basename(file)[0] === .) {      return;    }    files.push(file);  });
  return files;};
/** * Generate an undefined error with a message warning the user. * *   */
exports.undefinedError = function () {  return new Error(Caught undefined error, did you throw without specifying what?);};
/** * Generate an undefined error if `err` is not defined. * *    *   */
exports.getError = function (err) {  return err || exports.undefinedError();};
/** *  * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`) *  * When invoking this function you get a filter function that get the Error.stack as an input, * and return a prettify output. * (i.e: strip Mocha and internal node functions from stack trace). *   */exports.stackTraceFilter = function () {   TODO: Replace with `process.browser`  var is = typeof document === undefined ? { node: true } : { browser: true };  var slash = path.sep;  var cwd;  if (is.node) {    cwd = process.cwd() + slash;  } else {    cwd = (typeof location === undefined ? window.location : location).href.replace(, /);    slash = /;  }
  function isMochaInternal (line) {    return (~line.indexOf(node_modules + slash + mocha + slash)) ||      (~line.indexOf(node_modules + slash + mocha.js)) ||      (~line.indexOf(bower_components + slash + mocha.js)) ||      (~line.indexOf(slash + mocha.js));  }
  function isNodeInternal (line) {    return (~line.indexOf((timers.js:)) ||      (~line.indexOf((events.js:)) ||      (~line.indexOf((node.js:)) ||      (~line.indexOf((module.js:)) ||      (~line.indexOf(GeneratorFunctionPrototype.next (native))) ||      false;  }
  return function (stack) {    stack = stack.split();
    stack = reduce(stack, function (list, line) {      if (isMochaInternal(line)) {        return list;      }
      if (is.node && isNodeInternal(line)) {        return list;      }
       Clean up cwd(absolute)      if (::.test(line)) {        line = line.replace(cwd, );      }
      list.push(line);      return list;    }, []);
    return stack.join();  };};
/** * Crude, but effective. * @api *    *   Whether or not `value` is a Promise */exports.isPromise = function isPromise (value) {  return typeof value === object && typeof value.then === function;};
/** * It's a noop. * @api */exports.noop = function () {};
}).call(this,require(_process),require(buffer).Buffer)},{./to-iso-string:37,_process:67,buffer:44,debug:2,fs:42,glob:42,json3:54,path:42,util:84}],39:[function(require,module,exports){use strict
exports.byteLength = byteLengthexports.toByteArray = toByteArrayexports.fromByteArray = fromByteArray
var lookup = []var revLookup = []var Arr = typeof Uint8Array !== undefined ? Uint8Array : Array
var code = ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/for (var i = 0, len = code.length; i < len; ++i) {  lookup[i] = code[i]  revLookup[code.charCodeAt(i)] = i}
revLookup[-.charCodeAt(0)] = 62revLookup[_.charCodeAt(0)] = 63
function placeHoldersCount (b64) {  var len = b64.length  if (len % 4 > 0) {    throw new Error(Invalid string. Length must be a multiple of 4)  }
   the number of equal signs (place holders)   if there are two placeholders, than the two characters before it   represent one byte   if there is only one, then the three characters before it represent 2 bytes   this is just a cheap hack to not do indexOf twice  return b64[len - 2] === = ? 2 : b64[len - 1] === = ? 1 : 0}
function byteLength (b64) {   base64 is 4/3 + up to two characters of the original data  return b64.length * 3 / 4 - placeHoldersCount(b64)}
function toByteArray (b64) {  var i, j, l, tmp, placeHolders, arr  var len = b64.length  placeHolders = placeHoldersCount(b64)
  arr = new Arr(len * 3 / 4 - placeHolders)
   if there are placeholders, only get up to the last complete 4 chars  l = placeHolders > 0 ? len - 4 : len
  var L = 0
  for (i = 0, j = 0; i < l; i += 4, j += 3) {    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]    arr[L++] = (tmp >> 16) & 0xFF    arr[L++] = (tmp >> 8) & 0xFF    arr[L++] = tmp & 0xFF  }
  if (placeHolders === 2) {    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)    arr[L++] = tmp & 0xFF  } else if (placeHolders === 1) {    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)    arr[L++] = (tmp >> 8) & 0xFF    arr[L++] = tmp & 0xFF  }
  return arr}
function tripletToBase64 (num) {  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]}
function encodeChunk (uint8, start, end) {  var tmp  var output = []  for (var i = start; i < end; i += 3) {    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])    output.push(tripletToBase64(tmp))  }  return output.join()}
function fromByteArray (uint8) {  var tmp  var len = uint8.length  var extraBytes = len % 3  if we have 1 byte left, pad 2 bytes  var output =   var parts = []  var maxChunkLength = 16383  must be multiple of 3
   go through the array every three bytes, we'll deal with trailing stuff later  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))  }
   pad the end with zeros, but make sure to not forget the extra bytes  if (extraBytes === 1) {    tmp = uint8[len - 1]    output += lookup[tmp >> 2]    output += lookup[(tmp << 4) & 0x3F]    output += ==  } else if (extraBytes === 2) {    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])    output += lookup[tmp >> 10]    output += lookup[(tmp >> 4) & 0x3F]    output += lookup[(tmp << 2) & 0x3F]    output += =  }
  parts.push(output)
  return parts.join()}
},{}],40:[function(require,module,exports){
},{}],41:[function(require,module,exports){(function (process){var WritableStream = require(stream).Writablevar inherits = require(util).inherits
module.exports = BrowserStdout

inherits(BrowserStdout, WritableStream)
function BrowserStdout(opts) {  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)
  opts = opts || {}  WritableStream.call(this, opts)  this.label = (opts.label !== undefined) ? opts.label : stdout}
BrowserStdout.prototype._write = function(chunks, encoding, cb) {  var output = chunks.toString ? chunks.toString() : chunks  if (this.label === false) {    console.log(output)  } else {    console.log(this.label+:, output)  }  process.nextTick(cb)}
}).call(this,require(_process))},{_process:67,stream:79,util:84}],42:[function(require,module,exports){arguments[4][40][0].apply(exports,arguments)},{dup:40}],43:[function(require,module,exports){(function (global){use strict;
var buffer = require(buffer);var Buffer = buffer.Buffer;var SlowBuffer = buffer.SlowBuffer;var MAX_LEN = buffer.kMaxLength || 2147483647;exports.alloc = function alloc(size, fill, encoding) {  if (typeof Buffer.alloc === function) {    return Buffer.alloc(size, fill, encoding);  }  if (typeof encoding === number) {    throw new TypeError(encoding must not be number);  }  if (typeof size !== number) {    throw new TypeError(size must be a number);  }  if (size > MAX_LEN) {    throw new RangeError(size is too large);  }  var enc = encoding;  var _fill = fill;  if (_fill === undefined) {    enc = undefined;    _fill = 0;  }  var buf = new Buffer(size);  if (typeof _fill === string) {    var fillBuf = new Buffer(_fill, enc);    var flen = fillBuf.length;    var i = -1;    while (++i < size) {      buf[i] = fillBuf[i % flen];    }  } else {    buf.fill(_fill);  }  return buf;}exports.allocUnsafe = function allocUnsafe(size) {  if (typeof Buffer.allocUnsafe === function) {    return Buffer.allocUnsafe(size);  }  if (typeof size !== number) {    throw new TypeError(size must be a number);  }  if (size > MAX_LEN) {    throw new RangeError(size is too large);  }  return new Buffer(size);}exports.from = function from(value, encodingOrOffset, length) {  if (typeof Buffer.from === function && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {    return Buffer.from(value, encodingOrOffset, length);  }  if (typeof value === number) {    throw new TypeError(""value"" argument must not be a number);  }  if (typeof value === string) {    return new Buffer(value, encodingOrOffset);  }  if (typeof ArrayBuffer !== undefined && value instanceof ArrayBuffer) {    var offset = encodingOrOffset;    if (arguments.length === 1) {      return new Buffer(value);    }    if (typeof offset === undefined) {      offset = 0;    }    var len = length;    if (typeof len === undefined) {      len = value.byteLength - offset;    }    if (offset >= value.byteLength) {      throw new RangeError(offset is out of bounds);    }    if (len > value.byteLength - offset) {      throw new RangeError(length is out of bounds);    }    return new Buffer(value.slice(offset, offset + len));  }  if (Buffer.isBuffer(value)) {    var out = new Buffer(value.length);    value.copy(out, 0, 0, value.length);    return out;  }  if (value) {    if (Array.isArray(value) || (typeof ArrayBuffer !== undefined && value.buffer instanceof ArrayBuffer) || length in value) {      return new Buffer(value);    }    if (value.type === Buffer && Array.isArray(value.data)) {      return new Buffer(value.data);    }  }
  throw new TypeError(First argument must be a string, Buffer,  + ArrayBuffer, Array, or array-like object.);}exports.allocUnsafeSlow = function allocUnsafeSlow(size) {  if (typeof Buffer.allocUnsafeSlow === function) {    return Buffer.allocUnsafeSlow(size);  }  if (typeof size !== number) {    throw new TypeError(size must be a number);  }  if (size >= MAX_LEN) {    throw new RangeError(size is too large);  }  return new SlowBuffer(size);}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{buffer:44}],44:[function(require,module,exports){(function (global){/*! * The buffer module from node.js, for the browser. * * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license  MIT *//* eslint-disable no-proto */
use strict
var base64 = require(base64-js)var ieee754 = require(ieee754)var isArray = require(isarray)
exports.Buffer = Bufferexports.SlowBuffer = SlowBufferexports.INSPECT_MAX_BYTES = 50
/** * If `Buffer.TYPED_ARRAY_SUPPORT`: *   === true    Use Uint8Array implementation (fastest) *   === false   Use Object implementation (most compatible, even IE6) * * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+, * Opera 11.6+, iOS 4.2+. * * Due to various browser bugs, sometimes the Object implementation will be used even * when the browser supports typed arrays. * * Note: * *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances, *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438. * *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function. * *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of *     incorrect length in some situations. * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they * get the Object implementation, which is slower but behaves correctly. */Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined  ? global.TYPED_ARRAY_SUPPORT  : typedArraySupport()
/* * Export kMaxLength after typed array support is determined. */exports.kMaxLength = kMaxLength()
function typedArraySupport () {  try {    var arr = new Uint8Array(1)    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}    return arr.foo() === 42 &&  typed array instances can be augmented        typeof arr.subarray === function &&  chrome 9-10 lack `subarray`        arr.subarray(1, 1).byteLength === 0  ie10 has broken `subarray`  } catch (e) {    return false  }}
function kMaxLength () {  return Buffer.TYPED_ARRAY_SUPPORT    ? 0x7fffffff    : 0x3fffffff}
function createBuffer (that, length) {  if (kMaxLength() < length) {    throw new RangeError(Invalid typed array length)  }  if (Buffer.TYPED_ARRAY_SUPPORT) {     Return an augmented `Uint8Array` instance, for best performance    that = new Uint8Array(length)    that.__proto__ = Buffer.prototype  } else {     Fallback: Return an object instance of the Buffer class    if (that === null) {      that = new Buffer(length)    }    that.length = length  }
  return that}
/** * The Buffer constructor returns instances of `Uint8Array` that have their * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of * `Uint8Array`, so the returned instances will have all the node `Buffer` methods * and the `Uint8Array` methods. Square bracket notation works as expected -- it * returns a single octet. * * The `Uint8Array` prototype remains unmodified. */
function Buffer (arg, encodingOrOffset, length) {  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {    return new Buffer(arg, encodingOrOffset, length)  }
   Common case.  if (typeof arg === number) {    if (typeof encodingOrOffset === string) {      throw new Error(        If encoding is specified then the first argument must be a string      )    }    return allocUnsafe(this, arg)  }  return from(this, arg, encodingOrOffset, length)}
Buffer.poolSize = 8192  not used by this implementation
 TODO: Legacy, not needed anymore. Remove in next major version.Buffer._augment = function (arr) {  arr.__proto__ = Buffer.prototype  return arr}
function from (that, value, encodingOrOffset, length) {  if (typeof value === number) {    throw new TypeError(""value"" argument must not be a number)  }
  if (typeof ArrayBuffer !== undefined && value instanceof ArrayBuffer) {    return fromArrayBuffer(that, value, encodingOrOffset, length)  }
  if (typeof value === string) {    return fromString(that, value, encodingOrOffset)  }
  return fromObject(that, value)}
/** * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError * if value is a number. * Buffer.from(str[, encoding]) * Buffer.from(array) * Buffer.from(buffer) * Buffer.from(arrayBuffer[, byteOffset[, length]]) **/Buffer.from = function (value, encodingOrOffset, length) {  return from(null, value, encodingOrOffset, length)}
if (Buffer.TYPED_ARRAY_SUPPORT) {  Buffer.prototype.__proto__ = Uint8Array.prototype  Buffer.__proto__ = Uint8Array  if (typeof Symbol !== undefined && Symbol.species &&      Buffer[Symbol.species] === Buffer) {     Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97    Object.defineProperty(Buffer, Symbol.species, {      value: null,      configurable: true    })  }}
function assertSize (size) {  if (typeof size !== number) {    throw new TypeError(""size"" argument must be a number)  } else if (size < 0) {    throw new RangeError(""size"" argument must not be negative)  }}
function alloc (that, size, fill, encoding) {  assertSize(size)  if (size <= 0) {    return createBuffer(that, size)  }  if (fill !== undefined) {     Only pay attention to encoding if it's a string. This     prevents accidentally sending in a number that would     be interpretted as a start offset.    return typeof encoding === string      ? createBuffer(that, size).fill(fill, encoding)      : createBuffer(that, size).fill(fill)  }  return createBuffer(that, size)}
/** * Creates a new filled Buffer instance. * alloc(size[, fill[, encoding]]) **/Buffer.alloc = function (size, fill, encoding) {  return alloc(null, size, fill, encoding)}
function allocUnsafe (that, size) {  assertSize(size)  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)  if (!Buffer.TYPED_ARRAY_SUPPORT) {    for (var i = 0; i < size; ++i) {      that[i] = 0    }  }  return that}
/** * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance. * */Buffer.allocUnsafe = function (size) {  return allocUnsafe(null, size)}/** * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance. */Buffer.allocUnsafeSlow = function (size) {  return allocUnsafe(null, size)}
function fromString (that, string, encoding) {  if (typeof encoding !== string || encoding === ) {    encoding = utf8  }
  if (!Buffer.isEncoding(encoding)) {    throw new TypeError(""encoding"" must be a valid string encoding)  }
  var length = byteLength(string, encoding) | 0  that = createBuffer(that, length)
  var actual = that.write(string, encoding)
  if (actual !== length) {     Writing a hex string, for example, that contains invalid characters will     cause everything after the first invalid character to be ignored. (e.g.     'abxxcd' will be treated as 'ab')    that = that.slice(0, actual)  }
  return that}
function fromArrayLike (that, array) {  var length = array.length < 0 ? 0 : checked(array.length) | 0  that = createBuffer(that, length)  for (var i = 0; i < length; i += 1) {    that[i] = array[i] & 255  }  return that}
function fromArrayBuffer (that, array, byteOffset, length) {  array.byteLength  this throws if `array` is not a valid ArrayBuffer
  if (byteOffset < 0 || array.byteLength < byteOffset) {    throw new RangeError(offset is out of bounds)  }
  if (array.byteLength < byteOffset + (length || 0)) {    throw new RangeError(length is out of bounds)  }
  if (byteOffset === undefined && length === undefined) {    array = new Uint8Array(array)  } else if (length === undefined) {    array = new Uint8Array(array, byteOffset)  } else {    array = new Uint8Array(array, byteOffset, length)  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {     Return an augmented `Uint8Array` instance, for best performance    that = array    that.__proto__ = Buffer.prototype  } else {     Fallback: Return an object instance of the Buffer class    that = fromArrayLike(that, array)  }  return that}
function fromObject (that, obj) {  if (Buffer.isBuffer(obj)) {    var len = checked(obj.length) | 0    that = createBuffer(that, len)
    if (that.length === 0) {      return that    }
    obj.copy(that, 0, 0, len)    return that  }
  if (obj) {    if ((typeof ArrayBuffer !== undefined &&        obj.buffer instanceof ArrayBuffer) || length in obj) {      if (typeof obj.length !== number || isnan(obj.length)) {        return createBuffer(that, 0)      }      return fromArrayLike(that, obj)    }
    if (obj.type === Buffer && isArray(obj.data)) {      return fromArrayLike(that, obj.data)    }  }
  throw new TypeError(First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.)}
function checked (length) {   Note: cannot use `length < kMaxLength()` here because that fails when   length is NaN (which is otherwise coerced to zero.)  if (length >= kMaxLength()) {    throw new RangeError(Attempt to allocate Buffer larger than maximum  +                         size: 0x + kMaxLength().toString(16) +  bytes)  }  return length | 0}
function SlowBuffer (length) {  if (+length != length) {  eslint-disable-line eqeqeq    length = 0  }  return Buffer.alloc(+length)}
Buffer.isBuffer = function isBuffer (b) {  return !!(b != null && b._isBuffer)}
Buffer.compare = function compare (a, b) {  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {    throw new TypeError(Arguments must be Buffers)  }
  if (a === b) return 0
  var x = a.length  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {    if (a[i] !== b[i]) {      x = a[i]      y = b[i]      break    }  }
  if (x < y) return -1  if (y < x) return 1  return 0}
Buffer.isEncoding = function isEncoding (encoding) {  switch (String(encoding).toLowerCase()) {    case hex:    case utf8:    case utf-8:    case ascii:    case latin1:    case binary:    case base64:    case ucs2:    case ucs-2:    case utf16le:    case utf-16le:      return true    default:      return false  }}
Buffer.concat = function concat (list, length) {  if (!isArray(list)) {    throw new TypeError(""list"" argument must be an Array of Buffers)  }
  if (list.length === 0) {    return Buffer.alloc(0)  }
  var i  if (length === undefined) {    length = 0    for (i = 0; i < list.length; ++i) {      length += list[i].length    }  }
  var buffer = Buffer.allocUnsafe(length)  var pos = 0  for (i = 0; i < list.length; ++i) {    var buf = list[i]    if (!Buffer.isBuffer(buf)) {      throw new TypeError(""list"" argument must be an Array of Buffers)    }    buf.copy(buffer, pos)    pos += buf.length  }  return buffer}
function byteLength (string, encoding) {  if (Buffer.isBuffer(string)) {    return string.length  }  if (typeof ArrayBuffer !== undefined && typeof ArrayBuffer.isView === function &&      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {    return string.byteLength  }  if (typeof string !== string) {    string =  + string  }
  var len = string.length  if (len === 0) return 0
   Use a for loop to avoid recursion  var loweredCase = false  for (;;) {    switch (encoding) {      case ascii:      case latin1:      case binary:        return len      case utf8:      case utf-8:      case undefined:        return utf8ToBytes(string).length      case ucs2:      case ucs-2:      case utf16le:      case utf-16le:        return len * 2      case hex:        return len >>> 1      case base64:        return base64ToBytes(string).length      default:        if (loweredCase) return utf8ToBytes(string).length  assume utf8        encoding = ( + encoding).toLowerCase()        loweredCase = true    }  }}Buffer.byteLength = byteLength
function slowToString (encoding, start, end) {  var loweredCase = false
   No need to verify that ""this.length <= MAX_UINT32"" since it's a read-only   property of a typed array.
   This behaves neither like String nor Uint8Array in that we set start/end   to their upper/lower bounds if the value passed is out of range.   undefined is handled specially as per ECMA-262 6th Edition,   Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.  if (start === undefined || start < 0) {    start = 0  }   Return early if start > this.length. Done here to prevent potential uint32   coercion fail below.  if (start > this.length) {    return   }
  if (end === undefined || end > this.length) {    end = this.length  }
  if (end <= 0) {    return   }
   Force coersion to uint32. This will also coerce falsey/NaN values to 0.  end >>>= 0  start >>>= 0
  if (end <= start) {    return   }
  if (!encoding) encoding = utf8
  while (true) {    switch (encoding) {      case hex:        return hexSlice(this, start, end)
      case utf8:      case utf-8:        return utf8Slice(this, start, end)
      case ascii:        return asciiSlice(this, start, end)
      case latin1:      case binary:        return latin1Slice(this, start, end)
      case base64:        return base64Slice(this, start, end)
      case ucs2:      case ucs-2:      case utf16le:      case utf-16le:        return utf16leSlice(this, start, end)
      default:        if (loweredCase) throw new TypeError(Unknown encoding:  + encoding)        encoding = (encoding + ).toLowerCase()        loweredCase = true    }  }}
 The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect Buffer instances.Buffer.prototype._isBuffer = true
function swap (b, n, m) {  var i = b[n]  b[n] = b[m]  b[m] = i}
Buffer.prototype.swap16 = function swap16 () {  var len = this.length  if (len % 2 !== 0) {    throw new RangeError(Buffer size must be a multiple of 16-bits)  }  for (var i = 0; i < len; i += 2) {    swap(this, i, i + 1)  }  return this}
Buffer.prototype.swap32 = function swap32 () {  var len = this.length  if (len % 4 !== 0) {    throw new RangeError(Buffer size must be a multiple of 32-bits)  }  for (var i = 0; i < len; i += 4) {    swap(this, i, i + 3)    swap(this, i + 1, i + 2)  }  return this}
Buffer.prototype.swap64 = function swap64 () {  var len = this.length  if (len % 8 !== 0) {    throw new RangeError(Buffer size must be a multiple of 64-bits)  }  for (var i = 0; i < len; i += 8) {    swap(this, i, i + 7)    swap(this, i + 1, i + 6)    swap(this, i + 2, i + 5)    swap(this, i + 3, i + 4)  }  return this}
Buffer.prototype.toString = function toString () {  var length = this.length | 0  if (length === 0) return   if (arguments.length === 0) return utf8Slice(this, 0, length)  return slowToString.apply(this, arguments)}
Buffer.prototype.equals = function equals (b) {  if (!Buffer.isBuffer(b)) throw new TypeError(Argument must be a Buffer)  if (this === b) return true  return Buffer.compare(this, b) === 0}
Buffer.prototype.inspect = function inspect () {  var str =   var max = exports.INSPECT_MAX_BYTES  if (this.length > 0) {    str = this.toString(hex, 0, max).match(g).join( )    if (this.length > max) str +=  ...   }  return <Buffer  + str + >}
Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {  if (!Buffer.isBuffer(target)) {    throw new TypeError(Argument must be a Buffer)  }
  if (start === undefined) {    start = 0  }  if (end === undefined) {    end = target ? target.length : 0  }  if (thisStart === undefined) {    thisStart = 0  }  if (thisEnd === undefined) {    thisEnd = this.length  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {    throw new RangeError(out of range index)  }
  if (thisStart >= thisEnd && start >= end) {    return 0  }  if (thisStart >= thisEnd) {    return -1  }  if (start >= end) {    return 1  }
  start >>>= 0  end >>>= 0  thisStart >>>= 0  thisEnd >>>= 0
  if (this === target) return 0
  var x = thisEnd - thisStart  var y = end - start  var len = Math.min(x, y)
  var thisCopy = this.slice(thisStart, thisEnd)  var targetCopy = target.slice(start, end)
  for (var i = 0; i < len; ++i) {    if (thisCopy[i] !== targetCopy[i]) {      x = thisCopy[i]      y = targetCopy[i]      break    }  }
  if (x < y) return -1  if (y < x) return 1  return 0}
 Finds either the first index of `val` in `buffer` at offset >= `byteOffset`, OR the last index of `val` in `buffer` at offset <= `byteOffset`. Arguments: - buffer - a Buffer to search - val - a string, Buffer, or number - byteOffset - an index into `buffer`; will be clamped to an int32 - encoding - an optional encoding, relevant is val is a string - dir - true for indexOf, false for lastIndexOffunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {   Empty buffer means no match  if (buffer.length === 0) return -1
   Normalize byteOffset  if (typeof byteOffset === string) {    encoding = byteOffset    byteOffset = 0  } else if (byteOffset > 0x7fffffff) {    byteOffset = 0x7fffffff  } else if (byteOffset < -0x80000000) {    byteOffset = -0x80000000  }  byteOffset = +byteOffset   Coerce to Number.  if (isNaN(byteOffset)) {     byteOffset: it it's undefined, null, NaN, ""foo"", etc, search whole buffer    byteOffset = dir ? 0 : (buffer.length - 1)  }
   Normalize byteOffset: negative offsets start from the end of the buffer  if (byteOffset < 0) byteOffset = buffer.length + byteOffset  if (byteOffset >= buffer.length) {    if (dir) return -1    else byteOffset = buffer.length - 1  } else if (byteOffset < 0) {    if (dir) byteOffset = 0    else return -1  }
   Normalize val  if (typeof val === string) {    val = Buffer.from(val, encoding)  }
   Finally, search either indexOf (if dir is true) or lastIndexOf  if (Buffer.isBuffer(val)) {     Special case: looking for empty string/buffer always fails    if (val.length === 0) {      return -1    }    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)  } else if (typeof val === number) {    val = val & 0xFF  Search for a byte value [0-255]    if (Buffer.TYPED_ARRAY_SUPPORT &&        typeof Uint8Array.prototype.indexOf === function) {      if (dir) {        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)      } else {        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)      }    }    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)  }
  throw new TypeError(val must be string, number or Buffer)}
function arrayIndexOf (arr, val, byteOffset, encoding, dir) {  var indexSize = 1  var arrLength = arr.length  var valLength = val.length
  if (encoding !== undefined) {    encoding = String(encoding).toLowerCase()    if (encoding === ucs2 || encoding === ucs-2 ||        encoding === utf16le || encoding === utf-16le) {      if (arr.length < 2 || val.length < 2) {        return -1      }      indexSize = 2      arrLength /= 2      valLength /= 2      byteOffset /= 2    }  }
  function read (buf, i) {    if (indexSize === 1) {      return buf[i]    } else {      return buf.readUInt16BE(i * indexSize)    }  }
  var i  if (dir) {    var foundIndex = -1    for (i = byteOffset; i < arrLength; i++) {      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {        if (foundIndex === -1) foundIndex = i        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize      } else {        if (foundIndex !== -1) i -= i - foundIndex        foundIndex = -1      }    }  } else {    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength    for (i = byteOffset; i >= 0; i--) {      var found = true      for (var j = 0; j < valLength; j++) {        if (read(arr, i + j) !== read(val, j)) {          found = false          break        }      }      if (found) return i    }  }
  return -1}
Buffer.prototype.includes = function includes (val, byteOffset, encoding) {  return this.indexOf(val, byteOffset, encoding) !== -1}
Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)}
Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)}
function hexWrite (buf, string, offset, length) {  offset = Number(offset) || 0  var remaining = buf.length - offset  if (!length) {    length = remaining  } else {    length = Number(length)    if (length > remaining) {      length = remaining    }  }
   must be an even number of digits  var strLen = string.length  if (strLen % 2 !== 0) throw new TypeError(Invalid hex string)
  if (length > strLen / 2) {    length = strLen / 2  }  for (var i = 0; i < length; ++i) {    var parsed = parseInt(string.substr(i * 2, 2), 16)    if (isNaN(parsed)) return i    buf[offset + i] = parsed  }  return i}
function utf8Write (buf, string, offset, length) {  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)}
function asciiWrite (buf, string, offset, length) {  return blitBuffer(asciiToBytes(string), buf, offset, length)}
function latin1Write (buf, string, offset, length) {  return asciiWrite(buf, string, offset, length)}
function base64Write (buf, string, offset, length) {  return blitBuffer(base64ToBytes(string), buf, offset, length)}
function ucs2Write (buf, string, offset, length) {  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)}
Buffer.prototype.write = function write (string, offset, length, encoding) {   Buffer#write(string)  if (offset === undefined) {    encoding = utf8    length = this.length    offset = 0   Buffer#write(string, encoding)  } else if (length === undefined && typeof offset === string) {    encoding = offset    length = this.length    offset = 0   Buffer#write(string, offset[, length][, encoding])  } else if (isFinite(offset)) {    offset = offset | 0    if (isFinite(length)) {      length = length | 0      if (encoding === undefined) encoding = utf8    } else {      encoding = length      length = undefined    }   legacy write(string, encoding, offset, length) - remove in v0.13  } else {    throw new Error(      Buffer.write(string, encoding, offset[, length]) is no longer supported    )  }
  var remaining = this.length - offset  if (length === undefined || length > remaining) length = remaining
  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {    throw new RangeError(Attempt to write outside buffer bounds)  }
  if (!encoding) encoding = utf8
  var loweredCase = false  for (;;) {    switch (encoding) {      case hex:        return hexWrite(this, string, offset, length)
      case utf8:      case utf-8:        return utf8Write(this, string, offset, length)
      case ascii:        return asciiWrite(this, string, offset, length)
      case latin1:      case binary:        return latin1Write(this, string, offset, length)
      case base64:         Warning: maxLength not taken into account in base64Write        return base64Write(this, string, offset, length)
      case ucs2:      case ucs-2:      case utf16le:      case utf-16le:        return ucs2Write(this, string, offset, length)
      default:        if (loweredCase) throw new TypeError(Unknown encoding:  + encoding)        encoding = ( + encoding).toLowerCase()        loweredCase = true    }  }}
Buffer.prototype.toJSON = function toJSON () {  return {    type: Buffer,    data: Array.prototype.slice.call(this._arr || this, 0)  }}
function base64Slice (buf, start, end) {  if (start === 0 && end === buf.length) {    return base64.fromByteArray(buf)  } else {    return base64.fromByteArray(buf.slice(start, end))  }}
function utf8Slice (buf, start, end) {  end = Math.min(buf.length, end)  var res = []
  var i = start  while (i < end) {    var firstByte = buf[i]    var codePoint = null    var bytesPerSequence = (firstByte > 0xEF) ? 4      : (firstByte > 0xDF) ? 3      : (firstByte > 0xBF) ? 2      : 1
    if (i + bytesPerSequence <= end) {      var secondByte, thirdByte, fourthByte, tempCodePoint
      switch (bytesPerSequence) {        case 1:          if (firstByte < 0x80) {            codePoint = firstByte          }          break        case 2:          secondByte = buf[i + 1]          if ((secondByte & 0xC0) === 0x80) {            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)            if (tempCodePoint > 0x7F) {              codePoint = tempCodePoint            }          }          break        case 3:          secondByte = buf[i + 1]          thirdByte = buf[i + 2]          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {              codePoint = tempCodePoint            }          }          break        case 4:          secondByte = buf[i + 1]          thirdByte = buf[i + 2]          fourthByte = buf[i + 3]          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {              codePoint = tempCodePoint            }          }      }    }
    if (codePoint === null) {       we did not generate a valid codePoint so insert a       replacement char (U+FFFD) and advance only 1 byte      codePoint = 0xFFFD      bytesPerSequence = 1    } else if (codePoint > 0xFFFF) {       encode to utf16 (surrogate pair dance)      codePoint -= 0x10000      res.push(codePoint >>> 10 & 0x3FF | 0xD800)      codePoint = 0xDC00 | codePoint & 0x3FF    }
    res.push(codePoint)    i += bytesPerSequence  }
  return decodeCodePointsArray(res)}
 Based on http://stackoverflow.com/a/22747272/680742, the browser with the lowest limit is Chrome, with 0x10000 args. We go 1 magnitude less, for safetyvar MAX_ARGUMENTS_LENGTH = 0x1000
function decodeCodePointsArray (codePoints) {  var len = codePoints.length  if (len <= MAX_ARGUMENTS_LENGTH) {    return String.fromCharCode.apply(String, codePoints)  avoid extra slice()  }
   Decode in chunks to avoid ""call stack size exceeded"".  var res =   var i = 0  while (i < len) {    res += String.fromCharCode.apply(      String,      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)    )  }  return res}
function asciiSlice (buf, start, end) {  var ret =   end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {    ret += String.fromCharCode(buf[i] & 0x7F)  }  return ret}
function latin1Slice (buf, start, end) {  var ret =   end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {    ret += String.fromCharCode(buf[i])  }  return ret}
function hexSlice (buf, start, end) {  var len = buf.length
  if (!start || start < 0) start = 0  if (!end || end < 0 || end > len) end = len
  var out =   for (var i = start; i < end; ++i) {    out += toHex(buf[i])  }  return out}
function utf16leSlice (buf, start, end) {  var bytes = buf.slice(start, end)  var res =   for (var i = 0; i < bytes.length; i += 2) {    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)  }  return res}
Buffer.prototype.slice = function slice (start, end) {  var len = this.length  start = ~~start  end = end === undefined ? len : ~~end
  if (start < 0) {    start += len    if (start < 0) start = 0  } else if (start > len) {    start = len  }
  if (end < 0) {    end += len    if (end < 0) end = 0  } else if (end > len) {    end = len  }
  if (end < start) end = start
  var newBuf  if (Buffer.TYPED_ARRAY_SUPPORT) {    newBuf = this.subarray(start, end)    newBuf.__proto__ = Buffer.prototype  } else {    var sliceLen = end - start    newBuf = new Buffer(sliceLen, undefined)    for (var i = 0; i < sliceLen; ++i) {      newBuf[i] = this[i + start]    }  }
  return newBuf}
/* * Need to make sure that buffer isn't trying to write out of bounds. */function checkOffset (offset, ext, length) {  if ((offset % 1) !== 0 || offset < 0) throw new RangeError(offset is not uint)  if (offset + ext > length) throw new RangeError(Trying to access beyond buffer length)}
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) checkOffset(offset, byteLength, this.length)
  var val = this[offset]  var mul = 1  var i = 0  while (++i < byteLength && (mul *= 0x100)) {    val += this[offset + i] * mul  }
  return val}
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) {    checkOffset(offset, byteLength, this.length)  }
  var val = this[offset + --byteLength]  var mul = 1  while (byteLength > 0 && (mul *= 0x100)) {    val += this[offset + --byteLength] * mul  }
  return val}
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {  if (!noAssert) checkOffset(offset, 1, this.length)  return this[offset]}
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  return this[offset] | (this[offset + 1] << 8)}
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  return (this[offset] << 8) | this[offset + 1]}
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return ((this[offset]) |      (this[offset + 1] << 8) |      (this[offset + 2] << 16)) +      (this[offset + 3] * 0x1000000)}
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return (this[offset] * 0x1000000) +    ((this[offset + 1] << 16) |    (this[offset + 2] << 8) |    this[offset + 3])}
Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) checkOffset(offset, byteLength, this.length)
  var val = this[offset]  var mul = 1  var i = 0  while (++i < byteLength && (mul *= 0x100)) {    val += this[offset + i] * mul  }  mul *= 0x80
  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
  return val}
Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) checkOffset(offset, byteLength, this.length)
  var i = byteLength  var mul = 1  var val = this[offset + --i]  while (i > 0 && (mul *= 0x100)) {    val += this[offset + --i] * mul  }  mul *= 0x80
  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
  return val}
Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {  if (!noAssert) checkOffset(offset, 1, this.length)  if (!(this[offset] & 0x80)) return (this[offset])  return ((0xff - this[offset] + 1) * -1)}
Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  var val = this[offset] | (this[offset + 1] << 8)  return (val & 0x8000) ? val | 0xFFFF0000 : val}
Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  var val = this[offset + 1] | (this[offset] << 8)  return (val & 0x8000) ? val | 0xFFFF0000 : val}
Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return (this[offset]) |    (this[offset + 1] << 8) |    (this[offset + 2] << 16) |    (this[offset + 3] << 24)}
Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return (this[offset] << 24) |    (this[offset + 1] << 16) |    (this[offset + 2] << 8) |    (this[offset + 3])}
Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)  return ieee754.read(this, offset, true, 23, 4)}
Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)  return ieee754.read(this, offset, false, 23, 4)}
Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 8, this.length)  return ieee754.read(this, offset, true, 52, 8)}
Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 8, this.length)  return ieee754.read(this, offset, false, 52, 8)}
function checkInt (buf, value, offset, ext, max, min) {  if (!Buffer.isBuffer(buf)) throw new TypeError(""buffer"" argument must be a Buffer instance)  if (value > max || value < min) throw new RangeError(""value"" argument is out of bounds)  if (offset + ext > buf.length) throw new RangeError(Index out of range)}
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) {    var maxBytes = Math.pow(2, 8 * byteLength) - 1    checkInt(this, value, offset, byteLength, maxBytes, 0)  }
  var mul = 1  var i = 0  this[offset] = value & 0xFF  while (++i < byteLength && (mul *= 0x100)) {    this[offset + i] = (value / mul) & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) {    var maxBytes = Math.pow(2, 8 * byteLength) - 1    checkInt(this, value, offset, byteLength, maxBytes, 0)  }
  var i = byteLength - 1  var mul = 1  this[offset + i] = value & 0xFF  while (--i >= 0 && (mul *= 0x100)) {    this[offset + i] = (value / mul) & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)  this[offset] = (value & 0xff)  return offset + 1}
function objectWriteUInt16 (buf, value, offset, littleEndian) {  if (value < 0) value = 0xffff + value + 1  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>      (littleEndian ? i : 1 - i) * 8  }}
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value & 0xff)    this[offset + 1] = (value >>> 8)  } else {    objectWriteUInt16(this, value, offset, true)  }  return offset + 2}
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 8)    this[offset + 1] = (value & 0xff)  } else {    objectWriteUInt16(this, value, offset, false)  }  return offset + 2}
function objectWriteUInt32 (buf, value, offset, littleEndian) {  if (value < 0) value = 0xffffffff + value + 1  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff  }}
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset + 3] = (value >>> 24)    this[offset + 2] = (value >>> 16)    this[offset + 1] = (value >>> 8)    this[offset] = (value & 0xff)  } else {    objectWriteUInt32(this, value, offset, true)  }  return offset + 4}
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 24)    this[offset + 1] = (value >>> 16)    this[offset + 2] = (value >>> 8)    this[offset + 3] = (value & 0xff)  } else {    objectWriteUInt32(this, value, offset, false)  }  return offset + 4}
Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) {    var limit = Math.pow(2, 8 * byteLength - 1)
    checkInt(this, value, offset, byteLength, limit - 1, -limit)  }
  var i = 0  var mul = 1  var sub = 0  this[offset] = value & 0xFF  while (++i < byteLength && (mul *= 0x100)) {    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {      sub = 1    }    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) {    var limit = Math.pow(2, 8 * byteLength - 1)
    checkInt(this, value, offset, byteLength, limit - 1, -limit)  }
  var i = byteLength - 1  var mul = 1  var sub = 0  this[offset + i] = value & 0xFF  while (--i >= 0 && (mul *= 0x100)) {    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {      sub = 1    }    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)  if (value < 0) value = 0xff + value + 1  this[offset] = (value & 0xff)  return offset + 1}
Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value & 0xff)    this[offset + 1] = (value >>> 8)  } else {    objectWriteUInt16(this, value, offset, true)  }  return offset + 2}
Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 8)    this[offset + 1] = (value & 0xff)  } else {    objectWriteUInt16(this, value, offset, false)  }  return offset + 2}
Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value & 0xff)    this[offset + 1] = (value >>> 8)    this[offset + 2] = (value >>> 16)    this[offset + 3] = (value >>> 24)  } else {    objectWriteUInt32(this, value, offset, true)  }  return offset + 4}
Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)  if (value < 0) value = 0xffffffff + value + 1  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 24)    this[offset + 1] = (value >>> 16)    this[offset + 2] = (value >>> 8)    this[offset + 3] = (value & 0xff)  } else {    objectWriteUInt32(this, value, offset, false)  }  return offset + 4}
function checkIEEE754 (buf, value, offset, ext, max, min) {  if (offset + ext > buf.length) throw new RangeError(Index out of range)  if (offset < 0) throw new RangeError(Index out of range)}
function writeFloat (buf, value, offset, littleEndian, noAssert) {  if (!noAssert) {    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)  }  ieee754.write(buf, value, offset, littleEndian, 23, 4)  return offset + 4}
Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {  return writeFloat(this, value, offset, true, noAssert)}
Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {  return writeFloat(this, value, offset, false, noAssert)}
function writeDouble (buf, value, offset, littleEndian, noAssert) {  if (!noAssert) {    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)  }  ieee754.write(buf, value, offset, littleEndian, 52, 8)  return offset + 8}
Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {  return writeDouble(this, value, offset, true, noAssert)}
Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {  return writeDouble(this, value, offset, false, noAssert)}
 copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)Buffer.prototype.copy = function copy (target, targetStart, start, end) {  if (!start) start = 0  if (!end && end !== 0) end = this.length  if (targetStart >= target.length) targetStart = target.length  if (!targetStart) targetStart = 0  if (end > 0 && end < start) end = start
   Copy 0 bytes; we're done  if (end === start) return 0  if (target.length === 0 || this.length === 0) return 0
   Fatal error conditions  if (targetStart < 0) {    throw new RangeError(targetStart out of bounds)  }  if (start < 0 || start >= this.length) throw new RangeError(sourceStart out of bounds)  if (end < 0) throw new RangeError(sourceEnd out of bounds)
   Are we oob?  if (end > this.length) end = this.length  if (target.length - targetStart < end - start) {    end = target.length - targetStart + start  }
  var len = end - start  var i
  if (this === target && start < targetStart && targetStart < end) {     descending copy from end    for (i = len - 1; i >= 0; --i) {      target[i + targetStart] = this[i + start]    }  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {     ascending copy from start    for (i = 0; i < len; ++i) {      target[i + targetStart] = this[i + start]    }  } else {    Uint8Array.prototype.set.call(      target,      this.subarray(start, start + len),      targetStart    )  }
  return len}
 Usage:    buffer.fill(number[, offset[, end]])    buffer.fill(buffer[, offset[, end]])    buffer.fill(string[, offset[, end]][, encoding])Buffer.prototype.fill = function fill (val, start, end, encoding) {   Handle string cases:  if (typeof val === string) {    if (typeof start === string) {      encoding = start      start = 0      end = this.length    } else if (typeof end === string) {      encoding = end      end = this.length    }    if (val.length === 1) {      var code = val.charCodeAt(0)      if (code < 256) {        val = code      }    }    if (encoding !== undefined && typeof encoding !== string) {      throw new TypeError(encoding must be a string)    }    if (typeof encoding === string && !Buffer.isEncoding(encoding)) {      throw new TypeError(Unknown encoding:  + encoding)    }  } else if (typeof val === number) {    val = val & 255  }
   Invalid ranges are not set to a default, so can range check early.  if (start < 0 || this.length < start || this.length < end) {    throw new RangeError(Out of range index)  }
  if (end <= start) {    return this  }
  start = start >>> 0  end = end === undefined ? this.length : end >>> 0
  if (!val) val = 0
  var i  if (typeof val === number) {    for (i = start; i < end; ++i) {      this[i] = val    }  } else {    var bytes = Buffer.isBuffer(val)      ? val      : utf8ToBytes(new Buffer(val, encoding).toString())    var len = bytes.length    for (i = 0; i < end - start; ++i) {      this[i + start] = bytes[i % len]    }  }
  return this}
 HELPER FUNCTIONS ================
var INVALID_BASE64_RE = g
function base64clean (str) {   Node strips out invalid characters like \n and \t from the string, base64-js does not  str = stringtrim(str).replace(INVALID_BASE64_RE, )   Node converts strings with length < 2 to ''  if (str.length < 2) return    Node allows for non-padded base64 strings (missing trailing ===), base64-js does not  while (str.length % 4 !== 0) {    str = str + =  }  return str}
function stringtrim (str) {  if (str.trim) return str.trim()  return str.replace(g, )}
function toHex (n) {  if (n < 16) return 0 + n.toString(16)  return n.toString(16)}
function utf8ToBytes (string, units) {  units = units || Infinity  var codePoint  var length = string.length  var leadSurrogate = null  var bytes = []
  for (var i = 0; i < length; ++i) {    codePoint = string.charCodeAt(i)
     is surrogate component    if (codePoint > 0xD7FF && codePoint < 0xE000) {       last char was a lead      if (!leadSurrogate) {         no lead yet        if (codePoint > 0xDBFF) {           unexpected trail          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)          continue        } else if (i + 1 === length) {           unpaired lead          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)          continue        }
         valid lead        leadSurrogate = codePoint
        continue      }
       2 leads in a row      if (codePoint < 0xDC00) {        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)        leadSurrogate = codePoint        continue      }
       valid surrogate pair      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000    } else if (leadSurrogate) {       valid bmp char, but last char was a lead      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)    }
    leadSurrogate = null
     encode utf8    if (codePoint < 0x80) {      if ((units -= 1) < 0) break      bytes.push(codePoint)    } else if (codePoint < 0x800) {      if ((units -= 2) < 0) break      bytes.push(        codePoint >> 0x6 | 0xC0,        codePoint & 0x3F | 0x80      )    } else if (codePoint < 0x10000) {      if ((units -= 3) < 0) break      bytes.push(        codePoint >> 0xC | 0xE0,        codePoint >> 0x6 & 0x3F | 0x80,        codePoint & 0x3F | 0x80      )    } else if (codePoint < 0x110000) {      if ((units -= 4) < 0) break      bytes.push(        codePoint >> 0x12 | 0xF0,        codePoint >> 0xC & 0x3F | 0x80,        codePoint >> 0x6 & 0x3F | 0x80,        codePoint & 0x3F | 0x80      )    } else {      throw new Error(Invalid code point)    }  }
  return bytes}
function asciiToBytes (str) {  var byteArray = []  for (var i = 0; i < str.length; ++i) {     Node's code seems to be doing this and not & 0x7F..    byteArray.push(str.charCodeAt(i) & 0xFF)  }  return byteArray}
function utf16leToBytes (str, units) {  var c, hi, lo  var byteArray = []  for (var i = 0; i < str.length; ++i) {    if ((units -= 2) < 0) break
    c = str.charCodeAt(i)    hi = c >> 8    lo = c % 256    byteArray.push(lo)    byteArray.push(hi)  }
  return byteArray}
function base64ToBytes (str) {  return base64.toByteArray(base64clean(str))}
function blitBuffer (src, dst, offset, length) {  for (var i = 0; i < length; ++i) {    if ((i + offset >= dst.length) || (i >= src.length)) break    dst[i + offset] = src[i]  }  return i}
function isnan (val) {  return val !== val  eslint-disable-line no-self-compare}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{base64-js:39,ieee754:50,isarray:53}],45:[function(require,module,exports){(function (Buffer){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 NOTE: These type checking functions intentionally don't use `instanceof` because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {  if (Array.isArray) {    return Array.isArray(arg);  }  return objectToString(arg) === [object Array];}exports.isArray = isArray;
function isBoolean(arg) {  return typeof arg === boolean;}exports.isBoolean = isBoolean;
function isNull(arg) {  return arg === null;}exports.isNull = isNull;
function isNullOrUndefined(arg) {  return arg == null;}exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {  return typeof arg === number;}exports.isNumber = isNumber;
function isString(arg) {  return typeof arg === string;}exports.isString = isString;
function isSymbol(arg) {  return typeof arg === symbol;}exports.isSymbol = isSymbol;
function isUndefined(arg) {  return arg === void 0;}exports.isUndefined = isUndefined;
function isRegExp(re) {  return objectToString(re) === [object RegExp];}exports.isRegExp = isRegExp;
function isObject(arg) {  return typeof arg === object && arg !== null;}exports.isObject = isObject;
function isDate(d) {  return objectToString(d) === [object Date];}exports.isDate = isDate;
function isError(e) {  return (objectToString(e) === [object Error] || e instanceof Error);}exports.isError = isError;
function isFunction(arg) {  return typeof arg === function;}exports.isFunction = isFunction;
function isPrimitive(arg) {  return arg === null ||         typeof arg === boolean ||         typeof arg === number ||         typeof arg === string ||         typeof arg === symbol ||   ES6 symbol         typeof arg === undefined;}exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;
function objectToString(o) {  return Object.prototype.toString.call(o);}
}).call(this,{isBuffer:require(../../is-buffer/index.js)})},{../../is-buffer/index.js:52}],46:[function(require,module,exports){/* See LICENSE file for terms of use */
/* * Text diff implementation. * * This library supports the following APIS: * JsDiff.diffChars: Character by character diff * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace * JsDiff.diffLines: Line based diff * * JsDiff.diffCss: Diff targeted at CSS content * * These methods are based on the implementation proposed in * ""An O(ND) Difference Algorithm and its Variations"" (Myers, 1986). * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927 */(function(global, undefined) {  var objectPrototypeToString = Object.prototype.toString;
  /*istanbul ignore next*/  function map(arr, mapper, that) {    if (Array.prototype.map) {      return Array.prototype.map.call(arr, mapper, that);    }
    var other = new Array(arr.length);
    for (var i = 0, n = arr.length; i < n; i++) {      other[i] = mapper.call(that, arr[i], i, arr);    }    return other;  }  function clonePath(path) {    return { newPos: path.newPos, components: path.components.slice(0) };  }  function removeEmpty(array) {    var ret = [];    for (var i = 0; i < array.length; i++) {      if (array[i]) {        ret.push(array[i]);      }    }    return ret;  }  function escapeHTML(s) {    var n = s;    n = n.replace(&g, &amp;);    n = n.replace(<g, &lt;);    n = n.replace(>g, &gt;);    n = n.replace(""g, &quot;);
    return n;  }
   This function handles the presence of circular references by bailing out when encountering an   object that is already on the ""stack"" of items being processed.  function canonicalize(obj, stack, replacementStack) {    stack = stack || [];    replacementStack = replacementStack || [];
    var i;
    for (i = 0; i < stack.length; i += 1) {      if (stack[i] === obj) {        return replacementStack[i];      }    }
    var canonicalizedObj;
    if ([object Array] === objectPrototypeToString.call(obj)) {      stack.push(obj);      canonicalizedObj = new Array(obj.length);      replacementStack.push(canonicalizedObj);      for (i = 0; i < obj.length; i += 1) {        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);      }      stack.pop();      replacementStack.pop();    } else if (typeof obj === object && obj !== null) {      stack.push(obj);      canonicalizedObj = {};      replacementStack.push(canonicalizedObj);      var sortedKeys = [],          key;      for (key in obj) {        sortedKeys.push(key);      }      sortedKeys.sort();      for (i = 0; i < sortedKeys.length; i += 1) {        key = sortedKeys[i];        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);      }      stack.pop();      replacementStack.pop();    } else {      canonicalizedObj = obj;    }    return canonicalizedObj;  }
  function buildValues(components, newString, oldString, useLongestToken) {    var componentPos = 0,        componentLen = components.length,        newPos = 0,        oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {      var component = components[componentPos];      if (!component.removed) {        if (!component.added && useLongestToken) {          var value = newString.slice(newPos, newPos + component.count);          value = map(value, function(value, i) {            var oldValue = oldString[oldPos + i];            return oldValue.length > value.length ? oldValue : value;          });
          component.value = value.join();        } else {          component.value = newString.slice(newPos, newPos + component.count).join();        }        newPos += component.count;
         Common case        if (!component.added) {          oldPos += component.count;        }      } else {        component.value = oldString.slice(oldPos, oldPos + component.count).join();        oldPos += component.count;
         Reverse add and remove so removes are output first to match common convention         The diffing algorithm is tied to add then remove output and this is the simplest         route to get the desired output with minimal overhead.        if (componentPos && components[componentPos - 1].added) {          var tmp = components[componentPos - 1];          components[componentPos - 1] = components[componentPos];          components[componentPos] = tmp;        }      }    }
    return components;  }
  function Diff(ignoreWhitespace) {    this.ignoreWhitespace = ignoreWhitespace;  }  Diff.prototype = {    diff: function(oldString, newString, callback) {      var self = this;
      function done(value) {        if (callback) {          setTimeout(function() { callback(undefined, value); }, 0);          return true;        } else {          return value;        }      }
       Handle the identity case (this is due to unrolling editLength == 0      if (newString === oldString) {        return done([{ value: newString }]);      }      if (!newString) {        return done([{ value: oldString, removed: true }]);      }      if (!oldString) {        return done([{ value: newString, added: true }]);      }
      newString = this.tokenize(newString);      oldString = this.tokenize(oldString);
      var newLen = newString.length, oldLen = oldString.length;      var editLength = 1;      var maxEditLength = newLen + oldLen;      var bestPath = [{ newPos: -1, components: [] }];
       Seed editLength = 0, i.e. the content starts with the same values      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {         Identity per the equality and tokenizer        return done([{value: newString.join()}]);      }
       Main worker method. checks all permutations of a given edit length for acceptance.      function execEditLength() {        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {          var basePath;          var addPath = bestPath[diagonalPath - 1],              removePath = bestPath[diagonalPath + 1],              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;          if (addPath) {             No one else is going to attempt to use this value, clear it            bestPath[diagonalPath - 1] = undefined;          }
          var canAdd = addPath && addPath.newPos + 1 < newLen,              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;          if (!canAdd && !canRemove) {             If this path is a terminal then prune            bestPath[diagonalPath] = undefined;            continue;          }
           Select the diagonal that we want to branch from. We select the prior           path whose position in the new string is the farthest from the origin           and does not pass the bounds of the diff graph          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {            basePath = clonePath(removePath);            self.pushComponent(basePath.components, undefined, true);          } else {            basePath = addPath;    No need to clone, we've pulled it from the list            basePath.newPos++;            self.pushComponent(basePath.components, true, undefined);          }
          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
           If we have hit the end of both strings, then we are done          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));          } else {             Otherwise track this path as a potential candidate and continue.            bestPath[diagonalPath] = basePath;          }        }
        editLength++;      }
       Performs the length of edit iteration. Is a bit fugly as this has to support the       sync and async mode which is never fun. Loops over execEditLength until a value       is produced.      if (callback) {        (function exec() {          setTimeout(function() {             This should not happen, but we want to be safe.            /*istanbul ignore next */            if (editLength > maxEditLength) {              return callback();            }
            if (!execEditLength()) {              exec();            }          }, 0);        }());      } else {        while (editLength <= maxEditLength) {          var ret = execEditLength();          if (ret) {            return ret;          }        }      }    },
    pushComponent: function(components, added, removed) {      var last = components[components.length - 1];      if (last && last.added === added && last.removed === removed) {         We need to clone here as the component clone operation is just         as shallow array clone        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };      } else {        components.push({count: 1, added: added, removed: removed });      }    },    extractCommon: function(basePath, newString, oldString, diagonalPath) {      var newLen = newString.length,          oldLen = oldString.length,          newPos = basePath.newPos,          oldPos = newPos - diagonalPath,
          commonCount = 0;      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {        newPos++;        oldPos++;        commonCount++;      }
      if (commonCount) {        basePath.components.push({count: commonCount});      }
      basePath.newPos = newPos;      return oldPos;    },
    equals: function(left, right) {      var reWhitespace = ;      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));    },    tokenize: function(value) {      return value.split();    }  };
  var CharDiff = new Diff();
  var WordDiff = new Diff(true);  var WordWithSpaceDiff = new Diff();  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {    return removeEmpty(value.split(()));  };
  var CssDiff = new Diff(true);  CssDiff.tokenize = function(value) {    return removeEmpty(value.split(()));  };
  var LineDiff = new Diff();
  var TrimmedLineDiff = new Diff();  TrimmedLineDiff.ignoreTrim = true;
  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {    var retLines = [],        lines = value.split(m);    for (var i = 0; i < lines.length; i++) {      var line = lines[i],          lastLine = lines[i - 1],          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];
       Merge lines that may contain windows new lines      if (line ===  && lastLineLastChar === ) {          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + ;      } else {        if (this.ignoreTrim) {          line = line.trim();           add a newline unless this is the last line.          if (i < lines.length - 1) {            line += ;          }        }        retLines.push(line);      }    }
    return retLines;  };
  var PatchDiff = new Diff();  PatchDiff.tokenize = function(value) {    var ret = [],        linesAndNewlines = value.split(());
     Ignore the final empty token that occurs if the string ends with a new line    if (!linesAndNewlines[linesAndNewlines.length - 1]) {      linesAndNewlines.pop();    }
     Merge the content and line separators into single tokens    for (var i = 0; i < linesAndNewlines.length; i++) {      var line = linesAndNewlines[i];
      if (i % 2) {        ret[ret.length - 1] += line;      } else {        ret.push(line);      }    }    return ret;  };
  var SentenceDiff = new Diff();  SentenceDiff.tokenize = function(value) {    return removeEmpty(value.split(()(?=)));  };
  var JsonDiff = new Diff();   Discriminate between two lines of pretty-printed, serialized JSON where one of them has a   dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:  JsonDiff.useLongestToken = true;  JsonDiff.tokenize = LineDiff.tokenize;  JsonDiff.equals = function(left, right) {    return LineDiff.equals(left.replace(,()g, $1), right.replace(,()g, $1));  };
  var JsDiff = {    Diff: Diff,
    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },
    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },
    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },    diffJson: function(oldObj, newObj, callback) {      return JsonDiff.diff(        typeof oldObj === string ? oldObj : JSON.stringify(canonicalize(oldObj), undefined,   ),        typeof newObj === string ? newObj : JSON.stringify(canonicalize(newObj), undefined,   ),        callback      );    },
    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {      var ret = [];
      if (oldFileName == newFileName) {        ret.push(Index:  + oldFileName);      }      ret.push(===================================================================);      ret.push(---  + oldFileName + (typeof oldHeader === undefined ?  :  + oldHeader));      ret.push(+++  + newFileName + (typeof newHeader === undefined ?  :  + newHeader));
      var diff = PatchDiff.diff(oldStr, newStr);      diff.push({value: , lines: []});    Append an empty value to make cleanup easier
       Formats a given set of lines for printing as context lines in a patch      function contextLines(lines) {        return map(lines, function(entry) { return   + entry; });      }
       Outputs the no newline at end of file warning if needed      function eofNL(curRange, i, current) {        var last = diff[diff.length - 2],            isLast = i === diff.length - 2,            isLastOfType = i === diff.length - 3 && current.added !== last.added;
         Figure out if this is the last line for the given file and missing NL        if (!(.test(current.value)) && (isLast || isLastOfType)) {          curRange.push( No newline at end of file);        }      }
      var oldRangeStart = 0, newRangeStart = 0, curRange = [],          oldLine = 1, newLine = 1;      for (var i = 0; i < diff.length; i++) {        var current = diff[i],            lines = current.lines || current.value.replace(, ).split();        current.lines = lines;
        if (current.added || current.removed) {           If we have previous context, start with that          if (!oldRangeStart) {            var prev = diff[i - 1];            oldRangeStart = oldLine;            newRangeStart = newLine;
            if (prev) {              curRange = contextLines(prev.lines.slice(-4));              oldRangeStart -= curRange.length;              newRangeStart -= curRange.length;            }          }
           Output our changes          curRange.push.apply(curRange, map(lines, function(entry) {            return (current.added ? + : -) + entry;          }));          eofNL(curRange, i, current);
           Track the updated file position          if (current.added) {            newLine += lines.length;          } else {            oldLine += lines.length;          }        } else {           Identical context lines. Track line changes          if (oldRangeStart) {             Close out any changes that have been output (or join overlapping)            if (lines.length <= 8 && i < diff.length - 2) {               Overlapping              curRange.push.apply(curRange, contextLines(lines));            } else {               end the range and output              var contextSize = Math.min(lines.length, 4);              ret.push(                  @@ - + oldRangeStart + , + (oldLine - oldRangeStart + contextSize)                  +  + + newRangeStart + , + (newLine - newRangeStart + contextSize)                  +  @@);              ret.push.apply(ret, curRange);              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));              if (lines.length <= 4) {                eofNL(ret, i, current);              }
              oldRangeStart = 0;              newRangeStart = 0;              curRange = [];            }          }          oldLine += lines.length;          newLine += lines.length;        }      }
      return ret.join() + ;    },
    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);    },
    applyPatch: function(oldStr, uniDiff) {      var diffstr = uniDiff.split(),          hunks = [],          i = 0,          remEOFNL = false,          addEOFNL = false;
       Skip to the first change hunk      while (i < diffstr.length && !(@@.test(diffstr[i]))) {        i++;      }
       Parse the unified diff      for (; i < diffstr.length; i++) {        if (diffstr[i][0] === @) {          var chnukHeader = diffstr[i].split(@@ -(),() (),() @@);          hunks.unshift({            start: chnukHeader[3],            oldlength: +chnukHeader[2],            removed: [],            newlength: chnukHeader[4],            added: []          });        } else if (diffstr[i][0] === +) {          hunks[0].added.push(diffstr[i].substr(1));        } else if (diffstr[i][0] === -) {          hunks[0].removed.push(diffstr[i].substr(1));        } else if (diffstr[i][0] ===  ) {          hunks[0].added.push(diffstr[i].substr(1));          hunks[0].removed.push(diffstr[i].substr(1));        } else if (diffstr[i][0] === ) {          if (diffstr[i - 1][0] === +) {            remEOFNL = true;          } else if (diffstr[i - 1][0] === -) {            addEOFNL = true;          }        }      }
       Apply the diff to the input      var lines = oldStr.split();      for (i = hunks.length - 1; i >= 0; i--) {        var hunk = hunks[i];         Sanity check the input string. Bail if we don't match.        for (var j = 0; j < hunk.oldlength; j++) {          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {            return false;          }        }        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));      }
       Handle EOFNL insertion/removal      if (remEOFNL) {        while (!lines[lines.length - 1]) {          lines.pop();        }      } else if (addEOFNL) {        lines.push();      }      return lines.join();    },
    convertChangesToXML: function(changes) {      var ret = [];      for (var i = 0; i < changes.length; i++) {        var change = changes[i];        if (change.added) {          ret.push(<ins>);        } else if (change.removed) {          ret.push(<del>);        }
        ret.push(escapeHTML(change.value));
        if (change.added) {          ret.push(</ins>);        } else if (change.removed) {          ret.push(</del>);        }      }      return ret.join();    },
     See: http://code.google.com/p/google-diff-match-patch/wiki/API    convertChangesToDMP: function(changes) {      var ret = [],          change,          operation;      for (var i = 0; i < changes.length; i++) {        change = changes[i];        if (change.added) {          operation = 1;        } else if (change.removed) {          operation = -1;        } else {          operation = 0;        }
        ret.push([operation, change.value]);      }      return ret;    },
    canonicalize: canonicalize  };
  /*istanbul ignore next */  /*global module */  if (typeof module !== undefined && module.exports) {    module.exports = JsDiff;  } else if (false) {    /*global define */    define([], function() { return JsDiff; });  } else if (typeof global.JsDiff === undefined) {    global.JsDiff = JsDiff;  }}(this));
},{}],47:[function(require,module,exports){use strict;
var matchOperatorsRe = g;
module.exports = function (str) {	if (typeof str !== string) {		throw new TypeError(Expected a string);	}
	return str.replace(matchOperatorsRe, $&);};
},{}],48:[function(require,module,exports){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter() {  this._events = this._events || {};  this._maxListeners = this._maxListeners || undefined;}module.exports = EventEmitter;
 Backwards-compat with node 0.10.xEventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;EventEmitter.prototype._maxListeners = undefined;
 By default EventEmitters will print a warning if more than 10 listeners are added to it. This is a useful default which helps finding memory leaks.EventEmitter.defaultMaxListeners = 10;
 Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.EventEmitter.prototype.setMaxListeners = function(n) {  if (!isNumber(n) || n < 0 || isNaN(n))    throw TypeError(n must be a positive number);  this._maxListeners = n;  return this;};
EventEmitter.prototype.emit = function(type) {  var er, handler, len, args, i, listeners;
  if (!this._events)    this._events = {};
   If there is no 'error' event listener then throw.  if (type === error) {    if (!this._events.error ||        (isObject(this._events.error) && !this._events.error.length)) {      er = arguments[1];      if (er instanceof Error) {        throw er;  Unhandled 'error' event      } else {         At least give some kind of context to the user        var err = new Error(Uncaught, unspecified ""error"" event. ( + er + ));        err.context = er;        throw err;      }    }  }
  handler = this._events[type];
  if (isUndefined(handler))    return false;
  if (isFunction(handler)) {    switch (arguments.length) {       fast cases      case 1:        handler.call(this);        break;      case 2:        handler.call(this, arguments[1]);        break;      case 3:        handler.call(this, arguments[1], arguments[2]);        break;       slower      default:        args = Array.prototype.slice.call(arguments, 1);        handler.apply(this, args);    }  } else if (isObject(handler)) {    args = Array.prototype.slice.call(arguments, 1);    listeners = handler.slice();    len = listeners.length;    for (i = 0; i < len; i++)      listeners[i].apply(this, args);  }
  return true;};
EventEmitter.prototype.addListener = function(type, listener) {  var m;
  if (!isFunction(listener))    throw TypeError(listener must be a function);
  if (!this._events)    this._events = {};
   To avoid recursion in the case that type === ""newListener""! Before   adding it to the listeners, first emit ""newListener"".  if (this._events.newListener)    this.emit(newListener, type,              isFunction(listener.listener) ?              listener.listener : listener);
  if (!this._events[type])     Optimize the case of one listener. Don't need the extra array object.    this._events[type] = listener;  else if (isObject(this._events[type]))     If we've already got an array, just append.    this._events[type].push(listener);  else     Adding the second element, need to change to array.    this._events[type] = [this._events[type], listener];
   Check for listener leak  if (isObject(this._events[type]) && !this._events[type].warned) {    if (!isUndefined(this._maxListeners)) {      m = this._maxListeners;    } else {      m = EventEmitter.defaultMaxListeners;    }
    if (m && m > 0 && this._events[type].length > m) {      this._events[type].warned = true;      console.error((node) warning: possible EventEmitter memory  +                    leak detected. %d listeners added.  +                    Use emitter.setMaxListeners() to increase limit.,                    this._events[type].length);      if (typeof console.trace === function) {         not supported in IE 10        console.trace();      }    }  }
  return this;};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.once = function(type, listener) {  if (!isFunction(listener))    throw TypeError(listener must be a function);
  var fired = false;
  function g() {    this.removeListener(type, g);
    if (!fired) {      fired = true;      listener.apply(this, arguments);    }  }
  g.listener = listener;  this.on(type, g);
  return this;};
 emits a 'removeListener' event iff the listener was removedEventEmitter.prototype.removeListener = function(type, listener) {  var list, position, length, i;
  if (!isFunction(listener))    throw TypeError(listener must be a function);
  if (!this._events || !this._events[type])    return this;
  list = this._events[type];  length = list.length;  position = -1;
  if (list === listener ||      (isFunction(list.listener) && list.listener === listener)) {    delete this._events[type];    if (this._events.removeListener)      this.emit(removeListener, type, listener);
  } else if (isObject(list)) {    for (i = length; i-- > 0;) {      if (list[i] === listener ||          (list[i].listener && list[i].listener === listener)) {        position = i;        break;      }    }
    if (position < 0)      return this;
    if (list.length === 1) {      list.length = 0;      delete this._events[type];    } else {      list.splice(position, 1);    }
    if (this._events.removeListener)      this.emit(removeListener, type, listener);  }
  return this;};
EventEmitter.prototype.removeAllListeners = function(type) {  var key, listeners;
  if (!this._events)    return this;
   not listening for removeListener, no need to emit  if (!this._events.removeListener) {    if (arguments.length === 0)      this._events = {};    else if (this._events[type])      delete this._events[type];    return this;  }
   emit removeListener for all listeners on all events  if (arguments.length === 0) {    for (key in this._events) {      if (key === removeListener) continue;      this.removeAllListeners(key);    }    this.removeAllListeners(removeListener);    this._events = {};    return this;  }
  listeners = this._events[type];
  if (isFunction(listeners)) {    this.removeListener(type, listeners);  } else if (listeners) {     LIFO order    while (listeners.length)      this.removeListener(type, listeners[listeners.length - 1]);  }  delete this._events[type];
  return this;};
EventEmitter.prototype.listeners = function(type) {  var ret;  if (!this._events || !this._events[type])    ret = [];  else if (isFunction(this._events[type]))    ret = [this._events[type]];  else    ret = this._events[type].slice();  return ret;};
EventEmitter.prototype.listenerCount = function(type) {  if (this._events) {    var evlistener = this._events[type];
    if (isFunction(evlistener))      return 1;    else if (evlistener)      return evlistener.length;  }  return 0;};
EventEmitter.listenerCount = function(emitter, type) {  return emitter.listenerCount(type);};
function isFunction(arg) {  return typeof arg === function;}
function isNumber(arg) {  return typeof arg === number;}
function isObject(arg) {  return typeof arg === object && arg !== null;}
function isUndefined(arg) {  return arg === void 0;}
},{}],49:[function(require,module,exports){(function (process){ Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)
/** * Module dependencies. */
var exec = require(child_process).exec  , fs = require(fs)  , path = require(path)  , exists = fs.existsSync || path.existsSync  , os = require(os)  , quote = JSON.stringify  , cmd;
function which(name) {  var paths = process.env.PATH.split(:);  var loc;
  for (var i = 0, len = paths.length; i < len; ++i) {    loc = path.join(paths[i], name);    if (exists(loc)) return loc;  }}
switch(os.type()) {  case Darwin:    if (which(terminal-notifier)) {      cmd = {          type: Darwin-NotificationCenter        , pkg: terminal-notifier        , msg: -message        , title: -title        , subtitle: -subtitle        , icon: -appIcon        , sound:  -sound        , url: -open        , priority: {              cmd: -execute            , range: []          }      };    } else {      cmd = {          type: Darwin-Growl        , pkg: growlnotify        , msg: -m        , sticky: --sticky        , priority: {              cmd: --priority            , range: [                -2              , -1              , 0              , 1              , 2              , Very Low              , Moderate              , Normal              , High              , Emergency            ]          }      };    }    break;  case Linux:    if (which(growl)) {      cmd = {          type: Linux-Growl        , pkg: growl        , msg: -m        , title: -title        , subtitle: -subtitle        , host: {            cmd: -H          , hostname: 192.168.33.1        }      };    } else {      cmd = {          type: Linux        , pkg: notify-send        , msg:         , sticky: -t 0        , icon: -i        , priority: {            cmd: -u          , range: [              low            , normal            , critical          ]        }      };    }    break;  case Windows_NT:    cmd = {        type: Windows      , pkg: growlnotify      , msg:       , sticky: /s:true      , title: /t:      , icon: /i:      , url: /cu:      , priority: {            cmd: /p:          , range: [              -2            , -1            , 0            , 1            , 2          ]        }    };    break;}
/** * Expose `growl`. */
exports = module.exports = growl;
/** * Node-growl version. */
exports.version = 1.4.1
/** * Send growl notification _msg_ with _options_. * * Options: * *  - title   Notification title *  - sticky  Make the notification stick (defaults to false) *  - priority  Specify an int or named key (default is 0) *  - name    Application name (defaults to growlnotify) *  - sound   Sound efect ( in OSx defined in preferences -> sound -> effects) * works only in OSX > 10.8x *  - image *    - path to an icon sets --iconpath *    - path to an image sets --image *    - capitalized word sets --appIcon *    - filename uses extname as --icon *    - otherwise treated as --icon * * Examples: * *   growl('New email') *   growl('5 new emails', { title: 'Thunderbird' }) *   growl('5 new emails', { title: 'Thunderbird', sound: 'Purr' }) *   growl('Email sent', function(){ *     // ... notification sent *   }) * *    *    *    * @api public */
function growl(msg, options, fn) {  var image    , args    , options = options || {}    , fn = fn || function(){};
  if (options.exec) {    cmd = {        type: Custom      , pkg: options.exec      , range: []    };  }
   noop  if (!cmd) return fn(new Error(growl not supported on this platform));  args = [cmd.pkg];
   image  if (image = options.image) {    switch(cmd.type) {      case Darwin-Growl:        var flag, ext = path.extname(image).substr(1)        flag = flag || ext == icns && iconpath        flag = flag || .test(image) && appIcon        flag = flag || pnggifjpeg.test(ext) && image        flag = flag || ext && (image = ext) && icon        flag = flag || icon        args.push(-- + flag, quote(image))        break;      case Darwin-NotificationCenter:        args.push(cmd.icon, quote(image));        break;      case Linux:        args.push(cmd.icon, quote(image));         libnotify defaults to sticky, set a hint for transient notifications        if (!options.sticky) args.push(--hint=int:transient:1);        break;      case Windows:        args.push(cmd.icon + quote(image));        break;    }  }
   sticky  if (options.sticky) args.push(cmd.sticky);
   priority  if (options.priority) {    var priority = options.priority + ;    var checkindexOf = cmd.priority.range.indexOf(priority);    if (~cmd.priority.range.indexOf(priority)) {      args.push(cmd.priority, options.priority);    }  }
  sound  if(options.sound && cmd.type === Darwin-NotificationCenter){    args.push(cmd.sound, options.sound)  }
   name  if (options.name && cmd.type === Darwin-Growl) {    args.push(--name, options.name);  }
  switch(cmd.type) {    case Darwin-Growl:      args.push(cmd.msg);      args.push(quote(msg).replace(ng, ));      if (options.title) args.push(quote(options.title));      break;    case Darwin-NotificationCenter:      args.push(cmd.msg);      var stringifiedMsg = quote(msg);      var escapedMsg = stringifiedMsg.replace(ng, );      args.push(escapedMsg);      if (options.title) {        args.push(cmd.title);        args.push(quote(options.title));      }      if (options.subtitle) {        args.push(cmd.subtitle);        args.push(quote(options.subtitle));      }      if (options.url) {        args.push(cmd.url);        args.push(quote(options.url));      }      break;    case Linux-Growl:      args.push(cmd.msg);      args.push(quote(msg).replace(ng, ));      if (options.title) args.push(quote(options.title));      if (cmd.host) {        args.push(cmd.host.cmd, cmd.host.hostname)      }      break;    case Linux:      if (options.title) {        args.push(quote(options.title));        args.push(cmd.msg);        args.push(quote(msg).replace(ng, ));      } else {        args.push(quote(msg).replace(ng, ));      }      break;    case Windows:      args.push(quote(msg).replace(ng, ));      if (options.title) args.push(cmd.title + quote(options.title));      if (options.url) args.push(cmd.url + quote(options.url));      break;    case Custom:      args[0] = (function(origCommand) {        var message = options.title          ? options.title + :  + msg          : msg;        var command = origCommand.replace(()%sg, $1 + quote(message));        if (command === origCommand) args.push(quote(message));        return command;      })(args[0]);      break;  }
   execute  exec(args.join( ), fn);};
}).call(this,require(_process))},{_process:67,child_process:42,fs:42,os:65,path:42}],50:[function(require,module,exports){exports.read = function (buffer, offset, isLE, mLen, nBytes) {  var e, m  var eLen = nBytes * 8 - mLen - 1  var eMax = (1 << eLen) - 1  var eBias = eMax >> 1  var nBits = -7  var i = isLE ? (nBytes - 1) : 0  var d = isLE ? -1 : 1  var s = buffer[offset + i]
  i += d
  e = s & ((1 << (-nBits)) - 1)  s >>= (-nBits)  nBits += eLen  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & ((1 << (-nBits)) - 1)  e >>= (-nBits)  nBits += mLen  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {    e = 1 - eBias  } else if (e === eMax) {    return m ? NaN : ((s ? -1 : 1) * Infinity)  } else {    m = m + Math.pow(2, mLen)    e = e - eBias  }  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)}
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {  var e, m, c  var eLen = nBytes * 8 - mLen - 1  var eMax = (1 << eLen) - 1  var eBias = eMax >> 1  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)  var i = isLE ? 0 : (nBytes - 1)  var d = isLE ? 1 : -1  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
  value = Math.abs(value)
  if (isNaN(value) || value === Infinity) {    m = isNaN(value) ? 1 : 0    e = eMax  } else {    e = Math.floor(Math.log(value) / Math.LN2)    if (value * (c = Math.pow(2, -e)) < 1) {      e--      c *= 2    }    if (e + eBias >= 1) {      value += rt / c    } else {      value += rt * Math.pow(2, 1 - eBias)    }    if (value * c >= 2) {      e++      c /= 2    }
    if (e + eBias >= eMax) {      m = 0      e = eMax    } else if (e + eBias >= 1) {      m = (value * c - 1) * Math.pow(2, mLen)      e = e + eBias    } else {      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)      e = 0    }  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = (e << mLen) | m  eLen += mLen  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128}
},{}],51:[function(require,module,exports){if (typeof Object.create === function) {   implementation from standard node.js 'util' module  module.exports = function inherits(ctor, superCtor) {    ctor.super_ = superCtor    ctor.prototype = Object.create(superCtor.prototype, {      constructor: {        value: ctor,        enumerable: false,        writable: true,        configurable: true      }    });  };} else {   old school shim for old browsers  module.exports = function inherits(ctor, superCtor) {    ctor.super_ = superCtor    var TempCtor = function () {}    TempCtor.prototype = superCtor.prototype    ctor.prototype = new TempCtor()    ctor.prototype.constructor = ctor  }}
},{}],52:[function(require,module,exports){/*! * Determine if an object is a Buffer * * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license  MIT */
 The _isBuffer check is for Safari 5-7 support, because it's missing Object.prototype.constructor. Remove this eventuallymodule.exports = function (obj) {  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)}
function isBuffer (obj) {  return !!obj.constructor && typeof obj.constructor.isBuffer === function && obj.constructor.isBuffer(obj)}
 For Node v0.10 support. Remove this eventually.function isSlowBuffer (obj) {  return typeof obj.readFloatLE === function && typeof obj.slice === function && isBuffer(obj.slice(0, 0))}
},{}],53:[function(require,module,exports){var toString = {}.toString;
module.exports = Array.isArray || function (arr) {  return toString.call(arr) == [object Array];};
},{}],54:[function(require,module,exports){(function (global){/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */;(function () {   Detect the `define` function exposed by asynchronous module loaders. The   strict `define` check is necessary for compatibility with `r.js`.  var isLoader = false;
   A set of types used to distinguish objects from primitives.  var objectTypes = {    function: true,    object: true  };
   Detect the `exports` object exposed by CommonJS implementations.  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
   Use the `global` object exposed by Node (including Browserify via   `insert-module-globals`), Narwhal, and Ringo as the default context,   and the `window` object in browsers. Rhino exports a `global` function   instead.  var root = objectTypes[typeof window] && window || this,      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == object && global;
  if (freeGlobal && (freeGlobal[global] === freeGlobal || freeGlobal[window] === freeGlobal || freeGlobal[self] === freeGlobal)) {    root = freeGlobal;  }
   Public: Initializes JSON 3 using the given `context` object, attaching the   `stringify` and `parse` functions to the specified `exports` object.  function runInContext(context, exports) {    context || (context = root[Object]());    exports || (exports = root[Object]());
     Native constructor aliases.    var Number = context[Number] || root[Number],        String = context[String] || root[String],        Object = context[Object] || root[Object],        Date = context[Date] || root[Date],        SyntaxError = context[SyntaxError] || root[SyntaxError],        TypeError = context[TypeError] || root[TypeError],        Math = context[Math] || root[Math],        nativeJSON = context[JSON] || root[JSON];
     Delegate to the native `stringify` and `parse` implementations.    if (typeof nativeJSON == object && nativeJSON) {      exports.stringify = nativeJSON.stringify;      exports.parse = nativeJSON.parse;    }
     Convenience aliases.    var objectProto = Object.prototype,        getClass = objectProto.toString,        isProperty, forEach, undef;
     Test the `Date#getUTC*` methods. Based on work by @Yaffle.    var isExtended = new Date(-3509827334573292);    try {       The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical       results for certain dates in Opera >= 10.53.      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&         Safari < 2.0.2 stores the internal millisecond time value correctly,         but clips the values returned by the date methods to the range of         signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;    } catch (exception) {}
     Internal: Determines whether the native `JSON.stringify` and `parse`     implementations are spec-compliant. Based on work by Ken Snyder.    function has(name) {      if (has[name] !== undef) {         Return cached feature test result.        return has[name];      }      var isSupported;      if (name == bug-string-char-index) {         IE <= 7 doesn't support accessing string characters using square         bracket notation. IE 8 only supports this for primitives.        isSupported = a[0] != a;      } else if (name == json) {         Indicates whether both `JSON.stringify` and `JSON.parse` are         supported.        isSupported = has(json-stringify) && has(json-parse);      } else {        var value, serialized = {""a"":[1,true,false,null,""u0000bnfrt""]};         Test `JSON.stringify`.        if (name == json-stringify) {          var stringify = exports.stringify, stringifySupported = typeof stringify == function && isExtended;          if (stringifySupported) {             A test function object with a custom `toJSON` method.            (value = function () {              return 1;            }).toJSON = value;            try {              stringifySupported =                 Firefox 3.1b1 and b2 serialize string, number, and boolean                 primitives as object literals.                stringify(0) === 0 &&                 FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object                 literals.                stringify(new Number()) === 0 &&                stringify(new String()) == """" &&                 FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or                 does not define a canonical JSON representation (this applies to                 objects with `toJSON` properties as well, *unless* they are nested                 within an object or array).                stringify(getClass) === undef &&                 IE 8 serializes `undefined` as `""undefined""`. Safari <= 5.1.7 and                 FF 3.1b3 pass this test.                stringify(undef) === undef &&                 Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,                 respectively, if the value is omitted entirely.                stringify() === undef &&                 FF 3.1b1, 2 throw an error if the given value is not a number,                 string, array, object, Boolean, or `null` literal. This applies to                 objects with custom `toJSON` methods as well, unless they are nested                 inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`                 methods entirely.                stringify(value) === 1 &&                stringify([value]) == [1] &&                 Prototype <= 1.6.1 serializes `[undefined]` as `""[]""` instead of                 `""[null]""`.                stringify([undef]) == [null] &&                 YUI 3.0.0b1 fails to serialize `null` literals.                stringify(null) == null &&                 FF 3.1b1, 2 halts serialization if an array contains a function:                 `[1, true, getClass, 1]` serializes as ""[1,true,],"". FF 3.1b3                 elides non-JSON values from objects and arrays, unless they                 define custom `toJSON` methods.                stringify([undef, getClass, null]) == [null,null,null] &&                 Simple serialization test. FF 3.1b1 uses Unicode escape sequences                 where character escape codes are expected (e.g., `\b` => `\u0008`).                stringify({ a: [value, true, false, null, 00] }) == serialized &&                 FF 3.1b1 and b2 ignore the `filter` and `width` arguments.                stringify(null, value) === 1 &&                stringify([1, 2], null, 1) == [ 1, 2] &&                 JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly                 serialize extended years.                stringify(new Date(-8.64e15)) == ""-271821-04-20T00:00:00.000Z"" &&                 The milliseconds are optional in ES 5, but required in 5.1.                stringify(new Date(8.64e15)) == ""+275760-09-13T00:00:00.000Z"" &&                 Firefox <= 11.0 incorrectly serializes years prior to 0 as negative                 four-digit years instead of six-digit years. Credits: @Yaffle.                stringify(new Date(-621987552e5)) == ""-000001-01-01T00:00:00.000Z"" &&                 Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond                 values less than 1000. Credits: @Yaffle.                stringify(new Date(-1)) == ""1969-12-31T23:59:59.999Z"";            } catch (exception) {              stringifySupported = false;            }          }          isSupported = stringifySupported;        }         Test `JSON.parse`.        if (name == json-parse) {          var parse = exports.parse;          if (typeof parse == function) {            try {               FF 3.1b1, b2 will throw an exception if a bare literal is provided.               Conforming implementations should also coerce the initial argument to               a string prior to parsing.              if (parse(0) === 0 && !parse(false)) {                 Simple parsing test.                value = parse(serialized);                var parseSupported = value[a].length == 5 && value[a][0] === 1;                if (parseSupported) {                  try {                     Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.                    parseSupported = !parse("""");                  } catch (exception) {}                  if (parseSupported) {                    try {                       FF 4.0 and 4.0.1 allow leading `+` signs and leading                       decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow                       certain octal literals.                      parseSupported = parse(01) !== 1;                    } catch (exception) {}                  }                  if (parseSupported) {                    try {                       FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal                       points. These environments, along with FF 3.1b1 and 2,                       also allow trailing commas in JSON objects and arrays.                      parseSupported = parse(1.) !== 1;                    } catch (exception) {}                  }                }              }            } catch (exception) {              parseSupported = false;            }          }          isSupported = parseSupported;        }      }      return has[name] = !!isSupported;    }
    if (!has(json)) {       Common `[[Class]]` name aliases.      var functionClass = [object Function],          dateClass = [object Date],          numberClass = [object Number],          stringClass = [object String],          arrayClass = [object Array],          booleanClass = [object Boolean];
       Detect incomplete support for accessing string characters by index.      var charIndexBuggy = has(bug-string-char-index);
       Define additional utility methods if the `Date` methods are buggy.      if (!isExtended) {        var floor = Math.floor;         A mapping between the months of the year and the number of days between         January 1st and the first of the respective month.        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];         Internal: Calculates the number of days between the Unix epoch and the         first day of the given month.        var getDay = function (year, month) {          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);        };      }
       Internal: Determines if a property is a direct property of the given       object. Delegates to the native `Object#hasOwnProperty` method.      if (!(isProperty = objectProto.hasOwnProperty)) {        isProperty = function (property) {          var members = {}, constructor;          if ((members.__proto__ = null, members.__proto__ = {             The *proto* property cannot be set multiple times in recent             versions of Firefox and SeaMonkey.            toString: 1          }, members).toString != getClass) {             Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but             supports the mutable *proto* property.            isProperty = function (property) {               Capture and break the object's prototype chain (see section 8.6.2               of the ES 5.1 spec). The parenthesized expression prevents an               unsafe transformation by the Closure Compiler.              var original = this.__proto__, result = property in (this.__proto__ = null, this);               Restore the original prototype chain.              this.__proto__ = original;              return result;            };          } else {             Capture a reference to the top-level `Object` constructor.            constructor = members.constructor;             Use the `constructor` property to simulate `Object#hasOwnProperty` in             other environments.            isProperty = function (property) {              var parent = (this.constructor || constructor).prototype;              return property in this && !(property in parent && this[property] === parent[property]);            };          }          members = null;          return isProperty.call(this, property);        };      }
       Internal: Normalizes the `for...in` iteration algorithm across       environments. Each enumerated key is yielded to a `callback` function.      forEach = function (object, callback) {        var size = 0, Properties, members, property;
         Tests for bugs in the current environment's `for...in` algorithm. The         `valueOf` property inherits the non-enumerable flag from         `Object.prototype` in older versions of IE, Netscape, and Mozilla.        (Properties = function () {          this.valueOf = 0;        }).prototype.valueOf = 0;
         Iterate over a new instance of the `Properties` class.        members = new Properties();        for (property in members) {           Ignore all properties inherited from `Object.prototype`.          if (isProperty.call(members, property)) {            size++;          }        }        Properties = members = null;
         Normalize the iteration algorithm.        if (!size) {           A list of non-enumerable properties inherited from `Object.prototype`.          members = [valueOf, toString, toLocaleString, propertyIsEnumerable, isPrototypeOf, hasOwnProperty, constructor];           IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable           properties.          forEach = function (object, callback) {            var isFunction = getClass.call(object) == functionClass, property, length;            var hasProperty = !isFunction && typeof object.constructor != function && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;            for (property in object) {               Gecko <= 1.0 enumerates the `prototype` property of functions under               certain conditions; IE does not.              if (!(isFunction && property == prototype) && hasProperty.call(object, property)) {                callback(property);              }            }             Manually invoke the callback for each non-enumerable property.            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));          };        } else if (size == 2) {           Safari <= 2.0.4 enumerates shadowed properties twice.          forEach = function (object, callback) {             Create a set of iterated properties.            var members = {}, isFunction = getClass.call(object) == functionClass, property;            for (property in object) {               Store each property name to prevent double enumeration. The               `prototype` property of functions is not enumerated due to cross-               environment inconsistencies.              if (!(isFunction && property == prototype) && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {                callback(property);              }            }          };        } else {           No bugs detected; use the standard `for...in` algorithm.          forEach = function (object, callback) {            var isFunction = getClass.call(object) == functionClass, property, isConstructor;            for (property in object) {              if (!(isFunction && property == prototype) && isProperty.call(object, property) && !(isConstructor = property === constructor)) {                callback(property);              }            }             Manually invoke the callback for the `constructor` property due to             cross-environment inconsistencies.            if (isConstructor || isProperty.call(object, (property = constructor))) {              callback(property);            }          };        }        return forEach(object, callback);      };
       Public: Serializes a JavaScript `value` as a JSON string. The optional       `filter` argument may specify either a function that alters how object and       array members are serialized, or an array of strings and numbers that       indicates which properties should be serialized. The optional `width`       argument may be either a string or number that specifies the indentation       level of the output.      if (!has(json-stringify)) {         Internal: A map of control characters and their escaped equivalents.        var Escapes = {          92: ,          34: "",          8: b,          12: f,          10: n,          13: r,          9: t        };
         Internal: Converts `value` into a zero-padded string such that its         length is at least equal to `width`. The `width` must be <= 6.        var leadingZeroes = 000000;        var toPaddedString = function (width, value) {           The `|| 0` expression is necessary to work around a bug in           Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== ""0""`.          return (leadingZeroes + (value || 0)).slice(-width);        };
         Internal: Double-quotes a string `value`, replacing all ASCII control         characters (characters with code unit values between 0 and 31) with         their escaped equivalents. This is an implementation of the         `Quote(value)` operation defined in ES 5.1 section 15.12.3.        var unicodePrefix = u00;        var quote = function (value) {          var result = "", index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;          var symbols = useCharIndex && (charIndexBuggy ? value.split() : value);          for (; index < length; index++) {            var charCode = value.charCodeAt(index);             If the character is a control character, append its Unicode or             shorthand escape sequence; otherwise, append the character as-is.            switch (charCode) {              case 8: case 9: case 10: case 12: case 13: case 34: case 92:                result += Escapes[charCode];                break;              default:                if (charCode < 32) {                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));                  break;                }                result += useCharIndex ? symbols[index] : value.charAt(index);            }          }          return result + "";        };
         Internal: Recursively serializes an object. Implements the         `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;          try {             Necessary for host object support.            value = object[property];          } catch (exception) {}          if (typeof value == object && value) {            className = getClass.call(value);            if (className == dateClass && !isProperty.call(value, toJSON)) {              if (value > -1 / 0 && value < 1 / 0) {                 Dates are serialized according to the `Date#toJSON` method                 specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15                 for the ISO 8601 date time string format.                if (getDay) {                   Manually compute the year, month, date, hours, minutes,                   seconds, and milliseconds if the `getUTC*` methods are                   buggy. Adapted from @Yaffle's `date-shim` project.                  date = floor(value / 864e5);                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);                  date = 1 + date - getDay(year, month);                   The `time` value specifies the time within the day (see ES                   5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used                   to compute `A modulo B`, as the `%` operator does not                   correspond to the `modulo` operation for negative numbers.                  time = (value % 864e5 + 864e5) % 864e5;                   The hours, minutes, seconds, and milliseconds are obtained by                   decomposing the time within the day. See section 15.9.1.10.                  hours = floor(time / 36e5) % 24;                  minutes = floor(time / 6e4) % 60;                  seconds = floor(time / 1e3) % 60;                  milliseconds = time % 1e3;                } else {                  year = value.getUTCFullYear();                  month = value.getUTCMonth();                  date = value.getUTCDate();                  hours = value.getUTCHours();                  minutes = value.getUTCMinutes();                  seconds = value.getUTCSeconds();                  milliseconds = value.getUTCMilliseconds();                }                 Serialize extended years correctly.                value = (year <= 0 || year >= 1e4 ? (year < 0 ? - : +) + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +                  - + toPaddedString(2, month + 1) + - + toPaddedString(2, date) +                   Months, dates, hours, minutes, and seconds should have two                   digits; milliseconds should have three.                  T + toPaddedString(2, hours) + : + toPaddedString(2, minutes) + : + toPaddedString(2, seconds) +                   Milliseconds are optional in ES 5.0, but required in 5.1.                  . + toPaddedString(3, milliseconds) + Z;              } else {                value = null;              }            } else if (typeof value.toJSON == function && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, toJSON))) {               Prototype <= 1.6.1 adds non-standard `toJSON` methods to the               `Number`, `String`, `Date`, and `Array` prototypes. JSON 3               ignores all `toJSON` methods on these objects unless they are               defined directly on an instance.              value = value.toJSON(property);            }          }          if (callback) {             If a replacement function was provided, call it to obtain the value             for serialization.            value = callback.call(object, property, value);          }          if (value === null) {            return null;          }          className = getClass.call(value);          if (className == booleanClass) {             Booleans are represented literally.            return  + value;          } else if (className == numberClass) {             JSON numbers must be finite. `Infinity` and `NaN` are serialized as             `""null""`.            return value > -1 / 0 && value < 1 / 0 ?  + value : null;          } else if (className == stringClass) {             Strings are double-quoted and escaped.            return quote( + value);          }           Recursively serialize objects and arrays.          if (typeof value == object) {             Check for cyclic structures. This is a linear search; performance             is inversely proportional to the number of unique nested objects.            for (length = stack.length; length--;) {              if (stack[length] === value) {                 Cyclic structures cannot be serialized by `JSON.stringify`.                throw TypeError();              }            }             Add the object to the stack of traversed objects.            stack.push(value);            results = [];             Save the current indentation level and indent one additional level.            prefix = indentation;            indentation += whitespace;            if (className == arrayClass) {               Recursively serialize array elements.              for (index = 0, length = value.length; index < length; index++) {                element = serialize(index, value, callback, properties, whitespace, indentation, stack);                results.push(element === undef ? null : element);              }              result = results.length ? (whitespace ? [ + indentation + results.join(, + indentation) +  + prefix + ] : ([ + results.join(,) + ])) : [];            } else {               Recursively serialize object members. Members are selected from               either a user-specified list of property names, or the object               itself.              forEach(properties || value, function (property) {                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);                if (element !== undef) {                   According to ES 5.1 section 15.12.3: ""If `gap` {whitespace}                   is not the empty string, let `member` {quote(property) + "":""}                   be the concatenation of `member` and the `space` character.""                   The ""`space` character"" refers to the literal space                   character, not the `space` {width} argument provided to                   `JSON.stringify`.                  results.push(quote(property) + : + (whitespace ?   : ) + element);                }              });              result = results.length ? (whitespace ? { + indentation + results.join(, + indentation) +  + prefix + } : ({ + results.join(,) + })) : {};            }             Remove the object from the traversed object stack.            stack.pop();            return result;          }        };
         Public: `JSON.stringify`. See ES 5.1 section 15.12.3.        exports.stringify = function (source, filter, width) {          var whitespace, callback, properties, className;          if (objectTypes[typeof filter] && filter) {            if ((className = getClass.call(filter)) == functionClass) {              callback = filter;            } else if (className == arrayClass) {               Convert the property names array into a makeshift set.              properties = {};              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));            }          }          if (width) {            if ((className = getClass.call(width)) == numberClass) {               Convert the `width` to an integer and create a string containing               `width` number of space characters.              if ((width -= width % 1) > 0) {                for (whitespace = , width > 10 && (width = 10); whitespace.length < width; whitespace +=  );              }            } else if (className == stringClass) {              whitespace = width.length <= 10 ? width : width.slice(0, 10);            }          }           Opera <= 7.54u2 discards the values associated with empty string keys           (`""""`) only if they are used directly within an object member list           (e.g., `!("""" in { """": 1})`).          return serialize(, (value = {}, value[] = source, value), callback, properties, whitespace, , []);        };      }
       Public: Parses a JSON source string.      if (!has(json-parse)) {        var fromCharCode = String.fromCharCode;
         Internal: A map of escaped control characters and their unescaped         equivalents.        var Unescapes = {          92: ,          34: "",          47: /,          98: ,          116: ,          110: ,          102: ,          114:         };
         Internal: Stores the parser state.        var Index, Source;
         Internal: Resets the parser state and throws a `SyntaxError`.        var abort = function () {          Index = Source = null;          throw SyntaxError();        };
         Internal: Returns the next token, or `""$""` if the parser has reached         the end of the source string. A token may be a string, number, `null`         literal, or Boolean literal.        var lex = function () {          var source = Source, length = source.length, value, begin, position, isSigned, charCode;          while (Index < length) {            charCode = source.charCodeAt(Index);            switch (charCode) {              case 9: case 10: case 13: case 32:                 Skip whitespace tokens, including tabs, carriage returns, line                 feeds, and space characters.                Index++;                break;              case 123: case 125: case 91: case 93: case 58: case 44:                 Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at                 the current position.                value = charIndexBuggy ? source.charAt(Index) : source[Index];                Index++;                return value;              case 34:                 `""` delimits a JSON string; advance to the next character and                 begin parsing the string. String tokens are prefixed with the                 sentinel `@` character to distinguish them from punctuators and                 end-of-string tokens.                for (value = @, Index++; Index < length;) {                  charCode = source.charCodeAt(Index);                  if (charCode < 32) {                     Unescaped ASCII control characters (those with a code unit                     less than the space character) are not permitted.                    abort();                  } else if (charCode == 92) {                     A reverse solidus (`\`) marks the beginning of an escaped                     control character (including `""`, `\`, and `/`) or Unicode                     escape sequence.                    charCode = source.charCodeAt(++Index);                    switch (charCode) {                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:                         Revive escaped control characters.                        value += Unescapes[charCode];                        Index++;                        break;                      case 117:                         `\u` marks the beginning of a Unicode escape sequence.                         Advance to the first character and validate the                         four-digit code point.                        begin = ++Index;                        for (position = Index + 4; Index < position; Index++) {                          charCode = source.charCodeAt(Index);                           A valid sequence comprises four hexdigits (case-                           insensitive) that form a single hexadecimal value.                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {                             Invalid Unicode escape sequence.                            abort();                          }                        }                         Revive the escaped character.                        value += fromCharCode(0x + source.slice(begin, Index));                        break;                      default:                         Invalid escape sequence.                        abort();                    }                  } else {                    if (charCode == 34) {                       An unescaped double-quote character marks the end of the                       string.                      break;                    }                    charCode = source.charCodeAt(Index);                    begin = Index;                     Optimize for the common case where a string is valid.                    while (charCode >= 32 && charCode != 92 && charCode != 34) {                      charCode = source.charCodeAt(++Index);                    }                     Append the string as-is.                    value += source.slice(begin, Index);                  }                }                if (source.charCodeAt(Index) == 34) {                   Advance to the next character and return the revived string.                  Index++;                  return value;                }                 Unterminated string.                abort();              default:                 Parse numbers and literals.                begin = Index;                 Advance past the negative sign, if one is specified.                if (charCode == 45) {                  isSigned = true;                  charCode = source.charCodeAt(++Index);                }                 Parse an integer or floating-point value.                if (charCode >= 48 && charCode <= 57) {                   Leading zeroes are interpreted as octal literals.                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {                     Illegal octal literal.                    abort();                  }                  isSigned = false;                   Parse the integer component.                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);                   Floats cannot contain a leading decimal point; however, this                   case is already accounted for by the parser.                  if (source.charCodeAt(Index) == 46) {                    position = ++Index;                     Parse the decimal component.                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);                    if (position == Index) {                       Illegal trailing decimal.                      abort();                    }                    Index = position;                  }                   Parse exponents. The `e` denoting the exponent is                   case-insensitive.                  charCode = source.charCodeAt(Index);                  if (charCode == 101 || charCode == 69) {                    charCode = source.charCodeAt(++Index);                     Skip past the sign following the exponent, if one is                     specified.                    if (charCode == 43 || charCode == 45) {                      Index++;                    }                     Parse the exponential component.                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);                    if (position == Index) {                       Illegal empty exponent.                      abort();                    }                    Index = position;                  }                   Coerce the parsed value to a JavaScript number.                  return +source.slice(begin, Index);                }                 A negative sign may only precede numbers.                if (isSigned) {                  abort();                }                 `true`, `false`, and `null` literals.                if (source.slice(Index, Index + 4) == true) {                  Index += 4;                  return true;                } else if (source.slice(Index, Index + 5) == false) {                  Index += 5;                  return false;                } else if (source.slice(Index, Index + 4) == null) {                  Index += 4;                  return null;                }                 Unrecognized token.                abort();            }          }           Return the sentinel `$` character if the parser has reached the end           of the source string.          return $;        };
         Internal: Parses a JSON `value` token.        var get = function (value) {          var results, hasMembers;          if (value == $) {             Unexpected end of input.            abort();          }          if (typeof value == string) {            if ((charIndexBuggy ? value.charAt(0) : value[0]) == @) {               Remove the sentinel `@` character.              return value.slice(1);            }             Parse object and array literals.            if (value == [) {               Parses a JSON array, returning a new JavaScript array.              results = [];              for (;; hasMembers || (hasMembers = true)) {                value = lex();                 A closing square bracket marks the end of the array literal.                if (value == ]) {                  break;                }                 If the array literal contains elements, the current token                 should be a comma separating the previous element from the                 next.                if (hasMembers) {                  if (value == ,) {                    value = lex();                    if (value == ]) {                       Unexpected trailing `,` in array literal.                      abort();                    }                  } else {                     A `,` must separate each array element.                    abort();                  }                }                 Elisions and leading commas are not permitted.                if (value == ,) {                  abort();                }                results.push(get(value));              }              return results;            } else if (value == {) {               Parses a JSON object, returning a new JavaScript object.              results = {};              for (;; hasMembers || (hasMembers = true)) {                value = lex();                 A closing curly brace marks the end of the object literal.                if (value == }) {                  break;                }                 If the object literal contains members, the current token                 should be a comma separator.                if (hasMembers) {                  if (value == ,) {                    value = lex();                    if (value == }) {                       Unexpected trailing `,` in object literal.                      abort();                    }                  } else {                     A `,` must separate each object member.                    abort();                  }                }                 Leading commas are not permitted, object property names must be                 double-quoted strings, and a `:` must separate each property                 name and value.                if (value == , || typeof value != string || (charIndexBuggy ? value.charAt(0) : value[0]) != @ || lex() != :) {                  abort();                }                results[value.slice(1)] = get(lex());              }              return results;            }             Unexpected token encountered.            abort();          }          return value;        };
         Internal: Updates a traversed object member.        var update = function (source, property, callback) {          var element = walk(source, property, callback);          if (element === undef) {            delete source[property];          } else {            source[property] = element;          }        };
         Internal: Recursively traverses a parsed JSON object, invoking the         `callback` function for each value. This is an implementation of the         `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.        var walk = function (source, property, callback) {          var value = source[property], length;          if (typeof value == object && value) {             `forEach` can't be used to traverse an array in Opera <= 8.54             because its `Object#hasOwnProperty` implementation returns `false`             for array indices (e.g., `![1, 2, 3].hasOwnProperty(""0"")`).            if (getClass.call(value) == arrayClass) {              for (length = value.length; length--;) {                update(value, length, callback);              }            } else {              forEach(value, function (property) {                update(value, property, callback);              });            }          }          return callback.call(source, property, value);        };
         Public: `JSON.parse`. See ES 5.1 section 15.12.2.        exports.parse = function (source, callback) {          var result, value;          Index = 0;          Source =  + source;          result = get(lex());           If a JSON string contains multiple tokens, it is invalid.          if (lex() != $) {            abort();          }           Reset the parser state.          Index = Source = null;          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[] = result, value), , callback) : result;        };      }    }
    exports[runInContext] = runInContext;    return exports;  }
  if (freeExports && !isLoader) {     Export for CommonJS environments.    runInContext(root, freeExports);  } else {     Export for web browsers and JavaScript engines.    var nativeJSON = root.JSON,        previousJSON = root[JSON3],        isRestored = false;
    var JSON3 = runInContext(root, (root[JSON3] = {       Public: Restores the original value of the global `JSON` object and       returns a reference to the `JSON3` object.      : function () {        if (!isRestored) {          isRestored = true;          root.JSON = nativeJSON;          root[JSON3] = previousJSON;          nativeJSON = previousJSON = null;        }        return JSON3;      }    }));
    root.JSON = {      parse: JSON3.parse,      stringify: JSON3.stringify    };  }
   Export for asynchronous module loaders.  if (isLoader) {    define(function () {      return JSON3;    });  }}).call(this);
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{}],55:[function(require,module,exports){/** * lodash 3.2.0 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */var baseCopy = require(lodash._basecopy),    keys = require(lodash.keys);
/** * The base implementation of `_.assign` without support for argument juggling, * multiple sources, and `customizer` functions. * *  *    The destination object. *    The source object. *   Returns `object`. */function baseAssign(object, source) {  return source == null    ? object    : baseCopy(source, keys(source), object);}
module.exports = baseAssign;
},{lodash._basecopy:56,lodash.keys:63}],56:[function(require,module,exports){/** * lodash 3.0.1 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
/** * Copies properties of `source` to `object`. * *  *    The object to copy properties from. *    The property names to copy. *    The object to copy properties to. *   Returns `object`. */function baseCopy(source, props, object) {  object || (object = {});
  var index = -1,      length = props.length;
  while (++index < length) {    var key = props[index];    object[key] = source[key];  }  return object;}
module.exports = baseCopy;
},{}],57:[function(require,module,exports){/** * lodash 3.0.3 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
/** * The base implementation of `_.create` without support for assigning * properties to the created object. * *  *    The object to inherit from. *   Returns the new object. */var baseCreate = (function() {  function object() {}  return function(prototype) {    if (isObject(prototype)) {      object.prototype = prototype;      var result = new object;      object.prototype = undefined;    }    return result || {};  };}());
/** * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
module.exports = baseCreate;
},{}],58:[function(require,module,exports){/** * lodash 3.9.1 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
var funcTag = [object Function];
var reIsHostCtor = object Constructor;
/** * Checks if `value` is object-like. * *  *    The value to check. *   Returns `true` if `value` is object-like, else `false`. */function isObjectLike(value) {  return !!value && typeof value == object;}
var objectProto = Object.prototype;
var fnToString = Function.prototype.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
/** * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring) * of values. */var objToString = objectProto.toString;
var reIsNative = RegExp(^ +  fnToString.call(hasOwnProperty).replace(g, $&)  .replace(hasOwnProperty(function)(?=) for (?=)g, $1.*?) + $);
/** * Gets the native function at `key` of `object`. * *  *    The object to query. *    The key of the method to get. *   Returns the function if it's native, else `undefined`. */function getNative(object, key) {  var value = object == null ? undefined : object[key];  return isNative(value) ? value : undefined;}
/** * Checks if `value` is classified as a `Function` object. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is correctly classified, else `false`. *  * *  *  * *  *  */function isFunction(value) {   The use of `Object#toString` avoids issues with the `typeof` operator   in older versions of Chrome and Safari which return 'function' for regexes   and Safari 8 equivalents which return 'object' for typed array constructors.  return isObject(value) && objToString.call(value) == funcTag;}
/** * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
/** * Checks if `value` is a native function. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is a native function, else `false`. *  * *  *  * *  *  */function isNative(value) {  if (value == null) {    return false;  }  if (isFunction(value)) {    return reIsNative.test(fnToString.call(value));  }  return isObjectLike(value) && reIsHostCtor.test(value);}
module.exports = getNative;
},{}],59:[function(require,module,exports){/** * lodash 3.0.9 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
var reIsUint = ;
/** * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer) * of an array-like value. */var MAX_SAFE_INTEGER = 9007199254740991;
/** * The base implementation of `_.property` without support for deep paths. * *  *    The key of the property to get. *   Returns the new function. */function baseProperty(key) {  return function(object) {    return object == null ? undefined : object[key];  };}
/** * Gets the ""length"" property value of `object`. * * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) * that affects Safari on at least iOS 8.1-8.3 ARM64. * *  *    The object to query. *   Returns the ""length"" value. */var getLength = baseProperty(length);
/** * Checks if `value` is array-like. * *  *    The value to check. *   Returns `true` if `value` is array-like, else `false`. */function isArrayLike(value) {  return value != null && isLength(getLength(value));}
/** * Checks if `value` is a valid array-like index. * *  *    The value to check. *    The upper bounds of a valid index. *   Returns `true` if `value` is a valid index, else `false`. */function isIndex(value, length) {  value = (typeof value == number || reIsUint.test(value)) ? +value : -1;  length = length == null ? MAX_SAFE_INTEGER : length;  return value > -1 && value % 1 == 0 && value < length;}
/** * Checks if the provided arguments are from an iteratee call. * *  *    The potential iteratee value argument. *    The potential iteratee index or key argument. *    The potential iteratee object argument. *   Returns `true` if the arguments are from an iteratee call, else `false`. */function isIterateeCall(value, index, object) {  if (!isObject(object)) {    return false;  }  var type = typeof index;  if (type == number      ? (isArrayLike(object) && isIndex(index, object.length))      : (type == string && index in object)) {    var other = object[index];    return value === value ? (value === other) : (other !== other);  }  return false;}
/** * Checks if `value` is a valid array-like length. * * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength). * *  *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. */function isLength(value) {  return typeof value == number && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
/** * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
module.exports = isIterateeCall;
},{}],60:[function(require,module,exports){/** * lodash 3.1.1 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */var baseAssign = require(lodash._baseassign),    baseCreate = require(lodash._basecreate),    isIterateeCall = require(lodash._isiterateecall);
/** * Creates an object that inherits from the given `prototype` object. If a * `properties` object is provided its own enumerable properties are assigned * to the created object. * *  * @memberOf _ * @category Object *    The object to inherit from. *    The properties to assign to the object. * - {Object} [guard] Enables use as a callback for functions like `_.map`. *   Returns the new object. *  * *  *    *    *  * *  *    *  * *  *    *  * *  *  *  * *  *  */function create(prototype, properties, guard) {  var result = baseCreate(prototype);  if (guard && isIterateeCall(prototype, properties, guard)) {    properties = undefined;  }  return properties ? baseAssign(result, properties) : result;}
module.exports = create;
},{lodash._baseassign:55,lodash._basecreate:57,lodash._isiterateecall:59}],61:[function(require,module,exports){/** * lodash (Custom Build) <https://lodash.com/> * Build: `lodash modularize exports=""npm"" -o ./` * Copyright jQuery Foundation and other contributors <https://jquery.org/> * Released under MIT license <https://lodash.com/license> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors */
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = [object Arguments],    funcTag = [object Function],    genTag = [object GeneratorFunction];
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
/** * Used to resolve the * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring) * of values. */var objectToString = objectProto.toString;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/** * Checks if `value` is likely an `arguments` object. * *  * @memberOf _ *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an `arguments` object, *  else `false`. *  * *  *  * *  *  */function isArguments(value) {   Safari 8.1 makes `arguments.callee` enumerable in strict mode.  return isArrayLikeObject(value) && hasOwnProperty.call(value, callee) &&    (!propertyIsEnumerable.call(value, callee) || objectToString.call(value) == argsTag);}
/** * Checks if `value` is array-like. A value is considered array-like if it's * not a function and has a `value.length` that's an integer greater than or * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`. * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is array-like, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isArrayLike(value) {  return value != null && isLength(value.length) && !isFunction(value);}
/** * This method is like `_.isArrayLike` except that it also checks if `value` * is an object. * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an array-like object, *  else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isArrayLikeObject(value) {  return isObjectLike(value) && isArrayLike(value);}
/** * Checks if `value` is classified as a `Function` object. * *  * @memberOf _ *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a function, else `false`. *  * *  *  * *  *  */function isFunction(value) {   The use of `Object#toString` avoids issues with the `typeof` operator   in Safari 8-9 which returns 'object' for typed array and other constructors.  var tag = isObject(value) ? objectToString.call(value) : ;  return tag == funcTag || tag == genTag;}
/** * Checks if `value` is a valid array-like length. * * **Note:** This method is loosely based on * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isLength(value) {  return typeof value == number &&    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
/** * Checks if `value` is the * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isObject(value) {  var type = typeof value;  return !!value && (type == object || type == function);}
/** * Checks if `value` is object-like. A value is object-like if it's not `null` * and has a `typeof` result of ""object"". * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is object-like, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isObjectLike(value) {  return !!value && typeof value == object;}
module.exports = isArguments;
},{}],62:[function(require,module,exports){/** * lodash 3.0.4 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
var arrayTag = [object Array],    funcTag = [object Function];
var reIsHostCtor = object Constructor;
/** * Checks if `value` is object-like. * *  *    The value to check. *   Returns `true` if `value` is object-like, else `false`. */function isObjectLike(value) {  return !!value && typeof value == object;}
var objectProto = Object.prototype;
var fnToString = Function.prototype.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
/** * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring) * of values. */var objToString = objectProto.toString;
var reIsNative = RegExp(^ +  fnToString.call(hasOwnProperty).replace(g, $&)  .replace(hasOwnProperty(function)(?=) for (?=)g, $1.*?) + $);
/* Native method references for those with the same name as other `lodash` methods. */var nativeIsArray = getNative(Array, isArray);
/** * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer) * of an array-like value. */var MAX_SAFE_INTEGER = 9007199254740991;
/** * Gets the native function at `key` of `object`. * *  *    The object to query. *    The key of the method to get. *   Returns the function if it's native, else `undefined`. */function getNative(object, key) {  var value = object == null ? undefined : object[key];  return isNative(value) ? value : undefined;}
/** * Checks if `value` is a valid array-like length. * * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength). * *  *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. */function isLength(value) {  return typeof value == number && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
/** * Checks if `value` is classified as an `Array` object. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is correctly classified, else `false`. *  * *  *  * *  *  */var isArray = nativeIsArray || function(value) {  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;};
/** * Checks if `value` is classified as a `Function` object. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is correctly classified, else `false`. *  * *  *  * *  *  */function isFunction(value) {   The use of `Object#toString` avoids issues with the `typeof` operator   in older versions of Chrome and Safari which return 'function' for regexes   and Safari 8 equivalents which return 'object' for typed array constructors.  return isObject(value) && objToString.call(value) == funcTag;}
/** * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
/** * Checks if `value` is a native function. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is a native function, else `false`. *  * *  *  * *  *  */function isNative(value) {  if (value == null) {    return false;  }  if (isFunction(value)) {    return reIsNative.test(fnToString.call(value));  }  return isObjectLike(value) && reIsHostCtor.test(value);}
module.exports = isArray;
},{}],63:[function(require,module,exports){/** * lodash 3.1.2 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */var getNative = require(lodash._getnative),    isArguments = require(lodash.isarguments),    isArray = require(lodash.isarray);
var reIsUint = ;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
/* Native method references for those with the same name as other `lodash` methods. */var nativeKeys = getNative(Object, keys);
/** * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer) * of an array-like value. */var MAX_SAFE_INTEGER = 9007199254740991;
/** * The base implementation of `_.property` without support for deep paths. * *  *    The key of the property to get. *   Returns the new function. */function baseProperty(key) {  return function(object) {    return object == null ? undefined : object[key];  };}
/** * Gets the ""length"" property value of `object`. * * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) * that affects Safari on at least iOS 8.1-8.3 ARM64. * *  *    The object to query. *   Returns the ""length"" value. */var getLength = baseProperty(length);
/** * Checks if `value` is array-like. * *  *    The value to check. *   Returns `true` if `value` is array-like, else `false`. */function isArrayLike(value) {  return value != null && isLength(getLength(value));}
/** * Checks if `value` is a valid array-like index. * *  *    The value to check. *    The upper bounds of a valid index. *   Returns `true` if `value` is a valid index, else `false`. */function isIndex(value, length) {  value = (typeof value == number || reIsUint.test(value)) ? +value : -1;  length = length == null ? MAX_SAFE_INTEGER : length;  return value > -1 && value % 1 == 0 && value < length;}
/** * Checks if `value` is a valid array-like length. * * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength). * *  *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. */function isLength(value) {  return typeof value == number && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
/** * A fallback implementation of `Object.keys` which creates an array of the * own enumerable property names of `object`. * *  *    The object to query. *   Returns the array of property names. */function shimKeys(object) {  var props = keysIn(object),      propsLength = props.length,      length = propsLength && object.length;
  var allowIndexes = !!length && isLength(length) &&    (isArray(object) || isArguments(object));
  var index = -1,      result = [];
  while (++index < propsLength) {    var key = props[index];    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {      result.push(key);    }  }  return result;}
/** * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
/** * Creates an array of the own enumerable property names of `object`. * * **Note:** Non-object values are coerced to objects. See the * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys) * for more details. * *  * @memberOf _ * @category Object *    The object to query. *   Returns the array of property names. *  * *  *    *    *  * *  * *  *  * *  *  */var keys = !nativeKeys ? shimKeys : function(object) {  var Ctor = object == null ? undefined : object.constructor;  if ((typeof Ctor == function && Ctor.prototype === object) ||      (typeof object != function && isArrayLike(object))) {    return shimKeys(object);  }  return isObject(object) ? nativeKeys(object) : [];};
/** * Creates an array of the own and inherited enumerable property names of `object`. * * **Note:** Non-object values are coerced to objects. * *  * @memberOf _ * @category Object *    The object to query. *   Returns the array of property names. *  * *  *    *    *  * *  * *  *  */function keysIn(object) {  if (object == null) {    return [];  }  if (!isObject(object)) {    object = Object(object);  }  var length = object.length;  length = (length && isLength(length) &&    (isArray(object) || isArguments(object)) && length) || 0;
  var Ctor = object.constructor,      index = -1,      isProto = typeof Ctor == function && Ctor.prototype === object,      result = Array(length),      skipIndexes = length > 0;
  while (++index < length) {    result[index] = (index + );  }  for (var key in object) {    if (!(skipIndexes && isIndex(key, length)) &&        !(key == constructor && (isProto || !hasOwnProperty.call(object, key)))) {      result.push(key);    }  }  return result;}
module.exports = keys;
},{lodash._getnative:58,lodash.isarguments:61,lodash.isarray:62}],64:[function(require,module,exports){(function (process){var path = require(path);var fs = require(fs);var _0777 = parseInt(0777, 8);
module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP (p, opts, f, made) {    if (typeof opts === function) {        f = opts;        opts = {};    }    else if (!opts || typeof opts !== object) {        opts = { mode: opts };    }        var mode = opts.mode;    var xfs = opts.fs || fs;        if (mode === undefined) {        mode = _0777 & (~process.umask());    }    if (!made) made = null;        var cb = f || function () {};    p = path.resolve(p);        xfs.mkdir(p, mode, function (er) {        if (!er) {            made = made || p;            return cb(null, made);        }        switch (er.code) {            case ENOENT:                mkdirP(path.dirname(p), opts, function (er, made) {                    if (er) cb(er, made);                    else mkdirP(p, opts, cb, made);                });                break;
             In the case of any other error, just see if there's a dir             there already.  If so, then hooray!  If not, then something             is borked.            default:                xfs.stat(p, function (er2, stat) {                     if the stat fails, then that's super weird.                     let the original error be the failure reason.                    if (er2 || !stat.isDirectory()) cb(er, made)                    else cb(null, made);                });                break;        }    });}
mkdirP.sync = function sync (p, opts, made) {    if (!opts || typeof opts !== object) {        opts = { mode: opts };    }        var mode = opts.mode;    var xfs = opts.fs || fs;        if (mode === undefined) {        mode = _0777 & (~process.umask());    }    if (!made) made = null;
    p = path.resolve(p);
    try {        xfs.mkdirSync(p, mode);        made = made || p;    }    catch (err0) {        switch (err0.code) {            case ENOENT :                made = sync(path.dirname(p), opts, made);                sync(p, opts, made);                break;
             In the case of any other error, just see if there's a dir             there already.  If so, then hooray!  If not, then something             is borked.            default:                var stat;                try {                    stat = xfs.statSync(p);                }                catch (err1) {                    throw err0;                }                if (!stat.isDirectory()) throw err0;                break;        }    }
    return made;};
}).call(this,require(_process))},{_process:67,fs:42,path:42}],65:[function(require,module,exports){exports.endianness = function () { return LE };
exports.hostname = function () {    if (typeof location !== undefined) {        return location.hostname    }    else return ;};
exports.loadavg = function () { return [] };
exports.uptime = function () { return 0 };
exports.freemem = function () {    return Number.MAX_VALUE;};
exports.totalmem = function () {    return Number.MAX_VALUE;};
exports.cpus = function () { return [] };
exports.type = function () { return Browser };
exports.release = function () {    if (typeof navigator !== undefined) {        return navigator.appVersion;    }    return ;};
exports.networkInterfaces= exports.getNetworkInterfaces= function () { return {} };
exports.arch = function () { return javascript };
exports.platform = function () { return browser };
exports.tmpdir = exports.tmpDir = function () {    return /tmp;};
exports.EOL = ;
},{}],66:[function(require,module,exports){(function (process){use strict;
if (!process.version ||    process.version.indexOf(v0.) === 0 ||    process.version.indexOf(v1.) === 0 && process.version.indexOf(v1.8.) !== 0) {  module.exports = nextTick;} else {  module.exports = process.nextTick;}
function nextTick(fn, arg1, arg2, arg3) {  if (typeof fn !== function) {    throw new TypeError(""callback"" argument must be a function);  }  var len = arguments.length;  var args, i;  switch (len) {  case 0:  case 1:    return process.nextTick(fn);  case 2:    return process.nextTick(function afterTickOne() {      fn.call(null, arg1);    });  case 3:    return process.nextTick(function afterTickTwo() {      fn.call(null, arg1, arg2);    });  case 4:    return process.nextTick(function afterTickThree() {      fn.call(null, arg1, arg2, arg3);    });  default:    args = new Array(len - 1);    i = 0;    while (i < args.length) {      args[i++] = arguments[i];    }    return process.nextTick(function afterTick() {      fn.apply(null, args);    });  }}
}).call(this,require(_process))},{_process:67}],67:[function(require,module,exports){ shim for using process in browservar process = module.exports = {};
 cached from whatever global is present so that test runners that stub it don't break things.  But we need to wrap it in a try catch in case it is wrapped in strict mode code which doesn't define any globals.  It's inside a function because try/catches deoptimize in certain engines.
var cachedSetTimeout;var cachedClearTimeout;
function defaultSetTimout() {    throw new Error(setTimeout has not been defined);}function defaultClearTimeout () {    throw new Error(clearTimeout has not been defined);}(function () {    try {        if (typeof setTimeout === function) {            cachedSetTimeout = setTimeout;        } else {            cachedSetTimeout = defaultSetTimout;        }    } catch (e) {        cachedSetTimeout = defaultSetTimout;    }    try {        if (typeof clearTimeout === function) {            cachedClearTimeout = clearTimeout;        } else {            cachedClearTimeout = defaultClearTimeout;        }    } catch (e) {        cachedClearTimeout = defaultClearTimeout;    }} ())function runTimeout(fun) {    if (cachedSetTimeout === setTimeout) {        normal enviroments in sane situations        return setTimeout(fun, 0);    }     if setTimeout wasn't available but was latter defined    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {        cachedSetTimeout = setTimeout;        return setTimeout(fun, 0);    }    try {         when when somebody has screwed with setTimeout but no I.E. maddness        return cachedSetTimeout(fun, 0);    } catch(e){        try {             When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally            return cachedSetTimeout.call(null, fun, 0);        } catch(e){             same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error            return cachedSetTimeout.call(this, fun, 0);        }    }

}function runClearTimeout(marker) {    if (cachedClearTimeout === clearTimeout) {        normal enviroments in sane situations        return clearTimeout(marker);    }     if clearTimeout wasn't available but was latter defined    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {        cachedClearTimeout = clearTimeout;        return clearTimeout(marker);    }    try {         when when somebody has screwed with setTimeout but no I.E. maddness        return cachedClearTimeout(marker);    } catch (e){        try {             When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally            return cachedClearTimeout.call(null, marker);        } catch (e){             same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.             Some versions of I.E. have different rules for clearTimeout vs setTimeout            return cachedClearTimeout.call(this, marker);        }    }


}var queue = [];var draining = false;var currentQueue;var queueIndex = -1;
function cleanUpNextTick() {    if (!draining || !currentQueue) {        return;    }    draining = false;    if (currentQueue.length) {        queue = currentQueue.concat(queue);    } else {        queueIndex = -1;    }    if (queue.length) {        drainQueue();    }}
function drainQueue() {    if (draining) {        return;    }    var timeout = runTimeout(cleanUpNextTick);    draining = true;
    var len = queue.length;    while(len) {        currentQueue = queue;        queue = [];        while (++queueIndex < len) {            if (currentQueue) {                currentQueue[queueIndex].run();            }        }        queueIndex = -1;        len = queue.length;    }    currentQueue = null;    draining = false;    runClearTimeout(timeout);}
process.nextTick = function (fun) {    var args = new Array(arguments.length - 1);    if (arguments.length > 1) {        for (var i = 1; i < arguments.length; i++) {            args[i - 1] = arguments[i];        }    }    queue.push(new Item(fun, args));    if (queue.length === 1 && !draining) {        runTimeout(drainQueue);    }};
 v8 likes predictible objectsfunction Item(fun, array) {    this.fun = fun;    this.array = array;}Item.prototype.run = function () {    this.fun.apply(null, this.array);};process.title = browser;process.browser = true;process.env = {};process.argv = [];process.version = ;  empty string to avoid regexp issuesprocess.versions = {};
function noop() {}
process.on = noop;process.addListener = noop;process.once = noop;process.off = noop;process.removeListener = noop;process.removeAllListeners = noop;process.emit = noop;
process.binding = function (name) {    throw new Error(process.binding is not supported);};
process.cwd = function () { return / };process.chdir = function (dir) {    throw new Error(process.chdir is not supported);};process.umask = function() { return 0; };
},{}],68:[function(require,module,exports){module.exports = require(./lib/_stream_duplex.js)
},{./lib/_stream_duplex.js:69}],69:[function(require,module,exports){ a duplex stream is just a stream that is both readable and writable. Since JS doesn't have multiple prototypal inheritance, this class prototypally inherits from Readable, and then parasitically from Writable.
use strict;
/*<replacement>*/
var objectKeys = Object.keys || function (obj) {  var keys = [];  for (var key in obj) {    keys.push(key);  }return keys;};/*</replacement>*/
module.exports = Duplex;
/*<replacement>*/var processNextTick = require(process-nextick-args);/*</replacement>*/
/*<replacement>*/var util = require(core-util-is);util.inherits = require(inherits);/*</replacement>*/
var Readable = require(./_stream_readable);var Writable = require(./_stream_writable);
util.inherits(Duplex, Readable);
var keys = objectKeys(Writable.prototype);for (var v = 0; v < keys.length; v++) {  var method = keys[v];  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];}
function Duplex(options) {  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once(end, onend);}
 the no-half-open enforcerfunction onend() {   if we allow half-open state, or if the writable side ended,   then we're ok.  if (this.allowHalfOpen || this._writableState.ended) return;
   no more data can be written.   But allow more writes to happen in this tick.  processNextTick(onEndNT, this);}
function onEndNT(self) {  self.end();}
function forEach(xs, f) {  for (var i = 0, l = xs.length; i < l; i++) {    f(xs[i], i);  }}},{./_stream_readable:71,./_stream_writable:73,core-util-is:45,inherits:51,process-nextick-args:66}],70:[function(require,module,exports){ a passthrough stream. basically just the most minimal sort of Transform stream. Every written chunk gets output as-is.
use strict;
module.exports = PassThrough;
var Transform = require(./_stream_transform);
/*<replacement>*/var util = require(core-util-is);util.inherits = require(inherits);/*</replacement>*/
util.inherits(PassThrough, Transform);
function PassThrough(options) {  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);}
PassThrough.prototype._transform = function (chunk, encoding, cb) {  cb(null, chunk);};},{./_stream_transform:72,core-util-is:45,inherits:51}],71:[function(require,module,exports){(function (process){use strict;
module.exports = Readable;
/*<replacement>*/var processNextTick = require(process-nextick-args);/*</replacement>*/
/*<replacement>*/var isArray = require(isarray);/*</replacement>*/
Readable.ReadableState = ReadableState;
/*<replacement>*/var EE = require(events).EventEmitter;
var EElistenerCount = function (emitter, type) {  return emitter.listeners(type).length;};/*</replacement>*/
/*<replacement>*/var Stream;(function () {  try {    Stream = require(st + ream);  } catch (_) {} finally {    if (!Stream) Stream = require(events).EventEmitter;  }})();/*</replacement>*/
var Buffer = require(buffer).Buffer;/*<replacement>*/var bufferShim = require(buffer-shims);/*</replacement>*/
/*<replacement>*/var util = require(core-util-is);util.inherits = require(inherits);/*</replacement>*/
/*<replacement>*/var debugUtil = require(util);var debug = void 0;if (debugUtil && debugUtil.debuglog) {  debug = debugUtil.debuglog(stream);} else {  debug = function () {};}/*</replacement>*/
var BufferList = require(./internal/streams/BufferList);var StringDecoder;
util.inherits(Readable, Stream);
function prependListener(emitter, event, fn) {  if (typeof emitter.prependListener === function) {    return emitter.prependListener(event, fn);  } else {     This is a hack to make sure that our error handler is attached before any     userland ones.  NEVER DO THIS. This is here only because this code needs     to continue to work with older versions of Node.js that do not include     the prependListener() method. The goal is to eventually remove this hack.    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];  }}
var Duplex;function ReadableState(options, stream) {  Duplex = Duplex || require(./_stream_duplex);
  options = options || {};
   object stream flag. Used to make read(n) ignore n and to   make all the buffer merging and length checks go away  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
   the point at which it stops calling _read() to fill the buffer   Note: 0 is a valid value, means ""don't call _read preemptively ever""  var hwm = options.highWaterMark;  var defaultHwm = this.objectMode ? 16 : 16 * 1024;  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
   cast to ints.  this.highWaterMark = ~ ~this.highWaterMark;
   A linked list is used to store data chunks instead of an array because the   linked list can remove elements from the beginning faster than   array.shift()  this.buffer = new BufferList();  this.length = 0;  this.pipes = null;  this.pipesCount = 0;  this.flowing = null;  this.ended = false;  this.endEmitted = false;  this.reading = false;
   a flag to be able to tell if the onwrite cb is called immediately,   or on a later tick.  We set this to true at first, because any   actions that shouldn't happen until ""later"" should generally also   not happen before the first write call.  this.sync = true;
   whenever we return null, then we set a flag to say   that we're awaiting a 'readable' event emission.  this.needReadable = false;  this.emittedReadable = false;  this.readableListening = false;  this.resumeScheduled = false;
   Crypto is kind of old and crusty.  Historically, its default string   encoding is 'binary' so we have to make this configurable.   Everything else in the universe uses 'utf8', though.  this.defaultEncoding = options.defaultEncoding || utf8;
   when piping, we only care about 'readable' events that happen   after read()ing all the bytes and not getting any pushback.  this.ranOut = false;
   the number of writers that are awaiting a drain event in .pipe()s  this.awaitDrain = 0;
   if true, a maybeReadMore has been scheduled  this.readingMore = false;
  this.decoder = null;  this.encoding = null;  if (options.encoding) {    if (!StringDecoder) StringDecoder = require(string_decoder/).StringDecoder;    this.decoder = new StringDecoder(options.encoding);    this.encoding = options.encoding;  }}
var Duplex;function Readable(options) {  Duplex = Duplex || require(./_stream_duplex);
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);
   legacy  this.readable = true;
  if (options && typeof options.read === function) this._read = options.read;
  Stream.call(this);}
 Manually shove something into the read() buffer. This returns true if the highWaterMark has not been hit yet, similar to how Writable.write() returns true if you should write() some more.Readable.prototype.push = function (chunk, encoding) {  var state = this._readableState;
  if (!state.objectMode && typeof chunk === string) {    encoding = encoding || state.defaultEncoding;    if (encoding !== state.encoding) {      chunk = bufferShim.from(chunk, encoding);      encoding = ;    }  }
  return readableAddChunk(this, state, chunk, encoding, false);};
 Unshift should *always* be something directly out of read()Readable.prototype.unshift = function (chunk) {  var state = this._readableState;  return readableAddChunk(this, state, chunk, , true);};
Readable.prototype.isPaused = function () {  return this._readableState.flowing === false;};
function readableAddChunk(stream, state, chunk, encoding, addToFront) {  var er = chunkInvalid(state, chunk);  if (er) {    stream.emit(error, er);  } else if (chunk === null) {    state.reading = false;    onEofChunk(stream, state);  } else if (state.objectMode || chunk && chunk.length > 0) {    if (state.ended && !addToFront) {      var e = new Error(stream.push() after EOF);      stream.emit(error, e);    } else if (state.endEmitted && addToFront) {      var _e = new Error(stream.unshift() after end event);      stream.emit(error, _e);    } else {      var skipAdd;      if (state.decoder && !addToFront && !encoding) {        chunk = state.decoder.write(chunk);        skipAdd = !state.objectMode && chunk.length === 0;      }
      if (!addToFront) state.reading = false;
       Don't add to the buffer if we've decoded to an empty string chunk and       we're not in object mode      if (!skipAdd) {         if we want the data now, just emit it.        if (state.flowing && state.length === 0 && !state.sync) {          stream.emit(data, chunk);          stream.read(0);        } else {           update the buffer info.          state.length += state.objectMode ? 1 : chunk.length;          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream);        }      }
      maybeReadMore(stream, state);    }  } else if (!addToFront) {    state.reading = false;  }
  return needMoreData(state);}
 if it's past the high water mark, we can push in some more. Also, if we have no data yet, we can stand some more bytes.  This is to work around cases where hwm=0, such as the repl.  Also, if the push() triggered a readable event, and the user called read(largeNumber) such that needReadable was set, then we ought to push more, so that another 'readable' event will be triggered.function needMoreData(state) {  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);}
 backwards compatibility.Readable.prototype.setEncoding = function (enc) {  if (!StringDecoder) StringDecoder = require(string_decoder/).StringDecoder;  this._readableState.decoder = new StringDecoder(enc);  this._readableState.encoding = enc;  return this;};
 Don't raise the hwm > 8MBvar MAX_HWM = 0x800000;function computeNewHighWaterMark(n) {  if (n >= MAX_HWM) {    n = MAX_HWM;  } else {     Get the next highest power of 2 to prevent increasing hwm excessively in     tiny amounts    n--;    n |= n >>> 1;    n |= n >>> 2;    n |= n >>> 4;    n |= n >>> 8;    n |= n >>> 16;    n++;  }  return n;}
 This function is designed to be inlinable, so please take care when making changes to the function body.function howMuchToRead(n, state) {  if (n <= 0 || state.length === 0 && state.ended) return 0;  if (state.objectMode) return 1;  if (n !== n) {     Only flow one buffer at a time    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;  }   If we're asking for more than the current hwm, then raise the hwm.  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);  if (n <= state.length) return n;   Don't have enough  if (!state.ended) {    state.needReadable = true;    return 0;  }  return state.length;}
 you can override either this method, or the async _read(n) below.Readable.prototype.read = function (n) {  debug(read, n);  n = parseInt(n, 10);  var state = this._readableState;  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;
   if we're doing read(0) to trigger a readable event, but we   already have a bunch of data in the buffer, then just trigger   the 'readable' event and move on.  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {    debug(read: emitReadable, state.length, state.ended);    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);    return null;  }
  n = howMuchToRead(n, state);
   if we've ended, and we're now clear, then finish it up.  if (n === 0 && state.ended) {    if (state.length === 0) endReadable(this);    return null;  }
   All the actual chunk generation logic needs to be   *below* the call to _read.  The reason is that in certain   synthetic stream cases, such as passthrough streams, _read   may be a completely synchronous operation which may change   the state of the read buffer, providing enough data when   before there was *not* enough.     So, the steps are:   1. Figure out what the state of things will be after we do   a read from the buffer.     2. If that resulting state will trigger a _read, then call _read.   Note that this may be asynchronous, or synchronous.  Yes, it is   deeply ugly to write APIs this way, but that still doesn't mean   that the Readable class should behave improperly, as streams are   designed to be sync/async agnostic.   Take note if the _read call is sync or async (ie, if the read call   has returned yet), so that we know whether or not it's safe to emit   'readable' etc.     3. Actually pull the requested chunks out of the buffer and return.
   if we need a readable event, then we need to do some reading.  var doRead = state.needReadable;  debug(need readable, doRead);
   if we currently have less than the highWaterMark, then also read some  if (state.length === 0 || state.length - n < state.highWaterMark) {    doRead = true;    debug(length less than watermark, doRead);  }
   however, if we've ended, then there's no point, and if we're already   reading, then it's unnecessary.  if (state.ended || state.reading) {    doRead = false;    debug(reading or ended, doRead);  } else if (doRead) {    debug(do read);    state.reading = true;    state.sync = true;     if the length is currently zero, then we *need* a readable event.    if (state.length === 0) state.needReadable = true;     call internal read method    this._read(state.highWaterMark);    state.sync = false;     If _read pushed data synchronously, then `reading` will be false,     and we need to re-evaluate how much data we can return to the user.    if (!state.reading) n = howMuchToRead(nOrig, state);  }
  var ret;  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {    state.needReadable = true;    n = 0;  } else {    state.length -= n;  }
  if (state.length === 0) {     If we have nothing in the buffer, then we want to know     as soon as we *do* get something into the buffer.    if (!state.ended) state.needReadable = true;
     If we tried to read() past the EOF, then emit end on the next tick.    if (nOrig !== n && state.ended) endReadable(this);  }
  if (ret !== null) this.emit(data, ret);
  return ret;};
function chunkInvalid(state, chunk) {  var er = null;  if (!Buffer.isBuffer(chunk) && typeof chunk !== string && chunk !== null && chunk !== undefined && !state.objectMode) {    er = new TypeError(Invalid non-string/buffer chunk);  }  return er;}
function onEofChunk(stream, state) {  if (state.ended) return;  if (state.decoder) {    var chunk = state.decoder.end();    if (chunk && chunk.length) {      state.buffer.push(chunk);      state.length += state.objectMode ? 1 : chunk.length;    }  }  state.ended = true;
   emit 'readable' now to make sure it gets picked up.  emitReadable(stream);}
 Don't emit readable right away in sync mode, because this can trigger another read() call => stack overflow.  This way, it might trigger a nextTick recursion warning, but that's not so bad.function emitReadable(stream) {  var state = stream._readableState;  state.needReadable = false;  if (!state.emittedReadable) {    debug(emitReadable, state.flowing);    state.emittedReadable = true;    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);  }}
function emitReadable_(stream) {  debug(emit readable);  stream.emit(readable);  flow(stream);}
 at this point, the user has presumably seen the 'readable' event, and called read() to consume some data.  that may have triggered in turn another _read(n) call, in which case reading = true if it's in progress. However, if we're not ended, or reading, and the length < hwm, then go ahead and try to read some more preemptively.function maybeReadMore(stream, state) {  if (!state.readingMore) {    state.readingMore = true;    processNextTick(maybeReadMore_, stream, state);  }}
function maybeReadMore_(stream, state) {  var len = state.length;  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {    debug(maybeReadMore read 0);    stream.read(0);    if (len === state.length)       didn't get any data, stop spinning.      break;else len = state.length;  }  state.readingMore = false;}
 abstract method.  to be overridden in specific implementation classes. call cb(er, data) where data is <= n in length. for virtual (non-string, non-buffer) streams, ""length"" is somewhat arbitrary, and perhaps not very meaningful.Readable.prototype._read = function (n) {  this.emit(error, new Error(not implemented));};
Readable.prototype.pipe = function (dest, pipeOpts) {  var src = this;  var state = this._readableState;
  switch (state.pipesCount) {    case 0:      state.pipes = dest;      break;    case 1:      state.pipes = [state.pipes, dest];      break;    default:      state.pipes.push(dest);      break;  }  state.pipesCount += 1;  debug(pipe count=%d opts=%j, state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : cleanup;  if (state.endEmitted) processNextTick(endFn);else src.once(end, endFn);
  dest.on(unpipe, onunpipe);  function onunpipe(readable) {    debug(onunpipe);    if (readable === src) {      cleanup();    }  }
  function onend() {    debug(onend);    dest.end();  }
   when the dest drains, it reduces the awaitDrain counter   on the source.  This would be more elegant with a .once()   handler in flow(), but adding and removing repeatedly is   too slow.  var ondrain = pipeOnDrain(src);  dest.on(drain, ondrain);
  var cleanedUp = false;  function cleanup() {    debug(cleanup);     cleanup event handlers once the pipe is broken    dest.removeListener(close, onclose);    dest.removeListener(finish, onfinish);    dest.removeListener(drain, ondrain);    dest.removeListener(error, onerror);    dest.removeListener(unpipe, onunpipe);    src.removeListener(end, onend);    src.removeListener(end, cleanup);    src.removeListener(data, ondata);
    cleanedUp = true;
     if the reader is waiting for a drain event from this     specific writer, then it would cause it to never start     flowing again.     So, if this is awaiting a drain, then we just call it now.     If we don't know, then assume that we are waiting for one.    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();  }
   If the user pushes more data while we're writing to dest then we'll end up   in ondata again. However, we only want to increase awaitDrain once because   dest will only emit one 'drain' event for the multiple writes.   => Introduce a guard on increasing awaitDrain.  var increasedAwaitDrain = false;  src.on(data, ondata);  function ondata(chunk) {    debug(ondata);    increasedAwaitDrain = false;    var ret = dest.write(chunk);    if (false === ret && !increasedAwaitDrain) {       If the user unpiped during `dest.write()`, it is possible       to get stuck in a permanently paused state if that write       also returned false.       => Check whether `dest` is still a piping destination.      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {        debug(false write response, pause, src._readableState.awaitDrain);        src._readableState.awaitDrain++;        increasedAwaitDrain = true;      }      src.pause();    }  }
   if the dest has an error, then stop piping into it.   however, don't suppress the throwing behavior for this.  function onerror(er) {    debug(onerror, er);    unpipe();    dest.removeListener(error, onerror);    if (EElistenerCount(dest, error) === 0) dest.emit(error, er);  }
   Make sure our error handler is attached before userland ones.  prependListener(dest, error, onerror);
   Both close and finish should trigger unpipe, but only once.  function onclose() {    dest.removeListener(finish, onfinish);    unpipe();  }  dest.once(close, onclose);  function onfinish() {    debug(onfinish);    dest.removeListener(close, onclose);    unpipe();  }  dest.once(finish, onfinish);
  function unpipe() {    debug(unpipe);    src.unpipe(dest);  }
   tell the dest that it's being piped to  dest.emit(pipe, src);
   start the flow if it hasn't been started already.  if (!state.flowing) {    debug(pipe resume);    src.resume();  }
  return dest;};
function pipeOnDrain(src) {  return function () {    var state = src._readableState;    debug(pipeOnDrain, state.awaitDrain);    if (state.awaitDrain) state.awaitDrain--;    if (state.awaitDrain === 0 && EElistenerCount(src, data)) {      state.flowing = true;      flow(src);    }  };}
Readable.prototype.unpipe = function (dest) {  var state = this._readableState;
   if we're not piping anywhere, then do nothing.  if (state.pipesCount === 0) return this;
   just one destination.  most common case.  if (state.pipesCount === 1) {     passed in one, but it's not the right one.    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;
     got a match.    state.pipes = null;    state.pipesCount = 0;    state.flowing = false;    if (dest) dest.emit(unpipe, this);    return this;  }
   slow case. multiple pipe destinations.
  if (!dest) {     remove all.    var dests = state.pipes;    var len = state.pipesCount;    state.pipes = null;    state.pipesCount = 0;    state.flowing = false;
    for (var _i = 0; _i < len; _i++) {      dests[_i].emit(unpipe, this);    }return this;  }
   try to find the right one.  var i = indexOf(state.pipes, dest);  if (i === -1) return this;
  state.pipes.splice(i, 1);  state.pipesCount -= 1;  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit(unpipe, this);
  return this;};
 set up data events if they are asked for Ensure readable listeners eventually get somethingReadable.prototype.on = function (ev, fn) {  var res = Stream.prototype.on.call(this, ev, fn);
  if (ev === data) {     Start flowing on next tick if stream isn't explicitly paused    if (this._readableState.flowing !== false) this.resume();  } else if (ev === readable) {    var state = this._readableState;    if (!state.endEmitted && !state.readableListening) {      state.readableListening = state.needReadable = true;      state.emittedReadable = false;      if (!state.reading) {        processNextTick(nReadingNextTick, this);      } else if (state.length) {        emitReadable(this, state);      }    }  }
  return res;};Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self) {  debug(readable nexttick read 0);  self.read(0);}
 pause() and resume() are remnants of the legacy readable stream API If the user uses them, then switch into old mode.Readable.prototype.resume = function () {  var state = this._readableState;  if (!state.flowing) {    debug(resume);    state.flowing = true;    resume(this, state);  }  return this;};
function resume(stream, state) {  if (!state.resumeScheduled) {    state.resumeScheduled = true;    processNextTick(resume_, stream, state);  }}
function resume_(stream, state) {  if (!state.reading) {    debug(resume read 0);    stream.read(0);  }
  state.resumeScheduled = false;  state.awaitDrain = 0;  stream.emit(resume);  flow(stream);  if (state.flowing && !state.reading) stream.read(0);}
Readable.prototype.pause = function () {  debug(call pause flowing=%j, this._readableState.flowing);  if (false !== this._readableState.flowing) {    debug(pause);    this._readableState.flowing = false;    this.emit(pause);  }  return this;};
function flow(stream) {  var state = stream._readableState;  debug(flow, state.flowing);  while (state.flowing && stream.read() !== null) {}}
 wrap an old-style stream as the async data source. This is *not* part of the readable stream interface. It is an ugly unfortunate mess of history.Readable.prototype.wrap = function (stream) {  var state = this._readableState;  var paused = false;
  var self = this;  stream.on(end, function () {    debug(wrapped end);    if (state.decoder && !state.ended) {      var chunk = state.decoder.end();      if (chunk && chunk.length) self.push(chunk);    }
    self.push(null);  });
  stream.on(data, function (chunk) {    debug(wrapped data);    if (state.decoder) chunk = state.decoder.write(chunk);
     don't skip over falsy values in objectMode    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = self.push(chunk);    if (!ret) {      paused = true;      stream.pause();    }  });
   proxy all the other methods.   important when wrapping filters and duplexes.  for (var i in stream) {    if (this[i] === undefined && typeof stream[i] === function) {      this[i] = function (method) {        return function () {          return stream[method].apply(stream, arguments);        };      }(i);    }  }
   proxy certain important events.  var events = [error, close, destroy, pause, resume];  forEach(events, function (ev) {    stream.on(ev, self.emit.bind(self, ev));  });
   when we try to consume some more bytes, simply unpause the   underlying stream.  self._read = function (n) {    debug(wrapped _read, n);    if (paused) {      paused = false;      stream.resume();    }  };
  return self;};
 exposed for testing purposes only.Readable._fromList = fromList;
 Pluck off n bytes from an array of buffers. Length is the combined lengths of all the buffers in the list. This function is designed to be inlinable, so please take care when making changes to the function body.function fromList(n, state) {   nothing buffered  if (state.length === 0) return null;
  var ret;  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {     read it all, truncate the list    if (state.decoder) ret = state.buffer.join();else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);    state.buffer.clear();  } else {     read part of list    ret = fromListPartial(n, state.buffer, state.decoder);  }
  return ret;}
 Extracts only enough buffered data to satisfy the amount requested. This function is designed to be inlinable, so please take care when making changes to the function body.function fromListPartial(n, list, hasStrings) {  var ret;  if (n < list.head.data.length) {     slice is the same for buffers and strings    ret = list.head.data.slice(0, n);    list.head.data = list.head.data.slice(n);  } else if (n === list.head.data.length) {     first chunk is a perfect match    ret = list.shift();  } else {     result spans more than one buffer    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);  }  return ret;}
 Copies a specified amount of characters from the list of buffered data chunks. This function is designed to be inlinable, so please take care when making changes to the function body.function copyFromBufferString(n, list) {  var p = list.head;  var c = 1;  var ret = p.data;  n -= ret.length;  while (p = p.next) {    var str = p.data;    var nb = n > str.length ? str.length : n;    if (nb === str.length) ret += str;else ret += str.slice(0, n);    n -= nb;    if (n === 0) {      if (nb === str.length) {        ++c;        if (p.next) list.head = p.next;else list.head = list.tail = null;      } else {        list.head = p;        p.data = str.slice(nb);      }      break;    }    ++c;  }  list.length -= c;  return ret;}
 Copies a specified amount of bytes from the list of buffered data chunks. This function is designed to be inlinable, so please take care when making changes to the function body.function copyFromBuffer(n, list) {  var ret = bufferShim.allocUnsafe(n);  var p = list.head;  var c = 1;  p.data.copy(ret);  n -= p.data.length;  while (p = p.next) {    var buf = p.data;    var nb = n > buf.length ? buf.length : n;    buf.copy(ret, ret.length - n, 0, nb);    n -= nb;    if (n === 0) {      if (nb === buf.length) {        ++c;        if (p.next) list.head = p.next;else list.head = list.tail = null;      } else {        list.head = p;        p.data = buf.slice(nb);      }      break;    }    ++c;  }  list.length -= c;  return ret;}
function endReadable(stream) {  var state = stream._readableState;
   If we get here before consuming all the bytes, then that is a   bug in node.  Should never happen.  if (state.length > 0) throw new Error(""endReadable()"" called on non-empty stream);
  if (!state.endEmitted) {    state.ended = true;    processNextTick(endReadableNT, state, stream);  }}
function endReadableNT(state, stream) {   Check that we didn't get one last unshift.  if (!state.endEmitted && state.length === 0) {    state.endEmitted = true;    stream.readable = false;    stream.emit(end);  }}
function forEach(xs, f) {  for (var i = 0, l = xs.length; i < l; i++) {    f(xs[i], i);  }}
function indexOf(xs, x) {  for (var i = 0, l = xs.length; i < l; i++) {    if (xs[i] === x) return i;  }  return -1;}}).call(this,require(_process))},{./_stream_duplex:69,./internal/streams/BufferList:74,_process:67,buffer:44,buffer-shims:43,core-util-is:45,events:48,inherits:51,isarray:53,process-nextick-args:66,string_decoder/:80,util:40}],72:[function(require,module,exports){ a transform stream is a readable/writable stream where you do something with the data.  Sometimes it's called a ""filter"", but that's not a great name for it, since that implies a thing where some bits pass through, and others are simply ignored.  (That would be a valid example of a transform, of course.) While the output is causally related to the input, it's not a necessarily symmetric or synchronous transformation.  For example, a zlib stream might take multiple plain-text writes(), and then emit a single compressed chunk some time in the future. Here's how this works: The Transform stream has all the aspects of the readable and writable stream classes.  When you write(chunk), that calls _write(chunk,cb) internally, and returns false if there's a lot of pending writes buffered up.  When you call read(), that calls _read(n) until there's enough pending readable data buffered up. In a transform stream, the written data is placed in a buffer.  When _read(n) is called, it transforms the queued up data, calling the buffered _write cb's as it consumes chunks.  If consuming a single written chunk would result in multiple output chunks, then the first outputted bit calls the readcb, and subsequent chunks just go into the read buffer, and will cause it to emit 'readable' if necessary. This way, back-pressure is actually determined by the reading side, since _read has to be called to start processing a new chunk.  However, a pathological inflate type of transform can cause excessive buffering here.  For example, imagine a stream where every byte of input is interpreted as an integer from 0-255, and then results in that many bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in 1kb of data being output.  In this case, you could write a very small amount of input, and end up with a very large amount of output.  In such a pathological inflating mechanism, there'd be no way to tell the system to stop doing the transform.  A single 4MB write could cause the system to run out of memory. However, even in such a pathological case, only a single written chunk would be consumed, and then the rest would wait (un-transformed) until the results of the previous transformed chunk were consumed.
use strict;
module.exports = Transform;
var Duplex = require(./_stream_duplex);
/*<replacement>*/var util = require(core-util-is);util.inherits = require(inherits);/*</replacement>*/
util.inherits(Transform, Duplex);
function TransformState(stream) {  this.afterTransform = function (er, data) {    return afterTransform(stream, er, data);  };
  this.needTransform = false;  this.transforming = false;  this.writecb = null;  this.writechunk = null;  this.writeencoding = null;}
function afterTransform(stream, er, data) {  var ts = stream._transformState;  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream.emit(error, new Error(no writecb in Transform class));
  ts.writechunk = null;  ts.writecb = null;
  if (data !== null && data !== undefined) stream.push(data);
  cb(er);
  var rs = stream._readableState;  rs.reading = false;  if (rs.needReadable || rs.length < rs.highWaterMark) {    stream._read(rs.highWaterMark);  }}
function Transform(options) {  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
   when the writable side finishes, then flush out anything remaining.  var stream = this;
   start out asking for a readable event once data is transformed.  this._readableState.needReadable = true;
   we have implemented the _read method, and done the other things   that Readable wants before the first _read call, so unset the   sync guard flag.  this._readableState.sync = false;
  if (options) {    if (typeof options.transform === function) this._transform = options.transform;
    if (typeof options.flush === function) this._flush = options.flush;  }
  this.once(prefinish, function () {    if (typeof this._flush === function) this._flush(function (er) {      done(stream, er);    });else done(stream);  });}
Transform.prototype.push = function (chunk, encoding) {  this._transformState.needTransform = false;  return Duplex.prototype.push.call(this, chunk, encoding);};
 This is the part where you do stuff! override this function in implementation classes. 'chunk' is an input chunk. Call `push(newChunk)` to pass along transformed output to the readable side.  You may call 'push' zero or more times. Call `cb(err)` when you are done with this chunk.  If you pass an error, then that'll put the hurt on the whole operation.  If you never call cb(), then you'll never get another chunk.Transform.prototype._transform = function (chunk, encoding, cb) {  throw new Error(Not implemented);};
Transform.prototype._write = function (chunk, encoding, cb) {  var ts = this._transformState;  ts.writecb = cb;  ts.writechunk = chunk;  ts.writeencoding = encoding;  if (!ts.transforming) {    var rs = this._readableState;    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);  }};
 Doesn't matter what the args are here. _transform does all the work. That we got here means that the readable side wants more data.Transform.prototype._read = function (n) {  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {    ts.transforming = true;    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);  } else {     mark that we need a transform, so that any data that comes in     will get processed, now that we've asked for it.    ts.needTransform = true;  }};
function done(stream, er) {  if (er) return stream.emit(error, er);
   if there's nothing in the write buffer, then that means   that nothing more will ever be provided  var ws = stream._writableState;  var ts = stream._transformState;
  if (ws.length) throw new Error(Calling transform done when ws.length != 0);
  if (ts.transforming) throw new Error(Calling transform done when still transforming);
  return stream.push(null);}},{./_stream_duplex:69,core-util-is:45,inherits:51}],73:[function(require,module,exports){(function (process){ A bit simpler than readable streams. Implement an async ._write(chunk, encoding, cb), and it'll handle all the drain event emission and buffering.
use strict;
module.exports = Writable;
/*<replacement>*/var processNextTick = require(process-nextick-args);/*</replacement>*/
/*<replacement>*/var asyncWrite = !process.browser && [v0.10, v0.9.].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;/*</replacement>*/
Writable.WritableState = WritableState;
/*<replacement>*/var util = require(core-util-is);util.inherits = require(inherits);/*</replacement>*/
/*<replacement>*/var internalUtil = {  deprecate: require(util-deprecate)};/*</replacement>*/
/*<replacement>*/var Stream;(function () {  try {    Stream = require(st + ream);  } catch (_) {} finally {    if (!Stream) Stream = require(events).EventEmitter;  }})();/*</replacement>*/
var Buffer = require(buffer).Buffer;/*<replacement>*/var bufferShim = require(buffer-shims);/*</replacement>*/
util.inherits(Writable, Stream);
function nop() {}
function WriteReq(chunk, encoding, cb) {  this.chunk = chunk;  this.encoding = encoding;  this.callback = cb;  this.next = null;}
var Duplex;function WritableState(options, stream) {  Duplex = Duplex || require(./_stream_duplex);
  options = options || {};
   object stream flag to indicate whether or not this stream   contains buffers or objects.  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
   the point at which write() starts returning false   Note: 0 is a valid value, means that we always return false if   the entire buffer is not flushed immediately on write()  var hwm = options.highWaterMark;  var defaultHwm = this.objectMode ? 16 : 16 * 1024;  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
   cast to ints.  this.highWaterMark = ~ ~this.highWaterMark;
  this.needDrain = false;   at the start of calling end()  this.ending = false;   when end() has been called, and returned  this.ended = false;   when 'finish' is emitted  this.finished = false;
   should we decode strings into buffers before passing to _write?   this is here so that some node-core streams can optimize string   handling at a lower level.  var noDecode = options.decodeStrings === false;  this.decodeStrings = !noDecode;
   Crypto is kind of old and crusty.  Historically, its default string   encoding is 'binary' so we have to make this configurable.   Everything else in the universe uses 'utf8', though.  this.defaultEncoding = options.defaultEncoding || utf8;
   not an actual buffer we keep track of, but a measurement   of how much we're waiting to get pushed to some underlying   socket or file.  this.length = 0;
   a flag to see when we're in the middle of a write.  this.writing = false;
   when true all writes will be buffered until .uncork() call  this.corked = 0;
   a flag to be able to tell if the onwrite cb is called immediately,   or on a later tick.  We set this to true at first, because any   actions that shouldn't happen until ""later"" should generally also   not happen before the first write call.  this.sync = true;
   a flag to know if we're processing previously buffered items, which   may call the _write() callback in the same tick, so that we don't   end up in an overlapped onwrite situation.  this.bufferProcessing = false;
   the callback that's passed to _write(chunk,cb)  this.onwrite = function (er) {    onwrite(stream, er);  };
   the callback that the user supplies to write(chunk,encoding,cb)  this.writecb = null;
   the amount that is being written when _write is called.  this.writelen = 0;
  this.bufferedRequest = null;  this.lastBufferedRequest = null;
   number of pending user-supplied write callbacks   this must be 0 before 'finish' can be emitted  this.pendingcb = 0;
   emit prefinish if the only thing we're waiting for is _write cbs   This is relevant for synchronous Transform streams  this.prefinished = false;
   True if the error was already emitted and should not be thrown again  this.errorEmitted = false;
   count buffered requests  this.bufferedRequestCount = 0;
   allocate the first CorkedRequest, there is always   one allocated and free to use, and we maintain at most two  this.corkedRequestsFree = new CorkedRequest(this);}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {  var current = this.bufferedRequest;  var out = [];  while (current) {    out.push(current);    current = current.next;  }  return out;};
(function () {  try {    Object.defineProperty(WritableState.prototype, buffer, {      get: internalUtil.deprecate(function () {        return this.getBuffer();      }, _writableState.buffer is deprecated. Use _writableState.getBuffer  + instead.)    });  } catch (_) {}})();
var Duplex;function Writable(options) {  Duplex = Duplex || require(./_stream_duplex);
   Writable ctor is applied to Duplexes, though they're not   instanceof Writable, they're instanceof Readable.  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this);
   legacy.  this.writable = true;
  if (options) {    if (typeof options.write === function) this._write = options.write;
    if (typeof options.writev === function) this._writev = options.writev;  }
  Stream.call(this);}
 Otherwise people can pipe Writable streams, which is just wrong.Writable.prototype.pipe = function () {  this.emit(error, new Error(Cannot pipe, not readable));};
function writeAfterEnd(stream, cb) {  var er = new Error(write after end);   TODO: defer error events consistently everywhere, not just the cb  stream.emit(error, er);  processNextTick(cb, er);}
 If we get something that is not a buffer, string, null, or undefined, and we're not in objectMode, then that's an error. Otherwise stream chunks are all considered to be of length=1, and the watermarks determine how many objects to keep in the buffer, rather than how many bytes or characters.function validChunk(stream, state, chunk, cb) {  var valid = true;  var er = false;   Always throw error if a null is written   if we are not in object mode then throw   if it is not a buffer, string, or undefined.  if (chunk === null) {    er = new TypeError(May not write null values to stream);  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== string && chunk !== undefined && !state.objectMode) {    er = new TypeError(Invalid non-string/buffer chunk);  }  if (er) {    stream.emit(error, er);    processNextTick(cb, er);    valid = false;  }  return valid;}
Writable.prototype.write = function (chunk, encoding, cb) {  var state = this._writableState;  var ret = false;
  if (typeof encoding === function) {    cb = encoding;    encoding = null;  }
  if (Buffer.isBuffer(chunk)) encoding = buffer;else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== function) cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {    state.pendingcb++;    ret = writeOrBuffer(this, state, chunk, encoding, cb);  }
  return ret;};
Writable.prototype.cork = function () {  var state = this._writableState;
  state.corked++;};
Writable.prototype.uncork = function () {  var state = this._writableState;
  if (state.corked) {    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);  }};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {   node::ParseEncoding() requires lower case.  if (typeof encoding === string) encoding = encoding.toLowerCase();  if (!([hex, utf8, utf-8, ascii, binary, base64, ucs2, ucs-2, utf16le, utf-16le, raw].indexOf((encoding + ).toLowerCase()) > -1)) throw new TypeError(Unknown encoding:  + encoding);  this._writableState.defaultEncoding = encoding;  return this;};
function decodeChunk(state, chunk, encoding) {  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === string) {    chunk = bufferShim.from(chunk, encoding);  }  return chunk;}
 if we're already writing something, then just put this in the queue, and wait our turn.  Otherwise, call _write If we return false, then we need a drain event, so set that flag.function writeOrBuffer(stream, state, chunk, encoding, cb) {  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk)) encoding = buffer;  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;   we must ensure that previous needDrain will not be reset to false.  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {    var last = state.lastBufferedRequest;    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);    if (last) {      last.next = state.lastBufferedRequest;    } else {      state.bufferedRequest = state.lastBufferedRequest;    }    state.bufferedRequestCount += 1;  } else {    doWrite(stream, state, false, len, chunk, encoding, cb);  }
  return ret;}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {  state.writelen = len;  state.writecb = cb;  state.writing = true;  state.sync = true;  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);  state.sync = false;}
function onwriteError(stream, state, sync, er, cb) {  --state.pendingcb;  if (sync) processNextTick(cb, er);else cb(er);
  stream._writableState.errorEmitted = true;  stream.emit(error, er);}
function onwriteStateUpdate(state) {  state.writing = false;  state.writecb = null;  state.length -= state.writelen;  state.writelen = 0;}
function onwrite(stream, er) {  var state = stream._writableState;  var sync = state.sync;  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {     Check if we're actually ready to finish, but don't emit yet    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {      clearBuffer(stream, state);    }
    if (sync) {      /*<replacement>*/      asyncWrite(afterWrite, stream, state, finished, cb);      /*</replacement>*/    } else {        afterWrite(stream, state, finished, cb);      }  }}
function afterWrite(stream, state, finished, cb) {  if (!finished) onwriteDrain(stream, state);  state.pendingcb--;  cb();  finishMaybe(stream, state);}
 Must force callback to be called on nextTick, so that we don't emit 'drain' before the write() consumer gets the 'false' return value, and has a chance to attach a 'drain' listener.function onwriteDrain(stream, state) {  if (state.length === 0 && state.needDrain) {    state.needDrain = false;    stream.emit(drain);  }}
 if there's something in the buffer waiting, then process itfunction clearBuffer(stream, state) {  state.bufferProcessing = true;  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {     Fast case, write everything using _writev()    var l = state.bufferedRequestCount;    var buffer = new Array(l);    var holder = state.corkedRequestsFree;    holder.entry = entry;
    var count = 0;    while (entry) {      buffer[count] = entry;      entry = entry.next;      count += 1;    }
    doWrite(stream, state, true, state.length, buffer, , holder.finish);
     doWrite is almost always async, defer these to save a bit of time     as the hot path ends with doWrite    state.pendingcb++;    state.lastBufferedRequest = null;    if (holder.next) {      state.corkedRequestsFree = holder.next;      holder.next = null;    } else {      state.corkedRequestsFree = new CorkedRequest(state);    }  } else {     Slow case, write chunks one-by-one    while (entry) {      var chunk = entry.chunk;      var encoding = entry.encoding;      var cb = entry.callback;      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);      entry = entry.next;       if we didn't call the onwrite immediately, then       it means that we need to wait until it does.       also, that means that the chunk and cb are currently       being processed, so move the buffer counter past them.      if (state.writing) {        break;      }    }
    if (entry === null) state.lastBufferedRequest = null;  }
  state.bufferedRequestCount = 0;  state.bufferedRequest = entry;  state.bufferProcessing = false;}
Writable.prototype._write = function (chunk, encoding, cb) {  cb(new Error(not implemented));};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {  var state = this._writableState;
  if (typeof chunk === function) {    cb = chunk;    chunk = null;    encoding = null;  } else if (typeof encoding === function) {    cb = encoding;    encoding = null;  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
   .end() fully uncorks  if (state.corked) {    state.corked = 1;    this.uncork();  }
   ignore unnecessary end() calls.  if (!state.ending && !state.finished) endWritable(this, state, cb);};
function needFinish(state) {  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;}
function prefinish(stream, state) {  if (!state.prefinished) {    state.prefinished = true;    stream.emit(prefinish);  }}
function finishMaybe(stream, state) {  var need = needFinish(state);  if (need) {    if (state.pendingcb === 0) {      prefinish(stream, state);      state.finished = true;      stream.emit(finish);    } else {      prefinish(stream, state);    }  }  return need;}
function endWritable(stream, state, cb) {  state.ending = true;  finishMaybe(stream, state);  if (cb) {    if (state.finished) processNextTick(cb);else stream.once(finish, cb);  }  state.ended = true;  stream.writable = false;}
 It seems a linked list but it is not there will be only 2 of these for each streamfunction CorkedRequest(state) {  var _this = this;
  this.next = null;  this.entry = null;
  this.finish = function (err) {    var entry = _this.entry;    _this.entry = null;    while (entry) {      var cb = entry.callback;      state.pendingcb--;      cb(err);      entry = entry.next;    }    if (state.corkedRequestsFree) {      state.corkedRequestsFree.next = _this;    } else {      state.corkedRequestsFree = _this;    }  };}}).call(this,require(_process))},{./_stream_duplex:69,_process:67,buffer:44,buffer-shims:43,core-util-is:45,events:48,inherits:51,process-nextick-args:66,util-deprecate:81}],74:[function(require,module,exports){use strict;
var Buffer = require(buffer).Buffer;/*<replacement>*/var bufferShim = require(buffer-shims);/*</replacement>*/
module.exports = BufferList;
function BufferList() {  this.head = null;  this.tail = null;  this.length = 0;}
BufferList.prototype.push = function (v) {  var entry = { data: v, next: null };  if (this.length > 0) this.tail.next = entry;else this.head = entry;  this.tail = entry;  ++this.length;};
BufferList.prototype.unshift = function (v) {  var entry = { data: v, next: this.head };  if (this.length === 0) this.tail = entry;  this.head = entry;  ++this.length;};
BufferList.prototype.shift = function () {  if (this.length === 0) return;  var ret = this.head.data;  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;  --this.length;  return ret;};
BufferList.prototype.clear = function () {  this.head = this.tail = null;  this.length = 0;};
BufferList.prototype.join = function (s) {  if (this.length === 0) return ;  var p = this.head;  var ret =  + p.data;  while (p = p.next) {    ret += s + p.data;  }return ret;};
BufferList.prototype.concat = function (n) {  if (this.length === 0) return bufferShim.alloc(0);  if (this.length === 1) return this.head.data;  var ret = bufferShim.allocUnsafe(n >>> 0);  var p = this.head;  var i = 0;  while (p) {    p.data.copy(ret, i);    i += p.data.length;    p = p.next;  }  return ret;};},{buffer:44,buffer-shims:43}],75:[function(require,module,exports){module.exports = require(./lib/_stream_passthrough.js)
},{./lib/_stream_passthrough.js:70}],76:[function(require,module,exports){(function (process){var Stream = (function (){  try {    return require(st + ream);  hack to fix a circular dependency issue when used with browserify  } catch(_){}}());exports = module.exports = require(./lib/_stream_readable.js);exports.Stream = Stream || exports;exports.Readable = exports;exports.Writable = require(./lib/_stream_writable.js);exports.Duplex = require(./lib/_stream_duplex.js);exports.Transform = require(./lib/_stream_transform.js);exports.PassThrough = require(./lib/_stream_passthrough.js);
if (!process.browser && process.env.READABLE_STREAM === disable && Stream) {  module.exports = Stream;}
}).call(this,require(_process))},{./lib/_stream_duplex.js:69,./lib/_stream_passthrough.js:70,./lib/_stream_readable.js:71,./lib/_stream_transform.js:72,./lib/_stream_writable.js:73,_process:67}],77:[function(require,module,exports){module.exports = require(./lib/_stream_transform.js)
},{./lib/_stream_transform.js:72}],78:[function(require,module,exports){module.exports = require(./lib/_stream_writable.js)
},{./lib/_stream_writable.js:73}],79:[function(require,module,exports){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require(events).EventEmitter;var inherits = require(inherits);
inherits(Stream, EE);Stream.Readable = require(readable-stream/readable.js);Stream.Writable = require(readable-stream/writable.js);Stream.Duplex = require(readable-stream/duplex.js);Stream.Transform = require(readable-stream/transform.js);Stream.PassThrough = require(readable-stream/passthrough.js);
 Backwards-compat with node 0.4.xStream.Stream = Stream;


 old-style streams.  Note that the pipe method (the only relevant part of this class) is overridden in the Readable class.
function Stream() {  EE.call(this);}
Stream.prototype.pipe = function(dest, options) {  var source = this;
  function ondata(chunk) {    if (dest.writable) {      if (false === dest.write(chunk) && source.pause) {        source.pause();      }    }  }
  source.on(data, ondata);
  function ondrain() {    if (source.readable && source.resume) {      source.resume();    }  }
  dest.on(drain, ondrain);
   If the 'end' option is not supplied, dest.end() will be called when   source gets the 'end' or 'close' events.  Only dest.end() once.  if (!dest._isStdio && (!options || options.end !== false)) {    source.on(end, onend);    source.on(close, onclose);  }
  var didOnEnd = false;  function onend() {    if (didOnEnd) return;    didOnEnd = true;
    dest.end();  }

  function onclose() {    if (didOnEnd) return;    didOnEnd = true;
    if (typeof dest.destroy === function) dest.destroy();  }
   don't leave dangling pipes when there are errors.  function onerror(er) {    cleanup();    if (EE.listenerCount(this, error) === 0) {      throw er;  Unhandled stream error in pipe.    }  }
  source.on(error, onerror);  dest.on(error, onerror);
   remove all the event listeners that were added.  function cleanup() {    source.removeListener(data, ondata);    dest.removeListener(drain, ondrain);
    source.removeListener(end, onend);    source.removeListener(close, onclose);
    source.removeListener(error, onerror);    dest.removeListener(error, onerror);
    source.removeListener(end, cleanup);    source.removeListener(close, cleanup);
    dest.removeListener(close, cleanup);  }
  source.on(end, cleanup);  source.on(close, cleanup);
  dest.on(close, cleanup);
  dest.emit(pipe, source);
   Allow for unix-like usage: A.pipe(B).pipe(C)  return dest;};
},{events:48,inherits:51,readable-stream/duplex.js:68,readable-stream/passthrough.js:75,readable-stream/readable.js:76,readable-stream/transform.js:77,readable-stream/writable.js:78}],80:[function(require,module,exports){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
var Buffer = require(buffer).Buffer;
var isBufferEncoding = Buffer.isEncoding  || function(encoding) {       switch (encoding && encoding.toLowerCase()) {         case hex: case utf8: case utf-8: case ascii: case binary: case base64: case ucs2: case ucs-2: case utf16le: case utf-16le: case raw: return true;         default: return false;       }     }

function assertEncoding(encoding) {  if (encoding && !isBufferEncoding(encoding)) {    throw new Error(Unknown encoding:  + encoding);  }}
 StringDecoder provides an interface for efficiently splitting a series of buffers into a series of JS strings without breaking apart multi-byte characters. CESU-8 is handled as part of the UTF-8 encoding. @TODO Handling all encodings inside a single object makes it very difficult to reason about this code, so it should be split up in the future. @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code points as used by CESU-8.var StringDecoder = exports.StringDecoder = function(encoding) {  this.encoding = (encoding || utf8).toLowerCase().replace(, );  assertEncoding(encoding);  switch (this.encoding) {    case utf8:       CESU-8 represents each of Surrogate Pair by 3-bytes      this.surrogateSize = 3;      break;    case ucs2:    case utf16le:       UTF-16 represents each of Surrogate Pair by 2-bytes      this.surrogateSize = 2;      this.detectIncompleteChar = utf16DetectIncompleteChar;      break;    case base64:       Base-64 stores 3 bytes in 4 chars, and pads the remainder.      this.surrogateSize = 3;      this.detectIncompleteChar = base64DetectIncompleteChar;      break;    default:      this.write = passThroughWrite;      return;  }
   Enough space to store all bytes of a single character. UTF-8 needs 4   bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).  this.charBuffer = new Buffer(6);   Number of bytes received for the current incomplete multi-byte character.  this.charReceived = 0;   Number of bytes expected for the current incomplete multi-byte character.  this.charLength = 0;};

 write decodes the given buffer and returns it as JS string that is guaranteed to not contain any partial multi-byte characters. Any partial character found at the end of the buffer is buffered up, and will be returned when calling write again with the remaining bytes. Note: Converting a Buffer containing an orphan surrogate to a String currently works, but converting a String to a Buffer (via `new Buffer`, or Buffer#write) will replace incomplete surrogates with the unicode replacement character. See https://codereview.chromium.org/121173009/ .StringDecoder.prototype.write = function(buffer) {  var charStr = ;   if our last write ended with an incomplete multibyte character  while (this.charLength) {     determine how many remaining bytes this buffer has to offer for this char    var available = (buffer.length >= this.charLength - this.charReceived) ?        this.charLength - this.charReceived :        buffer.length;
     add the new bytes to the char buffer    buffer.copy(this.charBuffer, this.charReceived, 0, available);    this.charReceived += available;
    if (this.charReceived < this.charLength) {       still not enough chars in this buffer? wait for more ...      return ;    }
     remove bytes belonging to the current character from the buffer    buffer = buffer.slice(available, buffer.length);
     get the character that was split    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
     CESU-8: lead surrogate (D800-DBFF) is also the incomplete character    var charCode = charStr.charCodeAt(charStr.length - 1);    if (charCode >= 0xD800 && charCode <= 0xDBFF) {      this.charLength += this.surrogateSize;      charStr = ;      continue;    }    this.charReceived = this.charLength = 0;
     if there are no more bytes in this buffer, just emit our char    if (buffer.length === 0) {      return charStr;    }    break;  }
   determine and set charLength / charReceived  this.detectIncompleteChar(buffer);
  var end = buffer.length;  if (this.charLength) {     buffer the incomplete character bytes we got    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);    end -= this.charReceived;  }
  charStr += buffer.toString(this.encoding, 0, end);
  var end = charStr.length - 1;  var charCode = charStr.charCodeAt(end);   CESU-8: lead surrogate (D800-DBFF) is also the incomplete character  if (charCode >= 0xD800 && charCode <= 0xDBFF) {    var size = this.surrogateSize;    this.charLength += size;    this.charReceived += size;    this.charBuffer.copy(this.charBuffer, size, 0, size);    buffer.copy(this.charBuffer, 0, 0, size);    return charStr.substring(0, end);  }
   or just emit the charStr  return charStr;};
 detectIncompleteChar determines if there is an incomplete UTF-8 character at the end of the given buffer. If so, it sets this.charLength to the byte length that character, and sets this.charReceived to the number of bytes that are available for this character.StringDecoder.prototype.detectIncompleteChar = function(buffer) {   determine how many bytes we have to check at the end of this buffer  var i = (buffer.length >= 3) ? 3 : buffer.length;
   Figure out if one of the last i bytes of our buffer announces an   incomplete char.  for (; i > 0; i--) {    var c = buffer[buffer.length - i];
     See http://en.wikipedia.org/wiki/UTF-8#Description
     110XXXXX    if (i == 1 && c >> 5 == 0x06) {      this.charLength = 2;      break;    }
     1110XXXX    if (i <= 2 && c >> 4 == 0x0E) {      this.charLength = 3;      break;    }
     11110XXX    if (i <= 3 && c >> 3 == 0x1E) {      this.charLength = 4;      break;    }  }  this.charReceived = i;};
StringDecoder.prototype.end = function(buffer) {  var res = ;  if (buffer && buffer.length)    res = this.write(buffer);
  if (this.charReceived) {    var cr = this.charReceived;    var buf = this.charBuffer;    var enc = this.encoding;    res += buf.slice(0, cr).toString(enc);  }
  return res;};
function passThroughWrite(buffer) {  return buffer.toString(this.encoding);}
function utf16DetectIncompleteChar(buffer) {  this.charReceived = buffer.length % 2;  this.charLength = this.charReceived ? 2 : 0;}
function base64DetectIncompleteChar(buffer) {  this.charReceived = buffer.length % 3;  this.charLength = this.charReceived ? 3 : 0;}
},{buffer:44}],81:[function(require,module,exports){(function (global){
/** * Module exports. */
module.exports = deprecate;
/** * Mark that a method should not be used. * Returns a modified function which warns once by default. * * If `localStorage.noDeprecation = true` is set, then it is a no-op. * * If `localStorage.throwDeprecation = true` is set, then deprecated functions * will throw an Error when invoked. * * If `localStorage.traceDeprecation = true` is set, then deprecated functions * will invoke `console.trace()` instead of `console.error()`. * *    - the function to deprecate *    - the string to print to the console when `fn` is invoked *   a new ""deprecated"" version of `fn` * @api public */
function deprecate (fn, msg) {  if (config(noDeprecation)) {    return fn;  }
  var warned = false;  function deprecated() {    if (!warned) {      if (config(throwDeprecation)) {        throw new Error(msg);      } else if (config(traceDeprecation)) {        console.trace(msg);      } else {        console.warn(msg);      }      warned = true;    }    return fn.apply(this, arguments);  }
  return deprecated;}
/** * Checks `localStorage` for boolean values for the given `name`. * *    *   * @api private */
function config (name) {   accessing global.localStorage can trigger a DOMException in sandboxed iframes  try {    if (!global.localStorage) return false;  } catch (_) {    return false;  }  var val = global.localStorage[name];  if (null == val) return false;  return String(val).toLowerCase() === true;}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{}],82:[function(require,module,exports){arguments[4][51][0].apply(exports,arguments)},{dup:51}],83:[function(require,module,exports){module.exports = function isBuffer(arg) {  return arg && typeof arg === object    && typeof arg.copy === function    && typeof arg.fill === function    && typeof arg.readUInt8 === function;}},{}],84:[function(require,module,exports){(function (process,global){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
var formatRegExp = %g;exports.format = function(f) {  if (!isString(f)) {    var objects = [];    for (var i = 0; i < arguments.length; i++) {      objects.push(inspect(arguments[i]));    }    return objects.join( );  }
  var i = 1;  var args = arguments;  var len = args.length;  var str = String(f).replace(formatRegExp, function(x) {    if (x === %%) return %;    if (i >= len) return x;    switch (x) {      case %s: return String(args[i++]);      case %d: return Number(args[i++]);      case %j:        try {          return JSON.stringify(args[i++]);        } catch (_) {          return [Circular];        }      default:        return x;    }  });  for (var x = args[i]; i < len; x = args[++i]) {    if (isNull(x) || !isObject(x)) {      str +=   + x;    } else {      str +=   + inspect(x);    }  }  return str;};

 Mark that a method should not be used. Returns a modified function which warns once by default. If --no-deprecation is set, then it is a no-op.exports.deprecate = function(fn, msg) {   Allow for deprecating things in the process of starting up.  if (isUndefined(global.process)) {    return function() {      return exports.deprecate(fn, msg).apply(this, arguments);    };  }
  if (process.noDeprecation === true) {    return fn;  }
  var warned = false;  function deprecated() {    if (!warned) {      if (process.throwDeprecation) {        throw new Error(msg);      } else if (process.traceDeprecation) {        console.trace(msg);      } else {        console.error(msg);      }      warned = true;    }    return fn.apply(this, arguments);  }
  return deprecated;};

var debugs = {};var debugEnviron;exports.debuglog = function(set) {  if (isUndefined(debugEnviron))    debugEnviron = process.env.NODE_DEBUG || ;  set = set.toUpperCase();  if (!debugs[set]) {    if (new RegExp(b + set + b, i).test(debugEnviron)) {      var pid = process.pid;      debugs[set] = function() {        var msg = exports.format.apply(exports, arguments);        console.error(%s %d: %s, set, pid, msg);      };    } else {      debugs[set] = function() {};    }  }  return debugs[set];};

/** * Echos the value of a value. Trys to print the value out * in the best way possible given the different types. * *    The object to print out. *    Optional options object that alters the output. *//* legacy: obj, showHidden, depth, colors*/function inspect(obj, opts) {   default options  var ctx = {    seen: [],    stylize: stylizeNoColor  };   legacy...  if (arguments.length >= 3) ctx.depth = arguments[2];  if (arguments.length >= 4) ctx.colors = arguments[3];  if (isBoolean(opts)) {     legacy...    ctx.showHidden = opts;  } else if (opts) {     got an ""options"" object    exports._extend(ctx, opts);  }   set default options  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;  if (isUndefined(ctx.depth)) ctx.depth = 2;  if (isUndefined(ctx.colors)) ctx.colors = false;  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;  if (ctx.colors) ctx.stylize = stylizeWithColor;  return formatValue(ctx, obj, ctx.depth);}exports.inspect = inspect;

 http://en.wikipedia.org/wiki/ANSI_escape_code#graphicsinspect.colors = {  bold : [1, 22],  italic : [3, 23],  underline : [4, 24],  inverse : [7, 27],  white : [37, 39],  grey : [90, 39],  black : [30, 39],  blue : [34, 39],  cyan : [36, 39],  green : [32, 39],  magenta : [35, 39],  red : [31, 39],  yellow : [33, 39]};
 Don't use 'blue' not visible on cmd.exeinspect.styles = {  special: cyan,  number: yellow,  boolean: yellow,  undefined: grey,  null: bold,  string: green,  date: magenta,   ""name"": intentionally not styling  regexp: red};

function stylizeWithColor(str, styleType) {  var style = inspect.styles[styleType];
  if (style) {    return [ + inspect.colors[style][0] + m + str +           [ + inspect.colors[style][1] + m;  } else {    return str;  }}

function stylizeNoColor(str, styleType) {  return str;}

function arrayToHash(array) {  var hash = {};
  array.forEach(function(val, idx) {    hash[val] = true;  });
  return hash;}

function formatValue(ctx, value, recurseTimes) {   Provide a hook for user-specified inspect functions.   Check that value is an object with an inspect function on it  if (ctx.customInspect &&      value &&      isFunction(value.inspect) &&       Filter out the util module, it's inspect function is special      value.inspect !== exports.inspect &&       Also filter out any prototype objects using the circular check.      !(value.constructor && value.constructor.prototype === value)) {    var ret = value.inspect(recurseTimes, ctx);    if (!isString(ret)) {      ret = formatValue(ctx, ret, recurseTimes);    }    return ret;  }
   Primitive types cannot have properties  var primitive = formatPrimitive(ctx, value);  if (primitive) {    return primitive;  }
   Look up the keys of the object.  var keys = Object.keys(value);  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {    keys = Object.getOwnPropertyNames(value);  }
   IE doesn't make error fields non-enumerable   http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx  if (isError(value)      && (keys.indexOf(message) >= 0 || keys.indexOf(description) >= 0)) {    return formatError(value);  }
   Some type of object without properties can be shortcutted.  if (keys.length === 0) {    if (isFunction(value)) {      var name = value.name ? :  + value.name : ;      return ctx.stylize([Function + name + ], special);    }    if (isRegExp(value)) {      return ctx.stylize(RegExp.prototype.toString.call(value), regexp);    }    if (isDate(value)) {      return ctx.stylize(Date.prototype.toString.call(value), date);    }    if (isError(value)) {      return formatError(value);    }  }
  var base = , array = false, braces = [{, }];
   Make Array say that they are Array  if (isArray(value)) {    array = true;    braces = [[, ]];  }
   Make functions say that they are functions  if (isFunction(value)) {    var n = value.name ? :  + value.name : ;    base =  [Function + n + ];  }
   Make RegExps say that they are RegExps  if (isRegExp(value)) {    base =   + RegExp.prototype.toString.call(value);  }
   Make dates with properties first say the date  if (isDate(value)) {    base =   + Date.prototype.toUTCString.call(value);  }
   Make error with message first say the error  if (isError(value)) {    base =   + formatError(value);  }
  if (keys.length === 0 && (!array || value.length == 0)) {    return braces[0] + base + braces[1];  }
  if (recurseTimes < 0) {    if (isRegExp(value)) {      return ctx.stylize(RegExp.prototype.toString.call(value), regexp);    } else {      return ctx.stylize([Object], special);    }  }
  ctx.seen.push(value);
  var output;  if (array) {    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);  } else {    output = keys.map(function(key) {      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);    });  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);}

function formatPrimitive(ctx, value) {  if (isUndefined(value))    return ctx.stylize(undefined, undefined);  if (isString(value)) {    var simple =  + JSON.stringify(value).replace(""""g, )                                             .replace('g, ')                                             .replace(""g, "") + ;    return ctx.stylize(simple, string);  }  if (isNumber(value))    return ctx.stylize( + value, number);  if (isBoolean(value))    return ctx.stylize( + value, boolean);   For some reason typeof null is ""object"", so special case here.  if (isNull(value))    return ctx.stylize(null, null);}

function formatError(value) {  return [ + Error.prototype.toString.call(value) + ];}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {  var output = [];  for (var i = 0, l = value.length; i < l; ++i) {    if (hasOwnProperty(value, String(i))) {      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,          String(i), true));    } else {      output.push();    }  }  keys.forEach(function(key) {    if (!key.match()) {      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,          key, true));    }  });  return output;}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {  var name, str, desc;  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };  if (desc.get) {    if (desc.set) {      str = ctx.stylize([Getter/Setter], special);    } else {      str = ctx.stylize([Getter], special);    }  } else {    if (desc.set) {      str = ctx.stylize([Setter], special);    }  }  if (!hasOwnProperty(visibleKeys, key)) {    name = [ + key + ];  }  if (!str) {    if (ctx.seen.indexOf(desc.value) < 0) {      if (isNull(recurseTimes)) {        str = formatValue(ctx, desc.value, null);      } else {        str = formatValue(ctx, desc.value, recurseTimes - 1);      }      if (str.indexOf() > -1) {        if (array) {          str = str.split().map(function(line) {            return    + line;          }).join().substr(2);        } else {          str =  + str.split().map(function(line) {            return     + line;          }).join();        }      }    } else {      str = ctx.stylize([Circular], special);    }  }  if (isUndefined(name)) {    if (array && key.match()) {      return str;    }    name = JSON.stringify( + key);    if (name.match(""()"")) {      name = name.substr(1, name.length - 2);      name = ctx.stylize(name, name);    } else {      name = name.replace('g, ')                 .replace(""g, "")                 .replace(("""")g, ');      name = ctx.stylize(name, string);    }  }
  return name + :  + str;}

function reduceToSingleString(output, base, braces) {  var numLinesEst = 0;  var length = output.reduce(function(prev, cur) {    numLinesEst++;    if (cur.indexOf() >= 0) numLinesEst++;    return prev + cur.replace(001bmg, ).length + 1;  }, 0);
  if (length > 60) {    return braces[0] +           (base ===  ?  : base +  ) +             +           output.join(,  ) +             +           braces[1];  }
  return braces[0] + base +   + output.join(, ) +   + braces[1];}

 NOTE: These type checking functions intentionally don't use `instanceof` because it is fragile and can be easily faked with `Object.create()`.function isArray(ar) {  return Array.isArray(ar);}exports.isArray = isArray;
function isBoolean(arg) {  return typeof arg === boolean;}exports.isBoolean = isBoolean;
function isNull(arg) {  return arg === null;}exports.isNull = isNull;
function isNullOrUndefined(arg) {  return arg == null;}exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {  return typeof arg === number;}exports.isNumber = isNumber;
function isString(arg) {  return typeof arg === string;}exports.isString = isString;
function isSymbol(arg) {  return typeof arg === symbol;}exports.isSymbol = isSymbol;
function isUndefined(arg) {  return arg === void 0;}exports.isUndefined = isUndefined;
function isRegExp(re) {  return isObject(re) && objectToString(re) === [object RegExp];}exports.isRegExp = isRegExp;
function isObject(arg) {  return typeof arg === object && arg !== null;}exports.isObject = isObject;
function isDate(d) {  return isObject(d) && objectToString(d) === [object Date];}exports.isDate = isDate;
function isError(e) {  return isObject(e) &&      (objectToString(e) === [object Error] || e instanceof Error);}exports.isError = isError;
function isFunction(arg) {  return typeof arg === function;}exports.isFunction = isFunction;
function isPrimitive(arg) {  return arg === null ||         typeof arg === boolean ||         typeof arg === number ||         typeof arg === string ||         typeof arg === symbol ||   ES6 symbol         typeof arg === undefined;}exports.isPrimitive = isPrimitive;
exports.isBuffer = require(./support/isBuffer);
function objectToString(o) {  return Object.prototype.toString.call(o);}

function pad(n) {  return n < 10 ? 0 + n.toString(10) : n.toString(10);}

var months = [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep,              Oct, Nov, Dec];
 26 Feb 16:19:34function timestamp() {  var d = new Date();  var time = [pad(d.getHours()),              pad(d.getMinutes()),              pad(d.getSeconds())].join(:);  return [d.getDate(), months[d.getMonth()], time].join( );}

 log is just a thin wrapper to console.log that prepends a timestampexports.log = function() {  console.log(%s - %s, timestamp(), exports.format.apply(exports, arguments));};

/** * Inherit the prototype methods from one constructor into another. * * The Function.prototype.inherits from lang.js rewritten as a standalone * function (not on Function.prototype). NOTE: If this file is to be loaded * during bootstrapping this function needs to be rewritten using some native * functions as prototype setup using normal JavaScript does not work as * expected during bootstrapping (see mirror.js in r114903). * *    Constructor function which needs to inherit the *     prototype. *    Constructor function to inherit prototype from. */exports.inherits = require(inherits);
exports._extend = function(origin, add) {   Don't do anything if add isn't an object  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);  var i = keys.length;  while (i--) {    origin[keys[i]] = add[keys[i]];  }  return origin;};
function hasOwnProperty(obj, prop) {  return Object.prototype.hasOwnProperty.call(obj, prop);}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./support/isBuffer:83,_process:67,inherits:82}]},{},[1]);"
"module.exports = function (wallaby) {  return {    files: [      server/**/*.js,      client/**/*.js,      lib/**/*.js,      dist/**/*.js,      test/**/*.*,      !test/**/*.test.js    ],
    tests: [      test/**/*.test.js,      !test/integration/**/*.test.js    ],
    compilers: {      **/*.js: wallaby.compilers.babel()    },
    env: {      type: node,      runner: node,      params: {        env: NODE_PATH=test/lib      }    },
    testFramework: jest  }}"
module.exports = require(./dist/lib/router)
module.exports = require(./dist/lib/prefetch)
module.exports = require(./dist/lib/link)
module.exports = require(./dist/lib/head)
"const notifier = require(node-notifier)const childProcess = require(child_process)const isWindows = win.test(process.platform)
export async function compile(fly) {  await fly.parallel([bin, server, lib, client])  await fly.start(unrestrict)}
export async function bin(fly, opts) {  await fly.source(opts.src || bin/*).babel().target(dist/bin, {mode: 0755})  notify(Compiled binaries)}
export async function lib(fly, opts) {  await fly.source(opts.src || lib/**/*.js).babel().target(dist/lib)  notify(Compiled lib files)}
export async function server(fly, opts) {  await fly.source(opts.src || server/**/*.js).babel().target(dist/server)  notify(Compiled server files)}
export async function client(fly, opts) {  await fly.source(opts.src || client/**/*.js).babel().target(dist/client)  notify(Compiled client files)}
export async function unrestrict(fly) {  await fly.source(dist/lib/eval-script.js).babel({    babelrc: false,    plugins: [babel-plugin-transform-remove-strict-mode]  }).target(dist/lib)  notify(Completed removing strict mode for eval script)}
export async function copy(fly) {  await fly.source(pages/**/*.js).target(dist/pages)}
export async function build(fly) {  await fly.serial([copy, compile])}
export default async function (fly) {  await fly.start(build)  await fly.watch(bin/*, bin)  await fly.watch(pages/**/*.js, copy)  await fly.watch(server/**/*.js, server)  await fly.watch(client/**/*.js, [client])  await fly.watch(lib/**/*.js, [lib])}
export async function release(fly) {  await fly.clear(dist).start(build)}
 We run following task inside a NPM script chain and it runs chromedriver inside a child process tree. Even though we kill this task's process, chromedriver exists throughout the lifetime of the original npm script.
export async function pretest(fly) {  const processName =  isWindows ? chromedriver.cmd : chromedriver  const chromedriver = childProcess.spawn(processName, { stdio: inherit })   We need to do this, otherwise this task's process will keep waiting.  setTimeout(() => process.exit(0), 2000)}
export async function posttest(fly) {  try {    const cmd = isWindows ? taskkill /im chromedriver* /t /f : pkill chromedriver    childProcess.execSync(cmd, { stdio: ignore })  } catch(err) {     Do nothing  }}
 notification helperfunction notify(msg) {  return notifier.notify({    title: ▲ Next,    message: msg,    icon: false  })}"
module.exports = require(./dist/lib/error)
module.exports = require(./dist/server/document)
module.exports = require(./dist/lib/css)
module.exports = require(./dist/server/build/babel/preset)
"use strict;
var fs = require(fs);var path = require(path);var mkdirp = require(mkdirp);var baseBundleDirpath = path.join(__dirname, .karma);var osName = require(os-name);
module.exports = function (config) {  var bundleDirpath;  var cfg = {    frameworks: [      browserify,      expect,      mocha    ],    files: [       we use the BDD interface for all of the tests that       aren't interface-specific.      test/browser-fixtures/bdd.fixture.js,      test/acceptance/*.spec.js    ],    exclude: [      test/acceptance/http.spec.js,      test/acceptance/fs.spec.js,      test/acceptance/file-utils.spec.js,      test/acceptance/require/**/*.js,      test/acceptance/misc/**/*.js    ],    preprocessors: {      test/**/*.js: [browserify]    },    browserify: {      debug: true,      configure: function configure (b) {        b.ignore(glob)          .ignore(fs)          .ignore(path)          .ignore(supports-color)          .on(bundled, function (err, content) {            if (!err && bundleDirpath) {               write bundle to directory for debugging              fs.writeFileSync(path.join(bundleDirpath,                bundle. + Date.now() + .js), content);            }          });      }    },    reporters: [spec],    colors: true,    browsers: [osName() === macOS Sierra ? Chrome : PhantomJS],  This is the default browser to run, locally    logLevel: config.LOG_INFO,    client: {      mocha: {        reporter: html      }    }  };
   see https://github.com/saucelabs/karma-sauce-example
   We define the browser to run on the Saucelabs Infrastructure   via the environment variables BROWSER and PLATFORM.   PLATFORM is e.g. ""Windows""   BROWSER is expected to be in the format ""<name>@<version>"",   e.g. ""MicrosoftEdge@latest""   See https://wiki.saucelabs.com/display/DOCS/Platform+Configurator#/   for available browsers.
   TO RUN LOCALLY, execute:   `CI=1 SAUCE_USERNAME=<user> SAUCE_ACCESS_KEY=<key> BROWSER=<browser> PLATFORM=<platform> make test-browser`  var env = process.env;  var sauceConfig;
  if (env.CI) {    console.error(CI mode enabled);    if (env.TRAVIS) {      console.error(Travis-CI detected);      bundleDirpath = path.join(baseBundleDirpath, process.env.TRAVIS_BUILD_ID);      if (env.BROWSER && env.PLATFORM) {        if (env.SAUCE_USERNAME && env.SAUCE_ACCESS_KEY) {           correlate build/tunnel with Travis          sauceConfig = {            build: TRAVIS # + env.TRAVIS_BUILD_NUMBER +             ( + env.TRAVIS_BUILD_ID + ),            tunnelIdentifier: env.TRAVIS_JOB_NUMBER          };          console.error(Configured SauceLabs);        } else {          console.error(No SauceLabs credentials present);        }      }    } else if (env.APPVEYOR) {      console.error(AppVeyor detected);      bundleDirpath = path.join(baseBundleDirpath, process.env.APPVEYOR_BUILD_ID);    } else {      console.error(Local/unknown environment detected);      bundleDirpath = path.join(baseBundleDirpath, local);       don't need to run sauce from appveyor b/c travis does it.      if (!(env.SAUCE_USERNAME || env.SAUCE_ACCESS_KEY)) {        console.error(No SauceLabs credentials present);      } else {        sauceConfig = {          build: require(os).hostname() +  ( + Date.now() + )        };        console.error(Configured SauceLabs);      }    }    mkdirp.sync(bundleDirpath);  } else {    console.error(CI mode disabled);  }
  if (sauceConfig) {    cfg.sauceLabs = sauceConfig;    addSauceTests(cfg);  }
   the MOCHA_UI env var will determine if we're running interface-specific   tests.  since you can only load one at a time, each must be run separately.   each has its own set of acceptance tests and a fixture.   the ""bdd"" fixture is used by default.  var ui = env.MOCHA_UI;  if (ui) {    if (cfg.sauceLabs) {      cfg.sauceLabs.testName = Interface "" + ui + "" integration tests;    }    cfg.files = [      test/browser-fixtures/ + ui + .fixture.js,      test/acceptance/interfaces/ + ui + .spec.js    ];  } else if (cfg.sauceLabs) {    cfg.sauceLabs.testName = Unit Tests;  }
  config.set(cfg);};
function addSauceTests (cfg) {  var env = process.env;  cfg.reporters.push(saucelabs);  cfg.customLaunchers = {};  cfg.customLaunchers[env.BROWSER] = {    base: SauceLabs,    browserName: env.BROWSER.split(@)[0],    version: env.BROWSER.split(@)[1],    platform: env.PLATFORM  };  cfg.browsers = [env.BROWSER];
   See https://github.com/karma-runner/karma-sauce-launcher   See https://github.com/bermi/sauce-connect-launcher#advanced-usage  cfg.sauceLabs = {    public: public,    startConnect: true,    connectOptions: {      connectRetries: 10,      connectRetryTimeout: 60000    }  };
  cfg.concurrency = 5;
  cfg.retryLimit = 5;
   for slow browser booting, ostensibly  cfg.captureTimeout = 120000;  cfg.browserNoActivityTimeout = 20000;}"
"use strict;
module.exports = require(./lib/mocha);"
"use strict;
/* eslint no-unused-vars: off *//* eslint-env commonjs */
/** * Shim process.stdout. */
process.stdout = require(browser-stdout)();
var Mocha = require(./lib/mocha);
/** * Create a Mocha instance. * *   */
var mocha = new Mocha({ reporter: html });
/** * Save timer references to avoid Sinon interfering (see GH-237). */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
var uncaughtExceptionHandlers = [];
var originalOnerrorHandler = global.onerror;
/** * Remove uncaughtException listener. * Revert to original onerror handler if previously defined. */
process.removeListener = function (e, fn) {  if (e === uncaughtException) {    if (originalOnerrorHandler) {      global.onerror = originalOnerrorHandler;    } else {      global.onerror = function () {};    }    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);    if (i !== -1) {      uncaughtExceptionHandlers.splice(i, 1);    }  }};
/** * Implements uncaughtException listener. */
process.on = function (e, fn) {  if (e === uncaughtException) {    global.onerror = function (err, url, line) {      fn(new Error(err +  ( + url + : + line + )));      return !mocha.allowUncaught;    };    uncaughtExceptionHandlers.push(fn);  }};
 The BDD UI is registered by default, but no UI will be functional in the browser without an explicit call to the overridden `mocha.ui` (see below). Ensure that this default UI does not expose its methods to the global scope.mocha.suite.removeAllListeners(pre-require);
var immediateQueue = [];var immediateTimeout;
function timeslice () {  var immediateStart = new Date().getTime();  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {    immediateQueue.shift()();  }  if (immediateQueue.length) {    immediateTimeout = setTimeout(timeslice, 0);  } else {    immediateTimeout = null;  }}
/** * High-performance override of Runner.immediately. */
Mocha.Runner.immediately = function (callback) {  immediateQueue.push(callback);  if (!immediateTimeout) {    immediateTimeout = setTimeout(timeslice, 0);  }};
/** * Function to allow assertion libraries to throw errors directly into mocha. * This is useful when running tests in a browser because window.onerror will * only receive the 'message' attribute of the Error. */mocha.throwError = function (err) {  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {    fn(err);  });  throw err;};
/** * Override ui to ensure that the ui functions are initialized. * Normally this would happen in Mocha.prototype.loadFiles. */
mocha.ui = function (ui) {  Mocha.prototype.ui.call(this, ui);  this.suite.emit(pre-require, global, null, this);  return this;};
/** * Setup mocha with the given setting options. */
mocha.setup = function (opts) {  if (typeof opts === string) {    opts = { ui: opts };  }  for (var opt in opts) {    if (opts.hasOwnProperty(opt)) {      this[opt](opts[opt]);    }  }  return this;};
/** * Run mocha, returning the Runner. */
mocha.run = function (fn) {  var options = mocha.options;  mocha.globals(location);
  var query = Mocha.utils.parseQuery(global.location.search || );  if (query.grep) {    mocha.grep(query.grep);  }  if (query.fgrep) {    mocha.fgrep(query.fgrep);  }  if (query.invert) {    mocha.invert();  }
  return Mocha.prototype.run.call(mocha, function (err) {     The DOM Document is not available in Web Workers.    var document = global.document;    if (document && document.getElementById(mocha) && options.noHighlighting !== true) {      Mocha.utils.highlightTags(code);    }    if (fn) {      fn(err);    }  });};
/** * Expose the process shim. * https://github.com/mochajs/mocha/pull/916 */
Mocha.process = process;
/** * Expose mocha. */
global.Mocha = Mocha;global.mocha = mocha;
 this allows test/acceptance/required-tokens.js to pass; thus, you can now do `const describe = require('mocha').describe` in a browser context (assuming browserification).  should fix #880module.exports = global;"
"use strict
 Karma configurationmodule.exports = function (config) {  var basePath = .
  config.set({
     base path, that will be used to resolve files and exclude    basePath: basePath,
     frameworks to use    frameworks: [jasmine],    files: [      app.js,      packages/**/public/tests/**/*.js    ],     list of files to exclude    exclude: [],
     test results reporter to use     possible values: 'dots', 'progress', 'junit', 'growl', 'coverage'    reporters: [progress, coverage, junit],
    junitReporter: {      outputDir: tests/results/public/junit/    },
     coverage    preprocessors: {       source files that you want to generate coverage for       do not include tests or libraries       (these files will be instrumented by Istanbul)      packages/**/public/controllers/**/*.js: [coverage],      packages/**/public/services/**/*.js: [coverage],      packages/**/public/directives/**/*.js: [coverage],
      packages/**/public/**/*.html: [ng-html2js],
       'packages/**/public/tests/**/*.js': ['webpack', 'babel'],      app.js: [webpack]    },
    webpack: require(./webpack.test.js),    webpackMiddleware: {      noInfo: true    },
    coverageReporter: {      type: html,      dir: tests/results/coverage/    },
    ngHtml2JsPreprocessor: {      cacheIdFromPath: function (path) {        var cacheId = path
         Strip packages/custom/ and public/ to match the pattern of URL that mean.io uses        cacheId = cacheId.replace(packages/custom/, )        cacheId = cacheId.replace(public/, )
        return cacheId      }    },
     web server port    port: 9876,     Look for server on port 3001 (invoked by mocha) - via @brownman    proxies: {      /: http://localhost:3001/    },
     enable / disable colors in the output (reporters and logs)    colors: true,
     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_INFO,
     enable / disable watching file and executing tests whenever any file changes    autoWatch: false,
     Start these browsers, currently available:     - Chrome     - ChromeCanary     - Firefox     - Opera     - Safari (only Mac)     - PhantomJS     - IE (only Windows)    browsers: [PhantomJS],
     If browser does not capture in given timeout [ms], kill it    captureTimeout: 60000,     How long will Karma wait for a message from a browser before disconnecting from it (in ms).    browserNoActivityTimeout: 60000,     Continuous Integration mode     if true, it capture browsers, run tests and exit    singleRun: true,    plugins: [      karma-jasmine,      karma-webpack,      karma-ng-html2js-preprocessor,      karma-phantomjs-launcher,      karma-coverage,      karma-junit-reporter    ]  })}"
"use strict
var gulp = require(gulp)
var env = process.env.NODE_ENV || development/*var defaultTasks = ['clean', 'jshint', 'csslint','serve','watch'] // initialize with development settingsif (env === 'production') { var defaultTasks = ['clean', 'cssmin', 'uglify', 'serve', 'watch'];}if (env === 'test')       { var defaultTasks = ['env:test', 'karma:unit', 'mochaTest'];}*/ read gulp directory contents for the tasks...require(require-dir)(./gulp)console.log(Invoking gulp -, env)gulp.task(default, [clean], function (defaultTasks) {   run with paramater  gulp.start(env)})"
"use strict;
import angular/angular-csp.css;import angular-ui-select/select.min.css;import angular-material/angular-material.min.css;
import jQuery from jquery;import angular;import angular-ui-select/select;import angular-mocks;import angular-cookies;import angular-resource;import angular-sanitize;import angular-ui-router;import angular-jwt;import angular-aria;import angular-animate;import angular-material;
window.$ = jQuery;
angular.element(document).ready(function () {   Fixing facebook bug with redirect  if (window.location.hash === #_=_) {    window.location.hash = #!;  }
   Then init the app  angular.bootstrap(document, [mean]);});
function processModules (modules) {  var packageModules = [ngCookies, ngResource, ui.router, ui.select, ngSanitize, ngMaterial];  var m;  var mn;  for (var index in modules) {    m = modules[index];    mn = mean. + m.name;    angular.module(mn, m.angularDependencies || []);    packageModules.push(mn);  }
  var req = require.context(./packages, true, public(?!testsassetsviews)()js);  req.keys().map(req);  req = require.context(./node_modules, true, meanio-()public(?!testsassetsviews)()js);  req.keys().map(req);  angular.module(mean, packageModules);}
jQuery.ajax(/_getModules, {  dataType: json,  async: false,  success: processModules});"
"use strict;
 Ensure the same AVA install is loaded by the test file as by the test workerif (process.env.AVA_PATH && process.env.AVA_PATH !== __dirname) {	module.exports = require(process.env.AVA_PATH);  eslint-disable-line import/no-dynamic-require} else {	module.exports = require(./lib/main);}"
"#!/usr/bin/env nodeuse strict;const path = require(path);const debug = require(debug)(ava);
 Prefer the local installation of AVA.const resolveCwd = require(resolve-cwd);const localCLI = resolveCwd(ava/cli);
 Use `path.relative()` to detect local AVA installation, because __filename's case is inconsistent on Windows see https://github.com/nodejs/node/issues/6624if (localCLI && path.relative(localCLI, __filename) !== ) {	debug(Using local install of AVA);	require(localCLI);  eslint-disable-line import/no-dynamic-require} else {	if (debug.enabled) {		require(time-require);  eslint-disable-line import/no-unassigned-import	}
	try {		require(./lib/cli).run();	} catch (err) {		console.error(  );		process.exit(1);	}}"
"use strict;const EventEmitter = require(events);const path = require(path);const fs = require(fs);const commonPathPrefix = require(common-path-prefix);const uniqueTempDir = require(unique-temp-dir);const findCacheDir = require(find-cache-dir);const resolveCwd = require(resolve-cwd);const debounce = require(lodash.debounce);const autoBind = require(auto-bind);const Promise = require(bluebird);const getPort = require(get-port);const arrify = require(arrify);const ms = require(ms);const babelConfigHelper = require(./lib/babel-config);const CachingPrecompiler = require(./lib/caching-precompiler);const RunStatus = require(./lib/run-status);const AvaError = require(./lib/ava-error);const AvaFiles = require(./lib/ava-files);const fork = require(./lib/fork);
function resolveModules(modules) {	return arrify(modules).map(name => {		const modulePath = resolveCwd(name);
		if (modulePath === null) {			throw new Error(Could not resolve required module '');		}
		return modulePath;	});}
function getBlankResults() {	return {		stats: {			knownFailureCount: 0,			testCount: 0,			passCount: 0,			skipCount: 0,			todoCount: 0,			failCount: 0		},		tests: []	};}
class Api extends EventEmitter {	constructor(options) {		super();		autoBind(this);
		this.options = Object.assign({match: []}, options);		this.options.require = resolveModules(this.options.require);	}	_runFile(file, runStatus, execArgv) {		const hash = this.precompiler.precompileFile(file);		const precompiled = Object.assign({}, this._precompiledHelpers);		const resolvedfpath = fs.realpathSync(file);		precompiled[resolvedfpath] = hash;
		const options = Object.assign({}, this.options, {precompiled});		const emitter = fork(file, options, execArgv);		runStatus.observeFork(emitter);
		return emitter;	}	run(files, options) {		return new AvaFiles({cwd: this.options.resolveTestsFrom, files})			.findTestFiles()			.then(files => this._run(files, options));	}	_onTimeout(runStatus) {		const timeout = ms(this.options.timeout);		const err = new AvaError(Exited because no new tests completed within the last ms of inactivity);		this._handleError(runStatus, err);		runStatus.emit(timeout);	}	_setupTimeout(runStatus) {		const timeout = ms(this.options.timeout);
		runStatus._restartTimer = debounce(() => {			this._onTimeout(runStatus);		}, timeout);
		runStatus._restartTimer();		runStatus.on(test, runStatus._restartTimer);	}	_cancelTimeout(runStatus) {		runStatus._restartTimer.cancel();	}	_setupPrecompiler(files) {		const isCacheEnabled = this.options.cacheEnabled !== false;		let cacheDir = uniqueTempDir();
		if (isCacheEnabled) {			const foundDir = findCacheDir({				name: ava,				files			});			if (foundDir !== null) {				cacheDir = foundDir;			}		}
		this.options.cacheDir = cacheDir;
		const isPowerAssertEnabled = this.options.powerAssert !== false;		return babelConfigHelper.build(this.options.projectDir, cacheDir, this.options.babelConfig, isPowerAssertEnabled)			.then(result => {				this.precompiler = new CachingPrecompiler({					path: cacheDir,					getBabelOptions: result.getOptions,					babelCacheKeys: result.cacheKeys				});			});	}	_precompileHelpers() {		this._precompiledHelpers = {};
		 Assumes the tests only load helpers from within the `resolveTestsFrom`		 directory. Without arguments this is the `projectDir`, else it's		 `process.cwd()` which may be nested too deeply. This will be solved		 as we implement RFC 001 and move helper compilation into the worker		 processes, avoiding the need for precompilation.		return new AvaFiles({cwd: this.options.resolveTestsFrom})			.findTestHelpers()			.map(file => {  eslint-disable-line array-callback-return				const hash = this.precompiler.precompileFile(file);				this._precompiledHelpers[file] = hash;			});	}	_run(files, options) {		options = options || {};
		const runStatus = new RunStatus({			runOnlyExclusive: options.runOnlyExclusive,			prefixTitles: this.options.explicitTitles || files.length > 1,			base: path.relative(process.cwd(), commonPathPrefix(files)) + path.sep,			failFast: this.options.failFast		});
		this.emit(test-run, runStatus, files);
		if (files.length === 0) {			const err = new AvaError(Couldnt find any files to test);			this._handleError(runStatus, err);			return Promise.resolve(runStatus);		}
		return this._setupPrecompiler(files)			.then(() => this._precompileHelpers())			.then(() => {				if (this.options.timeout) {					this._setupTimeout(runStatus);				}
				let overwatch;				if (this.options.concurrency > 0) {					const concurrency = this.options.serial ? 1 : this.options.concurrency;					overwatch = this._runWithPool(files, runStatus, concurrency);				} else {					 _runWithoutPool exists to preserve legacy behavior, specifically around `.only`					overwatch = this._runWithoutPool(files, runStatus);				}
				return overwatch;			});	}	_computeForkExecArgs(files) {		const execArgv = this.options.testOnlyExecArgv || process.execArgv;		let debugArgIndex = -1;
		 --debug-brk is used in addition to --inspect to break on first line and wait		execArgv.some((arg, index) => {			const isDebugArg = arg === --inspect || arg.indexOf(--inspect=) === 0;			if (isDebugArg) {				debugArgIndex = index;			}
			return isDebugArg;		});
		const isInspect = debugArgIndex >= 0;		if (!isInspect) {			execArgv.some((arg, index) => {				const isDebugArg = arg === --debug || arg === --debug-brk || arg.indexOf(--debug-brk=) === 0 || arg.indexOf(--debug=) === 0;				if (isDebugArg) {					debugArgIndex = index;				}
				return isDebugArg;			});		}
		if (debugArgIndex === -1) {			return Promise.resolve([]);		}
		return Promise			.map(files, () => getPort())			.map(port => {				const forkExecArgv = execArgv.slice();				let flagName = isInspect ? --inspect : --debug;				const oldValue = forkExecArgv[debugArgIndex];				if (oldValue.indexOf(brk) > 0) {					flagName += -brk;				}
				forkExecArgv[debugArgIndex] = =;
				return forkExecArgv;			});	}	_handleError(runStatus, err) {		runStatus.handleExceptions({			exception: err,			file: err.file ? path.relative(process.cwd(), err.file) : undefined		});	}	_runWithoutPool(files, runStatus) {		const tests = [];		let execArgvList;
		 TODO: This should be cleared at the end of the run		runStatus.on(timeout, () => {			tests.forEach(fork => {				fork.exit();			});		});
		return this._computeForkExecArgs(files)			.then(argvList => {				execArgvList = argvList;			})			.return(files)			.each((file, index) => {				return new Promise(resolve => {					const forkArgs = execArgvList[index];					const test = this._runFile(file, runStatus, forkArgs);					tests.push(test);					test.on(stats, resolve);					test.catch(resolve);				}).catch(err => {					err.results = [];					err.file = file;					return Promise.reject(err);				});			})			.then(() => {				if (this.options.match.length > 0 && !runStatus.hasExclusive) {					const err = new AvaError(Couldnt find any matching tests);					err.file = undefined;					err.results = [];					return Promise.reject(err);				}
				const method = this.options.serial ? mapSeries : map;				const options = {					runOnlyExclusive: runStatus.hasExclusive				};
				return Promise[method](files, (file, index) => {					return tests[index].run(options).catch(err => {						err.file = file;						this._handleError(runStatus, err);						return getBlankResults();					});				});			})			.catch(err => {				this._handleError(runStatus, err);				return err.results;			})			.tap(results => {				 If no tests ran, make sure to tear down the child processes				if (results.length === 0) {					tests.forEach(test => {						test.send(teardown);					});				}			})			.then(results => {				 Cancel debounced _onTimeout() from firing				if (this.options.timeout) {					this._cancelTimeout(runStatus);				}
				runStatus.processResults(results);
				return runStatus;			});	}	_runWithPool(files, runStatus, concurrency) {		const tests = [];		let execArgvList;
		runStatus.on(timeout, () => {			tests.forEach(fork => {				fork.exit();			});		});
		return this._computeForkExecArgs(files)			.then(argvList => {				execArgvList = argvList;			})			.return(files)			.map((file, index) => {				return new Promise(resolve => {					const forkArgs = execArgvList[index];					const test = this._runFile(file, runStatus, forkArgs);					tests.push(test);
					 If we're looking for matches, run every single test process in exclusive-only mode					const options = {						runOnlyExclusive: this.options.match.length > 0					};
					resolve(test.run(options));				}).catch(err => {					err.file = file;					this._handleError(runStatus, err);					return getBlankResults();				});			}, {concurrency})			.then(results => {				 Filter out undefined results (usually result of caught exceptions)				results = results.filter(Boolean);
				 Cancel debounced _onTimeout() from firing				if (this.options.timeout) {					this._cancelTimeout(runStatus);				}
				if (this.options.match.length > 0 && !runStatus.hasExclusive) {					results = [];
					const err = new AvaError(Couldnt find any matching tests);					this._handleError(runStatus, err);				}
				runStatus.processResults(results);
				return runStatus;			});	}}
module.exports = Api;"
"module.exports = {	app: {		openDevToolsDetached: true,		hideMainWindow: true	},	workSpaceDirectory: () => __dirname};"
"var browserify = require(browserify);
var packages = require(./admin/client/packages);var b = browserify({	debug: process.env.NODE_ENV !== production,});packages.forEach(function (i) { b.require(i); });b.bundle().pipe(process.stdout);"
"use strict;
/**  * The entry point.  *  *    */module.exports = require(./lib/sequelize);"
"/** * React Starter Kit (https://www.reactstarterkit.com/) * * Copyright © 2014-present Kriasoft, LLC. All rights reserved. * * This source code is licensed under the MIT license found in the * LICENSE.txt file in the root directory of this source tree. */
 ESLint configuration http://eslint.org/docs/user-guide/configuringmodule.exports = {    parser: babel-eslint,
    extends: [      airbnb,      plugin:css-modules/recommended,    ],
    plugins: [      css-modules,    ],
    globals: {      __DEV__: true,    },
    env: {      browser: true,    },
    rules: {       `js` and `jsx` are common extensions       `mjs` is for `universal-router` only, for now      import/extensions: [        error,        always,        {          js: never,          jsx: never,          mjs: never,        },      ],
       Not supporting nested package.json yet       https://github.com/benmosher/eslint-plugin-import/issues/458      import/no-extraneous-dependencies: off,
       Recommend not to leave any console.log in your code       Use console.error, console.warn and console.info instead      no-console: [        error,        {          allow: [warn, error, info],        },      ],
       Allow js files to use jsx syntax, too      react/jsx-filename-extension: off,
       https://github.com/kriasoft/react-starter-kit/pull/961       You can reopen this if you still want this rule      react/prefer-stateless-function: off,    },  };"
"module.exports = function(grunt) {  require(load-grunt-tasks)(grunt);
  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),    meta: {      banner: /* <%= pkg.name %> v<%= pkg.version %> | (c) <%= grunt.template.today(""yyyy"") %> by Matt Zabriskie */    },
    clean: {      dist: dist/**    },
    ts: {      test: {        options: {          lib: [            es5,            es2015.promise,            dom          ]        },        src: [typings/index.d.ts, test/typescript/*.ts]      }    },
    package2bower: {      all: {        fields: [          name,          description,          version,          homepage,          license,          keywords        ]      }    },
    usebanner: {      all: {        options: {          banner: <%= meta.banner %>,          linebreak: false        },        files: {          src: [dist/*.js]        }      }    },
    eslint: {      target: [lib/**/*.js]    },
    karma: {      options: {        configFile: karma.conf.js      },      single: {        singleRun: true      },      continuous: {        singleRun: false      }    },
    nodeunit: {      all: [test/unit/**/*.js]    },
    watch: {      build: {        files: [lib/**/*.js],        tasks: [build]      },      test: {        files: [lib/**/*.js, test/**/*.js, !test/typescript/axios.js, !test/typescript/out.js],        tasks: [test]      }    },
    webpack: require(./webpack.config.js)  });
  grunt.registerMultiTask(package2bower, Sync package.json to bower.json, function () {    var npm = grunt.file.readJSON(package.json);    var bower = grunt.file.readJSON(bower.json);    var fields = this.data.fields || [];
    for (var i=0, l=fields.length; i<l; i++) {      var field = fields[i];      bower[field] = npm[field];    }
    grunt.file.write(bower.json, JSON.stringify(bower, null, 2));  });
  grunt.registerTask(test, Run the jasmine and nodeunit tests, [eslint, nodeunit, karma:single, ts]);  grunt.registerTask(build, Run webpack and bundle the source, [clean, webpack]);  grunt.registerTask(version, Sync version info for a release, [usebanner, package2bower]);};"
"var webpack = require(webpack);var config = {};
function generateConfig(name) {  var uglify = name.indexOf(min) > -1;  var config = {    entry: ./index.js,    output: {      path: dist/,      filename: name + .js,      sourceMapFilename: name + .map,      library: axios,      libraryTarget: umd    },    node: {      process: false    },    devtool: source-map  };
  config.plugins = [    new webpack.DefinePlugin({      process.env.NODE_ENV: JSON.stringify(process.env.NODE_ENV)    })  ];
  if (uglify) {    config.plugins.push(      new webpack.optimize.UglifyJsPlugin({        compressor: {          warnings: false        }      })    );  }
  return config;}
[axios, axios.min].forEach(function (key) {  config[key] = generateConfig(key);});
module.exports = config;"
" Karma configuration Generated on Fri Aug 15 2014 23:11:13 GMT-0500 (CDT)
var webpack = require(webpack);
function createCustomLauncher(browser, version, platform) {  return {    base: SauceLabs,    browserName: browser,    version: version,    platform: platform  };}
module.exports = function(config) {  var customLaunchers = {};  var browsers = [];
  if (process.env.SAUCE_USERNAME || process.env.SAUCE_ACCESS_KEY) {    customLaunchers = {};
    var runAll = true;    var options = [      SAUCE_CHROME,      SAUCE_FIREFOX,      SAUCE_SAFARI,      SAUCE_OPERA,      SAUCE_IE,      SAUCE_EDGE,      SAUCE_IOS,      SAUCE_ANDROID    ];
    options.forEach(function (opt) {      if (process.env[opt]) {        runAll = false;      }    });
     Chrome    if (runAll || process.env.SAUCE_CHROME) {      customLaunchers.SL_Chrome = createCustomLauncher(chrome);       customLaunchers.SL_ChromeDev = createCustomLauncher('chrome', 'dev');       customLaunchers.SL_ChromeBeta = createCustomLauncher('chrome', 'beta');    }
     Firefox    if (runAll || process.env.SAUCE_FIREFOX) {      customLaunchers.SL_Firefox = createCustomLauncher(firefox);       customLaunchers.SL_FirefoxDev = createCustomLauncher('firefox', 'dev');       customLaunchers.SL_FirefoxBeta = createCustomLauncher('firefox', 'beta');    }
     Safari    if (runAll || process.env.SAUCE_SAFARI) {       customLaunchers.SL_Safari7 = createCustomLauncher('safari', 7);       customLaunchers.SL_Safari8 = createCustomLauncher('safari', 8);
      customLaunchers.SL_Safari9 = createCustomLauncher(safari, 9);    }
     Opera    if (runAll || process.env.SAUCE_OPERA) {       TODO The available versions of Opera are too old and lack basic APIs       customLaunchers.SL_Opera11 = createCustomLauncher('opera', 11, 'Windows XP');       customLaunchers.SL_Opera12 = createCustomLauncher('opera', 12, 'Windows 7');    }
     IE    if (runAll || process.env.SAUCE_IE) {       customLaunchers.SL_IE8 = createCustomLauncher('internet explorer', 8, 'Windows 7');      customLaunchers.SL_IE9 = createCustomLauncher(internet explorer, 9, Windows 2008);      customLaunchers.SL_IE10 = createCustomLauncher(internet explorer, 10, Windows 2012);      customLaunchers.SL_IE11 = createCustomLauncher(internet explorer, 11, Windows 8.1);    }
     Edge    if (runAll || process.env.SAUCE_EDGE) {      customLaunchers.SL_Edge = createCustomLauncher(microsoftedge, null, Windows 10);    }
     IOS    if (runAll || process.env.SAUCE_IOS) {       TODO IOS7 capture always timesout       customLaunchers.SL_IOS7 = createCustomLauncher('iphone', '7.1', 'OS X 10.10');       TODO Mobile browsers are causing failures, possibly from too many concurrent VMs       customLaunchers.SL_IOS8 = createCustomLauncher('iphone', '8.4', 'OS X 10.10');       customLaunchers.SL_IOS9 = createCustomLauncher('iphone', '9.2', 'OS X 10.10');    }
     Android    if (runAll || process.env.SAUCE_ANDROID) {       TODO Mobile browsers are causing failures, possibly from too many concurrent VMs       customLaunchers.SL_Android4 = createCustomLauncher('android', '4.4', 'Linux');       customLaunchers.SL_Android5 = createCustomLauncher('android', '5.1', 'Linux');    }
    browsers = Object.keys(customLaunchers);  } else if (process.env.TRAVIS_PULL_REQUEST && process.env.TRAVIS_PULL_REQUEST !== false) {    console.log(      Cannot run on Sauce Labs as encrypted environment variables are not available to PRs.  +      Running on Travis.    );    browsers = [Firefox];  } else {    console.log(Running locally since SAUCE_USERNAME and SAUCE_ACCESS_KEY environment variables are not set.);    browsers = [Firefox, Chrome, Safari, Opera];  }
  config.set({     base path that will be used to resolve all patterns (eg. files, exclude)    basePath: ,

     frameworks to use     available frameworks: https://npmjs.org/browse/keyword/karma-adapter    frameworks: [jasmine-ajax, jasmine, sinon],

     list of files / patterns to load in the browser    files: [      test/specs/__helpers.js,      test/specs/**/*.spec.js,    ],

     list of files to exclude    exclude: [
    ],

     preprocess matching files before serving them to the browser     available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor    preprocessors: {      test/specs/__helpers.js: [webpack, sourcemap],      test/specs/**/*.spec.js: [webpack, sourcemap]    },

     test results reporter to use     possible values: 'dots', 'progress'     available reporters: https://npmjs.org/browse/keyword/karma-reporter    reporters: [dots, coverage, saucelabs],

     web server port    port: 9876,

     Increase timeouts to prevent the issue with disconnected tests (https://goo.gl/nstA69)    captureTimeout: 4 * 60 * 1000,    browserDisconnectTimeout: 10000,    browserDisconnectTolerance: 1,    browserNoActivityTimeout: 4 * 60 * 1000,

     enable / disable colors in the output (reporters and logs)    colors: true,

     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_INFO,

     enable / disable watching file and executing tests whenever any file changes    autoWatch: false,

     start these browsers     available browser launchers: https://npmjs.org/browse/keyword/karma-launcher    browsers: browsers,

     Continuous Integration mode     if true, Karma captures browsers, runs the tests and exits    singleRun: false,
     Webpack config    webpack: {      cache: true,      devtool: inline-source-map,      module: {        postLoaders: [          {            test: js,            exclude: (node_modulestest),            loader: istanbul-instrumenter          }        ]      },      externals: [        {          ./adapters/http: var undefined        }      ],      plugins: [        new webpack.DefinePlugin({          process.env.NODE_ENV: JSON.stringify(test)        })      ]    },
    webpackServer: {      stats: {        colors: true      }    },

     Coverage reporting    coverageReporter: {      type: lcov,      dir: coverage/,      subdir: .    },

     SauceLabs config    sauceLabs: {      recordScreenshots: false,      connectOptions: {        port: 5757,        logfile: sauce_connect.log      },      public: public    },
    customLaunchers: customLaunchers  });};"
module.exports = require(./lib/axios);
"/** * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
var debug  = require(debug)(pm2:conf);var p      = require(path);var util   = require(util);var chalk  = require(chalk);var semver = require(semver);
/** * Get PM2 path structure */var path_structure = require(./paths.js)(process.env.OVER_HOME);
/** * Constants variables used by PM2 */var csts = {  PREFIX_MSG              : chalk.green([PM2] ),  PREFIX_MSG_ERR          : chalk.red([PM2][ERROR] ),  PREFIX_MSG_MOD          : chalk.bold.green([PM2][Module] ),  PREFIX_MSG_MOD_ERR      : chalk.red([PM2][Module][ERROR] ),  PREFIX_MSG_WARNING      : chalk.yellow([PM2][WARN] ),  PREFIX_MSG_SUCCESS      : chalk.cyan([PM2] ),
  TEMPLATE_FOLDER         : p.join(__dirname, lib/templates),
  APP_CONF_TPL            : ecosystem.tpl,  APP_CONF_TPL_SIMPLE     : ecosystem-simple.tpl,  SAMPLE_CONF_FILE        : sample-conf.js,  LOGROTATE_SCRIPT        : logrotate.d/pm2,
  DOCKERFILE_NODEJS       : Dockerfiles/Dockerfile-nodejs.tpl,  DOCKERFILE_JAVA         : Dockerfiles/Dockerfile-java.tpl,  DOCKERFILE_RUBY         : Dockerfiles/Dockerfile-ruby.tpl,
  SUCCESS_EXIT            : 0,  ERROR_EXIT              : 1,  CODE_UNCAUGHTEXCEPTION  : 1,
  IS_WINDOWS              : (process.platform === win32 || process.platform === win64),  ONLINE_STATUS           : online,  STOPPED_STATUS          : stopped,  STOPPING_STATUS         : stopping,  LAUNCHING_STATUS        : launching,  ERRORED_STATUS          : errored,  ONE_LAUNCH_STATUS       : one-launch-status,
  CLUSTER_MODE_ID         : cluster_mode,  FORK_MODE_ID            : fork_mode,
  KEYMETRICS_ROOT_URL     : process.env.KEYMETRICS_NODE || root.keymetrics.io,  KEYMETRICS_BANNER       : ../lib/keymetrics,  DEFAULT_MODULE_JSON     : package.json,
  REMOTE_PORT_TCP         : isNaN(parseInt(process.env.KEYMETRICS_PUSH_PORT)) ? 80 : parseInt(process.env.KEYMETRICS_PUSH_PORT),  REMOTE_PORT             : 41624,  REMOTE_REVERSE_PORT     : isNaN(parseInt(process.env.KEYMETRICS_REVERSE_PORT)) ? 43554 : parseInt(process.env.KEYMETRICS_REVERSE_PORT),  REMOTE_HOST             : s1.keymetrics.io,  SEND_INTERVAL           : 1000,  GRACEFUL_TIMEOUT        : parseInt(process.env.PM2_GRACEFUL_TIMEOUT) || 8000,  GRACEFUL_LISTEN_TIMEOUT : parseInt(process.env.PM2_GRACEFUL_LISTEN_TIMEOUT) || 3000,  LOGS_BUFFER             : 10,  CONTEXT_ON_ERROR        : 2,  AGGREGATION_DURATION    : process.env.PM2_DEBUG || process.env.NODE_ENV === test || process.env.NODE_ENV === development ? 3000 : 5 * 60000,  TRACE_FLUSH_INTERVAL    : process.env.PM2_DEBUG || process.env.NODE_ENV === local_test ? 1000 : 60000,
   Concurrent actions when doing start/restart/reload  CONCURRENT_ACTIONS      : (function() {    var concurrent_actions = parseInt(process.env.PM2_CONCURRENT_ACTIONS) || 1;    if (semver.satisfies(process.versions.node, >= 4.0.0))      concurrent_actions = 2;    debug(Using %d parallelism (CONCURRENT_ACTIONS), concurrent_actions);    return concurrent_actions;  })(),
  DEBUG                   : process.env.PM2_DEBUG || false,  WEB_IPADDR              : process.env.PM2_API_IPADDR || 0.0.0.0,  WEB_PORT                : parseInt(process.env.PM2_API_PORT)  || 9615,  MODIFY_REQUIRE          : process.env.PM2_MODIFY_REQUIRE || false,
  WORKER_INTERVAL         : process.env.PM2_WORKER_INTERVAL || 30000,  KILL_TIMEOUT            : process.env.PM2_KILL_TIMEOUT || 1600,  PM2_PROGRAMMATIC        : typeof(process.env.pm_id) !== undefined || process.env.PM2_PROGRAMMATIC,  PM2_LOG_DATE_FORMAT     : process.env.PM2_LOG_DATE_FORMAT !== undefined ? process.env.PM2_LOG_DATE_FORMAT : YYYY-MM-DD HH:mm:ss
};
module.exports = util._extend(csts, path_structure);"
"
/** * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
var debug = require(debug)(pm2:paths);var p     = require(path);
function getDefaultPM2Home() {  var PM2_ROOT_PATH;
  if (process.env.PM2_HOME)    PM2_ROOT_PATH = process.env.PM2_HOME;  else if (process.env.HOME && !process.env.HOMEPATH)    PM2_ROOT_PATH = p.resolve(process.env.HOME, .pm2);  else if (process.env.HOME || process.env.HOMEPATH)    PM2_ROOT_PATH = p.resolve(process.env.HOMEDRIVE, process.env.HOME || process.env.HOMEPATH, .pm2);  else {    console.error([PM2][Initialization] Environment variable HOME (Linux) or HOMEPATH (Windows) are not set!);    console.error([PM2][Initialization] Defaulting to /etc/.pm2);    PM2_ROOT_PATH = p.resolve(/etc, .pm2);  }
  debug(pm2 home resolved to %s, PM2_ROOT_PATH, process.env.HOME);  return PM2_ROOT_PATH;}
module.exports = function(PM2_HOME) {  if (!PM2_HOME)    PM2_HOME = getDefaultPM2Home()
  var pm2_file_stucture = {    PM2_HOME                 : PM2_HOME,    PM2_ROOT_PATH            : PM2_HOME,
    PM2_CONF_FILE            : p.resolve(PM2_HOME, conf.js),    PM2_MODULE_CONF_FILE     : p.resolve(PM2_HOME, module_conf.json),
    PM2_LOG_FILE_PATH        : p.resolve(PM2_HOME, pm2.log),    PM2_PID_FILE_PATH        : p.resolve(PM2_HOME, pm2.pid),
    DEFAULT_PID_PATH         : p.resolve(PM2_HOME, pids),    DEFAULT_LOG_PATH         : p.resolve(PM2_HOME, logs),    DUMP_FILE_PATH           : p.resolve(PM2_HOME, dump.pm2),
    DAEMON_RPC_PORT          : p.resolve(PM2_HOME, rpc.sock),    DAEMON_PUB_PORT          : p.resolve(PM2_HOME, pub.sock),    INTERACTOR_RPC_PORT      : p.resolve(PM2_HOME, interactor.sock),
    INTERACTOR_LOG_FILE_PATH : p.resolve(PM2_HOME, agent.log),    INTERACTOR_PID_PATH      : p.resolve(PM2_HOME, agent.pid),    INTERACTION_CONF         : p.resolve(PM2_HOME, agent.json5)  };
  if (process.platform === win32 ||      process.platform === win64) {    @todo instead of static unique rpc/pub file custom with PM2_HOME or UID    pm2_file_stucture.DAEMON_RPC_PORT = .piperpc.sock;    pm2_file_stucture.DAEMON_PUB_PORT = .pipepub.sock;    pm2_file_stucture.INTERACTOR_RPC_PORT = .pipeinteractor.sock;  }
  return pm2_file_stucture;};"
"/** * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
process.env.PM2_PROGRAMMATIC = true;
var API = require(./lib/API.js);
module.exports = new API;module.exports.custom = API;"
" This is not the main file in the npm package, but here so we can use github tarballs as packages when necessary.module.exports = require(./build/);"
"module.exports = function(config) {    config.set({        browsers: [Firefox],        files: [mocha_test/*.js],        frameworks: [browserify, mocha],        preprocessors: {            mocha_test/*.js: [browserify]        },        reporters: [mocha],        singleRun: true,
        browserify: {            debug: true,            transform: [babelify]        },
        client: {            mocha: {                grep: @nodeonly,                invert: true            }        }    });};"
"/*! * express * Copyright(c) 2009-2013 TJ Holowaychuk * Copyright(c) 2013 Roman Shtylman * Copyright(c) 2014-2015 Douglas Christopher Wilson * MIT Licensed */
use strict;
module.exports = require(./lib/express);"
"const gulp = require(gulp);const mocha = require(gulp-mocha);const babel = require(gulp-babel);const istanbul = require(gulp-istanbul);const help = require(gulp-task-listing);const del = require(del);
gulp.task(help, help);
gulp.task(default, [transpile]);
const TRANSPILE_DEST_DIR = ./dist;
 By default, individual js files are transformed by babel and exported to /distgulp.task(transpile, function () {  return gulp.src(lib/*.js)    .pipe(babel({ presets: [es2015] }))    .pipe(gulp.dest(TRANSPILE_DEST_DIR));});
gulp.task(clean, function () {  return del([TRANSPILE_DEST_DIR]);})
gulp.task(test, [transpile], function(){  return gulp.src(test/socket.io.js, {read: false})    .pipe(mocha({      slow: 200,      reporter: spec,      bail: true,      timeout: 10000    }))    .once(error, function (err) {      console.error(err.stack);      process.exit(1);    })    .once(end, function () {      process.exit();    });});
gulp.task(set-compat-node-env, function() {  process.env.TEST_VERSION = compat;});
gulp.task(test-compat, [set-compat-node-env, test]);
gulp.task(istanbul-pre-test, function () {  return gulp.src([lib/**/*.js])     Covering files    .pipe(istanbul())     Force `require` to return covered files    .pipe(istanbul.hookRequire());});
gulp.task(test-cov, [istanbul-pre-test], function(){  return gulp.src(test/socket.io.js, {read: false})    .pipe(mocha({      reporter: dot    }))    .pipe(istanbul.writeReports())    .once(error, function (err){      console.error(err.stack);      process.exit(1);    })    .once(end, function (){      process.exit();    });});"
code
" * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var spawn = require(child_process).spawn;var readlink = require(graceful-readlink).readlinkSync;var path = require(path);var dirname = path.dirname;var basename = path.basename;var fs = require(fs);
 * Expose the root command. */
exports = module.exports = new Command();
 * Expose `Command`. */
exports.Command = Command;
 * Expose `Option`. */
exports.Option = Option;
 * Initialize a new `Option` with the given `flags` and `description`. * *    *    * @api public */
function Option(flags, description) {  this.flags = flags;  this.required = ~flags.indexOf(<);  this.optional = ~flags.indexOf([);  this.bool = !~flags.indexOf(-no-);  flags = flags.split();  if (flags.length > 1 && !.test(flags[1])) this.short = flags.shift();  this.long = flags.shift();  this.description = description || ;}
 * Return option name. * *   * @api private */
Option.prototype.name = function() {  return this.long    .replace(--, )    .replace(no-, );};
 * Check if `arg` matches the short or long flag. * *    *   * @api private */
Option.prototype.is = function(arg) {  return arg == this.short || arg == this.long;};
 * Initialize a new `Command`. * *    * @api public */
function Command(name) {  this.commands = [];  this.options = [];  this._execs = {};  this._allowUnknownOption = false;  this._args = [];  this._name = name || ;}
 * Inherit from `EventEmitter.prototype`. */
Command.prototype.__proto__ = EventEmitter.prototype;
 * Add command `name`. * * The `.action()` callback is invoked when the * command `name` is specified via __ARGV__, * and the remaining arguments are applied to the * function for access. * * When the `name` is ""*"" an un-matched command * will be passed as the first arg, followed by * the rest of __ARGV__ remaining. * * Examples: * *      program *        .version('0.0.1') *        .option('-C, --chdir <path>', 'change the working directory') *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf') *        .option('-T, --no-tests', 'ignore test hook') * *      program *        .command('setup') *        .description('run remote setup commands') *        .action(function() { *          console.log('setup'); *        }); * *      program *        .command('exec <cmd>') *        .description('run the given remote command') *        .action(function(cmd) { *          console.log('exec ""%s""', cmd); *        }); * *      program *        .command('teardown <dir> [otherDirs...]') *        .description('run teardown commands') *        .action(function(dir, otherDirs) { *          console.log('dir ""%s""', dir); *          if (otherDirs) { *            otherDirs.forEach(function (oDir) { *              console.log('dir ""%s""', oDir); *            }); *          } *        }); * *      program *        .command('*') *        .description('deploy the given env') *        .action(function(env) { *          console.log('deploying ""%s""', env); *        }); * *      program.parse(process.argv);  * *    *    for git-style sub-commands *   the new command * @api public */
Command.prototype.command = function(name, desc, opts) {  opts = opts || {};  var args = name.split( );  var cmd = new Command(args.shift());
  if (desc) {    cmd.description(desc);    this.executables = true;    this._execs[cmd._name] = true;    if (opts.isDefault) this.defaultExecutable = cmd._name;  }
  cmd._noHelp = !!opts.noHelp;  this.commands.push(cmd);  cmd.parseExpectedArgs(args);  cmd.parent = this;
  if (desc) return this;  return cmd;};
 * Define argument syntax for the top-level command. * * @api public */
Command.prototype.arguments = function (desc) {  return this.parseExpectedArgs(desc.split( ));};
 * Add an implicit `help [cmd]` subcommand * which invokes `--help` for the given command. * * @api private */
Command.prototype.addImplicitHelpCommand = function() {  this.command(help [cmd], display help for [cmd]);};
 * Parse expected `args`. * * For example `[""[type]""]` becomes `[{ required: false, name: 'type' }]`. * *    *   for chaining * @api public */
Command.prototype.parseExpectedArgs = function(args) {  if (!args.length) return;  var self = this;  args.forEach(function(arg) {    var argDetails = {      required: false,      name: ,      variadic: false    };
    switch (arg[0]) {      case <:        argDetails.required = true;        argDetails.name = arg.slice(1, -1);        break;      case [:        argDetails.name = arg.slice(1, -1);        break;    }
    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === ...) {      argDetails.variadic = true;      argDetails.name = argDetails.name.slice(0, -3);    }    if (argDetails.name) {      self._args.push(argDetails);    }  });  return this;};
 * Register callback `fn` for the command. * * Examples: * *      program *        .command('help') *        .description('display verbose help') *        .action(function() { *           // output help here *        }); * *    *   for chaining * @api public */
Command.prototype.action = function(fn) {  var self = this;  var listener = function(args, unknown) {     Parse any so-far unknown options    args = args || [];    unknown = unknown || [];
    var parsed = self.parseOptions(unknown);
     Output help if necessary    outputHelpIfNecessary(self, parsed.unknown);
     If there are still any unknown options, then we simply     die, unless someone asked for help, in which case we give it     to them, and then we die.    if (parsed.unknown.length > 0) {      self.unknownOption(parsed.unknown[0]);    }
     Leftover arguments need to be pushed back. Fixes issue #56    if (parsed.args.length) args = parsed.args.concat(args);
    self._args.forEach(function(arg, i) {      if (arg.required && null == args[i]) {        self.missingArgument(arg.name);      } else if (arg.variadic) {        if (i !== self._args.length - 1) {          self.variadicArgNotLast(arg.name);        }
        args[i] = args.splice(i);      }    });
     Always append ourselves to the end of the arguments,     to make sure we match the number of arguments the user     expects    if (self._args.length) {      args[self._args.length] = self;    } else {      args.push(self);    }
    fn.apply(self, args);  };  var parent = this.parent || this;  var name = parent === this ?  : this._name;  parent.on(name, listener);  if (this._alias) parent.on(this._alias, listener);  return this;};
 * Define option with `flags`, `description` and optional * coercion `fn`. * * The `flags` string should contain both the short and long flags, * separated by comma, a pipe or space. The following are all valid * all will output this way when `--help` is used. * *    ""-p, --pepper"" *    ""-p|--pepper"" *    ""-p --pepper"" * * Examples: * *     // simple boolean defaulting to false *     program.option('-p, --pepper', 'add pepper'); * *     --pepper *     program.pepper *     // => Boolean * *     // simple boolean defaulting to true *     program.option('-C, --no-cheese', 'remove cheese'); * *     program.cheese *     // => true * *     --no-cheese *     program.cheese *     // => false * *     // required argument *     program.option('-C, --chdir <path>', 'change the working directory'); * *     --chdir /tmp *     program.chdir *     // => ""/tmp"" * *     // optional argument *     program.option('-c, --cheese [type]', 'add cheese [marble]'); * *    *    *    or default *    *   for chaining * @api public */
Command.prototype.option = function(flags, description, fn, defaultValue) {  var self = this    , option = new Option(flags, description)    , oname = option.name()    , name = camelcase(oname);
   default as 3rd arg  if (typeof fn != function) {    if (fn instanceof RegExp) {      var regex = fn;      fn = function(val, def) {        var m = regex.exec(val);        return m ? m[0] : def;      }    }    else {      defaultValue = fn;      fn = null;    }  }
   preassign default value only for --no-*, [optional], or <required>  if (false == option.bool || option.optional || option.required) {     when --no-* we make sure default is true    if (false == option.bool) defaultValue = true;     preassign only if we have a default    if (undefined !== defaultValue) self[name] = defaultValue;  }
   register the option  this.options.push(option);
   when it's passed assign the value   and conditionally invoke the callback  this.on(oname, function(val) {     coercion    if (null !== val && fn) val = fn(val, undefined === self[name]      ? defaultValue      : self[name]);
     unassigned or bool    if (boolean == typeof self[name] || undefined == typeof self[name]) {       if no value, bool true, and we have a default, then use it!      if (null == val) {        self[name] = option.bool          ? defaultValue || true          : false;      } else {        self[name] = val;      }    } else if (null !== val) {       reassign      self[name] = val;    }  });
  return this;};
 * Allow unknown options on the command line. * *    if `true` or omitted, no error will be thrown * for unknown options. * @api public */Command.prototype.allowUnknownOption = function(arg) {    this._allowUnknownOption = arguments.length === 0 || arg;    return this;};
 * Parse `argv`, settings options and invoking commands when defined. * *    *   for chaining * @api public */
Command.prototype.parse = function(argv) {   implicit help  if (this.executables) this.addImplicitHelpCommand();
   store raw args  this.rawArgs = argv;
   guess name  this._name = this._name || basename(argv[1], .js);
   github-style sub-commands with no sub-command  if (this.executables && argv.length < 3 && !this.defaultExecutable) {     this user needs help    argv.push(--help);  }
   process argv  var parsed = this.parseOptions(this.normalize(argv.slice(2)));  var args = this.args = parsed.args;
  var result = this.parseArgs(this.args, parsed.unknown);
   executable sub-commands  var name = result.args[0];
  var aliasCommand = null;   check alias of sub commands  if (name) {    aliasCommand = this.commands.filter(function(command) {      return command.alias() === name;    })[0];  }
  if (this._execs[name] && typeof this._execs[name] != function) {    return this.executeSubCommand(argv, args, parsed.unknown);  } else if (aliasCommand) {     is alias of a subCommand    args[0] = aliasCommand._name;    return this.executeSubCommand(argv, args, parsed.unknown);  } else if (this.defaultExecutable) {     use the default subcommand    args.unshift(this.defaultExecutable);    return this.executeSubCommand(argv, args, parsed.unknown);  }
  return result;};
 * Execute a sub-command executable. * *    *    *    * @api private */
Command.prototype.executeSubCommand = function(argv, args, unknown) {  args = args.concat(unknown);
  if (!args.length) this.help();  if (help == args[0] && 1 == args.length) this.help();
   <cmd> --help  if (help == args[0]) {    args[0] = args[1];    args[1] = --help;  }
   executable  var f = argv[1];   name of the subcommand, link `pm-install`  var bin = basename(f, .js) + - + args[0];

   In case of globally installed, get the base dir where executable    subcommand file should be located at  var baseDir    , link = readlink(f);
   when symbolink is relative path  if (link !== f && link.charAt(0) !== /) {    link = path.join(dirname(f), link)  }  baseDir = dirname(link);
   prefer local `./<bin>` to bin in the $PATH  var localBin = path.join(baseDir, bin);
   whether bin file is a js script with explicit `.js` extension  var isExplicitJS = false;  if (exists(localBin + .js)) {    bin = localBin + .js;    isExplicitJS = true;  } else if (exists(localBin)) {    bin = localBin;  }
  args = args.slice(1);
  var proc;  if (process.platform !== win32) {    if (isExplicitJS) {      args.unshift(bin);       add executable arguments to spawn      args = (process.execArgv || []).concat(args);
      proc = spawn(node, args, { stdio: inherit, customFds: [0, 1, 2] });    } else {      proc = spawn(bin, args, { stdio: inherit, customFds: [0, 1, 2] });    }  } else {    args.unshift(bin);    proc = spawn(process.execPath, args, { stdio: inherit});  }
  proc.on(close, process.exit.bind(process));  proc.on(error, function(err) {    if (err.code == ENOENT) {      console.error(  %s(1) does not exist, try --help, bin);    } else if (err.code == EACCES) {      console.error(  %s(1) not executable. try chmod or run with root, bin);    }    process.exit(1);  });
   Store the reference to the child process  this.runningCommand = proc;};
 * Normalize `args`, splitting joined short flags. For example * the arg ""-abc"" is equivalent to ""-a -b -c"". * This also normalizes equal sign and splits ""--abc=def"" into ""--abc def"". * *    *   * @api private */
Command.prototype.normalize = function(args) {  var ret = []    , arg    , lastOpt    , index;
  for (var i = 0, len = args.length; i < len; ++i) {    arg = args[i];    if (i > 0) {      lastOpt = this.optionFor(args[i-1]);    }
    if (arg === --) {       Honor option terminator      ret = ret.concat(args.slice(i));      break;    } else if (lastOpt && lastOpt.required) {      ret.push(arg);    } else if (arg.length > 1 && - == arg[0] && - != arg[1]) {      arg.slice(1).split().forEach(function(c) {        ret.push(- + c);      });    } else if (--.test(arg) && ~(index = arg.indexOf(=))) {      ret.push(arg.slice(0, index), arg.slice(index + 1));    } else {      ret.push(arg);    }  }
  return ret;};
 * Parse command `args`. * * When listener(s) are available those * callbacks are invoked, otherwise the ""*"" * event is emitted and those actions are invoked. * *    *   for chaining * @api private */
Command.prototype.parseArgs = function(args, unknown) {  var name;
  if (args.length) {    name = args[0];    if (this.listeners(name).length) {      this.emit(args.shift(), args, unknown);    } else {      this.emit(, args);    }  } else {    outputHelpIfNecessary(this, unknown);
     If there were no args and we have unknown options,     then they are extraneous and we need to error.    if (unknown.length > 0) {      this.unknownOption(unknown[0]);    }  }
  return this;};
 * Return an option matching `arg` if any. * *    *   * @api private */
Command.prototype.optionFor = function(arg) {  for (var i = 0, len = this.options.length; i < len; ++i) {    if (this.options[i].is(arg)) {      return this.options[i];    }  }};
 * Parse options from `argv` returning `argv` * void of these options. * *    *   * @api public */
Command.prototype.parseOptions = function(argv) {  var args = []    , len = argv.length    , literal    , option    , arg;
  var unknownOptions = [];
   parse options  for (var i = 0; i < len; ++i) {    arg = argv[i];
     literal args after --    if (literal) {      args.push(arg);      continue;    }
    if (-- == arg) {      literal = true;      continue;    }
     find matching Option    option = this.optionFor(arg);
     option is defined    if (option) {       requires arg      if (option.required) {        arg = argv[++i];        if (null == arg) return this.optionMissingArgument(option);        this.emit(option.name(), arg);       optional arg      } else if (option.optional) {        arg = argv[i+1];        if (null == arg || (- == arg[0] && - != arg)) {          arg = null;        } else {          ++i;        }        this.emit(option.name(), arg);       bool      } else {        this.emit(option.name());      }      continue;    }
     looks like an option    if (arg.length > 1 && - == arg[0]) {      unknownOptions.push(arg);
       If the next argument looks like it might be       an argument for this option, we pass it on.       If it isn't, then it'll simply be ignored      if (argv[i+1] && - != argv[i+1][0]) {        unknownOptions.push(argv[++i]);      }      continue;    }
     arg    args.push(arg);  }
  return { args: args, unknown: unknownOptions };};
 * Return an object containing options as key-value pairs * *   * @api public */Command.prototype.opts = function() {  var result = {}    , len = this.options.length;
  for (var i = 0 ; i < len; i++) {    var key = camelcase(this.options[i].name());    result[key] = key === version ? this._version : this[key];  }  return result;};
 * Argument `name` is missing. * *    * @api private */
Command.prototype.missingArgument = function(name) {  console.error();  console.error(  error: missing required argument `%s', name);  console.error();  process.exit(1);};
 * `Option` is missing an argument, but received `flag` or nothing. * *    *    * @api private */
Command.prototype.optionMissingArgument = function(option, flag) {  console.error();  if (flag) {    console.error(  error: option `%s' argument missing, got `%s', option.flags, flag);  } else {    console.error(  error: option `%s' argument missing, option.flags);  }  console.error();  process.exit(1);};
 * Unknown option `flag`. * *    * @api private */
Command.prototype.unknownOption = function(flag) {  if (this._allowUnknownOption) return;  console.error();  console.error(  error: unknown option `%s', flag);  console.error();  process.exit(1);};
 * Variadic argument with `name` is not the last argument as required. * *    * @api private */
Command.prototype.variadicArgNotLast = function(name) {  console.error();  console.error(  error: variadic arguments must be last `%s', name);  console.error();  process.exit(1);};
 * Set the program version to `str`. * * This method auto-registers the ""-V, --version"" flag * which will print the version number when passed. * *    *    *   for chaining * @api public */
Command.prototype.version = function(str, flags) {  if (0 == arguments.length) return this._version;  this._version = str;  flags = flags || -V, --version;  this.option(flags, output the version number);  this.on(version, function() {    process.stdout.write(str + );    process.exit(0);  });  return this;};
 * Set the description to `str`. * *    *   * @api public */
Command.prototype.description = function(str) {  if (0 === arguments.length) return this._description;  this._description = str;  return this;};
 * Set an alias for the command * *    *   * @api public */
Command.prototype.alias = function(alias) {  var command = this;  if(this.commands.length !== 0) {    command = this.commands[this.commands.length - 1]  }
  if (arguments.length === 0) return command._alias;
  command._alias = alias;  return this;};
 * Set / get the command usage `str`. * *    *   * @api public */
Command.prototype.usage = function(str) {  var args = this._args.map(function(arg) {    return humanReadableArgName(arg);  });
  var usage = [options]    + (this.commands.length ?  [command] : )    + (this._args.length ?   + args.join( ) : );
  if (0 == arguments.length) return this._usage || usage;  this._usage = str;
  return this;};
 * Get the name of the command * *    *   * @api public */
Command.prototype.name = function() {  return this._name;};
 * Return the largest option length. * *   * @api private */
Command.prototype.largestOptionLength = function() {  return this.options.reduce(function(max, option) {    return Math.max(max, option.flags.length);  }, 0);};
 * Return help for options. * *   * @api private */
Command.prototype.optionHelp = function() {  var width = this.largestOptionLength();
   Prepend the help information  return [pad(-h, --help, width) +    + output usage information]      .concat(this.options.map(function(option) {        return pad(option.flags, width) +    + option.description;      }))      .join();};
 * Return command help documentation. * *   * @api private */
Command.prototype.commandHelp = function() {  if (!this.commands.length) return ;
  var commands = this.commands.filter(function(cmd) {    return !cmd._noHelp;  }).map(function(cmd) {    var args = cmd._args.map(function(arg) {      return humanReadableArgName(arg);    }).join( );
    return [      cmd._name        + (cmd._alias ? | + cmd._alias : )        + (cmd.options.length ?  [options] : )        +   + args      , cmd._description    ];  });
  var width = commands.reduce(function(max, command) {    return Math.max(max, command[0].length);  }, 0);
  return [        ,   Commands:    ,     , commands.map(function(cmd) {      var desc = cmd[1] ?    + cmd[1] : ;      return pad(cmd[0], width) + desc;    }).join().replace(gm,     )    ,   ].join();};
 * Return program help documentation. * *   * @api private */
Command.prototype.helpInformation = function() {  var desc = [];  if (this._description) {    desc = [         + this._description      ,     ];  }
  var cmdName = this._name;  if (this._alias) {    cmdName = cmdName + | + this._alias;  }  var usage = [        ,  Usage:  + cmdName +   + this.usage()    ,   ];
  var cmds = [];  var commandHelp = this.commandHelp();  if (commandHelp) cmds = [commandHelp];
  var options = [      Options:    ,     ,  + this.optionHelp().replace(gm,     )    ,     ,   ];
  return usage    .concat(cmds)    .concat(desc)    .concat(options)    .join();};
 * Output help information for this command * * @api public */
Command.prototype.outputHelp = function(cb) {  if (!cb) {    cb = function(passthru) {      return passthru;    }  }  process.stdout.write(cb(this.helpInformation()));  this.emit(--help);};
 * Output help information and exit. * * @api public */
Command.prototype.help = function(cb) {  this.outputHelp(cb);  process.exit();};
 * Camel-case the given `flag` * *    *   * @api private */
function camelcase(flag) {  return flag.split(-).reduce(function(str, word) {    return str + word[0].toUpperCase() + word.slice(1);  });}
 * Pad `str` to `width`. * *    *    *   * @api private */
function pad(str, width) {  var len = Math.max(0, width - str.length);  return str + Array(len + 1).join( );}
 * Output help information if necessary * *    to output help for *    of options to search for -h or --help * @api private */
function outputHelpIfNecessary(cmd, options) {  options = options || [];  for (var i = 0; i < options.length; i++) {    if (options[i] == --help || options[i] == -h) {      cmd.outputHelp();      process.exit(0);    }  }}
 * Takes an argument an returns its human readable equivalent for help usage. * *    *   * @api private */
function humanReadableArgName(arg) {  var nameOutput = arg.name + (arg.variadic === true ? ... : );
  return arg.required    ? < + nameOutput + >    : [ + nameOutput + ]}
 for versions before node v0.8 when there weren't `fs.existsSync`function exists(file) {  try {    if (fs.statSync(file).isFile()) {      return true;    }  } catch (e) {    return false;  }}
"
"var Classes = Object.create(null);
 * Create a new Connection instance. *    Configuration or connection string for new MySQL connection *   A new MySQL connection *  */exports.createConnection = function createConnection(config) {  var Connection       = loadClass(Connection);  var ConnectionConfig = loadClass(ConnectionConfig);
  return new Connection({config: new ConnectionConfig(config)});};
 * Create a new Pool instance. *    Configuration or connection string for new MySQL connections *   A new MySQL pool *  */exports.createPool = function createPool(config) {  var Pool       = loadClass(Pool);  var PoolConfig = loadClass(PoolConfig);
  return new Pool({config: new PoolConfig(config)});};
 * Create a new PoolCluster instance. *    Configuration for pool cluster *   New MySQL pool cluster *  */exports.createPoolCluster = function createPoolCluster(config) {  var PoolCluster = loadClass(PoolCluster);
  return new PoolCluster(config);};
 * Create a new Query instance. *    The SQL for the query *    Any values to insert into placeholders in sql *    The callback to use when query is complete *   New query object *  */exports.createQuery = function createQuery(sql, values, callback) {  var Connection = loadClass(Connection);
  return Connection.createQuery(sql, values, callback);};
 * Escape a value for SQL. *    The value to escape *    Setting if objects should be stringified *    Setting for time zone to use for Date conversion *   Escaped string value *  */exports.escape = function escape(value, stringifyObjects, timeZone) {  var SqlString = loadClass(SqlString);
  return SqlString.escape(value, stringifyObjects, timeZone);};
 * Escape an identifier for SQL. *    The value to escape *    Setting to treat '.' as part of identifier *   Escaped string value *  */exports.escapeId = function escapeId(value, forbidQualified) {  var SqlString = loadClass(SqlString);
  return SqlString.escapeId(value, forbidQualified);};
 * Format SQL and replacement values into a SQL string. *    The SQL for the query *    Any values to insert into placeholders in sql *    Setting if objects should be stringified *    Setting for time zone to use for Date conversion *   Formatted SQL string *  */exports.format = function format(sql, values, stringifyObjects, timeZone) {  var SqlString = loadClass(SqlString);
  return SqlString.format(sql, values, stringifyObjects, timeZone);};
 * The type constants. *  */Object.defineProperty(exports, Types, {  get: loadClass.bind(null, Types)});
 * Load the given class. *    Name of class to default *   Class constructor or exports *  */function loadClass(className) {  var Class = Classes[className];
  if (Class !== undefined) {    return Class;  }
   This uses a switch for static require analysis  switch (className) {    case Connection:      Class = require(./lib/Connection);      break;    case ConnectionConfig:      Class = require(./lib/ConnectionConfig);      break;    case Pool:      Class = require(./lib/Pool);      break;    case PoolCluster:      Class = require(./lib/PoolCluster);      break;    case PoolConfig:      Class = require(./lib/PoolConfig);      break;    case SqlString:      Class = require(./lib/protocol/SqlString);      break;    case Types:      Class = require(./lib/protocol/constants/types);      break;    default:      throw new Error(Cannot find class  + className + );  }
   Store to prevent invoking require()  Classes[className] = Class;
  return Class;}"
"use strict;
 * Copy this file to ./sscce.js * Add code from issue * npm run sscce-{dialect} */
const Sequelize = require(./index);const sequelize = require(./test/support).createSequelizeInstance();"
"var _ = require(lodash);var express = require(express);var grappling = require(grappling-hook);var path = require(path);var utils = require(keystone-utils);var importer = require(./lib/core/importer);
 * Don't use process.cwd() as it breaks module encapsulation * Instead, let's use module.parent if it's present, or the module itself if there is no parent (probably testing keystone directly if that's the case) * This way, the consuming app/module can be an embedded node_module and path resolutions will still work * (process.cwd() breaks module encapsulation if the consuming app/module is itself a node_module) */var moduleRoot = (function (_rootPath) {	var parts = _rootPath.split(path.sep);	parts.pop();  get rid of /node_modules from the end of the path	return parts.join(path.sep);})(module.parent ? module.parent.paths[0] : module.paths[0]);

 * Keystone Class */var Keystone = function () {	grappling.mixin(this).allowHooks(pre:static, pre:bodyparser, pre:session, pre:logger, pre:admin, pre:routes, pre:render, updates, signin, signout);	this.lists = {};	this.fieldTypes = {};	this.paths = {};	this._options = {		name: Keystone,		brand: Keystone,		admin path: keystone,		compress: true,		headless: false,		logger: :method :url :status :response-time ms,		auto update: false,		model prefix: null,		module root: moduleRoot,		frame guard: sameorigin,		cache admin bundles: true,	};	this._redirects = {};
	 expose express	this.express = express;
	 init environment defaults	this.set(env, process.env.NODE_ENV || development);
	this.set(port, process.env.PORT || process.env.OPENSHIFT_NODEJS_PORT || 3000);	this.set(host, process.env.HOST || process.env.IP || process.env.OPENSHIFT_NODEJS_IP || 0.0.0.0);	this.set(listen, process.env.LISTEN);
	this.set(ssl, process.env.SSL);	this.set(ssl port, process.env.SSL_PORT || 3001);	this.set(ssl host, process.env.SSL_HOST || process.env.SSL_IP);	this.set(ssl key, process.env.SSL_KEY);	this.set(ssl cert, process.env.SSL_CERT);
	this.set(cookie secret, process.env.COOKIE_SECRET);	this.set(cookie signin, (this.get(env) === development) ? true : false);
	this.set(embedly api key, process.env.EMBEDLY_API_KEY || process.env.EMBEDLY_APIKEY);	this.set(mandrill api key, process.env.MANDRILL_API_KEY || process.env.MANDRILL_APIKEY);	this.set(mandrill username, process.env.MANDRILL_USERNAME);	this.set(google api key, process.env.GOOGLE_BROWSER_KEY);	this.set(google server api key, process.env.GOOGLE_SERVER_KEY);	this.set(ga property, process.env.GA_PROPERTY);	this.set(ga domain, process.env.GA_DOMAIN);	this.set(chartbeat property, process.env.CHARTBEAT_PROPERTY);	this.set(chartbeat domain, process.env.CHARTBEAT_DOMAIN);	this.set(allowed ip ranges, process.env.ALLOWED_IP_RANGES);
	if (process.env.S3_BUCKET && process.env.S3_KEY && process.env.S3_SECRET) {		this.set(s3 config, { bucket: process.env.S3_BUCKET, key: process.env.S3_KEY, secret: process.env.S3_SECRET, region: process.env.S3_REGION });	}
	if (process.env.AZURE_STORAGE_ACCOUNT && process.env.AZURE_STORAGE_ACCESS_KEY) {		this.set(azurefile config, { account: process.env.AZURE_STORAGE_ACCOUNT, key: process.env.AZURE_STORAGE_ACCESS_KEY });	}
	if (process.env.CLOUDINARY_URL) {		 process.env.CLOUDINARY_URL is processed by the cloudinary package when this is set		this.set(cloudinary config, true);	}
	 init mongoose	this.set(mongoose, require(mongoose));	this.mongoose.Promise = require(es6-promise).Promise;
	 Attach middleware packages, bound to this instance	this.middleware = {		api: require(./lib/middleware/api)(this),		cors: require(./lib/middleware/cors)(this),	};};
_.extend(Keystone.prototype, require(./lib/core/options));

Keystone.prototype.prefixModel = function (key) {	var modelPrefix = this.get(model prefix);
	if (modelPrefix) {		key = modelPrefix + _ + key;	}
	return require(mongoose/lib/utils).toCollectionName(key);};
Keystone.prototype.createItems = require(./lib/core/createItems);Keystone.prototype.createRouter = require(./lib/core/createRouter);Keystone.prototype.getOrphanedLists = require(./lib/core/getOrphanedLists);Keystone.prototype.importer = importer;Keystone.prototype.init = require(./lib/core/init);Keystone.prototype.initDatabaseConfig = require(./lib/core/initDatabaseConfig);Keystone.prototype.initExpressApp = require(./lib/core/initExpressApp);Keystone.prototype.initExpressSession = require(./lib/core/initExpressSession);Keystone.prototype.initNav = require(./lib/core/initNav);Keystone.prototype.list = require(./lib/core/list);Keystone.prototype.openDatabaseConnection = require(./lib/core/openDatabaseConnection);Keystone.prototype.closeDatabaseConnection = require(./lib/core/closeDatabaseConnection);Keystone.prototype.populateRelated = require(./lib/core/populateRelated);Keystone.prototype.redirect = require(./lib/core/redirect);Keystone.prototype.start = require(./lib/core/start);Keystone.prototype.wrapHTMLError = require(./lib/core/wrapHTMLError);Keystone.prototype.createKeystoneHash = require(./lib/core/createKeystoneHash);
Keystone.prototype.routes = function () {	throw new Error(keystone.routes(fn) has been removed, use keystone.set(routes, fn));};

 * The exports object is an instance of Keystone. */var keystone = module.exports = new Keystone();
	Note: until #1777 is complete, the order of execution here with the requires	(specifically, they happen _after_ the module.exports above) is really	important. As soon as the circular dependencies are sorted out to get their	keystone instance from a closure or reference on {this} we can move these	bindings into the Keystone constructor.
 Expose modules and Classeskeystone.Admin = {	Server: require(./admin/server),};keystone.Email = require(./lib/email);keystone.Field = require(./fields/types/Type);keystone.Field.Types = require(./lib/fieldTypes);keystone.Keystone = Keystone;keystone.List = require(./lib/list)(keystone);keystone.Storage = require(./lib/storage);keystone.View = require(./lib/view);
keystone.content = require(./lib/content);keystone.security = {	csrf: require(./lib/security/csrf),};keystone.utils = utils;
 * returns all .js modules (recursively) in the path specified, relative * to the module root (where the keystone project is being consumed from). * * ####Example: *     var models = keystone.import('models'); */
Keystone.prototype.import = function (dirname) {	return importer(this.get(module root))(dirname);};

 * Applies Application updates */
Keystone.prototype.applyUpdates = function (callback) {	var self = this;	self.callHook(pre:updates, function (err) {		if (err) return callback(err);		require(./lib/updates).apply(function (err) {			if (err) return callback(err);			self.callHook(post:updates, callback);		});	});};

 * Logs a configuration error to the console */
Keystone.prototype.console = {};Keystone.prototype.console.err = function (type, msg) {	if (keystone.get(logger)) {		var dashes = ------------------------------------------------;		console.log(dashes + KeystoneJS:  + type + : + msg + dashes);	}};
 * Keystone version */
keystone.version = require(./package.json).version;

 Expose Moduleskeystone.session = require(./lib/session);"
"use strict;
 Iron-node does not work with forked processes This cli command will run a single file in the current process. Intended to be used with iron-node for profiling purposes.
const path = require(path);const EventEmitter = require(events);const meow = require(meow);const Promise = require(bluebird);const pkgConf = require(pkg-conf);const findCacheDir = require(find-cache-dir);const uniqueTempDir = require(unique-temp-dir);const arrify = require(arrify);const resolveCwd = require(resolve-cwd);const babelConfigHelper = require(./lib/babel-config);const CachingPrecompiler = require(./lib/caching-precompiler);const globals = require(./lib/globals);
function resolveModules(modules) {	return arrify(modules).map(name => {		const modulePath = resolveCwd(name);
		if (modulePath === null) {			throw new Error(Could not resolve required module '');		}
		return modulePath;	});}
 Chrome gets upset when the `this` value is non-null for these functionsglobals.setTimeout = setTimeout.bind(null);globals.clearTimeout = clearTimeout.bind(null);
Promise.longStackTraces();
const conf = pkgConf.sync(ava, {	defaults: {		babel: default	}});
 Define a minimal set of options from the main CLIconst cli = meow(	Usage	  $ iron-node node_modules/ava/profile.js <test-file>	Options	  --fail-fast   Stop after first test failure	  --serial, -s  Run tests serially, {	string: [		_	],	boolean: [		fail-fast,		verbose,		serial,		tap	],	default: conf,	alias: {		s: serial	}});
if (cli.input.length !== 1) {	throw new Error(Specify a test file);}
const file = path.resolve(cli.input[0]);const cacheDir = findCacheDir({	name: ava,	files: [file]}) || uniqueTempDir();
babelConfigHelper.build(process.cwd(), cacheDir, conf.babel, true)	.then(result => {		const precompiler = new CachingPrecompiler({			path: cacheDir,			getBabelOptions: result.getOptions,			babelCacheKeys: result.cacheKeys		});
		const precompiled = {};		precompiled[file] = precompiler.precompileFile(file);
		const opts = {			file,			failFast: cli.flags.failFast,			serial: cli.flags.serial,			tty: false,			cacheDir,			precompiled,			require: resolveModules(conf.require)		};
		const events = new EventEmitter();		let uncaughtExceptionCount = 0;
		 Mock the behavior of a parent process		process.channel = {ref() {}, unref() {}};		process.send = data => {			if (data && data.ava) {				const name = data.name.replace(ava-, );
				if (events.listeners(name).length > 0) {					events.emit(name, data.data);				} else {					console.log(UNHANDLED AVA EVENT:, name, data.data);				}
				return;			}
			console.log(NON AVA EVENT:, data);		};
		events.on(test, data => {			console.log(TEST:, data.title, data.error);		});
		events.on(results, data => {			if (console.profileEnd) {				console.profileEnd();			}
			console.log(RESULTS:, data.stats);
			if (process.exit) {				process.exit(data.stats.failCount + uncaughtExceptionCount);  eslint-disable-line unicorn/no-process-exit			}		});
		events.on(stats, () => {			setImmediate(() => {				process.emit(ava-run, {});			});		});
		events.on(uncaughtException, data => {			uncaughtExceptionCount++;			let stack = data && data.exception && data.exception.stack;			stack = stack || data;			console.log(stack);		});
		 `test-worker` will read process.argv[2] for options		process.argv[2] = JSON.stringify(opts);		process.argv.length = 3;
		if (console.profile) {			console.profile(AVA test-worker process);		}
		setImmediate(() => {			require(./lib/test-worker);  eslint-disable-line import/no-unassigned-import		});	});"
"use strict
module.exports = {  module: {    loaders: [{      test: css,      loader: style-loader!css-loader    },{      test: scss,      loaders: [style, css?sourceMap, sass?sourceMap]    }, {      test: js,      exclude: (node_modulesbower_componentslib),      loader: babel?presets[]=es2015&presets[]=stage-1    }, {      test: (pngwoffwoff2eotttfsvg)(v=),      loader: url    }]  },  resolve: {    modulesDirectories: [bower_components, node_modules]  }}"
"use strict
var webpack = require(webpack)var config = require(./webpack.config)var merge = require(lodash).merge
module.exports = merge(config, {  entry: [./app.js, webpack-hot-middleware/client?reload=true],  output: {    publicPath: /bundle/  },  plugins: [    new webpack.optimize.OccurenceOrderPlugin(),    new webpack.HotModuleReplacementPlugin(),    new webpack.NoErrorsPlugin()  ]});"
"Npm.depends({    faker: 3.0.1});

Package.describe({  summary: Generate massive amounts of fake data in node.js and in the browser.,  name: practicalmeteor:faker,  version: 3.0.1_1,  git: https://github.com/practicalmeteor/meteor-faker.git,  documentation: Readme.md});

Package.onUse(function (api) {  api.versionsFrom(1.0);
  api.addFiles(meteor/npm-require.js, server);
  api.addFiles(build/build/faker.js, client);
  api.export(faker, server);});

Package.onTest(function(api) {  api.use([practicalmeteor:faker, coffeescript, tinytest, practicalmeteor:chai]);
  api.addFiles(meteor/tests/faker-export-test.coffee);});"
" since we are requiring the top level of faker, load all locales by defaultvar Faker = require(./lib);var faker = new Faker({ locales: require(./lib/locales) });module[exports] = faker;"
"use strict
var path = require(path)
 var ngAnnotatePlugin = require('ng-annotate-webpack-plugin')
module.exports = {  context: __dirname,  entry: ./app.js,  output: {    path: path.join(__dirname, ./bundle),    publicPath: /,    filename: app.js  },  module: {    loaders: [{      test: css,      loaders: [style, css?sourceMap]    }, {      test: scss,      loaders: [style, css?sourceMap, sass?sourceMap]    }, {      test: less,      loaders: [style, css?sourceMap, less?sourceMap]    }, {      test: js,      exclude: (node_modulesbower_componentslib),      loader: babel?presets[]=es2015&presets[]=stage-1    }, {      test: ()(eotsvgttfwoffwoff2),      loader: url-loader    }]  },  resolve: {    modulesDirectories: [node_modules]  },  plugins: [     new ngAnnotatePlugin({       add: true,       // other ng-annotate options here     })  ]}"
"use strict
var cl = console.logconsole.log = function(){  console.trace()  cl.apply(console,arguments)}
process.env.NODE_CONFIG_DIR = ./config/env
 Requires meanio .var mean = require(meanio)var cluster = require(cluster)var deferred = require(q).defer()var debug = require(debug)(cluster)
 Code to run if we're in the master process or if we are not in debug mode/ running tests
if ((cluster.isMaster) &&  (process.execArgv.indexOf(--debug) < 0) &&  (process.env.NODE_ENV !== test) && (process.env.NODE_ENV !== development) &&  (process.execArgv.indexOf(--singleProcess) < 0)) {   if (cluster.isMaster) {
  debug(Production Environment)   Count the machine's CPUs  var cpuCount = process.env.CPU_COUNT || require(os).cpus().length
   Create a worker for each CPU  for (var i = 0; i < cpuCount; i += 1) {    debug(forking )    cluster.fork()  }
   Listen for dying workers  cluster.on(exit, function (worker) {     Replace the dead worker, we're not sentimental    debug(Worker  died :()    cluster.fork()  })
 Code to run if we're in a worker process} else {  var workerId = 0  if (!cluster.isMaster) {    workerId = cluster.worker.id  }   Creates and serves mean application  mean.serve({ workerid: workerId }, function (app) {    var config = app.getConfig()    var port = config.https && config.https.port ? config.https.port : config.http.port    debug(MEAN app started on port  () with cluster worker id )
    deferred.resolve(app)  })}
module.exports = deferred.promise"
"var mdeps = require(module-deps);var depsSort = require(deps-sort);var bpack = require(browser-pack);var insertGlobals = require(insert-module-globals);var syntaxError = require(syntax-error);
var builtins = require(./lib/builtins.js);
var splicer = require(labeled-stream-splicer);var through = require(through2);var concat = require(concat-stream);
var inherits = require(inherits);var EventEmitter = require(events).EventEmitter;var xtend = require(xtend);var isArray = Array.isArray;var defined = require(defined);var has = require(has);var sanitize = require(htmlescape).sanitize;var shasum = require(shasum);
var bresolve = require(browser-resolve);var resolve = require(resolve);
var readonly = require(read-only-stream);
module.exports = Browserify;inherits(Browserify, EventEmitter);
var fs = require(fs);var path = require(path);var relativePath = require(cached-path-relative)var paths = {    empty: path.join(__dirname, lib/_empty.js)};
function Browserify (files, opts) {    var self = this;    if (!(this instanceof Browserify)) return new Browserify(files, opts);    if (!opts) opts = {};        if (typeof files === string || isArray(files) || isStream(files)) {        opts = xtend(opts, { entries: [].concat(opts.entries || [], files) });    }    else opts = xtend(files, opts);        self._options = opts;    if (opts.noparse) opts.noParse = opts.noparse;        if (opts.basedir !== undefined && typeof opts.basedir !== string) {        throw new Error(opts.basedir must be either undefined or a string.);    }
    opts.dedupe = opts.dedupe === false ? false : true;
    self._external = [];    self._exclude = [];    self._ignore = [];    self._expose = {};    self._hashes = {};    self._pending = 0;    self._transformOrder = 0;    self._transformPending = 0;    self._transforms = [];    self._entryOrder = 0;    self._ticked = false;    self._bresolve = opts.browserField === false        ? function (id, opts, cb) {            if (!opts.basedir) opts.basedir = path.dirname(opts.filename)            resolve(id, opts, cb)        }        : bresolve    ;    self._syntaxCache = {};
    var ignoreTransform = [].concat(opts.ignoreTransform).filter(Boolean);    self._filterTransform = function (tr) {        if (isArray(tr)) {            return ignoreTransform.indexOf(tr[0]) === -1;        }        return ignoreTransform.indexOf(tr) === -1;    };
    self.pipeline = self._createPipeline(opts);        [].concat(opts.transform).filter(Boolean).filter(self._filterTransform)    .forEach(function (tr) {        self.transform(tr);    });        [].concat(opts.entries).filter(Boolean).forEach(function (file) {        self.add(file, { basedir: opts.basedir });    });        [].concat(opts.require).filter(Boolean).forEach(function (file) {        self.require(file, { basedir: opts.basedir });    });        [].concat(opts.plugin).filter(Boolean).forEach(function (p) {        self.plugin(p, { basedir: opts.basedir });    });}
Browserify.prototype.require = function (file, opts) {    var self = this;    if (isArray(file)) {        file.forEach(function (x) {            if (typeof x === object) {                self.require(x.file, xtend(opts, x));            }            else self.require(x, opts);        });        return this;    }        if (!opts) opts = {};    var basedir = defined(opts.basedir, self._options.basedir, process.cwd());    var expose = opts.expose;    if (file === expose && .test(expose)) {        expose = / + relativePath(basedir, expose);        expose = expose.replace(g, /);    }    if (expose === undefined && this._options.exposeAll) {        expose = true;    }    if (expose === true) {        expose = / + relativePath(basedir, file);        expose = expose.replace(g, /);    }        if (isStream(file)) {        self._pending ++;        var order = self._entryOrder ++;        file.pipe(concat(function (buf) {            var filename = opts.file || file.file || path.join(                basedir,                _stream_ + order + .js            );            var id = file.id || expose || filename;            if (expose || opts.entry === false) {                self._expose[id] = filename;            }            if (!opts.entry && self._options.exports === undefined) {                self._bpack.hasExports = true;            }            var rec = {                source: buf.toString(utf8),                entry: defined(opts.entry, false),                file: filename,                id: id            };            if (rec.entry) rec.order = order;            if (rec.transform === false) rec.transform = false;            self.pipeline.write(rec);                        if (-- self._pending === 0) self.emit(_ready);        }));        return this;    }        var row;    if (typeof file === object) {        row = xtend(file, opts);    }    else if (!opts.entry && isExternalModule(file)) {         external module or builtin        row = xtend(opts, { id: expose || file, file: file });    }    else {        row = xtend(opts, { file: path.resolve(basedir, file) });    }        if (!row.id) {        row.id = expose || row.file;    }    if (expose || !row.entry) {         Make this available to mdeps so that it can assign the value when it         resolves the pathname.        row.expose = row.id;    }        if (opts.external) return self.external(file, opts);    if (row.entry === undefined) row.entry = false;        if (!row.entry && self._options.exports === undefined) {        self._bpack.hasExports = true;    }        if (row.entry) row.order = self._entryOrder ++;        if (opts.transform === false) row.transform = false;    self.pipeline.write(row);    return self;};
Browserify.prototype.add = function (file, opts) {    var self = this;    if (!opts) opts = {};    if (isArray(file)) {        file.forEach(function (x) { self.add(x, opts) });        return this;    }    return this.require(file, xtend({ entry: true, expose: false }, opts));};
Browserify.prototype.external = function (file, opts) {    var self = this;    if (isArray(file)) {        file.forEach(function (f) {            if (typeof f === object) {                self.external(f, xtend(opts, f));            }            else self.external(f, opts)        });        return this;    }    if (file && typeof file === object && typeof file.bundle === function) {        var b = file;        self._pending ++;
        var bdeps = {};        var blabels = {};
        b.on(label, function (prev, id) {            self._external.push(id);
            if (prev !== id) {                blabels[prev] = id;                self._external.push(prev);            }        });
        b.pipeline.get(deps).push(through.obj(function (row, enc, next) {            bdeps = xtend(bdeps, row.deps);            this.push(row);            next();        }));
        self.on(dep, function (row) {            Object.keys(row.deps).forEach(function (key) {                var prev = bdeps[key];                if (prev) {                    var id = blabels[prev];                    if (id) {                        row.indexDeps[key] = id;                    }                }            });        });
        b.pipeline.get(label).once(end, function () {            if (-- self._pending === 0) self.emit(_ready);        });        return this;    }        if (!opts) opts = {};    var basedir = defined(opts.basedir, process.cwd());    this._external.push(file);    this._external.push(/ + relativePath(basedir, file));    return this;};
Browserify.prototype.exclude = function (file, opts) {    if (!opts) opts = {};    var basedir = defined(opts.basedir, process.cwd());    this._exclude.push(file);    this._exclude.push(/ + relativePath(basedir, file));    return this;};
Browserify.prototype.ignore = function (file, opts) {    if (!opts) opts = {};    var basedir = defined(opts.basedir, process.cwd());
     Handle relative paths    if (file[0] === .) {        this._ignore.push(path.resolve(basedir, file));    }    else {        this._ignore.push(file);    }    return this;};
Browserify.prototype.transform = function (tr, opts) {    var self = this;    if (typeof opts === function || typeof opts === string) {        tr = [ opts, tr ];    }    if (isArray(tr)) {        opts = tr[1];        tr = tr[0];    }        if the bundler is ignoring this transform    if (typeof tr === string && !self._filterTransform(tr)) {        return this;    }
    function resolved () {      self._transforms[order] = rec;      -- self._pending;      if (-- self._transformPending === 0) {          self._transforms.forEach(function (transform) {            self.pipeline.write(transform);          });
          if (self._pending === 0) {            self.emit(_ready);          }      }    }        if (!opts) opts = {};    opts._flags = _flags in opts ? opts._flags : self._options;        var basedir = defined(opts.basedir, this._options.basedir, process.cwd());    var order = self._transformOrder ++;    self._pending ++;    self._transformPending ++;
    var rec = {        transform: tr,        options: opts,        global: opts.global    };
    if (typeof tr === string) {        var topts = {            basedir: basedir,            paths: (self._options.paths || []).map(function (p) {                return path.resolve(basedir, p);            })        };        resolve(tr, topts, function (err, res) {            if (err) return self.emit(error, err);            rec.transform = res;            resolved();        });    }    else process.nextTick(resolved);    return this;};
Browserify.prototype.plugin = function (p, opts) {    if (isArray(p)) {        opts = p[1];        p = p[0];    }    if (!opts) opts = {};    var basedir = defined(opts.basedir, this._options.basedir, process.cwd());    if (typeof p === function) {        p(this, opts);    }    else {        var pfile = resolve.sync(String(p), { basedir: basedir })        var f = require(pfile);        if (typeof f !== function) {            throw new Error(plugin  + p +  should export a function);        }        f(this, opts);    }    return this;};
Browserify.prototype._createPipeline = function (opts) {    var self = this;    if (!opts) opts = {};    this._mdeps = this._createDeps(opts);    this._mdeps.on(file, function (file, id) {        pipeline.emit(file, file, id);        self.emit(file, file, id);    });    this._mdeps.on(package, function (pkg) {        pipeline.emit(package, pkg);        self.emit(package, pkg);    });    this._mdeps.on(transform, function (tr, file) {        pipeline.emit(transform, tr, file);        self.emit(transform, tr, file);    });        var dopts = {        index: !opts.fullPaths && !opts.exposeAll,        dedupe: opts.dedupe,        expose: this._expose    };    this._bpack = bpack(xtend(opts, { raw: true }));        var pipeline = splicer.obj([        record, [ this._recorder() ],        deps, [ this._mdeps ],        json, [ this._json() ],        unbom, [ this._unbom() ],        unshebang, [ this._unshebang() ],        syntax, [ this._syntax() ],        sort, [ depsSort(dopts) ],        dedupe, [ this._dedupe() ],        label, [ this._label(opts) ],        emit-deps, [ this._emitDeps() ],        debug, [ this._debug(opts) ],        pack, [ this._bpack ],        wrap, []    ]);    if (opts.exposeAll) {        var basedir = defined(opts.basedir, process.cwd());        pipeline.get(deps).push(through.obj(function (row, enc, next) {            if (self._external.indexOf(row.id) >= 0) return next();            if (self._external.indexOf(row.file) >= 0) return next();                        if (isAbsolutePath(row.id)) {                row.id = / + relativePath(basedir, row.file);            }            Object.keys(row.deps || {}).forEach(function (key) {                row.deps[key] = / + relativePath(basedir, row.deps[key]);            });            this.push(row);            next();        }));    }    return pipeline;};
Browserify.prototype._createDeps = function (opts) {    var self = this;    var mopts = xtend(opts);    var basedir = defined(opts.basedir, process.cwd());
     Let mdeps populate these values since it will be resolving file paths     anyway.    mopts.expose = this._expose;    mopts.extensions = [ .js, .json ].concat(mopts.extensions || []);    self._extensions = mopts.extensions;
    mopts.transform = [];    mopts.transformKey = defined(opts.transformKey, [ browserify, transform ]);    mopts.postFilter = function (id, file, pkg) {        if (opts.postFilter && !opts.postFilter(id, file, pkg)) return false;        if (self._external.indexOf(file) >= 0) return false;        if (self._exclude.indexOf(file) >= 0) return false;
        filter transforms on module dependencies        if (pkg && pkg.browserify && pkg.browserify.transform) {            In edge cases it may be a string            pkg.browserify.transform = [].concat(pkg.browserify.transform)                    .filter(Boolean)                    .filter(self._filterTransform);        }        return true;    };    mopts.filter = function (id) {        if (opts.filter && !opts.filter(id)) return false;        if (self._external.indexOf(id) >= 0) return false;        if (self._exclude.indexOf(id) >= 0) return false;        if (opts.bundleExternal === false && isExternalModule(id)) {            return false;        }        return true;    };    mopts.resolve = function (id, parent, cb) {        if (self._ignore.indexOf(id) >= 0) return cb(null, paths.empty, {});                self._bresolve(id, parent, function (err, file, pkg) {            if (file && self._ignore.indexOf(file) >= 0) {                return cb(null, paths.empty, {});            }            if (file && self._ignore.length) {                var nm = file.split(/node_modules/)[1];                if (nm) {                    nm = nm.split(/)[0];                    if (self._ignore.indexOf(nm) >= 0) {                        return cb(null, paths.empty, {});                    }                }            }                        if (file) {                var ex = / + relativePath(basedir, file);                if (self._external.indexOf(ex) >= 0) {                    return cb(null, ex);                }                if (self._exclude.indexOf(ex) >= 0) {                    return cb(null, ex);                }                if (self._ignore.indexOf(ex) >= 0) {                    return cb(null, paths.empty, {});                }            }            if (err) cb(err, file, pkg)            else if (file) fs.realpath(file, function (err, res) {                cb(err, res, pkg, file);            });            else cb(err, null, pkg)        });    };        if (opts.builtins === false) {        mopts.modules = {};        self._exclude.push.apply(self._exclude, Object.keys(builtins));    }    else if (opts.builtins && isArray(opts.builtins)) {        mopts.modules = {};        opts.builtins.forEach(function (key) {            mopts.modules[key] = builtins[key];        });    }    else if (opts.builtins && typeof opts.builtins === object) {        mopts.modules = opts.builtins;    }    else mopts.modules = xtend(builtins);        Object.keys(builtins).forEach(function (key) {        if (!has(mopts.modules, key)) self._exclude.push(key);    });        mopts.globalTransform = [];    if (!this._bundled) {        this.once(bundle, function () {            self.pipeline.write({                transform: globalTr,                global: true,                options: {}            });        });    }        var no = [].concat(opts.noParse).filter(Boolean);    var absno = no.filter(function(x) {        return typeof x === string;    }).map(function (x) {        return path.resolve(basedir, x);    });        function globalTr (file) {        if (opts.detectGlobals === false) return through();                if (opts.noParse === true) return through();        if (no.indexOf(file) >= 0) return through();        if (absno.indexOf(file) >= 0) return through();                var parts = file.split(/node_modules/);        for (var i = 0; i < no.length; i++) {            if (typeof no[i] === function && no[i](file)) {                return through();            }            else if (no[i] === parts[parts.length-1].split(/)[0]) {                return through();            }            else if (no[i] === parts[parts.length-1]) {                return through();            }        }                var vars = xtend({            process: function () { return require('_process') },        }, opts.insertGlobalVars);                if (opts.bundleExternal === false) {            vars.process = undefined;            vars.buffer = undefined;        }                return insertGlobals(file, xtend(opts, {            debug: opts.debug,            always: opts.insertGlobals,            basedir: opts.commondir === false                ? /                : opts.basedir || process.cwd()            ,            vars: vars        }));    }    return mdeps(mopts);};
Browserify.prototype._recorder = function (opts) {    var self = this;    var ended = false;    this._recorded = [];        if (!this._ticked) {        process.nextTick(function () {            self._ticked = true;            self._recorded.forEach(function (row) {                stream.push(row);            });            if (ended) stream.push(null);        });    }        var stream = through.obj(write, end);    return stream;        function write (row, enc, next) {        self._recorded.push(row);        if (self._ticked) this.push(row);        next();    }    function end () {        ended = true;        if (self._ticked) this.push(null);    }};
Browserify.prototype._json = function () {    return through.obj(function (row, enc, next) {        if (json.test(row.file)) {            row.source = module.exports= + sanitize(row.source);        }        this.push(row);        next();    });};
Browserify.prototype._unbom = function () {    return through.obj(function (row, enc, next) {        if (feff.test(row.source)) {            row.source = row.source.replace(feff, );        }        this.push(row);        next();    });};
Browserify.prototype._unshebang = function () {    return through.obj(function (row, enc, next) {        if (#!.test(row.source)) {            row.source = row.source.replace(#!, );        }        this.push(row);        next();    });};
Browserify.prototype._syntax = function () {    var self = this;    return through.obj(function (row, enc, next) {        var h = shasum(row.source);        if (typeof self._syntaxCache[h] === undefined) {            var err = syntaxError(row.source, row.file || row.id);            if (err) return this.emit(error, err);            self._syntaxCache[h] = true;        }        this.push(row);        next();    });};
Browserify.prototype._dedupe = function () {    return through.obj(function (row, enc, next) {        if (!row.dedupeIndex && row.dedupe) {            row.source = arguments[4][                + JSON.stringify(row.dedupe)                + ][0].apply(exports,arguments)            ;            row.nomap = true;        }        else if (row.dedupeIndex) {            row.source = arguments[4][                + JSON.stringify(row.dedupeIndex)                + ][0].apply(exports,arguments)            ;            row.nomap = true;        }        if (row.dedupeIndex && row.indexDeps) {            row.indexDeps.dup = row.dedupeIndex;        }        this.push(row);        next();    });};
Browserify.prototype._label = function (opts) {    var self = this;    var basedir = defined(opts.basedir, process.cwd());        return through.obj(function (row, enc, next) {        var prev = row.id;
        if (self._external.indexOf(row.id) >= 0) return next();        if (self._external.indexOf(/ + relativePath(basedir, row.id)) >= 0) {            return next();        }        if (self._external.indexOf(row.file) >= 0) return next();                if (row.index) row.id = row.index;                self.emit(label, prev, row.id);        if (row.indexDeps) row.deps = row.indexDeps || {};                Object.keys(row.deps).forEach(function (key) {            if (self._expose[key]) {                row.deps[key] = key;                return;            }
            var afile = path.resolve(path.dirname(row.file), key);            var rfile = / + relativePath(basedir, afile);            if (self._external.indexOf(rfile) >= 0) {                row.deps[key] = rfile;            }            if (self._external.indexOf(afile) >= 0) {                row.deps[key] = rfile;            }            if (self._external.indexOf(key) >= 0) {                row.deps[key] = key;                return;            }                        for (var i = 0; i < self._extensions.length; i++) {                var ex = self._extensions[i];                if (self._external.indexOf(rfile + ex) >= 0) {                    row.deps[key] = rfile + ex;                    break;                }            }        });                if (row.entry || row.expose) {            self._bpack.standaloneModule = row.id;        }        this.push(row);        next();    });};
Browserify.prototype._emitDeps = function () {    var self = this;    return through.obj(function (row, enc, next) {        self.emit(dep, row);        this.push(row);        next();    })};
Browserify.prototype._debug = function (opts) {    var basedir = defined(opts.basedir, process.cwd());    return through.obj(function (row, enc, next) {        if (opts.debug) {            row.sourceRoot = file://localhost;            row.sourceFile = relativePath(basedir, row.file)                .replace(g, /);        }        this.push(row);        next();    });};
Browserify.prototype.reset = function (opts) {    if (!opts) opts = {};    var hadExports = this._bpack.hasExports;    this.pipeline = this._createPipeline(xtend(opts, this._options));    this._bpack.hasExports = hadExports;    this._entryOrder = 0;    this._bundled = false;    this.emit(reset);};
Browserify.prototype.bundle = function (cb) {    var self = this;    if (cb && typeof cb === object) {        throw new Error(            bundle() no longer accepts option arguments.            + Move all option arguments to the browserify() constructor.        );    }    if (this._bundled) {        var recorded = this._recorded;        this.reset();        recorded.forEach(function (x) {            self.pipeline.write(x);        });    }    var output = readonly(this.pipeline);    if (cb) {        output.on(error, cb);        output.pipe(concat(function (body) {            cb(null, body);        }));    }
    function ready () {        self.emit(bundle, output);        self.pipeline.end();    }
    if (this._pending === 0) ready();    else this.once(_ready, ready);
    this._bundled = true;    return output;};
function isStream (s) { return s && typeof s.pipe === function }function isAbsolutePath (file) {    var regexp = process.platform === win32 ?        : :        ;    return regexp.test(file);}function isExternalModule (file) {    var regexp = process.platform === win32 ?        (:) :        ;    return !regexp.test(file);}"
" Public API for node-inspector embeddersvar url = require(url);var path = require(path);
exports.buildInspectorUrl = buildInspectorUrl;exports.buildWebSocketUrl = buildWebSocketUrl;
 * Build a URL for loading inspector UI in the browser. *    as configured via --web-host *    as configured via --web-port *    as configured via --debug in the debugged app *    as configured via --ssl-cert and --ssl-key in the debugged app */function buildInspectorUrl(inspectorHost, inspectorPort, debugPort, isHttps) {  var host = inspectorHost == 0.0.0.0 ? 127.0.0.1 : inspectorHost;  var port = inspectorPort;  var protocol = isHttps ? https : http;
  var isUnixSocket = !.test(port);  if (isUnixSocket) {    host = path.resolve(__dirname, inspectorPort);    port = null;    protocol = unix;  }
  var parts = {    protocol: protocol,    hostname: host,    port: port,    pathname: /,    search: ?port= + debugPort  };
  return url.format(parts);}
 * Build a URL for the WebSocket endpoint. *    as configured via --web-host *    as configured via --web-port *    as configured via --debug in the debugged app *    as configured via --ssl-cert and --ssl-key in the debugged app */function buildWebSocketUrl(inspectorHost, inspectorPort, debugPort, isSecure) {  var parts = {    protocol: isSecure ? wss: : ws:,    hostname: inspectorHost == 0.0.0.0 ? 127.0.0.1 : inspectorHost,    port: inspectorPort,    pathname: /,    search: ?port= + debugPort,    slashes: true  };
  return url.format(parts);}"
"module.exports = function(grunt) {  var pkg = require(./package.json);  global.jasmineVersion = pkg.version;
  grunt.initConfig({    pkg: pkg,    jshint: require(./grunt/config/jshint.js),    concat: require(./grunt/config/concat.js),    compass: require(./grunt/config/compass.js),    compress: require(./grunt/config/compress.js)  });
  require(load-grunt-tasks)(grunt);
  grunt.loadTasks(grunt/tasks);
  grunt.registerTask(default, [jshint:all]);
  var version = require(./grunt/tasks/version.js);
  grunt.registerTask(build:copyVersionToGem,    Propagates the version from package.json to version.rb,    version.copyToGem);
  grunt.registerTask(buildDistribution,    Builds and lints jasmine.js, jasmine-html.js, jasmine.css,    [      compass,      jshint:beforeConcat,      concat,      jshint:afterConcat,      build:copyVersionToGem    ]  );
  grunt.registerTask(execSpecsInNode,    Run Jasmine core specs in Node.js,    function() {      var done = this.async(),          Jasmine = require(jasmine),          jasmineCore = require(./lib/jasmine-core.js),          jasmine = new Jasmine({jasmineCore: jasmineCore});
      jasmine.loadConfigFile(./spec/support/jasmine.json);      jasmine.onComplete(function(passed) {        done(passed);      });
      jasmine.execute();    }  );
  grunt.registerTask(execSpecsInNode:performance,    Run Jasmine performance specs in Node.js,    function() {      require(shelljs).exec(node_modules/.bin/jasmine JASMINE_CONFIG_PATH=spec/support/jasmine-performance.json);    }  );};"
"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==function&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(Cannot find module '+o+');throw f.code=MODULE_NOT_FOUND,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==function&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){(function (process,global){use strict;

 * Shim process.stdout. */
process.stdout = require(browser-stdout)();
var Mocha = require(./lib/mocha);
 * Create a Mocha instance. * *   */
var mocha = new Mocha({ reporter: html });
 * Save timer references to avoid Sinon interfering (see GH-237). */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
var uncaughtExceptionHandlers = [];
var originalOnerrorHandler = global.onerror;
 * Remove uncaughtException listener. * Revert to original onerror handler if previously defined. */
process.removeListener = function (e, fn) {  if (e === uncaughtException) {    if (originalOnerrorHandler) {      global.onerror = originalOnerrorHandler;    } else {      global.onerror = function () {};    }    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);    if (i !== -1) {      uncaughtExceptionHandlers.splice(i, 1);    }  }};
 * Implements uncaughtException listener. */
process.on = function (e, fn) {  if (e === uncaughtException) {    global.onerror = function (err, url, line) {      fn(new Error(err +  ( + url + : + line + )));      return !mocha.allowUncaught;    };    uncaughtExceptionHandlers.push(fn);  }};
 The BDD UI is registered by default, but no UI will be functional in the browser without an explicit call to the overridden `mocha.ui` (see below). Ensure that this default UI does not expose its methods to the global scope.mocha.suite.removeAllListeners(pre-require);
var immediateQueue = [];var immediateTimeout;
function timeslice () {  var immediateStart = new Date().getTime();  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {    immediateQueue.shift()();  }  if (immediateQueue.length) {    immediateTimeout = setTimeout(timeslice, 0);  } else {    immediateTimeout = null;  }}
 * High-performance override of Runner.immediately. */
Mocha.Runner.immediately = function (callback) {  immediateQueue.push(callback);  if (!immediateTimeout) {    immediateTimeout = setTimeout(timeslice, 0);  }};
 * Function to allow assertion libraries to throw errors directly into mocha. * This is useful when running tests in a browser because window.onerror will * only receive the 'message' attribute of the Error. */mocha.throwError = function (err) {  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {    fn(err);  });  throw err;};
 * Override ui to ensure that the ui functions are initialized. * Normally this would happen in Mocha.prototype.loadFiles. */
mocha.ui = function (ui) {  Mocha.prototype.ui.call(this, ui);  this.suite.emit(pre-require, global, null, this);  return this;};
 * Setup mocha with the given setting options. */
mocha.setup = function (opts) {  if (typeof opts === string) {    opts = { ui: opts };  }  for (var opt in opts) {    if (opts.hasOwnProperty(opt)) {      this[opt](opts[opt]);    }  }  return this;};
 * Run mocha, returning the Runner. */
mocha.run = function (fn) {  var options = mocha.options;  mocha.globals(location);
  var query = Mocha.utils.parseQuery(global.location.search || );  if (query.grep) {    mocha.grep(query.grep);  }  if (query.fgrep) {    mocha.fgrep(query.fgrep);  }  if (query.invert) {    mocha.invert();  }
  return Mocha.prototype.run.call(mocha, function (err) {     The DOM Document is not available in Web Workers.    var document = global.document;    if (document && document.getElementById(mocha) && options.noHighlighting !== true) {      Mocha.utils.highlightTags(code);    }    if (fn) {      fn(err);    }  });};
 * Expose the process shim. * https://github.com/mochajs/mocha/pull/916 */
Mocha.process = process;
 * Expose mocha. */
global.Mocha = Mocha;global.mocha = mocha;
 this allows test/acceptance/required-tokens.js to pass; thus, you can now do `const describe = require('mocha').describe` in a browser context (assuming browserification).  should fix #880module.exports = global;
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./lib/mocha:14,_process:67,browser-stdout:41}],2:[function(require,module,exports){use strict;
function noop () {}
module.exports = function () {  return noop;};
},{}],3:[function(require,module,exports){use strict;
 * Module exports. */
exports.EventEmitter = EventEmitter;
 * Object#toString reference. */var objToString = Object.prototype.toString;
 * Check if a value is an array. * * @api private *    The value to test. *   true if the value is an array, otherwise false. */function isArray (val) {  return objToString.call(val) === [object Array];}
 * Event emitter constructor. * * @api public */function EventEmitter () {}
 * Add a listener. * * @api public *    Event name. *    Event handler. *   Emitter instance. */EventEmitter.prototype.on = function (name, fn) {  if (!this.$events) {    this.$events = {};  }
  if (!this.$events[name]) {    this.$events[name] = fn;  } else if (isArray(this.$events[name])) {    this.$events[name].push(fn);  } else {    this.$events[name] = [this.$events[name], fn];  }
  return this;};
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
 * Adds a volatile listener. * * @api public *    Event name. *    Event handler. *   Emitter instance. */EventEmitter.prototype.once = function (name, fn) {  var self = this;
  function on () {    self.removeListener(name, on);    fn.apply(this, arguments);  }
  on.listener = fn;  this.on(name, on);
  return this;};
 * Remove a listener. * * @api public *    Event name. *    Event handler. *   Emitter instance. */EventEmitter.prototype.removeListener = function (name, fn) {  if (this.$events && this.$events[name]) {    var list = this.$events[name];
    if (isArray(list)) {      var pos = -1;
      for (var i = 0, l = list.length; i < l; i++) {        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {          pos = i;          break;        }      }
      if (pos < 0) {        return this;      }
      list.splice(pos, 1);
      if (!list.length) {        delete this.$events[name];      }    } else if (list === fn || (list.listener && list.listener === fn)) {      delete this.$events[name];    }  }
  return this;};
 * Remove all listeners for an event. * * @api public *    Event name. *   Emitter instance. */EventEmitter.prototype.removeAllListeners = function (name) {  if (name === undefined) {    this.$events = {};    return this;  }
  if (this.$events && this.$events[name]) {    this.$events[name] = null;  }
  return this;};
 * Get all listeners for a given event. * * @api public *    Event name. *   Emitter instance. */EventEmitter.prototype.listeners = function (name) {  if (!this.$events) {    this.$events = {};  }
  if (!this.$events[name]) {    this.$events[name] = [];  }
  if (!isArray(this.$events[name])) {    this.$events[name] = [this.$events[name]];  }
  return this.$events[name];};
 * Emit an event. * * @api public *    Event name. *   true if at least one handler was invoked, else false. */EventEmitter.prototype.emit = function (name) {  if (!this.$events) {    return false;  }
  var handler = this.$events[name];
  if (!handler) {    return false;  }
  var args = Array.prototype.slice.call(arguments, 1);
  if (typeof handler === function) {    handler.apply(this, args);  } else if (isArray(handler)) {    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {      listeners[i].apply(this, args);    }  } else {    return false;  }
  return true;};
},{}],4:[function(require,module,exports){use strict;
 * Expose `Progress`. */
module.exports = Progress;
 * Initialize a new `Progress` indicator. */function Progress () {  this.percent = 0;  this.size(0);  this.fontSize(11);  this.font(helvetica, arial, sans-serif);}
 * Set progress size to `size`. * * @api public *    *   Progress instance. */Progress.prototype.size = function (size) {  this._size = size;  return this;};
 * Set text to `text`. * * @api public *    *   Progress instance. */Progress.prototype.text = function (text) {  this._text = text;  return this;};
 * Set font size to `size`. * * @api public *    *   Progress instance. */Progress.prototype.fontSize = function (size) {  this._fontSize = size;  return this;};
 * Set font to `family`. * *    *   Progress instance. */Progress.prototype.font = function (family) {  this._font = family;  return this;};
 * Update percentage to `n`. * *    *   Progress instance. */Progress.prototype.update = function (n) {  this.percent = n;  return this;};
 * Draw on `ctx`. * *    *   Progress instance. */Progress.prototype.draw = function (ctx) {  try {    var percent = Math.min(this.percent, 100);    var size = this._size;    var half = size / 2;    var x = half;    var y = half;    var rad = half - 1;    var fontSize = this._fontSize;
    ctx.font = fontSize + px  + this._font;
    var angle = Math.PI  2  (percent / 100);    ctx.clearRect(0, 0, size, size);
     outer circle    ctx.strokeStyle = #9f9f9f;    ctx.beginPath();    ctx.arc(x, y, rad, 0, angle, false);    ctx.stroke();
     inner circle    ctx.strokeStyle = #eee;    ctx.beginPath();    ctx.arc(x, y, rad - 1, 0, angle, true);    ctx.stroke();
     text    var text = this._text || (percent | 0) + %;    var w = ctx.measureText(text).width;
    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);  } catch (err) {     don't fail if we can't render progress  }  return this;};
},{}],5:[function(require,module,exports){(function (global){use strict;
exports.isatty = function isatty () {  return true;};
exports.getWindowSize = function getWindowSize () {  if (innerHeight in global) {    return [global.innerHeight, global.innerWidth];  }   In a Web Worker, the DOM Window is not available.  return [640, 480];};
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{}],6:[function(require,module,exports){use strict;
 * Module dependencies. */
var JSON = require(json3);
 * Expose `Context`. */
module.exports = Context;
 * Initialize a new `Context`. * * @api private */function Context () {}
 * Set or get the context `Runnable` to `runnable`. * * @api private *    *   */Context.prototype.runnable = function (runnable) {  if (!arguments.length) {    return this._runnable;  }  this.test = this._runnable = runnable;  return this;};
 * Set test timeout `ms`. * * @api private *    *   self */Context.prototype.timeout = function (ms) {  if (!arguments.length) {    return this.runnable().timeout();  }  this.runnable().timeout(ms);  return this;};
 * Set test timeout `enabled`. * * @api private *    *   self */Context.prototype.enableTimeouts = function (enabled) {  this.runnable().enableTimeouts(enabled);  return this;};
 * Set test slowness threshold `ms`. * * @api private *    *   self */Context.prototype.slow = function (ms) {  this.runnable().slow(ms);  return this;};
 * Mark a test as skipped. * * @api private *   self */Context.prototype.skip = function () {  this.runnable().skip();  return this;};
 * Allow a number of retries on failed tests * * @api private *    *   self */Context.prototype.retries = function (n) {  if (!arguments.length) {    return this.runnable().retries();  }  this.runnable().retries(n);  return this;};
 * Inspect the context void of `._runnable`. * * @api private *   */Context.prototype.inspect = function () {  return JSON.stringify(this, function (key, val) {    return key === runnable || key === test ? undefined : val;  }, 2);};
},{json3:54}],7:[function(require,module,exports){use strict;
 * Module dependencies. */
var Runnable = require(./runnable);var inherits = require(./utils).inherits;
 * Expose `Hook`. */
module.exports = Hook;
 * Initialize a new `Hook` with the given `title` and callback `fn`. * *    *    * @api private */function Hook (title, fn) {  Runnable.call(this, title, fn);  this.type = hook;}
 * Inherit from `Runnable.prototype`. */inherits(Hook, Runnable);
 * Get or set the test `err`. * *    *   * @api public */Hook.prototype.error = function (err) {  if (!arguments.length) {    err = this._error;    this._error = null;    return err;  }
  this._error = err;};
},{./runnable:33,./utils:38}],8:[function(require,module,exports){use strict;
 * Module dependencies. */
var Test = require(../test);
 * BDD-style interface: * *      describe('Array', function() { *        describe('#indexOf()', function() { *          it('should return -1 when not present', function() { *            // ... *          }); * *          it('should return the index when present', function() { *            // ... *          }); *        }); *      }); * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(pre-require, function (context, file, mocha) {    var common = require(./common)(suites, context, mocha);
    context.before = common.before;    context.after = common.after;    context.beforeEach = common.beforeEach;    context.afterEach = common.afterEach;    context.run = mocha.options.delay && common.runWithSuite(suite);         * Describe a ""suite"" with the given `title`     * and callback `fn` containing nested suites     * and/or tests.     */
    context.describe = context.context = function (title, fn) {      return common.suite.create({        title: title,        file: file,        fn: fn      });    };
         * Pending describe.     */
    context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {      return common.suite.skip({        title: title,        file: file,        fn: fn      });    };
         * Exclusive suite.     */
    context.describe.only = function (title, fn) {      return common.suite.only({        title: title,        file: file,        fn: fn      });    };
         * Describe a specification or test-case     * with the given `title` and callback `fn`     * acting as a thunk.     */
    context.it = context.specify = function (title, fn) {      var suite = suites[0];      if (suite.isPending()) {        fn = null;      }      var test = new Test(title, fn);      test.file = file;      suite.addTest(test);      return test;    };
         * Exclusive test-case.     */
    context.it.only = function (title, fn) {      return common.test.only(mocha, context.it(title, fn));    };
         * Pending test case.     */
    context.xit = context.xspecify = context.it.skip = function (title) {      context.it(title);    };
         * Number of attempts to retry.     */    context.it.retries = function (n) {      context.retries(n);    };  });};
},{../test:36,./common:9}],9:[function(require,module,exports){use strict;
var Suite = require(../suite);
 * Functions common to more than one interface. * *    *    *    *   An object containing common functions. */module.exports = function (suites, context, mocha) {  return {         * This is only present if flag --delay is passed into Mocha. It triggers     * root suite execution.     *     *    The root suite.     *   A function which runs the root suite     */    runWithSuite: function runWithSuite (suite) {      return function run () {        suite.run();      };    },
         * Execute before running tests.     *     *        *        */    before: function (name, fn) {      suites[0].beforeAll(name, fn);    },
         * Execute after running tests.     *     *        *        */    after: function (name, fn) {      suites[0].afterAll(name, fn);    },
         * Execute before each test case.     *     *        *        */    beforeEach: function (name, fn) {      suites[0].beforeEach(name, fn);    },
         * Execute after each test case.     *     *        *        */    afterEach: function (name, fn) {      suites[0].afterEach(name, fn);    },
    suite: {             * Create an exclusive Suite; convenience function       * See docstring for create() below.       *       *          *         */      only: function only (opts) {        mocha.options.hasOnly = true;        opts.isOnly = true;        return this.create(opts);      },
             * Create a Suite, but skip it; convenience function       * See docstring for create() below.       *       *          *         */      skip: function skip (opts) {        opts.pending = true;        return this.create(opts);      },
             * Creates a suite.       *    Options       *    Title of Suite       *    Suite Function (not always applicable)       *    Is Suite pending?       *    Filepath where this Suite resides       *    Is Suite exclusive?       *         */      create: function create (opts) {        var suite = Suite.create(suites[0], opts.title);        suite.pending = Boolean(opts.pending);        suite.file = opts.file;        suites.unshift(suite);        if (opts.isOnly) {          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);          mocha.options.hasOnly = true;        }        if (typeof opts.fn === function) {          opts.fn.call(suite);          suites.shift();        } else if (typeof opts.fn === undefined && !suite.pending) {          throw new Error(Suite "" + suite.fullTitle() + "" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.);        }
        return suite;      }    },
    test: {
             * Exclusive test-case.       *       *          *          *         */      only: function (mocha, test) {        test.parent._onlyTests = test.parent._onlyTests.concat(test);        mocha.options.hasOnly = true;        return test;      },
             * Pending test case.       *       *          */      skip: function (title) {        context.test(title);      },
             * Number of retry attempts       *       *          */      retries: function (n) {        context.retries(n);      }    }  };};
},{../suite:35}],10:[function(require,module,exports){use strict;
 * Module dependencies. */
var Suite = require(../suite);var Test = require(../test);
 * Exports-style (as Node.js module) interface: * *     exports.Array = { *       '#indexOf()': { *         'should return -1 when the value is not present': function() { * *         }, * *         'should return the correct index when the value is present': function() { * *         } *       } *     }; * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(require, visit);
  function visit (obj, file) {    var suite;    for (var key in obj) {      if (typeof obj[key] === function) {        var fn = obj[key];        switch (key) {          case before:            suites[0].beforeAll(fn);            break;          case after:            suites[0].afterAll(fn);            break;          case beforeEach:            suites[0].beforeEach(fn);            break;          case afterEach:            suites[0].afterEach(fn);            break;          default:            var test = new Test(key, fn);            test.file = file;            suites[0].addTest(test);        }      } else {        suite = Suite.create(suites[0], key);        suites.unshift(suite);        visit(obj[key], file);        suites.shift();      }    }  }};
},{../suite:35,../test:36}],11:[function(require,module,exports){use strict;
exports.bdd = require(./bdd);exports.tdd = require(./tdd);exports.qunit = require(./qunit);exports.exports = require(./exports);
},{./bdd:8,./exports:10,./qunit:12,./tdd:13}],12:[function(require,module,exports){use strict;
 * Module dependencies. */
var Test = require(../test);
 * QUnit-style interface: * *     suite('Array'); * *     test('#length', function() { *       var arr = [1,2,3]; *       ok(arr.length == 3); *     }); * *     test('#indexOf()', function() { *       var arr = [1,2,3]; *       ok(arr.indexOf(1) == 0); *       ok(arr.indexOf(2) == 1); *       ok(arr.indexOf(3) == 2); *     }); * *     suite('String'); * *     test('#length', function() { *       ok('foo'.length == 3); *     }); * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(pre-require, function (context, file, mocha) {    var common = require(./common)(suites, context, mocha);
    context.before = common.before;    context.after = common.after;    context.beforeEach = common.beforeEach;    context.afterEach = common.afterEach;    context.run = mocha.options.delay && common.runWithSuite(suite);         * Describe a ""suite"" with the given `title`.     */
    context.suite = function (title) {      if (suites.length > 1) {        suites.shift();      }      return common.suite.create({        title: title,        file: file,        fn: false      });    };
         * Exclusive Suite.     */
    context.suite.only = function (title) {      if (suites.length > 1) {        suites.shift();      }      return common.suite.only({        title: title,        file: file,        fn: false      });    };
         * Describe a specification or test-case     * with the given `title` and callback `fn`     * acting as a thunk.     */
    context.test = function (title, fn) {      var test = new Test(title, fn);      test.file = file;      suites[0].addTest(test);      return test;    };
         * Exclusive test-case.     */
    context.test.only = function (title, fn) {      return common.test.only(mocha, context.test(title, fn));    };
    context.test.skip = common.test.skip;    context.test.retries = common.test.retries;  });};
},{../test:36,./common:9}],13:[function(require,module,exports){use strict;
 * Module dependencies. */
var Test = require(../test);
 * TDD-style interface: * *      suite('Array', function() { *        suite('#indexOf()', function() { *          suiteSetup(function() { * *          }); * *          test('should return -1 when not present', function() { * *          }); * *          test('should return the index when present', function() { * *          }); * *          suiteTeardown(function() { * *          }); *        }); *      }); * *    Root suite. */module.exports = function (suite) {  var suites = [suite];
  suite.on(pre-require, function (context, file, mocha) {    var common = require(./common)(suites, context, mocha);
    context.setup = common.beforeEach;    context.teardown = common.afterEach;    context.suiteSetup = common.before;    context.suiteTeardown = common.after;    context.run = mocha.options.delay && common.runWithSuite(suite);
         * Describe a ""suite"" with the given `title` and callback `fn` containing     * nested suites and/or tests.     */    context.suite = function (title, fn) {      return common.suite.create({        title: title,        file: file,        fn: fn      });    };
         * Pending suite.     */    context.suite.skip = function (title, fn) {      return common.suite.skip({        title: title,        file: file,        fn: fn      });    };
         * Exclusive test-case.     */    context.suite.only = function (title, fn) {      return common.suite.only({        title: title,        file: file,        fn: fn      });    };
         * Describe a specification or test-case with the given `title` and     * callback `fn` acting as a thunk.     */    context.test = function (title, fn) {      var suite = suites[0];      if (suite.isPending()) {        fn = null;      }      var test = new Test(title, fn);      test.file = file;      suite.addTest(test);      return test;    };
         * Exclusive test-case.     */
    context.test.only = function (title, fn) {      return common.test.only(mocha, context.test(title, fn));    };
    context.test.skip = common.test.skip;    context.test.retries = common.test.retries;  });};
},{../test:36,./common:9}],14:[function(require,module,exports){(function (process,global,__dirname){use strict;
 * mocha * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca> * MIT Licensed */
 * Module dependencies. */
var escapeRe = require(escape-string-regexp);var path = require(path);var reporters = require(./reporters);var utils = require(./utils);
 * Expose `Mocha`. */
exports = module.exports = Mocha;
 * To require local UIs and reporters when running in node. */
if (!process.browser) {  var cwd = process.cwd();  module.paths.push(cwd, path.join(cwd, node_modules));}
 * Expose internals. */
exports.utils = utils;exports.interfaces = require(./interfaces);exports.reporters = reporters;exports.Runnable = require(./runnable);exports.Context = require(./context);exports.Runner = require(./runner);exports.Suite = require(./suite);exports.Hook = require(./hook);exports.Test = require(./test);
 * Return image `name` path. * * @api private *    *   */function image (name) {  return path.join(__dirname, ../images, name + .png);}
 * Set up mocha with `options`. * * Options: * *   - `ui` name ""bdd"", ""tdd"", ""exports"" etc *   - `reporter` reporter instance, defaults to `mocha.reporters.spec` *   - `globals` array of accepted globals *   - `timeout` timeout in milliseconds *   - `retries` number of times to retry failed tests *   - `bail` bail on the first test failure *   - `slow` milliseconds to wait before considering a test slow *   - `ignoreLeaks` ignore global leaks *   - `fullTrace` display the full stack-trace on failing *   - `grep` string or regexp to filter tests with * *    * @api public */function Mocha (options) {  options = options || {};  this.files = [];  this.options = options;  if (options.grep) {    this.grep(new RegExp(options.grep));  }  if (options.fgrep) {    this.fgrep(options.fgrep);  }  this.suite = new exports.Suite(, new exports.Context());  this.ui(options.ui);  this.bail(options.bail);  this.reporter(options.reporter, options.reporterOptions);  if (typeof options.timeout !== undefined && options.timeout !== null) {    this.timeout(options.timeout);  }  if (typeof options.retries !== undefined && options.retries !== null) {    this.retries(options.retries);  }  this.useColors(options.useColors);  if (options.enableTimeouts !== null) {    this.enableTimeouts(options.enableTimeouts);  }  if (options.slow) {    this.slow(options.slow);  }}
 * Enable or disable bailing on the first failure. * * @api public *    */Mocha.prototype.bail = function (bail) {  if (!arguments.length) {    bail = true;  }  this.suite.bail(bail);  return this;};
 * Add test `file`. * * @api public *    */Mocha.prototype.addFile = function (file) {  this.files.push(file);  return this;};
 * Set reporter to `reporter`, defaults to ""spec"". * *    name or constructor *    optional options * @api public *    name or constructor *    optional options */Mocha.prototype.reporter = function (reporter, reporterOptions) {  if (typeof reporter === function) {    this._reporter = reporter;  } else {    reporter = reporter || spec;    var _reporter;     Try to load a built-in reporter.    if (reporters[reporter]) {      _reporter = reporters[reporter];    }     Try to load reporters from process.cwd() and node_modules    if (!_reporter) {      try {        _reporter = require(reporter);      } catch (err) {        err.message.indexOf(Cannot find module) !== -1          ? console.warn("" + reporter + "" reporter not found)          : console.warn("" + reporter + "" reporter blew up with error: + err.stack);      }    }    if (!_reporter && reporter === teamcity) {      console.warn(The Teamcity reporter was moved to a package named  +        mocha-teamcity-reporter  +        (https://npmjs.org/package/mocha-teamcity-reporter).);    }    if (!_reporter) {      throw new Error(invalid reporter "" + reporter + "");    }    this._reporter = _reporter;  }  this.options.reporterOptions = reporterOptions;  return this;};
 * Set test UI `name`, defaults to ""bdd"". * * @api public *    */Mocha.prototype.ui = function (name) {  name = name || bdd;  this._ui = exports.interfaces[name];  if (!this._ui) {    try {      this._ui = require(name);    } catch (err) {      throw new Error(invalid interface "" + name + "");    }  }  this._ui = this._ui(this.suite);
  this.suite.on(pre-require, function (context) {    exports.afterEach = context.afterEach || context.teardown;    exports.after = context.after || context.suiteTeardown;    exports.beforeEach = context.beforeEach || context.setup;    exports.before = context.before || context.suiteSetup;    exports.describe = context.describe || context.suite;    exports.it = context.it || context.test;    exports.setup = context.setup || context.beforeEach;    exports.suiteSetup = context.suiteSetup || context.before;    exports.suiteTeardown = context.suiteTeardown || context.after;    exports.suite = context.suite || context.describe;    exports.teardown = context.teardown || context.afterEach;    exports.test = context.test || context.it;    exports.run = context.run;  });
  return this;};
 * Load registered files. * * @api private */Mocha.prototype.loadFiles = function (fn) {  var self = this;  var suite = this.suite;  this.files.forEach(function (file) {    file = path.resolve(file);    suite.emit(pre-require, global, file, self);    suite.emit(require, require(file), file, self);    suite.emit(post-require, global, file, self);  });  fn && fn();};
 * Enable growl support. * * @api private */Mocha.prototype._growl = function (runner, reporter) {  var notify = require(growl);
  runner.on(end, function () {    var stats = reporter.stats;    if (stats.failures) {      var msg = stats.failures +  of  + runner.total +  tests failed;      notify(msg, { name: mocha, title: Failed, image: image(error) });    } else {      notify(stats.passes +  tests passed in  + stats.duration + ms, {        name: mocha,        title: Passed,        image: image(ok)      });    }  });};
 * Escape string and add it to grep as a regexp. * * @api public *   *   */Mocha.prototype.fgrep = function (str) {  return this.grep(new RegExp(escapeRe(str)));};
 * Add regexp to grep, if `re` is a string it is escaped. * *    *   * @api public *    *   */Mocha.prototype.grep = function (re) {  if (utils.isString(re)) {     extract args if it's regex-like, i.e: [string, pattern, flag]    var arg = re.match(()(gi));    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);  } else {    this.options.grep = re;  }  return this;}; * Invert `.grep()` matches. * *   * @api public */Mocha.prototype.invert = function () {  this.options.invert = true;  return this;};
 * Ignore global leaks. * *    *   * @api public *    *   */Mocha.prototype.ignoreLeaks = function (ignore) {  this.options.ignoreLeaks = Boolean(ignore);  return this;};
 * Enable global leak checking. * *   * @api public */Mocha.prototype.checkLeaks = function () {  this.options.ignoreLeaks = false;  return this;};
 * Display long stack-trace on failing * *   * @api public */Mocha.prototype.fullTrace = function () {  this.options.fullStackTrace = true;  return this;};
 * Enable growl support. * *   * @api public */Mocha.prototype.growl = function () {  this.options.growl = true;  return this;};
 * Ignore `globals` array or string. * *    *   * @api public *    *   */Mocha.prototype.globals = function (globals) {  this.options.globals = (this.options.globals || []).concat(globals);  return this;};
 * Emit color output. * *    *   * @api public *    *   */Mocha.prototype.useColors = function (colors) {  if (colors !== undefined) {    this.options.useColors = colors;  }  return this;};
 * Use inline diffs rather than +/-. * *    *   * @api public *    *   */Mocha.prototype.useInlineDiffs = function (inlineDiffs) {  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;  return this;};
 * Set the timeout in milliseconds. * *    *   * @api public *    *   */Mocha.prototype.timeout = function (timeout) {  this.suite.timeout(timeout);  return this;};
 * Set the number of times to retry failed tests. * *    times *   * @api public */Mocha.prototype.retries = function (n) {  this.suite.retries(n);  return this;};
 * Set slowness threshold in milliseconds. * *    *   * @api public *    *   */Mocha.prototype.slow = function (slow) {  this.suite.slow(slow);  return this;};
 * Enable timeouts. * *    *   * @api public *    *   */Mocha.prototype.enableTimeouts = function (enabled) {  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);  return this;};
 * Makes all tests async (accepting a callback) * *   * @api public */Mocha.prototype.asyncOnly = function () {  this.options.asyncOnly = true;  return this;};
 * Disable syntax highlighting (in browser). * * @api public */Mocha.prototype.noHighlighting = function () {  this.options.noHighlighting = true;  return this;};
 * Enable uncaught errors to propagate (in browser). * *   * @api public */Mocha.prototype.allowUncaught = function () {  this.options.allowUncaught = true;  return this;};
 * Delay root suite execution. *   */Mocha.prototype.delay = function delay () {  this.options.delay = true;  return this;};
 * Run tests and invoke `fn()` when complete. * * @api public *    *   */Mocha.prototype.run = function (fn) {  if (this.files.length) {    this.loadFiles();  }  var suite = this.suite;  var options = this.options;  options.files = this.files;  var runner = new exports.Runner(suite, options.delay);  var reporter = new this._reporter(runner, options);  runner.ignoreLeaks = options.ignoreLeaks !== false;  runner.fullStackTrace = options.fullStackTrace;  runner.hasOnly = options.hasOnly;  runner.asyncOnly = options.asyncOnly;  runner.allowUncaught = options.allowUncaught;  if (options.grep) {    runner.grep(options.grep, options.invert);  }  if (options.globals) {    runner.globals(options.globals);  }  if (options.growl) {    this._growl(runner, reporter);  }  if (options.useColors !== undefined) {    exports.reporters.Base.useColors = options.useColors;  }  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;
  function done (failures) {    if (reporter.done) {      reporter.done(failures, fn);    } else {      fn && fn(failures);    }  }
  return runner.run(done);};
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {},/lib)},{./context:6,./hook:7,./interfaces:11,./reporters:21,./runnable:33,./runner:34,./suite:35,./test:36,./utils:38,_process:67,escape-string-regexp:47,growl:49,path:42}],15:[function(require,module,exports){use strict;
 * Helpers. */
var s = 1000;var m = s  60;var h = m  60;var d = h  24;var y = d  365.25;
 * Parse or format the given `val`. * * Options: * *  - `long` verbose formatting [false] * * @api public *    *    *   */module.exports = function (val, options) {  options = options || {};  if (typeof val === string) {    return parse(val);  }   https://github.com/mochajs/mocha/pull/1035  return options[long] ? longFormat(val) : shortFormat(val);};
 * Parse the given `str` and return milliseconds. * * @api private *    *   */function parse (str) {  var match = (((?:)) (mssecondssminutesmhourshdaysdyearsy)i).exec(str);  if (!match) {    return;  }  var n = parseFloat(match[1]);  var type = (match[2] || ms).toLowerCase();  switch (type) {    case years:    case year:    case y:      return n  y;    case days:    case day:    case d:      return n  d;    case hours:    case hour:    case h:      return n  h;    case minutes:    case minute:    case m:      return n  m;    case seconds:    case second:    case s:      return n  s;    case ms:      return n;    default:       No default case  }}
 * Short format for `ms`. * * @api private *    *   */function shortFormat (ms) {  if (ms >= d) {    return Math.round(ms / d) + d;  }  if (ms >= h) {    return Math.round(ms / h) + h;  }  if (ms >= m) {    return Math.round(ms / m) + m;  }  if (ms >= s) {    return Math.round(ms / s) + s;  }  return ms + ms;}
 * Long format for `ms`. * * @api private *    *   */function longFormat (ms) {  return plural(ms, d, day) ||    plural(ms, h, hour) ||    plural(ms, m, minute) ||    plural(ms, s, second) ||    ms +  ms;}
 * Pluralization helper. * * @api private *    *    *    */function plural (ms, n, name) {  if (ms < n) {    return;  }  if (ms < n  1.5) {    return Math.floor(ms / n) +   + name;  }  return Math.ceil(ms / n) +   + name + s;}
},{}],16:[function(require,module,exports){use strict;
 * Expose `Pending`. */
module.exports = Pending;
 * Initialize a new `Pending` error with the given message. * *    */function Pending (message) {  this.message = message;}
},{}],17:[function(require,module,exports){(function (process,global){use strict;
 * Module dependencies. */
var tty = require(tty);var diff = require(diff);var ms = require(../ms);var utils = require(../utils);var supportsColor = process.browser ? null : require(supports-color);
 * Expose `Base`. */
exports = module.exports = Base;
 * Save timer references to avoid Sinon interfering. * See: https://github.com/mochajs/mocha/issues/237 */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
 * Check if both stdio streams are associated with a tty. */
var isatty = tty.isatty(1) && tty.isatty(2);
 * Enable coloring by default, except in the browser interface. */
exports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));
 * Inline diffs instead of +/- */
exports.inlineDiffs = false;
 * Default color map. */
exports.colors = {  pass: 90,  fail: 31,  bright pass: 92,  bright fail: 91,  bright yellow: 93,  pending: 36,  suite: 0,  error title: 0,  error message: 31,  error stack: 90,  checkmark: 32,  fast: 90,  medium: 33,  slow: 31,  green: 32,  light: 90,  diff gutter: 90,  diff added: 32,  diff removed: 31};
 * Default symbol map. */
exports.symbols = {  ok: ✓,  err: ✖,  dot: ․,  comma: ,,  bang: !};
 With node.js on Windows: use symbols available in terminal default fontsif (process.platform === win32) {  exports.symbols.ok = ;  exports.symbols.err = ;  exports.symbols.dot = .;}
 * Color `str` with the given `type`, * allowing colors to be disabled, * as well as user-defined color * schemes. * *    *    *   * @api private */var color = exports.color = function (type, str) {  if (!exports.useColors) {    return String(str);  }  return [ + exports.colors[type] + m + str + [0m;};
 * Expose term window size, with some defaults for when stderr is not a tty. */
exports.window = {  width: 75};
if (isatty) {  exports.window.width = process.stdout.getWindowSize      ? process.stdout.getWindowSize(1)[0]      : tty.getWindowSize()[1];}
 * Expose some basic cursor interactions that are common among reporters. */
exports.cursor = {  hide: function () {    isatty && process.stdout.write([?25l);  },
  show: function () {    isatty && process.stdout.write([?25h);  },
  deleteLine: function () {    isatty && process.stdout.write([2K);  },
  beginningOfLine: function () {    isatty && process.stdout.write([0G);  },
  CR: function () {    if (isatty) {      exports.cursor.deleteLine();      exports.cursor.beginningOfLine();    } else {      process.stdout.write();    }  }};
 * Outut the given `failures` as a list. * *    * @api public */
exports.list = function (failures) {  console.log();  failures.forEach(function (test, i) {     format    var fmt = color(error title,   %s) %s:) +      color(error message,      %s) +      color(error stack, %s);
     msg    var msg;    var err = test.err;    var message;    if (err.message && typeof err.message.toString === function) {      message = err.message + ;    } else if (typeof err.inspect === function) {      message = err.inspect() + ;    } else {      message = ;    }    var stack = err.stack || message;    var index = message ? stack.indexOf(message) : -1;    var actual = err.actual;    var expected = err.expected;    var escape = true;
    if (index === -1) {      msg = message;    } else {      index += message.length;      msg = stack.slice(0, index);       remove msg from stack      stack = stack.slice(index + 1);    }
     uncaught    if (err.uncaught) {      msg = Uncaught  + msg;    }     explicitly show diff    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {      escape = false;      if (!(utils.isString(actual) && utils.isString(expected))) {        err.actual = actual = utils.stringify(actual);        err.expected = expected = utils.stringify(expected);      }
      fmt = color(error title,   %s) %s:%s) + color(error stack, %s);      var match = message.match((): expected);      msg =        + color(error message, match ? match[1] : msg);
      if (exports.inlineDiffs) {        msg += inlineDiff(err, escape);      } else {        msg += unifiedDiff(err, escape);      }    }
     indent stack trace    stack = stack.replace(gm,   );
    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);  });};
 * Initialize a new `Base` reporter. * * All other reporters generally * inherit from this reporter, providing * stats such as test duration, number * of tests passed / failed etc. * *    * @api public */
function Base (runner) {  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };  var failures = this.failures = [];
  if (!runner) {    return;  }  this.runner = runner;
  runner.stats = stats;
  runner.on(start, function () {    stats.start = new Date();  });
  runner.on(suite, function (suite) {    stats.suites = stats.suites || 0;    suite.root || stats.suites++;  });
  runner.on(test end, function () {    stats.tests = stats.tests || 0;    stats.tests++;  });
  runner.on(pass, function (test) {    stats.passes = stats.passes || 0;
    if (test.duration > test.slow()) {      test.speed = slow;    } else if (test.duration > test.slow() / 2) {      test.speed = medium;    } else {      test.speed = fast;    }
    stats.passes++;  });
  runner.on(fail, function (test, err) {    stats.failures = stats.failures || 0;    stats.failures++;    test.err = err;    failures.push(test);  });
  runner.on(end, function () {    stats.end = new Date();    stats.duration = new Date() - stats.start;  });
  runner.on(pending, function () {    stats.pending++;  });}
 * Output common epilogue used by many of * the bundled reporters. * * @api public */Base.prototype.epilogue = function () {  var stats = this.stats;  var fmt;
  console.log();
   passes  fmt = color(bright pass,  ) +    color(green,  %d passing) +    color(light,  (%s));
  console.log(fmt,    stats.passes || 0,    ms(stats.duration));
   pending  if (stats.pending) {    fmt = color(pending,  ) +      color(pending,  %d pending);
    console.log(fmt, stats.pending);  }
   failures  if (stats.failures) {    fmt = color(fail,   %d failing);
    console.log(fmt, stats.failures);
    Base.list(this.failures);    console.log();  }
  console.log();};
 * Pad the given `str` to `len`. * * @api private *    *    *   */function pad (str, len) {  str = String(str);  return Array(len - str.length + 1).join( ) + str;}
 * Returns an inline diff between 2 strings with coloured ANSI output * * @api private *    with actual/expected *    *   Diff */function inlineDiff (err, escape) {  var msg = errorDiff(err, WordsWithSpace, escape);
   linenos  var lines = msg.split();  if (lines.length > 4) {    var width = String(lines.length).length;    msg = lines.map(function (str, i) {      return pad(++i, width) +  | +   + str;    }).join();  }
   legend  msg =  +    color(diff removed, actual) +      +    color(diff added, expected) +     +    msg +    ;
   indent  msg = msg.replace(gm,       );  return msg;}
 * Returns a unified diff between two strings. * * @api private *    with actual/expected *    *   The diff. */function unifiedDiff (err, escape) {  var indent =       ;  function cleanUp (line) {    if (escape) {      line = escapeInvisibles(line);    }    if (line[0] === +) {      return indent + colorLines(diff added, line);    }    if (line[0] === -) {      return indent + colorLines(diff removed, line);    }    if (line.match(@@)) {      return null;    }    if (line.match( No newline)) {      return null;    }    return indent + line;  }  function notBlank (line) {    return typeof line !== undefined && line !== null;  }  var msg = diff.createPatch(string, err.actual, err.expected);  var lines = msg.split().splice(4);  return        +    colorLines(diff added, + expected) +   +    colorLines(diff removed, - actual) +     +    lines.map(cleanUp).filter(notBlank).join();}
 * Return a character diff for `err`. * * @api private *    *    *    *   */function errorDiff (err, type, escape) {  var actual = escape ? escapeInvisibles(err.actual) : err.actual;  var expected = escape ? escapeInvisibles(err.expected) : err.expected;  return diff[diff + type](actual, expected).map(function (str) {    if (str.added) {      return colorLines(diff added, str.value);    }    if (str.removed) {      return colorLines(diff removed, str.value);    }    return str.value;  }).join();}
 * Returns a string with all invisible characters in plain text * * @api private *    *   */function escapeInvisibles (line) {  return line.replace(g, <tab>)    .replace(g, <CR>)    .replace(g, <LF>);}
 * Color lines for `str`, using the color `name`. * * @api private *    *    *   */function colorLines (name, str) {  return str.split().map(function (str) {    return color(name, str);  }).join();}
 * Object#toString reference. */var objToString = Object.prototype.toString;
 * Check that a / b have the same type. * * @api private *    *    *   */function sameType (a, b) {  return objToString.call(a) === objToString.call(b);}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{../ms:15,../utils:38,_process:67,diff:46,supports-color:42,tty:5}],18:[function(require,module,exports){use strict;
 * Module dependencies. */
var Base = require(./base);var utils = require(../utils);
 * Expose `Doc`. */
exports = module.exports = Doc;
 * Initialize a new `Doc` reporter. * *    * @api public */function Doc (runner) {  Base.call(this, runner);
  var indents = 2;
  function indent () {    return Array(indents).join(  );  }
  runner.on(suite, function (suite) {    if (suite.root) {      return;    }    ++indents;    console.log(%s<section class=""suite"">, indent());    ++indents;    console.log(%s<h1>%s</h1>, indent(), utils.escape(suite.title));    console.log(%s<dl>, indent());  });
  runner.on(suite end, function (suite) {    if (suite.root) {      return;    }    console.log(%s</dl>, indent());    --indents;    console.log(%s</section>, indent());    --indents;  });
  runner.on(pass, function (test) {    console.log(%s  <dt>%s</dt>, indent(), utils.escape(test.title));    var code = utils.escape(utils.clean(test.body));    console.log(%s  <dd><pre><code>%s</code></pre></dd>, indent(), code);  });
  runner.on(fail, function (test, err) {    console.log(%s  <dt class=""error"">%s</dt>, indent(), utils.escape(test.title));    var code = utils.escape(utils.clean(test.body));    console.log(%s  <dd class=""error""><pre><code>%s</code></pre></dd>, indent(), code);    console.log(%s  <dd class=""error"">%s</dd>, indent(), utils.escape(err));  });}
},{../utils:38,./base:17}],19:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;
 * Expose `Dot`. */
exports = module.exports = Dot;
 * Initialize a new `Dot` matrix test reporter. * * @api public *    */function Dot (runner) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width  0.75 | 0;  var n = -1;
  runner.on(start, function () {    process.stdout.write();  });
  runner.on(pending, function () {    if (++n % width === 0) {      process.stdout.write(  );    }    process.stdout.write(color(pending, Base.symbols.comma));  });
  runner.on(pass, function (test) {    if (++n % width === 0) {      process.stdout.write(  );    }    if (test.speed === slow) {      process.stdout.write(color(bright yellow, Base.symbols.dot));    } else {      process.stdout.write(color(test.speed, Base.symbols.dot));    }  });
  runner.on(fail, function () {    if (++n % width === 0) {      process.stdout.write(  );    }    process.stdout.write(color(fail, Base.symbols.bang));  });
  runner.on(end, function () {    console.log();    self.epilogue();  });}
 * Inherit from `Base.prototype`. */inherits(Dot, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],20:[function(require,module,exports){(function (global){use strict;

 * Module dependencies. */
var Base = require(./base);var utils = require(../utils);var Progress = require(../browser/progress);var escapeRe = require(escape-string-regexp);var escape = utils.escape;
 * Save timer references to avoid Sinon interfering (see GH-237). */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
 * Expose `HTML`. */
exports = module.exports = HTML;
 * Stats template. */
var statsTemplate = <ul id=""mocha-stats""> +  <li class=""progress""><canvas width=""40"" height=""40""></canvas></li> +  <li class=""passes""><a href=""javascript:void(0);"">passes:</a> <em>0</em></li> +  <li class=""failures""><a href=""javascript:void(0);"">failures:</a> <em>0</em></li> +  <li class=""duration"">duration: <em>0</em>s</li> +  </ul>;
 * Initialize a new `HTML` reporter. * * @api public *    */function HTML (runner) {  Base.call(this, runner);
  var self = this;  var stats = this.stats;  var stat = fragment(statsTemplate);  var items = stat.getElementsByTagName(li);  var passes = items[1].getElementsByTagName(em)[0];  var passesLink = items[1].getElementsByTagName(a)[0];  var failures = items[2].getElementsByTagName(em)[0];  var failuresLink = items[2].getElementsByTagName(a)[0];  var duration = items[3].getElementsByTagName(em)[0];  var canvas = stat.getElementsByTagName(canvas)[0];  var report = fragment(<ul id=""mocha-report""></ul>);  var stack = [report];  var progress;  var ctx;  var root = document.getElementById(mocha);
  if (canvas.getContext) {    var ratio = window.devicePixelRatio || 1;    canvas.style.width = canvas.width;    canvas.style.height = canvas.height;    canvas.width  ratio;    canvas.height  ratio;    ctx = canvas.getContext(2d);    ctx.scale(ratio, ratio);    progress = new Progress();  }
  if (!root) {    return error(#mocha div missing, add it to your document);  }
   pass toggle  on(passesLink, click, function (evt) {    evt.preventDefault();    unhide();    var name = (pass).test(report.className) ?  :  pass;    report.className = report.className.replace(failpassg, ) + name;    if (report.className.trim()) {      hideSuitesWithout(test pass);    }  });
   failure toggle  on(failuresLink, click, function (evt) {    evt.preventDefault();    unhide();    var name = (fail).test(report.className) ?  :  fail;    report.className = report.className.replace(failpassg, ) + name;    if (report.className.trim()) {      hideSuitesWithout(test fail);    }  });
  root.appendChild(stat);  root.appendChild(report);
  if (progress) {    progress.size(40);  }
  runner.on(suite, function (suite) {    if (suite.root) {      return;    }
     suite    var url = self.suiteURL(suite);    var el = fragment(<li class=""suite""><h1><a href=""%s"">%s</a></h1></li>, url, escape(suite.title));
     container    stack[0].appendChild(el);    stack.unshift(document.createElement(ul));    el.appendChild(stack[0]);  });
  runner.on(suite end, function (suite) {    if (suite.root) {      updateStats();      return;    }    stack.shift();  });
  runner.on(pass, function (test) {    var url = self.testURL(test);    var markup = <li class=""test pass %e""><h2>%e<span class=""duration"">%ems</span>  +      <a href=""%s"" class=""replay"">&#x2023;</a></h2></li>;    var el = fragment(markup, test.speed, test.title, test.duration, url);    self.addCodeToggle(el, test.body);    appendToStack(el);    updateStats();  });
  runner.on(fail, function (test) {    var el = fragment(<li class=""test fail""><h2>%e <a href=""%e"" class=""replay"">&#x2023;</a></h2></li>,      test.title, self.testURL(test));    var stackString;  Note: Includes leading newline    var message = test.err.toString();
     <=IE7 stringifies to [Object Error]. Since it can be overloaded, we     check for the result of the stringifying.    if (message === [object Error]) {      message = test.err.message;    }
    if (test.err.stack) {      var indexOfMessage = test.err.stack.indexOf(test.err.message);      if (indexOfMessage === -1) {        stackString = test.err.stack;      } else {        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);      }    } else if (test.err.sourceURL && test.err.line !== undefined) {       Safari doesn't give you a stack. Let's at least provide a source line.      stackString = ( + test.err.sourceURL + : + test.err.line + );    }
    stackString = stackString || ;
    if (test.err.htmlMessage && stackString) {      el.appendChild(fragment(<div class=""html-error"">%s<pre class=""error"">%e</pre></div>,        test.err.htmlMessage, stackString));    } else if (test.err.htmlMessage) {      el.appendChild(fragment(<div class=""html-error"">%s</div>, test.err.htmlMessage));    } else {      el.appendChild(fragment(<pre class=""error"">%e%e</pre>, message, stackString));    }
    self.addCodeToggle(el, test.body);    appendToStack(el);    updateStats();  });
  runner.on(pending, function (test) {    var el = fragment(<li class=""test pass pending""><h2>%e</h2></li>, test.title);    appendToStack(el);    updateStats();  });
  function appendToStack (el) {     Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.    if (stack[0]) {      stack[0].appendChild(el);    }  }
  function updateStats () {     TODO: add to stats    var percent = stats.tests / runner.total  100 | 0;    if (progress) {      progress.update(percent).draw(ctx);    }
     update stats    var ms = new Date() - stats.start;    text(passes, stats.passes);    text(failures, stats.failures);    text(duration, (ms / 1000).toFixed(2));  }}
 * Makes a URL, preserving querystring (""search"") parameters. * *    *   A new URL. */function makeUrl (s) {  var search = window.location.search;
   Remove previous grep query parameter if present  if (search) {    search = search.replace(grep=g, ).replace(&, ?);  }
  return window.location.pathname + (search ? search + & : ?) + grep= + encodeURIComponent(escapeRe(s));}
 * Provide suite URL. * *    */HTML.prototype.suiteURL = function (suite) {  return makeUrl(suite.fullTitle());};
 * Provide test URL. * *    */HTML.prototype.testURL = function (test) {  return makeUrl(test.fullTitle());};
 * Adds code toggle functionality for the provided test's list element. * *    *    */HTML.prototype.addCodeToggle = function (el, contents) {  var h2 = el.getElementsByTagName(h2)[0];
  on(h2, click, function () {    pre.style.display = pre.style.display === none ? block : none;  });
  var pre = fragment(<pre><code>%e</code></pre>, utils.clean(contents));  el.appendChild(pre);  pre.style.display = none;};
 * Display error `msg`. * *    */function error (msg) {  document.body.appendChild(fragment(<div id=""mocha-error"">%s</div>, msg));}
 * Return a DOM fragment from `html`. * *    */function fragment (html) {  var args = arguments;  var div = document.createElement(div);  var i = 1;
  div.innerHTML = html.replace(%()g, function (_, type) {    switch (type) {      case s: return String(args[i++]);      case e: return escape(args[i++]);       no default    }  });
  return div.firstChild;}
 * Check for suites that do not have elements * with `classname`, and hide them. * *    */function hideSuitesWithout (classname) {  var suites = document.getElementsByClassName(suite);  for (var i = 0; i < suites.length; i++) {    var els = suites[i].getElementsByClassName(classname);    if (!els.length) {      suites[i].className +=  hidden;    }  }}
 * Unhide .hidden suites. */function unhide () {  var els = document.getElementsByClassName(suite hidden);  for (var i = 0; i < els.length; ++i) {    els[i].className = els[i].className.replace(suite hidden, suite);  }}
 * Set an element's text contents. * *    *    */function text (el, contents) {  if (el.textContent) {    el.textContent = contents;  } else {    el.innerText = contents;  }}
 * Listen on `event` with callback `fn`. */function on (el, event, fn) {  if (el.addEventListener) {    el.addEventListener(event, fn, false);  } else {    el.attachEvent(on + event, fn);  }}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{../browser/progress:4,../utils:38,./base:17,escape-string-regexp:47}],21:[function(require,module,exports){use strict;
 Alias exports to a their normalized format Mocha#reporter to prevent a need for dynamic (try/catch) requires, which Browserify doesn't handle.exports.Base = exports.base = require(./base);exports.Dot = exports.dot = require(./dot);exports.Doc = exports.doc = require(./doc);exports.TAP = exports.tap = require(./tap);exports.JSON = exports.json = require(./json);exports.HTML = exports.html = require(./html);exports.List = exports.list = require(./list);exports.Min = exports.min = require(./min);exports.Spec = exports.spec = require(./spec);exports.Nyan = exports.nyan = require(./nyan);exports.XUnit = exports.xunit = require(./xunit);exports.Markdown = exports.markdown = require(./markdown);exports.Progress = exports.progress = require(./progress);exports.Landing = exports.landing = require(./landing);exports.JSONStream = exports[json-stream] = require(./json-stream);
},{./base:17,./doc:18,./dot:19,./html:20,./json:23,./json-stream:22,./landing:24,./list:25,./markdown:26,./min:27,./nyan:28,./progress:29,./spec:30,./tap:31,./xunit:32}],22:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var JSON = require(json3);
 * Expose `List`. */
exports = module.exports = List;
 * Initialize a new `List` test reporter. * * @api public *    */function List (runner) {  Base.call(this, runner);
  var self = this;  var total = runner.total;
  runner.on(start, function () {    console.log(JSON.stringify([start, { total: total }]));  });
  runner.on(pass, function (test) {    console.log(JSON.stringify([pass, clean(test)]));  });
  runner.on(fail, function (test, err) {    test = clean(test);    test.err = err.message;    test.stack = err.stack || null;    console.log(JSON.stringify([fail, test]));  });
  runner.on(end, function () {    process.stdout.write(JSON.stringify([end, self.stats]));  });}
 * Return a plain-object representation of `test` * free of cyclic properties etc. * * @api private *    *   */function clean (test) {  return {    title: test.title,    fullTitle: test.fullTitle(),    duration: test.duration,    currentRetry: test.currentRetry()  };}
}).call(this,require(_process))},{./base:17,_process:67,json3:54}],23:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);
 * Expose `JSON`. */
exports = module.exports = JSONReporter;
 * Initialize a new `JSON` reporter. * * @api public *    */function JSONReporter (runner) {  Base.call(this, runner);
  var self = this;  var tests = [];  var pending = [];  var failures = [];  var passes = [];
  runner.on(test end, function (test) {    tests.push(test);  });
  runner.on(pass, function (test) {    passes.push(test);  });
  runner.on(fail, function (test) {    failures.push(test);  });
  runner.on(pending, function (test) {    pending.push(test);  });
  runner.on(end, function () {    var obj = {      stats: self.stats,      tests: tests.map(clean),      pending: pending.map(clean),      failures: failures.map(clean),      passes: passes.map(clean)    };
    runner.testResults = obj;
    process.stdout.write(JSON.stringify(obj, null, 2));  });}
 * Return a plain-object representation of `test` * free of cyclic properties etc. * * @api private *    *   */function clean (test) {  return {    title: test.title,    fullTitle: test.fullTitle(),    duration: test.duration,    currentRetry: test.currentRetry(),    err: errorJSON(test.err || {})  };}
 * Transform `error` into a JSON object. * * @api private *    *   */function errorJSON (err) {  var res = {};  Object.getOwnPropertyNames(err).forEach(function (key) {    res[key] = err[key];  }, err);  return res;}
}).call(this,require(_process))},{./base:17,_process:67}],24:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var cursor = Base.cursor;var color = Base.color;
 * Expose `Landing`. */
exports = module.exports = Landing;
 * Airplane color. */
Base.colors.plane = 0;
 * Airplane crash color. */
Base.colors[plane crash] = 31;
 * Runway color. */
Base.colors.runway = 90;
 * Initialize a new `Landing` reporter. * * @api public *    */function Landing (runner) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width  0.75 | 0;  var total = runner.total;  var stream = process.stdout;  var plane = color(plane, ✈);  var crashed = -1;  var n = 0;
  function runway () {    var buf = Array(width).join(-);    return    + color(runway, buf);  }
  runner.on(start, function () {    stream.write(  );    cursor.hide();  });
  runner.on(test end, function (test) {     check if the plane crashed    var col = crashed === -1 ? width  ++n / total | 0 : crashed;
     show the crash    if (test.state === failed) {      plane = color(plane crash, ✈);      crashed = col;    }
     render landing strip    stream.write([ + (width + 1) + D[2A);    stream.write(runway());    stream.write(  );    stream.write(color(runway, Array(col).join(⋅)));    stream.write(plane);    stream.write(color(runway, Array(width - col).join(⋅) + ));    stream.write(runway());    stream.write([0m);  });
  runner.on(end, function () {    cursor.show();    console.log();    self.epilogue();  });}
 * Inherit from `Base.prototype`. */inherits(Landing, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],25:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;var cursor = Base.cursor;
 * Expose `List`. */
exports = module.exports = List;
 * Initialize a new `List` test reporter. * * @api public *    */function List (runner) {  Base.call(this, runner);
  var self = this;  var n = 0;
  runner.on(start, function () {    console.log();  });
  runner.on(test, function (test) {    process.stdout.write(color(pass,      + test.fullTitle() + : ));  });
  runner.on(pending, function (test) {    var fmt = color(checkmark,   -) +      color(pending,  %s);    console.log(fmt, test.fullTitle());  });
  runner.on(pass, function (test) {    var fmt = color(checkmark,    + Base.symbols.ok) +      color(pass,  %s: ) +      color(test.speed, %dms);    cursor.CR();    console.log(fmt, test.fullTitle(), test.duration);  });
  runner.on(fail, function (test) {    cursor.CR();    console.log(color(fail,   %d) %s), ++n, test.fullTitle());  });
  runner.on(end, self.epilogue.bind(self));}
 * Inherit from `Base.prototype`. */inherits(List, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],26:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var utils = require(../utils);
 * Constants */
var SUITE_PREFIX = $;
 * Expose `Markdown`. */
exports = module.exports = Markdown;
 * Initialize a new `Markdown` reporter. * * @api public *    */function Markdown (runner) {  Base.call(this, runner);
  var level = 0;  var buf = ;
  function title (str) {    return Array(level).join(#) +   + str;  }
  function mapTOC (suite, obj) {    var ret = obj;    var key = SUITE_PREFIX + suite.title;
    obj = obj[key] = obj[key] || { suite: suite };    suite.suites.forEach(function (suite) {      mapTOC(suite, obj);    });
    return ret;  }
  function stringifyTOC (obj, level) {    ++level;    var buf = ;    var link;    for (var key in obj) {      if (key === suite) {        continue;      }      if (key !== SUITE_PREFIX) {        link =  - [ + key.substring(1) + ];        link += (# + utils.slug(obj[key].suite.fullTitle()) + );        buf += Array(level).join(  ) + link;      }      buf += stringifyTOC(obj[key], level);    }    return buf;  }
  function generateTOC (suite) {    var obj = mapTOC(suite, {});    return stringifyTOC(obj, 0);  }
  generateTOC(runner.suite);
  runner.on(suite, function (suite) {    ++level;    var slug = utils.slug(suite.fullTitle());    buf += <a name="" + slug + ""></a> + ;    buf += title(suite.title) + ;  });
  runner.on(suite end, function () {    --level;  });
  runner.on(pass, function (test) {    var code = utils.clean(test.body);    buf += test.title + .;    buf += ```js;    buf += code + ;    buf += ```;  });
  runner.on(end, function () {    process.stdout.write(# TOC);    process.stdout.write(generateTOC(runner.suite));    process.stdout.write(buf);  });}
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],27:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;
 * Expose `Min`. */
exports = module.exports = Min;
 * Initialize a new `Min` minimal test reporter (best used with --watch). * * @api public *    */function Min (runner) {  Base.call(this, runner);
  runner.on(start, function () {     clear screen    process.stdout.write([2J);     set cursor position    process.stdout.write([1;3H);  });
  runner.on(end, this.epilogue.bind(this));}
 * Inherit from `Base.prototype`. */inherits(Min, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],28:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;
 * Expose `Dot`. */
exports = module.exports = NyanCat;
 * Initialize a new `Dot` matrix test reporter. * *    * @api public */
function NyanCat (runner) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width  0.75 | 0;  var nyanCatWidth = this.nyanCatWidth = 11;
  this.colorIndex = 0;  this.numberOfLines = 4;  this.rainbowColors = self.generateColors();  this.scoreboardWidth = 5;  this.tick = 0;  this.trajectories = [[], [], [], []];  this.trajectoryWidthMax = (width - nyanCatWidth);
  runner.on(start, function () {    Base.cursor.hide();    self.draw();  });
  runner.on(pending, function () {    self.draw();  });
  runner.on(pass, function () {    self.draw();  });
  runner.on(fail, function () {    self.draw();  });
  runner.on(end, function () {    Base.cursor.show();    for (var i = 0; i < self.numberOfLines; i++) {      write();    }    self.epilogue();  });}
 * Inherit from `Base.prototype`. */inherits(NyanCat, Base);
 * Draw the nyan cat * * @api private */
NyanCat.prototype.draw = function () {  this.appendRainbow();  this.drawScoreboard();  this.drawRainbow();  this.drawNyanCat();  this.tick = !this.tick;};
 * Draw the ""scoreboard"" showing the number * of passes, failures and pending tests. * * @api private */
NyanCat.prototype.drawScoreboard = function () {  var stats = this.stats;
  function draw (type, n) {    write( );    write(Base.color(type, n));    write();  }
  draw(green, stats.passes);  draw(fail, stats.failures);  draw(pending, stats.pending);  write();
  this.cursorUp(this.numberOfLines);};
 * Append the rainbow. * * @api private */
NyanCat.prototype.appendRainbow = function () {  var segment = this.tick ? _ : -;  var rainbowified = this.rainbowify(segment);
  for (var index = 0; index < this.numberOfLines; index++) {    var trajectory = this.trajectories[index];    if (trajectory.length >= this.trajectoryWidthMax) {      trajectory.shift();    }    trajectory.push(rainbowified);  }};
 * Draw the rainbow. * * @api private */
NyanCat.prototype.drawRainbow = function () {  var self = this;
  this.trajectories.forEach(function (line) {    write([ + self.scoreboardWidth + C);    write(line.join());    write();  });
  this.cursorUp(this.numberOfLines);};
 * Draw the nyan cat * * @api private */NyanCat.prototype.drawNyanCat = function () {  var self = this;  var startWidth = this.scoreboardWidth + this.trajectories[0].length;  var dist = [ + startWidth + C;  var padding = ;
  write(dist);  write(_,------,);  write();
  write(dist);  padding = self.tick ?    :    ;  write(_| + padding + /_/ );  write();
  write(dist);  padding = self.tick ? _ : __;  var tail = self.tick ? ~ : ^;  write(tail + | + padding + this.face() +  );  write();
  write(dist);  padding = self.tick ?   :   ;  write(padding + """"  """" );  write();
  this.cursorUp(this.numberOfLines);};
 * Draw nyan cat face. * * @api private *   */
NyanCat.prototype.face = function () {  var stats = this.stats;  if (stats.failures) {    return ( x .x);  } else if (stats.pending) {    return ( o .o);  } else if (stats.passes) {    return ( ^ .^);  }  return ( - .-);};
 * Move cursor up `n`. * * @api private *    */
NyanCat.prototype.cursorUp = function (n) {  write([ + n + A);};
 * Move cursor down `n`. * * @api private *    */
NyanCat.prototype.cursorDown = function (n) {  write([ + n + B);};
 * Generate rainbow colors. * * @api private *   */NyanCat.prototype.generateColors = function () {  var colors = [];
  for (var i = 0; i < (6  7); i++) {    var pi3 = Math.floor(Math.PI / 3);    var n = (i  (1.0 / 6));    var r = Math.floor(3  Math.sin(n) + 3);    var g = Math.floor(3  Math.sin(n + 2  pi3) + 3);    var b = Math.floor(3  Math.sin(n + 4  pi3) + 3);    colors.push(36  r + 6  g + b + 16);  }
  return colors;};
 * Apply rainbow to the given `str`. * * @api private *    *   */NyanCat.prototype.rainbowify = function (str) {  if (!Base.useColors) {    return str;  }  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];  this.colorIndex += 1;  return [38;5; + color + m + str + [0m;};
 * Stdout helper. * *    A message to write to stdout. */function write (string) {  process.stdout.write(string);}
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],29:[function(require,module,exports){(function (process){use strict;
 * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;var cursor = Base.cursor;
 * Expose `Progress`. */
exports = module.exports = Progress;
 * General progress bar color. */
Base.colors.progress = 90;
 * Initialize a new `Progress` bar test reporter. * * @api public *    *    */function Progress (runner, options) {  Base.call(this, runner);
  var self = this;  var width = Base.window.width  0.50 | 0;  var total = runner.total;  var complete = 0;  var lastN = -1;
   default chars  options = options || {};  options.open = options.open || [;  options.complete = options.complete || ▬;  options.incomplete = options.incomplete || Base.symbols.dot;  options.close = options.close || ];  options.verbose = false;
   tests started  runner.on(start, function () {    console.log();    cursor.hide();  });
   tests complete  runner.on(test end, function () {    complete++;
    var percent = complete / total;    var n = width  percent | 0;    var i = width - n;
    if (n === lastN && !options.verbose) {       Don't re-render the line if it hasn't changed      return;    }    lastN = n;
    cursor.CR();    process.stdout.write([J);    process.stdout.write(color(progress,    + options.open));    process.stdout.write(Array(n).join(options.complete));    process.stdout.write(Array(i).join(options.incomplete));    process.stdout.write(color(progress, options.close));    if (options.verbose) {      process.stdout.write(color(progress,   + complete +  of  + total));    }  });
   tests are complete, output some stats   and the failures if any  runner.on(end, function () {    cursor.show();    console.log();    self.epilogue();  });}
 * Inherit from `Base.prototype`. */inherits(Progress, Base);
}).call(this,require(_process))},{../utils:38,./base:17,_process:67}],30:[function(require,module,exports){use strict;
 * Module dependencies. */
var Base = require(./base);var inherits = require(../utils).inherits;var color = Base.color;
 * Expose `Spec`. */
exports = module.exports = Spec;
 * Initialize a new `Spec` test reporter. * * @api public *    */function Spec (runner) {  Base.call(this, runner);
  var self = this;  var indents = 0;  var n = 0;
  function indent () {    return Array(indents).join(  );  }
  runner.on(start, function () {    console.log();  });
  runner.on(suite, function (suite) {    ++indents;    console.log(color(suite, %s%s), indent(), suite.title);  });
  runner.on(suite end, function () {    --indents;    if (indents === 1) {      console.log();    }  });
  runner.on(pending, function (test) {    var fmt = indent() + color(pending,   - %s);    console.log(fmt, test.title);  });
  runner.on(pass, function (test) {    var fmt;    if (test.speed === fast) {      fmt = indent() +        color(checkmark,    + Base.symbols.ok) +        color(pass,  %s);      console.log(fmt, test.title);    } else {      fmt = indent() +        color(checkmark,    + Base.symbols.ok) +        color(pass,  %s) +        color(test.speed,  (%dms));      console.log(fmt, test.title, test.duration);    }  });
  runner.on(fail, function (test) {    console.log(indent() + color(fail,   %d) %s), ++n, test.title);  });
  runner.on(end, self.epilogue.bind(self));}
 * Inherit from `Base.prototype`. */inherits(Spec, Base);
},{../utils:38,./base:17}],31:[function(require,module,exports){use strict;
 * Module dependencies. */
var Base = require(./base);
 * Expose `TAP`. */
exports = module.exports = TAP;
 * Initialize a new `TAP` reporter. * * @api public *    */function TAP (runner) {  Base.call(this, runner);
  var n = 1;  var passes = 0;  var failures = 0;
  runner.on(start, function () {    var total = runner.grepTotal(runner.suite);    console.log(%d..%d, 1, total);  });
  runner.on(test end, function () {    ++n;  });
  runner.on(pending, function (test) {    console.log(ok %d %s # SKIP -, n, title(test));  });
  runner.on(pass, function (test) {    passes++;    console.log(ok %d %s, n, title(test));  });
  runner.on(fail, function (test, err) {    failures++;    console.log(not ok %d %s, n, title(test));    if (err.stack) {      console.log(err.stack.replace(gm,   ));    }  });
  runner.on(end, function () {    console.log(# tests  + (passes + failures));    console.log(# pass  + passes);    console.log(# fail  + failures);  });}
 * Return a TAP-safe title of `test` * * @api private *    *   */function title (test) {  return test.fullTitle().replace(#g, );}
},{./base:17}],32:[function(require,module,exports){(function (process,global){use strict;
 * Module dependencies. */
var Base = require(./base);var utils = require(../utils);var inherits = utils.inherits;var fs = require(fs);var escape = utils.escape;var mkdirp = require(mkdirp);var path = require(path);
 * Save timer references to avoid Sinon interfering (see GH-237). */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
 * Expose `XUnit`. */
exports = module.exports = XUnit;
 * Initialize a new `XUnit` reporter. * * @api public *    */function XUnit (runner, options) {  Base.call(this, runner);
  var stats = this.stats;  var tests = [];  var self = this;
  if (options && options.reporterOptions && options.reporterOptions.output) {    if (!fs.createWriteStream) {      throw new Error(file output not supported in browser);    }    mkdirp.sync(path.dirname(options.reporterOptions.output));    self.fileStream = fs.createWriteStream(options.reporterOptions.output);  }
  runner.on(pending, function (test) {    tests.push(test);  });
  runner.on(pass, function (test) {    tests.push(test);  });
  runner.on(fail, function (test) {    tests.push(test);  });
  runner.on(end, function () {    self.write(tag(testsuite, {      name: Mocha Tests,      tests: stats.tests,      failures: stats.failures,      errors: stats.failures,      skipped: stats.tests - stats.failures - stats.passes,      timestamp: (new Date()).toUTCString(),      time: (stats.duration / 1000) || 0    }, false));
    tests.forEach(function (t) {      self.test(t);    });
    self.write(</testsuite>);  });}
 * Inherit from `Base.prototype`. */inherits(XUnit, Base);
 * Override done to close the stream (if it's a file). * *   *    */XUnit.prototype.done = function (failures, fn) {  if (this.fileStream) {    this.fileStream.end(function () {      fn(failures);    });  } else {    fn(failures);  }};
 * Write out the given line. * *    */XUnit.prototype.write = function (line) {  if (this.fileStream) {    this.fileStream.write(line + );  } else if (typeof process === object && process.stdout) {    process.stdout.write(line + );  } else {    console.log(line);  }};
 * Output tag for the given `test.` * *    */XUnit.prototype.test = function (test) {  var attrs = {    classname: test.parent.fullTitle(),    name: test.title,    time: (test.duration / 1000) || 0  };
  if (test.state === failed) {    var err = test.err;    this.write(tag(testcase, attrs, false, tag(failure, {}, false, escape(err.message) +  + escape(err.stack))));  } else if (test.isPending()) {    this.write(tag(testcase, attrs, false, tag(skipped, {}, true)));  } else {    this.write(tag(testcase, attrs, true));  }};
 * HTML tag helper. * *   *   *   *   *   */function tag (name, attrs, close, content) {  var end = close ? /> : >;  var pairs = [];  var tag;
  for (var key in attrs) {    if (Object.prototype.hasOwnProperty.call(attrs, key)) {      pairs.push(key + ="" + escape(attrs[key]) + "");    }  }
  tag = < + name + (pairs.length ?   + pairs.join( ) : ) + end;  if (content) {    tag += content + </ + name + end;  }  return tag;}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{../utils:38,./base:17,_process:67,fs:42,mkdirp:64,path:42}],33:[function(require,module,exports){(function (global){use strict;
 * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var JSON = require(json3);var Pending = require(./pending);var debug = require(debug)(mocha:runnable);var milliseconds = require(./ms);var utils = require(./utils);var create = require(lodash.create);
 * Save timer references to avoid Sinon interfering (see GH-237). */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
 * Object#toString(). */
var toString = Object.prototype.toString;
 * Expose `Runnable`. */
module.exports = Runnable;
 * Initialize a new `Runnable` with the given `title` and callback `fn`. * *    *    * @api private *    *    */function Runnable (title, fn) {  this.title = title;  this.fn = fn;  this.body = (fn || ).toString();  this.async = fn && fn.length;  this.sync = !this.async;  this._timeout = 2000;  this._slow = 75;  this._enableTimeouts = true;  this.timedOut = false;  this._trace = new Error(done() called multiple times);  this._retries = -1;  this._currentRetry = 0;  this.pending = false;}
 * Inherit from `EventEmitter.prototype`. */Runnable.prototype = create(EventEmitter.prototype, {  constructor: Runnable});
 * Set & get timeout `ms`. * * @api private *    *   ms or Runnable instance. */Runnable.prototype.timeout = function (ms) {  if (!arguments.length) {    return this._timeout;  }   see #1652 for reasoning  if (ms === 0 || ms > Math.pow(2, 31)) {    this._enableTimeouts = false;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(timeout %d, ms);  this._timeout = ms;  if (this.timer) {    this.resetTimeout();  }  return this;};
 * Set & get slow `ms`. * * @api private *    *   ms or Runnable instance. */Runnable.prototype.slow = function (ms) {  if (typeof ms === undefined) {    return this._slow;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(timeout %d, ms);  this._slow = ms;  return this;};
 * Set and get whether timeout is `enabled`. * * @api private *    *   enabled or Runnable instance. */Runnable.prototype.enableTimeouts = function (enabled) {  if (!arguments.length) {    return this._enableTimeouts;  }  debug(enableTimeouts %s, enabled);  this._enableTimeouts = enabled;  return this;};
 * Halt and mark as pending. * * @api public */Runnable.prototype.skip = function () {  throw new Pending(sync skip);};
 * Check if this runnable or its parent suite is marked as pending. * * @api private */Runnable.prototype.isPending = function () {  return this.pending || (this.parent && this.parent.isPending());};
 * Set number of retries. * * @api private */Runnable.prototype.retries = function (n) {  if (!arguments.length) {    return this._retries;  }  this._retries = n;};
 * Get current retry * * @api private */Runnable.prototype.currentRetry = function (n) {  if (!arguments.length) {    return this._currentRetry;  }  this._currentRetry = n;};
 * Return the full title generated by recursively concatenating the parent's * full title. * * @api public *   */Runnable.prototype.fullTitle = function () {  return this.parent.fullTitle() +   + this.title;};
 * Clear the timeout. * * @api private */Runnable.prototype.clearTimeout = function () {  clearTimeout(this.timer);};
 * Inspect the runnable void of private properties. * * @api private *   */Runnable.prototype.inspect = function () {  return JSON.stringify(this, function (key, val) {    if (key[0] === _) {      return;    }    if (key === parent) {      return #<Suite>;    }    if (key === ctx) {      return #<Context>;    }    return val;  }, 2);};
 * Reset the timeout. * * @api private */Runnable.prototype.resetTimeout = function () {  var self = this;  var ms = this.timeout() || 1e9;
  if (!this._enableTimeouts) {    return;  }  this.clearTimeout();  this.timer = setTimeout(function () {    if (!self._enableTimeouts) {      return;    }    self.callback(new Error(Timeout of  + ms +      ms exceeded. For async tests and hooks, ensure ""done()"" is called; if returning a Promise, ensure it resolves.));    self.timedOut = true;  }, ms);};
 * Whitelist a list of globals for this test run. * * @api private *    */Runnable.prototype.globals = function (globals) {  if (!arguments.length) {    return this._allowedGlobals;  }  this._allowedGlobals = globals;};
 * Run the test and invoke `fn(err)`. * *    * @api private */Runnable.prototype.run = function (fn) {  var self = this;  var start = new Date();  var ctx = this.ctx;  var finished;  var emitted;
   Sometimes the ctx exists, but it is not runnable  if (ctx && ctx.runnable) {    ctx.runnable(this);  }
   called multiple times  function multiple (err) {    if (emitted) {      return;    }    emitted = true;    self.emit(error, err || new Error(done() called multiple times; stacktrace may be inaccurate));  }
   finished  function done (err) {    var ms = self.timeout();    if (self.timedOut) {      return;    }    if (finished) {      return multiple(err || self._trace);    }
    self.clearTimeout();    self.duration = new Date() - start;    finished = true;    if (!err && self.duration > ms && self._enableTimeouts) {      err = new Error(Timeout of  + ms +      ms exceeded. For async tests and hooks, ensure ""done()"" is called; if returning a Promise, ensure it resolves.);    }    fn(err);  }
   for .resetTimeout()  this.callback = done;
   explicit async with `done` argument  if (this.async) {    this.resetTimeout();
     allows skip() to be used in an explicit async context    this.skip = function asyncSkip () {      done(new Pending(async skip call));       halt execution.  the Runnable will be marked pending       by the previous call, and the uncaught handler will ignore       the failure.      throw new Pending(async skip; aborting execution);    };
    if (this.allowUncaught) {      return callFnAsync(this.fn);    }    try {      callFnAsync(this.fn);    } catch (err) {      emitted = true;      done(utils.getError(err));    }    return;  }
  if (this.allowUncaught) {    callFn(this.fn);    done();    return;  }
   sync or promise-returning  try {    if (this.isPending()) {      done();    } else {      callFn(this.fn);    }  } catch (err) {    emitted = true;    done(utils.getError(err));  }
  function callFn (fn) {    var result = fn.call(ctx);    if (result && typeof result.then === function) {      self.resetTimeout();      result        .then(function () {          done();           Return null so libraries like bluebird do not warn about           subsequently constructed Promises.          return null;        },        function (reason) {          done(reason || new Error(Promise rejected with no or falsy reason));        });    } else {      if (self.asyncOnly) {        return done(new Error(--async-only option in use without declaring `done()` or returning a promise));      }
      done();    }  }
  function callFnAsync (fn) {    var result = fn.call(ctx, function (err) {      if (err instanceof Error || toString.call(err) === [object Error]) {        return done(err);      }      if (err) {        if (Object.prototype.toString.call(err) === [object Object]) {          return done(new Error(done() invoked with non-Error:  +            JSON.stringify(err)));        }        return done(new Error(done() invoked with non-Error:  + err));      }      if (result && utils.isPromise(result)) {        return done(new Error(Resolution method is overspecified. Specify a callback *or* return a Promise; not both.));      }
      done();    });  }};
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./ms:15,./pending:16,./utils:38,debug:2,events:3,json3:54,lodash.create:60}],34:[function(require,module,exports){(function (process,global){use strict;
 * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var Pending = require(./pending);var utils = require(./utils);var inherits = utils.inherits;var debug = require(debug)(mocha:runner);var Runnable = require(./runnable);var filter = utils.filter;var indexOf = utils.indexOf;var some = utils.some;var keys = utils.keys;var stackFilter = utils.stackTraceFilter();var stringify = utils.stringify;var type = utils.type;var undefinedError = utils.undefinedError;var isArray = utils.isArray;
 * Non-enumerable globals. */
var globals = [  setTimeout,  clearTimeout,  setInterval,  clearInterval,  XMLHttpRequest,  Date,  setImmediate,  clearImmediate];
 * Expose `Runner`. */
module.exports = Runner;
 * Initialize a `Runner` for the given `suite`. * * Events: * *   - `start`  execution started *   - `end`  execution complete *   - `suite`  (suite) test suite execution started *   - `suite end`  (suite) all tests (and sub-suites) have finished *   - `test`  (test) test execution started *   - `test end`  (test) test completed *   - `hook`  (hook) hook execution started *   - `hook end`  (hook) hook complete *   - `pass`  (test) test passed *   - `fail`  (test, err) test failed *   - `pending`  (test) test pending * * @api public *    Root suite *    Whether or not to delay execution of root suite * until ready. */function Runner (suite, delay) {  var self = this;  this._globals = [];  this._abort = false;  this._delay = delay;  this.suite = suite;  this.started = false;  this.total = suite.total();  this.failures = 0;  this.on(test end, function (test) {    self.checkGlobals(test);  });  this.on(hook end, function (hook) {    self.checkGlobals(hook);  });  this._defaultGrep = ;  this.grep(this._defaultGrep);  this.globals(this.globalProps().concat(extraGlobals()));}
 * Wrapper for setImmediate, process.nextTick, or browser polyfill. * *    * @api private */Runner.immediately = global.setImmediate || process.nextTick;
 * Inherit from `EventEmitter.prototype`. */inherits(Runner, EventEmitter);
 * Run tests with full titles matching `re`. Updates runner.total * with number of tests matched. * *    *    *   for chaining * @api public *    *    *   Runner instance. */Runner.prototype.grep = function (re, invert) {  debug(grep %s, re);  this._grep = re;  this._invert = invert;  this.total = this.grepTotal(this.suite);  return this;};
 * Returns the number of tests matching the grep search for the * given suite. * *    *   * @api public *    *   */Runner.prototype.grepTotal = function (suite) {  var self = this;  var total = 0;
  suite.eachTest(function (test) {    var match = self._grep.test(test.fullTitle());    if (self._invert) {      match = !match;    }    if (match) {      total++;    }  });
  return total;};
 * Return a list of global properties. * *   * @api private */Runner.prototype.globalProps = function () {  var props = keys(global);
   non-enumerables  for (var i = 0; i < globals.length; ++i) {    if (~indexOf(props, globals[i])) {      continue;    }    props.push(globals[i]);  }
  return props;};
 * Allow the given `arr` of globals. * *    *   for chaining * @api public *    *   Runner instance. */Runner.prototype.globals = function (arr) {  if (!arguments.length) {    return this._globals;  }  debug(globals %j, arr);  this._globals = this._globals.concat(arr);  return this;};
 * Check for global variable leaks. * * @api private */Runner.prototype.checkGlobals = function (test) {  if (this.ignoreLeaks) {    return;  }  var ok = this._globals;
  var globals = this.globalProps();  var leaks;
  if (test) {    ok = ok.concat(test._allowedGlobals || []);  }
  if (this.prevGlobalsLength === globals.length) {    return;  }  this.prevGlobalsLength = globals.length;
  leaks = filterLeaks(ok, globals);  this._globals = this._globals.concat(leaks);
  if (leaks.length > 1) {    this.fail(test, new Error(global leaks detected:  + leaks.join(, ) + ));  } else if (leaks.length) {    this.fail(test, new Error(global leak detected:  + leaks[0]));  }};
 * Fail the given `test`. * * @api private *    *    */Runner.prototype.fail = function (test, err) {  if (test.isPending()) {    return;  }
  ++this.failures;  test.state = failed;
  if (!(err instanceof Error || err && typeof err.message === string)) {    err = new Error(the  + type(err) +   + stringify(err) +  was thrown, throw an Error :));  }
  try {    err.stack = (this.fullStackTrace || !err.stack)      ? err.stack      : stackFilter(err.stack);  } catch (ignored) {     some environments do not take kindly to monkeying with the stack  }
  this.emit(fail, test, err);};
 * Fail the given `hook` with `err`. * * Hook failures work in the following pattern: * - If bail, then exit * - Failed `before` hook skips all tests in a suite and subsuites, *   but jumps to corresponding `after` hook * - Failed `before each` hook skips remaining tests in a *   suite and jumps to corresponding `after each` hook, *   which is run only once * - Failed `after` hook does not alter *   execution order * - Failed `after each` hook skips remaining tests in a *   suite and subsuites, but executes other `after each` *   hooks * * @api private *    *    */Runner.prototype.failHook = function (hook, err) {  if (hook.ctx && hook.ctx.currentTest) {    hook.originalTitle = hook.originalTitle || hook.title;    hook.title = hook.originalTitle +  for "" + hook.ctx.currentTest.title + "";  }
  this.fail(hook, err);  if (this.suite.bail()) {    this.emit(end);  }};
 * Run hook `name` callbacks and then invoke `fn()`. * * @api private *    *    */
Runner.prototype.hook = function (name, fn) {  var suite = this.suite;  var hooks = suite[_ + name];  var self = this;
  function next (i) {    var hook = hooks[i];    if (!hook) {      return fn();    }    self.currentRunnable = hook;
    hook.ctx.currentTest = self.test;
    self.emit(hook, hook);
    if (!hook.listeners(error).length) {      hook.on(error, function (err) {        self.failHook(hook, err);      });    }
    hook.run(function (err) {      var testError = hook.error();      if (testError) {        self.fail(self.test, testError);      }      if (err) {        if (err instanceof Pending) {          if (name === beforeEach || name === afterEach) {            self.test.pending = true;          } else {            utils.forEach(suite.tests, function (test) {              test.pending = true;            });             a pending hook won't be executed twice.            hook.pending = true;          }        } else {          self.failHook(hook, err);
           stop executing hooks, notify callee of hook err          return fn(err);        }      }      self.emit(hook end, hook);      delete hook.ctx.currentTest;      next(++i);    });  }
  Runner.immediately(function () {    next(0);  });};
 * Run hook `name` for the given array of `suites` * in order, and callback `fn(err, errSuite)`. * * @api private *    *    *    */Runner.prototype.hooks = function (name, suites, fn) {  var self = this;  var orig = this.suite;
  function next (suite) {    self.suite = suite;
    if (!suite) {      self.suite = orig;      return fn();    }
    self.hook(name, function (err) {      if (err) {        var errSuite = self.suite;        self.suite = orig;        return fn(err, errSuite);      }
      next(suites.pop());    });  }
  next(suites.pop());};
 * Run hooks from the top level down. * *    *    * @api private */Runner.prototype.hookUp = function (name, fn) {  var suites = [this.suite].concat(this.parents()).reverse();  this.hooks(name, suites, fn);};
 * Run hooks from the bottom up. * *    *    * @api private */Runner.prototype.hookDown = function (name, fn) {  var suites = [this.suite].concat(this.parents());  this.hooks(name, suites, fn);};
 * Return an array of parent Suites from * closest to furthest. * *   * @api private */Runner.prototype.parents = function () {  var suite = this.suite;  var suites = [];  while (suite.parent) {    suite = suite.parent;    suites.push(suite);  }  return suites;};
 * Run the current test and callback `fn(err)`. * *    * @api private */Runner.prototype.runTest = function (fn) {  var self = this;  var test = this.test;
  if (!test) {    return;  }  if (this.asyncOnly) {    test.asyncOnly = true;  }
  if (this.allowUncaught) {    test.allowUncaught = true;    return test.run(fn);  }  try {    test.on(error, function (err) {      self.fail(test, err);    });    test.run(fn);  } catch (err) {    fn(err);  }};
 * Run tests in the given `suite` and invoke the callback `fn()` when complete. * * @api private *    *    */Runner.prototype.runTests = function (suite, fn) {  var self = this;  var tests = suite.tests.slice();  var test;
  function hookErr (_, errSuite, after) {     before/after Each hook for errSuite failed:    var orig = self.suite;
     for failed 'after each' hook start from errSuite parent,     otherwise start from errSuite itself    self.suite = after ? errSuite.parent : errSuite;
    if (self.suite) {       call hookUp afterEach      self.hookUp(afterEach, function (err2, errSuite2) {        self.suite = orig;         some hooks may fail even now        if (err2) {          return hookErr(err2, errSuite2, true);        }         report error suite        fn(errSuite);      });    } else {       there is no need calling other 'after each' hooks      self.suite = orig;      fn(errSuite);    }  }
  function next (err, errSuite) {     if we bail after first err    if (self.failures && suite._bail) {      return fn();    }
    if (self._abort) {      return fn();    }
    if (err) {      return hookErr(err, errSuite, true);    }
     next test    test = tests.shift();
     all done    if (!test) {      return fn();    }
     grep    var match = self._grep.test(test.fullTitle());    if (self._invert) {      match = !match;    }    if (!match) {       Run immediately only if we have defined a grep. When we       define a grep — It can cause maximum callstack error if       the grep is doing a large recursive loop by neglecting       all tests. The run immediately function also comes with       a performance cost. So we don't want to run immediately       if we run the whole test suite, because running the whole       test suite don't do any immediate recursive loops. Thus,       allowing a JS runtime to breathe.      if (self._grep !== self._defaultGrep) {        Runner.immediately(next);      } else {        next();      }      return;    }
    if (test.isPending()) {      self.emit(pending, test);      self.emit(test end, test);      return next();    }
     execute test and hook(s)    self.emit(test, self.test = test);    self.hookDown(beforeEach, function (err, errSuite) {      if (test.isPending()) {        self.emit(pending, test);        self.emit(test end, test);        return next();      }      if (err) {        return hookErr(err, errSuite, false);      }      self.currentRunnable = self.test;      self.runTest(function (err) {        test = self.test;        if (err) {          var retry = test.currentRetry();          if (err instanceof Pending) {            test.pending = true;            self.emit(pending, test);          } else if (retry < test.retries()) {            var clonedTest = test.clone();            clonedTest.currentRetry(retry + 1);            tests.unshift(clonedTest);
             Early return + hook trigger so that it doesn't             increment the count wrong            return self.hookUp(afterEach, next);          } else {            self.fail(test, err);          }          self.emit(test end, test);
          if (err instanceof Pending) {            return next();          }
          return self.hookUp(afterEach, next);        }
        test.state = passed;        self.emit(pass, test);        self.emit(test end, test);        self.hookUp(afterEach, next);      });    });  }
  this.next = next;  this.hookErr = hookErr;  next();};
 * Run the given `suite` and invoke the callback `fn()` when complete. * * @api private *    *    */Runner.prototype.runSuite = function (suite, fn) {  var i = 0;  var self = this;  var total = this.grepTotal(suite);  var afterAllHookCalled = false;
  debug(run suite %s, suite.fullTitle());
  if (!total || (self.failures && suite._bail)) {    return fn();  }
  this.emit(suite, this.suite = suite);
  function next (errSuite) {    if (errSuite) {       current suite failed on a hook from errSuite      if (errSuite === suite) {         if errSuite is current suite         continue to the next sibling suite        return done();      }       errSuite is among the parents of current suite       stop execution of errSuite and all sub-suites      return done(errSuite);    }
    if (self._abort) {      return done();    }
    var curr = suite.suites[i++];    if (!curr) {      return done();    }
     Avoid grep neglecting large number of tests causing a     huge recursive loop and thus a maximum call stack error.     See comment in `this.runTests()` for more information.    if (self._grep !== self._defaultGrep) {      Runner.immediately(function () {        self.runSuite(curr, next);      });    } else {      self.runSuite(curr, next);    }  }
  function done (errSuite) {    self.suite = suite;    self.nextSuite = next;
    if (afterAllHookCalled) {      fn(errSuite);    } else {       mark that the afterAll block has been called once       and so can be skipped if there is an error in it.      afterAllHookCalled = true;
       remove reference to test      delete self.test;
      self.hook(afterAll, function () {        self.emit(suite end, suite);        fn(errSuite);      });    }  }
  this.nextSuite = next;
  this.hook(beforeAll, function (err) {    if (err) {      return done();    }    self.runTests(suite, next);  });};
 * Handle uncaught exceptions. * *    * @api private */Runner.prototype.uncaught = function (err) {  if (err) {    debug(uncaught exception %s, err !== function () {      return this;    }.call(err) ? err : (err.message || err));  } else {    debug(uncaught undefined exception);    err = undefinedError();  }  err.uncaught = true;
  var runnable = this.currentRunnable;
  if (!runnable) {    runnable = new Runnable(Uncaught error outside test suite);    runnable.parent = this.suite;
    if (this.started) {      this.fail(runnable, err);    } else {       Can't recover from this failure      this.emit(start);      this.fail(runnable, err);      this.emit(end);    }
    return;  }
  runnable.clearTimeout();
   Ignore errors if complete or pending  if (runnable.state || runnable.isPending()) {    return;  }  this.fail(runnable, err);
   recover from test  if (runnable.type === test) {    this.emit(test end, runnable);    this.hookUp(afterEach, this.next);    return;  }
  recover from hooks  if (runnable.type === hook) {    var errSuite = this.suite;     if hook failure is in afterEach block    if (runnable.fullTitle().indexOf(after each) > -1) {      return this.hookErr(err, errSuite, true);    }     if hook failure is in beforeEach block    if (runnable.fullTitle().indexOf(before each) > -1) {      return this.hookErr(err, errSuite, false);    }     if hook failure is in after or before blocks    return this.nextSuite(errSuite);  }
   bail  this.emit(end);};
 * Cleans up the references to all the deferred functions * (before/after/beforeEach/afterEach) and tests of a Suite. * These must be deleted otherwise a memory leak can happen, * as those functions may reference variables from closures, * thus those variables can never be garbage collected as long * as the deferred functions exist. * *    */function cleanSuiteReferences (suite) {  function cleanArrReferences (arr) {    for (var i = 0; i < arr.length; i++) {      delete arr[i].fn;    }  }
  if (isArray(suite._beforeAll)) {    cleanArrReferences(suite._beforeAll);  }
  if (isArray(suite._beforeEach)) {    cleanArrReferences(suite._beforeEach);  }
  if (isArray(suite._afterAll)) {    cleanArrReferences(suite._afterAll);  }
  if (isArray(suite._afterEach)) {    cleanArrReferences(suite._afterEach);  }
  for (var i = 0; i < suite.tests.length; i++) {    delete suite.tests[i].fn;  }}
 * Run the root suite and invoke `fn(failures)` * on completion. * *    *   for chaining * @api public *    *   Runner instance. */Runner.prototype.run = function (fn) {  var self = this;  var rootSuite = this.suite;
   If there is an `only` filter  if (this.hasOnly) {    filterOnly(rootSuite);  }
  fn = fn || function () {};
  function uncaught (err) {    self.uncaught(err);  }
  function start () {    self.started = true;    self.emit(start);    self.runSuite(rootSuite, function () {      debug(finished running);      self.emit(end);    });  }
  debug(start);
   references cleanup to avoid memory leaks  this.on(suite end, cleanSuiteReferences);
   callback  this.on(end, function () {    debug(end);    process.removeListener(uncaughtException, uncaught);    fn(self.failures);  });
   uncaught exception  process.on(uncaughtException, uncaught);
  if (this._delay) {     for reporters, I guess.     might be nice to debounce some dots while we wait.    this.emit(waiting, rootSuite);    rootSuite.once(run, start);  } else {    start();  }
  return this;};
 * Cleanly abort execution. * * @api public *   Runner instance. */Runner.prototype.abort = function () {  debug(aborting);  this._abort = true;
  return this;};
 * Filter suites based on `isOnly` logic. * *    *   * @api private */function filterOnly (suite) {  if (suite._onlyTests.length) {     If the suite contains `only` tests, run those and ignore any nested suites.    suite.tests = suite._onlyTests;    suite.suites = [];  } else {     Otherwise, do not run any of the tests in this suite.    suite.tests = [];    utils.forEach(suite._onlySuites, function (onlySuite) {       If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.       Otherwise, all of the tests on this `only` suite should be run, so don't filter it.      if (hasOnly(onlySuite)) {        filterOnly(onlySuite);      }    });     Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.    suite.suites = filter(suite.suites, function (childSuite) {      return indexOf(suite._onlySuites, childSuite) !== -1 || filterOnly(childSuite);    });  }   Keep the suite only if there is something to run  return suite.tests.length || suite.suites.length;}
 * Determines whether a suite has an `only` test or suite as a descendant. * *    *   * @api private */function hasOnly (suite) {  return suite._onlyTests.length || suite._onlySuites.length || some(suite.suites, hasOnly);}
 * Filter leaks with the given globals flagged as `ok`. * * @api private *    *    *   */function filterLeaks (ok, globals) {  return filter(globals, function (key) {     Firefox and Chrome exposes iframes as index inside the window object    if (.test(key)) {      return false;    }
     in firefox     if runner runs in an iframe, this iframe's window.getInterface method     not init at first it is assigned in some seconds    if (global.navigator && (getInterface).test(key)) {      return false;    }
     an iframe could be approached by window[iframeIndex]     in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak    if (global.navigator && ().test(key)) {      return false;    }
     Opera and IE expose global variables for HTML element IDs (issue #243)    if (mocha-.test(key)) {      return false;    }
    var matched = filter(ok, function (ok) {      if (~ok.indexOf()) {        return key.indexOf(ok.split()[0]) === 0;      }      return key === ok;    });    return !matched.length && (!global.navigator || key !== onerror);  });}
 * Array of globals dependent on the environment. * *   * @api private */function extraGlobals () {  if (typeof process === object && typeof process.version === string) {    var parts = process.version.split(.);    var nodeVersion = utils.reduce(parts, function (a, v) {      return a << 8 | v;    });
     'errno' was renamed to process._errno in v0.9.11.
    if (nodeVersion < 0x00090B) {      return [errno];    }  }
  return [];}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./pending:16,./runnable:33,./utils:38,_process:67,debug:2,events:3}],35:[function(require,module,exports){use strict;
 * Module dependencies. */
var EventEmitter = require(events).EventEmitter;var Hook = require(./hook);var utils = require(./utils);var inherits = utils.inherits;var debug = require(debug)(mocha:suite);var milliseconds = require(./ms);
 * Expose `Suite`. */
exports = module.exports = Suite;
 * Create a new `Suite` with the given `title` and parent `Suite`. When a suite * with the same title is already present, that suite is returned to provide * nicer reporter and more flexible meta-testing. * * @api public *    *    *   */exports.create = function (parent, title) {  var suite = new Suite(title, parent.ctx);  suite.parent = parent;  title = suite.fullTitle();  parent.addSuite(suite);  return suite;};
 * Initialize a new `Suite` with the given `title` and `ctx`. * * @api private *    *    */function Suite (title, parentContext) {  if (!utils.isString(title)) {    throw new Error(Suite `title` should be a ""string"" but "" + typeof title + "" was given instead.);  }  this.title = title;  function Context () {}  Context.prototype = parentContext;  this.ctx = new Context();  this.suites = [];  this.tests = [];  this.pending = false;  this._beforeEach = [];  this._beforeAll = [];  this._afterEach = [];  this._afterAll = [];  this.root = !title;  this._timeout = 2000;  this._enableTimeouts = true;  this._slow = 75;  this._bail = false;  this._retries = -1;  this._onlyTests = [];  this._onlySuites = [];  this.delayed = false;}
 * Inherit from `EventEmitter.prototype`. */inherits(Suite, EventEmitter);
 * Return a clone of this `Suite`. * * @api private *   */Suite.prototype.clone = function () {  var suite = new Suite(this.title);  debug(clone);  suite.ctx = this.ctx;  suite.timeout(this.timeout());  suite.retries(this.retries());  suite.enableTimeouts(this.enableTimeouts());  suite.slow(this.slow());  suite.bail(this.bail());  return suite;};
 * Set timeout `ms` or short-hand such as ""2s"". * * @api private *    *   for chaining */Suite.prototype.timeout = function (ms) {  if (!arguments.length) {    return this._timeout;  }  if (ms.toString() === 0) {    this._enableTimeouts = false;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(timeout %d, ms);  this._timeout = parseInt(ms, 10);  return this;};
 * Set number of times to retry a failed test. * * @api private *    *   for chaining */Suite.prototype.retries = function (n) {  if (!arguments.length) {    return this._retries;  }  debug(retries %d, n);  this._retries = parseInt(n, 10) || 0;  return this;};
  * Set timeout to `enabled`.  *  * @api private  *     *   self or enabled  */Suite.prototype.enableTimeouts = function (enabled) {  if (!arguments.length) {    return this._enableTimeouts;  }  debug(enableTimeouts %s, enabled);  this._enableTimeouts = enabled;  return this;};
 * Set slow `ms` or short-hand such as ""2s"". * * @api private *    *   for chaining */Suite.prototype.slow = function (ms) {  if (!arguments.length) {    return this._slow;  }  if (typeof ms === string) {    ms = milliseconds(ms);  }  debug(slow %d, ms);  this._slow = ms;  return this;};
 * Sets whether to bail after first error. * * @api private *    *   for chaining */Suite.prototype.bail = function (bail) {  if (!arguments.length) {    return this._bail;  }  debug(bail %s, bail);  this._bail = bail;  return this;};
 * Check if this suite or its parent suite is marked as pending. * * @api private */Suite.prototype.isPending = function () {  return this.pending || (this.parent && this.parent.isPending());};
 * Run `fn(test[, done])` before running tests. * * @api private *    *    *   for chaining */Suite.prototype.beforeAll = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""before all"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._beforeAll.push(hook);  this.emit(beforeAll, hook);  return this;};
 * Run `fn(test[, done])` after running tests. * * @api private *    *    *   for chaining */Suite.prototype.afterAll = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""after all"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._afterAll.push(hook);  this.emit(afterAll, hook);  return this;};
 * Run `fn(test[, done])` before each test case. * * @api private *    *    *   for chaining */Suite.prototype.beforeEach = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""before each"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._beforeEach.push(hook);  this.emit(beforeEach, hook);  return this;};
 * Run `fn(test[, done])` after each test case. * * @api private *    *    *   for chaining */Suite.prototype.afterEach = function (title, fn) {  if (this.isPending()) {    return this;  }  if (typeof title === function) {    fn = title;    title = fn.name;  }  title = ""after each"" hook + (title ? :  + title : );
  var hook = new Hook(title, fn);  hook.parent = this;  hook.timeout(this.timeout());  hook.retries(this.retries());  hook.enableTimeouts(this.enableTimeouts());  hook.slow(this.slow());  hook.ctx = this.ctx;  this._afterEach.push(hook);  this.emit(afterEach, hook);  return this;};
 * Add a test `suite`. * * @api private *    *   for chaining */Suite.prototype.addSuite = function (suite) {  suite.parent = this;  suite.timeout(this.timeout());  suite.retries(this.retries());  suite.enableTimeouts(this.enableTimeouts());  suite.slow(this.slow());  suite.bail(this.bail());  this.suites.push(suite);  this.emit(suite, suite);  return this;};
 * Add a `test` to this suite. * * @api private *    *   for chaining */Suite.prototype.addTest = function (test) {  test.parent = this;  test.timeout(this.timeout());  test.retries(this.retries());  test.enableTimeouts(this.enableTimeouts());  test.slow(this.slow());  test.ctx = this.ctx;  this.tests.push(test);  this.emit(test, test);  return this;};
 * Return the full title generated by recursively concatenating the parent's * full title. * * @api public *   */Suite.prototype.fullTitle = function () {  if (this.parent) {    var full = this.parent.fullTitle();    if (full) {      return full +   + this.title;    }  }  return this.title;};
 * Return the total number of tests. * * @api public *   */Suite.prototype.total = function () {  return utils.reduce(this.suites, function (sum, suite) {    return sum + suite.total();  }, 0) + this.tests.length;};
 * Iterates through each suite recursively to find all tests. Applies a * function in the format `fn(test)`. * * @api private *    *   */Suite.prototype.eachTest = function (fn) {  utils.forEach(this.tests, fn);  utils.forEach(this.suites, function (suite) {    suite.eachTest(fn);  });  return this;};
 * This will run the root suite if we happen to be running in delayed mode. */Suite.prototype.run = function run () {  if (this.root) {    this.emit(run);  }};
},{./hook:7,./ms:15,./utils:38,debug:2,events:3}],36:[function(require,module,exports){use strict;
 * Module dependencies. */
var Runnable = require(./runnable);var create = require(lodash.create);var isString = require(./utils).isString;
 * Expose `Test`. */
module.exports = Test;
 * Initialize a new `Test` with the given `title` and callback `fn`. * * @api private *    *    */function Test (title, fn) {  if (!isString(title)) {    throw new Error(Test `title` should be a ""string"" but "" + typeof title + "" was given instead.);  }  Runnable.call(this, title, fn);  this.pending = !fn;  this.type = test;}
 * Inherit from `Runnable.prototype`. */Test.prototype = create(Runnable.prototype, {  constructor: Test});
Test.prototype.clone = function () {  var test = new Test(this.title, this.fn);  test.timeout(this.timeout());  test.slow(this.slow());  test.enableTimeouts(this.enableTimeouts());  test.retries(this.retries());  test.currentRetry(this.currentRetry());  test.globals(this.globals());  test.parent = this.parent;  test.file = this.file;  test.ctx = this.ctx;  return test;};
},{./runnable:33,./utils:38,lodash.create:60}],37:[function(require,module,exports){use strict;
 * Pad a `number` with a ten's place zero. * *    *   */function pad(number) {  var n = number.toString();  return n.length === 1 ? 0 + n : n;}
 * Turn a `date` into an ISO string. * * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString * *    *   */function toISOString(date) {  return date.getUTCFullYear()    + - + pad(date.getUTCMonth() + 1)    + - + pad(date.getUTCDate())    + T + pad(date.getUTCHours())    + : + pad(date.getUTCMinutes())    + : + pad(date.getUTCSeconds())    + . + String((date.getUTCMilliseconds()/1000).toFixed(3)).slice(2, 5)    + Z;}
 * Exports. */
module.exports = toISOString;
},{}],38:[function(require,module,exports){(function (process,Buffer){use strict;

 * Module dependencies. */
var JSON = require(json3);var basename = require(path).basename;var debug = require(debug)(mocha:watch);var exists = require(fs).existsSync || require(path).existsSync;var glob = require(glob);var path = require(path);var join = path.join;var readdirSync = require(fs).readdirSync;var statSync = require(fs).statSync;var watchFile = require(fs).watchFile;var lstatSync = require(fs).lstatSync;var toISOString = require(./to-iso-string);
 * Ignored directories. */
var ignore = [node_modules, .git];
exports.inherits = require(util).inherits;
 * Escape special characters in the given string of html. * * @api private *     *   */exports.escape = function (html) {  return String(html)    .replace(&g, &amp;)    .replace(""g, &quot;)    .replace(<g, &lt;)    .replace(>g, &gt;);};
 * Array#forEach (<=IE8) * * @api private *    *    *    */exports.forEach = function (arr, fn, scope) {  for (var i = 0, l = arr.length; i < l; i++) {    fn.call(scope, arr[i], i);  }};
 * Test if the given obj is type of string. * * @api private *    *   */exports.isString = function (obj) {  return typeof obj === string;};
 * Array#map (<=IE8) * * @api private *    *    *    *   */exports.map = function (arr, fn, scope) {  var result = [];  for (var i = 0, l = arr.length; i < l; i++) {    result.push(fn.call(scope, arr[i], i, arr));  }  return result;};
 * Array#indexOf (<=IE8) * * @api private *    *    to find index of *    *   */var indexOf = exports.indexOf = function (arr, obj, start) {  for (var i = start || 0, l = arr.length; i < l; i++) {    if (arr[i] === obj) {      return i;    }  }  return -1;};
 * Array#reduce (<=IE8) * * @api private *    *    *    Initial value. *   */var reduce = exports.reduce = function (arr, fn, val) {  var rval = val;
  for (var i = 0, l = arr.length; i < l; i++) {    rval = fn(rval, arr[i], i, arr);  }
  return rval;};
 * Array#filter (<=IE8) * * @api private *    *    *   */exports.filter = function (arr, fn) {  var ret = [];
  for (var i = 0, l = arr.length; i < l; i++) {    var val = arr[i];    if (fn(val, i, arr)) {      ret.push(val);    }  }
  return ret;};
 * Array#some (<=IE8) * * @api private *    *    *   */exports.some = function (arr, fn) {  for (var i = 0, l = arr.length; i < l; i++) {    if (fn(arr[i])) {      return true;    }  }  return false;};
 * Object.keys (<=IE8) * * @api private *    *   keys */exports.keys = typeof Object.keys === function ? Object.keys : function (obj) {  var keys = [];  var has = Object.prototype.hasOwnProperty;  for `window` on <=IE8
  for (var key in obj) {    if (has.call(obj, key)) {      keys.push(key);    }  }
  return keys;};
 * Watch the given `files` for changes * and invoke `fn(file)` on modification. * * @api private *    *    */exports.watch = function (files, fn) {  var options = { interval: 100 };  files.forEach(function (file) {    debug(file %s, file);    watchFile(file, options, function (curr, prev) {      if (prev.mtime < curr.mtime) {        fn(file);      }    });  });};
 * Array.isArray (<=IE8) * * @api private *    *   */var isArray = typeof Array.isArray === function ? Array.isArray : function (obj) {  return Object.prototype.toString.call(obj) === [object Array];};
exports.isArray = isArray;
 * Buffer.prototype.toJSON polyfill. * *   */if (typeof Buffer !== undefined && Buffer.prototype) {  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {    return Array.prototype.slice.call(this, 0);  };}
 * Ignored files. * * @api private *    *   */function ignored (path) {  return !~ignore.indexOf(path);}
 * Lookup files in the given `dir`. * * @api private *    *   ] *   ] *   */exports.files = function (dir, ext, ret) {  ret = ret || [];  ext = ext || [js];
  var re = new RegExp(.( + ext.join(|) + )$);
  readdirSync(dir)    .filter(ignored)    .forEach(function (path) {      path = join(dir, path);      if (lstatSync(path).isDirectory()) {        exports.files(path, ext, ret);      } else if (path.match(re)) {        ret.push(path);      }    });
  return ret;};
 * Compute a slug from the given `str`. * * @api private *    *   */exports.slug = function (str) {  return str    .toLowerCase()    .replace( g, -)    .replace(g, );};
 * Strip the function definition from `str`, and re-indent for pre whitespace. * *    *   */exports.clean = function (str) {  str = str    .replace(g, ).replace(FEFF, )     (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content    .replace(function(?:)((?:))=>(?:((?:))((?:))), $1$2$3);
  var spaces = str.match(( ))[1].length;  var tabs = str.match(())[1].length;  var re = new RegExp(^? + (tabs ?  :  ) + { + (tabs || spaces) + }, gm);
  str = str.replace(re, );
  return exports.trim(str);};
 * Trim the given `str`. * * @api private *    *   */exports.trim = function (str) {  return str.replace(g, );};
 * Parse the given `qs`. * * @api private *    *   */exports.parseQuery = function (qs) {  return reduce(qs.replace(?, ).split(&), function (obj, pair) {    var i = pair.indexOf(=);    var key = pair.slice(0, i);    var val = pair.slice(++i);
    obj[key] = decodeURIComponent(val);    return obj;  }, {});};
 * Highlight the given string of `js`. * * @api private *    *   */function highlight (js) {  return js    .replace(<g, &lt;)    .replace(>g, &gt;)    .replace(()gm, <span class=""comment"">//$1</span>)    .replace(('')gm, <span class=""string"">$1</span>)    .replace(()gm, <span class=""number"">$1</span>)    .replace(()gm, <span class=""number"">$1</span>)    .replace(new()gm, <span class=""keyword"">new</span> <span class=""init"">$1</span>)    .replace((functionnewthrowreturnvarifelse)gm, <span class=""keyword"">$1</span>);}
 * Highlight the contents of tag `name`. * * @api private *    */exports.highlightTags = function (name) {  var code = document.getElementById(mocha).getElementsByTagName(name);  for (var i = 0, len = code.length; i < len; ++i) {    code[i].innerHTML = highlight(code[i].innerHTML);  }};
 * If a value could have properties, and has none, this function is called, * which returns a string representation of the empty value. * * Functions w/ no properties return `'[Function]'` * Arrays w/ length === 0 return `'[]'` * Objects w/ no properties return `'{}'` * All else: return result of `value.toString()` * * @api private *    The value to inspect. *    The type of the value *   */function emptyRepresentation (value, typeHint) {  switch (typeHint) {    case function:      return [Function];    case object:      return {};    case array:      return [];    default:      return value.toString();  }}
 * Takes some variable and asks `Object.prototype.toString()` what it thinks it * is. * * @api private *   *    The value to test. *   Computed type *  *  *  *  *  *  *  *  *  *  *  *  */var type = exports.type = function type (value) {  if (value === undefined) {    return undefined;  } else if (value === null) {    return null;  } else if (typeof Buffer !== undefined && Buffer.isBuffer(value)) {    return buffer;  }  return Object.prototype.toString.call(value)    .replace((), $1)    .toLowerCase();};
 * Stringify `value`. Different behavior depending on type of value: * * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively. * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes. * - If `value` is an *empty* object, function, or array, return result of function *   . * - If `value` has properties, call  on it, then return result of *   JSON.stringify(). * * @api private *   *    *   */exports.stringify = function (value) {  var typeHint = type(value);
  if (!~indexOf([object, array, function], typeHint)) {    if (typeHint === buffer) {      var json = value.toJSON();       Based on the toJSON result      return jsonStringify(json.data && json.type ? json.data : json, 2)        .replace(,()g, $1);    }
     IE7/IE8 has a bizarre String constructor; needs to be coerced     into an array and back to obj.    if (typeHint === string && typeof value === object) {      value = reduce(value.split(), function (acc, char, idx) {        acc[idx] = char;        return acc;      }, {});      typeHint = object;    } else {      return jsonStringify(value);    }  }
  for (var prop in value) {    if (Object.prototype.hasOwnProperty.call(value, prop)) {      return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(,()g, $1);    }  }
  return emptyRepresentation(value, typeHint);};
 * like JSON.stringify but more sense. * * @api private *     *    *    *   */function jsonStringify (object, spaces, depth) {  if (typeof spaces === undefined) {     primitive types    return _stringify(object);  }
  depth = depth || 1;  var space = spaces  depth;  var str = isArray(object) ? [ : {;  var end = isArray(object) ? ] : };  var length = typeof object.length === number ? object.length : exports.keys(object).length;   `.repeat()` polyfill  function repeat (s, n) {    return new Array(n).join(s);  }
  function _stringify (val) {    switch (type(val)) {      case null:      case undefined:        val = [ + val + ];        break;      case array:      case object:        val = jsonStringify(val, spaces, depth + 1);        break;      case boolean:      case regexp:      case symbol:      case number:        val = val === 0 && (1 / val) === -Infinity  `-0`          ? -0          : val.toString();        break;      case date:        var sDate;        if (isNaN(val.getTime())) {  Invalid date          sDate = val.toString();        } else {          sDate = val.toISOString ? val.toISOString() : toISOString(val);        }        val = [Date:  + sDate + ];        break;      case buffer:        var json = val.toJSON();         Based on the toJSON result        json = json.data && json.type ? json.data : json;        val = [Buffer:  + jsonStringify(json, 2, depth + 1) + ];        break;      default:        val = (val === [Function] || val === [Circular])          ? val          : JSON.stringify(val);  string    }    return val;  }
  for (var i in object) {    if (!Object.prototype.hasOwnProperty.call(object, i)) {      continue;  not my business    }    --length;    str +=   + repeat( , space) +      (isArray(object) ?  : "" + i + "": ) +  key      _stringify(object[i]) +                     value      (length ? , : );                        comma  }
  return str +     [], {}    (str.length !== 1 ?  + repeat( , --space) + end : end);}
 * Test if a value is a buffer. * * @api private *    The value to test. *   True if `value` is a buffer, otherwise false */exports.isBuffer = function (value) {  return typeof Buffer !== undefined && Buffer.isBuffer(value);};
 * Return a new Thing that has the keys in sorted order. Recursive. * * If the Thing... * - has already been seen, return string `'[Circular]'` * - is `undefined`, return string `'[undefined]'` * - is `null`, return value `null` * - is some other primitive, return the value * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again. * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()` * * @api private *  @link exports.stringify} *    Thing to inspect.  May or may not have properties. *   ] Stack of seen values *    Type hint *   */exports.canonicalize = function canonicalize (value, stack, typeHint) {  var canonicalizedObj;    var prop;    typeHint = typeHint || type(value);  function withStack (value, fn) {    stack.push(value);    fn();    stack.pop();  }
  stack = stack || [];
  if (indexOf(stack, value) !== -1) {    return [Circular];  }
  switch (typeHint) {    case undefined:    case buffer:    case null:      canonicalizedObj = value;      break;    case array:      withStack(value, function () {        canonicalizedObj = exports.map(value, function (item) {          return exports.canonicalize(item, stack);        });      });      break;    case function:            for (prop in value) {        canonicalizedObj = {};        break;      }            if (!canonicalizedObj) {        canonicalizedObj = emptyRepresentation(value, typeHint);        break;      }        case object:      canonicalizedObj = canonicalizedObj || {};      withStack(value, function () {        exports.forEach(exports.keys(value).sort(), function (key) {          canonicalizedObj[key] = exports.canonicalize(value[key], stack);        });      });      break;    case date:    case number:    case regexp:    case boolean:    case symbol:      canonicalizedObj = value;      break;    default:      canonicalizedObj = value + ;  }
  return canonicalizedObj;};
 * Lookup file names at the given `path`. * * @api public *    Base path to start searching from. *    File extensions to look for. *    Whether or not to recurse into subdirectories. *   An array of paths. */exports.lookupFiles = function lookupFiles (path, extensions, recursive) {  var files = [];  var re = new RegExp(.( + extensions.join(|) + )$);
  if (!exists(path)) {    if (exists(path + .js)) {      path += .js;    } else {      files = glob.sync(path);      if (!files.length) {        throw new Error(cannot resolve path (or pattern) ' + path + ');      }      return files;    }  }
  try {    var stat = statSync(path);    if (stat.isFile()) {      return path;    }  } catch (err) {     ignore error    return;  }
  readdirSync(path).forEach(function (file) {    file = join(path, file);    try {      var stat = statSync(file);      if (stat.isDirectory()) {        if (recursive) {          files = files.concat(lookupFiles(file, extensions, recursive));        }        return;      }    } catch (err) {       ignore error      return;    }    if (!stat.isFile() || !re.test(file) || basename(file)[0] === .) {      return;    }    files.push(file);  });
  return files;};
 * Generate an undefined error with a message warning the user. * *   */
exports.undefinedError = function () {  return new Error(Caught undefined error, did you throw without specifying what?);};
 * Generate an undefined error if `err` is not defined. * *    *   */
exports.getError = function (err) {  return err || exports.undefinedError();};
 *  * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`) *  * When invoking this function you get a filter function that get the Error.stack as an input, * and return a prettify output. * (i.e: strip Mocha and internal node functions from stack trace). *   */exports.stackTraceFilter = function () {   TODO: Replace with `process.browser`  var is = typeof document === undefined ? { node: true } : { browser: true };  var slash = path.sep;  var cwd;  if (is.node) {    cwd = process.cwd() + slash;  } else {    cwd = (typeof location === undefined ? window.location : location).href.replace(, /);    slash = /;  }
  function isMochaInternal (line) {    return (~line.indexOf(node_modules + slash + mocha + slash)) ||      (~line.indexOf(node_modules + slash + mocha.js)) ||      (~line.indexOf(bower_components + slash + mocha.js)) ||      (~line.indexOf(slash + mocha.js));  }
  function isNodeInternal (line) {    return (~line.indexOf((timers.js:)) ||      (~line.indexOf((events.js:)) ||      (~line.indexOf((node.js:)) ||      (~line.indexOf((module.js:)) ||      (~line.indexOf(GeneratorFunctionPrototype.next (native))) ||      false;  }
  return function (stack) {    stack = stack.split();
    stack = reduce(stack, function (list, line) {      if (isMochaInternal(line)) {        return list;      }
      if (is.node && isNodeInternal(line)) {        return list;      }
       Clean up cwd(absolute)      if (::.test(line)) {        line = line.replace(cwd, );      }
      list.push(line);      return list;    }, []);
    return stack.join();  };};
 * Crude, but effective. * @api *    *   Whether or not `value` is a Promise */exports.isPromise = function isPromise (value) {  return typeof value === object && typeof value.then === function;};
 * It's a noop. * @api */exports.noop = function () {};
}).call(this,require(_process),require(buffer).Buffer)},{./to-iso-string:37,_process:67,buffer:44,debug:2,fs:42,glob:42,json3:54,path:42,util:84}],39:[function(require,module,exports){use strict
exports.byteLength = byteLengthexports.toByteArray = toByteArrayexports.fromByteArray = fromByteArray
var lookup = []var revLookup = []var Arr = typeof Uint8Array !== undefined ? Uint8Array : Array
var code = ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/for (var i = 0, len = code.length; i < len; ++i) {  lookup[i] = code[i]  revLookup[code.charCodeAt(i)] = i}
revLookup[-.charCodeAt(0)] = 62revLookup[_.charCodeAt(0)] = 63
function placeHoldersCount (b64) {  var len = b64.length  if (len % 4 > 0) {    throw new Error(Invalid string. Length must be a multiple of 4)  }
   the number of equal signs (place holders)   if there are two placeholders, than the two characters before it   represent one byte   if there is only one, then the three characters before it represent 2 bytes   this is just a cheap hack to not do indexOf twice  return b64[len - 2] === = ? 2 : b64[len - 1] === = ? 1 : 0}
function byteLength (b64) {   base64 is 4/3 + up to two characters of the original data  return b64.length  3 / 4 - placeHoldersCount(b64)}
function toByteArray (b64) {  var i, j, l, tmp, placeHolders, arr  var len = b64.length  placeHolders = placeHoldersCount(b64)
  arr = new Arr(len  3 / 4 - placeHolders)
   if there are placeholders, only get up to the last complete 4 chars  l = placeHolders > 0 ? len - 4 : len
  var L = 0
  for (i = 0, j = 0; i < l; i += 4, j += 3) {    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]    arr[L++] = (tmp >> 16) & 0xFF    arr[L++] = (tmp >> 8) & 0xFF    arr[L++] = tmp & 0xFF  }
  if (placeHolders === 2) {    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)    arr[L++] = tmp & 0xFF  } else if (placeHolders === 1) {    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)    arr[L++] = (tmp >> 8) & 0xFF    arr[L++] = tmp & 0xFF  }
  return arr}
function tripletToBase64 (num) {  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]}
function encodeChunk (uint8, start, end) {  var tmp  var output = []  for (var i = start; i < end; i += 3) {    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])    output.push(tripletToBase64(tmp))  }  return output.join()}
function fromByteArray (uint8) {  var tmp  var len = uint8.length  var extraBytes = len % 3  if we have 1 byte left, pad 2 bytes  var output =   var parts = []  var maxChunkLength = 16383  must be multiple of 3
   go through the array every three bytes, we'll deal with trailing stuff later  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))  }
   pad the end with zeros, but make sure to not forget the extra bytes  if (extraBytes === 1) {    tmp = uint8[len - 1]    output += lookup[tmp >> 2]    output += lookup[(tmp << 4) & 0x3F]    output += ==  } else if (extraBytes === 2) {    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])    output += lookup[tmp >> 10]    output += lookup[(tmp >> 4) & 0x3F]    output += lookup[(tmp << 2) & 0x3F]    output += =  }
  parts.push(output)
  return parts.join()}
},{}],40:[function(require,module,exports){
},{}],41:[function(require,module,exports){(function (process){var WritableStream = require(stream).Writablevar inherits = require(util).inherits
module.exports = BrowserStdout

inherits(BrowserStdout, WritableStream)
function BrowserStdout(opts) {  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)
  opts = opts || {}  WritableStream.call(this, opts)  this.label = (opts.label !== undefined) ? opts.label : stdout}
BrowserStdout.prototype._write = function(chunks, encoding, cb) {  var output = chunks.toString ? chunks.toString() : chunks  if (this.label === false) {    console.log(output)  } else {    console.log(this.label+:, output)  }  process.nextTick(cb)}
}).call(this,require(_process))},{_process:67,stream:79,util:84}],42:[function(require,module,exports){arguments[4][40][0].apply(exports,arguments)},{dup:40}],43:[function(require,module,exports){(function (global){use strict;
var buffer = require(buffer);var Buffer = buffer.Buffer;var SlowBuffer = buffer.SlowBuffer;var MAX_LEN = buffer.kMaxLength || 2147483647;exports.alloc = function alloc(size, fill, encoding) {  if (typeof Buffer.alloc === function) {    return Buffer.alloc(size, fill, encoding);  }  if (typeof encoding === number) {    throw new TypeError(encoding must not be number);  }  if (typeof size !== number) {    throw new TypeError(size must be a number);  }  if (size > MAX_LEN) {    throw new RangeError(size is too large);  }  var enc = encoding;  var _fill = fill;  if (_fill === undefined) {    enc = undefined;    _fill = 0;  }  var buf = new Buffer(size);  if (typeof _fill === string) {    var fillBuf = new Buffer(_fill, enc);    var flen = fillBuf.length;    var i = -1;    while (++i < size) {      buf[i] = fillBuf[i % flen];    }  } else {    buf.fill(_fill);  }  return buf;}exports.allocUnsafe = function allocUnsafe(size) {  if (typeof Buffer.allocUnsafe === function) {    return Buffer.allocUnsafe(size);  }  if (typeof size !== number) {    throw new TypeError(size must be a number);  }  if (size > MAX_LEN) {    throw new RangeError(size is too large);  }  return new Buffer(size);}exports.from = function from(value, encodingOrOffset, length) {  if (typeof Buffer.from === function && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {    return Buffer.from(value, encodingOrOffset, length);  }  if (typeof value === number) {    throw new TypeError(""value"" argument must not be a number);  }  if (typeof value === string) {    return new Buffer(value, encodingOrOffset);  }  if (typeof ArrayBuffer !== undefined && value instanceof ArrayBuffer) {    var offset = encodingOrOffset;    if (arguments.length === 1) {      return new Buffer(value);    }    if (typeof offset === undefined) {      offset = 0;    }    var len = length;    if (typeof len === undefined) {      len = value.byteLength - offset;    }    if (offset >= value.byteLength) {      throw new RangeError(offset is out of bounds);    }    if (len > value.byteLength - offset) {      throw new RangeError(length is out of bounds);    }    return new Buffer(value.slice(offset, offset + len));  }  if (Buffer.isBuffer(value)) {    var out = new Buffer(value.length);    value.copy(out, 0, 0, value.length);    return out;  }  if (value) {    if (Array.isArray(value) || (typeof ArrayBuffer !== undefined && value.buffer instanceof ArrayBuffer) || length in value) {      return new Buffer(value);    }    if (value.type === Buffer && Array.isArray(value.data)) {      return new Buffer(value.data);    }  }
  throw new TypeError(First argument must be a string, Buffer,  + ArrayBuffer, Array, or array-like object.);}exports.allocUnsafeSlow = function allocUnsafeSlow(size) {  if (typeof Buffer.allocUnsafeSlow === function) {    return Buffer.allocUnsafeSlow(size);  }  if (typeof size !== number) {    throw new TypeError(size must be a number);  }  if (size >= MAX_LEN) {    throw new RangeError(size is too large);  }  return new SlowBuffer(size);}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{buffer:44}],44:[function(require,module,exports){(function (global){ * The buffer module from node.js, for the browser. * * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license  MIT */
use strict
var base64 = require(base64-js)var ieee754 = require(ieee754)var isArray = require(isarray)
exports.Buffer = Bufferexports.SlowBuffer = SlowBufferexports.INSPECT_MAX_BYTES = 50
 * If `Buffer.TYPED_ARRAY_SUPPORT`: *   === true    Use Uint8Array implementation (fastest) *   === false   Use Object implementation (most compatible, even IE6) * * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+, * Opera 11.6+, iOS 4.2+. * * Due to various browser bugs, sometimes the Object implementation will be used even * when the browser supports typed arrays. * * Note: * *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances, *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438. * *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function. * *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of *     incorrect length in some situations. * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they * get the Object implementation, which is slower but behaves correctly. */Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined  ? global.TYPED_ARRAY_SUPPORT  : typedArraySupport()
 * Export kMaxLength after typed array support is determined. */exports.kMaxLength = kMaxLength()
function typedArraySupport () {  try {    var arr = new Uint8Array(1)    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}    return arr.foo() === 42 &&  typed array instances can be augmented        typeof arr.subarray === function &&  chrome 9-10 lack `subarray`        arr.subarray(1, 1).byteLength === 0  ie10 has broken `subarray`  } catch (e) {    return false  }}
function kMaxLength () {  return Buffer.TYPED_ARRAY_SUPPORT    ? 0x7fffffff    : 0x3fffffff}
function createBuffer (that, length) {  if (kMaxLength() < length) {    throw new RangeError(Invalid typed array length)  }  if (Buffer.TYPED_ARRAY_SUPPORT) {     Return an augmented `Uint8Array` instance, for best performance    that = new Uint8Array(length)    that.__proto__ = Buffer.prototype  } else {     Fallback: Return an object instance of the Buffer class    if (that === null) {      that = new Buffer(length)    }    that.length = length  }
  return that}
 * The Buffer constructor returns instances of `Uint8Array` that have their * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of * `Uint8Array`, so the returned instances will have all the node `Buffer` methods * and the `Uint8Array` methods. Square bracket notation works as expected -- it * returns a single octet. * * The `Uint8Array` prototype remains unmodified. */
function Buffer (arg, encodingOrOffset, length) {  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {    return new Buffer(arg, encodingOrOffset, length)  }
   Common case.  if (typeof arg === number) {    if (typeof encodingOrOffset === string) {      throw new Error(        If encoding is specified then the first argument must be a string      )    }    return allocUnsafe(this, arg)  }  return from(this, arg, encodingOrOffset, length)}
Buffer.poolSize = 8192  not used by this implementation
 TODO: Legacy, not needed anymore. Remove in next major version.Buffer._augment = function (arr) {  arr.__proto__ = Buffer.prototype  return arr}
function from (that, value, encodingOrOffset, length) {  if (typeof value === number) {    throw new TypeError(""value"" argument must not be a number)  }
  if (typeof ArrayBuffer !== undefined && value instanceof ArrayBuffer) {    return fromArrayBuffer(that, value, encodingOrOffset, length)  }
  if (typeof value === string) {    return fromString(that, value, encodingOrOffset)  }
  return fromObject(that, value)}
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError * if value is a number. * Buffer.from(str[, encoding]) * Buffer.from(array) * Buffer.from(buffer) * Buffer.from(arrayBuffer[, byteOffset[, length]]) **/Buffer.from = function (value, encodingOrOffset, length) {  return from(null, value, encodingOrOffset, length)}
if (Buffer.TYPED_ARRAY_SUPPORT) {  Buffer.prototype.__proto__ = Uint8Array.prototype  Buffer.__proto__ = Uint8Array  if (typeof Symbol !== undefined && Symbol.species &&      Buffer[Symbol.species] === Buffer) {     Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97    Object.defineProperty(Buffer, Symbol.species, {      value: null,      configurable: true    })  }}
function assertSize (size) {  if (typeof size !== number) {    throw new TypeError(""size"" argument must be a number)  } else if (size < 0) {    throw new RangeError(""size"" argument must not be negative)  }}
function alloc (that, size, fill, encoding) {  assertSize(size)  if (size <= 0) {    return createBuffer(that, size)  }  if (fill !== undefined) {     Only pay attention to encoding if it's a string. This     prevents accidentally sending in a number that would     be interpretted as a start offset.    return typeof encoding === string      ? createBuffer(that, size).fill(fill, encoding)      : createBuffer(that, size).fill(fill)  }  return createBuffer(that, size)}
 * Creates a new filled Buffer instance. * alloc(size[, fill[, encoding]]) **/Buffer.alloc = function (size, fill, encoding) {  return alloc(null, size, fill, encoding)}
function allocUnsafe (that, size) {  assertSize(size)  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)  if (!Buffer.TYPED_ARRAY_SUPPORT) {    for (var i = 0; i < size; ++i) {      that[i] = 0    }  }  return that}
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance. * */Buffer.allocUnsafe = function (size) {  return allocUnsafe(null, size)} * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance. */Buffer.allocUnsafeSlow = function (size) {  return allocUnsafe(null, size)}
function fromString (that, string, encoding) {  if (typeof encoding !== string || encoding === ) {    encoding = utf8  }
  if (!Buffer.isEncoding(encoding)) {    throw new TypeError(""encoding"" must be a valid string encoding)  }
  var length = byteLength(string, encoding) | 0  that = createBuffer(that, length)
  var actual = that.write(string, encoding)
  if (actual !== length) {     Writing a hex string, for example, that contains invalid characters will     cause everything after the first invalid character to be ignored. (e.g.     'abxxcd' will be treated as 'ab')    that = that.slice(0, actual)  }
  return that}
function fromArrayLike (that, array) {  var length = array.length < 0 ? 0 : checked(array.length) | 0  that = createBuffer(that, length)  for (var i = 0; i < length; i += 1) {    that[i] = array[i] & 255  }  return that}
function fromArrayBuffer (that, array, byteOffset, length) {  array.byteLength  this throws if `array` is not a valid ArrayBuffer
  if (byteOffset < 0 || array.byteLength < byteOffset) {    throw new RangeError(offset is out of bounds)  }
  if (array.byteLength < byteOffset + (length || 0)) {    throw new RangeError(length is out of bounds)  }
  if (byteOffset === undefined && length === undefined) {    array = new Uint8Array(array)  } else if (length === undefined) {    array = new Uint8Array(array, byteOffset)  } else {    array = new Uint8Array(array, byteOffset, length)  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {     Return an augmented `Uint8Array` instance, for best performance    that = array    that.__proto__ = Buffer.prototype  } else {     Fallback: Return an object instance of the Buffer class    that = fromArrayLike(that, array)  }  return that}
function fromObject (that, obj) {  if (Buffer.isBuffer(obj)) {    var len = checked(obj.length) | 0    that = createBuffer(that, len)
    if (that.length === 0) {      return that    }
    obj.copy(that, 0, 0, len)    return that  }
  if (obj) {    if ((typeof ArrayBuffer !== undefined &&        obj.buffer instanceof ArrayBuffer) || length in obj) {      if (typeof obj.length !== number || isnan(obj.length)) {        return createBuffer(that, 0)      }      return fromArrayLike(that, obj)    }
    if (obj.type === Buffer && isArray(obj.data)) {      return fromArrayLike(that, obj.data)    }  }
  throw new TypeError(First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.)}
function checked (length) {   Note: cannot use `length < kMaxLength()` here because that fails when   length is NaN (which is otherwise coerced to zero.)  if (length >= kMaxLength()) {    throw new RangeError(Attempt to allocate Buffer larger than maximum  +                         size: 0x + kMaxLength().toString(16) +  bytes)  }  return length | 0}
function SlowBuffer (length) {  if (+length != length) {  eslint-disable-line eqeqeq    length = 0  }  return Buffer.alloc(+length)}
Buffer.isBuffer = function isBuffer (b) {  return !!(b != null && b._isBuffer)}
Buffer.compare = function compare (a, b) {  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {    throw new TypeError(Arguments must be Buffers)  }
  if (a === b) return 0
  var x = a.length  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {    if (a[i] !== b[i]) {      x = a[i]      y = b[i]      break    }  }
  if (x < y) return -1  if (y < x) return 1  return 0}
Buffer.isEncoding = function isEncoding (encoding) {  switch (String(encoding).toLowerCase()) {    case hex:    case utf8:    case utf-8:    case ascii:    case latin1:    case binary:    case base64:    case ucs2:    case ucs-2:    case utf16le:    case utf-16le:      return true    default:      return false  }}
Buffer.concat = function concat (list, length) {  if (!isArray(list)) {    throw new TypeError(""list"" argument must be an Array of Buffers)  }
  if (list.length === 0) {    return Buffer.alloc(0)  }
  var i  if (length === undefined) {    length = 0    for (i = 0; i < list.length; ++i) {      length += list[i].length    }  }
  var buffer = Buffer.allocUnsafe(length)  var pos = 0  for (i = 0; i < list.length; ++i) {    var buf = list[i]    if (!Buffer.isBuffer(buf)) {      throw new TypeError(""list"" argument must be an Array of Buffers)    }    buf.copy(buffer, pos)    pos += buf.length  }  return buffer}
function byteLength (string, encoding) {  if (Buffer.isBuffer(string)) {    return string.length  }  if (typeof ArrayBuffer !== undefined && typeof ArrayBuffer.isView === function &&      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {    return string.byteLength  }  if (typeof string !== string) {    string =  + string  }
  var len = string.length  if (len === 0) return 0
   Use a for loop to avoid recursion  var loweredCase = false  for (;;) {    switch (encoding) {      case ascii:      case latin1:      case binary:        return len      case utf8:      case utf-8:      case undefined:        return utf8ToBytes(string).length      case ucs2:      case ucs-2:      case utf16le:      case utf-16le:        return len  2      case hex:        return len >>> 1      case base64:        return base64ToBytes(string).length      default:        if (loweredCase) return utf8ToBytes(string).length  assume utf8        encoding = ( + encoding).toLowerCase()        loweredCase = true    }  }}Buffer.byteLength = byteLength
function slowToString (encoding, start, end) {  var loweredCase = false
   No need to verify that ""this.length <= MAX_UINT32"" since it's a read-only   property of a typed array.
   This behaves neither like String nor Uint8Array in that we set start/end   to their upper/lower bounds if the value passed is out of range.   undefined is handled specially as per ECMA-262 6th Edition,   Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.  if (start === undefined || start < 0) {    start = 0  }   Return early if start > this.length. Done here to prevent potential uint32   coercion fail below.  if (start > this.length) {    return   }
  if (end === undefined || end > this.length) {    end = this.length  }
  if (end <= 0) {    return   }
   Force coersion to uint32. This will also coerce falsey/NaN values to 0.  end >>>= 0  start >>>= 0
  if (end <= start) {    return   }
  if (!encoding) encoding = utf8
  while (true) {    switch (encoding) {      case hex:        return hexSlice(this, start, end)
      case utf8:      case utf-8:        return utf8Slice(this, start, end)
      case ascii:        return asciiSlice(this, start, end)
      case latin1:      case binary:        return latin1Slice(this, start, end)
      case base64:        return base64Slice(this, start, end)
      case ucs2:      case ucs-2:      case utf16le:      case utf-16le:        return utf16leSlice(this, start, end)
      default:        if (loweredCase) throw new TypeError(Unknown encoding:  + encoding)        encoding = (encoding + ).toLowerCase()        loweredCase = true    }  }}
 The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect Buffer instances.Buffer.prototype._isBuffer = true
function swap (b, n, m) {  var i = b[n]  b[n] = b[m]  b[m] = i}
Buffer.prototype.swap16 = function swap16 () {  var len = this.length  if (len % 2 !== 0) {    throw new RangeError(Buffer size must be a multiple of 16-bits)  }  for (var i = 0; i < len; i += 2) {    swap(this, i, i + 1)  }  return this}
Buffer.prototype.swap32 = function swap32 () {  var len = this.length  if (len % 4 !== 0) {    throw new RangeError(Buffer size must be a multiple of 32-bits)  }  for (var i = 0; i < len; i += 4) {    swap(this, i, i + 3)    swap(this, i + 1, i + 2)  }  return this}
Buffer.prototype.swap64 = function swap64 () {  var len = this.length  if (len % 8 !== 0) {    throw new RangeError(Buffer size must be a multiple of 64-bits)  }  for (var i = 0; i < len; i += 8) {    swap(this, i, i + 7)    swap(this, i + 1, i + 6)    swap(this, i + 2, i + 5)    swap(this, i + 3, i + 4)  }  return this}
Buffer.prototype.toString = function toString () {  var length = this.length | 0  if (length === 0) return   if (arguments.length === 0) return utf8Slice(this, 0, length)  return slowToString.apply(this, arguments)}
Buffer.prototype.equals = function equals (b) {  if (!Buffer.isBuffer(b)) throw new TypeError(Argument must be a Buffer)  if (this === b) return true  return Buffer.compare(this, b) === 0}
Buffer.prototype.inspect = function inspect () {  var str =   var max = exports.INSPECT_MAX_BYTES  if (this.length > 0) {    str = this.toString(hex, 0, max).match(g).join( )    if (this.length > max) str +=  ...   }  return <Buffer  + str + >}
Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {  if (!Buffer.isBuffer(target)) {    throw new TypeError(Argument must be a Buffer)  }
  if (start === undefined) {    start = 0  }  if (end === undefined) {    end = target ? target.length : 0  }  if (thisStart === undefined) {    thisStart = 0  }  if (thisEnd === undefined) {    thisEnd = this.length  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {    throw new RangeError(out of range index)  }
  if (thisStart >= thisEnd && start >= end) {    return 0  }  if (thisStart >= thisEnd) {    return -1  }  if (start >= end) {    return 1  }
  start >>>= 0  end >>>= 0  thisStart >>>= 0  thisEnd >>>= 0
  if (this === target) return 0
  var x = thisEnd - thisStart  var y = end - start  var len = Math.min(x, y)
  var thisCopy = this.slice(thisStart, thisEnd)  var targetCopy = target.slice(start, end)
  for (var i = 0; i < len; ++i) {    if (thisCopy[i] !== targetCopy[i]) {      x = thisCopy[i]      y = targetCopy[i]      break    }  }
  if (x < y) return -1  if (y < x) return 1  return 0}
 Finds either the first index of `val` in `buffer` at offset >= `byteOffset`, OR the last index of `val` in `buffer` at offset <= `byteOffset`. Arguments: - buffer - a Buffer to search - val - a string, Buffer, or number - byteOffset - an index into `buffer`; will be clamped to an int32 - encoding - an optional encoding, relevant is val is a string - dir - true for indexOf, false for lastIndexOffunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {   Empty buffer means no match  if (buffer.length === 0) return -1
   Normalize byteOffset  if (typeof byteOffset === string) {    encoding = byteOffset    byteOffset = 0  } else if (byteOffset > 0x7fffffff) {    byteOffset = 0x7fffffff  } else if (byteOffset < -0x80000000) {    byteOffset = -0x80000000  }  byteOffset = +byteOffset   Coerce to Number.  if (isNaN(byteOffset)) {     byteOffset: it it's undefined, null, NaN, ""foo"", etc, search whole buffer    byteOffset = dir ? 0 : (buffer.length - 1)  }
   Normalize byteOffset: negative offsets start from the end of the buffer  if (byteOffset < 0) byteOffset = buffer.length + byteOffset  if (byteOffset >= buffer.length) {    if (dir) return -1    else byteOffset = buffer.length - 1  } else if (byteOffset < 0) {    if (dir) byteOffset = 0    else return -1  }
   Normalize val  if (typeof val === string) {    val = Buffer.from(val, encoding)  }
   Finally, search either indexOf (if dir is true) or lastIndexOf  if (Buffer.isBuffer(val)) {     Special case: looking for empty string/buffer always fails    if (val.length === 0) {      return -1    }    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)  } else if (typeof val === number) {    val = val & 0xFF  Search for a byte value [0-255]    if (Buffer.TYPED_ARRAY_SUPPORT &&        typeof Uint8Array.prototype.indexOf === function) {      if (dir) {        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)      } else {        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)      }    }    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)  }
  throw new TypeError(val must be string, number or Buffer)}
function arrayIndexOf (arr, val, byteOffset, encoding, dir) {  var indexSize = 1  var arrLength = arr.length  var valLength = val.length
  if (encoding !== undefined) {    encoding = String(encoding).toLowerCase()    if (encoding === ucs2 || encoding === ucs-2 ||        encoding === utf16le || encoding === utf-16le) {      if (arr.length < 2 || val.length < 2) {        return -1      }      indexSize = 2      arrLength /= 2      valLength /= 2      byteOffset /= 2    }  }
  function read (buf, i) {    if (indexSize === 1) {      return buf[i]    } else {      return buf.readUInt16BE(i  indexSize)    }  }
  var i  if (dir) {    var foundIndex = -1    for (i = byteOffset; i < arrLength; i++) {      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {        if (foundIndex === -1) foundIndex = i        if (i - foundIndex + 1 === valLength) return foundIndex  indexSize      } else {        if (foundIndex !== -1) i -= i - foundIndex        foundIndex = -1      }    }  } else {    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength    for (i = byteOffset; i >= 0; i--) {      var found = true      for (var j = 0; j < valLength; j++) {        if (read(arr, i + j) !== read(val, j)) {          found = false          break        }      }      if (found) return i    }  }
  return -1}
Buffer.prototype.includes = function includes (val, byteOffset, encoding) {  return this.indexOf(val, byteOffset, encoding) !== -1}
Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)}
Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)}
function hexWrite (buf, string, offset, length) {  offset = Number(offset) || 0  var remaining = buf.length - offset  if (!length) {    length = remaining  } else {    length = Number(length)    if (length > remaining) {      length = remaining    }  }
   must be an even number of digits  var strLen = string.length  if (strLen % 2 !== 0) throw new TypeError(Invalid hex string)
  if (length > strLen / 2) {    length = strLen / 2  }  for (var i = 0; i < length; ++i) {    var parsed = parseInt(string.substr(i  2, 2), 16)    if (isNaN(parsed)) return i    buf[offset + i] = parsed  }  return i}
function utf8Write (buf, string, offset, length) {  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)}
function asciiWrite (buf, string, offset, length) {  return blitBuffer(asciiToBytes(string), buf, offset, length)}
function latin1Write (buf, string, offset, length) {  return asciiWrite(buf, string, offset, length)}
function base64Write (buf, string, offset, length) {  return blitBuffer(base64ToBytes(string), buf, offset, length)}
function ucs2Write (buf, string, offset, length) {  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)}
Buffer.prototype.write = function write (string, offset, length, encoding) {   Buffer#write(string)  if (offset === undefined) {    encoding = utf8    length = this.length    offset = 0   Buffer#write(string, encoding)  } else if (length === undefined && typeof offset === string) {    encoding = offset    length = this.length    offset = 0   Buffer#write(string, offset[, length][, encoding])  } else if (isFinite(offset)) {    offset = offset | 0    if (isFinite(length)) {      length = length | 0      if (encoding === undefined) encoding = utf8    } else {      encoding = length      length = undefined    }   legacy write(string, encoding, offset, length) - remove in v0.13  } else {    throw new Error(      Buffer.write(string, encoding, offset[, length]) is no longer supported    )  }
  var remaining = this.length - offset  if (length === undefined || length > remaining) length = remaining
  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {    throw new RangeError(Attempt to write outside buffer bounds)  }
  if (!encoding) encoding = utf8
  var loweredCase = false  for (;;) {    switch (encoding) {      case hex:        return hexWrite(this, string, offset, length)
      case utf8:      case utf-8:        return utf8Write(this, string, offset, length)
      case ascii:        return asciiWrite(this, string, offset, length)
      case latin1:      case binary:        return latin1Write(this, string, offset, length)
      case base64:         Warning: maxLength not taken into account in base64Write        return base64Write(this, string, offset, length)
      case ucs2:      case ucs-2:      case utf16le:      case utf-16le:        return ucs2Write(this, string, offset, length)
      default:        if (loweredCase) throw new TypeError(Unknown encoding:  + encoding)        encoding = ( + encoding).toLowerCase()        loweredCase = true    }  }}
Buffer.prototype.toJSON = function toJSON () {  return {    type: Buffer,    data: Array.prototype.slice.call(this._arr || this, 0)  }}
function base64Slice (buf, start, end) {  if (start === 0 && end === buf.length) {    return base64.fromByteArray(buf)  } else {    return base64.fromByteArray(buf.slice(start, end))  }}
function utf8Slice (buf, start, end) {  end = Math.min(buf.length, end)  var res = []
  var i = start  while (i < end) {    var firstByte = buf[i]    var codePoint = null    var bytesPerSequence = (firstByte > 0xEF) ? 4      : (firstByte > 0xDF) ? 3      : (firstByte > 0xBF) ? 2      : 1
    if (i + bytesPerSequence <= end) {      var secondByte, thirdByte, fourthByte, tempCodePoint
      switch (bytesPerSequence) {        case 1:          if (firstByte < 0x80) {            codePoint = firstByte          }          break        case 2:          secondByte = buf[i + 1]          if ((secondByte & 0xC0) === 0x80) {            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)            if (tempCodePoint > 0x7F) {              codePoint = tempCodePoint            }          }          break        case 3:          secondByte = buf[i + 1]          thirdByte = buf[i + 2]          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {              codePoint = tempCodePoint            }          }          break        case 4:          secondByte = buf[i + 1]          thirdByte = buf[i + 2]          fourthByte = buf[i + 3]          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {              codePoint = tempCodePoint            }          }      }    }
    if (codePoint === null) {       we did not generate a valid codePoint so insert a       replacement char (U+FFFD) and advance only 1 byte      codePoint = 0xFFFD      bytesPerSequence = 1    } else if (codePoint > 0xFFFF) {       encode to utf16 (surrogate pair dance)      codePoint -= 0x10000      res.push(codePoint >>> 10 & 0x3FF | 0xD800)      codePoint = 0xDC00 | codePoint & 0x3FF    }
    res.push(codePoint)    i += bytesPerSequence  }
  return decodeCodePointsArray(res)}
 Based on http://stackoverflow.com/a/22747272/680742, the browser with the lowest limit is Chrome, with 0x10000 args. We go 1 magnitude less, for safetyvar MAX_ARGUMENTS_LENGTH = 0x1000
function decodeCodePointsArray (codePoints) {  var len = codePoints.length  if (len <= MAX_ARGUMENTS_LENGTH) {    return String.fromCharCode.apply(String, codePoints)  avoid extra slice()  }
   Decode in chunks to avoid ""call stack size exceeded"".  var res =   var i = 0  while (i < len) {    res += String.fromCharCode.apply(      String,      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)    )  }  return res}
function asciiSlice (buf, start, end) {  var ret =   end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {    ret += String.fromCharCode(buf[i] & 0x7F)  }  return ret}
function latin1Slice (buf, start, end) {  var ret =   end = Math.min(buf.length, end)
  for (var i = start; i < end; ++i) {    ret += String.fromCharCode(buf[i])  }  return ret}
function hexSlice (buf, start, end) {  var len = buf.length
  if (!start || start < 0) start = 0  if (!end || end < 0 || end > len) end = len
  var out =   for (var i = start; i < end; ++i) {    out += toHex(buf[i])  }  return out}
function utf16leSlice (buf, start, end) {  var bytes = buf.slice(start, end)  var res =   for (var i = 0; i < bytes.length; i += 2) {    res += String.fromCharCode(bytes[i] + bytes[i + 1]  256)  }  return res}
Buffer.prototype.slice = function slice (start, end) {  var len = this.length  start = ~~start  end = end === undefined ? len : ~~end
  if (start < 0) {    start += len    if (start < 0) start = 0  } else if (start > len) {    start = len  }
  if (end < 0) {    end += len    if (end < 0) end = 0  } else if (end > len) {    end = len  }
  if (end < start) end = start
  var newBuf  if (Buffer.TYPED_ARRAY_SUPPORT) {    newBuf = this.subarray(start, end)    newBuf.__proto__ = Buffer.prototype  } else {    var sliceLen = end - start    newBuf = new Buffer(sliceLen, undefined)    for (var i = 0; i < sliceLen; ++i) {      newBuf[i] = this[i + start]    }  }
  return newBuf}
 * Need to make sure that buffer isn't trying to write out of bounds. */function checkOffset (offset, ext, length) {  if ((offset % 1) !== 0 || offset < 0) throw new RangeError(offset is not uint)  if (offset + ext > length) throw new RangeError(Trying to access beyond buffer length)}
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) checkOffset(offset, byteLength, this.length)
  var val = this[offset]  var mul = 1  var i = 0  while (++i < byteLength && (mul  0x100)) {    val += this[offset + i]  mul  }
  return val}
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) {    checkOffset(offset, byteLength, this.length)  }
  var val = this[offset + --byteLength]  var mul = 1  while (byteLength > 0 && (mul  0x100)) {    val += this[offset + --byteLength]  mul  }
  return val}
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {  if (!noAssert) checkOffset(offset, 1, this.length)  return this[offset]}
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  return this[offset] | (this[offset + 1] << 8)}
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  return (this[offset] << 8) | this[offset + 1]}
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return ((this[offset]) |      (this[offset + 1] << 8) |      (this[offset + 2] << 16)) +      (this[offset + 3]  0x1000000)}
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return (this[offset]  0x1000000) +    ((this[offset + 1] << 16) |    (this[offset + 2] << 8) |    this[offset + 3])}
Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) checkOffset(offset, byteLength, this.length)
  var val = this[offset]  var mul = 1  var i = 0  while (++i < byteLength && (mul  0x100)) {    val += this[offset + i]  mul  }  mul  0x80
  if (val >= mul) val -= Math.pow(2, 8  byteLength)
  return val}
Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) checkOffset(offset, byteLength, this.length)
  var i = byteLength  var mul = 1  var val = this[offset + --i]  while (i > 0 && (mul  0x100)) {    val += this[offset + --i]  mul  }  mul  0x80
  if (val >= mul) val -= Math.pow(2, 8  byteLength)
  return val}
Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {  if (!noAssert) checkOffset(offset, 1, this.length)  if (!(this[offset] & 0x80)) return (this[offset])  return ((0xff - this[offset] + 1)  -1)}
Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  var val = this[offset] | (this[offset + 1] << 8)  return (val & 0x8000) ? val | 0xFFFF0000 : val}
Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 2, this.length)  var val = this[offset + 1] | (this[offset] << 8)  return (val & 0x8000) ? val | 0xFFFF0000 : val}
Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return (this[offset]) |    (this[offset + 1] << 8) |    (this[offset + 2] << 16) |    (this[offset + 3] << 24)}
Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)
  return (this[offset] << 24) |    (this[offset + 1] << 16) |    (this[offset + 2] << 8) |    (this[offset + 3])}
Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)  return ieee754.read(this, offset, true, 23, 4)}
Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 4, this.length)  return ieee754.read(this, offset, false, 23, 4)}
Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 8, this.length)  return ieee754.read(this, offset, true, 52, 8)}
Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {  if (!noAssert) checkOffset(offset, 8, this.length)  return ieee754.read(this, offset, false, 52, 8)}
function checkInt (buf, value, offset, ext, max, min) {  if (!Buffer.isBuffer(buf)) throw new TypeError(""buffer"" argument must be a Buffer instance)  if (value > max || value < min) throw new RangeError(""value"" argument is out of bounds)  if (offset + ext > buf.length) throw new RangeError(Index out of range)}
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) {    var maxBytes = Math.pow(2, 8  byteLength) - 1    checkInt(this, value, offset, byteLength, maxBytes, 0)  }
  var mul = 1  var i = 0  this[offset] = value & 0xFF  while (++i < byteLength && (mul  0x100)) {    this[offset + i] = (value / mul) & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  byteLength = byteLength | 0  if (!noAssert) {    var maxBytes = Math.pow(2, 8  byteLength) - 1    checkInt(this, value, offset, byteLength, maxBytes, 0)  }
  var i = byteLength - 1  var mul = 1  this[offset + i] = value & 0xFF  while (--i >= 0 && (mul  0x100)) {    this[offset + i] = (value / mul) & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)  this[offset] = (value & 0xff)  return offset + 1}
function objectWriteUInt16 (buf, value, offset, littleEndian) {  if (value < 0) value = 0xffff + value + 1  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {    buf[offset + i] = (value & (0xff << (8  (littleEndian ? i : 1 - i)))) >>>      (littleEndian ? i : 1 - i)  8  }}
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value & 0xff)    this[offset + 1] = (value >>> 8)  } else {    objectWriteUInt16(this, value, offset, true)  }  return offset + 2}
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 8)    this[offset + 1] = (value & 0xff)  } else {    objectWriteUInt16(this, value, offset, false)  }  return offset + 2}
function objectWriteUInt32 (buf, value, offset, littleEndian) {  if (value < 0) value = 0xffffffff + value + 1  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i)  8) & 0xff  }}
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset + 3] = (value >>> 24)    this[offset + 2] = (value >>> 16)    this[offset + 1] = (value >>> 8)    this[offset] = (value & 0xff)  } else {    objectWriteUInt32(this, value, offset, true)  }  return offset + 4}
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 24)    this[offset + 1] = (value >>> 16)    this[offset + 2] = (value >>> 8)    this[offset + 3] = (value & 0xff)  } else {    objectWriteUInt32(this, value, offset, false)  }  return offset + 4}
Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) {    var limit = Math.pow(2, 8  byteLength - 1)
    checkInt(this, value, offset, byteLength, limit - 1, -limit)  }
  var i = 0  var mul = 1  var sub = 0  this[offset] = value & 0xFF  while (++i < byteLength && (mul  0x100)) {    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {      sub = 1    }    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) {    var limit = Math.pow(2, 8  byteLength - 1)
    checkInt(this, value, offset, byteLength, limit - 1, -limit)  }
  var i = byteLength - 1  var mul = 1  var sub = 0  this[offset + i] = value & 0xFF  while (--i >= 0 && (mul  0x100)) {    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {      sub = 1    }    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF  }
  return offset + byteLength}
Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)  if (value < 0) value = 0xff + value + 1  this[offset] = (value & 0xff)  return offset + 1}
Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value & 0xff)    this[offset + 1] = (value >>> 8)  } else {    objectWriteUInt16(this, value, offset, true)  }  return offset + 2}
Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 8)    this[offset + 1] = (value & 0xff)  } else {    objectWriteUInt16(this, value, offset, false)  }  return offset + 2}
Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value & 0xff)    this[offset + 1] = (value >>> 8)    this[offset + 2] = (value >>> 16)    this[offset + 3] = (value >>> 24)  } else {    objectWriteUInt32(this, value, offset, true)  }  return offset + 4}
Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {  value = +value  offset = offset | 0  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)  if (value < 0) value = 0xffffffff + value + 1  if (Buffer.TYPED_ARRAY_SUPPORT) {    this[offset] = (value >>> 24)    this[offset + 1] = (value >>> 16)    this[offset + 2] = (value >>> 8)    this[offset + 3] = (value & 0xff)  } else {    objectWriteUInt32(this, value, offset, false)  }  return offset + 4}
function checkIEEE754 (buf, value, offset, ext, max, min) {  if (offset + ext > buf.length) throw new RangeError(Index out of range)  if (offset < 0) throw new RangeError(Index out of range)}
function writeFloat (buf, value, offset, littleEndian, noAssert) {  if (!noAssert) {    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)  }  ieee754.write(buf, value, offset, littleEndian, 23, 4)  return offset + 4}
Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {  return writeFloat(this, value, offset, true, noAssert)}
Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {  return writeFloat(this, value, offset, false, noAssert)}
function writeDouble (buf, value, offset, littleEndian, noAssert) {  if (!noAssert) {    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)  }  ieee754.write(buf, value, offset, littleEndian, 52, 8)  return offset + 8}
Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {  return writeDouble(this, value, offset, true, noAssert)}
Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {  return writeDouble(this, value, offset, false, noAssert)}
 copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)Buffer.prototype.copy = function copy (target, targetStart, start, end) {  if (!start) start = 0  if (!end && end !== 0) end = this.length  if (targetStart >= target.length) targetStart = target.length  if (!targetStart) targetStart = 0  if (end > 0 && end < start) end = start
   Copy 0 bytes; we're done  if (end === start) return 0  if (target.length === 0 || this.length === 0) return 0
   Fatal error conditions  if (targetStart < 0) {    throw new RangeError(targetStart out of bounds)  }  if (start < 0 || start >= this.length) throw new RangeError(sourceStart out of bounds)  if (end < 0) throw new RangeError(sourceEnd out of bounds)
   Are we oob?  if (end > this.length) end = this.length  if (target.length - targetStart < end - start) {    end = target.length - targetStart + start  }
  var len = end - start  var i
  if (this === target && start < targetStart && targetStart < end) {     descending copy from end    for (i = len - 1; i >= 0; --i) {      target[i + targetStart] = this[i + start]    }  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {     ascending copy from start    for (i = 0; i < len; ++i) {      target[i + targetStart] = this[i + start]    }  } else {    Uint8Array.prototype.set.call(      target,      this.subarray(start, start + len),      targetStart    )  }
  return len}
 Usage:    buffer.fill(number[, offset[, end]])    buffer.fill(buffer[, offset[, end]])    buffer.fill(string[, offset[, end]][, encoding])Buffer.prototype.fill = function fill (val, start, end, encoding) {   Handle string cases:  if (typeof val === string) {    if (typeof start === string) {      encoding = start      start = 0      end = this.length    } else if (typeof end === string) {      encoding = end      end = this.length    }    if (val.length === 1) {      var code = val.charCodeAt(0)      if (code < 256) {        val = code      }    }    if (encoding !== undefined && typeof encoding !== string) {      throw new TypeError(encoding must be a string)    }    if (typeof encoding === string && !Buffer.isEncoding(encoding)) {      throw new TypeError(Unknown encoding:  + encoding)    }  } else if (typeof val === number) {    val = val & 255  }
   Invalid ranges are not set to a default, so can range check early.  if (start < 0 || this.length < start || this.length < end) {    throw new RangeError(Out of range index)  }
  if (end <= start) {    return this  }
  start = start >>> 0  end = end === undefined ? this.length : end >>> 0
  if (!val) val = 0
  var i  if (typeof val === number) {    for (i = start; i < end; ++i) {      this[i] = val    }  } else {    var bytes = Buffer.isBuffer(val)      ? val      : utf8ToBytes(new Buffer(val, encoding).toString())    var len = bytes.length    for (i = 0; i < end - start; ++i) {      this[i + start] = bytes[i % len]    }  }
  return this}
 HELPER FUNCTIONS ================
var INVALID_BASE64_RE = g
function base64clean (str) {   Node strips out invalid characters like \n and \t from the string, base64-js does not  str = stringtrim(str).replace(INVALID_BASE64_RE, )   Node converts strings with length < 2 to ''  if (str.length < 2) return    Node allows for non-padded base64 strings (missing trailing ===), base64-js does not  while (str.length % 4 !== 0) {    str = str + =  }  return str}
function stringtrim (str) {  if (str.trim) return str.trim()  return str.replace(g, )}
function toHex (n) {  if (n < 16) return 0 + n.toString(16)  return n.toString(16)}
function utf8ToBytes (string, units) {  units = units || Infinity  var codePoint  var length = string.length  var leadSurrogate = null  var bytes = []
  for (var i = 0; i < length; ++i) {    codePoint = string.charCodeAt(i)
     is surrogate component    if (codePoint > 0xD7FF && codePoint < 0xE000) {       last char was a lead      if (!leadSurrogate) {         no lead yet        if (codePoint > 0xDBFF) {           unexpected trail          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)          continue        } else if (i + 1 === length) {           unpaired lead          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)          continue        }
         valid lead        leadSurrogate = codePoint
        continue      }
       2 leads in a row      if (codePoint < 0xDC00) {        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)        leadSurrogate = codePoint        continue      }
       valid surrogate pair      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000    } else if (leadSurrogate) {       valid bmp char, but last char was a lead      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)    }
    leadSurrogate = null
     encode utf8    if (codePoint < 0x80) {      if ((units -= 1) < 0) break      bytes.push(codePoint)    } else if (codePoint < 0x800) {      if ((units -= 2) < 0) break      bytes.push(        codePoint >> 0x6 | 0xC0,        codePoint & 0x3F | 0x80      )    } else if (codePoint < 0x10000) {      if ((units -= 3) < 0) break      bytes.push(        codePoint >> 0xC | 0xE0,        codePoint >> 0x6 & 0x3F | 0x80,        codePoint & 0x3F | 0x80      )    } else if (codePoint < 0x110000) {      if ((units -= 4) < 0) break      bytes.push(        codePoint >> 0x12 | 0xF0,        codePoint >> 0xC & 0x3F | 0x80,        codePoint >> 0x6 & 0x3F | 0x80,        codePoint & 0x3F | 0x80      )    } else {      throw new Error(Invalid code point)    }  }
  return bytes}
function asciiToBytes (str) {  var byteArray = []  for (var i = 0; i < str.length; ++i) {     Node's code seems to be doing this and not & 0x7F..    byteArray.push(str.charCodeAt(i) & 0xFF)  }  return byteArray}
function utf16leToBytes (str, units) {  var c, hi, lo  var byteArray = []  for (var i = 0; i < str.length; ++i) {    if ((units -= 2) < 0) break
    c = str.charCodeAt(i)    hi = c >> 8    lo = c % 256    byteArray.push(lo)    byteArray.push(hi)  }
  return byteArray}
function base64ToBytes (str) {  return base64.toByteArray(base64clean(str))}
function blitBuffer (src, dst, offset, length) {  for (var i = 0; i < length; ++i) {    if ((i + offset >= dst.length) || (i >= src.length)) break    dst[i + offset] = src[i]  }  return i}
function isnan (val) {  return val !== val  eslint-disable-line no-self-compare}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{base64-js:39,ieee754:50,isarray:53}],45:[function(require,module,exports){(function (Buffer){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 NOTE: These type checking functions intentionally don't use `instanceof` because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {  if (Array.isArray) {    return Array.isArray(arg);  }  return objectToString(arg) === [object Array];}exports.isArray = isArray;
function isBoolean(arg) {  return typeof arg === boolean;}exports.isBoolean = isBoolean;
function isNull(arg) {  return arg === null;}exports.isNull = isNull;
function isNullOrUndefined(arg) {  return arg == null;}exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {  return typeof arg === number;}exports.isNumber = isNumber;
function isString(arg) {  return typeof arg === string;}exports.isString = isString;
function isSymbol(arg) {  return typeof arg === symbol;}exports.isSymbol = isSymbol;
function isUndefined(arg) {  return arg === void 0;}exports.isUndefined = isUndefined;
function isRegExp(re) {  return objectToString(re) === [object RegExp];}exports.isRegExp = isRegExp;
function isObject(arg) {  return typeof arg === object && arg !== null;}exports.isObject = isObject;
function isDate(d) {  return objectToString(d) === [object Date];}exports.isDate = isDate;
function isError(e) {  return (objectToString(e) === [object Error] || e instanceof Error);}exports.isError = isError;
function isFunction(arg) {  return typeof arg === function;}exports.isFunction = isFunction;
function isPrimitive(arg) {  return arg === null ||         typeof arg === boolean ||         typeof arg === number ||         typeof arg === string ||         typeof arg === symbol ||   ES6 symbol         typeof arg === undefined;}exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;
function objectToString(o) {  return Object.prototype.toString.call(o);}
}).call(this,{isBuffer:require(../../is-buffer/index.js)})},{../../is-buffer/index.js:52}],46:[function(require,module,exports){
 * Text diff implementation. * * This library supports the following APIS: * JsDiff.diffChars: Character by character diff * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace * JsDiff.diffLines: Line based diff * * JsDiff.diffCss: Diff targeted at CSS content * * These methods are based on the implementation proposed in * ""An O(ND) Difference Algorithm and its Variations"" (Myers, 1986). * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927 */(function(global, undefined) {  var objectPrototypeToString = Object.prototype.toString;
    function map(arr, mapper, that) {    if (Array.prototype.map) {      return Array.prototype.map.call(arr, mapper, that);    }
    var other = new Array(arr.length);
    for (var i = 0, n = arr.length; i < n; i++) {      other[i] = mapper.call(that, arr[i], i, arr);    }    return other;  }  function clonePath(path) {    return { newPos: path.newPos, components: path.components.slice(0) };  }  function removeEmpty(array) {    var ret = [];    for (var i = 0; i < array.length; i++) {      if (array[i]) {        ret.push(array[i]);      }    }    return ret;  }  function escapeHTML(s) {    var n = s;    n = n.replace(&g, &amp;);    n = n.replace(<g, &lt;);    n = n.replace(>g, &gt;);    n = n.replace(""g, &quot;);
    return n;  }
   This function handles the presence of circular references by bailing out when encountering an   object that is already on the ""stack"" of items being processed.  function canonicalize(obj, stack, replacementStack) {    stack = stack || [];    replacementStack = replacementStack || [];
    var i;
    for (i = 0; i < stack.length; i += 1) {      if (stack[i] === obj) {        return replacementStack[i];      }    }
    var canonicalizedObj;
    if ([object Array] === objectPrototypeToString.call(obj)) {      stack.push(obj);      canonicalizedObj = new Array(obj.length);      replacementStack.push(canonicalizedObj);      for (i = 0; i < obj.length; i += 1) {        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);      }      stack.pop();      replacementStack.pop();    } else if (typeof obj === object && obj !== null) {      stack.push(obj);      canonicalizedObj = {};      replacementStack.push(canonicalizedObj);      var sortedKeys = [],          key;      for (key in obj) {        sortedKeys.push(key);      }      sortedKeys.sort();      for (i = 0; i < sortedKeys.length; i += 1) {        key = sortedKeys[i];        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);      }      stack.pop();      replacementStack.pop();    } else {      canonicalizedObj = obj;    }    return canonicalizedObj;  }
  function buildValues(components, newString, oldString, useLongestToken) {    var componentPos = 0,        componentLen = components.length,        newPos = 0,        oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {      var component = components[componentPos];      if (!component.removed) {        if (!component.added && useLongestToken) {          var value = newString.slice(newPos, newPos + component.count);          value = map(value, function(value, i) {            var oldValue = oldString[oldPos + i];            return oldValue.length > value.length ? oldValue : value;          });
          component.value = value.join();        } else {          component.value = newString.slice(newPos, newPos + component.count).join();        }        newPos += component.count;
         Common case        if (!component.added) {          oldPos += component.count;        }      } else {        component.value = oldString.slice(oldPos, oldPos + component.count).join();        oldPos += component.count;
         Reverse add and remove so removes are output first to match common convention         The diffing algorithm is tied to add then remove output and this is the simplest         route to get the desired output with minimal overhead.        if (componentPos && components[componentPos - 1].added) {          var tmp = components[componentPos - 1];          components[componentPos - 1] = components[componentPos];          components[componentPos] = tmp;        }      }    }
    return components;  }
  function Diff(ignoreWhitespace) {    this.ignoreWhitespace = ignoreWhitespace;  }  Diff.prototype = {    diff: function(oldString, newString, callback) {      var self = this;
      function done(value) {        if (callback) {          setTimeout(function() { callback(undefined, value); }, 0);          return true;        } else {          return value;        }      }
       Handle the identity case (this is due to unrolling editLength == 0      if (newString === oldString) {        return done([{ value: newString }]);      }      if (!newString) {        return done([{ value: oldString, removed: true }]);      }      if (!oldString) {        return done([{ value: newString, added: true }]);      }
      newString = this.tokenize(newString);      oldString = this.tokenize(oldString);
      var newLen = newString.length, oldLen = oldString.length;      var editLength = 1;      var maxEditLength = newLen + oldLen;      var bestPath = [{ newPos: -1, components: [] }];
       Seed editLength = 0, i.e. the content starts with the same values      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {         Identity per the equality and tokenizer        return done([{value: newString.join()}]);      }
       Main worker method. checks all permutations of a given edit length for acceptance.      function execEditLength() {        for (var diagonalPath = -1  editLength; diagonalPath <= editLength; diagonalPath += 2) {          var basePath;          var addPath = bestPath[diagonalPath - 1],              removePath = bestPath[diagonalPath + 1],              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;          if (addPath) {             No one else is going to attempt to use this value, clear it            bestPath[diagonalPath - 1] = undefined;          }
          var canAdd = addPath && addPath.newPos + 1 < newLen,              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;          if (!canAdd && !canRemove) {             If this path is a terminal then prune            bestPath[diagonalPath] = undefined;            continue;          }
           Select the diagonal that we want to branch from. We select the prior           path whose position in the new string is the farthest from the origin           and does not pass the bounds of the diff graph          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {            basePath = clonePath(removePath);            self.pushComponent(basePath.components, undefined, true);          } else {            basePath = addPath;    No need to clone, we've pulled it from the list            basePath.newPos++;            self.pushComponent(basePath.components, true, undefined);          }
          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
           If we have hit the end of both strings, then we are done          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));          } else {             Otherwise track this path as a potential candidate and continue.            bestPath[diagonalPath] = basePath;          }        }
        editLength++;      }
       Performs the length of edit iteration. Is a bit fugly as this has to support the       sync and async mode which is never fun. Loops over execEditLength until a value       is produced.      if (callback) {        (function exec() {          setTimeout(function() {             This should not happen, but we want to be safe.                        if (editLength > maxEditLength) {              return callback();            }
            if (!execEditLength()) {              exec();            }          }, 0);        }());      } else {        while (editLength <= maxEditLength) {          var ret = execEditLength();          if (ret) {            return ret;          }        }      }    },
    pushComponent: function(components, added, removed) {      var last = components[components.length - 1];      if (last && last.added === added && last.removed === removed) {         We need to clone here as the component clone operation is just         as shallow array clone        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };      } else {        components.push({count: 1, added: added, removed: removed });      }    },    extractCommon: function(basePath, newString, oldString, diagonalPath) {      var newLen = newString.length,          oldLen = oldString.length,          newPos = basePath.newPos,          oldPos = newPos - diagonalPath,
          commonCount = 0;      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {        newPos++;        oldPos++;        commonCount++;      }
      if (commonCount) {        basePath.components.push({count: commonCount});      }
      basePath.newPos = newPos;      return oldPos;    },
    equals: function(left, right) {      var reWhitespace = ;      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));    },    tokenize: function(value) {      return value.split();    }  };
  var CharDiff = new Diff();
  var WordDiff = new Diff(true);  var WordWithSpaceDiff = new Diff();  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {    return removeEmpty(value.split(()));  };
  var CssDiff = new Diff(true);  CssDiff.tokenize = function(value) {    return removeEmpty(value.split(()));  };
  var LineDiff = new Diff();
  var TrimmedLineDiff = new Diff();  TrimmedLineDiff.ignoreTrim = true;
  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {    var retLines = [],        lines = value.split(m);    for (var i = 0; i < lines.length; i++) {      var line = lines[i],          lastLine = lines[i - 1],          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];
       Merge lines that may contain windows new lines      if (line ===  && lastLineLastChar === ) {          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + ;      } else {        if (this.ignoreTrim) {          line = line.trim();           add a newline unless this is the last line.          if (i < lines.length - 1) {            line += ;          }        }        retLines.push(line);      }    }
    return retLines;  };
  var PatchDiff = new Diff();  PatchDiff.tokenize = function(value) {    var ret = [],        linesAndNewlines = value.split(());
     Ignore the final empty token that occurs if the string ends with a new line    if (!linesAndNewlines[linesAndNewlines.length - 1]) {      linesAndNewlines.pop();    }
     Merge the content and line separators into single tokens    for (var i = 0; i < linesAndNewlines.length; i++) {      var line = linesAndNewlines[i];
      if (i % 2) {        ret[ret.length - 1] += line;      } else {        ret.push(line);      }    }    return ret;  };
  var SentenceDiff = new Diff();  SentenceDiff.tokenize = function(value) {    return removeEmpty(value.split(()(?=)));  };
  var JsonDiff = new Diff();   Discriminate between two lines of pretty-printed, serialized JSON where one of them has a   dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:  JsonDiff.useLongestToken = true;  JsonDiff.tokenize = LineDiff.tokenize;  JsonDiff.equals = function(left, right) {    return LineDiff.equals(left.replace(,()g, $1), right.replace(,()g, $1));  };
  var JsDiff = {    Diff: Diff,
    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },
    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },
    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },    diffJson: function(oldObj, newObj, callback) {      return JsonDiff.diff(        typeof oldObj === string ? oldObj : JSON.stringify(canonicalize(oldObj), undefined,   ),        typeof newObj === string ? newObj : JSON.stringify(canonicalize(newObj), undefined,   ),        callback      );    },
    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {      var ret = [];
      if (oldFileName == newFileName) {        ret.push(Index:  + oldFileName);      }      ret.push(===================================================================);      ret.push(---  + oldFileName + (typeof oldHeader === undefined ?  :  + oldHeader));      ret.push(+++  + newFileName + (typeof newHeader === undefined ?  :  + newHeader));
      var diff = PatchDiff.diff(oldStr, newStr);      diff.push({value: , lines: []});    Append an empty value to make cleanup easier
       Formats a given set of lines for printing as context lines in a patch      function contextLines(lines) {        return map(lines, function(entry) { return   + entry; });      }
       Outputs the no newline at end of file warning if needed      function eofNL(curRange, i, current) {        var last = diff[diff.length - 2],            isLast = i === diff.length - 2,            isLastOfType = i === diff.length - 3 && current.added !== last.added;
         Figure out if this is the last line for the given file and missing NL        if (!(.test(current.value)) && (isLast || isLastOfType)) {          curRange.push( No newline at end of file);        }      }
      var oldRangeStart = 0, newRangeStart = 0, curRange = [],          oldLine = 1, newLine = 1;      for (var i = 0; i < diff.length; i++) {        var current = diff[i],            lines = current.lines || current.value.replace(, ).split();        current.lines = lines;
        if (current.added || current.removed) {           If we have previous context, start with that          if (!oldRangeStart) {            var prev = diff[i - 1];            oldRangeStart = oldLine;            newRangeStart = newLine;
            if (prev) {              curRange = contextLines(prev.lines.slice(-4));              oldRangeStart -= curRange.length;              newRangeStart -= curRange.length;            }          }
           Output our changes          curRange.push.apply(curRange, map(lines, function(entry) {            return (current.added ? + : -) + entry;          }));          eofNL(curRange, i, current);
           Track the updated file position          if (current.added) {            newLine += lines.length;          } else {            oldLine += lines.length;          }        } else {           Identical context lines. Track line changes          if (oldRangeStart) {             Close out any changes that have been output (or join overlapping)            if (lines.length <= 8 && i < diff.length - 2) {               Overlapping              curRange.push.apply(curRange, contextLines(lines));            } else {               end the range and output              var contextSize = Math.min(lines.length, 4);              ret.push(                  @@ - + oldRangeStart + , + (oldLine - oldRangeStart + contextSize)                  +  + + newRangeStart + , + (newLine - newRangeStart + contextSize)                  +  @@);              ret.push.apply(ret, curRange);              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));              if (lines.length <= 4) {                eofNL(ret, i, current);              }
              oldRangeStart = 0;              newRangeStart = 0;              curRange = [];            }          }          oldLine += lines.length;          newLine += lines.length;        }      }
      return ret.join() + ;    },
    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);    },
    applyPatch: function(oldStr, uniDiff) {      var diffstr = uniDiff.split(),          hunks = [],          i = 0,          remEOFNL = false,          addEOFNL = false;
       Skip to the first change hunk      while (i < diffstr.length && !(@@.test(diffstr[i]))) {        i++;      }
       Parse the unified diff      for (; i < diffstr.length; i++) {        if (diffstr[i][0] === @) {          var chnukHeader = diffstr[i].split(@@ -(),() (),() @@);          hunks.unshift({            start: chnukHeader[3],            oldlength: +chnukHeader[2],            removed: [],            newlength: chnukHeader[4],            added: []          });        } else if (diffstr[i][0] === +) {          hunks[0].added.push(diffstr[i].substr(1));        } else if (diffstr[i][0] === -) {          hunks[0].removed.push(diffstr[i].substr(1));        } else if (diffstr[i][0] ===  ) {          hunks[0].added.push(diffstr[i].substr(1));          hunks[0].removed.push(diffstr[i].substr(1));        } else if (diffstr[i][0] === ) {          if (diffstr[i - 1][0] === +) {            remEOFNL = true;          } else if (diffstr[i - 1][0] === -) {            addEOFNL = true;          }        }      }
       Apply the diff to the input      var lines = oldStr.split();      for (i = hunks.length - 1; i >= 0; i--) {        var hunk = hunks[i];         Sanity check the input string. Bail if we don't match.        for (var j = 0; j < hunk.oldlength; j++) {          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {            return false;          }        }        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));      }
       Handle EOFNL insertion/removal      if (remEOFNL) {        while (!lines[lines.length - 1]) {          lines.pop();        }      } else if (addEOFNL) {        lines.push();      }      return lines.join();    },
    convertChangesToXML: function(changes) {      var ret = [];      for (var i = 0; i < changes.length; i++) {        var change = changes[i];        if (change.added) {          ret.push(<ins>);        } else if (change.removed) {          ret.push(<del>);        }
        ret.push(escapeHTML(change.value));
        if (change.added) {          ret.push(</ins>);        } else if (change.removed) {          ret.push(</del>);        }      }      return ret.join();    },
     See: http://code.google.com/p/google-diff-match-patch/wiki/API    convertChangesToDMP: function(changes) {      var ret = [],          change,          operation;      for (var i = 0; i < changes.length; i++) {        change = changes[i];        if (change.added) {          operation = 1;        } else if (change.removed) {          operation = -1;        } else {          operation = 0;        }
        ret.push([operation, change.value]);      }      return ret;    },
    canonicalize: canonicalize  };
      if (typeof module !== undefined && module.exports) {    module.exports = JsDiff;  } else if (false) {        define([], function() { return JsDiff; });  } else if (typeof global.JsDiff === undefined) {    global.JsDiff = JsDiff;  }}(this));
},{}],47:[function(require,module,exports){use strict;
var matchOperatorsRe = g;
module.exports = function (str) {	if (typeof str !== string) {		throw new TypeError(Expected a string);	}
	return str.replace(matchOperatorsRe, $&);};
},{}],48:[function(require,module,exports){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter() {  this._events = this._events || {};  this._maxListeners = this._maxListeners || undefined;}module.exports = EventEmitter;
 Backwards-compat with node 0.10.xEventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;EventEmitter.prototype._maxListeners = undefined;
 By default EventEmitters will print a warning if more than 10 listeners are added to it. This is a useful default which helps finding memory leaks.EventEmitter.defaultMaxListeners = 10;
 Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.EventEmitter.prototype.setMaxListeners = function(n) {  if (!isNumber(n) || n < 0 || isNaN(n))    throw TypeError(n must be a positive number);  this._maxListeners = n;  return this;};
EventEmitter.prototype.emit = function(type) {  var er, handler, len, args, i, listeners;
  if (!this._events)    this._events = {};
   If there is no 'error' event listener then throw.  if (type === error) {    if (!this._events.error ||        (isObject(this._events.error) && !this._events.error.length)) {      er = arguments[1];      if (er instanceof Error) {        throw er;  Unhandled 'error' event      } else {         At least give some kind of context to the user        var err = new Error(Uncaught, unspecified ""error"" event. ( + er + ));        err.context = er;        throw err;      }    }  }
  handler = this._events[type];
  if (isUndefined(handler))    return false;
  if (isFunction(handler)) {    switch (arguments.length) {       fast cases      case 1:        handler.call(this);        break;      case 2:        handler.call(this, arguments[1]);        break;      case 3:        handler.call(this, arguments[1], arguments[2]);        break;       slower      default:        args = Array.prototype.slice.call(arguments, 1);        handler.apply(this, args);    }  } else if (isObject(handler)) {    args = Array.prototype.slice.call(arguments, 1);    listeners = handler.slice();    len = listeners.length;    for (i = 0; i < len; i++)      listeners[i].apply(this, args);  }
  return true;};
EventEmitter.prototype.addListener = function(type, listener) {  var m;
  if (!isFunction(listener))    throw TypeError(listener must be a function);
  if (!this._events)    this._events = {};
   To avoid recursion in the case that type === ""newListener""! Before   adding it to the listeners, first emit ""newListener"".  if (this._events.newListener)    this.emit(newListener, type,              isFunction(listener.listener) ?              listener.listener : listener);
  if (!this._events[type])     Optimize the case of one listener. Don't need the extra array object.    this._events[type] = listener;  else if (isObject(this._events[type]))     If we've already got an array, just append.    this._events[type].push(listener);  else     Adding the second element, need to change to array.    this._events[type] = [this._events[type], listener];
   Check for listener leak  if (isObject(this._events[type]) && !this._events[type].warned) {    if (!isUndefined(this._maxListeners)) {      m = this._maxListeners;    } else {      m = EventEmitter.defaultMaxListeners;    }
    if (m && m > 0 && this._events[type].length > m) {      this._events[type].warned = true;      console.error((node) warning: possible EventEmitter memory  +                    leak detected. %d listeners added.  +                    Use emitter.setMaxListeners() to increase limit.,                    this._events[type].length);      if (typeof console.trace === function) {         not supported in IE 10        console.trace();      }    }  }
  return this;};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.once = function(type, listener) {  if (!isFunction(listener))    throw TypeError(listener must be a function);
  var fired = false;
  function g() {    this.removeListener(type, g);
    if (!fired) {      fired = true;      listener.apply(this, arguments);    }  }
  g.listener = listener;  this.on(type, g);
  return this;};
 emits a 'removeListener' event iff the listener was removedEventEmitter.prototype.removeListener = function(type, listener) {  var list, position, length, i;
  if (!isFunction(listener))    throw TypeError(listener must be a function);
  if (!this._events || !this._events[type])    return this;
  list = this._events[type];  length = list.length;  position = -1;
  if (list === listener ||      (isFunction(list.listener) && list.listener === listener)) {    delete this._events[type];    if (this._events.removeListener)      this.emit(removeListener, type, listener);
  } else if (isObject(list)) {    for (i = length; i-- > 0;) {      if (list[i] === listener ||          (list[i].listener && list[i].listener === listener)) {        position = i;        break;      }    }
    if (position < 0)      return this;
    if (list.length === 1) {      list.length = 0;      delete this._events[type];    } else {      list.splice(position, 1);    }
    if (this._events.removeListener)      this.emit(removeListener, type, listener);  }
  return this;};
EventEmitter.prototype.removeAllListeners = function(type) {  var key, listeners;
  if (!this._events)    return this;
   not listening for removeListener, no need to emit  if (!this._events.removeListener) {    if (arguments.length === 0)      this._events = {};    else if (this._events[type])      delete this._events[type];    return this;  }
   emit removeListener for all listeners on all events  if (arguments.length === 0) {    for (key in this._events) {      if (key === removeListener) continue;      this.removeAllListeners(key);    }    this.removeAllListeners(removeListener);    this._events = {};    return this;  }
  listeners = this._events[type];
  if (isFunction(listeners)) {    this.removeListener(type, listeners);  } else if (listeners) {     LIFO order    while (listeners.length)      this.removeListener(type, listeners[listeners.length - 1]);  }  delete this._events[type];
  return this;};
EventEmitter.prototype.listeners = function(type) {  var ret;  if (!this._events || !this._events[type])    ret = [];  else if (isFunction(this._events[type]))    ret = [this._events[type]];  else    ret = this._events[type].slice();  return ret;};
EventEmitter.prototype.listenerCount = function(type) {  if (this._events) {    var evlistener = this._events[type];
    if (isFunction(evlistener))      return 1;    else if (evlistener)      return evlistener.length;  }  return 0;};
EventEmitter.listenerCount = function(emitter, type) {  return emitter.listenerCount(type);};
function isFunction(arg) {  return typeof arg === function;}
function isNumber(arg) {  return typeof arg === number;}
function isObject(arg) {  return typeof arg === object && arg !== null;}
function isUndefined(arg) {  return arg === void 0;}
},{}],49:[function(require,module,exports){(function (process){ Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)
 * Module dependencies. */
var exec = require(child_process).exec  , fs = require(fs)  , path = require(path)  , exists = fs.existsSync || path.existsSync  , os = require(os)  , quote = JSON.stringify  , cmd;
function which(name) {  var paths = process.env.PATH.split(:);  var loc;
  for (var i = 0, len = paths.length; i < len; ++i) {    loc = path.join(paths[i], name);    if (exists(loc)) return loc;  }}
switch(os.type()) {  case Darwin:    if (which(terminal-notifier)) {      cmd = {          type: Darwin-NotificationCenter        , pkg: terminal-notifier        , msg: -message        , title: -title        , subtitle: -subtitle        , icon: -appIcon        , sound:  -sound        , url: -open        , priority: {              cmd: -execute            , range: []          }      };    } else {      cmd = {          type: Darwin-Growl        , pkg: growlnotify        , msg: -m        , sticky: --sticky        , priority: {              cmd: --priority            , range: [                -2              , -1              , 0              , 1              , 2              , Very Low              , Moderate              , Normal              , High              , Emergency            ]          }      };    }    break;  case Linux:    if (which(growl)) {      cmd = {          type: Linux-Growl        , pkg: growl        , msg: -m        , title: -title        , subtitle: -subtitle        , host: {            cmd: -H          , hostname: 192.168.33.1        }      };    } else {      cmd = {          type: Linux        , pkg: notify-send        , msg:         , sticky: -t 0        , icon: -i        , priority: {            cmd: -u          , range: [              low            , normal            , critical          ]        }      };    }    break;  case Windows_NT:    cmd = {        type: Windows      , pkg: growlnotify      , msg:       , sticky: /s:true      , title: /t:      , icon: /i:      , url: /cu:      , priority: {            cmd: /p:          , range: [              -2            , -1            , 0            , 1            , 2          ]        }    };    break;}
 * Expose `growl`. */
exports = module.exports = growl;
 * Node-growl version. */
exports.version = 1.4.1
 * Send growl notification _msg_ with _options_. * * Options: * *  - title   Notification title *  - sticky  Make the notification stick (defaults to false) *  - priority  Specify an int or named key (default is 0) *  - name    Application name (defaults to growlnotify) *  - sound   Sound efect ( in OSx defined in preferences -> sound -> effects) * works only in OSX > 10.8x *  - image *    - path to an icon sets --iconpath *    - path to an image sets --image *    - capitalized word sets --appIcon *    - filename uses extname as --icon *    - otherwise treated as --icon * * Examples: * *   growl('New email') *   growl('5 new emails', { title: 'Thunderbird' }) *   growl('5 new emails', { title: 'Thunderbird', sound: 'Purr' }) *   growl('Email sent', function(){ *     // ... notification sent *   }) * *    *    *    * @api public */
function growl(msg, options, fn) {  var image    , args    , options = options || {}    , fn = fn || function(){};
  if (options.exec) {    cmd = {        type: Custom      , pkg: options.exec      , range: []    };  }
   noop  if (!cmd) return fn(new Error(growl not supported on this platform));  args = [cmd.pkg];
   image  if (image = options.image) {    switch(cmd.type) {      case Darwin-Growl:        var flag, ext = path.extname(image).substr(1)        flag = flag || ext == icns && iconpath        flag = flag || .test(image) && appIcon        flag = flag || pnggifjpeg.test(ext) && image        flag = flag || ext && (image = ext) && icon        flag = flag || icon        args.push(-- + flag, quote(image))        break;      case Darwin-NotificationCenter:        args.push(cmd.icon, quote(image));        break;      case Linux:        args.push(cmd.icon, quote(image));         libnotify defaults to sticky, set a hint for transient notifications        if (!options.sticky) args.push(--hint=int:transient:1);        break;      case Windows:        args.push(cmd.icon + quote(image));        break;    }  }
   sticky  if (options.sticky) args.push(cmd.sticky);
   priority  if (options.priority) {    var priority = options.priority + ;    var checkindexOf = cmd.priority.range.indexOf(priority);    if (~cmd.priority.range.indexOf(priority)) {      args.push(cmd.priority, options.priority);    }  }
  sound  if(options.sound && cmd.type === Darwin-NotificationCenter){    args.push(cmd.sound, options.sound)  }
   name  if (options.name && cmd.type === Darwin-Growl) {    args.push(--name, options.name);  }
  switch(cmd.type) {    case Darwin-Growl:      args.push(cmd.msg);      args.push(quote(msg).replace(ng, ));      if (options.title) args.push(quote(options.title));      break;    case Darwin-NotificationCenter:      args.push(cmd.msg);      var stringifiedMsg = quote(msg);      var escapedMsg = stringifiedMsg.replace(ng, );      args.push(escapedMsg);      if (options.title) {        args.push(cmd.title);        args.push(quote(options.title));      }      if (options.subtitle) {        args.push(cmd.subtitle);        args.push(quote(options.subtitle));      }      if (options.url) {        args.push(cmd.url);        args.push(quote(options.url));      }      break;    case Linux-Growl:      args.push(cmd.msg);      args.push(quote(msg).replace(ng, ));      if (options.title) args.push(quote(options.title));      if (cmd.host) {        args.push(cmd.host.cmd, cmd.host.hostname)      }      break;    case Linux:      if (options.title) {        args.push(quote(options.title));        args.push(cmd.msg);        args.push(quote(msg).replace(ng, ));      } else {        args.push(quote(msg).replace(ng, ));      }      break;    case Windows:      args.push(quote(msg).replace(ng, ));      if (options.title) args.push(cmd.title + quote(options.title));      if (options.url) args.push(cmd.url + quote(options.url));      break;    case Custom:      args[0] = (function(origCommand) {        var message = options.title          ? options.title + :  + msg          : msg;        var command = origCommand.replace(()%sg, $1 + quote(message));        if (command === origCommand) args.push(quote(message));        return command;      })(args[0]);      break;  }
   execute  exec(args.join( ), fn);};
}).call(this,require(_process))},{_process:67,child_process:42,fs:42,os:65,path:42}],50:[function(require,module,exports){exports.read = function (buffer, offset, isLE, mLen, nBytes) {  var e, m  var eLen = nBytes  8 - mLen - 1  var eMax = (1 << eLen) - 1  var eBias = eMax >> 1  var nBits = -7  var i = isLE ? (nBytes - 1) : 0  var d = isLE ? -1 : 1  var s = buffer[offset + i]
  i += d
  e = s & ((1 << (-nBits)) - 1)  s >>= (-nBits)  nBits += eLen  for (; nBits > 0; e = e  256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & ((1 << (-nBits)) - 1)  e >>= (-nBits)  nBits += mLen  for (; nBits > 0; m = m  256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {    e = 1 - eBias  } else if (e === eMax) {    return m ? NaN : ((s ? -1 : 1)  Infinity)  } else {    m = m + Math.pow(2, mLen)    e = e - eBias  }  return (s ? -1 : 1)  m  Math.pow(2, e - mLen)}
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {  var e, m, c  var eLen = nBytes  8 - mLen - 1  var eMax = (1 << eLen) - 1  var eBias = eMax >> 1  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)  var i = isLE ? 0 : (nBytes - 1)  var d = isLE ? 1 : -1  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
  value = Math.abs(value)
  if (isNaN(value) || value === Infinity) {    m = isNaN(value) ? 1 : 0    e = eMax  } else {    e = Math.floor(Math.log(value) / Math.LN2)    if (value  (c = Math.pow(2, -e)) < 1) {      e--      c  2    }    if (e + eBias >= 1) {      value += rt / c    } else {      value += rt  Math.pow(2, 1 - eBias)    }    if (value  c >= 2) {      e++      c /= 2    }
    if (e + eBias >= eMax) {      m = 0      e = eMax    } else if (e + eBias >= 1) {      m = (value  c - 1)  Math.pow(2, mLen)      e = e + eBias    } else {      m = value  Math.pow(2, eBias - 1)  Math.pow(2, mLen)      e = 0    }  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = (e << mLen) | m  eLen += mLen  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s  128}
},{}],51:[function(require,module,exports){if (typeof Object.create === function) {   implementation from standard node.js 'util' module  module.exports = function inherits(ctor, superCtor) {    ctor.super_ = superCtor    ctor.prototype = Object.create(superCtor.prototype, {      constructor: {        value: ctor,        enumerable: false,        writable: true,        configurable: true      }    });  };} else {   old school shim for old browsers  module.exports = function inherits(ctor, superCtor) {    ctor.super_ = superCtor    var TempCtor = function () {}    TempCtor.prototype = superCtor.prototype    ctor.prototype = new TempCtor()    ctor.prototype.constructor = ctor  }}
},{}],52:[function(require,module,exports){ * Determine if an object is a Buffer * * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license  MIT */
 The _isBuffer check is for Safari 5-7 support, because it's missing Object.prototype.constructor. Remove this eventuallymodule.exports = function (obj) {  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)}
function isBuffer (obj) {  return !!obj.constructor && typeof obj.constructor.isBuffer === function && obj.constructor.isBuffer(obj)}
 For Node v0.10 support. Remove this eventually.function isSlowBuffer (obj) {  return typeof obj.readFloatLE === function && typeof obj.slice === function && isBuffer(obj.slice(0, 0))}
},{}],53:[function(require,module,exports){var toString = {}.toString;
module.exports = Array.isArray || function (arr) {  return toString.call(arr) == [object Array];};
},{}],54:[function(require,module,exports){(function (global){;(function () {   Detect the `define` function exposed by asynchronous module loaders. The   strict `define` check is necessary for compatibility with `r.js`.  var isLoader = false;
   A set of types used to distinguish objects from primitives.  var objectTypes = {    function: true,    object: true  };
   Detect the `exports` object exposed by CommonJS implementations.  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
   Use the `global` object exposed by Node (including Browserify via   `insert-module-globals`), Narwhal, and Ringo as the default context,   and the `window` object in browsers. Rhino exports a `global` function   instead.  var root = objectTypes[typeof window] && window || this,      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == object && global;
  if (freeGlobal && (freeGlobal[global] === freeGlobal || freeGlobal[window] === freeGlobal || freeGlobal[self] === freeGlobal)) {    root = freeGlobal;  }
   Public: Initializes JSON 3 using the given `context` object, attaching the   `stringify` and `parse` functions to the specified `exports` object.  function runInContext(context, exports) {    context || (context = root[Object]());    exports || (exports = root[Object]());
     Native constructor aliases.    var Number = context[Number] || root[Number],        String = context[String] || root[String],        Object = context[Object] || root[Object],        Date = context[Date] || root[Date],        SyntaxError = context[SyntaxError] || root[SyntaxError],        TypeError = context[TypeError] || root[TypeError],        Math = context[Math] || root[Math],        nativeJSON = context[JSON] || root[JSON];
     Delegate to the native `stringify` and `parse` implementations.    if (typeof nativeJSON == object && nativeJSON) {      exports.stringify = nativeJSON.stringify;      exports.parse = nativeJSON.parse;    }
     Convenience aliases.    var objectProto = Object.prototype,        getClass = objectProto.toString,        isProperty, forEach, undef;
     Test the `Date#getUTC*` methods. Based on work by @Yaffle.    var isExtended = new Date(-3509827334573292);    try {       The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical       results for certain dates in Opera >= 10.53.      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&         Safari < 2.0.2 stores the internal millisecond time value correctly,         but clips the values returned by the date methods to the range of         signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;    } catch (exception) {}
     Internal: Determines whether the native `JSON.stringify` and `parse`     implementations are spec-compliant. Based on work by Ken Snyder.    function has(name) {      if (has[name] !== undef) {         Return cached feature test result.        return has[name];      }      var isSupported;      if (name == bug-string-char-index) {         IE <= 7 doesn't support accessing string characters using square         bracket notation. IE 8 only supports this for primitives.        isSupported = a[0] != a;      } else if (name == json) {         Indicates whether both `JSON.stringify` and `JSON.parse` are         supported.        isSupported = has(json-stringify) && has(json-parse);      } else {        var value, serialized = {""a"":[1,true,false,null,""u0000bnfrt""]};         Test `JSON.stringify`.        if (name == json-stringify) {          var stringify = exports.stringify, stringifySupported = typeof stringify == function && isExtended;          if (stringifySupported) {             A test function object with a custom `toJSON` method.            (value = function () {              return 1;            }).toJSON = value;            try {              stringifySupported =                 Firefox 3.1b1 and b2 serialize string, number, and boolean                 primitives as object literals.                stringify(0) === 0 &&                 FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object                 literals.                stringify(new Number()) === 0 &&                stringify(new String()) == """" &&                 FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or                 does not define a canonical JSON representation (this applies to                 objects with `toJSON` properties as well, *unless* they are nested                 within an object or array).                stringify(getClass) === undef &&                 IE 8 serializes `undefined` as `""undefined""`. Safari <= 5.1.7 and                 FF 3.1b3 pass this test.                stringify(undef) === undef &&                 Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,                 respectively, if the value is omitted entirely.                stringify() === undef &&                 FF 3.1b1, 2 throw an error if the given value is not a number,                 string, array, object, Boolean, or `null` literal. This applies to                 objects with custom `toJSON` methods as well, unless they are nested                 inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`                 methods entirely.                stringify(value) === 1 &&                stringify([value]) == [1] &&                 Prototype <= 1.6.1 serializes `[undefined]` as `""[]""` instead of                 `""[null]""`.                stringify([undef]) == [null] &&                 YUI 3.0.0b1 fails to serialize `null` literals.                stringify(null) == null &&                 FF 3.1b1, 2 halts serialization if an array contains a function:                 `[1, true, getClass, 1]` serializes as ""[1,true,],"". FF 3.1b3                 elides non-JSON values from objects and arrays, unless they                 define custom `toJSON` methods.                stringify([undef, getClass, null]) == [null,null,null] &&                 Simple serialization test. FF 3.1b1 uses Unicode escape sequences                 where character escape codes are expected (e.g., `\b` => `\u0008`).                stringify({ a: [value, true, false, null, 00] }) == serialized &&                 FF 3.1b1 and b2 ignore the `filter` and `width` arguments.                stringify(null, value) === 1 &&                stringify([1, 2], null, 1) == [ 1, 2] &&                 JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly                 serialize extended years.                stringify(new Date(-8.64e15)) == ""-271821-04-20T00:00:00.000Z"" &&                 The milliseconds are optional in ES 5, but required in 5.1.                stringify(new Date(8.64e15)) == ""+275760-09-13T00:00:00.000Z"" &&                 Firefox <= 11.0 incorrectly serializes years prior to 0 as negative                 four-digit years instead of six-digit years. Credits: @Yaffle.                stringify(new Date(-621987552e5)) == ""-000001-01-01T00:00:00.000Z"" &&                 Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond                 values less than 1000. Credits: @Yaffle.                stringify(new Date(-1)) == ""1969-12-31T23:59:59.999Z"";            } catch (exception) {              stringifySupported = false;            }          }          isSupported = stringifySupported;        }         Test `JSON.parse`.        if (name == json-parse) {          var parse = exports.parse;          if (typeof parse == function) {            try {               FF 3.1b1, b2 will throw an exception if a bare literal is provided.               Conforming implementations should also coerce the initial argument to               a string prior to parsing.              if (parse(0) === 0 && !parse(false)) {                 Simple parsing test.                value = parse(serialized);                var parseSupported = value[a].length == 5 && value[a][0] === 1;                if (parseSupported) {                  try {                     Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.                    parseSupported = !parse("""");                  } catch (exception) {}                  if (parseSupported) {                    try {                       FF 4.0 and 4.0.1 allow leading `+` signs and leading                       decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow                       certain octal literals.                      parseSupported = parse(01) !== 1;                    } catch (exception) {}                  }                  if (parseSupported) {                    try {                       FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal                       points. These environments, along with FF 3.1b1 and 2,                       also allow trailing commas in JSON objects and arrays.                      parseSupported = parse(1.) !== 1;                    } catch (exception) {}                  }                }              }            } catch (exception) {              parseSupported = false;            }          }          isSupported = parseSupported;        }      }      return has[name] = !!isSupported;    }
    if (!has(json)) {       Common `[[Class]]` name aliases.      var functionClass = [object Function],          dateClass = [object Date],          numberClass = [object Number],          stringClass = [object String],          arrayClass = [object Array],          booleanClass = [object Boolean];
       Detect incomplete support for accessing string characters by index.      var charIndexBuggy = has(bug-string-char-index);
       Define additional utility methods if the `Date` methods are buggy.      if (!isExtended) {        var floor = Math.floor;         A mapping between the months of the year and the number of days between         January 1st and the first of the respective month.        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];         Internal: Calculates the number of days between the Unix epoch and the         first day of the given month.        var getDay = function (year, month) {          return Months[month] + 365  (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);        };      }
       Internal: Determines if a property is a direct property of the given       object. Delegates to the native `Object#hasOwnProperty` method.      if (!(isProperty = objectProto.hasOwnProperty)) {        isProperty = function (property) {          var members = {}, constructor;          if ((members.__proto__ = null, members.__proto__ = {             The *proto* property cannot be set multiple times in recent             versions of Firefox and SeaMonkey.            toString: 1          }, members).toString != getClass) {             Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but             supports the mutable *proto* property.            isProperty = function (property) {               Capture and break the object's prototype chain (see section 8.6.2               of the ES 5.1 spec). The parenthesized expression prevents an               unsafe transformation by the Closure Compiler.              var original = this.__proto__, result = property in (this.__proto__ = null, this);               Restore the original prototype chain.              this.__proto__ = original;              return result;            };          } else {             Capture a reference to the top-level `Object` constructor.            constructor = members.constructor;             Use the `constructor` property to simulate `Object#hasOwnProperty` in             other environments.            isProperty = function (property) {              var parent = (this.constructor || constructor).prototype;              return property in this && !(property in parent && this[property] === parent[property]);            };          }          members = null;          return isProperty.call(this, property);        };      }
       Internal: Normalizes the `for...in` iteration algorithm across       environments. Each enumerated key is yielded to a `callback` function.      forEach = function (object, callback) {        var size = 0, Properties, members, property;
         Tests for bugs in the current environment's `for...in` algorithm. The         `valueOf` property inherits the non-enumerable flag from         `Object.prototype` in older versions of IE, Netscape, and Mozilla.        (Properties = function () {          this.valueOf = 0;        }).prototype.valueOf = 0;
         Iterate over a new instance of the `Properties` class.        members = new Properties();        for (property in members) {           Ignore all properties inherited from `Object.prototype`.          if (isProperty.call(members, property)) {            size++;          }        }        Properties = members = null;
         Normalize the iteration algorithm.        if (!size) {           A list of non-enumerable properties inherited from `Object.prototype`.          members = [valueOf, toString, toLocaleString, propertyIsEnumerable, isPrototypeOf, hasOwnProperty, constructor];           IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable           properties.          forEach = function (object, callback) {            var isFunction = getClass.call(object) == functionClass, property, length;            var hasProperty = !isFunction && typeof object.constructor != function && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;            for (property in object) {               Gecko <= 1.0 enumerates the `prototype` property of functions under               certain conditions; IE does not.              if (!(isFunction && property == prototype) && hasProperty.call(object, property)) {                callback(property);              }            }             Manually invoke the callback for each non-enumerable property.            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));          };        } else if (size == 2) {           Safari <= 2.0.4 enumerates shadowed properties twice.          forEach = function (object, callback) {             Create a set of iterated properties.            var members = {}, isFunction = getClass.call(object) == functionClass, property;            for (property in object) {               Store each property name to prevent double enumeration. The               `prototype` property of functions is not enumerated due to cross-               environment inconsistencies.              if (!(isFunction && property == prototype) && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {                callback(property);              }            }          };        } else {           No bugs detected; use the standard `for...in` algorithm.          forEach = function (object, callback) {            var isFunction = getClass.call(object) == functionClass, property, isConstructor;            for (property in object) {              if (!(isFunction && property == prototype) && isProperty.call(object, property) && !(isConstructor = property === constructor)) {                callback(property);              }            }             Manually invoke the callback for the `constructor` property due to             cross-environment inconsistencies.            if (isConstructor || isProperty.call(object, (property = constructor))) {              callback(property);            }          };        }        return forEach(object, callback);      };
       Public: Serializes a JavaScript `value` as a JSON string. The optional       `filter` argument may specify either a function that alters how object and       array members are serialized, or an array of strings and numbers that       indicates which properties should be serialized. The optional `width`       argument may be either a string or number that specifies the indentation       level of the output.      if (!has(json-stringify)) {         Internal: A map of control characters and their escaped equivalents.        var Escapes = {          92: ,          34: "",          8: b,          12: f,          10: n,          13: r,          9: t        };
         Internal: Converts `value` into a zero-padded string such that its         length is at least equal to `width`. The `width` must be <= 6.        var leadingZeroes = 000000;        var toPaddedString = function (width, value) {           The `|| 0` expression is necessary to work around a bug in           Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== ""0""`.          return (leadingZeroes + (value || 0)).slice(-width);        };
         Internal: Double-quotes a string `value`, replacing all ASCII control         characters (characters with code unit values between 0 and 31) with         their escaped equivalents. This is an implementation of the         `Quote(value)` operation defined in ES 5.1 section 15.12.3.        var unicodePrefix = u00;        var quote = function (value) {          var result = "", index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;          var symbols = useCharIndex && (charIndexBuggy ? value.split() : value);          for (; index < length; index++) {            var charCode = value.charCodeAt(index);             If the character is a control character, append its Unicode or             shorthand escape sequence; otherwise, append the character as-is.            switch (charCode) {              case 8: case 9: case 10: case 12: case 13: case 34: case 92:                result += Escapes[charCode];                break;              default:                if (charCode < 32) {                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));                  break;                }                result += useCharIndex ? symbols[index] : value.charAt(index);            }          }          return result + "";        };
         Internal: Recursively serializes an object. Implements the         `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;          try {             Necessary for host object support.            value = object[property];          } catch (exception) {}          if (typeof value == object && value) {            className = getClass.call(value);            if (className == dateClass && !isProperty.call(value, toJSON)) {              if (value > -1 / 0 && value < 1 / 0) {                 Dates are serialized according to the `Date#toJSON` method                 specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15                 for the ISO 8601 date time string format.                if (getDay) {                   Manually compute the year, month, date, hours, minutes,                   seconds, and milliseconds if the `getUTC*` methods are                   buggy. Adapted from @Yaffle's `date-shim` project.                  date = floor(value / 864e5);                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);                  date = 1 + date - getDay(year, month);                   The `time` value specifies the time within the day (see ES                   5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used                   to compute `A modulo B`, as the `%` operator does not                   correspond to the `modulo` operation for negative numbers.                  time = (value % 864e5 + 864e5) % 864e5;                   The hours, minutes, seconds, and milliseconds are obtained by                   decomposing the time within the day. See section 15.9.1.10.                  hours = floor(time / 36e5) % 24;                  minutes = floor(time / 6e4) % 60;                  seconds = floor(time / 1e3) % 60;                  milliseconds = time % 1e3;                } else {                  year = value.getUTCFullYear();                  month = value.getUTCMonth();                  date = value.getUTCDate();                  hours = value.getUTCHours();                  minutes = value.getUTCMinutes();                  seconds = value.getUTCSeconds();                  milliseconds = value.getUTCMilliseconds();                }                 Serialize extended years correctly.                value = (year <= 0 || year >= 1e4 ? (year < 0 ? - : +) + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +                  - + toPaddedString(2, month + 1) + - + toPaddedString(2, date) +                   Months, dates, hours, minutes, and seconds should have two                   digits; milliseconds should have three.                  T + toPaddedString(2, hours) + : + toPaddedString(2, minutes) + : + toPaddedString(2, seconds) +                   Milliseconds are optional in ES 5.0, but required in 5.1.                  . + toPaddedString(3, milliseconds) + Z;              } else {                value = null;              }            } else if (typeof value.toJSON == function && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, toJSON))) {               Prototype <= 1.6.1 adds non-standard `toJSON` methods to the               `Number`, `String`, `Date`, and `Array` prototypes. JSON 3               ignores all `toJSON` methods on these objects unless they are               defined directly on an instance.              value = value.toJSON(property);            }          }          if (callback) {             If a replacement function was provided, call it to obtain the value             for serialization.            value = callback.call(object, property, value);          }          if (value === null) {            return null;          }          className = getClass.call(value);          if (className == booleanClass) {             Booleans are represented literally.            return  + value;          } else if (className == numberClass) {             JSON numbers must be finite. `Infinity` and `NaN` are serialized as             `""null""`.            return value > -1 / 0 && value < 1 / 0 ?  + value : null;          } else if (className == stringClass) {             Strings are double-quoted and escaped.            return quote( + value);          }           Recursively serialize objects and arrays.          if (typeof value == object) {             Check for cyclic structures. This is a linear search; performance             is inversely proportional to the number of unique nested objects.            for (length = stack.length; length--;) {              if (stack[length] === value) {                 Cyclic structures cannot be serialized by `JSON.stringify`.                throw TypeError();              }            }             Add the object to the stack of traversed objects.            stack.push(value);            results = [];             Save the current indentation level and indent one additional level.            prefix = indentation;            indentation += whitespace;            if (className == arrayClass) {               Recursively serialize array elements.              for (index = 0, length = value.length; index < length; index++) {                element = serialize(index, value, callback, properties, whitespace, indentation, stack);                results.push(element === undef ? null : element);              }              result = results.length ? (whitespace ? [ + indentation + results.join(, + indentation) +  + prefix + ] : ([ + results.join(,) + ])) : [];            } else {               Recursively serialize object members. Members are selected from               either a user-specified list of property names, or the object               itself.              forEach(properties || value, function (property) {                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);                if (element !== undef) {                   According to ES 5.1 section 15.12.3: ""If `gap` {whitespace}                   is not the empty string, let `member` {quote(property) + "":""}                   be the concatenation of `member` and the `space` character.""                   The ""`space` character"" refers to the literal space                   character, not the `space` {width} argument provided to                   `JSON.stringify`.                  results.push(quote(property) + : + (whitespace ?   : ) + element);                }              });              result = results.length ? (whitespace ? { + indentation + results.join(, + indentation) +  + prefix + } : ({ + results.join(,) + })) : {};            }             Remove the object from the traversed object stack.            stack.pop();            return result;          }        };
         Public: `JSON.stringify`. See ES 5.1 section 15.12.3.        exports.stringify = function (source, filter, width) {          var whitespace, callback, properties, className;          if (objectTypes[typeof filter] && filter) {            if ((className = getClass.call(filter)) == functionClass) {              callback = filter;            } else if (className == arrayClass) {               Convert the property names array into a makeshift set.              properties = {};              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));            }          }          if (width) {            if ((className = getClass.call(width)) == numberClass) {               Convert the `width` to an integer and create a string containing               `width` number of space characters.              if ((width -= width % 1) > 0) {                for (whitespace = , width > 10 && (width = 10); whitespace.length < width; whitespace +=  );              }            } else if (className == stringClass) {              whitespace = width.length <= 10 ? width : width.slice(0, 10);            }          }           Opera <= 7.54u2 discards the values associated with empty string keys           (`""""`) only if they are used directly within an object member list           (e.g., `!("""" in { """": 1})`).          return serialize(, (value = {}, value[] = source, value), callback, properties, whitespace, , []);        };      }
       Public: Parses a JSON source string.      if (!has(json-parse)) {        var fromCharCode = String.fromCharCode;
         Internal: A map of escaped control characters and their unescaped         equivalents.        var Unescapes = {          92: ,          34: "",          47: /,          98: ,          116: ,          110: ,          102: ,          114:         };
         Internal: Stores the parser state.        var Index, Source;
         Internal: Resets the parser state and throws a `SyntaxError`.        var abort = function () {          Index = Source = null;          throw SyntaxError();        };
         Internal: Returns the next token, or `""$""` if the parser has reached         the end of the source string. A token may be a string, number, `null`         literal, or Boolean literal.        var lex = function () {          var source = Source, length = source.length, value, begin, position, isSigned, charCode;          while (Index < length) {            charCode = source.charCodeAt(Index);            switch (charCode) {              case 9: case 10: case 13: case 32:                 Skip whitespace tokens, including tabs, carriage returns, line                 feeds, and space characters.                Index++;                break;              case 123: case 125: case 91: case 93: case 58: case 44:                 Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at                 the current position.                value = charIndexBuggy ? source.charAt(Index) : source[Index];                Index++;                return value;              case 34:                 `""` delimits a JSON string; advance to the next character and                 begin parsing the string. String tokens are prefixed with the                 sentinel `@` character to distinguish them from punctuators and                 end-of-string tokens.                for (value = @, Index++; Index < length;) {                  charCode = source.charCodeAt(Index);                  if (charCode < 32) {                     Unescaped ASCII control characters (those with a code unit                     less than the space character) are not permitted.                    abort();                  } else if (charCode == 92) {                     A reverse solidus (`\`) marks the beginning of an escaped                     control character (including `""`, `\`, and `/`) or Unicode                     escape sequence.                    charCode = source.charCodeAt(++Index);                    switch (charCode) {                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:                         Revive escaped control characters.                        value += Unescapes[charCode];                        Index++;                        break;                      case 117:                         `\u` marks the beginning of a Unicode escape sequence.                         Advance to the first character and validate the                         four-digit code point.                        begin = ++Index;                        for (position = Index + 4; Index < position; Index++) {                          charCode = source.charCodeAt(Index);                           A valid sequence comprises four hexdigits (case-                           insensitive) that form a single hexadecimal value.                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {                             Invalid Unicode escape sequence.                            abort();                          }                        }                         Revive the escaped character.                        value += fromCharCode(0x + source.slice(begin, Index));                        break;                      default:                         Invalid escape sequence.                        abort();                    }                  } else {                    if (charCode == 34) {                       An unescaped double-quote character marks the end of the                       string.                      break;                    }                    charCode = source.charCodeAt(Index);                    begin = Index;                     Optimize for the common case where a string is valid.                    while (charCode >= 32 && charCode != 92 && charCode != 34) {                      charCode = source.charCodeAt(++Index);                    }                     Append the string as-is.                    value += source.slice(begin, Index);                  }                }                if (source.charCodeAt(Index) == 34) {                   Advance to the next character and return the revived string.                  Index++;                  return value;                }                 Unterminated string.                abort();              default:                 Parse numbers and literals.                begin = Index;                 Advance past the negative sign, if one is specified.                if (charCode == 45) {                  isSigned = true;                  charCode = source.charCodeAt(++Index);                }                 Parse an integer or floating-point value.                if (charCode >= 48 && charCode <= 57) {                   Leading zeroes are interpreted as octal literals.                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {                     Illegal octal literal.                    abort();                  }                  isSigned = false;                   Parse the integer component.                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);                   Floats cannot contain a leading decimal point; however, this                   case is already accounted for by the parser.                  if (source.charCodeAt(Index) == 46) {                    position = ++Index;                     Parse the decimal component.                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);                    if (position == Index) {                       Illegal trailing decimal.                      abort();                    }                    Index = position;                  }                   Parse exponents. The `e` denoting the exponent is                   case-insensitive.                  charCode = source.charCodeAt(Index);                  if (charCode == 101 || charCode == 69) {                    charCode = source.charCodeAt(++Index);                     Skip past the sign following the exponent, if one is                     specified.                    if (charCode == 43 || charCode == 45) {                      Index++;                    }                     Parse the exponential component.                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);                    if (position == Index) {                       Illegal empty exponent.                      abort();                    }                    Index = position;                  }                   Coerce the parsed value to a JavaScript number.                  return +source.slice(begin, Index);                }                 A negative sign may only precede numbers.                if (isSigned) {                  abort();                }                 `true`, `false`, and `null` literals.                if (source.slice(Index, Index + 4) == true) {                  Index += 4;                  return true;                } else if (source.slice(Index, Index + 5) == false) {                  Index += 5;                  return false;                } else if (source.slice(Index, Index + 4) == null) {                  Index += 4;                  return null;                }                 Unrecognized token.                abort();            }          }           Return the sentinel `$` character if the parser has reached the end           of the source string.          return $;        };
         Internal: Parses a JSON `value` token.        var get = function (value) {          var results, hasMembers;          if (value == $) {             Unexpected end of input.            abort();          }          if (typeof value == string) {            if ((charIndexBuggy ? value.charAt(0) : value[0]) == @) {               Remove the sentinel `@` character.              return value.slice(1);            }             Parse object and array literals.            if (value == [) {               Parses a JSON array, returning a new JavaScript array.              results = [];              for (;; hasMembers || (hasMembers = true)) {                value = lex();                 A closing square bracket marks the end of the array literal.                if (value == ]) {                  break;                }                 If the array literal contains elements, the current token                 should be a comma separating the previous element from the                 next.                if (hasMembers) {                  if (value == ,) {                    value = lex();                    if (value == ]) {                       Unexpected trailing `,` in array literal.                      abort();                    }                  } else {                     A `,` must separate each array element.                    abort();                  }                }                 Elisions and leading commas are not permitted.                if (value == ,) {                  abort();                }                results.push(get(value));              }              return results;            } else if (value == {) {               Parses a JSON object, returning a new JavaScript object.              results = {};              for (;; hasMembers || (hasMembers = true)) {                value = lex();                 A closing curly brace marks the end of the object literal.                if (value == }) {                  break;                }                 If the object literal contains members, the current token                 should be a comma separator.                if (hasMembers) {                  if (value == ,) {                    value = lex();                    if (value == }) {                       Unexpected trailing `,` in object literal.                      abort();                    }                  } else {                     A `,` must separate each object member.                    abort();                  }                }                 Leading commas are not permitted, object property names must be                 double-quoted strings, and a `:` must separate each property                 name and value.                if (value == , || typeof value != string || (charIndexBuggy ? value.charAt(0) : value[0]) != @ || lex() != :) {                  abort();                }                results[value.slice(1)] = get(lex());              }              return results;            }             Unexpected token encountered.            abort();          }          return value;        };
         Internal: Updates a traversed object member.        var update = function (source, property, callback) {          var element = walk(source, property, callback);          if (element === undef) {            delete source[property];          } else {            source[property] = element;          }        };
         Internal: Recursively traverses a parsed JSON object, invoking the         `callback` function for each value. This is an implementation of the         `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.        var walk = function (source, property, callback) {          var value = source[property], length;          if (typeof value == object && value) {             `forEach` can't be used to traverse an array in Opera <= 8.54             because its `Object#hasOwnProperty` implementation returns `false`             for array indices (e.g., `![1, 2, 3].hasOwnProperty(""0"")`).            if (getClass.call(value) == arrayClass) {              for (length = value.length; length--;) {                update(value, length, callback);              }            } else {              forEach(value, function (property) {                update(value, property, callback);              });            }          }          return callback.call(source, property, value);        };
         Public: `JSON.parse`. See ES 5.1 section 15.12.2.        exports.parse = function (source, callback) {          var result, value;          Index = 0;          Source =  + source;          result = get(lex());           If a JSON string contains multiple tokens, it is invalid.          if (lex() != $) {            abort();          }           Reset the parser state.          Index = Source = null;          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[] = result, value), , callback) : result;        };      }    }
    exports[runInContext] = runInContext;    return exports;  }
  if (freeExports && !isLoader) {     Export for CommonJS environments.    runInContext(root, freeExports);  } else {     Export for web browsers and JavaScript engines.    var nativeJSON = root.JSON,        previousJSON = root[JSON3],        isRestored = false;
    var JSON3 = runInContext(root, (root[JSON3] = {       Public: Restores the original value of the global `JSON` object and       returns a reference to the `JSON3` object.      : function () {        if (!isRestored) {          isRestored = true;          root.JSON = nativeJSON;          root[JSON3] = previousJSON;          nativeJSON = previousJSON = null;        }        return JSON3;      }    }));
    root.JSON = {      parse: JSON3.parse,      stringify: JSON3.stringify    };  }
   Export for asynchronous module loaders.  if (isLoader) {    define(function () {      return JSON3;    });  }}).call(this);
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{}],55:[function(require,module,exports){ * lodash 3.2.0 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */var baseCopy = require(lodash._basecopy),    keys = require(lodash.keys);
 * The base implementation of `_.assign` without support for argument juggling, * multiple sources, and `customizer` functions. * *  *    The destination object. *    The source object. *   Returns `object`. */function baseAssign(object, source) {  return source == null    ? object    : baseCopy(source, keys(source), object);}
module.exports = baseAssign;
},{lodash._basecopy:56,lodash.keys:63}],56:[function(require,module,exports){ * lodash 3.0.1 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
 * Copies properties of `source` to `object`. * *  *    The object to copy properties from. *    The property names to copy. *    The object to copy properties to. *   Returns `object`. */function baseCopy(source, props, object) {  object || (object = {});
  var index = -1,      length = props.length;
  while (++index < length) {    var key = props[index];    object[key] = source[key];  }  return object;}
module.exports = baseCopy;
},{}],57:[function(require,module,exports){ * lodash 3.0.3 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
 * The base implementation of `_.create` without support for assigning * properties to the created object. * *  *    The object to inherit from. *   Returns the new object. */var baseCreate = (function() {  function object() {}  return function(prototype) {    if (isObject(prototype)) {      object.prototype = prototype;      var result = new object;      object.prototype = undefined;    }    return result || {};  };}());
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
module.exports = baseCreate;
},{}],58:[function(require,module,exports){ * lodash 3.9.1 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
var funcTag = [object Function];
var reIsHostCtor = object Constructor;
 * Checks if `value` is object-like. * *  *    The value to check. *   Returns `true` if `value` is object-like, else `false`. */function isObjectLike(value) {  return !!value && typeof value == object;}
var objectProto = Object.prototype;
var fnToString = Function.prototype.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring) * of values. */var objToString = objectProto.toString;
var reIsNative = RegExp(^ +  fnToString.call(hasOwnProperty).replace(g, $&)  .replace(hasOwnProperty(function)(?=) for (?=)g, $1.*?) + $);
 * Gets the native function at `key` of `object`. * *  *    The object to query. *    The key of the method to get. *   Returns the function if it's native, else `undefined`. */function getNative(object, key) {  var value = object == null ? undefined : object[key];  return isNative(value) ? value : undefined;}
 * Checks if `value` is classified as a `Function` object. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is correctly classified, else `false`. *  * *  *  * *  *  */function isFunction(value) {   The use of `Object#toString` avoids issues with the `typeof` operator   in older versions of Chrome and Safari which return 'function' for regexes   and Safari 8 equivalents which return 'object' for typed array constructors.  return isObject(value) && objToString.call(value) == funcTag;}
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
 * Checks if `value` is a native function. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is a native function, else `false`. *  * *  *  * *  *  */function isNative(value) {  if (value == null) {    return false;  }  if (isFunction(value)) {    return reIsNative.test(fnToString.call(value));  }  return isObjectLike(value) && reIsHostCtor.test(value);}
module.exports = getNative;
},{}],59:[function(require,module,exports){ * lodash 3.0.9 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
var reIsUint = ;
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer) * of an array-like value. */var MAX_SAFE_INTEGER = 9007199254740991;
 * The base implementation of `_.property` without support for deep paths. * *  *    The key of the property to get. *   Returns the new function. */function baseProperty(key) {  return function(object) {    return object == null ? undefined : object[key];  };}
 * Gets the ""length"" property value of `object`. * * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) * that affects Safari on at least iOS 8.1-8.3 ARM64. * *  *    The object to query. *   Returns the ""length"" value. */var getLength = baseProperty(length);
 * Checks if `value` is array-like. * *  *    The value to check. *   Returns `true` if `value` is array-like, else `false`. */function isArrayLike(value) {  return value != null && isLength(getLength(value));}
 * Checks if `value` is a valid array-like index. * *  *    The value to check. *    The upper bounds of a valid index. *   Returns `true` if `value` is a valid index, else `false`. */function isIndex(value, length) {  value = (typeof value == number || reIsUint.test(value)) ? +value : -1;  length = length == null ? MAX_SAFE_INTEGER : length;  return value > -1 && value % 1 == 0 && value < length;}
 * Checks if the provided arguments are from an iteratee call. * *  *    The potential iteratee value argument. *    The potential iteratee index or key argument. *    The potential iteratee object argument. *   Returns `true` if the arguments are from an iteratee call, else `false`. */function isIterateeCall(value, index, object) {  if (!isObject(object)) {    return false;  }  var type = typeof index;  if (type == number      ? (isArrayLike(object) && isIndex(index, object.length))      : (type == string && index in object)) {    var other = object[index];    return value === value ? (value === other) : (other !== other);  }  return false;}
 * Checks if `value` is a valid array-like length. * * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength). * *  *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. */function isLength(value) {  return typeof value == number && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
module.exports = isIterateeCall;
},{}],60:[function(require,module,exports){ * lodash 3.1.1 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */var baseAssign = require(lodash._baseassign),    baseCreate = require(lodash._basecreate),    isIterateeCall = require(lodash._isiterateecall);
 * Creates an object that inherits from the given `prototype` object. If a * `properties` object is provided its own enumerable properties are assigned * to the created object. * *  * @memberOf _ * @category Object *    The object to inherit from. *    The properties to assign to the object. * - {Object} [guard] Enables use as a callback for functions like `_.map`. *   Returns the new object. *  * *  *    *    *  * *  *    *  * *  *    *  * *  *  *  * *  *  */function create(prototype, properties, guard) {  var result = baseCreate(prototype);  if (guard && isIterateeCall(prototype, properties, guard)) {    properties = undefined;  }  return properties ? baseAssign(result, properties) : result;}
module.exports = create;
},{lodash._baseassign:55,lodash._basecreate:57,lodash._isiterateecall:59}],61:[function(require,module,exports){ * lodash (Custom Build) <https://lodash.com/> * Build: `lodash modularize exports=""npm"" -o ./` * Copyright jQuery Foundation and other contributors <https://jquery.org/> * Released under MIT license <https://lodash.com/license> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors */
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = [object Arguments],    funcTag = [object Function],    genTag = [object GeneratorFunction];
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
 * Used to resolve the * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring) * of values. */var objectToString = objectProto.toString;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
 * Checks if `value` is likely an `arguments` object. * *  * @memberOf _ *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an `arguments` object, *  else `false`. *  * *  *  * *  *  */function isArguments(value) {   Safari 8.1 makes `arguments.callee` enumerable in strict mode.  return isArrayLikeObject(value) && hasOwnProperty.call(value, callee) &&    (!propertyIsEnumerable.call(value, callee) || objectToString.call(value) == argsTag);}
 * Checks if `value` is array-like. A value is considered array-like if it's * not a function and has a `value.length` that's an integer greater than or * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`. * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is array-like, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isArrayLike(value) {  return value != null && isLength(value.length) && !isFunction(value);}
 * This method is like `_.isArrayLike` except that it also checks if `value` * is an object. * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an array-like object, *  else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isArrayLikeObject(value) {  return isObjectLike(value) && isArrayLike(value);}
 * Checks if `value` is classified as a `Function` object. * *  * @memberOf _ *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a function, else `false`. *  * *  *  * *  *  */function isFunction(value) {   The use of `Object#toString` avoids issues with the `typeof` operator   in Safari 8-9 which returns 'object' for typed array and other constructors.  var tag = isObject(value) ? objectToString.call(value) : ;  return tag == funcTag || tag == genTag;}
 * Checks if `value` is a valid array-like length. * * **Note:** This method is loosely based on * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isLength(value) {  return typeof value == number &&    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
 * Checks if `value` is the * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isObject(value) {  var type = typeof value;  return !!value && (type == object || type == function);}
 * Checks if `value` is object-like. A value is object-like if it's not `null` * and has a `typeof` result of ""object"". * *  * @memberOf _ *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is object-like, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isObjectLike(value) {  return !!value && typeof value == object;}
module.exports = isArguments;
},{}],62:[function(require,module,exports){ * lodash 3.0.4 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */
var arrayTag = [object Array],    funcTag = [object Function];
var reIsHostCtor = object Constructor;
 * Checks if `value` is object-like. * *  *    The value to check. *   Returns `true` if `value` is object-like, else `false`. */function isObjectLike(value) {  return !!value && typeof value == object;}
var objectProto = Object.prototype;
var fnToString = Function.prototype.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring) * of values. */var objToString = objectProto.toString;
var reIsNative = RegExp(^ +  fnToString.call(hasOwnProperty).replace(g, $&)  .replace(hasOwnProperty(function)(?=) for (?=)g, $1.*?) + $);
var nativeIsArray = getNative(Array, isArray);
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer) * of an array-like value. */var MAX_SAFE_INTEGER = 9007199254740991;
 * Gets the native function at `key` of `object`. * *  *    The object to query. *    The key of the method to get. *   Returns the function if it's native, else `undefined`. */function getNative(object, key) {  var value = object == null ? undefined : object[key];  return isNative(value) ? value : undefined;}
 * Checks if `value` is a valid array-like length. * * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength). * *  *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. */function isLength(value) {  return typeof value == number && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
 * Checks if `value` is classified as an `Array` object. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is correctly classified, else `false`. *  * *  *  * *  *  */var isArray = nativeIsArray || function(value) {  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;};
 * Checks if `value` is classified as a `Function` object. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is correctly classified, else `false`. *  * *  *  * *  *  */function isFunction(value) {   The use of `Object#toString` avoids issues with the `typeof` operator   in older versions of Chrome and Safari which return 'function' for regexes   and Safari 8 equivalents which return 'object' for typed array constructors.  return isObject(value) && objToString.call(value) == funcTag;}
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
 * Checks if `value` is a native function. * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is a native function, else `false`. *  * *  *  * *  *  */function isNative(value) {  if (value == null) {    return false;  }  if (isFunction(value)) {    return reIsNative.test(fnToString.call(value));  }  return isObjectLike(value) && reIsHostCtor.test(value);}
module.exports = isArray;
},{}],63:[function(require,module,exports){ * lodash 3.1.2 (Custom Build) <https://lodash.com/> * Build: `lodash modern modularize exports=""npm"" -o ./` * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors * Available under MIT license <https://lodash.com/license> */var getNative = require(lodash._getnative),    isArguments = require(lodash.isarguments),    isArray = require(lodash.isarray);
var reIsUint = ;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeKeys = getNative(Object, keys);
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer) * of an array-like value. */var MAX_SAFE_INTEGER = 9007199254740991;
 * The base implementation of `_.property` without support for deep paths. * *  *    The key of the property to get. *   Returns the new function. */function baseProperty(key) {  return function(object) {    return object == null ? undefined : object[key];  };}
 * Gets the ""length"" property value of `object`. * * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) * that affects Safari on at least iOS 8.1-8.3 ARM64. * *  *    The object to query. *   Returns the ""length"" value. */var getLength = baseProperty(length);
 * Checks if `value` is array-like. * *  *    The value to check. *   Returns `true` if `value` is array-like, else `false`. */function isArrayLike(value) {  return value != null && isLength(getLength(value));}
 * Checks if `value` is a valid array-like index. * *  *    The value to check. *    The upper bounds of a valid index. *   Returns `true` if `value` is a valid index, else `false`. */function isIndex(value, length) {  value = (typeof value == number || reIsUint.test(value)) ? +value : -1;  length = length == null ? MAX_SAFE_INTEGER : length;  return value > -1 && value % 1 == 0 && value < length;}
 * Checks if `value` is a valid array-like length. * * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength). * *  *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. */function isLength(value) {  return typeof value == number && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}
 * A fallback implementation of `Object.keys` which creates an array of the * own enumerable property names of `object`. * *  *    The object to query. *   Returns the array of property names. */function shimKeys(object) {  var props = keysIn(object),      propsLength = props.length,      length = propsLength && object.length;
  var allowIndexes = !!length && isLength(length) &&    (isArray(object) || isArguments(object));
  var index = -1,      result = [];
  while (++index < propsLength) {    var key = props[index];    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {      result.push(key);    }  }  return result;}
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`. * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  * @memberOf _ * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  */function isObject(value) {   Avoid a V8 JIT bug in Chrome 19-20.   See https://code.google.com/p/v8/issues/detail?id=2291 for more details.  var type = typeof value;  return !!value && (type == object || type == function);}
 * Creates an array of the own enumerable property names of `object`. * * **Note:** Non-object values are coerced to objects. See the * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys) * for more details. * *  * @memberOf _ * @category Object *    The object to query. *   Returns the array of property names. *  * *  *    *    *  * *  * *  *  * *  *  */var keys = !nativeKeys ? shimKeys : function(object) {  var Ctor = object == null ? undefined : object.constructor;  if ((typeof Ctor == function && Ctor.prototype === object) ||      (typeof object != function && isArrayLike(object))) {    return shimKeys(object);  }  return isObject(object) ? nativeKeys(object) : [];};
 * Creates an array of the own and inherited enumerable property names of `object`. * * **Note:** Non-object values are coerced to objects. * *  * @memberOf _ * @category Object *    The object to query. *   Returns the array of property names. *  * *  *    *    *  * *  * *  *  */function keysIn(object) {  if (object == null) {    return [];  }  if (!isObject(object)) {    object = Object(object);  }  var length = object.length;  length = (length && isLength(length) &&    (isArray(object) || isArguments(object)) && length) || 0;
  var Ctor = object.constructor,      index = -1,      isProto = typeof Ctor == function && Ctor.prototype === object,      result = Array(length),      skipIndexes = length > 0;
  while (++index < length) {    result[index] = (index + );  }  for (var key in object) {    if (!(skipIndexes && isIndex(key, length)) &&        !(key == constructor && (isProto || !hasOwnProperty.call(object, key)))) {      result.push(key);    }  }  return result;}
module.exports = keys;
},{lodash._getnative:58,lodash.isarguments:61,lodash.isarray:62}],64:[function(require,module,exports){(function (process){var path = require(path);var fs = require(fs);var _0777 = parseInt(0777, 8);
module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP (p, opts, f, made) {    if (typeof opts === function) {        f = opts;        opts = {};    }    else if (!opts || typeof opts !== object) {        opts = { mode: opts };    }        var mode = opts.mode;    var xfs = opts.fs || fs;        if (mode === undefined) {        mode = _0777 & (~process.umask());    }    if (!made) made = null;        var cb = f || function () {};    p = path.resolve(p);        xfs.mkdir(p, mode, function (er) {        if (!er) {            made = made || p;            return cb(null, made);        }        switch (er.code) {            case ENOENT:                mkdirP(path.dirname(p), opts, function (er, made) {                    if (er) cb(er, made);                    else mkdirP(p, opts, cb, made);                });                break;
             In the case of any other error, just see if there's a dir             there already.  If so, then hooray!  If not, then something             is borked.            default:                xfs.stat(p, function (er2, stat) {                     if the stat fails, then that's super weird.                     let the original error be the failure reason.                    if (er2 || !stat.isDirectory()) cb(er, made)                    else cb(null, made);                });                break;        }    });}
mkdirP.sync = function sync (p, opts, made) {    if (!opts || typeof opts !== object) {        opts = { mode: opts };    }        var mode = opts.mode;    var xfs = opts.fs || fs;        if (mode === undefined) {        mode = _0777 & (~process.umask());    }    if (!made) made = null;
    p = path.resolve(p);
    try {        xfs.mkdirSync(p, mode);        made = made || p;    }    catch (err0) {        switch (err0.code) {            case ENOENT :                made = sync(path.dirname(p), opts, made);                sync(p, opts, made);                break;
             In the case of any other error, just see if there's a dir             there already.  If so, then hooray!  If not, then something             is borked.            default:                var stat;                try {                    stat = xfs.statSync(p);                }                catch (err1) {                    throw err0;                }                if (!stat.isDirectory()) throw err0;                break;        }    }
    return made;};
}).call(this,require(_process))},{_process:67,fs:42,path:42}],65:[function(require,module,exports){exports.endianness = function () { return LE };
exports.hostname = function () {    if (typeof location !== undefined) {        return location.hostname    }    else return ;};
exports.loadavg = function () { return [] };
exports.uptime = function () { return 0 };
exports.freemem = function () {    return Number.MAX_VALUE;};
exports.totalmem = function () {    return Number.MAX_VALUE;};
exports.cpus = function () { return [] };
exports.type = function () { return Browser };
exports.release = function () {    if (typeof navigator !== undefined) {        return navigator.appVersion;    }    return ;};
exports.networkInterfaces= exports.getNetworkInterfaces= function () { return {} };
exports.arch = function () { return javascript };
exports.platform = function () { return browser };
exports.tmpdir = exports.tmpDir = function () {    return /tmp;};
exports.EOL = ;
},{}],66:[function(require,module,exports){(function (process){use strict;
if (!process.version ||    process.version.indexOf(v0.) === 0 ||    process.version.indexOf(v1.) === 0 && process.version.indexOf(v1.8.) !== 0) {  module.exports = nextTick;} else {  module.exports = process.nextTick;}
function nextTick(fn, arg1, arg2, arg3) {  if (typeof fn !== function) {    throw new TypeError(""callback"" argument must be a function);  }  var len = arguments.length;  var args, i;  switch (len) {  case 0:  case 1:    return process.nextTick(fn);  case 2:    return process.nextTick(function afterTickOne() {      fn.call(null, arg1);    });  case 3:    return process.nextTick(function afterTickTwo() {      fn.call(null, arg1, arg2);    });  case 4:    return process.nextTick(function afterTickThree() {      fn.call(null, arg1, arg2, arg3);    });  default:    args = new Array(len - 1);    i = 0;    while (i < args.length) {      args[i++] = arguments[i];    }    return process.nextTick(function afterTick() {      fn.apply(null, args);    });  }}
}).call(this,require(_process))},{_process:67}],67:[function(require,module,exports){ shim for using process in browservar process = module.exports = {};
 cached from whatever global is present so that test runners that stub it don't break things.  But we need to wrap it in a try catch in case it is wrapped in strict mode code which doesn't define any globals.  It's inside a function because try/catches deoptimize in certain engines.
var cachedSetTimeout;var cachedClearTimeout;
function defaultSetTimout() {    throw new Error(setTimeout has not been defined);}function defaultClearTimeout () {    throw new Error(clearTimeout has not been defined);}(function () {    try {        if (typeof setTimeout === function) {            cachedSetTimeout = setTimeout;        } else {            cachedSetTimeout = defaultSetTimout;        }    } catch (e) {        cachedSetTimeout = defaultSetTimout;    }    try {        if (typeof clearTimeout === function) {            cachedClearTimeout = clearTimeout;        } else {            cachedClearTimeout = defaultClearTimeout;        }    } catch (e) {        cachedClearTimeout = defaultClearTimeout;    }} ())function runTimeout(fun) {    if (cachedSetTimeout === setTimeout) {        normal enviroments in sane situations        return setTimeout(fun, 0);    }     if setTimeout wasn't available but was latter defined    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {        cachedSetTimeout = setTimeout;        return setTimeout(fun, 0);    }    try {         when when somebody has screwed with setTimeout but no I.E. maddness        return cachedSetTimeout(fun, 0);    } catch(e){        try {             When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally            return cachedSetTimeout.call(null, fun, 0);        } catch(e){             same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error            return cachedSetTimeout.call(this, fun, 0);        }    }

}function runClearTimeout(marker) {    if (cachedClearTimeout === clearTimeout) {        normal enviroments in sane situations        return clearTimeout(marker);    }     if clearTimeout wasn't available but was latter defined    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {        cachedClearTimeout = clearTimeout;        return clearTimeout(marker);    }    try {         when when somebody has screwed with setTimeout but no I.E. maddness        return cachedClearTimeout(marker);    } catch (e){        try {             When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally            return cachedClearTimeout.call(null, marker);        } catch (e){             same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.             Some versions of I.E. have different rules for clearTimeout vs setTimeout            return cachedClearTimeout.call(this, marker);        }    }


}var queue = [];var draining = false;var currentQueue;var queueIndex = -1;
function cleanUpNextTick() {    if (!draining || !currentQueue) {        return;    }    draining = false;    if (currentQueue.length) {        queue = currentQueue.concat(queue);    } else {        queueIndex = -1;    }    if (queue.length) {        drainQueue();    }}
function drainQueue() {    if (draining) {        return;    }    var timeout = runTimeout(cleanUpNextTick);    draining = true;
    var len = queue.length;    while(len) {        currentQueue = queue;        queue = [];        while (++queueIndex < len) {            if (currentQueue) {                currentQueue[queueIndex].run();            }        }        queueIndex = -1;        len = queue.length;    }    currentQueue = null;    draining = false;    runClearTimeout(timeout);}
process.nextTick = function (fun) {    var args = new Array(arguments.length - 1);    if (arguments.length > 1) {        for (var i = 1; i < arguments.length; i++) {            args[i - 1] = arguments[i];        }    }    queue.push(new Item(fun, args));    if (queue.length === 1 && !draining) {        runTimeout(drainQueue);    }};
 v8 likes predictible objectsfunction Item(fun, array) {    this.fun = fun;    this.array = array;}Item.prototype.run = function () {    this.fun.apply(null, this.array);};process.title = browser;process.browser = true;process.env = {};process.argv = [];process.version = ;  empty string to avoid regexp issuesprocess.versions = {};
function noop() {}
process.on = noop;process.addListener = noop;process.once = noop;process.off = noop;process.removeListener = noop;process.removeAllListeners = noop;process.emit = noop;
process.binding = function (name) {    throw new Error(process.binding is not supported);};
process.cwd = function () { return / };process.chdir = function (dir) {    throw new Error(process.chdir is not supported);};process.umask = function() { return 0; };
},{}],68:[function(require,module,exports){module.exports = require(./lib/_stream_duplex.js)
},{./lib/_stream_duplex.js:69}],69:[function(require,module,exports){ a duplex stream is just a stream that is both readable and writable. Since JS doesn't have multiple prototypal inheritance, this class prototypally inherits from Readable, and then parasitically from Writable.
use strict;

var objectKeys = Object.keys || function (obj) {  var keys = [];  for (var key in obj) {    keys.push(key);  }return keys;};
module.exports = Duplex;
var processNextTick = require(process-nextick-args);
var util = require(core-util-is);util.inherits = require(inherits);
var Readable = require(./_stream_readable);var Writable = require(./_stream_writable);
util.inherits(Duplex, Readable);
var keys = objectKeys(Writable.prototype);for (var v = 0; v < keys.length; v++) {  var method = keys[v];  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];}
function Duplex(options) {  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once(end, onend);}
 the no-half-open enforcerfunction onend() {   if we allow half-open state, or if the writable side ended,   then we're ok.  if (this.allowHalfOpen || this._writableState.ended) return;
   no more data can be written.   But allow more writes to happen in this tick.  processNextTick(onEndNT, this);}
function onEndNT(self) {  self.end();}
function forEach(xs, f) {  for (var i = 0, l = xs.length; i < l; i++) {    f(xs[i], i);  }}},{./_stream_readable:71,./_stream_writable:73,core-util-is:45,inherits:51,process-nextick-args:66}],70:[function(require,module,exports){ a passthrough stream. basically just the most minimal sort of Transform stream. Every written chunk gets output as-is.
use strict;
module.exports = PassThrough;
var Transform = require(./_stream_transform);
var util = require(core-util-is);util.inherits = require(inherits);
util.inherits(PassThrough, Transform);
function PassThrough(options) {  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);}
PassThrough.prototype._transform = function (chunk, encoding, cb) {  cb(null, chunk);};},{./_stream_transform:72,core-util-is:45,inherits:51}],71:[function(require,module,exports){(function (process){use strict;
module.exports = Readable;
var processNextTick = require(process-nextick-args);
var isArray = require(isarray);
Readable.ReadableState = ReadableState;
var EE = require(events).EventEmitter;
var EElistenerCount = function (emitter, type) {  return emitter.listeners(type).length;};
var Stream;(function () {  try {    Stream = require(st + ream);  } catch (_) {} finally {    if (!Stream) Stream = require(events).EventEmitter;  }})();
var Buffer = require(buffer).Buffer;var bufferShim = require(buffer-shims);
var util = require(core-util-is);util.inherits = require(inherits);
var debugUtil = require(util);var debug = void 0;if (debugUtil && debugUtil.debuglog) {  debug = debugUtil.debuglog(stream);} else {  debug = function () {};}
var BufferList = require(./internal/streams/BufferList);var StringDecoder;
util.inherits(Readable, Stream);
function prependListener(emitter, event, fn) {  if (typeof emitter.prependListener === function) {    return emitter.prependListener(event, fn);  } else {     This is a hack to make sure that our error handler is attached before any     userland ones.  NEVER DO THIS. This is here only because this code needs     to continue to work with older versions of Node.js that do not include     the prependListener() method. The goal is to eventually remove this hack.    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];  }}
var Duplex;function ReadableState(options, stream) {  Duplex = Duplex || require(./_stream_duplex);
  options = options || {};
   object stream flag. Used to make read(n) ignore n and to   make all the buffer merging and length checks go away  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
   the point at which it stops calling _read() to fill the buffer   Note: 0 is a valid value, means ""don't call _read preemptively ever""  var hwm = options.highWaterMark;  var defaultHwm = this.objectMode ? 16 : 16  1024;  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
   cast to ints.  this.highWaterMark = ~ ~this.highWaterMark;
   A linked list is used to store data chunks instead of an array because the   linked list can remove elements from the beginning faster than   array.shift()  this.buffer = new BufferList();  this.length = 0;  this.pipes = null;  this.pipesCount = 0;  this.flowing = null;  this.ended = false;  this.endEmitted = false;  this.reading = false;
   a flag to be able to tell if the onwrite cb is called immediately,   or on a later tick.  We set this to true at first, because any   actions that shouldn't happen until ""later"" should generally also   not happen before the first write call.  this.sync = true;
   whenever we return null, then we set a flag to say   that we're awaiting a 'readable' event emission.  this.needReadable = false;  this.emittedReadable = false;  this.readableListening = false;  this.resumeScheduled = false;
   Crypto is kind of old and crusty.  Historically, its default string   encoding is 'binary' so we have to make this configurable.   Everything else in the universe uses 'utf8', though.  this.defaultEncoding = options.defaultEncoding || utf8;
   when piping, we only care about 'readable' events that happen   after read()ing all the bytes and not getting any pushback.  this.ranOut = false;
   the number of writers that are awaiting a drain event in .pipe()s  this.awaitDrain = 0;
   if true, a maybeReadMore has been scheduled  this.readingMore = false;
  this.decoder = null;  this.encoding = null;  if (options.encoding) {    if (!StringDecoder) StringDecoder = require(string_decoder/).StringDecoder;    this.decoder = new StringDecoder(options.encoding);    this.encoding = options.encoding;  }}
var Duplex;function Readable(options) {  Duplex = Duplex || require(./_stream_duplex);
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);
   legacy  this.readable = true;
  if (options && typeof options.read === function) this._read = options.read;
  Stream.call(this);}
 Manually shove something into the read() buffer. This returns true if the highWaterMark has not been hit yet, similar to how Writable.write() returns true if you should write() some more.Readable.prototype.push = function (chunk, encoding) {  var state = this._readableState;
  if (!state.objectMode && typeof chunk === string) {    encoding = encoding || state.defaultEncoding;    if (encoding !== state.encoding) {      chunk = bufferShim.from(chunk, encoding);      encoding = ;    }  }
  return readableAddChunk(this, state, chunk, encoding, false);};
 Unshift should *always* be something directly out of read()Readable.prototype.unshift = function (chunk) {  var state = this._readableState;  return readableAddChunk(this, state, chunk, , true);};
Readable.prototype.isPaused = function () {  return this._readableState.flowing === false;};
function readableAddChunk(stream, state, chunk, encoding, addToFront) {  var er = chunkInvalid(state, chunk);  if (er) {    stream.emit(error, er);  } else if (chunk === null) {    state.reading = false;    onEofChunk(stream, state);  } else if (state.objectMode || chunk && chunk.length > 0) {    if (state.ended && !addToFront) {      var e = new Error(stream.push() after EOF);      stream.emit(error, e);    } else if (state.endEmitted && addToFront) {      var _e = new Error(stream.unshift() after end event);      stream.emit(error, _e);    } else {      var skipAdd;      if (state.decoder && !addToFront && !encoding) {        chunk = state.decoder.write(chunk);        skipAdd = !state.objectMode && chunk.length === 0;      }
      if (!addToFront) state.reading = false;
       Don't add to the buffer if we've decoded to an empty string chunk and       we're not in object mode      if (!skipAdd) {         if we want the data now, just emit it.        if (state.flowing && state.length === 0 && !state.sync) {          stream.emit(data, chunk);          stream.read(0);        } else {           update the buffer info.          state.length += state.objectMode ? 1 : chunk.length;          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream);        }      }
      maybeReadMore(stream, state);    }  } else if (!addToFront) {    state.reading = false;  }
  return needMoreData(state);}
 if it's past the high water mark, we can push in some more. Also, if we have no data yet, we can stand some more bytes.  This is to work around cases where hwm=0, such as the repl.  Also, if the push() triggered a readable event, and the user called read(largeNumber) such that needReadable was set, then we ought to push more, so that another 'readable' event will be triggered.function needMoreData(state) {  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);}
 backwards compatibility.Readable.prototype.setEncoding = function (enc) {  if (!StringDecoder) StringDecoder = require(string_decoder/).StringDecoder;  this._readableState.decoder = new StringDecoder(enc);  this._readableState.encoding = enc;  return this;};
 Don't raise the hwm > 8MBvar MAX_HWM = 0x800000;function computeNewHighWaterMark(n) {  if (n >= MAX_HWM) {    n = MAX_HWM;  } else {     Get the next highest power of 2 to prevent increasing hwm excessively in     tiny amounts    n--;    n |= n >>> 1;    n |= n >>> 2;    n |= n >>> 4;    n |= n >>> 8;    n |= n >>> 16;    n++;  }  return n;}
 This function is designed to be inlinable, so please take care when making changes to the function body.function howMuchToRead(n, state) {  if (n <= 0 || state.length === 0 && state.ended) return 0;  if (state.objectMode) return 1;  if (n !== n) {     Only flow one buffer at a time    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;  }   If we're asking for more than the current hwm, then raise the hwm.  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);  if (n <= state.length) return n;   Don't have enough  if (!state.ended) {    state.needReadable = true;    return 0;  }  return state.length;}
 you can override either this method, or the async _read(n) below.Readable.prototype.read = function (n) {  debug(read, n);  n = parseInt(n, 10);  var state = this._readableState;  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;
   if we're doing read(0) to trigger a readable event, but we   already have a bunch of data in the buffer, then just trigger   the 'readable' event and move on.  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {    debug(read: emitReadable, state.length, state.ended);    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);    return null;  }
  n = howMuchToRead(n, state);
   if we've ended, and we're now clear, then finish it up.  if (n === 0 && state.ended) {    if (state.length === 0) endReadable(this);    return null;  }
   All the actual chunk generation logic needs to be   *below* the call to _read.  The reason is that in certain   synthetic stream cases, such as passthrough streams, _read   may be a completely synchronous operation which may change   the state of the read buffer, providing enough data when   before there was *not* enough.     So, the steps are:   1. Figure out what the state of things will be after we do   a read from the buffer.     2. If that resulting state will trigger a _read, then call _read.   Note that this may be asynchronous, or synchronous.  Yes, it is   deeply ugly to write APIs this way, but that still doesn't mean   that the Readable class should behave improperly, as streams are   designed to be sync/async agnostic.   Take note if the _read call is sync or async (ie, if the read call   has returned yet), so that we know whether or not it's safe to emit   'readable' etc.     3. Actually pull the requested chunks out of the buffer and return.
   if we need a readable event, then we need to do some reading.  var doRead = state.needReadable;  debug(need readable, doRead);
   if we currently have less than the highWaterMark, then also read some  if (state.length === 0 || state.length - n < state.highWaterMark) {    doRead = true;    debug(length less than watermark, doRead);  }
   however, if we've ended, then there's no point, and if we're already   reading, then it's unnecessary.  if (state.ended || state.reading) {    doRead = false;    debug(reading or ended, doRead);  } else if (doRead) {    debug(do read);    state.reading = true;    state.sync = true;     if the length is currently zero, then we *need* a readable event.    if (state.length === 0) state.needReadable = true;     call internal read method    this._read(state.highWaterMark);    state.sync = false;     If _read pushed data synchronously, then `reading` will be false,     and we need to re-evaluate how much data we can return to the user.    if (!state.reading) n = howMuchToRead(nOrig, state);  }
  var ret;  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {    state.needReadable = true;    n = 0;  } else {    state.length -= n;  }
  if (state.length === 0) {     If we have nothing in the buffer, then we want to know     as soon as we *do* get something into the buffer.    if (!state.ended) state.needReadable = true;
     If we tried to read() past the EOF, then emit end on the next tick.    if (nOrig !== n && state.ended) endReadable(this);  }
  if (ret !== null) this.emit(data, ret);
  return ret;};
function chunkInvalid(state, chunk) {  var er = null;  if (!Buffer.isBuffer(chunk) && typeof chunk !== string && chunk !== null && chunk !== undefined && !state.objectMode) {    er = new TypeError(Invalid non-string/buffer chunk);  }  return er;}
function onEofChunk(stream, state) {  if (state.ended) return;  if (state.decoder) {    var chunk = state.decoder.end();    if (chunk && chunk.length) {      state.buffer.push(chunk);      state.length += state.objectMode ? 1 : chunk.length;    }  }  state.ended = true;
   emit 'readable' now to make sure it gets picked up.  emitReadable(stream);}
 Don't emit readable right away in sync mode, because this can trigger another read() call => stack overflow.  This way, it might trigger a nextTick recursion warning, but that's not so bad.function emitReadable(stream) {  var state = stream._readableState;  state.needReadable = false;  if (!state.emittedReadable) {    debug(emitReadable, state.flowing);    state.emittedReadable = true;    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);  }}
function emitReadable_(stream) {  debug(emit readable);  stream.emit(readable);  flow(stream);}
 at this point, the user has presumably seen the 'readable' event, and called read() to consume some data.  that may have triggered in turn another _read(n) call, in which case reading = true if it's in progress. However, if we're not ended, or reading, and the length < hwm, then go ahead and try to read some more preemptively.function maybeReadMore(stream, state) {  if (!state.readingMore) {    state.readingMore = true;    processNextTick(maybeReadMore_, stream, state);  }}
function maybeReadMore_(stream, state) {  var len = state.length;  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {    debug(maybeReadMore read 0);    stream.read(0);    if (len === state.length)       didn't get any data, stop spinning.      break;else len = state.length;  }  state.readingMore = false;}
 abstract method.  to be overridden in specific implementation classes. call cb(er, data) where data is <= n in length. for virtual (non-string, non-buffer) streams, ""length"" is somewhat arbitrary, and perhaps not very meaningful.Readable.prototype._read = function (n) {  this.emit(error, new Error(not implemented));};
Readable.prototype.pipe = function (dest, pipeOpts) {  var src = this;  var state = this._readableState;
  switch (state.pipesCount) {    case 0:      state.pipes = dest;      break;    case 1:      state.pipes = [state.pipes, dest];      break;    default:      state.pipes.push(dest);      break;  }  state.pipesCount += 1;  debug(pipe count=%d opts=%j, state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : cleanup;  if (state.endEmitted) processNextTick(endFn);else src.once(end, endFn);
  dest.on(unpipe, onunpipe);  function onunpipe(readable) {    debug(onunpipe);    if (readable === src) {      cleanup();    }  }
  function onend() {    debug(onend);    dest.end();  }
   when the dest drains, it reduces the awaitDrain counter   on the source.  This would be more elegant with a .once()   handler in flow(), but adding and removing repeatedly is   too slow.  var ondrain = pipeOnDrain(src);  dest.on(drain, ondrain);
  var cleanedUp = false;  function cleanup() {    debug(cleanup);     cleanup event handlers once the pipe is broken    dest.removeListener(close, onclose);    dest.removeListener(finish, onfinish);    dest.removeListener(drain, ondrain);    dest.removeListener(error, onerror);    dest.removeListener(unpipe, onunpipe);    src.removeListener(end, onend);    src.removeListener(end, cleanup);    src.removeListener(data, ondata);
    cleanedUp = true;
     if the reader is waiting for a drain event from this     specific writer, then it would cause it to never start     flowing again.     So, if this is awaiting a drain, then we just call it now.     If we don't know, then assume that we are waiting for one.    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();  }
   If the user pushes more data while we're writing to dest then we'll end up   in ondata again. However, we only want to increase awaitDrain once because   dest will only emit one 'drain' event for the multiple writes.   => Introduce a guard on increasing awaitDrain.  var increasedAwaitDrain = false;  src.on(data, ondata);  function ondata(chunk) {    debug(ondata);    increasedAwaitDrain = false;    var ret = dest.write(chunk);    if (false === ret && !increasedAwaitDrain) {       If the user unpiped during `dest.write()`, it is possible       to get stuck in a permanently paused state if that write       also returned false.       => Check whether `dest` is still a piping destination.      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {        debug(false write response, pause, src._readableState.awaitDrain);        src._readableState.awaitDrain++;        increasedAwaitDrain = true;      }      src.pause();    }  }
   if the dest has an error, then stop piping into it.   however, don't suppress the throwing behavior for this.  function onerror(er) {    debug(onerror, er);    unpipe();    dest.removeListener(error, onerror);    if (EElistenerCount(dest, error) === 0) dest.emit(error, er);  }
   Make sure our error handler is attached before userland ones.  prependListener(dest, error, onerror);
   Both close and finish should trigger unpipe, but only once.  function onclose() {    dest.removeListener(finish, onfinish);    unpipe();  }  dest.once(close, onclose);  function onfinish() {    debug(onfinish);    dest.removeListener(close, onclose);    unpipe();  }  dest.once(finish, onfinish);
  function unpipe() {    debug(unpipe);    src.unpipe(dest);  }
   tell the dest that it's being piped to  dest.emit(pipe, src);
   start the flow if it hasn't been started already.  if (!state.flowing) {    debug(pipe resume);    src.resume();  }
  return dest;};
function pipeOnDrain(src) {  return function () {    var state = src._readableState;    debug(pipeOnDrain, state.awaitDrain);    if (state.awaitDrain) state.awaitDrain--;    if (state.awaitDrain === 0 && EElistenerCount(src, data)) {      state.flowing = true;      flow(src);    }  };}
Readable.prototype.unpipe = function (dest) {  var state = this._readableState;
   if we're not piping anywhere, then do nothing.  if (state.pipesCount === 0) return this;
   just one destination.  most common case.  if (state.pipesCount === 1) {     passed in one, but it's not the right one.    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;
     got a match.    state.pipes = null;    state.pipesCount = 0;    state.flowing = false;    if (dest) dest.emit(unpipe, this);    return this;  }
   slow case. multiple pipe destinations.
  if (!dest) {     remove all.    var dests = state.pipes;    var len = state.pipesCount;    state.pipes = null;    state.pipesCount = 0;    state.flowing = false;
    for (var _i = 0; _i < len; _i++) {      dests[_i].emit(unpipe, this);    }return this;  }
   try to find the right one.  var i = indexOf(state.pipes, dest);  if (i === -1) return this;
  state.pipes.splice(i, 1);  state.pipesCount -= 1;  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit(unpipe, this);
  return this;};
 set up data events if they are asked for Ensure readable listeners eventually get somethingReadable.prototype.on = function (ev, fn) {  var res = Stream.prototype.on.call(this, ev, fn);
  if (ev === data) {     Start flowing on next tick if stream isn't explicitly paused    if (this._readableState.flowing !== false) this.resume();  } else if (ev === readable) {    var state = this._readableState;    if (!state.endEmitted && !state.readableListening) {      state.readableListening = state.needReadable = true;      state.emittedReadable = false;      if (!state.reading) {        processNextTick(nReadingNextTick, this);      } else if (state.length) {        emitReadable(this, state);      }    }  }
  return res;};Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self) {  debug(readable nexttick read 0);  self.read(0);}
 pause() and resume() are remnants of the legacy readable stream API If the user uses them, then switch into old mode.Readable.prototype.resume = function () {  var state = this._readableState;  if (!state.flowing) {    debug(resume);    state.flowing = true;    resume(this, state);  }  return this;};
function resume(stream, state) {  if (!state.resumeScheduled) {    state.resumeScheduled = true;    processNextTick(resume_, stream, state);  }}
function resume_(stream, state) {  if (!state.reading) {    debug(resume read 0);    stream.read(0);  }
  state.resumeScheduled = false;  state.awaitDrain = 0;  stream.emit(resume);  flow(stream);  if (state.flowing && !state.reading) stream.read(0);}
Readable.prototype.pause = function () {  debug(call pause flowing=%j, this._readableState.flowing);  if (false !== this._readableState.flowing) {    debug(pause);    this._readableState.flowing = false;    this.emit(pause);  }  return this;};
function flow(stream) {  var state = stream._readableState;  debug(flow, state.flowing);  while (state.flowing && stream.read() !== null) {}}
 wrap an old-style stream as the async data source. This is *not* part of the readable stream interface. It is an ugly unfortunate mess of history.Readable.prototype.wrap = function (stream) {  var state = this._readableState;  var paused = false;
  var self = this;  stream.on(end, function () {    debug(wrapped end);    if (state.decoder && !state.ended) {      var chunk = state.decoder.end();      if (chunk && chunk.length) self.push(chunk);    }
    self.push(null);  });
  stream.on(data, function (chunk) {    debug(wrapped data);    if (state.decoder) chunk = state.decoder.write(chunk);
     don't skip over falsy values in objectMode    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = self.push(chunk);    if (!ret) {      paused = true;      stream.pause();    }  });
   proxy all the other methods.   important when wrapping filters and duplexes.  for (var i in stream) {    if (this[i] === undefined && typeof stream[i] === function) {      this[i] = function (method) {        return function () {          return stream[method].apply(stream, arguments);        };      }(i);    }  }
   proxy certain important events.  var events = [error, close, destroy, pause, resume];  forEach(events, function (ev) {    stream.on(ev, self.emit.bind(self, ev));  });
   when we try to consume some more bytes, simply unpause the   underlying stream.  self._read = function (n) {    debug(wrapped _read, n);    if (paused) {      paused = false;      stream.resume();    }  };
  return self;};
 exposed for testing purposes only.Readable._fromList = fromList;
 Pluck off n bytes from an array of buffers. Length is the combined lengths of all the buffers in the list. This function is designed to be inlinable, so please take care when making changes to the function body.function fromList(n, state) {   nothing buffered  if (state.length === 0) return null;
  var ret;  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {     read it all, truncate the list    if (state.decoder) ret = state.buffer.join();else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);    state.buffer.clear();  } else {     read part of list    ret = fromListPartial(n, state.buffer, state.decoder);  }
  return ret;}
 Extracts only enough buffered data to satisfy the amount requested. This function is designed to be inlinable, so please take care when making changes to the function body.function fromListPartial(n, list, hasStrings) {  var ret;  if (n < list.head.data.length) {     slice is the same for buffers and strings    ret = list.head.data.slice(0, n);    list.head.data = list.head.data.slice(n);  } else if (n === list.head.data.length) {     first chunk is a perfect match    ret = list.shift();  } else {     result spans more than one buffer    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);  }  return ret;}
 Copies a specified amount of characters from the list of buffered data chunks. This function is designed to be inlinable, so please take care when making changes to the function body.function copyFromBufferString(n, list) {  var p = list.head;  var c = 1;  var ret = p.data;  n -= ret.length;  while (p = p.next) {    var str = p.data;    var nb = n > str.length ? str.length : n;    if (nb === str.length) ret += str;else ret += str.slice(0, n);    n -= nb;    if (n === 0) {      if (nb === str.length) {        ++c;        if (p.next) list.head = p.next;else list.head = list.tail = null;      } else {        list.head = p;        p.data = str.slice(nb);      }      break;    }    ++c;  }  list.length -= c;  return ret;}
 Copies a specified amount of bytes from the list of buffered data chunks. This function is designed to be inlinable, so please take care when making changes to the function body.function copyFromBuffer(n, list) {  var ret = bufferShim.allocUnsafe(n);  var p = list.head;  var c = 1;  p.data.copy(ret);  n -= p.data.length;  while (p = p.next) {    var buf = p.data;    var nb = n > buf.length ? buf.length : n;    buf.copy(ret, ret.length - n, 0, nb);    n -= nb;    if (n === 0) {      if (nb === buf.length) {        ++c;        if (p.next) list.head = p.next;else list.head = list.tail = null;      } else {        list.head = p;        p.data = buf.slice(nb);      }      break;    }    ++c;  }  list.length -= c;  return ret;}
function endReadable(stream) {  var state = stream._readableState;
   If we get here before consuming all the bytes, then that is a   bug in node.  Should never happen.  if (state.length > 0) throw new Error(""endReadable()"" called on non-empty stream);
  if (!state.endEmitted) {    state.ended = true;    processNextTick(endReadableNT, state, stream);  }}
function endReadableNT(state, stream) {   Check that we didn't get one last unshift.  if (!state.endEmitted && state.length === 0) {    state.endEmitted = true;    stream.readable = false;    stream.emit(end);  }}
function forEach(xs, f) {  for (var i = 0, l = xs.length; i < l; i++) {    f(xs[i], i);  }}
function indexOf(xs, x) {  for (var i = 0, l = xs.length; i < l; i++) {    if (xs[i] === x) return i;  }  return -1;}}).call(this,require(_process))},{./_stream_duplex:69,./internal/streams/BufferList:74,_process:67,buffer:44,buffer-shims:43,core-util-is:45,events:48,inherits:51,isarray:53,process-nextick-args:66,string_decoder/:80,util:40}],72:[function(require,module,exports){ a transform stream is a readable/writable stream where you do something with the data.  Sometimes it's called a ""filter"", but that's not a great name for it, since that implies a thing where some bits pass through, and others are simply ignored.  (That would be a valid example of a transform, of course.) While the output is causally related to the input, it's not a necessarily symmetric or synchronous transformation.  For example, a zlib stream might take multiple plain-text writes(), and then emit a single compressed chunk some time in the future. Here's how this works: The Transform stream has all the aspects of the readable and writable stream classes.  When you write(chunk), that calls _write(chunk,cb) internally, and returns false if there's a lot of pending writes buffered up.  When you call read(), that calls _read(n) until there's enough pending readable data buffered up. In a transform stream, the written data is placed in a buffer.  When _read(n) is called, it transforms the queued up data, calling the buffered _write cb's as it consumes chunks.  If consuming a single written chunk would result in multiple output chunks, then the first outputted bit calls the readcb, and subsequent chunks just go into the read buffer, and will cause it to emit 'readable' if necessary. This way, back-pressure is actually determined by the reading side, since _read has to be called to start processing a new chunk.  However, a pathological inflate type of transform can cause excessive buffering here.  For example, imagine a stream where every byte of input is interpreted as an integer from 0-255, and then results in that many bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in 1kb of data being output.  In this case, you could write a very small amount of input, and end up with a very large amount of output.  In such a pathological inflating mechanism, there'd be no way to tell the system to stop doing the transform.  A single 4MB write could cause the system to run out of memory. However, even in such a pathological case, only a single written chunk would be consumed, and then the rest would wait (un-transformed) until the results of the previous transformed chunk were consumed.
use strict;
module.exports = Transform;
var Duplex = require(./_stream_duplex);
var util = require(core-util-is);util.inherits = require(inherits);
util.inherits(Transform, Duplex);
function TransformState(stream) {  this.afterTransform = function (er, data) {    return afterTransform(stream, er, data);  };
  this.needTransform = false;  this.transforming = false;  this.writecb = null;  this.writechunk = null;  this.writeencoding = null;}
function afterTransform(stream, er, data) {  var ts = stream._transformState;  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream.emit(error, new Error(no writecb in Transform class));
  ts.writechunk = null;  ts.writecb = null;
  if (data !== null && data !== undefined) stream.push(data);
  cb(er);
  var rs = stream._readableState;  rs.reading = false;  if (rs.needReadable || rs.length < rs.highWaterMark) {    stream._read(rs.highWaterMark);  }}
function Transform(options) {  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
   when the writable side finishes, then flush out anything remaining.  var stream = this;
   start out asking for a readable event once data is transformed.  this._readableState.needReadable = true;
   we have implemented the _read method, and done the other things   that Readable wants before the first _read call, so unset the   sync guard flag.  this._readableState.sync = false;
  if (options) {    if (typeof options.transform === function) this._transform = options.transform;
    if (typeof options.flush === function) this._flush = options.flush;  }
  this.once(prefinish, function () {    if (typeof this._flush === function) this._flush(function (er) {      done(stream, er);    });else done(stream);  });}
Transform.prototype.push = function (chunk, encoding) {  this._transformState.needTransform = false;  return Duplex.prototype.push.call(this, chunk, encoding);};
 This is the part where you do stuff! override this function in implementation classes. 'chunk' is an input chunk. Call `push(newChunk)` to pass along transformed output to the readable side.  You may call 'push' zero or more times. Call `cb(err)` when you are done with this chunk.  If you pass an error, then that'll put the hurt on the whole operation.  If you never call cb(), then you'll never get another chunk.Transform.prototype._transform = function (chunk, encoding, cb) {  throw new Error(Not implemented);};
Transform.prototype._write = function (chunk, encoding, cb) {  var ts = this._transformState;  ts.writecb = cb;  ts.writechunk = chunk;  ts.writeencoding = encoding;  if (!ts.transforming) {    var rs = this._readableState;    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);  }};
 Doesn't matter what the args are here. _transform does all the work. That we got here means that the readable side wants more data.Transform.prototype._read = function (n) {  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {    ts.transforming = true;    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);  } else {     mark that we need a transform, so that any data that comes in     will get processed, now that we've asked for it.    ts.needTransform = true;  }};
function done(stream, er) {  if (er) return stream.emit(error, er);
   if there's nothing in the write buffer, then that means   that nothing more will ever be provided  var ws = stream._writableState;  var ts = stream._transformState;
  if (ws.length) throw new Error(Calling transform done when ws.length != 0);
  if (ts.transforming) throw new Error(Calling transform done when still transforming);
  return stream.push(null);}},{./_stream_duplex:69,core-util-is:45,inherits:51}],73:[function(require,module,exports){(function (process){ A bit simpler than readable streams. Implement an async ._write(chunk, encoding, cb), and it'll handle all the drain event emission and buffering.
use strict;
module.exports = Writable;
var processNextTick = require(process-nextick-args);
var asyncWrite = !process.browser && [v0.10, v0.9.].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
Writable.WritableState = WritableState;
var util = require(core-util-is);util.inherits = require(inherits);
var internalUtil = {  deprecate: require(util-deprecate)};
var Stream;(function () {  try {    Stream = require(st + ream);  } catch (_) {} finally {    if (!Stream) Stream = require(events).EventEmitter;  }})();
var Buffer = require(buffer).Buffer;var bufferShim = require(buffer-shims);
util.inherits(Writable, Stream);
function nop() {}
function WriteReq(chunk, encoding, cb) {  this.chunk = chunk;  this.encoding = encoding;  this.callback = cb;  this.next = null;}
var Duplex;function WritableState(options, stream) {  Duplex = Duplex || require(./_stream_duplex);
  options = options || {};
   object stream flag to indicate whether or not this stream   contains buffers or objects.  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
   the point at which write() starts returning false   Note: 0 is a valid value, means that we always return false if   the entire buffer is not flushed immediately on write()  var hwm = options.highWaterMark;  var defaultHwm = this.objectMode ? 16 : 16  1024;  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
   cast to ints.  this.highWaterMark = ~ ~this.highWaterMark;
  this.needDrain = false;   at the start of calling end()  this.ending = false;   when end() has been called, and returned  this.ended = false;   when 'finish' is emitted  this.finished = false;
   should we decode strings into buffers before passing to _write?   this is here so that some node-core streams can optimize string   handling at a lower level.  var noDecode = options.decodeStrings === false;  this.decodeStrings = !noDecode;
   Crypto is kind of old and crusty.  Historically, its default string   encoding is 'binary' so we have to make this configurable.   Everything else in the universe uses 'utf8', though.  this.defaultEncoding = options.defaultEncoding || utf8;
   not an actual buffer we keep track of, but a measurement   of how much we're waiting to get pushed to some underlying   socket or file.  this.length = 0;
   a flag to see when we're in the middle of a write.  this.writing = false;
   when true all writes will be buffered until .uncork() call  this.corked = 0;
   a flag to be able to tell if the onwrite cb is called immediately,   or on a later tick.  We set this to true at first, because any   actions that shouldn't happen until ""later"" should generally also   not happen before the first write call.  this.sync = true;
   a flag to know if we're processing previously buffered items, which   may call the _write() callback in the same tick, so that we don't   end up in an overlapped onwrite situation.  this.bufferProcessing = false;
   the callback that's passed to _write(chunk,cb)  this.onwrite = function (er) {    onwrite(stream, er);  };
   the callback that the user supplies to write(chunk,encoding,cb)  this.writecb = null;
   the amount that is being written when _write is called.  this.writelen = 0;
  this.bufferedRequest = null;  this.lastBufferedRequest = null;
   number of pending user-supplied write callbacks   this must be 0 before 'finish' can be emitted  this.pendingcb = 0;
   emit prefinish if the only thing we're waiting for is _write cbs   This is relevant for synchronous Transform streams  this.prefinished = false;
   True if the error was already emitted and should not be thrown again  this.errorEmitted = false;
   count buffered requests  this.bufferedRequestCount = 0;
   allocate the first CorkedRequest, there is always   one allocated and free to use, and we maintain at most two  this.corkedRequestsFree = new CorkedRequest(this);}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {  var current = this.bufferedRequest;  var out = [];  while (current) {    out.push(current);    current = current.next;  }  return out;};
(function () {  try {    Object.defineProperty(WritableState.prototype, buffer, {      get: internalUtil.deprecate(function () {        return this.getBuffer();      }, _writableState.buffer is deprecated. Use _writableState.getBuffer  + instead.)    });  } catch (_) {}})();
var Duplex;function Writable(options) {  Duplex = Duplex || require(./_stream_duplex);
   Writable ctor is applied to Duplexes, though they're not   instanceof Writable, they're instanceof Readable.  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this);
   legacy.  this.writable = true;
  if (options) {    if (typeof options.write === function) this._write = options.write;
    if (typeof options.writev === function) this._writev = options.writev;  }
  Stream.call(this);}
 Otherwise people can pipe Writable streams, which is just wrong.Writable.prototype.pipe = function () {  this.emit(error, new Error(Cannot pipe, not readable));};
function writeAfterEnd(stream, cb) {  var er = new Error(write after end);   TODO: defer error events consistently everywhere, not just the cb  stream.emit(error, er);  processNextTick(cb, er);}
 If we get something that is not a buffer, string, null, or undefined, and we're not in objectMode, then that's an error. Otherwise stream chunks are all considered to be of length=1, and the watermarks determine how many objects to keep in the buffer, rather than how many bytes or characters.function validChunk(stream, state, chunk, cb) {  var valid = true;  var er = false;   Always throw error if a null is written   if we are not in object mode then throw   if it is not a buffer, string, or undefined.  if (chunk === null) {    er = new TypeError(May not write null values to stream);  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== string && chunk !== undefined && !state.objectMode) {    er = new TypeError(Invalid non-string/buffer chunk);  }  if (er) {    stream.emit(error, er);    processNextTick(cb, er);    valid = false;  }  return valid;}
Writable.prototype.write = function (chunk, encoding, cb) {  var state = this._writableState;  var ret = false;
  if (typeof encoding === function) {    cb = encoding;    encoding = null;  }
  if (Buffer.isBuffer(chunk)) encoding = buffer;else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== function) cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {    state.pendingcb++;    ret = writeOrBuffer(this, state, chunk, encoding, cb);  }
  return ret;};
Writable.prototype.cork = function () {  var state = this._writableState;
  state.corked++;};
Writable.prototype.uncork = function () {  var state = this._writableState;
  if (state.corked) {    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);  }};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {   node::ParseEncoding() requires lower case.  if (typeof encoding === string) encoding = encoding.toLowerCase();  if (!([hex, utf8, utf-8, ascii, binary, base64, ucs2, ucs-2, utf16le, utf-16le, raw].indexOf((encoding + ).toLowerCase()) > -1)) throw new TypeError(Unknown encoding:  + encoding);  this._writableState.defaultEncoding = encoding;  return this;};
function decodeChunk(state, chunk, encoding) {  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === string) {    chunk = bufferShim.from(chunk, encoding);  }  return chunk;}
 if we're already writing something, then just put this in the queue, and wait our turn.  Otherwise, call _write If we return false, then we need a drain event, so set that flag.function writeOrBuffer(stream, state, chunk, encoding, cb) {  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk)) encoding = buffer;  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;   we must ensure that previous needDrain will not be reset to false.  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {    var last = state.lastBufferedRequest;    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);    if (last) {      last.next = state.lastBufferedRequest;    } else {      state.bufferedRequest = state.lastBufferedRequest;    }    state.bufferedRequestCount += 1;  } else {    doWrite(stream, state, false, len, chunk, encoding, cb);  }
  return ret;}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {  state.writelen = len;  state.writecb = cb;  state.writing = true;  state.sync = true;  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);  state.sync = false;}
function onwriteError(stream, state, sync, er, cb) {  --state.pendingcb;  if (sync) processNextTick(cb, er);else cb(er);
  stream._writableState.errorEmitted = true;  stream.emit(error, er);}
function onwriteStateUpdate(state) {  state.writing = false;  state.writecb = null;  state.length -= state.writelen;  state.writelen = 0;}
function onwrite(stream, er) {  var state = stream._writableState;  var sync = state.sync;  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {     Check if we're actually ready to finish, but don't emit yet    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {      clearBuffer(stream, state);    }
    if (sync) {            asyncWrite(afterWrite, stream, state, finished, cb);          } else {        afterWrite(stream, state, finished, cb);      }  }}
function afterWrite(stream, state, finished, cb) {  if (!finished) onwriteDrain(stream, state);  state.pendingcb--;  cb();  finishMaybe(stream, state);}
 Must force callback to be called on nextTick, so that we don't emit 'drain' before the write() consumer gets the 'false' return value, and has a chance to attach a 'drain' listener.function onwriteDrain(stream, state) {  if (state.length === 0 && state.needDrain) {    state.needDrain = false;    stream.emit(drain);  }}
 if there's something in the buffer waiting, then process itfunction clearBuffer(stream, state) {  state.bufferProcessing = true;  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {     Fast case, write everything using _writev()    var l = state.bufferedRequestCount;    var buffer = new Array(l);    var holder = state.corkedRequestsFree;    holder.entry = entry;
    var count = 0;    while (entry) {      buffer[count] = entry;      entry = entry.next;      count += 1;    }
    doWrite(stream, state, true, state.length, buffer, , holder.finish);
     doWrite is almost always async, defer these to save a bit of time     as the hot path ends with doWrite    state.pendingcb++;    state.lastBufferedRequest = null;    if (holder.next) {      state.corkedRequestsFree = holder.next;      holder.next = null;    } else {      state.corkedRequestsFree = new CorkedRequest(state);    }  } else {     Slow case, write chunks one-by-one    while (entry) {      var chunk = entry.chunk;      var encoding = entry.encoding;      var cb = entry.callback;      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);      entry = entry.next;       if we didn't call the onwrite immediately, then       it means that we need to wait until it does.       also, that means that the chunk and cb are currently       being processed, so move the buffer counter past them.      if (state.writing) {        break;      }    }
    if (entry === null) state.lastBufferedRequest = null;  }
  state.bufferedRequestCount = 0;  state.bufferedRequest = entry;  state.bufferProcessing = false;}
Writable.prototype._write = function (chunk, encoding, cb) {  cb(new Error(not implemented));};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {  var state = this._writableState;
  if (typeof chunk === function) {    cb = chunk;    chunk = null;    encoding = null;  } else if (typeof encoding === function) {    cb = encoding;    encoding = null;  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
   .end() fully uncorks  if (state.corked) {    state.corked = 1;    this.uncork();  }
   ignore unnecessary end() calls.  if (!state.ending && !state.finished) endWritable(this, state, cb);};
function needFinish(state) {  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;}
function prefinish(stream, state) {  if (!state.prefinished) {    state.prefinished = true;    stream.emit(prefinish);  }}
function finishMaybe(stream, state) {  var need = needFinish(state);  if (need) {    if (state.pendingcb === 0) {      prefinish(stream, state);      state.finished = true;      stream.emit(finish);    } else {      prefinish(stream, state);    }  }  return need;}
function endWritable(stream, state, cb) {  state.ending = true;  finishMaybe(stream, state);  if (cb) {    if (state.finished) processNextTick(cb);else stream.once(finish, cb);  }  state.ended = true;  stream.writable = false;}
 It seems a linked list but it is not there will be only 2 of these for each streamfunction CorkedRequest(state) {  var _this = this;
  this.next = null;  this.entry = null;
  this.finish = function (err) {    var entry = _this.entry;    _this.entry = null;    while (entry) {      var cb = entry.callback;      state.pendingcb--;      cb(err);      entry = entry.next;    }    if (state.corkedRequestsFree) {      state.corkedRequestsFree.next = _this;    } else {      state.corkedRequestsFree = _this;    }  };}}).call(this,require(_process))},{./_stream_duplex:69,_process:67,buffer:44,buffer-shims:43,core-util-is:45,events:48,inherits:51,process-nextick-args:66,util-deprecate:81}],74:[function(require,module,exports){use strict;
var Buffer = require(buffer).Buffer;var bufferShim = require(buffer-shims);
module.exports = BufferList;
function BufferList() {  this.head = null;  this.tail = null;  this.length = 0;}
BufferList.prototype.push = function (v) {  var entry = { data: v, next: null };  if (this.length > 0) this.tail.next = entry;else this.head = entry;  this.tail = entry;  ++this.length;};
BufferList.prototype.unshift = function (v) {  var entry = { data: v, next: this.head };  if (this.length === 0) this.tail = entry;  this.head = entry;  ++this.length;};
BufferList.prototype.shift = function () {  if (this.length === 0) return;  var ret = this.head.data;  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;  --this.length;  return ret;};
BufferList.prototype.clear = function () {  this.head = this.tail = null;  this.length = 0;};
BufferList.prototype.join = function (s) {  if (this.length === 0) return ;  var p = this.head;  var ret =  + p.data;  while (p = p.next) {    ret += s + p.data;  }return ret;};
BufferList.prototype.concat = function (n) {  if (this.length === 0) return bufferShim.alloc(0);  if (this.length === 1) return this.head.data;  var ret = bufferShim.allocUnsafe(n >>> 0);  var p = this.head;  var i = 0;  while (p) {    p.data.copy(ret, i);    i += p.data.length;    p = p.next;  }  return ret;};},{buffer:44,buffer-shims:43}],75:[function(require,module,exports){module.exports = require(./lib/_stream_passthrough.js)
},{./lib/_stream_passthrough.js:70}],76:[function(require,module,exports){(function (process){var Stream = (function (){  try {    return require(st + ream);  hack to fix a circular dependency issue when used with browserify  } catch(_){}}());exports = module.exports = require(./lib/_stream_readable.js);exports.Stream = Stream || exports;exports.Readable = exports;exports.Writable = require(./lib/_stream_writable.js);exports.Duplex = require(./lib/_stream_duplex.js);exports.Transform = require(./lib/_stream_transform.js);exports.PassThrough = require(./lib/_stream_passthrough.js);
if (!process.browser && process.env.READABLE_STREAM === disable && Stream) {  module.exports = Stream;}
}).call(this,require(_process))},{./lib/_stream_duplex.js:69,./lib/_stream_passthrough.js:70,./lib/_stream_readable.js:71,./lib/_stream_transform.js:72,./lib/_stream_writable.js:73,_process:67}],77:[function(require,module,exports){module.exports = require(./lib/_stream_transform.js)
},{./lib/_stream_transform.js:72}],78:[function(require,module,exports){module.exports = require(./lib/_stream_writable.js)
},{./lib/_stream_writable.js:73}],79:[function(require,module,exports){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require(events).EventEmitter;var inherits = require(inherits);
inherits(Stream, EE);Stream.Readable = require(readable-stream/readable.js);Stream.Writable = require(readable-stream/writable.js);Stream.Duplex = require(readable-stream/duplex.js);Stream.Transform = require(readable-stream/transform.js);Stream.PassThrough = require(readable-stream/passthrough.js);
 Backwards-compat with node 0.4.xStream.Stream = Stream;


 old-style streams.  Note that the pipe method (the only relevant part of this class) is overridden in the Readable class.
function Stream() {  EE.call(this);}
Stream.prototype.pipe = function(dest, options) {  var source = this;
  function ondata(chunk) {    if (dest.writable) {      if (false === dest.write(chunk) && source.pause) {        source.pause();      }    }  }
  source.on(data, ondata);
  function ondrain() {    if (source.readable && source.resume) {      source.resume();    }  }
  dest.on(drain, ondrain);
   If the 'end' option is not supplied, dest.end() will be called when   source gets the 'end' or 'close' events.  Only dest.end() once.  if (!dest._isStdio && (!options || options.end !== false)) {    source.on(end, onend);    source.on(close, onclose);  }
  var didOnEnd = false;  function onend() {    if (didOnEnd) return;    didOnEnd = true;
    dest.end();  }

  function onclose() {    if (didOnEnd) return;    didOnEnd = true;
    if (typeof dest.destroy === function) dest.destroy();  }
   don't leave dangling pipes when there are errors.  function onerror(er) {    cleanup();    if (EE.listenerCount(this, error) === 0) {      throw er;  Unhandled stream error in pipe.    }  }
  source.on(error, onerror);  dest.on(error, onerror);
   remove all the event listeners that were added.  function cleanup() {    source.removeListener(data, ondata);    dest.removeListener(drain, ondrain);
    source.removeListener(end, onend);    source.removeListener(close, onclose);
    source.removeListener(error, onerror);    dest.removeListener(error, onerror);
    source.removeListener(end, cleanup);    source.removeListener(close, cleanup);
    dest.removeListener(close, cleanup);  }
  source.on(end, cleanup);  source.on(close, cleanup);
  dest.on(close, cleanup);
  dest.emit(pipe, source);
   Allow for unix-like usage: A.pipe(B).pipe(C)  return dest;};
},{events:48,inherits:51,readable-stream/duplex.js:68,readable-stream/passthrough.js:75,readable-stream/readable.js:76,readable-stream/transform.js:77,readable-stream/writable.js:78}],80:[function(require,module,exports){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
var Buffer = require(buffer).Buffer;
var isBufferEncoding = Buffer.isEncoding  || function(encoding) {       switch (encoding && encoding.toLowerCase()) {         case hex: case utf8: case utf-8: case ascii: case binary: case base64: case ucs2: case ucs-2: case utf16le: case utf-16le: case raw: return true;         default: return false;       }     }

function assertEncoding(encoding) {  if (encoding && !isBufferEncoding(encoding)) {    throw new Error(Unknown encoding:  + encoding);  }}
 StringDecoder provides an interface for efficiently splitting a series of buffers into a series of JS strings without breaking apart multi-byte characters. CESU-8 is handled as part of the UTF-8 encoding. @TODO Handling all encodings inside a single object makes it very difficult to reason about this code, so it should be split up in the future. @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code points as used by CESU-8.var StringDecoder = exports.StringDecoder = function(encoding) {  this.encoding = (encoding || utf8).toLowerCase().replace(, );  assertEncoding(encoding);  switch (this.encoding) {    case utf8:       CESU-8 represents each of Surrogate Pair by 3-bytes      this.surrogateSize = 3;      break;    case ucs2:    case utf16le:       UTF-16 represents each of Surrogate Pair by 2-bytes      this.surrogateSize = 2;      this.detectIncompleteChar = utf16DetectIncompleteChar;      break;    case base64:       Base-64 stores 3 bytes in 4 chars, and pads the remainder.      this.surrogateSize = 3;      this.detectIncompleteChar = base64DetectIncompleteChar;      break;    default:      this.write = passThroughWrite;      return;  }
   Enough space to store all bytes of a single character. UTF-8 needs 4   bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).  this.charBuffer = new Buffer(6);   Number of bytes received for the current incomplete multi-byte character.  this.charReceived = 0;   Number of bytes expected for the current incomplete multi-byte character.  this.charLength = 0;};

 write decodes the given buffer and returns it as JS string that is guaranteed to not contain any partial multi-byte characters. Any partial character found at the end of the buffer is buffered up, and will be returned when calling write again with the remaining bytes. Note: Converting a Buffer containing an orphan surrogate to a String currently works, but converting a String to a Buffer (via `new Buffer`, or Buffer#write) will replace incomplete surrogates with the unicode replacement character. See https://codereview.chromium.org/121173009/ .StringDecoder.prototype.write = function(buffer) {  var charStr = ;   if our last write ended with an incomplete multibyte character  while (this.charLength) {     determine how many remaining bytes this buffer has to offer for this char    var available = (buffer.length >= this.charLength - this.charReceived) ?        this.charLength - this.charReceived :        buffer.length;
     add the new bytes to the char buffer    buffer.copy(this.charBuffer, this.charReceived, 0, available);    this.charReceived += available;
    if (this.charReceived < this.charLength) {       still not enough chars in this buffer? wait for more ...      return ;    }
     remove bytes belonging to the current character from the buffer    buffer = buffer.slice(available, buffer.length);
     get the character that was split    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
     CESU-8: lead surrogate (D800-DBFF) is also the incomplete character    var charCode = charStr.charCodeAt(charStr.length - 1);    if (charCode >= 0xD800 && charCode <= 0xDBFF) {      this.charLength += this.surrogateSize;      charStr = ;      continue;    }    this.charReceived = this.charLength = 0;
     if there are no more bytes in this buffer, just emit our char    if (buffer.length === 0) {      return charStr;    }    break;  }
   determine and set charLength / charReceived  this.detectIncompleteChar(buffer);
  var end = buffer.length;  if (this.charLength) {     buffer the incomplete character bytes we got    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);    end -= this.charReceived;  }
  charStr += buffer.toString(this.encoding, 0, end);
  var end = charStr.length - 1;  var charCode = charStr.charCodeAt(end);   CESU-8: lead surrogate (D800-DBFF) is also the incomplete character  if (charCode >= 0xD800 && charCode <= 0xDBFF) {    var size = this.surrogateSize;    this.charLength += size;    this.charReceived += size;    this.charBuffer.copy(this.charBuffer, size, 0, size);    buffer.copy(this.charBuffer, 0, 0, size);    return charStr.substring(0, end);  }
   or just emit the charStr  return charStr;};
 detectIncompleteChar determines if there is an incomplete UTF-8 character at the end of the given buffer. If so, it sets this.charLength to the byte length that character, and sets this.charReceived to the number of bytes that are available for this character.StringDecoder.prototype.detectIncompleteChar = function(buffer) {   determine how many bytes we have to check at the end of this buffer  var i = (buffer.length >= 3) ? 3 : buffer.length;
   Figure out if one of the last i bytes of our buffer announces an   incomplete char.  for (; i > 0; i--) {    var c = buffer[buffer.length - i];
     See http://en.wikipedia.org/wiki/UTF-8#Description
     110XXXXX    if (i == 1 && c >> 5 == 0x06) {      this.charLength = 2;      break;    }
     1110XXXX    if (i <= 2 && c >> 4 == 0x0E) {      this.charLength = 3;      break;    }
     11110XXX    if (i <= 3 && c >> 3 == 0x1E) {      this.charLength = 4;      break;    }  }  this.charReceived = i;};
StringDecoder.prototype.end = function(buffer) {  var res = ;  if (buffer && buffer.length)    res = this.write(buffer);
  if (this.charReceived) {    var cr = this.charReceived;    var buf = this.charBuffer;    var enc = this.encoding;    res += buf.slice(0, cr).toString(enc);  }
  return res;};
function passThroughWrite(buffer) {  return buffer.toString(this.encoding);}
function utf16DetectIncompleteChar(buffer) {  this.charReceived = buffer.length % 2;  this.charLength = this.charReceived ? 2 : 0;}
function base64DetectIncompleteChar(buffer) {  this.charReceived = buffer.length % 3;  this.charLength = this.charReceived ? 3 : 0;}
},{buffer:44}],81:[function(require,module,exports){(function (global){
 * Module exports. */
module.exports = deprecate;
 * Mark that a method should not be used. * Returns a modified function which warns once by default. * * If `localStorage.noDeprecation = true` is set, then it is a no-op. * * If `localStorage.throwDeprecation = true` is set, then deprecated functions * will throw an Error when invoked. * * If `localStorage.traceDeprecation = true` is set, then deprecated functions * will invoke `console.trace()` instead of `console.error()`. * *    - the function to deprecate *    - the string to print to the console when `fn` is invoked *   a new ""deprecated"" version of `fn` * @api public */
function deprecate (fn, msg) {  if (config(noDeprecation)) {    return fn;  }
  var warned = false;  function deprecated() {    if (!warned) {      if (config(throwDeprecation)) {        throw new Error(msg);      } else if (config(traceDeprecation)) {        console.trace(msg);      } else {        console.warn(msg);      }      warned = true;    }    return fn.apply(this, arguments);  }
  return deprecated;}
 * Checks `localStorage` for boolean values for the given `name`. * *    *   * @api private */
function config (name) {   accessing global.localStorage can trigger a DOMException in sandboxed iframes  try {    if (!global.localStorage) return false;  } catch (_) {    return false;  }  var val = global.localStorage[name];  if (null == val) return false;  return String(val).toLowerCase() === true;}
}).call(this,typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{}],82:[function(require,module,exports){arguments[4][51][0].apply(exports,arguments)},{dup:51}],83:[function(require,module,exports){module.exports = function isBuffer(arg) {  return arg && typeof arg === object    && typeof arg.copy === function    && typeof arg.fill === function    && typeof arg.readUInt8 === function;}},{}],84:[function(require,module,exports){(function (process,global){ Copyright Joyent, Inc. and other Node contributors. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
var formatRegExp = %g;exports.format = function(f) {  if (!isString(f)) {    var objects = [];    for (var i = 0; i < arguments.length; i++) {      objects.push(inspect(arguments[i]));    }    return objects.join( );  }
  var i = 1;  var args = arguments;  var len = args.length;  var str = String(f).replace(formatRegExp, function(x) {    if (x === %%) return %;    if (i >= len) return x;    switch (x) {      case %s: return String(args[i++]);      case %d: return Number(args[i++]);      case %j:        try {          return JSON.stringify(args[i++]);        } catch (_) {          return [Circular];        }      default:        return x;    }  });  for (var x = args[i]; i < len; x = args[++i]) {    if (isNull(x) || !isObject(x)) {      str +=   + x;    } else {      str +=   + inspect(x);    }  }  return str;};

 Mark that a method should not be used. Returns a modified function which warns once by default. If --no-deprecation is set, then it is a no-op.exports.deprecate = function(fn, msg) {   Allow for deprecating things in the process of starting up.  if (isUndefined(global.process)) {    return function() {      return exports.deprecate(fn, msg).apply(this, arguments);    };  }
  if (process.noDeprecation === true) {    return fn;  }
  var warned = false;  function deprecated() {    if (!warned) {      if (process.throwDeprecation) {        throw new Error(msg);      } else if (process.traceDeprecation) {        console.trace(msg);      } else {        console.error(msg);      }      warned = true;    }    return fn.apply(this, arguments);  }
  return deprecated;};

var debugs = {};var debugEnviron;exports.debuglog = function(set) {  if (isUndefined(debugEnviron))    debugEnviron = process.env.NODE_DEBUG || ;  set = set.toUpperCase();  if (!debugs[set]) {    if (new RegExp(b + set + b, i).test(debugEnviron)) {      var pid = process.pid;      debugs[set] = function() {        var msg = exports.format.apply(exports, arguments);        console.error(%s %d: %s, set, pid, msg);      };    } else {      debugs[set] = function() {};    }  }  return debugs[set];};

 * Echos the value of a value. Trys to print the value out * in the best way possible given the different types. * *    The object to print out. *    Optional options object that alters the output. */function inspect(obj, opts) {   default options  var ctx = {    seen: [],    stylize: stylizeNoColor  };   legacy...  if (arguments.length >= 3) ctx.depth = arguments[2];  if (arguments.length >= 4) ctx.colors = arguments[3];  if (isBoolean(opts)) {     legacy...    ctx.showHidden = opts;  } else if (opts) {     got an ""options"" object    exports._extend(ctx, opts);  }   set default options  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;  if (isUndefined(ctx.depth)) ctx.depth = 2;  if (isUndefined(ctx.colors)) ctx.colors = false;  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;  if (ctx.colors) ctx.stylize = stylizeWithColor;  return formatValue(ctx, obj, ctx.depth);}exports.inspect = inspect;

 http://en.wikipedia.org/wiki/ANSI_escape_code#graphicsinspect.colors = {  bold : [1, 22],  italic : [3, 23],  underline : [4, 24],  inverse : [7, 27],  white : [37, 39],  grey : [90, 39],  black : [30, 39],  blue : [34, 39],  cyan : [36, 39],  green : [32, 39],  magenta : [35, 39],  red : [31, 39],  yellow : [33, 39]};
 Don't use 'blue' not visible on cmd.exeinspect.styles = {  special: cyan,  number: yellow,  boolean: yellow,  undefined: grey,  null: bold,  string: green,  date: magenta,   ""name"": intentionally not styling  regexp: red};

function stylizeWithColor(str, styleType) {  var style = inspect.styles[styleType];
  if (style) {    return [ + inspect.colors[style][0] + m + str +           [ + inspect.colors[style][1] + m;  } else {    return str;  }}

function stylizeNoColor(str, styleType) {  return str;}

function arrayToHash(array) {  var hash = {};
  array.forEach(function(val, idx) {    hash[val] = true;  });
  return hash;}

function formatValue(ctx, value, recurseTimes) {   Provide a hook for user-specified inspect functions.   Check that value is an object with an inspect function on it  if (ctx.customInspect &&      value &&      isFunction(value.inspect) &&       Filter out the util module, it's inspect function is special      value.inspect !== exports.inspect &&       Also filter out any prototype objects using the circular check.      !(value.constructor && value.constructor.prototype === value)) {    var ret = value.inspect(recurseTimes, ctx);    if (!isString(ret)) {      ret = formatValue(ctx, ret, recurseTimes);    }    return ret;  }
   Primitive types cannot have properties  var primitive = formatPrimitive(ctx, value);  if (primitive) {    return primitive;  }
   Look up the keys of the object.  var keys = Object.keys(value);  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {    keys = Object.getOwnPropertyNames(value);  }
   IE doesn't make error fields non-enumerable   http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx  if (isError(value)      && (keys.indexOf(message) >= 0 || keys.indexOf(description) >= 0)) {    return formatError(value);  }
   Some type of object without properties can be shortcutted.  if (keys.length === 0) {    if (isFunction(value)) {      var name = value.name ? :  + value.name : ;      return ctx.stylize([Function + name + ], special);    }    if (isRegExp(value)) {      return ctx.stylize(RegExp.prototype.toString.call(value), regexp);    }    if (isDate(value)) {      return ctx.stylize(Date.prototype.toString.call(value), date);    }    if (isError(value)) {      return formatError(value);    }  }
  var base = , array = false, braces = [{, }];
   Make Array say that they are Array  if (isArray(value)) {    array = true;    braces = [[, ]];  }
   Make functions say that they are functions  if (isFunction(value)) {    var n = value.name ? :  + value.name : ;    base =  [Function + n + ];  }
   Make RegExps say that they are RegExps  if (isRegExp(value)) {    base =   + RegExp.prototype.toString.call(value);  }
   Make dates with properties first say the date  if (isDate(value)) {    base =   + Date.prototype.toUTCString.call(value);  }
   Make error with message first say the error  if (isError(value)) {    base =   + formatError(value);  }
  if (keys.length === 0 && (!array || value.length == 0)) {    return braces[0] + base + braces[1];  }
  if (recurseTimes < 0) {    if (isRegExp(value)) {      return ctx.stylize(RegExp.prototype.toString.call(value), regexp);    } else {      return ctx.stylize([Object], special);    }  }
  ctx.seen.push(value);
  var output;  if (array) {    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);  } else {    output = keys.map(function(key) {      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);    });  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);}

function formatPrimitive(ctx, value) {  if (isUndefined(value))    return ctx.stylize(undefined, undefined);  if (isString(value)) {    var simple =  + JSON.stringify(value).replace(""""g, )                                             .replace('g, ')                                             .replace(""g, "") + ;    return ctx.stylize(simple, string);  }  if (isNumber(value))    return ctx.stylize( + value, number);  if (isBoolean(value))    return ctx.stylize( + value, boolean);   For some reason typeof null is ""object"", so special case here.  if (isNull(value))    return ctx.stylize(null, null);}

function formatError(value) {  return [ + Error.prototype.toString.call(value) + ];}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {  var output = [];  for (var i = 0, l = value.length; i < l; ++i) {    if (hasOwnProperty(value, String(i))) {      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,          String(i), true));    } else {      output.push();    }  }  keys.forEach(function(key) {    if (!key.match()) {      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,          key, true));    }  });  return output;}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {  var name, str, desc;  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };  if (desc.get) {    if (desc.set) {      str = ctx.stylize([Getter/Setter], special);    } else {      str = ctx.stylize([Getter], special);    }  } else {    if (desc.set) {      str = ctx.stylize([Setter], special);    }  }  if (!hasOwnProperty(visibleKeys, key)) {    name = [ + key + ];  }  if (!str) {    if (ctx.seen.indexOf(desc.value) < 0) {      if (isNull(recurseTimes)) {        str = formatValue(ctx, desc.value, null);      } else {        str = formatValue(ctx, desc.value, recurseTimes - 1);      }      if (str.indexOf() > -1) {        if (array) {          str = str.split().map(function(line) {            return    + line;          }).join().substr(2);        } else {          str =  + str.split().map(function(line) {            return     + line;          }).join();        }      }    } else {      str = ctx.stylize([Circular], special);    }  }  if (isUndefined(name)) {    if (array && key.match()) {      return str;    }    name = JSON.stringify( + key);    if (name.match(""()"")) {      name = name.substr(1, name.length - 2);      name = ctx.stylize(name, name);    } else {      name = name.replace('g, ')                 .replace(""g, "")                 .replace(("""")g, ');      name = ctx.stylize(name, string);    }  }
  return name + :  + str;}

function reduceToSingleString(output, base, braces) {  var numLinesEst = 0;  var length = output.reduce(function(prev, cur) {    numLinesEst++;    if (cur.indexOf() >= 0) numLinesEst++;    return prev + cur.replace(001bmg, ).length + 1;  }, 0);
  if (length > 60) {    return braces[0] +           (base ===  ?  : base +  ) +             +           output.join(,  ) +             +           braces[1];  }
  return braces[0] + base +   + output.join(, ) +   + braces[1];}

 NOTE: These type checking functions intentionally don't use `instanceof` because it is fragile and can be easily faked with `Object.create()`.function isArray(ar) {  return Array.isArray(ar);}exports.isArray = isArray;
function isBoolean(arg) {  return typeof arg === boolean;}exports.isBoolean = isBoolean;
function isNull(arg) {  return arg === null;}exports.isNull = isNull;
function isNullOrUndefined(arg) {  return arg == null;}exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {  return typeof arg === number;}exports.isNumber = isNumber;
function isString(arg) {  return typeof arg === string;}exports.isString = isString;
function isSymbol(arg) {  return typeof arg === symbol;}exports.isSymbol = isSymbol;
function isUndefined(arg) {  return arg === void 0;}exports.isUndefined = isUndefined;
function isRegExp(re) {  return isObject(re) && objectToString(re) === [object RegExp];}exports.isRegExp = isRegExp;
function isObject(arg) {  return typeof arg === object && arg !== null;}exports.isObject = isObject;
function isDate(d) {  return isObject(d) && objectToString(d) === [object Date];}exports.isDate = isDate;
function isError(e) {  return isObject(e) &&      (objectToString(e) === [object Error] || e instanceof Error);}exports.isError = isError;
function isFunction(arg) {  return typeof arg === function;}exports.isFunction = isFunction;
function isPrimitive(arg) {  return arg === null ||         typeof arg === boolean ||         typeof arg === number ||         typeof arg === string ||         typeof arg === symbol ||   ES6 symbol         typeof arg === undefined;}exports.isPrimitive = isPrimitive;
exports.isBuffer = require(./support/isBuffer);
function objectToString(o) {  return Object.prototype.toString.call(o);}

function pad(n) {  return n < 10 ? 0 + n.toString(10) : n.toString(10);}

var months = [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep,              Oct, Nov, Dec];
 26 Feb 16:19:34function timestamp() {  var d = new Date();  var time = [pad(d.getHours()),              pad(d.getMinutes()),              pad(d.getSeconds())].join(:);  return [d.getDate(), months[d.getMonth()], time].join( );}

 log is just a thin wrapper to console.log that prepends a timestampexports.log = function() {  console.log(%s - %s, timestamp(), exports.format.apply(exports, arguments));};

 * Inherit the prototype methods from one constructor into another. * * The Function.prototype.inherits from lang.js rewritten as a standalone * function (not on Function.prototype). NOTE: If this file is to be loaded * during bootstrapping this function needs to be rewritten using some native * functions as prototype setup using normal JavaScript does not work as * expected during bootstrapping (see mirror.js in r114903). * *    Constructor function which needs to inherit the *     prototype. *    Constructor function to inherit prototype from. */exports.inherits = require(inherits);
exports._extend = function(origin, add) {   Don't do anything if add isn't an object  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);  var i = keys.length;  while (i--) {    origin[keys[i]] = add[keys[i]];  }  return origin;};
function hasOwnProperty(obj, prop) {  return Object.prototype.hasOwnProperty.call(obj, prop);}
}).call(this,require(_process),typeof global !== undefined ? global : typeof self !== undefined ? self : typeof window !== undefined ? window : {})},{./support/isBuffer:83,_process:67,inherits:82}]},{},[1]);"
"module.exports = function (wallaby) {  return {    files: [      server/**/*.js,      client/**/*.js,      lib/**/*.js,      dist/**/*.js,      test/**/*.*,      !test/**/*.test.js    ],
    tests: [      test/**/*.test.js,      !test/integration/**/*.test.js    ],
    compilers: {      : wallaby.compilers.babel()    },
    env: {      type: node,      runner: node,      params: {        env: NODE_PATH=test/lib      }    },
    testFramework: jest  }}"
module.exports = require(./dist/lib/router)
module.exports = require(./dist/lib/prefetch)
module.exports = require(./dist/lib/link)
module.exports = require(./dist/lib/head)
"const notifier = require(node-notifier)const childProcess = require(child_process)const isWindows = win.test(process.platform)
export async function compile(fly) {  await fly.parallel([bin, server, lib, client])  await fly.start(unrestrict)}
export async function bin(fly, opts) {  await fly.source(opts.src || bin/*).babel().target(dist/bin, {mode: 0755})  notify(Compiled binaries)}
export async function lib(fly, opts) {  await fly.source(opts.src || lib/**/*.js).babel().target(dist/lib)  notify(Compiled lib files)}
export async function server(fly, opts) {  await fly.source(opts.src || server/**/*.js).babel().target(dist/server)  notify(Compiled server files)}
export async function client(fly, opts) {  await fly.source(opts.src || client/**/*.js).babel().target(dist/client)  notify(Compiled client files)}
export async function unrestrict(fly) {  await fly.source(dist/lib/eval-script.js).babel({    babelrc: false,    plugins: [babel-plugin-transform-remove-strict-mode]  }).target(dist/lib)  notify(Completed removing strict mode for eval script)}
export async function copy(fly) {  await fly.source(pages/**/*.js).target(dist/pages)}
export async function build(fly) {  await fly.serial([copy, compile])}
export default async function (fly) {  await fly.start(build)  await fly.watch(bin/*, bin)  await fly.watch(pages/**/*.js, copy)  await fly.watch(server/**/*.js, server)  await fly.watch(client/**/*.js, [client])  await fly.watch(lib/**/*.js, [lib])}
export async function release(fly) {  await fly.clear(dist).start(build)}
 We run following task inside a NPM script chain and it runs chromedriver inside a child process tree. Even though we kill this task's process, chromedriver exists throughout the lifetime of the original npm script.
export async function pretest(fly) {  const processName =  isWindows ? chromedriver.cmd : chromedriver  const chromedriver = childProcess.spawn(processName, { stdio: inherit })   We need to do this, otherwise this task's process will keep waiting.  setTimeout(() => process.exit(0), 2000)}
export async function posttest(fly) {  try {    const cmd = isWindows ? taskkill /im chromedriver* /t /f : pkill chromedriver    childProcess.execSync(cmd, { stdio: ignore })  } catch(err) {     Do nothing  }}
 notification helperfunction notify(msg) {  return notifier.notify({    title: ▲ Next,    message: msg,    icon: false  })}"
module.exports = require(./dist/lib/error)
module.exports = require(./dist/server/document)
module.exports = require(./dist/lib/css)
module.exports = require(./dist/server/build/babel/preset)
"use strict;
var fs = require(fs);var path = require(path);var mkdirp = require(mkdirp);var baseBundleDirpath = path.join(__dirname, .karma);var osName = require(os-name);
module.exports = function (config) {  var bundleDirpath;  var cfg = {    frameworks: [      browserify,      expect,      mocha    ],    files: [       we use the BDD interface for all of the tests that       aren't interface-specific.      test/browser-fixtures/bdd.fixture.js,      test/acceptance/*.spec.js    ],    exclude: [      test/acceptance/http.spec.js,      test/acceptance/fs.spec.js,      test/acceptance/file-utils.spec.js,      test/acceptance/require/**/*.js,      test/acceptance/misc/**/*.js    ],    preprocessors: {      test/**/*.js: [browserify]    },    browserify: {      debug: true,      configure: function configure (b) {        b.ignore(glob)          .ignore(fs)          .ignore(path)          .ignore(supports-color)          .on(bundled, function (err, content) {            if (!err && bundleDirpath) {               write bundle to directory for debugging              fs.writeFileSync(path.join(bundleDirpath,                bundle. + Date.now() + .js), content);            }          });      }    },    reporters: [spec],    colors: true,    browsers: [osName() === macOS Sierra ? Chrome : PhantomJS],  This is the default browser to run, locally    logLevel: config.LOG_INFO,    client: {      mocha: {        reporter: html      }    }  };
   see https://github.com/saucelabs/karma-sauce-example
   We define the browser to run on the Saucelabs Infrastructure   via the environment variables BROWSER and PLATFORM.   PLATFORM is e.g. ""Windows""   BROWSER is expected to be in the format ""<name>@<version>"",   e.g. ""MicrosoftEdge@latest""   See https://wiki.saucelabs.com/display/DOCS/Platform+Configurator#/   for available browsers.
   TO RUN LOCALLY, execute:   `CI=1 SAUCE_USERNAME=<user> SAUCE_ACCESS_KEY=<key> BROWSER=<browser> PLATFORM=<platform> make test-browser`  var env = process.env;  var sauceConfig;
  if (env.CI) {    console.error(CI mode enabled);    if (env.TRAVIS) {      console.error(Travis-CI detected);      bundleDirpath = path.join(baseBundleDirpath, process.env.TRAVIS_BUILD_ID);      if (env.BROWSER && env.PLATFORM) {        if (env.SAUCE_USERNAME && env.SAUCE_ACCESS_KEY) {           correlate build/tunnel with Travis          sauceConfig = {            build: TRAVIS # + env.TRAVIS_BUILD_NUMBER +             ( + env.TRAVIS_BUILD_ID + ),            tunnelIdentifier: env.TRAVIS_JOB_NUMBER          };          console.error(Configured SauceLabs);        } else {          console.error(No SauceLabs credentials present);        }      }    } else if (env.APPVEYOR) {      console.error(AppVeyor detected);      bundleDirpath = path.join(baseBundleDirpath, process.env.APPVEYOR_BUILD_ID);    } else {      console.error(Local/unknown environment detected);      bundleDirpath = path.join(baseBundleDirpath, local);       don't need to run sauce from appveyor b/c travis does it.      if (!(env.SAUCE_USERNAME || env.SAUCE_ACCESS_KEY)) {        console.error(No SauceLabs credentials present);      } else {        sauceConfig = {          build: require(os).hostname() +  ( + Date.now() + )        };        console.error(Configured SauceLabs);      }    }    mkdirp.sync(bundleDirpath);  } else {    console.error(CI mode disabled);  }
  if (sauceConfig) {    cfg.sauceLabs = sauceConfig;    addSauceTests(cfg);  }
   the MOCHA_UI env var will determine if we're running interface-specific   tests.  since you can only load one at a time, each must be run separately.   each has its own set of acceptance tests and a fixture.   the ""bdd"" fixture is used by default.  var ui = env.MOCHA_UI;  if (ui) {    if (cfg.sauceLabs) {      cfg.sauceLabs.testName = Interface "" + ui + "" integration tests;    }    cfg.files = [      test/browser-fixtures/ + ui + .fixture.js,      test/acceptance/interfaces/ + ui + .spec.js    ];  } else if (cfg.sauceLabs) {    cfg.sauceLabs.testName = Unit Tests;  }
  config.set(cfg);};
function addSauceTests (cfg) {  var env = process.env;  cfg.reporters.push(saucelabs);  cfg.customLaunchers = {};  cfg.customLaunchers[env.BROWSER] = {    base: SauceLabs,    browserName: env.BROWSER.split(@)[0],    version: env.BROWSER.split(@)[1],    platform: env.PLATFORM  };  cfg.browsers = [env.BROWSER];
   See https://github.com/karma-runner/karma-sauce-launcher   See https://github.com/bermi/sauce-connect-launcher#advanced-usage  cfg.sauceLabs = {    public: public,    startConnect: true,    connectOptions: {      connectRetries: 10,      connectRetryTimeout: 60000    }  };
  cfg.concurrency = 5;
  cfg.retryLimit = 5;
   for slow browser booting, ostensibly  cfg.captureTimeout = 120000;  cfg.browserNoActivityTimeout = 20000;}"
"use strict;
module.exports = require(./lib/mocha);"
"use strict;

 * Shim process.stdout. */
process.stdout = require(browser-stdout)();
var Mocha = require(./lib/mocha);
 * Create a Mocha instance. * *   */
var mocha = new Mocha({ reporter: html });
 * Save timer references to avoid Sinon interfering (see GH-237). */
var Date = global.Date;var setTimeout = global.setTimeout;var setInterval = global.setInterval;var clearTimeout = global.clearTimeout;var clearInterval = global.clearInterval;
var uncaughtExceptionHandlers = [];
var originalOnerrorHandler = global.onerror;
 * Remove uncaughtException listener. * Revert to original onerror handler if previously defined. */
process.removeListener = function (e, fn) {  if (e === uncaughtException) {    if (originalOnerrorHandler) {      global.onerror = originalOnerrorHandler;    } else {      global.onerror = function () {};    }    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);    if (i !== -1) {      uncaughtExceptionHandlers.splice(i, 1);    }  }};
 * Implements uncaughtException listener. */
process.on = function (e, fn) {  if (e === uncaughtException) {    global.onerror = function (err, url, line) {      fn(new Error(err +  ( + url + : + line + )));      return !mocha.allowUncaught;    };    uncaughtExceptionHandlers.push(fn);  }};
 The BDD UI is registered by default, but no UI will be functional in the browser without an explicit call to the overridden `mocha.ui` (see below). Ensure that this default UI does not expose its methods to the global scope.mocha.suite.removeAllListeners(pre-require);
var immediateQueue = [];var immediateTimeout;
function timeslice () {  var immediateStart = new Date().getTime();  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {    immediateQueue.shift()();  }  if (immediateQueue.length) {    immediateTimeout = setTimeout(timeslice, 0);  } else {    immediateTimeout = null;  }}
 * High-performance override of Runner.immediately. */
Mocha.Runner.immediately = function (callback) {  immediateQueue.push(callback);  if (!immediateTimeout) {    immediateTimeout = setTimeout(timeslice, 0);  }};
 * Function to allow assertion libraries to throw errors directly into mocha. * This is useful when running tests in a browser because window.onerror will * only receive the 'message' attribute of the Error. */mocha.throwError = function (err) {  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {    fn(err);  });  throw err;};
 * Override ui to ensure that the ui functions are initialized. * Normally this would happen in Mocha.prototype.loadFiles. */
mocha.ui = function (ui) {  Mocha.prototype.ui.call(this, ui);  this.suite.emit(pre-require, global, null, this);  return this;};
 * Setup mocha with the given setting options. */
mocha.setup = function (opts) {  if (typeof opts === string) {    opts = { ui: opts };  }  for (var opt in opts) {    if (opts.hasOwnProperty(opt)) {      this[opt](opts[opt]);    }  }  return this;};
 * Run mocha, returning the Runner. */
mocha.run = function (fn) {  var options = mocha.options;  mocha.globals(location);
  var query = Mocha.utils.parseQuery(global.location.search || );  if (query.grep) {    mocha.grep(query.grep);  }  if (query.fgrep) {    mocha.fgrep(query.fgrep);  }  if (query.invert) {    mocha.invert();  }
  return Mocha.prototype.run.call(mocha, function (err) {     The DOM Document is not available in Web Workers.    var document = global.document;    if (document && document.getElementById(mocha) && options.noHighlighting !== true) {      Mocha.utils.highlightTags(code);    }    if (fn) {      fn(err);    }  });};
 * Expose the process shim. * https://github.com/mochajs/mocha/pull/916 */
Mocha.process = process;
 * Expose mocha. */
global.Mocha = Mocha;global.mocha = mocha;
 this allows test/acceptance/required-tokens.js to pass; thus, you can now do `const describe = require('mocha').describe` in a browser context (assuming browserification).  should fix #880module.exports = global;"
"use strict
 Karma configurationmodule.exports = function (config) {  var basePath = .
  config.set({
     base path, that will be used to resolve files and exclude    basePath: basePath,
     frameworks to use    frameworks: [jasmine],    files: [      app.js,      packages/**/public/tests/**/*.js    ],     list of files to exclude    exclude: [],
     test results reporter to use     possible values: 'dots', 'progress', 'junit', 'growl', 'coverage'    reporters: [progress, coverage, junit],
    junitReporter: {      outputDir: tests/results/public/junit/    },
     coverage    preprocessors: {       source files that you want to generate coverage for       do not include tests or libraries       (these files will be instrumented by Istanbul)      packages/**/public/controllers/**/*.js: [coverage],      packages/**/public/services/**/*.js: [coverage],      packages/**/public/directives/**/*.js: [coverage],
      packages/**/public/**/*.html: [ng-html2js],
       'packages/**/public/tests/**/*.js': ['webpack', 'babel'],      app.js: [webpack]    },
    webpack: require(./webpack.test.js),    webpackMiddleware: {      noInfo: true    },
    coverageReporter: {      type: html,      dir: tests/results/coverage/    },
    ngHtml2JsPreprocessor: {      cacheIdFromPath: function (path) {        var cacheId = path
         Strip packages/custom/ and public/ to match the pattern of URL that mean.io uses        cacheId = cacheId.replace(packages/custom/, )        cacheId = cacheId.replace(public/, )
        return cacheId      }    },
     web server port    port: 9876,     Look for server on port 3001 (invoked by mocha) - via @brownman    proxies: {      /: http://localhost:3001/    },
     enable / disable colors in the output (reporters and logs)    colors: true,
     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_INFO,
     enable / disable watching file and executing tests whenever any file changes    autoWatch: false,
     Start these browsers, currently available:     - Chrome     - ChromeCanary     - Firefox     - Opera     - Safari (only Mac)     - PhantomJS     - IE (only Windows)    browsers: [PhantomJS],
     If browser does not capture in given timeout [ms], kill it    captureTimeout: 60000,     How long will Karma wait for a message from a browser before disconnecting from it (in ms).    browserNoActivityTimeout: 60000,     Continuous Integration mode     if true, it capture browsers, run tests and exit    singleRun: true,    plugins: [      karma-jasmine,      karma-webpack,      karma-ng-html2js-preprocessor,      karma-phantomjs-launcher,      karma-coverage,      karma-junit-reporter    ]  })}"
"use strict
var gulp = require(gulp)
var env = process.env.NODE_ENV || developmentvar defaultTasks = ['clean', 'jshint', 'csslint','serve','watch'] // initialize with development settingsif (env === 'production') { var defaultTasks = ['clean', 'cssmin', 'uglify', 'serve', 'watch'];}if (env === 'test')       { var defaultTasks = ['env:test', 'karma:unit', 'mochaTest'];} read gulp directory contents for the tasks...require(require-dir)(./gulp)console.log(Invoking gulp -, env)gulp.task(default, [clean], function (defaultTasks) {   run with paramater  gulp.start(env)})"
"use strict;
import angular/angular-csp.css;import angular-ui-select/select.min.css;import angular-material/angular-material.min.css;
import jQuery from jquery;import angular;import angular-ui-select/select;import angular-mocks;import angular-cookies;import angular-resource;import angular-sanitize;import angular-ui-router;import angular-jwt;import angular-aria;import angular-animate;import angular-material;
window.$ = jQuery;
angular.element(document).ready(function () {   Fixing facebook bug with redirect  if (window.location.hash === #_=_) {    window.location.hash = #!;  }
   Then init the app  angular.bootstrap(document, [mean]);});
function processModules (modules) {  var packageModules = [ngCookies, ngResource, ui.router, ui.select, ngSanitize, ngMaterial];  var m;  var mn;  for (var index in modules) {    m = modules[index];    mn = mean. + m.name;    angular.module(mn, m.angularDependencies || []);    packageModules.push(mn);  }
  var req = require.context(./packages, true, public(?!testsassetsviews)()js);  req.keys().map(req);  req = require.context(./node_modules, true, meanio-()public(?!testsassetsviews)()js);  req.keys().map(req);  angular.module(mean, packageModules);}
jQuery.ajax(/_getModules, {  dataType: json,  async: false,  success: processModules});"
"use strict;
 Ensure the same AVA install is loaded by the test file as by the test workerif (process.env.AVA_PATH && process.env.AVA_PATH !== __dirname) {	module.exports = require(process.env.AVA_PATH);  eslint-disable-line import/no-dynamic-require} else {	module.exports = require(./lib/main);}"
"#!/usr/bin/env nodeuse strict;const path = require(path);const debug = require(debug)(ava);
 Prefer the local installation of AVA.const resolveCwd = require(resolve-cwd);const localCLI = resolveCwd(ava/cli);
 Use `path.relative()` to detect local AVA installation, because __filename's case is inconsistent on Windows see https://github.com/nodejs/node/issues/6624if (localCLI && path.relative(localCLI, __filename) !== ) {	debug(Using local install of AVA);	require(localCLI);  eslint-disable-line import/no-dynamic-require} else {	if (debug.enabled) {		require(time-require);  eslint-disable-line import/no-unassigned-import	}
	try {		require(./lib/cli).run();	} catch (err) {		console.error(  );		process.exit(1);	}}"
"use strict;const EventEmitter = require(events);const path = require(path);const fs = require(fs);const commonPathPrefix = require(common-path-prefix);const uniqueTempDir = require(unique-temp-dir);const findCacheDir = require(find-cache-dir);const resolveCwd = require(resolve-cwd);const debounce = require(lodash.debounce);const autoBind = require(auto-bind);const Promise = require(bluebird);const getPort = require(get-port);const arrify = require(arrify);const ms = require(ms);const babelConfigHelper = require(./lib/babel-config);const CachingPrecompiler = require(./lib/caching-precompiler);const RunStatus = require(./lib/run-status);const AvaError = require(./lib/ava-error);const AvaFiles = require(./lib/ava-files);const fork = require(./lib/fork);
function resolveModules(modules) {	return arrify(modules).map(name => {		const modulePath = resolveCwd(name);
		if (modulePath === null) {			throw new Error(Could not resolve required module '');		}
		return modulePath;	});}
function getBlankResults() {	return {		stats: {			knownFailureCount: 0,			testCount: 0,			passCount: 0,			skipCount: 0,			todoCount: 0,			failCount: 0		},		tests: []	};}
class Api extends EventEmitter {	constructor(options) {		super();		autoBind(this);
		this.options = Object.assign({match: []}, options);		this.options.require = resolveModules(this.options.require);	}	_runFile(file, runStatus, execArgv) {		const hash = this.precompiler.precompileFile(file);		const precompiled = Object.assign({}, this._precompiledHelpers);		const resolvedfpath = fs.realpathSync(file);		precompiled[resolvedfpath] = hash;
		const options = Object.assign({}, this.options, {precompiled});		const emitter = fork(file, options, execArgv);		runStatus.observeFork(emitter);
		return emitter;	}	run(files, options) {		return new AvaFiles({cwd: this.options.resolveTestsFrom, files})			.findTestFiles()			.then(files => this._run(files, options));	}	_onTimeout(runStatus) {		const timeout = ms(this.options.timeout);		const err = new AvaError(Exited because no new tests completed within the last ms of inactivity);		this._handleError(runStatus, err);		runStatus.emit(timeout);	}	_setupTimeout(runStatus) {		const timeout = ms(this.options.timeout);
		runStatus._restartTimer = debounce(() => {			this._onTimeout(runStatus);		}, timeout);
		runStatus._restartTimer();		runStatus.on(test, runStatus._restartTimer);	}	_cancelTimeout(runStatus) {		runStatus._restartTimer.cancel();	}	_setupPrecompiler(files) {		const isCacheEnabled = this.options.cacheEnabled !== false;		let cacheDir = uniqueTempDir();
		if (isCacheEnabled) {			const foundDir = findCacheDir({				name: ava,				files			});			if (foundDir !== null) {				cacheDir = foundDir;			}		}
		this.options.cacheDir = cacheDir;
		const isPowerAssertEnabled = this.options.powerAssert !== false;		return babelConfigHelper.build(this.options.projectDir, cacheDir, this.options.babelConfig, isPowerAssertEnabled)			.then(result => {				this.precompiler = new CachingPrecompiler({					path: cacheDir,					getBabelOptions: result.getOptions,					babelCacheKeys: result.cacheKeys				});			});	}	_precompileHelpers() {		this._precompiledHelpers = {};
		 Assumes the tests only load helpers from within the `resolveTestsFrom`		 directory. Without arguments this is the `projectDir`, else it's		 `process.cwd()` which may be nested too deeply. This will be solved		 as we implement RFC 001 and move helper compilation into the worker		 processes, avoiding the need for precompilation.		return new AvaFiles({cwd: this.options.resolveTestsFrom})			.findTestHelpers()			.map(file => {  eslint-disable-line array-callback-return				const hash = this.precompiler.precompileFile(file);				this._precompiledHelpers[file] = hash;			});	}	_run(files, options) {		options = options || {};
		const runStatus = new RunStatus({			runOnlyExclusive: options.runOnlyExclusive,			prefixTitles: this.options.explicitTitles || files.length > 1,			base: path.relative(process.cwd(), commonPathPrefix(files)) + path.sep,			failFast: this.options.failFast		});
		this.emit(test-run, runStatus, files);
		if (files.length === 0) {			const err = new AvaError(Couldnt find any files to test);			this._handleError(runStatus, err);			return Promise.resolve(runStatus);		}
		return this._setupPrecompiler(files)			.then(() => this._precompileHelpers())			.then(() => {				if (this.options.timeout) {					this._setupTimeout(runStatus);				}
				let overwatch;				if (this.options.concurrency > 0) {					const concurrency = this.options.serial ? 1 : this.options.concurrency;					overwatch = this._runWithPool(files, runStatus, concurrency);				} else {					 _runWithoutPool exists to preserve legacy behavior, specifically around `.only`					overwatch = this._runWithoutPool(files, runStatus);				}
				return overwatch;			});	}	_computeForkExecArgs(files) {		const execArgv = this.options.testOnlyExecArgv || process.execArgv;		let debugArgIndex = -1;
		 --debug-brk is used in addition to --inspect to break on first line and wait		execArgv.some((arg, index) => {			const isDebugArg = arg === --inspect || arg.indexOf(--inspect=) === 0;			if (isDebugArg) {				debugArgIndex = index;			}
			return isDebugArg;		});
		const isInspect = debugArgIndex >= 0;		if (!isInspect) {			execArgv.some((arg, index) => {				const isDebugArg = arg === --debug || arg === --debug-brk || arg.indexOf(--debug-brk=) === 0 || arg.indexOf(--debug=) === 0;				if (isDebugArg) {					debugArgIndex = index;				}
				return isDebugArg;			});		}
		if (debugArgIndex === -1) {			return Promise.resolve([]);		}
		return Promise			.map(files, () => getPort())			.map(port => {				const forkExecArgv = execArgv.slice();				let flagName = isInspect ? --inspect : --debug;				const oldValue = forkExecArgv[debugArgIndex];				if (oldValue.indexOf(brk) > 0) {					flagName += -brk;				}
				forkExecArgv[debugArgIndex] = =;
				return forkExecArgv;			});	}	_handleError(runStatus, err) {		runStatus.handleExceptions({			exception: err,			file: err.file ? path.relative(process.cwd(), err.file) : undefined		});	}	_runWithoutPool(files, runStatus) {		const tests = [];		let execArgvList;
		 TODO: This should be cleared at the end of the run		runStatus.on(timeout, () => {			tests.forEach(fork => {				fork.exit();			});		});
		return this._computeForkExecArgs(files)			.then(argvList => {				execArgvList = argvList;			})			.return(files)			.each((file, index) => {				return new Promise(resolve => {					const forkArgs = execArgvList[index];					const test = this._runFile(file, runStatus, forkArgs);					tests.push(test);					test.on(stats, resolve);					test.catch(resolve);				}).catch(err => {					err.results = [];					err.file = file;					return Promise.reject(err);				});			})			.then(() => {				if (this.options.match.length > 0 && !runStatus.hasExclusive) {					const err = new AvaError(Couldnt find any matching tests);					err.file = undefined;					err.results = [];					return Promise.reject(err);				}
				const method = this.options.serial ? mapSeries : map;				const options = {					runOnlyExclusive: runStatus.hasExclusive				};
				return Promise[method](files, (file, index) => {					return tests[index].run(options).catch(err => {						err.file = file;						this._handleError(runStatus, err);						return getBlankResults();					});				});			})			.catch(err => {				this._handleError(runStatus, err);				return err.results;			})			.tap(results => {				 If no tests ran, make sure to tear down the child processes				if (results.length === 0) {					tests.forEach(test => {						test.send(teardown);					});				}			})			.then(results => {				 Cancel debounced _onTimeout() from firing				if (this.options.timeout) {					this._cancelTimeout(runStatus);				}
				runStatus.processResults(results);
				return runStatus;			});	}	_runWithPool(files, runStatus, concurrency) {		const tests = [];		let execArgvList;
		runStatus.on(timeout, () => {			tests.forEach(fork => {				fork.exit();			});		});
		return this._computeForkExecArgs(files)			.then(argvList => {				execArgvList = argvList;			})			.return(files)			.map((file, index) => {				return new Promise(resolve => {					const forkArgs = execArgvList[index];					const test = this._runFile(file, runStatus, forkArgs);					tests.push(test);
					 If we're looking for matches, run every single test process in exclusive-only mode					const options = {						runOnlyExclusive: this.options.match.length > 0					};
					resolve(test.run(options));				}).catch(err => {					err.file = file;					this._handleError(runStatus, err);					return getBlankResults();				});			}, {concurrency})			.then(results => {				 Filter out undefined results (usually result of caught exceptions)				results = results.filter(Boolean);
				 Cancel debounced _onTimeout() from firing				if (this.options.timeout) {					this._cancelTimeout(runStatus);				}
				if (this.options.match.length > 0 && !runStatus.hasExclusive) {					results = [];
					const err = new AvaError(Couldnt find any matching tests);					this._handleError(runStatus, err);				}
				runStatus.processResults(results);
				return runStatus;			});	}}
module.exports = Api;"
"module.exports = {	app: {		openDevToolsDetached: true,		hideMainWindow: true	},	workSpaceDirectory: () => __dirname};"
"var browserify = require(browserify);
var packages = require(./admin/client/packages);var b = browserify({	debug: process.env.NODE_ENV !== production,});packages.forEach(function (i) { b.require(i); });b.bundle().pipe(process.stdout);"
"use strict;
  * The entry point.  *  *    */module.exports = require(./lib/sequelize);"
" * React Starter Kit (https://www.reactstarterkit.com/) * * Copyright © 2014-present Kriasoft, LLC. All rights reserved. * * This source code is licensed under the MIT license found in the * LICENSE.txt file in the root directory of this source tree. */
 ESLint configuration http://eslint.org/docs/user-guide/configuringmodule.exports = {    parser: babel-eslint,
    extends: [      airbnb,      plugin:css-modules/recommended,    ],
    plugins: [      css-modules,    ],
    globals: {      __DEV__: true,    },
    env: {      browser: true,    },
    rules: {       `js` and `jsx` are common extensions       `mjs` is for `universal-router` only, for now      import/extensions: [        error,        always,        {          js: never,          jsx: never,          mjs: never,        },      ],
       Not supporting nested package.json yet       https://github.com/benmosher/eslint-plugin-import/issues/458      import/no-extraneous-dependencies: off,
       Recommend not to leave any console.log in your code       Use console.error, console.warn and console.info instead      no-console: [        error,        {          allow: [warn, error, info],        },      ],
       Allow js files to use jsx syntax, too      react/jsx-filename-extension: off,
       https://github.com/kriasoft/react-starter-kit/pull/961       You can reopen this if you still want this rule      react/prefer-stateless-function: off,    },  };"
"module.exports = function(grunt) {  require(load-grunt-tasks)(grunt);
  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),    meta: {      banner:     },
    clean: {      dist: dist/**    },
    ts: {      test: {        options: {          lib: [            es5,            es2015.promise,            dom          ]        },        src: [typings/index.d.ts, test/typescript/*.ts]      }    },
    package2bower: {      all: {        fields: [          name,          description,          version,          homepage,          license,          keywords        ]      }    },
    usebanner: {      all: {        options: {          banner: <%= meta.banner %>,          linebreak: false        },        files: {          src: [dist/*.js]        }      }    },
    eslint: {      target: [lib/**/*.js]    },
    karma: {      options: {        configFile: karma.conf.js      },      single: {        singleRun: true      },      continuous: {        singleRun: false      }    },
    nodeunit: {      all: [test/unit/**/*.js]    },
    watch: {      build: {        files: [lib/**/*.js],        tasks: [build]      },      test: {        files: [lib/**/*.js, test/**/*.js, !test/typescript/axios.js, !test/typescript/out.js],        tasks: [test]      }    },
    webpack: require(./webpack.config.js)  });
  grunt.registerMultiTask(package2bower, Sync package.json to bower.json, function () {    var npm = grunt.file.readJSON(package.json);    var bower = grunt.file.readJSON(bower.json);    var fields = this.data.fields || [];
    for (var i=0, l=fields.length; i<l; i++) {      var field = fields[i];      bower[field] = npm[field];    }
    grunt.file.write(bower.json, JSON.stringify(bower, null, 2));  });
  grunt.registerTask(test, Run the jasmine and nodeunit tests, [eslint, nodeunit, karma:single, ts]);  grunt.registerTask(build, Run webpack and bundle the source, [clean, webpack]);  grunt.registerTask(version, Sync version info for a release, [usebanner, package2bower]);};"
"var webpack = require(webpack);var config = {};
function generateConfig(name) {  var uglify = name.indexOf(min) > -1;  var config = {    entry: ./index.js,    output: {      path: dist/,      filename: name + .js,      sourceMapFilename: name + .map,      library: axios,      libraryTarget: umd    },    node: {      process: false    },    devtool: source-map  };
  config.plugins = [    new webpack.DefinePlugin({      process.env.NODE_ENV: JSON.stringify(process.env.NODE_ENV)    })  ];
  if (uglify) {    config.plugins.push(      new webpack.optimize.UglifyJsPlugin({        compressor: {          warnings: false        }      })    );  }
  return config;}
[axios, axios.min].forEach(function (key) {  config[key] = generateConfig(key);});
module.exports = config;"
" Karma configuration Generated on Fri Aug 15 2014 23:11:13 GMT-0500 (CDT)
var webpack = require(webpack);
function createCustomLauncher(browser, version, platform) {  return {    base: SauceLabs,    browserName: browser,    version: version,    platform: platform  };}
module.exports = function(config) {  var customLaunchers = {};  var browsers = [];
  if (process.env.SAUCE_USERNAME || process.env.SAUCE_ACCESS_KEY) {    customLaunchers = {};
    var runAll = true;    var options = [      SAUCE_CHROME,      SAUCE_FIREFOX,      SAUCE_SAFARI,      SAUCE_OPERA,      SAUCE_IE,      SAUCE_EDGE,      SAUCE_IOS,      SAUCE_ANDROID    ];
    options.forEach(function (opt) {      if (process.env[opt]) {        runAll = false;      }    });
     Chrome    if (runAll || process.env.SAUCE_CHROME) {      customLaunchers.SL_Chrome = createCustomLauncher(chrome);       customLaunchers.SL_ChromeDev = createCustomLauncher('chrome', 'dev');       customLaunchers.SL_ChromeBeta = createCustomLauncher('chrome', 'beta');    }
     Firefox    if (runAll || process.env.SAUCE_FIREFOX) {      customLaunchers.SL_Firefox = createCustomLauncher(firefox);       customLaunchers.SL_FirefoxDev = createCustomLauncher('firefox', 'dev');       customLaunchers.SL_FirefoxBeta = createCustomLauncher('firefox', 'beta');    }
     Safari    if (runAll || process.env.SAUCE_SAFARI) {       customLaunchers.SL_Safari7 = createCustomLauncher('safari', 7);       customLaunchers.SL_Safari8 = createCustomLauncher('safari', 8);
      customLaunchers.SL_Safari9 = createCustomLauncher(safari, 9);    }
     Opera    if (runAll || process.env.SAUCE_OPERA) {       TODO The available versions of Opera are too old and lack basic APIs       customLaunchers.SL_Opera11 = createCustomLauncher('opera', 11, 'Windows XP');       customLaunchers.SL_Opera12 = createCustomLauncher('opera', 12, 'Windows 7');    }
     IE    if (runAll || process.env.SAUCE_IE) {       customLaunchers.SL_IE8 = createCustomLauncher('internet explorer', 8, 'Windows 7');      customLaunchers.SL_IE9 = createCustomLauncher(internet explorer, 9, Windows 2008);      customLaunchers.SL_IE10 = createCustomLauncher(internet explorer, 10, Windows 2012);      customLaunchers.SL_IE11 = createCustomLauncher(internet explorer, 11, Windows 8.1);    }
     Edge    if (runAll || process.env.SAUCE_EDGE) {      customLaunchers.SL_Edge = createCustomLauncher(microsoftedge, null, Windows 10);    }
     IOS    if (runAll || process.env.SAUCE_IOS) {       TODO IOS7 capture always timesout       customLaunchers.SL_IOS7 = createCustomLauncher('iphone', '7.1', 'OS X 10.10');       TODO Mobile browsers are causing failures, possibly from too many concurrent VMs       customLaunchers.SL_IOS8 = createCustomLauncher('iphone', '8.4', 'OS X 10.10');       customLaunchers.SL_IOS9 = createCustomLauncher('iphone', '9.2', 'OS X 10.10');    }
     Android    if (runAll || process.env.SAUCE_ANDROID) {       TODO Mobile browsers are causing failures, possibly from too many concurrent VMs       customLaunchers.SL_Android4 = createCustomLauncher('android', '4.4', 'Linux');       customLaunchers.SL_Android5 = createCustomLauncher('android', '5.1', 'Linux');    }
    browsers = Object.keys(customLaunchers);  } else if (process.env.TRAVIS_PULL_REQUEST && process.env.TRAVIS_PULL_REQUEST !== false) {    console.log(      Cannot run on Sauce Labs as encrypted environment variables are not available to PRs.  +      Running on Travis.    );    browsers = [Firefox];  } else {    console.log(Running locally since SAUCE_USERNAME and SAUCE_ACCESS_KEY environment variables are not set.);    browsers = [Firefox, Chrome, Safari, Opera];  }
  config.set({     base path that will be used to resolve all patterns (eg. files, exclude)    basePath: ,

     frameworks to use     available frameworks: https://npmjs.org/browse/keyword/karma-adapter    frameworks: [jasmine-ajax, jasmine, sinon],

     list of files / patterns to load in the browser    files: [      test/specs/__helpers.js,      test/specs/**/*.spec.js,    ],

     list of files to exclude    exclude: [
    ],

     preprocess matching files before serving them to the browser     available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor    preprocessors: {      test/specs/__helpers.js: [webpack, sourcemap],      test/specs/**/*.spec.js: [webpack, sourcemap]    },

     test results reporter to use     possible values: 'dots', 'progress'     available reporters: https://npmjs.org/browse/keyword/karma-reporter    reporters: [dots, coverage, saucelabs],

     web server port    port: 9876,

     Increase timeouts to prevent the issue with disconnected tests (https://goo.gl/nstA69)    captureTimeout: 4  60  1000,    browserDisconnectTimeout: 10000,    browserDisconnectTolerance: 1,    browserNoActivityTimeout: 4  60  1000,

     enable / disable colors in the output (reporters and logs)    colors: true,

     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_INFO,

     enable / disable watching file and executing tests whenever any file changes    autoWatch: false,

     start these browsers     available browser launchers: https://npmjs.org/browse/keyword/karma-launcher    browsers: browsers,

     Continuous Integration mode     if true, Karma captures browsers, runs the tests and exits    singleRun: false,
     Webpack config    webpack: {      cache: true,      devtool: inline-source-map,      module: {        postLoaders: [          {            test: js,            exclude: (node_modulestest),            loader: istanbul-instrumenter          }        ]      },      externals: [        {          ./adapters/http: var undefined        }      ],      plugins: [        new webpack.DefinePlugin({          process.env.NODE_ENV: JSON.stringify(test)        })      ]    },
    webpackServer: {      stats: {        colors: true      }    },

     Coverage reporting    coverageReporter: {      type: lcov,      dir: coverage/,      subdir: .    },

     SauceLabs config    sauceLabs: {      recordScreenshots: false,      connectOptions: {        port: 5757,        logfile: sauce_connect.log      },      public: public    },
    customLaunchers: customLaunchers  });};"
module.exports = require(./lib/axios);
" * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
var debug  = require(debug)(pm2:conf);var p      = require(path);var util   = require(util);var chalk  = require(chalk);var semver = require(semver);
 * Get PM2 path structure */var path_structure = require(./paths.js)(process.env.OVER_HOME);
 * Constants variables used by PM2 */var csts = {  PREFIX_MSG              : chalk.green([PM2] ),  PREFIX_MSG_ERR          : chalk.red([PM2][ERROR] ),  PREFIX_MSG_MOD          : chalk.bold.green([PM2][Module] ),  PREFIX_MSG_MOD_ERR      : chalk.red([PM2][Module][ERROR] ),  PREFIX_MSG_WARNING      : chalk.yellow([PM2][WARN] ),  PREFIX_MSG_SUCCESS      : chalk.cyan([PM2] ),
  TEMPLATE_FOLDER         : p.join(__dirname, lib/templates),
  APP_CONF_TPL            : ecosystem.tpl,  APP_CONF_TPL_SIMPLE     : ecosystem-simple.tpl,  SAMPLE_CONF_FILE        : sample-conf.js,  LOGROTATE_SCRIPT        : logrotate.d/pm2,
  DOCKERFILE_NODEJS       : Dockerfiles/Dockerfile-nodejs.tpl,  DOCKERFILE_JAVA         : Dockerfiles/Dockerfile-java.tpl,  DOCKERFILE_RUBY         : Dockerfiles/Dockerfile-ruby.tpl,
  SUCCESS_EXIT            : 0,  ERROR_EXIT              : 1,  CODE_UNCAUGHTEXCEPTION  : 1,
  IS_WINDOWS              : (process.platform === win32 || process.platform === win64),  ONLINE_STATUS           : online,  STOPPED_STATUS          : stopped,  STOPPING_STATUS         : stopping,  LAUNCHING_STATUS        : launching,  ERRORED_STATUS          : errored,  ONE_LAUNCH_STATUS       : one-launch-status,
  CLUSTER_MODE_ID         : cluster_mode,  FORK_MODE_ID            : fork_mode,
  KEYMETRICS_ROOT_URL     : process.env.KEYMETRICS_NODE || root.keymetrics.io,  KEYMETRICS_BANNER       : ../lib/keymetrics,  DEFAULT_MODULE_JSON     : package.json,
  REMOTE_PORT_TCP         : isNaN(parseInt(process.env.KEYMETRICS_PUSH_PORT)) ? 80 : parseInt(process.env.KEYMETRICS_PUSH_PORT),  REMOTE_PORT             : 41624,  REMOTE_REVERSE_PORT     : isNaN(parseInt(process.env.KEYMETRICS_REVERSE_PORT)) ? 43554 : parseInt(process.env.KEYMETRICS_REVERSE_PORT),  REMOTE_HOST             : s1.keymetrics.io,  SEND_INTERVAL           : 1000,  GRACEFUL_TIMEOUT        : parseInt(process.env.PM2_GRACEFUL_TIMEOUT) || 8000,  GRACEFUL_LISTEN_TIMEOUT : parseInt(process.env.PM2_GRACEFUL_LISTEN_TIMEOUT) || 3000,  LOGS_BUFFER             : 10,  CONTEXT_ON_ERROR        : 2,  AGGREGATION_DURATION    : process.env.PM2_DEBUG || process.env.NODE_ENV === test || process.env.NODE_ENV === development ? 3000 : 5  60000,  TRACE_FLUSH_INTERVAL    : process.env.PM2_DEBUG || process.env.NODE_ENV === local_test ? 1000 : 60000,
   Concurrent actions when doing start/restart/reload  CONCURRENT_ACTIONS      : (function() {    var concurrent_actions = parseInt(process.env.PM2_CONCURRENT_ACTIONS) || 1;    if (semver.satisfies(process.versions.node, >= 4.0.0))      concurrent_actions = 2;    debug(Using %d parallelism (CONCURRENT_ACTIONS), concurrent_actions);    return concurrent_actions;  })(),
  DEBUG                   : process.env.PM2_DEBUG || false,  WEB_IPADDR              : process.env.PM2_API_IPADDR || 0.0.0.0,  WEB_PORT                : parseInt(process.env.PM2_API_PORT)  || 9615,  MODIFY_REQUIRE          : process.env.PM2_MODIFY_REQUIRE || false,
  WORKER_INTERVAL         : process.env.PM2_WORKER_INTERVAL || 30000,  KILL_TIMEOUT            : process.env.PM2_KILL_TIMEOUT || 1600,  PM2_PROGRAMMATIC        : typeof(process.env.pm_id) !== undefined || process.env.PM2_PROGRAMMATIC,  PM2_LOG_DATE_FORMAT     : process.env.PM2_LOG_DATE_FORMAT !== undefined ? process.env.PM2_LOG_DATE_FORMAT : YYYY-MM-DD HH:mm:ss
};
module.exports = util._extend(csts, path_structure);"
"
 * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
var debug = require(debug)(pm2:paths);var p     = require(path);
function getDefaultPM2Home() {  var PM2_ROOT_PATH;
  if (process.env.PM2_HOME)    PM2_ROOT_PATH = process.env.PM2_HOME;  else if (process.env.HOME && !process.env.HOMEPATH)    PM2_ROOT_PATH = p.resolve(process.env.HOME, .pm2);  else if (process.env.HOME || process.env.HOMEPATH)    PM2_ROOT_PATH = p.resolve(process.env.HOMEDRIVE, process.env.HOME || process.env.HOMEPATH, .pm2);  else {    console.error([PM2][Initialization] Environment variable HOME (Linux) or HOMEPATH (Windows) are not set!);    console.error([PM2][Initialization] Defaulting to /etc/.pm2);    PM2_ROOT_PATH = p.resolve(/etc, .pm2);  }
  debug(pm2 home resolved to %s, PM2_ROOT_PATH, process.env.HOME);  return PM2_ROOT_PATH;}
module.exports = function(PM2_HOME) {  if (!PM2_HOME)    PM2_HOME = getDefaultPM2Home()
  var pm2_file_stucture = {    PM2_HOME                 : PM2_HOME,    PM2_ROOT_PATH            : PM2_HOME,
    PM2_CONF_FILE            : p.resolve(PM2_HOME, conf.js),    PM2_MODULE_CONF_FILE     : p.resolve(PM2_HOME, module_conf.json),
    PM2_LOG_FILE_PATH        : p.resolve(PM2_HOME, pm2.log),    PM2_PID_FILE_PATH        : p.resolve(PM2_HOME, pm2.pid),
    DEFAULT_PID_PATH         : p.resolve(PM2_HOME, pids),    DEFAULT_LOG_PATH         : p.resolve(PM2_HOME, logs),    DUMP_FILE_PATH           : p.resolve(PM2_HOME, dump.pm2),
    DAEMON_RPC_PORT          : p.resolve(PM2_HOME, rpc.sock),    DAEMON_PUB_PORT          : p.resolve(PM2_HOME, pub.sock),    INTERACTOR_RPC_PORT      : p.resolve(PM2_HOME, interactor.sock),
    INTERACTOR_LOG_FILE_PATH : p.resolve(PM2_HOME, agent.log),    INTERACTOR_PID_PATH      : p.resolve(PM2_HOME, agent.pid),    INTERACTION_CONF         : p.resolve(PM2_HOME, agent.json5)  };
  if (process.platform === win32 ||      process.platform === win64) {    @todo instead of static unique rpc/pub file custom with PM2_HOME or UID    pm2_file_stucture.DAEMON_RPC_PORT = .piperpc.sock;    pm2_file_stucture.DAEMON_PUB_PORT = .pipepub.sock;    pm2_file_stucture.INTERACTOR_RPC_PORT = .pipeinteractor.sock;  }
  return pm2_file_stucture;};"
" * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
process.env.PM2_PROGRAMMATIC = true;
var API = require(./lib/API.js);
module.exports = new API;module.exports.custom = API;"
" This is not the main file in the npm package, but here so we can use github tarballs as packages when necessary.module.exports = require(./build/);"
"module.exports = function(config) {    config.set({        browsers: [Firefox],        files: [mocha_test/*.js],        frameworks: [browserify, mocha],        preprocessors: {            mocha_test/*.js: [browserify]        },        reporters: [mocha],        singleRun: true,
        browserify: {            debug: true,            transform: [babelify]        },
        client: {            mocha: {                grep: @nodeonly,                invert: true            }        }    });};"
" * express * Copyright(c) 2009-2013 TJ Holowaychuk * Copyright(c) 2013 Roman Shtylman * Copyright(c) 2014-2015 Douglas Christopher Wilson * MIT Licensed */
use strict;
module.exports = require(./lib/express);"
"const gulp = require(gulp);const mocha = require(gulp-mocha);const babel = require(gulp-babel);const istanbul = require(gulp-istanbul);const help = require(gulp-task-listing);const del = require(del);
gulp.task(help, help);
gulp.task(default, [transpile]);
const TRANSPILE_DEST_DIR = ./dist;
 By default, individual js files are transformed by babel and exported to /distgulp.task(transpile, function () {  return gulp.src(lib/*.js)    .pipe(babel({ presets: [es2015] }))    .pipe(gulp.dest(TRANSPILE_DEST_DIR));});
gulp.task(clean, function () {  return del([TRANSPILE_DEST_DIR]);})
gulp.task(test, [transpile], function(){  return gulp.src(test/socket.io.js, {read: false})    .pipe(mocha({      slow: 200,      reporter: spec,      bail: true,      timeout: 10000    }))    .once(error, function (err) {      console.error(err.stack);      process.exit(1);    })    .once(end, function () {      process.exit();    });});
gulp.task(set-compat-node-env, function() {  process.env.TEST_VERSION = compat;});
gulp.task(test-compat, [set-compat-node-env, test]);
gulp.task(istanbul-pre-test, function () {  return gulp.src([lib/**/*.js])     Covering files    .pipe(istanbul())     Force `require` to return covered files    .pipe(istanbul.hookRequire());});
gulp.task(test-cov, [istanbul-pre-test], function(){  return gulp.src(test/socket.io.js, {read: false})    .pipe(mocha({      reporter: dot    }))    .pipe(istanbul.writeReports())    .once(error, function (err){      console.error(err.stack);      process.exit(1);    })    .once(end, function (){      process.exit();    });});"
code
" * This file/module contains all configuration for the build process. */module.exports = {     * The `build_dir` folder is where our projects are compiled during   * development and the `compile_dir` folder is where our app resides once it's   * completely built.   */  build_dir: build,  compile_dir: bin,  vendor_dir: vendor,
     * This is a collection of file patterns that refer to our app code (the   * stuff in `src/`). These file paths are used in the configuration of   * build tasks. `js` is all project javascript, less tests. `ctpl` contains   * our reusable components' (`src/common`) template HTML files, while   * `atpl` contains the same, but for our app's code. `html` is just our   * main HTML file, `less` is our main stylesheet, and `unit` contains our   * app's unit tests.   */  app_files: {    js: [ src/**/*.module.js,src/**/*.js, !src/**/*.spec.js, !src/assets/**/*.js ],    jsunit: [ src/**/*.spec.js ],
    atpl: [ src/app/**/*.tpl.html ],    ctpl: [ src/common/**/*.tpl.html ],
    html: [ src/index.html ]  },
  build_files: {    css: [<%= build_dir %>/css/sass/*.css, <%= build_dir %>/css/**/*.css]  },
     * This is a collection of files used during testing only.   */  test_files: {    js: [      vendor/angular-mocks/angular-mocks.js    ],    mocks: [      mocks/**/*.json    ]  },
     * This is the same as `app_files`, except it contains patterns that   * reference vendor code (`vendor/`) that we need to place into the build   * process somewhere. While the `app_files` property ensures all   * standardized files are collected for compilation, it is the user's job   * to ensure non-standardized (i.e. vendor-related) files are handled   * appropriately in `vendor_files.js`.   *   * The `vendor_files.js` property holds files to be automatically   * concatenated and minified with our project source files.   *   * The `vendor_files.css` property holds any CSS files to be automatically   * included in our app.   *   * The `vendor_files.assets` property holds any assets to be copied along   * with our app's assets. This structure is flattened, so it is not   * recommended that you use wildcards.   */  vendor_files: {    js: [      vendor/jquery/dist/jquery.js,      vendor/angular/angular.js,      vendor/angular-route/angular-route.js,      vendor/lodash/dist/lodash.min.js,      vendor/reveal.js/js/reveal.js    ],    css: [      vendor/animate.css/animate.css,      vendor/reveal.js/css/reveal.min.css    ],    assets: [    ]  }};"
" vim: set et sw=4 ts=4 sts=4 ft=javascript fdm=marker ff=unix fenc=utf8 nobomb: *  <> * @date   2013-03-27 * @link   http://www.gracecode.com/ */
~function() {     http://developer.chrome.com/extensions/content_scripts.html    var flags = [videoId, iid, $SCOPE, vid, info, COVER_INFO, XL_CLOUD_FX_INSTANCE, _page_, aid, system];
    for(var i = 0; i < flags.length; i++) {            var flag = flags[i], value = window[flag];
            if (flag == $SCOPE && window[flag]) {                value = window[flag][video][vid];                flag = SCOPE;            }
        try {            document.body.setAttribute(data- + flag, value || );        }catch(e) {             ...        }    }}();

 vim: set et sw=4 ts=4 sts=4 ft=javascript fdm=marker ff=unix fenc=utf8 nobomb: *  <> * @date   2013-03-27 * @link   http://www.gracecode.com/ */
~function(cscope) {    var ATTR_VIDEO_ADDRESS = data-video-url;    var isSupportM3U8 = (document.createElement(video).canPlayType(application/x-mpegURL)) ? true : false;    var PLAYER_SCRIPT_URL = http://vjs.zencdn.net/c/video.js, PLAYER_CSS_URL = http://vjs.zencdn.net/c/video-js.css;    var replacedElement, orgialHTML;
    var flagElement = document.createElement(z);        flagElement.setAttribute(id, html5-player);        flagElement.setAttribute(title, Click to resume original player.);        flagElement.innerHTML = Embedded HTML5 Player;
    var segElement = document.createElement(z);        segElement.setAttribute(id, html5-player-seg);        segElement.innerHTML = 选择分段： ;
    flagElement.addEventListener(click, function(e) {        if (replacedElement) {            replacedElement.innerHTML = orgialHTML;        }
        flagElement.parentNode.removeChild(flagElement);        replacedElement.parentNode.removeChild(replacedElement);    });
    function getScript(url, success, error) {         var script = document.createElement(script);         script.setAttribute(src, url);         script.addEventListener(load,  success);         script.addEventListener(error, error);         document.body.appendChild(script);    };
    function loadCSS(url) {        var head  = document.getElementsByTagName(head)[0];        var link  = document.createElement(link);            link.rel  = stylesheet;            link.type = text/css;            link.href = url;            link.media = all;        head.appendChild(link);    };
    function log(message) {        console.log([HTML5 Player]  + message);    };
    function markVideoUrl(url) {        log(HTML5 Video Founded, The address is  + url);        <z id=""html5-player"">正在使用 HTML5 播放器</z>
        flagElement.setAttribute(ATTR_VIDEO_ADDRESS, url);        document.body.appendChild(flagElement);        document.body.setAttribute(ATTR_VIDEO_ADDRESS, url);    };
    var markSegs = function (index, callback) {        var b = function(index, callback) {            var link = document.createElement(a), call = callback;            link.innerHTML = index; link.title = 选择播放第+index +段视频;            link.onclick = function(e) {                var links = segElement.getElementsByTagName(a);
                for (var i = 0, len = links.length; i < len; i++) {                    links[i].className = ;                }
                links[index-1].className = current;                call();            };            segElement.appendChild(link);        }
        b(index, callback);        document.body.appendChild(segElement);        markSegs = b;    }
    var selectSegs = function(index) {        var links = segElement.getElementsByTagName(a);        links[index].onclick();    }
    function launchPlayer(element, url, success) {        var width = element.clientWidth, height = element.clientHeight;        var html  =         <video id=""my_video_1"" autoplay=""autoplay"" class=""video-js vjs-default-skin"" controls=""controls"" +              preload=""auto"" width=""+ width +"" height=""+ height +""> +            <source src=""+ url +"" type=""video/mp4"" /> +        </video>;
        if (!element || !url.length) {return;}
        replacedElement = element;        orgialHTML = element.innerHTML;
        element.innerHTML = html;        markVideoUrl(url);
		document.getElementById(my_video_1).addEventListener(ended, 			function(e) {				idSeg = document.getElementById(html5-player-seg);				var cur = parseInt(idSeg.getElementsByClassName(current)[0].innerHTML);				var len = idSeg.getElementsByTagName(a).length;				log(Event ended comes: cur= + cur +  len= + len);				if (cur < len) {					idSeg.getElementsByTagName(a)[cur].click();				}			}		);		        loadCSS(PLAYER_CSS_URL);        getScript(PLAYER_SCRIPT_URL, success);    };
    if (cscope.HTML5PlayerToolKit) { return; }    cscope.HTML5PlayerToolKit = {        getScript: getScript,        isSupportM3U8: isSupportM3U8,        launchPlayer: launchPlayer,        log: log,        markVideoUrl: markVideoUrl,        markSegs: markSegs,        selectSegs: selectSegs,        getVideoUrl: function() {             var body  = document.body, value = body.getAttribute(ATTR_VIDEO_ADDRESS);             if (!value) {                 return false;             }             return value;         },         getUniqString: function() {            return _ + Math.round(+new Date()  Math.random());         }    }}(window);
"
"(function(){	var hasFrame = window.parent!=window,		scripts = document.getElementsByTagName(script),		current = scripts[scripts.length-1],		config = current.getAttribute(data-config),		head = document.getElementsByTagName(head)[0],		dest = location.href.replace(scmplayertrueg, scmplayer=false),		destHost = dest.substr(0,dest.indexOf(/,10)),		scm = current.getAttribute(src).replace(scriptjsg,scm.html?03022013)+#+dest,		scmHost = scm.substr(0,scm.indexOf(/,10)),		isOutside = !hasFrame || location.href.indexOf(scmplayer=true)>0,		postMessage = function(msg){			return window.top.document.getElementById(scmframe)				.contentWindow.postMessage(msg,scmHost);		},		postFactory = function(obj,keys){			var keys = keys.split(,),				post = function(key){					return function(arg){						var argStr = ;						if(typeof(arg)!=undefined)							argStr = (key.match((playqueue)) ? new Song(:() +								JSON.stringify(arg)+);						postMessage(SCM.+key+(+argStr+));					}				};			for(var i=0;i<keys.length;i++){				var key = keys[i];				obj[key] = post(key);			}		},		postConfig = function(config){			if(!isOutside)			postMessage(SCM.config(+config+));		},
		addEvent = function(elm, evType, fn) {			if(elm.addEventListener) 				elm.addEventListener(evType, fn);			else if (elm.attachEvent) 				elm.attachEvent(on + evType, fn);			else				elm[on + evType] = fn;		},		isIE = (function(){			var undef,v = 3,div = document.createElement(div),			all = div.getElementsByTagName(i);			while (				div.innerHTML = <!--[if gt IE  + (++v) + ]><i></i><![endif]-->,				all[0] );			return v > 4 ? v : undef;		})(),		isMobile = navigator.userAgent.match(iPadiPhoneAndroidBlackberryi),
		init = function(){			if(!document.body){ 				setTimeout(init,10); 				return;			}			if(isOutside) outside(); else inside();		},
		outside = function(){			var css = html,body{overflow:hidden;} body{margin:0;padding:0;border:0;} img,a,embed,object,div,address,table,iframe,p,span,form,header,section,footer{ display:none;border:0;margin:0;padding:0; } #tumblr_controls{display:none;} #scmframe{display:block; background-color:transparent; position:fixed; top:0px; left:0px; width:100%; height:100%; z-index:1667;} ;			var style = document.createElement(style);			style.type = text/css;			style.id = scmcss;
			if(style.styleSheet) style.styleSheet.cssText = css;			else style.appendChild(document.createTextNode(css));
			head.appendChild(style);						while(head.firstChild.id!=""scmcss"")				head.removeChild(head.firstChild);			*/						var scmframe = document.createElement(iframe);			scmframe.frameBorder = 0;			scmframe.id = scmframe;			scmframe.allowTransparency = true;			scmframe.src = scm;						document.body.insertBefore(scmframe,document.body.firstChild);
			addEvent(window,load,function() {				setTimeout(function(){					while(document.body.firstChild!=scmframe)						document.body.removeChild(document.body.firstChild);					while(document.body.lastChild!=scmframe)						document.body.removeChild(document.body.lastChild);				},0);			});
			fix frame height in IE			addEvent(window,resize,function(){				scmframe.style.height = (function(){					if( typeof( window.innerHeight ) == number )						return window.innerHeight; 					else if( document.documentElement && document.documentElement.clientHeight ) 						return document.documentElement.clientHeight; 					else if( document.body && document.body.clientHeight ) 						return document.body.clientHeight; 				})();			});			pushState and hash change detection			var getPath = function(){					return location.href.replace(#,);				},				path = getPath(),				hash = location.hash;			setInterval(function(){				if(getPath()!=path){					path = getPath();					window.scminside.location.replace(path);				}				if(location.hash != hash){					hash = location.hash;					window.scminside.location.hash = hash;				}			},100);		},		inside = function(){			change title			window.top.document.title = document.title;			fix links			var filter = function(host){					host = host.replace(blogspoti,blogspot.com);					host = host.replace((http(s):)(www)i,);					return host;				};			addEvent(document.body,click,function(e){				var tar = e.target;				var ext = (tar.target == _blank);				while(!tar.tagName.match((aarea)i) && tar!=document.body)					tar = tar.parentNode;				if(tar.tagName.match((aarea)i) && 					!tar.href.match((jpgpng)i) && ignore picture link					!tar.href.match(javascript:) ignore javascript link				){ 					if(tar.href.indexOf(#)==0){						hash						if(tar.href != #){							window.top.scminside = window;							window.top.location.hash = location.hash;							e.preventDefault();						}					}else if(tar.title.match((SCM:SCM)i)){						SCM Play link						var title = tar.title.replace((SCM:SCM)( )i,);						var url = tar.href;						SCM.play({title:title,url:url});						e.preventDefault();					}else if(tar.href.match(css)){						auto add skin						window.open(http://scmplayer.net/#skin=+tar.href,_blank);						window.focus();						e.preventDefault();					}else if(ext || filter(tar.href).indexOf(filter(location.host))==-1 ){						if(tar.href.match(http(s))){							external links							window.open(tar.href,_blank);							window.focus();							e.preventDefault();						}					}else if(history.pushState){						internal link & has pushState						change address bar href						var url = filter(tar.href).replace(filter(destHost),);						window.top.scminside = window;						window.top.history.pushState(null,null,url);						e.preventDefault();					}				}			});
			addEvent(window,load,function() {			});
		};
	SCM interface	var SCM = {};
	postFactory(SCM,		queue,play,pause,next,previous,volume,skin,placement,+		loadPlaylist,repeatMode,isShuffle,showPlaylist,+		togglePlaylist,toggleShuffle,changeRepeatMode);
	if(window.SCM && window.SCMMusicPlayer) return;
	if(!isMobile) init();
	send config	if(config) postConfig(config);	SCM.init = postConfig;
	window.SCMMusicPlayer = window.SCMMusicPlayer || SCM;	window.SCM = window.SCM || SCM;})();"
module.exports = require(./dist/preview)
" * Created by andrewhurst on 10/5/15. */import React, { Component, PropTypes } from react;import {  Keyboard,  LayoutAnimation,  View,  Dimensions,  Platform,  StyleSheet} from react-native;
const styles = StyleSheet.create({  container: {    left: 0,    right: 0,    bottom: 0,  },});
 From: https://medium.com/man-moon/writing-modern-react-native-ui-e317ff956f02const defaultAnimation = {  duration: 500,  create: {    duration: 300,    type: LayoutAnimation.Types.easeInEaseOut,    property: LayoutAnimation.Properties.opacity  },  update: {    type: LayoutAnimation.Types.spring,    springDamping: 200  }};
export default class KeyboardSpacer extends Component {  static propTypes = {    topSpacing: PropTypes.number,    onToggle: PropTypes.func,    style: View.propTypes.style,  };
  static defaultProps = {    topSpacing: 0,    onToggle: () => null,  };
  constructor(props, context) {    super(props, context);    this.state = {      keyboardSpace: 0,      isKeyboardOpened: false    };    this._listeners = null;    this.updateKeyboardSpace = this.updateKeyboardSpace.bind(this);    this.resetKeyboardSpace = this.resetKeyboardSpace.bind(this);  }
  componentDidMount() {    const updateListener = Platform.OS === android ? keyboardDidShow : keyboardWillShow;    const resetListener = Platform.OS === android ? keyboardDidHide : keyboardWillHide;    this._listeners = [      Keyboard.addListener(updateListener, this.updateKeyboardSpace),      Keyboard.addListener(resetListener, this.resetKeyboardSpace)    ];  }
  componentWillUnmount() {    this._listeners.forEach(listener => listener.remove());  }
  updateKeyboardSpace(event) {    if (!event.endCoordinates) {      return;    }
    let animationConfig = defaultAnimation;    if (Platform.OS === ios) {      animationConfig = LayoutAnimation.create(        event.duration,        LayoutAnimation.Types[event.easing],        LayoutAnimation.Properties.opacity,      );    }    LayoutAnimation.configureNext(animationConfig);
     get updated on rotation    const screenHeight = Dimensions.get(window).height;     when external physical keyboard is connected     event.endCoordinates.height still equals virtual keyboard height     however only the keyboard toolbar is showing if there should be one    const keyboardSpace = (screenHeight - event.endCoordinates.screenY) + this.props.topSpacing;    this.setState({      keyboardSpace,      isKeyboardOpened: true    }, this.props.onToggle(true, keyboardSpace));  }
  resetKeyboardSpace(event) {    let animationConfig = defaultAnimation;    if (Platform.OS === ios) {      animationConfig = LayoutAnimation.create(        event.duration,        LayoutAnimation.Types[event.easing],        LayoutAnimation.Properties.opacity,      );    }    LayoutAnimation.configureNext(animationConfig);
    this.setState({      keyboardSpace: 0,      isKeyboardOpened: false    }, this.props.onToggle(false, 0));  }
  render() {    return (      <View style={[styles.container, { height: this.state.keyboardSpace }, this.props.style]} />);  }}"
"use strict; * Webpack frontend test configuration. */var path = require(path);var merge = require(lodash/merge);var prodCfg = require(./webpack.config);var webpack = require(webpack);
module.exports = {  cache: true,  context: path.join(__dirname, test/client),  entry: ./main,  output: {    path: __dirname,    filename: main.js,    publicPath: /assets/  },  resolve: merge({}, prodCfg.resolve, {    alias: {       Allow root import of `src/FOO` from ROOT/src.      src: path.join(__dirname, src)    }  }),  plugins: [    new webpack.ProvidePlugin({      CodeMirror: codemirror,      window.CodeMirror: codemirror    })  ],  module: prodCfg.module,  devtool: #source-map};"
"use strict;
var webpack = require(webpack);var path = require(path);
module.exports = {  cache: true,  entry: path.join(__dirname, src/index.js),  externals: [    {      react: {        root: React,        commonjs2: react,        commonjs: react,        amd: react      },      react-dom: {        root: ReactDom,        commonjs2: react-dom,        commonjs: react-dom,        amd: react-dom      }    }  ],  output: {    path: path.join(__dirname, dist),    filename: component-playground.min.js,    library: ComponentPlayground,    libraryTarget: umd  },  resolve: {    extensions: [, .js, .jsx]  },  module: {    loaders: [      {        test: jsx,        exclude: (node_modules),        loader: babel-loader      }, {        test: css,        loader: style-loader!css-loader      }, {        test: (pngjpg),        loader: url-loader?limit=8192      }    ]  },  plugins: [    new webpack.optimize.DedupePlugin(),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    }),    new webpack.DefinePlugin({       Signal production, so that webpack removes non-production code that       is in condtionals like: `if (process.env.NODE_ENV === ""production"")`      process.env.NODE_ENV: JSON.stringify(production)    }),    new webpack.SourceMapDevToolPlugin([file].map)  ]};"
"var gulp = require(gulp);
var PATHS = {    src: src/**/*.ts};
gulp.task(clean, function (done) {    var del = require(del);    del([dist], done);});
gulp.task(ts2js, function () {    var typescript = require(gulp-typescript);    var tscConfig = require(./tsconfig.json);
    var tsResult = gulp        .src([PATHS.src, node_modules/angular2/typings/browser.d.ts])        .pipe(typescript(tscConfig.compilerOptions));
    return tsResult.js.pipe(gulp.dest(dist));});
gulp.task(play, [ts2js], function () {    var http = require(http);    var connect = require(connect);    var serveStatic = require(serve-static);    var open = require(open);
    var port = 9000, app;
    gulp.watch(PATHS.src, [ts2js]);
    app = connect().use(serveStatic(__dirname));    http.createServer(app).listen(port, function () {        open(http://localhost: + port);    });});
gulp.task(default, [play]);"
"use strict;
var webpack = require(webpack);var config = require(./webpack.config);
 **WARNING**: Mutates base configuration. We do this because lodash isn't available in `production` mode.config.output.filename = component-playground.js;config.plugins = [  new webpack.SourceMapDevToolPlugin([file].map)];
 Export mutated base.module.exports = config;"
"use strict; * Webpack frontend test (w/ coverage) configuration. */var merge = require(lodash/merge);var testCfg = require(./webpack.config.test);
module.exports = merge({}, testCfg, {  isparta: {    babel: {      presets: [es2015, stage-1, react]    }  },  module: {    preLoaders: [       Manually instrument client code for code coverage.       https://github.com/deepsweet/isparta-loader handles ES6 + normal JS.      {        test: srcjsx,        exclude: (testnode_modules),        loader: isparta      }    ]  }});"
"(function(){	if(!window.videoId){		return false;	}	var coverCss = [		,		position:fixed,		top:0,		left:0,		bottom:0,		right:0,		background-color:rgba(255,255,255,0),		z-index:999999999999,		-webkit-transition:background-color 0.2s ease;,		-moz-transition:background-color 0.2s ease;,		-o-transition:background-color 0.2s ease;,		transition:background-color 0.2s ease;,		pointer-events:none,			];	var videoCss = [		,		position:absolute,		width:610px,		height:458px,		top:-500px,		left:50%,		margin-left:-306px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		-webkit-transition:top 1s ease;,		-moz-transition:top 1s ease;,		-o-transition:top 1s ease;,		transition:top 1s ease;,			];	var aCss = [		,		position:absolute,		bottom:0,		left:0,		right:0,		height:30px;,		text-align:center,		font-size:14px,		pointer-events:auto,			];		var btnCss = [		,		position:absolute,		top:0,		height:30px;,		line-height:30px,		width:60px,		text-align:center,		font-size:14px,		letter-spacing:-1px,		color:#014CCC,		cursor:pointer,		pointer-events:auto,			];		var changeBtnCss = [		,		position:absolute,		width:500px,		height:40px,		top:470px,		left:50%,		margin-left:-250px,		z-index:1000000000000,		background:#000,		background-image: -webkit-linear-gradient(top,#333,#000),		background-image: -moz-linear-gradient(top,#333,#000),		background-image: -ms-linear-gradient(top,#333,#000),		background-image: -o-linear-gradient(top,#333,#000),		background-image: linear-gradient(top,#333,#000),		box-shadow:0 0 5px #333,		text-align:center,		color:#eee,		border-radius:150px,		overflow:hidden,			];		var changeBtnItemCss = [		,		display:inline-block,		width:90px,		height:40px,		line-height:40px,		font-size:20px,				cursor:pointer,			];			var HTML5Player = function(){			var hd2Src= /player/getM3U8/vid/+videoId+/type/hd2/ts/+(((new Date()).getTime()/1000).toString()|0)+/v.m3u8;		var mp4Src= /player/getM3U8/vid/+videoId+/type/mp4/ts/+(((new Date()).getTime()/1000).toString()|0)+/v.m3u8;		var flvSrc= /player/getM3U8/vid/+videoId+/type/flv/ts/+(((new Date()).getTime()/1000).toString()|0)+/v.m3u8;		var mp4Src2 = http://3g.youku.com/pvs?id=+videoId2+&format=3gphd;		var m3u8Src= '/player/getM3U8/vid/'+videoId+'/type/mp4/flv/ts/'+(new Date()).getTime()+'/v.m3u8';		var cover = document.createElement(div);		cover.style.cssText += coverCss.join(;);
		var v = document.createElement(video);		v.setAttribute(height,458);		v.setAttribute(width,610);		v.setAttribute(controls,true);		v.setAttribute(autoplay,true);		v.style.cssText += videoCss.join(;);		v.src = hd2Src;						var a = document.createElement(a);				a.setAttribute(href,mp4Src);		a.innerHTML = &#x4E0D;&#x80FD;&#x76F4;&#x63A5;&#x89C2;&#x770B;&#xFF0C;&#x70B9;&#x51FB;&#x8FD9;&#x91CC;&#xFF1A;+mp4Src;		a.style.cssText += aCss.join(;);		cover.appendChild(a);				var off = document.createElement(div);		off.innerHTML = &#x9000;&#x51FA;;		off.style.cssText += btnCss.join(;)+;right:0;;		cover.appendChild(off);		var nocover = document.createElement(div);		nocover.innerHTML = &#x6253;&#x5F00;&#x8FF7;&#x96FE;;		nocover.style.cssText += btnCss.join(;)+;right:60px;;;		cover.appendChild(nocover);				off.addEventListener(click,function(){			y.HTML5.remove();			y.flash.add();			y.flag = false;		},false);				nocover.addEventListener(click,function(){			cover.style.backgroundColor = rgba(255,255,255,0);		},false);					var changeBtn = document.createElement(div);		changeBtn.style.cssText += changeBtnCss.join(;);								var hd2btn = document.createElement(div);		hd2btn.style.cssText += changeBtnItemCss.join(;);		hd2btn.style.backgroundColor = #666;		hd2btn.style.boxShadow = 0 0 3px #000 inset;		hd2btn.innerHTML = &#x8D85;&#x6E05;;		changeBtn.appendChild(hd2btn);						var mp4btn = document.createElement(div);		mp4btn.style.cssText += changeBtnItemCss.join(;);		mp4btn.innerHTML = &#x9AD8;&#x6E05;;		changeBtn.appendChild(mp4btn);				var flvbtn = document.createElement(div);		flvbtn.style.cssText += changeBtnItemCss.join(;);		flvbtn.innerHTML = &#x6807;&#x6E05;;		changeBtn.appendChild(flvbtn);				var mp4btn2 = document.createElement(div);		mp4btn2.style.cssText += changeBtnItemCss.join(;);		mp4btn2.innerHTML = mp4;		changeBtn.appendChild(mp4btn2);				hd2btn.addEventListener(click,function(){			v.src = hd2Src;			hd2btn.style.backgroundColor = #666;						hd2btn.style.boxShadow = 0 0 3px #000 inset;			mp4btn.style.backgroundColor = transparent;			mp4btn.style.boxShadow = none;			flvbtn.style.backgroundColor = transparent;			flvbtn.style.boxShadow = none;			mp4btn2.style.backgroundColor = transparent;			mp4btn2.style.boxShadow = none;		},false);				mp4btn.addEventListener(click,function(){			v.src = mp4Src;			mp4btn.style.backgroundColor = #666;			mp4btn.style.boxShadow = 0 0 3px #000 inset;			hd2btn.style.backgroundColor = transparent;			hd2btn.style.boxShadow = none;			flvbtn.style.backgroundColor = transparent;			flvbtn.style.boxShadow = none;			mp4btn2.style.backgroundColor = transparent;			mp4btn2.style.boxShadow = none;		},false);				flvbtn.addEventListener(click,function(){			v.src = flvSrc;			flvbtn.style.backgroundColor = #666;			flvbtn.style.boxShadow = 0 0 3px #000 inset;			hd2btn.style.backgroundColor = transparent;			hd2btn.style.boxShadow = none;			mp4btn.style.backgroundColor = transparent;			mp4btn.style.boxShadow = none;			mp4btn2.style.backgroundColor = transparent;			mp4btn2.style.boxShadow = none;		},false);				mp4btn2.addEventListener(click,function(){			v.src = mp4Src2;						mp4btn2.style.backgroundColor = #666;			mp4btn2.style.boxShadow = 0 0 3px #000 inset;			hd2btn.style.backgroundColor = transparent;			hd2btn.style.boxShadow = none;			flvbtn.style.backgroundColor = transparent;			flvbtn.style.boxShadow = none;			mp4btn.style.backgroundColor = transparent;			mp4btn.style.boxShadow = none;		},false);				return {			add : function(){				document.body.appendChild(cover);				document.body.appendChild(changeBtn);				document.body.appendChild(v);								v.addEventListener(canplay,v.play);				setTimeout(function(){					cover.style.backgroundColor = rgba(255,255,255,0.6);					v.style.top = -1px;				},100);			},			remove : function(){				v.pause();				cover.style.backgroundColor = rgba(255,255,255,0);				v.style.top = -500px;				setTimeout(function(){					cover.parentNode && document.body.removeChild(cover);					v.parentNode && document.body.removeChild(v);					changeBtn.parentNode && document.body.removeChild(changeBtn);				},1100);			}		}	}
	var flashPlayer = function(){		var flash = document.getElementById(movie_player);		var flashOut = flash.parentNode;		return {			add : function(){				flashOut.appendChild(flash);			},			remove : function(){				flashOut.parentNode && flashOut.removeChild(flash);			}		}	}			window.isYoukuHTML5PlayerBookMarkCodeByZythum = window.isYoukuHTML5PlayerBookMarkCodeByZythum || {};	var y = window.isYoukuHTML5PlayerBookMarkCodeByZythum;	y.HTML5  = y.HTML5 || HTML5Player();	y.flash = y.flash || flashPlayer();	y.flag = y.flag || false;	if(y.flag === false){		y.HTML5.add();		y.flash.remove();		y.flag = true;	}else if(y.flag === true){		y.HTML5.remove();		y.flash.add();		y.flag = false;	}
})();"
" * * Copyright 2015 Google Inc. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the ""License""); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an ""AS IS"" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
var isProd = false;var gulp = require(gulp),    fs = require(fs),    del = require(del),    watch = require(gulp-watch)    watchify = require(watchify),    browserify = require(browserify),    source = require(vinyl-source-stream),    gutil = require(gulp-util),    babelify = require(babelify),    minifycss = require(gulp-minify-css),    uglify = require(gulp-uglify),    sass = require(gulp-sass),    streamify = require(gulp-streamify),    runSequence = require(run-sequence),    license = require(gulp-license),    replace = require(gulp-replace),    bump = require(gulp-bump);var version = null;
function createBundle(url) {  return browserify({    entries: [url],    debug: !isProd  }).transform(babelify);}
function watchBundles() {  var bundleKeys = Object.keys(bundles);  var watch = null;  var key = null;  for (var b = 0; b < bundleKeys.length; b++) {    key = bundleKeys[b];    watch = watchify(bundles[key].bundle);    watch.on(update, buildBundle.bind(this, key));  }}
function buildBundle(bundleName) {
  var job = bundles[bundleName];  var bundle = job.bundle;  var name = job.name;
  var b = bundle.bundle()      .on(log, gutil.log.bind(gutil, Browserify Log))      .on(error, gutil.log.bind(gutil, Browserify Error))      .pipe(source(name));
  if (isProd) {    b = b.pipe(streamify(uglify()));  }
  return b.pipe(license(Apache, {      organization: Google Inc. All rights reserved.    }))    .pipe(gulp.dest(./dist/scripts))}
var bundles = {  core: {    url: ./src/scripts/voicememo-core.js,    name: voicememo-core.js,    bundle: null  },  list: {    url: ./src/scripts/voicememo-list.js,    name: voicememo-list.js,    bundle: null  },  record: {    url: ./src/scripts/voicememo-record.js,    name: voicememo-record.js,    bundle: null  },  details: {    url: ./src/scripts/voicememo-details.js,    name: voicememo-details.js,    bundle: null  }};
gulp.task(clean, function(done) {  del([dist], done);});
gulp.task(styles, function() {  gulp.src(./src/styles/*.scss)      .pipe(sass())      .pipe(minifycss())      .pipe(license(Apache, {        organization: Google Inc. All rights reserved.      }))      .pipe(gulp.dest(./dist/styles))});
gulp.task(scripts, function() {  var bundleKeys = Object.keys(bundles);  for (var b = 0; b < bundleKeys.length; b++) {    buildBundle(bundleKeys[b]);  }})
gulp.task(root, function() {  gulp.src(./src/*.*)    .pipe(replace(@VERSION@g, version))    .pipe(gulp.dest(./dist/))
  gulp.src(./src/favicon.ico)    .pipe(gulp.dest(./dist/))});
gulp.task(html, function() {
  gulp.src(./src/**/*.html)    .pipe(replace(@VERSION@g, version))    .pipe(gulp.dest(./dist/))});
gulp.task(images, function() {  gulp.src(./src/images/**/*.*)    .pipe(gulp.dest(./dist/images))});
gulp.task(third_party, function() {  gulp.src(./src/third_party/**/*.*)    .pipe(gulp.dest(./dist/third_party))});
gulp.task(serviceworker, function() {  gulp.src(./src/scripts/sw.js)    .pipe(replace(@VERSION@g, version))    .pipe(gulp.dest(./dist/scripts))});
gulp.task(watch, function() {  gulp.watch(./src/**/*.scss, [styles]);  gulp.watch(./src/*.*, [root]);  gulp.watch(./src/**/*.html, [html]);  gulp.watch(./src/images/**/*.*, [images]);  gulp.watch(./src/third_party/**/*.*, [third_party]);  gulp.watch(./src/scripts/sw.js, [serviceworker]);
  watchBundles();});
gulp.task(getversion, function() {  version = JSON.parse(fs.readFileSync(./package.json, utf8)).version;});

(function () {  var bundleKeys = Object.keys(bundles);  var key = null;  for (var b = 0; b < bundleKeys.length; b++) {    key = bundleKeys[b];    bundles[key].bundle = createBundle(bundles[key].url);  }})();
var allTasks = [styles, scripts, root, html, images,    third_party, serviceworker];
gulp.task(bump, function() {  return gulp.src(./package.json)    .pipe(bump({type:patch}))    .pipe(gulp.dest(./));});
gulp.task(default, function() {  isProd = true;  return runSequence(clean, bump, getversion, allTasks);})
gulp.task(dev, function() {  return runSequence(clean, getversion, allTasks, watch);});
"
"(function(){	if(!window.iid){		return false;	}	var coverCss = [		,		position:fixed,		top:0,		left:0,		bottom:0,		right:0,		background-color:rgba(255,255,255,0),		z-index:999999999999,		-webkit-transition:background-color 0.2s ease;,		-moz-transition:background-color 0.2s ease;,		-o-transition:background-color 0.2s ease;,		transition:background-color 0.2s ease;,		pointer-events:none,			];	var videoCss = [		,		position:absolute,		width:610px,		height:458px,		top:-500px,		left:50%,		margin-left:-306px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		-webkit-transition:top 1s ease;,		-moz-transition:top 1s ease;,		-o-transition:top 1s ease;,		transition:top 1s ease;,			];	var aCss = [		,		position:absolute,		bottom:0,		left:0,		right:0,		height:30px;,		text-align:center,		font-size:14px,		pointer-events:auto,			];		var btnCss = [		,		position:absolute,		top:0,		height:30px;,		line-height:30px,		width:60px,		text-align:center,		font-size:14px,		letter-spacing:-1px,		color:#014CCC,		cursor:pointer,		pointer-events:auto,			];		var changeBtnCss = [		,		position:absolute,		width:500px,		height:40px,		top:470px,		left:50%,		margin-left:-250px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		text-align:center,		color:#eee,		border-radius:150px,		overflow:hidden,			];		var changeBtnItemCss = [		,		display:inline-block,		width:150px,		height:40px,		line-height:40px,		font-size:20px,				cursor:pointer,			];
	var pad = function(num, n) {        return (new Array(n >(+num).length ? (n - (+num).length+1) : 0).join(0) + num);	}		var HTML5Player = function(){		123/554/149/3		iidStr = iid.toString().match(/(\d{3})(\d{3})(\d{3})/);		iidStr = pad(iid,9).match(()()());		var idEncodeed = iidStr[1] + / + iidStr[2] + / + iidStr[3];
		var t_yuanhuaSrc = http://m3u8.tdimg.com/+idEncodeed+/+99.m3u8;		var t_360Src = http://m3u8.tdimg.com/+idEncodeed+/+3.m3u8;		var t_256Src = http://m3u8.tdimg.com/+idEncodeed+/+2.m3u8;
		var cover = document.createElement(div);		cover.style.cssText += coverCss.join(;);
		var v = document.createElement(video);		v.setAttribute(height,458);		v.setAttribute(width,610);		v.setAttribute(controls,true);		v.setAttribute(autoplay,true);		v.style.cssText += videoCss.join(;);		v.src = t_yuanhuaSrc;						var a = document.createElement(span);				a.innerHTML = 目前只有m3u8格式的支持,貌似只有safair才能播放。;		a.style.cssText += aCss.join(;);		cover.appendChild(a);				var off = document.createElement(div);		off.innerHTML = 退出;		off.style.cssText += btnCss.join(;)+;right:0;;		cover.appendChild(off);		var nocover = document.createElement(div);		nocover.innerHTML = 打开迷雾;		nocover.style.cssText += btnCss.join(;)+;right:60px;;		cover.appendChild(nocover);				off.addEventListener(click,function(){			y.HTML5.remove();			y.flash.add();			y.flag = false;		},false);				nocover.addEventListener(click,function(){			cover.style.backgroundColor = rgba(255,255,255,0);		},false);				var changeBtn = document.createElement(div);		changeBtn.style.cssText += changeBtnCss.join(;);				var t_yuanhua = document.createElement(div);		t_yuanhua.style.cssText += changeBtnItemCss.join(;);		t_yuanhua.style.backgroundColor = #666;		t_yuanhua.style.boxShadow = 0 0 3px #000 inset;		t_yuanhua.innerHTML = 原画;		changeBtn.appendChild(t_yuanhua);				var t_360 = document.createElement(div);		t_360.style.cssText += changeBtnItemCss.join(;);		t_360.innerHTML = 360P;		changeBtn.appendChild(t_360);				var t_256 = document.createElement(div);		t_256.style.cssText += changeBtnItemCss.join(;);		t_256.innerHTML = 256P;		changeBtn.appendChild(t_256);
		t_yuanhua.addEventListener(click,function(){			v.src = t_yuanhuaSrc;			t_yuanhua.style.backgroundColor = #666;			t_360.style.backgroundColor = transparent;			t_256.style.backgroundColor = transparent;			t_yuanhua.style.boxShadow = 0 0 3px #000 inset;			t_360.style.boxShadow = none;			t_256.style.boxShadow = none;		},false);				t_360.addEventListener(click,function(){			v.src = t_360Src;			t_360.style.backgroundColor = #666;			t_yuanhua.style.backgroundColor = transparent;			t_256.style.backgroundColor = transparent;			t_360.style.boxShadow = 0 0 3px #000 inset;			t_yuanhua.style.boxShadow = none;			t_256.style.boxShadow = none;		},false);				t_256.addEventListener(click,function(){			v.src = t_360Src;			t_256.style.backgroundColor = #666;			t_yuanhua.style.backgroundColor = transparent;			t_360.style.backgroundColor = transparent;			t_256.style.boxShadow = 0 0 3px #000 inset;			t_yuanhua.style.boxShadow = none;			t_360.style.boxShadow = none;		},false);


		return {			add : function(){				document.body.appendChild(cover);				document.body.appendChild(changeBtn);				document.body.appendChild(v);								v.addEventListener(canplay,v.play);				setTimeout(function(){					cover.style.backgroundColor = rgba(255,255,255,0.6);					v.style.top = -1px;				},100);			},			remove : function(){				v.pause();				cover.style.backgroundColor = rgba(255,255,255,0);				v.style.top = -500px;				setTimeout(function(){					cover.parentNode && document.body.removeChild(cover);					v.parentNode && document.body.removeChild(v);					changeBtn.parentNode && document.body.removeChild(changeBtn);				},1100);			}		}	}
	var flashPlayer = function(){		var flashOut = document.getElementById(player);		var flash = document.getElementById(playerObject);		return {			add : function(){				flashOut.appendChild(flash);			},			remove : function(){				flashOut.parentNode && flashOut.removeChild(flash);			}		}	}			window.isTudouHTML5PlayerBookMarkCodeByZythum = window.isTudouHTML5PlayerBookMarkCodeByZythum || {};	var y = window.isTudouHTML5PlayerBookMarkCodeByZythum;	y.HTML5  = y.HTML5 || HTML5Player();	y.flash = y.flash || flashPlayer();	y.flag = y.flag || false;	if(y.flag === false){		y.HTML5.add();		y.flash.remove();		y.flag = true;	}else if(y.flag === true){		y.HTML5.remove();		y.flash.add();		y.flag = false;	}
})();"
"module.exports = function(grunt) {    var comments =  +                    * Name: SewisePlayer framework 2.5.2 +                    * Author: Jack Zhang +                    * Website: http://player.sewise.com +                    * Date: December 26, 2014 +                    * Copyright: 2013-2014, Sewise +                    * Mail: jackzhang1204@gmail.com +                    * QQ: 237432172 +                    *  */;
    var srcFiles = [                    src/com/sewise/base/core/Base.js,                    src/com/sewise/interfaces/player/IVodPlayer.js,                    src/com/sewise/interfaces/skin/IVodSkin.js,                    src/com/sewise/interfaces/player/ILivePlayer.js,                    src/com/sewise/interfaces/skin/ILiveSkin.js,                    src/com/sewise/base/globals/GlobalConst.js,                    src/com/sewise/base/globals/GlobalVars.js,                    src/com/sewise/base/events/CommandDispatcher.js,                    src/com/sewise/base/events/Events.js,                    src/com/sewise/base/utils/Utils.js,                    src/com/sewise/base/params/GlobalParams.js,                    src/com/sewise/base/params/H5Params.js,                    src/com/sewise/base/medias/PlayerSkinLoader.js,                    src/com/sewise/base/medias/vod/VodVideo.js,                    src/com/sewise/base/medias/vod/VodAudio.js,                    src/com/sewise/base/medias/vod/VodMediaConsole.js,                    src/com/sewise/base/medias/vod/VodMediaStreams.js,                    src/com/sewise/base/medias/live/LiveVideo.js,                    src/com/sewise/base/medias/live/LiveMediaConsole.js,                    src/com/sewise/base/medias/live/LiveMediaStreams.js,                    src/com/sewise/base/medias/PlayerCommon.js,                    src/com/sewise/base/external/FlashExternalInterface.js,                    src/com/sewise/base/external/Html5ExternalInterface.js,                    src/com/sewise/base/dom/ContextMenu.js,                    src/com/sewise/base/SewisePlayer.js                ];
    grunt.initConfig({        pkg: grunt.file.readJSON(package.json),                    options: {                banner: comments,                stripBanners: true,                separator: '\n\n'            },            dist: {                src: srcFiles,                dest: 'bin/<%= pkg.name %>.js'            }        },*/        uglify: {            options: {                banner: comments,                compress: {                    drop_console: true                }            },            my_target: {                files: {                    bin/<%= pkg.name %>.min.js: srcFiles                }            }        },        jshint: {            files: [gruntfile.js, srcFiles],            options: {                globals: {                    jQuery: true,                    console: true,                    module: true                }            }        },        watch: {            files: [<%= jshint.files %>],            tasks: [jshint]        }                    });        grunt.loadNpmTasks('grunt-contrib-concat');    grunt.loadNpmTasks(grunt-contrib-uglify);    grunt.loadNpmTasks(grunt-contrib-jshint);    grunt.loadNpmTasks(grunt-contrib-watch);        grunt.registerTask(test, [jshint]);    grunt.registerTask('default', ['uglify', 'concat', 'jshint']);    grunt.registerTask(default, [uglify, jshint]);    };"
" CONSTGITHUB_ID = process.env.GITHUB_IDGITHUB_TOKEN = process.env.GITHUB_TOKENGITHUB_ACCESS_TOKEN = process.env.GITHUB_ACCESS_TOKENSECRETS = [process.env.SECRET]PORT = process.env.PORT || +process.argv[2] || 80
 core libsfs    = require(fs)url   = require(url)http  = require(http)https = require(https)
request = require(request)
 file servernode_static = require(node-static)fileserver = new node_static.Server(.)
 cookiesCookies = require(cookies)
Keygrip = require(keygrip)keys    = new Keygrip(SECRETS)
 oauthOAuth2 = require(oauth).OAuth2github = new OAuth2(  GITHUB_ID,  GITHUB_TOKEN,  https://github.com/login/oauth/,  authorize,  access_token)
 index datavar index = {}
 routesroutes = [  api             , apiHandler    ,
  login          , loginHandler  ,  logout         , logoutHandler ,  oauth_redirect , authHandler   ,
  faviconico   , staticHandler ,  static          , staticHandler ,
                   , defaultHandler]
apiRoutes = [  apime              , currentUser,  apiusers() , user,  apikeywords() , keyword,  api                , currentEntries]
 handlersfunction staticHandler(req, res) {  req.addListener(end, function() {    fileserver      .serve(req, res)      .addListener(error, function(err) {        console.log(Error serving  + req.url, err.message)      })  })}
function authHandler(req, res) {  var next = req.url.query.next || url.format(url.resolve(req.url, /))    , code = req.url.query.code
	github.getOAuthAccessToken(code, {}, function(err, access, refresh) {		github.get(			https://api.github.com/user,			access,			function(err, data, response) {			  if (err) return res.end()
			  var user = JSON.parse(data)
				req.cookies.set(id, user.login, {signed: true})				res.writeHead(307, {Location: next})				res.end()			}		)	})}
function loginHandler(req, res) {	var next = github.getAuthorizeUrl()
	res.writeHead(307, {Location: next})	res.end()}
function logoutHandler(req, res) {  var next = req.url.query.next || url.format(url.resolve(req.url, /))
  req.cookies.set(id, null, {signed: true})  res.writeHead(307, {Location: next})  res.end()}
function apiHandler(req, res) {  var callback = req.url.query.callback    , handler    , i = 0    , route
  for (; route = apiRoutes[i++]; i++) {    if (route.test(req.url.pathname)) {      handler = apiRoutes[i]      req.url.captures = req.url.pathname.match(route)      break    }  }
  if (!callback || .test(callback)) callback = alert
	handler || (handler = function(cb){ cb(404, Not found.) })
  handler(req, function(err, data) {    if (err) {      res.writeHead(404)      return res.end({error: ""Not found.""})    }
    var ret = callback + ( + JSON.stringify(data) + )
    res.writeHead(200, {      Content-Type:   text/javascript,      Content-Length: Buffer.byteLength(ret)    })
    res.end(ret)  })}
function defaultHandler(req, res) {  req.url = /static/index.html  staticHandler(req, res)}
function currentUser(req, cb) {  var id = req.cookies.get(id, {signed: true})
  cb(null, id && {id: id})}
function currentEntries(req, cb) {  var ids = Object.keys(index.entries.byId)    , randomEntries = []    , i = 4
  while (i--) randomEntries[i] = index.entries.byId[    ids.splice(0|Math.random()ids.length, 1)[0]  ]
  cb(null, {    entries:  randomEntries,    keywords: index.keywords.list,    users:    index.users.list  })}
function user(req, cb) {  var data = index.users.byName[req.url.captures[1]]    , ret = {}
  for (var name in data) ret[name] = data[name]  ret.entries = data.entries.map(function(id){ return index.entries.byId[id] })
  data ? cb(null, ret) : cb(404)}
function keyword(req, cb) {  var data = Object    .keys(index.keywords.byWord[req.url.captures[1]])    .map(function(id){ return index.entries.byId[id] })
  cb(null, data)}
 setuphttp.createServer(function listener(req, res) {  req.url = url.parse(req.url, true)  req.cookies = new Cookies(req, res, keys)
  for (var i = 0, route; route = routes[i++]; i++) {    if (route.test(req.url.pathname)) return routes[i](req, res)  }}).listen(PORT)
console.log(140byt.es now running on port  + PORT)
gistEndpoint = url.format({  protocol: https:,  hostname: api.github.com,  pathname: /gists/starred,  query: {    access_token: GITHUB_ACCESS_TOKEN,    per_page: 100  }})
function getEntries(entries, uri) {  entries || (entries = [])  uri || (uri = gistEndpoint)
  console.log(fetching entries at  + uri)
  request({uri: uri}, function(err, response, body) {    if (err) console.log(entries could not be fetched:  + err.message)
    else {      var link = response.headers.link
      uri = (link && link.match(<()>; rel=""next"") || 0)[1]      entries = entries.concat(JSON.parse(body))
      if (uri) return getEntries(entries, uri)
      else {        console.log(entries.length +  entries found. checking freshness...)        updateEntries(entries)      }    }  })}



function updateEntries(entries) {  var remote = entries[0], local, path
  if (!remote) return indexEntries()
  path = ./data/entries/ + remote.id + .json
  fs.readFile(path, utf8, function(err, body) {    local = body && JSON.parse(body)
    if (err || remote.updated_at != local.updated_at) {      console.log(fetching entry  + remote.id + ...)      remote.url += ?access_token= + GITHUB_ACCESS_TOKEN      request({uri: remote.url }, function(err, response, body) {        if (err) console.log(entry could not be fetched:  + err.message)        else fs.writeFile(path, body, utf8, function(err) {          if (err) {            console.log(entry could not be written:  + err.message)          } else {            updated = true            updateEntries(entries)          }        })      })    }
    else {      console.log(entry  + remote.id +  is up to date.)      updateEntries(entries.slice(1))    }  })}
function indexEntries() {  index = {    entries: {      byId: {}    },
    keywords: {      byWord: {},      list: []    },
    users: {      byId: {},      byName: {},      list: []    }  }
   from @atk's entry at https://gist.github.com/1102380  var cleanJSON = function j(a,b,c){return c?(b?""+b+"":):JSON.stringify(JSON.parse(a.replace(,(?=)'()'g,j)))}
  console.log(indexing entries...)
  fs.readdir(./data/entries, function(err, entries) {    !function loop(entries) {      var entry = entries.shift()
      if (!entry) {        for (var word in index.keywords.byWord) {          index.keywords.list.push([word, Object.keys(index.keywords.byWord[word]) ])        }
        for (var name in index.users.byId) {          index.users.list.push(index.users.byId[name])        }
        index.users.list.sort(function(a, b){ return b.entries.length - a .entries.length })        index.keywords.list.sort(function(a, b){ return b[1].length - a[1].length })      }
      else fs.readFile(./data/entries/ + entry, utf8, function(err, data) {        var meta, data
        try {          data = JSON.parse(data)
          try {            meta = JSON.parse(data.files[package.json].content)          }
          catch(e) {            meta = cleanJSON(data.files[package.json].content)            meta = JSON.parse(meta)          }
          meta.keywords = meta.keywords.map(function(word) {            word = word.toLowerCase().replace(g,)            index.keywords.byWord[word] || (index.keywords.byWord[word] = {})            index.keywords.byWord[word][data.id] = 1            return word          })
          user = index.users.byId[data.user.id] || (index.users.byId[data.user.id] = data.user)          user.entries || (user.entries = [])          index.users.byName[data.user.login] = user          user.entries.push(data.id)          index.entries.byId[data.id] = {            id: data.id,            name: meta.name,            code: data.files[index.js].content,            description: meta.description || data.description,            author: user.login,            keywords: meta.keywords          }        }
        catch (e) {          console.log(package.json malformed for  + entry)        }
        loop(entries)      })    }(entries)  })}
 uncomment to fetch new onesgetEntries()
indexEntries()setInterval(getEntries, 1000  60  60)
process.on(uncaughtException, function(e){ console.log(e.stack) })"
"(function(root, factory) {    if (typeof module !== undefined && module.exports) {        module.exports = factory();    } else if (typeof define === function && define.amd) {        define([], factory);    } else {        root.canvid = factory();    }}(this, function() {
    function canvid(params) {        var defaultOptions = {                width : 800,                height : 450,                selector: .canvid-wrapper            },            firstPlay = true,            control = {                play: function() {                    console.log(Cannot play before images are loaded);                }            },            _opts = merge(defaultOptions, params),            el = typeof _opts.selector === string ? document.querySelector(_opts.selector) : _opts.selector;
        if (!el) {            return console.warn(Error. No element found for selector, _opts.selector);        }
        if (!_opts.videos) {            return console.warn(Error. You need to define at least one video object);        }
        if (hasCanvas()) {
            loadImages(_opts.videos, function(err, images) {                if (err) return console.warn(Error while loading video sources., err);
                var ctx = initCanvas(),                    requestAnimationFrame = reqAnimFrame();
                control.play = function(key, reverse, fps) {                    if (control.pause) control.pause();  pause current vid
                    var img = images[key],                        opts = _opts.videos[key],                        frameWidth = img.width / opts.cols,                        frameHeight = img.height / Math.ceil(opts.frames / opts.cols);
                    var curFps = fps || opts.fps || 15,                        curFrame = reverse ? opts.frames - 1 : 0,                        wait = 0,                        playing = true,                        loops = 0,                        delay = 60 / curFps;
                    requestAnimationFrame(frame);
                    control.resume = function() {                        playing = true;                        requestAnimationFrame(frame);                    };
                    control.pause = function() {                        playing = false;                        requestAnimationFrame(frame);                    };
                    control.isPlaying = function() {                        return playing;                    };
                    control.destroy = function(){                        control.pause();                        removeCanvid();                    };
                    control.getCurrentFrame = function(){                        return curFrame;                    };
                    control.setCurrentFrame = function(frameNumber){                        if(frameNumber < 0 || frameNumber >= opts.frames){                            return false;                        }
                        if(!control.isPlaying()){                            drawFrame(frameNumber);                        }
                        curFrame = frameNumber;                    };
                    if (firstPlay) {                        firstPlay = false;                        hideChildren();                    }
                    function frame() {                        if (!wait) {                            drawFrame(curFrame);                            curFrame = (+curFrame + (reverse ? -1 : 1));                            if (curFrame < 0) curFrame += +opts.frames;                            if (curFrame >= opts.frames) curFrame = 0;                            if (reverse ? curFrame == opts.frames - 1 : !curFrame) loops++;                            if (opts.loops && loops >= opts.loops){                                playing = false;                                if(opts.onEnd && isFunction(opts.onEnd)){                                    opts.onEnd();                                }                            }                        }                        wait = (wait + 1) % delay;                        if (playing && opts.frames > 1) requestAnimationFrame(frame);                    }
                    function drawFrame(f) {                        var fx = Math.floor(f % opts.cols)  frameWidth,                            fy = Math.floor(f / opts.cols)  frameHeight;
                        ctx.clearRect(0, 0, _opts.width, _opts.height);  clear frame                        ctx.drawImage(img, fx, fy, frameWidth, frameHeight, 0, 0, _opts.width, _opts.height);                    }
                };  end control.play
                if (isFunction(_opts.loaded)) {                    _opts.loaded(control);                }
            });  end loadImages
        } else if (opts.srcGif) {            var fallbackImage = new Image();            fallbackImage.src = opts.srcGif;
            el.appendChild(fallbackImage);        }
        function loadImages(imageList, callback) {            var images = {},                imagesToLoad = Object.keys(imageList).length;
            if(imagesToLoad === 0) {                return callback(You need to define at least one video object.);            }
            for (var key in imageList) {                images[key] = new Image();                images[key].onload = checkCallback;                images[key].onerror = callback;                images[key].src = imageList[key].src;            }
            function checkCallback() {                imagesToLoad--;                if (imagesToLoad === 0) {                    callback(null, images);                }            }        }
        function initCanvas() {            var canvas = document.createElement(canvas);            canvas.width = _opts.width;            canvas.height = _opts.height;            canvas.classList.add(canvid);
            el.appendChild(canvas);
            return canvas.getContext(2d);        }
        function hideChildren() {            [].forEach.call(el.children, function(child){                if(!child.classList.contains(canvid) ){                    child.style.display = none;                }            });        }
        function removeCanvid(){            [].forEach.call(el.children, function(child){                if(child.classList.contains(canvid) ){                    el.removeChild(child);                }            });        }
        function reqAnimFrame() {            return window.requestAnimationFrame                || window.webkitRequestAnimationFrame                || window.mozRequestAnimationFrame                || window.msRequestAnimationFrame                || function(callback) {                    return setTimeout(callback, 1000 / 60);                };        }
        function hasCanvas() {             taken from Modernizr            var elem = document.createElement(canvas);            return !!(elem.getContext && elem.getContext(2d));        }
        function isFunction(obj) {             taken from jQuery            return typeof obj === function || !!(obj && obj.constructor && obj.call && obj.apply);        }
        function merge() {            var obj = {},                key;
            for (var i = 0; i < arguments.length; i++) {                for (key in arguments[i]) {                    if (arguments[i].hasOwnProperty(key)) {                        obj[key] = arguments[i][key];                    }                }            }            return obj;        }
        return control;    };  end canvid function
    return canvid;}));  end factory function"
module.exports = require(./lib);
"(function(){	if(!window.vid){		return false;	}	var coverCss = [		,		position:fixed,		top:0,		left:0,		bottom:0,		right:0,		background-color:rgba(255,255,255,0),		z-index:999999999999,		-webkit-transition:background-color 0.2s ease;,		-moz-transition:background-color 0.2s ease;,		-o-transition:background-color 0.2s ease;,		transition:background-color 0.2s ease;,		pointer-events:none,			];	var videoCss = [		,		position:absolute,		width:610px,		height:458px,		top:-500px,		left:50%,		margin-left:-306px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		-webkit-transition:top 1s ease;,		-moz-transition:top 1s ease;,		-o-transition:top 1s ease;,		transition:top 1s ease;,			];	var aCss = [		,		position:absolute,		bottom:0,		left:0,		right:0,		height:30px;,		text-align:center,		font-size:14px,		pointer-events:auto,			];		var btnCss = [		,		position:absolute,		top:0,		height:30px;,		line-height:30px,		width:60px,		text-align:center,		font-size:14px,		letter-spacing:-1px,		color:#014CCC,		cursor:pointer,		pointer-events:auto,			];		var changeBtnCss = [		,		position:absolute,		width:500px,		height:40px,		top:470px,		left:50%,		margin-left:-250px,		z-index:1000000000000,		background:#000,		box-shadow:0 0 5px #333,		text-align:center,		color:#eee,		border-radius:150px,		overflow:hidden,			];		var changeBtnItemCss = [		,		display:inline-block,		width:150px,		height:40px,		line-height:40px,		font-size:20px,				cursor:pointer,			];
	var pad = function(num, n) {        return (new Array(n >(+num).length ? (n - (+num).length+1) : 0).join(0) + num);	}		var HTML5Player = function(){
		var m3u8 = vid || ;		m3u8 = m3u8 ? http://hot.vrs.sohu.com/ipad+m3u8+.m3u8 : 0;		var cover = document.createElement(div);		cover.style.cssText += coverCss.join(;);
		var v = document.createElement(video);		v.setAttribute(height,458);		v.setAttribute(width,610);		v.setAttribute(controls,true);		v.setAttribute(autoplay,true);		v.style.cssText += videoCss.join(;);		v.src = m3u8;						var a = document.createElement(span);				a.innerHTML = 目前只有m3u8格式的支持,貌似只有safair才能播放。;		a.style.cssText += aCss.join(;);		cover.appendChild(a);				var off = document.createElement(div);		off.innerHTML = 退出;		off.style.cssText += btnCss.join(;)+;right:0;;		cover.appendChild(off);		var nocover = document.createElement(div);		nocover.innerHTML = 打开迷雾;		nocover.style.cssText += btnCss.join(;)+;right:60px;;		cover.appendChild(nocover);				off.addEventListener(click,function(){			y.HTML5.remove();			y.flash.add();			y.flag = false;		},false);				nocover.addEventListener(click,function(){			cover.style.backgroundColor = rgba(255,255,255,0);		},false);				var changeBtn = document.createElement(div);		changeBtn.style.cssText += changeBtnCss.join(;);				 var t_yuanhua = document.createElement('div');		 t_yuanhua.style.cssText += changeBtnItemCss.join(';');		 t_yuanhua.style.backgroundColor = '#666';		 t_yuanhua.style.boxShadow = '0 0 3px #000 inset';		 t_yuanhua.innerHTML = '原画';		 changeBtn.appendChild(t_yuanhua);				 var t_360 = document.createElement('div');		 t_360.style.cssText += changeBtnItemCss.join(';');		 t_360.innerHTML = '360P';		 changeBtn.appendChild(t_360);				 var t_256 = document.createElement('div');		 t_256.style.cssText += changeBtnItemCss.join(';');		 t_256.innerHTML = '256P';		 changeBtn.appendChild(t_256);
		 t_yuanhua.addEventListener('click',function(){		 	v.src = t_yuanhuaSrc;		 	t_yuanhua.style.backgroundColor = '#666';		 	t_360.style.backgroundColor = 'transparent';		 	t_256.style.backgroundColor = 'transparent';		 	t_yuanhua.style.boxShadow = '0 0 3px #000 inset';		 	t_360.style.boxShadow = 'none';		 	t_256.style.boxShadow = 'none';		 },false);				 t_360.addEventListener('click',function(){		 	v.src = t_360Src;		 	t_360.style.backgroundColor = '#666';		 	t_yuanhua.style.backgroundColor = 'transparent';		 	t_256.style.backgroundColor = 'transparent';		 	t_360.style.boxShadow = '0 0 3px #000 inset';		 	t_yuanhua.style.boxShadow = 'none';		 	t_256.style.boxShadow = 'none';		 },false);				 t_256.addEventListener('click',function(){		 	v.src = t_360Src;		 	t_256.style.backgroundColor = '#666';		 	t_yuanhua.style.backgroundColor = 'transparent';		 	t_360.style.backgroundColor = 'transparent';		 	t_256.style.boxShadow = '0 0 3px #000 inset';		 	t_yuanhua.style.boxShadow = 'none';		 	t_360.style.boxShadow = 'none';		 },false);


		return {			add : function(){				document.body.appendChild(cover);				 document.body.appendChild(changeBtn);				document.body.appendChild(v);								v.addEventListener(canplay,v.play);				setTimeout(function(){					cover.style.backgroundColor = rgba(255,255,255,0.6);					v.style.top = -1px;				},100);			},			remove : function(){				v.pause();				cover.style.backgroundColor = rgba(255,255,255,0);				v.style.top = -500px;				setTimeout(function(){					cover.parentNode && document.body.removeChild(cover);					v.parentNode && document.body.removeChild(v);					changeBtn.parentNode && document.body.removeChild(changeBtn);				},1100);			}		}	}
	var flashPlayer = function(){		var flashOut = document.getElementById(sohuplayer);		var flash = document.getElementById(player);		return {			add : function(){				flashOut.appendChild(flash);			},			remove : function(){				flashOut.parentNode && flashOut.removeChild(flash);			}		}	}			window.isSohuHTML5PlayerBookMarkCodeByZythum = window.isSohuHTML5PlayerBookMarkCodeByZythum || {};	var y = window.isSohuHTML5PlayerBookMarkCodeByZythum;	y.HTML5  = y.HTML5 || HTML5Player();	y.flash = y.flash || flashPlayer();	y.flag = y.flag || false;	if(y.flag === false){		y.HTML5.add();		y.flash.remove();		y.flag = true;	}else if(y.flag === true){		y.HTML5.remove();		y.flash.add();		y.flag = false;	}
})();"

"use strict; * Karma Configuration: ""full"" version. * * This configuration runs a temporary `webpack-dev-server` and builds * the test files one-off for just a single run. This is appropriate for a * CI environment or if you're not otherwise running `npm run dev|hot`. */var webpackCfg = require(./webpack.config.test);
 BUG: Karma 0.13 is broken for circular imports TODO: Upgrade Karma to 0.13 when upstream bug is fixed. https://github.com/FormidableLabs/        formidable-react-component-boilerplate/issues/25
module.exports = function (config) {   Start with the ""dev"" (webpack-dev-server is already running) config   and add in the webpack stuff.  require(./karma.conf.dev)(config);
   Overrides.  config.set({    preprocessors: {      test/client/main.js: [webpack]    },    files: [       Sinon has issues with webpack. Do global include.      node_modules/sinon/pkg/sinon.js,
       Test bundle (created via local webpack-dev-server in this config).      test/client/main.js    ],    webpack: webpackCfg,    webpackServer: {      port: 3002,  Choose a non-conflicting port (3000 app, 3001 test dev)      quiet: false,      noInfo: true,      stats: {        assets: false,        colors: true,        version: false,        hash: false,        timings: false,        chunks: false,        chunkModules: false      }    }  });};"
"use strict; * Karma Configuration: ""dev"" version. * * This configuration relies on a `webpack-dev-server` already running and * bundling `webpack.config.test.js` on port 3001. If this is not running, * then the alternate `karma.conf.js` file will _also_ run the webpack dev * server during the test run. */module.exports = function (config) {  config.set({    frameworks: [mocha, phantomjs-shim],    reporters: [spec],    browsers: [PhantomJS],    basePath: .,  repository root.    files: [       Sinon has issues with webpack. Do global include.      node_modules/sinon/pkg/sinon.js,
       Test bundle (must be created via `npm run dev|hot|server-test`)      http://127.0.0.1:3001/assets/main.js    ],    port: 9999,    singleRun: true,    client: {      mocha: {        ui: bdd      }    }  });};"
"use strict; * Karma Configuration: ""coverage"" version. * * This configuration is the same as basic one-shot version, just with coverage. */var webpackCovCfg = require(./webpack.config.coverage);
module.exports = function (config) {  require(./karma.conf)(config);  config.set({    reporters: [spec, coverage],    webpack: webpackCovCfg,    coverageReporter: {      reporters: [        { type: json, file: coverage.json },        { type: lcov },        { type: text-summary }      ],      dir: coverage/client    }  });};"
module.exports = require(./dist/play)
require(./dist/app.css)module.exports = require(./dist/app)
"var requirejs = ({	shim: {		underscore: {exports: _},		jquery.ui: {deps: [jquery],exports: jQuery},		jquery.scrollto: {deps: [jquery],exports: jQuery}	},	paths: {		jquery: http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min,		jquery.ui: http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.23/jquery-ui.min,		jquery.scrollto: lib/jquery/jquery.scrollTo.min,		underscore: http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.1/underscore-min,		knockout:http://cdnjs.cloudflare.com/ajax/libs/knockout/2.1.0/knockout-min,
		text: lib/require/text,		domready: lib/require/domready	},	config:{		scm:{			playback:{				youtube:(youtube.com|youtu.be),				soundcloud:^http(s)?soundcloud.com,				exfm: ^( *)(http(s)?://)?(www.)?ex.fm,				soundmanager:.*			},			playlist:{				youtube:(youtube.com|youtu.be),				soundcloud:^http(s)?soundcloud.com,				rss:.*			}		}	},	waitSeconds: 900,	baseUrl: js/});
soundManager.preferFlash = false;soundManager.useHTML5Audio = true;soundManager.url = swf/;soundManager.allowScriptAccess = always;"
" vim: set et sw=4 ts=4 sts=4 ft=javascript fdm=marker ff=unix fenc=utf8 nobomb: *  <> * @date   2013-03-27 * @link   http://www.gracecode.com/ */
~function() {     var Toolkit = HTML5PlayerToolKit, getScript = Toolkit.getScript, log = Toolkit.log;
     var getExtensionUrl = function(url) {        return chrome.extension.getURL(url);     };
     var getVideoFlag = function (flag) {         var body  = document.body, value = body.getAttribute(data- + flag);         if (!value) {             return false;         }         return value;     };
     var init = function(e) {         var type = false, host = location.host;
         if(youkucom.test(host) && getVideoFlag(videoId))                         type = youku;         if(tudoucom.test(host) && getVideoFlag(iid))                             type = tudou;         if(sohucom.test(host)  && getVideoFlag(vid))                             type = sohu;         if(iqiyicom.test(host) && getVideoFlag(info))                            type = iqiyi;         if(letvcom.test(host)  && document.getElementById(fla_box))              type = letv;         if(videosinacomcn.test(host) && getVideoFlag(SCOPE))                 type = sina;         if(vqqcom.test(host) && getVideoFlag(COVER_INFO))                      type = qq;         if(getVideoFlag(XL_CLOUD_FX_INSTANCE))                                       type = xunlei;         if(56com.test(host) && getVideoFlag(_page_))                             type = 56;         if(/bilibili\.tv/.test(host) && getVideoFlag('aid'))                           type = 'bilibili';         if(/acfun\.tv/.test(host) && getVideoFlag('system'))                           type = 'acfun';
         if(!type) {             log(Not found any video, ignore.);             return false;         }         log(Found  + type.toUpperCase() +  video tag, continue.);
         getScript(getExtensionUrl(sites/ + type + .js));     };
     window.addEventListener(load, function() {        getScript(getExtensionUrl(seed.js), init);     });} ();
"

"module.exports = function ( grunt ) {
     * Load required Grunt tasks. These are installed based on the versions listed   * in `package.json` when you do `npm install` in this directory.   */  require(load-grunt-tasks)(grunt);  require(time-grunt)(grunt);
     * Load in our build configuration file.   */  var userConfig = require( ./build.config.js );
     * This is the configuration object Grunt uses to give each plugin its   * instructions.   */  var taskConfig = {         * We read in our `package.json` file so we can access the package name and     * version. It's already there, so we don't repeat ourselves here.     */    pkg: grunt.file.readJSON(package.json),
         * The banner is the comment that is placed at the top of our compiled     * source files. It is first processed as a Grunt template, where the `<%=`     * pairs are evaluated based on this very configuration object.     */    meta: {      banner:         +         * <%= pkg.name %> - v<%= pkg.version %> - <%= grunt.template.today(""yyyy-mm-dd"") %> +         * +         * Copyright (c) <%= grunt.template.today(""yyyy"") %> <%= pkg.name %> +         */    },
         * Creates a changelog on a new version.     */    changelog: {      options: {        dest: CHANGELOG.md,        templateFile: misc/changelog.tpl.md      }    },
         * Increments the version number, etc.     */    bump: {      options: {        files: [          package.json,          bower.json        ],        commit: false,        commitMessage: chore(release): v%VERSION%,        commitFiles: [          package.json,          client/bower.json        ],        createTag: false,        tagName: v%VERSION%,        tagMessage: Version %VERSION%,        push: false,        pushTo: origin      }    },
         * The directories to delete when `grunt clean` is executed.     */    clean: {      all: {        files: [{          dot: true,          src: [            <%= build_dir %>,            <%= compile_dir %>,            .tmp          ]        }]      }    },
         * The `copy` task just copies files from A to B. We use it here to copy     * our project assets (images, fonts, etc.) and javascripts into     * `build_dir`, and then to copy the assets to `compile_dir`.     */    copy: {      build_app_assets: {        files: [          {            src: [  ],            dest: <%= build_dir %>/assets/,            cwd: src/assets,            expand: true          }        ]      },      build_vendor_assets: {        files: [          {            src: [ <%= vendor_files.assets %> ],            dest: <%= build_dir %>/assets/,            cwd: .,            expand: true,            flatten: true          }        ]      },      build_appjs: {        files: [          {            src: [ <%= app_files.js %> ],            dest: <%= build_dir %>/,            cwd: .,            expand: true          }        ]      },      build_vendorjs: {        files: [          {            src: [ <%= vendor_files.js %> ],            dest: <%= build_dir %>/,            cwd: .,            expand: true          }        ]      },      build_vendorcss: {        files: [          {            src: [ <%= vendor_files.css %> ],            dest: <%= build_dir %>/,            cwd: .,            expand: true          }        ]      },      compile_assets: {        files: [          {            src: [  ],            dest: <%= compile_dir %>/assets,            cwd: <%= build_dir %>/assets,            expand: true          }        ]      },      mario: {        files: [          {            src: [  ],            dest: <%= build_dir %>/assets/FullScreenMario,            cwd: <%= vendor_dir %>/FullScreenMario,            expand: true          }        ]      }
    },
         * `grunt concat` concatenates multiple source files into a single file.     */    concat: {             * The `build_css` target concatenates compiled CSS and vendor CSS       * together.       */      build_css: {        src: [          <%= vendor_files.css %>,          <%= build_files.css %>        ],        dest: <%= build_dir %>/assets/<%= pkg.name %>-<%= pkg.version %>.css      },             * The `compile_js` target is the concatenation of our application source       * code and all specified vendor source code into a single file.       */      compile_js: {        options: {          banner: <%= meta.banner %>        },        src: [          <%= vendor_files.js %>,          module.prefix,          <%= build_dir %>/src/**/*.module.js,          <%= build_dir %>/src/**/*.js,          <%= html2js.app.dest %>,          <%= html2js.common.dest %>,          module.suffix        ],        dest: <%= compile_dir %>/assets/<%= pkg.name %>-<%= pkg.version %>.js      }    },
         * `ng-annotate` annotates the sources before minifying. That is, it allows us     * to code without the array syntax.     */    ngAnnotate: {      compile: {        files: [          {            src: [ <%= app_files.js %> ],            cwd: <%= build_dir %>,            dest: <%= build_dir %>,            expand: true          }        ]      }    },
         * Minify the sources!     */    uglify: {      compile: {        options: {          banner: <%= meta.banner %>        },        files: {          <%= concat.compile_js.dest %>: <%= concat.compile_js.dest %>        }      }    },
         * `grunt-contrib-compass` handles our SASS compilation and uglification automatically.     */    compass: {      options: {        sassDir: src,        cssDir: <%= build_dir %>/css,        outputStyle: compressed,        force: true      },      build: {        options: {          outputStyle: expanded,          force: false        }      },      compile: {        options: {}      }    },
         * `jshint` defines the rules of our linter as well as which files we     * should check. This file, all javascript sources, and all our unit tests     * are linted based on the policies listed in `options`. But we can also     * specify exclusionary patterns by prefixing them with an exclamation     * point (!); this is useful when code comes from a third party but is     * nonetheless inside `src/`.     */    jshint: {      src: {        options: {          jshintrc: .jshintrc        },        files: {          src: [<%= app_files.js %>]        }      },      test: [        <%= app_files.jsunit %>      ],      gruntfile: [        Gruntfile.js      ],      options: {        curly: true,        immed: true,        newcap: true,        noarg: true,        sub: true,        boss: true,        eqnull: true      }    },
    jscs: {      src: [<%= app_files.js %>],      options: {        force: true,        config: .jscsrc      }    },
         * HTML2JS is a Grunt plugin that takes all of your template files and     * places them into JavaScript files as strings that are added to     * AngularJS's template cache. This means that the templates too become     * part of the initial payload as one JavaScript file. Neat!     */    html2js: {             * These are the templates from `src/app`.       */      app: {        options: {          base: src/app        },        src: [ <%= app_files.atpl %> ],        dest: <%= build_dir %>/templates-app.js      },
             * These are the templates from `src/common`.       */      common: {        options: {          base: src/common        },        src: [ <%= app_files.ctpl %> ],        dest: <%= build_dir %>/templates-common.js      }    },
         * The Karma configurations.     */    karma: {      options: {        configFile: <%= build_dir %>/karma-unit.js      },      unit: {        port: 9019,        background: true      },      continuous: {        singleRun: true      }    },
         * The `index` task compiles the `index.html` file as a Grunt template. CSS     * and JS files co-exist here but they get split apart later.     */    index: {
             * During development, we don't want to have wait for compilation,       * concatenation, minification, etc. So to avoid these steps, we simply       * add all script files directly to the `<head>` of `index.html`. The       * `src` property contains the list of included files.       */      build: {        dir: <%= build_dir %>,        src: [          <%= vendor_files.js %>,          <%= build_dir %>/src/**/*.module.js,          <%= build_dir %>/src/**/*.js,          <%= html2js.common.dest %>,          <%= html2js.app.dest %>,          <%= vendor_files.css %>,          <%= build_files.css %>        ]      },
             * When it is time to have a completely compiled application, we can       * alter the above to include only a single JavaScript and a single CSS       * file. Now we're back!       */      compile: {        dir: <%= compile_dir %>,        src: [          <%= concat.compile_js.dest %>,          <%= vendor_files.css %>,          <%= build_dir %>/assets/<%= pkg.name %>-<%= pkg.version %>.css        ]      }    },
         * This task compiles the karma template so that changes to its file array     * don't have to be managed manually.     */    karmaconfig: {      unit: {        dir: <%= build_dir %>,        src: [          <%= vendor_files.js %>,          <%= html2js.app.dest %>,          <%= html2js.common.dest %>,          <%= test_files.js %>        ]      }    },
         * And for rapid development, we have a watch set up that checks to see if     * any of the files listed below change, and then to execute the listed     * tasks when they do. This just saves us from having to type ""grunt"" into     * the command-line every time we want to see what we're working on; we can     * instead just leave ""grunt watch"" running in a background terminal. Set it     * and forget it, as Ron Popeil used to tell us.     *     * But we don't need the same thing to happen for all the files.     */    delta: {             * By default, we want the Live Reload to work for all tasks; this is       * overridden in some tasks (like this file) where browser resources are       * unaffected. It runs by default on port 35729, which your browser       * plugin should auto-detect.       */      options: {        livereload: true      },
             * When the Gruntfile changes, we just want to lint it. In fact, when       * your Gruntfile changes, it will automatically be reloaded!       */      gruntfile: {        files: Gruntfile.js,        tasks: [ jshint:gruntfile ],        options: {          livereload: false        }      },
             * When our JavaScript source files change, we want to run lint them and       * run our unit tests.       */      jssrc: {        files: [          <%= app_files.js %>        ],        tasks: [ jshint:src, karma:unit:run, beep:error, copy:build_appjs ]      },
             * When assets are changed, copy them. Note that this will *not* copy new       * files, so this is probably not very useful.       */      assets: {        files: [          src/assets/**/*        ],        tasks: [ copy:build_app_assets, copy:build_vendor_assets ]      },
      mario: {        files: [          vendor/FullScreenMario/**/*        ],        tasks: [ copy:mario ]      },
             * When index.html changes, we need to compile it.       */      html: {        files: [ <%= app_files.html %> ],        tasks: [ index:build, beep:error ]      },
             * When our templates change, we only rewrite the template cache.       */      tpls: {        files: [          <%= app_files.atpl %>,          <%= app_files.ctpl %>        ],        tasks: [ html2js, beep:error ]      },
             * When the CSS files change, we need to compile and minify them.       */      compass: {        files: [ src/sass/*.scss ],        tasks: [ compass:build, concat:build_css, beep:error ]      },
             * When a JavaScript unit test file changes, we only want to lint it and       * run the unit tests. We don't want to do any live reloading.       */      jsunit: {        files: [          <%= app_files.jsunit %>        ],        tasks: [ jshint:test, karma:unit:run, beep:error ],        options: {          livereload: false        }      }    }
  };
  grunt.initConfig( grunt.util._.extend( taskConfig, userConfig ) );
     * In order to make it safe to just compile or copy *only* what was changed,   * we need to ensure we are starting from a clean, fresh build. So we rename   * the `watch` task to `delta` (that's why the configuration var above is   * `delta`) and then add a new task called `watch` that does a clean build   * before watching for changes.   */  grunt.renameTask( watch, delta );  grunt.registerTask( watch, [ build, karma:unit, delta ]);
     * The default task is to build and compile.   */  grunt.registerTask( default, [ build, compile ] );
     * The `build` task gets your app ready to run for development and testing.   */  grunt.registerTask( build, [    gitHooks, clean:all, html2js, jshint, compass:build,    copy:build_app_assets, copy:build_vendor_assets,    copy:build_appjs, copy:build_vendorjs, copy:build_vendorcss, concat:build_css, copy:mario, index:build, karmaconfig,    karma:continuous  ]);
     * The `compile` task gets your app ready for deployment by concatenating and   * minifying your code.   */  grunt.registerTask( compile, [    compass:compile, concat:build_css, copy:compile_assets, ngAnnotate, concat:compile_js, uglify, index:compile  ]);
     * A utility function to get all app JavaScript sources.   */  function filterForJS ( files ) {    return files.filter( function ( file ) {      return file.match( js );    });  }
     * A utility function to get all app CSS sources.   */  function filterForCSS ( files ) {    return files.filter( function ( file ) {      return file.match( css );    });  }
     * The index.html template includes the stylesheet and javascript sources   * based on dynamic names calculated in this Gruntfile. This task assembles   * the list into variables for the template to use and then runs the   * compilation.   */  grunt.registerMultiTask( index, Process index.html template, function () {    var dirRE = new RegExp( ^(+grunt.config(build_dir)+|+grunt.config(compile_dir)+), g );    var jsFiles = filterForJS( this.filesSrc ).map( function ( file ) {      return file.replace( dirRE,  );    });    var cssFiles = filterForCSS( this.filesSrc ).map( function ( file ) {      return file.replace( dirRE,  );    });
    grunt.file.copy(src/index.html, this.data.dir + /index.html, {      process: function ( contents, path ) {        return grunt.template.process( contents, {          data: {            scripts: jsFiles,            styles: cssFiles,            name: grunt.config( pkg.name ),            version: grunt.config( pkg.version )          }        });      }    });  });
     * In order to avoid having to specify manually the files needed for karma to   * run, we use grunt to manage the list for us. The `karma/*` files are   * compiled as grunt templates for use by Karma. Yay!   */  grunt.registerMultiTask( karmaconfig, Process karma config templates, function () {    var jsFiles = filterForJS( this.filesSrc );
    grunt.file.copy( karma/karma-unit.tpl.js, grunt.config( build_dir ) + /karma-unit.js, {      process: function ( contents, path ) {        return grunt.template.process( contents, {          data: {            scripts: jsFiles          }        });      }    });  });
     * Install Git Hooks   */  grunt.registerTask(gitHooks, Install commit message enforce script if it doesnt exist, function() {    if (!grunt.file.exists(.git/hooks/commit-msg)) {      grunt.file.copy(misc/validate-commit-msg.js, .git/hooks/commit-msg);      require(fs).chmodSync(.git/hooks/commit-msg, 0755);    }  });
};"
" ==UserScript== @name        AposLoader @namespace   AposLoader @description Grabs latest versions of the bot scripts automatically. @include     http://agar.io/ @version     1.3 @grant       none @author      http://www.twitch.tv/apostolique ==/UserScript==var aposLoaderVersion = 1.3;var sha = efde0488cc2cc176db48dd23b28a20b90314352b;
function getLatestCommit() {	window.jQuery.ajax({		url: https://api.github.com/repos/apostolique/Agar.io-bot/git/refs/heads/master,		cache: false,		dataType: jsonp	}).done(function(data) {		console.dir(data[data])		console.log(hmm:  + data[data][object][sha]);		sha = data[data][object][sha];;		window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/launcher.user.js? + Math.floor((Math.random()  1000000) + 1), function(data) {			var latestVersion = data.replace(()gm, );			latestVersion = latestVersion.substring(latestVersion.indexOf() + 11, latestVersion.indexOf());			latestVersion = parseFloat(latestVersion + 0.0000);			var script1 = https://cdn.rawgit.com/Apostolique/Agar.io-bot/ + sha + /launcher.user.js;			console.log(Script:  + script1);			window.jQuery(body).append(<script type=""text/javascript"" src="" + script1 + ""></script>);		});		window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/bot.user.js? + Math.floor((Math.random()  1000000) + 1), function(data) {			var latestVersion = data.replace(()gm, );			latestVersion = latestVersion.substring(latestVersion.indexOf() + 11, latestVersion.indexOf());			latestVersion = parseFloat(latestVersion + 0.0000);			var script2 = https://cdn.rawgit.com/Apostolique/Agar.io-bot/ + sha + /bot.user.js;			console.log(Script:  + script2);			window.jQuery(body).append(<script type=""text/javascript"" src="" + script2 + ""></script>);		});
		function update(prefix, name, url) {			window.jQuery(document.body).prepend(<div id=' + prefix + Dialog' style='position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 100; display: none;'>);			window.jQuery(# + prefix + Dialog).append(<div id=' + prefix + Message' style='width: 350px; background-color: #FFFFFF; margin: 100px auto; border-radius: 15px; padding: 5px 15px 5px 15px;'>);			window.jQuery(# + prefix + Message).append(<h2>UPDATE TIME!!!</h2>);			window.jQuery(# + prefix + Message).append(<p>Grab the update for: <a id=' + prefix + Link' href=' + url + ' target=_blank> + name + </a></p>);			window.jQuery(# + prefix + Link).on(click, function() {				window.jQuery(# + prefix + Dialog).hide();				window.jQuery(# + prefix + Dialog).remove();			});			window.jQuery(# + prefix + Dialog).show();		}		window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/loader.user.js? + Math.floor((Math.random()  1000000) + 1), function(data) {			var latestVersion = data.replace(()gm, );			latestVersion = latestVersion.substring(latestVersion.indexOf() + 11, latestVersion.indexOf());			latestVersion = parseFloat(latestVersion + 0.0000);			var myVersion = parseFloat(aposLoaderVersion + 0.0000);			if (latestVersion > myVersion) {				update(aposLoader, loader.user.js, https://github.com/Apostolique/Agar.io-bot/blob/master/loader.user.js/);			}			console.log(Current loader.user.js Version:  + myVersion +  on Github:  + latestVersion);		});	}).fail(function() {});}getLatestCommit();"
"Copyright (c) 2015 ApostoliquePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the ""Software""), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.*/ ==UserScript== @name        AposLauncher @namespace   AposLauncher @include     http://agar.io/* @version     5.041 @grant       none @author      http://www.twitch.tv/apostolique ==/UserScript==var aposLauncherVersion = 5.041;
var showAd = true;
Number.prototype.mod = function(n) {    return ((this % n) + n) % n;};
window.logDebugging = falsewindow.log = function(message){    if(window.logDebugging === true){        console.log.apply(console, arguments);    }}
Array.prototype.peek = function() {    return this[this.length - 1];};var sha = efde0488cc2cc176db48dd23b28a20b90314352b;
function getLatestCommit() {    window.jQuery.ajax({        url: https://api.github.com/repos/apostolique/Agar.io-bot/git/refs/heads/master,        cache: false,        dataType: jsonp    }).done(function(data) {        console.dir(data.data);        window.log(hmm:  + data.data.object.sha);        sha = data.data.object.sha;
        function update(prefix, name, url) {            window.jQuery(document.body).prepend(<div id=' + prefix + Dialog' style='position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 100; display: none;'>);            window.jQuery(# + prefix + Dialog).append(<div id=' + prefix + Message' style='width: 350px; background-color: #FFFFFF; margin: 100px auto; border-radius: 15px; padding: 5px 15px 5px 15px;'>);            window.jQuery(# + prefix + Message).append(<h2>UPDATE TIME!!!</h2>);            window.jQuery(# + prefix + Message).append(<p>Grab the update for: <a id=' + prefix + Link' href=' + url + ' target=_blank> + name + </a></p>);            window.jQuery(# + prefix + Link).on(click, function() {                window.jQuery(# + prefix + Dialog).hide();                window.jQuery(# + prefix + Dialog).remove();            });            window.jQuery(# + prefix + Dialog).show();        }
        window.jQuery.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/launcher.user.js? + Math.floor((Math.random()  1000000) + 1), function(data) {            var latestVersion = data.replace(()gm, );            latestVersion = latestVersion.substring(latestVersion.indexOf() + 11, latestVersion.indexOf());
            latestVersion = parseFloat(latestVersion + 0.0000);            var myVersion = parseFloat(aposLauncherVersion + 0.0000);
            if (latestVersion > myVersion) {                update(aposLauncher, launcher.user.js, https://github.com/Apostolique/Agar.io-bot/blob/ + sha + /launcher.user.js/);            }            window.log(Current launcher.user.js Version:  + myVersion +  on Github:  + latestVersion);        });
    }).fail(function() {});}getLatestCommit();
function addAd() {    window.google_ad_client = ca-pub-5878021809689194;    window.google_ad_slot = 1479874665;    window.google_ad_width = 300;    window.google_ad_height = 250;
    window.jQuery(.side-container:last).append(<div class='agario-panel'><center id='aposAd'></center></div>);    var aposAd = document.getElementById(aposAd);    var w = document.write;    document.write = function(content) {        aposAd.innerHTML = content;        document.write = w;    };
    var script = document.createElement(script);    script.type = text/javascript;    script.src = ;    document.body.appendChild(script);}
if (showAd) {    addAd();}
(function(c, e) {    function vc() {        for (var a = document.cookie.split(;), b = 0; b < a.length; b++) {            for (var d = a[b];                  == d.charAt(0);) d = d.substring(1, d.length);            if (0 == d.indexOf(agario_redirect=)) return d.substring(16, d.length)        }        return null    }
    function qa(a, b) {        if (b) {            var d = new Date;            d.setTime(d.getTime() + 864E5  b);            d = ; expires= + d.toGMTString()        } else d = ;        document.cookie = agario_redirect= + a + d + ; path=/    }    UPDATE    function keyAction(e) {        if (84 == e.keyCode) {            window.log(Toggle);            toggle = !toggle;        }        if (82 == e.keyCode) {            window.log(ToggleDraw);            toggleDraw = !toggleDraw;        }        if (68 == e.keyCode) {            window.setDarkTheme(!getDarkBool());        }        if (70 == e.keyCode) {            window.setShowMass(!getMassBool());        }        window.botList[botIndex].keyAction(e);    }    UPDATE    function humanPlayer() {        Don't need to do anything.        return [getPointX(), getPointY()];    }

    function Lb() {        UPDATE
        window.botList = window.botList || [];
        window.jQuery(#nick).val(originalName);
        function HumanPlayerObject() {            this.name = Human;            this.keyAction = function(key) {};            this.displayText = function() {                return [];            };            this.mainLoop = humanPlayer;        }
        var hpo = new HumanPlayerObject();
        window.botList.push(hpo);
        window.updateBotList();
        ab = !0;        Ob();        setInterval(Ob, 18E4);
        var father = window.jQuery(#canvas).parent();        window.jQuery(#canvas).remove();        father.prepend(<canvas id='canvas1'>);        $b();
        O = Ab = document.getElementById(canvas1);        f = O.getContext(2d);        UPDATE        O.onmousedown = function(a) {            if (gc) {                var b = a.clientX - (5 + q / 5 / 2),                    c = a.clientY - (5 + q / 5 / 2);                if (Math.sqrt(b  b + c  c) <= q / 5 / 2) {                    Ka();                    H(17);                    return                }            }            Y = 1  a.clientX;            Z = 1  a.clientY;            $a();            Ka();        };        UPDATE        O.onmousemove = function(a) {            Xa = !1;            Y = 1  a.clientX;            Z = 1  a.clientY;            $a()        };        O.onmouseup = function() {};        firefoxi.test(navigator.userAgent) ? document.addEventListener(DOMMouseScroll, Nb, !1) : document.body.onmousewheel = Nb        c.onkeydown = function(a) {            UPDATE            if (!window.jQuery(#nick).is(:focus)) {                32 != a.keyCode || ra || (nick != a.target.id && a.preventDefault(), Za(), ra = !0);                81 == a.keyCode && (X(18), sa = !0);                87 != a.keyCode || ta || (Mb(), ta = !0);                27 == a.keyCode && (a.preventDefault(), ua(300), e(#oferwallContainer).is(:visible) && c.closeOfferwall(), e(#videoContainer).is(:visible) && c.closeVideoContainer())                    UPDATE                keyAction(a);            }        };        c.onkeyup = function(a) {            32 == a.keyCode && (ra = !1);            87 == a.keyCode && (ta = !1);            81 == a.keyCode && sa && (X(19), sa = !1)        }    }
    function Nb(a) {        a.preventDefault();        P  Math.pow(.9, a.wheelDelta / -120 || a.detail || 0);        window.log(P:  + P)            UPDATE        0.07 > P && (P = 0.07);        P > 4 / r && (P = 4 / r)    }
    function wc() {        if (.4 > r) ia = null;        else {            for (var a = Number.POSITIVE_INFINITY, b = Number.POSITIVE_INFINITY, d = Number.NEGATIVE_INFINITY, c = Number.NEGATIVE_INFINITY, g = 0; g < z.length; g++) {                var e = z[g];                !e.P() || e.V || 20 >= e.size  r || (a = Math.min(e.x - e.size, a), b = Math.min(e.y - e.size, b), d = Math.max(e.x + e.size, d), c = Math.max(e.y + e.size, c))            }            ia = xc.init({                Ba: a - 10,                Ca: b - 10,                za: d + 10,                Aa: c + 10,                Ja: 2,                Ka: 4            });            for (g = 0; g < z.length; g++)                if (e = z[g], e.P() && !(20 >= e.size  r))                    for (a = 0; a < e.a.length; ++a) b = e.a[a].x, d = e.a[a].y, b < A - q / 2 / r || d < B - u / 2 / r || b > A + q / 2 / r || d > B + u / 2 / r || ia.va(e.a[a])        }    }
    function $a() {        UPDATE        if (toggle || window.botList[botIndex].name == Human) {            setPoint((Y - q / 2) / r + A, (Z - u / 2) / r + B);        }    }
    function Ob() {        null == xa && (xa = {}, e(#region).children().each(function() {            var a = e(this),                b = a.val();            b && (xa[b] = a.text())        }));        e.get(ya + info, function(a) {            var b = {},                d;            for (d in a.regions) {                var c = d.split(:)[0];                b[c] = b[c] || 0;                b[c] += a.regions[d].numPlayers            }            for (d in b) e(#region option[value="" + d + ""]).text(xa[d] +  ( + b[d] +  players))        }, json)    }
    function Pb() {        e(#adsBottom).hide();        e(#overlays).hide();        e(#stats).hide();        e(#mainPanel).hide();        aa = ja = !1;        Qb();        c.destroyAd(c.adSlots.aa);        c.destroyAd(c.adSlots.ac)    }
    function za(a) {        a && (a == K ? e(.btn-needs-server).prop(disabled, !1) : (e(#region).val() != a && e(#region).val(a), K = c.localStorage.location = a, e(.region-message).hide(), e(.region-message. + a).show(), e(.btn-needs-server).prop(disabled, !1), ab && Q()))    }
    function ua(a) {        ja || aa || (Aa ? e(.btn-spectate).prop(disabled, !0) : e(.btn-spectate).prop(disabled, !1), Ba = !1, N = null, bb || (e(#adsBottom).show(), e(#g300x250).hide(), e(#a300x250).show(), e(#g728x90).hide(), e(#a728x90).show()), c.refreshAd(bb ? c.adSlots.ac : c.adSlots.aa), bb = !1, 1E3 > a && (C = 1), ja = !0, e(#mainPanel).show(), 0 < a ? e(#overlays).fadeIn(a) : e(#overlays).show())    }
    function ka(a) {        e(#helloContainer).attr(data-gamemode, a);        Ca = a;        e(#gamemode).val(a)    }
    function Qb() {        e(#region).val() ? c.localStorage.location = e(#region).val() : c.localStorage.location && e(#region).val(c.localStorage.location);        e(#region).val() ? e(#locationKnown).append(e(#region)) : e(#locationUnknown).append(e(#region))    }
    function cb(a) {        env_local in EnvConfig ? true == EnvConfig.load_local_configuration ? c.MC.updateConfigurationID(base) : c.MC.updateConfigurationID(EnvConfig.configID) : c.MC.updateConfigurationID(a)    }
    function yc() {        configID in E ? cb(E.configID) : e.get(ya + getLatestID, function(a) {            cb(a);            c.localStorage.last_config_id = a        }).fail(function() {            var a;            if (a = last_config_id in c.localStorage) a = c.localStorage.last_config_id, a = !(null == a || void 0 == a ||  === a);            a && (a = c.localStorage.last_config_id, window.log(Fallback to stored configID:  + a), cb(a))        })    }
    function zc() {        e.get(db + , function(a) {            var b = a.split( );            a = b[0];            b = b[1] || ; - 1 == [UA].indexOf(a) && Rb.push(ussr);            la.hasOwnProperty(a) && (string == typeof la[a] ? K || za(la[a]) : la[a].hasOwnProperty(b) && (K || za(la[a][b])))        }, text)    }
    function R(a) {        return c.i18n[a] || c.i18n_dict.en[a] || a    }
    function Sb() {        var a = ++eb;        Tb();        e.ajax(ya + findServer, {            error: function() {                window.log(Failed to get server. Will retry in 30 seconds);                setTimeout(Sb, 3E4)            },            success: function(b) {                if (a == eb) {                    b.alert && alert(b.alert);                    var d = b.ip;                    game_server_port in EnvConfig && (d = c.location.hostname + : + EnvConfig.game_server_port);                    fb(ws + (gb ? s : ) + :// + d, b.token)                }            },            dataType: json,            method: POST,            cache: !1,            crossDomain: !0,            data: (K + Ca || ?) + 154669603        })    }
    function Q() {        ab && K && (e(#connecting).show(), Sb())    }
    function Tb() {        if (x) {            x.onopen = null;            x.onmessage = null;            x.onclose = null;            try {                x.close()            } catch (a) {}            x = null        }    }
    function fb(a, b) {        Tb();        E.ip && (a = ws + (gb ? s : ) + :// + E.ip);        if (null != S) {            var d = S;            S = function() {                d(b)            }        }        if (gb && !EnvConfig.env_development && !EnvConfig.env_local) {            var c = a.split(:);            a = wss://ip- + c[1].replace(g, -).replace(g, ) + .tech.agar.io: + +c[2]        }        G = [];        t = [];        L = {};        z = [];        ba = [];        D = [];        H = I = null;        T = 0;        ma = !1;        m.cache.sentGameServerLogin = !1;        UPDATE        window.log(Connecting to  + a);        serverIP = a;        x = new WebSocket(a);        x.binaryType = arraybuffer;        x.onopen = function() {            var a;            Da = y = Date.now();            na = 120;            Ea = 0;            window.log(socket open);            a = U(5);            a.setUint8(0, 254);            a.setUint32(1, 5, !0);            V(a);            a = U(5);            a.setUint8(0, 255);            a.setUint32(1, 154669603, !0);            V(a);            a = U(1 + b.length);            a.setUint8(0, 80);            for (var d = 0; d < b.length; ++d) a.setUint8(d + 1, b.charCodeAt(d));            V(a);            m.core.proxy.onSocketOpen()        };        x.onmessage = Ac;        x.onclose = Bc;        x.onerror = function() {            window.log(hb.la() +  socket error, arguments)        }    }
    function U(a) {        return new DataView(new ArrayBuffer(a))    }
    function V(a) {        x.send(a.buffer)    }
    function Bc() {        ma && (Fa = 500);        m.core.proxy.onSocketClosed();        window.log(hb.la() +  socket close);        setTimeout(Q, Fa);        Fa  2    }
    function Ac(a) {        Cc(new DataView(a.data))    }
    function Cc(a) {        function b() {            for (var b = ;;) {                var c = a.getUint16(d, !0);                d += 2;                if (0 == c) break;                b += String.fromCharCode(c)            }            return b        }        var d = 0;        if (240 == a.getUint8(d)) Ga();        else switch (a.getUint8(d++)) {            case 16:                Dc(a, d);                break;            case 17:                ib = a.getFloat32(d, !0);                d += 4;                jb = a.getFloat32(d, !0);                d += 4;                kb = a.getFloat32(d, !0);                d += 4;                break;            case 18:                G = [];                t = [];                L = {};                z = [];                break;            case 20:                t = [];                G = [];                break;            case 21:                lb = a.getInt16(d, !0);                d += 2;                mb = a.getInt16(d, !0);                d += 2;                nb || (nb = !0, Ha = lb, Ia = mb);                break;            case 32:                G.push(a.getUint32(d, !0));                d += 4;                break;            case 49:                if (null != I) break;                var v = a.getUint32(d, !0),                    d = d + 4;                D = [];                for (var g = 0; g < v; ++g) {                    var e = a.getUint32(d, !0),                        d = d + 4;                    D.push({                        id: e,                        name: b()                    })                }                Ub();                break;            case 50:                I = [];                v = a.getUint32(d, !0);                d += 4;                for (g = 0; g < v; ++g) I.push(a.getFloat32(d, !0)), d += 4;                Ub();                break;            case 64:                ob = a.getFloat64(d, !0);                d += 8;                pb = a.getFloat64(d, !0);                d += 8;                qb = a.getFloat64(d, !0);                d += 8;                rb = a.getFloat64(d, !0);                d += 8;                a.byteLength > d && (v = a.getUint32(d, !0), d += 4, sb = !!(v & 1), tb = b(), c.MC.updateServerVersion(tb), window.log(Server version  + tb));                break;            case 102:                v = a.buffer.slice(d);                m.core.proxy.forwardProtoMessage(v);                break;            case 104:                c.logout()        }    }
    function Dc(a, b) {        function d() {            for (var d = ;;) {                var c = a.getUint16(b, !0);                b += 2;                if (0 == c) break;                d += String.fromCharCode(c)            }            return d        }
        function v() {            for (var d = ;;) {                var c = a.getUint8(b++);                if (0 == c) break;                d += String.fromCharCode(c)            }            return d        }        y = Date.now();        var g = y - Da;        Da = y;        na = Ec  na + Fc  g;        Ea = Gc  Ea + Hc  Math.abs(g - na);        m.core.debug && (m.debug.updateChart(networkUpdate, y, g), m.debug.updateChart(rttMean, y, na), m.debug.updateChart(rttSDev, y, Ea));        ma || (ma = !0, e(#connecting).hide(), Vb(), S && (S(), S = null));        ub = !1;        g = a.getUint16(b, !0);        b += 2;        for (var p = 0; p < g; ++p) {            var M = L[a.getUint32(b, !0)],                l = L[a.getUint32(b + 4, !0)];            b += 8;            M && l && (l.ca(), l.s = l.x, l.u = l.y, l.o = l.size, l.pa(M.x, M.y), l.g = l.size, l.T = y, Ic(M, l))        }        for (p = 0;;) {            g = a.getUint32(b, !0);            b += 4;            if (0 == g) break;            ++p;            var vb, M = a.getInt32(b, !0);            b += 4;            l = a.getInt32(b, !0);            b += 4;            vb = a.getInt16(b, !0);            b += 2;            var n = a.getUint8(b++),                f = a.getUint8(b++),                h = a.getUint8(b++),                f = Jc(n << 16 | f << 8 | h),                h = a.getUint8(b++),                k = !!(h & 1),                r = !!(h & 16),                q = null;            h & 2 && (b += 4 + a.getUint32(b, !0));            h & 4 && (q = v());            var u = d(),                n = null;            L.hasOwnProperty(g) ? (n = L[g], n.S(), n.s = n.x, n.u = n.y, n.o = n.size, n.color = f) : (n = new ca(g, M, l, vb, f, u), z.push(n), L[g] = n);            n.c = k;            n.h = r;            n.pa(M, l);            n.g = vb;            n.T = y;            n.ea = h;            q && (n.C = q);            UPDATE            u && n.A(u); - 1 != G.indexOf(g) && -1 == t.indexOf(n) && (t.push(n), n.birth = getLastUpdate(), n.birthMass = (n.size  n.size / 100), n.I = !0, 1 == t.length && (n.wa = !0, A = n.x, B = n.y, Wb(), document.getElementById(overlays).style.display = none, F = [], wb = 0, xb = t[0].color, Aa = !0, Ja = Date.now(), W = yb = zb = 0))                UPDATE            interNodes[g] = window.getCells()[g];        }        UPDATE        Object.keys(interNodes).forEach(function(element, index) {            window.log(""start: "" + interNodes[element].updateTime + "" current: "" + h.detail + "" life: "" + (h.detail - interNodes[element].updateTime));            var isRemoved = !window.getCells().hasOwnProperty(element);
            window.log(""Time not updated: "" + (window.getLastUpdate() - interNodes[element].getUptimeTime()));            if (isRemoved && (window.getLastUpdate() - interNodes[element].getUptimeTime()) > 3000) {                delete interNodes[element];            } else {                if (isRemoved &&                    interNodes[element].x > (getX() - (1920 / 2) / getZoomlessRatio()) &&                    interNodes[element].x < (getX() + (1920 / 2) / getZoomlessRatio()) &&                    interNodes[element].y > getY() - (1080 / 2) / getZoomlessRatio() &&                    interNodes[element].y < getY() + (1080 / 2) / getZoomlessRatio()) {
                    delete interNodes[element];                }            }        });        M = a.getUint32(b, !0);        b += 4;        for (p = 0; p < M; p++) g = a.getUint32(b, !0), b += 4, n = L[g], null != n && n.ca();        ub && 0 == t.length && (0 == c.MC.isUserLoggedIn() ? Ga() : Xb = setTimeout(Ga, 2E3))    }
    UPDATE    function computeDistance(x1, y1, x2, y2) {        var xdis = x1 - x2;  <--- FAKE AmS OF COURSE!        var ydis = y1 - y2;        var distance = Math.sqrt(xdis  xdis + ydis  ydis);
        return distance;    }    UPDATE         * Some horse shit of some sort.     *  Horse Shit     */    function screenDistance() {        return Math.min(computeDistance(getOffsetX(), getOffsetY(), screenToGameX(getWidth()), getOffsetY()), computeDistance(getOffsetX(), getOffsetY(), getOffsetX(), screenToGameY(getHeight())));    }
    window.verticalDistance = function() {        return computeDistance(screenToGameX(0), screenToGameY(0), screenToGameX(getWidth()), screenToGameY(getHeight()));    }
         * A conversion from the screen's horizontal coordinate system     * to the game's horizontal coordinate system.     *   in the screen's coordinate system     *  x in the game's coordinate system     */    window.screenToGameX = function(x) {        return (x - getWidth() / 2) / getRatio() + getX();    }
         * A conversion from the screen's vertical coordinate system     * to the game's vertical coordinate system.     *   in the screen's coordinate system     *  y in the game's coordinate system     */    window.screenToGameY = function(y) {        return (y - getHeight() / 2) / getRatio() + getY();    }
    window.drawPoint = function(x_1, y_1, drawColor, text) {        if (!toggleDraw) {            dPoints.push([x_1, y_1, drawColor]);            dText.push(text);        }    }
    window.drawArc = function(x_1, y_1, x_2, y_2, x_3, y_3, drawColor) {        if (!toggleDraw) {            var radius = computeDistance(x_1, y_1, x_3, y_3);            dArc.push([x_1, y_1, x_2, y_2, x_3, y_3, radius, drawColor]);        }    }
    window.drawLine = function(x_1, y_1, x_2, y_2, drawColor) {        if (!toggleDraw) {            lines.push([x_1, y_1, x_2, y_2, drawColor]);        }    }
    window.drawCircle = function(x_1, y_1, radius, drawColor) {        if (!toggleDraw) {            circles.push([x_1, y_1, radius, drawColor]);        }    }
    function Ka() {        UPDATE        if (firstStart) {            Uc(false);        }
        if (getPlayer().length == 0 && !reviving && ~~(getCurrentScore() / 100) > 0) {            window.log(Dead:  + ~~(getCurrentScore() / 100));            apos(send, pageview);        }
        if (getPlayer().length == 0 && !firstStart) {            window.log(Revive);            setNick(originalName);            reviving = true;        } else if (getPlayer().length > 0 && reviving) {            reviving = false;            window.log(Done Reviving!);        }
        if (da()) {            var a = Y - q / 2,                b = Z - u / 2;            64 > a  a + b  b || .01 > Math.abs(Yb - va) && .01 > Math.abs(Zb - wa) || (Yb = va, Zb = wa, a = U(13), a.setUint8(0, 16), a.setInt32(1, va, !0), a.setInt32(5, wa, !0), a.setUint32(9, 0, !0), V(a))        }    }
    function Vb() {        if (da() && ma && null != N) {            var a = U(1 + 2  N.length);            a.setUint8(0, 0);            for (var b = 0; b < N.length; ++b) a.setUint16(1 + 2  b, N.charCodeAt(b), !0);            V(a);            N = null;            Ba = !0        }    }
    function Za() {        Ka();        X(17)    }
    function Mb() {        Ka();        X(21)    }
    function da() {        return null != x && x.readyState == x.OPEN    }
    function X(a) {        if (da()) {            var b = U(1);            b.setUint8(0, a);            V(b)        }    }
    function Kc(a) {        auto == a.toLowerCase() ? h.auto = !0 : (m.renderSettings.selected = m.renderSettings[a.toLowerCase()], h.auto = !1)    }
    function $b() {        q = 1  c.innerWidth;        u = 1  c.innerHeight;        Ab.width = O.width = q;        Ab.height = O.height = u;        var a = e(#helloContainer);        a.css(transform, none);        var b = a.height(),            d = c.innerHeight;        0 != b / 2 % 2 && (b++, a.height(b));        b > d / 1.1 ? a.css(transform, translate(-50%, -50%) scale( + d / b / 1.1 + )) : a.css(transform, translate(-50%, -50%));        ac()    }
    function bc() {        var a;        a = 1  Math.max(u / 1080, q / 1920);        return a  P    }
    UPDATE    function bc2() {        var a;        a = 1  Math.max(u / 1080, q / 1920);        return a;    }
    function Lc() {        if (0 != t.length) {            for (var a = 0, b = 0; b < t.length; b++) a += t[b].size;            r = (9  r + Math.pow(Math.min(64 / a, 1), .4)  bc()) /                10;            UPDATE            var r2 = (9  r + Math.pow(Math.min(64 / a, 1), .4)  bc2()) / 10;        }    }
    function ac() {        UPDATE        window.log(Update rendering);        dPoints = [];        circles = [];        dArc = [];        dText = [];        lines = [];        var a, b = Date.now();        ++Mc;        cc && (++La, 180 < La && (La = 0));        y = b;        if (0 < t.length) {            Lc();            for (var d = a = 0, c = 0; c < t.length; c++) t[c].S(), a += t[c].x / t.length, d += t[c].y / t.length;            ib = a;            jb = d;            kb = r;            A = (A + a) / 2;            B = (B + d) / 2                UPDATE        } else A = (5  A + ib) / 6, B = (5  B + jb) / 6, r = (9  r + kb  bc()) / 10, r2 = (9  r + kb  bc2()) / 10;        wc();        $a();        Bb || f.clearRect(0, 0, q, u);        Bb ? (f.fillStyle = ea ? #111111 : #F2FBFF, f.globalAlpha = .05, f.fillRect(0, 0, q, u), f.globalAlpha = 1) : Nc();        z.sort(function(a, b) {            return a.size == b.size ? a.id - b.id : a.size - b.size        });        f.save();        f.translate(q / 2, u / 2);        f.scale(r, r);        f.translate(-A, -B);        UPDATE        f.save();        f.beginPath();        f.lineWidth = 5;        f.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);        f.moveTo(getMapStartX(), getMapStartY());        f.lineTo(getMapStartX(), getMapEndY());        f.stroke();        f.moveTo(getMapStartX(), getMapStartY());        f.lineTo(getMapEndX(), getMapStartY());        f.stroke();        f.moveTo(getMapEndX(), getMapStartY());        f.lineTo(getMapEndX(), getMapEndY());        f.stroke();        f.moveTo(getMapStartX(), getMapEndY());        f.lineTo(getMapEndX(), getMapEndY());        f.stroke();        f.restore();        for (c = 0; c < ba.length; c++) ba[c].w(f);        for (c = 0; c < z.length; c++) z[c].w(f);        UPDATE        if (getPlayer().length > 0) {            var moveLoc = window.botList[botIndex].mainLoop();            if (!toggle) {                setPoint(moveLoc[0], moveLoc[1]);            }        }        customRender(f);        if (nb) {            Ha = (3  Ha + lb) / 4;            Ia = (3  Ia + mb) / 4;            f.save();            f.strokeStyle = #FFAAAA;            f.lineWidth = 10;            f.lineCap = round;            f.lineJoin = round;            f.globalAlpha = .5;            f.beginPath();            for (c = 0; c < t.length; c++) f.moveTo(t[c].x, t[c].y), f.lineTo(Ha, Ia);            f.stroke();            f.restore()        }        f.restore();        H && H.width && f.drawImage(H, q - H.width - 10, 10);        T = Math.max(T, dc());        UPDATE
        var currentDate = new Date();
        var nbSeconds = 0;        if (getPlayer().length > 0) {            nbSeconds = currentDate.getSeconds() + currentDate.getMinutes() * 60 + currentDate.getHours() * 3600 - lifeTimer.getSeconds() - lifeTimer.getMinutes() * 60 - lifeTimer.getHours() * 3600;            nbSeconds = (currentDate.getTime() - lifeTimer.getTime()) / 1000;        }
        bestTime = Math.max(nbSeconds, bestTime);
        var displayText = Score:  + ~~(T / 100) +  Current Time:  + nbSeconds +  seconds.;
        0 != T && (null == Ma && (Ma = new Na(24, #FFFFFF)), Ma.B(displayText), d = Ma.N(), a = d.width, f.globalAlpha =            .2, f.fillStyle = #000000, f.fillRect(10, u - 10 - 24 - 10, a + 10, 34), f.globalAlpha = 1, f.drawImage(d, 15, u - 10 - 24 - 5));        Oc();        b = Date.now() - b;        b > 1E3 / 60 ? h.detail -= .01 : b < 1E3 / 65 && (h.detail += .001);        h.detail < h.selected.minDetail && (h.auto && h.downgrade(), h.detail = h.selected.minDetail);        h.detail > h.selected.maxDetail && (h.auto && h.upgrade(), h.detail = h.selected.maxDetail);        b = y - ec;        !da() || ja || aa ? (C += b / 2E3, 1 < C && (C = 1)) : (C -= b / 300, 0 > C && (C = 0));        0 < C ? (f.fillStyle = #000000, fc ? (f.globalAlpha = C, f.fillRect(0, 0, q, u), J.complete && J.width && (J.width /            J.height < q / u ? (b = q, a = J.height  q / J.width) : (b = J.width  u / J.height, a = u), f.drawImage(J, (q - b) / 2, (u - a) / 2, b, a), f.globalAlpha = .5  C, f.fillRect(0, 0, q, u))) : (f.globalAlpha = .5  C, f.fillRect(0, 0, q, u)), f.globalAlpha = 1) : fc = !1;        h.selected.ma && Ba && (Oa++, Oa > 10  h.selected.warnFps ? (h.selected.ma = !1, Oa = -1, Pa = 0) : Pc());        ec = y            UPDATE        drawStats(f);    }    UPDATE    function customRender(d) {        d.save();        for (var i = 0; i < lines.length; i++) {            d.beginPath();
            d.lineWidth = 5;
            if (lines[i][4] == 0) {                d.strokeStyle = #FF0000;            } else if (lines[i][4] == 1) {                d.strokeStyle = #00FF00;            } else if (lines[i][4] == 2) {                d.strokeStyle = #0000FF;            } else if (lines[i][4] == 3) {                d.strokeStyle = #FF8000;            } else if (lines[i][4] == 4) {                d.strokeStyle = #8A2BE2;            } else if (lines[i][4] == 5) {                d.strokeStyle = #FF69B4;            } else if (lines[i][4] == 6) {                d.strokeStyle = #008080;            } else if (lines[i][4] == 7) {                d.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);            } else {                d.strokeStyle = #000000;            }
            d.moveTo(lines[i][0], lines[i][1]);            d.lineTo(lines[i][2], lines[i][3]);
            d.stroke();        }        d.restore();        d.save();        for (var i = 0; i < circles.length; i++) {            if (circles[i][3] == 0) {                d.strokeStyle = #FF0000;            } else if (circles[i][3] == 1) {                d.strokeStyle = #00FF00;            } else if (circles[i][3] == 2) {                d.strokeStyle = #0000FF;            } else if (circles[i][3] == 3) {                d.strokeStyle = #FF8000;            } else if (circles[i][3] == 4) {                d.strokeStyle = #8A2BE2;            } else if (circles[i][3] == 5) {                d.strokeStyle = #FF69B4;            } else if (circles[i][3] == 6) {                d.strokeStyle = #008080;            } else if (circles[i][3] == 7) {                d.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);            } else {                d.strokeStyle = #000000;            }            d.beginPath();
            d.lineWidth = 10;            d.setLineDash([5]);            d.globalAlpha = 0.3;
            d.arc(circles[i][0], circles[i][1], circles[i][2], 0, 2  Math.PI, false);
            d.stroke();        }        d.restore();        d.save();        for (var i = 0; i < dArc.length; i++) {            if (dArc[i][7] == 0) {                d.strokeStyle = #FF0000;            } else if (dArc[i][7] == 1) {                d.strokeStyle = #00FF00;            } else if (dArc[i][7] == 2) {                d.strokeStyle = #0000FF;            } else if (dArc[i][7] == 3) {                d.strokeStyle = #FF8000;            } else if (dArc[i][7] == 4) {                d.strokeStyle = #8A2BE2;            } else if (dArc[i][7] == 5) {                d.strokeStyle = #FF69B4;            } else if (dArc[i][7] == 6) {                d.strokeStyle = #008080;            } else if (dArc[i][7] == 7) {                d.strokeStyle = (getDarkBool() ? #F2FBFF : #111111);            } else {                d.strokeStyle = #000000;            }
            d.beginPath();
            d.lineWidth = 5;
            var ang1 = Math.atan2(dArc[i][1] - dArc[i][5], dArc[i][0] - dArc[i][4]);            var ang2 = Math.atan2(dArc[i][3] - dArc[i][5], dArc[i][2] - dArc[i][4]);
            d.arc(dArc[i][4], dArc[i][5], dArc[i][6], ang1, ang2, false);
            d.stroke();        }        d.restore();        d.save();        for (var i = 0; i < dPoints.length; i++) {            if (dText[i] == ) {                var radius = 10;
                d.beginPath();                d.arc(dPoints[i][0], dPoints[i][1], radius, 0, 2  Math.PI, false);
                if (dPoints[i][2] == 0) {                    d.fillStyle = black;                } else if (dPoints[i][2] == 1) {                    d.fillStyle = yellow;                } else if (dPoints[i][2] == 2) {                    d.fillStyle = blue;                } else if (dPoints[i][2] == 3) {                    d.fillStyle = red;                } else if (dPoints[i][2] == 4) {                    d.fillStyle = #008080;                } else if (dPoints[i][2] == 5) {                    d.fillStyle = #FF69B4;                } else {                    d.fillStyle = #000000;                }
                d.fill();                d.lineWidth = 2;                d.strokeStyle = #003300;                d.stroke();            } else {                var text = new Na(18, (getDarkBool() ? #F2FBFF : #111111), true, (getDarkBool() ? #111111 : #F2FBFF));
                text.B(dText[i]);                var textRender = text.N();                d.drawImage(textRender, dPoints[i][0] - (textRender.width / 2), dPoints[i][1] - (textRender.height / 2));            }
        }        d.restore();    }    UPDATE    function drawStats(d) {        d.save()
        sessionScore = Math.max(getCurrentScore(), sessionScore);
        var botString = window.botList[botIndex].displayText();
        var debugStrings = [];        debugStrings.push(Bot:  + window.botList[botIndex].name);        debugStrings.push(Launcher: AposLauncher  + aposLauncherVersion);        debugStrings.push(T - Bot:  + (!toggle ? On : Off));        debugStrings.push(R - Lines:  + (!toggleDraw ? On : Off));
        for (var i = 0; i < botString.length; i++) {            debugStrings.push(botString[i]);        }
        debugStrings.push();        debugStrings.push(Best Score:  + ~~(sessionScore / 100));        debugStrings.push(Best Time:  + bestTime +  seconds);        debugStrings.push();        debugStrings.push(serverIP);
        if (getPlayer().length > 0) {            var offsetX = -getMapStartX();            var offsetY = -getMapStartY();            debugStrings.push(Location:  + Math.floor(getPlayer()[0].x + offsetX) + ,  + Math.floor(getPlayer()[0].y + offsetY));        }
        var offsetValue = 20;        var text = new Na(18, (getDarkBool() ? #F2FBFF : #111111));
        for (var i = 0; i < debugStrings.length; i++) {            text.B(debugStrings[i]);            var textRender = text.N();            d.drawImage(textRender, 20, offsetValue);            offsetValue += textRender.height;        }
        if (message.length > 0) {            var mRender = [];            var mWidth = 0;            var mHeight = 0;
            for (var i = 0; i < message.length; i++) {                var mText = new Na(28, #FF0000, true, #000000);                mText.B(message[i]);                mRender.push(mText.N());
                if (mRender[i].width > mWidth) {                    mWidth = mRender[i].width;                }                mHeight += mRender[i].height;            }
            var mX = getWidth() / 2 - mWidth / 2;            var mY = 20;
            d.globalAlpha = 0.4;            d.fillStyle = #000000;            d.fillRect(mX - 10, mY - 10, mWidth + 20, mHeight + 20);            d.globalAlpha = 1;
            var mOffset = mY;            for (var i = 0; i < mRender.length; i++) {                d.drawImage(mRender[i], getWidth() / 2 - mRender[i].width / 2, mOffset);                mOffset += mRender[i].height;            }        }
        d.restore();    }
    function Pc() {        var a = document.createElement(canvas),            b = a.getContext(2d),            d = Math.min(800, .6  q) / 800;        a.width = 800  d;        a.height = 60  d;        b.globalAlpha = .3;        b.fillStyle = #000000;        b.fillRect(0, 0, 800, 60);        b.globalAlpha =            1;        b.fillStyle = #FFFFFF;        b.scale(d, d);        d = null;        d = Your computer is running slow,;        b.font = 18px Ubuntu;        b.fillText(d, 400 - b.measureText(d).width / 2, 25);        d = please close other applications or tabs in your browser for better game performance.;        b.fillText(d, 400 - b.measureText(d).width / 2, 45);        f.drawImage(a, (q - a.width) / 2, u - a.height - 10)    }
    function Nc() {        f.fillStyle = ea ? #111111 : #F2FBFF;        f.fillRect(0, 0, q, u);        f.save();        f.strokeStyle = ea ? #AAAAAA : #000000;        f.globalAlpha = .2  r;        for (var a = q / r, b = u / r, d = (-A + a / 2) % 50; d < a; d += 50) f.beginPath(),            f.moveTo(d  r - .5, 0), f.lineTo(d  r - .5, b  r), f.stroke();        for (d = (-B + b / 2) % 50; d < b; d += 50) f.beginPath(), f.moveTo(0, d  r - .5), f.lineTo(a  r, d  r - .5), f.stroke();        f.restore()    }
    function Oc() {        if (gc && Cb.width) {            var a = q / 5;            f.drawImage(Cb, 5, 5, a, a)        }    }
    function dc() {        for (var a = 0, b = 0; b < t.length; b++) a += t[b].g  t[b].g;        return a    }
    function Ub() {        H = null;        if (null != I || 0 != D.length)            if (null != I || fa) {                H = document.createElement(canvas);                var a = H.getContext(2d),                    b = 60,                    b = null == I ? b + 24  D.length : b + 180,                    d = Math.min(200, .3  q) / 200;                H.width = 200  d;                H.height = b  d;                a.scale(d, d);                a.globalAlpha = .4;                a.fillStyle = #000000;                a.fillRect(0, 0, 200, b);                a.globalAlpha = 1;                a.fillStyle = #FFFFFF;                d = null;                d = R(leaderboard);                a.font = 30px Ubuntu;                a.fillText(d, 100 - a.measureText(d).width / 2, 40);                var c, e;                if (null == I)                    for (a.font = 20px Ubuntu, b = 0; b < D.length; ++b) d = D[b].name || R(unnamed_cell), fa || (d = R(unnamed_cell)), 1 == D[b].id || -1 != G.indexOf(D[b].id) ? (t[0].name && (d = t[0].name), a.fillStyle = #FFAAAA) : a.fillStyle = #FFFFFF, d = b + 1 + .  + d, e = a.measureText(d).width, c = 70 + 24  b, 200 < e ? a.fillText(d, 10, c) : a.fillText(d, (200 - e) / 2, c);                else                    for (b = d = 0; b < I.length; ++b) c = d + I[b]  Math.PI  2, a.fillStyle = Qc[b + 1], a.beginPath(), a.moveTo(100, 140), a.arc(100, 140, 80, d, c, !1), a.fill(), d = c            }    }
    function Rc(a) {        if (null == a || 0 == a.length) return null;        if (% == a[0]) {            if (!c.MC || !c.MC.getSkinInfo) return null;            a = c.MC.getSkinInfo(skin_ + a.slice(1));            if (null == a) return null;            for (a = (+a.color).toString(16); 6 > a.length;) a = 0 + a;            return # + a        }        return null    }
    function hc(a) {        if (null == a || 0 == a.length) return null;        if (!oa.hasOwnProperty(a)) {            var b = new Image;            if (: == a[0]) b.src = a.slice(1);            else if (% == a[0]) {                if (!c.MC || !c.MC.getSkinInfo) return null;                var d = c.MC.getSkinInfo(skin_ + a.slice(1));                if (null == d) return null;                b.src = c.ASSETS_ROOT + d.url            }            oa[a] = b        }        return 0 != oa[a].width && oa[a].complete ? oa[a] : null    }
    function Db(a, b, d, c, e) {        this.$ = a;        this.x = b;        this.y = d;        this.f = c;        this.b = e    }
    function ca(a, b, d, c, e, p) {        this.id = a;        this.s = this.x = this.L = this.J = b;        this.u = this.y = this.M = this.K = d;        this.o = this.size = c;        this.color = e;        this.a = [];        this.ba();        this.A(p)    }
    function Jc(a) {        for (a = a.toString(16); 6 > a.length;) a = 0 + a;        return # + a    }
    function Na(a, b, d, c) {        a && (this.v = a);        b && (this.W = b);        this.Y = !!d;        c && (this.Z = c)    }
    function Sc(a) {        for (var b = a.length, d, c; 0 < b;) c = Math.floor(Math.random()  b), b--, d = a[b], a[b] = a[c], a[c] = d    }
    function Tc() {        k = Qa    }
    function ic(a) {        k.context = google == a ? google : facebook;        Ra()    }
    function Ra() {        c.localStorage.storeObjectInfo = JSON.stringify(k);        k = JSON.parse(c.localStorage.storeObjectInfo);        c.storageInfo = k;        google == k.context ? (e(#gPlusShare).show(), e(#fbShare).hide()) : (e(#gPlusShare).hide(), e(#fbShare).show())    }
    function jc(a) {        e(#helloContainer).attr(data-has-account-data);         != a.displayName && (a.name = a.displayName);        if (null == a.name || void 0 == a.name) a.name = ;        var b = a.name.lastIndexOf(_); - 1 != b && (a.name = a.name.substring(0, b));        e(#helloContainer).attr(data-has-account-data, 1);        e(#helloContainer).attr(data-logged-in, 1);        e(.agario-profile-panel .progress-bar-star).text(a.level);        e(.agario-exp-bar .progress-bar-text).text(a.xp + / + a.xpNeeded +  XP);        e(.agario-exp-bar .progress-bar).css(width, (88  a.xp / a.xpNeeded).toFixed(2) + %);        e(.agario-profile-name).text(a.name);         != a.picture && e(.agario-profile-picture).attr(src, a.picture);        Eb();        k.userInfo.level = a.level;        k.userInfo.xp = a.xp;        k.userInfo.xpNeeded = a.xpNeeded;        k.userInfo.displayName = a.name;        k.userInfo.loggedIn = 1;        c.updateStorage()    }
    function ga(a, b) {        var d = a;        if (k.userInfo.loggedIn) {            var v = e(#helloContainer).is(:visible) && 1 == e(#helloContainer).attr(data-has-account-data);            if (null == d || void 0 == d) d = k.userInfo;            if (v) {                var g = +e(.agario-exp-bar .progress-bar-text).first().text().split(/)[0],                    v = +e(.agario-exp-bar .progress-bar-text).first().text().split(/)[1].split( )[0],                    p = e(.agario-profile-panel .progress-bar-star).first().text();                if (p != d.level) ga({                    xp: v,                    xpNeeded: v,                    level: p                }, function() {                    e(.agario-profile-panel .progress-bar-star).text(d.level);                    e(.agario-exp-bar .progress-bar).css(width, 100%);                    e(.progress-bar-star).addClass(animated tada).one(webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend, function() {                        e(.progress-bar-star).removeClass(animated tada)                    });                    setTimeout(function() {                        e(.agario-exp-bar .progress-bar-text).text(d.xpNeeded + / + d.xpNeeded +  XP);                        ga({                            xp: 0,                            xpNeeded: d.xpNeeded,                            level: d.level                        }, function() {                            ga(d)                        })                    }, 1E3)                });                else {                    var f = Date.now(),                        l = function() {                            var a;                            a = (Date.now() - f) / 1E3;                            a = 0 > a ? 0 : 1 < a ? 1 : a;                            a = a  a  (3 - 2  a);                            e(.agario-exp-bar .progress-bar-text).text(~~(g + (d.xp - g)  a) + / + d.xpNeeded +  XP);                            e(.agario-exp-bar .progress-bar).css(width, (88  (g + (d.xp - g)  a) / d.xpNeeded).toFixed(2) + %);                            b && b();                            1 > a && c.requestAnimationFrame(l)                        };                    c.requestAnimationFrame(l)                }            }        }    }
    function Eb() {        var a;        (undefined !== typeof a && a || none == e(#settings).css(display) && none == e(#socialLoginContainer).css(display)) && e(#instructions).show()    }
    function kc(a) {        if (connected == a.status) {            var b = a.authResponse.accessToken;            null == b || undefined == b ||  == b ? (3 > lc && (lc++, c.facebookRelogin()), c.logout()) : (c.MC.doLoginWithFB(b), m.cache.login_info = [b, facebook], c.FB.api(/me/picture?width=180&height=180, function(b) {                k.userInfo.picture = b.data.url;                c.updateStorage();                e(.agario-profile-picture).attr(src, b.data.url);                k.userInfo.socialId = a.authResponse.userID;                Sa()            }), e(#helloContainer).attr(data-logged-in, 1), k.context = facebook, k.loginIntent = 1, c.updateStorage())        }    }
    function mc(a) {        ka(:party);        e(#helloContainer).attr(data-party-state, 4);        a = decodeURIComponent(a).replace(#gim, );        Fb(# + c.encodeURIComponent(a));        e.ajax(ya + getToken, {            error: function() {                e(#helloContainer).attr(data-party-state, 6)            },            success: function(b) {                b = b.split();                e(.partyToken).val(agar.io/# + c.encodeURIComponent(a));                e(#helloContainer).attr(data-party-state, 5);                ka(:party);                fb(ws:// + b[0], a)            },            dataType: text,            method: POST,            cache: !1,            crossDomain: !0,            data: a        })    }
    function Fb(a) {        c.history && c.history.replaceState && c.history.replaceState({}, c.document.title, a)    }
    function Ga() {        Ba = !1;        clearTimeout(Xb);        null == c.storageInfo && c.createDefaultStorage();        Gb = Date.now();        0 >= Ja && (Ja = Gb);        Aa = !1;        Uc()    }
    function Ic(a, b) {        var d = -1 != G.indexOf(a.id),            c = -1 != G.indexOf(b.id),            e = 30 > b.size;        d && e && ++wb;        e || !d || c || b.ea & 32 || ++yb    }
    function nc(a) {        a = ~~a;        var b = (a % 60).toString();        a = (~~(a / 60)).toString();        2 > b.length && (b = 0 + b);        return a + : + b    }
    function Vc() {        if (null == D) return 0;        for (var a = 0; a < D.length; ++a)            if (D[a].id & 1) return a + 1;        return 0    }
    function Wc() {        e(.stats-food-eaten).text(wb);        e(.stats-time-alive).text(nc((Gb - Ja) / 1E3));        e(.stats-leaderboard-time).text(nc(zb));        e(.stats-highest-mass).text(~~(T / 100));        e(.stats-cells-eaten).text(yb);        e(.stats-top-position).text(0 == W ? :( : W);        var a = document.getElementById(statsGraph);        if (a) {            var b = a.getContext(2d),                d = a.width,                a = a.height;            b.clearRect(0, 0, d, a);            if (2 < F.length) {                for (var c = 200, g = 0; g < F.length; g++) c = Math.max(F[g], c);                b.lineWidth = 3;                b.lineCap = round;                b.lineJoin = round;                b.strokeStyle = xb;                b.fillStyle = xb;                b.beginPath();                b.moveTo(0, a - F[0] / c  (a - 10) + 10);                for (g = 1; g < F.length; g += Math.max(~~(F.length / d), 1)) {                    for (var p = g / (F.length - 1)  d, f = [], l = -20; 20 >= l; ++l) 0 > g + l || g + l >= F.length || f.push(F[g + l]);                    f = f.reduce(function(a, b) {                        return a + b                    }) / f.length / c;                    b.lineTo(p, a - f  (a - 10) + 10)                }                b.stroke();                b.globalAlpha = .5;                b.lineTo(d, a);                b.lineTo(0, a);                b.fill();                b.globalAlpha = 1            }        }    }
    function Uc() {        ja || aa || (Ta ? (c.refreshAd(c.adSlots.ab), Wc(), aa = !0, setTimeout(function() {            e(#overlays).fadeIn(500, function() {                ga()            });            e(#stats).show();            var a = oc(g_plus_share_stats);            c.fillSocialValues(a, gPlusShare)        }, 1500)) : ua(500))    }
    function oc(a) {        var b = e(.stats-time-alive).text();        return c.parseString(a, %@, [b.split(:)[0], b.split(:)[1], e(.stats-highest-mass).text()])    }
    function Xc() {        c.open(https://plus.google.com/share?url=www.agar.io&hl=en-US, Agar.io, width=484,height=580,menubar=no,toolbar=no,resizable=yes,scrollbars=no,left= +            (c.screenX + c.innerWidth / 2 - 242) + ,top= + (c.innerHeight - 580) / 2)    }    var pc = document.createElement(canvas);    if (undefined == typeof console || undefined == typeof DataView || undefined == typeof WebSocket || null == pc || null == pc.getContext || null == c.localStorage) alert(You browser does not support this game, we recommend you to use Firefox to play this);    else {        var E = {};        (function() {            var a = c.location.search;            ? == a.charAt(0) && (a = a.slice(1));            for (var a = a.split(&), b = 0; b < a.length; b++) {                var d = a[b].split(=);                E[d[0]] = d[1]            }        })();        c.queryString = E;        var qc = fb in E,            Yc = miniclip in E,            w = {                skinsEnabled: 0,                namesEnabled: 0,                noColors: 0,                blackTheme: 0,                showMass: 0,                statsEnabled: 0            },            Zc = function() {                qa(, -1)            },            rc = http: != c.location.protocol,            $c = 1 == vc(),            sc = !1;        qc || Yc || (rc && !$c ? (qa(1, 1), c.location.href = http: + c.location.href.substring(c.location.protocol.length), sc = !0) : qa(, -1));        rc || qa(, -1);        sc || setTimeout(Zc, 3E3);        if (!c.agarioNoInit) {            var db = c.location.protocol,                gb = https: == db;            E.master && (EnvConfig.master_url = E.master);            var ya = db +  +                EnvConfig.master_url + /,                Ua = c.navigator.userAgent;            if (-1 != Ua.indexOf(Android)) c.ga && c.ga(send, event, MobileRedirect, PlayStore), setTimeout(function() {                c.location.href = https://play.google.com/store/apps/details?id=com.miniclip.agar.io            }, 1E3);            else if (-1 != Ua.indexOf(iPhone) || -1 != Ua.indexOf(iPad) || -1 != Ua.indexOf(iPod)) c.ga && c.ga(send, event, MobileRedirect, AppStore), setTimeout(function() {                c.location.href = https://itunes.apple.com/app/agar.io/id995999703?mt=8&at=1l3vajp            }, 1E3);            else {                var m = {};                c.agarApp = m;                var Ab, f, O, q, u, ia = null,                    UPDATE                    toggle = false,                    toggleDraw = false,                    shootTime = 0,                    splitTime = 0,                    shootCooldown = 100,                    splitCooldown = 100,                    tempPoint = [0, 0, 1],                    dPoints = [],                    circles = [],                    dArc = [],                    dText = [],                    lines = [],                    names = [NotReallyABot],                    firstStart = true;                originalName = names[Math.floor(Math.random()  names.length)],                    sessionScore = 0,                    serverIP = ,                    interNodes = [],                    lifeTimer = new Date(),                    bestTime = 0,                    botIndex = 0,                    reviving = false,                    message = [],
                    x = null,                    A = 0,                    B = 0,                    G = [],                    t = [],                    L = {},                    z = [],                    ba = [],                    D = [],                    Y = 0,                    Z = 0,                    va = -1,                    wa = -1,                    Mc = 0,                    y = 0,                    ec = 0,                    N = null,                    ob = 0,                    pb = 0,                    qb = 1E4,                    rb = 1E4,                    r = 1,                    K = null,                    Va = !0,                    fa = !0,                    pa = !1,                    ub = !1,                    T = 0,                    ea = !1,                    Wa = !1,                    ib = A = ~~((ob + qb) / 2),                    jb = B = ~~((pb + rb) / 2),                    kb = 1,                    Ca = ,                    I = null,                    ab = !1,                    nb = !1,                    lb = 0,                    mb = 0,                    Ha = 0,                    Ia = 0,                    Qc = [#333333, #FF3333, #33FF33, #3333FF],                    Bb = !1,                    ma = !1,                    Da = 0,                    P = 1,                    C = 1,                    ja = !1,                    eb = 0,                    fc = !0,                    tb = null,                    sb = !1,                    J = new Image;                J.src = /img/background.png;                var gc = ontouchstart in c && AndroidwebOSiPhoneiPadiPodBlackBerryIEMobileOpera Minii.test(c.navigator.userAgent),                    Cb = new Image;                Cb.src = /img/split.png;                var ra = !1,                    sa = !1,                    ta = !1,                    Xa = !1,                    Hb, Ib;                gamepad in E && setInterval(function() {                    Xa && (Y = Ya.ha(Y, Hb), Z = Ya.ha(Z, Ib))                }, 25);                c.gamepadAxisUpdate = function(a, b) {                    var d = .1 > b  b;                    0 == a && (d ? Hb = q / 2 : (Hb = (b + 1) / 2  q, Xa = !0));                    1 == a && (d ? Ib = u / 2 : (Ib = (b + 1) / 2  u, Xa = !0))                };                c.agarioInit = function() {                    ab = !0;                    zc();                    yc();                    m.core.init();                    null != c.localStorage.settings && (w = JSON.parse(c.localStorage.settings), Wa = w.showMass, ea = w.blackTheme, fa = w.namesEnabled, pa = w.noColors, Ta = w.statsEnabled, Va = w.skinsEnabled);                    e(#showMass).prop(checked,                        w.showMass);                    e(#noSkins).prop(checked, !w.skinsEnabled);                    e(#skipStats).prop(checked, !w.statsEnabled);                    e(#noColors).prop(checked, w.noColors);                    e(#noNames).prop(checked, !w.namesEnabled);                    e(#darkTheme).prop(checked, w.blackTheme);                    Ob();                    setInterval(Ob, 18E4);                    O = Ab = document.getElementById(canvas);                    null != O && (f = O.getContext(2d), O.onmousedown = function(a) {                        if (gc) {                            var b = a.clientX - (5 + q / 5 / 2),                                d = a.clientY - (5 + q / 5 / 2);                            if (Math.sqrt(b  b + d  d) <= q / 5 / 2) {                                Za();                                return                            }                        }                        Y = 1  a.clientX;                        Z = 1  a.clientY;                        $a();                        Ka()                    }, O.onmousemove = function(a) {                        Xa = !1;                        Y = 1  a.clientX;                        Z = 1  a.clientY;                        $a()                    }, O.onmouseup = function() {}, firefoxi.test(navigator.userAgent) ? document.addEventListener(DOMMouseScroll, Nb, !1) : document.body.onmousewheel = Nb, c.onblur = function() {                        X(19);                        ta = sa = ra = !1                    }, c.onresize = $b, c.requestAnimationFrame(tc), setInterval(Ka, 40), K && e(#region).val(K), Qb(), za(e(#region).val()), 0 == eb && K && Q(), ua(0), $b(), c.location.hash && 6 <= c.location.hash.length && mc(c.location.hash))                };                var xa = null;                c.setNick = function(a) {                    UPDATE                    firstStart = false;                    originalName = a;                    if (getPlayer().length == 0) {                        lifeTimer = new Date();                    }
                    c.ga && c.ga(send, event, Nick, a.toLowerCase());                    Pb();                    N = a;                    Vb();                    T = 0;                    w.skinsEnabled = Va;                    w.namesEnabled = fa;                    w.noColors = pa;                    w.blackTheme = ea;                    w.showMass = Wa;                    w.statsEnabled = Ta;                    c.localStorage.settings = JSON.stringify(w);                    Lb()                };                c.setSkins = function(a) {                    Va = a                };                c.setNames = function(a) {                    fa = a                };                c.setDarkTheme = function(a) {                    ea = a                };                c.setColors = function(a) {                    pa = a                };                c.setShowMass = function(a) {                    Wa = a                };                c.spectate = function() {                    N = null;                    Lb();                    X(1);                    Pb()                };                c.setRegion = za;                var bb = !0;                c.setGameMode = function(a) {                    a != Ca && (:party == Ca && e(#helloContainer).attr(data-party-state, 0), ka(a), :party != a && Q())                };                c.setAcid = function(a) {                    Bb = a                };                var ad = function(a) {                    var b = {},                        d = !1,                        v = {                            skipDraw: !0,                            predictionModifier: 1.1                        };                    a.init = function() {                        m.account.init();                        m.google.xa();                        m.fa.init();                        (d = debug in c.queryString) && m.debug.showDebug()                    };                    a.bind = function(a, d) {                        e(b).bind(a, d)                    };                    a.unbind = function(a, d) {                        e(b).unbind(a, d)                    };                    a.trigger = function(a, d) {                        e(b).trigger(a, d)                    };                    a.__defineGetter__(debug, function() {                        return d                    });                    a.__defineSetter__(debug, function(a) {                        return d = a                    });                    a.__defineGetter__(proxy, function() {                        return c.MC                    });                    a.__defineGetter__(config, function() {                        return v                    });                    return a                }({});                m.core = ad;                m.cache = {};                var bd = function(a) {                    function b(a, b, d, c) {                        a = a + Canvas;                        var g = e(<canvas>, {                            id: a                        });                        p.append(g);                        d = new SmoothieChart(d);                        for (g = 0; g < b.length; g++) {                            var v = b[g],                                f = _.extend(h, c[g]);                            d.addTimeSeries(v, f)                        }                        d.streamTo(document.getElementById(a), 0)                    }
                    function d(a, d) {                        l[a] = c();                        b(a, [l[a]], d, [{                            strokeStyle: rgba(0, 255, 0, 1),                            fillStyle: rgba(0, 255, 0, 0.2),                            lineWidth: 2                        }])                    }
                    function c() {                        return new TimeSeries({                            Ma: !1                        })                    }                    var g = !1,                        p, f = !1,                        l = {},                        h = {                            strokeStyle: rgba(0, 255, 0, 1),                            fillStyle: rgba(0, 255, 0, 0.2),                            lineWidth: 2                        };                    a.showDebug = function() {                        g || (p = e(#debug-overlay), d(networkUpdate, {                            name: network updates,                            minValue: 0,                            maxValue: 120                        }), d(fps, {                            name: fps,                            minValue: 0,                            maxValue: 120                        }), l.rttSDev = c(), l.rttMean = c(), b(rttMean, [l.rttSDev, l.rttMean], {                            name: rtt,                            minValue: 0,                            maxValue: 120                        }, [{                            strokeStyle: rgba(255, 0, 0, 1),                            fillStyle: rgba(0, 255, 0, 0.2),                            lineWidth: 2                        }, {                            strokeStyle: rgba(0, 255, 0, 1),                            fillStyle: rgba(0, 255, 0, 0),                            lineWidth: 2                        }]), g = !0);                        m.core.debug = !0;                        p.show()                    };                    a.hideDebug = function() {                        p.hide();                        m.core.debug = !1                    };                    a.updateChart = function(a, b, d) {                        g && a in l && l[a].append(b, d)                    };                    a.__defineGetter__(showPrediction, function() {                        return f                    });                    a.__defineSetter__(showPrediction, function(a) {                        return f = a                    });                    return a                }({});                m.debug = bd;                var la = {                        AF: JP-Tokyo,                        AX: EU-London,                        AL: EU-London,                        DZ: EU-London,                        AS: SG-Singapore,                        AD: EU-London,                        AO: EU-London,                        AI: US-Atlanta,                        AG: US-Atlanta,                        AR: BR-Brazil,                        AM: JP-Tokyo,                        AW: US-Atlanta,                        AU: SG-Singapore,                        AT: EU-London,                        AZ: JP-Tokyo,                        BS: US-Atlanta,                        BH: JP-Tokyo,                        BD: JP-Tokyo,                        BB: US-Atlanta,                        BY: EU-London,                        BE: EU-London,                        BZ: US-Atlanta,                        BJ: EU-London,                        BM: US-Atlanta,                        BT: JP-Tokyo,                        BO: BR-Brazil,                        BQ: US-Atlanta,                        BA: EU-London,                        BW: EU-London,                        BR: BR-Brazil,                        IO: JP-Tokyo,                        VG: US-Atlanta,                        BN: JP-Tokyo,                        BG: EU-London,                        BF: EU-London,                        BI: EU-London,                        KH: JP-Tokyo,                        CM: EU-London,                        CA: US-Atlanta,                        CV: EU-London,                        KY: US-Atlanta,                        CF: EU-London,                        TD: EU-London,                        CL: BR-Brazil,                        CN: CN-China,                        CX: JP-Tokyo,                        CC: JP-Tokyo,                        CO: BR-Brazil,                        KM: EU-London,                        CD: EU-London,                        CG: EU-London,                        CK: SG-Singapore,                        CR: US-Atlanta,                        CI: EU-London,                        HR: EU-London,                        CU: US-Atlanta,                        CW: US-Atlanta,                        CY: JP-Tokyo,                        CZ: EU-London,                        DK: EU-London,                        DJ: EU-London,                        DM: US-Atlanta,                        DO: US-Atlanta,                        EC: BR-Brazil,                        EG: EU-London,                        SV: US-Atlanta,                        GQ: EU-London,                        ER: EU-London,                        EE: EU-London,                        ET: EU-London,                        FO: EU-London,                        FK: BR-Brazil,                        FJ: SG-Singapore,                        FI: EU-London,                        FR: EU-London,                        GF: BR-Brazil,                        PF: SG-Singapore,                        GA: EU-London,                        GM: EU-London,                        GE: JP-Tokyo,                        DE: EU-London,                        GH: EU-London,                        GI: EU-London,                        GR: EU-London,                        GL: US-Atlanta,                        GD: US-Atlanta,                        GP: US-Atlanta,                        GU: SG-Singapore,                        GT: US-Atlanta,                        GG: EU-London,                        GN: EU-London,                        GW: EU-London,                        GY: BR-Brazil,                        HT: US-Atlanta,                        VA: EU-London,                        HN: US-Atlanta,                        HK: JP-Tokyo,                        HU: EU-London,                        IS: EU-London,                        IN: JP-Tokyo,                        ID: JP-Tokyo,                        IR: JP-Tokyo,                        IQ: JP-Tokyo,                        IE: EU-London,                        IM: EU-London,                        IL: JP-Tokyo,                        IT: EU-London,                        JM: US-Atlanta,                        JP: JP-Tokyo,                        JE: EU-London,                        JO: JP-Tokyo,                        KZ: JP-Tokyo,                        KE: EU-London,                        KI: SG-Singapore,                        KP: JP-Tokyo,                        KR: JP-Tokyo,                        KW: JP-Tokyo,                        KG: JP-Tokyo,                        LA: JP-Tokyo,                        LV: EU-London,                        LB: JP-Tokyo,                        LS: EU-London,                        LR: EU-London,                        LY: EU-London,                        LI: EU-London,                        LT: EU-London,                        LU: EU-London,                        MO: JP-Tokyo,                        MK: EU-London,                        MG: EU-London,                        MW: EU-London,                        MY: JP-Tokyo,                        MV: JP-Tokyo,                        ML: EU-London,                        MT: EU-London,                        MH: SG-Singapore,                        MQ: US-Atlanta,                        MR: EU-London,                        MU: EU-London,                        YT: EU-London,                        MX: US-Atlanta,                        FM: SG-Singapore,                        MD: EU-London,                        MC: EU-London,                        MN: JP-Tokyo,                        ME: EU-London,                        MS: US-Atlanta,                        MA: EU-London,                        MZ: EU-London,                        MM: JP-Tokyo,                        NA: EU-London,                        NR: SG-Singapore,                        NP: JP-Tokyo,                        NL: EU-London,                        NC: SG-Singapore,                        NZ: SG-Singapore,                        NI: US-Atlanta,                        NE: EU-London,                        NG: EU-London,                        NU: SG-Singapore,                        NF: SG-Singapore,                        MP: SG-Singapore,                        NO: EU-London,                        OM: JP-Tokyo,                        PK: JP-Tokyo,                        PW: SG-Singapore,                        PS: JP-Tokyo,                        PA: US-Atlanta,                        PG: SG-Singapore,                        PY: BR-Brazil,                        PE: BR-Brazil,                        PH: JP-Tokyo,                        PN: SG-Singapore,                        PL: EU-London,                        PT: EU-London,                        PR: US-Atlanta,                        QA: JP-Tokyo,                        RE: EU-London,                        RO: EU-London,                        RU: RU-Russia,                        RW: EU-London,                        BL: US-Atlanta,                        SH: EU-London,                        KN: US-Atlanta,                        LC: US-Atlanta,                        MF: US-Atlanta,                        PM: US-Atlanta,                        VC: US-Atlanta,                        WS: SG-Singapore,                        SM: EU-London,                        ST: EU-London,                        SA: EU-London,                        SN: EU-London,                        RS: EU-London,                        SC: EU-London,                        SL: EU-London,                        SG: JP-Tokyo,                        SX: US-Atlanta,                        SK: EU-London,                        SI: EU-London,                        SB: SG-Singapore,                        SO: EU-London,                        ZA: EU-London,                        SS: EU-London,                        ES: EU-London,                        LK: JP-Tokyo,                        SD: EU-London,                        SR: BR-Brazil,                        SJ: EU-London,                        SZ: EU-London,                        SE: EU-London,                        CH: EU-London,                        SY: EU-London,                        TW: JP-Tokyo,                        TJ: JP-Tokyo,                        TZ: EU-London,                        TH: JP-Tokyo,                        TL: JP-Tokyo,                        TG: EU-London,                        TK: SG-Singapore,                        TO: SG-Singapore,                        TT: US-Atlanta,                        TN: EU-London,                        TR: TK-Turkey,                        TM: JP-Tokyo,                        TC: US-Atlanta,                        TV: SG-Singapore,                        UG: EU-London,                        UA: EU-London,                        AE: EU-London,                        GB: EU-London,                        US: US-Atlanta,                        UM: SG-Singapore,                        VI: US-Atlanta,                        UY: BR-Brazil,                        UZ: JP-Tokyo,                        VU: SG-Singapore,                        VE: BR-Brazil,                        VN: JP-Tokyo,                        WF: SG-Singapore,                        EH: EU-London,                        YE: JP-Tokyo,                        ZM: EU-London,                        ZW: EU-London                    },                    na = 0,                    Ea = 0,                    S = null,                    Ba = !1,                    Xb;                c.connect = fb;                var Fa = 500,                    Ec = .875,                    Gc = .75,                    Hc = .25,                    Fc = .125,                    Yb = -1,                    Zb = -1;                c.sendMitosis = Za;                c.sendEject = Mb;                m.networking = function(a) {                    a.loginRealm = {                        GG: google,                        FB: facebook                    };                    a.sendMessage = function(a) {                        if (da()) {                            var d = a.byteView;                            if (null != d) {                                a = U(1 + a.length);                                a.setUint8(0, 102);                                for (var c = 0; c < d.length; ++c) a.setUint8(1 + c, d[c]);                                V(a)                            }                        }                    };                    return a                }({});                var H = null,                    Ma = null,                    h = m.renderSettings = {                        high: {                            warnFps: 30,                            simpleDraw: !1,                            maxDetail: 1,                            minDetail: .6,                            U: 30                        },                        medium: {                            warnFps: 30,                            simpleDraw: !1,                            maxDetail: .5,                            minDetail: .3,                            U: 25                        },                        low: {                            warnFps: 30,                            simpleDraw: !0,                            maxDetail: .3,                            minDetail: .2,                            U: 25                        },                        upgrade: function() {                            h.selected == h.low ? (h.selected = h.medium, h.detail = h.medium.maxDetail) : h.selected == h.medium && (h.selected = h.high, h.detail = h.high.maxDetail)                        },                        downgrade: function() {                            h.selected == h.high ? h.selected = h.medium : h.selected == h.medium && (h.selected = h.low)                        }                    };                h.selected = h.high;                h.detail = 1;                h.auto = !1;                UPDATE                                 * Tells you if the game is in Dark mode.                 *  Boolean for dark mode.                 */                window.getDarkBool = function() {                    return ea;                }
                                 * Tells you if the mass is shown.                 *  Boolean for player's mass.                 */                window.getMassBool = function() {                    return Wa;                }
                                 * This is a copy of everything that is shown on screen.                 * Normally stuff will time out when off the screen, this                 * memorizes everything that leaves the screen for a little                 * while longer.                 *  The memory object.                 */                window.getMemoryCells = function() {                    return interNodes;                }
                                 * [getCellsArray description]                 *   [description]                 */                window.getCellsArray = function() {                    return z;                }
                                 * [getCellsArray description]                 *   [description]                 */                window.getCells = function() {                    return L;                }
                                 * Returns an array with all the player's cells.                 *  Player's cells                 */                window.getPlayer = function() {                    return t;                }
                                 * The canvas' width.                 *  Integer Width                 */                window.getWidth = function() {                    return q;                }
                                 * The canvas' height                 *  Integer Height                 */                window.getHeight = function() {                    return u;                }
                                 * Scaling ratio of the canvas. The bigger this ratio,                 * the further that you see.                 *  Screen scaling ratio.                 */                window.getRatio = function() {                    return r;                }
                window.getZoomlessRatio = function() {                    return r2;                }
                                 * [getOffsetX description]                 *   [description]                 */                window.getOffsetX = function() {                    return ib;                }
                window.getOffsetY = function() {                    return jb;                }
                window.getX = function() {                    return A;                }
                window.getY = function() {                    return B;                }
                window.getPointX = function() {                    return va;                }
                window.getPointY = function() {                    return wa;                }
                                 * The X location of the mouse.                 *  Integer X                 */                window.getMouseX = function() {                    return Y;                }
                                 * The Y location of the mouse.                 *  Integer Y                 */                window.getMouseY = function() {                    return Z;                }
                window.getMapStartX = function() {                    return ob;                }
                window.getMapStartY = function() {                    return pb;                }
                window.getMapEndX = function() {                    return qb;                }
                window.getMapEndY = function() {                    return rb;                }
                window.getScreenDistance = function() {                    var temp = screenDistance();                    return temp;                }
                                 * A timestamp since the last time the server sent any data.                 *  Last update timestamp                 */                window.getLastUpdate = function() {                    return y;                }
                window.getCurrentScore = function() {                    return T;                }
                                 * The game's current mode. ("":ffa"", "":experimental"", "":teams"". "":party"")                 *   [description]                 */                window.getMode = function() {                    return Ca;                }
                window.getServer = function() {                    return serverIP;                }
                window.setPoint = function(x, y) {                    va = x;                    wa = y;                }
                window.setScore = function(a) {                    sessionScore = a  100;                }
                window.setBestTime = function(a) {                    bestTime = a;                }
                window.best = function(a, b) {                    setScore(a);                    setBestTime(b);                }
                window.setBotIndex = function(a) {                    window.log(Changing bot);                    botIndex = a;                    setLauncherCustomParameters(window.botList[a]);                }
                window.setLauncherCustomParameterOnChange = function(a, b, c) {                    a.on(change input, function() {                        var val = window.jQuery(this).val();                        c.value = val;                        b.text(val);                    });                }
                window.setLauncherCustomParameters = function(a) {                    window.jQuery(#launcher-custom-params).remove();                    window.jQuery(#launcher-wrapper).append(window.jQuery(<div id=""launcher-custom-params"">));
                     If no custom parameters are defined, abort                    if (a.customParameters === undefined) {                        return;                    }
                    for (var param in a.customParameters) {                        var form = window.jQuery(<div class=""form-group"">);                        var label = window.jQuery(<label>);                        var value = window.jQuery(<span style=""float: right; display: none;"">);                        var input = window.jQuery(<input class=""form-control"">);
                        if (a.customParameters[param].label !== undefined) {                            label.text(a.customParameters[param].label);                        } else {                            label.text(param);                        }
                        for (var paramKey in a.customParameters[param]) {                            if (paramKey == label) {                                continue;                            }
                            if (paramKey == value) {                                value.text(a.customParameters[param][paramKey]);                            } else if (paramKey == type && a.customParameters[param][paramKey] == range) {                                input.removeClass(form-control);                                value.show();                            }
                            input.attr(paramKey, a.customParameters[param][paramKey]);                        }
                        setLauncherCustomParameterOnChange(input, value, a.customParameters[param]);
                        form.append(label);                        form.append(value);                        form.append(input);                        form.appendTo(window.jQuery(#launcher-custom-params));                    }                }
                window.setLauncherBotList = function() {                    window.jQuery(#launcher-bot-list).remove();                    window.jQuery(#launcher-wrapper).append(window.jQuery(<div id=""launcher-bot-list"" class=""form-group"">));                    var select = window.jQuery(<select id=""bList"" class=""form-control"" onchange=""setBotIndex(window.jQuery(this).val());"" />);
                    for (var i = 0; i < window.botList.length; i++) {                        if (window.botList[i].name == Human && window.botList.length > 1) {                            if (botIndex == i) {                                botIndex = (botIndex + 1).mod(window.botList.length);                            }                            continue;                        }
                        window.jQuery(<option />, {                            value: i,                            text: window.botList[i].name                        }).appendTo(select);                    }
                    select.appendTo(window.jQuery(#launcher-bot-list));                }
                window.setMessage = function(a) {                    message = a;                }
                window.shoot = function() {                    if (!toggle && shootTime + shootCooldown < new Date().getTime()) {                        shootTime = new Date().getTime();                        opCode(21);                    }                }
                window.split = function() {
                    if (!toggle && splitTime + splitCooldown < new Date().getTime()) {                        splitTime = new Date().getTime();                        opCode(17);                    }                }
                window.updateBotList = function() {                    window.botList = window.botList || [];
                     Create wrapper for launcher controls                    window.jQuery(#launcher-wrapper).remove();                    window.jQuery(<div id=""launcher-wrapper"">).insertBefore(#agario-main-buttons);
                    setLauncherBotList();
                     Show initial custom parameters                    setLauncherCustomParameters(window.botList[window.jQuery(#bList).val()]);                }
                var Jb = 0,                    Pa = 0,                    Oa = 0,                    tc = function() {                        var a = Date.now(),                            b = 1E3 / 60;                        return function() {                            c.requestAnimationFrame(tc);                            var d = Date.now(),                                e = d - a;                            if (e > b) {                                a = d - e % b;                                var g = Date.now();                                !da() || 240 > g - Da || !m.core.config.skipDraw ? ac() : window.log(Skipping draw);                                cd();                                Jb = 1E3 / e;                                m.debug.updateChart(fps, d, Jb);                                Jb < h.selected.warnFps ? 0 == Oa && (Pa++, Pa > 2  h.selected.warnFps && (h.selected.ma = !0)) : Pa = 0                            }                        }                    }();                c.setQuality = Kc;                var ha = {},                    Rb = ""poland;usa;china;russia;canada;australia;spain;brazil;germany;ukraine;france;sweden;chaplin;north korea;south korea;japan;united kingdom;earth;greece;latvia;lithuania;estonia;finland;norway;cia;maldivas;austria;nigeria;reddit;yaranaika;confederate;9gag;indiana;4chan;italy;bulgaria;tumblr;2ch.hk;hong kong;portugal;jamaica;german empire;mexico;sanik;switzerland;croatia;chile;indonesia;bangladesh;thailand;iran;iraq;peru;moon;botswana;bosnia;netherlands;european union;taiwan;pakistan;hungary;satanist;qing dynasty;matriarchy;patriarchy;feminism;ireland;texas;facepunch;prodota;cambodia;steam;piccolo;ea;india;kc;denmark;quebec;ayy lmao;sealand;bait;tsarist russia;origin;vinesauce;stalin;belgium;luxembourg;stussy;prussia;8ch;argentina;scotland;sir;romania;wojak;doge;nasa;byzantium;imperial japan;french kingdom;somalia;turkey;mars;pokerface;8;irs;receita federal;facebook;putin;merkel;tsipras;obama;kim jong-un;dilma;hollande;berlusconi;cameron;clinton;hillary;venezuela;blatter;chavez;cuba;fidel;merkel;palin;queen;boris;bush;trump;underwood"".split("";""),                    dd = 8;nasa;putin;merkel;tsipras;obama;kim jong-un;dilma;hollande;berlusconi;cameron;clinton;hillary;blatter;chavez;fidel;merkel;palin;queen;boris;bush;trump;underwood.split(;),                    oa = {};                Db.prototype = {                    $: null,                    x: 0,                    y: 0,                    f: 0,                    b: 0                };                var La = -1,                    cc = !1;                ca.prototype = {                    id: 0,                    a: null,                    name: null,                    i: null,                    R: null,                    x: 0,                    y: 0,                    size: 0,                    s: 0,                    u: 0,                    o: 0,                    ja: 0,                    ka: 0,                    g: 0,                    L: 0,                    M: 0,                    J: 0,                    K: 0,                    ea: 0,                    T: 0,                    ta: 0,                    G: !1,                    c: !1,                    h: !1,                    V: !0,                    da: 0,                    UPDATE                    updateCode: 0,                    danger: false,                    dangerTimeOut: 0,                    isNotMoving: function() {                        return (this.x == this.s && this.y == this.u);                    },                    isVirus: function() {                        return this.c;                    },                    getUptimeTime: function() {                        return this.T;                    },
                    C: null,                    ia: 0,                    wa: !1,                    I: !1,                    ca: function() {                        var a;                        for (a = 0; a < z.length; a++)                            if (z[a] == this) {                                z.splice(a, 1);                                break                            }                        delete L[this.id];                        a = t.indexOf(this); - 1 != a && (ub = !0, t.splice(a, 1));                        a = G.indexOf(this.id); - 1 != a && G.splice(a, 1);                        this.G = !0;                        0 < this.da && ba.push(this)                    },                    m: function() {                        return Math.max(~~(.3  this.size), 24)                    },                    A: function(a) {                        if (this.name = a) null == this.i ? this.i = new Na(this.m(), #FFFFFF, !0, #000000) : this.i.O(this.m()), this.i.B(this.name)                    },                    ba: function() {                        for (var a = this.H(); this.a.length > a;) {                            var b = ~~(Math.random()  this.a.length);                            this.a.splice(b, 1)                        }                        for (0 == this.a.length && 0 < a && this.a.push(new Db(this, this.x, this.y, this.size, Math.random() - .5)); this.a.length < a;) b = ~~(Math.random()  this.a.length), b = this.a[b], this.a.push(new Db(this, b.x, b.y, b.f, b.b))                    },                    H: function() {                        var a = 10;                        20 > this.size && (a = 0);                        this.c && (a = m.renderSettings.selected.U);                        var b = this.size;                        this.c || (b  r);                        b  h.detail;                        return ~~Math.max(b, a)                    },                    Da: function() {                        this.ba();                        for (var a = this.a, b = a.length, d = this, c = this.c ? 0 : (this.id / 1E3 + y / 1E4) % (2  Math.PI), e = 0, p = 0; p < b; ++p) {                            var f = a[(p - 1 + b) % b].b,                                l = a[(p + 1) % b].b,                                h = a[p];                            h.b += (Math.random() - .5)  (this.h ? 3 : 1);                            h.b  .7;                            10 < h.b && (h.b = 10); - 10 > h.b && (h.b = -10);                            h.b = (f + l + 8  h.b) / 10;                            var n = h.f,                                f = a[(p - 1 + b) % b].f,                                l = a[(p + 1) % b].f;                            if (15 < this.size && null != ia && 20 < this.size  r && 0 < this.id) {                                var k = !1,                                    m = h.x,                                    q = h.y;                                ia.Ga(m - 5, q - 5, 10, 10, function(a) {                                    a.$ != d && 25 > (m - a.x)  (m - a.x) + (q - a.y)  (q - a.y) && (k = !0)                                });                                !k && (h.x < ob || h.y < pb || h.x > qb || h.y > rb) && (k = !0);                                k && (0 < h.b && (h.b = 0), --h.b)                            }                            n += h.b;                            0 > n && (n = 0);                            n = this.h ? (19  n + this.size) / 20 : (12  n + this.size) / 13;                            h.f = (f + l + 8  n) / 10;                            f = 2  Math.PI / b;                            l = h.f;                            this.c && 0 == p % 2 && (l += 5);                            h.x = this.x + Math.cos(f  p + c)  l;                            h.y = this.y + Math.sin(f  p + c)  l;                            e = Math.max(e, l)                        }                        this.ia =                            e                    },                    pa: function(a, b) {                        this.L = a;                        this.M = b;                        this.J = a;                        this.K = b;                        this.ja = a;                        this.ka = b                    },                    S: function() {                        if (0 >= this.id) return 1;                        var a = Ya.ra((y - this.T) / 120, 0, 1);                        if (this.G && 1 <= a) {                            var b = ba.indexOf(this); - 1 != b && ba.splice(b, 1)                        }                        this.x = a  (this.ja - this.s) + this.s;                        this.y = a  (this.ka - this.u) + this.u;                        this.size = a  (this.g - this.o) + this.o;                        .01 > Math.abs(this.size - this.g) && (this.size = this.g);                        return a                    },                    P: function() {                        return 0 >= this.id ? !0 : this.x + this.size + 40 < A - q / 2 / r || this.y + this.size + 40 < B - u / 2 / r || this.x - this.size - 40 > A + q / 2 / r || this.y - this.size -                            40 > B + u / 2 / r ? !1 : !0                    },                    sa: function(a) {                        a.beginPath();                        var b = this.H();                        a.moveTo(this.a[0].x, this.a[0].y);                        for (var d = 1; d <= b; ++d) {                            var c = d % b;                            a.lineTo(this.a[c].x, this.a[c].y)                        }                        a.closePath();                        a.stroke()                    },                    w: function(a) {                        if (this.P()) {                            ++this.da;                            var b = 0 < this.id && !this.c && !this.h && .4 > r || h.selected.simpleDraw && !this.c;                            5 > this.H() && 0 < this.id && (b = !0);                            if (this.V && !b)                                for (var d = 0; d < this.a.length; d++) this.a[d].f = this.size;                            this.V = b;                            a.save();                            this.ta = y;                            d = this.S();                            this.G && (a.globalAlpha  1 - d);                            a.lineWidth = 10;                            a.lineCap = round;                            a.lineJoin = this.c ? miter : round;                            var e = this.name.toLowerCase(),                                g = null,                                p = null,                                d = !1,                                f = this.color,                                l = !1;                            this.h || !Va || sb || (-1 != Rb.indexOf(e) ? (ha.hasOwnProperty(e) || (ha[e] = new Image, ha[e].src = c.ASSETS_ROOT + skins/ + e + .png), g = 0 != ha[e].width && ha[e].complete ? ha[e] : null) : g = null, null != g ? -1 != dd.indexOf(e) && (d = !0) : (this.I && %starball == this.C && shenron == e && 7 <= t.length && (cc = d = !0, p = hc(%starball1)), g = hc(this.C), null != g && (l = !0, f = Rc(this.C) || f)));                            m.core.debug && m.debug.showPrediction && this.I && (a.strokeStyle = #0000FF, a.beginPath(), a.arc(this.L, this.M, this.size + 5, 0, 2  Math.PI, !1), a.closePath(), a.stroke(), a.strokeStyle = #00FF00, a.beginPath(), a.arc(this.J, this.K, this.size + 5, 0, 2  Math.PI, !1), a.closePath(), a.stroke());                            pa && !sb ? (a.fillStyle = #FFFFFF, a.strokeStyle = #AAAAAA) : (a.fillStyle = f, a.strokeStyle = f);                            b ? (a.beginPath(), a.arc(this.x, this.y, this.size + 5, 0, 2  Math.PI, !1), a.closePath()) : (this.Da(), this.sa(a));                            l || a.fill();                            null != g && (this.na(a, g), null != p && this.na(a, p, {                                alpha: Math.sin(.0174  La)                            }));                            (pa || 20 < this.size) && !b && (a.strokeStyle = #000000, a.globalAlpha  .1, a.stroke());                            a.globalAlpha = 1;                            e = -1 != t.indexOf(this);                            b = ~~this.y;                            0 != this.id && (fa || e) && this.name && this.i && !d && (g = this.i, g.B(this.name), g.O(this.m()), d = 0 >= this.id ? 1 : Math.ceil(10  r) / 10, g.oa(d), g = g.N(), p = Math.ceil(g.width / d), f = Math.ceil(g.height / d), a.drawImage(g, ~~this.x - ~~(p / 2), b - ~~(f / 2), p, f), b += g.height / 2 / d + 4);                            0 < this.id && Wa && (e || 0 == t.length && (!this.c || this.h) && 20 < this.size) && (null == this.R && (this.R = new Na(this.m() / 2, #FFFFFF, !0, #000000)), e = this.R, e.O(this.m() / 2), e.B(~~(this.size  this.size /                                100)), d = Math.ceil(10  r) / 10, e.oa(d), g = e.N(), p = Math.ceil(g.width / d), f = Math.ceil(g.height / d), a.drawImage(g, ~~this.x - ~~(p / 2), b - ~~(f / 2), p, f));                            a.restore()                        }                    },                    na: function(a, b, d) {                        a.save();                        a.clip();                        var c = Math.max(this.size, this.ia);                        null != d && null != d.alpha && (a.globalAlpha = d.alpha);                        a.drawImage(b, this.x - c - 5, this.y - c - 5, 2  c + 10, 2  c + 10);                        a.restore()                    }                };                var Ya = function(a) {                    function b(a, b, c) {                        return a < b ? b : a > c ? c : a                    }                    a.ha = function(a, c) {                        var e;                        e = b(.5, 0, 1);                        return a + e  (c - a)                    };                    a.ra = b;                    a.fixed = function(a, b) {                        var c = Math.pow(10, b);                        return ~~(a                             c) / c                    };                    return a                }({});                c.Maths = Ya;                var hb = function(a) {                    a.la = function() {                        for (var a = new Date, d = [a.getMonth() + 1, a.getDate(), a.getFullYear()], a = [a.getHours(), a.getMinutes(), a.getSeconds()], c = 1; 3 > c; c++) 10 > a[c] && (a[c] = 0 + a[c]);                        return [ + d.join(/) +   + a.join(:) + ]                    };                    return a                }({});                c.Utils = hb;                Na.prototype = {                    F: ,                    W: #000000,                    Y: !1,                    Z: #000000,                    v: 16,                    j: null,                    X: null,                    l: !1,                    D: 1,                    O: function(a) {                        this.v != a && (this.v = a, this.l = !0)                    },                    oa: function(a) {                        this.D != a && (this.D = a, this.l = !0)                    },                    B: function(a) {                        a != this.F && (this.F = a, this.l = !0)                    },                    N: function() {                        null == this.j && (this.j = document.createElement(canvas), this.X = this.j.getContext(2d));                        if (this.l) {                            this.l = !1;                            var a = this.j,                                b = this.X,                                c = this.F,                                e = this.D,                                g = this.v,                                f = g + px Ubuntu;                            b.font = f;                            var h = ~~(.2  g);                            a.width = (b.measureText(c).width + 6)  e;                            a.height = (g + h)  e;                            b.font = f;                            b.scale(e, e);                            b.globalAlpha = 1;                            b.lineWidth = 3;                            b.strokeStyle = this.Z;                            b.fillStyle = this.W;                            this.Y && b.strokeText(c, 3, g - h / 2);                            b.fillText(c, 3, g - h / 2)                        }                        return this.j                    }                };                Date.now || (Date.now = function() {                    return (new Date).getTime()                });                (function() {                    for (var a = [ms, moz, webkit, o], b = 0; b < a.length && !c.requestAnimationFrame; ++b) c.requestAnimationFrame = c[a[b] + RequestAnimationFrame], c.cancelAnimationFrame = c[a[b] + CancelAnimationFrame] || c[a[b] + CancelRequestAnimationFrame];                    c.requestAnimationFrame || (c.requestAnimationFrame = function(a) {                        return setTimeout(a, 1E3 / 60)                    }, c.cancelAnimationFrame = function(a) {                        clearTimeout(a)                    })                })();                var xc = {                        init: function(a) {                            function b(a) {                                a < e && (a = e);                                a > f && (a = f);                                return ~~((a - e) / 32)                            }
                            function c(a) {                                a < g && (a = g);                                a > h && (a = h);                                return ~~((a - g) / 32)                            }                            var e = a.Ba,                                g = a.Ca,                                f = a.za,                                h = a.Aa,                                l = ~~((f - e) / 32) + 1,                                k = ~~((h - g) / 32) + 1,                                n = Array(l  k);                            return {                                va: function(a) {                                    var e = b(a.x) + c(a.y)  l;                                    null == n[e] ? n[e] = a : Array.isArray(n[e]) ? n[e].push(a) : n[e] = [n[e], a]                                },                                Ga: function(a, e, g, f, h) {                                    var p = b(a),                                        v = c(e);                                    a = b(a + g);                                    e = c(e + f);                                    if (0 > p || p >= l || 0 > v || v >= k) debugger;                                    for (; v <= e; ++v)                                        for (f = p; f <= a; ++f)                                            if (g = n[f + v  l], null != g)                                                if (Array.isArray(g))                                                    for (var m = 0; m < g.length; m++) h(g[m]);                                                else h(g)                                }                            }                        }                    },                    Wb = function() {                        var a = new ca(0, 0, 0, 32, #ED1C24, ),                            b = document.createElement(canvas);                        b.width = 32;                        b.height =                            32;                        var c = b.getContext(2d);                        return function() {                            0 < t.length && (a.color = t[0].color, a.A(t[0].name));                            c.clearRect(0, 0, 32, 32);                            c.save();                            c.translate(16, 16);                            c.scale(.4, .4);                            a.w(c);                            c.restore();                            var e = document.getElementById(favicon),                                g = e.cloneNode(!0);                            g.setAttribute(href, b.toDataURL(image/png));                            UPDATE -- ?????                            e.setAttribute(""href"", b.toDataURL(""image/png""));                            e.parentNode.replaceChild(g, e)                        }                    }();                e(function() {                    Wb()                });                var Qa = {                        context: null,                        defaultProvider: facebook,                        loginIntent: 0,                        userInfo: {                            socialToken: null,                            tokenExpires: ,                            level: ,                            xp: ,                            xpNeeded: ,                            name: ,                            picture: ,                            displayName: ,                            loggedIn: 0,                            socialId:                         }                    },                    k = c.defaultSt = Qa;                c.storageInfo = k;                c.createDefaultStorage = Tc;                c.updateStorage = Ra;                e(function() {                    null != c.localStorage.storeObjectInfo && (k = JSON.parse(c.localStorage.storeObjectInfo));                    1 == k.loginIntent && ic(k.context);                     == k.userInfo.name &&  == k.userInfo.displayName || jc(k.userInfo)                });                c.checkLoginStatus = function() {                    1 == k.loginIntent && (Sa(), ic(k.context))                };                var Sa = function() {                    c.MC.setProfilePicture(k.userInfo.picture);                    c.MC.setSocialId(k.userInfo.socialId)                };                c.logout = function() {                    k = Qa;                    delete c.localStorage.storeObjectInfo;                    c.localStorage.storeObjectInfo = JSON.stringify(Qa);                    Ra();                    uc();                    m.cache.sentGameServerLogin = !1;                    delete m.cache.login_info;                    e(#helloContainer).attr(data-logged-in, 0);                    e(#helloContainer).attr(data-has-account-data, 0);                    e(.timer).text();                    e(#gPlusShare).hide();                    e(#fbShare).show();                    e(#user-id-tag).text();                    Q();                    c.MC.doLogout()                };                c.toggleSocialLogin = function() {                    e(#socialLoginContainer).toggle();                    e(#settings).hide();                    e(#instructions).hide();                    Eb()                };                c.toggleSettings = function() {                    e(#settings).toggle();                    e(#socialLoginContainer).hide();                    e(#instructions).hide();                    Eb()                };                m.account = function(a) {                    function b() {}
                    function d(a, b) {                        if (null == f || f.id != b.id) f = b, null != c.ssa_json && (c.ssa_json.applicationUserId =  + b.id, c.ssa_json.custom_user_id =  + b.id), undefined != typeof SSA_CORE && SSA_CORE.start()                    }                    var f = null;                    a.init = function() {                        m.core.bind(user_login, d);                        m.core.bind(user_logout, b)                    };                    a.setUserData = function(a) {                        jc(a)                    };                    a.setAccountData = function(a, b) {                        var c = e(#helloContainer).attr(data-has-account-data, 1);                        k.userInfo.xp = a.xp;                        k.userInfo.xpNeeded = a.xpNeeded;                        k.userInfo.level = a.level;                        Ra();                        c && b ? ga(a) : (e(.agario-profile-panel .progress-bar-star).text(a.level), e(.agario-exp-bar .progress-bar-text).text(a.xp + / + a.xpNeeded +  XP), e(.agario-exp-bar .progress-bar).css(width, (88  a.xp / a.xpNeeded).toFixed(2) + %))                    };                    a.Ia = function(a) {                        ga(a)                    };                    return a                }({});                var lc = 0;                c.fbAsyncInit = function() {                    function a() {                        null == c.FB ? alert(You seem to have something blocking Facebook on your browser, please check for any extensions) : (k.loginIntent = 1, c.updateStorage(), c.FB.login(function(a) {                            kc(a)                        }, {                            scope: public_profile, email                        }))                    }                    c.FB.init({                        appId: EnvConfig.fb_app_id,                        cookie: !0,                        xfbml: !0,                        status: !0,                        version: v2.2                    });                    (1 == c.storageInfo.loginIntent && facebook == c.storageInfo.context || qc) && c.FB.getLoginStatus(function(b) {                        connected === b.status ? kc(b) : not_authorized === b.status ? (c.logout(), a()) : c.logout()                    });                    c.facebookRelogin = a;                    c.facebookLogin = a                };                var Kb = !1;                (function(a) {                    function b() {                        var a = document.createElement(script);                        a.type = text/javascript;                        a.async = !0;                        a.src = ;                        var b = document.getElementsByTagName(script)[0];                        b.parentNode.insertBefore(a, b);                        f = !0                    }                    var d = {},                        f = !1;                    c.gapiAsyncInit = function() {                        e(d).trigger(initialized)                    };                    a.google = {                        xa: function() {                            b()                        },                        ua: function(a, b) {                            c.gapi.client.load(plus, v1, function() {                                window.log(fetching me profile);                                gapi.client.plus.people.get({                                    userId: me                                }).execute(function(a) {                                    b(a)                                })                            })                        }                    };                    a.Fa = function(a) {                        f || b();                        undefined !== typeof gapi ? a() : e(d).bind(initialized, a)                    };                    return a                })(m);                var ed = function(a) {                    function b(a) {                        c.MC.doLoginWithGPlus(a);                        m.cache.login_info = [a, google]                    }
                    function d(a) {                        k.userInfo.picture = a;                        e(.agario-profile-picture).attr(src, a)                    }                    var f = null,                        g = {                            client_id: EnvConfig.gplus_client_id,                            cookie_policy: single_host_origin,                            scope: profile email                        };                    a.fa = {                        qa: function() {                            return f                        },                        init: function() {                            var a = this,                                b = k && 1 == k.loginIntent && google == k.context;                            m.Fa(function() {                                c.gapi.ytsubscribe.go(agarYoutube);                                c.gapi.load(auth2, function() {                                    f = c.gapi.auth2.init(g);                                    f.attachClickHandler(document.getElementById(gplusLogin), {}, function(a) {                                        window.log(googleUser :  + a)                                    }, function(a) {                                        window.log(failed to login in google plus: , JSON.stringify(a, void 0, 2))                                    });                                    f.currentUser.listen(_.bind(a.Ea, a));                                    b && 1 == f.isSignedIn.get() && f.signIn()                                })                            })                        },                        Ea: function(a) {                            if (f && a && f.isSignedIn.get() && !Kb) {                                Kb = !0;                                k.loginIntent = 1;                                var e = a.getAuthResponse(),                                    g = e.access_token;                                c.qa = e;                                window.log(loggedIn with G+!);                                var h = a.getBasicProfile();                                a = h.getImageUrl();                                void 0 == a ? m.google.ua(e, function(a) {                                    a.result.isPlusUser ? (a && d(a.image.url), b(g), a && (k.userInfo.picture = a.image.url), k.userInfo.socialId = h.getId(), Sa()) : (alert(Please add Google+ to your Google account and try again.Or you can login with another account.), c.logout())                                }) : (d(a), k.userInfo.picture = a, k.userInfo.socialId = h.getId(), Sa(), b(g));                                k.context = google;                                c.updateStorage()                            }                        },                        ya: function() {                            f && (f.signOut(), Kb = !1)                        }                    };                    return a                }(m);                c.gplusModule = ed;                var uc = function() {                    m.fa.ya()                };                c.logoutGooglePlus = uc;                var cd = function() {                    function a(a, b, c, d, e) {                        var f = b.getContext(2d),                            g = b.width;                        b = b.height;                        a.color = e;                        a.A(c);                        a.size = d;                        f.save();                        f.translate(g / 2, b / 2);                        a.w(f);                        f.restore()                    }                    for (var b = new ca(-1, 0, 0, 32, #5bc0de, ), c = new ca(-1, 0, 0, 32, #5bc0de, ), f = #0791ff #5a07ff #ff07fe #ffa507 #ff0774 #077fff #3aff07 #ff07ed #07a8ff #ff076e #3fff07 #ff0734 #07ff20 #ff07a2 #ff8207 #07ff0e.split( ), g = [], h = 0; h < f.length; ++h) {                        var k = h / f.length  12,                            l = 30  Math.sqrt(h / f.length);                        g.push(new ca(-1, Math.cos(k)  l, Math.sin(k)  l, 10, f[h], ))                    }                    Sc(g);                    var m = document.createElement(canvas);                    m.getContext(2d);                    m.width = m.height = 70;                    a(c, m, , 26, #ebc0de);                    return function() {                        e(.cell-spinner).filter(:visible).each(function() {                            var c = e(this),                                d = Date.now(),                                f = this.width,                                g = this.height,                                h = this.getContext(2d);                            h.clearRect(0, 0, f, g);                            h.save();                            h.translate(f / 2, g / 2);                            for (var k = 0; 10 > k; ++k) h.drawImage(m, (.1  d + 80  k) % (f + 140) - f / 2 - 70 - 35, g / 2  Math.sin((.001  d + k) % Math.PI  2) - 35, 70, 70);                            h.restore();                            (c = c.attr(data-itr)) && (c = R(c));                            a(b, this, c || , +e(this).attr(data-size), #5bc0de)                        });                        e(#statsPellets).filter(:visible).each(function() {                            e(this);                            var b = this.width,                                c = this.height;                            this.getContext(2d).clearRect(0, 0, b, c);                            for (b = 0; b < g.length; b++) a(g[b], this, , g[b].size, g[b].color)                        })                    }                }();                c.createParty = function() {                    ka(:party);                    S = function(a) {                        Fb(/# + c.encodeURIComponent(a));                        e(.partyToken).val(agar.io/# + c.encodeURIComponent(a));                        e(#helloContainer).attr(data-party-state, 1)                    };                    Q()                };                c.joinParty = mc;                c.cancelParty = function() {                    Fb(/);                    e(#helloContainer).attr(data-party-state, 0);                    ka();                    Q()                };                var F = [],                    wb = 0,                    xb = #000000,                    aa = !1,                    Aa = !1,                    Ja = 0,                    Gb = 0,                    zb = 0,                    yb = 0,                    W = 0,                    Ta = !0;                c.onPlayerDeath = Ga;                setInterval(function() {                    Aa && F.push(dc() / 100)                }, 1E3 / 60);                setInterval(function() {                    var a = Vc();                    0 != a && (++zb, 0 == W && (W = a), W = Math.min(W, a))                }, 1E3);                c.closeStats = function() {                    aa = !1;                    e(#stats).hide();                    c.destroyAd(c.adSlots.ab);                    ua(0)                };                c.setSkipStats = function(a) {                    Ta = !a                };                c.getStatsString = oc;                c.gPlusShare = Xc;                c.twitterShareStats = function() {                    var a = c.getStatsString(tt_share_stats);                    c.open(https://twitter.com/intent/tweet?text= + a, Agar.io, width=660,height=310,menubar=no,toolbar=no,resizable=yes,scrollbars=no,left= +                        (c.screenX + c.innerWidth / 2 - 330) + ,top= + (c.innerHeight - 310) / 2)                };                c.fbShareStats = function() {                    var a = c.getStatsString(fb_matchresults_subtitle);                    c.FB.ui({                        method: feed,                        display: iframe,                        name: R(fb_matchresults_title),                        caption: R(fb_matchresults_description),                        description: a,                        link: http://agar.io,                        La: http://static2.miniclipcdn.com/mobile/agar/Agar.io_matchresults_fb_1200x630.png,                        Ha: {                            name: play now!,                            link: http://agar.io                        }                    })                };                c.fillSocialValues = function(a, b) {                    1 == c.isChrome && google == c.storageInfo.context &&                        c.gapi.interactivepost.render(b, {                            contenturl: EnvConfig.game_url,                            clientid: EnvConfig.gplus_client_id,                            cookiepolicy: http://agar.io,                            prefilltext: a,                            calltoactionlabel: BEAT,                            calltoactionurl: EnvConfig.game_url                        })                };                e(function() {                    MAsyncInit in c && c.MAsyncInit()                })            }        }    }})(window, window.jQuery);UPDATE(function(i, s, o, g, r, a, m) {    i[GoogleAnalyticsObject] = r;    i[r] = i[r] || function() {        (i[r].q = i[r].q || []).push(arguments)    }, i[r].l = 1  new Date();    a = s.createElement(o),        m = s.getElementsByTagName(o)[0];    a.async = 1;    a.src = g;    m.parentNode.insertBefore(a, m)})(window, document, script, , apos);
apos(create, UA-64394184-1, auto);apos(send, pageview);
window.ignoreStream = false;window.refreshTwitch = function() {    window.jQuery.ajax({        url: https://api.twitch.tv/kraken/streams/apostolique,        cache: false,        dataType: jsonp    }).done(function(data) {        if (data[stream] == null) {            console.log(""Apostolique is not online!"");            window.setMessage([]);            window.onmouseup = function() {};            window.ignoreStream = false;        } else {            console.log(""Apostolique is online!"");            if (!window.ignoreStream) {                window.setMessage([twitch.tv/apostolique is online right now!, Click the screen to open the stream!, Press E to ignore.]);                window.onmouseup = function() {                    window.open(http://www.twitch.tv/apostolique);                };            }        }    }).fail(function() {});}setInterval(window.refreshTwitch, 60000);window.refreshTwitch();"
"Copyright (c) 2015 ApostoliquePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the ""Software""), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.*/
 ==UserScript== @name        AposBot @namespace   AposBot @include     http://agar.io/* @version     3.651 @grant       none @author      http://www.twitch.tv/apostolique ==/UserScript==
var aposBotVersion = 3.651;
TODO: Team mode      Detect when people are merging      Split to catch smaller targets      Angle based cluster code      Better wall code      In team mode, make allies be obstacles.
Number.prototype.mod = function(n) {    return ((this % n) + n) % n;};
Array.prototype.peek = function() {    return this[this.length - 1];};
Load it from the two file in case one is not loadedwindow.log = function(message){    if(window.logDebugging === true){        console.log.apply(console, arguments);    }}
var sha = efde0488cc2cc176db48dd23b28a20b90314352b;(function () {    window.jQuery.ajax({            url: https://api.github.com/repos/apostolique/Agar.io-bot/git/refs/heads/master,            cache: false,            dataType: jsonp        }).done(function(data) {            console.dir(data.data);            window.log(hmm:  + data.data.object.sha);            sha = data.data.object.sha;
            function update(prefix, name, url) {                window.jQuery(document.body).prepend(<div id=' + prefix + Dialog' style='position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 100; display: none;'>);                window.jQuery(# + prefix + Dialog).append(<div id=' + prefix + Message' style='width: 350px; background-color: #FFFFFF; margin: 100px auto; border-radius: 15px; padding: 5px 15px 5px 15px;'>);                window.jQuery(# + prefix + Message).append(<h2>UPDATE TIME!!!</h2>);                window.jQuery(# + prefix + Message).append(<p>Grab the update for: <a id=' + prefix + Link' href=' + url + ' target=_blank> + name + </a></p>);                window.jQuery(# + prefix + Link).on(click, function() {                    window.jQuery(# + prefix + Dialog).hide();                    window.jQuery(# + prefix + Dialog).remove();                });                window.jQuery(# + prefix + Dialog).show();            }
            $.get(https://raw.githubusercontent.com/Apostolique/Agar.io-bot/master/bot.user.js? + Math.floor((Math.random()  1000000) + 1), function(data) {                var latestVersion = data.replace(()gm,);                latestVersion = latestVersion.substring(latestVersion.indexOf()+11,latestVersion.indexOf());
                latestVersion = parseFloat(latestVersion + 0.0000);                var myVersion = parseFloat(aposBotVersion + 0.0000);
                if(latestVersion > myVersion)                {                    update(aposBot, bot.user.js, https://github.com/Apostolique/Agar.io-bot/blob/ + sha + /bot.user.js/);                }                window.log(Current bot.user.js Version:  + myVersion +  on Github:  + latestVersion);            });
        }).fail(function() {});})();
window.log(Running Apos Bot!);
var f = window;var g = window.jQuery;

window.log(Apos Bot!);
window.botList = window.botList || [];
    this.name = ""QuickBot V1"";    this.customParameters = {};    this.keyAction = function(key) {};    this.displayText = function() {return [];};    this.mainLoop = function() {        return [screenToGameX(getMouseX()),                screenToGameY(getMouseY())];    };}window.botList.push(new QuickBot());*/
function AposBot() {    this.name = AposBot  + aposBotVersion;
    this.toggleFollow = false;    this.keyAction = function(key) {        if (key.keyCode === 81) {            window.log(Toggle Follow Mouse!);            this.toggleFollow = !this.toggleFollow;        }    };
    this.displayText = function() {        return [Q - Follow Mouse:  + (this.toggleFollow ? On : Off)];    };
     Using mod function instead the prototype directly as it is very slow    this.mod = function(num, mod) {        if (mod & (mod - 1) === 0 && mod !== 0) {            return num & (mod - 1);        }        return num < 0 ? ((num % mod) + mod) % mod : num % mod;    };    this.splitDistance = 710;
    this.isMerging = function(cell1, cell2) {        var dist = this.computeDistance(cell1.x, cell1.y, cell2.x, cell2.y, cell1.size, cell2.size);
        debug logging		window.log(Merge:, [cell1.x, cell1.y, cell2.x, cell2.y, cell1.size, cell2.size, dist].join(, ))
        return dist <= -50;    };
    Given an angle value that was gotten from valueAndleBased(),    returns a new value that scales it appropriately.    this.paraAngleValue = function(angleValue, range) {        return (15 / (range[1]))  (angleValue  angleValue) - (range[1] / 6);    };
    this.getMass = function(size) {        return Math.pow(size / 10, 2);    };
    this.valueAngleBased = function(angle, range) {        var leftValue = this.mod(angle - range[0], 360);        var rightValue = this.mod(this.rangeToAngle(range) - angle, 360);
        var bestValue = Math.min(leftValue, rightValue);
        if (bestValue <= range[1]) {            return this.paraAngleValue(bestValue, range);        }        return -1;    };
    this.computeDistance = function(x1, y1, x2, y2, s1, s2) {         Make sure there are no null optional params.        s1 = s1 || 0;        s2 = s2 || 0;        var xdis = x1 - x2;  <--- FAKE AmS OF COURSE!        var ydis = y1 - y2;        var distance = Math.sqrt(xdis  xdis + ydis  ydis) - (s1 + s2);
        return distance;    };
     Get a distance that is Inexpensive on the cpu for various purpaces    this.computeInexpensiveDistance = function(x1, y1, x2, y2, s1, s2) {         Make sure there are no null optional params.        s1 = s1 || 0;        s2 = s2 || 0;        var xdis = x1 - x2;        var ydis = y1 - y2;         Get abs quickly        xdis = xdis < 0 ? xdis  -1 : xdis;        ydis = ydis < 0 ? ydis  -1 : ydis;
        var distance = xdis + ydis;
        return distance;    };
    this.computeDistanceFromCircleEdgeDeprecated = function(x1, y1, x2, y2, s2) {        var tempD = this.computeDistance(x1, y1, x2, y2);
        var offsetX = 0;        var offsetY = 0;
        var ratioX = tempD / (x1 - x2);        var ratioY = tempD / (y1 - y2);
        offsetX = x1 - (s2 / ratioX);        offsetY = y1 - (s2 / ratioY);
        drawPoint(offsetX, offsetY, 5, );
        return this.computeDistance(x2, y2, offsetX, offsetY);    };
    this.compareSize = function(player1, player2, ratio) {        if (player1.size  player1.size  ratio < player2.size  player2.size) {            return true;        }        return false;    },
    this.canSplit = function(player1, player2) {        return this.compareSize(player1, player2, 2.8) && !this.compareSize(player1, player2, 20);    };
    this.isItMe = function(player, cell) {        if (getMode() == :teams) {            var currentColor = player[0].color;            var currentRed = currentColor.substring(1,3);            var currentGreen = currentColor.substring(3,5);            var currentBlue = currentColor.substring(5,7);
            var currentTeam = this.getTeam(currentRed, currentGreen, currentBlue);
            var cellColor = cell.color;
            var cellRed = cellColor.substring(1,3);            var cellGreen = cellColor.substring(3,5);            var cellBlue = cellColor.substring(5,7);
            var cellTeam = this.getTeam(cellRed, cellGreen, cellBlue);
            if (currentTeam == cellTeam && !cell.isVirus()) {                return true;            }
            window.log(COLOR:  + color);
        } else {            for (var i = 0; i < player.length; i++) {                if (cell.id == player[i].id) {                    return true;                }            }        }        return false;    };
    this.getTeam = function(red, green, blue) {        if (red == ff) {            return 0;        } else if (green == ff) {            return 1;        }        return 2;    };
    this.isFood = function(blob, cell) {        if (!cell.isVirus() && this.compareSize(cell, blob, 1.33) || (cell.size <= 13)) {            return true;        }        return false;    };
    this.isThreat = function(blob, cell) {
        if (!cell.isVirus() && this.compareSize(blob, cell, 1.30)) {            return true;        }        return false;    };
    this.isVirus = function(blob, cell) {    if (blob == null) {        if (cell.isVirus()) {            return true;        } else {            return false;        }    }    if (cell.isVirus() && this.compareSize(cell, blob, 1.1)) {        return true;    } else if (cell.isVirus() && cell.color.substring(3, 5).toLowerCase() != ff) {        return true;    }    return false;};
    this.isSplitTarget = function(that, blob, cell) {        if (that.canSplit(cell, blob)) {            return true;        }        return false;    };
    this.getTimeToRemerge = function(mass){        return Math.max(30, Math.floor(mass0.02));        return ((mass*0.02) + 30);    };
    this.separateListBasedOnFunction = function(that, listToUse, blob) {        var foodElementList = [];        var threatList = [];        var virusList = [];        var splitTargetList = [];
        var player = getPlayer();
        var mergeList = [];
        Object.keys(listToUse).forEach(function(element, index) {            var isMe = that.isItMe(player, listToUse[element]);
            if (!isMe) {                if (that.isFood(blob, listToUse[element]) && listToUse[element].isNotMoving()) {                    IT'S FOOD!                    foodElementList.push(listToUse[element]);

                } else if (that.isThreat(blob, listToUse[element])) {                    IT'S DANGER!                    threatList.push(listToUse[element]);                    mergeList.push(listToUse[element]);                } else if (that.isVirus(blob, listToUse[element])) {                    IT'S VIRUS!                    virusList.push(listToUse[element]);                }                else if (that.isSplitTarget(that, blob, listToUse[element])) {                        drawCircle(listToUse[element].x, listToUse[element].y, listToUse[element].size + 50, 7);                        splitTargetList.push(listToUse[element]);                        foodElementList.push(listToUse[element]);                        mergeList.push(listToUse[element]);                }                else {if (that.isVirus(null, listToUse[element])==false) {mergeList.push(listToUse[element]);}                    }            }                //Attempt to make the other cell follow the mother one                foodElementList.push(listToUse[element]);            }*/        });
        foodList = [];        for (var i = 0; i < foodElementList.length; i++) {            foodList.push([foodElementList[i].x, foodElementList[i].y, foodElementList[i].size]);        }
        window.log(Merglist length:  +  mergeList.length)        cell merging        for (var i = 0; i < mergeList.length; i++) {            for (var z = 0; z < mergeList.length; z++) {                if (z != i && that.isMerging(mergeList[i], mergeList[z])) { z != i &&                        found cells that appear to be merging - if they constitute a threat add them to the theatlist
                        clone us a new cell                        var newThreat = {};                        var prop;
                        for (prop in mergeList[i]) {                            newThreat[prop] = mergeList[i][prop];                        }
                        average distance and sum the size                        newThreat.x = (mergeList[i].x + mergeList[z].x)/2;                        newThreat.y = (mergeList[i].y + mergeList[z].y)/2;                        newThreat.size = (mergeList[i].size + mergeList[z].size);                        newThreat.nopredict = true;                        check its a threat                        if (that.isThreat(blob, newThreat)) {                             IT'S DANGER!                            threatList.push(newThreat);                        }
                }            }        }
        return [foodList, threatList, virusList, splitTargetList];    };
    this.getAll = function(blob) {        var dotList = [];        var player = getPlayer();        var interNodes = getMemoryCells();
        dotList = this.separateListBasedOnFunction(this, interNodes, blob);
        return dotList;    };
    this.clusterFood = function(foodList, blobSize) {        var clusters = [];        var addedCluster = false;
        1: x        2: y        3: size or value        4: Angle, not set here.
        for (var i = 0; i < foodList.length; i++) {            for (var j = 0; j < clusters.length; j++) {                if (this.computeInexpensiveDistance(foodList[i][0], foodList[i][1], clusters[j][0], clusters[j][1]) < blobSize  2) {                    clusters[j][0] = (foodList[i][0] + clusters[j][0]) / 2;                    clusters[j][1] = (foodList[i][1] + clusters[j][1]) / 2;                    clusters[j][2] += foodList[i][2];                    addedCluster = true;                    break;                }            }            if (!addedCluster) {                clusters.push([foodList[i][0], foodList[i][1], foodList[i][2], 0]);            }            addedCluster = false;        }        return clusters;    };
    this.getAngle = function(x1, y1, x2, y2) {        Handle vertical and horizontal lines.
        if (x1 == x2) {            if (y1 < y2) {                return 271;                return 89;            } else {                return 89;            }        }
        return (Math.round(Math.atan2(-(y1 - y2), -(x1 - x2)) / Math.PI  180 + 180));    };
    this.slope = function(x1, y1, x2, y2) {        var m = (y1 - y2) / (x1 - x2);
        return m;    };
    this.slopeFromAngle = function(degree) {        if (degree == 270) {            degree = 271;        } else if (degree == 90) {            degree = 91;        }        return Math.tan((degree - 180) / 180  Math.PI);    };
    Given two points on a line, finds the slope of a perpendicular line crossing it.    this.inverseSlope = function(x1, y1, x2, y2) {        var m = this.slope(x1, y1, x2, y2);        return (-1) / m;    };
    Given a slope and an offset, returns two points on that line.    this.pointsOnLine = function(slope, useX, useY, distance) {        var b = useY - slope  useX;        var r = Math.sqrt(1 + slope  slope);
        var newX1 = (useX + (distance / r));        var newY1 = (useY + ((distance  slope) / r));        var newX2 = (useX + ((-distance) / r));        var newY2 = (useY + (((-distance)  slope) / r));
        return [            [newX1, newY1],            [newX2, newY2]        ];    };
    this.followAngle = function(angle, useX, useY, distance) {        var slope = this.slopeFromAngle(angle);        var coords = this.pointsOnLine(slope, useX, useY, distance);
        var side = this.mod(angle - 90, 360);        if (side < 180) {            return coords[1];        } else {            return coords[0];        }    };
    Using a line formed from point a to b, tells if point c is on S side of that line.    this.isSideLine = function(a, b, c) {        if ((b[0] - a[0])  (c[1] - a[1]) - (b[1] - a[1])  (c[0] - a[0]) > 0) {            return true;        }        return false;    };
    angle range2 is within angle range2    an Angle is a point and a distance between an other point [5, 40]    this.angleRangeIsWithin = function(range1, range2) {        if (range2[0] == this.mod(range2[0] + range2[1], 360)) {            return true;        }        window.log(r1:  + range1[0] + ,  + range1[1] +  ... r2:  + range2[0] + ,  + range2[1]);
        var distanceFrom0 = this.mod(range1[0] - range2[0], 360);        var distanceFrom1 = this.mod(range1[1] - range2[0], 360);
        if (distanceFrom0 < range2[1] && distanceFrom1 < range2[1] && distanceFrom0 < distanceFrom1) {            return true;        }        return false;    };
    this.angleRangeIsWithinInverted = function(range1, range2) {        var distanceFrom0 = this.mod(range1[0] - range2[0], 360);        var distanceFrom1 = this.mod(range1[1] - range2[0], 360);
        if (distanceFrom0 < range2[1] && distanceFrom1 < range2[1] && distanceFrom0 > distanceFrom1) {            return true;        }        return false;    };
    this.angleIsWithin = function(angle, range) {        var diff = this.mod(this.rangeToAngle(range) - angle, 360);        if (diff >= 0 && diff <= range[1]) {            return true;        }        return false;    };
    this.rangeToAngle = function(range) {        return this.mod(range[0] + range[1], 360);    };
    this.anglePair = function(range) {        return (range[0] + ,  + this.rangeToAngle(range) +  range:  + range[1]);    };
    this.computeAngleRanges = function(blob1, blob2) {        var mainAngle = this.getAngle(blob1.x, blob1.y, blob2.x, blob2.y);        var leftAngle = this.mod(mainAngle - 90, 360);        var rightAngle = this.mod(mainAngle + 90, 360);
        var blob1Left = this.followAngle(leftAngle, blob1.x, blob1.y, blob1.size);        var blob1Right = this.followAngle(rightAngle, blob1.x, blob1.y, blob1.size);
        var blob2Left = this.followAngle(rightAngle, blob2.x, blob2.y, blob2.size);        var blob2Right = this.followAngle(leftAngle, blob2.x, blob2.y, blob2.size);
        var blob1AngleLeft = this.getAngle(blob2.x, blob2.y, blob1Left[0], blob1Left[1]);        var blob1AngleRight = this.getAngle(blob2.x, blob2.y, blob1Right[0], blob1Right[1]);
        var blob2AngleLeft = this.getAngle(blob1.x, blob1.y, blob2Left[0], blob2Left[1]);        var blob2AngleRight = this.getAngle(blob1.x, blob1.y, blob2Right[0], blob2Right[1]);
        var blob1Range = this.mod(blob1AngleRight - blob1AngleLeft, 360);        var blob2Range = this.mod(blob2AngleRight - blob2AngleLeft, 360);
        var tempLine = this.followAngle(blob2AngleLeft, blob2Left[0], blob2Left[1], 400);        drawLine(blob2Left[0], blob2Left[1], tempLine[0], tempLine[1], 0);
        if ((blob1Range / blob2Range) > 1) {            drawPoint(blob1Left[0], blob1Left[1], 3, );            drawPoint(blob1Right[0], blob1Right[1], 3, );            drawPoint(blob1.x, blob1.y, 3,  + blob1Range + ,  + blob2Range +  R:  + (Math.round((blob1Range / blob2Range)  1000) / 1000));        }
        drawPoint(blob2.x, blob2.y, 3, """" + blob1Range);    };
    this.debugAngle = function(angle, text) {        var player = getPlayer();        var line1 = this.followAngle(angle, player[0].x, player[0].y, 300);        drawLine(player[0].x, player[0].y, line1[0], line1[1], 5);        drawPoint(line1[0], line1[1], 5,  + text);    };
    TODO: Don't let this function do the radius math.    this.getEdgeLinesFromPoint = function(blob1, blob2, radius) {        var px = blob1.x;        var py = blob1.y;
        var cx = blob2.x;        var cy = blob2.y;
        var radius = blob2.size;
                    radius = blob1.size;        } else if(canSplit(blob1, blob2)) {            radius += splitDistance;        } else {            radius += blob1.size * 2;        }*/
        var shouldInvert = false;
        var tempRadius = this.computeDistance(px, py, cx, cy);        if (tempRadius <= radius) {            radius = tempRadius - 5;            shouldInvert = true;        }
        var dx = cx - px;        var dy = cy - py;        var dd = Math.sqrt(dx  dx + dy  dy);        var a = Math.asin(radius / dd);        var b = Math.atan2(dy, dx);
        var t = b - a;        var ta = {            x: radius  Math.sin(t),            y: radius  -Math.cos(t)        };
        t = b + a;        var tb = {            x: radius  -Math.sin(t),            y: radius  Math.cos(t)        };
        var angleLeft = this.getAngle(cx + ta.x, cy + ta.y, px, py);        var angleRight = this.getAngle(cx + tb.x, cy + tb.y, px, py);        var angleDistance = this.mod(angleRight - angleLeft, 360);
                    var temp = angleLeft;            angleLeft = this.mod(angleRight + 180, 360);            angleRight = this.mod(temp + 180, 360);            angleDistance = this.mod(angleRight - angleLeft, 360);        }*/
        return [angleLeft, angleDistance, [cx + tb.x, cy + tb.y],            [cx + ta.x, cy + ta.y]        ];    };
    this.addWall = function(listToUse, blob) {        var mapSizeX = Math.abs(f.getMapStartX - f.getMapEndX);        var mapSizeY = Math.abs(f.getMapStartY - f.getMapEndY);        var distanceFromWallX = mapSizeX/3;        var distanceFromWallY = mapSizeY/3;        var distanceFromWallY = 1000;        var distanceFromWallX = 1000;        if (blob.x < getMapStartX() + distanceFromWallX) {            LEFT            window.log(Left);            listToUse.push([                [115, true],                [245, false], this.computeInexpensiveDistance(getMapStartX(), blob.y, blob.x, blob.y)            ]);            var lineLeft = this.followAngle(115, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(245, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        if (blob.y < getMapStartY() + distanceFromWallY) {            TOP            window.log(TOP);            listToUse.push([                [205, true],                [335, false], this.computeInexpensiveDistance(blob.x, getMapStartY(), blob.x, blob.y)            ]);            var lineLeft = this.followAngle(205, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(335, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        if (blob.x > getMapEndX() - distanceFromWallX) {            RIGHT            window.log(RIGHT);            listToUse.push([                [295, true],                [65, false], this.computeInexpensiveDistance(getMapEndX(), blob.y, blob.x, blob.y)            ]);            var lineLeft = this.followAngle(295, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(65, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        if (blob.y > getMapEndY() - distanceFromWallY) {            BOTTOM            window.log(BOTTOM);            listToUse.push([                [25, true],                [155, false], this.computeInexpensiveDistance(blob.x, getMapEndY(), blob.x, blob.y)            ]);            var lineLeft = this.followAngle(25, blob.x, blob.y, 190 + blob.size);            var lineRight = this.followAngle(155, blob.x, blob.y, 190 + blob.size);            drawLine(blob.x, blob.y, lineLeft[0], lineLeft[1], 5);            drawLine(blob.x, blob.y, lineRight[0], lineRight[1], 5);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob.x, blob.y, 5);        }        return listToUse;    };
    listToUse contains angles in the form of [angle, boolean].    boolean is true when the range is starting. False when it's ending.    range = [[angle1, true], [angle2, false]]
    this.getAngleIndex = function(listToUse, angle) {        if (listToUse.length === 0) {            return 0;        }
        for (var i = 0; i < listToUse.length; i++) {            if (angle <= listToUse[i][0]) {                return i;            }        }
        return listToUse.length;    };
    this.addAngle = function(listToUse, range) {        #1 Find first open element        #2 Try to add range1 to the list. If it is within other range, don't add it, set a boolean.        #3 Try to add range2 to the list. If it is withing other range, don't add it, set a boolean.
        TODO: Only add the new range at the end after the right stuff has been removed.
        var newListToUse = listToUse.slice();
        var startIndex = 1;
        if (newListToUse.length > 0 && !newListToUse[0][1]) {            startIndex = 0;        }
        var startMark = this.getAngleIndex(newListToUse, range[0][0]);        var startBool = this.mod(startMark, 2) != startIndex;
        var endMark = this.getAngleIndex(newListToUse, range[1][0]);        var endBool = this.mod(endMark, 2) != startIndex;
        var removeList = [];
        if (startMark != endMark) {            Note: If there is still an error, this would be it.            var biggerList = 0;            if (endMark == newListToUse.length) {                biggerList = 1;            }
            for (var i = startMark; i < startMark + this.mod(endMark - startMark, newListToUse.length + biggerList); i++) {                removeList.push(this.mod(i, newListToUse.length));            }        } else if (startMark < newListToUse.length && endMark < newListToUse.length) {            var startDist = this.mod(newListToUse[startMark][0] - range[0][0], 360);            var endDist = this.mod(newListToUse[endMark][0] - range[1][0], 360);
            if (startDist < endDist) {                for (var i = 0; i < newListToUse.length; i++) {                    removeList.push(i);                }            }        }
        removeList.sort(function(a, b){return b-a;});
        for (var i = 0; i < removeList.length; i++) {            newListToUse.splice(removeList[i], 1);        }
        if (startBool) {            newListToUse.splice(this.getAngleIndex(newListToUse, range[0][0]), 0, range[0]);        }        if (endBool) {            newListToUse.splice(this.getAngleIndex(newListToUse, range[1][0]), 0, range[1]);        }
        return newListToUse;    };
    this.getAngleRange = function(blob1, blob2, index, radius) {        var angleStuff = this.getEdgeLinesFromPoint(blob1, blob2, radius);
        var leftAngle = angleStuff[0];        var rightAngle = this.rangeToAngle(angleStuff);        var difference = angleStuff[1];
        drawPoint(angleStuff[2][0], angleStuff[2][1], 3, );        drawPoint(angleStuff[3][0], angleStuff[3][1], 3, );
        window.log(Adding badAngles:  + leftAngle + ,  + rightAngle +  diff:  + difference);
        var lineLeft = this.followAngle(leftAngle, blob1.x, blob1.y, 150 + blob1.size - index  10);        var lineRight = this.followAngle(rightAngle, blob1.x, blob1.y, 150 + blob1.size - index  10);
        if (blob2.isVirus()) {            drawLine(blob1.x, blob1.y, lineLeft[0], lineLeft[1], 6);            drawLine(blob1.x, blob1.y, lineRight[0], lineRight[1], 6);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob1.x, blob1.y, 6);        } else if(getCells().hasOwnProperty(blob2.id)) {            drawLine(blob1.x, blob1.y, lineLeft[0], lineLeft[1], 0);            drawLine(blob1.x, blob1.y, lineRight[0], lineRight[1], 0);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob1.x, blob1.y, 0);        } else {            drawLine(blob1.x, blob1.y, lineLeft[0], lineLeft[1], 3);            drawLine(blob1.x, blob1.y, lineRight[0], lineRight[1], 3);            drawArc(lineLeft[0], lineLeft[1], lineRight[0], lineRight[1], blob1.x, blob1.y, 3);        }
        return [leftAngle, difference];    };
    Given a list of conditions, shift the angle to the closest available spot respecting the range given.    this.shiftAngle = function(listToUse, angle, range) {        TODO: shiftAngle needs to respect the range! DONE?        for (var i = 0; i < listToUse.length; i++) {            if (this.angleIsWithin(angle, listToUse[i])) {                window.log(Shifting needed!);
                var angle1 = listToUse[i][0];                var angle2 = this.rangeToAngle(listToUse[i]);
                var dist1 = this.mod(angle - angle1, 360);                var dist2 = this.mod(angle2 - angle, 360);
                if (dist1 < dist2) {                    if (this.angleIsWithin(angle1, range)) {                        return angle1;                    } else {                        return angle2;                    }                } else {                    if (this.angleIsWithin(angle2, range)) {                        return angle2;                    } else {                        return angle1;                    }                }            }        }        window.log(No Shifting Was needed!);        return angle;    };
         * This is the main bot logic. This is called quite often.     *  A 2 dimensional array with coordinates for every cells.  [[x, y], [x, y]]     */    this.mainLoop = function() {        var player = getPlayer();        var interNodes = getMemoryCells();
        if (  1) {            The following code converts the mouse position into an            absolute game coordinate.            var useMouseX = screenToGameX(getMouseX());            var useMouseY = screenToGameY(getMouseY());            tempPoint = [useMouseX, useMouseY, 1];
            The current destination that the cells were going towards.            var tempMoveX = getPointX();            var tempMoveY = getPointY();
            drawLine(getX() - (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), getX() + (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), 7);            drawLine(getX() - (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), getX() + (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), 7);            drawLine(getX() - (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), getX() - (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), 7);            drawLine(getX() + (1920 / 2) / getZoomlessRatio(), getY() - (1080 / 2) / getZoomlessRatio(), getX() + (1920 / 2) / getZoomlessRatio(), getY() + (1080 / 2) / getZoomlessRatio(), 7);
            This variable will be returned at the end.            It will contain the destination choices for all the cells.            BTW!!! ERROR ERROR ABORT MISSION!!!!!!! READ BELOW -----------                        SINCE IT'S STUPID NOW TO ASK EACH CELL WHERE THEY WANT TO GO,            THE BOT SHOULD SIMPLY PICK ONE AND THAT'S IT, I MEAN WTF....            var destinationChoices = []; destination, size, danger
            Just to make sure the player is alive.            if (player.length > 0) {
                Loop through all the player's cells.                for (var k = 0; k < player.length; k++) {                    if (true) {                        drawPoint(player[k].x, player[k].y + player[k].size, 0,  + (getLastUpdate() - player[k].birth) +  /  + parseInt((30000 + (player[k].birthMass  57) - (getLastUpdate() - player[k].birth))) +  /  + player[k].birthMass);                    }                }

                Loops only for one cell for now.                for (var k = 0;  k < 1; k++) {
                    window.log(Working on blob:  + k);
                    drawCircle(player[k].x, player[k].y, player[k].size + this.splitDistance, 5);                    drawPoint(player[0].x, player[0].y - player[0].size, 3, """" + Math.floor(player[0].x) + "", "" + Math.floor(player[0].y));
                    var allDots = processEverything(interNodes);
                    loop through everything that is on the screen and                    separate everything in it's own category.                    var allIsAll = this.getAll(player[k]);
                    The food stored in element 0 of allIsAll                    var allPossibleFood = allIsAll[0];                    The threats are stored in element 1 of allIsAll                    var allPossibleThreats = allIsAll[1];                    The viruses are stored in element 2 of allIsAll                    var allPossibleViruses = allIsAll[2];
                    The bot works by removing angles in which it is too                    dangerous to travel towards to.                    var badAngles = [];                    var obstacleList = [];
                    var isSafeSpot = true;                    var isMouseSafe = true;
                    var clusterAllFood = this.clusterFood(allPossibleFood, player[k].size);
                    window.log(Looking for enemies!);
                    Loop through all the cells that were identified as threats.                    for (var i = 0; i < allPossibleThreats.length; i++) {
                        var enemyDistance = this.computeDistance(allPossibleThreats[i].x, allPossibleThreats[i].y, player[k].x, player[k].y, allPossibleThreats[i].size);
                        allPossibleThreats[i].enemyDist = enemyDistance;                    }
                                            return a.enemyDist-b.enemyDist;                    })*/
                    for (var i = 0; i < allPossibleThreats.length; i++) {
                        var enemyDistance = this.computeDistance(allPossibleThreats[i].x, allPossibleThreats[i].y, player[k].x, player[k].y);
                        var splitDangerDistance = allPossibleThreats[i].size + this.splitDistance + 150;
                        var normalDangerDistance = allPossibleThreats[i].size + 150;
                        var shiftDistance = player[k].size;
                        window.log(Found distance.);
                        var enemyCanSplit = this.canSplit(player[k], allPossibleThreats[i]);                        var secureDistance = (enemyCanSplit ? splitDangerDistance : normalDangerDistance);
                        for (var j = clusterAllFood.length - 1; j >= 0 ; j--) {                            if (this.computeDistance(allPossibleThreats[i].x, allPossibleThreats[i].y, clusterAllFood[j][0], clusterAllFood[j][1]) < secureDistance + shiftDistance)                                clusterAllFood.splice(j, 1);                        }
                        window.log(Removed some food.);
                        if (enemyCanSplit) {                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, splitDangerDistance, 0);                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, splitDangerDistance + shiftDistance, 6);                        } else {                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, normalDangerDistance, 3);                            drawCircle(allPossibleThreats[i].x, allPossibleThreats[i].y, normalDangerDistance + shiftDistance, 6);                        }
                        if (allPossibleThreats[i].danger && getLastUpdate() - allPossibleThreats[i].dangerTimeOut > 1000) {
                            allPossibleThreats[i].danger = false;                        }
                                                    (!enemyCanSplit && enemyDistance < normalDangerDistance)) {                            allPossibleThreats[i].danger = true;                            allPossibleThreats[i].dangerTimeOut = f.getLastUpdate();                        }*/
                        window.log(Figured out who was important.);
                        if ((enemyCanSplit && enemyDistance < splitDangerDistance) || (enemyCanSplit && allPossibleThreats[i].danger)) {
                            badAngles.push(this.getAngleRange(player[k], allPossibleThreats[i], i, splitDangerDistance).concat(allPossibleThreats[i].enemyDist));
                        } else if ((!enemyCanSplit && enemyDistance < normalDangerDistance) || (!enemyCanSplit && allPossibleThreats[i].danger)) {
                            badAngles.push(this.getAngleRange(player[k], allPossibleThreats[i], i, normalDangerDistance).concat(allPossibleThreats[i].enemyDist));
                        } else if (enemyCanSplit && enemyDistance < splitDangerDistance + shiftDistance) {                            var tempOb = this.getAngleRange(player[k], allPossibleThreats[i], i, splitDangerDistance + shiftDistance);                            var angle1 = tempOb[0];                            var angle2 = this.rangeToAngle(tempOb);
                            obstacleList.push([[angle1, true], [angle2, false]]);                        } else if (!enemyCanSplit && enemyDistance < normalDangerDistance + shiftDistance) {                            var tempOb = this.getAngleRange(player[k], allPossibleThreats[i], i, normalDangerDistance + shiftDistance);                            var angle1 = tempOb[0];                            var angle2 = this.rangeToAngle(tempOb);
                            obstacleList.push([[angle1, true], [angle2, false]]);                        }                        window.log(Done with enemy:  + i);                    }
                    window.log(Done looking for enemies!);
                    var goodAngles = [];                    var stupidList = [];
                    for (var i = 0; i < allPossibleViruses.length; i++) {                        if (player[k].size < allPossibleViruses[i].size) {                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, allPossibleViruses[i].size + 10, 3);                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, allPossibleViruses[i].size  2, 6);
                        } else {                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, player[k].size + 50, 3);                            drawCircle(allPossibleViruses[i].x, allPossibleViruses[i].y, player[k].size  2, 6);                        }                    }
                    for (var i = 0; i < allPossibleViruses.length; i++) {                        var virusDistance = this.computeDistance(allPossibleViruses[i].x, allPossibleViruses[i].y, player[k].x, player[k].y);                        if (player[k].size < allPossibleViruses[i].size) {                            if (virusDistance < (allPossibleViruses[i].size  2)) {                                var tempOb = this.getAngleRange(player[k], allPossibleViruses[i], i, allPossibleViruses[i].size + 10);                                var angle1 = tempOb[0];                                var angle2 = this.rangeToAngle(tempOb);                                obstacleList.push([[angle1, true], [angle2, false]]);                            }                        } else {                            if (virusDistance < (player[k].size  2)) {                                var tempOb = this.getAngleRange(player[k], allPossibleViruses[i], i, player[k].size + 50);                                var angle1 = tempOb[0];                                var angle2 = this.rangeToAngle(tempOb);                                obstacleList.push([[angle1, true], [angle2, false]]);                            }                        }                    }
                    if (badAngles.length > 0) {                        NOTE: This is only bandaid wall code. It's not the best way to do it.                        stupidList = this.addWall(stupidList, player[k]);                    }
                    for (var i = 0; i < badAngles.length; i++) {                        var angle1 = badAngles[i][0];                        var angle2 = this.rangeToAngle(badAngles[i]);                        stupidList.push([[angle1, true], [angle2, false], badAngles[i][2]]);                    }
                    stupidList.push([[45, true], [135, false]]);                    stupidList.push([[10, true], [200, false]]);
                    stupidList.sort(function(a, b){                        window.log(Distance:  + a[2] + ,  + b[2]);                        return a[2]-b[2];                    });
                    window.log(Added random noob stuff.);
                    var sortedInterList = [];                    var sortedObList = [];
                    for (var i = 0; i < stupidList.length; i++) {                        window.log(Adding to sorted:  + stupidList[i][0][0] + ,  + stupidList[i][1][0]);                        var tempList = this.addAngle(sortedInterList, stupidList[i]);
                        if (tempList.length === 0) {                            window.log(MAYDAY IT'S HAPPENING!);                            break;                        } else {                            sortedInterList = tempList;                        }                    }
                    for (var i = 0; i < obstacleList.length; i++) {                        sortedObList = this.addAngle(sortedObList, obstacleList[i]);
                        if (sortedObList.length === 0) {                            break;                        }                    }
                    var offsetI = 0;                    var obOffsetI = 1;
                    if (sortedInterList.length > 0 && sortedInterList[0][1]) {                        offsetI = 1;                    }                    if (sortedObList.length > 0 && sortedObList[0][1]) {                        obOffsetI = 0;                    }
                    var goodAngles = [];                    var obstacleAngles = [];
                    for (var i = 0; i < sortedInterList.length; i += 2) {                        var angle1 = sortedInterList[this.mod(i + offsetI, sortedInterList.length)][0];                        var angle2 = sortedInterList[this.mod(i + 1 + offsetI, sortedInterList.length)][0];                        var diff = this.mod(angle2 - angle1, 360);                        goodAngles.push([angle1, diff]);                    }
                    for (var i = 0; i < sortedObList.length; i += 2) {                        var angle1 = sortedObList[this.mod(i + obOffsetI, sortedObList.length)][0];                        var angle2 = sortedObList[this.mod(i + 1 + obOffsetI, sortedObList.length)][0];                        var diff = this.mod(angle2 - angle1, 360);                        obstacleAngles.push([angle1, diff]);                    }
                    for (var i = 0; i < goodAngles.length; i++) {                        var line1 = this.followAngle(goodAngles[i][0], player[k].x, player[k].y, 100 + player[k].size);                        var line2 = this.followAngle(this.mod(goodAngles[i][0] + goodAngles[i][1], 360), player[k].x, player[k].y, 100 + player[k].size);                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 1);                        drawLine(player[k].x, player[k].y, line2[0], line2[1], 1);
                        drawArc(line1[0], line1[1], line2[0], line2[1], player[k].x, player[k].y, 1);
                        drawPoint(player[0].x, player[0].y, 2, """");
                        drawPoint(line1[0], line1[1], 0,  + i + : 0);                        drawPoint(line2[0], line2[1], 0,  + i + : 1);                    }
                    for (var i = 0; i < obstacleAngles.length; i++) {                        var line1 = this.followAngle(obstacleAngles[i][0], player[k].x, player[k].y, 50 + player[k].size);                        var line2 = this.followAngle(this.mod(obstacleAngles[i][0] + obstacleAngles[i][1], 360), player[k].x, player[k].y, 50 + player[k].size);                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 6);                        drawLine(player[k].x, player[k].y, line2[0], line2[1], 6);
                        drawArc(line1[0], line1[1], line2[0], line2[1], player[k].x, player[k].y, 6);
                        drawPoint(player[0].x, player[0].y, 2, """");
                        drawPoint(line1[0], line1[1], 0,  + i + : 0);                        drawPoint(line2[0], line2[1], 0,  + i + : 1);                    }
                    if (this.toggleFollow && goodAngles.length === 0) {                        This is the follow the mouse mode                        var distance = this.computeDistance(player[k].x, player[k].y, tempPoint[0], tempPoint[1]);
                        var shiftedAngle = this.shiftAngle(obstacleAngles, this.getAngle(tempPoint[0], tempPoint[1], player[k].x, player[k].y), [0, 360]);
                        var destination = this.followAngle(shiftedAngle, player[k].x, player[k].y, distance);
                        destinationChoices = destination;                        drawLine(player[k].x, player[k].y, destination[0], destination[1], 1);                        tempMoveX = destination[0];                        tempMoveY = destination[1];
                    } else if (goodAngles.length > 0) {                        var bIndex = goodAngles[0];                        var biggest = goodAngles[0][1];                        for (var i = 1; i < goodAngles.length; i++) {                            var size = goodAngles[i][1];                            if (size > biggest) {                                biggest = size;                                bIndex = goodAngles[i];                            }                        }                        var perfectAngle = this.mod(bIndex[0] + bIndex[1] / 2, 360);
                        perfectAngle = this.shiftAngle(obstacleAngles, perfectAngle, bIndex);
                        var line1 = this.followAngle(perfectAngle, player[k].x, player[k].y, verticalDistance());
                        destinationChoices = line1;                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 7);                        tempMoveX = line1[0];                        tempMoveY = line1[1];                    } else if (badAngles.length > 0 && goodAngles.length === 0) {                        When there are enemies around but no good angles                        You're likely screwed. (This should never happen.)
                        window.log(Failed);                        destinationChoices = [tempMoveX, tempMoveY];                                                for (var i = 0; i < allPossibleThreats.length; i++){                            var dist = this.computeDistance(player[k].x, player[k].y, allPossibleThreats[i].x, allPossibleThreats[i].y);                            var angle = this.getAngle(allPossibleThreats[i].x, allPossibleThreats[i].y, player[k].x, player[k].y);                            angleWeights.push([angle,dist]);                        }                        var maxDist = 0;                        var finalAngle = 0;                        for (var i = 0; i < angleWeights.length; i++){                            if (angleWeights[i][1] > maxDist){                                maxDist = angleWeights[i][1];                                finalAngle = this.mod(angleWeights[i][0] + 180, 360);                            }                        }                        var line1 = this.followAngle(finalAngle,player[k].x,player[k].y,f.verticalDistance());                        drawLine(player[k].x, player[k].y, line1[0], line1[1], 2);                        destinationChoices.push(line1);*/                    } else if (clusterAllFood.length > 0) {                        for (var i = 0; i < clusterAllFood.length; i++) {                            window.log(mefore:  + clusterAllFood[i][2]);                            This is the cost function. Higher is better.
                                var clusterAngle = this.getAngle(clusterAllFood[i][0], clusterAllFood[i][1], player[k].x, player[k].y);
                                clusterAllFood[i][2] = clusterAllFood[i][2]  6 - this.computeDistance(clusterAllFood[i][0], clusterAllFood[i][1], player[k].x, player[k].y);                                window.log(Current Value:  + clusterAllFood[i][2]);
                                (goodAngles[bIndex][1] / 2 - (Math.abs(perfectAngle - clusterAngle)));
                                clusterAllFood[i][3] = clusterAngle;
                                drawPoint(clusterAllFood[i][0], clusterAllFood[i][1], 1, );                                window.log(After:  + clusterAllFood[i][2]);                        }
                        var bestFoodI = 0;                        var bestFood = clusterAllFood[0][2];                        for (var i = 1; i < clusterAllFood.length; i++) {                            if (bestFood < clusterAllFood[i][2]) {                                bestFood = clusterAllFood[i][2];                                bestFoodI = i;                            }                        }
                        window.log(Best Value:  + clusterAllFood[bestFoodI][2]);
                        var distance = this.computeDistance(player[k].x, player[k].y, clusterAllFood[bestFoodI][0], clusterAllFood[bestFoodI][1]);
                        var shiftedAngle = this.shiftAngle(obstacleAngles, this.getAngle(clusterAllFood[bestFoodI][0], clusterAllFood[bestFoodI][1], player[k].x, player[k].y), [0, 360]);
                        var destination = this.followAngle(shiftedAngle, player[k].x, player[k].y, distance);
                        destinationChoices = destination;                        tempMoveX = destination[0];                        tempMoveY = destination[1];                        drawLine(player[k].x, player[k].y, destination[0], destination[1], 1);                    } else {                        If there are no enemies around and no food to eat.                        destinationChoices = [tempMoveX, tempMoveY];                    }
                    drawPoint(tempPoint[0], tempPoint[1], tempPoint[2], );                    drawPoint(tempPoint[0], tempPoint[1], tempPoint[2], """" + Math.floor(this.computeDistance(tempPoint[0], tempPoint[1], I, J)));                    drawLine(tempPoint[0], tempPoint[1], player[0].x, player[0].y, 6);                    window.log(""Slope: "" + slope(tempPoint[0], tempPoint[1], player[0].x, player[0].y) + "" Angle: "" + getAngle(tempPoint[0], tempPoint[1], player[0].x, player[0].y) + "" Side: "" + this.mod(getAngle(tempPoint[0], tempPoint[1], player[0].x, player[0].y) - 90, 360));                    tempPoint[2] = 1;
                    window.log(Done working on blob:  + i);                }
                TODO: Find where to go based on destinationChoices.                                for (var i = 0; i < destinationChoices.length; i++) {                    if (destinationChoices[i][2]) {                        dangerFound = true;                        break;                    }                }                destinationChoices.sort(function(a, b){return b[1] - a[1]});                if (dangerFound) {                    for (var i = 0; i < destinationChoices.length; i++) {                        if (destinationChoices[i][2]) {                            tempMoveX = destinationChoices[i][0][0];                            tempMoveY = destinationChoices[i][0][1];                            break;                        }                    }                } else {                    tempMoveX = destinationChoices.peek()[0][0];                    tempMoveY = destinationChoices.peek()[0][1];                    //window.log(""Done "" + tempMoveX + "", "" + tempMoveY);                }*/            }            window.log(MOVING RIGHT NOW!);
            window.log(______Never lied ever in my life.);
            return destinationChoices;        }    };};window.botList.push(new AposBot());
if ( typeof window.updateBotList == function ) {    window.updateBotList(); This function might not exist yet.} else {    window.log(The launcher is not yet started.);}"
" *  * Copyright 2016 Google Inc. * * Licensed under the Apache License, Version 2.0 (the ""License""); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an ""AS IS"" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
 *  Require all exported classes an app might use. *   */
goog.require(shaka.Player);goog.require(shaka.abr.SimpleAbrManager);goog.require(shaka.cast.CastProxy);goog.require(shaka.cast.CastReceiver);goog.require(shaka.dash.DashParser);goog.require(shaka.hls.HlsParser);goog.require(shaka.log);goog.require(shaka.media.InitSegmentReference);goog.require(shaka.media.ManifestParser);goog.require(shaka.media.Mp4TtmlParser);goog.require(shaka.media.Mp4VttParser);goog.require(shaka.media.PresentationTimeline);goog.require(shaka.media.SegmentIndex);goog.require(shaka.media.SegmentReference);goog.require(shaka.media.TextEngine);goog.require(shaka.media.TtmlTextParser);goog.require(shaka.media.VttTextParser);goog.require(shaka.net.DataUriPlugin);goog.require(shaka.net.HttpPlugin);goog.require(shaka.offline.OfflineManifestParser);goog.require(shaka.offline.OfflineScheme);goog.require(shaka.offline.Storage);goog.require(shaka.polyfill.Fullscreen);goog.require(shaka.polyfill.IndexedDB);goog.require(shaka.polyfill.MediaKeys);goog.require(shaka.polyfill.MediaSource);goog.require(shaka.polyfill.Promise);goog.require(shaka.polyfill.VTTCue);goog.require(shaka.polyfill.VideoPlaybackQuality);goog.require(shaka.polyfill.installAll);goog.require(shaka.util.Error);"
" *  * Copyright 2016 Google Inc. * * Licensed under the Apache License, Version 2.0 (the ""License""); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an ""AS IS"" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
 Karma configuration Install required modules by running ""npm install""
module.exports = function(config) {  config.set({     base path that will be used to resolve all patterns (eg. files, exclude)    basePath: .,
     frameworks to use     available frameworks: https://npmjs.org/browse/keyword/karma-adapter    frameworks: [      jasmine-ajax, jasmine,      sprintf-js,    ],
    plugins: [      karma-*,   default      frameworkPluginForModule(sprintf-js),    ],
     list of files / patterns to load in the browser    files: [       closure base first      third_party/closure/goog/base.js,
       deps next      dist/deps.js,      shaka-player.uncompiled.js,
       requirejs next      node_modules/requirejs/require.js,
       bootstrapping for the test suite      test/test/boot.js,
       test utils next      test/test/util/*.js,
       list of test assets next      demo/assets.js,
       unit tests last      test/**/*_unit.js,
       if --quick is not present, we will add integration tests.
       source files - these are only watched and served      {pattern: lib/**/*.js, included: false},      {pattern: third_party/closure/goog/**/*.js, included: false},      {pattern: test/test/assets/*, included: false},      {pattern: dist/shaka-player.compiled.js, included: false},    ],
     NOTE: Do not use proxies at all!  They cannot be used with the --hostname     option, which is necessary for some of our lab testing.    proxies: {},
    preprocessors: {       Don't compute coverage over lib/debug/ or lib/polyfill/      lib/!(debug|polyfill)/*.js: coverage,       Player is not matched by the above, so add it explicitly      lib/player.js: coverage,    },
     to avoid DISCONNECTED messages on Safari:    browserDisconnectTimeout: 10  1000,   10s to reconnect    browserDisconnectTolerance: 1,   max of 1 disconnect is OK    browserNoActivityTimeout: 5  60  1000,   disconnect after 5m silence    captureTimeout: 1  60  1000,   give up if startup takes 1m     https://support.saucelabs.com/customer/en/portal/articles/2440724
    client: {       don't capture the client's console logs      captureConsole: false,       |args| must be an array; pass a key-value map as the sole client       argument.      args: [{}],    },
     enable / disable colors in the output (reporters and logs)    colors: true,
     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR ||                      config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_WARN,
     do not execute tests whenever any file changes    autoWatch: false,
     do a single run of the tests on captured browsers and then quit    singleRun: true,
    coverageReporter: {      includeAllSources: true,      reporters: [        { type: text },      ],    },
    specReporter: {      suppressSkipped: true,    },  });
  if (flagPresent(html-coverage-report)) {     Wipe out any old coverage reports to avoid confusion.    var rimraf = require(rimraf);    rimraf.sync(coverage, {});   Like rm -rf
    config.set({      reporters: [ coverage, progress ],      coverageReporter: {        reporters: [          { type: html, dir: coverage },          { type: cobertura, dir: coverage, file: coverage.xml },        ],      },    });  }
  if (!flagPresent(quick)) {     If --quick is present, we don't serve integration tests.    var files = config.files;    files.push(test/**/*_integration.js);     We just modified the config in-place.  No need for config.set().  }
  var logLevel = getFlagValue(enable-logging);  if (logLevel !== null) {    if (logLevel === )      logLevel = 3;   INFO
    config.set({      reporters: [spec],    });     Setting |config.client| using config.set will remove the     |config.client.args| member.    config.client.captureConsole = true;    setClientArg(config, logLevel, logLevel);  }
  if (flagPresent(external)) {     Run Player integration tests against external assets.     Skipped by default.    setClientArg(config, external, true);  }
  if (flagPresent(drm)) {     Run Player integration tests against DRM license servers.     Skipped by default.    setClientArg(config, drm, true);  }
  if (flagPresent(quarantined)) {     Run quarantined tests which do not consistently pass.     Skipped by default.    setClientArg(config, quarantined, true);  }
  if (flagPresent(uncompiled)) {     Run Player integration tests with uncompiled code for debugging.    setClientArg(config, uncompiled, true);  }
  if (flagPresent(random)) {     Run tests in a random order.    setClientArg(config, random, true);
     If --seed was specified use that value, else generate a seed so that the     exact order can be reproduced if it catches an issue.    var seed = getFlagValue(seed) || new Date().getTime();    setClientArg(config, seed, seed);
    console.log(Using a random test order (--random) with --seed= + seed);  }
  if (flagPresent(specFilter)) {    setClientArg(config, specFilter, getFlagValue(specFilter));  }};
 Sets the value of an argument passed to the client.function setClientArg(config, name, value) {  config.client.args[0][name] = value;}
 Find a custom command-line flag that has a value (e.g. --option=12). Returns: * string value  --option=12 * empty string  --option= or --option * null          not presentfunction getFlagValue(name) {  var re = --()(?:=());  for (var i = 0; i < process.argv.length; i++) {    var match = re.exec(process.argv[i]);    if (match && match[1] == name) {      if (match[2] !== undefined)        return match[2];      else        return ;    }  }
  return null;}
 Find custom command-line flags.function flagPresent(name) {  return getFlagValue(name) !== null;}
 Construct framework plugins on-the-fly for arbitrary node modules. A call to this must be placed in the config in the 'plugins' array, and the module name must be added to the config in the 'frameworks' array.function frameworkPluginForModule(name) {   The framework injects files into the client which runs the tests.  var framework = function(files) {     Locate the main file for the node module.    var path = require(path);    var mainFile = path.resolve(require.resolve(name));
     Add a file entry to the list of files to be served.     This follows the same syntax as above in config.set({files: ...}).    files.unshift({      pattern: mainFile, included: true, served: true, watched: false    });  };
   The framework factory function takes one argument, which is the list of   files from the karma config.  framework.$inject = [config.files];
   This is the plugin interface to register a new framework.  Adding this to   the list of plugins makes the named module available as a framework.  That   framework then injects the module into the client.  var obj = {};  obj[framework: + name] = [factory, framework];  return obj;}"
"var castv2 = require(castv2-client)var debug = require(debug)(chromecasts)var events = require(events)var get = require(simple-get)var mdns = require(multicast-dns)var mime = require(mime)var parseString = require(xml2js).parseString
var SSDPtry {  SSDP = require(node-ssdp).Client} catch (err) {  SSDP = null}
var thunky = require(thunky)var url = require(url)
var noop = function () {}var toMap = function (url) {  return typeof url === string ? {url: url} : url}var toSubtitles = function (url, i) {  if (typeof url !== string) return url  return {    trackId: i + 1,    type: TEXT,    trackContentId: url,    trackContentType: text/vtt,    name: English,    language: en-US,    subtype: SUBTITLES  }}
module.exports = function () {  var dns = mdns()  var that = new events.EventEmitter()  var casts = {}  var ssdp = SSDP ? new SSDP({logLevel: process.env.DEBUG ? trace : false}) : null
  that.players = []
  var emit = function (cst) {    if (!cst || !cst.host || cst.emitted) return    cst.emitted = true
    var player = new events.EventEmitter()
    var connect = thunky(function reconnect (cb) {      var client = new castv2.Client()
      client.on(error, function (err) {        player.emit(error, err)      })
      client.on(close, function () {        connect = thunky(reconnect)      })
      client.client.on(close, function () {        connect = thunky(reconnect)      })
      client.connect(player.host, function (err) {        if (err) return cb(err)        player.emit(connect)
        client.getSessions(function (err, sess) {          if (err) return cb(err)
          var session = sess[0]          if (session && session.appId === castv2.DefaultMediaReceiver.APP_ID) {            client.join(session, castv2.DefaultMediaReceiver, ready)          } else {            client.launch(castv2.DefaultMediaReceiver, ready)          }        })
        function ready (err, p) {          if (err) return cb(err)
          player.emit(ready)
          p.on(close, function () {            connect = thunky(reconnect)          })
          p.on(status, function (status) {            player.emit(status, status)          })
          cb(null, p)        }      })    })
    var connectClient = thunky(function reconnectClient (cb) {      var client = new castv2.Client()
      client.on(error, function () {        connectClient = thunky(reconnectClient)      })
      client.on(close, function () {        connectClient = thunky(reconnectClient)      })
      client.connect(player.host, function (err) {        if (err) return cb(err)        cb(null, client)      })    })
    player.name = cst.name    player.host = cst.host
    player.client = function (cb) {      connectClient(cb)    }
    player.chromecastStatus = function (cb) {      connectClient(function (err, client) {        if (err) return cb(err)        client.getStatus(cb)      })    }
    player.play = function (url, opts, cb) {      if (typeof opts === function) return player.play(url, null, opts)      if (!opts) opts = {}      if (!url) return player.resume(cb)      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)
        var media = {          contentId: url,          contentType: opts.type || mime.lookup(url, video/mp4),          streamType: opts.streamType || BUFFERED,          tracks: [].concat(opts.subtitles || []).map(toSubtitles),          textTrackStyle: opts.textTrackStyle,          metadata: opts.metadata || {            type: 0,            metadataType: 0,            title: opts.title || ,            images: [].concat(opts.images || []).map(toMap)          }        }
        var autoSubtitles = opts.autoSubtitles        if (autoSubtitles === false) autoSubtitles = 0        if (autoSubtitles === true) autoSubtitles = 1
        var playerOptions = {          autoplay: opts.autoPlay !== false,          currentTime: opts.seek,          activeTrackIds: opts.subtitles && (autoSubtitles === 0 ? [] : [autoSubtitles || 1])        }
        p.load(media, playerOptions, cb)      })    }
    player.resume = function (cb) {      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)        p.play()      })    }
    player.pause = function (cb) {      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)        p.pause(cb)      })    }
    player.stop = function (cb) {      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)        p.stop(cb)      })    }
    player.status = function (cb) {      connect(function (err, p) {        if (err) return cb(err)        p.getStatus(cb)      })    }
    player.subtitles = function (id, cb) {      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)
        player.request({          type: EDIT_TRACKS_INFO,          activeTrackIds: id ? [id === true ? 1 : id] : []        }, cb)      })    }
    player.volume = function (vol, cb) {      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)
        player.request({          type: SET_VOLUME,          volume: vol === 0 ? { muted: true } : { level: vol, muted: false }        }, cb)      })    }
    player.request = function (data, cb) {      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)        p.media.sessionRequest(data, cb)      })    }
    player.seek = function (time, cb) {      if (!cb) cb = noop      connect(function (err, p) {        if (err) return cb(err)        p.seek(time, cb)      })    }
    that.players.push(player)    that.emit(update, player)  }
  dns.on(response, function (response) {    response.answers.forEach(function (a) {      if (a.type === PTR && a.name === _googlecast._tcp.local) {        var name = a.data.replace(._googlecast._tcp.local, )        if (!casts[name]) casts[name] = {name: name, host: null}      }    })
    var onanswer = function (a) {      debug(got answer %j, a)
      var name = a.name.replace(.local, )      if (a.type === A && casts[name] && !casts[name].host) {        casts[name].host = a.data        emit(casts[name])      }    }
    response.additionals.forEach(onanswer)    response.answers.forEach(onanswer)  })
  if (ssdp) {    ssdp.on(response, function (headers, statusCode, info) {      if (!headers.LOCATION) return
      get.concat(headers.LOCATION, function (err, res, body) {        if (err) return        parseString(body.toString(), {explicitArray: false, explicitRoot: false},          function (err, service) {            if (err) return            if (!service.device) return            if (service.device.manufacturer !== Google Inc.) return
            debug(device %j, service.device)
            var name = service.device.friendlyName
            if (!name) return
            var host = url.parse(service.URLBase).hostname
            if (!casts[name]) {              casts[name] = {name: name, host: host}              return emit(casts[name])            }
            if (casts[name] && !casts[name].host) {              casts[name].host = host              emit(casts[name])            }          })      })    })  }
  that.update = function () {    debug(querying mdns and ssdp)    if (ssdp) ssdp.search(urn:dial-multiscreen-org:device:dial:1)    dns.query(_googlecast._tcp.local, PTR)  }
  that.destroy = function () {    dns.destroy()  }
  that.update()
  return that}"
"var torrents = require(webtorrent)var request = require(request)var duplex = require(duplexify)var ytdl = require(ytdl-core)var events = require(events)var path = require(path)var fs = require(fs)var vtt = require(srt-to-vtt)var concat = require(concat-stream)
var noop = function () {}
module.exports = function () {  var that = new events.EventEmitter()
  that.entries = []
  var onmagnet = function (link, cb) {    console.log(torrent  + link)
    var engine = torrents()    var subtitles = {}
    engine.add(link, {      announce: [ wss://tracker.webtorrent.io ]    }, function (torrent) {      console.log(torrent ready)
      torrent.files.forEach(function (f) {        if ((vttsrt)i.test(f.name)) {          subtitles[f.name] = f;        }      })
      torrent.files.forEach(function (f) {        f.downloadSpeed = torrent.downloadSpeed()        if ((mp4mkvmp3)i.test(f.name)) {          f.select()          f.id = that.entries.push(f) - 1
          var basename = f.name.substr(0, f.name.lastIndexOf(.))          var subtitle = subtitles[basename + .srt] || subtitles[basename + .vtt]          if (subtitle) {             subtitle.createReadStream().pipe(vtt()).pipe(concat(function(data) {               f.subtitles = data            }))          }        }
      })
      setInterval(function () {        console.log(torrent.downloadSpeed() +  ( + torrent.swarm.wires.length + ))      }, 1000)
      that.emit(update)      cb()    })  }
  var ontorrent = function (link, cb) {    fs.readFile(link, function (err, buf) {      if (err) return cb(err)      onmagnet(buf, cb)    })  }
  var onyoutube = function (link, cb) {    var file = {}    var url = https:.test(link) ? link : https: + link
    getYoutubeData(function (err, data) {      if (err) return cb(err)      var fmt = data.fmt      var info = data.info      request({method: HEAD, url: fmt.url}, function (err, resp, body) {        if (err) return cb(err)        var len = resp.headers[content-length]        if (!len) return cb(new Error(no content-length on response))        file.length = +len        file.name = info.title
        file.createReadStream = function (opts) {          if (!opts) opts = {}           fetch this for every range request           TODO try and avoid doing this call twice the first time          getYoutubeData(function (err, data) {            if (err) return cb(err)            var vidUrl = data.fmt.url            if (opts.start || opts.end) vidUrl += &range= + ([opts.start || 0, opts.end || len].join(-))            stream.setReadable(request(vidUrl))          })
          var stream = duplex()          return stream        }        file.id = that.entries.push(file) - 1        that.emit(update)        cb()      })    })
    function getYoutubeData (cb) {      ytdl.getInfo(url, function (err, info) {        if (err) return cb(err)
        var vidFmt        var formats = info.formats
        formats.sort(function sort (a, b) {          return +a.itag - +b.itag        })
        var vidFmt        formats.forEach(function (fmt) {           prefer webm          if (fmt.itag === 46) return vidFmt = fmt          if (fmt.itag === 45) return vidFmt = fmt          if (fmt.itag === 44) return vidFmt = fmt          if (fmt.itag === 43) return vidFmt = fmt
           otherwise h264          if (fmt.itag === 38) return vidFmt = fmt          if (fmt.itag === 37) return vidFmt = fmt          if (fmt.itag === 22) return vidFmt = fmt          if (fmt.itag === 18) return vidFmt = fmt        })
        if (!vidFmt) return cb (new Error(No suitable video format found))
        cb(null, {info: info, fmt: vidFmt})      })    }  }
  var onfile = function (link, cb) {    var file = {}
    fs.stat(link, function (err, st) {      if (err) return cb(err)
      file.length = st.size      file.name = path.basename(link)      file.createReadStream = function (opts) {        return fs.createReadStream(link, opts)      }
      file.id = that.entries.push(file) - 1
      var ondone = function () {        that.emit(update)        cb()      }      var basename = link.substr(0, link.lastIndexOf(.))      var extensions = [srt, vtt]      var next = function () {        var ext = extensions.shift()        if (!ext) return ondone()
        fs.exists(basename + . + ext, function(exists) {          if (!exists) return next()          fs.createReadStream(basename + . + ext).pipe(vtt()).pipe(concat(function(data) {            file.subtitles = data            ondone()          }))        })      }      next()    })  }
  var onhttplink = function (link, cb) {    var file = {}
    file.name = link.lastIndexOf(/) > -1 ? link.split(/).pop() : link
    file.createReadStream = function (opts) {      if (!opts) opts = {}
      if (opts && (opts.start || opts.end)) {        var rs = bytes= + (opts.start || 0) + - + (opts.end || file.length || )        return request(link, {headers: {Range: rs}})      }
      return request(link)    }
     first, get the head for the content length.     IMPORTANT: servers without HEAD will not work.    request.head(link, function (err, response) {      if (err) return cb(err)      if (!2.test(response.statusCode)) return cb(new Error(request failed))
      file.length = Number(response.headers[content-length])      file.id = that.entries.push(file) - 1      that.emit(update)      cb()    })  }
  var onipfslink = function (link, cb) {    if (link[0] != /) link = / + link  / may be stripped in add
    var local = localhost:8080  todo: make this configurable    var gateway = gateway.ipfs.io    var file = {}
     first, try the local http gateway    var u = http:// + local + link    console.log(trying local ipfs gateway:  + u)    onhttplink(u, function (err) {      if (!err) return cb()  done.
       error? ok try fuse... maybe the gateway's broken.      console.log(trying mounted ipfs fs (just in case))      onfile(link, function (err) {        if (!err) return cb()  done.
         worst case, try global ipfs gateway.        var u = http:// + gateway + link        console.log(trying local ipfs gateway:  + u)        onhttplink(u, cb)      })    })  }
  that.selected = null
  that.deselect = function () {    that.selected = null    that.emit(deselect)  }
  that.selectNext = function (loop) {    if (!that.entries.length) return null    if (!that.selected) return that.select(0)    if (that.repeatingOne && !loop) return that.select(that.selected.id)    if (that.selected.id === that.entries.length - 1) {      if (that.repeating || loop) return that.select(0)      else return null    }    return that.select(that.selected.id + 1)  }
  that.selectPrevious = function (loop) {    if (!that.entries.length) return null    if (!that.selected) return that.select(that.entries.length - 1)    if (that.selected.id === 0) {      if (that.repeating || loop) return that.select(that.entries.length - 1)      else return null    }    return that.select(that.selected.id - 1)  }
  that.select = function (id) {    that.selected = that.get(id)    that.emit(select)    return that.selected  }
  that.get = function (id) {    return that.entries[id]  }
  that.add = function (link, cb) {    link = link.replace(playback://, ).replace(playback:, )  strip playback protocol    if (!cb) cb = noop    if (magnet:.test(link)) return onmagnet(link, cb)    if (torrenti.test(link)) return ontorrent(link, cb)    if (youtubecomwatchyoutubei.test(link)) return onyoutube(link, cb)    if ((ipfsipns)i.test(link)) return onipfslink(link, cb)    if (https:i.test(link)) return onhttplink(link, cb)    onfile(link, cb)  }
  that.repeating = false  that.repeatingOne = false
  that.repeat = function () {    that.repeating = true    that.repeatingOne = false  }
  that.repeatOne = function () {    that.repeating = true    that.repeatingOne = true  }
  that.unrepeat = function () {    that.repeating = false    that.repeatingOne = false  }
  return that}"
"var events = require(events)var network = require(network-address)
module.exports = function ($video) {  var that = new events.EventEmitter()  var atEnd = false  var lastUrl = null
  that.setMaxListeners(0)
  that.width = 0  that.height = 0  that.element = $video
  var chromecast = null  var chromecastTime = 0  var chromecastOffset = 0  var chromecastSubtitles = 1  var interval = null
  var onerror = function () {    if (chromecast) chromecast.removeListener(error, onerror)    that.chromecast(null)  }
  var onmetadata = function (err, status) {    if (err) return onerror(err)    if (chromecastTime) chromecastOffset = 0    chromecastTime = status.currentTime    chromecastSubtitles = 1    that.duration = status.media.duration    that.emit(metadata)
    clearInterval(interval)    interval = setInterval(function () {      chromecast.status(function (err, status) {        if (err) return onerror(err)
        if (!status) {          chromecastOffset = 0          clearInterval(interval)          atEnd = true          that.playing = false          that.emit(pause)          that.emit(end)          return        }
        if (chromecastTime) chromecastOffset = 0        chromecastTime = status.currentTime      })    }, 1000)  }
  that.casting = false  that.chromecast = function (player) {    chromecastOffset = chromecast ? 0 : $video.currentTime    clearInterval(interval)    if (chromecast && that.playing) chromecast.stop()    chromecast = player    that.casting = player    if (chromecast) chromecast.on(error, onerror)    if (!that.playing) return    media.play(lastUrl, that.casting ? chromecastOffset : chromecastTime)  }
  $video.addEventListener(seeked, function () {    if (chromecast) return    that.emit(seek)  }, false)
  $video.addEventListener(ended, function () {    if (chromecast) return    atEnd = true    that.playing = false    that.emit(pause)    that.emit(end)  }, false)
  $video.addEventListener(loadedmetadata, function () {    if (chromecast) return    that.width = $video.videoWidth    that.height =  $video.videoHeight    that.ratio = that.width / that.height    that.duration = $video.duration    that.emit(metadata)  }, false)
  that.time = function (time) {    atEnd = false    if (chromecast) {      if (arguments.length) {        chromecastOffset = 0        chromecast.seek(time)      }      return chromecastOffset || chromecastTime    }    if (arguments.length) $video.currentTime = time    return $video.currentTime  }
  that.playing = false
  that.play = function (url, time) {    if (!url && !lastUrl) return    var changed = url && lastUrl !== url    if (changed) subs = null    if (chromecast) {      $video.innerHTML =   clear      $video.pause()      $video.load()      if (url) lastUrl = url      else url = lastUrl      atEnd = false      if (url) {        var mediaUrl = url.replace(127.0.0.1, network())        var subsUrl = mediaUrl.replace((:), $1/subtitles)        var subsList = []        for (var i = 0; i < 100; i++) subsList.push(subsUrl)        chromecast.play(mediaUrl, {title: Playback, seek: time || 0, subtitles: subsList, autoSubtitles: !!subs }, onmetadata)      } else {        chromecast.resume()      }    } else {      if (atEnd && url === lastUrl) that.time(0)      if (!url) {        $video.play()      } else {        lastUrl = url        atEnd = false        $video.innerHTML =   clear        var $src = document.createElement(source)        $src.setAttribute(src, url)        $src.setAttribute(type, video/mp4)        $video.appendChild($src)        if (changed) $video.load()        $video.play()        if (time) $video.currentTime = time      }    }    that.playing = true    that.emit(play)  }
  that.pause = function () {    if (chromecast) chromecast.pause()    else $video.pause()    that.playing = false    that.emit(pause)  }
  var subs = null  that.subtitles = function (buf) {    if (!arguments.length) return subs    subs = buf
    if (chromecast) {      if (!buf) chromecast.subtitles(false)      else chromecast.subtitles(++chromecastSubtitles)      return    }
    if ($video.querySelector(track)) $video.removeChild($video.querySelector(track))    if (!buf) return null    var $track = document.createElement(track)    $track.setAttribute(default, default)    $track.setAttribute(src, data:text/vtt;base64,+buf.toString(base64))    $track.setAttribute(label, Subtitles)    $track.setAttribute(kind, subtitles)    $video.appendChild($track)    that.emit(subtitles, buf)    return buf  }
  that.volume = function (value) {    $video.volume = value  }
  that.playbackRate = function (value) {    $video.playbackRate = value  }
  return that}"
"var $ = require(dombo)
module.exports = function (elem, timeout, className) {  var max = (timeout / 250) | 0  var overMovie = false  var hiding = false  var moving = 0  var tick = 0  var mousedown = false
  var update = function () {    if (hiding) {      $(body).removeClass(className)      hiding = false    }  }
  $(elem).on(mouseover, function () {    overMovie = true    update()  })
  $(elem).on(mouseout, function () {    overMovie = false  })
  $(elem).on(mousedown, function (e) {    mousedown = true    moving = tick    update()  })
  $(elem).on(mouseup, function (e) {    mousedown = false    moving = tick  })
  $(window).on(mousemove, function (e) {    moving = tick    update()  })
  setInterval(function () {    tick++    if (!overMovie) return    if (tick - moving < max || mousedown) return    hiding = true    $(body).addClass(className)  }, 250)}"
"var request = require(request)var drop = require(drag-and-drop-files)var mdns = require(multicast-dns)()var concat = require(concat-stream)var vtt = require(srt-to-vtt)var ipc = require(electron).ipcRenderervar remote = require(remote)var Menu = remote.require(menu)var MenuItem = remote.require(menu-item)var http = require(http)var rangeParser = require(range-parser)var pump = require(pump)var fs = require(fs)var eos = require(end-of-stream)var minimist = require(minimist)var JSONStream = require(JSONStream)var network = require(network-address)var chromecasts = require(chromecasts)()var $ = require(dombo)var titlebar = require(titlebar)()var clipboard = require(clipboard)var player = require(./player)var playlist = require(./playlist)var mouseidle = require(./mouseidle)
var argv = minimist(JSON.parse(window.location.toString().split(#)[1]), {  alias: {follow: f},  boolean: [follow]})
var printError = function (err) {  if (err) console.log(err)}
var onsubs = function (data) {  media.subtitles(data)}
ipc.on(add-to-playlist, function (event, links) {  links.forEach(function (link) {    if ((vttsrt)i.test(link)) {      fs.createReadStream(link).pipe(vtt()).pipe(concat(onsubs))      return    }
    list.add(link, printError)  })})
$(document).on(paste, function (e) {  ipc.emit(add-to-playlist, e.clipboardData.getData(text).split())})
var media = player($(#player)[0])var list = playlist()
if (process.platform !== win32) {  titlebar.appendTo(#titlebar)}
drop($(body)[0], function (files) {  for (var i = 0; i < files.length; i++) {    if ((vttsrt)i.test(files[i].path)) {      fs.createReadStream(files[i].path).pipe(vtt()).pipe(concat(onsubs))      return    }
    list.add(files[i].path, printError)  }})
var videoDown = falsevar videoOffsets = [0, 0]
$(#idle).on(mousedown, function (e) {  videoDown = true  videoOffsets = [e.clientX, e.clientY]})
$(#idle).on(mouseup, function () {  videoDown = false})
$(#idle).on(mousemove, function (e) {  if (videoDown) remote.getCurrentWindow().setPosition(e.screenX - videoOffsets[0], e.screenY - videoOffsets[1])})
var onTop = false
$(window).on(contextmenu, function (e) {  e.preventDefault()  videoDown = false
  var menu = new Menu()
  menu.append(new MenuItem({    label: Always on top,    type: checkbox,    checked: onTop,    click: function () {      onTop = !onTop      remote.getCurrentWindow().setAlwaysOnTop(onTop)    }  }))
  menu.append(new MenuItem({    label: Paste link,    click: function () {      ipc.emit(add-to-playlist, clipboard.readText().split())    }  }))
  if (media.subtitles()) {    menu.append(new MenuItem({      label: Remove subtitles,      click: function () {        media.subtitles(null)      }    }))  }
  menu.popup(remote.getCurrentWindow())})
$(body).on(mouseover, function () {  if (onTop) ipc.send(focus)})
var isFullscreen = false
var onfullscreentoggle = function (e) {  if (!isFullscreen && e.shiftKey) {    ipc.send(resize, {      width: media.width,      height: media.height,      ratio: media.ratio    })    return  }
  var $icon = $(#controls-fullscreen .js-icon)  if (isFullscreen) {    isFullscreen = false    $(#titlebar)[0].style.display = block    $icon.removeClass(ion-arrow-shrink)    $icon.addClass(ion-arrow-expand)    ipc.send(exit-full-screen)  } else {    isFullscreen = true    $(#titlebar)[0].style.display = none    $icon.removeClass(ion-arrow-expand)    $icon.addClass(ion-arrow-shrink)    ipc.send(enter-full-screen)  }}
var onplaytoggle = function () {  if (media.playing) media.pause()  else media.play()}
var onnexttrack = function () {  var shouldLoop = true  list.selectNext(shouldLoop)}
var onprevioustrack = function () {  var shouldLoop = true  list.selectPrevious(shouldLoop)}
var onrepeatcycle = function () {  var $controlsRepeat = $(#controls-repeat)  if (!list.repeating) {    $controlsRepeat.addClass(repeating)    list.repeat()    return  }
  if (!list.repeatingOne) {    $controlsRepeat.addClass(one)    list.repeatOne()    return  }
  $controlsRepeat.removeClass(repeating)  $controlsRepeat.removeClass(one)  list.unrepeat()}
$(#idle).on(dblclick, onfullscreentoggle)$(#controls-fullscreen).on(click, onfullscreentoggle)
$(#controls-timeline).on(click, function (e) {  var time = e.pageX / $(#controls-timeline)[0].offsetWidth  media.duration  media.time(time)})
function updateTimelineTooltip(e) {  var tooltip = $(#controls-timeline-tooltip)[0]  var percentage = e.pageX / $(#controls-timeline)[0].offsetWidth  var time =  formatTime(percentage  media.duration)  tooltip.innerHTML = time  tooltip.style.left = (e.pageX - tooltip.offsetWidth / 2) + px}
$(#controls-timeline).on(mousemove, function (e) {  updateTimelineTooltip(e)})
$(#controls-timeline).on(mouseover, function (e) {  var tooltip = $(#controls-timeline-tooltip)[0]  tooltip.style.opacity = 1  updateTimelineTooltip(e)})
$(#controls-timeline).on(mouseout, function (e) {  var tooltip = $(#controls-timeline-tooltip)[0]  tooltip.style.opacity = 0})
var isVolumeSliderClicked = falsevar isPbrateSliderClicked = false
function updateAudioVolume(value) {  media.volume(value)}
function updateVolumeSlider(volume) {  var val = volume.value  100  volume.style.background = -webkit-gradient(linear, left top, right top, color-stop( + val.toString() + %, #31A357), color-stop( + val.toString() + %, #727374))}
function updatePlaybackRate(value) {  media.playbackRate(value)}
function updatePlaybackRateSlider(volume) {  var min = 0.5  var max = 4  var scaled = (volume.value - min) / (max - min)  var val = scaled  100  volume.style.background = -webkit-gradient(linear, left top, right top, color-stop( + val.toString() + %, #31A357), color-stop( + val.toString() + %, #727374))}
$(#controls-volume-slider).on(mousemove, function (e) {  if (isVolumeSliderClicked) {    var volume = $(#controls-volume-slider)[0]    updateAudioVolume(volume.value)    updateVolumeSlider(volume)  }})
$(#controls-volume-slider).on(mousedown, function (e) {  isVolumeSliderClicked = true})
$(#controls-volume-slider).on(mouseup, function (e) {  var volume = $(#controls-volume-slider)[0]  updateAudioVolume(volume.value)  updateVolumeSlider(volume)  isVolumeSliderClicked = false})
$(#controls-pbrate-slider).on(mousemove, function (e) {  if (isPbrateSliderClicked) {    var volume = $(#controls-pbrate-slider)[0]    updatePlaybackRate(volume.value)    updatePlaybackRateSlider(volume)  }})
$(#controls-pbrate-slider).on(mousedown, function (e) {  isPbrateSliderClicked = true})
$(#controls-pbrate-slider).on(mouseup, function (e) {  var volume = $(#controls-pbrate-slider)[0]  updatePlaybackRate(volume.value)  updatePlaybackRateSlider(volume)  isPbrateSliderClicked = false})
$(document).on(keydown, function (e) {  if (e.keyCode === 27 && isFullscreen) return onfullscreentoggle(e)  if (e.keyCode === 13 && e.metaKey) return onfullscreentoggle(e)  if (e.keyCode === 13 && e.shiftKey) return onfullscreentoggle(e)  if (e.keyCode === 32) return onplaytoggle(e)
  if ($(#controls-playlist).hasClass(selected)) $(#controls-playlist).trigger(click)  if ($(#controls-chromecast).hasClass(selected)) $(#controls-chromecast).trigger(click)})
mouseidle($(#idle)[0], 3000, hide-cursor)
list.on(select, function () {  $(#controls-name)[0].innerText = list.selected.name  media.play(http://127.0.0.1: + server.address().port + / + list.selected.id)  if (list.selected.subtitles) onsubs(list.selected.subtitles)  updatePlaylist()})
var updatePlaylist = function () {  var html = 
  list.entries.forEach(function (entry, i) {    html += <div class=""playlist-entry  + (i % 2 ? odd  : ) + (list.selected === entry ? selected  : ) + "" data-index="" + i + "" data-id="" + entry.id + ""> +      <span> + entry.name + </span><span class=""status""></span></div>  })
  $(#playlist-entries)[0].innerHTML = html}
var updateChromecast = function () {  var html = 
  chromecasts.players.forEach(function (player, i) {    html += <div class=""chromecast-entry  + (i % 2 ? odd  : ) + (media.casting === player ? selected  : ) + "" data-index="" + i + "" data-id="" + i + ""> +      <span> + player.name + </span>  })
  $(#chromecast-entries)[0].innerHTML = html}
chromecasts.on(update, updateChromecast)
var updateSpeeds = function () {  $(#player-downloadspeed)[0].innerText =   list.entries.forEach(function (entry, i) {    if (!entry.downloadSpeed) return
    $(.playlist-entry[data-index="" + i + ""] .status).addClass(ion-loop)
    var kilobytes = entry.downloadSpeed() / 1024    var megabytes = kilobytes / 1024    var text = megabytes > 1 ? megabytes.toFixed(1) +  mb/s : Math.floor(kilobytes) +  kb/s
    if (list.selected === entry) $(#player-downloadspeed)[0].innerText = text  })}setInterval(updateSpeeds, 750)
list.on(update, updatePlaylist)
list.once(update, function () {  list.select(0)})
var popupSelected = function () {  return $(#controls-playlist).hasClass(selected) || $(#controls-chromecast).hasClass(selected)}
var closePopup = function (e) {  if (e && (e.target === $(#controls-playlist .js-icon)[0] || e.target === $(#controls-chromecast .chromecast)[0])) return  $(#popup)[0].style.opacity = 0  $(#controls-playlist).removeClass(selected)  $(#controls-chromecast).removeClass(selected)}
$(#controls).on(click, closePopup)$(#idle).on(click, closePopup)
$(#playlist-entries).on(click, .playlist-entry, function (e) {  var id = Number(this.getAttribute(data-id))  list.select(id)})
$(#chromecast-entries).on(click, .chromecast-entry, function (e) {  var id = Number(this.getAttribute(data-id))  var player = chromecasts.players[id]
  if (media.casting === player) {    $(body).removeClass(chromecasting)    media.chromecast(null)    return updateChromecast()  }
  $(body).addClass(chromecasting)  media.chromecast(player)  updateChromecast()})
var updatePopup = function () {  if (popupSelected()) {    $(#popup)[0].style.display = block    $(#popup)[0].style.opacity = 1  } else {    $(#popup)[0].style.opacity = 0  }}
$(#controls-chromecast).on(click, function (e) {  if ($(#controls-chromecast).hasClass(selected)) {    closePopup()    return  }
  $(#popup)[0].className = chromecast  $(#controls .controls-secondary .selected).removeClass(selected)  $(#controls-chromecast).addClass(selected)  chromecasts.update()  updatePopup()})
$(#controls-playlist).on(click, function (e) {  if ($(#controls-playlist).hasClass(selected)) {    closePopup()    return  }
  $(#popup)[0].className = playlist  $(#controls .controls-secondary .selected).removeClass(selected)  $(#controls-playlist).addClass(selected)  updatePopup()})
$(#playlist-add-media).on(click, function () {  ipc.send(open-file-dialog)})
$(#popup).on(transitionend, function () {  if (!popupSelected()) $(#popup)[0].style.display = none})
titlebar.on(close, function () {  ipc.send(close)})
titlebar.on(minimize, function () {  ipc.send(minimize)})
titlebar.on(maximize, function () {  ipc.send(maximize)})
titlebar.on(fullscreen, onfullscreentoggle)
var appmenu_template = [  {    label: Playback,    submenu: [      {        label: About Playback,        click: function() { ipc.send(open-url-in-external, https://mafintosh.github.io/playback/) }      },      {        type: separator      },      {        label: Quit,        accelerator: Command+Q,        click: function() { ipc.send(close) }      }    ]  },  {    label: File,    submenu: [      {        label: Add media,        accelerator: Command+O,        click: function() { ipc.send(open-file-dialog) }      },      {        label: Add link from clipboard,        accelerator: CommandOrControl+V,        click: function () { ipc.emit(add-to-playlist, clipboard.readText().split()) }      }    ]  },  {    label: Window,    submenu: [      {        label: Minimize,        accelerator: Command+M,        click: function() { ipc.send(minimize) }      },      {        label: Toggle Full Screen,        accelerator: Command+Enter,        click: onfullscreentoggle      }    ]  },  {    label: Help,    submenu: [      {        label: Report Issue,        click: function() { ipc.send(open-url-in-external, https://github.com/mafintosh/playback/issues) }      },      {        label: View Source Code on GitHub,        click: function() { ipc.send(open-url-in-external, https://github.com/mafintosh/playback) }      },      {        type: separator      },      {        label: Releases,        click: function() { ipc.send(open-url-in-external, https://github.com/mafintosh/playback/releases) }      }    ]  }]var appmenu = Menu.buildFromTemplate(appmenu_template)Menu.setApplicationMenu(appmenu)
var formatTime = function (secs) {  var hours = (secs / 3600) | 0  var mins = ((secs - hours  3600) / 60) | 0  secs = (secs - (3600  hours + 60  mins)) | 0  if (mins < 10) mins = 0 + mins  if (secs < 10) secs = 0 + secs  return (hours ? hours + : : ) + mins + : + secs}
var updateIntervalmedia.on(metadata, function () {   TODO: comment in again when not quirky   if (!isFullscreen) {     ipc.send('resize', {       width: media.width,       height: media.height,       ratio: media.ratio     })   }
  $(#controls-main)[0].style.display = block  $(#controls-time-total)[0].innerText = formatTime(media.duration)  $(#controls-time-current)[0].innerText = formatTime(media.time())
  clearInterval(updateInterval)  updateInterval = setInterval(function () {    $(#controls-timeline-position)[0].style.width = (100  (media.time() / media.duration)) + %    $(#controls-time-current)[0].innerText = formatTime(media.time())  }, 250)})
$(#controls-play).on(click, onplaytoggle)$(#controls-repeat).on(click, onrepeatcycle)ipc.on(media-play-pause, onplaytoggle)ipc.on(media-next-track, onnexttrack)ipc.on(media-previous-track, onprevioustrack)
media.on(end, function () {  ipc.send(allow-sleep)  list.selectNext()})
media.on(play, function () {  ipc.send(prevent-sleep)  $(#splash).toggleClass(hidden, !media.casting)  $(#player).toggleClass(hidden, media.casting)  $(#controls-play .js-icon).removeClass(ion-play)  $(#controls-play .js-icon).addClass(ion-pause)})
media.on(pause, function () {  ipc.send(allow-sleep)  $(#controls-play .js-icon).removeClass(ion-pause)  $(#controls-play .js-icon).addClass(ion-play)})
var server = http.createServer(function (req, res) {  if (req.headers.origin) res.setHeader(Access-Control-Allow-Origin, req.headers.origin)
  if (req.url === /subtitles) {    var buf = media.subtitles()
    if (buf) {      res.setHeader(Content-Type, text/vtt; charset=utf-8)      res.setHeader(Content-Length, buf.length)      res.end(buf)    } else {      res.statusCode = 404      res.end()    }  }
  if (req.url === /follow) {  TODO: do not hardcode /0    if (!list.selected) return res.end()    var stringify = JSONStream.stringify()
    var onseek = function () {      stringify.write({type: seek, time: media.time() })    }
    var onsubs = function (data) {      stringify.write({type: subtitles, data: data.toString(base64)})    }
    stringify.pipe(res)    stringify.write({type: open, url: http:// + network() + : + server.address().port + / + list.selected.id, time: media.time() })
    media.on(subtitles, onsubs)    media.on(seek, onseek)    eos(res, function () {      media.removeListener(subtitles, onsubs)      media.removeListener(seek, onseek)    })    return  }
  var id = Number(req.url.slice(1))  var file = list.get(id)
  if (!file) {    res.statusCode = 404    res.end()    return  }
  var range = req.headers.range && rangeParser(file.length, req.headers.range)[0]
  res.setHeader(Accept-Ranges, bytes)  res.setHeader(Content-Type, video/mp4)
  if (!range) {    res.setHeader(Content-Length, file.length)    if (req.method === HEAD) return res.end()    pump(file.createReadStream(), res)    return  }
  res.statusCode = 206  res.setHeader(Content-Length, range.end - range.start + 1)  res.setHeader(Content-Range, bytes  + range.start + - + range.end + / + file.length)  if (req.method === HEAD) return res.end()  pump(file.createReadStream(range), res)})
server.listen(0, function () {  console.log(Playback server running on port  + server.address().port)
  argv._.forEach(function (file) {    if (file) list.add(file, printError)  })
  if (argv.follow) {    mdns.on(response, function onresponse(response) {      response.answers.forEach(function (a) {        if (a.name !== playback) return        clearInterval(interval)        mdns.removeListener(response, onresponse)
        var host = a.data.target + : + a.data.port
        request(http:// + host + /follow).pipe(JSONStream.parse()).on(data, function (data) {          if (data.type === open) {            media.play(data.url)            media.time(data.time)          }
          if (data.type === seek) {            media.time(data.time)          }
          if (data.type === subtitles) {            media.subtitles(data.data)          }        })      })    })
    var query = function () {      mdns.query({        questions: [{          name: playback,          type: SRV        }]      })    }
    var interval = setInterval(query, 5000)    query()  } else {    mdns.on(query, function (query) {      var valid = query.questions.some(function (q) {        return q.name === playback      })
      if (!valid) return
      mdns.respond({        answers: [{          type: SRV,          ttl: 5,          name: playback,          data: {port: server.address().port, target: network()}        }]      })    })  }
  setTimeout(function () {    ipc.send(ready)  }, 10)})
var volumeSlider = $(#controls-volume-slider)[0]volumeSlider.setAttribute(value, 0.5)volumeSlider.setAttribute(min, 0)volumeSlider.setAttribute(max, 1)volumeSlider.setAttribute(step, 0.05)updateAudioVolume(0.5)updateVolumeSlider(volumeSlider)
var pbrateSlider = $(#controls-pbrate-slider)[0]pbrateSlider.setAttribute(value, 1)pbrateSlider.setAttribute(min, 0.5)pbrateSlider.setAttribute(max, 4)pbrateSlider.setAttribute(step, 0.25)updatePlaybackRate(1)updatePlaybackRateSlider(pbrateSlider)"
"import webpack from webpack
export default {  entry: [    babel-polyfill,    ./src/index.js  ],
  output: {    path: ./dist,    filename: index.js,    chunkFilename: [name].js  },
  module: {    rules: [      { test: js, exclude: node_modules, loader: babel-loader },      { test: css, loader: style-loader!css-loader!postcss-loader },      { test: json, loader: json }    ]  },
  plugins: [     https://github.com/postcss/postcss-loader/issues/99    new webpack.LoaderOptionsPlugin({      test: css,      options: {        postcss: (webpackInstance) => [          require(postcss-import)({ addDependencyTo: webpackInstance }),          require(precss)()        ],        context: __dirname,      },    }),    ...process.env.NODE_ENV === production ? [      new webpack.LoaderOptionsPlugin({ minimize: false, debug: false }),      new webpack.optimize.DedupePlugin(),      new webpack.optimize.UglifyJsPlugin({        compress: {          warnings: false,          screw_ie8: true,          sequences: true,          dead_code: true,          drop_debugger: true,          comparisons: true,          conditionals: true,          evaluate: true,          booleans: true,          loops: true,          unused: true,          hoist_funs: true,          if_return: true,          join_vars: true,          cascade: true,          drop_console: true        },        output: {          comments: false        }      })    ] : [],  ]}"
"const electron = require(electron)const { resolve } = require(path)const { execSync } = require(child_process)
const tryCatch = require(./src/try-catch)
const { app } = electronconst { BrowserWindow } = electron
 enable chrome dev-tools when builded require('electron-debug')({ enabled: true, showDevTools: true })
let win
const createWindow = () => {  win = new BrowserWindow({ width: 800, height: 800 })  win.maximize()  win.loadURL(file:///index.html)
   open external URLs into default browser  win.webContents.on(new-window, (e, url) => {    e.preventDefault()    execSync(open )  })
  win.on(closed, () => { win = null })}
app.on(ready, () => {  const tmp = require(tmp)
  tmp.dir((err, path) => {    if (err) throw err
    global.tmpProjectPath = path    createWindow()
    execSync(cp -R  )    execSync(open )
     quit xcode && remove tmp directory on exit    app.on(before-quit, () => {      tryCatch(() => execSync(killall Xcode))      tryCatch(() => execSync(rm -rf ))    })  })})
app.on(window-all-closed, () => (process.platform !== darwin) && app.quit())app.on(activate, () => (win === null) && createWindow())"
"(function() {	var timeouts = [];	var messageName = zero-timeout-message;
	function setZeroTimeout(fn) {		timeouts.push(fn);		window.postMessage(messageName, );	}
	function handleMessage(event) {		if (event.source == window && event.data == messageName) {			event.stopPropagation();			if (timeouts.length > 0) {				var fn = timeouts.shift();				fn();			}		}	}
	window.addEventListener(message, handleMessage, true);
	window.setZeroTimeout = setZeroTimeout;})();
var Neuvol;var game;var FPS = 60;var maxScore=0;
var images = {};
var speed = function(fps){	FPS = parseInt(fps);}
var loadImages = function(sources, callback){	var nb = 0;	var loaded = 0;	var imgs = {};	for(var i in sources){		nb++;		imgs[i] = new Image();		imgs[i].src = sources[i];		imgs[i].onload = function(){			loaded++;			if(loaded == nb){				callback(imgs);			}		}	}}
var Bird = function(json){	this.x = 80;	this.y = 250;	this.width = 40;	this.height = 30;
	this.alive = true;	this.gravity = 0;	this.velocity = 0.3;	this.jump = -6;
	this.init(json);}
Bird.prototype.init = function(json){	for(var i in json){		this[i] = json[i];	}}
Bird.prototype.flap = function(){	this.gravity = this.jump;}
Bird.prototype.update = function(){	this.gravity += this.velocity;	this.y += this.gravity;}
Bird.prototype.isDead = function(height, pipes){	if(this.y >= height || this.y + this.height <= 0){		return true;	}	for(var i in pipes){		if(!(			this.x > pipes[i].x + pipes[i].width ||			this.x + this.width < pipes[i].x || 			this.y > pipes[i].y + pipes[i].height ||			this.y + this.height < pipes[i].y			)){			return true;	}}}
var Pipe = function(json){	this.x = 0;	this.y = 0;	this.width = 50;	this.height = 40;	this.speed = 3;
	this.init(json);}
Pipe.prototype.init = function(json){	for(var i in json){		this[i] = json[i];	}}
Pipe.prototype.update = function(){	this.x -= this.speed;}
Pipe.prototype.isOut = function(){	if(this.x + this.width < 0){		return true;	}}
var Game = function(){	this.pipes = [];	this.birds = [];	this.score = 0;	this.canvas = document.querySelector(#flappy);	this.ctx = this.canvas.getContext(2d);	this.width = this.canvas.width;	this.height = this.canvas.height;	this.spawnInterval = 90;	this.interval = 0;	this.gen = [];	this.alives = 0;	this.generation = 0;	this.backgroundSpeed = 0.5;	this.backgroundx = 0;	this.maxScore = 0;}
Game.prototype.start = function(){	this.interval = 0;	this.score = 0;	this.pipes = [];	this.birds = [];
	this.gen = Neuvol.nextGeneration();	for(var i in this.gen){		var b = new Bird();		this.birds.push(b)	}	this.generation++;	this.alives = this.birds.length;}
Game.prototype.update = function(){	this.backgroundx += this.backgroundSpeed;	var nextHoll = 0;	if(this.birds.length > 0){		for(var i = 0; i < this.pipes.length; i+=2){			if(this.pipes[i].x + this.pipes[i].width > this.birds[0].x){				nextHoll = this.pipes[i].height/this.height;				break;			}		}	}
	for(var i in this.birds){		if(this.birds[i].alive){
			var inputs = [			this.birds[i].y / this.height,			nextHoll			];
			var res = this.gen[i].compute(inputs);			if(res > 0.5){				this.birds[i].flap();			}
			this.birds[i].update();			if(this.birds[i].isDead(this.height, this.pipes)){				this.birds[i].alive = false;				this.alives--;				console.log(this.alives);				Neuvol.networkScore(this.gen[i], this.score);				if(this.isItEnd()){					this.start();				}			}		}	}
	for(var i = 0; i < this.pipes.length; i++){		this.pipes[i].update();		if(this.pipes[i].isOut()){			this.pipes.splice(i, 1);			i--;		}	}
	if(this.interval == 0){		var deltaBord = 50;		var pipeHoll = 120;		var hollPosition = Math.round(Math.random()  (this.height - deltaBord  2 - pipeHoll)) +  deltaBord;		this.pipes.push(new Pipe({x:this.width, y:0, height:hollPosition}));		this.pipes.push(new Pipe({x:this.width, y:hollPosition+pipeHoll, height:this.height}));	}
	this.interval++;	if(this.interval == this.spawnInterval){		this.interval = 0;	}
	this.score++;	this.maxScore = (this.score > this.maxScore) ? this.score : this.maxScore;	var self = this;
	if(FPS == 0){		setZeroTimeout(function(){			self.update();		});	}else{		setTimeout(function(){			self.update();		}, 1000/FPS);	}}

Game.prototype.isItEnd = function(){	for(var i in this.birds){		if(this.birds[i].alive){			return false;		}	}	return true;}
Game.prototype.display = function(){	this.ctx.clearRect(0, 0, this.width, this.height);	for(var i = 0; i < Math.ceil(this.width / images.background.width) + 1; i++){		this.ctx.drawImage(images.background, i  images.background.width - Math.floor(this.backgroundx%images.background.width), 0)	}
	for(var i in this.pipes){		if(i%2 == 0){			this.ctx.drawImage(images.pipetop, this.pipes[i].x, this.pipes[i].y + this.pipes[i].height - images.pipetop.height, this.pipes[i].width, images.pipetop.height);		}else{			this.ctx.drawImage(images.pipebottom, this.pipes[i].x, this.pipes[i].y, this.pipes[i].width, images.pipetop.height);		}	}
	this.ctx.fillStyle = #FFC600;	this.ctx.strokeStyle = #CE9E00;	for(var i in this.birds){		if(this.birds[i].alive){			this.ctx.save(); 			this.ctx.translate(this.birds[i].x + this.birds[i].width/2, this.birds[i].y + this.birds[i].height/2);			this.ctx.rotate(Math.PI/2  this.birds[i].gravity/20);			this.ctx.drawImage(images.bird, -this.birds[i].width/2, -this.birds[i].height/2, this.birds[i].width, this.birds[i].height);			this.ctx.restore();		}	}
	this.ctx.fillStyle = white;	this.ctx.font=20px Oswald, sans-serif;	this.ctx.fillText(Score : + this.score, 10, 25);	this.ctx.fillText(Max Score : +this.maxScore, 10, 50);	this.ctx.fillText(Generation : +this.generation, 10, 75);	this.ctx.fillText(Alive : +this.alives+ / +Neuvol.options.population, 10, 100);
	var self = this;	requestAnimationFrame(function(){		self.display();	});}
window.onload = function(){	var sprites = {		bird:./img/bird.png,		background:./img/background.png,		pipetop:./img/pipetop.png,		pipebottom:./img/pipebottom.png	}
	var start = function(){		Neuvol = new Neuroevolution({			population:50,			network:[2, [2], 1],		});		game = new Game();		game.start();		game.update();		game.display();	}

	loadImages(sprites, function(imgs){		images = imgs;		start();	})
}"
"module.exports = function(grunt) {
	grunt.initConfig({		pkg: grunt.file.readJSON(package.json),
		 Using concat to copy the source. In future, we plan to split the source up, making the concat more appropriate.
		concat: {			jplayer: {				files: {					dist/jplayer/jquery.jplayer.js: [src/javascript/jplayer/jquery.jplayer.js]				}			},			playlist: {				files: {					dist/add-on/jplayer.playlist.js: [src/javascript/add-on/jplayer.playlist.js]				}			},			inspector: {				files: {					dist/add-on/jquery.jplayer.inspector.js: [src/javascript/add-on/jquery.jplayer.inspector.js]				}			},			popcorn: {				files: {					dist/popcorn/popcorn.jplayer.js: [src/javascript/popcorn/popcorn.jplayer.js]				}			}		},
		uglify: {			options: {				 maxLineLen:  0 // Generates the output on a single line			},			jplayer: {				options: {					banner: 				},				files: {					dist/jplayer/jquery.jplayer.min.js: [dist/jplayer/jquery.jplayer.js]				}			},			playlist: {				options: {					banner: 				},				files: {					dist/add-on/jplayer.playlist.min.js: [dist/add-on/jplayer.playlist.js]				}			},			inspector: {				options: {					banner: 				},				files: {					dist/add-on/jquery.jplayer.inspector.min.js: [dist/add-on/jquery.jplayer.inspector.js]				}			},			popcorn: {				options: {					banner: 				},				files: {					dist/popcorn/popcorn.jplayer.min.js: [dist/popcorn/popcorn.jplayer.js]				}			}		},
		sass: {			options: {				sourcemap: none,				style: nested			},			blue.monday: {				options: {					banner: 				},				files: {					dist/skin/blue.monday/css/jplayer.blue.monday.css: src/skin/blue.monday/scss/jplayer.blue.monday.scss				}			},			pink.flag: {				options: {					banner: 				},				files: {					dist/skin/pink.flag/css/jplayer.pink.flag.css: src/skin/pink.flag/scss/jplayer.pink.flag.scss				}			}		},
		cssmin: {			skins: {				files: {					dist/skin/blue.monday/css/jplayer.blue.monday.min.css: [dist/skin/blue.monday/css/jplayer.blue.monday.css],					dist/skin/pink.flag/css/jplayer.pink.flag.min.css: [dist/skin/pink.flag/css/jplayer.pink.flag.css]				}			},		},
		copy: {			skins: {				files: [					{expand: true, cwd: src/skin/blue.monday/, src: [image/**, mustache/**], dest: dist/skin/blue.monday/},					{expand: true, cwd: src/skin/pink.flag/, src: [image/**, mustache/**], dest: dist/skin/pink.flag/}				]			},		},
		jshint: {
			test: {				src: [					Gruntfile.js,					,					src/javascript/**/*.js,					!**/jquery.jplayer.inspector.js  The inspector does not pass jshint, and this will be addressed in due course.				]			},
			 jQuery linting guide http://contribute.jquery.org/style-guide/js/#linting			 docs http://www/jshint.com/docs/			options: {				 Using .jshintrc files for the options.				jshintrc: true			}		},
		mxmlc: {			options: {				rawConfig: -static-link-runtime-shared-libraries=true			},			jplayer: {				files: {					 Compile and give the SWF a filename like the JavaScript filenames. Important as it is the jPlayer code.					dist/jplayer/jquery.jplayer.swf: [src/actionscript/Jplayer.as]				}			}		}	});
	grunt.loadNpmTasks(grunt-contrib-jshint);	grunt.loadNpmTasks(grunt-contrib-concat);	grunt.loadNpmTasks(grunt-contrib-copy);	grunt.loadNpmTasks(grunt-contrib-cssmin);	grunt.loadNpmTasks(grunt-contrib-uglify);	grunt.loadNpmTasks(grunt-contrib-sass);	grunt.loadNpmTasks(grunt-mxmlc);
	grunt.registerTask(default, [test, build]);
	grunt.registerTask(test, [jshint]);	grunt.registerTask(build, [js, swf, css]);	grunt.registerTask(js, [concat, uglify]);	grunt.registerTask(swf, [mxmlc]);	grunt.registerTask(css, [sass, cssmin, copy:skins]);};"
" * Provides a set of classes and methods for handling Neuroevolution and * genetic algorithms. * *    object of options for Neuroevolution. */var Neuroevolution = function(options){	var self = this;   reference to the top scope of this module
 	 Declaration of module parameters (options) and default values	self.options = {    	     	 * Logistic activation function.     	 *	 *    value.	 *  Logistic function output.	 */		activation: function(a){			ap = (-a)/1;			return (1/(1 + Math.exp(ap)))		},
				 * Returns a random value between -1 and 1.		 *		 *  Random value.		 */		randomClamped: function(){			return Math.random()  2 - 1;		},
		 various factors and parameters (along with default values).		network:[1, [1], 1],     Perceptron network structure (1 hidden					 layer).		population:50,           Population by generation.		elitism:0.2,             Best networks kepts unchanged for the next				         generation (rate).		randomBehaviour:0.2,     New random networks for the next generation				         (rate).		mutationRate:0.1,        Mutation rate on the weights of synapses.		mutationRange:0.5,       Interval of the mutation changes on the				         synapse weight.		historic:0,              Latest generations saved.		lowHistoric:false,       Only save score (not the network).		scoreSort:-1,            Sort order (-1 = desc, 1 = asc).		nbChild:1                Number of children by breeding.
	}
		 * Override default options.	 *	 *    object of Neuroevolution options.	 *  void	 */	self.set = function(options){		for(var i in options){      			if(this.options[i] != undefined){  Only override if the passed in value                        	                  	   is actually defined.				self.options[i] = options[i];			}		}	}
	 Overriding default options with the pass in options	self.set(options);

		 * Artificial Neuron class	 *	 * 	 */	var Neuron = function(){		this.value = 0;		this.weights = [];	}
		 * Initialize number of neuron weights to random clamped values.	 *	 *    of neuron weights (number of inputs).	 *  void	 */	Neuron.prototype.populate = function(nb){		this.weights = [];		for(var i = 0; i < nb; i++){			this.weights.push(self.options.randomClamped());		}	}

		 * Neural Network Layer class.	 *	 * 	 *    of this Layer in the Network.	 */	var Layer = function(index){		this.id = index || 0;		this.neurons = [];	}
		 * Populate the Layer with a set of randomly weighted Neurons.	 *	 * Each Neuron be initialied with nbInputs inputs with a random clamped	 * value.	 *	 *    of neurons.	 *    of inputs.	 *  void	 */	Layer.prototype.populate = function(nbNeurons, nbInputs){		this.neurons = [];		for(var i = 0; i < nbNeurons; i++){			var n = new Neuron();			n.populate(nbInputs);			this.neurons.push(n);		}	}

		 * Neural Network class	 *	 * Composed of Neuron Layers.	 *	 * 	 */	var Network = function(){		this.layers = [];	}
		 * Generate the Network layers.	 *	 *    of Neurons in Input layer.	 *    of Neurons per Hidden layer.	 *    of Neurons in Output layer.	 *  void	 */	Network.prototype.perceptronGeneration = function(input, hiddens, output){		var index = 0;		var previousNeurons = 0;		var layer = new Layer(index);    		layer.populate(input, previousNeurons);  Number of Inputs will be set to                	                                 0 since it is an input layer.		previousNeurons = input;   number of input is size of previous layer.		this.layers.push(layer);		index++;		for(var i in hiddens){			 Repeat same process as first layer for each hidden layer.			var layer = new Layer(index);			layer.populate(hiddens[i], previousNeurons);			previousNeurons = hiddens[i];			this.layers.push(layer);			index++;		}		var layer = new Layer(index);		layer.populate(output, previousNeurons);   Number of input is equal to                        	                           the size of the last hidden							   layer.		this.layers.push(layer);	}
		 * Create a copy of the Network (neurons and weights).	 *	 * Returns number of neurons per layer and a flat array of all weights.	 *	 *  Network data.	 */	Network.prototype.getSave = function(){		var datas = {			neurons:[],  Number of Neurons per layer.			weights:[]   Weights of each Neuron's inputs.		};
		for(var i in this.layers){			datas.neurons.push(this.layers[i].neurons.length);			for(var j in this.layers[i].neurons){				for(var k in this.layers[i].neurons[j].weights){	  				 push all input weights of each Neuron of each Layer into a flat	  				 array.					datas.weights.push(this.layers[i].neurons[j].weights[k]);				}			}		}		return datas;	}
		 * Apply network data (neurons and weights).	 *	 *    of network data (neurons and weights).	 *  void	 */	Network.prototype.setSave = function(save){		var previousNeurons = 0;		var index = 0;		var indexWeights = 0;		this.layers = [];		for(var i in save.neurons){			 Create and populate layers.			var layer = new Layer(index);			layer.populate(save.neurons[i], previousNeurons);			for(var j in layer.neurons){				for(var k in layer.neurons[j].weights){	  				 Apply neurons weights to each Neuron.					layer.neurons[j].weights[k] = save.weights[indexWeights];
					indexWeights++;  Increment index of flat array.				}			}			previousNeurons = save.neurons[i];			index++;			this.layers.push(layer);		}	}
		 * Compute the output of an input.	 *	 *    of inputs.	 *  Network output.	 */	Network.prototype.compute = function(inputs){		 Set the value of each Neuron in the input layer.		for(var i in inputs){			if(this.layers[0] && this.layers[0].neurons[i]){				this.layers[0].neurons[i].value = inputs[i];			}		}
		var prevLayer = this.layers[0];  Previous layer is input layer.		for(var i = 1; i < this.layers.length; i++){			for(var j in this.layers[i].neurons){				 For each Neuron in each layer.				var sum = 0;				for(var k in prevLayer.neurons){	  				 Every Neuron in the previous layer is an input to each Neuron in	  				 the next layer.					sum += prevLayer.neurons[k].value	       						 this.layers[i].neurons[j].weights[k];				}
				 Compute the activation of the Neuron.				this.layers[i].neurons[j].value = self.options.activation(sum);			}			prevLayer = this.layers[i];		}
		 All outputs of the Network.		var out = [];		var lastLayer = this.layers[this.layers.length - 1];		for(var i in lastLayer.neurons){			out.push(lastLayer.neurons[i].value);		}		return out;	}

		 * Genome class.	 *	 * Composed of a score and a Neural Network.	 *	 * 	 *	 *  	 *  	 */	var Genome = function(score, network){		this.score = score || 0;		this.network = network || null;	}

		 * Generation class.	 *	 * Composed of a set of Genomes.	 *	 * 	 */	var Generation = function(){		this.genomes = [];	}
		 * Add a genome to the generation.	 *	 *    to add.	 *  void.	 */	Generation.prototype.addGenome = function(genome){    		 Locate position to insert Genome into.    		 The gnomes should remain sorted.		for(var i = 0; i < this.genomes.length; i++){      			 Sort in descending order.			if(self.options.scoreSort < 0){				if(genome.score > this.genomes[i].score){					break;				}			 Sort in ascending order.			}else{				if(genome.score < this.genomes[i].score){					break;				}			}
		}
		 Insert genome into correct position.		this.genomes.splice(i, 0, genome);	}
		 * Breed to genomes to produce offspring(s).	 *	 *    1.	 *    2.	 *    of offspring (children).	 */	Generation.prototype.breed = function(g1, g2, nbChilds){		var datas = [];		for(var nb = 0; nb < nbChilds; nb++){			 Deep clone of genome 1.			var data = JSON.parse(JSON.stringify(g1));			for(var i in g2.network.weights){				 Genetic crossover				 0.5 is the crossover factor.				 FIXME Really should be a predefined constant.				if(Math.random() <= 0.5){					data.network.weights[i] = g2.network.weights[i];				}			}
			 Perform mutation on some weights.			for(var i in data.network.weights){				if(Math.random() <= self.options.mutationRate){					data.network.weights[i] += Math.random()						 self.options.mutationRange				   		 2				   		- self.options.mutationRange;				}			}			datas.push(data);		}
		return datas;	}
		 * Generate the next generation.	 *	 *  Next generation data array.	 */	Generation.prototype.generateNextGeneration = function(){		var nexts = [];
		for(var i = 0; i < Math.round(self.options.elitism                                  self.options.population); i++){			if(nexts.length < self.options.population){        			 Push a deep copy of ith Genome's Nethwork.				nexts.push(JSON.parse(JSON.stringify(this.genomes[i].network)));			}		}
		for(var i = 0; i < Math.round(self.options.randomBehaviour                                  self.options.population); i++){			var n = JSON.parse(JSON.stringify(this.genomes[0].network));			for(var k in n.weights){				n.weights[k] = self.options.randomClamped();			}			if(nexts.length < self.options.population){				nexts.push(n);			}		}
		var max = 0;		while(true){			for(var i = 0; i < max; i++){        			 Create the children and push them to the nexts array.        			var childs = this.breed(this.genomes[i], this.genomes[max],                     		(self.options.nbChild > 0 ? self.options.nbChild : 1) );				for(var c in childs){					nexts.push(childs[c].network);					if(nexts.length >= self.options.population){						 Return once number of children is equal to the						 population by generatino value.						return nexts;					}				}			}			max++;			if(max >= this.genomes.length - 1){				max = 0;			}		}	}

		 * Generations class.	 *	 * Hold's previous Generations and current Generation.	 *	 * 	 */	var Generations = function(){		this.generations = [];		var currentGeneration = new Generation();	}
		 * Create the first generation.	 *	 *    layer.	 *    layer(s).	 *    layer.	 *  First Generation.	 */	Generations.prototype.firstGeneration = function(input, hiddens, output){    		 FIXME input, hiddens, output unused.
		var out = [];		for(var i = 0; i < self.options.population; i++){      			 Generate the Network and save it.			var nn = new Network();			nn.perceptronGeneration(self.options.network[0],						self.options.network[1],                              			self.options.network[2]);			out.push(nn.getSave());		}
		this.generations.push(new Generation());		return out;	}
		 * Create the next Generation.	 *	 *  Next Generation.	 */	Generations.prototype.nextGeneration = function(){		if(this.generations.length == 0){			 Need to create first generation.			return false;		}
		var gen = this.generations[this.generations.length - 1]				.generateNextGeneration();		this.generations.push(new Generation());		return gen;	}
		 * Add a genome to the Generations.	 *	 *  	 *  False if no Generations to add to.	 */	Generations.prototype.addGenome = function(genome){    		 Can't add to a Generation if there are no Generations.		if(this.generations.length == 0) return false;
   		  FIXME addGenome returns void.		return this.generations[this.generations.length - 1].addGenome(genome);	}

	self.generations = new Generations();
		 * Reset and create a new Generations object.	 *	 *  void.	 */	self.restart = function(){		self.generations = new Generations();	}
		 * Create the next generation.	 *	 *  Neural Network array for next Generation.	 */	self.nextGeneration = function(){		var networks = [];
		if(self.generations.generations.length == 0){      			 If no Generations, create first.			networks = self.generations.firstGeneration();		}else{      			 Otherwise, create next one.			networks = self.generations.nextGeneration();		}
    		 Create Networks from the current Generation.		var nns = [];		for(var i in networks){			var nn = new Network();			nn.setSave(networks[i]);			nns.push(nn);		}
		if(self.options.lowHistoric){      			 Remove old Networks.			if(self.generations.generations.length >= 2){				var genomes =					self.generations						.generations[self.generations.generations.length - 2]              					.genomes;				for(var i in genomes){					delete genomes[i].network;				}			}		}
		if(self.options.historic != -1){      			 Remove older generations.			if(self.generations.generations.length > self.options.historic + 1){        			self.generations.generations.splice(0,            			self.generations.generations.length - (self.options.historic + 1));			}		}
		return nns;	}
		 * Adds a new Genome with specified Neural Network and score.	 *	 *    Network.	 *    value.	 *  void.	 */	self.networkScore = function(network, score){		self.generations.addGenome(new Genome(score, network.getSave()));	}}"
"
import gulp from gulp;
import { spawn, exec } from child_process;import _ from lodash;import babel from gulp-babel;import clean from gulp-clean;import concat from gulp-concat;import cssmin from gulp-cssmin;import { createWindowsInstaller as electronInstaller } from gpmdp-electron-winstaller;import fs from fs;import globber from glob;import header from gulp-header;import less from gulp-less;import packager from electron-packager;import nodePath from path;import replace from gulp-replace;import runSequence from run-sequence;import electronWindowsStore from electron-windows-store; import uglify from 'gulp-uglify';import rebuild from electron-rebuild;import rasterImages from ./vendor/svg_raster;
const paths = {  internalScripts: [src/**/*.js],  utilityScripts: [node_modules/jquery/dist/jquery.min.js,                    node_modules/materialize-css/dist/js/materialize.min.js,                    node_modules/materialize-css/extras/noUiSlider/nouislider.min.js],  html: src/public_html/**/*.html,  less: src/assets/less/**/*.less,  fonts: [node_modules/materialize-css/dist/fonts/**/*,          !node_modules/materialize-css/dist/font/material-design-icons/*,          node_modules/material-design-icons-iconfont/dist/fonts/**/*],  images: [src/assets/img/**/*, src/assets/icons/*],  locales: [src/_locales/*.json],};
const packageJSON = require(./package.json);
let version = packageJSON.dependencies.electron;if (version.substr(0, 1) !== 0 && version.substr(0, 1) !== 1) {  version = version.substr(1);}
const defaultPackageConf = {  appBundleId: packageJSON.name,  appCategoryType: public.app-category.music,  appCopyright: Copyright ©  , All rights reserved.,  eslint-disable-line  appVersion: packageJSON.version,  afterCopy: [    (buildPath, electronVersion, pPlatform, pArch, done) => rebuild(buildPath, electronVersion, pArch).then(() => done()).catch(done),    (buildPath, electronVersion, pPlatform, pArch, done) => {      const files = globber.sync(nodePath.resolve(buildPath, , ))        .concat(globber.sync(nodePath.resolve(buildPath, , )))        .concat(globber.sync(nodePath.resolve(buildPath, , .bin, , )));      files.forEach(filePath => fs.unlinkSync(filePath));      done();    },  ],  arch: all,  asar: true,  buildVersion: packageJSON.version,  dir: __dirname,  icon: ./build/assets/img/main,  ignore: (path) => {    const tests = [       Ignore git directory      () => gitg,       Ignore uwp directory      () => wpg,       Ignore electron-packager on Docker machines      () => electron-packagerg,       Ignore electron      () => node_moduleselectrong,      () => node_moduleselectrong,       Ignore debug files      () => node_modulespdbg,       Ignore native module obj files      () => node_modulesobjg,       Ignore optional dev modules      () => node_modulesappdmgg,      () => node_moduleselectron-installer-debiang,      () => node_moduleselectron-installer-redhatg,       Ignore symlinks in the bin directory      () => node_modulesbing,       Ignore root dev FileDescription      () => (vendordistsigdocssrctestcertpfxeditorconfigeslintignoreeslintrcgitignoretravisymlappveyorymlcircleymlCONTRIBUTINGmdGruntfilejsgulpfilejsISSUE_TEMPLATEmdLICENSEREADMEmd)()g,  eslint-disable-line    ];    for (let i = 0; i < tests.length; i++) {      if (tests[i]().test(path)) {        return true;      }    }    return false;  },  name: packageJSON.productName,  out: ./dist/,  overwrite: true,  platform: all,  prune: true,  electronVersion: version,  win32metadata: {    CompanyName: packageJSON.author.name,    FileDescription: packageJSON.productName,    ProductName: packageJSON.productName,    InternalName: packageJSON.productName,  },};
const winstallerConfig = {  appDirectory: dist/-win32-ia32,  outputDirectory: dist/installers/win32,  authors: packageJSON.author.name,  exe: .exe,  description: packageJSON.productName,  title: packageJSON.productName,  owners: packageJSON.author.name,  name: GPMDP_3,  noMsi: true,  certificateFile: .cert.pfx,  certificatePassword: process.env.SIGN_CERT_PASS,   DEV: When in master we should change this to point to github raw url  iconUrl: https://www.samuelattard.com/img/gpmdp_setup.ico,  setupIcon: build/assets/img/main.ico,  loadingGif: build/assets/img/installing.gif,};
if (!process.env.GPMDP_DONT_BUILD_DELTAS) {  winstallerConfig.remoteReleases = https://github.com/MarshallOfSound/Google-Play-Music-Desktop-Player-UNOFFICIAL-;}
if (process.env.APPVEYOR) {  delete winstallerConfig.remoteReleases;}
const appdmgConf = {  target: dist/-darwin-x64/.dmg,  basepath: __dirname,  specification: {    title: GPMDP,    icon: .icns,    background: src/assets/img/dmg.png,    window: {      size: {        width: 600,        height: 400,      },    },    contents: [      {        x: 490, y: 252, type: link, path: /Applications,      },      {        x: 106, y: 252, type: file, path: dist/-darwin-x64/.app,      },    ],  },};
const cleanGlob = (glob) => {  return () => {    return gulp.src(glob, { read: false })      .pipe(clean({ force: true }));  };};
const windowsSignFile = (filePath, signDigest) =>  new Promise((resolve) => {    console.log(Signing file: """"With digest: );    exec(      vendorsigntool sign /f "".cert.pfx"" /p  /fd  /tr ""http://timestamp.geotrust.com/tsa"" /v /as """",      {},      () => {        setTimeout(() => {          setTimeout(resolve, 500);        });      }    );  });
gulp.task(clean, cleanGlob([./build, ./dist]));gulp.task(clean-dist-win, cleanGlob(./dist/-win32-ia32));gulp.task(clean-dist-darwin, cleanGlob(./dist/-darwin-ia32));gulp.task(clean-dist-linux-32, cleanGlob(./dist/-linux-ia32));gulp.task(clean-dist-linux-64, cleanGlob(./dist/-linux-x64));gulp.task(clean-material, cleanGlob(./build/assets/material));gulp.task(clean-utility, cleanGlob(./build/assets/util));gulp.task(clean-html, cleanGlob(./build/public_html));gulp.task(clean-internal, cleanGlob([./build/*.js, ./build/**/*.js, !./build/assets/**/*]));gulp.task(clean-fonts, cleanGlob(./build/assets/fonts));gulp.task(clean-less, cleanGlob(./build/assets/css));gulp.task(clean-images, cleanGlob(./build/assets/img));gulp.task(clean-locales, cleanGlob(./build/_locales/*.json));
gulp.task(materialize-js, [clean-material], () => {  return gulp.src(node_modules/materialize-css/dist/js/materialize.min.js)    .pipe(gulp.dest(./build/assets/material));});
gulp.task(utility-js, [clean-utility], () => {  return gulp.src(paths.utilityScripts)    .pipe(gulp.dest(./build/assets/util));});
gulp.task(html, [clean-html], () => {  return gulp.src(paths.html)    .pipe(gulp.dest(./build/public_html));});
gulp.task(transpile, [clean-internal], () => {  return gulp.src(paths.internalScripts)    .pipe(babel())    .on(error, (err) => { console.error(err); })  eslint-disable-line    .pipe(replace(processenv()( ,;)gi, (envCall, envKey, closer) => {      return '';    }))    .pipe(gulp.dest(./build/));});
gulp.task(locales, [clean-locales], () => {  return gulp.src(paths.locales)    .pipe(gulp.dest(./build/_locales));});
gulp.task(fonts, [clean-fonts], () => {  return gulp.src(paths.fonts)    .pipe(gulp.dest(./build/assets/fonts));});
gulp.task(less, [clean-less], () => {  return gulp.src(paths.less)    .pipe(less())    .on(error, (err) => { console.error(err); })  eslint-disable-line    .pipe(cssmin())    .pipe(concat(core.css))    .pipe(gulp.dest(./build/assets/css));});
 Copy all static imagesgulp.task(copy-static-images, [clean-images], () => {  return gulp.src(paths.images)    .pipe(gulp.dest(./build/assets/img/));});
gulp.task(images, [copy-static-images], (done) => {  rasterImages(done);});
gulp.task(build-release, [build], () => {  return gulp.src(./build/**/*.js)     .pipe(uglify())    .pipe(header(Version: vAPI Version: vCompiled: Copyright (C)  This software may be modified and distributed under the terms of the MIT license. */    ))    .pipe(gulp.dest(./build));});
 Rerun the task when a file changesgulp.task(watch, [build], () => {  gulp.watch(paths.internalScripts, [transpile]);  gulp.watch(paths.html, [html]);  gulp.watch(paths.images, [images]);  gulp.watch(paths.less, [less]);  gulp.watch(paths.locales, [locales]);});
gulp.task(package:win, [clean-dist-win, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: win32, arch: ia32 }), (err) => {    if (err) return done(err);    setTimeout(() => {      const packageExePath = dist/-win32-ia32/.exe;      windowsSignFile(packageExePath, sha1)      .then(() => windowsSignFile(packageExePath, sha256))      .then(() => done());    }, 1000);  });});
gulp.task(make:win, [package:win], (done) => {  electronInstaller(winstallerConfig)    .then(() => {      const installerExePath = dist/installers/win32/Setup.exe;      windowsSignFile(installerExePath, sha1)      .then(() => windowsSignFile(installerExePath, sha256))      .then(() => done());    })    .catch((err) => done(err));});
gulp.task(make:win:uwp, [package:win], (done) => {  electronWindowsStore({    containerVirtualization: false,    inputDirectory: nodePath.resolve(__dirname, dist/-win32-ia32),    outputDirectory: nodePath.resolve(__dirname, dist/uwp),    flatten: true,    packageVersion: .0,    packageName: GPMDP,    packageDisplayName: GPMDP,    packageDescription: packageJSON.description,    packageExecutable: app.exe,    publisher: CN=E800FCD7-1562-414E-A4AC-F1BA78F4A060,    publisherDisplayName: Samuel Attard,    assets: buildassetsimgassets,    devCert: nodePath.resolve(__dirname, .uwp.pfx),    signtoolParams: [/p, process.env.SIGN_CERT_PASS],    finalSay: () => new Promise((resolve) => {      const manifestPath = nodePath.resolve(__dirname, dist/uwp/pre-appx/appxmanifest.xml);      const manifest = fs.readFileSync(manifestPath, utf8).replace(<Identity Name=""GPMDP"", <Identity Name=""24619SamuelAttard.GPMDP"");      fs.writeFileSync(manifestPath, manifest);      resolve();    }),  }).then(() => done()).catch(done);});
gulp.task(package:darwin, [clean-dist-darwin, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: darwin, osxSign: { identity: Developer ID Application: Samuel Attard (S7WPQ45ZU2) } }), done);  eslint-disable-line});
gulp.task(make:darwin, [package:darwin], (done) => {  const pathEscapedName = packageJSON.productName.replace( gi,  );  const child = spawn(zip, [-r, -y, .zip, .app],    {      cwd: ./dist/-darwin-x64,    });
  console.log(Zipping "".app"");  eslint-disable-line
  child.stdout.on(data, () => {});
  child.stderr.on(data, () => {});
  child.on(close, (code) => {    console.log(Finished zipping with code  + code);  eslint-disable-line
    done();  });});
gulp.task(dmg:darwin, [package:darwin], (done) => {  if (fs.existsSync(nodePath.resolve(__dirname, appdmgConf.target))) {    fs.unlinkSync(nodePath.resolve(__dirname, appdmgConf.target));  }  const dmg = require(appdmg)(appdmgConf);
  dmg.on(finish, () => done());  dmg.on(error, done);});
gulp.task(package:linux:32, [clean-dist-linux-32, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: linux, arch: ia32 }), done);});
gulp.task(package:linux:64, [clean-dist-linux-64, build-release], (done) => {  packager(_.extend({}, defaultPackageConf, { platform: linux, arch: x64 }), done);});
gulp.task(package:linux, (done) => {  runSequence(package:linux:32, package:linux:64, done);});
const generateGulpLinuxDistroTask = (prefix, name, arch) => {  gulp.task(:linux:, [package:linux:], (done) => {    const tool = require(electron-installer-);
    const defaults = {      bin: packageJSON.productName,      dest: dist/installers/,      depends: [libappindicator1, avahi-daemon],      maintainer:  <>,      homepage: packageJSON.homepage,      icon: build/assets/img/main.png,      categories: [AudioVideo, Audio],      section: sound,    };
    let pkgArch = i386;    if (arch === 64) {      pkgArch = (prefix === rpm ? x86_64 : amd64);    }
    tool(_.extend({}, defaults, {      src: dist/-linux-,      arch: pkgArch,    }), (err) => {      console.log(bit  package built);  eslint-disable-line      if (err) return done(err);      done();    });  });};
generateGulpLinuxDistroTask(rpm, redhat, 32);generateGulpLinuxDistroTask(rpm, redhat, 64);generateGulpLinuxDistroTask(deb, debian, 32);generateGulpLinuxDistroTask(deb, debian, 64);
gulp.task(rpm:linux, (done) => {  runSequence(rpm:linux:32, rpm:linux:64, done);});
gulp.task(deb:linux, (done) => {  runSequence(deb:linux:32, deb:linux:64, done);});
const zipTask = (makeName, deps, cwd, what) => {  gulp.task(make:, deps, (done) => {    const child = spawn(zip, [-r, -y, installers.zip, .], { cwd });
    console.log(Zipping );  eslint-disable-line
     spit stdout to screen    child.stdout.on(data, () => {});
     Send stderr to the main console    child.stderr.on(data, () => {});
    child.on(close, (code) => {      console.log(Finished zipping  with code: );  eslint-disable-line      done();    });  });};
gulp.task(make:linux, (done) => {  runSequence(deb:linux, rpm:linux, make:linux:both, done);});
zipTask(linux:both, [], ./dist/installers, all the Linux Installers);zipTask(linux:deb, [deb:linux], ./dist/installers/debian, the Debian Packages);zipTask(linux:rpm, [rpm:linux], ./dist/installers/redhat, the Redhat (Fedora) Packages);
 The default task (called when you run `gulp` from cli)gulp.task(default, [watch, transpile, images]);gulp.task(build, [materialize-js, utility-js, transpile, images, less,                    fonts, html, locales]);gulp.task(package, [package:win, package:darwin, package:linux]);"
"#!/usr/bin/env electron
var app = require(app)var BrowserWindow = require(browser-window)var path = require(path)var ipc = require(electron).ipcMainvar dialog = require(dialog)var shell = require(shell)var powerSaveBlocker = require(electron).powerSaveBlockervar globalShortcut = require(electron).globalShortcut
var winvar linkvar ready = false
var onopen = function (e, lnk) {  e.preventDefault()
  if (ready) {    win.send(add-to-playlist, [].concat(lnk))    return  }
  link = lnk}
app.on(open-file, onopen)app.on(open-url, onopen)
var frame = process.platform === win32
app.on(ready, function () {  win = new BrowserWindow({    title: playback,    width: 860,    height: 470,    frame: frame,    show: false,    transparent: true  })
  win.loadURL(file:// + path.join(__dirname, index.html# + JSON.stringify(process.argv.slice(2))))
  ipc.on(close, function () {    app.quit()  })
  ipc.on(open-file-dialog, function () {    var files = dialog.showOpenDialog({ properties: [ openFile, multiSelections ]})    if (files) {      files.forEach(app.addRecentDocument)      win.send(add-to-playlist, files)    }  })
  ipc.on(open-url-in-external, function (event, url) {    shell.openExternal(url)  })
  ipc.on(focus, function () {    win.focus()  })
  ipc.on(minimize, function () {    win.minimize()  })
  ipc.on(maximize, function () {    win.maximize()  })
  ipc.on(resize, function (e, message) {    if (win.isMaximized()) return    var wid = win.getSize()[0]    var hei = (wid / message.ratio) | 0    win.setSize(wid, hei)  })
  ipc.on(enter-full-screen, function () {    win.setFullScreen(true)  })
  ipc.on(exit-full-screen, function () {    win.setFullScreen(false)    win.show()  })
  ipc.on(ready, function () {    ready = true    if (link) win.send(add-to-playlist, [].concat(link))    win.show()  })
  ipc.on(prevent-sleep, function () {    app.sleepId = powerSaveBlocker.start(prevent-display-sleep)  })
  ipc.on(allow-sleep, function () {    powerSaveBlocker.stop(app.sleepId)  })
  globalShortcut.register(MediaPlayPause, function () {    win.send(media-play-pause)  })
  globalShortcut.register(MediaNextTrack, function () {    win.send(media-next-track)  })
  globalShortcut.register(MediaPreviousTrack, function () {    win.send(media-previous-track)  })
})
app.on(will-quit, function () {
  globalShortcut.unregisterAll()
})"
" * Note: You probably don't need to edit this file. Instead, add your gulp * tasks with the ./tasks directory, where tasks are grouped by their * particular purpose. If you feel like your task doesn't fit within the * existing files, feel free to create a ""gulp-thing.js"" file within that * directory, and it will automatically be included. */
require(babel-register);
if (process.env.NODE_ENV === production) {  require(./gulp/gulp-apidoc);  require(./gulp/gulp-newstuff);  require(./gulp/gulp-build);  require(./gulp/gulp-babelify);} else {  require(glob).sync(./gulp/gulp-*).forEach(require);  require(gulp).task(default, [test]);}"
"require(babel-register);var _ = require(lodash);module.exports = function(grunt) {
   Project configuration.  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),
    karma: {      unit: {        configFile: test/client-old/spec/karma.conf.js      },      continuous: {        configFile: test/client-old/spec/karma.conf.js,        singleRun: true,        autoWatch: false      }    },
    clean: {      build: [website/build]    },
    cssmin: {      dist: {        options: {          report: gzip        },        files:{          website/client-old/css/habitrpg-shared.css: [            website/assets/sprites/dist/spritesmith*.css,            website/assets/sprites/css/backer.css,            website/assets/sprites/css/Mounts.css,            website/assets/sprites/css/index.css          ]        }      }    },
    stylus: {      build: {        options: {          compress: false,  AFTER          include css: true,          paths: [website/client-old]        },        files: {          website/build/app.css: [website/client-old/css/index.styl],          website/build/static.css: [website/client-old/css/static.styl]        }      }    },
    copy: {      build: {        files: [          {expand: true, cwd: website/client-old/, src: favicon.ico, dest: website/build/},          {expand: true, cwd: website/client-old/, src: favicon_192x192.png, dest: website/build/},          {expand: true, cwd: website/assets/sprites/dist/, src: spritesmith*.png, dest: website/build/static/sprites},          {expand: true, cwd: website/assets/sprites/, src: backer-only/*.gif, dest: website/build/},          {expand: true, cwd: website/assets/sprites/, src: npc_ian.gif, dest: website/build/},          {expand: true, cwd: website/assets/sprites/, src: quest_*.gif, dest: website/build/},          {expand: true, cwd: website/client-old/, src: bower_components/bootstrap/dist/fonts/*, dest: website/build/}        ]      }    },
     UPDATE IT WHEN YOU ADD SOME FILES NOT ALREADY MATCHED!    hashres: {      build: {        options: {          fileNameFormat: ${name}-${hash}.${ext}        },        src: [          website/build/*.js,          website/build/*.css,          website/build/favicon.ico,          website/build/favicon_192x192.png,          website/build/*.png,          website/build/static/sprites/*.png,          website/build/*.gif,          website/build/bower_components/bootstrap/dist/fonts/*        ],        dest: website/build/*.css      }    }  });
  Load build files from client-old/manifest.json  grunt.registerTask(loadManifestFiles, Load all build files from client-old/manifest.json, function(){    var files = grunt.file.readJSON(./website/client-old/manifest.json);    var uglify = {};    var cssmin = {};
    _.each(files, function(val, key){
      var js = uglify[website/build/ + key + .js] = [];
      _.each(files[key].js, function(val){        var path = ./;        if( val.indexOf(common/) == -1)          path = ./website/client-old/;        js.push(path + val);      });
      var css = cssmin[website/build/ + key + .css] = [];
      _.each(files[key].css, function(val){        var path = ./;        if( val.indexOf(common/) == -1) {          path = (val == app.css || val == static.css) ?  ./website/build/ : ./website/client-old/;        }        css.push(path + val)      });
    });
    grunt.config.set(uglify.build.files, uglify);    grunt.config.set(uglify.build.options, {compress: false});
    grunt.config.set(cssmin.build.files, cssmin);     Rewrite urls to relative path    grunt.config.set(cssmin.build.options, {target: website/client-old/css/whatever-css.css});  });
   Register tasks.  grunt.registerTask(build:prod, [loadManifestFiles, clean:build, uglify, stylus, cssmin, copy:build, hashres]);  grunt.registerTask(build:dev, [cssmin, stylus]);  grunt.registerTask(build:test, [build:dev]);
   Load tasks  grunt.loadNpmTasks(grunt-contrib-uglify);  grunt.loadNpmTasks(grunt-contrib-clean);  grunt.loadNpmTasks(grunt-contrib-stylus);  grunt.loadNpmTasks(grunt-contrib-cssmin);  grunt.loadNpmTasks(grunt-contrib-copy);  grunt.loadNpmTasks(grunt-contrib-watch);  grunt.loadNpmTasks(grunt-hashres);  if (process.env.NODE_ENV !== production) grunt.loadNpmTasks(grunt-karma);
};"
code
#!/usr/bin/env nodevar x;x = require(./package);console.log(x.version)
"use strict;
var tmp = require(tmp);var childProcess = require(child_process);var arraydiff = require(arr-diff);var fs = require(fs);var wrench = require(wrench);var inquirer = require(inquirer);var path = require(path);
module.exports = function (grunt) {    require(load-grunt-tasks)(grunt);
    grunt.initConfig({        eslint: {            options: {                fix: true            },            files: [                Gruntfile.js,                bin/*,                lib/**/*.js,                test/**/*.js,                !test/assets/**/*,                !test/reports/**/*,                !test/sample/**/*,                !test/tmp/**/*            ]        },        simplemocha: {            options: {                reporter: spec,                timeout: 15000            },            full: {                src: [test/test.js]            },            short: {                options: {                    reporter: dot                },                src: [test/test.js]            }        },        exec: {            assets: {                command: node test/packages.js && node test/packages-svn.js            },            assets-force: {                command: node test/packages.js --force && node test/packages-svn.js --force            },            cover: {                command: node node_modules/istanbul/lib/cli.js cover --dir ./test/reports node_modules/mocha/bin/_mocha -- --timeout 30000 -R dot test/test.js            },            coveralls: {                command: npm run coveralls < test/reports/lcov.info,                exitCodes: [0, 1, 2, 3]  Alow for failure for coverage report            }        },        watch: {            files: [<%= eslint.files %>],            tasks: [eslint, simplemocha:short]        }    });
    grunt.registerTask(assets, [exec:assets-force]);    grunt.registerTask(test, [eslint, exec:assets, simplemocha:full]);    grunt.registerTask(cover, exec:cover);    grunt.registerTask(travis, [eslint, exec:assets, exec:cover, exec:coveralls]);    grunt.registerTask(default, test);
    grunt.task.registerTask(publish, Perform final checks and publish Bower, function () {        var npmVersion = JSON.parse(childProcess.execSync(npm version --json).toString()).npm.split(.);        var npmMajor = parseInt(npmVersion[0], 10);        var npmMinor = parseInt(npmVersion[1], 10);
        var jsonPackage = require(./package);
        if (npmMajor !== 3 || npmMinor < 5) {            grunt.log.writeln(You need to use at least npm@3.5 to publish bower.);            grunt.log.writeln(It is because npm 2.x produces too long paths that Windows does not handle.);            grunt.log.writeln(Please upgrade it: npm install -g npm);            process.exit(1);        }
        var version = jsonPackage.version;        var changelog = fs.readFileSync(./CHANGELOG.md);
        if (changelog.indexOf(##  + version) === -1) {            grunt.log.writeln(Please add changelog.md entry for this bower version ( + version + ));
            var lastRelease = childProcess.execSync(git tag | tail -1).toString().trim();
            grunt.log.writeln(Commits since last release ( + lastRelease + ): );
            grunt.log.writeln(childProcess.execSync(git log --oneline  + lastRelease + ..).toString());
            process.exit(1);        }
        if (childProcess.execSync(git rev-parse --abbrev-ref HEAD).toString().trim() !== master) {            grunt.log.writeln(You need to release bower from the ""master"" branch);
            process.exit(1);        }
        if (process.env.SKIP_TESTS !== 1) {            grunt.log.writeln(Reinstalling dependencies...);            childProcess.execSync(rm -rf node_modules && npm install, { stdio: [0, 1, 2] });
            grunt.log.writeln(Running test suite...);            childProcess.execSync(grunt test, { stdio: [0, 1, 2] });        }
        var dir = tmp.dirSync().name;
        wrench.copyDirSyncRecursive(__dirname, dir, {            forceDelete: true,            include: function (path) {                return !path.match(node_modulesgittest);            }        });
        grunt.log.writeln(Installing production dependencies...);        childProcess.execSync(npm install --production --silent, { cwd: dir, stdio: [0, 1, 2] });
        delete jsonPackage.dependencies;        delete jsonPackage.devDependencies;        delete jsonPackage.scripts;
        fs.writeFileSync(path.resolve(dir, package.json), JSON.stringify(jsonPackage, null,   ) + );

        grunt.log.writeln(Moving node_modules to lib directory...);
        wrench.copyDirSyncRecursive(path.resolve(dir, node_modules), path.resolve(dir, lib, node_modules));        wrench.rmdirSyncRecursive(path.resolve(dir, node_modules));
        grunt.log.writeln(Testing bower on sample project...);
        childProcess.execSync(            cd test/sample && rm -rf bower_components &&  + dir + /bin/bower install --force, { stdio: [0, 1, 2] }        );
        var expectedPackages = (            SHA-1 ace-builds almond angular angular-animate angular-bootstrap angular-charts angular-contenteditable  +            angular-deckgrid angular-fullscreen angular-gravatar angular-hotkeys angular-local-storage angular-marked  +            angular-moment angular-sanitize angular-touch angular-ui-router angular-ui-sortable  +            angulartics asEvented bootstrap coffee-script d3 es6-shim font-awesome howler jquery  +            jquery-ui jquery-waypoints js-beautify lodash lz-string marked moment ng-file-upload peerjs  +            requirejs restangular slimScroll slimScrollHorizontal venturocket-angular-slider        ).split( );
        var installedPackages = fs.readdirSync(./test/sample/bower_components);
        var installedDiff = arraydiff(expectedPackages, installedPackages);
        if (installedDiff.length > 0) {            grunt.log.writeln(ERROR. Some packages were not installed by bower: );            grunt.log.writeln(installedDiff.join(, ));
            process.exit(1);        }
        grunt.log.writeln(Bower production bundle installed in:);        grunt.log.writeln(dir + );
        var questions = [            {                type: confirm,                name: review,                message: Did you review all the changes with ""git diff""?,                default: false            },            {                type: confirm,                name: changelog,                message: Are you sure the CHANGELOG.md contains all changes?,                default: false            },            {                type: confirm,                name: tests,                message: Are you sure all tests are passing on Travis and Appveyor?,                default: false            },            {                type: confirm,                name: publish,                message: Are you SURE you want to publish  + jsonPackage.name + @ + jsonPackage.version + ?,                default: false            }        ];
        var done = this.async();
        inquirer.prompt(questions, function (answers) {            if (!answers.review || !answers.changelog || !answers.tests || !answers.publish) {                grunt.log.writeln(Please publish bower after you fix this issue);
                process.exit(1);            }
            grunt.log.writeln(Please remember to tag this relese, and add a release on Github!);            grunt.log.writeln(Also, please remember to test published Bower one more time!);            grunt.log.writeln(Publishing Bower...);
            childProcess.execSync(npm publish --tag beta, { cwd: dir, stdio: [0, 1, 2] });
            done();        });    });};"
" Accepts input of any filename, ie. node test.js README.md
const fs = require(fs);
let log = {;let issuelog =   ""message"": ""#### Syntax Issuesnn Name | Entryn----|----------------------n;
const file = fs.readFileSync(process.argv[2], utf8);  Reads argv into var file
function entryFilter(md) {  Function to find lines with entries  const linepatt =   `;  return linepatt.test(md);}
function split(text) {  Function to split lines into array  return text.split();}
function findPattern(text) {  Test entries against 8 patterns.  If matches pattern returns true  const nodnospatt =    -  `` ``;  Regex for entries with no demo and no source code  const slpatt =    -  Demo, Source Code `` ``;  Regex for entries with demo and source code  const nodpatt =    -  Source Code `` ``;  Regex for entries with no demo  const nospatt =    -  Demo `` ``;  Regex for entries with no source code  const pnodnospatt =    `⚠` -  `` ``;  Regex for entries with proprietary with no demo and no source code  const pslpatt =    `⚠` -  Demo, Source Code `` ``;  Regex for entries with proprietary with demo and source code  const pnodpatt =    `⚠` -  Source Code `` ``;  Regex for entries with proprietary with no demo  const pnospatt =    `⚠` -  Demo `` ``;  Regex for entries with proprietary with no source code  if (nodnospatt.test(text) === true) {    return true;  } else if (slpatt.test(text) === true) {    return true;  } else if (nodpatt.test(text) === true) {    return true;  } else if (nospatt.test(text) === true) {    return true;  } else if (pnodnospatt.test(text) === true) {    return true;  } else if (pslpatt.test(text) === true) {    return true;  } else if (pnodpatt.test(text) === true) {    return true;  } else if (pnospatt.test(text) === true) {    return true;  }  return false;}
function entryErrorCheck(md) {  const namepatt =  ();  regex pattern to find name of entryArray  const entries = split(md);  Inserts each line into the entries array  let totalFail = 0;  let totalPass = 0;  let total = 0;  const entryArray = [];  for (let i = 0, len = entries.length; i < len; i += 1) {  Loop to create array of objects    entryArray[i] = new Object;    entryArray[i].raw = entries[i];    if (entryFilter(entries[i]) === true) {  filter out lines that don't with * [)      total += 1;      entryArray[i].name = namepatt.exec(entries[i])[1];  Parses name of entry      entryArray[i].pass = findPattern(entries[i]);  Tests against known patterns      if (entryArray[i].pass === true) {  If entry passes increment totalPass counter        totalPass += 1;      } else {        console.log( Failed.);  If entry fails increment totalFail counter and append error to issuelog         entryArray[i].error = findError(entries[i]) //WIP        totalFail += 1;        issuelog +=  |  n;      }    }  }  if (totalFail > 0) {  Logs # passed & failed to console, and failures to syntaxcheck.json    console.log( Failed,  Passed, of );    log +=  ""error"": true,  ""title"": ""Found  entries with syntax error(s)."",;    fs.writeFileSync(syntaxcheck.json,   ""});    process.exit(1);  } else {  Logs # of entries passed to console and error: false to syntaxcheck.json    console.log( Failed,  Passed, of  );    log +=   ""error"": false};    fs.writeFileSync(syntaxcheck.json, log);    process.exit(0);  }}
entryErrorCheck(file);"
"var gulp = require(gulp);
var glob       = require(glob);var path       = require(path);var jshint     = require(gulp-jshint);var sass       = require(gulp-sass);var concat     = require(gulp-concat);var uglify     = require(gulp-uglify);var rename     = require(gulp-rename);var minifyCSS  = require(gulp-minify-css);var babelify   = require(babelify);var browserify = require(browserify);var source     = require(vinyl-source-stream);var buffer     = require(vinyl-buffer);var wrap       = require(gulp-wrap);var qunit      = require(gulp-qunit);var babel      = require(gulp-babel);
 Lint Taskgulp.task(lint, function() {  gulp.src(dev/sweetalert.es6.js)    .pipe(jshint())    .pipe(jshint.reporter(default));
  return gulp.src(dev/*/*.js)    .pipe(jshint())    .pipe(jshint.reporter(default));});
 Compile Our Sassgulp.task(sass, function() {
  gulp.src(example/example.scss)    .pipe(sass())    .pipe(rename(example.css))    .pipe(gulp.dest(example));
   (We don't use minifyCSS since it breaks the ie9 file for some reason)  gulp.src([dev/sweetalert.scss, dev/ie9.css, dev/loader-animation.css])    .pipe(sass())    .pipe(concat(sweetalert.css))    .pipe(gulp.dest(dist));});

 Compile theme CSSvar themes = glob.sync(themes/*).map(function(themeDir) {  return path.basename(themeDir);});
themes.forEach(function(name) {  gulp.task(name + -theme, function() {    return gulp.src(themes/ + name + / + name + .scss)      .pipe(sass())  etc      .pipe(rename(name + .css))      .pipe(gulp.dest(themes/ + name))  });});
gulp.task(themes, themes.map(function(name){ return name + -theme; }));
 Compile ES5 CommonJS entry pointgulp.task(commonjs, function() {  gulp.src(./dev/sweetalert.es6.js)    .pipe(babel())    .pipe(rename(sweetalert.js))    .pipe(gulp.dest(lib));  gulp.src(./dev/modules/*.js)    .pipe(babel())    .pipe(gulp.dest(lib/modules));});
 Concatenate & Minify JSgulp.task(scripts, function() {  return browserify({      entries: ./dev/sweetalert.es6.js,      debug: true    })    .transform(babelify)    .bundle()    .pipe(source(sweetalert-dev.js))    .pipe(wrap({      src: ./dev/gulpfile-wrap-template.js    }))    .pipe(gulp.dest(dist))  Developer version
    .pipe(rename(sweetalert.min.js))    .pipe(buffer())    .pipe(uglify())    .pipe(gulp.dest(dist));  User version});
gulp.task(test, function() {  return gulp.src(./test/index.html)    .pipe(qunit({      timeout: 20    }));});
 Watch Files For Changesgulp.task(watch, function() {  gulp.watch([dev/*.js, dev/*/*.js], [lint, scripts]);  gulp.watch([dev/*.scss, dev/*.css], [sass]);  gulp.watch(themes/*/*.scss, [themes]);});
 Default Taskgulp.task(default, [lint, sass, scripts, commonjs, watch, test]);"
"#!/usr/bin/env node
var http = require(http)  , path = require(path)  , url = require(url)  , fs = require(fs)  , port = process.env.PORT || 8888  , ip = process.env.IP || 0.0.0.0;
function lookupMime(filename) {    var ext = .exec(filename)[0];    return {        js: application/javascript,        ico: image/x-icon,        css: text/css,        svg: image/svg+xml,        png: image/png,        jpg: image/jpg,        html: text/html,        jpeg: image/jpeg    }[ext];}   compatibility with node 0.6if (!fs.exists)    fs.exists = path.exists;
var allowSave = process.argv.indexOf(--allow-save) != -1;if (allowSave)    console.warn(writing files from browser is enabled);
http.createServer(function(req, res) {    var uri = unescape(url.parse(req.url).pathname);    var filename = path.join(process.cwd(), uri);
    if (req.method == OPTIONS) {        writeHead(res, 200);        return res.end();    }        if (req.method == PUT) {        if (!allowSave)            return error(res, 404, Saving not allowed pass --allow-save to enable);        return save(req, res, filename);    }
    fs.exists(filename, function(exists) {        if (!exists)            return error(res, 404, 404 Not Found + filename);
        if (fs.statSync(filename).isDirectory())            return serveDirectory(filename, uri, req, res);
        fs.readFile(filename, binary, function(err, file) {            if (err) {                writeHead(res, 500, text/plain);                res.write(err + );                res.end();                return;            }
            var contentType = lookupMime(filename) || text/plain;            writeHead(res, 200, contentType);            res.write(file, binary);            res.end();        });    });}).listen(port, ip);
function writeHead(res, code, contentType) {    var headers = {        Access-Control-Allow-Origin: file://,        Access-Control-Allow-Methods: PUT, GET, OPTIONS, HEAD    };    headers[Content-Type] = contentType;    res.writeHead(code, headers);}
function serveDirectory(filename, uri, req, res) {    var files = fs.readdirSync(filename);    writeHead(res, 200, text/html);        files.push(., ..);    var html = files.map(function(name) {        var href = uri + / + name;        href = href.replace(g, /).replace(g, );        try {            var stat = fs.statSync(filename + / + name);            if (stat.isDirectory())                href += /;            return <a href=' + href + '> + name + </a><br>;        } catch(e) {}    }).filter(Boolean);
    res._hasBody && res.write(html.join());    res.end();}
function error(res, status, message, error) {    console.error(error || message);    writeHead(res, status, text/plain);    res.write(message);    res.end();}
function save(req, res, filePath) {    var data = ;    req.on(data, function(chunk) {        data += chunk;    });    req.on(error, function() {        error(res, 404, Could't save file);    });    req.on(end, function() {        try {            fs.writeFileSync(filePath, data);        }        catch (e) {            return error(res, 404, Could't save file, e);        }        writeHead(res, 200);        res.end(OK);        console.log(saved , filePath);    });}
function getLocalIps() {    var os = require(os);
    var interfaces = os.networkInterfaces ? os.networkInterfaces() : {};    var addresses = [];    for (var k in interfaces) {        for (var k2 in interfaces[k]) {            var address = interfaces[k][k2];            if (address.family === IPv4 && !address.internal) {                addresses.push(address.address);            }        }    }    return addresses;}
console.log(http:// + (ip == 0.0.0.0 ? getLocalIps()[0] : ip) + : + port);
"
"const fs = require(fs);const pkg = require(./package.json);
let hammer = fs.readFileSync(hammer.js, utf8);hammer = hammer.replace({{PKG_VERSION}}g, pkg.version);
fs.writeFile(hammer.js, hammer, utf8, (err) => {  if (err) {    throw err;  }  console.log(String Replaced!);});"
"const path = require(path);
const webpack = require(webpack);const Copy = require(copy-webpack-plugin);
const nodeEnv = process.env.NODE_ENV || development;const isProd = nodeEnv === production;
module.exports = {  devtool: isProd ? hidden-source-map : cheap-eval-source-map,  entry: ./lib/index.js,  output: {    path: path.join(__dirname, app, dist),    filename: bundle.js  },  module: {    loaders: [      {        test: (jsjsx),        exclude: node_modules,        loader: babel-loader      },      {        test: json,        loader: json-loader      }    ]  },  plugins: [    new webpack.DefinePlugin({      process.env: {  eslint-disable-line quote-props        NODE_ENV: JSON.stringify(nodeEnv)      }    }),    new Copy([      {        from: ./assets,        to: ./assets      }    ])  ],  target: electron};"
"var PROD = process.argv.indexOf(-p) >= 0;var webpack = require(webpack);
module.exports = {    plugins: [        new webpack.DefinePlugin({            typeof __DEV__: JSON.stringify(boolean),            __DEV__: PROD ? false : true        })    ],    entry: {        echarts: __dirname + /index.js,        echarts.simple: __dirname + /index.simple.js,        echarts.common: __dirname + /index.common.js    },    output: {        libraryTarget: umd,        library: echarts,        path: __dirname + /dist,        filename: PROD ? [name].min.js : [name].js    }};"
"var TapReporter = require(testem/lib/reporters/tap_reporter);
function FailureOnlyReporter() {  TapReporter.apply(this, arguments);  this._reportCount = 0;}
FailureOnlyReporter.prototype = Object.create(TapReporter.prototype);FailureOnlyReporter.prototype.constructor = FailureOnlyReporter;
FailureOnlyReporter.prototype.display = function(prefix, result) {  this._reportCount++;
  if (!result.passed) {    TapReporter.prototype.display.apply(this, arguments);  }
  if (this._reportCount > 100) {    this.out.write(pass count:  + this.pass);    this._reportCount = 0;  }};
module.exports = {  framework: qunit,  test_page: dist/tests/index.html?hidepassed&hideskipped&timeout=60000,  timeout: 540,  parallel: 1,  disable_watching: true,  launch_in_dev: [    Firefox,    Chrome  ],  launch_in_ci: [    Firefox,    Chrome  ],  reporter: new FailureOnlyReporter()};"
"var webpack = require(webpack);var config = {};
function generateConfig(name) {  var uglify = name.indexOf(min) > -1;  var config = {    entry: ./index.js,    output: {      path: dist/,      filename: name + .js,      sourceMapFilename: name + .map,      library: axios,      libraryTarget: umd    },    node: {      process: false    },    devtool: source-map  };
  config.plugins = [    new webpack.DefinePlugin({      process.env.NODE_ENV: JSON.stringify(process.env.NODE_ENV)    })  ];
  if (uglify) {    config.plugins.push(      new webpack.optimize.UglifyJsPlugin({        compressor: {          warnings: false        }      })    );  }
  return config;}
[axios, axios.min].forEach(function (key) {  config[key] = generateConfig(key);});
module.exports = config;"
"
 * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
var debug = require(debug)(pm2:paths);var p     = require(path);
function getDefaultPM2Home() {  var PM2_ROOT_PATH;
  if (process.env.PM2_HOME)    PM2_ROOT_PATH = process.env.PM2_HOME;  else if (process.env.HOME && !process.env.HOMEPATH)    PM2_ROOT_PATH = p.resolve(process.env.HOME, .pm2);  else if (process.env.HOME || process.env.HOMEPATH)    PM2_ROOT_PATH = p.resolve(process.env.HOMEDRIVE, process.env.HOME || process.env.HOMEPATH, .pm2);  else {    console.error([PM2][Initialization] Environment variable HOME (Linux) or HOMEPATH (Windows) are not set!);    console.error([PM2][Initialization] Defaulting to /etc/.pm2);    PM2_ROOT_PATH = p.resolve(/etc, .pm2);  }
  debug(pm2 home resolved to %s, PM2_ROOT_PATH, process.env.HOME);  return PM2_ROOT_PATH;}
module.exports = function(PM2_HOME) {  if (!PM2_HOME)    PM2_HOME = getDefaultPM2Home()
  var pm2_file_stucture = {    PM2_HOME                 : PM2_HOME,    PM2_ROOT_PATH            : PM2_HOME,
    PM2_CONF_FILE            : p.resolve(PM2_HOME, conf.js),    PM2_MODULE_CONF_FILE     : p.resolve(PM2_HOME, module_conf.json),
    PM2_LOG_FILE_PATH        : p.resolve(PM2_HOME, pm2.log),    PM2_PID_FILE_PATH        : p.resolve(PM2_HOME, pm2.pid),
    DEFAULT_PID_PATH         : p.resolve(PM2_HOME, pids),    DEFAULT_LOG_PATH         : p.resolve(PM2_HOME, logs),    DUMP_FILE_PATH           : p.resolve(PM2_HOME, dump.pm2),
    DAEMON_RPC_PORT          : p.resolve(PM2_HOME, rpc.sock),    DAEMON_PUB_PORT          : p.resolve(PM2_HOME, pub.sock),    INTERACTOR_RPC_PORT      : p.resolve(PM2_HOME, interactor.sock),
    INTERACTOR_LOG_FILE_PATH : p.resolve(PM2_HOME, agent.log),    INTERACTOR_PID_PATH      : p.resolve(PM2_HOME, agent.pid),    INTERACTION_CONF         : p.resolve(PM2_HOME, agent.json5)  };
  if (process.platform === win32 ||      process.platform === win64) {    @todo instead of static unique rpc/pub file custom with PM2_HOME or UID    pm2_file_stucture.DAEMON_RPC_PORT = .piperpc.sock;    pm2_file_stucture.DAEMON_PUB_PORT = .pipepub.sock;    pm2_file_stucture.INTERACTOR_RPC_PORT = .pipeinteractor.sock;  }
  return pm2_file_stucture;};"
"module.exports = function (grunt) {   Full list of files that must be included by RequireJS  includes = [    jquery.select2,    almond,
    jquery-mousewheel  shimmed for non-full builds  ];
  fullIncludes = [    jquery,
    select2/compat/containerCss,    select2/compat/dropdownCss,
    select2/compat/initSelection,    select2/compat/inputData,    select2/compat/matcher,    select2/compat/query,
    select2/dropdown/attachContainer,    select2/dropdown/stopPropagation,
    select2/selection/stopPropagation  ].concat(includes);
  var i18nModules = [];  var i18nPaths = {};
  var i18nFiles = grunt.file.expand({    cwd: src/js  }, select2/i18n/*.js);
  var testFiles = grunt.file.expand(tests/**/*.html);  var testUrls = testFiles.map(function (filePath) {    return http://localhost:9999/ + filePath;  });
  var testBuildNumber = unknown;
  if (process.env.TRAVIS_JOB_ID) {    testBuildNumber = travis- + process.env.TRAVIS_JOB_ID;  } else {    var currentTime = new Date();
    testBuildNumber = manual- + currentTime.getTime();  }
  for (var i = 0; i < i18nFiles.length; i++) {    var file = i18nFiles[i];    var name = file.split(.)[0];
    i18nModules.push({      name: name    });
    i18nPaths[name] = ../../ + name;  }
  var minifiedBanner = ;
  grunt.initConfig({    package: grunt.file.readJSON(package.json),
    clean: {      docs: [docs/_site]    },
    concat: {      dist: {        options: {          banner: grunt.file.read(src/js/wrapper.start.js),        },        src: [          dist/js/select2.js,          src/js/wrapper.end.js        ],        dest: dist/js/select2.js      },      dist.full: {        options: {          banner: grunt.file.read(src/js/wrapper.start.js),        },        src: [          dist/js/select2.full.js,          src/js/wrapper.end.js        ],        dest: dist/js/select2.full.js      }    },
    connect: {      tests: {        options: {          base: .,          hostname: 127.0.0.1,          port: 9999        }      }    },
    uglify: {      dist: {        src: dist/js/select2.js,        dest: dist/js/select2.min.js,        options: {          banner: minifiedBanner        }      },      dist.full: {        src: dist/js/select2.full.js,        dest: dist/js/select2.full.min.js,        options: {          banner: minifiedBanner        }      }    },
    qunit: {      all: {        options: {          urls: testUrls        }      }    },
    saucelabs-qunit: {      all: {        options: {          build: testBuildNumber,          tags: [tests, qunit],          urls: testUrls,          testname: QUnit test for Select2,          browsers: [            {              browserName: internet explorer,              version: 8            },            {              browserName: internet explorer,              version: 9            },            {              browserName: internet explorer,              version: 10            },            {              browserName: internet explorer,              version: 11            },
            {              browserName: firefox,              platform: linux            },
            {              browserName: chrome            },
            {              browserName: opera,              version: 12,              platform: linux            }          ]        }      }    },
    gh-pages: {      options: {        base: docs,        branch: master,        clone: node_modules/grunt-gh-pages/repo,        message: Updated docs with master,        push: true,        repo: git@github.com:select2/select2.github.io.git      },      src:     },
    jekyll: {      options: {        src: docs,        dest: docs/_site      },      build: {        d: null      },      serve: {        options: {          serve: true,          watch: true        }      }    },
    jshint: {      options: {        jshintrc: true      },      code: {        src: [src/js/**/*.js]      },      tests: {        src: [tests/**/*.js]      }    },
    sass: {      dist: {        options: {          outputStyle: compressed        },        files: {          dist/css/select2.min.css: [            src/scss/core.scss,            src/scss/theme/default/layout.css          ]        }      },      dev: {        options: {          outputStyle: nested        },        files: {          dist/css/select2.css: [            src/scss/core.scss,            src/scss/theme/default/layout.css          ]        }      }    },
    symlink: {      docs: {        cwd: dist,        expand: true,        overwrite: false,        src: [                  ],        dest: docs/dist,        filter: isDirectory      }    },
    requirejs: {      dist: {        options: {          baseUrl: src/js,          optimize: none,          name: select2/core,          out: dist/js/select2.js,          include: includes,          namespace: S2,          paths: {            almond: require.resolve(almond).slice(0, -3),            jquery: jquery.shim,            jquery-mousewheel: jquery.mousewheel.shim          },          wrap: {            startFile: src/js/banner.start.js,            endFile: src/js/banner.end.js          }        }      },      dist.full: {        options: {          baseUrl: src/js,          optimize: none,          name: select2/core,          out: dist/js/select2.full.js,          include: fullIncludes,          namespace: S2,          paths: {            almond: require.resolve(almond).slice(0, -3),            jquery: jquery.shim,            jquery-mousewheel: require.resolve(jquery-mousewheel).slice(0, -3)          },          wrap: {            startFile: src/js/banner.start.js,            endFile: src/js/banner.end.js          }        }      },      i18n: {        options: {          baseUrl: src/js/select2/i18n,          dir: dist/js/i18n,          paths: i18nPaths,          modules: i18nModules,          namespace: S2,          wrap: {            start: minifiedBanner + grunt.file.read(src/js/banner.start.js),            end: grunt.file.read(src/js/banner.end.js)          }        }      }    },
    watch: {      js: {        files: [          src/js/select2/**/*.js,          tests/**/*.js        ],        tasks: [          compile,          test,          minify        ]      },      css: {        files: [          src/scss/**/*.scss        ],        tasks: [          compile,          minify        ]      }    }  });
  grunt.loadNpmTasks(grunt-contrib-clean);  grunt.loadNpmTasks(grunt-contrib-concat);  grunt.loadNpmTasks(grunt-contrib-connect);  grunt.loadNpmTasks(grunt-contrib-jshint);  grunt.loadNpmTasks(grunt-contrib-qunit);  grunt.loadNpmTasks(grunt-contrib-requirejs);  grunt.loadNpmTasks(grunt-contrib-symlink);  grunt.loadNpmTasks(grunt-contrib-uglify);  grunt.loadNpmTasks(grunt-contrib-watch);
  grunt.loadNpmTasks(grunt-gh-pages);  grunt.loadNpmTasks(grunt-jekyll);  grunt.loadNpmTasks(grunt-saucelabs);  grunt.loadNpmTasks(grunt-sass);
  grunt.registerTask(default, [compile, test, minify]);
  grunt.registerTask(compile, [    requirejs:dist, requirejs:dist.full, requirejs:i18n,    concat:dist, concat:dist.full,    sass:dev  ]);  grunt.registerTask(minify, [uglify, sass:dist]);  grunt.registerTask(test, [connect:tests, qunit, jshint]);
  var ciTasks = [];
  ciTasks.push(compile)  ciTasks.push(connect:tests);
   Can't run Sauce Labs tests in pull requests  if (process.env.TRAVIS_PULL_REQUEST == false) {    ciTasks.push(saucelabs-qunit);  }
  ciTasks.push(qunit);  ciTasks.push(jshint);
  grunt.registerTask(ci, ciTasks);
  grunt.registerTask(docs, [symlink:docs, jekyll:serve]);
  grunt.registerTask(docs-release, [default, clean:docs, gh-pages]);};"
"
var browsers = require(./test/browser/sauce-browsers.json);var serveStatic = require(serve-static);
module.exports = function(grunt) {  use strict;
   load grunt dependencies  require(load-grunt-tasks)(grunt);
  var browserTests = grunt.file.expand([    test/universal/**/*.js,    test/browser/**/*.js,    !test/browser/setup.js,    !test/browser/integration/*.js  ]);
  grunt.initConfig({    env: {      nodeTests: [        test/universal/**/*.js,        test/node/**/*.js      ],      browserTests: browserTests,      coverage: {        APP_DIR_FOR_CODE_COVERAGE: test/coverage/instrument,        urls: [          http://localhost:9999/test/unit.html,          http://localhost:9999/test/index.html        ]      }    },    generate: {      dest: ./dist/modernizr-build.js    },    copy: {      gh-pages: {        files: [          {            expand: true,            src: [              ./**/*,              !./test/coverage/**,              !./node_modules/*grunt-*/**,              !./node_modules/**/node_modules/**            ],            dest: gh-pages          }        ]      }    },    eslint: {      target: [        <%= env.nodeTests%>,        <%= env.browserTests %>,        test/browser/setup.js,        test/browser/integration/*.js,        Gruntfile.js,        src/*.js,        lib/*.js,        test/**/*.js,        feature-detects/**/*.js,        !src/html5printshiv.js,        !test/coverage/**/*.js,        !test/js/lib/**/*.js,        !src/html5shiv.js      ],      options: {        rulePaths: [test/eslint/rules]      }    },    clean: {      dist: [        dist,        test/coverage,        test/*.html,        gh-pages      ]    },    jade: {      compile: {        options: {          data: {            unitTests: browserTests,            integrationTests: grunt.file.expand([test/browser/integration/*.js])          }        },        files: {          test/unit.html: test/browser/unit.jade,          test/iframe.html: test/browser/iframe.jade,          test/index.html: test/browser/integration.jade        }      }    },    connect: {      server: {        options: {          middleware: function() {            return [              function(req, res, next) {                 catchall middleware used in testing                var ua = req.headers[user-agent];
                 record code coverage results from browsers                if (req.url == /coverage/client && req.method == POST) {                  var name = encodeURI(ua.replace(g, -));                  var body = ;
                  req.on(data, function(data) {                    body = body + data;                  });
                  req.on(end, function() {                    grunt.file.write(test/coverage/reports/ + name + .json, body);                    res.end();                  });
                  return;                }
                 redirect requests form the `require`d components to their instrumented versions                if (req.url.match((srclib))) {                  req.url = /test/coverage/instrument + req.url;                }
                next();              },              serveStatic(__dirname)            ];          },          port: 9999        }      }    },    saucelabs-custom: {      all: {        options: {          urls:  <%= env.coverage.urls %>,          testname: process.env.CI_BUILD_NUMBER || Modernizr Test,          browsers: browsers,          maxRetries: 3        }      }    },    mocha: {      test: {        options: {          urls: <%= env.coverage.urls %>,          log: true        },      },    },     `mocha` runs browser tests, `mochaTest` runs node tests    mochaTest: {      test: {        options: {          reporter: dot,          timeout: 5000        },        src: [<%= env.nodeTests%>]      }    },    instrument: {      files: [        src/**/*.js,        lib/**/*.js      ],      options: {        basePath: test/coverage/instrument/      }    },    storeCoverage: {      options: {        dir: test/coverage/reports      }    },    makeReport: {      src: test/coverage/reports/**/*.json,      options: {        type: lcov,        dir: test/coverage/reports,        print: detail      }    },    coveralls: {      all: {        src: test/coverage/reports/lcov.info,        options: {          force: true        }      }    }  });
  grunt.registerMultiTask(generate, Create a version of Modernizr from Grunt, function() {    var done = this.async();    var config = require(./lib/config-all);    var modernizr = require(./lib/cli);    var dest = this.data;
    modernizr.build(config, function(output) {      grunt.file.write(dest, output);      done();    });  });
  grunt.registerTask(nodeTests, [mochaTest]);
  grunt.registerTask(browserTests, [connect, mocha]);
  grunt.registerTask(build, [clean, generate]);
  grunt.registerTask(default, [eslint, build]);
  var tests = [clean, eslint, jade, instrument, env:coverage, nodeTests];
  if (process.env.APPVEYOR) {    grunt.registerTask(test, tests);  } else if (process.env.BROWSER_COVERAGE !== true) {    grunt.registerTask(test, tests.concat([generate, browserTests]));  } else {    grunt.registerTask(test, tests.concat([generate, storeCoverage, browserTests, saucelabs-custom, makeReport, coveralls]));  }};"
"use strict;
const plumber = require(gulp-plumber);const through = require(through2);const chalk = require(chalk);const newer = require(gulp-newer);const babel = require(gulp-babel);const watch = require(gulp-watch);const gutil = require(gulp-util);const gulp = require(gulp);const path = require(path);
const base = path.join(__dirname, packages);const scripts = ./packages/*/src/**/*.js;
function swapSrcWithLib(srcPath) {  const parts = srcPath.split(path.sep);  parts[1] = lib;  return parts.join(path.sep);}
gulp.task(default, [build]);
gulp.task(build, function () {  return gulp.src(scripts, { base: base })    .pipe(plumber({      errorHandler: function (err) {        gutil.log(err.stack);      },    }))    .pipe(newer({      dest: base,      map: swapSrcWithLib,    }))    .pipe(through.obj(function (file, enc, callback) {      gutil.log(Compiling, ' + chalk.cyan(file.relative) + '...);      callback(null, file);    }))    .pipe(babel())    .pipe(through.obj(function (file, enc, callback) {       Passing 'file.relative' because newer() above uses a relative path and this keeps it consistent.      file.path = path.resolve(file.base, swapSrcWithLib(file.relative));      callback(null, file);    }))    .pipe(gulp.dest(base));});
gulp.task(watch, [build], function () {  watch(scripts, { debounceDelay: 200 }, function () {    gulp.start(build);  });});"
"use strict;
let envOpts = {  loose: true};
module.exports = {  comments: false,  presets: [    [      env, envOpts    ],    stage-0,    flow,  ],  env: {    cov: {      auxiliaryCommentBefore: istanbul ignore next,      plugins: [istanbul]    }  }};
if (process.env.BABEL_ENV === development) {  envOpts.targets = {    node: current  };  envOpts.debug = true;};"
"module.exports = function(config) {    config.set({        browsers: [Firefox],        files: [mocha_test/*.js],        frameworks: [browserify, mocha],        preprocessors: {            mocha_test/*.js: [browserify]        },        reporters: [mocha],        singleRun: true,
        browserify: {            debug: true,            transform: [babelify]        },
        client: {            mocha: {                grep: @nodeonly,                invert: true            }        }    });};"
" # Ghost Startup Orchestrates the startup of Ghost when run from command line.console.time(Ghost boot);
var debug = require(debug)(ghost:boot:index),    ghost, express, logging, errors, utils, parentApp;
debug(First requires...);
ghost = require(./core);
debug(Required ghost);
express = require(express);logging = require(./core/server/logging);errors = require(./core/server/errors);utils = require(./core/server/utils);parentApp = express();
debug(Initialising Ghost);ghost().then(function (ghostServer) {     Mount our Ghost instance on our desired subdirectory path if it exists.    parentApp.use(utils.url.getSubdir(), ghostServer.rootApp);
    debug(Starting Ghost);     Let Ghost handle starting our server instance.    return ghostServer.start(parentApp).then(function afterStart() {        console.timeEnd(Ghost boot);         if IPC messaging is enabled, ensure ghost sends message to parent         process on successful start        if (process.send) {            process.send({started: true});        }    });}).catch(function (err) {    if (!errors.utils.isIgnitionError(err)) {        err = new errors.GhostError({err: err});    }
    if (process.send) {        process.send({started: false, error: err.message});    }
    logging.error(err);    process.exit(-1);});"
"var config = require(./core/server/config),    ghostVersion = require(./core/server/utils/ghost-version);
 * knex-migrator can be used via CLI or within the application * when using the CLI, we need to ensure that our global overrides are triggered */require(./core/server/overrides);
module.exports = {    currentVersion: ghostVersion.safe,    database: config.get(database),    migrationPath: config.get(paths:migrationPath)};"
" # Task automation for Ghost Run various tasks when developing for and working with Ghost. **Usage instructions:** can be found in the [Custom Tasks](#custom%20tasks) section or by running `grunt --help`. **Debug tip:** If you have any problems with any Grunt tasks, try running them with the `--verbose` command
 jshint unused: falsevar overrides      = require(./core/server/overrides),    config         = require(./core/server/config),    utils          = require(./core/server/utils),    _              = require(lodash),    chalk          = require(chalk),    fs             = require(fs-extra),    KnexMigrator   = require(knex-migrator),    knexMigrator = new KnexMigrator({        knexMigratorFilePath: config.get(paths:appRoot)    }),
    path           = require(path),
    escapeChar     = process.platform.match(win) ? ^ : ,    cwd            = process.cwd().replace(( )g, escapeChar + $1),    buildDirectory = path.resolve(cwd, .build),    distDirectory  = path.resolve(cwd, .dist),
     ## Grunt configuration
    configureGrunt = function (grunt) {         #### Load all grunt tasks                 Find all of the task which start with `grunt-` and load them, rather than explicitly declaring them all        require(matchdep).filterDev([grunt-*, !grunt-cli]).forEach(grunt.loadNpmTasks);
        var cfg = {             #### Common paths used by tasks            paths: {                build: buildDirectory,                releaseBuild: path.join(buildDirectory, release),                dist: distDirectory,                releaseDist: path.join(distDirectory, release)            },             Standard build type, for when we have nightlies again.            buildType: Build,             Load package.json so that we can create correctly versioned releases.            pkg: grunt.file.readJSON(package.json),
            clientFiles: [                server/admin/views/default.html,                built/assets/ghost.js,                built/assets/ghost.css,                built/assets/vendor.js,                built/assets/vendor.css            ],
             ### grunt-contrib-watch             Watch files and livereload in the browser during development.             See the [grunt dev](#live%20reload) task for how this is used.            watch: {                livereload: {                    files: [                        content/themes/casper/assets/css/*.css,                        content/themes/casper/assets/js/*.js                    ],                    options: {                        livereload: true                    }                },                express: {                    files:  [core/ghost-server.js, core/server/**/*.js, config.*.json],                    tasks:  [express:dev],                    options: {                        nospawn: true,                        livereload: true                    }                }            },
             ### grunt-express-server             Start a Ghost expess server for use in development and testing            express: {                options: {                    script: index.js,                    output: Ghost is running                },
                dev: {                    options: {}                },                test: {                    options: {                        node_env: testing                    }                }            },
             ### grunt-contrib-jshint             Linting rules, run as part of `grunt validate`. See [grunt validate](#validate) and its subtasks for             more information.            jshint: {                options: {                    jshintrc: .jshintrc                },
                server: [                    ,                    !config.*.json,  note: i added this, do we want this linted?                    core/*.js,                    core/server/**/*.js,                    core/test/**/*.js,                    !core/test/coverage/**,                    !core/server/public/**/*.js                ]            },
            jscs: {                options: {                    config: true                },
                server: {                    files: {                        src: [                            ,                            !config.*.json,  note: i added this, do we want this linted?                            core/*.js,                            core/server/**/*.js,                            core/test/**/*.js,                            !core/test/coverage/**,                            !core/server/public/**/*.js                        ]                    }                }            },
             ### grunt-mocha-cli             Configuration for the mocha test runner, used to run unit, integration and route tests as part of             `grunt validate`. See [grunt validate](#validate) and its sub tasks for more information.            mochacli: {                options: {                    ui: bdd,                    reporter: grunt.option(reporter) || spec,                    timeout: 30000,                    save: grunt.option(reporter-output),                    require: [core/server/overrides]                },
                 #### All Unit tests                unit: {                    src: [                        core/test/unit/**/*_spec.js,                        core/server/apps/**/tests/*_spec.js                    ]                },
                 #### All Integration tests                integration: {                    src: [                        core/test/integration/**/*_spec.js,                        core/test/integration/*_spec.js                    ]                },
                 #### All Route tests                routes: {                    src: [                        core/test/functional/routes/**/*_spec.js                    ]                },
                 #### All Module tests                module: {                    src: [                        core/test/functional/module/**/*_spec.js                    ]                },
                 #### Run single test (src is set dynamically, see grunt task 'test')                single: {}            },
             ### grunt-mocha-istanbul             Configuration for the mocha test coverage generator             `grunt coverage`.            mocha_istanbul: {                coverage: {                     they can also have coverage generated for them & the order doesn't matter                    src: [                        core/test/unit,                        core/server/apps                    ],                    options: {                        mask: ,                        coverageFolder: core/test/coverage/unit,                        mochaOptions: [--timeout=15000, --require, core/server/overrides],                        excludes: [core/client, core/server/built]                    }                },                coverage_all: {                    src: [                        core/test/integration,                        core/server/apps,                        core/test/functional,                        core/test/unit                    ],                    options: {                        coverageFolder: core/test/coverage/all,                        mask: ,                        mochaOptions: [--timeout=15000, --require, core/server/overrides],                        excludes: [core/client, core/server/built]                    }
                }            },
            bgShell: {                client: {                    cmd: grunt subgrunt:watch,                    bg: grunt.option(client) ? false : true,                    stdout: function (chunk) {                         hide certain output to prevent confusion when running alongside server                        var filter = grunt.option(client) ? false : [                            > ghost-admin,                            Livereload,                            Serving on                        ].some(function (regexp) {                            return regexp.test(chunk);                        });
                        if (!filter) {                            grunt.log.write(chunk);                        }                    },                    stderr: true                }            },
             ### grunt-shell             Command line tools where it's easier to run a command directly than configure a grunt plugin            shell: {                master: {                    command: function () {                        var upstream = grunt.option(upstream) || process.env.GHOST_UPSTREAM || upstream;                        grunt.log.writeln(Pulling down the latest master from  + upstream);                        return git checkout master; git pull  + upstream +  master;  +                        yarn; git submodule foreach ""git checkout master && git pull  +                        upstream +  master"";                    }                },
                dbhealth: {                    command: knex-migrator health                }            },
             ### grunt-docker             Generate documentation from code            docker: {                docs: {                    dest: docs,                    src: [.],                    options: {                        onlyUpdated: true,                        exclude: node_modules,bower_components,content,core/client,*test,*doc*, +                         +                        MigratorConfig.js                    }                }            },
             ### grunt-contrib-clean             Clean up files as part of other tasks            clean: {                built: {                    src: [                        core/built/**,                        core/client/dist/**                    ]                },                release: {                    src: [<%= paths.releaseBuild %>/**]                },                test: {                    src: [content/data/ghost-test.db]                },                tmp: {                    src: [.tmp/**]                },                dependencies: {                    src: [node_modules/**, core/client/bower_components/**, core/client/node_modules/**]                }            },
             ### grunt-contrib-compress             Zip up files for builds / releases            compress: {                release: {                    options: {                        archive: <%= paths.releaseDist %>/Ghost-<%= pkg.version %>.zip                    },                    expand: true,                    cwd: <%= paths.releaseBuild %>/,                    src: []                }            },
             ### grunt-update-submodules             Grunt task to update git submodules            update_submodules: {                pinned: {                    options: {                        params: --init                    }                }            },
            uglify: {                prod: {                    options: {                        sourceMap: false                    },                    files: {                        core/server/public/ghost-url.min.js: core/server/public/ghost-url.js                    }                }            },
            cssnano: {                prod: {                    options: {                        sourcemap: false                    },                    files: {                        core/server/public/ghost.min.css: core/server/public/ghost.css                    }                }            },
             ### grunt-subgrunt             Run grunt tasks in submodule Gruntfiles            subgrunt: {                options: {                    npmInstall: false,                    npmPath: yarn                },
                init: {                    options: {                        npmInstall: true                    },                    projects: {                        core/client: init                    }                },
                dev: {                    core/client: shell:ember:dev                },
                prod: {                    core/client: shell:ember:prod                },
                watch: {                    projects: {                        core/client: [shell:ember:watch, --live-reload-base-url="" + utils.url.getSubdir() + /ghost/""]                    }                }            },
             ### grunt-contrib-symlink             Create symlink for git hooks            symlink: {                githooks: {                     Enable overwrite to delete symlinks before recreating them                    overwrite: false,                     Enable force to overwrite symlinks outside the current working directory                    force: false,                     Expand to all files in /hooks                    expand: true,                    cwd: .github/hooks,                    src: [],                    dest: .git/hooks                }            }        };
         Load the configuration        grunt.initConfig(cfg);
         # Custom Tasks
         Ghost has a number of useful tasks that we use every day in development. Tasks marked as *Utility* are used         by grunt to perform current actions, but isn't useful to developers.                 Skip ahead to the section on:                 * [Building assets](#building%20assets):             `grunt init`, `grunt` & `grunt prod` or live reload with `grunt dev`         * [Testing](#testing):             `grunt validate`, the `grunt test-*` sub-tasks or generate a coverage report with `grunt coverage`.
         ### Help         Run `grunt help` on the commandline to get a print out of the available tasks and details of         what each one does along with any available options. This is an alias for `grunt --help`        grunt.registerTask(help,            Outputs help information if you type `grunt help` instead of `grunt --help`,            function () {                console.log(Type `grunt --help` to get the details of available grunt tasks.);            });
         ### Documentation         Run `grunt docs` to generate annotated source code using the documentation described in the code comments.        grunt.registerTask(docs, Generate Docs, [docker]);
         Run `grunt watch-docs` to setup livereload & watch whilst you're editing the docs        grunt.registerTask(watch-docs, function () {            grunt.config.merge({                watch: {                    docs: {                        files: [core/server/**/*, index.js, Gruntfile.js],                        tasks: [docker],                        options: {                            livereload: true                        }                    }                }            });
            grunt.task.run(watch:docs);        });
         ## Testing
         Ghost has an extensive set of test suites. The following section documents the various types of tests         and how to run them.                 TLDR; run `grunt validate`
         #### Set Test Env *(Utility Task)*         Set the NODE_ENV to 'testing' unless the environment is already set to TRAVIS.         This ensures that the tests get run under the correct environment, using the correct database, and         that they work as expected. Trying to run tests with no ENV set will throw an error to do with `client`.        grunt.registerTask(setTestEnv,            Use ""testing"" Ghost config; unless we are running on travis (then show queries for debugging),            function () {                process.env.NODE_ENV = process.env.TRAVIS ? process.env.NODE_ENV : testing;                cfg.express.test.options.node_env = process.env.NODE_ENV;            });
         ### Test         **Testing utility**                 `grunt test:unit/apps_spec.js` will run just the tests inside the apps_spec.js file                 It works for any path relative to the core/test folder. It will also run all the tests in a single directory         You can also run a test with grunt test:core/test/unit/... to get bash autocompletion                 `grunt test:integration/api` - runs the api integration tests         `grunt test:integration` - runs the integration tests in the root folder and excludes all api & model tests        grunt.registerTask(test, Run a particular spec file from the core/test directory e.g. `grunt test:unit/apps_spec.js`, function (test) {            if (!test) {                grunt.fail.fatal(No test provided. `grunt test` expects a filename. e.g.: `grunt test:unit/apps_spec.js`. Did you mean `npm test` or `grunt validate`?);            }
            if (!test.match(coretest) && !test.match(coreserver)) {                test = core/test/ + test;            }
             CASE: execute folder            if (!test.match(js)) {                test += ;            } else if (!fs.existsSync(test)) {                grunt.fail.fatal(This file does not exist!);            }
            cfg.mochacli.single.src = [test];            grunt.initConfig(cfg);            grunt.task.run(test-setup, mochacli:single);        });
         #### Stub out ghost files *(Utility Task)*         Creates stub files in the built directory and the views directory         so that the test environments do not need to build out the client files        grunt.registerTask(stubClientFiles, function () {            _.each(cfg.clientFiles, function (file) {                var filePath = path.resolve(cwd + /core/ + file);                fs.ensureFileSync(filePath);            });        });
                 * Ensures the target database get's automatically created.         */        grunt.registerTask(knex-migrator, function () {            return knexMigrator.init({noScripts: true});        });
         ### Validate         **Main testing task**                 `grunt validate` will either run all tests or run linting         `grunt validate` is called by `npm test` and is used by Travis.        grunt.registerTask(validate, Run tests or lint code, function () {            if (process.env.TEST_SUITE === lint) {                return grunt.task.run([lint]);            }
            grunt.task.run([test-all]);        });
         ### Test-All         **Main testing task**                 `grunt test-all` will lint and test your pre-built local Ghost codebase.                grunt.registerTask(test-all, Run all server tests,            [test-routes, test-module, test-unit, test-integration]);
         ### Lint                 `grunt lint` will run the linter and the code style checker so you can make sure your code is pretty        grunt.registerTask(lint, Run the code style checks and linter for server,            [jshint, jscs]        );
         ### test-setup *(utility)(         `grunt test-setup` will run all the setup tasks required for running tests        grunt.registerTask(test-setup, Setup ready to run tests,            [knex-migrator, clean:test, setTestEnv, stubClientFiles]        );
         ### Unit Tests *(sub task)*         `grunt test-unit` will run just the unit tests                 If you need to run an individual unit test file, you can use the `grunt test:<file_path>` task:                 `grunt test:unit/config_spec.js`                 This also works for folders (although it isn't recursive), E.g.                 `grunt test:unit/server_helpers`                 Unit tests are run with [mocha](http://mochajs.org/) using         [should](https://github.com/visionmedia/should.js) to describe the tests in a highly readable style.         Unit tests do **not** touch the database.         A coverage report can be generated for these tests using the `grunt test-coverage` task.        grunt.registerTask(test-unit, Run unit tests (mocha),            [test-setup, mochacli:unit]        );
         ### Integration tests *(sub task)*         `grunt test-integration` will run just the integration tests                 Provided you already have a `config.*.json` file, you can run just the model integration tests by running:                 `grunt test:integration/model`                 Or just the api integration tests by running:                 `grunt test:integration/api`                 Integration tests are run with [mocha](http://mochajs.org/) using         [should](https://github.com/visionmedia/should.js) to describe the tests in a highly readable style.         Integration tests are different to the unit tests because they make requests to the database.                 If you need to run an individual integration test file you can use the `grunt test:<file_path>` task:                 `grunt test:integration/api/api_tags_spec.js`                 Their purpose is to test that both the api and models behave as expected when the database layer is involved.         These tests are run against sqlite3 and mysql on travis and ensure that differences between the databases         don't cause bugs.                 A coverage report can be generated for these tests using the `grunt test-coverage` task.        grunt.registerTask(test-integration, Run integration tests (mocha + db access),            [test-setup, mochacli:integration]        );
         ### Route tests *(sub task)*         `grunt test-routes` will run just the route tests                 If you need to run an individual route test file, you can use the `grunt test:<file_path>` task:                 `grunt test:functional/routes/admin_spec.js`                 Route tests are run with [mocha](http://mochajs.org/) using         [should](https://github.com/visionmedia/should.js) and [supertest](https://github.com/visionmedia/supertest)         to describe and create the tests.                 Supertest enables us to describe requests that we want to make, and also describe the response we expect to         receive back. It works directly with express, so we don't have to run a server to run the tests.                 The purpose of the route tests is to ensure that all of the routes (pages, and API requests) in Ghost         are working as expected, including checking the headers and status codes received. It is very easy and         quick to test many permutations of routes / urls in the system.        grunt.registerTask(test-routes, Run functional route tests (mocha),            [test-setup, mochacli:routes]        );
         ### Module tests *(sub task)*         `grunt test-module` will run just the module tests                 The purpose of the module tests is to ensure that Ghost can be used as an npm module and exposes all         required methods to interact with it.        grunt.registerTask(test-module, Run functional module tests (mocha),            [test-setup, mochacli:module]        );
         ### Coverage         `grunt coverage` will generate a report for the Unit Tests.                 This is not currently done as part of CI or any build, but is a tool we have available to keep an eye on how         well the unit and integration tests are covering the code base.         Ghost does not have a minimum coverage level - we're more interested in ensuring important and useful areas         of the codebase are covered, than that the whole codebase is covered to a particular level.                 Key areas for coverage are: helpers and theme elements, apps / GDK, the api and model layers.
        grunt.registerTask(coverage, Generate unit and integration (mocha) tests coverage report,            [test-setup, mocha_istanbul:coverage]        );
        grunt.registerTask(coverage-all, Generate unit and integration tests coverage report,            [test-setup, mocha_istanbul:coverage_all]        );
         #### Master Warning *(Utility Task)*         Warns git users not ot use the `master` branch in production.         `master` is an unstable branch and shouldn't be used in production as you run the risk of ending up with a         database in an unrecoverable state. Instead there is a branch called `stable` which is the equivalent of the         release zip for git users.        grunt.registerTask(master-warn,            Outputs a warning to runners of grunt prod, that master shouldnt be used for live blogs,            function () {                console.log(chalk.red(                    Use the  + chalk.bold(stable) +  branch for live blogs.                     + chalk.bold.underline(Never) +  master!                ));                console.log(>, Always two there are, no more, no less. A master and a  + chalk.bold(stable) + .);            });
         ## Building assets                 Ghost's GitHub repository contains the un-built source code for Ghost. If you're looking for the already         built release zips, you can get these from the [release page](https://github.com/TryGhost/Ghost/releases) on         GitHub or from https://ghost.org/download. These zip files are created using the [grunt release](#release)         task.                 If you want to work on Ghost core, or you want to use the source files from GitHub, then you have to build         the Ghost assets in order to make them work.                 There are a number of grunt tasks available to help with this. Firstly after fetching an updated version of         the Ghost codebase, after running `yarn install`, you will need to run [grunt init](#init%20assets).                 For production blogs you will need to run [grunt prod](#production%20assets).                 For updating assets during development, the tasks [grunt](#default%20asset%20build) and         [grunt dev](#live%20reload) are available.
         ### Init assets         `grunt init` - will run an initial asset build for you                 Grunt init runs `yarn install && bower install` inside `core/client` as well as the standard asset build         tasks which occur when you run just `grunt`. This fetches the latest client-side dependencies.                 This task is very important, and should always be run when fetching down an updated code base just after         running `yarn install`.                 `bower` does have some quirks, such as not running as root. If you have problems please try running         `grunt init --verbose` to see if there are any errors.        grunt.registerTask(init, Prepare the project for development,            [update_submodules:pinned, subgrunt:init, clean:tmp, default]);
         ### Build assets         `grunt build` - will build client assets (without updating the submodule)                 This task is identical to `grunt init`, except it does not build client dependencies        grunt.registerTask(build, Build client app,            [subgrunt:init, clean:tmp, default]);
         ### Default asset build         `grunt` - default grunt task                 Build assets and dev version of the admin app.        grunt.registerTask(default, Build JS & templates for development,            [subgrunt:dev]);
         ### Production assets         `grunt prod` - will build the minified assets used in production.                 It is otherwise the same as running `grunt`, but is only used when running Ghost in the `production` env.        grunt.registerTask(prod, Build JS & templates for production,            [subgrunt:prod, uglify:prod, cssnano:prod, master-warn]);
         ### Live reload         `grunt dev` - build assets on the fly whilst developing                 If you want Ghost to live reload for you whilst you're developing, you can do this by running `grunt dev`.         This works hand-in-hand with the [livereload](http://livereload.com/) chrome extension.                 `grunt dev` manages starting an express server and restarting the server whenever core files change (which         require a server restart for the changes to take effect) and also manage reloading the browser whenever         frontend code changes.                 Note that the current implementation of watch only works with casper, not other themes.        grunt.registerTask(dev, Dev Mode; watch files and restart server on changes, function () {            if (grunt.option(client)) {                grunt.task.run([bgShell:client]);            } else if (grunt.option(server)) {                grunt.task.run([express:dev, watch]);            } else {                grunt.task.run([bgShell:client, express:dev, watch]);            }        });
         ### grunt master         This command helps you to bring your working directory back to current master.         It will also update your dependencies to master and shows you if your database is healthy.         It won't build the client!                 `grunt master` [`upstream` is the default upstream to pull from]         `grunt master --upstream=parent`        grunt.registerTask(master, Update your current working folder to latest master.,            [shell:master, subgrunt:init, shell:dbhealth]        );
         ### Release         Run `grunt release` to create a Ghost release zip file.         Uses the files specified by `.npmignore` to know what should and should not be included.         Runs the asset generation tasks for both development and production so that the release can be used in         either environment, and packages all the files up into a zip.        grunt.registerTask(release,            Release task - creates a final built zip +             - Do our standard build steps  +             - Copy files to release-folder/#/#{version} directory +             - Clean out unnecessary files (travis, .git*, etc) +             - Zip files in release-folder to dist-folder/#{version} directory,            function () {                grunt.config.set(copy.release, {                    expand: true,                     #### Build File Patterns                     A list of files and patterns to include when creating a release zip.                     This is read from the `.npmignore` file and all patterns are inverted as the `.npmignore`                     file defines what to ignore, whereas we want to define what to include.                    src: fs.readFileSync(.npmignore, utf8).split().filter(Boolean).map(function (pattern) {                        return pattern[0] === ! ? pattern.substr(1) : ! + pattern;                    }),                    dest: <%= paths.releaseBuild %>/                });
                grunt.task.run([init, prod, clean:release, copy:release, compress:release]);            }        );    };
module.exports = configureGrunt;"
" This is not the main file in the npm package, but here so we can use github tarballs as packages when necessary.module.exports = require(./build/);"
" * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
process.env.PM2_PROGRAMMATIC = true;
var API = require(./lib/API.js);
module.exports = new API;module.exports.custom = API;"
" * Copyright 2013 the PM2 project authors. All rights reserved. * Use of this source code is governed by a license that * can be found in the LICENSE file. */
var debug  = require(debug)(pm2:conf);var p      = require(path);var util   = require(util);var chalk  = require(chalk);var semver = require(semver);
 * Get PM2 path structure */var path_structure = require(./paths.js)(process.env.OVER_HOME);
 * Constants variables used by PM2 */var csts = {  PREFIX_MSG              : chalk.green([PM2] ),  PREFIX_MSG_ERR          : chalk.red([PM2][ERROR] ),  PREFIX_MSG_MOD          : chalk.bold.green([PM2][Module] ),  PREFIX_MSG_MOD_ERR      : chalk.red([PM2][Module][ERROR] ),  PREFIX_MSG_WARNING      : chalk.yellow([PM2][WARN] ),  PREFIX_MSG_SUCCESS      : chalk.cyan([PM2] ),
  TEMPLATE_FOLDER         : p.join(__dirname, lib/templates),
  APP_CONF_TPL            : ecosystem.tpl,  APP_CONF_TPL_SIMPLE     : ecosystem-simple.tpl,  SAMPLE_CONF_FILE        : sample-conf.js,  LOGROTATE_SCRIPT        : logrotate.d/pm2,
  DOCKERFILE_NODEJS       : Dockerfiles/Dockerfile-nodejs.tpl,  DOCKERFILE_JAVA         : Dockerfiles/Dockerfile-java.tpl,  DOCKERFILE_RUBY         : Dockerfiles/Dockerfile-ruby.tpl,
  SUCCESS_EXIT            : 0,  ERROR_EXIT              : 1,  CODE_UNCAUGHTEXCEPTION  : 1,
  IS_WINDOWS              : (process.platform === win32 || process.platform === win64),  ONLINE_STATUS           : online,  STOPPED_STATUS          : stopped,  STOPPING_STATUS         : stopping,  LAUNCHING_STATUS        : launching,  ERRORED_STATUS          : errored,  ONE_LAUNCH_STATUS       : one-launch-status,
  CLUSTER_MODE_ID         : cluster_mode,  FORK_MODE_ID            : fork_mode,
  KEYMETRICS_ROOT_URL     : process.env.KEYMETRICS_NODE || root.keymetrics.io,  KEYMETRICS_BANNER       : ../lib/keymetrics,  DEFAULT_MODULE_JSON     : package.json,
  REMOTE_PORT_TCP         : isNaN(parseInt(process.env.KEYMETRICS_PUSH_PORT)) ? 80 : parseInt(process.env.KEYMETRICS_PUSH_PORT),  REMOTE_PORT             : 41624,  REMOTE_REVERSE_PORT     : isNaN(parseInt(process.env.KEYMETRICS_REVERSE_PORT)) ? 43554 : parseInt(process.env.KEYMETRICS_REVERSE_PORT),  REMOTE_HOST             : s1.keymetrics.io,  SEND_INTERVAL           : 1000,  GRACEFUL_TIMEOUT        : parseInt(process.env.PM2_GRACEFUL_TIMEOUT) || 8000,  GRACEFUL_LISTEN_TIMEOUT : parseInt(process.env.PM2_GRACEFUL_LISTEN_TIMEOUT) || 3000,  LOGS_BUFFER             : 10,  CONTEXT_ON_ERROR        : 2,  AGGREGATION_DURATION    : process.env.PM2_DEBUG || process.env.NODE_ENV === test || process.env.NODE_ENV === development ? 3000 : 5  60000,  TRACE_FLUSH_INTERVAL    : process.env.PM2_DEBUG || process.env.NODE_ENV === local_test ? 1000 : 60000,
   Concurrent actions when doing start/restart/reload  CONCURRENT_ACTIONS      : (function() {    var concurrent_actions = parseInt(process.env.PM2_CONCURRENT_ACTIONS) || 1;    if (semver.satisfies(process.versions.node, >= 4.0.0))      concurrent_actions = 2;    debug(Using %d parallelism (CONCURRENT_ACTIONS), concurrent_actions);    return concurrent_actions;  })(),
  DEBUG                   : process.env.PM2_DEBUG || false,  WEB_IPADDR              : process.env.PM2_API_IPADDR || 0.0.0.0,  WEB_PORT                : parseInt(process.env.PM2_API_PORT)  || 9615,  MODIFY_REQUIRE          : process.env.PM2_MODIFY_REQUIRE || false,
  WORKER_INTERVAL         : process.env.PM2_WORKER_INTERVAL || 30000,  KILL_TIMEOUT            : process.env.PM2_KILL_TIMEOUT || 1600,  PM2_PROGRAMMATIC        : typeof(process.env.pm_id) !== undefined || process.env.PM2_PROGRAMMATIC,  PM2_LOG_DATE_FORMAT     : process.env.PM2_LOG_DATE_FORMAT !== undefined ? process.env.PM2_LOG_DATE_FORMAT : YYYY-MM-DD HH:mm:ss
};
module.exports = util._extend(csts, path_structure);"
" Karma configuration Generated on Fri Aug 15 2014 23:11:13 GMT-0500 (CDT)
var webpack = require(webpack);
function createCustomLauncher(browser, version, platform) {  return {    base: SauceLabs,    browserName: browser,    version: version,    platform: platform  };}
module.exports = function(config) {  var customLaunchers = {};  var browsers = [];
  if (process.env.SAUCE_USERNAME || process.env.SAUCE_ACCESS_KEY) {    customLaunchers = {};
    var runAll = true;    var options = [      SAUCE_CHROME,      SAUCE_FIREFOX,      SAUCE_SAFARI,      SAUCE_OPERA,      SAUCE_IE,      SAUCE_EDGE,      SAUCE_IOS,      SAUCE_ANDROID    ];
    options.forEach(function (opt) {      if (process.env[opt]) {        runAll = false;      }    });
     Chrome    if (runAll || process.env.SAUCE_CHROME) {      customLaunchers.SL_Chrome = createCustomLauncher(chrome);       customLaunchers.SL_ChromeDev = createCustomLauncher('chrome', 'dev');       customLaunchers.SL_ChromeBeta = createCustomLauncher('chrome', 'beta');    }
     Firefox    if (runAll || process.env.SAUCE_FIREFOX) {      customLaunchers.SL_Firefox = createCustomLauncher(firefox);       customLaunchers.SL_FirefoxDev = createCustomLauncher('firefox', 'dev');       customLaunchers.SL_FirefoxBeta = createCustomLauncher('firefox', 'beta');    }
     Safari    if (runAll || process.env.SAUCE_SAFARI) {       customLaunchers.SL_Safari7 = createCustomLauncher('safari', 7);       customLaunchers.SL_Safari8 = createCustomLauncher('safari', 8);
      customLaunchers.SL_Safari9 = createCustomLauncher(safari, 9);    }
     Opera    if (runAll || process.env.SAUCE_OPERA) {       TODO The available versions of Opera are too old and lack basic APIs       customLaunchers.SL_Opera11 = createCustomLauncher('opera', 11, 'Windows XP');       customLaunchers.SL_Opera12 = createCustomLauncher('opera', 12, 'Windows 7');    }
     IE    if (runAll || process.env.SAUCE_IE) {       customLaunchers.SL_IE8 = createCustomLauncher('internet explorer', 8, 'Windows 7');      customLaunchers.SL_IE9 = createCustomLauncher(internet explorer, 9, Windows 2008);      customLaunchers.SL_IE10 = createCustomLauncher(internet explorer, 10, Windows 2012);      customLaunchers.SL_IE11 = createCustomLauncher(internet explorer, 11, Windows 8.1);    }
     Edge    if (runAll || process.env.SAUCE_EDGE) {      customLaunchers.SL_Edge = createCustomLauncher(microsoftedge, null, Windows 10);    }
     IOS    if (runAll || process.env.SAUCE_IOS) {       TODO IOS7 capture always timesout       customLaunchers.SL_IOS7 = createCustomLauncher('iphone', '7.1', 'OS X 10.10');       TODO Mobile browsers are causing failures, possibly from too many concurrent VMs       customLaunchers.SL_IOS8 = createCustomLauncher('iphone', '8.4', 'OS X 10.10');       customLaunchers.SL_IOS9 = createCustomLauncher('iphone', '9.2', 'OS X 10.10');    }
     Android    if (runAll || process.env.SAUCE_ANDROID) {       TODO Mobile browsers are causing failures, possibly from too many concurrent VMs       customLaunchers.SL_Android4 = createCustomLauncher('android', '4.4', 'Linux');       customLaunchers.SL_Android5 = createCustomLauncher('android', '5.1', 'Linux');    }
    browsers = Object.keys(customLaunchers);  } else if (process.env.TRAVIS_PULL_REQUEST && process.env.TRAVIS_PULL_REQUEST !== false) {    console.log(      Cannot run on Sauce Labs as encrypted environment variables are not available to PRs.  +      Running on Travis.    );    browsers = [Firefox];  } else {    console.log(Running locally since SAUCE_USERNAME and SAUCE_ACCESS_KEY environment variables are not set.);    browsers = [Firefox, Chrome, Safari, Opera];  }
  config.set({     base path that will be used to resolve all patterns (eg. files, exclude)    basePath: ,

     frameworks to use     available frameworks: https://npmjs.org/browse/keyword/karma-adapter    frameworks: [jasmine-ajax, jasmine, sinon],

     list of files / patterns to load in the browser    files: [      test/specs/__helpers.js,      test/specs/**/*.spec.js,    ],

     list of files to exclude    exclude: [
    ],

     preprocess matching files before serving them to the browser     available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor    preprocessors: {      test/specs/__helpers.js: [webpack, sourcemap],      test/specs/**/*.spec.js: [webpack, sourcemap]    },

     test results reporter to use     possible values: 'dots', 'progress'     available reporters: https://npmjs.org/browse/keyword/karma-reporter    reporters: [dots, coverage, saucelabs],

     web server port    port: 9876,

     Increase timeouts to prevent the issue with disconnected tests (https://goo.gl/nstA69)    captureTimeout: 4  60  1000,    browserDisconnectTimeout: 10000,    browserDisconnectTolerance: 1,    browserNoActivityTimeout: 4  60  1000,

     enable / disable colors in the output (reporters and logs)    colors: true,

     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_INFO,

     enable / disable watching file and executing tests whenever any file changes    autoWatch: false,

     start these browsers     available browser launchers: https://npmjs.org/browse/keyword/karma-launcher    browsers: browsers,

     Continuous Integration mode     if true, Karma captures browsers, runs the tests and exits    singleRun: false,
     Webpack config    webpack: {      cache: true,      devtool: inline-source-map,      module: {        postLoaders: [          {            test: js,            exclude: (node_modulestest),            loader: istanbul-instrumenter          }        ]      },      externals: [        {          ./adapters/http: var undefined        }      ],      plugins: [        new webpack.DefinePlugin({          process.env.NODE_ENV: JSON.stringify(test)        })      ]    },
    webpackServer: {      stats: {        colors: true      }    },

     Coverage reporting    coverageReporter: {      type: lcov,      dir: coverage/,      subdir: .    },

     SauceLabs config    sauceLabs: {      recordScreenshots: false,      connectOptions: {        port: 5757,        logfile: sauce_connect.log      },      public: public    },
    customLaunchers: customLaunchers  });};"
module.exports = require(./lib/axios);
"module.exports = function(grunt) {  require(load-grunt-tasks)(grunt);
  grunt.initConfig({    pkg: grunt.file.readJSON(package.json),    meta: {      banner:     },
    clean: {      dist: dist/**    },
    ts: {      test: {        options: {          lib: [            es5,            es2015.promise,            dom          ]        },        src: [typings/index.d.ts, test/typescript/*.ts]      }    },
    package2bower: {      all: {        fields: [          name,          description,          version,          homepage,          license,          keywords        ]      }    },
    usebanner: {      all: {        options: {          banner: <%= meta.banner %>,          linebreak: false        },        files: {          src: [dist/*.js]        }      }    },
    eslint: {      target: [lib/**/*.js]    },
    karma: {      options: {        configFile: karma.conf.js      },      single: {        singleRun: true      },      continuous: {        singleRun: false      }    },
    nodeunit: {      all: [test/unit/**/*.js]    },
    watch: {      build: {        files: [lib/**/*.js],        tasks: [build]      },      test: {        files: [lib/**/*.js, test/**/*.js, !test/typescript/axios.js, !test/typescript/out.js],        tasks: [test]      }    },
    webpack: require(./webpack.config.js)  });
  grunt.registerMultiTask(package2bower, Sync package.json to bower.json, function () {    var npm = grunt.file.readJSON(package.json);    var bower = grunt.file.readJSON(bower.json);    var fields = this.data.fields || [];
    for (var i=0, l=fields.length; i<l; i++) {      var field = fields[i];      bower[field] = npm[field];    }
    grunt.file.write(bower.json, JSON.stringify(bower, null, 2));  });
  grunt.registerTask(test, Run the jasmine and nodeunit tests, [eslint, nodeunit, karma:single, ts]);  grunt.registerTask(build, Run webpack and bundle the source, [clean, webpack]);  grunt.registerTask(version, Sync version info for a release, [usebanner, package2bower]);};"
"use strict;
var fs = require(fs);var path = require(path);var resolve = require(resolve);
var paths = {};var absolutePaths = {};
function add(paths, name, path) {  Object.defineProperty(paths, name, {    configurable: false,    get: function() { return path; }  });}
add(paths, prod,  vendor/ember/ember.prod.js);add(paths, debug, vendor/ember/ember.debug.js);add(paths, testing, vendor/ember/ember-testing.js);add(paths, jquery, vendor/ember/jquery/jquery.js);
add(absolutePaths, templateCompiler, __dirname + /dist/ember-template-compiler.js);
module.exports = {  init: function() {		this._super.init && this._super.init.apply(this, arguments);    if (ember in this.project.bowerDependencies()) {       TODO: move this to a throw soon.      this.ui.writeWarnLine(Ember.js is now provided by node_module `ember-source`, please remove it from bower);    }  },
  name: ember-source,  paths: paths,  absolutePaths: absolutePaths,
  treeForVendor: function() {    var Funnel = require(broccoli-funnel);    var MergeTrees = require(broccoli-merge-trees);
    var jqueryPath;    try {      jqueryPath = path.dirname(resolve.sync(jquery/package.json, { basedir: this.project.root }));    } catch (error) {      jqueryPath = path.dirname(require.resolve(jquery/package.json));    }
    var jquery = new Funnel(jqueryPath + /dist, {      destDir: ember/jquery,      files: [ jquery.js ]    });
    var emberFiles = [      ember-runtime.js,      ember-template-compiler.js,      ember-testing.js,      ember.debug.js,      ember.min.js,      ember.prod.js    ].filter(function(file) {      var fullPath = path.join(__dirname, dist, file);
      return fs.existsSync(fullPath);    });
    var ember = new Funnel(__dirname + /dist, {      destDir: ember,      files: emberFiles    });
    return new MergeTrees([ember, jquery]);  }};"
"use strict;
 To create fast production builds (without ES3 support, minification, derequire, or JSHint) run the following: DISABLE_ES3=true DISABLE_JSCS=true DISABLE_JSHINT=true DISABLE_MIN=true DISABLE_DEREQUIRE=true ember serve --environment=production
const MergeTrees = require(broccoli-merge-trees);const Funnel = require(broccoli-funnel);const babelHelpers = require(./broccoli/babel-helpers);const bootstrapModule = require(./broccoli/bootstrap-modules);const addon = require(./broccoli/addon);const concat = require(./broccoli/concat-bundle);const testIndexHTML = require(./broccoli/test-index-html);const toES5 = require(./broccoli/to-es5);const stripForProd = toES5.stripForProd;const minify = require(./broccoli/minify);const lint = require(./broccoli/lint);const Rollup = require(broccoli-rollup);const { stripIndent } = require(common-tags);const {  routerES,  jquery,  internalLoader,  qunit,  emberGlimmerES,  handlebarsES,  rsvpES,  simpleHTMLTokenizerES,  backburnerES,  dagES,  routeRecognizerES,  emberPkgES,  glimmerPkgES,  emberTestsES,  nodeModuleUtils,  emberVersionES,  emberLicense,  emberFeaturesES,  packageManagerJSONs,  nodeTests,  rollupEmberMetal} = require(./broccoli/packages);const SHOULD_ROLLUP = true;
module.exports = function(options) {  let loader = internalLoader();  let license = emberLicense();  let nodeModule = nodeModuleUtils();  let ENV = process.env.EMBER_ENV || development;  let debugFeatures = toES5(emberFeaturesES());  let version = toES5(emberVersionES());  let emberTesting = emberPkgES(ember-testing);  let emberTestingES5 = toES5(emberTesting, { annotation: ember-testing });  let emberDebug = emberPkgES(ember-debug);  let emberDebugES5 = toES5(emberDebug, { annotation: ember-debug });  let emberTemplateCompiler = emberPkgES(ember-template-compiler);  let emberTemplateCompilerES5 = toES5(emberTemplateCompiler, { annotation: ember-template-compiler });  let glimmerSyntax = toES5(    glimmerPkgES(@glimmer/syntax, [handlebars, simple-html-tokenizer]),    { annotation: @glimmer/syntax }  );  let glimmerCompiler = toES5(    glimmerPkgES(@glimmer/compiler, [@glimmer/util, @glimmer/wire-format, @glimmer/syntax]),    { annotation: @glimmer/compiler }  );  let glimmerReference = toES5(glimmerPkgES(@glimmer/reference, [@glimmer/util]));  let glimmerUtil = toES5(glimmerPkgES(@glimmer/util));  let glimmerWireFormat = toES5(glimmerPkgES(@glimmer/wire-format, [@glimmer/util]));  let babelDebugHelpersES5 = toES5(babelHelpers(debug), { annotation: babel helpers debug });  let inlineParser = toES5(handlebarsES(), { annotation: handlebars });  let tokenizer = toES5(simpleHTMLTokenizerES(), { annotation: tokenizer });  let rsvp = toES5(rsvpES(), { annotation: rsvp });  let emberMetal = new Funnel(packages/ember-metal/lib, { destDir: / });  let emberMetalES5 = rollupEmberMetal(emberMetal);  let emberConsole = emberPkgES(ember-console, SHOULD_ROLLUP, [ember-environment]);  let emberConsoleES5 = toES5(emberConsole, { annotation: ember-console });  let emberEnvironment = emberPkgES(ember-environment, SHOULD_ROLLUP);  let emberEnvironmentES5 = toES5(emberEnvironment, { annotation: ember-environment });  let emberUtils = emberPkgES(ember-utils, SHOULD_ROLLUP);  let emberUtilsES5 = toES5(emberUtils, { annotation: ember-utils });  let container = emberPkgES(container, SHOULD_ROLLUP, [    ember-debug,    ember-utils,    ember-environment,    ember-env-flags,    ember/features  ]);  let containerES5 = toES5(container, { annotation: container });  let emberCoreES6 = emberES6();  let emberTests = emberTestsES6();  let testHarness = testHarnessFiles();  let backburner = toES5(backburnerES());
   Linting  let emberTestsLinted = emberTests.map(lint);  let emberLinted = emberCoreES6.map(lint);
   ES5  let dependenciesES5 = dependenciesES6().map(toES5);  let emberES5 = emberCoreES6.map(toES5);  emberTests.push(addon(ember-dev, options.project));  let emberTestsES5 = emberTests.map(toES5);
   Bundling  let emberTestsBundle = new MergeTrees([    ...emberTestsES5,    ...emberTestsLinted,    ...emberLinted,    loader,    nodeModule,    license,    babelDebugHelpersES5,    lint(emberUtils),    lint(emberTesting),    lint(emberDebug),    lint(emberTemplateCompiler),    lint(emberMetal),    lint(emberConsole),    lint(emberEnvironment),    lint(container)  ]);
  let emberDebugBase = [    ...emberES5,    ...dependenciesES5,    rsvp,    containerES5,    emberUtilsES5,    emberEnvironmentES5,    emberMetalES5,    emberConsoleES5,    emberDebugES5,    glimmerReference,    glimmerUtil,    glimmerWireFormat,    backburner,    version,    license,    loader,    nodeModule,    bootstrapModule(ember)  ];
  emberTestsBundle = concat(emberTestsBundle, {    outputFile: ember-tests.js,    hasBootstrap: false  });
  let emberDebugBundle = new MergeTrees([    ...emberDebugBase,    emberTestingES5,    babelDebugHelpersES5,    inlineParser,    debugFeatures,    emberTemplateCompilerES5  ]);
  emberDebugBundle = concat(emberDebugBundle, {    outputFile: ember.debug.js  });
  let emberTestingBundle = new MergeTrees([    loader,    license,    emberTestingES5,    emberDebugES5,    babelDebugHelpersES5,    nodeModule  ]);
  emberTestingBundle = concat(emberTestingBundle, {    outputFile: ember-testing.js,    hasBootstrap: false,    footer: stripIndent      var testing = requireModule('ember-testing');      Ember.Test = testing.Test;      Ember.Test.Adapter = testing.Adapter;      Ember.Test.QUnitAdapter = testing.QUnitAdapter;      Ember.setupForTesting = testing.setupForTesting;      });
  function templateCompiler(babelHelpers) {    return [      containerES5,      emberUtilsES5,      emberEnvironmentES5,      emberMetalES5,      emberConsoleES5,      emberTemplateCompilerES5,      emberDebugES5,      glimmerSyntax,      glimmerCompiler,      glimmerReference,      glimmerUtil,      glimmerWireFormat,      backburner,      debugFeatures,      tokenizer,      inlineParser,      babelHelpers,      bootstrapModule(ember-template-compiler, umd)    ];  }
  let trees = [];
  if (ENV === production) {    let babelProdHelpersES5 = toES5(babelHelpers(prod), { environment: production });    let productionFeatures = toES5(emberFeaturesES(true), { environment: production });    let emberMetalProd = stripForProd(rollupEmberMetal(emberMetal, { environment: production }));
    let emberProdES5 = [      ...emberCoreES6,      ...dependenciesES6(),      container,      emberUtils,      emberEnvironment,      emberConsole,      emberDebug    ].map((tree) => {      return stripForProd(toES5(tree, { environment: production }));    });
    let depsProd = [      glimmerReference,      glimmerUtil,      glimmerWireFormat,      backburner,    ].map(stripForProd);
    let emberProdTestES5 = emberTests.map((tree) => {      return stripForProd(toES5(tree, { environment: production }));    });
    let emberRuntimeBundle = new MergeTrees([      loader,      babelDebugHelpersES5,      emberMetalES5,      emberEnvironmentES5,      emberConsoleES5,      containerES5,      rsvp,      license,      bootstrapModule(ember-runtime, default)    ]);
    let emberProdBundle = new MergeTrees([      ...emberProdES5,      ...depsProd,      emberMetalProd,      rsvp,      productionFeatures,      babelProdHelpersES5,      version,      license,      loader,      nodeModule,      bootstrapModule(ember)    ]);
     Note:     We have to build custom production template compiler     because we strip babel helpers in the prod build    let prodTemplateCompiler = new MergeTrees(templateCompiler(babelProdHelpersES5));
    prodTemplateCompiler = stripForProd(prodTemplateCompiler)
    prodTemplateCompiler = new MergeTrees([      nodeModule,      prodTemplateCompiler,      version,      license,      loader    ]);
    prodTemplateCompiler = concat(prodTemplateCompiler, {      outputFile: ember-template-compiler.js    });
    let emberProdTestsBundle = new MergeTrees([      ...emberProdTestES5,      tokenizer,      emberTemplateCompilerES5,      babelProdHelpersES5,      license,      loader,      nodeModule    ]);
    emberRuntimeBundle = concat(emberRuntimeBundle, {      outputFile: ember-runtime.js    });
    emberProdBundle = concat(emberProdBundle, {      outputFile: ember.prod.js    });
    emberProdTestsBundle = concat(emberProdTestsBundle, {      outputFile: ember-tests.prod.js,      hasBootstrap: false    });
    let emberMinBundle = minify(emberProdBundle, ember.min);
    trees.push(emberRuntimeBundle, emberProdBundle, emberMinBundle, emberProdTestsBundle, prodTemplateCompiler);  } else {    let emberTemplateCompilerBundle = new MergeTrees([      ...templateCompiler(babelDebugHelpersES5),        version,        license,        loader,        nodeModule    ]);
    emberTemplateCompilerBundle = concat(emberTemplateCompilerBundle, {      outputFile: ember-template-compiler.js    });
    trees.push(emberTemplateCompilerBundle);  }
  return new MergeTrees([    ...trees,    ...testHarness,    emberTestsBundle,    emberDebugBundle,    emberTestingBundle,    packageManagerJSONs(),    nodeTests()  ]);};
function dependenciesES6() {  return [    dagES(),    routerES(),    routeRecognizerES(),    glimmerPkgES(@glimmer/node, [@glimmer/runtime]),    glimmerPkgES(@glimmer/runtime, [      @glimmer/util,      @glimmer/reference,      @glimmer/wire-format    ])  ];}
function emberTestsES6() {  return [    emberPkgES(internal-test-helpers),    emberTestsES(container),    emberTestsES(ember),    emberTestsES(ember-metal),    emberTestsES(ember-template-compiler),    emberTestsES(ember-glimmer),    emberTestsES(ember-application),    emberTestsES(ember-debug),    emberTestsES(ember-runtime),    emberTestsES(ember-extension-support),    emberTestsES(ember-routing),    emberTestsES(ember-utils),    emberTestsES(ember-testing),    emberTestsES(internal-test-helpers)  ];}
function emberES6() {  return [    emberPkgES(ember-views),    emberPkgES(ember),    emberPkgES(ember-application),    emberPkgES(ember-runtime),    emberPkgES(ember-extension-support),    emberPkgES(ember-routing),    emberGlimmerES()  ];}
function testHarnessFiles() {  return [    testIndexHTML(),    jquery(),    qunit()  ];}"
" GETTTING D8 (v8 + basic console):   1. git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git   2. add depot_tools to your path: export PATH=/path/to/depo/tools/depot_tools:""$PATH""   3. no, in the cwd where you want v8 to live type: `fetch v8`   4. build (for your local architecture) `make native` (otherwise you may wait for a very long time)   5. now, you have a d8 at your disposale /path/to/v8/out/x64.debug/d8 GETTING EMBER WORKING: most likely you will need to run: npm install bower install npm run build // for one time production build for active iteration, recommendation is: `ember server --env production` Please note: production builds (due to minification, can be abit slow) want to run an app, checkout: https://github.com/stefanpenner/d8-ember
 handy d8 stuff: --------------- --trace-opt-verbose --prof + tick-processor enableProfiler() / disableProfiler() --trace-inlining --trace-gc --allow-natives    %DebugPrint(x);    %OptimizeFunctionOnNextCall(x);    %HaveSameMap(x, y); --trace-maps --trace_generalization --help --expose-gc --print-opt-code --code-comments begin MISC setup;const global = new Function(return this;)();global.self = global;function loadFile(file) {  print(load:  + file);  load(file);}
global.console = {  log(...args) {    print(...args);  }};
global.setTimeout = function(callback) {   good enough  Promise.resolve().then(callback).catch(e => print(error + e));};loadFile(./node_modules/simple-dom/dist/simple-dom.js);
 url protocolglobal.URL = {};
 end MISC setup
 Load the ember you wantloadFile(./dist/ember.prod.js);  prod build === no asserts and dev related code loadFile('/dist/ember.min.js'); // prod build + minified loadFile('/dist/ember.debug.js'); // debug build === asserts and stuff, has perf issues

 do what you want
 try running `d8 d8-runner.js d8-app.js`"
"var Router = Ember.Router.extend({  location: none,  rootURL: /});Router.map(function() {  this.route(my-route, { path: /my-route }, function () {  });});Ember.TEMPLATES[index] = Ember.HTMLBars.template({id:null,block:{statements:[[text,index]],locals:[],named:[],yields:[],blocks:[],hasPartials:false},meta:{}});Ember.TEMPLATES[my-route/index] = Ember.HTMLBars.template({id:null,block:{statements:[[text,my-route]],locals:[],named:[],yields:[],blocks:[],hasPartials:false},meta:{}});var App = Ember.Application.extend({  Router: Router,  autoboot: false});var app = new App();var serializer = new SimpleDOM.HTMLSerializer(SimpleDOM.voidMap);var doc = new SimpleDOM.Document();var options = {  isBrowser: false,  document: doc,  rootElement: doc.body,  shouldRender: true};app.visit(/, options).then(function (instance) {  print(serializer.serialize(doc.body));  var router = instance.lookup(router:main);  return router.transitionTo(/my-route);}).then(function () {  return new Ember.RSVP.Promise(function (resolve) {    Ember.run.schedule(afterRender, resolve)  });}).then(function () {  print(serializer.serialize(doc.body));}).catch(function (err) {  print(err.stack);});"
"var fs = require(fs);var path = require(path);
var options = {  root: true,  parserOptions: {    ecmaVersion: 6,    sourceType: module,  },  extends: eslint:recommended,  plugins: [    ember-internal  ],  env: {    qunit: true,  },  globals: {    expectAssertion: true,    expectDeprecation: true,    expectNoDeprecation: true,    expectWarning: true,    expectNoWarning: true,    ignoreAssertion: true,    ignoreDeprecation: true,
     A safe subset of ""browser:true"":    window: true,    document: true,    setTimeout: true,    clearTimeout: true,    setInterval: true,    clearInterval: true,
    Symbol: true,    WeakMap: true,  },  rules: {    ember-internal/require-yuidoc-access: error,    ember-internal/no-const-outside-module-scope: error,
     temporarily disabled    no-unused-vars: off,    comma-dangle: off,  },};
module.exports = options;"
" * Export echarts as CommonJS module */module.exports = require(./lib/echarts);
require(./lib/chart/line);require(./lib/chart/bar);require(./lib/chart/pie);require(./lib/component/gridSimple);"
" * Export echarts as CommonJS module */module.exports = require(./lib/echarts);
 Import all charts and componentsrequire(./lib/chart/line);require(./lib/chart/bar);require(./lib/chart/pie);require(./lib/chart/scatter);require(./lib/chart/radar);
require(./lib/chart/map);require(./lib/chart/treemap);require(./lib/chart/graph);require(./lib/chart/gauge);require(./lib/chart/funnel);require(./lib/chart/parallel);require(./lib/chart/sankey);require(./lib/chart/boxplot);require(./lib/chart/candlestick);require(./lib/chart/effectScatter);require(./lib/chart/lines);require(./lib/chart/heatmap);require(./lib/chart/pictorialBar);require(./lib/chart/themeRiver);
require(./lib/component/graphic);require(./lib/component/grid);require(./lib/component/legend);require(./lib/component/tooltip);require(./lib/component/axisPointer);require(./lib/component/polar);require(./lib/component/geo);require(./lib/component/parallel);require(./lib/component/singleAxis);require(./lib/component/brush);require(./lib/component/calendar);
require(./lib/component/title);
require(./lib/component/dataZoom);require(./lib/component/visualMap);
require(./lib/component/markPoint);require(./lib/component/markLine);require(./lib/component/markArea);
require(./lib/component/timeline);require(./lib/component/toolbox);
require(zrender/lib/vml/vml);"
" * Export echarts as CommonJS module */module.exports = require(./lib/echarts);
require(./lib/chart/line);require(./lib/chart/bar);require(./lib/chart/pie);require(./lib/chart/scatter);require(./lib/component/graphic);require(./lib/component/tooltip);require(./lib/component/axisPointer);require(./lib/component/legend);
require(./lib/component/grid);require(./lib/component/title);
require(./lib/component/markPoint);require(./lib/component/markLine);require(./lib/component/markArea);require(./lib/component/dataZoom);require(./lib/component/toolbox);
require(zrender/lib/vml/vml);"
"import babel from rollup-plugin-babel;
export default {  entry: src/main.js,  format: es,  plugins: [ babel({ exclude: node_modules/** }) ],  dest: hammer.js,  intro:  (function(window, document, exportName, undefined) { 'use strict';,  outro: })(window, document, 'Hammer');};"
" * http://hammerjs.github.io/ * * Copyright (c)  Jorik Tangelder; * Licensed under the MIT license */(function(window,document,exportName,undefined){""use strict"";function ifUndefined(val1,val2){return val1===undefined?val2:val1}var VENDOR_PREFIXES=["""",""webkit"",""Moz"",""MS"",""ms"",""o""];var TEST_ELEMENT=document.createElement(""div"");var TYPE_FUNCTION=""function"";var round=Math.round;var abs=Math.abs;var now=Date.now;function prefixed(obj,property){var prefix=void 0;var prop=void 0;var camelProp=property[0].toUpperCase()+property.slice(1);var i=0;while(i<VENDOR_PREFIXES.length){prefix=VENDOR_PREFIXES[i];prop=prefix?prefix+camelProp:property;if(prop in obj){return prop}i++}return undefined}function getTouchActionProps(){if(!NATIVE_TOUCH_ACTION){return false}var touchMap={};var cssSupports=window.CSS&&window.CSS.supports;[""auto"",""manipulation"",""pan-y"",""pan-x"",""pan-x pan-y"",""none""].forEach(function(val){return touchMap[val]=cssSupports?window.CSS.supports(""touch-action"",val):true});return touchMap}var PREFIXED_TOUCH_ACTION=prefixed(TEST_ELEMENT.style,""touchAction"");var NATIVE_TOUCH_ACTION=PREFIXED_TOUCH_ACTION!==undefined;var TOUCH_ACTION_COMPUTE=""compute"";var TOUCH_ACTION_AUTO=""auto"";var TOUCH_ACTION_MANIPULATION=""manipulation"";var TOUCH_ACTION_NONE=""none"";var TOUCH_ACTION_PAN_X=""pan-x"";var TOUCH_ACTION_PAN_Y=""pan-y"";var TOUCH_ACTION_MAP=getTouchActionProps();var MOBILE_REGEX=/mobile|tablet|ip(ad|hone|od)|android/i;var SUPPORT_TOUCH=""ontouchstart""in window;var SUPPORT_POINTER_EVENTS=prefixed(window,""PointerEvent"")!==undefined;var SUPPORT_ONLY_TOUCH=SUPPORT_TOUCH&&MOBILE_REGEX.test(navigator.userAgent);var INPUT_TYPE_TOUCH=""touch"";var INPUT_TYPE_PEN=""pen"";var INPUT_TYPE_MOUSE=""mouse"";var INPUT_TYPE_KINECT=""kinect"";var COMPUTE_INTERVAL=25;var INPUT_START=1;var INPUT_MOVE=2;var INPUT_END=4;var INPUT_CANCEL=8;var DIRECTION_NONE=1;var DIRECTION_LEFT=2;var DIRECTION_RIGHT=4;var DIRECTION_UP=8;var DIRECTION_DOWN=16;var DIRECTION_HORIZONTAL=DIRECTION_LEFT|DIRECTION_RIGHT;var DIRECTION_VERTICAL=DIRECTION_UP|DIRECTION_DOWN;var DIRECTION_ALL=DIRECTION_HORIZONTAL|DIRECTION_VERTICAL;var PROPS_XY=[""x"",""y""];var PROPS_CLIENT_XY=[""clientX"",""clientY""];var STATE_POSSIBLE=1;var STATE_BEGAN=2;var STATE_CHANGED=4;var STATE_ENDED=8;var STATE_RECOGNIZED=STATE_ENDED;var STATE_CANCELLED=16;var STATE_FAILED=32;var assign=void 0;if(typeof Object.assign!==""function""){assign=function assign(target){if(target===undefined||target===null){throw new TypeError(""Cannot convert undefined or null to object"")}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(source.hasOwnProperty(nextKey)){output[nextKey]=source[nextKey]}}}}return output}}else{assign=Object.assign}var assign$1=assign;var _uniqueId=1;function uniqueId(){return _uniqueId++}function each(obj,iterator,context){var i=void 0;if(!obj){return}if(obj.forEach){obj.forEach(iterator,context)}else if(obj.length!==undefined){i=0;while(i<obj.length){iterator.call(context,obj[i],i,obj);i++}}else{for(i in obj){obj.hasOwnProperty(i)&&iterator.call(context,obj[i],i,obj)}}}function invokeArrayArg(arg,fn,context){if(Array.isArray(arg)){each(arg,context[fn],context);return true}return false}function inArray(src,find,findByKey){if(src.indexOf&&!findByKey){return src.indexOf(find)}else{var i=0;while(i<src.length){if(findByKey&&src[i][findByKey]==find||!findByKey&&src[i]===find){return i}i++}return-1}}var _typeof=typeof Symbol===""function""&&typeof Symbol.iterator===""symbol""?function(obj){return typeof obj}:function(obj){return obj&&typeof Symbol===""function""&&obj.constructor===Symbol&&obj!==Symbol.prototype?""symbol"":typeof obj};var asyncGenerator=function(){function AwaitValue(value){this.value=value}function AsyncGenerator(gen){var front,back;function send(key,arg){return new Promise(function(resolve,reject){var request={key:key,arg:arg,resolve:resolve,reject:reject,next:null};if(back){back=back.next=request}else{front=back=request;resume(key,arg)}})}function resume(key,arg){try{var result=gen[key](arg);var value=result.value;if(value instanceof AwaitValue){Promise.resolve(value.value).then(function(arg){resume(""next"",arg)},function(arg){resume(""throw"",arg)})}else{settle(result.done?""return"":""normal"",result.value)}}catch(err){settle(""throw"",err)}}function settle(type,value){switch(type){case""return"":front.resolve({value:value,done:true});break;case""throw"":front.reject(value);break;default:front.resolve({value:value,done:false});break}front=front.next;if(front){resume(front.key,front.arg)}else{back=null}}this._invoke=send;if(typeof gen.return!==""function""){this.return=undefined}}if(typeof Symbol===""function""&&Symbol.asyncIterator){AsyncGenerator.prototype[Symbol.asyncIterator]=function(){return this}}AsyncGenerator.prototype.next=function(arg){return this._invoke(""next"",arg)};AsyncGenerator.prototype.throw=function(arg){return this._invoke(""throw"",arg)};AsyncGenerator.prototype.return=function(arg){return this._invoke(""return"",arg)};return{wrap:function(fn){return function(){return new AsyncGenerator(fn.apply(this,arguments))}},await:function(value){return new AwaitValue(value)}}}();var classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(""Cannot call a class as a function"")}};var createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(""value""in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();var get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined}else{return get(parent,property,receiver)}}else if(""value""in desc){return desc.value}else{var getter=desc.get;if(getter===undefined){return undefined}return getter.call(receiver)}};var inherits=function(subClass,superClass){if(typeof superClass!==""function""&&superClass!==null){throw new TypeError(""Super expression must either be null or a function, not ""+typeof superClass)}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass};var possibleConstructorReturn=function(self,call){if(!self){throw new ReferenceError(""this hasn't been initialised - super() hasn't been called"")}return call&&(typeof call===""object""||typeof call===""function"")?call:self};var slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i[""return""])_i[""return""]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError(""Invalid attempt to destructure non-iterable instance"")}}}();function boolOrFn(val,args){if((typeof val===""undefined""?""undefined"":_typeof(val))===TYPE_FUNCTION){return val.apply(args?args[0]||undefined:undefined,args)}return val}function getRecognizerByNameIfManager(otherRecognizer,recognizer){var manager=recognizer.manager;if(manager){return manager.get(otherRecognizer)}return otherRecognizer}function stateStr(state){if(state&STATE_CANCELLED){return""cancel""}else if(state&STATE_ENDED){return""end""}else if(state&STATE_CHANGED){return""move""}else if(state&STATE_BEGAN){return""start""}return""""}var Recognizer=function(){function Recognizer(options){classCallCheck(this,Recognizer);this.options=assign$1({},this.defaults,options||{});this.id=uniqueId();this.manager=null;this.options.enable=ifUndefined(this.options.enable,true);this.state=STATE_POSSIBLE;this.simultaneous={};this.requireFail=[]}createClass(Recognizer,[{key:""set"",value:function set(options){assign$1(this.options,options);this.manager&&this.manager.touchAction.update();return this}},{key:""recognizeWith"",value:function recognizeWith(otherRecognizer){if(invokeArrayArg(otherRecognizer,""recognizeWith"",this)){return this}var simultaneous=this.simultaneous;otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);if(!simultaneous[otherRecognizer.id]){simultaneous[otherRecognizer.id]=otherRecognizer;otherRecognizer.recognizeWith(this)}return this}},{key:""dropRecognizeWith"",value:function dropRecognizeWith(otherRecognizer){if(invokeArrayArg(otherRecognizer,""dropRecognizeWith"",this)){return this}otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);delete this.simultaneous[otherRecognizer.id];return this}},{key:""requireFailure"",value:function requireFailure(otherRecognizer){if(invokeArrayArg(otherRecognizer,""requireFailure"",this)){return this}var requireFail=this.requireFail;otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);if(inArray(requireFail,otherRecognizer)===-1){requireFail.push(otherRecognizer);otherRecognizer.requireFailure(this)}return this}},{key:""dropRequireFailure"",value:function dropRequireFailure(otherRecognizer){if(invokeArrayArg(otherRecognizer,""dropRequireFailure"",this)){return this}otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);var index=inArray(this.requireFail,otherRecognizer);if(index>-1){this.requireFail.splice(index,1)}return this}},{key:""hasRequireFailures"",value:function hasRequireFailures(){return this.requireFail.length>0}},{key:""canRecognizeWith"",value:function canRecognizeWith(otherRecognizer){return!!this.simultaneous[otherRecognizer.id]}},{key:""emit"",value:function emit(input){var self=this;var state=this.state;function emit(event){self.manager.emit(event,input)}if(state<STATE_ENDED){emit(self.options.event+stateStr(state))}emit(self.options.event);if(input.additionalEvent){emit(input.additionalEvent)}if(state>=STATE_ENDED){emit(self.options.event+stateStr(state))}}},{key:""tryEmit"",value:function tryEmit(input){if(this.canEmit()){return this.emit(input)}this.state=STATE_FAILED}},{key:""canEmit"",value:function canEmit(){var i=0;while(i<this.requireFail.length){if(!(this.requireFail[i].state&(STATE_FAILED|STATE_POSSIBLE))){return false}i++}return true}},{key:""recognize"",value:function recognize(inputData){var inputDataClone=assign$1({},inputData);if(!boolOrFn(this.options.enable,[this,inputDataClone])){this.reset();this.state=STATE_FAILED;return}if(this.state&(STATE_RECOGNIZED|STATE_CANCELLED|STATE_FAILED)){this.state=STATE_POSSIBLE}this.state=this.process(inputDataClone);if(this.state&(STATE_BEGAN|STATE_CHANGED|STATE_ENDED|STATE_CANCELLED)){this.tryEmit(inputDataClone)}}},{key:""process"",value:function process(inputData){}},{key:""getTouchAction"",value:function getTouchAction(){}},{key:""reset"",value:function reset(){}}]);return Recognizer}();Recognizer.prototype.defaults={};var AttrRecognizer=function(_Recognizer){inherits(AttrRecognizer,_Recognizer);function AttrRecognizer(){classCallCheck(this,AttrRecognizer);return possibleConstructorReturn(this,(AttrRecognizer.__proto__||Object.getPrototypeOf(AttrRecognizer)).apply(this,arguments))}createClass(AttrRecognizer,[{key:""attrTest"",value:function attrTest(input){var optionPointers=this.options.pointers;return optionPointers===0||input.pointers.length===optionPointers}},{key:""process"",value:function process(input){var state=this.state;var eventType=input.eventType;var isRecognized=state&(STATE_BEGAN|STATE_CHANGED);var isValid=this.attrTest(input);if(isRecognized&&(eventType&INPUT_CANCEL||!isValid)){return state|STATE_CANCELLED}else if(isRecognized||isValid){if(eventType&INPUT_END){return state|STATE_ENDED}else if(!(state&STATE_BEGAN)){return STATE_BEGAN}return state|STATE_CHANGED}return STATE_FAILED}}]);return AttrRecognizer}(Recognizer);AttrRecognizer.prototype.defaults={pointers:1};var RotateRecognizer=function(_AttrRecognizer){inherits(RotateRecognizer,_AttrRecognizer);function RotateRecognizer(){classCallCheck(this,RotateRecognizer);return possibleConstructorReturn(this,(RotateRecognizer.__proto__||Object.getPrototypeOf(RotateRecognizer)).apply(this,arguments))}createClass(RotateRecognizer,[{key:""getTouchAction"",value:function getTouchAction(){return[TOUCH_ACTION_NONE]}},{key:""attrTest"",value:function attrTest(input){return get(RotateRecognizer.prototype.__proto__||Object.getPrototypeOf(RotateRecognizer.prototype),""attrTest"",this).call(this,input)&&(Math.abs(input.rotation)>this.options.threshold||this.state&STATE_BEGAN)}}]);return RotateRecognizer}(AttrRecognizer);RotateRecognizer.prototype.defaults={event:""rotate"",threshold:0,pointers:2};var PinchRecognizer=function(_AttrRecognizer){inherits(PinchRecognizer,_AttrRecognizer);function PinchRecognizer(){classCallCheck(this,PinchRecognizer);return possibleConstructorReturn(this,(PinchRecognizer.__proto__||Object.getPrototypeOf(PinchRecognizer)).apply(this,arguments))}createClass(PinchRecognizer,[{key:""getTouchAction"",value:function getTouchAction(){return[TOUCH_ACTION_NONE]}},{key:""attrTest"",value:function attrTest(input){return get(PinchRecognizer.prototype.__proto__||Object.getPrototypeOf(PinchRecognizer.prototype),""attrTest"",this).call(this,input)&&(Math.abs(input.scale-1)>this.options.threshold||this.state&STATE_BEGAN)}},{key:""emit"",value:function emit(input){if(input.scale!==1){var inOut=input.scale<1?""in"":""out"";input.additionalEvent=this.options.event+inOut}get(PinchRecognizer.prototype.__proto__||Object.getPrototypeOf(PinchRecognizer.prototype),""emit"",this).call(this,input)}}]);return PinchRecognizer}(AttrRecognizer);PinchRecognizer.prototype.defaults={event:""pinch"",threshold:0,pointers:2};function directionStr(direction){if(direction===DIRECTION_DOWN){return""down""}else if(direction===DIRECTION_UP){return""up""}else if(direction===DIRECTION_LEFT){return""left""}else if(direction===DIRECTION_RIGHT){return""right""}return""""}var PanRecognizer=function(_AttrRecognizer){inherits(PanRecognizer,_AttrRecognizer);function PanRecognizer(){classCallCheck(this,PanRecognizer);var _this=possibleConstructorReturn(this,(PanRecognizer.__proto__||Object.getPrototypeOf(PanRecognizer)).apply(this,arguments));_this.pX=null;_this.pY=null;return _this}createClass(PanRecognizer,[{key:""getTouchAction"",value:function getTouchAction(){var direction=this.options.direction;var actions=[];if(direction&DIRECTION_HORIZONTAL){actions.push(TOUCH_ACTION_PAN_Y)}if(direction&DIRECTION_VERTICAL){actions.push(TOUCH_ACTION_PAN_X)}return actions}},{key:""directionTest"",value:function directionTest(input){var options=this.options;var hasMoved=true;var distance=input.distance;var direction=input.direction;var x=input.deltaX;var y=input.deltaY;if(!(direction&options.direction)){if(options.direction&DIRECTION_HORIZONTAL){direction=x===0?DIRECTION_NONE:x<0?DIRECTION_LEFT:DIRECTION_RIGHT;hasMoved=x!==this.pX;distance=Math.abs(input.deltaX)}else{direction=y===0?DIRECTION_NONE:y<0?DIRECTION_UP:DIRECTION_DOWN;hasMoved=y!==this.pY;distance=Math.abs(input.deltaY)}}input.direction=direction;return hasMoved&&distance>options.threshold&&direction&options.direction}},{key:""attrTest"",value:function attrTest(input){return AttrRecognizer.prototype.attrTest.call(this,input)&&(this.state&STATE_BEGAN||!(this.state&STATE_BEGAN)&&this.directionTest(input))}},{key:""emit"",value:function emit(input){this.pX=input.deltaX;this.pY=input.deltaY;var direction=directionStr(input.direction);if(direction){input.additionalEvent=this.options.event+direction}get(PanRecognizer.prototype.__proto__||Object.getPrototypeOf(PanRecognizer.prototype),""emit"",this).call(this,input)}}]);return PanRecognizer}(AttrRecognizer);PanRecognizer.prototype.defaults={event:""pan"",threshold:10,pointers:1,direction:DIRECTION_ALL};var SwipeRecognizer=function(_AttrRecognizer){inherits(SwipeRecognizer,_AttrRecognizer);function SwipeRecognizer(){classCallCheck(this,SwipeRecognizer);return possibleConstructorReturn(this,(SwipeRecognizer.__proto__||Object.getPrototypeOf(SwipeRecognizer)).apply(this,arguments))}createClass(SwipeRecognizer,[{key:""getTouchAction"",value:function getTouchAction(){return PanRecognizer.prototype.getTouchAction.call(this)}},{key:""attrTest"",value:function attrTest(input){var direction=this.options.direction;var velocity=void 0;if(direction&(DIRECTION_HORIZONTAL|DIRECTION_VERTICAL)){velocity=input.overallVelocity}else if(direction&DIRECTION_HORIZONTAL){velocity=input.overallVelocityX}else if(direction&DIRECTION_VERTICAL){velocity=input.overallVelocityY}return get(SwipeRecognizer.prototype.__proto__||Object.getPrototypeOf(SwipeRecognizer.prototype),""attrTest"",this).call(this,input)&&direction&input.offsetDirection&&input.distance>this.options.threshold&&input.maxPointers===this.options.pointers&&abs(velocity)>this.options.velocity&&input.eventType&INPUT_END}},{key:""emit"",value:function emit(input){var direction=directionStr(input.offsetDirection);if(direction){this.manager.emit(this.options.event+direction,input)}this.manager.emit(this.options.event,input)}}]);return SwipeRecognizer}(AttrRecognizer);SwipeRecognizer.prototype.defaults={event:""swipe"",threshold:10,velocity:.3,direction:DIRECTION_HORIZONTAL|DIRECTION_VERTICAL,pointers:1};function bindFn(fn,context){return function boundFn(){return fn.apply(context,arguments)}}function setTimeoutContext(fn,timeout,context){return setTimeout(bindFn(fn,context),timeout)}function getDistance(p1,p2,props){if(!props){props=PROPS_XY}var x=p2[props[0]]-p1[props[0]];var y=p2[props[1]]-p1[props[1]];return Math.sqrt(x*x+y*y)}var TapRecognizer=function(_Recognizer){inherits(TapRecognizer,_Recognizer);function TapRecognizer(){classCallCheck(this,TapRecognizer);var _this=possibleConstructorReturn(this,(TapRecognizer.__proto__||Object.getPrototypeOf(TapRecognizer)).apply(this,arguments));_this.pTime=false;_this.pCenter=false;_this._timer=null;_this._input=null;_this.count=0;return _this}createClass(TapRecognizer,[{key:""getTouchAction"",value:function getTouchAction(){return[TOUCH_ACTION_MANIPULATION]}},{key:""process"",value:function process(input){var _this2=this;var options=this.options;var validPointers=input.pointers.length===options.pointers;var validMovement=input.distance<options.threshold;var validTouchTime=input.deltaTime<options.time;this.reset();if(input.eventType&INPUT_START&&this.count===0){return this.failTimeout()}if(validMovement&&validTouchTime&&validPointers){if(input.eventType!==INPUT_END){return this.failTimeout()}var validInterval=this.pTime?input.timeStamp-this.pTime<options.interval:true;var validMultiTap=!this.pCenter||getDistance(this.pCenter,input.center)<options.posThreshold;this.pTime=input.timeStamp;this.pCenter=input.center;if(!validMultiTap||!validInterval){this.count=1}else{this.count+=1}this._input=input;var tapCount=this.count%options.taps;if(tapCount===0){if(!this.hasRequireFailures()){return STATE_RECOGNIZED}else{this._timer=setTimeoutContext(function(){_this2.state=STATE_RECOGNIZED;_this2.tryEmit()},options.interval,this);return STATE_BEGAN}}}return STATE_FAILED}},{key:""failTimeout"",value:function failTimeout(){var _this3=this;this._timer=setTimeoutContext(function(){_this3.state=STATE_FAILED},this.options.interval,this);return STATE_FAILED}},{key:""reset"",value:function reset(){clearTimeout(this._timer)}},{key:""emit"",value:function emit(){if(this.state===STATE_RECOGNIZED){this._input.tapCount=this.count;this.manager.emit(this.options.event,this._input)}}}]);return TapRecognizer}(Recognizer);TapRecognizer.prototype.defaults={event:""tap"",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10};var PressRecognizer=function(_Recognizer){inherits(PressRecognizer,_Recognizer);function PressRecognizer(){classCallCheck(this,PressRecognizer);var _this=possibleConstructorReturn(this,(PressRecognizer.__proto__||Object.getPrototypeOf(PressRecognizer)).apply(this,arguments));_this._timer=null;_this._input=null;return _this}createClass(PressRecognizer,[{key:""getTouchAction"",value:function getTouchAction(){return[TOUCH_ACTION_AUTO]}},{key:""process"",value:function process(input){var _this2=this;var options=this.options;var validPointers=input.pointers.length===options.pointers;var validMovement=input.distance<options.threshold;var validTime=input.deltaTime>options.time;this._input=input;if(!validMovement||!validPointers||input.eventType&(INPUT_END|INPUT_CANCEL)&&!validTime){this.reset()}else if(input.eventType&INPUT_START){this.reset();this._timer=setTimeoutContext(function(){_this2.state=STATE_RECOGNIZED;_this2.tryEmit()},options.time,this)}else if(input.eventType&INPUT_END){return STATE_RECOGNIZED}return STATE_FAILED}},{key:""reset"",value:function reset(){clearTimeout(this._timer)}},{key:""emit"",value:function emit(input){if(this.state!==STATE_RECOGNIZED){return}if(input&&input.eventType&INPUT_END){this.manager.emit(this.options.event+""up"",input)}else{this._input.timeStamp=now();this.manager.emit(this.options.event,this._input)}}}]);return PressRecognizer}(Recognizer);PressRecognizer.prototype.defaults={event:""press"",pointers:1,time:251,threshold:9};function inStr(str,find){return str.indexOf(find)>-1}function cleanTouchActions(actions){if(inStr(actions,TOUCH_ACTION_NONE)){return TOUCH_ACTION_NONE}var hasPanX=inStr(actions,TOUCH_ACTION_PAN_X);var hasPanY=inStr(actions,TOUCH_ACTION_PAN_Y);if(hasPanX&&hasPanY){return TOUCH_ACTION_NONE}if(hasPanX||hasPanY){return hasPanX?TOUCH_ACTION_PAN_X:TOUCH_ACTION_PAN_Y}if(inStr(actions,TOUCH_ACTION_MANIPULATION)){return TOUCH_ACTION_MANIPULATION}return TOUCH_ACTION_AUTO}var TouchAction=function(){function TouchAction(manager,value){classCallCheck(this,TouchAction);this.manager=manager;this.set(value)}createClass(TouchAction,[{key:""set"",value:function set(value){if(value===TOUCH_ACTION_COMPUTE){value=this.compute()}if(NATIVE_TOUCH_ACTION&&this.manager.element.style&&TOUCH_ACTION_MAP[value]){this.manager.element.style[PREFIXED_TOUCH_ACTION]=value}this.actions=value.toLowerCase().trim()}},{key:""update"",value:function update(){this.set(this.manager.options.touchAction)}},{key:""compute"",value:function compute(){var actions=[];each(this.manager.recognizers,function(recognizer){if(boolOrFn(recognizer.options.enable,[recognizer])){actions=actions.concat(recognizer.getTouchAction())}});return cleanTouchActions(actions.join("" ""))}},{key:""preventDefaults"",value:function preventDefaults(input){var srcEvent=input.srcEvent;var direction=input.offsetDirection;if(this.manager.session.prevented){srcEvent.preventDefault();return}var actions=this.actions;var hasNone=inStr(actions,TOUCH_ACTION_NONE)&&!TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];var hasPanY=inStr(actions,TOUCH_ACTION_PAN_Y)&&!TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];var hasPanX=inStr(actions,TOUCH_ACTION_PAN_X)&&!TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];if(hasNone){var isTapPointer=input.pointers.length===1;var isTapMovement=input.distance<2;var isTapTouchTime=input.deltaTime<250;if(isTapPointer&&isTapMovement&&isTapTouchTime){return}}if(hasPanX&&hasPanY){return}if(hasNone||hasPanY&&direction&DIRECTION_HORIZONTAL||hasPanX&&direction&DIRECTION_VERTICAL){return this.preventSrc(srcEvent)}}},{key:""preventSrc"",value:function preventSrc(srcEvent){this.manager.session.prevented=true;srcEvent.preventDefault()}}]);return TouchAction}();function hasParent(node,parent){while(node){if(node===parent){return true}node=node.parentNode}return false}function getCenter(pointers){var pointersLength=pointers.length;if(pointersLength===1){return{x:round(pointers[0].clientX),y:round(pointers[0].clientY)}}var x=0;var y=0;var i=0;while(i<pointersLength){x+=pointers[i].clientX;y+=pointers[i].clientY;i++}return{x:round(x/pointersLength),y:round(y/pointersLength)}}function simpleCloneInputData(input){var pointers=[];var i=0;while(i<input.pointers.length){pointers[i]={clientX:round(input.pointers[i].clientX),clientY:round(input.pointers[i].clientY)};i++}return{timeStamp:now(),pointers:pointers,center:getCenter(pointers),deltaX:input.deltaX,deltaY:input.deltaY}}function getAngle(p1,p2,props){if(!props){props=PROPS_XY}var x=p2[props[0]]-p1[props[0]];var y=p2[props[1]]-p1[props[1]];return Math.atan2(y,x)*180/Math.PI}function getDirection(x,y){if(x===y){return DIRECTION_NONE}if(abs(x)>=abs(y)){return x<0?DIRECTION_LEFT:DIRECTION_RIGHT}return y<0?DIRECTION_UP:DIRECTION_DOWN}function computeDeltaXY(session,input){var center=input.center;var offset=session.offsetDelta||{};var prevDelta=session.prevDelta||{};var prevInput=session.prevInput||{};if(input.eventType===INPUT_START||prevInput.eventType===INPUT_END){prevDelta=session.prevDelta={x:prevInput.deltaX||0,y:prevInput.deltaY||0};offset=session.offsetDelta={x:center.x,y:center.y}}input.deltaX=prevDelta.x+(center.x-offset.x);input.deltaY=prevDelta.y+(center.y-offset.y)}function getVelocity(deltaTime,x,y){return{x:x/deltaTime||0,y:y/deltaTime||0}}function getScale(start,end){return getDistance(end[0],end[1],PROPS_CLIENT_XY)/getDistance(start[0],start[1],PROPS_CLIENT_XY)}function getRotation(start,end){return getAngle(end[1],end[0],PROPS_CLIENT_XY)+getAngle(start[1],start[0],PROPS_CLIENT_XY)}function computeIntervalInputData(session,input){var last=session.lastInterval||input;var deltaTime=input.timeStamp-last.timeStamp;var velocity=void 0;var velocityX=void 0;var velocityY=void 0;var direction=void 0;if(input.eventType!==INPUT_CANCEL&&(deltaTime>COMPUTE_INTERVAL||last.velocity===undefined)){var deltaX=input.deltaX-last.deltaX;var deltaY=input.deltaY-last.deltaY;var v=getVelocity(deltaTime,deltaX,deltaY);velocityX=v.x;velocityY=v.y;velocity=abs(v.x)>abs(v.y)?v.x:v.y;direction=getDirection(deltaX,deltaY);session.lastInterval=input}else{velocity=last.velocity;velocityX=last.velocityX;velocityY=last.velocityY;direction=last.direction}input.velocity=velocity;input.velocityX=velocityX;input.velocityY=velocityY;input.direction=direction}function computeInputData(manager,input){var session=manager.session;var pointers=input.pointers;var pointersLength=pointers.length;if(!session.firstInput){session.firstInput=simpleCloneInputData(input)}if(pointersLength>1&&!session.firstMultiple){session.firstMultiple=simpleCloneInputData(input)}else if(pointersLength===1){session.firstMultiple=false}var firstInput=session.firstInput;var firstMultiple=session.firstMultiple;var offsetCenter=firstMultiple?firstMultiple.center:firstInput.center;var center=input.center=getCenter(pointers);input.timeStamp=now();input.deltaTime=input.timeStamp-firstInput.timeStamp;input.angle=getAngle(offsetCenter,center);input.distance=getDistance(offsetCenter,center);computeDeltaXY(session,input);input.offsetDirection=getDirection(input.deltaX,input.deltaY);var overallVelocity=getVelocity(input.deltaTime,input.deltaX,input.deltaY);input.overallVelocityX=overallVelocity.x;input.overallVelocityY=overallVelocity.y;input.overallVelocity=abs(overallVelocity.x)>abs(overallVelocity.y)?overallVelocity.x:overallVelocity.y;input.scale=firstMultiple?getScale(firstMultiple.pointers,pointers):1;input.rotation=firstMultiple?getRotation(firstMultiple.pointers,pointers):0;input.maxPointers=!session.prevInput?input.pointers.length:input.pointers.length>session.prevInput.maxPointers?input.pointers.length:session.prevInput.maxPointers;computeIntervalInputData(session,input);var target=manager.element;if(hasParent(input.srcEvent.target,target)){target=input.srcEvent.target}input.target=target}function inputHandler(manager,eventType,input){var pointersLen=input.pointers.length;var changedPointersLen=input.changedPointers.length;var isFirst=eventType&INPUT_START&&pointersLen-changedPointersLen===0;var isFinal=eventType&(INPUT_END|INPUT_CANCEL)&&pointersLen-changedPointersLen===0;input.isFirst=!!isFirst;input.isFinal=!!isFinal;if(isFirst){manager.session={}}input.eventType=eventType;computeInputData(manager,input);manager.emit(""hammer.input"",input);manager.recognize(input);manager.session.prevInput=input}function splitStr(str){return str.trim().split(/\s+/g)}function addEventListeners(target,types,handler){each(splitStr(types),function(type){target.addEventListener(type,handler,false)})}function removeEventListeners(target,types,handler){each(splitStr(types),function(type){target.removeEventListener(type,handler,false)})}function getWindowForElement(element){var doc=element.ownerDocument||element;return doc.defaultView||doc.parentWindow||window}var Input=function(){function Input(manager,callback){classCallCheck(this,Input);var self=this;this.manager=manager;this.callback=callback;this.element=manager.element;this.target=manager.options.inputTarget;this.domHandler=function(ev){if(boolOrFn(manager.options.enable,[manager])){self.handler(ev)}};this.init()}createClass(Input,[{key:""handler"",value:function handler(){}},{key:""init"",value:function init(){this.evEl&&addEventListeners(this.element,this.evEl,this.domHandler);this.evTarget&&addEventListeners(this.target,this.evTarget,this.domHandler);this.evWin&&addEventListeners(getWindowForElement(this.element),this.evWin,this.domHandler)}},{key:""destroy"",value:function destroy(){this.evEl&&removeEventListeners(this.element,this.evEl,this.domHandler);this.evTarget&&removeEventListeners(this.target,this.evTarget,this.domHandler);this.evWin&&removeEventListeners(getWindowForElement(this.element),this.evWin,this.domHandler)}}]);return Input}();var POINTER_INPUT_MAP={pointerdown:INPUT_START,pointermove:INPUT_MOVE,pointerup:INPUT_END,pointercancel:INPUT_CANCEL,pointerout:INPUT_CANCEL};var IE10_POINTER_TYPE_ENUM={2:INPUT_TYPE_TOUCH,3:INPUT_TYPE_PEN,4:INPUT_TYPE_MOUSE,5:INPUT_TYPE_KINECT};var POINTER_ELEMENT_EVENTS=""pointerdown"";var POINTER_WINDOW_EVENTS=""pointermove pointerup pointercancel"";if(window.MSPointerEvent&&!window.PointerEvent){POINTER_ELEMENT_EVENTS=""MSPointerDown"";POINTER_WINDOW_EVENTS=""MSPointerMove MSPointerUp MSPointerCancel""}var PointerEventInput=function(_Input){inherits(PointerEventInput,_Input);function PointerEventInput(){classCallCheck(this,PointerEventInput);var _this=possibleConstructorReturn(this,(PointerEventInput.__proto__||Object.getPrototypeOf(PointerEventInput)).apply(this,arguments));_this.evEl=POINTER_ELEMENT_EVENTS;_this.evWin=POINTER_WINDOW_EVENTS;_this.store=_this.manager.session.pointerEvents=[];return _this}createClass(PointerEventInput,[{key:""handler"",value:function handler(ev){var store=this.store;var removePointer=false;var eventTypeNormalized=ev.type.toLowerCase().replace(""ms"","""");var eventType=POINTER_INPUT_MAP[eventTypeNormalized];var pointerType=IE10_POINTER_TYPE_ENUM[ev.pointerType]||ev.pointerType;var isTouch=pointerType===INPUT_TYPE_TOUCH;var storeIndex=inArray(store,ev.pointerId,""pointerId"");if(eventType&INPUT_START&&(ev.button===0||isTouch)){if(storeIndex<0){store.push(ev);storeIndex=store.length-1}}else if(eventType&(INPUT_END|INPUT_CANCEL)){removePointer=true}if(storeIndex<0){return}store[storeIndex]=ev;this.callback(this.manager,eventType,{pointers:store,changedPointers:[ev],pointerType:pointerType,srcEvent:ev});if(removePointer){store.splice(storeIndex,1)}}}]);return PointerEventInput}(Input);function toArray$1(obj){return Array.prototype.slice.call(obj,0)}function uniqueArray(src,key,sort){var results=[];var values=[];var i=0;while(i<src.length){var val=key?src[i][key]:src[i];if(inArray(values,val)<0){results.push(src[i])}values[i]=val;i++}if(sort){if(!key){results=results.sort()}else{results=results.sort(function(a,b){return a[key]>b[key]})}}return results}var TOUCH_INPUT_MAP={touchstart:INPUT_START,touchmove:INPUT_MOVE,touchend:INPUT_END,touchcancel:INPUT_CANCEL};var TOUCH_TARGET_EVENTS=""touchstart touchmove touchend touchcancel"";var TouchInput=function(_Input){inherits(TouchInput,_Input);function TouchInput(){classCallCheck(this,TouchInput);TouchInput.prototype.evTarget=TOUCH_TARGET_EVENTS;TouchInput.prototype.targetIds={};var _this=possibleConstructorReturn(this,(TouchInput.__proto__||Object.getPrototypeOf(TouchInput)).apply(this,arguments));_this.evTarget=TOUCH_TARGET_EVENTS;_this.targetIds={};return _this}createClass(TouchInput,[{key:""handler"",value:function handler(ev){var type=TOUCH_INPUT_MAP[ev.type];var touches=getTouches.call(this,ev,type);if(!touches){return}this.callback(this.manager,type,{pointers:touches[0],changedPointers:touches[1],pointerType:INPUT_TYPE_TOUCH,srcEvent:ev})}}]);return TouchInput}(Input);function getTouches(ev,type){var allTouches=toArray$1(ev.touches);var targetIds=this.targetIds;if(type&(INPUT_START|INPUT_MOVE)&&allTouches.length===1){targetIds[allTouches[0].identifier]=true;return[allTouches,allTouches]}var i=void 0;var targetTouches=void 0;var changedTouches=toArray$1(ev.changedTouches);var changedTargetTouches=[];var target=this.target;targetTouches=allTouches.filter(function(touch){return hasParent(touch.target,target)});if(type===INPUT_START){i=0;while(i<targetTouches.length){targetIds[targetTouches[i].identifier]=true;i++}}i=0;while(i<changedTouches.length){if(targetIds[changedTouches[i].identifier]){changedTargetTouches.push(changedTouches[i])}if(type&(INPUT_END|INPUT_CANCEL)){delete targetIds[changedTouches[i].identifier]}i++}if(!changedTargetTouches.length){return}return[uniqueArray(targetTouches.concat(changedTargetTouches),""identifier"",true),changedTargetTouches]}var MOUSE_INPUT_MAP={mousedown:INPUT_START,mousemove:INPUT_MOVE,mouseup:INPUT_END};var MOUSE_ELEMENT_EVENTS=""mousedown"";var MOUSE_WINDOW_EVENTS=""mousemove mouseup"";var MouseInput=function(_Input){inherits(MouseInput,_Input);function MouseInput(){classCallCheck(this,MouseInput);var _this=possibleConstructorReturn(this,(MouseInput.__proto__||Object.getPrototypeOf(MouseInput)).apply(this,arguments));_this.evEl=MOUSE_ELEMENT_EVENTS;_this.evWin=MOUSE_WINDOW_EVENTS;_this.pressed=false;return _this}createClass(MouseInput,[{key:""handler"",value:function handler(ev){var eventType=MOUSE_INPUT_MAP[ev.type];if(eventType&INPUT_START&&ev.button===0){this.pressed=true}if(eventType&INPUT_MOVE&&ev.which!==1){eventType=INPUT_END}if(!this.pressed){return}if(eventType&INPUT_END){this.pressed=false}this.callback(this.manager,eventType,{pointers:[ev],changedPointers:[ev],pointerType:INPUT_TYPE_MOUSE,srcEvent:ev})}}]);return MouseInput}(Input);var DEDUP_TIMEOUT=2500;var DEDUP_DISTANCE=25;var TouchMouseInput=function(_Input){inherits(TouchMouseInput,_Input);function TouchMouseInput(){classCallCheck(this,TouchMouseInput);var _this=possibleConstructorReturn(this,(TouchMouseInput.__proto__||Object.getPrototypeOf(TouchMouseInput)).apply(this,arguments));var handler=bindFn(_this.handler,_this);_this.touch=new TouchInput(_this.manager,handler);_this.mouse=new MouseInput(_this.manager,handler);_this.primaryTouch=null;_this.lastTouches=[];return _this}createClass(TouchMouseInput,[{key:""handler"",value:function handler(manager,inputEvent,inputData){var isTouch=inputData.pointerType===INPUT_TYPE_TOUCH;var isMouse=inputData.pointerType===INPUT_TYPE_MOUSE;if(isMouse&&inputData.sourceCapabilities&&inputData.sourceCapabilities.firesTouchEvents){return}if(isTouch){recordTouches.call(this,inputEvent,inputData)}else if(isMouse&&isSyntheticEvent.call(this,inputData)){return}this.callback(manager,inputEvent,inputData)}},{key:""destroy"",value:function destroy(){this.touch.destroy();this.mouse.destroy()}}]);return TouchMouseInput}(Input);function recordTouches(eventType,eventData){if(eventType&INPUT_START){this.primaryTouch=eventData.changedPointers[0].identifier;setLastTouch.call(this,eventData)}else if(eventType&(INPUT_END|INPUT_CANCEL)){setLastTouch.call(this,eventData)}}function setLastTouch(eventData){var _this2=this;var _eventData$changedPoi=slicedToArray(eventData.changedPointers,1);var touch=_eventData$changedPoi[0];if(touch.identifier===this.primaryTouch){(function(){var lastTouch={x:touch.clientX,y:touch.clientY};_this2.lastTouches.push(lastTouch);var lts=_this2.lastTouches;var removeLastTouch=function removeLastTouch(){var i=lts.indexOf(lastTouch);if(i>-1){lts.splice(i,1)}};setTimeout(removeLastTouch,DEDUP_TIMEOUT)})()}}function isSyntheticEvent(eventData){var x=eventData.srcEvent.clientX;var y=eventData.srcEvent.clientY;for(var i=0;i<this.lastTouches.length;i++){var t=this.lastTouches[i];var dx=Math.abs(x-t.x);var dy=Math.abs(y-t.y);if(dx<=DEDUP_DISTANCE&&dy<=DEDUP_DISTANCE){return true}}return false}function createInputInstance(manager){var Type=void 0;var inputClass=manager.options.inputClass;if(inputClass){Type=inputClass}else if(SUPPORT_POINTER_EVENTS){Type=PointerEventInput}else if(SUPPORT_ONLY_TOUCH){Type=TouchInput}else if(!SUPPORT_TOUCH){Type=MouseInput}else{Type=TouchMouseInput}return new Type(manager,inputHandler)}var STOP=1;var FORCED_STOP=2;var Manager=function(){function Manager(element,options){var _this=this;classCallCheck(this,Manager);this.options=assign$1({},Hammer.defaults,options||{});this.options.inputTarget=this.options.inputTarget||element;this.handlers={};this.session={};this.recognizers=[];this.oldCssProps={};this.element=element;this.input=createInputInstance(this);this.touchAction=new TouchAction(this,this.options.touchAction);toggleCssProps(this,true);each(this.options.recognizers,function(item){var recognizer=_this.add(new item[0](item[1]));item[2]&&recognizer.recognizeWith(item[2]);item[3]&&recognizer.requireFailure(item[3])},this)}createClass(Manager,[{key:""set"",value:function set(options){assign$1(this.options,options);if(options.touchAction){this.touchAction.update()}if(options.inputTarget){this.input.destroy();this.input.target=options.inputTarget;this.input.init()}return this}},{key:""stop"",value:function stop(force){this.session.stopped=force?FORCED_STOP:STOP}},{key:""recognize"",value:function recognize(inputData){var session=this.session;if(session.stopped){return}this.touchAction.preventDefaults(inputData);var recognizer=void 0;var recognizers=this.recognizers;var curRecognizer=session.curRecognizer;if(!curRecognizer||curRecognizer&&curRecognizer.state&STATE_RECOGNIZED){curRecognizer=session.curRecognizer=null}var i=0;while(i<recognizers.length){recognizer=recognizers[i];if(session.stopped!==FORCED_STOP&&(!curRecognizer||recognizer===curRecognizer||recognizer.canRecognizeWith(curRecognizer))){recognizer.recognize(inputData)}else{recognizer.reset()}if(!curRecognizer&&recognizer.state&(STATE_BEGAN|STATE_CHANGED|STATE_ENDED)){curRecognizer=session.curRecognizer=recognizer}i++}}},{key:""get"",value:function get(recognizer){if(recognizer instanceof Recognizer){return recognizer}var recognizers=this.recognizers;for(var i=0;i<recognizers.length;i++){if(recognizers[i].options.event===recognizer){return recognizers[i]}}return null}},{key:""add"",value:function add(recognizer){if(invokeArrayArg(recognizer,""add"",this)){return this}var existing=this.get(recognizer.options.event);if(existing){this.remove(existing)}this.recognizers.push(recognizer);recognizer.manager=this;this.touchAction.update();return recognizer}},{key:""remove"",value:function remove(recognizer){if(invokeArrayArg(recognizer,""remove"",this)){return this}recognizer=this.get(recognizer);if(recognizer){var recognizers=this.recognizers;var index=inArray(recognizers,recognizer);if(index!==-1){recognizers.splice(index,1);this.touchAction.update()}}return this}},{key:""on"",value:function on(events,handler){if(events===undefined){return}if(handler===undefined){return}var handlers=this.handlers;each(splitStr(events),function(event){handlers[event]=handlers[event]||[];handlers[event].push(handler)});return this}},{key:""off"",value:function off(events,handler){if(events===undefined){return}var handlers=this.handlers;each(splitStr(events),function(event){if(!handler){delete handlers[event]}else{handlers[event]&&handlers[event].splice(inArray(handlers[event],handler),1)}});return this}},{key:""emit"",value:function emit(event,data){if(this.options.domEvents){triggerDomEvent(event,data)}var handlers=this.handlers[event]&&this.handlers[event].slice();if(!handlers||!handlers.length){return}data.type=event;data.preventDefault=function(){data.srcEvent.preventDefault()};var i=0;while(i<handlers.length){handlers[i](data);i++}}},{key:""destroy"",value:function destroy(){this.element&&toggleCssProps(this,false);this.handlers={};this.session={};this.input.destroy();this.element=null}}]);return Manager}();function toggleCssProps(manager,add){var element=manager.element;if(!element.style){return}var prop=void 0;each(manager.options.cssProps,function(value,name){prop=prefixed(element.style,name);if(add){manager.oldCssProps[prop]=element.style[prop];element.style[prop]=value}else{element.style[prop]=manager.oldCssProps[prop]||""""}});if(!add){manager.oldCssProps={}}}function triggerDomEvent(event,data){var gestureEvent=document.createEvent(""Event"");gestureEvent.initEvent(event,true,true);gestureEvent.gesture=data;data.target.dispatchEvent(gestureEvent)}var Hammer=function Hammer(element,options){classCallCheck(this,Hammer);options=options||{};options.recognizers=ifUndefined(options.recognizers,Hammer.defaults.preset);return new Manager(element,options)};Hammer.VERSION=""2.0.8"";Hammer.defaults={domEvents:false,touchAction:TOUCH_ACTION_COMPUTE,enable:true,inputTarget:null,inputClass:null,preset:[[RotateRecognizer,{enable:false}],[PinchRecognizer,{enable:false},[""rotate""]],[SwipeRecognizer,{direction:DIRECTION_HORIZONTAL}],[PanRecognizer,{direction:DIRECTION_HORIZONTAL},[""swipe""]],[TapRecognizer],[TapRecognizer,{event:""doubletap"",taps:2},[""tap""]],[PressRecognizer]],cssProps:{userSelect:""none"",touchSelect:""none"",touchCallout:""none"",contentZooming:""none"",userDrag:""none"",tapHighlightColor:""rgba(0,0,0,0)""}};var SINGLE_TOUCH_INPUT_MAP={touchstart:INPUT_START,touchmove:INPUT_MOVE,touchend:INPUT_END,touchcancel:INPUT_CANCEL};var SINGLE_TOUCH_TARGET_EVENTS=""touchstart"";var SINGLE_TOUCH_WINDOW_EVENTS=""touchstart touchmove touchend touchcancel"";var SingleTouchInput=function(_Input){inherits(SingleTouchInput,_Input);function SingleTouchInput(){classCallCheck(this,SingleTouchInput);var _this=possibleConstructorReturn(this,(SingleTouchInput.__proto__||Object.getPrototypeOf(SingleTouchInput)).apply(this,arguments));_this.evTarget=SINGLE_TOUCH_TARGET_EVENTS;_this.evWin=SINGLE_TOUCH_WINDOW_EVENTS;_this.started=false;Input.apply(_this,arguments);return _this}createClass(SingleTouchInput,[{key:""handler"",value:function handler(ev){var type=SINGLE_TOUCH_INPUT_MAP[ev.type];if(type===INPUT_START){this.started=true}if(!this.started){return}var touches=normalizeSingleTouches.call(this,ev,type);if(type&(INPUT_END|INPUT_CANCEL)&&touches[0].length-touches[1].length===0){this.started=false}this.callback(this.manager,type,{pointers:touches[0],changedPointers:touches[1],pointerType:INPUT_TYPE_TOUCH,srcEvent:ev})}}]);return SingleTouchInput}(Input);function normalizeSingleTouches(ev,type){var all=toArray$1(ev.touches);var changed=toArray$1(ev.changedTouches);if(type&(INPUT_END|INPUT_CANCEL)){all=uniqueArray(all.concat(changed),""identifier"",true)}return[all,changed]}function deprecate(method,name,message){var deprecationMessage=""DEPRECATED METHOD: ""+name+""\n""+message+"" AT \n"";return function(){var e=new Error(""get-stack-trace"");var stack=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,"""").replace(/^\s+at\s+/gm,"""").replace(/^Object.<anonymous>\s*\(/gm,""{anonymous}()@""):""Unknown Stack Trace"";var log=window.console&&(window.console.warn||window.console.log);if(log){log.call(window.console,deprecationMessage,stack)}return method.apply(this,arguments)}}var extend=deprecate(function(dest,src,merge){var keys=Object.keys(src);var i=0;while(i<keys.length){if(!merge||merge&&dest[keys[i]]===undefined){dest[keys[i]]=src[keys[i]]}i++}return dest},""extend"",""Use `assign`."");var merge=deprecate(function(dest,src){return extend(dest,src,true)},""merge"",""Use `assign`."");function inherit(child,base,properties){var baseP=base.prototype;var childP=void 0;childP=child.prototype=Object.create(baseP);childP.constructor=child;childP._super=baseP;if(properties){assign$1(childP,properties)}}assign$1(Hammer,{INPUT_START:INPUT_START,INPUT_MOVE:INPUT_MOVE,INPUT_END:INPUT_END,INPUT_CANCEL:INPUT_CANCEL,STATE_POSSIBLE:STATE_POSSIBLE,STATE_BEGAN:STATE_BEGAN,STATE_CHANGED:STATE_CHANGED,STATE_ENDED:STATE_ENDED,STATE_RECOGNIZED:STATE_RECOGNIZED,STATE_CANCELLED:STATE_CANCELLED,STATE_FAILED:STATE_FAILED,DIRECTION_NONE:DIRECTION_NONE,DIRECTION_LEFT:DIRECTION_LEFT,DIRECTION_RIGHT:DIRECTION_RIGHT,DIRECTION_UP:DIRECTION_UP,DIRECTION_DOWN:DIRECTION_DOWN,DIRECTION_HORIZONTAL:DIRECTION_HORIZONTAL,DIRECTION_VERTICAL:DIRECTION_VERTICAL,DIRECTION_ALL:DIRECTION_ALL,Manager:Manager,Input:Input,TouchAction:TouchAction,TouchInput:TouchInput,MouseInput:MouseInput,PointerEventInput:PointerEventInput,TouchMouseInput:TouchMouseInput,SingleTouchInput:SingleTouchInput,Recognizer:Recognizer,AttrRecognizer:AttrRecognizer,Tap:TapRecognizer,Pan:PanRecognizer,Swipe:SwipeRecognizer,Pinch:PinchRecognizer,Rotate:RotateRecognizer,Press:PressRecognizer,on:addEventListeners,off:removeEventListeners,each:each,merge:merge,extend:extend,assign:assign$1,inherit:inherit,bindFn:bindFn,prefixed:prefixed,toArray:toArray$1,inArray:inArray,uniqueArray:uniqueArray,splitStr:splitStr,boolOrFn:boolOrFn,hasParent:hasParent,addEventListeners:addEventListeners,removeEventListeners:removeEventListeners});if(typeof define===""function""&&define.amd){define(function(){return Hammer})}else if(typeof module!==""undefined""&&module.exports){module.exports=Hammer}else{window[exportName]=Hammer}})(window,document,""Hammer"");"
" * http://hammerjs.github.io/ * * Copyright (c)  Jorik Tangelder; * Licensed under the MIT license */(function(window, document, exportName, undefined) { use strict; *  * use the val2 when val1 is undefined *    *    *   */function ifUndefined(val1, val2) {  return val1 === undefined ? val2 : val1;}
var VENDOR_PREFIXES = [, webkit, Moz, MS, ms, o];var TEST_ELEMENT = document.createElement(div);
var TYPE_FUNCTION = function;
var round = Math.round;var abs = Math.abs;var now = Date.now;
 *  * get the prefixed property *    *    *   prefixed */function prefixed(obj, property) {  var prefix = void 0;  var prop = void 0;  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;  while (i < VENDOR_PREFIXES.length) {    prefix = VENDOR_PREFIXES[i];    prop = prefix ? prefix + camelProp : property;
    if (prop in obj) {      return prop;    }    i++;  }  return undefined;}
function getTouchActionProps() {  if (!NATIVE_TOUCH_ACTION) {    return false;  }  var touchMap = {};  var cssSupports = window.CSS && window.CSS.supports;  [auto, manipulation, pan-y, pan-x, pan-x pan-y, none].forEach(function (val) {
     If css.supports is not supported but there is native touch-action assume it supports     all values. This is the case for IE 10 and 11.    return touchMap[val] = cssSupports ? window.CSS.supports(touch-action, val) : true;  });  return touchMap;}
var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, touchAction);var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
 magical touchAction valuevar TOUCH_ACTION_COMPUTE = compute;var TOUCH_ACTION_AUTO = auto;var TOUCH_ACTION_MANIPULATION = manipulation;  not implementedvar TOUCH_ACTION_NONE = none;var TOUCH_ACTION_PAN_X = pan-x;var TOUCH_ACTION_PAN_Y = pan-y;var TOUCH_ACTION_MAP = getTouchActionProps();
var MOBILE_REGEX = mobiletabletip(adhoneod)androidi;
var SUPPORT_TOUCH = ontouchstart in window;var SUPPORT_POINTER_EVENTS = prefixed(window, PointerEvent) !== undefined;var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = touch;var INPUT_TYPE_PEN = pen;var INPUT_TYPE_MOUSE = mouse;var INPUT_TYPE_KINECT = kinect;
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;var INPUT_MOVE = 2;var INPUT_END = 4;var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;var DIRECTION_LEFT = 2;var DIRECTION_RIGHT = 4;var DIRECTION_UP = 8;var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = [x, y];var PROPS_CLIENT_XY = [clientX, clientY];
var STATE_POSSIBLE = 1;var STATE_BEGAN = 2;var STATE_CHANGED = 4;var STATE_ENDED = 8;var STATE_RECOGNIZED = STATE_ENDED;var STATE_CANCELLED = 16;var STATE_FAILED = 32;
 *  * extend object. * means that properties in dest will be overwritten by the ones in src. *    *    *   target */var assign = void 0;if (typeof Object.assign !== function) {  assign = function assign(target) {    if (target === undefined || target === null) {      throw new TypeError(Cannot convert undefined or null to object);    }
    var output = Object(target);    for (var index = 1; index < arguments.length; index++) {      var source = arguments[index];      if (source !== undefined && source !== null) {        for (var nextKey in source) {          if (source.hasOwnProperty(nextKey)) {            output[nextKey] = source[nextKey];          }        }      }    }    return output;  };} else {  assign = Object.assign;}
var assign$1 = assign;
 *  * get a unique id *   uniqueId */var _uniqueId = 1;function uniqueId() {  return _uniqueId++;}
 *  * walk objects and arrays *    *    *    */function each(obj, iterator, context) {  var i = void 0;
  if (!obj) {    return;  }
  if (obj.forEach) {    obj.forEach(iterator, context);  } else if (obj.length !== undefined) {    i = 0;    while (i < obj.length) {      iterator.call(context, obj[i], i, obj);      i++;    }  } else {    for (i in obj) {      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);    }  }}
 *  * if the argument is an array, we want to execute the fn on each entry * if it aint an array we don't want to do a thing. * this is used by all the methods that accept a single and array argument. *    *    *    *   */function invokeArrayArg(arg, fn, context) {  if (Array.isArray(arg)) {    each(arg, context[fn], context);    return true;  }  return false;}
 *  * find if a array contains the object using indexOf or a simple polyFill *    *    *    *   false when not found, or the index */function inArray(src, find, findByKey) {  if (src.indexOf && !findByKey) {    return src.indexOf(find);  } else {    var i = 0;    while (i < src.length) {      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {         do not use === here, test fails        return i;      }      i++;    }    return -1;  }}
var _typeof = typeof Symbol === function && typeof Symbol.iterator === symbol ? function (obj) {  return typeof obj;} : function (obj) {  return obj && typeof Symbol === function && obj.constructor === Symbol && obj !== Symbol.prototype ? symbol : typeof obj;};
var asyncGenerator = function () {  function AwaitValue(value) {    this.value = value;  }
  function AsyncGenerator(gen) {    var front, back;
    function send(key, arg) {      return new Promise(function (resolve, reject) {        var request = {          key: key,          arg: arg,          resolve: resolve,          reject: reject,          next: null        };
        if (back) {          back = back.next = request;        } else {          front = back = request;          resume(key, arg);        }      });    }
    function resume(key, arg) {      try {        var result = gen[key](arg);        var value = result.value;
        if (value instanceof AwaitValue) {          Promise.resolve(value.value).then(function (arg) {            resume(next, arg);          }, function (arg) {            resume(throw, arg);          });        } else {          settle(result.done ? return : normal, result.value);        }      } catch (err) {        settle(throw, err);      }    }
    function settle(type, value) {      switch (type) {        case return:          front.resolve({            value: value,            done: true          });          break;
        case throw:          front.reject(value);          break;
        default:          front.resolve({            value: value,            done: false          });          break;      }
      front = front.next;
      if (front) {        resume(front.key, front.arg);      } else {        back = null;      }    }
    this._invoke = send;
    if (typeof gen.return !== function) {      this.return = undefined;    }  }
  if (typeof Symbol === function && Symbol.asyncIterator) {    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {      return this;    };  }
  AsyncGenerator.prototype.next = function (arg) {    return this._invoke(next, arg);  };
  AsyncGenerator.prototype.throw = function (arg) {    return this._invoke(throw, arg);  };
  AsyncGenerator.prototype.return = function (arg) {    return this._invoke(return, arg);  };
  return {    wrap: function (fn) {      return function () {        return new AsyncGenerator(fn.apply(this, arguments));      };    },    await: function (value) {      return new AwaitValue(value);    }  };}();
var classCallCheck = function (instance, Constructor) {  if (!(instance instanceof Constructor)) {    throw new TypeError(Cannot call a class as a function);  }};
var createClass = function () {  function defineProperties(target, props) {    for (var i = 0; i < props.length; i++) {      var descriptor = props[i];      descriptor.enumerable = descriptor.enumerable || false;      descriptor.configurable = true;      if (value in descriptor) descriptor.writable = true;      Object.defineProperty(target, descriptor.key, descriptor);    }  }
  return function (Constructor, protoProps, staticProps) {    if (protoProps) defineProperties(Constructor.prototype, protoProps);    if (staticProps) defineProperties(Constructor, staticProps);    return Constructor;  };}();
var get = function get(object, property, receiver) {  if (object === null) object = Function.prototype;  var desc = Object.getOwnPropertyDescriptor(object, property);
  if (desc === undefined) {    var parent = Object.getPrototypeOf(object);
    if (parent === null) {      return undefined;    } else {      return get(parent, property, receiver);    }  } else if (value in desc) {    return desc.value;  } else {    var getter = desc.get;
    if (getter === undefined) {      return undefined;    }
    return getter.call(receiver);  }};
var inherits = function (subClass, superClass) {  if (typeof superClass !== function && superClass !== null) {    throw new TypeError(Super expression must either be null or a function, not  + typeof superClass);  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {    constructor: {      value: subClass,      enumerable: false,      writable: true,      configurable: true    }  });  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;};
var possibleConstructorReturn = function (self, call) {  if (!self) {    throw new ReferenceError(this hasn't been initialised - super() hasn't been called);  }
  return call && (typeof call === object || typeof call === function) ? call : self;};
var slicedToArray = function () {  function sliceIterator(arr, i) {    var _arr = [];    var _n = true;    var _d = false;    var _e = undefined;
    try {      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {        _arr.push(_s.value);
        if (i && _arr.length === i) break;      }    } catch (err) {      _d = true;      _e = err;    } finally {      try {        if (!_n && _i[return]) _i[return]();      } finally {        if (_d) throw _e;      }    }
    return _arr;  }
  return function (arr, i) {    if (Array.isArray(arr)) {      return arr;    } else if (Symbol.iterator in Object(arr)) {      return sliceIterator(arr, i);    } else {      throw new TypeError(Invalid attempt to destructure non-iterable instance);    }  };}();
 *  * let a boolean value also be a function that must return a boolean * this first item in args will be used as the context *    *    *   */function boolOrFn(val, args) {  if ((typeof val === undefined ? undefined : _typeof(val)) === TYPE_FUNCTION) {    return val.apply(args ? args[0] || undefined : undefined, args);  }  return val;}
 *  * get a recognizer by name if it is bound to a manager *    *    *   */function getRecognizerByNameIfManager(otherRecognizer, recognizer) {  var manager = recognizer.manager;
  if (manager) {    return manager.get(otherRecognizer);  }  return otherRecognizer;}
 *  * get a usable string, used as event postfix *    *   state */function stateStr(state) {  if (state & STATE_CANCELLED) {    return cancel;  } else if (state & STATE_ENDED) {    return end;  } else if (state & STATE_CHANGED) {    return move;  } else if (state & STATE_BEGAN) {    return start;  }  return ;}
 *  * Recognizer flow explained; * * All recognizers have the initial state of POSSIBLE when a input session starts. * The definition of a input session is from the first input until the last input, with all it's movement in it. * * Example session for mouse-input: mousedown -> mousemove -> mouseup * * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed * which determines with state it should be. * * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to * POSSIBLE to give it another change on the next cycle. * *               Possible *                  | *            +-----+---------------+ *            |                     | *      +-----+-----+               | *      |           |               | *   Failed      Cancelled          | *                          +-------+------+ *                          |              | *                      Recognized       Began *                                         | *                                      Changed *                                         | *                                  Ended/Recognized */
 *  * Recognizer * Every recognizer needs to extend from this class. *  *    */
var Recognizer = function () {  function Recognizer(options) {    classCallCheck(this, Recognizer);
    this.options = assign$1({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null;
     default is enable true    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;    this.simultaneous = {};    this.requireFail = [];  }
     *    * set options   *      *     */

  createClass(Recognizer, [{    key: set,    value: function set(options) {      assign$1(this.options, options);
       also update the touchAction, in case something changed about the directions/enabled state      this.manager && this.manager.touchAction.update();      return this;    }
         *      * recognize simultaneous with an other recognizer.     *        *   this     */
  }, {    key: recognizeWith,    value: function recognizeWith(otherRecognizer) {      if (invokeArrayArg(otherRecognizer, recognizeWith, this)) {        return this;      }
      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);      if (!simultaneous[otherRecognizer.id]) {        simultaneous[otherRecognizer.id] = otherRecognizer;        otherRecognizer.recognizeWith(this);      }      return this;    }
         *      * drop the simultaneous link. it doesnt remove the link on the other recognizer.     *        *   this     */
  }, {    key: dropRecognizeWith,    value: function dropRecognizeWith(otherRecognizer) {      if (invokeArrayArg(otherRecognizer, dropRecognizeWith, this)) {        return this;      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);      delete this.simultaneous[otherRecognizer.id];      return this;    }
         *      * recognizer can only run when an other is failing     *        *   this     */
  }, {    key: requireFailure,    value: function requireFailure(otherRecognizer) {      if (invokeArrayArg(otherRecognizer, requireFailure, this)) {        return this;      }
      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);      if (inArray(requireFail, otherRecognizer) === -1) {        requireFail.push(otherRecognizer);        otherRecognizer.requireFailure(this);      }      return this;    }
         *      * drop the requireFailure link. it does not remove the link on the other recognizer.     *        *   this     */
  }, {    key: dropRequireFailure,    value: function dropRequireFailure(otherRecognizer) {      if (invokeArrayArg(otherRecognizer, dropRequireFailure, this)) {        return this;      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);      var index = inArray(this.requireFail, otherRecognizer);      if (index > -1) {        this.requireFail.splice(index, 1);      }      return this;    }
         *      * has require failures boolean     *       */
  }, {    key: hasRequireFailures,    value: function hasRequireFailures() {      return this.requireFail.length > 0;    }
         *      * if the recognizer can recognize simultaneous with an other recognizer     *        *       */
  }, {    key: canRecognizeWith,    value: function canRecognizeWith(otherRecognizer) {      return !!this.simultaneous[otherRecognizer.id];    }
         *      * You should use `tryEmit` instead of `emit` directly to check     * that all the needed recognizers has failed before emitting.     *        */
  }, {    key: emit,    value: function emit(input) {      var self = this;      var state = this.state;

      function emit(event) {        self.manager.emit(event, input);      }
       'panstart' and 'panmove'      if (state < STATE_ENDED) {        emit(self.options.event + stateStr(state));      }
      emit(self.options.event);  simple 'eventName' events
      if (input.additionalEvent) {         additional event(panleft, panright, pinchin, pinchout...)        emit(input.additionalEvent);      }
       panend and pancancel      if (state >= STATE_ENDED) {        emit(self.options.event + stateStr(state));      }    }
         *      * Check that all the require failure recognizers has failed,     * if true, it emits a gesture event,     * otherwise, setup the state to FAILED.     *        */
  }, {    key: tryEmit,    value: function tryEmit(input) {      if (this.canEmit()) {        return this.emit(input);      }       it's failing anyway      this.state = STATE_FAILED;    }
         *      * can we emit?     *       */
  }, {    key: canEmit,    value: function canEmit() {      var i = 0;      while (i < this.requireFail.length) {        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {          return false;        }        i++;      }      return true;    }
         *      * update the recognizer     *        */
  }, {    key: recognize,    value: function recognize(inputData) {       make a new copy of the inputData       so we can change the inputData without messing up the other recognizers      var inputDataClone = assign$1({}, inputData);
       is is enabled and allow recognizing?      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {        this.reset();        this.state = STATE_FAILED;        return;      }
       reset when we've reached the end      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {        this.state = STATE_POSSIBLE;      }
      this.state = this.process(inputDataClone);
       the recognizer has recognized a gesture       so trigger an event      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {        this.tryEmit(inputDataClone);      }    }
         *      * return the state of the recognizer     * the actual recognizing happens in this method     *      *        *   STATE     */
    
  }, {    key: process,    value: function process(inputData) {}    
         *      * return the preferred touch-action     *      *       */
  }, {    key: getTouchAction,    value: function getTouchAction() {}
         *      * called when the gesture isn't allowed to recognize     * like when another is being recognized or it is disabled     *      */
  }, {    key: reset,    value: function reset() {}  }]);  return Recognizer;}();
Recognizer.prototype.defaults = {};
 *  * This recognizer is just used as a base for the simple attribute recognizers. *  *   */
var AttrRecognizer = function (_Recognizer) {  inherits(AttrRecognizer, _Recognizer);
  function AttrRecognizer() {    classCallCheck(this, AttrRecognizer);    return possibleConstructorReturn(this, (AttrRecognizer.__proto__ || Object.getPrototypeOf(AttrRecognizer)).apply(this, arguments));  }
     *    * Used to check if it the recognizer receives valid input, like input.distance > 10.   *     *      *   recognized   */

  createClass(AttrRecognizer, [{    key: attrTest,    value: function attrTest(input) {      var optionPointers = this.options.pointers;      return optionPointers === 0 || input.pointers.length === optionPointers;    }
         *      * Process the input and return the state for the recognizer     *       *        *   State     */
  }, {    key: process,    value: function process(input) {      var state = this.state;      var eventType = input.eventType;

      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);      var isValid = this.attrTest(input);
       on cancel input and we've recognized before, return STATE_CANCELLED      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {        return state | STATE_CANCELLED;      } else if (isRecognized || isValid) {        if (eventType & INPUT_END) {          return state | STATE_ENDED;        } else if (!(state & STATE_BEGAN)) {          return STATE_BEGAN;        }        return state | STATE_CHANGED;      }      return STATE_FAILED;    }  }]);  return AttrRecognizer;}(Recognizer);
AttrRecognizer.prototype.defaults = {     *    *     *     */  pointers: 1};
 *  * Rotate * Recognized when two or more pointer are moving in a circular motion. *  *   */
var RotateRecognizer = function (_AttrRecognizer) {  inherits(RotateRecognizer, _AttrRecognizer);
  function RotateRecognizer() {    classCallCheck(this, RotateRecognizer);    return possibleConstructorReturn(this, (RotateRecognizer.__proto__ || Object.getPrototypeOf(RotateRecognizer)).apply(this, arguments));  }
  createClass(RotateRecognizer, [{    key: getTouchAction,    value: function getTouchAction() {      return [TOUCH_ACTION_NONE];    }  }, {    key: attrTest,    value: function attrTest(input) {      return get(RotateRecognizer.prototype.__proto__ || Object.getPrototypeOf(RotateRecognizer.prototype), attrTest, this).call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);    }  }]);  return RotateRecognizer;}(AttrRecognizer);
RotateRecognizer.prototype.defaults = {  event: rotate,  threshold: 0,  pointers: 2};
 *  * Pinch * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out). *  *   */
var PinchRecognizer = function (_AttrRecognizer) {  inherits(PinchRecognizer, _AttrRecognizer);
  function PinchRecognizer() {    classCallCheck(this, PinchRecognizer);    return possibleConstructorReturn(this, (PinchRecognizer.__proto__ || Object.getPrototypeOf(PinchRecognizer)).apply(this, arguments));  }
  createClass(PinchRecognizer, [{    key: getTouchAction,    value: function getTouchAction() {      return [TOUCH_ACTION_NONE];    }  }, {    key: attrTest,    value: function attrTest(input) {      return get(PinchRecognizer.prototype.__proto__ || Object.getPrototypeOf(PinchRecognizer.prototype), attrTest, this).call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);    }  }, {    key: emit,    value: function emit(input) {      if (input.scale !== 1) {        var inOut = input.scale < 1 ? in : out;        input.additionalEvent = this.options.event + inOut;      }      get(PinchRecognizer.prototype.__proto__ || Object.getPrototypeOf(PinchRecognizer.prototype), emit, this).call(this, input);    }  }]);  return PinchRecognizer;}(AttrRecognizer);
PinchRecognizer.prototype.defaults = {  event: pinch,  threshold: 0,  pointers: 2};
 *  * direction cons to string *    *   */function directionStr(direction) {  if (direction === DIRECTION_DOWN) {    return down;  } else if (direction === DIRECTION_UP) {    return up;  } else if (direction === DIRECTION_LEFT) {    return left;  } else if (direction === DIRECTION_RIGHT) {    return right;  }  return ;}
 *  * Pan * Recognized when the pointer is down and moved in the allowed direction. *  *   */
var PanRecognizer = function (_AttrRecognizer) {  inherits(PanRecognizer, _AttrRecognizer);
  function PanRecognizer() {    classCallCheck(this, PanRecognizer);
    var _this = possibleConstructorReturn(this, (PanRecognizer.__proto__ || Object.getPrototypeOf(PanRecognizer)).apply(this, arguments));
    _this.pX = null;    _this.pY = null;    return _this;  }
  createClass(PanRecognizer, [{    key: getTouchAction,    value: function getTouchAction() {      var direction = this.options.direction;
      var actions = [];      if (direction & DIRECTION_HORIZONTAL) {        actions.push(TOUCH_ACTION_PAN_Y);      }      if (direction & DIRECTION_VERTICAL) {        actions.push(TOUCH_ACTION_PAN_X);      }      return actions;    }  }, {    key: directionTest,    value: function directionTest(input) {      var options = this.options;
      var hasMoved = true;      var distance = input.distance;      var direction = input.direction;
      var x = input.deltaX;      var y = input.deltaY;
       lock to axis?      if (!(direction & options.direction)) {        if (options.direction & DIRECTION_HORIZONTAL) {          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;          hasMoved = x !== this.pX;          distance = Math.abs(input.deltaX);        } else {          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;          hasMoved = y !== this.pY;          distance = Math.abs(input.deltaY);        }      }      input.direction = direction;      return hasMoved && distance > options.threshold && direction & options.direction;    }  }, {    key: attrTest,    value: function attrTest(input) {      return AttrRecognizer.prototype.attrTest.call(this, input) && (  replace with a super call      this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));    }  }, {    key: emit,    value: function emit(input) {
      this.pX = input.deltaX;      this.pY = input.deltaY;
      var direction = directionStr(input.direction);
      if (direction) {        input.additionalEvent = this.options.event + direction;      }      get(PanRecognizer.prototype.__proto__ || Object.getPrototypeOf(PanRecognizer.prototype), emit, this).call(this, input);    }  }]);  return PanRecognizer;}(AttrRecognizer);
PanRecognizer.prototype.defaults = {  event: pan,  threshold: 10,  pointers: 1,  direction: DIRECTION_ALL};
 *  * Swipe * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction. *  *   */
var SwipeRecognizer = function (_AttrRecognizer) {  inherits(SwipeRecognizer, _AttrRecognizer);
  function SwipeRecognizer() {    classCallCheck(this, SwipeRecognizer);    return possibleConstructorReturn(this, (SwipeRecognizer.__proto__ || Object.getPrototypeOf(SwipeRecognizer)).apply(this, arguments));  }
  createClass(SwipeRecognizer, [{    key: getTouchAction,    value: function getTouchAction() {      return PanRecognizer.prototype.getTouchAction.call(this);    }  }, {    key: attrTest,    value: function attrTest(input) {      var direction = this.options.direction;
      var velocity = void 0;
      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {        velocity = input.overallVelocity;      } else if (direction & DIRECTION_HORIZONTAL) {        velocity = input.overallVelocityX;      } else if (direction & DIRECTION_VERTICAL) {        velocity = input.overallVelocityY;      }
      return get(SwipeRecognizer.prototype.__proto__ || Object.getPrototypeOf(SwipeRecognizer.prototype), attrTest, this).call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;    }  }, {    key: emit,    value: function emit(input) {      var direction = directionStr(input.offsetDirection);      if (direction) {        this.manager.emit(this.options.event + direction, input);      }
      this.manager.emit(this.options.event, input);    }  }]);  return SwipeRecognizer;}(AttrRecognizer);
SwipeRecognizer.prototype.defaults = {  event: swipe,  threshold: 10,  velocity: 0.3,  direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,  pointers: 1};
 *  * simple function bind *    *    *   */function bindFn(fn, context) {  return function boundFn() {    return fn.apply(context, arguments);  };}
 *  * set a timeout with a given scope *    *    *    *   */function setTimeoutContext(fn, timeout, context) {  return setTimeout(bindFn(fn, context), timeout);}
 *  * calculate the absolute distance between two points *    {x, y} *    {x, y} *    containing x and y keys *   distance */function getDistance(p1, p2, props) {  if (!props) {    props = PROPS_XY;  }  var x = p2[props[0]] - p1[props[0]];  var y = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x  x + y  y);}
 *  * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur * between the given interval and position. The delay option can be used to recognize multi-taps without firing * a single tap. * * The eventData from the emitted event contains the property `tapCount`, which contains the amount of * multi-taps being recognized. *  *   */
var TapRecognizer = function (_Recognizer) {  inherits(TapRecognizer, _Recognizer);
  function TapRecognizer() {    classCallCheck(this, TapRecognizer);
     previous time and center,     used for tap counting    var _this = possibleConstructorReturn(this, (TapRecognizer.__proto__ || Object.getPrototypeOf(TapRecognizer)).apply(this, arguments));
    _this.pTime = false;    _this.pCenter = false;
    _this._timer = null;    _this._input = null;    _this.count = 0;    return _this;  }
  createClass(TapRecognizer, [{    key: getTouchAction,    value: function getTouchAction() {      return [TOUCH_ACTION_MANIPULATION];    }  }, {    key: process,    value: function process(input) {      var _this2 = this;
      var options = this.options;

      var validPointers = input.pointers.length === options.pointers;      var validMovement = input.distance < options.threshold;      var validTouchTime = input.deltaTime < options.time;
      this.reset();
      if (input.eventType & INPUT_START && this.count === 0) {        return this.failTimeout();      }
       we only allow little movement       and we've reached an end event, so a tap is possible      if (validMovement && validTouchTime && validPointers) {        if (input.eventType !== INPUT_END) {          return this.failTimeout();        }
        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;        this.pCenter = input.center;
        if (!validMultiTap || !validInterval) {          this.count = 1;        } else {          this.count += 1;        }
        this._input = input;
         if tap count matches we have recognized it,         else it has began recognizing...        var tapCount = this.count % options.taps;        if (tapCount === 0) {           no failing requirements, immediately trigger the tap event           or wait as long as the multitap interval to trigger          if (!this.hasRequireFailures()) {            return STATE_RECOGNIZED;          } else {            this._timer = setTimeoutContext(function () {              _this2.state = STATE_RECOGNIZED;              _this2.tryEmit();            }, options.interval, this);            return STATE_BEGAN;          }        }      }      return STATE_FAILED;    }  }, {    key: failTimeout,    value: function failTimeout() {      var _this3 = this;
      this._timer = setTimeoutContext(function () {        _this3.state = STATE_FAILED;      }, this.options.interval, this);      return STATE_FAILED;    }  }, {    key: reset,    value: function reset() {      clearTimeout(this._timer);    }  }, {    key: emit,    value: function emit() {      if (this.state === STATE_RECOGNIZED) {        this._input.tapCount = this.count;        this.manager.emit(this.options.event, this._input);      }    }  }]);  return TapRecognizer;}(Recognizer);
TapRecognizer.prototype.defaults = {  event: tap,  pointers: 1,  taps: 1,  interval: 300,  max time between the multi-tap taps  time: 250,  max time of the pointer to be down (like finger on the screen)  threshold: 9,  a minimal movement is ok, but keep it low  posThreshold: 10  a multi-tap can be a bit off the initial position};
 *  * Press * Recognized when the pointer is down for x ms without any movement. *  *   */
var PressRecognizer = function (_Recognizer) {  inherits(PressRecognizer, _Recognizer);
  function PressRecognizer() {    classCallCheck(this, PressRecognizer);
    var _this = possibleConstructorReturn(this, (PressRecognizer.__proto__ || Object.getPrototypeOf(PressRecognizer)).apply(this, arguments));
    _this._timer = null;    _this._input = null;    return _this;  }
  createClass(PressRecognizer, [{    key: getTouchAction,    value: function getTouchAction() {      return [TOUCH_ACTION_AUTO];    }  }, {    key: process,    value: function process(input) {      var _this2 = this;
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;      var validMovement = input.distance < options.threshold;      var validTime = input.deltaTime > options.time;
      this._input = input;
       we only allow little movement       and we've reached an end event, so a tap is possible      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {        this.reset();      } else if (input.eventType & INPUT_START) {        this.reset();        this._timer = setTimeoutContext(function () {          _this2.state = STATE_RECOGNIZED;          _this2.tryEmit();        }, options.time, this);      } else if (input.eventType & INPUT_END) {        return STATE_RECOGNIZED;      }      return STATE_FAILED;    }  }, {    key: reset,    value: function reset() {      clearTimeout(this._timer);    }  }, {    key: emit,    value: function emit(input) {      if (this.state !== STATE_RECOGNIZED) {        return;      }
      if (input && input.eventType & INPUT_END) {        this.manager.emit(this.options.event + up, input);      } else {        this._input.timeStamp = now();        this.manager.emit(this.options.event, this._input);      }    }  }]);  return PressRecognizer;}(Recognizer);
PressRecognizer.prototype.defaults = {  event: press,  pointers: 1,  time: 251,  minimal time of the pointer to be pressed  threshold: 9  a minimal movement is ok, but keep it low};
 *  * small indexOf wrapper *    *    *   found */function inStr(str, find) {  return str.indexOf(find) > -1;}
 *  * when the touchActions are collected they are not a valid value, so we need to clean things up. * *    *   */function cleanTouchActions(actions) {   none  if (inStr(actions, TOUCH_ACTION_NONE)) {    return TOUCH_ACTION_NONE;  }
  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
   if both pan-x and pan-y are set (different recognizers   for different directions, e.g. horizontal pan but vertical swipe?)   we need none (as otherwise with pan-x pan-y combined none of these   recognizers will work, since the browser would handle all panning  if (hasPanX && hasPanY) {    return TOUCH_ACTION_NONE;  }
   pan-x OR pan-y  if (hasPanX || hasPanY) {    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;  }
   manipulation  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {    return TOUCH_ACTION_MANIPULATION;  }
  return TOUCH_ACTION_AUTO;}
 *  * Touch Action * sets the touchAction property or uses the js alternative *    *    *  */
var TouchAction = function () {  function TouchAction(manager, value) {    classCallCheck(this, TouchAction);
    this.manager = manager;    this.set(value);  }
     *    * set the touchAction value on the element or enable the polyfill   *      */

  createClass(TouchAction, [{    key: set,    value: function set(value) {       find out the touch-action by the event handlers      if (value === TOUCH_ACTION_COMPUTE) {        value = this.compute();      }
      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;      }      this.actions = value.toLowerCase().trim();    }
         *      * just re-set the touchAction value     */
  }, {    key: update,    value: function update() {      this.set(this.manager.options.touchAction);    }
         *      * compute the value for the touchAction property based on the recognizer's settings     *   value     */
  }, {    key: compute,    value: function compute() {      var actions = [];      each(this.manager.recognizers, function (recognizer) {        if (boolOrFn(recognizer.options.enable, [recognizer])) {          actions = actions.concat(recognizer.getTouchAction());        }      });      return cleanTouchActions(actions.join( ));    }
         *      * this method is called on each input cycle and provides the preventing of the browser behavior     *        */
  }, {    key: preventDefaults,    value: function preventDefaults(input) {      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection;
       if the touch action did prevented once this session      if (this.manager.session.prevented) {        srcEvent.preventDefault();        return;      }
      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
      if (hasNone) {         do not prevent defaults if this is a tap gesture        var isTapPointer = input.pointers.length === 1;        var isTapMovement = input.distance < 2;        var isTapTouchTime = input.deltaTime < 250;
        if (isTapPointer && isTapMovement && isTapTouchTime) {          return;        }      }
      if (hasPanX && hasPanY) {         `pan-x pan-y` means browser handles all scrolling/panning, do not prevent        return;      }
      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {        return this.preventSrc(srcEvent);      }    }
         *      * call preventDefault to prevent the browser's default behavior (scrolling in most cases)     *        */
  }, {    key: preventSrc,    value: function preventSrc(srcEvent) {      this.manager.session.prevented = true;      srcEvent.preventDefault();    }  }]);  return TouchAction;}();
 *  * find if a node is in the given parent *   *    *    *   found */function hasParent(node, parent) {  while (node) {    if (node === parent) {      return true;    }    node = node.parentNode;  }  return false;}
 *  * get the center of all the pointers *    *   center contains `x` and `y` properties */function getCenter(pointers) {  var pointersLength = pointers.length;
   no need to loop when only one touch  if (pointersLength === 1) {    return {      x: round(pointers[0].clientX),      y: round(pointers[0].clientY)    };  }
  var x = 0;  var y = 0;  var i = 0;  while (i < pointersLength) {    x += pointers[i].clientX;    y += pointers[i].clientY;    i++;  }
  return {    x: round(x / pointersLength),    y: round(y / pointersLength)  };}
 *  * create a simple clone from the input used for storage of firstInput and firstMultiple *    *   clonedInputData */function simpleCloneInputData(input) {   make a simple copy of the pointers because we will get a reference if we don't   we only need clientXY for the calculations  var pointers = [];  var i = 0;  while (i < input.pointers.length) {    pointers[i] = {      clientX: round(input.pointers[i].clientX),      clientY: round(input.pointers[i].clientY)    };    i++;  }
  return {    timeStamp: now(),    pointers: pointers,    center: getCenter(pointers),    deltaX: input.deltaX,    deltaY: input.deltaY  };}
 *  * calculate the angle between two coordinates *    *    *    containing x and y keys *   angle */function getAngle(p1, p2, props) {  if (!props) {    props = PROPS_XY;  }  var x = p2[props[0]] - p1[props[0]];  var y = p2[props[1]] - p1[props[1]];  return Math.atan2(y, x)  180 / Math.PI;}
 *  * get the direction between two points *    *    *   direction */function getDirection(x, y) {  if (x === y) {    return DIRECTION_NONE;  }
  if (abs(x) >= abs(y)) {    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;  }  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;}
function computeDeltaXY(session, input) {  var center = input.center;   let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;   jscs throwing error on defalut destructured values and without defaults tests fail
  var offset = session.offsetDelta || {};  var prevDelta = session.prevDelta || {};  var prevInput = session.prevInput || {};
  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {    prevDelta = session.prevDelta = {      x: prevInput.deltaX || 0,      y: prevInput.deltaY || 0    };
    offset = session.offsetDelta = {      x: center.x,      y: center.y    };  }
  input.deltaX = prevDelta.x + (center.x - offset.x);  input.deltaY = prevDelta.y + (center.y - offset.y);}
 *  * calculate the velocity between two points. unit is in px per ms. *    *    *    *   velocity `x` and `y` */function getVelocity(deltaTime, x, y) {  return {    x: x / deltaTime || 0,    y: y / deltaTime || 0  };}
 *  * calculate the scale factor between two pointersets * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out *    array of pointers *    array of pointers *   scale */function getScale(start, end) {  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);}
 *  * calculate the rotation degrees between two pointersets *    array of pointers *    array of pointers *   rotation */function getRotation(start, end) {  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);}
 *  * velocity is calculated every x ms *    *    */function computeIntervalInputData(session, input) {  var last = session.lastInterval || input;  var deltaTime = input.timeStamp - last.timeStamp;  var velocity = void 0;  var velocityX = void 0;  var velocityY = void 0;  var direction = void 0;
  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {    var deltaX = input.deltaX - last.deltaX;    var deltaY = input.deltaY - last.deltaY;
    var v = getVelocity(deltaTime, deltaX, deltaY);    velocityX = v.x;    velocityY = v.y;    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;  } else {     use latest velocity info if it doesn't overtake a minimum period    velocity = last.velocity;    velocityX = last.velocityX;    velocityY = last.velocityY;    direction = last.direction;  }
  input.velocity = velocity;  input.velocityX = velocityX;  input.velocityY = velocityY;  input.direction = direction;}
 * extend the data with some usable properties like scale, rotate, velocity etc *    *    */function computeInputData(manager, input) {  var session = manager.session;  var pointers = input.pointers;  var pointersLength = pointers.length;
   store the first input to calculate the distance and direction
  if (!session.firstInput) {    session.firstInput = simpleCloneInputData(input);  }
   to compute scale and rotation we need to store the multiple touches  if (pointersLength > 1 && !session.firstMultiple) {    session.firstMultiple = simpleCloneInputData(input);  } else if (pointersLength === 1) {    session.firstMultiple = false;  }
  var firstInput = session.firstInput;  var firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);  input.timeStamp = now();  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);  input.overallVelocityX = overallVelocity.x;  input.overallVelocityY = overallVelocity.y;  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input);
   find the correct target  var target = manager.element;  if (hasParent(input.srcEvent.target, target)) {    target = input.srcEvent.target;  }  input.target = target;}
 *  * handle input events *    *    *    */function inputHandler(manager, eventType, input) {  var pointersLen = input.pointers.length;  var changedPointersLen = input.changedPointers.length;  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;  input.isFinal = !!isFinal;
  if (isFirst) {    manager.session = {};  }
   source event is the normalized value of the domEvents   like 'touchstart, mouseup, pointerdown'  input.eventType = eventType;
   compute scale, rotation etc  computeInputData(manager, input);
   emit secret event  manager.emit(hammer.input, input);
  manager.recognize(input);  manager.session.prevInput = input;}
 *  * split string on whitespace *    *   words */
function splitStr(str) {  return str.trim().split(g);}
 *  * addEventListener with multiple events at once *    *    *    */function addEventListeners(target, types, handler) {  each(splitStr(types), function (type) {    target.addEventListener(type, handler, false);  });}
 *  * removeEventListener with multiple events at once *    *    *    */function removeEventListeners(target, types, handler) {  each(splitStr(types), function (type) {    target.removeEventListener(type, handler, false);  });}
 *  * get the window object of an element *    *   */function getWindowForElement(element) {  var doc = element.ownerDocument || element;  return doc.defaultView || doc.parentWindow || window;}
 *  * create new input type manager *    *    *   *  */
var Input = function () {  function Input(manager, callback) {    classCallCheck(this, Input);
    var self = this;    this.manager = manager;    this.callback = callback;    this.element = manager.element;    this.target = manager.options.inputTarget;
     smaller wrapper around the handler, for the scope and the enabled state of the manager,     so when disabled the input events are completely bypassed.    this.domHandler = function (ev) {      if (boolOrFn(manager.options.enable, [manager])) {        self.handler(ev);      }    };
    this.init();  }     *    * should handle the inputEvent data and trigger the callback   *    */

  createClass(Input, [{    key: handler,    value: function handler() {}
         *      * bind the events     */
  }, {    key: init,    value: function init() {      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);    }
         *      * unbind the events     */
  }, {    key: destroy,    value: function destroy() {      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);    }  }]);  return Input;}();
var POINTER_INPUT_MAP = {  pointerdown: INPUT_START,  pointermove: INPUT_MOVE,  pointerup: INPUT_END,  pointercancel: INPUT_CANCEL,  pointerout: INPUT_CANCEL};
 in IE10 the pointer types is defined as an enumvar IE10_POINTER_TYPE_ENUM = {  2: INPUT_TYPE_TOUCH,  3: INPUT_TYPE_PEN,  4: INPUT_TYPE_MOUSE,  5: INPUT_TYPE_KINECT  see https://twitter.com/jacobrossi/status/480596438489890816};
var POINTER_ELEMENT_EVENTS = pointerdown;var POINTER_WINDOW_EVENTS = pointermove pointerup pointercancel;
 IE10 has prefixed support, and case-sensitiveif (window.MSPointerEvent && !window.PointerEvent) {  POINTER_ELEMENT_EVENTS = MSPointerDown;  POINTER_WINDOW_EVENTS = MSPointerMove MSPointerUp MSPointerCancel;}
 *  * Pointer events input *  *   */
var PointerEventInput = function (_Input) {  inherits(PointerEventInput, _Input);
  function PointerEventInput() {    classCallCheck(this, PointerEventInput);
    var _this = possibleConstructorReturn(this, (PointerEventInput.__proto__ || Object.getPrototypeOf(PointerEventInput)).apply(this, arguments));
    _this.evEl = POINTER_ELEMENT_EVENTS;    _this.evWin = POINTER_WINDOW_EVENTS;
    _this.store = _this.manager.session.pointerEvents = [];    return _this;  }
     *    * handle mouse events   *      */

  createClass(PointerEventInput, [{    key: handler,    value: function handler(ev) {      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace(ms, );      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType === INPUT_TYPE_TOUCH;
       get index of the event in the store      var storeIndex = inArray(store, ev.pointerId, pointerId);
       start and mouse must be down      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {        if (storeIndex < 0) {          store.push(ev);          storeIndex = store.length - 1;        }      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {        removePointer = true;      }
       it not found, so the pointer hasn't been down (so it's probably a hover)      if (storeIndex < 0) {        return;      }
       update the event in the store      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {        pointers: store,        changedPointers: [ev],        pointerType: pointerType,        srcEvent: ev      });
      if (removePointer) {         remove from the store        store.splice(storeIndex, 1);      }    }  }]);  return PointerEventInput;}(Input);
 *  * convert array-like objects to real arrays *    *   */function toArray$1(obj) {  return Array.prototype.slice.call(obj, 0);}
 *  * unique array with objects based on a key (like 'id') or just by the array's value *    [{id:1},{id:2},{id:1}] *    *    *   [{id:1},{id:2}] */function uniqueArray(src, key, sort) {  var results = [];  var values = [];  var i = 0;
  while (i < src.length) {    var val = key ? src[i][key] : src[i];    if (inArray(values, val) < 0) {      results.push(src[i]);    }    values[i] = val;    i++;  }
  if (sort) {    if (!key) {      results = results.sort();    } else {      results = results.sort(function (a, b) {        return a[key] > b[key];      });    }  }
  return results;}
var TOUCH_INPUT_MAP = {  touchstart: INPUT_START,  touchmove: INPUT_MOVE,  touchend: INPUT_END,  touchcancel: INPUT_CANCEL};
var TOUCH_TARGET_EVENTS = touchstart touchmove touchend touchcancel;
 *  * Multi-user touch events input *  *   */
var TouchInput = function (_Input) {  inherits(TouchInput, _Input);
  function TouchInput() {    classCallCheck(this, TouchInput);
    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;    TouchInput.prototype.targetIds = {};
    var _this = possibleConstructorReturn(this, (TouchInput.__proto__ || Object.getPrototypeOf(TouchInput)).apply(this, arguments));
    _this.evTarget = TOUCH_TARGET_EVENTS;    _this.targetIds = {};    return _this;  }
  createClass(TouchInput, [{    key: handler,    value: function handler(ev) {      var type = TOUCH_INPUT_MAP[ev.type];      var touches = getTouches.call(this, ev, type);      if (!touches) {        return;      }
      this.callback(this.manager, type, {        pointers: touches[0],        changedPointers: touches[1],        pointerType: INPUT_TYPE_TOUCH,        srcEvent: ev      });    }  }]);  return TouchInput;}(Input);
function getTouches(ev, type) {  var allTouches = toArray$1(ev.touches);  var targetIds = this.targetIds;
   when there is only one touch, the process can be simplified
  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {    targetIds[allTouches[0].identifier] = true;    return [allTouches, allTouches];  }
  var i = void 0;  var targetTouches = void 0;  var changedTouches = toArray$1(ev.changedTouches);  var changedTargetTouches = [];  var target = this.target;
   get target touches from touches
  targetTouches = allTouches.filter(function (touch) {    return hasParent(touch.target, target);  });
   collect touches  if (type === INPUT_START) {    i = 0;    while (i < targetTouches.length) {      targetIds[targetTouches[i].identifier] = true;      i++;    }  }
   filter changed touches to only contain touches that exist in the collected target ids  i = 0;  while (i < changedTouches.length) {    if (targetIds[changedTouches[i].identifier]) {      changedTargetTouches.push(changedTouches[i]);    }
     cleanup removed touches    if (type & (INPUT_END | INPUT_CANCEL)) {      delete targetIds[changedTouches[i].identifier];    }    i++;  }
  if (!changedTargetTouches.length) {    return;  }
  return [   merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'  uniqueArray(targetTouches.concat(changedTargetTouches), identifier, true), changedTargetTouches];}
var MOUSE_INPUT_MAP = {  mousedown: INPUT_START,  mousemove: INPUT_MOVE,  mouseup: INPUT_END};
var MOUSE_ELEMENT_EVENTS = mousedown;var MOUSE_WINDOW_EVENTS = mousemove mouseup;
 *  * Mouse events input *  *   */
var MouseInput = function (_Input) {  inherits(MouseInput, _Input);
  function MouseInput() {    classCallCheck(this, MouseInput);
    var _this = possibleConstructorReturn(this, (MouseInput.__proto__ || Object.getPrototypeOf(MouseInput)).apply(this, arguments));
    _this.evEl = MOUSE_ELEMENT_EVENTS;    _this.evWin = MOUSE_WINDOW_EVENTS;
    _this.pressed = false;  mousedown state    return _this;  }
     *    * handle mouse events   *      */

  createClass(MouseInput, [{    key: handler,    value: function handler(ev) {      var eventType = MOUSE_INPUT_MAP[ev.type];
       on start we want to have the left mouse button down      if (eventType & INPUT_START && ev.button === 0) {        this.pressed = true;      }
      if (eventType & INPUT_MOVE && ev.which !== 1) {        eventType = INPUT_END;      }
       mouse must be down      if (!this.pressed) {        return;      }
      if (eventType & INPUT_END) {        this.pressed = false;      }
      this.callback(this.manager, eventType, {        pointers: [ev],        changedPointers: [ev],        pointerType: INPUT_TYPE_MOUSE,        srcEvent: ev      });    }  }]);  return MouseInput;}(Input);
 *  * Combined touch and mouse input * * Touch has a higher priority then mouse, and while touching no mouse events are allowed. * This because touch devices also emit mouse events while doing a touch. * *  *   */
var DEDUP_TIMEOUT = 2500;var DEDUP_DISTANCE = 25;
var TouchMouseInput = function (_Input) {  inherits(TouchMouseInput, _Input);
  function TouchMouseInput() {    classCallCheck(this, TouchMouseInput);
    var _this = possibleConstructorReturn(this, (TouchMouseInput.__proto__ || Object.getPrototypeOf(TouchMouseInput)).apply(this, arguments));
    var handler = bindFn(_this.handler, _this);    _this.touch = new TouchInput(_this.manager, handler);    _this.mouse = new MouseInput(_this.manager, handler);
    _this.primaryTouch = null;    _this.lastTouches = [];    return _this;  }
     *    * handle mouse and touch events   *      *      *      */

  createClass(TouchMouseInput, [{    key: handler,    value: function handler(manager, inputEvent, inputData) {      var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;      var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;
      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {        return;      }
       when we're in a touch event, record touches to  de-dupe synthetic mouse event      if (isTouch) {        recordTouches.call(this, inputEvent, inputData);      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {        return;      }
      this.callback(manager, inputEvent, inputData);    }
         *      * remove the event listeners     */
  }, {    key: destroy,    value: function destroy() {      this.touch.destroy();      this.mouse.destroy();    }  }]);  return TouchMouseInput;}(Input);
function recordTouches(eventType, eventData) {  if (eventType & INPUT_START) {    this.primaryTouch = eventData.changedPointers[0].identifier;    setLastTouch.call(this, eventData);  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {    setLastTouch.call(this, eventData);  }}
function setLastTouch(eventData) {  var _this2 = this;
  var _eventData$changedPoi = slicedToArray(eventData.changedPointers, 1);
  var touch = _eventData$changedPoi[0];
  if (touch.identifier === this.primaryTouch) {    (function () {      var lastTouch = { x: touch.clientX, y: touch.clientY };      _this2.lastTouches.push(lastTouch);      var lts = _this2.lastTouches;      var removeLastTouch = function removeLastTouch() {        var i = lts.indexOf(lastTouch);        if (i > -1) {          lts.splice(i, 1);        }      };      setTimeout(removeLastTouch, DEDUP_TIMEOUT);    })();  }}
function isSyntheticEvent(eventData) {  var x = eventData.srcEvent.clientX;  var y = eventData.srcEvent.clientY;  for (var i = 0; i < this.lastTouches.length; i++) {    var t = this.lastTouches[i];    var dx = Math.abs(x - t.x);    var dy = Math.abs(y - t.y);    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {      return true;    }  }  return false;}
 *  * create new input type manager * called by the Manager constructor *    *   */function createInputInstance(manager) {  var Type = void 0;   let inputClass = manager.options.inputClass;  var inputClass = manager.options.inputClass;
  if (inputClass) {    Type = inputClass;  } else if (SUPPORT_POINTER_EVENTS) {    Type = PointerEventInput;  } else if (SUPPORT_ONLY_TOUCH) {    Type = TouchInput;  } else if (!SUPPORT_TOUCH) {    Type = MouseInput;  } else {    Type = TouchMouseInput;  }  return new Type(manager, inputHandler);}
var STOP = 1;var FORCED_STOP = 2;
 * Manager *    *    *  */
var Manager = function () {  function Manager(element, options) {    var _this = this;
    classCallCheck(this, Manager);
    this.options = assign$1({}, Hammer.defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};    this.session = {};    this.recognizers = [];    this.oldCssProps = {};
    this.element = element;    this.input = createInputInstance(this);    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {      var recognizer = _this.add(new item[0](item[1]));      item[2] && recognizer.recognizeWith(item[2]);      item[3] && recognizer.requireFailure(item[3]);    }, this);  }
     *    * set options   *      *     */

  createClass(Manager, [{    key: set,    value: function set(options) {      assign$1(this.options, options);
       Options that need a little more setup      if (options.touchAction) {        this.touchAction.update();      }      if (options.inputTarget) {         Clean up existing event listeners and reinitialize        this.input.destroy();        this.input.target = options.inputTarget;        this.input.init();      }      return this;    }
         *      * stop recognizing for this session.     * This session will be discarded, when a new [input]start event is fired.     * When forced, the recognizer cycle is stopped immediately.     *        */
  }, {    key: stop,    value: function stop(force) {      this.session.stopped = force ? FORCED_STOP : STOP;    }
         *      * run the recognizers!     * called by the inputHandler function on every movement of the pointers (touches)     * it walks through all the recognizers and tries to detect the gesture that is being made     *        */
  }, {    key: recognize,    value: function recognize(inputData) {      var session = this.session;
      if (session.stopped) {        return;      }
       run the touch-action polyfill      this.touchAction.preventDefaults(inputData);
      var recognizer = void 0;      var recognizers = this.recognizers;
       this holds the recognizer that is being recognized.       so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED       if no recognizer is detecting a thing, it is set to `null`
      var curRecognizer = session.curRecognizer;
       reset when the last recognizer is recognized       or when we're in a new session
      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {        curRecognizer = session.curRecognizer = null;      }
      var i = 0;      while (i < recognizers.length) {        recognizer = recognizers[i];
         find out if we are allowed try to recognize the input for this one.         1.   allow if the session is NOT forced stopped (see the .stop() method)         2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one              that is being recognized.         3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.              this can be setup with the `recognizeWith()` method on the recognizer.        if (session.stopped !== FORCED_STOP && (  1        !curRecognizer || recognizer === curRecognizer ||  2        recognizer.canRecognizeWith(curRecognizer))) {           3          recognizer.recognize(inputData);        } else {          recognizer.reset();        }
         if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the         current active recognizer. but only if we don't already have an active recognizer        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {          curRecognizer = session.curRecognizer = recognizer;        }        i++;      }    }
         *      * get a recognizer by its event name.     *        *       */
  }, {    key: get,    value: function get(recognizer) {      if (recognizer instanceof Recognizer) {        return recognizer;      }
      var recognizers = this.recognizers;
      for (var i = 0; i < recognizers.length; i++) {        if (recognizers[i].options.event === recognizer) {          return recognizers[i];        }      }      return null;    }
         *  add a recognizer to the manager     * existing recognizers with the same event name will be removed     *        *       */
  }, {    key: add,    value: function add(recognizer) {      if (invokeArrayArg(recognizer, add, this)) {        return this;      }
       remove existing      var existing = this.get(recognizer.options.event);      if (existing) {        this.remove(existing);      }
      this.recognizers.push(recognizer);      recognizer.manager = this;
      this.touchAction.update();      return recognizer;    }
         *      * remove a recognizer by name or instance     *        *       */
  }, {    key: remove,    value: function remove(recognizer) {      if (invokeArrayArg(recognizer, remove, this)) {        return this;      }
      recognizer = this.get(recognizer);
       let's make sure this recognizer exists      if (recognizer) {        var recognizers = this.recognizers;
        var index = inArray(recognizers, recognizer);
        if (index !== -1) {          recognizers.splice(index, 1);          this.touchAction.update();        }      }
      return this;    }
         *      * bind event     *        *        *   this     */
  }, {    key: on,    value: function on(events, handler) {      if (events === undefined) {        return;      }      if (handler === undefined) {        return;      }
      var handlers = this.handlers;
      each(splitStr(events), function (event) {        handlers[event] = handlers[event] || [];        handlers[event].push(handler);      });      return this;    }
         *  unbind event, leave emit blank to remove all handlers     *        *        *   this     */
  }, {    key: off,    value: function off(events, handler) {      if (events === undefined) {        return;      }
      var handlers = this.handlers;
      each(splitStr(events), function (event) {        if (!handler) {          delete handlers[event];        } else {          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);        }      });      return this;    }
         *  emit event to the listeners     *        *        */
  }, {    key: emit,    value: function emit(event, data) {       we also want to trigger dom events      if (this.options.domEvents) {        triggerDomEvent(event, data);      }
       no handlers, so skip it all      var handlers = this.handlers[event] && this.handlers[event].slice();      if (!handlers || !handlers.length) {        return;      }
      data.type = event;      data.preventDefault = function () {        data.srcEvent.preventDefault();      };
      var i = 0;      while (i < handlers.length) {        handlers[i](data);        i++;      }    }
         *      * destroy the manager and unbinds all events     * it doesn't unbind dom events, that is the user own responsibility     */
  }, {    key: destroy,    value: function destroy() {      this.element && toggleCssProps(this, false);
      this.handlers = {};      this.session = {};      this.input.destroy();      this.element = null;    }  }]);  return Manager;}();
function toggleCssProps(manager, add) {  var element = manager.element;
  if (!element.style) {    return;  }  var prop = void 0;  each(manager.options.cssProps, function (value, name) {    prop = prefixed(element.style, name);    if (add) {      manager.oldCssProps[prop] = element.style[prop];      element.style[prop] = value;    } else {      element.style[prop] = manager.oldCssProps[prop] || ;    }  });  if (!add) {    manager.oldCssProps = {};  }}
 *  * trigger dom event *    *    */function triggerDomEvent(event, data) {  var gestureEvent = document.createEvent(Event);  gestureEvent.initEvent(event, true, true);  gestureEvent.gesture = data;  data.target.dispatchEvent(gestureEvent);}
 *  * Simple way to create a manager with a default set of recognizers. *    *    *  */
var Hammer = function Hammer(element, options) {  classCallCheck(this, Hammer);
  options = options || {};  options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);  return new Manager(element, options);};
Hammer.VERSION = 2.0.8;
 *  * default settings *  */Hammer.defaults = {     *    * set if DOM events are being triggered.   * But this is slower and unused by simple implementations, so disabled by default.   *     *     */  domEvents: false,
     *    * The value for the touchAction property/fallback.   * When set to `compute` it will magically set the correct value based on the added recognizers.   *     *     */  touchAction: TOUCH_ACTION_COMPUTE,
     *    *     *     */  enable: true,
     *    * EXPERIMENTAL FEATURE -- can be removed/changed   * Change the parent input target element.   * If Null, then it is being set the to main element.   *     *     */  inputTarget: null,
     *    * force an input class   *     *     */  inputClass: null,
     *    * Default recognizer setup when calling `Hammer()`   * When creating a new Manager these will be skipped.   *     */  preset: [   RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]  [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, [rotate]], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, [swipe]], [TapRecognizer], [TapRecognizer, { event: doubletap, taps: 2 }, [tap]], [PressRecognizer]],
     *    * Some CSS properties can be used to improve the working of Hammer.   * Add them to this method and they will be set when creating a new Manager.   *    */  cssProps: {         *      * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.     *       *       */    userSelect: none,
         *      * Disable the Windows Phone grippers when pressing an element.     *       *       */    touchSelect: none,
         *      * Disables the default callout shown when you touch and hold a touch target.     * On iOS, when you touch and hold a touch target such as a link, Safari displays     * a callout containing information about the link. This property allows you to disable that callout.     *       *       */    touchCallout: none,
         *      * Specifies whether zooming is enabled. Used by IE10>     *       *       */    contentZooming: none,
         *      * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.     *       *       */    userDrag: none,
         *      * Overrides the highlight color shown when the user taps a link or a JavaScript     * clickable element in iOS. This property obeys the alpha value, if specified.     *       *       */    tapHighlightColor: rgba(0,0,0,0)  }};
var SINGLE_TOUCH_INPUT_MAP = {  touchstart: INPUT_START,  touchmove: INPUT_MOVE,  touchend: INPUT_END,  touchcancel: INPUT_CANCEL};
var SINGLE_TOUCH_TARGET_EVENTS = touchstart;var SINGLE_TOUCH_WINDOW_EVENTS = touchstart touchmove touchend touchcancel;
 *  * Touch events input *  *   */
var SingleTouchInput = function (_Input) {  inherits(SingleTouchInput, _Input);
  function SingleTouchInput() {    classCallCheck(this, SingleTouchInput);
    var _this = possibleConstructorReturn(this, (SingleTouchInput.__proto__ || Object.getPrototypeOf(SingleTouchInput)).apply(this, arguments));
    _this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;    _this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;    _this.started = false;
    Input.apply(_this, arguments);    return _this;  }
  createClass(SingleTouchInput, [{    key: handler,    value: function handler(ev) {      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
       should we handle the touch events?      if (type === INPUT_START) {        this.started = true;      }
      if (!this.started) {        return;      }
      var touches = normalizeSingleTouches.call(this, ev, type);
       when done, reset the started state      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {        this.started = false;      }
      this.callback(this.manager, type, {        pointers: touches[0],        changedPointers: touches[1],        pointerType: INPUT_TYPE_TOUCH,        srcEvent: ev      });    }  }]);  return SingleTouchInput;}(Input);
function normalizeSingleTouches(ev, type) {  var all = toArray$1(ev.touches);  var changed = toArray$1(ev.changedTouches);
  if (type & (INPUT_END | INPUT_CANCEL)) {    all = uniqueArray(all.concat(changed), identifier, true);  }
  return [all, changed];}
 *  * wrap a method with a deprecation warning and stack trace *    *    *    *   A new function wrapping the supplied method. */function deprecate(method, name, message) {  var deprecationMessage = DEPRECATED METHOD:  + name +  + message +  AT ;  return function () {    var e = new Error(get-stack-trace);    var stack = e && e.stack ? e.stack.replace(gm, ).replace(atgm, ).replace(Object<anonymous>gm, {anonymous}()@) : Unknown Stack Trace;
    var log = window.console && (window.console.warn || window.console.log);    if (log) {      log.call(window.console, deprecationMessage, stack);    }    return method.apply(this, arguments);  };}
 *  * extend object. * means that properties in dest will be overwritten by the ones in src. *    *    *    *   dest */var extend = deprecate(function (dest, src, merge) {  var keys = Object.keys(src);  var i = 0;  while (i < keys.length) {    if (!merge || merge && dest[keys[i]] === undefined) {      dest[keys[i]] = src[keys[i]];    }    i++;  }  return dest;}, extend, Use `assign`.);
 *  * merge the values from src in the dest. * means that properties that exist in dest will not be overwritten by src *    *    *   dest */var merge = deprecate(function (dest, src) {  return extend(dest, src, true);}, merge, Use `assign`.);
 *  * simple class inheritance *    *    *    */function inherit(child, base, properties) {  var baseP = base.prototype;  var childP = void 0;
  childP = child.prototype = Object.create(baseP);  childP.constructor = child;  childP._super = baseP;
  if (properties) {    assign$1(childP, properties);  }}
 this prevents errors when Hammer is loaded in the presence of an AMD  style loader but by script tag, not by the loader.
assign$1(Hammer, {  INPUT_START: INPUT_START,  INPUT_MOVE: INPUT_MOVE,  INPUT_END: INPUT_END,  INPUT_CANCEL: INPUT_CANCEL,
  STATE_POSSIBLE: STATE_POSSIBLE,  STATE_BEGAN: STATE_BEGAN,  STATE_CHANGED: STATE_CHANGED,  STATE_ENDED: STATE_ENDED,  STATE_RECOGNIZED: STATE_RECOGNIZED,  STATE_CANCELLED: STATE_CANCELLED,  STATE_FAILED: STATE_FAILED,
  DIRECTION_NONE: DIRECTION_NONE,  DIRECTION_LEFT: DIRECTION_LEFT,  DIRECTION_RIGHT: DIRECTION_RIGHT,  DIRECTION_UP: DIRECTION_UP,  DIRECTION_DOWN: DIRECTION_DOWN,  DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,  DIRECTION_VERTICAL: DIRECTION_VERTICAL,  DIRECTION_ALL: DIRECTION_ALL,
  Manager: Manager,  Input: Input,  TouchAction: TouchAction,
  TouchInput: TouchInput,  MouseInput: MouseInput,  PointerEventInput: PointerEventInput,  TouchMouseInput: TouchMouseInput,  SingleTouchInput: SingleTouchInput,
  Recognizer: Recognizer,  AttrRecognizer: AttrRecognizer,  Tap: TapRecognizer,  Pan: PanRecognizer,  Swipe: SwipeRecognizer,  Pinch: PinchRecognizer,  Rotate: RotateRecognizer,  Press: PressRecognizer,
  on: addEventListeners,  off: removeEventListeners,  each: each,  merge: merge,  extend: extend,  assign: assign$1,  inherit: inherit,  bindFn: bindFn,  prefixed: prefixed,  toArray: toArray$1,  inArray: inArray,  uniqueArray: uniqueArray,  splitStr: splitStr,  boolOrFn: boolOrFn,  hasParent: hasParent,  addEventListeners: addEventListeners,  removeEventListeners: removeEventListeners});
if (typeof define === function && define.amd) {  define(function () {    return Hammer;  });} else if (typeof module !== undefined && module.exports) {  module.exports = Hammer;} else {  window[exportName] = Hammer;}})(window, document, Hammer);"
"var changelog = require( changelogplease );var gittags = require( git-tags ).get( function( error, tags ) {	if ( error ) {		throw error	}	console.log( tags[ 2 ] + .. + tags[ 0 ] );	var exclude = [ Merge, Whitespace, Fixup, Cleanup, Formatting, Ignore ];	changelog( {		ticketUrl: https://github.com/hammerjs/hammer.js/issues/{id},		commitUrl: https://github.com/hammerjs/hammerjs/commit/{id},		sort: false,		repo: ./,		committish: tags[ 2 ] + .. + tags[ 0 ]	}, function( error, log ) {		if ( error ) {			throw error;		}		log = parseLog( log );		console.log( log );	} );	function parseLog( log ) {		var lines = log.split(  );		var newLog = [];		var log = [];		var currentComponent;
				lines.shift();		lines.forEach( function( line ) {			var newLine = parseLine( line );			if ( newLine ) {				log.push( line );			}		} );		var log = log.join(  );		return log.replace( g, - ).replace( __TICKETREF__,g,  );	}	function parseLine( line ) {		var parts = getParts( line );
		if ( exclude.indexOf( parts.component ) > -1 ) {			return false;		}		return parts;	}	function getParts( line ) {		var parts = line.split( : );		var component = ;		var message;		var commits = line.match( () )
		if ( parts.length > 1 && parts[ 0 ].length <= 20 ) {			component = parts[ 0 ];			parts.shift();			message = parts.join( : );		} else {			parts = line.split(   );			component = parts[ 1 ];			parts.shift();			message = parts.join(   );		}
		if ( component ) {			component = component.replace(  ,,  );		}		return {			component: component,			message: message		};	}} );"
"#!/usr/bin/env node * Distributed under the BSD license: * * Copyright (c) 2010, Ajax.org B.V. * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * Neither the name of Ajax.org B.V. nor the *       names of its contributors may be used to endorse or promote products *       derived from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" AND * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * ***** END LICENSE BLOCK ***** */
var fs = require(fs);var path = require(path);var copy = require(architect-build/copy);var build = require(architect-build/build);
var ACE_HOME = __dirname;var BUILD_DIR = ACE_HOME + /build;var CACHE = {};
function main(args) {    if (args.indexOf(updateModes) !== -1) {        return updateModes();    }    var type = minimal;    args = args.map(function(x) {        if (x[0] == - && x[1] != -)            return - + x;        return x;    }).filter(Boolean);
    if (args[2] && (args[2][0] != - || args[2].indexOf(h) != -1))        type = args[2];
    var i = args.indexOf(--target);    if (i != -1 && args[i+1])        BUILD_DIR = args[i+1];
    if (args.indexOf(--h) == -1) {        if (type == minimal) {            buildAce({                compress: args.indexOf(--m) != -1,                noconflict: args.indexOf(--nc) != -1,                shrinkwrap: args.indexOf(--s) != -1            });        } else if (type == normal) {            ace();        } else if (type == demo) {            demo();        } else if (type == full) {            ace();            demo();        } else if (type == highlighter) {             TODO        }    }}
function showHelp(type) {    console.log(--- Ace Dryice Build Tool ---);    console.log();    console.log(Options:);    console.log(  minimal      Places necessary Ace files out in build dir; uses configuration flags below [default]);    console.log(  normal       Runs four Ace builds--minimal, minimal-noconflict, minimal-min, and minimal-noconflict-min);    console.log(  demo         Runs demo build of Ace);    console.log(  full         all of above);    console.log(  highlighter  );    console.log(args:);    console.log(  --target ./path   path to build folder);    console.log(flags:);    console.log(  --h                print this help);    console.log(  --m                minify);    console.log(  --nc               namespace require);    console.log(  --s                shrinkwrap (combines all output files into one));    console.log();    if (type)        console.log(  output for  + type +  generated in  + BUILD_DIR);}
function ace() {    console.log(# ace License | Readme | Changelog ---------);
    copy.file(ACE_HOME + /build_support/editor.html,  BUILD_DIR + /editor.html);    copy.file(ACE_HOME + /LICENSE, BUILD_DIR + /LICENSE);    copy.file(ACE_HOME + /ChangeLog.txt, BUILD_DIR + /ChangeLog.txt);        console.log(# ace ---------);    for (var i = 0; i < 4; i++)        buildAce({compress: i & 2, noconflict: i & 1, check: true});}
function demo() {    console.log(# kitchen sink ---------);
    var version = , ref = ;    try {        version = JSON.parse(fs.readFileSync(ACE_HOME + /package.json)).version;        ref = fs.readFileSync(ACE_HOME + /.git-ref).toString();    } catch(e) {}
    function changeComments(data) {        return (data            .replace(doc/site/images/ace-logo.png, demo/kitchen-sink/ace-logo.png)            .replace(<!DEVELDEVEL>g, )            .replace(PACKAGE><!PACKAGEg, )            .replace(DEVELDEVELg, )            .replace(PACKAGEPACKAGEg, )            .replace(%version%, version)            .replace(%commit%, ref)        );    }        copy(ACE_HOME +/demo/kitchen-sink/docs/, BUILD_DIR + /demo/kitchen-sink/docs/);        copy.file(ACE_HOME + /demo/kitchen-sink/logo.png, BUILD_DIR + /demo/kitchen-sink/logo.png);    copy.file(ACE_HOME + /demo/kitchen-sink/styles.css, BUILD_DIR + /demo/kitchen-sink/styles.css);    copy.file(ACE_HOME + /kitchen-sink.html, BUILD_DIR + /kitchen-sink.html, changeComments);
    buildSubmodule({}, {        require: [kitchen-sink/demo],        projectType: demo    }, BUILD_DIR + /demo/kitchen-sink/demo);
    copy(ACE_HOME + /demo/, BUILD_DIR + /demo/, {        shallow: true,        exclude: requirejs,        include: (jshtml),        replace: function(source) {            if (!<.test(source))                return source;            var removeRequireJS;            source = source.replace(<script src=""kitchen-sinkrequirejs""require(), function(e, m) {                removeRequireJS = true;                var scripts = m.split(,);                var result = [];                function comment(str) {result.push(<!--  + str +  -->)}                function script(str) {result.push(<script src=""../src/ + str + .js""></script>)}                scripts.forEach(function(s) {                    s = s.replace(""g, );                    if (s == ace/ace) {                        comment(load ace);                        script(ace);                    } else {                        var extName = s.match()[0];                        comment(load ace  + extName +  extension);                        script(ext- + extName);                    }                });                result.push(<script>);                return result.join();            });            if (removeRequireJS)                source = source.replace(;(<script>), $1);            source = source.replace(""buildg, function(e) {                console.log(e); return ""../;            });            return source;        }    });}
function jsFileList(path, filter) {    path = ACE_HOME + / + path;    if (!filter)        filter = _test;
    return fs.readdirSync(path).map(function(x) {        if (x.slice(-3) == .js && !filter.test(x) && !BASE(_)dummy(_).test(x))            return x.slice(0, -3);    }).filter(Boolean);}
function workers(path) {    return jsFileList(path).map(function(x) {        if (x.slice(-7) == _worker)            return x.slice(0, -7);    }).filter(function(x) { return !!x; });}
function modeList() {    return jsFileList(lib/ace/mode, _highlight_rules_test_workerxml_util_outdentbehaviourcompletions);}
function buildAceModule(opts, callback) {     calling buildAceModuleInternal many times in parallel is slow, so we use queue    if (!buildAceModule.queue) {        buildAceModule.queue = [];        buildAceModule.dequeue = function() {            if (buildAceModule.running) return;            var call = buildAceModule.queue.shift();            buildAceModule.running = call;            if (call)                buildAceModuleInternal.apply(null, call);        };    }        buildAceModule.queue.push([opts, function(err, result) {        callback && callback(err, result);        buildAceModule.running = null;        buildAceModule.dequeue();    }]);
    if (!buildAceModule.running) {        buildAceModule.dequeue();    } else {        process.nextTick(buildAceModule.dequeue);    }}
function buildAceModuleInternal(opts, callback) {    var cache = opts.cache == undefined ? CACHE : opts.cache;    var key = opts.require + | + opts.projectType;    if (cache && cache.configs && cache.configs[key])        return write(null, cache.configs[key]);            var pathConfig = {        paths: {            ace: ACE_HOME + /lib/ace,            kitchen-sink: ACE_HOME + /demo/kitchen-sink,            build_support:  ACE_HOME + /build_support        },        root: ACE_HOME    };            function write(err, result) {        if (cache && key && !(cache.configs && cache.configs[key])) {            cache.configs = cache.configs || Object.create(null);            cache.configs[key] = result;            result.sources = result.sources.map(function(pkg) {                return {deps: pkg.deps};            });        }                 if (!opts.outputFile)            return callback(err, result);                var code = result.code;        if (opts.compress) {            if (!result.codeMin)                result.codeMin = compress(result.code);            code = result.codeMin;        }                    var targetDir = getTargetDir(opts);                var to = (:).test(opts.outputFile)            ? opts.outputFile            : path.join(opts.outputFolder || targetDir, opts.outputFile);            var filters = [];
        var ns = opts.ns || ace;        if (opts.filters)            filters = filters.concat(opts.filters);            if (opts.noconflict)            filters.push(namespace(ns));        var projectType = opts.projectType;        if (projectType == main || projectType == ext) {            filters.push(exportAce(ns, opts.require[0],                opts.noconflict ? ns : , projectType == ext));        }                filters.push(normalizeLineEndings);                filters.forEach(function(f) { code = f(code); });                build.writeToFile({code: code}, {            outputFolder: path.dirname(to),            outputFile: path.basename(to)        }, function() {});                callback && callback(err, result);    }        build(opts.require, {        cache: cache,        quiet: opts.quiet,        pathConfig: pathConfig,        additional: opts.additional,        enableBrowser: true,        keepDepArrays: all,        noArchitect: true,        compress: false,        ignore: opts.ignore || [],        withRequire: false,        basepath: ACE_HOME,        transforms: [normalizeLineEndings],        afterRead: [optimizeTextModules]    }, write);}
function buildCore(options, extra, callback) {    options = extend(extra, options);    options.additional = [{        id: build_support/mini_require,         order: -1000,        literal: true    }];    options.require =[ace/ace];    options.projectType = main;    options.ns = ace;    buildAceModule(options, callback);}
function buildSubmodule(options, extra, file, callback) {    options = extend(extra, options);    getLoadedFileList(options, function(coreFiles) {        options.outputFile = file + .js;        options.ignore = options.ignore || coreFiles;        options.quiet = true;        buildAceModule(options, callback);    });}
function buildAce(options, callback) {    var snippetFiles = jsFileList(lib/ace/snippets);    var modeNames = modeList();
    buildCore(options, {outputFile: ace.js}, addCb());     modes    modeNames.forEach(function(name) {        buildSubmodule(options, {            projectType: mode,            require: [ace/mode/ + name]        }, mode- + name, addCb());    });     snippets    modeNames.forEach(function(name) {        if (snippetFiles.indexOf(name + .js) == -1)            addSnippetFile(name);                buildSubmodule(options, {            require: [ace/snippets/ + name]        }, snippets/ + name, addCb());    });     themes    jsFileList(lib/ace/theme).forEach(function(name) {        buildSubmodule(options, {            projectType: theme,            require: [ace/theme/ + name]        }, theme- +  name, addCb());    });     keybindings    [vim, emacs].forEach(function(name) {        buildSubmodule(options, {            projectType: keybinding,            require: [ace/keyboard/ + name ]        }, keybinding- + name, addCb());    });     extensions    jsFileList(lib/ace/ext).forEach(function(name) {        buildSubmodule(options, {            projectType: ext,            require: [ace/ext/ + name]        }, ext- + name, addCb());    });     workers    workers(lib/ace/mode).forEach(function(name) {        buildSubmodule(options, {            projectType: worker,            require: [ace/mode/ + name + _worker],            ignore: [],            additional: [{                id: ace/worker/worker,                transforms: [],                order: -1000            }]        }, worker- + name, addCb());    });         function addCb() {        addCb.count = (addCb.count || 0) + 1;         return done    }    function done() {        if (--addCb.count > 0)            return;        if (options.check)            sanityCheck(options, callback);        if (callback)             return callback();        console.log(Finished building  + getTargetDir(options))    }}
function getLoadedFileList(options, callback, result) {    if (!result) {        return buildCore({}, {}, function(e, result) {            getLoadedFileList(options, callback, result);        });    }    var deps = Object.create(null);    result.sources.forEach(function(pkg) {        pkg.deps && pkg.deps.forEach(function(p) {            if (!deps[p]) deps[p] = 1;        });    });    delete deps[ace/theme/textmate];    deps[ace/ace] = 1;    callback(Object.keys(deps));}
function normalizeLineEndings(module) {    if (typeof module == string)         module = {source: module};    return module.source = module.source.replace(g, );}
function optimizeTextModules(sources) {    var textModules = {};    return sources.filter(function(pkg) {        if (!pkg.id) {            return true;        }        else if (pkg.id.indexOf(text!) > -1) {            detectTextModules(pkg);            return false;        }        else {            pkg.source = rewriteTextImports(pkg.source, pkg.deps);            return true;        }    }).map(function(pkg) {        if (pkg && pkg.deps) {            pkg.deps = pkg.deps && pkg.deps.filter(function(p) {                return p.indexOf(text!) == -1;            });        }        return pkg;    });        function rewriteTextImports(text, deps) {        return text.replace( require(?:ace)requirejstext!()g, function(_, call) {            if (call) {                var dep;                deps.some(function(d) {                    if (d.split(/).pop() == call.split(/).pop()) {                        dep = d;                        return true;                    }                });                    call = textModules[dep];                if (call)                    return   + call;            }        });    }    function detectTextModules(pkg) {        var input = pkg.source.replace(g, ).replace(""g, "");        if (css.test(pkg.id)) {             remove unnecessary whitespace from css            input = input.replace(g, );            input = "" + input.replace(g, ) + "";        } else {             but don't break other files!            input = "" + input.replace(g, n) + "";        }        textModules[pkg.id] = input;    }}
function namespace(ns) {    return function(text) {        text = text            .toString()            .replace(ACE_NAMESPACE="""", ACE_NAMESPACE = "" + ns +"")            .replace(defineg, function(def, index, source) {                if (().test(source.slice(0, index)))                    return ns + . + def;                return def;            });
        return text;    };}
function exportAce(ns, modules, requireBase, extModules) {    requireBase = requireBase || window;    return function(text) {                var template = function() {            (function() {                REQUIRE_NS.require(MODULES, function(a) {                    if (a) {                        a.config.init(true);                        a.define = REQUIRE_NS.define;                    }                    if (!window.NS)                        window.NS = a;                    for (var key in a) if (a.hasOwnProperty(key))                        window.NS[key] = a[key];                });            })();        };                if (extModules) {            template = function() {                (function() {                    REQUIRE_NS.require(MODULES, function() {});                })();            };        }                text = text.replace(function initpackaged {, init(true);$&);                if (typeof modules == string)            modules = [modules];                    return (text.replace(;, ) + ; + template            .toString()            .replace(MODULESg, JSON.stringify(modules))            .replace(REQUIRE_NSg, requireBase)            .replace(NSg, ns)            .slice(13, -1)        );    };}
function updateModes() {    modeList().forEach(function(m) {        var filepath = __dirname + /lib/ace/mode/ + m + .js;        var source = fs.readFileSync(filepath, utf8);        if (!thisid="".test(source))            source = source.replace(()(callModeprototype), $1    this.$id = """";$1$2);                source = source.replace((thisid=)"""",  $1""ace/mode/ + m + "");        fs.writeFileSync(filepath, source, utf8);    });}
function generateThemesModule(themes) {    var themelist = [        define(function(require, exports, module) {,        module.exports.themes =  + JSON.stringify(themes, null,     ),        ;});    ].join();    fs.writeFileSync(__dirname + /lib/ace/ext/themelist_utils/themes.js, themelist, utf8);}
function addSnippetFile(modeName) {    var snippetFilePath = ACE_HOME + /lib/ace/snippets/ + modeName;    if (!fs.existsSync(snippetFilePath + .js)) {        copy.file(ACE_HOME + /tool/templates/snippets.js, snippetFilePath + .js, function(t) {            return t.replace(%modeName%g, modeName);        });    }    if (!fs.existsSync(snippetFilePath + .snippets)) {        fs.writeFileSync(snippetFilePath + .snippets, );    }}
function compress(text) {    var ujs = require(dryice).copy.filter.uglifyjs;    ujs.options.mangle_toplevel = {except: [ACE_NAMESPACE, requirejs]};    ujs.options.beautify = {ascii_only: true, inline_script: true}    return ujs(text);}
function extend(base, extra) {    Object.keys(extra).forEach(function(k) {        base[k] = extra[k];    });    return base;}
function getTargetDir(opts) {    var targetDir = BUILD_DIR + /src;    if (opts.compress)        targetDir += -min;    if (opts.noconflict)        targetDir += -noconflict;    return targetDir;}
function sanityCheck(opts, callback) {    var targetDir = getTargetDir(opts);    require(child_process).execFile(process.execPath, [-e, ( + function() {        window = global;        require(./ace);        if (typeof ace.edit != function)            process.exit(1);        require(fs).readdirSync(.).forEach(function(p) {            if (!acejs.test(p) && js.test(p))                require(./ + p);        });        process.exit(0);    } + )()], {        cwd: targetDir    }, function(err, stdout) {        if (callback) return callback(err, stdout);        if (err)            throw err;    });}
if (!module.parent)    main(process.argv);else    exports.buildAce = buildAce;"
"module.exports = {  extends: [plugin:import/errors],  plugins: [import],  env: {    es6: true,    node: true  },  parserOptions: {    ecmaVersion: 6,    sourceType: module,    ecmaFeatures: {      impliedStrict: true,      objectLiteralDuplicateProperties: false    }  },  rules: {    array-bracket-spacing: [error, never],
    camelcase: [error, {      properties: never    }],
    comma-dangle: [error, never],
    curly: [error, all],
    eol-last: [error],
    indent: [error, 2, {      SwitchCase: 1    }],
    keyword-spacing: [error],
    max-len: [error, {      code: 180,      ignoreComments: true,      ignoreRegExpLiterals: true    }],
    no-else-return: [error],
    no-mixed-spaces-and-tabs: [error],
    no-multiple-empty-lines: [error],
    no-spaced-func: [error],
    no-trailing-spaces: [error],
    no-undef: [error],
    no-unexpected-multiline: [error],
    no-unused-vars: [error, {      args: none,      vars: all    }],
    quotes: [error, single, {      allowTemplateLiterals: true,      avoidEscape: true    }],
    semi: [error, never],
    space-before-blocks: [error, always],
    space-before-function-paren: [error, never],
    space-in-parens: [error, never],
    space-unary-ops: [error, {      nonwords: false,      overrides: {}    }],
     'valid-jsdoc': ['error']
     ECMAScript 6 rules
    arrow-body-style: [error, as-needed, {      requireReturnForObjectLiteral: false    }],
    arrow-parens: [error, always],
    arrow-spacing: [error, {      after: true,      before: true    }],
    no-class-assign: [error],
    no-const-assign: [error],
    no-dupe-class-members: [error],
    no-duplicate-imports: [error],
    no-new-symbol: [error],
    no-useless-rename: [error],
    no-var: [error],
    object-shorthand: [error, always, {      avoidQuotes: true,      ignoreConstructors: false    }],
    prefer-arrow-callback: [error, {      allowNamedFunctions: false,      allowUnboundThis: true    }],
    prefer-const: [error],
    prefer-rest-params: [error],
    prefer-template: [error],
    template-curly-spacing: [error, never]  }};"
" * This method is like `find` except that it returns the key of the first * element `predicate` returns truthy for instead of the element itself. * *  1.1.0 * @category Object *    The object to inspect. *    The function invoked per iteration. *   Returns the key of the matched element, *  else `undefined`. *   findIndex, findLast, findLastIndex, findLastKey *  * *  *    *    *    *  * *  *  */function findKey(object, predicate) {  let result  if (object == null) {    return result  }  Object.keys(object).some((key) => {    const value = object[key]    if (predicate(value, key, object)) {      result = value      return true    }  })  return result}
export default findKey"
"import findIndex from ./findIndex.jsimport isArrayLike from ./isArrayLikeimport keys from ./keys
 * Iterates over elements of `collection`, returning the first element * `predicate` returns truthy for. The predicate is invoked with three * arguments: (value, index|key, collection). * *  0.1.0 * @category Collection *    The collection to inspect. *    The function invoked per iteration. *    The index to search from. *   Returns the matched element, else `undefined`. *   findKey, findLast, findLastIndex, findLastKey *  * *  *    *    *    *  * *  *  */function find(collection, predicate, fromIndex) {  let iteratee  const iterable = Object(collection)
  if (!isArrayLike(collection)) {    collection = keys(collection)    iteratee = (key) => predicate(iterable[key], key, iterable)  }  const index = findIndex(collection, predicate, fromIndex)  return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined}
export default find"
"import unzipWith from ./unzipWith.js
 * This method is like `zip` except that it accepts `iteratee` to specify * how grouped values should be combined. The iteratee is invoked with the * elements of each group: (...group). * *  3.8.0 * @category Array *    The arrays to process. *    The function to combine *  grouped values. *   Returns the new array of grouped elements. *   unzipWith, zip, zipObject, zipObjectDeep, zipWith *  * *  *  */function zipWith(...arrays) {  const length = arrays.length  let iteratee = length > 1 ? arrays[length - 1] : undefined  iteratee = typeof iteratee == function ? (arrays.pop(), iteratee) : undefined  return unzipWith(arrays, iteratee)}
export default zipWith"
" * Iterates over properties of `object`, returning an array of all elements * `predicate` returns truthy for. The predicate is invoked with three * arguments: (value, key, object). * *  5.0.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   Returns the new filtered array. *   pullAll, pullAllBy, pullAllWith, pullAt, remove, reject *  * *  * *  *  */function filterObject(object, predicate) {  object = Object(object)  const result = []
  Object.keys(object).forEach((key) => {    const value = object[key]    if (predicate(value, key, object)) {      result.push(value)    }  })  return result}
export default filterObject"
"import baseSet from ./.internal/baseSet.jsimport baseZipObject from ./.internal/baseZipObject.js
 * This method is like `zipObject` except that it supports property paths. * *  4.1.0 * @category Array *   ] The property identifiers. *   ] The property values. *   Returns the new object. *   unzipWith, zip, zipObject, zipWith *  * *  *  */function zipObjectDeep(props, values) {  return baseZipObject(props || [], values || [], baseSet)}
export default zipObjectDeep"
" package metadata file for Meteor.js
Package.describe({  name: materialize:materialize,   http://atmospherejs.com/materialize/materialize  summary: Materialize (official): A modern responsive front-end framework based on Material Design,  version: 0.98.2,  git: https://github.com/Dogfalo/materialize.git});

Package.onUse(function (api) {  api.versionsFrom(METEOR@1.0);
  api.use(fourseven:scss@3.10.0);  api.use(jquery, client);  api.imply(jquery, client);
  var assets = [    fonts/roboto/Roboto-Bold.woff,    fonts/roboto/Roboto-Bold.woff2,    fonts/roboto/Roboto-Light.woff,    fonts/roboto/Roboto-Light.woff2,    fonts/roboto/Roboto-Medium.woff,    fonts/roboto/Roboto-Medium.woff2,    fonts/roboto/Roboto-Regular.woff,    fonts/roboto/Roboto-Regular.woff2,    fonts/roboto/Roboto-Thin.woff,    fonts/roboto/Roboto-Thin.woff2,  ];
  addAssets(api, assets);
  api.addFiles([    dist/js/materialize.js  ], client);
  var scssFiles = [    sass/components/date_picker/_default.date.scss,    sass/components/date_picker/_default.scss,    sass/components/date_picker/_default.time.scss,    sass/components/forms/_checkboxes.scss,    sass/components/forms/_file-input.scss,    sass/components/forms/_forms.scss,    sass/components/forms/_input-fields.scss,    sass/components/forms/_radio-buttons.scss,    sass/components/forms/_range.scss,    sass/components/forms/_select.scss,    sass/components/forms/_switches.scss,    sass/components/_badges.scss,    sass/components/_buttons.scss,    sass/components/_cards.scss,    sass/components/_carousel.scss,    sass/components/_chips.scss,    sass/components/_collapsible.scss,    sass/components/_color.scss,    sass/components/_dropdown.scss,    sass/components/_global.scss,    sass/components/_grid.scss,    sass/components/_icons-material-design.scss,    sass/components/_materialbox.scss,    sass/components/_mixins.scss,    sass/components/_modal.scss,    sass/components/_navbar.scss,    sass/components/_normalize.scss,    sass/components/_prefixer.scss,    sass/components/_preloader.scss,    sass/components/_pulse.scss,    sass/components/_roboto.scss,    sass/components/_sideNav.scss,    sass/components/_slider.scss,    sass/components/_table_of_contents.scss,    sass/components/_tabs.scss,    sass/components/_tapTarget.scss,    sass/components/_toast.scss,    sass/components/_tooltip.scss,    sass/components/_transitions.scss,    sass/components/_typography.scss,    sass/components/_variables.scss,    sass/components/_waves.scss,    sass/materialize.scss  ];
  api.addFiles(scssFiles, client);

  api.export(Materialize, client);});

function addAssets(api, assets){  if(api.addAssets){    api.addAssets(assets, client);  } else {    api.addFiles(assets, client, {isAsset: true});  }}"
invalid javascript
"module.exports = {	root: true,	plugins: [node],	extends: [eslint:recommended, plugin:node/recommended],	env: {		node: true,		es6: true,	},	parserOptions: { ecmaVersion: 2017 },	rules: {		quotes: [error, double],		no-undef: error,		no-extra-semi: error,		semi: error,		no-template-curly-in-string: error,		no-caller: error,		yoda: error,		eqeqeq: error,		global-require: off,		brace-style: error,		eol-last: error,		indent: [error, tab, { SwitchCase: 1 }],		no-extra-bind: warn,		no-empty: off,		no-multiple-empty-lines: error,		no-multi-spaces: error,		no-process-exit: warn,		space-in-parens: error,		no-trailing-spaces: error,		no-use-before-define: off,		no-unused-vars: [error, { args: none }],		key-spacing: error,		space-infix-ops: error,		no-unsafe-negation: error,		no-loop-func: warn,		space-before-function-paren: [error, never],		space-before-blocks: error,		object-curly-spacing: [error, always],		keyword-spacing: [error, {			after: false,			overrides: {				const: { after: true },				try: { after: true },				else: { after: true },				throw: { after: true },				case: { after: true },				return: { after: true },				finally: { after: true },				do: { after: true }			}		}],		no-console: off,		valid-jsdoc: error,		node/no-unsupported-features: [error, { version: 4 }],		node/no-deprecated-api: error,		node/no-missing-import: error,		node/no-missing-require: [			error,			{				allowModules: [					webpack				]			}		],		node/no-unpublished-bin: error,		node/no-unpublished-require: error,		node/process-exit-as-throw: error	}};"
"module.exports = function( config ) {  config.set( {
     Base path, that will be used to resolve files and exclude    basePath: ,
     Frameworks to use    frameworks: [ qunit ],
     List of files / patterns to load in the browser    files: [      test/bootstrap.js,      js/impress.js,      test/core_tests.js    ],
     List of files to exclude    exclude: [],
     Test results reporter to use     possible values: 'dots', 'progress', 'junit', 'growl', 'coverage'    reporters: [ progress ],
     Web server port    port: 9876,
     Enable / disable colors in the output (reporters and logs)    colors: true,
     Level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR ||     config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_DEBUG,
     Enable / disable watching file and executing tests whenever any file changes    autoWatch: true,
     Start these browsers, currently available:     - Chrome     - ChromeCanary     - Firefox     - Opera (has to be installed with `npm install karma-opera-launcher`)     - Safari (only Mac; has to be installed with `npm install karma-safari-launcher`)     - PhantomJS     - IE (only Windows; has to be installed with `npm install karma-ie-launcher`)    browsers: [ Chrome ],
     If browser does not capture in given timeout [ms], kill it    captureTimeout: 60000,
     Continuous Integration mode     if true, it capture browsers, run tests and exit    singleRun: false  } );};"
" Karma configurationmodule.exports = function(config) {  config.set({
     base path, that will be used to resolve files and exclude    basePath: ,
     frameworks to use    frameworks: [      jasmine    ],
     list of files / patterns to load in the browser    files: [       require jquery      server/files/javascript/library/jquery.js,       read css from compiled css      docs/build/uncompressed/**/*.css,       read js from src js      src/definitions/**/*.js,       require helpers      test/helpers/*.js,       require fixtures      {        pattern  : test/fixtures/*.html,        included : false,        served   : true      },       require spec      test/modules/module.spec.js,       require tests      test/modules/*.js    ],
     list of files to exclude    exclude: [      ,      karma.conf.js    ],
    preprocessors: {      : [],      src/definitions/**/*.js: coverage    },
     test results reporter to use     possible values: 'dots', 'progress', 'junit', 'growl', 'coverage'    reporters: [spec, coverage],
    coverageReporter: {      type: lcov    },
     web server port    port: 9999,
     enable / disable colors in the output (reporters and logs)    colors: true,
     level of logging     possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG    logLevel: config.LOG_INFO,
     enable / disable watching file and executing tests whenever any file changes    autoWatch: true,
     Start these browsers, currently available:     - Chrome     - ChromeCanary     - Firefox     - Opera     - Safari (only Mac)     - PhantomJS     - IE (only Windows)    browsers: [PhantomJS],

     If browser does not capture in given timeout [ms], kill it    captureTimeout: 60000,
     Continuous Integration mode     if true, it capture browsers, run tests and exit    singleRun: false  });};"
"import fs from fs;import path from path;
import gulp from gulp;
 Load all gulp plugins automatically and attach them to the `plugins` objectimport plugins from gulp-load-plugins;
 Temporary solution until gulp 4 https://github.com/gulpjs/gulp/issues/355import runSequence from run-sequence;
import archiver from archiver;import glob from glob;import del from del;import sri from node-sri
import pkg from ./package.json;
const dirs = pkg[h5bp-configs].directories;
 --------------------------------------------------------------------- | Helper tasks                                                      | ---------------------------------------------------------------------
gulp.task(archive:create_archive_dir, () => {    fs.mkdirSync(path.resolve(dirs.archive), 0755);});
gulp.task(archive:zip, (done) => {
    const archiveName = path.resolve(dirs.archive, _v.zip);    const zip = archiver(zip);    const files = glob.sync(, {        cwd: dirs.dist,        dot: true  include hidden files    });    const output = fs.createWriteStream(archiveName);
    zip.on(error, (error) => {        done();        throw error;    });
    output.on(close, done);
    files.forEach( (file) => {
        const filePath = path.resolve(dirs.dist, file);
         `zip.bulk` does not maintain the file         permissions, so we need to add files individually        zip.append(fs.createReadStream(filePath), {            name: file,            mode: fs.statSync(filePath).mode        });
    });
    zip.pipe(output);    zip.finalize();
});
gulp.task(clean, (done) => {    del([        dirs.archive,        dirs.dist    ]).then( () => {        done();    });});
gulp.task(copy, [    copy:.htaccess,    copy:index.html,    copy:jquery,    copy:license,    copy:main.css,    copy:misc,    copy:normalize]);
gulp.task(copy:.htaccess, () =>    gulp.src(node_modules/apache-server-configs/dist/.htaccess)        .pipe(plugins().replace(# ErrorDocumentg, ErrorDocument))        .pipe(gulp.dest(dirs.dist)));
gulp.task(copy:index.html, (done) =>    sri.hash(node_modules/jquery/dist/jquery.min.js, (err, hash) => {        if (err) throw err
        let version = pkg.devDependencies.jquery;        gulp.src(/index.html)            .pipe(plugins().replace({{JQUERY_VERSION}}g, version))            .pipe(plugins().replace({{JQUERY_SRI_HASH}}g, hash))            .pipe(gulp.dest(dirs.dist));        done();    }));
gulp.task(copy:jquery, () =>    gulp.src([node_modules/jquery/dist/jquery.min.js])        .pipe(plugins().rename(jquery-.min.js))        .pipe(gulp.dest(/js/vendor)));
gulp.task(copy:license, () =>    gulp.src(LICENSE.txt)        .pipe(gulp.dest(dirs.dist)));
gulp.task(copy:main.css, () => {
    const banner =  |  License |  */;
    gulp.src(/css/main.css)        .pipe(plugins().header(banner))        .pipe(plugins().autoprefixer({            browsers: [last 2 versions, ie >= 8, > 1%],            cascade: false        }))        .pipe(gulp.dest(/css));});
gulp.task(copy:misc, () =>    gulp.src([
         Copy all files        ,
         Exclude the following files         (other tasks will handle the copying of these files)        !/css/main.css,        !/index.html
    ], {
         Include hidden files by default        dot: true
    }).pipe(gulp.dest(dirs.dist)));
gulp.task(copy:normalize, () =>    gulp.src(node_modules/normalize.css/normalize.css)        .pipe(gulp.dest(/css)));
gulp.task(lint:js, () =>    gulp.src([        gulpfile.js,        /js/*.js,            ]).pipe(plugins().jscs())      .pipe(plugins().jshint())      .pipe(plugins().jshint.reporter(jshint-stylish))      .pipe(plugins().jshint.reporter(fail)));

 --------------------------------------------------------------------- | Main tasks                                                        | ---------------------------------------------------------------------
gulp.task(archive, (done) => {    runSequence(        build,        archive:create_archive_dir,        archive:zip,    done)});
gulp.task(build, (done) => {    runSequence(        [clean, lint:js],        copy,    done)});
gulp.task(default, [build]);"
" * Copyright (c) 2013-present, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * LICENSE file in the root directory of this source tree. An additional grant * of patent rights can be found in the PATENTS file in the same directory. */
use strict;
const babelRegisterOnly = require(./packager/babelRegisterOnly);const escapeRegExp = require(lodash/escapeRegExp);const path = require(path);
const BABEL_ENABLED_PATHS = [  packager/react-packager.js,  packager/src,  packager/transformer.js,  local-cli,];
 * We use absolute paths for matching only the top-level folders reliably. For * example, we would not want to match some deeply nested forder that happens to * have the same name as one of `BABEL_ENABLED_PATHS`. */function buildRegExps(basePath, dirPaths) {  return dirPaths.map(folderPath =>     Babel `only` option works with forward slashes in the RegExp so replace     backslashes for Windows.    new RegExp(^)  );}
function getOnlyList() {  return buildRegExps(__dirname, BABEL_ENABLED_PATHS);}
 * Centralized place to register all the directories that need a Babel * transformation before being fed to Node.js. Notably, this is necessary to * support Flow type annotations. */function setupBabel() {  babelRegisterOnly(getOnlyList());}
setupBabel.buildRegExps = buildRegExps;setupBabel.getOnlyList = getOnlyList;module.exports = setupBabel;"
" * Copyright (c) 2015-present, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * LICENSE file in the root directory of this source tree. An additional grant * of patent rights can be found in the PATENTS file in the same directory. */use strict;
 * This cli config is needed for development purposes, e.g. for running * integration tests during local development or on CI services. */module.exports = {  extraNodeModules: {    react-native: __dirname,  },};"
"use strict;
var config = require(./protractor-shared-conf).config;
if (process.env.BROWSER_PROVIDER === browserstack) {   Using BrowserStack.  config.seleniumAddress = http://hub.browserstack.com/wd/hub;  config.multiCapabilities = [    capabilitiesForBrowserStack({      browserName: chrome,      platform: MAC,      version: 49    }),    capabilitiesForBrowserStack({      browserName: firefox,      version: 47    }),    capabilitiesForBrowserStack({      browserName: safari,      platform: MAC,      version: 9    })  ];} else {   Using SauceLabs.  config.sauceUser = process.env.SAUCE_USERNAME;  config.sauceKey = process.env.SAUCE_ACCESS_KEY;  config.multiCapabilities = [    capabilitiesForSauceLabs({      browserName: chrome,      platform: OS X 10.11,      version: 48    }),    capabilitiesForSauceLabs({      browserName: firefox,      version: 47    }),    capabilitiesForSauceLabs({      browserName: safari,      platform: OS X 10.11,      version: 9    })  ];}

config.allScriptsTimeout = 30000;config.getPageTimeout = 30000;
exports.config = config;

function capabilitiesForBrowserStack(capabilities) {  return {    browserstack.user: process.env.BROWSER_STACK_USERNAME,    browserstack.key: process.env.BROWSER_STACK_ACCESS_KEY,    browserstack.local: true,    browserstack.debug: true,    browserstack.tunnelIdentifier: process.env.TRAVIS_JOB_NUMBER,    tunnelIdentifier: process.env.TRAVIS_JOB_NUMBER,
    name: AngularJS E2E,    build: process.env.TRAVIS_BUILD_NUMBER,
    browserName: capabilities.browserName,    platform: capabilities.platform,    version: capabilities.version,    elementScrollBehavior: 1  };}
function capabilitiesForSauceLabs(capabilities) {  return {    tunnel-identifier: process.env.TRAVIS_JOB_NUMBER,
    name: AngularJS E2E,    build: process.env.TRAVIS_BUILD_NUMBER,
    browserName: capabilities.browserName,    platform: capabilities.platform,    version: capabilities.version,    elementScrollBehavior: 1  };}"
"use strict;
exports.config = {  allScriptsTimeout: 11000,
  baseUrl: http://localhost:8000/,
  framework: jasmine2,
  capabilities: {     Fix element scrolling behavior in Firefox for fixed header elements (like angularjs.org has)    elementScrollBehavior: 1  },
  onPrepare: function() {    
     Disable animations so e2e tests run more quickly    var disableNgAnimate = function() {      angular.module(disableNgAnimate, []).run([$animate, function($animate) {        $animate.enabled(false);      }]);    };
    browser.addMockModule(disableNgAnimate, disableNgAnimate);
     Store the name of the browser that's currently being used.    browser.getCapabilities().then(function(caps) {      browser.params.browser = caps.get(browserName);    });  },
  jasmineNodeOpts: {    defaultTimeoutInterval: 60000,    showTiming: true  }};"
"use strict;
const OFF = 0; const WARNING = 1;const ERROR = 2;
module.exports = {  extends: fbjs,
  plugins: [    react,    react-internal,  ],
   We're stricter than the default config, mostly. We'll override a few rules   and then enable some React specific ones.  rules: {    accessor-pairs: OFF,    brace-style: [ERROR, 1tbs],    comma-dangle: [ERROR, always-multiline],    consistent-return: OFF,    dot-location: [ERROR, property],    dot-notation: ERROR,    eol-last: ERROR,    eqeqeq: [ERROR, allow-null],    indent: OFF,    jsx-quotes: [ERROR, prefer-double],    keyword-spacing: [ERROR, {after: true, before: true}],    no-bitwise: OFF,    no-inner-declarations: [ERROR, functions],    no-multi-spaces: ERROR,    no-restricted-syntax: [ERROR, WithStatement],    no-shadow: ERROR,    no-unused-expressions: ERROR,    no-unused-vars: [ERROR, {args: none}],    no-useless-concat: OFF,    quotes: [ERROR, single, {avoidEscape: true, allowTemplateLiterals: true }],    space-before-blocks: ERROR,    space-before-function-paren: OFF,
     React & JSX     Our transforms set this automatically    react/jsx-boolean-value: [ERROR, always],    react/jsx-no-undef: ERROR,     We don't care to do this    react/jsx-sort-prop-types: OFF,    react/jsx-space-before-closing: ERROR,    react/jsx-uses-react: ERROR,    react/no-is-mounted: OFF,     This isn't useful in our test code    react/react-in-jsx-scope: ERROR,    react/self-closing-comp: ERROR,     We don't care to do this    react/jsx-wrap-multilines: [ERROR, {declaration: false, assignment: false}],
     CUSTOM RULES     the second argument of warning/invariant should be a literal string    react-internal/warning-and-invariant-args: ERROR,    react-internal/no-primitive-constructors: ERROR,  },
  globals: {    expectDev: true,  },};"
"use strict;
exports.config = {  allScriptsTimeout: 11000,
  specs: [    test/e2e/tests/**/*.js,    build/docs/ptore2e/**/*.js,    docs/app/e2e/*.scenario.js  ],
  capabilities: {    browserName: chrome  },
  baseUrl: http://localhost:8000/,
  framework: jasmine2,
  onPrepare: function() {    
     Disable animations so e2e tests run more quickly    var disableNgAnimate = function() {      angular.module(disableNgAnimate, []).run([$animate, function($animate) {        $animate.enabled(false);      }]);    };
    browser.addMockModule(disableNgAnimate, disableNgAnimate);
    var reporters = require(jasmine-reporters);    jasmine.getEnv().addReporter(new reporters.JUnitXmlReporter({      savePath: test_out/docs-e2e- + exports.config.capabilities.browserName + -    }));  },
  jasmineNodeOpts: {    defaultTimeoutInterval: 30000,    showColors: false  }};"
"use strict;
var config = require(./protractor-shared-conf).config;
config.specs = [  test/e2e/tests/**/*.js,  build/docs/ptore2e/**/*.js,  docs/app/e2e/**/*.scenario.js];
config.capabilities.browserName = chrome;
config.directConnect = true;
exports.config = config;"
"use strict;
module.exports = function(config, specificOptions) {  config.set({    frameworks: [jasmine],    autoWatch: true,    logLevel: config.LOG_INFO,    logColors: true,    browsers: [Chrome],    browserDisconnectTimeout: 10000,    browserDisconnectTolerance: 2,    browserNoActivityTimeout: 30000,

     SauceLabs config for local development.    sauceLabs: {      testName: specificOptions.testName || AngularJS,      startConnect: true,      options: {         We need selenium version +2.46 for Firefox 39 and the last selenium version for OS X is 2.45.         TODO: Uncomment when there is a selenium 2.46 available for OS X.         'selenium-version': '2.46.0'      }    },
     BrowserStack config for local development.    browserStack: {      project: AngularJS,      name: specificOptions.testName,      startTunnel: true,      timeout: 600  10min    },
     For more browsers on Sauce Labs see:     https://saucelabs.com/docs/platforms/webdriver    customLaunchers: {      SL_Chrome: {        base: SauceLabs,        browserName: chrome,        version: 51      },      SL_Firefox: {        base: SauceLabs,        browserName: firefox,        version: 47      },      SL_Safari_8: {        base: SauceLabs,        browserName: safari,        platform: OS X 10.10,        version: 8      },      SL_Safari_9: {        base: SauceLabs,        browserName: safari,        platform: OS X 10.11,        version: 9      },      SL_IE_9: {        base: SauceLabs,        browserName: internet explorer,        platform: Windows 2008,        version: 9      },      SL_IE_10: {        base: SauceLabs,        browserName: internet explorer,        platform: Windows 2012,        version: 10      },      SL_IE_11: {        base: SauceLabs,        browserName: internet explorer,        platform: Windows 8.1,        version: 11      },      SL_EDGE: {        base: SauceLabs,        browserName: microsoftedge,        platform: Windows 10,        version: 14      },      SL_iOS: {        base: SauceLabs,        browserName: iphone,        platform: OS X 10.10,        version: 8.1      },
      BS_Chrome: {        base: BrowserStack,        browser: chrome,        os: OS X,        os_version: Sierra      },      BS_Safari: {        base: BrowserStack,        browser: safari,        os: OS X,        os_version: Sierra      },      BS_Firefox: {        base: BrowserStack,        browser: firefox,        os: Windows,        os_version: 10      },      BS_IE_9: {        base: BrowserStack,        browser: ie,        browser_version: 9.0,        os: Windows,        os_version: 7      },      BS_IE_10: {        base: BrowserStack,        browser: ie,        browser_version: 10.0,        os: Windows,        os_version: 8      },      BS_IE_11: {        base: BrowserStack,        browser: ie,        browser_version: 11.0,        os: Windows,        os_version: 8.1      },      BS_EDGE: {        base: BrowserStack,        browser: edge,        browser_version: 14,        os: Windows,        os_version: 10      },      BS_iOS_8: {        base: BrowserStack,        device: iPhone 6,        os: ios,        os_version: 8.3      },      BS_iOS_9: {        base: BrowserStack,        device: iPhone 6S,        os: ios,        os_version: 9.3      },      BS_iOS_10: {        base: BrowserStack,        device: iPhone 7,        os: ios,        os_version: 10.0      }    }  });

  if (process.env.TRAVIS) {    var buildLabel = TRAVIS # + process.env.TRAVIS_BUILD_NUMBER +  ( + process.env.TRAVIS_BUILD_ID + );
    config.logLevel = config.LOG_DEBUG;     Karma (with socket.io 1.x) buffers by 50 and 50 tests can take a long time on IEs;-)    config.browserNoActivityTimeout = 120000;
    config.browserStack.build = buildLabel;    config.browserStack.startTunnel = false;    config.browserStack.tunnelIdentifier = process.env.TRAVIS_JOB_NUMBER;
    config.sauceLabs.build = buildLabel;    config.sauceLabs.startConnect = false;    config.sauceLabs.tunnelIdentifier = process.env.TRAVIS_JOB_NUMBER;    config.sauceLabs.recordScreenshots = true;
     Debug logging into a file, that we print out at the end of the build.    config.loggers.push({      type: file,      filename: process.env.LOGS_DIR + / + (specificOptions.logFile || karma.log)    });
    if (process.env.BROWSER_PROVIDER === saucelabs || !process.env.BROWSER_PROVIDER) {       Allocating a browser can take pretty long (eg. if we are out of capacity and need to wait       for another build to finish) and so the `captureTimeout` typically kills       an in-queue-pending request, which makes no sense.      config.captureTimeout = 0;    }  }

   Terrible hack to workaround inflexibility of log4js:   - ignore web-server's 404 warnings,   - ignore DEBUG logs (on Travis), we log them into a file instead.  var IGNORED_404 = [    /favicon.ico,    /%7B%7BtestUrl%7D%7D,    /someSanitizedUrl,    /{{testUrl}}  ];  var log4js = require(log4js);  var layouts = require(log4js/lib/layouts);  var originalConfigure = log4js.configure;  log4js.configure = function(log4jsConfig) {    var consoleAppender = log4jsConfig.appenders.shift();    var originalResult = originalConfigure.call(log4js, log4jsConfig);    var layout = layouts.layout(consoleAppender.layout.type, consoleAppender.layout);


    log4js.addAppender(function(log) {      var msg = log.data[0];
       ignore web-server's 404s      if (log.categoryName === web-server && log.level.levelStr === config.LOG_WARN &&          IGNORED_404.some(function(ignoredLog) {return msg.indexOf(ignoredLog) !== -1;})) {        return;      }
       on Travis, ignore DEBUG statements      if (process.env.TRAVIS && log.level.levelStr === config.LOG_DEBUG) {        return;      }
      console.log(layout(log));    });
    return originalResult;  };};"
"use strict;
var angularFiles = require(./angularFiles);var sharedConfig = require(./karma-shared.conf);
module.exports = function(config) {  sharedConfig(config, {testName: AngularJS: modules, logFile: karma-modules.log});
  config.set({    files: angularFiles.mergeFilesFor(karmaModules),
    junitReporter: {      outputFile: test_out/modules.xml,      suite: modules    }  });};"
"use strict;
var karmaConfigFactory = require(./karma-jquery.conf-factory);
module.exports = karmaConfigFactory();"
"use strict;
var angularFiles = require(./angularFiles);var sharedConfig = require(./karma-shared.conf);
module.exports = function(version) {  version = version || ;
  return function(config) {    sharedConfig(config, {      testName: AngularJS: jQuery + (version ?   + version : ),      logFile: karma-jquery + version + .log    });
    config.set({      files: angularFiles.mergeFilesFor(karmaJquery + version),      exclude: angularFiles.mergeFilesFor(karmaJqueryExclude),
      junitReporter: {        outputFile: test_out/jquery.xml,        suite: jQuery      }    });  };};"
"use strict;
var karmaConfigFactory = require(./karma-jquery.conf-factory);
module.exports = karmaConfigFactory(2.2);"
"use strict;
var karmaConfigFactory = require(./karma-jquery.conf-factory);
module.exports = karmaConfigFactory(2.1);"
"use strict;
var angularFiles = require(./angularFiles);var sharedConfig = require(./karma-shared.conf);
module.exports = function(config) {  sharedConfig(config, {testName: AngularJS: jqLite, logFile: karma-jqlite.log});
  config.set({    files: angularFiles.mergeFilesFor(karma),    exclude: angularFiles.mergeFilesFor(karmaExclude),
    junitReporter: {      outputFile: test_out/jqlite.xml,      suite: jqLite    }  });};"
"use strict;
var sharedConfig = require(./karma-shared.conf);
module.exports = function(config) {  sharedConfig(config, {testName: AngularJS: docs, logFile: karma-docs.log});
  config.set({    files: [      build/angular.js,      build/angular-mocks.js,      docs/app/src/**/*.js,      docs/app/test/**/*Spec.js    ],
    junitReporter: {      outputFile: test_out/docs.xml,      suite: Docs    }  });};"
"use strict;
var angularFiles = {  angularSrc: [    src/minErr.js,    src/Angular.js,    src/loader.js,    src/shallowCopy.js,    src/stringify.js,    src/AngularPublic.js,    src/jqLite.js,    src/apis.js,
    src/auto/injector.js,
    src/ng/anchorScroll.js,    src/ng/animate.js,    src/ng/animateRunner.js,    src/ng/animateCss.js,    src/ng/browser.js,    src/ng/cacheFactory.js,    src/ng/compile.js,    src/ng/controller.js,    src/ng/document.js,    src/ng/exceptionHandler.js,    src/ng/forceReflow.js,    src/ng/http.js,    src/ng/httpBackend.js,    src/ng/interpolate.js,    src/ng/interval.js,    src/ng/jsonpCallbacks.js,    src/ng/locale.js,    src/ng/location.js,    src/ng/log.js,    src/ng/parse.js,    src/ng/q.js,    src/ng/raf.js,    src/ng/rootScope.js,    src/ng/rootElement.js,    src/ng/sanitizeUri.js,    src/ng/sce.js,    src/ng/sniffer.js,    src/ng/templateRequest.js,    src/ng/testability.js,    src/ng/timeout.js,    src/ng/urlUtils.js,    src/ng/window.js,    src/ng/cookieReader.js,
    src/ng/filter.js,    src/ng/filter/filter.js,    src/ng/filter/filters.js,    src/ng/filter/limitTo.js,    src/ng/filter/orderBy.js,
    src/ng/directive/directives.js,    src/ng/directive/a.js,    src/ng/directive/attrs.js,    src/ng/directive/form.js,    src/ng/directive/input.js,    src/ng/directive/ngBind.js,    src/ng/directive/ngChange.js,    src/ng/directive/ngClass.js,    src/ng/directive/ngCloak.js,    src/ng/directive/ngController.js,    src/ng/directive/ngCsp.js,    src/ng/directive/ngEventDirs.js,    src/ng/directive/ngIf.js,    src/ng/directive/ngInclude.js,    src/ng/directive/ngInit.js,    src/ng/directive/ngList.js,    src/ng/directive/ngModel.js,    src/ng/directive/ngModelOptions.js,    src/ng/directive/ngNonBindable.js,    src/ng/directive/ngOptions.js,    src/ng/directive/ngPluralize.js,    src/ng/directive/ngRepeat.js,    src/ng/directive/ngShowHide.js,    src/ng/directive/ngStyle.js,    src/ng/directive/ngSwitch.js,    src/ng/directive/ngTransclude.js,    src/ng/directive/script.js,    src/ng/directive/select.js,    src/ng/directive/validators.js,    src/angular.bind.js,    src/publishExternalApis.js,    src/ngLocale/angular-locale_en-us.js  ],
  angularLoader: [    src/stringify.js,    src/minErr.js,    src/loader.js  ],
  angularModules: {    ngAnimate: [      src/ngAnimate/shared.js,      src/ngAnimate/rafScheduler.js,      src/ngAnimate/animateChildrenDirective.js,      src/ngAnimate/animateCss.js,      src/ngAnimate/animateCssDriver.js,      src/ngAnimate/animateJs.js,      src/ngAnimate/animateJsDriver.js,      src/ngAnimate/animateQueue.js,      src/ngAnimate/animation.js,      src/ngAnimate/ngAnimateSwap.js,      src/ngAnimate/module.js    ],    ngCookies: [      src/ngCookies/cookies.js,      src/ngCookies/cookieStore.js,      src/ngCookies/cookieWriter.js    ],    ngMessageFormat: [      src/ngMessageFormat/messageFormatCommon.js,      src/ngMessageFormat/messageFormatSelector.js,      src/ngMessageFormat/messageFormatInterpolationParts.js,      src/ngMessageFormat/messageFormatParser.js,      src/ngMessageFormat/messageFormatService.js    ],    ngMessages: [      src/ngMessages/messages.js    ],    ngParseExt: [      src/ngParseExt/ucd.js,      src/ngParseExt/module.js    ],    ngResource: [      src/ngResource/resource.js    ],    ngRoute: [      src/shallowCopy.js,      src/ngRoute/route.js,      src/ngRoute/routeParams.js,      src/ngRoute/directive/ngView.js    ],    ngSanitize: [      src/ngSanitize/sanitize.js,      src/ngSanitize/filter/linky.js    ],    ngMock: [      src/ngMock/angular-mocks.js,      src/ngMock/browserTrigger.js    ],    ngTouch: [      src/ngTouch/touch.js,      src/ngTouch/swipe.js,      src/ngTouch/directive/ngSwipe.js    ],    ngAria: [      src/ngAria/aria.js    ]  },
  angularScenario: [    src/ngScenario/Scenario.js,    src/ngScenario/Application.js,    src/ngScenario/Describe.js,    src/ngScenario/Future.js,    src/ngScenario/ObjectModel.js,    src/ngScenario/Runner.js,    src/ngScenario/SpecRunner.js,    src/ngScenario/dsl.js,    src/ngScenario/matchers.js,    src/ngScenario/output/Html.js,    src/ngScenario/output/Json.js,    src/ngScenario/output/Xml.js,    src/ngScenario/output/Object.js  ],
  angularTest: [    test/helpers/*.js,    test/ngScenario/*.js,    test/ngScenario/output/*.js,    test/*.js,    test/auto/*.js,    test/ng/**/*.js,    test/ngAnimate/*.js,    test/ngMessageFormat/*.js,    test/ngMessages/*.js,    test/ngCookies/*.js,    test/ngResource/*.js,    test/ngRoute/**/*.js,    test/ngSanitize/**/*.js,    test/ngMock/*.js,    test/ngTouch/**/*.js,    test/ngAria/*.js  ],
  karma: [    bower_components/jquery/dist/jquery.js,    test/jquery_remove.js,    @angularSrc,    @angularSrcModules,    @angularScenario,    @angularTest  ],
  karmaExclude: [    test/jquery_alias.js,    src/angular-bootstrap.js,    src/ngScenario/angular-bootstrap.js,    src/angular.bind.js  ],
  karmaScenario: [    build/angular-scenario.js,    build/docs/docs-scenario.js  ],
  karmaModules: [    build/angular.js,    @angularSrcModules,    test/modules/no_bootstrap.js,    test/helpers/*.js,    test/ngAnimate/*.js,    test/ngMessageFormat/*.js,    test/ngMessages/*.js,    test/ngMock/*.js,    test/ngCookies/*.js,    test/ngRoute/**/*.js,    test/ngResource/*.js,    test/ngSanitize/**/*.js,    test/ngTouch/**/*.js,    test/ngAria/*.js  ],
  karmaJquery: [    bower_components/jquery/dist/jquery.js,    test/jquery_alias.js,    @angularSrc,    @angularSrcModules,    @angularScenario,    @angularTest  ],
  karmaJqueryExclude: [    src/angular-bootstrap.js,    src/ngScenario/angular-bootstrap.js,    test/jquery_remove.js,    src/angular.bind.js  ]};
[2.1, 2.2].forEach(function(jQueryVersion) {  angularFiles[karmaJquery + jQueryVersion] = []    .concat(angularFiles.karmaJquery)    .map(function(path) {      if (path.startsWith(bower_components/jquery)) {        return path.replace(bower_componentsjquery, bower_components/jquery- + jQueryVersion);      }      return path;    });});
angularFiles[angularSrcModules] = [].concat(  angularFiles[angularModules][ngAnimate],  angularFiles[angularModules][ngMessageFormat],  angularFiles[angularModules][ngMessages],  angularFiles[angularModules][ngCookies],  angularFiles[angularModules][ngResource],  angularFiles[angularModules][ngRoute],  angularFiles[angularModules][ngSanitize],  angularFiles[angularModules][ngMock],  angularFiles[angularModules][ngTouch],  angularFiles[angularModules][ngAria]);
if (exports) {  exports.files = angularFiles;  exports.mergeFilesFor = function() {    var files = [];
    Array.prototype.slice.call(arguments, 0).forEach(function(filegroup) {      angularFiles[filegroup].forEach(function(file) {         replace @ref        var match = file.match(@());        if (match) {          files = files.concat(angularFiles[match[1]]);        } else {          files.push(file);        }      });    });
    return files;  };}"
"use strict;
var serveFavicon = require(serve-favicon);var serveStatic = require(serve-static);var serveIndex = require(serve-index);var files = require(./angularFiles).files;var util = require(./lib/grunt/utils.js);var versionInfo = require(./lib/versions/version-info);var path = require(path);var e2e = require(./test/e2e/tools);
var semver = require(semver);var exec = require(shelljs).exec;var pkg = require(__dirname + /package.json);
 Node.js version checksif (!semver.satisfies(process.version, pkg.engines.node)) {  reportOrFail(Invalid node version ( + process.version + ).  +               Please use a version that satisfies  + pkg.engines.node);}
 Yarn version checksvar expectedYarnVersion = pkg.engines.yarn;var currentYarnVersion = exec(yarn --version, {silent: true}).stdout.trim();if (!semver.satisfies(currentYarnVersion, expectedYarnVersion)) {  reportOrFail(Invalid yarn version ( + currentYarnVersion + ).  +               Please use a version that satisfies  + expectedYarnVersion);}
 Grunt CLI version checksvar expectedGruntVersion = pkg.engines.grunt;var currentGruntVersions = exec(grunt --version, {silent: true}).stdout;var match = grunt-cli v()m.exec(currentGruntVersions);if (!match) {  reportOrFail(Unable to compute the current grunt-cli version. We found: +               currentGruntVersions);} else {  if (!semver.satisfies(match[1], expectedGruntVersion)) {  reportOrFail(Invalid grunt-cli version ( + match[1] + ).  +               Please use a version that satisfies  + expectedGruntVersion);  }}
 Ensure Node.js dependencies have been installedif (!process.env.TRAVIS && !process.env.JENKINS_HOME) {  var yarnOutput = exec(yarn install);  if (yarnOutput.code !== 0) {    throw new Error(Yarn install failed:  + yarnOutput.stderr);  }}

module.exports = function(grunt) {
   this loads all the node_modules that start with `grunt-` as plugins  require(load-grunt-tasks)(grunt);
   load additional grunt tasks  grunt.loadTasks(lib/grunt);  grunt.loadNpmTasks(angular-benchpress);
   compute version related info for this build  var NG_VERSION = versionInfo.currentVersion;  NG_VERSION.cdn = versionInfo.cdnVersion;  var dist = angular- + NG_VERSION.full;
  if (versionInfo.cdnVersion == null) {    throw new Error(Unable to read CDN version, are you offline or has the CDN not been properly pushed? +                    Perhaps you want to set the NG1_BUILD_NO_REMOTE_VERSION_REQUESTS environment variable?);  }
  config  grunt.initConfig({    NG_VERSION: NG_VERSION,    bp_build: {      options: {        buildPath: build/benchmarks,        benchmarksPath: benchmarks      }    },
    connect: {      devserver: {        options: {          port: 8000,          hostname: 0.0.0.0,          base: .,          keepalive: true,          middleware: function(connect, options) {            var base = Array.isArray(options.base) ? options.base[options.base.length - 1] : options.base;            return [              util.conditionalCsp(),              util.rewrite(),              e2e.middleware(),              serveFavicon(images/favicon.ico),              serveStatic(base),              serveIndex(base)            ];          }        }      },      testserver: {        options: {           We use end2end task (which does not start the webserver)           and start the webserver as a separate process (in travis_build.sh)           to avoid https://github.com/joyent/libuv/issues/826          port: 8000,          hostname: 0.0.0.0,          middleware: function(connect, options) {            var base = Array.isArray(options.base) ? options.base[options.base.length - 1] : options.base;            return [              function(req, resp, next) {                 cache get requests to speed up tests on travis                if (req.method === GET) {                  resp.setHeader(Cache-control, public, max-age=3600);                }
                next();              },              util.conditionalCsp(),              e2e.middleware(),              serveFavicon(images/favicon.ico),              serveStatic(base)            ];          }        }      }    },

    tests: {      jqlite: karma-jqlite.conf.js,      jquery: karma-jquery.conf.js,      jquery-2.2: karma-jquery-2.2.conf.js,      jquery-2.1: karma-jquery-2.1.conf.js,      docs: karma-docs.conf.js,      modules: karma-modules.conf.js    },

    autotest: {      jqlite: karma-jqlite.conf.js,      jquery: karma-jquery.conf.js,      jquery-2.2: karma-jquery-2.2.conf.js,      jquery-2.1: karma-jquery-2.1.conf.js,      modules: karma-modules.conf.js,      docs: karma-docs.conf.js    },

    protractor: {      normal: protractor-conf.js,      travis: protractor-travis-conf.js,      jenkins: protractor-jenkins-conf.js    },

    clean: {      build: [build],      tmp: [tmp]    },
    eslint: {      all: {        src: [          ,          benchmarks/**/*.js,          docs/**/*.js,          lib/**/*.js,          scripts/**/*.js,          src/**/*.js,          test/**/*.js,          i18n/**/*.js,          !docs/app/assets/js/angular-bootstrap/**,          !docs/config/templates/**,          !src/angular.bind.js,          !i18n/closure/**,          !src/ngParseExt/ucd.js        ]      }    },
    build: {      scenario: {        dest: build/angular-scenario.js,        src: [          bower_components/jquery/dist/jquery.js,          util.wrap([files[angularSrc], files[angularScenario]], ngScenario/angular)        ],        styles: {          css: [css/angular.css, css/angular-scenario.css]        }      },      angular: {        dest: build/angular.js,        src: util.wrap([files[angularSrc]], angular),        styles: {          css: [css/angular.css],          generateCspCssFile: true,          minify: true        }      },      loader: {        dest: build/angular-loader.js,        src: util.wrap(files[angularLoader], loader)      },      touch: {        dest: build/angular-touch.js,        src: util.wrap(files[angularModules][ngTouch], module)      },      mocks: {        dest: build/angular-mocks.js,        src: util.wrap(files[angularModules][ngMock], module),        strict: false      },      sanitize: {        dest: build/angular-sanitize.js,        src: util.wrap(files[angularModules][ngSanitize], module)      },      resource: {        dest: build/angular-resource.js,        src: util.wrap(files[angularModules][ngResource], module)      },      messageformat: {        dest: build/angular-message-format.js,        src: util.wrap(files[angularModules][ngMessageFormat], module)      },      messages: {        dest: build/angular-messages.js,        src: util.wrap(files[angularModules][ngMessages], module)      },      animate: {        dest: build/angular-animate.js,        src: util.wrap(files[angularModules][ngAnimate], module)      },      route: {        dest: build/angular-route.js,        src: util.wrap(files[angularModules][ngRoute], module)      },      cookies: {        dest: build/angular-cookies.js,        src: util.wrap(files[angularModules][ngCookies], module)      },      aria: {        dest: build/angular-aria.js,        src: util.wrap(files[angularModules][ngAria], module)      },      parseext: {        dest: build/angular-parse-ext.js,        src: util.wrap(files[angularModules][ngParseExt], module)      },      promises-aplus-adapter: {        dest:tmp/promises-aplus-adapter++.js,        src:[src/ng/q.js, lib/promises-aplus/promises-aplus-test-adapter.js]      }    },

    min: {      angular: build/angular.js,      animate: build/angular-animate.js,      cookies: build/angular-cookies.js,      loader: build/angular-loader.js,      messageformat: build/angular-message-format.js,      messages: build/angular-messages.js,      touch: build/angular-touch.js,      resource: build/angular-resource.js,      route: build/angular-route.js,      sanitize: build/angular-sanitize.js,      aria: build/angular-aria.js,      parseext: build/angular-parse-ext.js    },

    ddescribe-iit: {      files: [        src/**/*.js,        test/**/*.js,        !test/ngScenario/DescribeSpec.js,        !src/ng/directive/attrs.js,  legitimate xit here        !src/ngScenario/**/*.js,        !test/helpers/privateMocks*.js      ],      options: {        disallowed: [          fit,          iit,          xit,          fthey,          tthey,          xthey,          fdescribe,          ddescribe,          xdescribe,          it.only,          describe.only        ]      }    },
    merge-conflict: {      files: [        src/**/*,        test/**/*,        docs/**/*,        css/**/*      ]    },
    copy: {      i18n: {        files: [          { src: src/ngLocale/**, dest: build/i18n/, expand: true, flatten: true }        ]      }    },

    compress: {      build: {        options: {archive: build/ + dist + .zip, mode: zip},        src: [],        cwd: build,        expand: true,        dot: true,        dest: dist + /      }    },
    shell: {      install-node-dependencies: {        command: yarn      },      promises-aplus-tests: {        options: {          stdout: false,          stderr: true,          failOnError: true        },        command: path.normalize(./node_modules/.bin/promises-aplus-tests tmp/promises-aplus-adapter++.js --timeout 2000)      }    },

    write: {      versionTXT: {file: build/version.txt, val: NG_VERSION.full},      versionJSON: {file: build/version.json, val: JSON.stringify(NG_VERSION)}    },
    bump: {      options: {        files: [package.json],        commit: false,        createTag: false,        push: false      }    }  });
  alias tasks  grunt.registerTask(test, Run unit, docs and e2e tests with Karma, [eslint, package, test:unit, test:promises-aplus, tests:docs, test:protractor]);  grunt.registerTask(test:jqlite, Run the unit tests with Karma , [tests:jqlite]);  grunt.registerTask(test:jquery, Run the jQuery (latest) unit tests with Karma, [tests:jquery]);  grunt.registerTask(test:jquery-2.2, Run the jQuery 2.2 unit tests with Karma, [tests:jquery-2.2]);  grunt.registerTask(test:jquery-2.1, Run the jQuery 2.1 unit tests with Karma, [tests:jquery-2.1]);  grunt.registerTask(test:modules, Run the Karma module tests with Karma, [build, tests:modules]);  grunt.registerTask(test:docs, Run the doc-page tests with Karma, [package, tests:docs]);  grunt.registerTask(test:unit, Run unit, jQuery and Karma module tests with Karma, [test:jqlite, test:jquery, test:jquery-2.2, test:jquery-2.1, test:modules]);  grunt.registerTask(test:protractor, Run the end to end tests with Protractor and keep a test server running in the background, [webdriver, connect:testserver, protractor:normal]);  grunt.registerTask(test:travis-protractor, Run the end to end tests with Protractor for Travis CI builds, [connect:testserver, protractor:travis]);  grunt.registerTask(test:ci-protractor, Run the end to end tests with Protractor for Jenkins CI builds, [webdriver, connect:testserver, protractor:jenkins]);  grunt.registerTask(test:e2e, Alias for test:protractor, [test:protractor]);  grunt.registerTask(test:promises-aplus,[build:promises-aplus-adapter, shell:promises-aplus-tests]);
  grunt.registerTask(minify, [bower, clean, build, minall]);  grunt.registerTask(webserver, [connect:devserver]);  grunt.registerTask(package, [bower, validate-angular-files, clean, buildall, minall, collect-errors, write, docs, copy, compress]);  grunt.registerTask(ci-checks, [ddescribe-iit, merge-conflict, eslint]);  grunt.registerTask(default, [package]);};

function reportOrFail(message) {  if (process.env.TRAVIS || process.env.JENKINS_HOME) {    throw new Error(message);  } else {    console.log(===============================================================================);    console.log(message);    console.log(===============================================================================);  }}"
" * Copyright (c) 2015-present, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * LICENSE file in the root directory of this source tree. An additional grant * of patent rights can be found in the PATENTS file in the same directory. */use strict;
module.exports = require(./local-cli/cli.js);"
"            Set-up
var  gulp         = require(gulp-help)(require(gulp)),
   read user config to know what task to load  config       = require(./tasks/config/user),
   watch for file changes and build  watch        = require(./tasks/watch),
   build all files  build        = require(./tasks/build),  buildJS      = require(./tasks/build/javascript),  buildCSS     = require(./tasks/build/css),  buildAssets  = require(./tasks/build/assets),
   utility tasks  clean        = require(./tasks/clean),  version      = require(./tasks/version),
   install tasks  install      = require(./tasks/install),  checkInstall = require(./tasks/check-install),
   docs tasks  serveDocs    = require(./tasks/docs/serve),  buildDocs    = require(./tasks/docs/build),
   rtl  buildRTL     = require(./tasks/rtl/build),  watchRTL     = require(./tasks/rtl/watch);

             Tasks
gulp.task(default, false, [  check-install]);
gulp.task(watch, Watch for site/theme changes, watch);
gulp.task(build, Builds all files from source, build);gulp.task(build-javascript, Builds all javascript from source, buildJS);gulp.task(build-css, Builds all css from source, buildCSS);gulp.task(build-assets, Copies all assets from source, buildAssets);
gulp.task(clean, Clean dist folder, clean);gulp.task(version, Displays current version of Semantic, version);
gulp.task(install, Runs set-up, install);gulp.task(check-install, Displays current version of Semantic, checkInstall);
      Docs---------------*/
  Lets you serve files to a local documentation instance  https://github.com/Semantic-Org/Semantic-UI-Docs/
gulp.task(serve-docs, Serve file changes to SUI Docs, serveDocs);gulp.task(build-docs, Build all files and add to SUI Docs, buildDocs);

      RTL---------------*/
if(config.rtl) {  gulp.task(watch-rtl, Watch files as RTL, watchRTL);  gulp.task(build-rtl, Build all files as RTL, buildRTL);}
if(config.admin) {  require(./tasks/collections/admin)(gulp);}"
"
use strict;
 Browsers to run on Sauce Labs platforms.var sauceBrowsers = [  [ chrome, 53, Windows 10 ],  [ chrome, 52, Windows 10 ],  [ firefox, 48, Windows 10 ],  [ firefox, 47, Windows 10 ],  [ microsoftedge, 13, Windows 10 ],  [ internet explorer, 11, Windows 10 ],  [ safari, 9, OS X 10.11 ],  [ safari, 8, OS X 10.10 ]].reduce( function( object, platform ) {
   Convert ""internet explorer"" -> ""ie"".  var label = platform[ 0 ].split(   );  label = (    label.length > 1 ? label.map( function( word ) { return word[ 0 ]; } ) : label  ).join(  ) +  _v + platform[ 1 ];
  object[ label ] = {    base: SauceLabs,    browserName: platform[ 0 ],    version: platform[ 1 ],    platform: platform[ 2 ]  };  return object;}, {} );
module.exports = function( config ) {  if ( !process.env.SAUCE_USERNAME || !process.env.SAUCE_ACCESS_KEY ) {    console.log( Sauce environments not set --- Skipping );    return process.exit( 0 );  }  config.set( {    basePath: ,    browserDisconnectTolerance: 5,    frameworks: [ qunit ],    singleRun: true,
     The list of files / patterns to load in the browser.    files: [      test/bootstrap.js,      js/impress.js,      test/core_tests.js    ],
     The number of sauce tests to start in parallel.    concurrency: 1,
     Test results reporter to use.    reporters: [ dots, saucelabs ],    port: 9876,    colors: true,    logLevel: config.LOG_INFO,    sauceLabs: {      build: CIRCLE-CI # + process.env.CIRCLE_BUILD_NUM,      startConnect: true,      tunnelIdentifier: process.env.CIRCLE_BUILD_NUM    },    captureTimeout: 120000,    customLaunchers: sauceBrowsers,
     Browsers to launch.    browsers: Object.keys( sauceBrowsers )  } );};"
"module.exports = function(grunt) {
   configure the tasks  grunt.initConfig({      Copy    copy: {      dist: { cwd: fonts, src: [  ], dest: dist/fonts, expand: true },    },
      Jasmine    jasmine: {      components: {        src: [          bin/materialize.js        ],        options: {          vendor: [            node_modules/jquery/dist/jquery.min.js,            node_modules/jasmine-jquery/lib/jasmine-jquery.js          ],          styles: bin/materialize.css,          specs: tests/spec/**/*Spec.js,          helpers: tests/spec/helper.js,          keepRunner : true,          helpers: 'test/spec/*.js'        }      }    },


      Sass    sass: {                               Task      expanded: {                             Target        options: {                        Target options          outputStyle: expanded,          sourcemap: false,        },        files: {          dist/css/materialize.css: sass/materialize.scss,        }      },
      min: {        options: {          outputStyle: compressed,          sourcemap: false        },        files: {          dist/css/materialize.min.css: sass/materialize.scss,        }      },
       Compile ghpages css      gh: {        options: {          outputStyle: compressed,          sourcemap: false        },        files: {          css/ghpages-materialize.css: sass/ghpages-materialize.scss,        }      },
       Compile bin css      bin: {        options: {          outputStyle: expanded,          sourcemap: false        },        files: {          bin/materialize.css: sass/materialize.scss,        }      }    },
     PostCss Autoprefixer    postcss: {      options: {        processors: [          require(autoprefixer)({            browsers: [              last 2 versions,              Chrome >= 30,              Firefox >= 30,              ie >= 10,              Safari >= 8]          })        ]      },      expended: {        src: dist/css/materialize.css      },      min: {        src: dist/css/materialize.min.css      },      gh: {        src: css/ghpages-materialize.css      },      bin: {        src: bin/materialize.css      }    },
     Browser Sync integration    browserSync: {      bsFiles: [bin/*.js, bin/*.css, !**/node_modules/**/*],      options: {        server: {          baseDir: ./  make server from root dir        },        port: 8000,        ui: {          port: 8080,          weinre: {            port: 9090          }        },        open: false      }    },
      Concat    concat: {      options: {        separator: ;      },      dist: {         the files to concatenate        src: [          js/initial.js,          js/jquery.easing.1.3.js,          js/animation.js,          js/velocity.min.js,          js/hammer.min.js,          js/jquery.hammer.js,          js/global.js,          js/collapsible.js,          js/dropdown.js,          js/modal.js,          js/materialbox.js,          js/parallax.js,          js/tabs.js,          js/tooltip.js,          js/waves.js,          js/toasts.js,          js/sideNav.js,          js/scrollspy.js,          js/forms.js,          js/slider.js,          js/cards.js,          js/chips.js,          js/pushpin.js,          js/buttons.js,          js/transitions.js,          js/scrollFire.js,          js/date_picker/picker.js,          js/date_picker/picker.date.js,          js/character_counter.js,          js/carousel.js,          js/tapTarget.js,        ],         the location of the resulting JS file        dest: dist/js/materialize.js      },      temp: {         the files to concatenate        src: [          js/initial.js,          js/jquery.easing.1.3.js,          js/animation.js,          js/velocity.min.js,          js/hammer.min.js,          js/jquery.hammer.js,          js/global.js,          js/collapsible.js,          js/dropdown.js,          js/modal.js,          js/materialbox.js,          js/parallax.js,          js/tabs.js,          js/tooltip.js,          js/waves.js,          js/toasts.js,          js/sideNav.js,          js/scrollspy.js,          js/forms.js,          js/slider.js,          js/cards.js,          js/chips.js,          js/pushpin.js,          js/buttons.js,          js/transitions.js,          js/scrollFire.js,          js/date_picker/picker.js,          js/date_picker/picker.date.js,          js/character_counter.js,          js/carousel.js,          js/tapTarget.js,        ],         the location of the resulting JS file        dest: temp/js/materialize.js      },    },
      Uglify    uglify: {      options: {         Use these options when debugging         mangle: false,         compress: false,         beautify: true
      },      dist: {        files: {          dist/js/materialize.min.js: [dist/js/materialize.js]        }      },      bin: {        files: {          bin/materialize.js: [temp/js/materialize.js]        }      },      extras: {        files: {          extras/noUiSlider/nouislider.min.js: [extras/noUiSlider/nouislider.js]        }      }    },

      Compress    compress: {      main: {        options: {          archive: bin/materialize.zip,          level: 6        },        files:[          { expand: true, cwd: dist/, src: [], dest: materialize/},          { expand: true, cwd: ./, src: [LICENSE, README.md], dest: materialize/},        ]      },
      src: {        options: {          archive: bin/materialize-src.zip,          level: 6        },        files:[          {expand: true, cwd: fonts/, src: [], dest: materialize-src/fonts/},          {expand: true, cwd: sass/, src: [materialize.scss], dest: materialize-src/sass/},          {expand: true, cwd: sass/, src: [components/**/*], dest: materialize-src/sass/},          {expand: true, cwd: js/, src: [            initial.js,            jquery.easing.1.3.js,            animation.js,            velocity.min.js,            hammer.min.js,            jquery.hammer.js,            global.js,            collapsible.js,            dropdown.js,            modal.js,            materialbox.js,            parallax.js,            tabs.js,            tooltip.js,            waves.js,            toasts.js,            sideNav.js,            scrollspy.js,            forms.js,            slider.js,            cards.js,            chips.js,            pushpin.js,            buttons.js,            transitions.js,            scrollFire.js,            date_picker/picker.js,            date_picker/picker.date.js,            character_counter.js,            carousel.js,            tapTarget.js,          ], dest: materialize-src/js/},          {expand: true, cwd: dist/js/, src: [], dest: materialize-src/js/bin/},          {expand: true, cwd: ./, src: [LICENSE, README.md], dest: materialize-src/}
        ]      },
      starter_template: {        options: {          archive: templates/starter-template.zip,          level: 6        },        files:[          { expand: true, cwd: dist/, src: [], dest: starter-template/},          { expand: true, cwd: templates/starter-template/, src: [index.html, LICENSE], dest: starter-template/},          { expand: true, cwd: templates/starter-template/css, src: [style.css], dest: starter-template/css},          { expand: true, cwd: templates/starter-template/js, src: [init.js], dest: starter-template/js}
        ]      },
      parallax_template: {        options: {          archive: templates/parallax-template.zip,          level: 6        },        files:[          { expand: true, cwd: dist/, src: [], dest: parallax-template/},          { expand: true, cwd: templates/parallax-template/, src: [index.html, LICENSE, background1.jpg, background2.jpg, background3.jpg], dest: parallax-template/},          { expand: true, cwd: templates/parallax-template/css, src: [style.css], dest: parallax-template/css},          { expand: true, cwd: templates/parallax-template/js, src: [init.js], dest: parallax-template/js}
        ]      }
    },

      Clean    clean: {      temp: {        src: [ temp/ ]      },    },
      Jade    jade: {      compile: {        options: {          pretty: true,          data: {            debug: false          }        },        files: {          index.html: jade/index.jade,          icons.html: jade/icons.jade,          about.html: jade/about.jade,          sass.html: jade/sass.jade,          getting-started.html: jade/getting-started.jade,          mobile.html: jade/mobile.jade,          showcase.html: jade/showcase.jade,          parallax.html: jade/parallax.jade,          parallax-demo.html: jade/parallax-demo.jade,          typography.html: jade/typography.jade,          color.html: jade/color.jade,          shadow.html: jade/shadow.jade,          grid.html: jade/grid.jade,          media-css.html: jade/media-css.jade,          table.html: jade/table.jade,          helpers.html: jade/helpers.jade,          forms.html: jade/forms.jade,          buttons.html: jade/buttons.jade,          navbar.html: jade/navbar.jade,          cards.html: jade/cards.jade,          preloader.html: jade/preloader.jade,          collections.html: jade/collections.jade,          badges.html: jade/badges.jade,          footer.html: jade/footer.jade,          dialogs.html: jade/dialogs.jade,          modals.html: jade/modals.jade,          dropdown.html: jade/dropdown.jade,          tabs.html: jade/tabs.jade,          side-nav.html: jade/sideNav.jade,          pushpin.html: jade/pushpin.jade,          waves.html: jade/waves.jade,          media.html: jade/media.jade,          collapsible.html: jade/collapsible.jade,          chips.html: jade/chips.jade,          scrollfire.html: jade/scrollFire.jade,          scrollspy.html: jade/scrollspy.jade,          transitions.html: jade/transitions.jade,          fullscreen-slider-demo.html: jade/fullscreen-slider-demo.jade,          pagination.html: jade/pagination.jade,          breadcrumbs.html: jade/breadcrumbs.jade,          carousel.html: jade/carousel.jade,          feature-discovery.html: jade/feature-discovery.jade,          pulse.html: jade/pulse.jade,          pushpin-demo.html: jade/pushpin-demo.jade,          css-transitions.html: jade/css-transitions.jade,          themes.html: jade/themes.jade,          404.html: jade/404.jade,
        }      }    },
      Watch Files    watch: {      jade: {        files: [jade/**/*],        tasks: [jade_compile],        options: {          interrupt: false,          spawn: false,        },      },
      js: {        files: [ js/**/*, !js/init.js],        tasks: [js_compile],        options: {          interrupt: false,          spawn: false,        },      },
      sass: {        files: [sass/**/*],        tasks: [sass_compile],        options: {          interrupt: false,          spawn: false,        },      }    },

      Concurrent    concurrent: {      options: {        logConcurrentOutput: true,        limit: 10,      },      monitor: {        tasks: [jade_compile, sass_compile, js_compile,                watch:jade, watch:js, watch:sass,                notify:watching, server]      },    },

      Notifications    notify: {      watching: {        options: {          enabled: true,          message: Watching Files!,          title: Materialize,  defaults to the name in package.json, or will use project directory's name          success: true,  whether successful grunt executions should be notified automatically          duration: 1  the duration of notification in seconds, for `notify-send only        }      },
      sass_compile: {        options: {          enabled: true,          message: Sass Compiled!,          title: Materialize,          success: true,          duration: 1        }      },
      js_compile: {        options: {          enabled: true,          message: JS Compiled!,          title: Materialize,          success: true,          duration: 1        }      },
      jade_compile: {        options: {          enabled: true,          message: Jade Compiled!,          title: Materialize,          success: true,          duration: 1        }      },
      server: {        options: {          enabled: true,          message: Server Running!,          title: Materialize,          success: true,          duration: 1        }      }    },
     Text Replace    replace: {      version: {  Does not edit README.md        src: [          bower.json,          package.json,          package.js,          jade/**/*.html        ],        overwrite: true,        replacements: [{          from: grunt.option( oldver ),          to: grunt.option( newver )        }]      },      readme: {  Changes README.md        src: [          README.md        ],        overwrite: true,        replacements: [{          from: Current Version : v+grunt.option( oldver ),          to: Current Version : v+grunt.option( newver )        }]      },    },
     Create Version Header for files    usebanner: {      release: {        options: {          position: top,          banner:  * Materialize v+ grunt.option( newver ) + (http://materializecss.com) * Copyright 2014-2015 Materialize * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE) */,          linebreak: true        },        files: {          src: [ dist/css/*.css, dist/js/*.js]        }      }    },
     Rename files    rename: {      rename_src: {        src: bin/materialize-src+.zip,        dest: bin/materialize-src-v+grunt.option( newver )+.zip,        options: {          ignore: true        }      },      rename_compiled: {        src: bin/materialize+.zip,        dest: bin/materialize-v+grunt.option( newver )+.zip,        options: {          ignore: true        }      },    },
     Removes console logs    removelogging: {      source: {        src: [js/**/*.js, !js/velocity.min.js],        options: {           see below for options. this is optional.        }      }    },  });
   load the tasks   grunt.loadNpmTasks('grunt-gitinfo');  grunt.loadNpmTasks(grunt-contrib-watch);  grunt.loadNpmTasks(grunt-contrib-copy);  grunt.loadNpmTasks(grunt-sass);  grunt.loadNpmTasks(grunt-contrib-concat);  grunt.loadNpmTasks(grunt-contrib-uglify);  grunt.loadNpmTasks(grunt-contrib-compress);  grunt.loadNpmTasks(grunt-contrib-clean);  grunt.loadNpmTasks(grunt-contrib-jade);  grunt.loadNpmTasks(grunt-concurrent);  grunt.loadNpmTasks(grunt-notify);  grunt.loadNpmTasks(grunt-text-replace);  grunt.loadNpmTasks(grunt-banner);  grunt.loadNpmTasks(grunt-rename);  grunt.loadNpmTasks(grunt-remove-logging);  grunt.loadNpmTasks(grunt-browser-sync);  grunt.loadNpmTasks(grunt-contrib-jasmine);  grunt.loadNpmTasks(grunt-postcss);   define the tasks  grunt.registerTask(    release,[      lint,      copy,      sass:expanded,      sass:min,      postcss:expended,      postcss:min,      concat:dist,      uglify:dist,      uglify:extras,      usebanner:release,      compress:main,      compress:src,      compress:starter_template,      compress:parallax_template,      replace:version,      replace:readme,      rename:rename_src,      rename:rename_compiled    ]  );
  grunt.registerTask(jade_compile, [jade, notify:jade_compile]);  grunt.registerTask(js_compile, [concat:temp, uglify:bin, notify:js_compile, clean:temp]);  grunt.registerTask(sass_compile, [sass:gh, sass:bin, postcss:gh, postcss:bin, notify:sass_compile]);  grunt.registerTask(server, [browserSync, notify:server]);  grunt.registerTask(lint, [removelogging:source]);  grunt.registerTask(monitor, [concurrent:monitor]);  grunt.registerTask(travis, [js_compile, sass_compile, jasmine]);};"
"import assignValue from ./.internal/assignValue.jsimport baseZipObject from ./.internal/baseZipObject.js
 * This method is like `fromPairs` except that it accepts two arrays, * one of property identifiers and one of corresponding values. * *  0.4.0 * @category Array *   ] The property identifiers. *   ] The property values. *   Returns the new object. *   unzipWith, zip, zipObjectDeep, zipWith *  * *  *  */function zipObject(props, values) {  return baseZipObject(props || [], values || [], assignValue)}
export default zipObject"
"import unzip from ./unzip.js
 * Creates an array of grouped elements, the first of which contains the * first elements of the given arrays, the second of which contains the * second elements of the given arrays, and so on. * *  0.1.0 * @category Array *    The arrays to process. *   Returns the new array of grouped elements. *   unzipWith, zipObject, zipObjectDeep, zipWith *  * *  *  */function zip(...arrays) {  return unzip(arrays)}
export default zip"
"import filter from ./filter.jsimport baseXor from ./.internal/baseXor.jsimport isArrayLikeObject from ./isArrayLikeObject.jsimport last from ./last.js
 * This method is like `xor` except that it accepts `comparator` which is * invoked to compare elements of `arrays`. The order of result values is * determined by the order they occur in the arrays. The comparator is invoked * with two arguments: (arrVal, othVal). * *  4.0.0 * @category Array *    The arrays to inspect. *    The comparator invoked per element. *   Returns the new array of filtered values. *   union, unionBy, unionWith, without, xor, xorBy *  * *  *  * *  *  */function xorWith(...arrays) {  let comparator = last(arrays)  comparator = typeof comparator == function ? comparator : undefined  return baseXor(filter(arrays, isArrayLikeObject), undefined, comparator)}
export default xorWith"
"import filter from ./filter.jsimport baseXor from ./.internal/baseXor.jsimport isArrayLikeObject from ./isArrayLikeObject.jsimport last from ./last.js
 * This method is like `xor` except that it accepts `iteratee` which is * invoked for each element of each `arrays` to generate the criterion by * which by which they're compared. The order of result values is determined * by the order they occur in the arrays. The iteratee is invoked with one * argument: (value). * *  4.0.0 * @category Array *    The arrays to inspect. *    The iteratee invoked per element. *   Returns the new array of filtered values. *   union, unionBy, unionWith, without, xor, xorWith *  * *  *  */function xorBy(...arrays) {  let iteratee = last(arrays)  if (isArrayLikeObject(iteratee)) {    iteratee = undefined  }  return baseXor(filter(arrays, isArrayLikeObject), iteratee)}
export default xorBy"
"import filter from ./filter.jsimport baseXor from ./.internal/baseXor.jsimport isArrayLikeObject from ./isArrayLikeObject.js
 * Creates an array of unique values that is the * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) * of the given arrays. The order of result values is determined by the order * they occur in the arrays. * *  2.4.0 * @category Array *    The arrays to inspect. *   Returns the new array of filtered values. *   union, unionBy, unionWith, without, xorBy, xorWith *  * *  *  */function xor(...arrays) {  return baseXor(filter(arrays, isArrayLikeObject))}
export default xor"
"import unicodeWords from ./.internal/unicodeWords.js
const asciiWords = RegExp.prototype.exec.bind(  g)
const hasUnicodeWord = RegExp.prototype.test.bind(  )
 * Splits `string` into an array of its words. * *  3.0.0 * @category String *    The string to inspect. *    The pattern to match words. *   Returns the words of `string`. *  * *  *  * *  *  */function words(string, pattern) {  if (pattern === undefined) {    const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string)    return result || []  }  return string.match(pattern) || []}
export default words"
"import baseDifference from ./.internal/baseDifference.jsimport isArrayLikeObject from ./isArrayLikeObject.js
 * Creates an array excluding all given values using * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * **Note:** Unlike `pull`, this method returns a new array. * *  0.1.0 * @category Array *    The array to inspect. *    The values to exclude. *   Returns the new array of filtered values. *   union, unionBy, unionWith, xor, xorBy, xorWith *  * *  *  */function without(array, ...values) {  return isArrayLikeObject(array) ? baseDifference(array, values) : []}
export default without"
"import baseValues from ./.internal/baseValues.jsimport keys from ./keys.js
 * Creates an array of the own enumerable string keyed property values of `object`. * * **Note:** Non-object values are coerced to objects. * *  0.1.0 * @category Object *    The object to query. *   Returns the array of property values. *   valuesIn *  * *  *    *    *  * *  * *  *  * *  *  */function values(object) {  return object == null ? [] : baseValues(object, keys(object))}
export default values"
"import createCaseFirst from ./.internal/createCaseFirst.js
 * Converts the first character of `string` to upper case. * *  4.0.0 * @category String *    The string to convert. *   Returns the converted string. *   kebabCase, lowerCase, snakeCase, startCase, upperCase *  * *  *  * *  *  */const upperFirst = createCaseFirst(toUpperCase)
export default upperFirst"
"import words from ./words.js
 * Converts `string`, as space separated words, to upper case. * *  4.0.0 * @category String *    The string to convert. *   Returns the upper cased string. *   kebabCase, lowerCase, snakeCase, startCase, upperFirst *  * *  *  * *  *  * *  *  */const upperCase = (string) => (  words(.replace(g, )).reduce((result, word, index) => (    result + (index ?   : ) + word.toUpperCase()  ), ))
export default upperCase"
"import baseUpdate from ./.internal/baseUpdate.js
 * This method is like `update` except that it accepts `customizer` which is * invoked to produce the objects of `path`. If `customizer` returns `undefined` * path creation is handled by the method instead. The `customizer` is invoked * with three arguments: (nsValue, key, nsObject). * * **Note:** This method mutates `object`. * *  4.6.0 * @category Object *    The object to modify. *    The path of the property to set. *    The function to produce the updated value. *    The function to customize assigned values. *   Returns `object`. *  * *  * *  *  */function updateWith(object, path, updater, customizer) {  customizer = typeof customizer == function ? customizer : undefined  return object == null ? object : baseUpdate(object, path, updater, customizer)}
export default updateWith"
"import baseUpdate from ./.internal/baseUpdate.js
 * This method is like `set` except that accepts `updater` to produce the * value to set. Use `updateWith` to customize `path` creation. The `updater` * is invoked with one argument: (value). * * **Note:** This method mutates `object`. * *  4.6.0 * @category Object *    The object to modify. *    The path of the property to set. *    The function to produce the updated value. *   Returns `object`. *  * *  * *  *  *  * *  *  *  */function update(object, path, updater) {  return object == null ? object : baseUpdate(object, path, updater)}
export default update"
"import map from ./map.jsimport unzip from ./unzip.js
 * This method is like `unzip` except that it accepts `iteratee` to specify * how regrouped values should be combined. The iteratee is invoked with the * elements of each group: (...group). * *  3.8.0 * @category Array *    The array of grouped elements to process. *    The function to combine *  regrouped values. *   Returns the new array of regrouped elements. *  * *  *  * *  *  */function unzipWith(array, iteratee) {  if (!(array != null && array.length)) {    return []  }  const result = unzip(array)  return map(result, (group) => iteratee.apply(undefined, group))}
export default unzipWith"
"import filter from ./filter.jsimport map from ./map.jsimport baseProperty from ./.internal/baseProperty.jsimport isArrayLikeObject from ./isArrayLikeObject.js
 * This method is like `zip` except that it accepts an array of grouped * elements and creates an array regrouping the elements to their pre-zip * configuration. * *  1.2.0 * @category Array *    The array of grouped elements to process. *   Returns the new array of regrouped elements. *   zip, zipObject, zipObjectDeep, zipWith *  * *  *  * *  *  */function unzip(array) {  if (!(array != null && array.length)) {    return []  }  let length = 0  array = filter(array, (group) => {    if (isArrayLikeObject(group)) {      length = Math.max(group.length, length)      return true    }  })  let index = -1  const result = new Array(length)  while (++index < length) {    result[index] = map(array, baseProperty(index))  }  return result}
export default unzip"
"import baseUnset from ./.internal/baseUnset.js
 * Removes the property at `path` of `object`. * * **Note:** This method mutates `object`. * *  4.0.0 * @category Object *    The object to modify. *    The path of the property to unset. *   Returns `true` if the property is deleted, else `false`. *   has, set *  * *  *  *  * *  *  * *  *  * *  *  */function unset(object, path) {  return object == null ? true : baseUnset(object, path)}
export default unset"
"let idCounter = 0
 * Generates a unique ID. If `prefix` is given, the ID is appended to it. * *  0.1.0 * @category Util *    The value to prefix the ID with. *   Returns the unique ID. *   *  * *  *  * *  *  */function uniqueId(prefix) {  const id = ++idCounter  return }
export default uniqueId"
"import baseUniq from ./.internal/baseUniq.js
 * This method is like `uniq` except that it accepts `comparator` which * is invoked to compare elements of `array`. The order of result values is * determined by the order they occur in the array.The comparator is invoked * with two arguments: (arrVal, othVal). * *  4.0.0 * @category Array *    The array to inspect. *    The comparator invoked per element. *   Returns the new duplicate free array. *   uniqBy *  * *  * *  *  */function uniqWith(array, comparator) {  comparator = typeof comparator == function ? comparator : undefined  return (array != null && array.length)    ? baseUniq(array, undefined, comparator)    : []}
export default uniqWith"
"import baseUniq from ./.internal/baseUniq.js
 * This method is like `uniq` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * uniqueness is computed. The order of result values is determined by the * order they occur in the array. The iteratee is invoked with one argument: * (value). * *  4.0.0 * @category Array *    The array to inspect. *    The iteratee invoked per element. *   Returns the new duplicate free array. *   uniqWith *  * *  *  */function uniqBy(array, iteratee) {  return (array != null && array.length)    ? baseUniq(array, iteratee)    : []}
export default uniqBy"
"import baseUniq from ./.internal/baseUniq.js
 * Creates a duplicate-free version of an array, using * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons, in which only the first occurrence of each element * is kept. The order of result values is determined by the order they occur * in the array. * *  0.1.0 * @category Array *    The array to inspect. *   Returns the new duplicate free array. *   uniqWith *  * *  *  */function uniq(array) {  return (array != null && array.length)    ? baseUniq(array)    : []}
export default uniq"
"import baseFlatten from ./.internal/baseFlatten.jsimport baseUniq from ./.internal/baseUniq.jsimport isArrayLikeObject from ./isArrayLikeObject.jsimport last from ./last.js
 * This method is like `union` except that it accepts `comparator` which * is invoked to compare elements of `arrays`. Result values are chosen from * the first array in which the value occurs. The comparator is invoked * with two arguments: (arrVal, othVal). * *  4.0.0 * @category Array *    The arrays to inspect. *    The comparator invoked per element. *   Returns the new array of combined values. *   union, unionBy, without, xor, xorBy *  * *  *  * *  *  */function unionWith(...arrays) {  let comparator = last(arrays)  comparator = typeof comparator == function ? comparator : undefined  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator)}
export default unionWith"
"import baseFlatten from ./.internal/baseFlatten.jsimport baseUniq from ./.internal/baseUniq.jsimport isArrayLikeObject from ./isArrayLikeObject.jsimport last from ./last.js
 * This method is like `union` except that it accepts `iteratee` which is * invoked for each element of each `arrays` to generate the criterion by * which uniqueness is computed. Result values are chosen from the first * array in which the value occurs. The iteratee is invoked with one argument: * (value). * *  4.0.0 * @category Array *    The arrays to inspect. *    The iteratee invoked per element. *   Returns the new array of combined values. *   union, unionWith, without, xor, xorBy *  * *  *  */function unionBy(...arrays) {  let iteratee = last(arrays)  if (isArrayLikeObject(iteratee)) {    iteratee = undefined  }  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), iteratee)}
export default unionBy"
"import baseFlatten from ./.internal/baseFlatten.jsimport baseUniq from ./.internal/baseUniq.jsimport isArrayLikeObject from ./isArrayLikeObject.js
 * Creates an array of unique values, in order, from all given arrays using * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * *  0.1.0 * @category Array *    The arrays to inspect. *   Returns the new array of combined values. *   unionBy, unionWith, without, xor, xorBy *  * *  *  */function union(...arrays) {  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true))}
export default union"
"const htmlUnescapes = {  &amp;: &,  &lt;: <,  &gt;: >,  &quot;: "",  &#39;: '}
const reEscapedHtml = &(?:ampltgtquot#39);gconst reHasEscapedHtml = RegExp(reEscapedHtml.source)
 * The inverse of `escape`this method converts the HTML entities * `&amp;`, `&lt;`, `&gt;`, `&quot;` and `&#39;` in `string` to * their corresponding characters. * * **Note:** No other HTML entities are unescaped. To unescape additional * HTML entities use a third-party library like [_he_](https://mths.be/he). * *  0.6.0 * @category String *    The string to unescape. *   Returns the unescaped string. *   escapeRegExp *  * *  *  */function unescape(string) {  return (string && reHasEscapedHtml.test(string))    ? string.replace(reEscapedHtml, (entity) => htmlUnescapes[entity])    : string}
export default unescape"
"import baseToString from ./.internal/baseToString.jsimport castSlice from ./.internal/castSlice.jsimport hasUnicode from ./.internal/hasUnicode.jsimport isObject from ./isObject.jsimport isRegExp from ./isRegExp.jsimport stringSize from ./.internal/stringSize.jsimport stringToArray from ./.internal/stringToArray.js
const DEFAULT_TRUNC_LENGTH = 30const DEFAULT_TRUNC_OMISSION = ...
const reFlags = 
 * Truncates `string` if it's longer than the given maximum string length. * The last characters of the truncated string are replaced with the omission * string which defaults to ""..."". * *  4.0.0 * @category String *    The string to truncate. *    The options object. *    The maximum string length. *    The string to indicate text is omitted. *    The separator pattern to truncate to. *   Returns the truncated string. *   *  * *  *  * *  *    *    *  *  * *  *    *    *  *  * *  *    *  *  */function truncate(string, options) {  let separator  let length = DEFAULT_TRUNC_LENGTH  let omission = DEFAULT_TRUNC_OMISSION
  if (isObject(options)) {    separator = separator in options ? options.separator : separator    length = length in options ? options.length : length    omission = omission in options ? baseToString(options.omission) : omission  }  let strSymbols  let strLength = string.length  if (hasUnicode(string)) {    strSymbols = stringToArray(string)    strLength = strSymbols.length  }  if (length >= strLength) {    return string  }  let end = length - stringSize(omission)  if (end < 1) {    return omission  }  let result = strSymbols    ? castSlice(strSymbols, 0, end).join()    : string.slice(0, end)
  if (separator === undefined) {    return result + omission  }  if (strSymbols) {    end += (result.length - end)  }  if (isRegExp(separator)) {    if (string.slice(end).search(separator)) {      let match      let newEnd      const substring = result
      if (!separator.global) {        separator = RegExp(separator.source, g)      }      separator.lastIndex = 0      while ((match = separator.exec(substring))) {        newEnd = match.index      }      result = result.slice(0, newEnd === undefined ? end : newEnd)    }  } else if (string.indexOf(baseToString(separator), end) != end) {    const index = result.lastIndexOf(separator)    if (index > -1) {      result = result.slice(0, index)    }  }  return result + omission}
export default truncate"
"import castSlice from ./.internal/castSlice.jsimport charsStartIndex from ./.internal/charsStartIndex.jsimport stringToArray from ./.internal/stringToArray.js
const methodName =  .trimLeft ? trimLeft : trimStart
 * Removes leading whitespace or specified characters from `string`. * *  4.0.0 * @category String *    The string to trim. *    The characters to trim. *   Returns the trimmed string. *   trimEnd *  * *  *  * *  *  */function trimStart(string, chars) {  if (string && chars === undefined) {    return string[methodName]()  }  if (!string || !chars) {    return string  }  const strSymbols = stringToArray(string)  const start = charsStartIndex(strSymbols, stringToArray(chars))  return castSlice(strSymbols, start).join()}
export default trimStart"
"import castSlice from ./.internal/castSlice.jsimport charsEndIndex from ./.internal/charsEndIndex.jsimport stringToArray from ./.internal/stringToArray.js
const methodName = .trimRight ? trimRight: trimEnd
 * Removes trailing whitespace or specified characters from `string`. * *  4.0.0 * @category String *    The string to trim. *    The characters to trim. *   Returns the trimmed string. *   trimStart *  * *  *  * *  *  */function trimEnd(string, chars) {  if (string && chars === undefined) {    return string[methodName]()  }  if (!string || !chars) {    return string  }  const strSymbols = stringToArray(string)  const end = charsEndIndex(strSymbols, stringToArray(chars)) + 1  return castSlice(strSymbols, 0, end).join()}
export default trimEnd"
"import castSlice from ./.internal/castSlice.jsimport charsEndIndex from ./.internal/charsEndIndex.jsimport charsStartIndex from ./.internal/charsStartIndex.jsimport stringToArray from ./.internal/stringToArray.js
 * Removes leading and trailing whitespace or specified characters from `string`. * *  3.0.0 * @category String *    The string to trim. *    The characters to trim. *   Returns the trimmed string. *   trimStart *  * *  *  * *  *  * *  *  */function trim(string, chars) {  if (string && chars === undefined) {    return string.trim()  }  if (!string || !chars) {    return string  }  const strSymbols = stringToArray(string)  const chrSymbols = stringToArray(chars)  const start = charsStartIndex(strSymbols, chrSymbols)  const end = charsEndIndex(strSymbols, chrSymbols) + 1
  return castSlice(strSymbols, start, end).join()}
export default trim"
"import arrayEach from ./.internal/arrayEach.jsimport baseForOwn from ./.internal/baseForOwn.jsimport isBuffer from ./isBuffer.jsimport isObject from ./isObject.jsimport isTypedArray from ./isTypedArray.js
 * An alternative to `reduce` this method transforms `object` to a new * `accumulator` object which is the result of running each of its own * enumerable string keyed properties thru `iteratee`, with each invocation * potentially mutating the `accumulator` object. If `accumulator` is not * provided, a new object with the same `[[Prototype]]` will be used. The * iteratee is invoked with four arguments: (accumulator, value, key, object). * Iteratee functions may exit iteration early by explicitly returning `false`. * *  1.3.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *    The custom accumulator value. *   Returns the accumulated value. *   reduceRight *  * *  *    *    *  *  * *  *    *  *  */function transform(object, iteratee, accumulator) {  const isArr = Array.isArray(object)  const isArrLike = isArr || isBuffer(object) || isTypedArray(object)
  if (accumulator == null) {    const Ctor = object && object.constructor    if (isArrLike) {      accumulator = isArr ? new Ctor : []    }    else if (isObject(object)) {      accumulator = typeof Ctor == function        ? Object.create(Object.getPrototypeOf(object))        : {}    }    else {      accumulator = {}    }  }  (isArrLike ? arrayEach : baseForOwn)(object, (value, index, object) =>    iteratee(accumulator, value, index, object))  return accumulator}
export default transform"
"import map from ./map.jsimport isSymbol from ./isSymbol.js
const INFINITY = 1 / 0
const symbolProto = Symbol ? Symbol.prototype : undefinedconst symbolToString = symbolProto ? symbolProto.toString : undefined
 * Converts `value` to a string. An empty string is returned for `null` * and `undefined` values. The sign of `-0` is preserved. * *  4.0.0 * @category Lang *    The value to convert. *   Returns the converted string. *  * *  *  * *  *  * *  *  */function toString(value) {  if (value == null) {    return   }   Exit early for strings to avoid a performance hit in some environments.  if (typeof value == string) {    return value  }  if (Array.isArray(value)) {     Recursively convert values (susceptible to call stack limits).    return   }  if (isSymbol(value)) {    return symbolToString ? symbolToString.call(value) :   }  const result =   return (result == 0 && (1 / value) == -INFINITY) ? -0 : result}
export default toString"
"import toInteger from ./toInteger.js
const MAX_SAFE_INTEGER = 9007199254740991
 * Converts `value` to a safe integer. A safe integer can be compared and * represented correctly. * *  4.0.0 * @category Lang *    The value to convert. *   Returns the converted integer. *  * *  *  * *  *  * *  *  * *  *  */function toSafeInteger(value) {  if (!value) {    return value === 0 ? value : 0  }  value = toInteger(value)  if (value < -MAX_SAFE_INTEGER) {    return -MAX_SAFE_INTEGER  }  if (value > MAX_SAFE_INTEGER) {    return MAX_SAFE_INTEGER  }  return value}
export default toSafeInteger"
" * Converts `value` to a plain object flattening inherited enumerable string * keyed properties of `value` to own properties of the plain object. * *  3.0.0 * @category Lang *    The value to convert. *   Returns the converted plain object. *  * *  *    *  * *  * *  *  * *  *  */function toPlainObject(value) {  value = Object(value)  const result = {}  for (const key in value) {    result[key] = value[value]  }  return result}
export default toPlainObject"
"import map from ./map.jsimport copyArray from ./.internal/copyArray.jsimport isSymbol from ./isSymbol.jsimport stringToPath from ./.internal/stringToPath.jsimport toKey from ./.internal/toKey.js
 * Converts `value` to a property path array. * *  4.0.0 * @category Util *    The value to convert. *   Returns the new property path array. *  * *  *  * *  *  */function toPath(value) {  if (Array.isArray(value)) {    return map(value, toKey)  }  return isSymbol(value) ? [value] : copyArray(stringToPath(value))}
export default toPath"
"import isObject from ./isObject.jsimport isSymbol from ./isSymbol.js
const NAN = 0 / 0
const reTrim = g
const reIsBadHex = 0xi
const reIsBinary = 0bi
const reIsOctal = 0oi
const freeParseInt = parseInt
 * Converts `value` to a number. * *  4.0.0 * @category Lang *    The value to process. *   Returns the number. *   toInteger, isNumber *  * *  *  * *  *  * *  *  * *  *  */function toNumber(value) {  if (typeof value == number) {    return value  }  if (isSymbol(value)) {    return NAN  }  if (isObject(value)) {    const other = typeof value.valueOf == function ? value.valueOf() : value    value = isObject(other) ?  : other  }  if (typeof value != string) {    return value === 0 ? value : +value  }  value = value.replace(reTrim, )  const isBinary = reIsBinary.test(value)  return (isBinary || reIsOctal.test(value))    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)    : (reIsBadHex.test(value) ? NAN : +value)}
export default toNumber"
"import toInteger from ./toInteger.js
const MAX_ARRAY_LENGTH = 4294967295
 * Converts `value` to an integer suitable for use as the length of an * array-like object. * * **Note:** This method is based on * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * *  4.0.0 * @category Lang *    The value to convert. *   Returns the converted integer. *  * *  *  * *  *  * *  *  * *  *  */function toLength(value) {  if (!value) {    return 0  }  value = toInteger(value)  if (value < 0) {    return 0  }  if (value > MAX_ARRAY_LENGTH) {    return MAX_ARRAY_LENGTH  }  return value}
export default toLength"
"import toFinite from ./toFinite.js
 * Converts `value` to an integer. * * **Note:** This method is loosely based on * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger). * *  4.0.0 * @category Lang *    The value to convert. *   Returns the converted integer. *   isNumber, toNumber *  * *  *  * *  *  * *  *  * *  *  */function toInteger(value) {  const result = toFinite(value)  const remainder = result % 1
  return result === result ? (remainder ? result - remainder : result) : 0}
export default toInteger"
"import toNumber from ./toNumber.js
const INFINITY = 1 / 0const MAX_INTEGER = 1.7976931348623157e+308
 * Converts `value` to a finite number. * *  4.12.0 * @category Lang *    The value to convert. *   Returns the converted number. *  * *  *  * *  *  * *  *  * *  *  */function toFinite(value) {  if (!value) {    return value === 0 ? value : 0  }  value = toNumber(value)  if (value === INFINITY || value === -INFINITY) {    const sign = (value < 0 ? -1 : 1)    return sign  MAX_INTEGER  }  return value === value ? value : 0}
export default toFinite"
"import copyArray from ./.internal/copyArray.jsimport getTag from ./.internal/getTag.jsimport isArrayLike from ./isArrayLike.jsimport isString from ./isString.jsimport iteratorToArray from ./.internal/iteratorToArray.jsimport mapToArray from ./.internal/mapToArray.jsimport setToArray from ./.internal/setToArray.jsimport stringToArray from ./.internal/stringToArray.jsimport values from ./values.js
const mapTag = [object Map]const setTag = [object Set]
const symIterator = Symbol ? Symbol.iterator : undefined
 * Converts `value` to an array. * *  0.1.0 * @category Lang *    The value to convert. *   Returns the converted array. *  * *  *  * *  *  * *  *  * *  *  */function toArray(value) {  if (!value) {    return []  }  if (isArrayLike(value)) {    return isString(value) ? stringToArray(value) : copyArray(value)  }  if (symIterator && value[symIterator]) {    return iteratorToArray(value[symIterator]())  }  const tag = getTag(value)  const func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values)
  return func(value)}
export default toArray"
"const MAX_SAFE_INTEGER = 9007199254740991
const MAX_ARRAY_LENGTH = 4294967295
 * Invokes the iteratee `n` times, returning an array of the results of * each invocation. The iteratee is invoked with one argumentindex). * *  0.1.0 * @category Util *    The number of times to invoke `iteratee`. *    The function invoked per iteration. *   Returns the array of results. *  * *  *  * *   *  */function times(n, iteratee) {  if (n < 1 || n > MAX_SAFE_INTEGER) {    return []  }  let index = -1  const length = Math.min(n, MAX_ARRAY_LENGTH)  const result = new Array(length)  while (++index < length) {    result[index] = iteratee(index)  }  index = MAX_ARRAY_LENGTH  n -= MAX_ARRAY_LENGTH  while (++index < n) {    iteratee(index)  }  return result}
export default times"
"import debounce from ./debounce.jsimport isObject from ./isObject.js
 * Creates a throttled function that only invokes `func` at most once per * every `wait` milliseconds. The throttled function comes with a `cancel` * method to cancel delayed `func` invocations and a `flush` method to * immediately invoke them. Provide `options` to indicate whether `func` * should be invoked on the leading and/or trailing edge of the `wait` * timeout. The `func` is invoked with the last arguments provided to the * throttled function. Subsequent calls to the throttled function return the * result of the last `func` invocation. * * **Note:** If `leading` and `trailing` options are `true`, `func` is * invoked on the trailing edge of the timeout only if the throttled function * is invoked more than once during the `wait` timeout. * * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred * until to the next tick, similar to `setTimeout` with a timeout of `0`. * * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) * for details over the differences between `throttle` and `debounce`. * *  0.1.0 * @category Function *    The function to throttle. *    The number of milliseconds to throttle invocations to. *    The options object. *    *  Specify invoking on the leading edge of the timeout. *    *  Specify invoking on the trailing edge of the timeout. *   Returns the new throttled function. *  * *  *  * *  *  *  * *  *  */function throttle(func, wait, options) {  let leading = true  let trailing = true
  if (typeof func != function) {    throw new TypeError(Expected a function)  }  if (isObject(options)) {    leading = leading in options ? !!options.leading : leading    trailing = trailing in options ? !!options.trailing : trailing  }  return debounce(func, wait, {    leading: leading,    maxWait: wait,    trailing: trailing  })}
export default throttle"
"import escape from ./escape.jsimport reEscape from ./.internal/reEscape.jsimport reEvaluate from ./.internal/reEvaluate.jsimport reInterpolate from ./.internal/reInterpolate.js
 * By default, the template delimiters used by lodash are like those in * embedded Ruby (ERB) as well as ES2015 template strings. Change the * following template settings to use alternative delimiters. * *   */const templateSettings = {
     * Used to detect `data` property values to be HTML-escaped.   *   * @memberOf templateSettings   *     */  escape: reEscape,
     * Used to detect code to be evaluated.   *   * @memberOf templateSettings   *     */  evaluate: reEvaluate,
     * Used to detect `data` property values to inject.   *   * @memberOf templateSettings   *     */  interpolate: reInterpolate,
     * Used to reference the data object in the template text.   *   * @memberOf templateSettings   *     */  variable: ,
     * Used to import variables into the compiled template.   *   * @memberOf templateSettings   *     */  imports: {
         * A reference to the `lodash` function.     *     * @memberOf templateSettings.imports     *       */    _: { escape: escape }  }}
export default templateSettings"
"import assignInWith from ./assignInWith.jsimport attempt from ./attempt.jsimport baseValues from ./.internal/baseValues.jsimport customDefaultsAssignIn from ./.internal/customDefaultsAssignIn.jsimport isError from ./isError.jsimport keys from ./keys.jsimport reInterpolate from ./.internal/reInterpolate.jsimport templateSettings from ./templateSettings.js
const reEmptyStringLeading = __p = '';gconst reEmptyStringMiddle = (__p =) '' gconst reEmptyStringTrailing = (__e__t) '';g
 * Used to match * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components). */const reEsTemplate = ((?:))g
const reNoMatch = ()
const reUnescapedString = g
const stringEscapes = {  : ,  ': ',  : n,  : r,  : u2028,  : u2029}
 * Creates a compiled template function that can interpolate data properties * in ""interpolate"" delimiters, HTML-escape interpolated data properties in * ""escape"" delimiters, and execute JavaScript in ""evaluate"" delimiters. Data * properties may be accessed as free variables in the template. If a setting * object is given, it takes precedence over `templateSettings` values. * * **Note:** In the development build `template` utilizes * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) * for easier debugging. * * For more information on precompiling templates see * [lodash's custom builds documentation](https://lodash.com/custom-builds). * * For more information on Chrome extension sandboxes see * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). * *  0.1.0 * @category String *    The template string. *    The options object. *    *  The HTML ""escape"" delimiter. *    *  The ""evaluate"" delimiter. *    *  An object to import into the template as free variables. *    *  The ""interpolate"" delimiter. *   '] *  The sourceURL of the compiled template. *    *  The data object variable name. *   Returns the compiled template function. *  * *  *  *  *  * *  *  *  *  * *  *  *  *  * *  *  *  *  * *  *  *  *  *  * *  *  *  *  * *  *  *  *  *  * *  *  *  *  * *  *  *  *  *  *  *  *  * *  *  *  *  *  * *  *  *  *    *      *    *  */function template(string, options) {   Based on John Resig's `tmpl` implementation   (http://ejohn.org/blog/javascript-micro-templating/)   and Laura Doktorova's doT.js (https://github.com/olado/doT).  const settings = templateSettings.imports.templateSettings || templateSettings
  options = assignInWith({}, options, settings, customDefaultsAssignIn)
  const imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn)  const importsKeys = keys(imports)  const importsValues = baseValues(imports, importsKeys)
  let isEscaping  let isEvaluating  let index = 0
  const interpolate = options.interpolate || reNoMatch  let source = __p += '
   Compile the regexp to match each delimiter.  const reDelimiters = RegExp(|$, g)
   Use a sourceURL for easier debugging.  const sourceURL = sourceURL in options    ?     : 
  string.replace(reDelimiters, (    match,    escapeValue,    interpolateValue,    esTemplateValue,    evaluateValue,    offset  ) => {    interpolateValue || (interpolateValue = esTemplateValue)
     Escape characters that can't be included in string literals.    source += string      .slice(index, offset)      .replace(reUnescapedString, (chr) => )
     Replace delimiters with snippets.    if (escapeValue) {      isEscaping = true      source += ' +__e() +'    }    if (evaluateValue) {      isEvaluating = true      source += ';;__p += '    }    if (interpolateValue) {      source += ' +((__t = ()) == null ? '' : __t) +'    }    index = offset + match.length
     The JS engine embedded in Adobe products needs `match` returned in     order to produce the correct `offset` value.    return match  })
  source += ';
   If `variable` is not specified wrap a with-statement around the generated   code to add the data object to the top of the scope chain.  const variable = options.variable  if (!variable) {    source = with (obj) {}  }   Cleanup code by stripping empty strings.  source = (isEvaluating ? source.replace(reEmptyStringLeading, ) : source)    .replace(reEmptyStringMiddle, $1)    .replace(reEmptyStringTrailing, $1;)
   Frame code as the function body.  source = function() { +     +    var __t, __p = '' +     +     +     return __p;}
  const result = attempt(() => (    Function(importsKeys, return ))(...importsValues)  )
   Provide the compiled function's source by its `toString` method or   the `source` property as a convenience for inlining compiled templates.  result.source = source  if (isError(result)) {    throw result  }  return result}
export default template"
"import baseWhile from ./.internal/baseWhile.js
 * Creates a slice of `array` with elements taken from the beginning. Elements * are taken until `predicate` returns falsey. The predicate is invoked with * three arguments: (value, index, array). * *  3.0.0 * @category Array *    The array to query. *    The function invoked per iteration. *   Returns the slice of `array`. *  * *  *    *    *    *  * *  *  */function takeWhile(array, predicate) {  return (array != null && array.length)    ? baseWhile(array, predicate)    : []}
export default takeWhile"
"import baseWhile from ./.internal/baseWhile.js
 * Creates a slice of `array` with elements taken from the end. Elements are * taken until `predicate` returns falsey. The predicate is invoked with * three arguments: (value, index, array). * *  3.0.0 * @category Array *    The array to query. *    The function invoked per iteration. *   Returns the slice of `array`. *  * *  *    *    *    *  * *  *  */function takeRightWhile(array, predicate) {  return (array != null && array.length)    ? baseWhile(array, predicate, false, true)    : []}
export default takeRightWhile"
"import slice from ./slice.js
 * Creates a slice of `array` with `n` elements taken from the end. * *  3.0.0 * @category Array *    The array to query. *    The number of elements to take. *   Returns the slice of `array`. *  * *  *  * *  *  * *  *  * *  *  */function takeRight(array, n=1) {  const length = array == null ? 0 : array.length  if (!length) {    return []  }  n = length - n  return slice(array, n < 0 ? 0 : n, length)}
export default takeRight"
"import slice from ./slice.js
 * Creates a slice of `array` with `n` elements taken from the beginning. * *  0.1.0 * @category Array *    The array to query. *    The number of elements to take. *   Returns the slice of `array`. *  * *  *  * *  *  * *  *  * *  *  */function take(array, n=1) {  if (!(array != null && array.length)) {    return []  }  return slice(array, 0, n < 0 ? 0 : n)}
export default take"
" * Gets all but the first element of `array`. * *  4.0.0 * @category Array *    The array to query. *   Returns the slice of `array`. *  * *  *  */function tail(array) {  const length = array == null ? 0 : array.length  if (!length) {    return []  }  const [head, ...result] = array  return result}
export default tail"
"import baseSum from ./.internal/baseSum.js
 * This method is like `sum` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be summed. * The iteratee is invoked with one argument: (value). * *  4.0.0 * @category Math *    The array to iterate over. *    The iteratee invoked per element. *   Returns the sum. *  * *  * *  *  */function sumBy(array, iteratee) {  return (array != null && array.length)    ? baseSum(array, iteratee)    : 0}
export default sumBy"
"import baseSum from ./.internal/baseSum.js
 * Computes the sum of the values in `array`. * *  3.4.0 * @category Math *    The array to iterate over. *   Returns the sum. *  * *  *  */function sum(array) {  return (array != null && array.length)    ? baseSum(array, (value) => value)    : 0}
export default sum"
"import createMathOperation from ./.internal/createMathOperation.js
 * Subtract two numbers. * *  4.0.0 * @category Math *    The first number in a subtraction. *    The second number in a subtraction. *   Returns the difference. *  * *  *  */const subtract = createMathOperation((minuend, subtrahend) => minuend - subtrahend, 0)
export default subtract"
" * Checks if `string` starts with the given target string. * *  3.0.0 * @category String *    The string to inspect. *    The string to search for. *    The position to search from. *   Returns `true` if `string` starts with `target`, *  else `false`. *   includes *  * *  *  * *  *  * *  *  */function startsWith(string, target, position) {  const { length } = string  position = position == null ? 0 : position  if (position < 0) {    position = 0  }  else if (position > length) {    position = length  }  target =   return string.slice(position, position + target.length) == target}
export default startsWith"
"import upperFirst from ./upperFirst.jsimport words from ./words.js
 * Converts `string` to * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). * *  3.1.0 * @category String *    The string to convert. *   Returns the start cased string. *   lowerCase, kebabCase, snakeCase, upperCase, upperFirst *  * *  *  * *  *  * *  *  */const startCase = (string) => (  words(.replace(g, )).reduce((result, word, index) => (    result + (index ?   : ) + upperFirst(word)  ), ))
export default startCase"
"import castSlice from ./.internal/castSlice.jsimport hasUnicode from ./.internal/hasUnicode.jsimport isRegExp from ./isRegExp.jsimport stringToArray from ./.internal/stringToArray.js
const MAX_ARRAY_LENGTH = 4294967295
 * Splits `string` by `separator`. * * **Note:** This method is based on * [`String#split`](https://mdn.io/String/split). * *  4.0.0 * @category String *    The string to split. *    The separator pattern to split by. *    The length to truncate results to. *   Returns the string segments. *  * *  *  */function split(string, separator, limit) {  limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0  if (!limit) {    return []  }  if (string && (        typeof separator == string ||        (separator != null && !isRegExp(separator))      )) {    if (!separator && hasUnicode(string)) {      return castSlice(stringToArray(string), 0, limit)    }  }  return string.split(separator, limit)}
export default split"
"import baseSortedUniq from ./.internal/baseSortedUniq.js
 * This method is like `uniqBy` except that it's designed and optimized * for sorted arrays. * *  4.0.0 * @category Array *    The array to inspect. *    The iteratee invoked per element. *   Returns the new duplicate free array. *  * *  *  */function sortedUniqBy(array, iteratee) {  return (array != null && array.length)    ? baseSortedUniq(array, iteratee)    : []}
export default sortedUniqBy"
"import baseSortedUniq from ./.internal/baseSortedUniq.js
 * This method is like `uniq` except that it's designed and optimized * for sorted arrays. * *  4.0.0 * @category Array *    The array to inspect. *   Returns the new duplicate free array. *  * *  *  */function sortedUniq(array) {  return (array != null && array.length)    ? baseSortedUniq(array)    : []}
export default sortedUniq"
"import baseSortedIndex from ./.internal/baseSortedIndex.jsimport eq from ./eq.js
 * This method is like `lastIndexOf` except that it performs a binary * search on a sorted `array`. * *  4.0.0 * @category Array *    The array to inspect. *    The value to search for. *   Returns the index of the matched value, else `-1`. *  * *  *  */function sortedLastIndexOf(array, value) {  const length = array == null ? 0 : array.length  if (length) {    const index = baseSortedIndex(array, value, true) - 1    if (eq(array[index], value)) {      return index    }  }  return -1}
export default sortedLastIndexOf"
"import baseSortedIndexBy from ./.internal/baseSortedIndexBy.js
 * This method is like `sortedLastIndex` except that it accepts `iteratee` * which is invoked for `value` and each element of `array` to compute their * sort ranking. The iteratee is invoked with one argument: (value). * *  4.0.0 * @category Array *    The sorted array to inspect. *    The value to evaluate. *    The iteratee invoked per element. *   Returns the index at which `value` should be inserted *  into `array`. *  * *  * *  *  */function sortedLastIndexBy(array, value, iteratee) {  return baseSortedIndexBy(array, value, iteratee, true)}
export default sortedLastIndexBy"
"import baseSortedIndex from ./.internal/baseSortedIndex.js
 * This method is like `sortedIndex` except that it returns the highest * index at which `value` should be inserted into `array` in order to * maintain its sort order. * *  3.0.0 * @category Array *    The sorted array to inspect. *    The value to evaluate. *   Returns the index at which `value` should be inserted *  into `array`. *  * *  *  */function sortedLastIndex(array, value) {  return baseSortedIndex(array, value, true)}
export default sortedLastIndex"
"import baseSortedIndex from ./.internal/baseSortedIndex.jsimport eq from ./eq.js
 * This method is like `indexOf` except that it performs a binary * search on a sorted `array`. * *  4.0.0 * @category Array *    The array to inspect. *    The value to search for. *   Returns the index of the matched value, else `-1`. *  * *  *  */function sortedIndexOf(array, value) {  const length = array == null ? 0 : array.length  if (length) {    const index = baseSortedIndex(array, value)    if (index < length && eq(array[index], value)) {      return index    }  }  return -1}
export default sortedIndexOf"
"import baseSortedIndexBy from ./.internal/baseSortedIndexBy.js
 * This method is like `sortedIndex` except that it accepts `iteratee` * which is invoked for `value` and each element of `array` to compute their * sort ranking. The iteratee is invoked with one argument: (value). * *  4.0.0 * @category Array *    The sorted array to inspect. *    The value to evaluate. *    The iteratee invoked per element. *   Returns the index at which `value` should be inserted *  into `array`. *  * *  * *  *  */function sortedIndexBy(array, value, iteratee) {  return baseSortedIndexBy(array, value, iteratee)}
export default sortedIndexBy"
"import baseSortedIndex from ./.internal/baseSortedIndex.js
 * Uses a binary search to determine the lowest index at which `value` * should be inserted into `array` in order to maintain its sort order. * *  0.1.0 * @category Array *    The sorted array to inspect. *    The value to evaluate. *   Returns the index at which `value` should be inserted *  into `array`. *  * *  *  */function sortedIndex(array, value) {  return baseSortedIndex(array, value)}
export default sortedIndex"
" * Checks if `predicate` returns truthy for **any** element of `object`. * Iteration is stopped once `predicate` returns truthy. The predicate is * invoked with three arguments: (value, key, object). * *  5.0.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   Returns `true` if any element passes the predicate check, *  else `false`. *  * *  *  */function someValues(object, predicate) {  object = Object(object)  const props = Object.keys(object)
  for (const key of props) {    if (predicate(object[key], key, object)) {      return true    }  }  return false}
export default someValues"
" * Checks if `predicate` returns truthy for **any** element of `array`. * Iteration is stopped once `predicate` returns truthy. The predicate is * invoked with three arguments: (value, index, array). * *  5.0.0 * @category Array *    The array to iterate over. *    The function invoked per iteration. *   Returns `true` if any element passes the predicate check, *  else `false`. *  * *  *  */function some(array, predicate) {  let index = -1  const length = array == null ? 0 : array.length
  while (++index < length) {    if (predicate(array[index], index, array)) {      return true    }  }  return false}
export default some"
"import words from ./words.js
 * Converts `string` to * [snake case](https://en.wikipedia.org/wiki/Snake_case). * *  3.0.0 * @category String *    The string to convert. *   Returns the snake cased string. *   lowerCase, kebabCase, startCase, upperCase, upperFirst *  * *  *  * *  *  * *  *  */const snakeCase = (string) => (  words(.replace(g, )).reduce((result, word, index) => (    result + (index ? _ : ) + word.toLowerCase()  ), ))
export default snakeCase"
" * Creates a slice of `array` from `start` up to, but not including, `end`. * * **Note:** This method is used instead of * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are * returned. * *  3.0.0 * @category Array *    The array to slice. *    The start position. *    The end position. *   Returns the slice of `array`. */function slice(array, start, end) {  let length = array == null ? 0 : array.length  if (!length) {    return []  }  start = start == null ? 0 : start  end = end === undefined ? length : end
  if (start < 0) {    start = -start > length ? 0 : (length + start)  }  end = end > length ? length : end  if (end < 0) {    end += length  }  length = start > end ? 0 : ((end - start) >>> 0)  start >>>= 0
  let index = -1  const result = new Array(length)  while (++index < length) {    result[index] = array[index + start]  }  return result}
export default slice"
"import getTag from ./.internal/getTag.jsimport isArrayLike from ./isArrayLike.jsimport isString from ./isString.jsimport stringSize from ./.internal/stringSize.js
const mapTag = [object Map]const setTag = [object Set]
 * Gets the size of `collection` by returning its length for array-like * values or the number of own enumerable string keyed properties for objects. * *  0.1.0 * @category Collection *    The collection to inspect. *   Returns the collection size. *  * *  *  * *  *  * *  *  */function size(collection) {  if (collection == null) {    return 0  }  if (isArrayLike(collection)) {    return isString(collection) ? stringSize(collection) : collection.length  }  const tag = getTag(collection)  if (tag == mapTag || tag == setTag) {    return collection.size  }  return Object.keys(collection).length}
export default size"
"import copyArray from ./.internal/copyArray.js
 * Creates an array of shuffled values, using a version of the * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle). * *  0.1.0 * @category Array *    The array to shuffle. *   Returns the new shuffled array. *  * *  *  */function shuffle(array) {  const length = array == null ? 0 : array.length  if (!length) {    return []  }  let index = -1  const lastIndex = length - 1  const result = copyArray(array)  while (++index < length) {    const rand = index + Math.floor(Math.random()  (lastIndex - index + 1))    const value = result[rand]    result[rand] = result[index]    result[index] = value  }  return result}
export default shuffle"
"import baseSet from ./.internal/baseSet.js
 * This method is like `set` except that it accepts `customizer` which is * invoked to produce the objects of `path`. If `customizer` returns `undefined` * path creation is handled by the method instead. The `customizer` is invoked * with three arguments: (nsValue, key, nsObject). * * **Note:** This method mutates `object`. * *  4.0.0 * @category Object *    The object to modify. *    The path of the property to set. *    The value to set. *    The function to customize assigned values. *   Returns `object`. *  * *  * *  *  */function setWith(object, path, value, customizer) {  customizer = typeof customizer == function ? customizer : undefined  return object == null ? object : baseSet(object, path, value, customizer)}
export default setWith"
"import baseSet from ./.internal/baseSet.js
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist, * it's created. Arrays are created for missing index properties while objects * are created for all other missing properties. Use `setWith` to customize * `path` creation. * * **Note:** This method mutates `object`. * *  3.7.0 * @category Object *    The object to modify. *    The path of the property to set. *    The value to set. *   Returns `object`. *   hasIn, get, unset *  * *  * *  *  *  * *  *  *  */function set(object, path, value) {  return object == null ? object : baseSet(object, path, value)}
export default set"
"import copyArray from ./.internal/copyArray.js
 * Gets `n` random elements at unique keys from `array` up to the * size of `array`. * *  4.0.0 * @category Array *    The array to sample. *    The number of elements to sample. *   Returns the random elements. *  * *  *  * *  *  */function sampleSize(array, n) {  const length = array == null ? 0 : array.length  if (!length || n < 1) {    return []  }  n = n > length ? length : n  let index = -1  const lastIndex = n - 1  const result = copyArray(array)  while (++index < n) {    const rand = index + Math.floor(Math.random()  (lastIndex - index + 1))    const value = result[rand]    result[rand] = result[index]    result[index] = value  }  return result}
export default sampleSize"
" * Gets a random element from `array`. * *  2.0.0 * @category Array *    The array to sample. *   Returns the random element. *  * *  *  */function sample(array) {  const length = array == null ? 0 : array.length  return length ? array[Math.floor(Math.random()  length)] : undefined}
export default sample"
"import createRound from ./.internal/createRound.js
 * Computes `number` rounded to `precision`. * *  3.10.0 * @category Math *    The number to round. *    The precision to round to. *   Returns the rounded number. *  * *  *  * *  *  * *  *  */const round = createRound(round)
export default round"
"import castPath from ./.internal/castPath.jsimport toKey from ./.internal/toKey.js
 * This method is like `get` except that if the resolved value is a * function it's invoked with the `this` binding of its parent object and * its result is returned. * *  0.1.0 * @category Object *    The object to query. *    The path of the property to resolve. *    The value returned for `undefined` resolved values. *   Returns the resolved value. *  * *  * *  *  * *  *  * *  *  * *  *  */function result(object, path, defaultValue) {  path = castPath(path, object)
  let index = -1  let length = path.length
   Ensure the loop is entered when path is empty.  if (!length) {    length = 1    object = undefined  }  while (++index < length) {    let value = object == null ? undefined : object[toKey(path[index])]    if (value === undefined) {      index = length      value = defaultValue    }    object = typeof value == function ? value.call(object) : value  }  return object}
export default result"
" * Replaces matches for `pattern` in `string` with `replacement`. * * **Note:** This method is based on * [`String#replace`](https://mdn.io/String/replace). * *  4.0.0 * @category String *    The string to modify. *    The pattern to replace. *    The match replacement. *   Returns the modified string. *   trim *  * *  *  */function replace(...args) {  const string =   return args.length < 3 ? string : string.replace(args[1], args[2])}
export default replace"
" * Repeats the given string `n` times. * *  3.0.0 * @category String *    The string to repeat. *    The number of times to repeat the string. *   Returns the repeated string. *  * *  *  * *  *  * *  *  */function repeat(string, n) {  let result =   if (!string || n < 1 || n > Number.MAX_SAFE_INTEGER) {    return result  }   Leverage the exponentiation by squaring algorithm for a faster repeat.   See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.  do {    if (n % 2) {      result += string    }    n = Math.floor(n / 2)    if (n) {      string += string    }  } while (n)
  return result}
export default repeat"
"import basePullAt from ./.internal/basePullAt.js
 * Removes all elements from `array` that `predicate` returns truthy for * and returns an array of the removed elements. The predicate is invoked * with three arguments: (value, index, array). * * **Note:** Unlike `filter`, this method mutates `array`. Use `pull` * to pull elements from an array by value. * *  2.0.0 * @category Array *    The array to modify. *    The function invoked per iteration. *   Returns the new array of removed elements. *   pullAll, pullAllBy, pullAllWith, pullAt, reject, filter *  * *  *  * *  *  * *  *  */function remove(array, predicate) {  const result = []  if (!(array != null && array.length)) {    return result  }  let index = -1  const indexes = []  const { length } = array
  while (++index < length) {    const value = array[index]    if (predicate(value, index, array)) {      result.push(value)      indexes.push(index)    }  }  basePullAt(array, indexes)  return result}
export default remove"
"import filter from ./filter.jsimport filterObject from ./filterObject.jsimport negate from ./negate.js
 * The opposite of `filter` this method returns the elements of `collection` * that `predicate` does **not** return truthy for. * *  0.1.0 * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *   Returns the new filtered array. *   pullAll, pullAllBy, pullAllWith, pullAt, remove, filter *  * *  *    *    *  * *  *  */function reject(collection, predicate) {  const func = Array.isArray(collection) ? filter : filterObject  return func(collection, negate(predicate))}
export default reject"
"import arrayReduceRight from ./.internal/arrayReduceRight.jsimport baseEachRight from ./.internal/baseEachRight.jsimport baseReduce from ./.internal/baseReduce.js
 * This method is like `reduce` except that it iterates over elements of * `collection` from right to left. * *  0.1.0 * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *    The initial value. *   Returns the accumulated value. *   *  * *  * *  *  */function reduceRight(collection, iteratee, accumulator) {  const func = Array.isArray(collection) ? arrayReduceRight : baseReduce  const initAccum = arguments.length < 3  return func(collection, iteratee, accumulator, initAccum, baseEachRight)}
export default reduceRight"
"import arrayReduce from ./.internal/arrayReduce.jsimport baseEach from ./.internal/baseEach.jsimport baseReduce from ./.internal/baseReduce.js
 * Reduces `collection` to a value which is the accumulated result of running * each element in `collection` thru `iteratee`, where each successive * invocation is supplied the return value of the previous. If `accumulator` * is not given, the first element of `collection` is used as the initial * value. The iteratee is invoked with four arguments: * (accumulator, value, index|key, collection). * * Many lodash methods are guarded to work as iteratees for methods like * `reduce`, `reduceRight`, and `transform`. * * The guarded methods are: * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`, * and `sortBy` * *  0.1.0 * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *    The initial value. *   Returns the accumulated value. *   transform *  * *  *  * *  *    *    *  *  */function reduce(collection, iteratee, accumulator) {  const func = Array.isArray(collection) ? arrayReduce : baseReduce  const initAccum = arguments.length < 3  return func(collection, iteratee, accumulator, initAccum, baseEach)}
export default reduce"
"import createRange from ./.internal/createRange.js
 * This method is like `range` except that it populates values in * descending order. * *  4.0.0 * @category Util *    The start of the range. *    The end of the range. *    The value to increment or decrement by. *   Returns the range of numbers. *   range *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  */const rangeRight = createRange(true)
export default rangeRight"
"import createRange from ./.internal/createRange.js
 * Creates an array of numbers (positive and/or negative) progressing from * `start` up to, but not including, `end`. A step of `-1` is used if a negative * `start` is specified without an `end` or `step`. If `end` is not specified, * it's set to `start` with `start` then set to `0`. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * *  0.1.0 * @category Util *    The start of the range. *    The end of the range. *    The value to increment or decrement by. *   Returns the range of numbers. *   rangeRight *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  */const range = createRange()
export default range"
"import toFinite from ./toFinite.js
const freeParseFloat = parseFloat
 * Produces a random number between the inclusive `lower` and `upper` bounds. * If only one argument is provided a number between `0` and the given number * is returned. If `floating` is `true`, or either `lower` or `upper` are * floats, a floating-point number is returned instead of an integer. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * *  0.7.0 * @category Number *    The lower bound. *    The upper bound. *    Specify returning a floating-point number. *   Returns the random number. *   *  * *  *  * *  *  * *  *  * *  *  */function random(lower, upper, floating) {  if (floating === undefined) {    if (typeof upper == boolean) {      floating = upper      upper = undefined    }    else if (typeof lower == boolean) {      floating = lower      lower = undefined    }  }  if (lower === undefined && upper === undefined) {    lower = 0    upper = 1  }  else {    lower = toFinite(lower)    if (upper === undefined) {      upper = lower      lower = 0    } else {      upper = toFinite(upper)    }  }  if (lower > upper) {    const temp = lower    lower = upper    upper = temp  }  if (floating || lower % 1 || upper % 1) {    const rand = Math.random()    const randLength = .length - 1    return Math.min(lower + (rand  (upper - lower + freeParseFloat(1e-)), upper))  }  return lower + Math.floor(Math.random()  (upper - lower + 1))}
export default random"
"import map from ./map.jsimport baseAt from ./.internal/baseAt.jsimport basePullAt from ./.internal/basePullAt.jsimport compareAscending from ./.internal/compareAscending.jsimport isIndex from ./.internal/isIndex.js
 * Removes elements from `array` corresponding to `indexes` and returns an * array of removed elements. * * **Note:** Unlike `at`, this method mutates `array`. * *  3.0.0 * @category Array *    The array to modify. *    The indexes of elements to remove. *   Returns the new array of removed elements. *   pullAll, pullAllBy, pullAllWith, remove, reject *  * *  *  * *  *  * *  *  */function pullAt(array, ...indexes) {  const length = array == null ? 0 : array.length  const result = baseAt(array, indexes)
  basePullAt(array, map(indexes, (index) => isIndex(index, length) ? +index : index).sort(compareAscending))  return result}
export default pullAt"
"import basePullAll from ./.internal/basePullAll.js
 * This method is like `pullAll` except that it accepts `comparator` which * is invoked to compare elements of `array` to `values`. The comparator is * invoked with two arguments: (arrVal, othVal). * * **Note:** Unlike `differenceWith`, this method mutates `array`. * *  4.6.0 * @category Array *    The array to modify. *    The values to remove. *    The comparator invoked per element. *   Returns `array`. *   pullAll, pullAllBy, pullAt, remove, reject *  * *  * *  *  *  */function pullAllWith(array, values, comparator) {  return (array != null && array.length && values != null && values.length)    ? basePullAll(array, values, undefined, comparator)    : array}
export default pullAllWith"
"import basePullAll from ./.internal/basePullAll.js
 * This method is like `pullAll` except that it accepts `iteratee` which is * invoked for each element of `array` and `values` to generate the criterion * by which they're compared. The iteratee is invoked with one argument: (value). * * **Note:** Unlike `differenceBy`, this method mutates `array`. * *  4.0.0 * @category Array *    The array to modify. *    The values to remove. *    The iteratee invoked per element. *   Returns `array`. *   pullAll, pullAllWith, pullAt, remove, reject *  * *  * *  *  *  */function pullAllBy(array, values, iteratee) {  return (array != null && array.length && values != null && values.length)    ? basePullAll(array, values, iteratee)    : array}
export default pullAllBy"
"import basePullAll from ./.internal/basePullAll.js
 * This method is like `pull` except that it accepts an array of values to remove. * * **Note:** Unlike `difference`, this method mutates `array`. * *  4.0.0 * @category Array *    The array to modify. *    The values to remove. *   Returns `array`. *   pullAllBy, pullAllWith, pullAt, remove, reject *  * *  * *  *  *  */function pullAll(array, values) {  return (array != null && array.length && values != null && values.length)    ? basePullAll(array, values)    : array}
export default pullAll"
"import pullAll from ./pullAll.js
 * Removes all given values from `array` using * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * **Note:** Unlike `without`, this method mutates `array`. Use `remove` * to remove elements from an array by predicate. * *  2.0.0 * @category Array *    The array to modify. *    The values to remove. *   Returns `array`. *   pullAllBy, pullAllWith, pullAt, remove, reject *  * *  * *  *  *  */function pull(array, ...values) {  return pullAll(array, values)}
export default pull"
"import baseGet from ./.internal/baseGet.js
 * The opposite of `property`s method creates a function that returns * the value at a given path of `object`. * *  3.0.0 * @category Util *    The object to query. *   Returns the new accessor function. *  * *  *  * *  *  * *  *  */function propertyOf(object) {  return (path) => object == null ? undefined : baseGet(object, path)}
export default propertyOf"
"import baseProperty from ./.internal/baseProperty.jsimport basePropertyDeep from ./.internal/basePropertyDeep.jsimport isKey from ./.internal/isKey.jsimport toKey from ./.internal/toKey.js
 * Creates a function that returns the value at `path` of a given object. * *  2.4.0 * @category Util *    The path of the property to get. *   Returns the new accessor function. *  * *  *    *    *  * *  *  * *  *  */function property(path) {  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)}
export default property"
"import map from ./map.jsimport basePickBy from ./.internal/basePickBy.jsimport getAllKeysIn from ./.internal/getAllKeysIn.js
 * Creates an object composed of the `object` properties `predicate` returns * truthy for. The predicate is invoked with two arguments: (value, key). * *  4.0.0 * @category Object *    The source object. *    The function invoked per property. *   Returns the new object. *  * *  * *  *  */function pickBy(object, predicate) {  if (object == null) {    return {}  }  const props = map(getAllKeysIn(object), (prop) => [prop])  return basePickBy(object, props, (value, path) => predicate(value, path[0]))}
export default pickBy"
"import basePick from ./.internal/basePick.js
 * Creates an object composed of the picked `object` properties. * *  0.1.0 * @category Object *    The source object. *    The property paths to pick. *   Returns the new object. *  * *  * *  *  */function pick(object, ...paths) {  return object == null ? {} : basePick(object, paths)}
export default pick"
"import reduce from ./reduce.js
 * Creates an array of elements split into two groups, the first of which * contains elements `predicate` returns truthy for, the second of which * contains elements `predicate` returns falsey for. The predicate is * invoked with one argument: (value). * *  3.0.0 * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *   Returns the array of grouped elements. *   keyBy *  * *  *    *    *    *  * *  *  */function partition(collection, predicate) {  return reduce(collection, (result, value, key) => (    result[predicate(value) ? 0 : 1].push(value), result  ), [[], []])}
export default partition"
"import root from ./.internal/root.js
const reTrimStart = 
const nativeParseInt = root.parseInt
 * Converts `string` to an integer of the specified radix. If `radix` is * `undefined` or `0`, a `radix` of `10` is used unless `value` is a * hexadecimal, in which case a `radix` of `16` is used. * * **Note:** This method aligns with the * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`. * *  1.1.0 * @category String *    The string to convert. *    The radix to interpret `value` by. *   Returns the converted integer. *  * *  *  * *  *  */function parseInt(string, radix) {  if (radix == null) {    radix = 0  } else if (radix) {    radix = +radix  }  return nativeParseInt(.replace(reTrimStart, ), radix || 0)}
export default parseInt"
"import createPadding from ./.internal/createPadding.jsimport stringSize from ./.internal/stringSize.js
 * Pads `string` on the left side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * *  4.0.0 * @category String *    The string to pad. *    The padding length. *    The string used as padding. *   Returns the padded string. *  * *  *  * *  *  * *  *  */function padStart(string, length, chars) {  const strLength = length ? stringSize(string) : 0  return (length && strLength < length)    ? (createPadding(length - strLength, chars) + string)    : string}
export default padStart"
"import createPadding from ./.internal/createPadding.jsimport stringSize from ./.internal/stringSize.js
 * Pads `string` on the right side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * *  4.0.0 * @category String *    The string to pad. *    The padding length. *    The string used as padding. *   Returns the padded string. *  * *  *  * *  *  * *  *  */function padEnd(string, length, chars) {  const strLength = length ? stringSize(string) : 0  return (length && strLength < length)    ? (string + createPadding(length - strLength, chars))    : string}
export default padEnd"
"import createPadding from ./.internal/createPadding.jsimport stringSize from ./.internal/stringSize.js
 * Pads `string` on the left and right sides if it's shorter than `length`. * Padding characters are truncated if they can't be evenly divided by `length`. * *  3.0.0 * @category String *    The string to pad. *    The padding length. *    The string used as padding. *   Returns the padded string. *  * *  *  * *  *  * *  *  */function pad(string, length, chars) {  const strLength = length ? stringSize(string) : 0  if (!length || strLength >= length) {    return string  }  const mid = (length - strLength) / 2  return (    createPadding(Math.floor(mid), chars) +    string +    createPadding(Math.ceil(mid), chars)  )}
export default pad"
"import some from ./some.js
 * Creates a function that checks if **any** of the `predicates` return * truthy when invoked with the arguments it receives. * *  4.0.0 * @category Util *   ] *  The predicates to check. *   Returns the new function. *  * *  * *  *  * *  *  * *  *  */function overSome(iteratees) {  return function(...args) {    return some(iteratees, (iteratee) => iteratee.apply(this, args))  }}
export default overSome"
"import every from ./every.js
 * Creates a function that checks if **all** of the `predicates` return * truthy when invoked with the arguments it receives. * *  4.0.0 * @category Util *   ] *  The predicates to check. *   Returns the new function. *  * *  * *  *  * *  *  * *  *  */function overEvery(iteratees) {  return function(...args) {    return every(iteratees, (iteratee) => iteratee.apply(this, args))  }}
export default overEvery"
"
 * Creates a function that invokes `func` with its arguments transformed. * *  4.0.0 * @category Function *    The function to wrap. *   ] *  The argument transforms. *   Returns the new function. *  * *  *    *  * *  *    *  * *  * *  *  * *  *  */function overArgs(func, transforms) {  const funcsLength = transforms.length  return function(...args) {    let index = -1    const length = Math.min(args.length, funcsLength)    while (++index < length) {      args[index] = transforms[index].call(this, args[index])    }    return func.apply(this, args)  }}
export default overArgs"
"import map from ./map.js
 * Creates a function that invokes `iteratees` with the arguments it receives * and returns their results. * *  4.0.0 * @category Util *   ] *  The iteratees to invoke. *   Returns the new function. *  * *  * *  *  */function over(iteratees) {  return function(...args) {    return map(iteratees, (iteratee) => iteratee.apply(this, args))  }}
export default over"
"import baseOrderBy from ./.internal/baseOrderBy.js
 * This method is like `sortBy` except that it allows specifying the sort * orders of the iteratees to sort by. If `orders` is unspecified, all values * are sorted in ascending order. Otherwise, specify an order of ""desc"" for * descending or ""asc"" for ascending sort order of corresponding values. * *  4.0.0 * @category Collection *    The collection to iterate over. *   ] *  The iteratees to sort by. *    The sort orders of `iteratees`. *   Returns the new sorted array. *   *  * *  *    *    *    *    *  * *  *  *  */function orderBy(collection, iteratees, orders) {  if (collection == null) {    return []  }  if (!Array.isArray(iteratees)) {    iteratees = iteratees == null ? [] : [iteratees]  }  if (!Array.isArray(orders)) {    orders = orders == null ? [] : [orders]  }  return baseOrderBy(collection, iteratees, orders)}
export default orderBy"
"import before from ./before.js
 * Creates a function that is restricted to invoking `func` once. Repeat calls * to the function return the value of the first invocation. The `func` is * invoked with the `this` binding and arguments of the created function. * *  0.1.0 * @category Function *    The function to restrict. *   Returns the new restricted function. *  * *  *  *  *  */function once(func) {  return before(2, func)}
export default once"
"import nth from ./nth.js
 * Creates a function that gets the argument at index `n`. If `n` is negative, * the nth argument from the end is returned. * *  4.0.0 * @category Util *    The index of the argument to return. *   Returns the new pass-thru function. *  * *  *  *  * *  *  *  */function nthArg(n) {  return (...args) => nth(args, n)}
export default nthArg"
"import isIndex from ./.internal/isIndex.js
 * Gets the element at index `n` of `array`. If `n` is negative, the nth * element from the end is returned. * *  4.11.0 * @category Array *    The array to query. *    The index of the element to return. *   Returns the nth element of `array`. *  * *  * *  *  * *  *  */function nth(array, n) {  const length = array == null ? 0 : array.length  if (!length) {    return  }  n += n < 0 ? length : 0  return isIndex(n, length) ? array[n] : undefined}
export default nth"
" * Creates a function that negates the result of the predicate `func`. The * `func` predicate is invoked with the `this` binding and arguments of the * created function. * *  3.0.0 * @category Function *    The predicate to negate. *   Returns the new negated function. *  * *  *    *  * *  *  */function negate(predicate) {  if (typeof predicate != function) {    throw new TypeError(Expected a function)  }  return function(...args) {    return !predicate.apply(this, args)  }}
export default negate"
"import createMathOperation from ./.internal/createMathOperation.js
 * Multiply two numbers. * *  4.7.0 * @category Math *    The first number in a multiplication. *    The second number in a multiplication. *   Returns the product. *  * *  *  */const multiply = createMathOperation((multiplier, multiplicand) => multiplier  multiplicand, 1)
export default multiply"
"import isSymbol from ./isSymbol.js
 * This method is like `min` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * *  4.0.0 * @category Math *    The array to iterate over. *    The iteratee invoked per element. *   Returns the minimum value. *  * *  * *  *  */function minBy(array, iteratee) {  let result  if (array == null) {    return result  }  for (const value of array) {    let computed    const current = iteratee(value)
    if (current != null && (computed === undefined          ? (current === current && !isSymbol(current))          : (current < computed)        )) {      computed = current      result = value    }  }  return result}
export default minBy"
"import invoke from ./invoke.js
 * The opposite of `method` this method creates a function that invokes * the method at a given path of `object`. Any additional arguments are * provided to the invoked method. * *  3.7.0 * @category Util *    The object to query. *    The arguments to invoke the method with. *   Returns the new invoker function. *  * *  *  * *  *  * *  *  */function methodOf(object, args) {  return (path) => invoke(object, path, args)}
export default methodOf"
"import invoke from ./invoke.js
 * Creates a function that invokes the method at `path` of a given object. * Any additional arguments are provided to the invoked method. * *  3.7.0 * @category Util *    The path of the method to invoke. *    The arguments to invoke the method with. *   Returns the new invoker function. *  * *  *    *    *  * *  *  * *  *  */function method(path, args) {  return (object) => invoke(object, path, args)}
export default method"
"import baseMerge from ./.internal/baseMerge.jsimport createAssigner from ./.internal/createAssigner.js
 * This method is like `merge` except that it accepts `customizer` which * is invoked to produce the merged values of the destination and source * properties. If `customizer` returns `undefined`, merging is handled by the * method instead. The `customizer` is invoked with six arguments: * (objValue, srcValue, key, object, source, stack). * * **Note:** This method mutates `object`. * *  4.0.0 * @category Object *    The destination object. *    The source objects. *    The function to customize assigned values. *   Returns `object`. *  * *  *    *      *    *  * *  *  * *  *  */const mergeWith = createAssigner((object, source, srcIndex, customizer) => {  baseMerge(object, source, srcIndex, customizer)})
export default mergeWith"
"import baseMerge from ./.internal/baseMerge.jsimport createAssigner from ./.internal/createAssigner.js
 * This method is like `assign` except that it recursively merges own and * inherited enumerable string keyed properties of source objects into the * destination object. Source properties that resolve to `undefined` are * skipped if a destination value exists. Array and plain object properties * are merged recursively. Other objects and value types are overridden by * assignment. Source objects are applied from left to right. Subsequent * sources overwrite property assignments of previous sources. * * **Note:** This method mutates `object`. * *  0.5.0 * @category Object *    The destination object. *    The source objects. *   Returns `object`. *  * *  *    *  * *  *    *  * *  *  */const merge = createAssigner((object, source, srcIndex) => {  baseMerge(object, source, srcIndex)})
export default merge"
"import MapCache from ./.internal/MapCache.js
 * Creates a function that memoizes the result of `func`. If `resolver` is * provided, it determines the cache key for storing the result based on the * arguments provided to the memoized function. By default, the first argument * provided to the memoized function is used as the map cache key. The `func` * is invoked with the `this` binding of the memoized function. * * **Note:** The cache is exposed as the `cache` property on the memoized * function. Its creation may be customized by replacing the `memoize.Cache` * constructor with one whose instances implement the * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object) * method interface of `clear`, `delete`, `get`, `has`, and `set`. * *  0.1.0 * @category Function *    The function to have its output memoized. *    The function to resolve the cache key. *   Returns the new memoized function. *  * *  *  * *  *  *  * *  *  * *  *  *  * *  *  *  *  * *  *  */function memoize(func, resolver) {  if (typeof func != function || (resolver != null && typeof resolver != function)) {    throw new TypeError(Expected a function)  }  const memoized = function(...args) {    const key = resolver ? resolver.apply(this, args) : args[0]    const cache = memoized.cache
    if (cache.has(key)) {      return cache.get(key)    }    const result = func.apply(this, args)    memoized.cache = cache.set(key, result) || cache    return result  }  memoized.cache = new (memoize.Cache || MapCache)  return memoized}
memoize.Cache = MapCache
export default memoize"
"import baseSum from ./.internal/baseSum.js
const NAN = 0 / 0
 * This method is like `mean` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be averaged. * The iteratee is invoked with one argument: (value). * *  4.7.0 * @category Math *    The array to iterate over. *    The iteratee invoked per element. *   Returns the mean. *  * *  * *  *  */function meanBy(array, iteratee) {  const length = array == null ? 0 : array.length  return length ? (baseSum(array, iteratee) / length) : NAN}
export default meanBy"
"import baseMean from ./meanBy.js
 * Computes the mean of the values in `array`. * *  4.0.0 * @category Math *    The array to iterate over. *   Returns the mean. *  * *  *  */function mean(array) {  return baseMean(array, (value) => value)}
export default mean"
"import isSymbol from ./isSymbol.js
 * This method is like `max` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * *  4.0.0 * @category Math *    The array to iterate over. *    The iteratee invoked per element. *   Returns the maximum value. *  * *  * *  *  */function maxBy(array, iteratee) {  let result  if (array == null) {    return result  }  for (const value of array) {    let computed    const current = iteratee(value)
    if (current != null && (computed === undefined          ? (current === current && !isSymbol(current))          : (current > computed)        )) {      computed = current      result = value    }  }  return result}
export default maxBy"
"import baseClone from ./.internal/baseClone.jsimport baseMatchesProperty from ./.internal/baseMatchesProperty.js
const CLONE_DEEP_FLAG = 1
 * Creates a function that performs a partial deep comparison between the * value at `path` of a given object to `srcValue`, returning `true` if the * object value is equivalent, else `false`. * * **Note:** Partial comparisons will match empty array and empty object * `srcValue` values against any array or object value, respectively. See * `isEqual` for a list of supported value comparisons. * *  3.2.0 * @category Util *    The path of the property to get. *    The value to match. *   Returns the new spec function. *  * *  *    *    *  * *  *  */function matchesProperty(path, srcValue) {  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))}
export default matchesProperty"
"import baseClone from ./.internal/baseClone.jsimport baseMatches from ./.internal/baseMatches.js
const CLONE_DEEP_FLAG = 1
 * Creates a function that performs a partial deep comparison between a given * object and `source`, returning `true` if the given object has equivalent * property values, else `false`. * * **Note:** The created function is equivalent to `isMatch` with `source` * partially applied. * * Partial comparisons will match empty array and empty object `source` * values against any array or object value, respectively. See `isEqual` * for a list of supported value comparisons. * *  3.0.0 * @category Util *    The object of property values to match. *   Returns the new spec function. *  * *  *    *    *  * *  *  */function matches(source) {  return baseMatches(baseClone(source, CLONE_DEEP_FLAG))}
export default matches"
" * Creates an object with the same keys as `object` and values generated * by running each own enumerable string keyed property of `object` thru * `iteratee`. The iteratee is invoked with three arguments: * (value, key, object). * *  2.4.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   Returns the new mapped object. *   *  * *  *    *    *  * *  *  */function mapValue(object, iteratee) {  object = Object(object)  const result = {}
  Object.keys(object).forEach((key) => {    result[key] = iteratee(object[key], key, object)  })  return result}
export default mapValue"
" * Creates an array of values by running each property of `object` thru * `iteratee`. The iteratee is invoked with three arguments: (value, key, object). * *  5.0.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   Returns the new mapped array. *  * *  *    *  * *  *  */function mapObject(object, iteratee) {  const props = Object.keys(object)  const result = new Array(props.length)
  props.forEach((key, index) => {    result[index] = iteratee(object[key], key, object)  })  return result}
export default mapObject"
" * The opposite of `mapValue` this method creates an object with the * same values as `object` and keys generated by running each own enumerable * string keyed property of `object` thru `iteratee`. The iteratee is invoked * with three arguments: (value, key, object). * *  3.8.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   Returns the new mapped object. *   *  * *  *    *  *  */function mapKey(object, iteratee) {  object = Object(object)  const result = {}
  Object.keys(object).forEach((key) => {    const value = object[key]    result[iteratee(value, key, object)] = value  })  return result}
export default mapKey"
" * Creates an array of values by running each element of `array` thru `iteratee`. * The iteratee is invoked with three arguments: (value, index, array). * *  5.0.0 * @category Array *    The array to iterate over. *    The function invoked per iteration. *   Returns the new mapped array. *  * *  *    *  * *  *  */function map(array, iteratee) {  let index = -1  const length = array == null ? 0 : array.length  const result = new Array(length)
  while (++index < length) {    result[index] = iteratee(array[index], index, array)  }  return result}
export default map"
" * Checks if `value` is less than or equal to `other`. * *  3.9.0 * @category Lang *    The value to compare. *    The other value to compare. *   Returns `true` if `value` is less than or equal to *  `other`, else `false`. *   gte, lt *  * *  *  * *  *  * *  *  */function lte(value, other) {  if (!(typeof value == string && typeof other == string)) {    value = +value    other = +other  }  return value <= other}
export default lte"
" * Checks if `value` is less than `other`. * *  3.9.0 * @category Lang *    The value to compare. *    The other value to compare. *   Returns `true` if `value` is less than `other`, *  else `false`. *   gte, lte *  * *  *  * *  *  * *  *  */function lt(value, other) {  if (!(typeof value == string && typeof other == string)) {    value = +value    other = +other  }  return value < other}
export default lt"
"import createCaseFirst from ./.internal/createCaseFirst.js
 * Converts the first character of `string` to lower case. * *  4.0.0 * @category String *    The string to convert. *   Returns the converted string. *  * *  *  * *  *  */const lowerFirst = createCaseFirst(toLowerCase)
export default lowerFirst"
"import words from ./words.js
 * Converts `string`, as space separated words, to lower case. * *  4.0.0 * @category String *    The string to convert. *   Returns the lower cased string. *   kebabCase, snakeCase, startCase, upperCase, upperFirst *  * *  *  * *  *  * *  *  */const lowerCase = (string) => (  words(.replace(g, )).reduce((result, word, index) => (    result + (index ?   : ) + word.toLowerCase()  ), ))
export default lowerCase"
"import baseFindIndex from ./.internal/baseFindIndex.jsimport baseIsNaN from ./.internal/baseIsNaN.jsimport strictLastIndexOf from ./.internal/strictLastIndexOf.js
 * This method is like `indexOf` except that it iterates over elements of * `array` from right to left. * *  0.1.0 * @category Array *    The array to inspect. *    The value to search for. *    The index to search from. *   Returns the index of the matched value, else `-1`. *  * *  *  * *  *  *  */function lastIndexOf(array, value, fromIndex) {  const length = array == null ? 0 : array.length  if (!length) {    return -1  }  let index = length  if (fromIndex !== undefined) {    index = index < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1)  }  return value === value    ? strictLastIndexOf(array, value, index)    : baseFindIndex(array, baseIsNaN, index, true)}
export default lastIndexOf"
" * Gets the last element of `array`. * *  0.1.0 * @category Array *    The array to query. *   Returns the last element of `array`. *  * *  *  */function last(array) {  const length = array == null ? 0 : array.length  return length ? array[length - 1] : undefined}
export default last"
"import arrayLikeKeys from ./.internal/arrayLikeKeys.jsimport isArrayLike from ./isArrayLike.js
 * Creates an array of the own enumerable property names of `object`. * * **Note:** Non-object values are coerced to objects. See the * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys) * for more details. * *  0.1.0 * @category Object *    The object to query. *   Returns the array of property names. *   valuesIn *  * *  *    *    *  * *  * *  *  * *  *  */function keys(object) {  return isArrayLike(object)    ? arrayLikeKeys(object)    : Object.keys(Object(object))}
export default keys"
"import baseAssignValue from ./.internal/baseAssignValue.jsimport reduce from ./reduce.js
 * Creates an object composed of keys generated from the results of running * each element of `collection` thru `iteratee`. The corresponding value of * each key is the last element responsible for generating the key. The * iteratee is invoked with one argument: (value). * *  4.0.0 * @category Collection *    The collection to iterate over. *    The iteratee to transform keys. *   Returns the composed aggregate object. *   partition *  * *  *    *    *  * *  *  */function keyBy(collection, iteratee) {  return reduce(collection, (result, value, key) => (    baseAssignValue(result, iteratee(value), value), result  ), {})}
export default keyBy"
"import words from ./words.js
 * Converts `string` to * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). * *  3.0.0 * @category String *    The string to convert. *   Returns the kebab cased string. *   lowerCase, snakeCase, startCase, upperCase, upperFirst *  * *  *  * *  *  * *  *  */const kebabCase = (string) => (  words(.replace(g, )).reduce((result, word, index) => (    result + (index ? - : ) + word.toLowerCase()  ), ))
export default kebabCase"
"import getTag from ./.internal/getTag.js
 * Checks if `value` is classified as a `WeakSet` object. * *  4.3.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a weak set, else `false`. *  * *  *  * *  *  */function isWeakSet(value) {  return typeof value == object && value !== null && getTag(value) == [object WeakSet]}
export default isWeakSet"
"import getTag from ./.internal/getTag.js
 * Checks if `value` is classified as a `WeakMap` object. * *  4.3.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a weak map, else `false`. *  * *  *  * *  *  */function isWeakMap(value) {  return typeof value == object && value !== null && getTag(value) == [object WeakMap]}
export default isWeakMap"
" * Checks if `value` is `undefined`. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is `undefined`, else `false`. *  * *  *  * *  *  */function isUndefined(value) {  return value === undefined}
export default isUndefined"
"import getTag from ./.internal/getTag.jsimport nodeUtil from ./.internal/nodeUtil.js
const reTypedTag = object (?:Float(?:3264)(?:IntUint)(?:81632)Uint8Clamped)
const nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray
 * Checks if `value` is classified as a typed array. * *  3.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a typed array, else `false`. *  * *  *  * *  *  */const isTypedArray = nodeIsTypedArray  ? (value) => nodeIsTypedArray(value)  : (value) => typeof value == object && value !== null && reTypedTag.test(getTag(value))
export default isTypedArray"
"import getTag from ./.internal/getTag.js
 * Checks if `value` is classified as a `Symbol` primitive or object. * *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a symbol, else `false`. *  * *  *  * *  *  */function isSymbol(value) {  const type = typeof value  return type == symbol || (type == object && value != null && getTag(value) == [object Symbol])}
export default isSymbol"
"import getTag from ./.internal/getTag.js
 * Checks if `value` is classified as a `String` primitive or object. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a string, else `false`. *  * *  *  * *  *  */function isString(value) {  const type = typeof value  return type == string || (type == object && value != null && !Array.isArray(value) && getTag(value) == [object String])}
export default isString"
"import getTag from ./.internal/getTag.jsimport nodeUtil from ./.internal/nodeUtil.js
const nodeIsSet = nodeUtil && nodeUtil.isSet
 * Checks if `value` is classified as a `Set` object. * *  4.3.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a set, else `false`. *  * *  *  * *  *  */const isSet = nodeIsSet  ? (value) => nodeIsSet(value)  : (value) => typeof value == object && value !== null && getTag(value) == [object Set]
export default isSet"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObjectLike from ./isObjectLike.jsimport nodeUtil from ./.internal/nodeUtil.js
const nodeIsRegExp = nodeUtil && nodeUtil.isRegExp
 * Checks if `value` is classified as a `RegExp` object. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a regexp, else `false`. *  * *  *  * *  *  */const isRegExp = nodeIsRegExp  ? (value) => nodeIsRegExp(value)  : (value) => isObjectLike(value) && baseGetTag(value) == [object RegExp]
export default isRegExp"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObjectLike from ./isObjectLike.js
const funcToString = Function.prototype.toString
const hasOwnProperty = Object.prototype.hasOwnProperty
const objectCtorString = funcToString.call(Object)
 * Checks if `value` is a plain object, that is, an object created by the * `Object` constructor or one with a `[[Prototype]]` of `null`. * *  0.8.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a plain object, else `false`. *  * *  *    *  * *  *  * *  *  * *  *  * *  *  */function isPlainObject(value) {  if (!isObjectLike(value) || baseGetTag(value) != [object Object]) {    return false  }  const proto = Object.getPrototypeOf(value)  if (proto === null) {    return true  }  const Ctor = hasOwnProperty.call(proto, constructor) && proto.constructor  return typeof Ctor == function && Ctor instanceof Ctor &&    funcToString.call(Ctor) == objectCtorString}
export default isPlainObject"
" * Checks if `value` is object-like. A value is object-like if it's not `null` * and has a `typeof` result of ""object"". * *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is object-like, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isObjectLike(value) {  return typeof value == object && value !== null}
export default isObjectLike"
" * Checks if `value` is the * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an object, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isObject(value) {  const type = typeof value  return value != null && (type == object || type == function)}
export default isObject"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObjectLike from ./isObjectLike.js
 * Checks if `value` is classified as a `Number` primitive or object. * * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are * classified as numbers, use the `Number.isFinite` method. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a number, else `false`. *   toInteger, toNumber *  * *  *  * *  *  * *  *  * *  *  */function isNumber(value) {  return typeof value == number ||    (isObjectLike(value) && baseGetTag(value) == [object Number])}
export default isNumber"
" * Checks if `value` is `null`. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is `null`, else `false`. *  * *  *  * *  *  */function isNull(value) {  return value === null}
export default isNull"
" * Checks if `value` is `null` or `undefined`. * *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is nullish, else `false`. *  * *  *  * *  *  * *  *  */function isNil(value) {  return value == null}
export default isNil"
"import isObject from ./isObject.js
 * Used to match `RegExp` * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns). */const reRegExpChar = g
const reIsNative = RegExp(^$)
 * Checks if `value` is a pristine native function. * *  3.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a native function, *  else `false`. *  * *  *  * *  *  */function isNative(value) {  return isObject(value) && reIsNative.test(value)}
export default isNative"
"import baseIsMatch from ./.internal/baseIsMatch.jsimport getMatchData from ./.internal/getMatchData.js
 * This method is like `isMatch` except that it accepts `customizer` which * is invoked to compare values. If `customizer` returns `undefined`, comparisons * are handled by the method instead. The `customizer` is invoked with five * arguments: (objValue, srcValue, index|key, object, source). * *  4.0.0 * @category Lang *    The object to inspect. *    The object of property values to match. *    The function to customize comparisons. *   Returns `true` if `object` is a match, else `false`. *  * *  *    *  * *  *    *      *    *  * *  *  * *  *  */function isMatchWith(object, source, customizer) {  customizer = typeof customizer == function ? customizer : undefined  return baseIsMatch(object, source, getMatchData(source), customizer)}
export default isMatchWith"
"import baseIsMatch from ./.internal/baseIsMatch.jsimport getMatchData from ./.internal/getMatchData.js
 * Performs a partial deep comparison between `object` and `source` to * determine if `object` contains equivalent property values. * * **Note:** This method is equivalent to `matches` when `source` is * partially applied. * * Partial comparisons will match empty array and empty object `source` * values against any array or object value, respectively. See `isEqual` * for a list of supported value comparisons. * *  3.0.0 * @category Lang *    The object to inspect. *    The object of property values to match. *   Returns `true` if `object` is a match, else `false`. *  * *  * *  *  * *  *  */function isMatch(object, source) {  return object === source || baseIsMatch(object, source, getMatchData(source))}
export default isMatch"
"import getTag from ./.internal/getTag.jsimport isObjectLike from ./isObjectLike.jsimport nodeUtil from ./.internal/nodeUtil.js
const nodeIsMap = nodeUtil && nodeUtil.isMap
 * Checks if `value` is classified as a `Map` object. * *  4.3.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a map, else `false`. *  * *  *  * *  *  */const isMap = nodeIsMap  ? (value) => nodeIsMap(value)  : (value) => isObjectLike(value) && getTag(value) == [object Map]
export default isMap"
"const MAX_SAFE_INTEGER = 9007199254740991
 * Checks if `value` is a valid array-like length. * * **Note:** This method is loosely based on * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a valid length, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isLength(value) {  return typeof value == number &&    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER}
export default isLength"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObject from ./isObject.js
 * Checks if `value` is classified as a `Function` object. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a function, else `false`. *  * *  *  * *  *  */function isFunction(value) {  if (!isObject(value)) {    return false  }   The use of `Object#toString` avoids issues with the `typeof` operator   in Safari 9 which returns 'object' for typed arrays and other constructors.  const tag = baseGetTag(value)  return tag == [object Function] || tag == [object AsyncFunction] ||    tag == [object GeneratorFunction] || tag == [object Proxy]}
export default isFunction"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObjectLike from ./isObjectLike.jsimport isPlainObject from ./isPlainObject.js
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`, * `SyntaxError`, `TypeError`, or `URIError` object. * *  3.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an error object, else `false`. *  * *  *  * *  *  */function isError(value) {  if (!isObjectLike(value)) {    return false  }  const tag = baseGetTag(value)  return tag == [object Error] || tag == [object DOMException] ||    (typeof value.message == string && typeof value.name == string && !isPlainObject(value))}
export default isError"
"import baseIsEqual from ./.internal/baseIsEqual.js
 * This method is like `isEqual` except that it accepts `customizer` which * is invoked to compare values. If `customizer` returns `undefined`, comparisons * are handled by the method instead. The `customizer` is invoked with up to * six arguments: (objValue, othValue [, index|key, object, other, stack]). * *  4.0.0 * @category Lang *    The value to compare. *    The other value to compare. *    The function to customize comparisons. *   Returns `true` if the values are equivalent, else `false`. *  * *  *    *  * *  *    *      *    *  * *  *  * *  *  */function isEqualWith(value, other, customizer) {  customizer = typeof customizer == function ? customizer : undefined  const result = customizer ? customizer(value, other) : undefined  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result}
export default isEqualWith"
"import getTag from ./.internal/getTag.jsimport isArguments from ./isArguments.jsimport isArrayLike from ./isArrayLike.jsimport isBuffer from ./isBuffer.jsimport isPrototype from ./.internal/isPrototype.jsimport isTypedArray from ./isTypedArray.js
const hasOwnProperty = Object.prototype.hasOwnProperty
 * Checks if `value` is an empty object, collection, map, or set. * * Objects are considered empty if they have no own enumerable string keyed * properties. * * Array-like values such as `arguments` objects, arrays, buffers, strings, or * jQuery-like collections are considered empty if they have a `length` of `0`. * Similarly, maps and sets are considered empty if they have a `size` of `0`. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is empty, else `false`. *  * *  *  * *  *  * *  *  * *  *  * *  *  */function isEmpty(value) {  if (value == null) {    return true  }  if (isArrayLike(value) &&      (Array.isArray(value) || typeof value == string || typeof value.splice == function ||        isBuffer(value) || isTypedArray(value) || isArguments(value))) {    return !value.length  }  const tag = getTag(value)  if (tag == [object Map] || tag == [object Set]) {    return !value.size  }  if (isPrototype(value)) {    return !Object.keys(value).length  }  for (const key in value) {    if (hasOwnProperty.call(value, key)) {      return false    }  }  return true}
export default isEmpty"
"import isObjectLike from ./isObjectLike.jsimport isPlainObject from ./isPlainObject.js
 * Checks if `value` is likely a DOM element. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a DOM element, else `false`. *  * *  *  * *  *  */function isElement(value) {  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value)}
export default isElement"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObjectLike from ./isObjectLike.jsimport nodeUtil from ./.internal/nodeUtil.js
const nodeIsDate = nodeUtil && nodeUtil.isDate
 * Checks if `value` is classified as a `Date` object. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a date object, else `false`. *  * *  *  * *  *  */const isDate = nodeIsDate  ? (value) => nodeIsDate(value)  : (value) => isObjectLike(value) && baseGetTag(value) == [object Date]
export default isDate"
"import root from ./.internal/root.js
const freeExports = typeof exports == object && exports !== null && !exports.nodeType && exports
const freeModule = freeExports && typeof module == object && module !== null && !module.nodeType && module
const moduleExports = freeModule && freeModule.exports === freeExports
const Buffer = moduleExports ? root.Buffer : undefined
const nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined
 * Checks if `value` is a buffer. * *  4.3.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a buffer, else `false`. *  * *  *  * *  *  */const isBuffer = nativeIsBuffer || (() => false)
export default isBuffer"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObjectLike from ./isObjectLike.js
 * Checks if `value` is classified as a boolean primitive or object. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is a boolean, else `false`. *  * *  *  * *  *  */function isBoolean(value) {  return value === true || value === false ||    (isObjectLike(value) && baseGetTag(value) == [object Boolean])}
export default isBoolean"
"import isArrayLike from ./isArrayLike.jsimport isObjectLike from ./isObjectLike.js
 * This method is like `isArrayLike` except that it also checks if `value` * is an object. * *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an array-like object, *  else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isArrayLikeObject(value) {  return isObjectLike(value) && isArrayLike(value)}
export default isArrayLikeObject"
"import isLength from ./isLength.js
 * Checks if `value` is array-like. A value is considered array-like if it's * not a function and has a `value.length` that's an integer greater than or * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`. * *  4.0.0 * @category Lang *    The value to check. *   Returns `true` if `value` is array-like, else `false`. *  * *  *  * *  *  * *  *  * *  *  */function isArrayLike(value) {  return value != null && typeof value != function && isLength(value.length)}
export default isArrayLike"
"import baseGetTag from ./.internal/baseGetTag.jsimport isObjectLike from ./isObjectLike.jsimport nodeUtil from ./.internal/nodeUtil.js
const nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer
 * Checks if `value` is classified as an `ArrayBuffer` object. * *  4.3.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an array buffer, else `false`. *  * *  *  * *  *  */const isArrayBuffer = nodeIsArrayBuffer  ? (value) => nodeIsArrayBuffer(value)  : (value) => isObjectLike(value) && baseGetTag(value) == [object ArrayBuffer]
export default isArrayBuffer"
"import getTag from ./.internal/getTag.js
 * Checks if `value` is likely an `arguments` object. * *  0.1.0 * @category Lang *    The value to check. *   Returns `true` if `value` is an `arguments` object, else `false`. *  * *  *  * *  *  */function isArguments(value) {  return typeof value == object && value !== null && getTag(value) == [object Arguments]}
export default isArguments"
"import baseEach from ./.internal/baseEach.jsimport invoke from ./invoke.jsimport isArrayLike from ./isArrayLike.js
 * Invokes the method at `path` of each element in `collection`, returning * an array of the results of each invoked method. Any additional arguments * are provided to each invoked method. If `path` is a function, it's invoked * for, and `this` bound to, each element in `collection`. * *  4.0.0 * @category Collection *    The collection to iterate over. *    The path of the method to invoke or *  the function invoked per iteration. *    The arguments to invoke each method with. *   Returns the array of results. *  * *  *  * *  *  */function invokeMap(collection, path, args) {  let index = -1  const isFunc = typeof path == function  const result = isArrayLike(collection) ? new Array(collection.length) : []
  baseEach(collection, (value) => {    result[++index] = isFunc ? path.apply(value, args) : invoke(value, path, args)  })  return result}
export default invokeMap"
"import castPath from ./.internal/castPath.jsimport last from ./last.jsimport parent from ./.internal/parent.jsimport toKey from ./.internal/toKey.js
 * Invokes the method at `path` of `object`. * *  4.0.0 * @category Object *    The object to query. *    The path of the method to invoke. *    The arguments to invoke the method with. *   Returns the result of the invoked method. *  * *  * *  *  */function invoke(object, path, args) {  path = castPath(path, object)  object = parent(object, path)  const func = object == null ? object : object[toKey(last(path))]  return func == null ? undefined : func.apply(object, args)}
export default invoke"
"const hasOwnProperty = Object.prototype.hasOwnProperty
 * This method is like `invert` except that the inverted object is generated * from the results of running each element of `object` thru `iteratee`. The * corresponding inverted value of each inverted key is an array of keys * responsible for generating the inverted value. The iteratee is invoked * with one argument: (value). * *  4.1.0 * @category Object *    The object to invert. *    The iteratee invoked per element. *   Returns the new inverted object. *  * *  * *  *  */function invertBy(object, iteratee) {  const result = {}  Object.keys(object).forEach((value, key) => {    value = iteratee(value)    if (hasOwnProperty.call(result, value)) {      result[value].push(key)    } else {      result[value] = [key]    }  })  return result}
export default invertBy"
" * Creates an object composed of the inverted keys and values of `object`. * If `object` contains duplicate values, subsequent values overwrite * property assignments of previous values. * *  0.7.0 * @category Object *    The object to invert. *   Returns the new inverted object. *  * *  * *  *  */function invert(object) {  const result = {}  Object.keys(object).forEach((value, key) => {    result[value] = key  })  return result}
export default invert"
"import map from ./map.jsimport baseIntersection from ./.internal/baseIntersection.jsimport castArrayLikeObject from ./.internal/castArrayLikeObject.jsimport last from ./last.js
 * This method is like `intersection` except that it accepts `comparator` * which is invoked to compare elements of `arrays`. The order and references * of result values are determined by the first array. The comparator is * invoked with two arguments: (arrVal, othVal). * *  4.0.0 * @category Array *    The arrays to inspect. *    The comparator invoked per element. *   Returns the new array of intersecting values. *  * *  *  * *  *  */function intersectionWith(...arrays) {  let comparator = last(arrays)  const mapped = map(arrays, castArrayLikeObject)
  comparator = typeof comparator == function ? comparator : undefined  if (comparator) {    mapped.pop()  }  return (mapped.length && mapped[0] === arrays[0])    ? baseIntersection(mapped, undefined, comparator)    : []}
export default intersectionWith"
"import map from ./map.jsimport baseIntersection from ./.internal/baseIntersection.jsimport castArrayLikeObject from ./.internal/castArrayLikeObject.jsimport last from ./last.js
 * This method is like `intersection` except that it accepts `iteratee` * which is invoked for each element of each `arrays` to generate the criterion * by which they're compared. The order and references of result values are * determined by the first array. The iteratee is invoked with one argument: * (value). * *  4.0.0 * @category Array *    The arrays to inspect. *    The iteratee invoked per element. *   Returns the new array of intersecting values. *  * *  *  */function intersectionBy(...arrays) {  let iteratee = last(arrays)  const mapped = map(arrays, castArrayLikeObject)
  if (iteratee === last(mapped)) {    iteratee = undefined  } else {    mapped.pop()  }  return (mapped.length && mapped[0] === arrays[0])    ? baseIntersection(mapped, iteratee)    : []}
export default intersectionBy"
"import map from ./map.jsimport baseIntersection from ./.internal/baseIntersection.jsimport castArrayLikeObject from ./.internal/castArrayLikeObject.js
 * Creates an array of unique values that are included in all given arrays * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. The order and references of result values are * determined by the first array. * *  0.1.0 * @category Array *    The arrays to inspect. *   Returns the new array of intersecting values. *  * *  *  */function intersection(...arrays) {  const mapped = map(arrays, castArrayLikeObject)  return (mapped.length && mapped[0] === arrays[0])    ? baseIntersection(mapped)    : []}
export default intersection"
"import slice from ./slice.js
 * Gets all but the last element of `array`. * *  0.1.0 * @category Array *    The array to query. *   Returns the slice of `array`. *  * *  *  */function initial(array) {  const length = array == null ? 0 : array.length  return length ? slice(array, 0, -1) : []}
export default initial"
"import baseIndexOf from ./.internal/baseIndexOf.js
 * Gets the index at which the first occurrence of `value` is found in `array` * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. If `fromIndex` is negative, it's used as the * offset from the end of `array`. * *  0.1.0 * @category Array *    The array to inspect. *    The value to search for. *    The index to search from. *   Returns the index of the matched value, else `-1`. *  * *  *  * *  *  *  */function indexOf(array, value, fromIndex) {  const length = array == null ? 0 : array.length  if (!length) {    return -1  }  let index = fromIndex == null ? 0 : +fromIndex  if (index < 0) {    index = Math.max(length + index, 0)  }  return baseIndexOf(array, value, index)}
export default indexOf"
"import baseInRange from ./.internal/baseInRange.js
 * Checks if `n` is between `start` and up to, but not including, `end`. If * `end` is not specified, it's set to `start` with `start` then set to `0`. * If `start` is greater than `end` the params are swapped to support * negative ranges. * *  3.3.0 * @category Number *    The number to check. *    The start of the range. *    The end of the range. *   Returns `true` if `number` is in the range, else `false`. *   rangeRight *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  */function inRange(number, start, end) {  if (end === undefined) {    end = start    start = 0  }  return baseInRange(+number, +start, +end)}
export default inRange"
" * Gets the first element of `array`. * *  0.1.0 *   * @category Array *    The array to query. *   Returns the first element of `array`. *   *  * *  *  * *  *  */function head(array) {  return (array != null && array.length)    ? array[0]    : undefined}
export default head"
"import castPath from ./.internal/castPath.jsimport isArguments from ./isArguments.jsimport isIndex from ./.internal/isIndex.jsimport isLength from ./isLength.jsimport toKey from ./.internal/toKey.js
 * Checks if `path` is a direct property of `object`. * *  5.0.0 * @category Object *    The object to query. *    The path to check. *   Returns `true` if `path` exists, else `false`. *   hasIn hasPath *  * *  *  * *  *  * *  *  */function hasPathIn(object, path) {  path = castPath(path, object)
  let index = -1  let { length } = path  let result = false  let key
  while (++index < length) {    key = toKey(path[index])    if (!(result = object != null && key in Object(object))) {      break    }    object = object[key]  }  if (result || ++index != length) {    return result  }  length = object == null ? 0 : object.length  return !!length && isLength(length) && isIndex(key, length) &&    (Array.isArray(object) || isArguments(object))}
export default hasPathIn"
"import castPath from ./.internal/castPath.jsimport isArguments from ./isArguments.jsimport isIndex from ./.internal/isIndex.jsimport isLength from ./isLength.jsimport toKey from ./.internal/toKey.js
const hasOwnProperty = Object.prototype.hasOwnProperty
 * Checks if `path` is a direct property of `object`. * *  5.0.0 * @category Object *    The object to query. *    The path to check. *   Returns `true` if `path` exists, else `false`. *   hasIn, hasPathIn *  * *  *  * *  *  * *  *  */function hasPath(object, path) {  path = castPath(path, object)
  let index = -1  let { length } = path  let result = false  let key
  while (++index < length) {    key = toKey(path[index])    if (!(result = object != null && hasOwnProperty.call(object, key))) {      break    }    object = object[key]  }  if (result || ++index != length) {    return result  }  length = object == null ? 0 : object.length  return !!length && isLength(length) && isIndex(key, length) &&    (Array.isArray(object) || isArguments(object))}
export default hasPath"
" * Checks if `path` is a direct or inherited property of `object`. * *  4.0.0 * @category Object *    The object to query. *    The key to check. *   Returns `true` if `key` exists, else `false`. *   hasPath, hasPathIn *  * *  * *  *  * *  *  */function hasIn(object, key) {  return object != null && key in Object(object)}
export default hasIn"
"const hasOwnProperty = Object.prototype.hasOwnProperty
 * Checks if `key` is a direct property of `object`. * *  0.1.0 * @category Object *    The object to query. *    The key to check. *   Returns `true` if `key` exists, else `false`. *   hasPath, hasPathIn *  * *  *  * *  *  * *  *  */function has(object, key) {  return object != null && hasOwnProperty.call(object, key)}
export default has"
" * Checks if `value` is greater than or equal to `other`. * *  3.9.0 * @category Lang *    The value to compare. *    The other value to compare. *   Returns `true` if `value` is greater than or equal to *  `other`, else `false`. *   lt, lte *  * *  *  * *  *  * *  *  */function gte(value, other) {  if (!(typeof value == string && typeof other == string)) {    value = +value    other = +other  }  return value >= other}
export default gte"
" * Checks if `value` is greater than `other`. * *  3.9.0 * @category Lang *    The value to compare. *    The other value to compare. *   Returns `true` if `value` is greater than `other`, *  else `false`. *   lt, lte *  * *  *  * *  *  * *  *  */function gt(value, other) {  if (!(typeof value == string && typeof other == string)) {    value = +value    other = +other  }  return value > other}
export default gt"
"import baseAssignValue from ./.internal/baseAssignValue.jsimport reduce from ./reduce.js
const hasOwnProperty = Object.prototype.hasOwnProperty
 * Creates an object composed of keys generated from the results of running * each element of `collection` thru `iteratee`. The order of grouped values * is determined by the order they occur in `collection`. The corresponding * value of each key is an array of elements responsible for generating the * key. The iteratee is invoked with one argument: (value). * *  0.1.0 * @category Collection *    The collection to iterate over. *    The iteratee to transform keys. *   Returns the composed aggregate object. *  * *  *  */function groupBy(collection, iteratee) {  return reduce(collection, (result, value, key) => {    key = iteratee(value)    if (hasOwnProperty.call(result, key)) {      result[key].push(value)    } else {      baseAssignValue(result, key, [value])    }    return result  }, {})}
export default groupBy"
"import baseGet from ./.internal/baseGet.js
 * Gets the value at `path` of `object`. If the resolved value is * `undefined`, the `defaultValue` is returned in its place. * *  3.7.0 * @category Object *    The object to query. *    The path of the property to get. *    The value returned for `undefined` resolved values. *   Returns the resolved value. *   hasIn, set, unset *  * *  * *  *  * *  *  * *  *  */function get(object, path, defaultValue) {  const result = object == null ? undefined : baseGet(object, path)  return result === undefined ? defaultValue : result}
export default get"
" * Creates an array of function property names from own enumerable properties * of `object`. * *  0.1.0 * @category Object *    The object to inspect. *   Returns the function names. *   *  * *  *    *    *  * *  * *  *  */function functions(object) {  if (object == null) {    return []  }  return Object.keys(object).filter((key) => typeof object[key] == function)}
export default functions"
" * The inverse of `toPairs`is method returns an object composed * from key-value `pairs`. * *  4.0.0 * @category Array *    The key-value pairs. *   Returns the new object. *  * *  *  */function fromPairs(pairs) {  const result = {}  if (pairs == null) {    return result  }  for (const pair of pairs) {    result[pair[0]] = pair[1]  }  return result}
export default fromPairs"
" * This method is like `forOwn` except that it iterates over properties of * `object` in the opposite order. * *  2.0.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   Returns `object`. *   forEachRight, forIn, forInRight, forOwn *  * *  *    *    *  * *  * *  *    *  *  */function forOwnRight(object, iteratee) {  if (object == null) {    return  }  const props = Object.keys(object)  let length = props.length  while (length--) {    iteratee(object[props[length]], iteratee, object)  }}
export default forOwnRight"
" * Iterates over own enumerable string keyed properties of an object and * invokes `iteratee` for each property. The iteratee is invoked with three * arguments: (value, key, object). Iteratee functions may exit iteration * early by explicitly returning `false`. * *  0.3.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   forEachRight, forIn, forInRight, forOwnRight *  * *  *    *    *  * *  * *  *    *  *  */function forOwn(object, iteratee) {  object = Object(object)  Object.keys(object).forEach((key) => iteratee(object[key], key, object))}
export default forOwn"
"import arrayEachRight from ./.internal/arrayEachRight.jsimport baseEachRight from ./.internal/baseEachRight.js
 * This method is like `forEach` except that it iterates over elements of * `collection` from right to left. * *  2.0.0 *   * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *   Returns `collection`. *   forIn, forInRight, forOwn, forOwnRight *  * *  *  */function forEachRight(collection, iteratee) {  const func = Array.isArray(collection) ? arrayEachRight : baseEachRight  return func(collection, iteratee)}
export default forEachRight"
"import arrayEach from ./.internal/arrayEach.jsimport baseEach from ./.internal/baseEach.js
 * Iterates over elements of `collection` and invokes `iteratee` for each element. * The iteratee is invoked with three arguments: (value, index|key, collection). * Iteratee functions may exit iteration early by explicitly returning `false`. * * **Note:** As with other ""Collections"" methods, objects with a ""length"" * property are iterated like arrays. To avoid this behavior use `forIn` * or `forOwn` for object iteration. * *  0.1.0 *   * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *   Returns `collection`. *   forIn, forInRight, forOwn, forOwnRight *  * *  *  * *  *  */function forEach(collection, iteratee) {  const func = Array.isArray(collection) ? arrayEach : baseEach  return func(collection, iteratee)}
export default forEach"
"import flow from ./flow.js
 * This method is like `flow` except that it composes a function that * invokes the given functions from right to left. * *  3.0.0 * @category Util *    The functions to invoke. *   Returns the new composite function. *   *  * *  *    *  * *  *  *  */function flowRight(funcs) {  return flow(funcs.reverse())}
export default flowRight"
" * Composes a function that returns the result of invoking the given functions * with the `this` binding of the created function, where each successive * invocation is supplied the return value of the previous. * *  3.0.0 * @category Util *    The functions to invoke. *   Returns the new composite function. *   *  * *  *    *  * *  *  *  */function flow(funcs) {  const length = funcs ? funcs.length : 0  let index = length  while (index--) {    if (typeof funcs[index] != function) {      throw new TypeError(Expected a function)    }  }  return function(...args) {    let index = 0    let result = length ? funcs[index].apply(this, args) : args[0]    while (++index < length) {      result = funcs[index].call(this, result)    }    return result  }}
export default flow"
"import createRound from ./.internal/createRound.js
 * Computes `number` rounded down to `precision`. * *  3.10.0 * @category Math *    The number to round down. *    The precision to round down to. *   Returns the rounded down number. *  * *  *  * *  *  * *  *  */const floor = createRound(floor)
export default floor"
" * Creates a function that invokes `func` with arguments reversed. * *  4.0.0 * @category Function *    The function to flip arguments for. *   Returns the new flipped function. *   *  * *  * *  *  */function flip(func) {  if (typeof func != function) {    throw new TypeError(Expected a function)  }  return function(...args) {    return func.apply(this, args.reverse())  }}
export default flip"
"import baseFlatten from ./.internal/baseFlatten.js
 * Recursively flatten `array` up to `depth` times. * *  4.4.0 * @category Array *    The array to flatten. *    The maximum recursion depth. *   Returns the new flattened array. *   flatMapDeep, flatMapDepth, flattenDeep *  * *  * *  *  * *  *  */function flattenDepth(array, depth) {  const length = array == null ? 0 : array.length  if (!length) {    return []  }  depth = depth === undefined ? 1 : +depth  return baseFlatten(array, depth)}
export default flattenDepth"
"import baseFlatten from ./.internal/baseFlatten.js
const INFINITY = 1 / 0
 * Recursively flattens `array`. * *  3.0.0 * @category Array *    The array to flatten. *   Returns the new flattened array. *   flatMapDeep, flatMapDepth, flatten, flattenDepth *  * *  *  */function flattenDeep(array) {  const length = array == null ? 0 : array.length  return length ? baseFlatten(array, INFINITY) : []}
export default flattenDeep"
"import baseFlatten from ./.internal/baseFlatten.js
 * Flattens `array` a single level deep. * *  0.1.0 * @category Array *    The array to flatten. *   Returns the new flattened array. *   flatMapDeep, flatMapDepth, flattenDeep, flattenDepth *  * *  *  */function flatten(array) {  const length = array == null ? 0 : array.length  return length ? baseFlatten(array, 1) : []}
export default flatten"
"import baseFlatten from ./.internal/baseFlatten.jsimport map from ./map.js
 * This method is like `flatMap` except that it recursively flattens the * mapped results up to `depth` times. * *  4.7.0 * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *    The maximum recursion depth. *   Returns the new flattened array. *   flatMapDeep, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues *  * *  *    *  * *  *  */function flatMapDepth(collection, iteratee, depth) {  depth = depth === undefined ? 1 : +depth  return baseFlatten(map(collection, iteratee), depth)}
export default flatMapDepth"
"import baseFlatten from ./.internal/baseFlatten.jsimport map from ./map.js
const INFINITY = 1 / 0
 * This method is like `flatMap` except that it recursively flattens the * mapped results. * *  4.7.0 * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *   Returns the new flattened array. *   flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues *  * *  *    *  * *  *  */function flatMapDeep(collection, iteratee) {  return baseFlatten(map(collection, iteratee), INFINITY)}
export default flatMapDeep"
"import baseFlatten from ./.internal/baseFlatten.jsimport map from ./map.js
 * Creates a flattened array of values by running each element in `collection` * thru `iteratee` and flattening the mapped results. The iteratee is invoked * with three arguments: (value, index|key, collection). * *  4.0.0 * @category Collection *    The collection to iterate over. *    The function invoked per iteration. *   Returns the new flattened array. *   flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues *  * *  *    *  * *  *  */function flatMap(collection, iteratee) {  return baseFlatten(map(collection, iteratee), 1)}
export default flatMap"
export { default } from ./head.js
"import baseFindKey from ./.internal/baseFindKey.jsimport baseForOwnRight from ./.internal/baseForOwnRight.js
 * This method is like `findKey` except that it iterates over elements of * a collection in the opposite order. * *  2.0.0 * @category Object *    The object to inspect. *    The function invoked per iteration. *   Returns the key of the matched element, *  else `undefined`. *   findIndex, findKey, findLast, findLastIndex *  * *  *    *    *    *  * *  *  */function findLastKey(object, predicate) {  return baseFindKey(object, predicate, baseForOwnRight)}
export default findLastKey"
"import baseFindIndex from ./.internal/baseFindIndex.js
 * This method is like `findIndex` except that it iterates over elements * of `collection` from right to left. * *  2.0.0 * @category Array *    The array to inspect. *    The function invoked per iteration. *    The index to search from. *   Returns the index of the found element, else `-1`. *   findIndex, findKey, findLast, findLastKey *  * *  *    *    *    *  * *  *  */function findLastIndex(array, predicate, fromIndex) {  const length = array == null ? 0 : array.length  if (!length) {    return -1  }  let index = length - 1  if (fromIndex !== undefined) {    index = fromIndex < 0      ? Math.max(length + fromIndex, 0)      : Math.min(fromIndex, length - 1)  }  return baseFindIndex(array, predicate, index, true)}
export default findLastIndex"
"import createFind from ./.internal/createFind.jsimport findLastIndex from ./findLastIndex.js
 * This method is like `find` except that it iterates over elements of * `collection` from right to left. * *  2.0.0 * @category Collection *    The collection to inspect. *    The function invoked per iteration. *    The index to search from. *   Returns the matched element, else `undefined`. *   findIndex, findKey, findLastIndex, findLastKey *  * *  *  */const findLast = createFind(findLastIndex)
export default findLast"
" * Iterates over elements of `array`, returning an array of all elements * `predicate` returns truthy for. The predicate is invoked with three * arguments: (value, index, array). * * **Note:** Unlike `remove`, this method returns a new array. * *  5.0.0 * @category Array *    The array to iterate over. *    The function invoked per iteration. *   Returns the new filtered array. *   pullAll, pullAllBy, pullAllWith, pullAt, remove, reject *  * *  *    *    *  * *  *  */function filter(array, predicate) {  let index = -1  let resIndex = 0  const length = array == null ? 0 : array.length  const result = []
  while (++index < length) {    const value = array[index]    if (predicate(value, index, array)) {      result[resIndex++] = value    }  }  return result}
export default filter"
" * Checks if `predicate` returns truthy for **all** properties of `object`. * Iteration is stopped once `predicate` returns falsey. The predicate is * invoked with three arguments: (value, key, object). * * **Note:** This method returns `true` for * [empty objects](https://en.wikipedia.org/wiki/Empty_set) because * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of * elements of empty objects. * *  5.0.0 * @category Object *    The object to iterate over. *    The function invoked per iteration. *   Returns `true` if all properties pass the predicate check, *  else `false`. *  * *  *  */function everyValue(object, predicate) {  object = Object(object)  const props = Object.keys(object)
  for (const key of props) {    if (!predicate(object[key], key, object)) {      return false    }  }  return true}
export default everyValue"
" * Checks if `predicate` returns truthy for **all** elements of `array`. * Iteration is stopped once `predicate` returns falsey. The predicate is * invoked with three arguments: (value, index, array). * * **Note:** This method returns `true` for * [empty arrays](https://en.wikipedia.org/wiki/Empty_set) because * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of * elements of empty arrays. * *  5.0.0 * @category Array *    The array to iterate over. *    The function invoked per iteration. *   Returns `true` if all elements pass the predicate check, *  else `false`. *  * *  *  */function every(array, predicate) {  let index = -1  const length = array == null ? 0 : array.length
  while (++index < length) {    if (!predicate(array[index], index, array)) {      return false    }  }  return true}
export default every"
" * Used to match `RegExp` * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns). */const reRegExpChar = gconst reHasRegExpChar = RegExp(reRegExpChar.source)
 * Escapes the `RegExp` special characters ""^"", ""$"", ""\"", ""."", ""*"", ""+"", * ""?"", ""("", "")"", ""["", ""]"", ""{"", ""}"", and ""|"" in `string`. * *  3.0.0 * @category String *    The string to escape. *   Returns the escaped string. *   escapeRegExp, unescape *  * *  *  */function escapeRegExp(string) {  return (string && reHasRegExpChar.test(string))    ? string.replace(reRegExpChar, $&)    : string}
export default escapeRegExp"
"const htmlEscapes = {  &: &amp,  <: &lt,  >: &gt,  "": &quot,  ': &#39}
const reUnescapedHtml = gconst reHasUnescapedHtml = RegExp(reUnescapedHtml.source)
 * Converts the characters ""&"", ""<"", "">"", '""', and ""'"" in `string` to their * corresponding HTML entities. * * **Note:** No other characters are escaped. To escape additional * characters use a third-party library like [_he_](https://mths.be/he). * * Though the "">"" character is escaped for symmetry, characters like * "">"" and ""/"" don't need escaping in HTML and have no special meaning * unless they're part of a tag or unquoted attribute value. See * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands) * (under ""semi-related fun fact"") for more details. * * When working with HTML you should always * [quote attribute values](http://wonko.com/post/html-escaping) to reduce * XSS vectors. * *  0.1.0 * @category String *    The string to escape. *   Returns the escaped string. *   unescape *  * *  *  */function escape(string) {  return (string && reHasUnescapedHtml.test(string))    ? string.replace(reUnescapedHtml, (chr) => htmlEscapes[chr])    : string}
export default escape"
"import baseIsEqual from ./.internal/baseIsEqual.js
 * Performs a deep comparison between two values to determine if they are * equivalent. * * **Note:** This method supports comparing arrays, array buffers, booleans, * date objects, error objects, maps, numbers, `Object` objects, regexes, * sets, strings, symbols, and typed arrays. `Object` objects are compared * by their own, not inherited, enumerable properties. Functions and DOM * nodes are compared by strict equality, i.e. `===`. * *  0.1.0 * @category Lang *    The value to compare. *    The other value to compare. *   Returns `true` if the values are equivalent, else `false`. *  * *  *  * *  *  * *  *  */function isEqual(value, other) {  return baseIsEqual(value, other)}
export default isEqual"
" * Performs a * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * comparison between two values to determine if they are equivalent. * *  4.0.0 * @category Lang *    The value to compare. *    The other value to compare. *   Returns `true` if the values are equivalent, else `false`. *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  */function eq(value, other) {  return value === other || (value !== value && other !== other)}
export default eq"
" * Checks if `string` ends with the given target string. * *  3.0.0 * @category String *    The string to inspect. *    The string to search for. *    The position to search up to. *   Returns `true` if `string` ends with `target`, *  else `false`. *   startsWith *  * *  *  * *  *  * *  *  */function endsWith(string, target, position) {  const { length } = string  position = position === undefined ? length : +position  if (position < 0 || position != position) {    position = 0  }  else if (position > length) {    position = length  }  const end = position  position -= target.length  return position >= 0 && string.slice(position, end) == target}
export default endsWith"
export { default } from ./forEachRight.js
export { default } from ./forEach.js
"import baseWhile from ./.internal/baseWhile.js
 * Creates a slice of `array` excluding elements dropped from the beginning. * Elements are dropped until `predicate` returns falsey. The predicate is * invoked with three arguments: (value, index, array). * *  3.0.0 * @category Array *    The array to query. *    The function invoked per iteration. *   Returns the slice of `array`. *  * *  *    *    *    *  * *  *  */function dropWhile(array, predicate) {  return (array != null && array.length)    ? baseWhile(array, predicate, true)    : []}
export default dropWhile"
"import baseWhile from ./.internal/baseWhile.js
 * Creates a slice of `array` excluding elements dropped from the end. * Elements are dropped until `predicate` returns falsey. The predicate is * invoked with three arguments: (value, index, array). * *  3.0.0 * @category Array *    The array to query. *    The function invoked per iteration. *   Returns the slice of `array`. *  * *  *    *    *    *  * *  *  */function dropRightWhile(array, predicate) {  return (array != null && array.length)    ? baseWhile(array, predicate, true, true)    : []}
export default dropRightWhile"
"import slice from ./slice.js
 * Creates a slice of `array` with `n` elements dropped from the end. * *  3.0.0 * @category Array *    The array to query. *    The number of elements to drop. *   Returns the slice of `array`. *  * *  *  * *  *  * *  *  * *  *  */function dropRight(array, n=1) {  const length = array == null ? 0 : array.length  if (!length) {    return []  }  n = length - n  return slice(array, 0, n < 0 ? 0 : n)}
export default dropRight"
"import slice from ./slice.js
 * Creates a slice of `array` with `n` elements dropped from the beginning. * *  0.5.0 * @category Array *    The array to query. *    The number of elements to drop. *   Returns the slice of `array`. *  * *  *  * *  *  * *  *  * *  *  */function drop(array, n=1) {  const length = array == null ? 0 : array.length  return length    ? slice(array, n < 0 ? 0 : n, length)    : []}
export default drop"
"import createMathOperation from ./.internal/createMathOperation.js
 * Divide two numbers. * *  4.7.0 * @category Math *    The first number in a division. *    The second number in a division. *   Returns the quotient. *  * *  *  */const divide = createMathOperation((dividend, divisor) => dividend / divisor, 1)
export default divide"
"import baseDifference from ./.internal/baseDifference.jsimport baseFlatten from ./.internal/baseFlatten.jsimport isArrayLikeObject from ./isArrayLikeObject.jsimport last from ./last.js
 * This method is like `difference` except that it accepts `comparator` * which is invoked to compare elements of `array` to `values`. The order and * references of result values are determined by the first array. The comparator * is invoked with two arguments: (arrVal, othVal). * * **Note:** Unlike `pullAllWith`, this method returns a new array. * *  4.0.0 * @category Array *    The array to inspect. *    The values to exclude. *    The comparator invoked per element. *   Returns the new array of filtered values. *  * *  * *  *  */function differenceWith(array, ...values) {  let comparator = last(values)  if (isArrayLikeObject(comparator)) {    comparator = undefined  }  return isArrayLikeObject(array)    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)    : []}
export default differenceWith"
"import baseDifference from ./.internal/baseDifference.jsimport baseFlatten from ./.internal/baseFlatten.jsimport isArrayLikeObject from ./isArrayLikeObject.jsimport last from ./last.js
 * This method is like `difference` except that it accepts `iteratee` which * is invoked for each element of `array` and `values` to generate the criterion * by which they're compared. The order and references of result values are * determined by the first array. The iteratee is invoked with one argument: * (value). * * **Note:** Unlike `pullAllBy`, this method returns a new array. * *  4.0.0 * @category Array *    The array to inspect. *    The values to exclude. *    The iteratee invoked per element. *   Returns the new array of filtered values. *  * *  *  */function differenceBy(array, ...values) {  let iteratee = last(values)  if (isArrayLikeObject(iteratee)) {    iteratee = undefined  }  return isArrayLikeObject(array)    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), iteratee)    : []}
export default differenceBy"
"import baseDifference from ./.internal/baseDifference.jsimport baseFlatten from ./.internal/baseFlatten.jsimport isArrayLikeObject from ./isArrayLikeObject.js
 * Creates an array of `array` values not included in the other given arrays * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. The order and references of result values are * determined by the first array. * * **Note:** Unlike `pullAll`, this method returns a new array. * *  0.1.0 * @category Array *    The array to inspect. *    The values to exclude. *   Returns the new array of filtered values. *   unionBy, unionWith, without, xor, xorBy, xorWith, *  * *  *  */function difference(array, ...values) {  return isArrayLikeObject(array)    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))    : []}
export default difference"
" * Invokes `func` after `wait` milliseconds. Any additional arguments are * provided to `func` when it's invoked. * *  0.1.0 * @category Function *    The function to delay. *    The number of milliseconds to delay invocation. *    The arguments to invoke `func` with. *   Returns the timer id. *  * *  *  */function delay(func, wait, ...args) {  if (typeof func != function) {    throw new TypeError(Expected a function)  }  return setTimeout(func, +wait || 0, ...args)}
export default delay"
" * Defers invoking the `func` until the current call stack has cleared. Any * additional arguments are provided to `func` when it's invoked. * *  0.1.0 * @category Function *    The function to defer. *    The arguments to invoke `func` with. *   Returns the timer id. *  * *  *  */function defer(func, ...args) {  if (typeof func != function) {    throw new TypeError(Expected a function)  }  return setTimeout(func, 1, ...args)}
export default defer"
"import customDefaultsMerge from ./.internal/customDefaultsMerge.jsimport mergeWith from ./mergeWith.js
 * This method is like `defaults` except that it recursively assigns * default properties. * * **Note:** This method mutates `object`. * *  3.10.0 * @category Object *    The destination object. *    The source objects. *   Returns `object`. *   *  * *  *  */function defaultsDeep(...args) {  args.push(undefined, customDefaultsMerge)  return mergeWith.apply(undefined, args)}
export default defaultsDeep"
"import eq from ./eq.js
const objectProto = Object.prototype
const hasOwnProperty = objectProto.hasOwnProperty
 * Assigns own and inherited enumerable string keyed properties of source * objects to the destination object for all destination properties that * resolve to `undefined`. Source objects are applied from left to right. * Once a property is set, additional values of the same property are ignored. * * **Note:** This method mutates `object`. * *  0.1.0 * @category Object *    The destination object. *    The source objects. *   Returns `object`. *   *  * *  *  */function defaults(object, ...sources) {  object = Object(object)  sources.forEach((source) => {    if (source != null) {      source = Object(source)      for (const key in source) {        const value = object[key]        if (value === undefined ||            (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {          object[key] = source[key]        }      }    }  })  return object}
export default defaults"
" * Checks `value` to determine whether a default value should be returned in * its place. The `defaultValue` is returned if `value` is `NaN`, `null`, * or `undefined`. * *  4.14.0 * @category Util *    The value to check. *    The default value. *   Returns the resolved value. *  * *  *  * *  *  */function defaultTo(value, defaultValue) {  return (value == null || value !== value) ? defaultValue : value}
export default defaultTo"
"import deburrLetter from ./.internal/deburrLetter.js
const reLatin = g
const rsComboMarksRange = u0300-u036fconst reComboHalfMarksRange = ufe20-ufe2fconst rsComboSymbolsRange = u20d0-u20ffconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange
const rsCombo = []
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols). */const reComboMark = RegExp(rsCombo, g)
 * Deburrs `string` by converting * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) * letters to basic Latin letters and removing * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). * *  3.0.0 * @category String *    The string to deburr. *   Returns the deburred string. *  * *  *  */function deburr(string) {  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, )}
export default deburr"
"import isObject from ./isObject.js
 * Creates a debounced function that delays invoking `func` until after `wait` * milliseconds have elapsed since the last time the debounced function was * invoked. The debounced function comes with a `cancel` method to cancel * delayed `func` invocations and a `flush` method to immediately invoke them. * Provide `options` to indicate whether `func` should be invoked on the * leading and/or trailing edge of the `wait` timeout. The `func` is invoked * with the last arguments provided to the debounced function. Subsequent * calls to the debounced function return the result of the last `func` * invocation. * * **Note:** If `leading` and `trailing` options are `true`, `func` is * invoked on the trailing edge of the timeout only if the debounced function * is invoked more than once during the `wait` timeout. * * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred * until the next tick, similar to `setTimeout` with a timeout of `0`. * * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) * for details over the differences between `debounce` and `throttle`. * *  0.1.0 * @category Function *    The function to debounce. *    The number of milliseconds to delay. *    The options object. *    *  Specify invoking on the leading edge of the timeout. *    *  The maximum time `func` is allowed to be delayed before it's invoked. *    *  Specify invoking on the trailing edge of the timeout. *   Returns the new debounced function. *  * *  *  * *  *  *    *    *  * *  *  *  *  * *  *  */function debounce(func, wait, options) {  let lastArgs,    lastThis,    maxWait,    result,    timerId,    lastCallTime
  let lastInvokeTime = 0  let leading = false  let maxing = false  let trailing = true
  if (typeof func != function) {    throw new TypeError(Expected a function)  }  wait = +wait || 0  if (isObject(options)) {    leading = !!options.leading    maxing = maxWait in options    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait    trailing = trailing in options ? !!options.trailing : trailing  }
  function invokeFunc(time) {    const args = lastArgs    const thisArg = lastThis
    lastArgs = lastThis = undefined    lastInvokeTime = time    result = func.apply(thisArg, args)    return result  }
  function leadingEdge(time) {     Reset any `maxWait` timer.    lastInvokeTime = time     Start the timer for the trailing edge.    timerId = setTimeout(timerExpired, wait)     Invoke the leading edge.    return leading ? invokeFunc(time) : result  }
  function remainingWait(time) {    const timeSinceLastCall = time - lastCallTime    const timeSinceLastInvoke = time - lastInvokeTime    const result = wait - timeSinceLastCall
    return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result  }
  function shouldInvoke(time) {    const timeSinceLastCall = time - lastCallTime    const timeSinceLastInvoke = time - lastInvokeTime
     Either this is the first call, activity has stopped and we're at the     trailing edge, the system time has gone backwards and we're treating     it as the trailing edge, or we've hit the `maxWait` limit.    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait))  }
  function timerExpired() {    const time = Date.now()    if (shouldInvoke(time)) {      return trailingEdge(time)    }     Restart the timer.    timerId = setTimeout(timerExpired, remainingWait(time))  }
  function trailingEdge(time) {    timerId = undefined
     Only invoke if we have `lastArgs` which means `func` has been     debounced at least once.    if (trailing && lastArgs) {      return invokeFunc(time)    }    lastArgs = lastThis = undefined    return result  }
  function cancel() {    if (timerId !== undefined) {      clearTimeout(timerId)    }    lastInvokeTime = 0    lastArgs = lastCallTime = lastThis = timerId = undefined  }
  function flush() {    return timerId === undefined ? result : trailingEdge(Date.now())  }
  function debounced(...args) {    const time = Date.now()    const isInvoking = shouldInvoke(time)
    lastArgs = args    lastThis = this    lastCallTime = time
    if (isInvoking) {      if (timerId === undefined) {        return leadingEdge(lastCallTime)      }      if (maxing) {         Handle invocations in a tight loop.        timerId = setTimeout(timerExpired, wait)        return invokeFunc(lastCallTime)      }    }    if (timerId === undefined) {      timerId = setTimeout(timerExpired, wait)    }    return result  }  debounced.cancel = cancel  debounced.flush = flush  return debounced}
export default debounce"
"import createWrap from ./.internal/createWrap.js
const WRAP_CURRY_RIGHT_FLAG = 16
 * This method is like `curry` except that arguments are applied to `func` * in the manner of `partialRight` instead of `partial`. * * The `curryRight.placeholder` value, which defaults to `_` in monolithic * builds, may be used as a placeholder for provided arguments. * * **Note:** This method doesn't set the ""length"" property of curried functions. * *  3.0.0 * @category Function *    The function to curry. *    The arity of `func`. *   Returns the new curried function. *  * *  *    *  * *  * *  *  * *  *  * *  *  * *  *  *  */function curryRight(func, arity) {  const result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity)  result.placeholder = curryRight.placeholder  return result}
 Assign default placeholders.curryRight.placeholder = {}
export default curryRight"
"import createWrap from ./.internal/createWrap.js
const WRAP_CURRY_FLAG = 8
 * Creates a function that accepts arguments of `func` and either invokes * `func` returning its result, if at least `arity` number of arguments have * been provided, or returns a function that accepts the remaining `func` * arguments, and so on. The arity of `func` may be specified if `func.length` * is not sufficient. * * The `curry.placeholder` value, which defaults to `_` in monolithic builds, * may be used as a placeholder for provided arguments. * * **Note:** This method doesn't set the ""length"" property of curried functions. * *  2.0.0 * @category Function *    The function to curry. *    The arity of `func`. *   Returns the new curried function. *  * *  *    *  * *  * *  *  * *  *  * *  *  * *  *  *  */function curry(func, arity) {  const result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity)  result.placeholder = curry.placeholder  return result}
 Assign default placeholders.curry.placeholder = {}
export default curry"
" * Creates an object that inherits from the `prototype` object. If a * `properties` object is given, its own enumerable string keyed properties * are assigned to the created object. * *  2.3.0 * @category Object *    The object to inherit from. *    The properties to assign to the object. *   Returns the new object. *  * *  *    *    *  * *  *    *  * *  *    *  * *  *  *  * *  *  */function create(prototype, properties) {  prototype = prototype === null ? null : Object(prototype)  const result = Object.create(prototype)  return properties == null ? result : Object.assign(result, properties)}
export default create"
"import baseAssignValue from ./.internal/baseAssignValue.jsimport reduce from ./reduce.js
const hasOwnProperty = Object.prototype.hasOwnProperty
 * Creates an object composed of keys generated from the results of running * each element of `collection` thru `iteratee`. The corresponding value of * each key is the number of times the key was returned by `iteratee`. The * iteratee is invoked with one argument: (value). * *  0.5.0 * @category Collection *    The collection to iterate over. *    The iteratee to transform keys. *   Returns the composed aggregate object. *  * *  *  */function countBy(collection, iteratee) {  return reduce(collection, (result, value, key) => {    key = iteratee(value)    if (hasOwnProperty.call(result, key)) {      ++result[key]    } else {      baseAssignValue(result, key, 1)    }    return result  }, {})}
export default countBy"
"import baseConformsTo from ./.internal/baseConformsTo.jsimport keys from ./keys.js
 * Checks if `object` conforms to `source` by invoking the predicate * properties of `source` with the corresponding property values of `object`. * * **Note:** This method is equivalent to `conforms` when `source` is * partially applied. * *  4.14.0 * @category Lang *    The object to inspect. *    The object of property predicates to conform to. *   Returns `true` if `object` conforms, else `false`. *  * *  * *  *  * *  *  */function conformsTo(object, source) {  return source == null || baseConformsTo(object, source, keys(source))}
export default conformsTo"
"import baseClone from ./.internal/baseClone.jsimport baseConforms from ./.internal/baseConforms.js
const CLONE_DEEP_FLAG = 1
 * Creates a function that invokes the predicate properties of `source` with * the corresponding property values of a given object, returning `true` if * all predicates return truthy, else `false`. * * **Note:** The created function is equivalent to `conformsTo` with * `source` partially applied. * *  4.0.0 * @category Util *    The object of property predicates to conform to. *   Returns the new spec function. *  * *  *    *    *  * *  *  */function conforms(source) {  return baseConforms(baseClone(source, CLONE_DEEP_FLAG))}
export default conforms"
"import map from ./map.js
 * Creates a function that iterates over `pairs` and invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with the `this` binding and arguments of the created * function. * *  4.0.0 * @category Util *    The predicate-function pairs. *   Returns the new composite function. *  * *  *    *    *    *  * *  *  * *  *  * *  *  */function cond(pairs) {  const length = pairs == null ? 0 : pairs.length
  pairs = !length ? [] : map(pairs, (pair) => {    if (typeof pair[1] != function) {      throw new TypeError(Expected a function)    }    return [pair[0], pair[1]]  })
  return (...args) => {    for (const pair of pairs) {      if (pair[0].apply(this, args)) {        return pair[1].apply(this, args)      }    }  }}
export default cond"
" * Creates an array with all falsey values removed. The values `false`, `null`, * `0`, `""""`, `undefined`, and `NaN` are falsey. * *  0.1.0 * @category Array *    The array to compact. *   Returns the new array of filtered values. *  * *  *  */function compact(array) {  let resIndex = 0  const result = []
  if (array == null) {    return result  }
  for (const value of array) {    if (value) {      result[resIndex++] = value    }  }  return result}
export default compact"
"import baseClone from ./.internal/baseClone.js
const CLONE_SYMBOLS_FLAG = 4
 * This method is like `clone` except that it accepts `customizer` which * is invoked to produce the cloned value. If `customizer` returns `undefined`, * cloning is handled by the method instead. The `customizer` is invoked with * up to four arguments (value [, index|key, object, stack]). * *  4.0.0 * @category Lang *    The value to clone. *    The function to customize cloning. *   Returns the cloned value. *   *  * *  *    *      *    *  * *  * *  *  *  *  *  *  */function cloneWith(value, customizer) {  customizer = typeof customizer == function ? customizer : undefined  return baseClone(value, CLONE_SYMBOLS_FLAG, customizer)}
export default cloneWith"
"import baseClone from ./.internal/baseClone.js
const CLONE_DEEP_FLAG = 1const CLONE_SYMBOLS_FLAG = 4
 * This method is like `cloneWith` except that it recursively clones `value`. * *  4.0.0 * @category Lang *    The value to recursively clone. *    The function to customize cloning. *   Returns the deep cloned value. *   *  * *  *    *      *    *  * *  * *  *  *  *  *  *  */function cloneDeepWith(value, customizer) {  customizer = typeof customizer == function ? customizer : undefined  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer)}
export default cloneDeepWith"
"import baseClone from ./.internal/baseClone.js
const CLONE_DEEP_FLAG = 1const CLONE_SYMBOLS_FLAG = 4
 * This method is like `clone` except that it recursively clones `value`. * *  1.0.0 * @category Lang *    The value to recursively clone. *   Returns the deep cloned value. *   *  * *  * *  *  *  */function cloneDeep(value) {  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)}
export default cloneDeep"
"import baseClone from ./.internal/baseClone.js
const CLONE_SYMBOLS_FLAG = 4
 * Creates a shallow clone of `value`. * * **Note:** This method is loosely based on the * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm) * and supports cloning arrays, array buffers, booleans, date objects, maps, * numbers, `Object` objects, regexes, sets, strings, symbols, and typed * arrays. The own enumerable properties of `arguments` objects are cloned * as plain objects. An empty object is returned for uncloneable values such * as error objects, functions, DOM nodes, and WeakMaps. * *  0.1.0 * @category Lang *    The value to clone. *   Returns the cloned value. *   *  * *  * *  *  *  */function clone(value) {  return baseClone(value, CLONE_SYMBOLS_FLAG)}
export default clone"
" * Clamps `number` within the inclusive `lower` and `upper` bounds. * *  4.0.0 * @category Number *    The number to clamp. *    The lower bound. *    The upper bound. *   Returns the clamped number. *  * *  *  * *  *  */function clamp(number, lower, upper) {  number = +number  lower = +lower  upper = +upper  lower = lower === lower ? lower : 0  upper = upper === upper ? upper : 0  if (number === number) {    number = number <= upper ? number : upper    number = number >= lower ? number : lower  }  return number}
export default clamp"
"import slice from ./slice.js
 * Creates an array of elements split into groups the length of `size`. * If `array` can't be split evenly, the final chunk will be the remaining * elements. * *  3.0.0 * @category Array *    The array to process. *    The length of each chunk *   Returns the new array of chunks. *  * *  *  * *  *  */function chunk(array, size) {  size = Math.max(size, 0)  const length = array == null ? 0 : array.length  if (!length || size < 1) {    return []  }  let index = 0  let resIndex = 0  const result = new Array(Math.ceil(length / size))
  while (index < length) {    result[resIndex++] = slice(array, index, (index += size))  }  return result}
export default chunk"
"import createRound from ./.internal/createRound.js
 * Computes `number` rounded up to `precision`. * *  3.10.0 * @category Math *    The number to round up. *    The precision to round up to. *   Returns the rounded up number. *  * *  *  * *  *  * *  *  */const ceil = createRound(ceil)
export default ceil"
"
 * Casts `value` as an array if it's not one. * *  4.4.0 * @category Lang *    The value to inspect. *   Returns the cast array. *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  * *  *  *  */function castArray(...args) {  if (!args.length) {    return []  }  const value = args[0]  return Array.isArray(value) ? value : [value]}
export default castArray"
"import upperFirst from ./upperFirst.js
 * Converts the first character of `string` to upper case and the remaining * to lower case. * *  3.0.0 * @category String *    The string to capitalize. *   Returns the capitalized string. *  * *  *  */function capitalize(string) {  return upperFirst(string.toLowerCase())}
export default capitalize"
"import capitalize from ./capitalize.jsimport words from ./words.js
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase). * *  3.0.0 * @category String *    The string to convert. *   Returns the camel cased string. *   kebabCase, snakeCase, startCase, upperCase, upperFirst *  * *  *  * *  *  * *  *  */const camelCase = (string) => (  words(.replace(g, )).reduce((result, word, index) => {    word = word.toLowerCase()    return result + (index ? capitalize(word) : word)  }, ))
export default camelCase"
"import createWrap from ./.internal/createWrap.jsimport getHolder from ./.internal/getHolder.jsimport replaceHolders from ./.internal/replaceHolders.js
const WRAP_BIND_FLAG = 1const WRAP_BIND_KEY_FLAG = 2const WRAP_PARTIAL_FLAG = 32
 * Creates a function that invokes the method at `object[key]` with `partials` * prepended to the arguments it receives. * * This method differs from `bind` by allowing bound functions to reference * methods that may be redefined or don't yet exist. See * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern) * for more details. * * The `bindKey.placeholder` value, which defaults to `_` in monolithic * builds, may be used as a placeholder for partially applied arguments. * *  0.10.0 * @category Function *    The object to invoke the method on. *    The key of the method. *    The arguments to be partially applied. *   Returns the new bound function. *  * *  *    *    *      *    *  * *  *  *  * *  *    *  * *  *  * *  *  *  *  */function bindKey(object, key, ...partials) {  let holders  let bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG  if (partials.length) {    holders = replaceHolders(partials, getHolder(bindKey))    bitmask |= WRAP_PARTIAL_FLAG  }  return createWrap(key, bitmask, object, partials, holders)}
 Assign default placeholders.bindKey.placeholder = {}
export default bindKey"
" * Creates a function that invokes `func`, with the `this` binding and arguments * of the created function, while it's called less than `n` times. Subsequent * calls to the created function return the result of the last `func` invocation. * *  3.0.0 * @category Function *    The number of calls at which `func` is no longer invoked. *    The function to restrict. *   Returns the new restricted function. *  * *  *  */function before(n, func) {  let result  if (typeof func != function) {    throw new TypeError(Expected a function)  }  return function(...args) {    if (--n > 0) {      result = func.apply(this, args)    }    if (n <= 1) {      func = undefined    }    return result  }}
export default before"
"import isError from ./isError.js
 * Attempts to invoke `func`, returning either the result or the caught error * object. Any additional arguments are provided to `func` when it's invoked. * *  3.0.0 * @category Util *    The function to attempt. *    The arguments to invoke `func` with. *   Returns the `func` result or error object. *  * *  *  *    * *  *    *  */function attempt(func, ...args) {  try {    return func.apply(undefined, args)  } catch (e) {    return isError(e) ? e : new Error(e)  }}
export default attempt"
"import baseAt from ./.internal/baseAt.js
 * Creates an array of values corresponding to `paths` of `object`. * *  1.0.0 * @category Object *    The object to iterate over. *    The property paths to pick. *   Returns the picked values. *  * *  * *  *  */function at(...paths) {  return baseAt(paths)}
export default at"
"import copyObject from ./.internal/copyObject.jsimport createAssigner from ./.internal/createAssigner.jsimport keys from ./keys.js
 * This method is like `assign` except that it accepts `customizer` * which is invoked to produce the assigned values. If `customizer` returns * `undefined`, assignment is handled by the method instead. The `customizer` * is invoked with five arguments: (objValue, srcValue, key, object, source). * * **Note:** This method mutates `object`. * *  4.0.0 * @category Object *    The destination object. *    The source objects. *    The function to customize assigned values. *   Returns `object`. *   *  * *  *    *  * *  * *  *  */const assignWith = createAssigner((object, source, srcIndex, customizer) => {  copyObject(source, keys(source), object, customizer)})
export default assignWith"
"import createWrap from ./.internal/createWrap.js
const WRAP_ARY_FLAG = 128
 * Creates a function that invokes `func`, with up to `n` arguments, * ignoring any additional arguments. * *  3.0.0 * @category Function *    The function to cap arguments for. *    The arity cap. *   Returns the new capped function. *  * *  *  */function ary(func, n) {  n = (func && n == null) ? func.length : n  return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n)}
export default ary"
" * The opposite of `before`his method creates a function that invokes * `func` once it's called `n` or more times. * *  0.1.0 * @category Function *    The number of calls before `func` is invoked. *    The function to restrict. *   Returns the new restricted function. *  * *  *  * *  *  */function after(n, func) {  if (typeof func != function) {    throw new TypeError(Expected a function)  }  return function(...args) {    if (--n < 1) {      return func.apply(this, args)    }  }}
export default after"
"import createMathOperation from ./.internal/createMathOperation.js
 * Adds two numbers. * *  3.4.0 * @category Math *    The first number in an addition. *    The second number in an addition. *   Returns the total. *  * *  *  */const add = createMathOperation((augend, addend) => augend + addend, 0)
export default add"
