keywords
"function primeGenerator(num, showPrimes) {
  var i,
      arr = [];
 
  function isPrime(num) {
    
    if (num <= 16) return (
      num == 2 || num == 3 || num == 5 || num == 7 || num == 11 || num == 13
    );
    
    if (num % 2 == 0 || num % 3 == 0 || num % 5 == 0 || num % 7 == 0)
      return false;
    
    for (var i = 10; i * i <= num; i += 10) {
      if (num % (i + 1) == 0) return false;
      if (num % (i + 3) == 0) return false;
      if (num % (i + 7) == 0) return false;
      if (num % (i + 9) == 0) return false;
    }
    return true;
  }
 
  if (typeof num == strv) {
    for (i = 0; arr.length < num; i++) if (isPrime(i)) arr.push(i);
    
    if (showPrimes) return arr;
    
    else return arr.pop();
  }
 
  if (Array.isArray(num)) {
    for (i = num[0]; i <= num[1]; i++) if (isPrime(i)) arr.push(i);
    
    if (showPrimes) return arr;
    
    else return arr.length;
  }
  
  
  throw(strv);
}"
"function pow(base, exp) {
    if (exp != Math.floor(exp)) 
        throw strv;
    if (exp < 0) 
        return 1 / pow(base, -exp);
    var ans = 1;
    while (exp > 0) {
        ans *= base;
        exp--;
    }
    return ans;
}"
"var number = Math.ceil(Math.random() * 100);
 
function verify() {
    var guess = Number(this.elements.guess.value),
        output = document.getElementById('output');
 
    if (isNaN(guess)) {
        output.innerHTML = 'Enter a number.';
    } else if (number === guess) {
        output.innerHTML = 'You guessed right!';
    } else if (guess > 100) {
        output.innerHTML = 'Your guess is out of the 1 to 100 range.';
    } else if (guess > number) {
        output.innerHTML = 'Your guess is too high.';
    } else if (guess < number) {
        output.innerHTML = 'Your guess is too low.';
    }
    return false;
}
 
document.getElementById('guessNumber').onsubmit = verify;#!/usr/bin/env js
 
function main() {
    guessTheNumber(1, 100);
}
 
function guessTheNumber(low, high) {
    var num = randOnRange(low, high);
    var guessCount = 0;
 
    function checkGuess(n) {
        if (n < low || n > high) {
            print('That number is not between ' + low + ' and ' + high + '!');
            return false;
        }
 
        if (n == num) {
            print('You got it in ' + String(guessCount) + ' tries.');
            return true;
        }
 
        if (n < num) {
            print('Too low.');
        } else {
            print('Too high.');
        }
        return false;
    }
 
    print('I have picked a number between ' + low + ' and ' + high + '. Try to guess it!');
    while (true) {
        guessCount++;
        putstr(strv);
        var n = parseInt(readline());
        if (checkGuess(n)) break;
    }
}
 
function randOnRange(low, high) {
    var r = Math.random();
    return Math.floor(r * (high - low + 1)) + low;
}
 
main();
 "
"<html><body>
<script type=strv>
var width = 640; var height = 400;
var c = document.createElement(strv);
c.setAttribute('id',    'myCanvas'); 
c.setAttribute('style', 'border:1px solid black;'); 
c.setAttribute('width',  width);
c.setAttribute('height', height); 
document.body.appendChild(c);
var ctx = document.getElementById('myCanvas').getContext(strv);
 
var columnCount = 8;    
var rowCount    = 4;    
var direction   = 1;    
var blackLeft   = 1;    
for(var j = 0; j < rowCount; j++){  
    for(var i = 0; i < columnCount; i++){
        ctx.fillStyle = 'rgba(0,0,0,'+ (blackLeft-(1/(columnCount-1)*i))*direction +')';  
        ctx.fillRect(
            (width/columnCount)*i,(height/rowCount)*j,
            (width/columnCount),(height/rowCount)
            ); 
        }
    columnCount *= 2; 
    direction *= -1; 
    blackLeft = blackLeft ? 0 : 1;
    }
</script>
</body></html>
 "
" 
function guessNumber() {
  
  var num = Math.ceil(Math.random() * 10);
  var guess;
 
  while (guess != num) {
    guess = prompt('Guess the number between 1 and 10 inclusive');
  }
  alert('Congratulations!The number was ' + num);
}
 
guessNumber();"
"<!DOCTYPE HTML PUBLIC strv
        strv>
<html><head><script type=strv>
window.addEventListener(
    strv, function(){   
        var img = new Image();   
        
        
        
        
        img.src = 
            'data:image/gif;base64,R0lGODlhEAAOALMAAOazToeHh0tLS/7LZv/0jvb29t/f3//Ub/            /ge8WSLf/rhf/3kdbW1mxsbP//mf///yH5BAAAAAAALAAAAAAQAA4AAARe8L1Ekyky67QZ1hLnjM5UUde0ECwLJoExKcpp            V0aCcGCmTIHEIUEqjgaORCMxIC6e0CcguWw6aFjsVMkkIr7g77ZKPJjPZqIyd7sJAgVGoEGv2xsBxqNgYPj/gAwXEQA7'; 
        img.onload = function(){ 
            var can1 = new CustomCanvas(strv, img.width, img.height);
            var can2 = new CustomCanvas(strv,  img.width, img.height);
            can1.ctx.drawImage(img,0, 0, img.width, img.height); 
            var imgData = can1.ctx.getImageData(0, 0, can1.w, can1.h);      
            
            var avg; var max; var rwgt=0.2126; var gwgt=0.7152;  var bwgt=0.0722;
            for(var i = 0, max = can1.w*can1.h*4; i < max; i=i+4){
                avg = imgData.data[i]*rwgt + imgData.data[i+1]*gwgt + imgData.data[i+2]*bwgt;
                imgData.data[i  ] = avg;  
                imgData.data[i+1] = avg;  
                imgData.data[i+2] = avg;} 
            can2.ctx.putImageData(imgData, 0, 0);  
            }
        }, false); 
 
    function CustomCanvas(id, w, h, s) { /* Custom Canvas Object */
        var c = document.createElement(strv);
        c.setAttribute('id', id); c.setAttribute('width', w);
        c.setAttribute('height', h); (s)?c.setAttribute('style', s):0;
        document.body.appendChild(c, document.body.firstChild);
        this.ctx = document.getElementById(id).getContext(strv);
        this.w = w; this.h = h;}           
</script></head><body></body></html>
 "
"function MaximumSubsequence(population) {
    var maxValue = 0;
    var subsequence = [];
 
    for (var i = 0, len = population.length; i < len; i++) {
        for (var j = i; j <= len; j++) {
            var subsequence = population.slice(i, j);
            var value = sumValues(subsequence);
            if (value > maxValue) {
                maxValue = value;
                greatest = subsequence;
            };
        }
    }
 
    return greatest;
}
 
function sumValues(arr) {
    var result = 0;
    for (var i = 0, len = arr.length; i < len; i++) {
        result += arr[i];
    }
    return result;
}"
"var GA = function () {
    function e(n) {
	var result = [];
	result[1 << n] = 1;
	return result;
    }
    function cdot(a, b) { return mul([0.5], add(mul(a, b), mul(b, a))) }
    function neg(x) { return mul([-1], x) }
    function bitCount(i) {
	
	i = i - ((i >> 1) & 0x55555555);
	i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
	i = (i + (i >> 4)) & 0x0F0F0F0F;
	i = i + (i >> 8);
	i = i + (i >> 16);
	return i & 0x0000003F;
    }
    function reorderingSign(a, b) {
	a >>= 1;
	var sum = 0;
	while (a != 0) {
	    sum += bitCount(a & b);
	    a >>= 1;
	}
	return (sum & 1) == 0 ? 1 : -1;
    }
    function add(a, b) {
	var result = a.slice(0);
	for (var i in b) {
	    if (result[i]) {
		result[i] += b[i];
	    } else {
		result[i] = b[i];
	    }
	}
	return result;
    }
    function mul(a, b)
    {
	var result = [];
	for (var i in a) {
	    if (a[i]) {
		for (var j in b) {
		    if (b[j]) {
			var s = reorderingSign(i, j) * a[i] * b[j];
			
			var k = i ^ j;
			if (result[k]) {
			    result[k] += s;
			} else {
			    result[k] = s;
			}
		    }
		}
	    }
	}
	return result;
    }
    return {
	e   : e,
	cdot : cdot,
	neg : neg,
	add : add,
	mul : mul
    };
}();var e = GA.e, cdot = GA.cdot;
 
for (var i = 0; i < 5; i++) {
    for (var j = 0; j < 5; j++) {
        if (i < j) {
            if (cdot(e(i), e(j))[0]) { console.log(strv); }
        } else if (i === j) {
            if (!cdot(e(i), e(j))[0]) { console.log(strv); }
        }
    }
}
 
function randomVector() {
    var result = [];
    for (var i = 0; i < 5; i++) { result = GA.add( result, GA.mul([Math.random()], e(i))); }
    return result;
}
function randomMultiVector() {
    var result = [];
    for (var i = 0; i < 32; i++) { result[i] = Math.random(); }
    return result;
}
 
var a = randomMultiVector(), b = randomMultiVector(), c = randomMultiVector();
var x = randomVector();
 

console.log(GA.mul(GA.mul(a, b), c));
console.log(GA.mul(a, GA.mul(b, c)));
 

console.log(GA.mul(a, GA.add(b, c)));
console.log(GA.add(GA.mul(a,b), GA.mul(a, c)));
 

console.log(GA.mul(GA.add(a, b), c));
console.log(GA.add(GA.mul(a,c), GA.mul(b, c)));
 

console.log(GA.mul(x, x));"
"Math.max.apply(null, [ 0, 1, 2, 5, 4 ]); (function () {
 
    
    function maximumBy(f, xs) {
        return xs.reduce(function (a, x) {
            return a === undefined ? x : (
                f(x, a) > 0 ? x : a
            );
        }, undefined);
    }
 
    
 
    //Ordering: (LT|EQ|GT)
    
    
    
 
    function wordSortFirst(a, b) {
        return a < b ? 1 : (a > b ? -1 : 0)
    }
 
    function wordSortLast(a, b) {
        return a < b ? -1 : (a > b ? 1 : 0)
    }
 
    function wordLongest(a, b) {
        return a.length - b.length;
    }
 
    function cityPopulationMost(a, b) {
        return a.population - b.population;
    }
 
    function cityPopulationLeast(a, b) {
        return b.population - a.population;
    }
 
    function cityNameSortFirst(a, b) {
        var strA = a.name,
            strB = b.name;
 
        return strA < strB ? 1 : (strA > strB ? -1 : 0);
    }
 
    function cityNameSortLast(a, b) {
        var strA = a.name,
            strB = b.name;
 
        return strA < strB ? -1 : (strA > strB ? 1 : 0);
    }
 
    var lstWords = [
            'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta',
            'theta', 'iota', 'kappa', 'lambda'
        ];
 
    var lstCities = [
        {
            name: 'Shanghai',
            population: 24.15
            }, {
            name: 'Karachi',
            population: 23.5
            }, {
            name: 'Beijing',
            population: 21.5
            }, {
            name: 'Tianjin',
            population: 14.7
            }, {
            name: 'Istanbul',
            population: 14.4
            }, , {
            name: 'Lagos',
            population: 13.4
            }, , {
            name: 'Tokyo',
            population: 13.3
            }
        ];
 
    return [
        maximumBy(wordSortFirst, lstWords),
        maximumBy(wordSortLast, lstWords),
        maximumBy(wordLongest, lstWords),
        maximumBy(cityPopulationMost, lstCities),
        maximumBy(cityPopulationLeast, lstCities),
        maximumBy(cityNameSortFirst, lstCities),
        maximumBy(cityNameSortLast, lstCities)
    ]
 
})();[
  strv,
  strv,
  strv,
  {
    strv: strv,
    strv: 24.15
  },
  {
    strv: strv,
    strv: 13.3
  },
  {
    strv: strv,
    strv: 21.5
  },
  {
    strv: strv,
    strv: 13.3
  }
]Math.max(...[ 0, 1, 2, 5, 4 ]); (() => {
    'use strict';
 
    
 
    
    const maximumBy = (f, xs) =>
        xs.reduce((a, x) => a === undefined ? x : (
            f(x, a) > 0 ? x : a
        ), undefined);
 
    
    const comparing = f =>
        (x, y) => {
            const
                a = f(x),
                b = f(y);
            return a < b ? -1 : a > b ? 1 : 0
        };
 
 
    
    const words = [strv, strv, strv, strv, strv, strv, strv];
    const cities = [{
        k: 'Bejing',
        n: 21.5
    }, {
        k: 'Delhi',
        n: 16.7
    }, {
        k: 'Karachi',
        n: 23.5
    }, {
        k: 'Lagos',
        n: 16.0
    }, {
        k: 'Shanghai',
        n: 24.3
    }];
 
    
    const length = xs => xs.length;
 
    
    const population = dct => dct.n;
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    
    return show({
        byWordLength: maximumBy(comparing(length), words),
        byCityPopulation: maximumBy(comparing(population), cities)
    });
})();"
"function gcd(a,b) {
  a = Math.abs(a);
  b = Math.abs(b);
 
  if (b > a) {
    var temp = a;
    a = b;
    b = temp; 
  }
 
  while (true) {
    a %= b;
    if (a === 0) { return b; }
    b %= a;
    if (b === 0) { return a; }
  }
}function gcd_rec(a, b) {
  return b ? gcd_rec(b, a % b) : Math.abs(a);
}function GCD(arr) {
  var i, y,
      n = arr.length,
      x = Math.abs(arr[0]);
 
  for (i = 1; i < n; i++) {
    y = Math.abs(arr[i]);
 
    while (x && y) {
      (x > y) ? x %= y : y %= x;
    }
    x += y;
  }
  return x;
}
 
//For example:
GCD([57,0,-45,-18,90,447]); //=> 3
 function gcd(a: number, b: number) {
  a = Math.abs(a);
  b = Math.abs(b);
 
  if (b > a) {
    let temp = a;
    a = b;
    b = temp; 
  }
 
  while (true) {
    a %= b;
    if (a === 0) { return b; }
    b %= a;
    if (b === 0) { return a; }
  }
}function gcd_rec(a: number, b: number) {
  return b ? gcd_rec(b, a % b) : Math.abs(a);
}"
"> Math.pow(0, 0);
1"
"(() => {
    'use strict';
 
    
    function zeckendorf(n) {
        let f = (n, x) => (n < x ? [n, 0] : [n - x, 1]);
 
        return (n === 0 ? (
                [0]
            ) : mapAccumL(f, n, reverse(tail(fibUntil(n))))[1])
            .join('');
    }
 
 
    
    let fibUntil = n => {
        let xs = [];
        until(
            ([a, b]) => a > n,
            ([a, b]) => (xs.push(a), [b, a + b]), [1, 1]
        )
        return xs;
    }
 
    
 
    
    let mapAccumL = (f, acc, xs) => {
        return xs.reduce((a, x) => {
            let pair = f(a[0], x);
 
            return [pair[0], a[1].concat(pair[1])];
        }, [acc, []]);
    }
 
    
    let until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    }
 
    
    let tail = xs => xs.length ? xs.slice(1) : undefined;
 
    
    let reverse = xs => xs.slice(0)
        .reverse();
 
    
    let range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    return range(0, 20)
        .map(zeckendorf)
        .join('')
 
})();
 "
"function ZigZagMatrix(n) {
    this.height = n;
    this.width = n;
 
    this.mtx = [];
    for (var i = 0; i < n; i++) 
        this.mtx[i] = [];
 
    var i=1, j=1;
    for (var e = 0; e < n*n; e++) {
        this.mtx[i-1][j-1] = e;
        if ((i + j) % 2 == 0) {
            
            if (j < n) j ++;
            else       i += 2;
            if (i > 1) i --;
        } else {
            
            if (i < n) i ++;
            else       j += 2;
            if (j > 1) j --;
        }
    }
}
ZigZagMatrix.prototype = Matrix.prototype;
 
var z = new ZigZagMatrix(5);
print(z);
print();
 
z = new ZigZagMatrix(4);
print(z);(function (n) {
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
    
      function diagonals(n) {
          function diags(xs, iCol, iRow) {
              if (iCol < xs.length) {
                  var xxs = splitAt(iCol, xs);
 
                  return [xxs[0]].concat(diags(
                      xxs[1],
                      (iCol + (iRow < n ? 1 : -1)),
                      iRow + 1
                  ));
              } else return [xs];
          }
 
          return diags(range(0, n * n - 1), 1, 1);
      }
 
 
 
    
    
    function nHeads(n, lst) {
        var zipEdge = lst.slice(0, n);
 
        return lst.length ? [zipEdge.map(function (x) {
            return x[0];
        })].concat(nHeads(n, [].concat.apply([], zipEdge.map(function (
                x) {
                return x.length > 1 ? [x.slice(1)] : [];
            }))
            .concat(lst.slice(n)))) : [];
    }
 
    
    
    function range(m, n, delta) {
        var d = delta || 1,
            blnUp = n > m,
            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,
            a = Array(lng),
            i = lng;
 
        if (blnUp)
            while (i--) a[i] = (d * i) + m;
        else
            while (i--) a[i] = m - (d * i);
        return a;
    }
 
    
    function splitAt(n, xs) {
        return [xs.slice(0, n), xs.slice(n)];
    }
 
    
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
 
    return nHeads(n, diagonals(n)
        .map(function (x, i) {
            i % 2 || x.reverse();
            return x;
        }));
 
})(5);[[0, 1, 5, 6, 14],
 [2, 4, 7, 13, 15],
 [3, 8, 12, 16, 21],
 [9, 11, 17, 20, 22],
 [10, 18, 19, 23, 24]](n => {
 
    
    function diagonals(n) {
        let diags = (xs, iCol, iRow) => {
            if (iCol < xs.length) {
                let xxs = splitAt(iCol, xs);
 
                return [xxs[0]].concat(diags(
                    xxs[1],
                    iCol + (iRow < n ? 1 : -1),
                    iRow + 1
                ));
            } else return [xs];
        }
 
        return diags(range(0, n * n - 1), 1, 1);
    }
 
 
    
    
    function rowsFromDiagonals(n, lst) {
        if (lst.length) {
            let [edge, rest] = splitAt(n, lst);
 
            return [edge.map(x => x[0])]
                .concat(rowsFromDiagonals(n,
                    edge.filter(x => x.length > 1)
                    .map(x => x.slice(1))
                    .concat(rest)
                ));
        } else return [];
    }
 
    
 
    
    function splitAt(n, xs) {
        return [xs.slice(0, n), xs.slice(n)];
    }
 
    
    
    function range(m, n, step) {
        let d = (step || 1) * (n >= m ? 1 : -1);
 
        return Array.from({
            length: Math.floor((n - m) / d) + 1
        }, (_, i) => m + (i * d));
    }
 
    
 
    return rowsFromDiagonals(n,
        diagonals(n)
        .map((x, i) => (i % 2 || x.reverse()) && x)
    );
 
})(5);[[0, 1, 5, 6, 14],
 [2, 4, 7, 13, 15],
 [3, 8, 12, 16, 21],
 [9, 11, 17, 20, 22],
 [10, 18, 19, 23, 24]]"
" 
function Arc(posX,posY,radius,startAngle,endAngle,color){//Angle in radians.
this.posX=posX;
this.posY=posY;
this.radius=radius;
this.startAngle=startAngle;
this.endAngle=endAngle;
this.color=color;
}
//0,0 is the top left of the screen
var YingYang=[
new Arc(0.5,0.5,1,0.5*Math.PI,1.5*Math.PI,strv),//Half white semi-circle
new Arc(0.5,0.5,1,1.5*Math.PI,0.5*Math.PI,strv),//Half black semi-circle
new Arc(0.5,0.25,.5,0,2*Math.PI,strv),//black circle
new Arc(0.5,0.75,.5,0,2*Math.PI,strv),//white circle
new Arc(0.5,0.25,1/6,0,2*Math.PI,strv),//small white circle
new Arc(0.5,0.75,1/6,0,2*Math.PI,strv)//small black circle
]
//Ying Yang is DONE!
//Now we'll have to draw it.
//We'll draw it in a matrix that way we can get results graphically or by text!
function Array2D(width,height){
this.height=height;
this.width=width;
this.array2d=[];
for(var i=0;i<this.height;i++){
this.array2d.push(new Array(this.width));
}
}
Array2D.prototype.resize=function(width,height){//This is expensive
//nheight and nwidth is the difference of the new and old height
var nheight=height-this.height,nwidth=width-this.width;
if(nwidth>0){
for(var i=0;i<this.height;i++){
if(i<height)
Array.prototype.push.apply(this.array2d[i],new Array(nwidth));
}
}
else if(nwidth<0){
for(var i=0;i<this.height;i++){
if(i<height)
 this.array2d[i].splice(width,nwidth);
}
}
if(nheight>0){
 Array.prototype.push.apply(this.array2d,new Array(width));
}
else if(nheight<0){
 this.array2d.splice(height,nheight)
}
}
Array2D.prototype.loop=function(callback){
for(var i=0;i<this.height;i++)
 for(var i2=0;i2<this.width;i++)
   callback.call(this,this.array2d[i][i2],i,i2);
 
}
var mat=new Array2D(100,100);//this sounds fine;
YingYang[0];
//In construction.
 YinYang = (function () {
  var scale_x = 2,
    scale_y = 1,
    black = strv,
    white = strv,
    clear = strv,
    out = strv;
 
  function draw(radius) {
    function inCircle(centre_x, centre_y, radius, x, y) {
      return Math.pow(x - centre_x, 2) + Math.pow(y - centre_y, 2) <= Math.pow(radius, 2)
    }
    var bigCircle = function (x, y) {
      return inCircle(0, 0, radius, x, y)
    }, whiteSemiCircle = function (x, y) {
        return inCircle(0, radius / 2, radius / 2, x, y)
      }, smallBlackCircle = function (x, y) {
        return inCircle(0, radius / 2, radius / 6, x, y)
      }, blackSemiCircle = function (x, y) {
        return inCircle(0, -radius / 2, radius / 2, x, y)
      }, smallWhiteCircle = function (x, y) {
        return inCircle(0, -radius / 2, radius / 6, x, y)
      };
    i = 0
    for (var sy = Math.round(radius * scale_y); sy >= -Math.round(radius * scale_y); sy--) {
      //console.log(sy)
      for (var sx = -Math.round(radius * scale_x); sx <= Math.round(radius * scale_x); sx++) {
 
        var x = sx / scale_x,
          y = sy / scale_y;
        //out+=sx
        //console.log(sx,bigCircle(x,y))
        if (bigCircle(x, y)) {
          //out+=strv;
          if (whiteSemiCircle(x, y)) {
            //console.log(x,y)
            if (smallBlackCircle(x, y)) {
              out += black
            } else {
              out += white
            }
          } else if (blackSemiCircle(x, y)) {
            if (smallWhiteCircle(x, y)) {
              out += white
            } else {
              out += black
            }
          } else if (x < 0) {
            out += white
          } else {
            out += black
          }
 
        } else {
          out += clear;
        }
 
      }
      out += """";
    }
    return out;
  }
  return draw
})()
console.log(YinYang(17))
console.log(YinYang(8))<!DOCTYPE html>
<html>
 
<head>
 
  <body>
    <svg
    id=strv
    xmlns=strv
    xmlns:xlink=strv
    version=strv
    width=strv
    height=strv>
      </svg>
      <script>
function makeElem(elemName, attribs) { //atribs must be an Object
  var e = document.createElementNS(strv, elemName),
    a, b, d = attribs.style;
  for (a in attribs) {
    if (attribs.hasOwnProperty(a)) {
 
      if (a == 'style') {
        for (b in d) {
          if (d.hasOwnProperty(b)) {
            e.style[b] = d[b];
          }
        }
        continue;
      }
      e.setAttributeNS(null, a, attribs[a]);
    }
  }
  return e;
}
var svg = document.getElementById(strv);
 
function drawYingYang(n, x, y) {
  var d = n / 10;
  h = d * 5, q = h / 2, t = q * 3;
  //A white circle, for the bulk of the left-hand part
  svg.appendChild(makeElem(strv, {
    cx: h,
    cy: h,
    r: h,
    fill: strv
  }));
  //A black semicircle, for the bulk of the right-hand part
  svg.appendChild(makeElem(strv, {
    d: strv + (h + x) + strv + y + strv + q + strv + q + strv + d * 3 + strv + (h + x) + strv + (n + y) + strv,
    fill: strv
  }));
  //Circles to extend each part 
  svg.appendChild(makeElem(strv, {
    cx: h + x,
    cy: q + y,
    r: q,
    fill: strv
  }));
  svg.appendChild(makeElem(strv, {
    cx: h + x,
    cy: t + y,
    r: q,
    fill: strv
  }));
  //The spots
  svg.appendChild(makeElem(strv, {
    cx: h + x,
    cy: q + y,
    r: d,
    fill: strv
  }));
  svg.appendChild(makeElem(strv, {
    cx: h + x,
    cy: t + y,
    r: q,
    fill: strv
  }));
  svg.appendChild(makeElem(strv, {
    cx: h + x,
    cy: t + y,
    r: d,
    fill: strv
  }));
  //An outline for the whole shape
  svg.appendChild(makeElem(strv, {
    cx: h + x,
    cy: h + y,
    r: h,
    fill: strv,
    stroke: strv,
    strv: d / 3
  }));
  if (svg.height.baseVal.valueInSpecifiedUnits < n) {
    svg.setAttributeNS(null, strv, y * 1.25 + n + strv)
  }
  //svg.appendChild(makeElem(strv})) 
}
drawYingYang(100, 30, 30);
drawYingYang(1000, 200, 200);
      </script>
  </body>
</head>
 
</html>"
"function Y(f) {
    var g = f((function(h) {
        return function() {
            var g = f(h(h));
            return g.apply(this, arguments);
        }
    })(function(h) {
        return function() {
            var g = f(h(h));
            return g.apply(this, arguments);
        }
    }));
    return g;
}
 
var fac = Y(function(f) {
    return function (n) {
        return n > 1 ? n * f(n - 1) : 1;
    };
});
 
var fib = Y(function(f) {
    return function(n) {
        return n > 1 ? f(n - 1) + f(n - 2) : n;
    };
});function Y(f) {
    return (function(h) {
        return h(h);
    })(function(h) {
        return f(function() {
            return h(h).apply(this, arguments);
        });
    });
}function pseudoY(f) {
    return (function(h) {
        return h(h);
    })(function(h) {
        return f.bind(function() {
            return h(h).apply(null, arguments);
        });
    });
}
 
var fac = pseudoY(function(n) {
    return n > 1 ? n * this(n - 1) : 1;
});
 
var fib = pseudoY(function(n) {
    return n > 1 ? this(n - 1) + this(n - 2) : n;
});function Y(f) {
    return function() {
    	return f(Y(f)).apply(this, arguments);
    };
}function Y(f) {
    return function() {
    	return f(arguments.callee).apply(this, arguments);
    };
}let
    Y= 
        f=>((g=>(f((...x)=>g(g)(...x))))
            (g=>(f((...x)=>g(g)(...x))))),
    Y2= 
        f=>((f=>f(f))
            (g=>(f((...x)=>g(g)(...x))))),
    Y3= 
        ((δ=>f=>δ(g=>(f((...x)=>g(g)(...x)))))
         ((f=>f(f)))),
    fix= 
        (((f)=>(g)=>(h)=>(f(h)(g(h)))) 
         ((f)=>(g)=>(...x)=>(f(g(g)))(...x)) 
         ((f)=>(g)=>(...x)=>(f(g(g)))(...x))),
    fix2= 
        f=>(f=>f(f))(g=>(...x)=>f(g(g))(...x)),
    opentailfact= 
        fact=>(n,m=1)=>n<2?m:fact(n-1,n*m);
    tailfact= 
        Y(opentailfact);let
    polyfix= 
        (...l)=>(
            (f=>f(f))
            (g=>l.map(f=>(...x)=>f(...g(g))(...x)))),
    [even,odd]= 
        polyfix(
            (even,odd)=>n=>(n===0)||odd(n-1),
            (even,odd)=>n=>(n!==0)&&even(n-1));var Y = f => (x => x(x))(y => f(x => y(y)(x)));
var fac = Y(f => n => n > 1 ? n * f(n-1) : 1);"
"var doc = document.implementation.createDocument( null, 'root', null );
var root = doc.documentElement;
var element = doc.createElement( 'element' );
root.appendChild( element );
element.appendChild( document.createTextNode('Some text here') );
var xmlString = new XMLSerializer().serializeToString( doc );var xml = <root>
  <element>Some text here</element>
</root>;
var xmlString = xml.toXMLString();XML.ignoreProcessingInstructions = false;
var xml = <?xml version=strv?>  
<root>
  <element>Some text here</element>
</root>;
var xmlString = xml.toXMLString();"
" 
var xmlstr = '<Students>' + 
  '<Student Name=strv />' +
  '<Student Name=strv />' +
  '<Student Name=strv />' +
  '<Student Name=strv>' +
    '<Pet Type=strv />' +
  '</Student>' +
  '<Student DateOfBirth=strv />' +
'</Students>';
 
if (window.DOMParser)
  {
  parser=new DOMParser();
  xmlDoc=parser.parseFromString(xmlstr,strv);
  }
else 
  {
  xmlDoc=new ActiveXObject(strv);
  xmlDoc.async=false;
  xmlDoc.loadXML(xmlstr); 
  }
 
var students=xmlDoc.getElementsByTagName('Student');
for(var e=0; e<=students.length-1; e++) {
  console.log(students[e].attributes.Name.value);
}
  
var parseString = require('xml2js').parseString;
var xmlstr = '<Students>' +
  '<Student Name=strv />' +
  '<Student Name=strv />' +
  '<Student Name=strv />' +
  '<Student Name=strv>' +
    '<Pet Type=strv />' +
  '</Student>' +
  '<Student DateOfBirth=strv />' +
'</Students>';
 
parseString(xmlstr, function (err, result) {
   if (!err) {
      result.Students.Student.forEach( function(student) {
         console.log(student.$.Name);
      } );
   }
});
  
var xmlstr = '<Students>' + 
  '<Student Name=strv />' +
  '<Student Name=strv />' +
  '<Student Name=strv />' +
  '<Student Name=strv>' +
    '<Pet Type=strv />' +
  '</Student>' +
  '<Student DateOfBirth=strv />' +
'</Students>';
var xml = XML(xmlstr);
var list = xml.Student.@Name;
var output = '';
for (var i = 0; i < list.length(); i++) {
  if (i > 0) {
    output += ', ';
  }
  output += list[i];
}
 
alert(output);
 "
"//create XMLDocument object from file
var xhr = new XMLHttpRequest();
xhr.open('GET', 'file.xml', false);
xhr.send(null);
var doc = xhr.responseXML;
 
//get first <item> element
var firstItem = doc.evaluate( '//item[1]', doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null ).singleNodeValue;
alert( firstItem.textContent );
 
//output contents of <price> elements
var prices = doc.evaluate( '//price', doc, null, XPathResult.ANY_TYPE, null );
for( var price = prices.iterateNext(); price != null; price = prices.iterateNext() ) {
  alert( price.textContent );
}
 
//add <name> elements to array
var names = doc.evaluate( '//name', doc, null, XPathResult.ANY_TYPE, null);
var namesArray = [];
for( var name = names.iterateNext(); name != null; name = names.iterateNext() ) {
  namesArray.push( name );
}
alert( namesArray );//create XML object from file
var xhr = new XMLHttpRequest();
xhr.open('GET', 'file.xml', false);
xhr.send(null);
var doc = new XML(xhr.responseText);
 
//get first <item> element
var firstItem = doc..item[0];
alert( firstItem );
 
//output contents of <price> elements
for each( var price in doc..price ) {
  alert( price );
}
 
//add <name> elements to array
var names = [];
for each( var name in doc..name ) {
  names.push( name );
}
alert( names );"
" 
function wrap (text, limit) {
  if (text.length > limit) {
    
    var edge = text.slice(0, limit).lastIndexOf(' ');
    if (edge > 0) {
      var line = text.slice(0, edge);
      var remainder = text.slice(edge + 1);
      return line + '' + wrap(remainder, limit);
    }
  }
  return text;
}
  
console.log(wrap(text, 80));
  
console.log(wrap(text, 42));
 (function (width) {
    'use strict';
 
    function wrapByRegex(n, s) {
        return s.match(
                RegExp('.{1,' + n + '}(s|$)', 'g')
            )
            .join('');
    }
 
    return wrapByRegex(width,
'Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column. The basic task is to wrap a paragraph of text in a simple way in your language. If there is a way to do this that is built-in, trivial, or provided in a standard library, show that. Otherwise implement the minimum length greedy algorithm from Wikipedia.'
    )
 
})(60); 
/** * [wordwrap description] * @param  {[type]}  text  [description] * @param  {Number}  width [description] * @param  {String}  br    [description] * @param  {Boolean} cut   [description] * @return {[type]}        [description] */
function wordwrap(text, width = 80, br = '', cut = false) {
  
  
  width >>>= 0;
  
  if (0 === width || text.length <= width) {
    return text;
  }
  
  return text.split('').map(line => {
    if (line.length <= width) {
      return line;
    }
    
    let words = line.split(' ');
    
    if (cut) {
      let temp = [];
      for (const word of words) {
        if (word.length > width) {
          let i = 0;
          const length = word.length;
          while (i < length) {
            temp.push(word.slice(i, Math.min(i + width, length)));
            i += width;
          }
        } else {
          temp.push(word);
        }
      }
      words = temp;
    }
    
    
    let wrapped = words.shift();
    let spaceLeft = width - wrapped.length;
    for (const word of words) {
      if (word.length + 1 > spaceLeft) {
        wrapped += br + word;
        spaceLeft = width - word.length;
      } else {
        wrapped += ' ' + word;
        spaceLeft -= 1 + word.length;
      }
    }
    return wrapped;
  }).join(''); 
}
  
console.log(wordwrap(strv, 20, ""<br />""));
 "
"(function () {
    'use strict';
 
    
    var waterCollected = function (xs) {
        return sum(                   
            zipWith(function (a, b) {
                    return a - b;     
                },
                zipWith(min,          
                    scanl1(max, xs),  
                    scanr1(max, xs)   
                ), 
                xs                    
            )
            .filter(function (x) {
                return x > 0;         
            })
        );
    };
 
    
 
    
    var zipWith = function (f, xs, ys) {
        var ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map(function (x, i) {
                return f(x, ys[i]);
            });
    };
 
    
    
    var scanl1 = function (f, xs) {
        return xs.length > 0 ? scanl(f, xs[0], xs.slice(1)) : [];
    };
 
    
    
    var scanr1 = function (f, xs) {
        return xs.length > 0 ? scanr(f, xs.slice(-1)[0], xs.slice(0, -1)) : [];
    };
 
    
    var scanl = function (f, startValue, xs) {
        var lst = [startValue];
        return xs.reduce(function (a, x) {
            var v = f(a, x);
            return lst.push(v), v;
        }, startValue), lst;
    };
 
    
    var scanr = function (f, startValue, xs) {
        var lst = [startValue];
        return xs.reduceRight(function (a, x) {
            var v = f(a, x);
            return lst.push(v), v;
        }, startValue), lst.reverse();
    };
 
    
    var sum = function (xs) {
        return xs.reduce(function (a, x) {
            return a + x;
        }, 0);
    };
 
    
    var max = function (a, b) {
        return a > b ? a : b;
    };
 
    
    var min = function (a, b) {
        return b < a ? b : a;
    };
 
    
    return [
        [1, 5, 3, 7, 2],
        [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
        [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
        [5, 5, 5, 5],
        [5, 6, 7, 8],
        [8, 7, 7, 6],
        [6, 7, 10, 7, 6]
    ].map(waterCollected);
 
    //--> [2, 14, 35, 0, 0, 0, 0]
})();[2, 14, 35, 0, 0, 0, 0](() => {
    'use strict';
 
    
    const waterCollected = xs => {
        const maxToRight = scanr1(max, xs),
            maxToLeft = scanl1(max, xs),
            levels = zipWith(min, maxToLeft, maxToRight);
 
        return sum(zipWith(difference, levels, xs)
            .filter(x => x > 0));
    };
 
 
    
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    }
 
    
    
    const scanl1 = (f, xs) =>
        xs.length > 0 ? scanl(f, xs[0], xs.slice(1)) : [];
 
    
    
    const scanr1 = (f, xs) =>
        xs.length > 0 ? scanr(f, xs.slice(-1)[0], xs.slice(0, -1)) : [];
 
    
    const scanl = (f, startValue, xs) => {
        const lst = [startValue];
        return (
            xs.reduce((a, x) => {
                const v = f(a, x);
                return (lst.push(v), v);
            }, startValue),
            lst
        );
    };
 
    
    const scanr = (f, startValue, xs) => {
        const lst = [startValue];
        return (
            xs.reduceRight((a, x) => {
                const v = f(a, x);
                return (lst.push(v), v);
            }, startValue),
            lst.reverse()
        );
    };
 
    
    const difference = (a, b) => a - b;
 
    
    const sum = xs => xs.reduce((a, x) => a + x, 0);
 
    
    const max = (a, b) => a > b ? a : b;
 
    
    const min = (a, b) => b < a ? b : a;
 
 
    
    return [
        [1, 5, 3, 7, 2],
        [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
        [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
        [5, 5, 5, 5],
        [5, 6, 7, 8],
        [8, 7, 7, 6],
        [6, 7, 10, 7, 6]
    ].map(waterCollected);
 
    //--> [2, 14, 35, 0, 0, 0, 0]
})();[2, 14, 35, 0, 0, 0, 0]"
"var fso = new ActiveXObject(strv);
 
function walkDirectoryTree(folder, folder_name, re_pattern) {
    WScript.Echo(strv + folder_name + strv + re_pattern + strv);
    walkDirectoryFilter(folder.files, re_pattern);
 
    var subfolders = folder.SubFolders;
    WScript.Echo(strv + folder_name + strv + re_pattern + strv);
    walkDirectoryFilter(subfolders, re_pattern);
 
    WScript.Echo();
    var en = new Enumerator(subfolders);
    while (! en.atEnd()) {
        var subfolder = en.item();
        walkDirectoryTree(subfolder, folder_name + strv + subfolder.name, re_pattern);
        en.moveNext();
    }
}
 
function walkDirectoryFilter(items, re_pattern) {
    var e = new Enumerator(items);
    while (! e.atEnd()) {
        var item = e.item();
        if (item.name.match(re_pattern))
            WScript.Echo(item.name);
        e.moveNext();
    }
}
 
walkDirectoryTree(dir, dir.name, '.txt$');"
"var fso = new ActiveXObject(strv);
var dir = fso.GetFolder('test_folder');
 
function walkDirectory(dir, re_pattern) {
    WScript.Echo(strv + dir.name + strv + re_pattern +strv);
    walkDirectoryFilter(dir.Files, re_pattern);
 
    WScript.Echo(strv + dir.name + strv + re_pattern +strv);
    walkDirectoryFilter(dir.Subfolders, re_pattern);
}
 
function walkDirectoryFilter(items, re_pattern) {
    var e = new Enumerator(items);
    while (! e.atEnd()) {
        var item = e.item();
        if (item.name.match(re_pattern))
            WScript.Echo(item.name);
        e.moveNext();
    }
}
 
walkDirectory(dir, '.txt$');"
"var req = new XMLHttpRequest();
req.onload = function () {
  var re = /[JFMASOND].+ UTC/; //beginning of month name to 'UTC'
  console.log(this.responseText.match(re)[0]);
};
req.open('GET', 'http://tycho.usno.navy.mil/cgi-bin/timer.pl', true);
req.send();"
"function distcheck(random_func, times, opts) {
    if (opts === undefined) opts = {}
    opts['delta'] = opts['delta'] || 2;
 
    var count = {}, vals = [];
    for (var i = 0; i < times; i++) {
        var val = random_func();
        if (! has_property(count, val)) {
            count[val] = 1;
            vals.push(val);
        }
        else
            count[val] ++;
    }
    vals.sort(function(a,b) {return a-b});
 
    var target = times / vals.length;
    var tolerance = target * opts['delta'] / 100; 
 
    for (var i = 0; i < vals.length; i++) {
        var val = vals[i];
        if (Math.abs(count[val] - target) > tolerance) 
            throw strv + val +
                  strv + target + strv +count[val];
        else
            print(val + """" + count[val]);
    }
}
 
function has_property(obj, propname) {
    return typeof(obj[propname]) == strv ? false : true;
}
 
try {
    distcheck(function() {return Math.floor(10 * Math.random())}, 100000);
    print();
    distcheck(function() {return (Math.random() > 0.95 ? 1 : 0)}, 100000);
} catch (e) {
    print(e);
}"
"

function ordA(a) {
  return a.charCodeAt(0) - 65;
}
 

function vigenere(text, key, decode) {
  var i = 0, b;
  key = key.toUpperCase().replace(/[^A-Z]/g, '');
  return text.toUpperCase().replace(/[^A-Z]/g, '').replace(/[A-Z]/g, function(a) {
    b = key[i++ % key.length];
    return String.fromCharCode(((ordA(a) + (decode ? 26 - ordA(b) : ordA(b))) % 26 + 65));
  });
}
 

var text = strv;
var key = 'alex';
var enc = vigenere(text,key);
var dec = vigenere(enc,key,true);
 
console.log(enc);
console.log(dec);class Vigenere {
 
    key: string
 
    /** Create new cipher based on key */
    constructor(key: string) {
        this.key = Vigenere.formatText(key)
    }
 
    /** Enrypt a given text using key */
    encrypt(plainText: string): string {
        return Array.prototype.map.call(Vigenere.formatText(plainText), (letter: string, index: number): string => {
            return String.fromCharCode((letter.charCodeAt(0) + this.key.charCodeAt(index % this.key.length) - 130) % 26 + 65)
        }).join('')
    }
 
    /** Decrypt ciphertext based on key */
    decrypt(cipherText: string): string {
        return Array.prototype.map.call(Vigenere.formatText(cipherText), (letter: string, index: number): string => {
            return String.fromCharCode((letter.charCodeAt(0) - this.key.charCodeAt(index % this.key.length) + 26) % 26 + 65)
        }).join('')
    }
 
    /** Converts to uppercase and removes non characters */
    private static formatText(text: string): string {
        return text.toUpperCase().replace(/[^A-Z]/g, strv)
    }
 
}
 
/** Example usage */
(() => {
    let original: string = strv
 
    console.log(`Original: ${original}`)
 
    let vig: Vigenere = new Vigenere(strv)
 
    let encoded: string = vig.encrypt(original)
 
    console.log(`After encryption: ${encoded}`)
 
    let back: string = vig.decrypt(encoded)
 
    console.log(`After decryption: ${back}`)
 
})()
 "
"function dotProduct() {
  var len = arguments[0] && arguments[0].length;
  var argsLen = arguments.length;
  var i, j = len;
  var prod, sum = 0;
 
  
  if (!len) {
    return;
  }
 
  
  i = argsLen;
  while (i--) {
 
    if (arguments[i].length != len) {
      return;  
    }
  }
 
  
  while (j--) {
    i = argsLen;
    prod = 1;
 
    while (i--) {
      prod *= arguments[i][j];
    }
    sum += prod;
  }
  return sum;
}
 
function crossProduct(a, b) {
 
  
  if (a.length != 3 || b.length != 3) {
     return;
  }
 
  return [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]];
 
}
 
function scalarTripleProduct(a, b, c) {
  return dotProduct(a, crossProduct(b, c));
}
 
function vectorTripleProduct(a, b, c) {
  return crossProduct(a, crossProduct(b, c));
}
 

(function () {
  var a = [3, 4, 5];
  var b = [4, 3, 5];
  var c = [-5, -12, -13];
 
  alert(
    'A . B: ' + dotProduct(a, b) +
    '' +
    'A x B: ' + crossProduct(a, b) +
    '' +
    'A . (B x C): ' + scalarTripleProduct(a, b, c) +
    '' +
    'A x (B x C): ' + vectorTripleProduct(a, b, c)
  ); 
}());"
"function printAll() {
  for (var i=0; i<arguments.length; i++)
    print(arguments[i])
}
printAll(4, 3, 5, 6, 4, 3);
printAll(4, 3, 5);
printAll(strv, strv, strv, strv);args = [strv, strv, strv, strv]
printAll.apply(null, args)let
  fix = 
    f => (f => f(f))(g => f((...a) => g(g)(...a))),
  forAll =
    f => 
      fix(
        z => (a,...b) => (
          (a === void 0)
          ||(f(a), z(...b)))),
  printAll = forAll(print);
 
printAll(0,1,2,3,4,5);
printAll(6,7,8);
(f => a => f(...a))(printAll)([9,10,11,12,13,14]);















 (() => {
    'use strict';
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    
    const printAll = (...a) => a.map(show)
        .join('');
 
    return printAll(1, 2, 3, 2 + 2, strv, 6);
})(); 
function printAll(separator,argv..) {
  if(argv.length)
    stdout.print(argv[0]);
  for (var i=1; i < argv.length; i++)
    stdout.print(separator, argv[i]);
}
printAll(strv, 4, 3, 5, 6, 4, 3);
printAll(strv, 4, 3, 5);
printAll(strv,strv, strv, strv, strv);"
"var fs = require('fs');
var request = require('request');
 
var meetup = function() {
  var key = fs.readFileSync('api_key.txt', 'utf-8');
  var url = strv;
 
  var composeURL = function(root, object) {
    return root + '?' + JSON.stringify(object).replace(/strv/g, '=').replace(/strv/g, '&').slice(2, -2)
  }
 
  var get = function(params, callback, path) {
    params.key = key;
 
    request.get(composeURL(url + (path || '/2/open_events'), params), function(err, res, body) {
      if ( err ) {
        console.error(err);
        return false;
      }
 
 
      callback(JSON.parse(body)['results']);
    })
  }
 
 
  var post = function(details, callback, path) {
    details.key = key;
 
    request.post({
      headers: { 'content-type' : 'application/x-www-form-urlencoded' },
      url: url + (path || '/2/event'),
      form: details
    }, function(err, res, body) {
      callback(body);
    })
  }
 
  var parseEvent = function(mEvent) {
    /*     * A simple function that converts JSON to      * string in a pretty way    **/
    var name = mEvent['name'] || '';
    var desc = mEvent['desc'] || '';
    var url = mEvent['url'] || '';
 
    if ( mEvent['venue'] ) {
      var city = mEvent['venue']['city'] || '';
      var lat = mEvent['venue']['lat'] || '';
      var lon = mEvent['venue']['lon'] || '';
    }
 
    if ( mEvent['group'] )
      var group = mEvent['group']['name'] || '';
 
    var parsed = '';
 
    if ( name ) parsed += 'Name: ' + name + '';
    if ( desc ) parsed += 'Description: ' + desc + '';
    if ( url ) parsed += 'Url: ' + url + '';
    if ( city ) parsed += 'City: ' + city + '';
    if ( lat ) parsed += 'Latitude: ' + lat + '';
    if ( lon ) parsed += 'Longitude: ' + lon + '';
    if ( group ) parsed += 'Group: ' + group + '';
 
    return parsed;
 
  };
 
  var parseEvents = function(results) {
    console.log('a');
    for ( var i = 0; i < results.length; i++ ) {
      console.log( parseEvent(results[i]) );
    }
  }
 
  return {
    get: get,
    parseEvents: parseEvents,
    post: post
  }
}
 
 
 
meetup().get({
  
  topic: 'photo',
  city: 'nyc'
}, function(results) {
  meetup().parseEvents(results);
});
 
 
/* * Getting group ID and group urlname * * The URL name is simply the part after meetup.com/ on a meetup group. * Example, ID of meetup.com/foodie-programmers is 'foodie-programmers'. * * Running the code below with the group name will give the group ID, an integer. meetup().get({  'group_urlname': 'foodie-programmers'}, function(group) {  console.log(group.id);}, '/2/groups');  * Using the above group_id and the group_urlname manually,  * you can post events to a group with the below code**/
 
meetup().post({
  
  name: 'Finding Nemo',
  address_1: 'p sherman 42 wallaby way sydney',
  city: 'sydney',
  country: 'australia',
  
}, function(venue) {
  console.log('Venue: ', venue, venue.id); 
  
}, '/' + '{{ foodie-programmers }}' + '/venues'); 

 
 
meetup().post({
  
  group_id: 42, 
  group_urlname: 'foodie-programmers',
  name: 'Tomato Python Fest',
  description: 'Code vegetables in Python! Special speech by Guido Van Ossum',
  duration: 1000 * 60 * 60 * 2, 
  time: 1419879086343, 
  why: 'We should do this because... Less than 250 characters',
  hosts: 'up to 5 comma separated member ids',
  venue_id: 42, 
  lat: 42, 
  lon: 42, 
  simple_html_description: 'Event description in <b>simple html</b>. Less than <i>50000</i> characters.'
}, function(result) {
  console.log('Event: ', result);
})"
"
var a=1;
 

function one(){
    alert(a); 
}
 

function two(a){
    alert(a);
}
 

function three(){
  var a = 3;
  alert(a);
}
 

function four(){
    if(true){
        var a=4;
    }
 
    alert(a); 
}
 
 

function Five(){
    this.a = 5;
}
 
 

var six = function(){
    var foo = 6;
 
    return function(){
        
        
        alert(foo);
    }
}()
 
 

function Seven(){
  this.a = 7;
}
 

Seven.prototype.a = -1; 
Seven.prototype.b = 8; 
 
 
 

one();
two(2);
three();
four();
alert(new Five().a);
six();
alert(new Seven().a);
alert(new Seven().b);"
"(function (lstURL) {
 
    var e = document.createElement('a'),
        lstKeys = [
            'hash',
            'host',
            'hostname',
            'origin',
            'pathname',
            'port',
            'protocol',
            'search'
        ],
 
        fnURLParse = function (strURL) {
            e.href = strURL;
 
            return lstKeys.reduce(
                function (dct, k) {
                    dct[k] = e[k];
                    return dct;
                }, {}
            );
        };
 
    return JSON.stringify(
        lstURL.map(fnURLParse),
        null, 2
    );
 
})([
  strv,
  strv,
  ""jdbc:mysql://test_user::3306/sakila?profileSQL=true"",
  strv,
  strv,
  strv,
  ""mailto:"",
  strv,
  strv,
  strv,
  strv,
  ""ssh:"",
  ""https://bob:/place"",
  strv
]);"
"var str = prompt(strv);
var value = 0;
while (value != 75000) {
    value = parseInt( prompt(strv) );
}"
"var normal = 'http://foo/bar/';
var encoded = encodeURIComponent(normal);"
"WScript.Echo(strv);
var str = WScript.StdIn.ReadLine();
 
var val = 0;
while (val != 75000) {
    WScript.Echo(strv);
    val = parseInt( WScript.StdIn.ReadLine() );
}print(strv);
var str = readline();
 
var val = 0;
while (val != 75000) {
    print(strv);
    val = parseInt( readline() );
}"
"const fs = require('fs');
fs.readdir('.', (err, names) => names.sort().map( name => console.log(name) ));"
decodeURIComponent(strv)
"var ᾩ = strv;
var ĦĔĽĻŎ = strv;
var 〱〱〱〱 = strv;
var जावास्क्रिप्ट = strv; 
var KingGeorgeⅦ = strv;
 
console.log([ᾩ, ĦĔĽĻŎ, 〱〱〱〱, जावास्क्रिप्ट, KingGeorgeⅦ])"
"var a;
 
typeof(a) === strv;
typeof(b) === strv;
 
var obj = {}; 
typeof(obj.c) === strv;
 
obj.c = 42;
 
obj.c === 42;
delete obj.c;
typeof(obj.c) === strv;var a;
a === void 0; 
b === void 0; "
"function tm(d,s,e,i,b,t,... r) {
	document.write(d, '<br>')
	if (i<0||i>=t.length) return
	var re=new RegExp(b,'g')
	write('*',s,i,t=t.split(''))
	var p={}; r.forEach(e=>((s,r,w,m,n)=>{p[s+'.'+r]={w,n,m:[0,1,-1][1+'RL'.indexOf(m)]}})(... e.split(/[ .:,]+/)))
	for (var n=1; s!=e; n+=1) {
		with (p[s+'.'+t[i]]) t[i]=w,s=n,i+=m
		if (i==-1) i=0,t.unshift(b)
		else if (i==t.length) t[i]=b
		write(n,s,i,t)
	}
	document.write('<br>')
	function write(n, s, i, t) {
		t = t.join('')
		t = t.substring(0,i) + '<u>' + t.charAt(i) + '</u>' + t.substr(i+1)
		document.write(('  '+n).slice(-3).replace(/ /g,'&nbsp;'), ': ', s, ' [', t.replace(re,'&nbsp;'), ']', '<br>')
	}
}
 
tm( 'Unary incrementer',
//	 s    e   i   b    t
	'a', 'h', 0, 'B', '111',
//	 s.r: w, m, n
	'a.1: 1, L, a',
	'a.B: 1, S, h'
)
 
tm( 'Unary adder',
	1, 0, 0, '0', '1110111',
	'1.1: 0, R, 2', 
	'2.1: 1, R, 2', 
	'2.0: 1, S, 0'  
)
 
tm( 'Three-state busy beaver',
	1, 0, 0, '0', '0',
	'1.0: 1, R, 2',
	'1.1: 1, R, 0',
	'2.0: 0, R, 3',
	'2.1: 1, R, 2',
	'3.0: 1, L, 3',
	'3.1: 1, L, 1'
)"
"<!DOCTYPE html><html><head><title>Truth table</title><script>
var elem,expr,vars;
function isboolop(chr){return strv.indexOf(chr)!=-1;}
function varsindexof(chr){
	var i;
	for(i=0;i<vars.length;i++){if(vars[i][0]==chr)return i;}
	return -1;
}
function printtruthtable(){
	var i,str;
	elem=document.createElement(strv);
	expr=prompt(""Boolean expression:Accepts single-character variables (except for T and F, which specify explicit true or false values), postfix, with &|!^ for and, or, not, xor, respectively; optionally seperated by whitespace."").replace(/\s/g,strv);
	vars=[];
	for(i=0;i<expr.length;i++)if(!isboolop(expr[i])&&expr[i]!=strv&&expr[i]!=strv&&varsindexof(expr[i])==-1)vars.push([expr[i],-1]);
	if(vars.length==0)return;
	str=strv;
	for(i=0;i<vars.length;i++)str+=vars[i][0]+strv;
	elem.innerHTML=strv+str+expr+""</b>"";
	vars[0][1]=false;
	truthpartfor(1);
	vars[0][1]=true;
	truthpartfor(1);
	vars[0][1]=-1;
	document.body.appendChild(elem);
}
function truthpartfor(index){
	if(index==vars.length){
		var str,i;
		str=strv;
		for(i=0;i<index;i++)str+=(vars[i][1]?strv:strv)+strv;
		elem.innerHTML+=str+(parsebool()?strv:strv)+"""";
		return;
	}
	vars[index][1]=false;
	truthpartfor(index+1);
	vars[index][1]=true;
	truthpartfor(index+1);
	vars[index][1]=-1;
}
function parsebool(){
	var stack,i,idx;
	console.log(vars);
	stack=[];
	for(i=0;i<expr.length;i++){
		if(expr[i]==strv)stack.push(true);
		else if(expr[i]==strv)stack.push(false);
		else if((idx=varsindexof(expr[i]))!=-1)stack.push(vars[idx][1]);
		else if(isboolop(expr[i])){
			switch(expr[i]){
				case strv:stack.push(stack.pop()&stack.pop());break;
				case strv:stack.push(stack.pop()|stack.pop());break;
				case strv:stack.push(!stack.pop());break;
				case strv:stack.push(stack.pop()^stack.pop());break;
			}
		} else alert(strv+expr[i]+strv);
		console.log(stack);
	}
	return stack[0];
}
</script></head><body onload=strv></body></html>"
"(function () {
    var concatMap = function (f, xs) {
        return [].concat.apply([], xs.map(f))
    };
 
    return function (n, xs) {
        return concatMap(function (x, ix) {
            return concatMap(function (y, iy) {
                return iy <= ix ? [] : x + y === n ? [
                    [ix, iy]
                ] : []
            }, xs)
        }, xs)
    }(21, [0, 2, 11, 19, 90]);
})();
 [[1,3]](() => {
    'use strict';
 
    let summingPairIndices = (n, xs) => nubBy(
            ([x, y], [x1, y1]) => x === x1 && y === y1,
            concatMap(
                ([x, y]) =>
                    x === y ? [] : (x + y === n ? [[x, y]] : []),
                cartesianProduct(xs, xs)
            ).map(xs => xs.sort())
        ).map(([x, y]) => [xs.indexOf(y), xs.indexOf(x)]);
 
 
    
 
    
    let concatMap = (f, xs) => [].concat.apply([], xs.map(f)),
 
        
        cartesianProduct = (xs, ys) =>
            concatMap(x => concatMap(y => [[x, y]], ys), xs),
 
        
        nubBy = (p, xs) => {
            let x = xs.length ? xs[0] : undefined;
 
            return x !== undefined ? [x].concat(
                nubBy(p, xs.slice(1).filter(y => !p(x, y)))
            ) : [];
        };
 
 
    return summingPairIndices(21, [0, 2, 11, 19, 90]);
})();
 [1,3](() => {
    'use strict';
 
    
    let concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    let summingPairIndices = (n, xs) =>
 
            
            
            concatMap((x, ix) => concatMap((y, iy) =>
                iy <= ix ? [] : (
                                 
                                 
                    x + y === n ? [
                        [ix, iy]
                    ] : []
                ), xs), xs);
 
    return summingPairIndices(21, [0, 2, 11, 19, 90]);
})();
 [[1,3]]"
"#!/usr/bin/env js
 
function main() {
    var nums = getNumbers(11);
    nums.reverse();
    for (var i in  nums) {
        pardoKnuth(nums[i], fn, 400);
    }
}
 
function pardoKnuth(n, f, max) {
    var res = f(n);
    putstr('f(' + String(n) + ')');
    if (res > max) {
        print(' is too large');
    } else {
        print(' = ' + String(res));
    } 
}
 
function fn(x) {
    return Math.pow(Math.abs(x), 0.5) + 5 * Math.pow(x, 3);
}
 
function getNumbers(n) {
    var nums = [];
    print('Enter', n, 'numbers.');
    for (var i = 1; i <= n; i++) {
        putstr('   ' + i + ': ');
        var num = readline();
        nums.push(Number(num));        
    }
    return nums;
}
 
main();
 "
"function BinaryTree(value, left, right) {
    this.value = value;
    this.left = left;
    this.right = right;
}
BinaryTree.prototype.preorder  = function(f) {this.walk(f,['this','left','right'])}
BinaryTree.prototype.inorder   = function(f) {this.walk(f,['left','this','right'])}
BinaryTree.prototype.postorder = function(f) {this.walk(f,['left','right','this'])}
BinaryTree.prototype.walk = function(func, order) {
    for (var i in order) 
        switch (order[i]) {
            case strv: func(this.value); break;
            case strv: if (this.left) this.left.walk(func, order); break;
            case strv: if (this.right) this.right.walk(func, order); break;
        }
}
BinaryTree.prototype.levelorder = function(func) {
    var queue = [this];
    while (queue.length != 0) {
        var node = queue.shift();
        func(node.value);
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
}
 

function createBinaryTreeFromArray(ary) {
    var left = null, right = null;
    if (ary[1]) left = createBinaryTreeFromArray(ary[1]);
    if (ary[2]) right = createBinaryTreeFromArray(ary[2]);
    return new BinaryTree(ary[0], left, right);
}
 
var tree = createBinaryTreeFromArray([1, [2, [4, [7]], [5]], [3, [6, [8],[9]]]]);
 
print(strv);   tree.preorder(print); 
print(strv);    tree.inorder(print); 
print(strv);  tree.postorder(print);
print(strv); tree.levelorder(print);(function () {
 
    function preorder(n) {
        return [n[v]].concat(
            n[l] ? preorder(n[l]) : []
        ).concat(
            n[r] ? preorder(n[r]) : []
        );
    }
 
    function inorder(n) {
        return (
            n[l] ? inorder(n[l]) : []
        ).concat(
            n[v]
        ).concat(
            n[r] ? inorder(n[r]) : []
        );
    }
 
    function postorder(n) {
        return (
            n[l] ? postorder(n[l]) : []
        ).concat(
            n[r] ? postorder(n[r]) : []
        ).concat(
            n[v]
        );
    }
 
    function levelorder(n) {
        return (function loop(x) {
            return x.length ? (
                x[0] ? (
                [x[0][v]].concat(
                        loop(
                            x.slice(1).concat(
                                [x[0][l], x[0][r]]
                            )
                        )
                    )
                ) : loop(x.slice(1))
            ) : [];
        })([n]);
    }
 
    var v = 0,
        l = 1,
        r = 2,
 
        tree = [1,
                [2,
                    [4,
                        [7]
                    ],
                    [5]
                ],
                [3,
                    [6,
                        [8],
                        [9]
                    ]
                ]
            ],
 
        lstTest = [[strv, strv]].concat(
            [preorder, inorder, postorder, levelorder].map(
                function (f) {
                    return [f.name, f(tree)];
                }
            )
        );
 
    
    function wikiTable(lstRows, blnHeaderRow, strStyle) {
        return '{| class=strv ' + (
            strStyle ? 'style=""' + strStyle + '""' : ''
        ) + lstRows.map(function (lstRow, iRow) {
            var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
            return '|-' + strDelim + ' ' + lstRow.map(function (v) {
                return typeof v === 'undefined' ? ' ' : v;
            }).join(' ' + strDelim + strDelim + ' ');
        }).join('') + '|}';
    }
 
    return wikiTable(lstTest, true) + '' + JSON.stringify(lstTest);
 
})();[[strv,strv],
[strv,[1,2,4,7,5,3,6,8,9]],[strv,[7,4,2,5,1,8,6,9,3]],
[strv,[7,4,5,2,8,9,6,3,1]],[strv,[1,2,3,4,5,6,7,8,9]]](function () {
    'use strict';
 
    
 
    
    function traverse(strOrderName, dctTree) {
        var strName = strOrderName.toLowerCase();
 
        if (strName.startsWith('level')) {
 
            
            return levelOrder([dctTree]);
 
        } else if (strName.startsWith('in')) {
            var lstNest = dctTree.nest;
 
            if ((lstNest ? lstNest.length : 0) < 3) {
                var left = lstNest[0] || [],
                    right = lstNest[1] || [],
 
                    lstLeft = left.nest ? (
                        traverse(strName, left)
                    ) : (left.value || []),
                    lstRight = right.nest ? (
                        traverse(strName, right)
                    ) : (right.value || []);
 
                return (lstLeft !== undefined && lstRight !== undefined) ?
 
                    
                    (lstLeft instanceof Array ? lstLeft : [lstLeft])
                    .concat(dctTree.value)
                    .concat(lstRight) : undefined;
 
            } else { 
                return undefined;
            }
 
        } else {
            var lstTraversed = concatMap(function (x) {
                return traverse(strName, x);
            }, (dctTree.nest || []));
 
            return (
                strName.startsWith('pre') ? (
 
                    
                    [dctTree.value].concat(lstTraversed)
 
                ) : strName.startsWith('post') ? (
 
                    
                    lstTraversed.concat(dctTree.value)
 
                ) : []
            );
        }
    }
 
    
    function levelOrder(lstTree) {
        var lngTree = lstTree.length,
            head = lngTree ? lstTree[0] : undefined,
            tail = lstTree.slice(1);
 
        
        
        
        return lngTree ? (
            head ? (
                [head.value].concat(
                    levelOrder(
                        tail
                        .concat(head.nest || [])
                    )
                )
            ) : levelOrder(tail)
        ) : [];
    }
 
    
    function concatMap(f, xs) {
        return [].concat.apply([], xs.map(f));
    }
 
    var dctTree = {
        value: 1,
        nest: [{
            value: 2,
            nest: [{
                value: 4,
                nest: [{
                    value: 7
                }]
            }, {
                value: 5
            }]
        }, {
            value: 3,
            nest: [{
                value: 6,
                nest: [{
                    value: 8
                }, {
                    value: 9
                }]
            }]
        }]
    };
 
 
    return ['preorder', 'inorder', 'postorder', 'level-order']
        .reduce(function (a, k) {
            return (
                a[k] = traverse(k, dctTree),
                a
            );
        }, {});
 
})();{strv:[1, 2, 4, 7, 5, 3, 6, 8, 9], 
strv:[7, 4, 2, 5, 1, 8, 6, 9, 3], 
strv:[7, 4, 5, 2, 8, 9, 6, 3, 1], 
strv:[1, 2, 3, 4, 5, 6, 7, 8, 9]}(() => {
    
 
    
    const preorder = a => [a[v]]
        .concat(a[l] ? preorder(a[l]) : [])
        .concat(a[r] ? preorder(a[r]) : []);
 
    
    const inorder = a =>
        (a[l] ? inorder(a[l]) : [])
        .concat(a[v])
        .concat(a[r] ? inorder(a[r]) : []);
 
    
    const postorder = a =>
        (a[l] ? postorder(a[l]) : [])
        .concat(a[r] ? postorder(a[r]) : [])
        .concat(a[v]);
 
    
    const levelorder = a => (function go(x) {
        return x.length ? (
            x[0] ? (
                [x[0][v]].concat(
                    go(x.slice(1)
                        .concat([x[0][l], x[0][r]])
                    )
                )
            ) : go(x.slice(1))
        ) : [];
    })([a]);
 
 
    
 
    
    
    const ap = (fs, xs) => //
        [].concat.apply([], fs.map(f => //
            [].concat.apply([], xs.map(x => [f(x)]))));
 
    
    const intercalate = (s, xs) => xs.join(s);
 
    
    const justifyLeft = (n, cFiller, strText) =>
        n > strText.length ? (
            (strText + cFiller.repeat(n))
            .substr(0, n)
        ) : strText;
 
    
    const min = (a, b) => b < a ? b : a;
 
    
    const unlines = xs => xs.join('');
 
    
    const unwords = xs => xs.join(' ');
 
    
    const zipWith = (f, xs, ys) =>
        Array.from({
            length: min(xs.length, ys.length)
        }, (_, i) => f(xs[i], ys[i]));
 
    
    
    const asciiTree = unlines([
        '         1',
        '        / ',
        '       /   ',
        '      /     ',
        '     2       3',
        '    /      /',
        '   4   5   6',
        '  /       / ',
        ' 7       8   9'
    ]);
 
    const [v, l, r] = [0, 1, 2],
    tree = [1, [2, [4, [7]],
                [5]
            ],
            [3, [6, [8],
                [9]
            ]]
        ],
 
        
        fs = [preorder, inorder, postorder, levelorder];
 
    return asciiTree + '' +
        intercalate('',
            zipWith(
                (f, xs) => justifyLeft(12, ' ', f.name + ':') + unwords(xs),
                fs,
                ap(fs, [tree])
            )
        );
})();         1
        / \
       /   \
      /     \
     2       3
    / \     /
   4   5   6
  /       / \
 7       8   9
 
preorder:   1 2 4 7 5 3 6 8 9
inorder:    7 4 2 5 1 8 6 9 3
postorder:  7 4 5 2 8 9 6 3 1
levelorder: 1 2 3 4 5 6 7 8 9"
"function move(n, a, b, c) {
  if (n > 0) {
    move(n-1, a, c, b);
    console.log(strv + a + strv + c);
    move(n-1, b, a, c);
  }
}
move(4, strv, strv, strv);(function () {
 
    
    function hanoi(n, a, b, c) {
        return n ? hanoi(n - 1, a, c, b)
            .concat([
                [a, b]
            ])
            .concat(hanoi(n - 1, c, b, a)) : [];
    }
 
    return hanoi(3, 'left', 'right', 'mid')
        .map(function (d) {
            return d[0] + ' -> ' + d[1];
        });
})();[strv, strv,
 strv, strv, 
 strv, strv, 
 strv](() => {
    'use strict';
 
    
    const hanoi = (n, a, b, c) =>
        n ? hanoi(n - 1, a, c, b)
        .concat([
            [a, b]
        ])
        .concat(hanoi(n - 1, c, b, a)) : [];
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    return show(
        hanoi(3, 'left', 'right', 'mid')
        .map(d => d[0] + ' -> ' + d[1])
    );
})();"
"var
 radians = Math.PI / 4, 
 degrees = 45.0,
 sine = Math.sin(radians),
 cosine = Math.cos(radians),
 tangent = Math.tan(radians),
 arcsin = Math.asin(sine),
 arccos = Math.acos(cosine),
 arctan = Math.atan(tangent);
 

window.alert(sine + strv + Math.sin(degrees * Math.PI / 180));

window.alert(cosine + strv + Math.cos(degrees * Math.PI / 180));

window.alert(tangent + strv + Math.tan(degrees * Math.PI / 180));

window.alert(arcsin + strv + (arcsin * 180 / Math.PI));

window.alert(arccos + strv + (arccos * 180 / Math.PI));

window.alert(arctan + strv + (arctan * 180 / Math.PI));"
"const libs =
  `des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee
  dw01             ieee dw01 dware gtech
  dw02             ieee dw02 dware
  dw03             std synopsys dware dw03 dw02 dw01 ieee gtech
  dw04             dw04 ieee dw01 dware gtech
  dw05             dw05 ieee dware
  dw06             dw06 ieee dware
  dw07             ieee dware
  dware            ieee dware
  gtech            ieee gtech
  ramlib           std ieee
  std_cell_lib     ieee std_cell_lib
  synopsys`;
 


const D = libs
  .split('')
  .map(e => e.split(' ').filter(e => e != ''))
  .reduce((p, c) =>
    p.set(c[0], c.filter((e, i) => i > 0 && e !== c[0] ? e : null)), new Map());
[].concat(...D.values()).forEach(e => {
  D.set(e, D.get(e) || [])
});
 







const G = [...D.keys()].reduce((p, c) =>
  p.set(
    c,
    [...D.keys()].filter(e => D.get(e).includes(c))),
  new Map()
);
 

const Q = [...D.keys()].filter(e => D.get(e).length == 0);
 

const S = [];
while (Q.length) {
  const u = Q.pop();
  S.push(u);
  G.get(u).forEach(v => {
    D.set(v, D.get(v).filter(e => e !== u));
    if (D.get(v).length == 0) {
      Q.push(v);
    }
  });
}
 
console.log('Solution:', S);
  
Solution: [
  'ieee',
  'std_cell_lib',
  'gtech',
  'dware',
  'dw07',
  'dw06',
  'dw05',
  'dw02',
  'dw01',
  'dw04',
  'std',
  'ramlib',
  'synopsys',
  'dw03',
  'des_system_lib' ]
 "
"(() => {
    'use strict';
 
    
 
    
    let thueMorse = nCycles => range(1, Math.abs(nCycles))
            .reduce(a => a.concat(a.map(x => 1 - x)), [0])
            .join('');
 
 
    
 
    
    let range = (m, n) => Array.from({
        length: Math.floor((n - m)) + 1
    }, (_, i) => m + i);
 
 
    
 
    return thueMorse(6);
 
    
 
})();
 "
alert( strv.split(strv).join(strv) );
"function tokenize(s, esc, sep) {
	for (var a=[], t='', i=0, e=s.length; i<e; i+=1) {
		var c = s.charAt(i)
		if (c == esc) t+=s.charAt(++i)
		else if (c != sep) t+=c
		else a.push(t), t=''		
	}
	a.push(t)
	return a
}
 
var s = 'one^|uno||three^^^^|four^^^|^cuatro|'
document.write(s, '<br>')	
for (var a=tokenize(s,'^','|'), i=0; i<a.length; i+=1) document.write(i, ': ', a[i], '<br>')(function () {
    'use strict';
 
    
    function tokenize(str, charDelim, charEsc) {
        var dctParse = str.split('')
            .reduce(function (a, x) {
 
                var blnEsc = a.esc,
                    blnBreak = !blnEsc && x === charDelim,
                    blnEscChar = !blnEsc && x === charEsc;
 
                return {
                    esc: blnEscChar,
                    token: blnBreak ? '' : (
                        a.token + (blnEscChar ? '' : x)
                    ),
                    list: a.list.concat(blnBreak ? a.token : [])
                };
            }, {
                esc: false,
                token: '',
                list: []
            });
 
        return dctParse.list.concat(
            dctParse.token
        );
    }
 
    return tokenize(
            'one^|uno||three^^^^|four^^^|^cuatro|',
            '|','^'
        )
        .join('');
 
})();((() => {
 
    
    const tokenize = (charDelim, charEsc, str) => {
        const [token, list, _] = str.split('')
            .reduce(([aToken, aList, aEsc], x) => {
                const
                    blnBreak = !aEsc && x === charDelim,
                    blnEscChar = !aEsc && x === charEsc;
 
                return [
                    blnBreak ? '' : (
                        aToken + (blnEscChar ? '' : x)
                    ),
                    aList.concat(blnBreak ? aToken : []),
                    blnEscChar
                ];
            }, ['', [], false]);
 
        return list.concat(token);
    };
 
    
    const splitEsc = str => tokenize('|', '^', str);
 
 
    
    
    const show = x => JSON.stringify(x, null, 2);
 
    return splitEsc(
            'one^|uno||three^^^^|four^^^|^cuatro|',
        )
        .map(show)
        .join('');
}))();"
"var data = [
    {name: strv,   id: strv, salary: 32000, dept: strv},
    {name: strv,      id: strv, salary: 47000, dept: strv},
    {name: strv,  id: strv, salary: 53500, dept: strv},
    {name: strv,      id: strv, salary: 18000, dept: strv},
    {name: strv,  id: strv, salary: 27800, dept: strv},
    {name: strv, id: strv, salary: 41500, dept: strv},
    {name: strv,    id: strv, salary: 49500, dept: strv},
    {name: strv,    id: strv, salary: 21900, dept: strv},
    {name: strv,  id: strv, salary: 15900, dept: strv},
    {name: strv, id: strv, salary: 19250, dept: strv},
    {name: strv,     id: strv, salary: 27000, dept: strv},
    {name: strv,      id: strv, salary: 57000, dept: strv},
    {name: strv,   id: strv, salary: 29900, dept: strv},
];
 
function top_rank(n) {
    var by_dept = group_by_dept(data);
    for (var dept in by_dept) {
        output(dept);
        for (var i = 0; i < n && i < by_dept[dept].length; i++) {
            var emp = by_dept[dept][i];
            output(emp.name + strv + emp.id + strv + emp.salary);
        }
        output(strv);
    }
}
 

function group_by_dept(data) {
    var by_dept = {};
    for (var idx in data)  {
        var dept = data[idx].dept;
        if ( ! has_property(by_dept, dept)) {
            by_dept[dept] = new Array();
        }
        by_dept[dept].push(data[idx]);
    }
    for (var dept in by_dept) {
        
        by_dept[dept].sort(function (a,b){return b.salary - a.salary});
    }
    return by_dept;
}
 
function has_property(obj, propname) {
    return typeof(obj[propname]) != strv;
}
 
function output(str) {
    try {
        WScript.Echo(str);  
    } catch(err) {
        print(str);  
    }
}
 
top_rank(3);
  
var collectDept = function (arrOfObj) {
  var collect = arrOfObj.reduce(function (rtnObj, obj) {
    if (rtnObj[obj.dept] === undefined) {
      rtnObj[obj.dept] = [];
    }
    rtnObj[obj.dept].push(obj);
    return rtnObj;
  }, {});
 
  return Object.keys(collect).map(function (key) {
    return collect[key];
  });
};
 
var sortSalary = function (arrOfSalaryArrs) {
  return arrOfSalaryArrs.map(function (item) {
    return item.sort(function (a, b) {
      if (a.salary > b.salary) { return -1; }
      if (a.salary < b.salary) { return 1; }
      return 0;
    });
  });
};
 
var getNTopSalariesByDept = function (n, data) {
  if (n < 0) { return; }
 
  return sortSalary(collectDept(data)).map(function (list) {
    return list.slice(0,n);
  });
};
 "
"(function() {
	var orig= document.body.innerHTML
	document.body.innerHTML= '';
	setTimeout(function() {
		document.body.innerHTML= 'something';
		setTimeout(function() {
			document.body.innerHTML= orig;
		}, 1000);
	}, 1000);
})();"
" 
var days = [
    'first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth',
    'tenth', 'eleventh', 'twelfth',
];
 
var gifts = [
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv
];
 
var lines, verses = [], song;
 
for ( var i = 0; i < 12; i++ ) {
 
    lines = [];
    lines[0] = strv + days[i] + strv;
 
    var j = i + 1;
    var k = 0;
    while ( j-- > 0 )
        lines[++k] = gifts[j];
 
 
    verses[i] = lines.join('');
 
    if ( i == 0 )
        gifts[0] = strv;
 
}
 
song = verses.join('');
document.write(song);
 JSON.stringify(
  (function (
    strPrepn,
    strHoliday,
    strUnit,
    strRole,
    strProcess,
    strRecipient
  ) {
    var lstOrdinal =
      'first second third fourth fifth sixth           seventh eighth ninth tenth eleventh twelfth'
      .split(/\s+/),
      lngUnits = lstOrdinal.length,
 
      lstGoods =
      'A partridge in a pear tree.           Two turtle doves           Three french hens           Four calling birds           Five golden rings           Six geese a-laying           Seven swans a-swimming           Eight maids a-milking           Nine ladies dancing           Ten lords a-leaping           Eleven pipers piping           Twelve drummers drumming'
      .split(/\s{2,}/),
 
      lstReversed = (function () {
        var lst = lstGoods.slice(0);
        return (lst.reverse(), lst);
      })(),
 
      strProvenance = [strRole, strProcess, strRecipient + ':'].join(' '),
 
      strPenultimate = lstReversed[lngUnits - 2] + ' and',
      strFinal = lstGoods[0];
 
    return lstOrdinal.reduce(
      function (sofar, day, i) {
        return sofar.concat(
          [
            [
              [ 
                strPrepn,
                'the',
                lstOrdinal[i],
                strUnit,
                'of',
                strHoliday
              ].join(' '),
              strProvenance
            ].concat( 
              (i > 1 ? [lstGoods[i]] : []).concat(
                lstReversed.slice(
                  lngUnits - i,
                  lngUnits - 2
                )
              ).concat( 
                [
                  strPenultimate,
                  strFinal
                ].slice(i ? 0 : 1)
              )
            )
          ]
        );
      }, []
    );
  })(
    'On', 'Christmas', 'day', 'my true love', 'gave to', 'me'
  ), null, 2
);JSON.stringify(function (h, k, l, f, m, n) {
  var c =
    strv
    .split(strv),
    d = c.length,
    e =
    strv
    .split(strv),
    g = function () {
      var b = e.slice(0);
      return b.reverse(), b;
    }(),
    p = [f, m, n + strv].join(strv),
    q = g[d - 2] + strv,
    r = e[0];
 
  return c.reduce(function (b, f, a) {
    return b.concat([[[h, strv, c[a], l, strv, k].join(strv), p].concat((1 <
      a ? [e[a]] : []).concat(g.slice(d - a, d - 2)).concat([q, r].slice(a ?
      0 : 1)))]);
  }, []);
}(strv, strv, strv, strv, strv, strv), null, 2);[
  [
    strv,
    strv,
    strv
  ],
  [
    strv,
    strv,
    strv,
    strv
  ],
  [
    strv,
    strv,
    strv,
    strv,
    strv
  ],
  [
    strv,
    strv,
    strv,
    strv,
    strv,
    strv
  ],
  [
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv
  ]
 
//... etc.
 
]"
"var file_system = new ActiveXObject(strv);
var fh = file_system.openTextFile('mlijobs.txt', 1); 
var in_use = 0, max_in_use = -1, max_in_use_at = [];
 
while ( ! fh.atEndOfStream) {
    var line = fh.readline();
    if (line.substr(8,3) == strv) {
        in_use++;
        if (in_use > max_in_use) {
            max_in_use = in_use;
            max_in_use_at = [ line.split(' ')[3] ];
        }
        else if (in_use == max_in_use)
            max_in_use_at.push( line.split(' ')[3] );
    }
    else if (line.substr(8,2) == strv) 
        in_use--;
}
 
fh.close();
 
WScript.echo(strv + max_in_use + ""  "" + max_in_use_at.join('  '));"
"const assert = require('assert');
 
describe('palindrome', () => {
  const pali = require('../lib/palindrome');
 
  describe('.check()', () => {
    it('should return true on encountering a palindrome', () => {
      assert.ok(pali.check('racecar'));
      assert.ok(pali.check('abcba'));
      assert.ok(pali.check('aa'));
      assert.ok(pali.check('a'));
    });
 
    it('should return true on encountering an empty string', () => {
      assert.ok(pali.check(''));
    });
 
    it('should return false on encountering a non-palindrome', () => {
      assert.ok(!pali.check('alice'));
      assert.ok(!pali.check('ab'));
      assert.ok(!pali.check('abcdba'));
    });
  })
});"
"
function analyze_func(filename) {
    var dates_seen = {};
    var format_bad = 0;
    var records_all = 0;
    var records_good = 0;
    return function() {
        var fh = new ActiveXObject(strv).openTextFile(filename, 1); 
        while ( ! fh.atEndOfStream) {
            records_all ++;
            var allOK = true;
            var line = fh.ReadLine();
            var fields = line.split('');
            if (fields.length != 49) {
                format_bad ++;
                continue;
            }
 
            var date = fields.shift();
            if (has_property(dates_seen, date)) 
                WScript.echo(strv + date);
            else
                dates_seen[date] = 1;
 
            while (fields.length > 0) {
                var value = parseFloat(fields.shift());
                var flag = parseInt(fields.shift(), 10);
                if (isNaN(value) || isNaN(flag)) {
                    format_bad ++;
                }
                else if (flag <= 0) {
                    allOK = false;
                }
            }
            if (allOK)
                records_good ++;
        }
        fh.close();
        WScript.echo(strv + records_all);
        WScript.echo(strv + format_bad);
        WScript.echo(strv + records_good);
    }
}
 
function has_property(obj, propname) {
    return typeof(obj[propname]) == strv ? false : true;
}
 
var analyze = analyze_func('readings.txt');
analyze();"
"var filename = 'readings.txt';
var show_lines = 5;
var file_stats = {
    'num_readings': 0,
    'total': 0,
    'reject_run': 0,
    'reject_run_max': 0,
    'reject_run_date': ''
};
 
var fh = new ActiveXObject(strv).openTextFile(filename, 1); 
while ( ! fh.atEndOfStream) {
    var line = fh.ReadLine();
    line_stats(line, (show_lines-- > 0));
}
fh.close();
 
WScript.echo(
    ""File(s)  = "" + filename + """" +
    strv + dec3(file_stats.total) + """" +
    strv + file_stats.num_readings + """" +
    strv + dec3(file_stats.total / file_stats.num_readings) + """" +
    strv + file_stats.reject_run_max + 
    strv + file_stats.reject_run_date
);
 
function line_stats(line, print_line) {
    var readings = 0;
    var rejects = 0;
    var total = 0;
    var fields = line.split('');
    var date = fields.shift();
 
    while (fields.length > 0) {
        var value = parseFloat(fields.shift());
        var flag = parseInt(fields.shift(), 10);
        readings++;
        if (flag <= 0) {
            rejects++;
            file_stats.reject_run++;
        }
        else {
            total += value;
            if (file_stats.reject_run > file_stats.reject_run_max) {
                file_stats.reject_run_max = file_stats.reject_run;
                file_stats.reject_run_date = date;
            }
            file_stats.reject_run = 0;
        }
    }
 
    file_stats.num_readings += readings - rejects;
    file_stats.total += total;
 
    if (print_line) {
        WScript.echo(
            strv + date + """" +
            strv + rejects + """" +
            strv + (readings - rejects) + """" +
            strv + dec3(total) + """" +
            strv + ((readings == rejects) ? strv : dec3(total / (readings - rejects)))
        );
    }
}
 

function dec3(value) {
    return Math.round(value * 1e3) / 1e3;
}"
"var k2c = k => k - 273.15
var k2r = k => k * 1.8
var k2f = k => k2r(k) - 459.67
 
Number.prototype.toMaxDecimal = function (d) {
	return +this.toFixed(d) + ''
}
 
function kCnv(k) {
	document.write( k,'K° = ', k2c(k).toMaxDecimal(2),'C° = ', k2r(k).toMaxDecimal(2),'R° = ', k2f(k).toMaxDecimal(2),'F°<br>' ) 
}
 
kCnv(21)
kCnv(295)(() => {
    'use strict';
 
    let kelvinTranslations = k => ['K', 'C', 'F', 'R']
        .map(x => [x, heatBabel(k, 'K', x)]);
 
    
    let heatBabel = (n, strFromScale, strToScale) => {
        let ratio = 9 / 5,
            cels = 273.15,
            fahr = 459.67,
            id = x => x,
            readK = {
                k: id,
                c: x => cels + x,
                f: x => (fahr + x) * ratio,
                r: x => x / ratio
            },
            writeK = {
                k: id,
                c: x => x - cels,
                f: x => (x * ratio) - fahr,
                r: x => ratio * x
            };
 
        return writeK[strToScale.charAt(0).toLowerCase()](
            readK[strFromScale.charAt(0).toLowerCase()](n)
        ).toFixed(2);
    };
 
 
    
    return kelvinTranslations(21)
        .map(([s, n]) => s + ('          ' + n)
            .slice(-10))
        .join('');
 
})();
 "
"var n3s = [],
    s3s = {}
for (var n = 1, e = 1200; n < e; n += 1) n3s[n] = n * n * n
for (var a = 1; a < e - 1; a += 1) {
    var a3 = n3s[a]
    for (var b = a; b < e; b += 1) {
        var b3 = n3s[b]
        var s3 = a3 + b3,
            abs = s3s[s3]
        if (!abs) s3s[s3] = abs = []
        abs.push([a, b])
    }
}
 
var i = 0
for (var s3 in s3s) {
    var abs = s3s[s3]
    if (abs.length < 2) continue
    i += 1
    if (abs.length == 2 && i > 25 && i < 2000) continue
    if (i > 2006) break
    document.write(i, ': ', s3)
    for (var ab of abs) {
        document.write(' = ', ab[0], '<sup>3</sup>+', ab[1], '<sup>3</sup>')
    }
    document.write('<br>')
}"
"var notes = 'NOTES.TXT';
 
var args = WScript.Arguments;
var fso = new ActiveXObject(strv);
var ForReading = 1, ForWriting = 2, ForAppending = 8;
 
if (args.length == 0) {
    if (fso.FileExists(notes)) {
        var f = fso.OpenTextFile(notes, ForReading);
        WScript.Echo(f.ReadAll());
        f.Close();
    }
}
else {
    var f = fso.OpenTextFile(notes, ForAppending, true);
    var d = new Date();
    f.WriteLine(d.toLocaleString());
    f.Write("""");
    
    
    for (var i = 0; i < args.length; i++) {
        f.Write(args(i) + strv);
    }
    f.WriteLine();
    f.Close();
}"
"console.log(new Date()) 
console.log(Date.now()) "
"var L3 = new Object();
 
L3.not = function(a) {
  if (typeof a == strv) return !a;
  if (a == undefined) return undefined;
  throw(strv);
}
 
L3.and = function(a, b) {
  if (typeof a == strv && typeof b == strv) return a && b;
  if ((a == true && b == undefined) || (a == undefined && b == true)) return undefined;
  if ((a == false && b == undefined) || (a == undefined && b == false)) return false;
  if (a == undefined && b == undefined) return undefined;
  throw(strv);
}
 
L3.or = function(a, b) {
  if (typeof a == strv && typeof b == strv) return a || b;
  if ((a == true && b == undefined) || (a == undefined && b == true)) return true;
  if ((a == false && b == undefined) || (a == undefined && b == false)) return undefined;
  if (a == undefined && b == undefined) return undefined;
  throw(strv);
}
 

L3.ifThen = function(a, b) {
  return L3.or(L3.not(a), b);
}
 

L3.iff = function(a, b) {
  return L3.and(L3.ifThen(a, b), L3.ifThen(b, a));
}
 "
" 
<html>
    <head>
	<script>
        function clip (subjectPolygon, clipPolygon) {
 
            var cp1, cp2, s, e;
            var inside = function (p) {
                return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);
            };
            var intersection = function () {
                var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],
                    dp = [ s[0] - e[0], s[1] - e[1] ],
                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
                    n2 = s[0] * e[1] - s[1] * e[0], 
                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];
            };
            var outputList = subjectPolygon;
            cp1 = clipPolygon[clipPolygon.length-1];
            for (j in clipPolygon) {
                var cp2 = clipPolygon[j];
                var inputList = outputList;
                outputList = [];
                s = inputList[inputList.length - 1]; //last on the input list
                for (i in inputList) {
                    var e = inputList[i];
                    if (inside(e)) {
                        if (!inside(s)) {
                            outputList.push(intersection());
                        }
                        outputList.push(e);
                    }
                    else if (inside(s)) {
                        outputList.push(intersection());
                    }
                    s = e;
                }
                cp1 = cp2;
            }
            return outputList
        }
 
        function drawPolygon(context, polygon, strokeStyle, fillStyle) {
            context.strokeStyle = strokeStyle;
            context.fillStyle = fillStyle;
            context.beginPath();
            context.moveTo(polygon[0][0],polygon[0][1]); //first vertex
            for (var i = 1; i < polygon.length ; i++)
                context.lineTo(polygon[i][0],polygon[i][1]);
            context.lineTo(polygon[0][0],polygon[0][1]); //back to start
            context.fill();
            context.stroke();
            context.closePath();
        }
 
        window.onload = function () {
	        var context = document.getElementById('canvas').getContext('2d');
	        var subjectPolygon = [[50, 150], [200, 50], [350, 150], [350, 300], [250, 300], [200, 250], [150, 350], [100, 250], [100, 200]],
	            clipPolygon = [[100, 100], [300, 100], [300, 300], [100, 300]];
	        var clippedPolygon = clip(subjectPolygon, clipPolygon);
	        drawPolygon(context, clipPolygon, '#888','#88f');
	        drawPolygon(context, subjectPolygon, '#888','#8f8');
	        drawPolygon(context, clippedPolygon, '#000','#0ff');
    	}
        </script>
    <body>
    	<canvas id='canvas' width='400' height='400'></canvas>
    </body>
</html>
 "
"
function relative_complement(A, B) {
    return A.filter(function(elem) {return B.indexOf(elem) == -1});
}
 

function symmetric_difference(A,B) {
    return relative_complement(A,B).concat(relative_complement(B,A));
}
 
var a = [strv, strv, strv, strv, strv].unique(); 
var b = [strv, strv, strv, strv, strv].unique();
 
print(a);
print(b);
print(symmetric_difference(a,b));function Difference(A,B)
{
    var a = A.length, b = B.length, c = 0, C = [];
    for (var i = 0; i < a; i++)
     { var j = 0, k = 0;
       while (j < b && B[j] !== A[i]) j++;
       while (k < c && C[k] !== A[i]) k++;
       if (j == b && k == c) C[c++] = A[i];
     }
    return C;
}
 
function SymmetricDifference(A,B)
{  
    var D1 = Difference(A,B), D2 = Difference(B,A),
        a = D1.length, b = D2.length;
    for (var i = 0; i < b; i++) D1[a++] = D2[i];
    return D1;
}
 
 
/* Example   A = ['John', 'Serena', 'Bob', 'Mary', 'Serena'];   B = ['Jim', 'Mary', 'John', 'Jim', 'Bob'];    Difference(A,B);           // 'Serena'   Difference(B,A);           // 'Jim'   SymmetricDifference(A,B);  // 'Serena','Jim'*/((a, b) => {
    'use strict';
 
 
    let 
 
    
        union = (xs, ys) => unionBy((a, b) => a === b, xs, ys),
 
        
        difference = (xs, ys) =>
            ys.reduce((a, y) =>
                a.indexOf(y) !== -1 ? (
                    delete_(y, a)
                ) : a.concat(y), xs),
 
 
 
        
 
        
        unionBy = (f, xs, ys) => {
            let sx = nubBy(f, xs),
                sy = nubBy(f, ys);
 
            return sx.concat(
                sx
                .reduce(
                    (a, x) => deleteBy(f, x, a),
                    sy
                )
            )
        },
 
        
        deleteBy = (f, x, xs) =>
            xs.reduce((a, y) => f(x, y) ? a : a.concat(y), []),
 
        
        delete_ = (x, xs) =>
            deleteBy((a, b) => a === b, x, xs),
 
        
        nubBy = (f, xs) => {
            let x = (xs.length ? xs[0] : undefined);
 
            return x !== undefined ? [x].concat(
                nubBy(f, xs.slice(1)
                    .filter(y => !f(x, y))
                )
            ) : [];
        };
 
 
 
    
 
    return union(
        difference(a, b),
        difference(b, a)
    );
 
})(
    [strv, strv, strv, strv, strv], 
    [strv, strv, strv, strv, strv]
);[strv, strv]"
"(function () {
    'use strict';
 
    
 
    
    var permutationsWithRepetition = function (n, as) {
        return as.length > 0 ?
            foldl1(curry(cartesianProduct)(as), replicate(n, as)) : [];
    };
 
    
    var cartesianProduct = function (xs, ys) {
        return [].concat.apply([], xs.map(function (x) {
            return [].concat.apply([], ys.map(function (y) {
                return [
                    [x].concat(y)
                ];
            }));
        }));
    };
 
    
    var curry = function (f) {
        return function (a) {
            return function (b) {
                return f(a, b);
            };
        };
    };
 
    
    var flip = function (f) {
        return function (a, b) {
            return f.apply(null, [b, a]);
        };
    };
 
    
    var foldl1 = function (f, xs) {
        return xs.length > 0 ? xs.slice(1)
            .reduce(f, xs[0]) : [];
    };
 
    
    var replicate = function (n, a) {
        var v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    var group = function (xs) {
        return groupBy(function (a, b) {
            return a === b;
        }, xs);
    };
 
    
    var groupBy = function (f, xs) {
        var dct = xs.slice(1)
            .reduce(function (a, x) {
                var h = a.active.length > 0 ? a.active[0] : undefined,
                    blnGroup = h !== undefined && f(h, x);
 
                return {
                    active: blnGroup ? a.active.concat(x) : [x],
                    sofar: blnGroup ? a.sofar : a.sofar.concat([a.active])
                };
            }, {
                active: xs.length > 0 ? [xs[0]] : [],
                sofar: []
            });
        return dct.sofar.concat(dct.active.length > 0 ? [dct.active] : []);
    };
 
    
    var compare = function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    };
 
    
    var on = function (f, g) {
        return function (a, b) {
            return f(g(a), g(b));
        };
    };
 
    
    var nub = function (xs) {
        return nubBy(function (a, b) {
            return a === b;
        }, xs);
    };
 
    
    var nubBy = function (p, xs) {
        var x = xs.length ? xs[0] : undefined;
 
        return x !== undefined ? [x].concat(nubBy(p, xs.slice(1)
            .filter(function (y) {
                return !p(x, y);
            }))) : [];
    };
 
    
    var find = function (f, xs) {
        for (var i = 0, lng = xs.length; i < lng; i++) {
            if (f(xs[i], i)) return xs[i];
        }
        return undefined;
    };
 
    
    var take = function (n, xs) {
        return xs.slice(0, n);
    };
 
    
    var unlines = function (xs) {
        return xs.join('');
    };
 
    
    var show = function (x) {
        return JSON.stringify(x);
    }; //, null, 2);
 
    
    var head = function (xs) {
        return xs.length ? xs[0] : undefined;
    };
 
    
    var tail = function (xs) {
        return xs.length ? xs.slice(1) : undefined;
    };
 
    
    var length = function (xs) {
        return xs.length;
    };
 
    
 
    
    
    var asSum = function (xs) {
        var dct = xs.reduceRight(function (a, sign, i) {
            var d = i + 1; 
            if (sign !== 0) {
                
                return {
                    digits: [],
                    n: a.n + sign * parseInt([d].concat(a.digits)
                        .join(''), 10)
                };
            } else return { 
                digits: [d].concat(a.digits),
                n: a.n
            };
        }, {
            digits: [],
            n: 0
        });
        return dct.n + (
            dct.digits.length > 0 ? parseInt(dct.digits.join(''), 10) : 0
        );
    };
 
    
    
    var asString = function (xs) {
        var ns = xs.reduce(function (a, sign, i) {
            var d = (i + 1)
                .toString();
            return sign === 0 ? a + d : a + (sign > 0 ? ' +' : ' -') + d;
        }, '');
 
        return ns[0] === '+' ? tail(ns) : ns;
    };
 
    
 
    
    var universe = permutationsWithRepetition(9, [0, 1, -1])
        .filter(function (x) {
            return x[0] !== 1;
        });
 
    
    var allNonNegativeSums = universe.map(asSum)
        .filter(function (x) {
            return x >= 0;
        })
        .sort();
 
    
    var uniqueNonNegativeSums = nub(allNonNegativeSums);
 
    return [""Sums to 100:"", unlines(universe.filter(function (x) {
                return asSum(x) === 100;
            })
            .map(asString)),
 
        ""10 commonest sums (sum, followed by number of routes to it):"",
        show(take(10, group(allNonNegativeSums)
            .sort(on(flip(compare), length))
            .map(function (xs) {
                return [xs[0], xs.length];
            }))),
 
        ""First positive integer not expressible as a sum of this kind:"",
        show(find(function (x, i) {
            return x !== i;
        }, uniqueNonNegativeSums.sort(compare)) - 1), 
 
        ""10 largest sums:"",
        show(take(10, uniqueNonNegativeSums.sort(flip(compare))))
    ].join('') + '';
})();(() => {
    'use strict';
 
    
 
    
    const permutationsWithRepetition = (n, as) =>
        as.length > 0 ? (
            foldl1(curry(cartesianProduct)(as), replicate(n, as))
        ) : [];
 
    
    const cartesianProduct = (xs, ys) =>
        [].concat.apply([], xs.map(x =>
        [].concat.apply([], ys.map(y => [[x].concat(y)]))));
 
    
    const curry = f => a => b => f(a, b);
 
    
    const flip = f => (a, b) => f.apply(null, [b, a]);
 
    
    const foldl1 = (f, xs) =>
        xs.length > 0 ? xs.slice(1)
        .reduce(f, xs[0]) : [];
 
    
    const replicate = (n, a) => {
        let v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    const group = xs => groupBy((a, b) => a === b, xs);
 
    
    const groupBy = (f, xs) => {
        const dct = xs.slice(1)
            .reduce((a, x) => {
                const
                    h = a.active.length > 0 ? a.active[0] : undefined,
                    blnGroup = h !== undefined && f(h, x);
 
                return {
                    active: blnGroup ? a.active.concat(x) : [x],
                    sofar: blnGroup ? a.sofar : a.sofar.concat([a.active])
                };
            }, {
                active: xs.length > 0 ? [xs[0]] : [],
                sofar: []
            });
        return dct.sofar.concat(dct.active.length > 0 ? [dct.active] : []);
    };
 
    
    const compare = (a, b) => a < b ? -1 : (a > b ? 1 : 0);
 
    
    const on = (f, g) => (a, b) => f(g(a), g(b));
 
    
    const nub = xs => nubBy((a, b) => a === b, xs);
 
    
    const nubBy = (p, xs) => {
        const x = xs.length ? xs[0] : undefined;
 
        return x !== undefined ? [x].concat(
            nubBy(p, xs.slice(1)
                .filter(y => !p(x, y)))
        ) : [];
    };
 
    
    const find = (f, xs) => {
        for (var i = 0, lng = xs.length; i < lng; i++) {
            if (f(xs[i], i)) return xs[i];
        }
        return undefined;
    }
 
    
    const take = (n, xs) => xs.slice(0, n);
 
    
    const unlines = xs => xs.join('');
 
    
    const show = x => JSON.stringify(x); //, null, 2);
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const tail = xs => xs.length ? xs.slice(1) : undefined;
 
    
    const length = xs => xs.length;
 
 
    
 
    
    
    const asSum = xs => {
        const dct = xs.reduceRight((a, sign, i) => {
            const d = i + 1; 
            if (sign !== 0) { 
                return {
                    digits: [],
                    n: a.n + (sign * parseInt([d].concat(a.digits)
                        .join(''), 10))
                };
            } else return { 
                digits: [d].concat(a.digits),
                n: a.n
            };
        }, {
            digits: [],
            n: 0
        });
        return dct.n + (dct.digits.length > 0 ? (
            parseInt(dct.digits.join(''), 10)
        ) : 0);
    };
 
    
    
    const asString = xs => {
        const ns = xs.reduce((a, sign, i) => {
            const d = (i + 1)
                .toString();
            return (sign === 0 ? (
                a + d
            ) : (a + (sign > 0 ? ' +' : ' -') + d));
        }, '');
 
        return ns[0] === '+' ? tail(ns) : ns;
    };
 
 
    
 
    
    const universe = permutationsWithRepetition(9, [0, 1, -1])
        .filter(x => x[0] !== 1);
 
    
    const allNonNegativeSums = universe.map(asSum)
        .filter(x => x >= 0)
        .sort();
 
    
    const uniqueNonNegativeSums = nub(allNonNegativeSums);
 
 
    return [
        ""Sums to 100:"",
        unlines(universe.filter(x => asSum(x) === 100)
            .map(asString)),
 
        ""10 commonest sums (sum, followed by number of routes to it):"",
        show(take(10, group(allNonNegativeSums)
            .sort(on(flip(compare), length))
            .map(xs => [xs[0], xs.length]))),
 
        ""First positive integer not expressible as a sum of this kind:"",
        show(find(
            (x, i) => x !== i,
            uniqueNonNegativeSums.sort(compare)
        ) - 1), 
 
        ""10 largest sums:"",
        show(take(10, uniqueNonNegativeSums.sort(flip(compare))))
    ].join('') + '';
})();"
"function sumsq(array) {
  var sum = 0;
  var i, iLen;
 
  for (i = 0, iLen = array.length; i < iLen; i++) {
    sum += array[i] * array[i];
  }
  return sum;
}
 
alert(sumsq([1,2,3,4,5]));  function sumsq(array) {
  var sum = 0, 
      i = array.length;
 
  while (i--) sum += Math.pow(array[i], 2);
 
  return sum;
}
 
alert(sumsq([1,2,3,4,5])); Functional.reduce(strv, 0, [1,2,3,4,5])[3,1,4,1,5,9].map(function (n) { return Math.pow(n,2); }).reduce(function (sum,n) { return sum+n; });(() => {
    'use strict';
 
    
    const squared = x => Math.pow(x, 2);
 
    
    const sum = xs => xs.reduce((a, x) => a + x, 0);
 
    
    const sumOfSquares = xs => sum(xs.map(squared));
 
    
    const sumOfSquares2 = xs =>
        xs.reduce((a, x) => a + squared(x), 0);
 
    return [sumOfSquares, sumOfSquares2]
        .map(f => f([3, 1, 4, 1, 5, 9]))
        .join('');
})();"
"function sum(a,b,fn) {
   var s = 0;
   for ( ; a <= b; a++) s += fn(a);
   return s;
}
 
 sum(1,1000, function(x) { return 1/(x*x) } )  (function () {
 
  function sum(fn, lstRange) {
    return lstRange.reduce(
      function (lngSum, x) {
        return lngSum + fn(x);
      }, 0
    );
  }
 
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
 
  return sum(
    function (x) {
      return 1 / (x * x);
    },
    range(1, 1000)
  );
 
})();1.6439345666815615(() => {
    'use strict';
 
    
    const seriesSum = (f, xs) =>
        xs.reduce((a, x) => a + f(x), 0);
 
 
    
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
 
    return seriesSum(x => 1 / (x * x), range(1, 1000));
})();1.6439345666815615"
"(function () {
    'use strict';
 
    
 
    
    var concatMap = function concatMap(f, xs) {
            return [].concat.apply([], xs.map(f));
        },
 
        
        curry = function curry(f) {
            return function (a) {
                return function (b) {
                    return f(a, b);
                };
            };
        },
 
        
        intersectBy = function intersectBy(eq, xs, ys) {
            return xs.length && ys.length ? xs.filter(function (x) {
                return ys.some(curry(eq)(x));
            }) : [];
        },
 
        
        range = function range(m, n, step) {
            var d = (step || 1) * (n >= m ? 1 : -1);
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, function (_, i) {
                return m + i * d;
            });
        };
 
    
 
    
    var add = function add(xy) {
            return xy[0] + xy[1];
        },
        mul = function mul(xy) {
            return xy[0] * xy[1];
        };
 
    
    var sumEq = function sumEq(p) {
            var addP = add(p);
            return s1.filter(function (q) {
                return add(q) === addP;
            });
        },
        mulEq = function mulEq(p) {
            var mulP = mul(p);
            return s1.filter(function (q) {
                return mul(q) === mulP;
            });
        };
 
    
    var pairEQ = function pairEQ(a, b) {
        return a[0] === b[0] && a[1] === b[1];
    };
 
    
 
    
    var xs = range(1, 100);
 
    
    var s1 = concatMap(function (x) {
            return concatMap(function (y) {
                return 1 < x && x < y && x + y < 100 ? [
                    [x, y]
                ] : [];
            }, xs);
        }, xs),
 
        s2 = s1.filter(function (p) {
            return sumEq(p).every(function (q) {
                return mulEq(q).length > 1;
            });
        }),
 
        s3 = s2.filter(function (p) {
            return intersectBy(pairEQ, mulEq(p), s2).length === 1;
        }),
 
        s4 = s3.filter(function (p) {
            return intersectBy(pairEQ, sumEq(p), s3).length === 1;
        });
 
    return s4;
})();
 [[4, 13]](() => {
    'use strict';
 
    
 
    
    let concatMap = (f, xs) => [].concat.apply([], xs.map(f)),
 
        
        curry = f => a => b => f(a, b),
 
        
        intersectBy = (eq, xs, ys) => (xs.length && ys.length) ?
        xs.filter(x => ys.some(curry(eq)(x))) : [],
 
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        };
 
    
 
    
    let add = xy => xy[0] + xy[1],
        mul = xy => xy[0] * xy[1];
 
    
    let sumEq = p => {
            let addP = add(p);
            return s1.filter(q => add(q) === addP);
        },
        mulEq = p => {
            let mulP = mul(p)
            return s1.filter(q => mul(q) === mulP);
        };
 
    
    let pairEQ = (a, b) => (a[0] === b[0]) && (a[1] === b[1]);
 
 
    
 
    
    let xs = range(1, 100);
 
    
    let s1 = concatMap(x =>
            concatMap(y =>
                ((1 < x) && (x < y) && (x + y) < 100) ? [
                    [x, y]
                ] : [],
                xs), xs),
        s2 = s1.filter(
            p => sumEq(p)
            .every(
                q => mulEq(q)
                .length > 1
            )
        ),
        s3 = s2.filter(
            p => intersectBy(
                pairEQ, mulEq(p), s2
            )
            .length === 1
        );
 
    return s3.filter(
        p => intersectBy(
            pairEQ, sumEq(p), s3
        )
        .length === 1
    );
 
})();[[4, 13]]"
" Number.MAX_SAFE_INTEGER(function (lstFactors, intExponent) {
 
    
    function sumMultiplesBelow(lstIntegers, limit) {
        return range(1, limit - 1).filter(function (x) {
            return isMultiple(lstIntegers, x);
        }).reduce(function (a, n) {
            return a + n;
        }, 0)
    }
 
    
    function isMultiple(lst, n) {
        var i = lng;
        while (i--)
            if (n % (lst[i]) === 0) return true;
        return false;
    }
 
    
    function range(m, n) {
        var a = Array(n - m + 1),
            i = n + 1;
        while (i--) a[i - 1] = i;
        return a;
    }
 
 
    /*      TESTING     */
 
    
    function wikiTable(lstRows, blnHeaderRow, strStyle) {
        return '{| class=strv ' + (
            strStyle ? 'style=""' + strStyle + '""' : ''
        ) + lstRows.map(function (lstRow, iRow) {
            var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
            return '|-' + strDelim + ' ' + lstRow.map(function (v) {
                return typeof v === 'undefined' ? ' ' : v;
            }).join(' ' + strDelim + strDelim + ' ');
        }).join('') + '|}';
    }
 
    var lng = lstFactors.length,
        lstSorted = lstFactors.slice(0).sort();
 
    var lstTable = [['Below', 'Sum']].concat(
        range(1, intExponent).map(function (x) {
            var pwr = Math.pow(10, x);
 
            return ['10^' + x, sumMultiplesBelow(lstSorted, pwr)];
        })
    );
 
    return 'For ' + JSON.stringify(lstFactors) + ':' +
        wikiTable(lstTable, true) + '' +
        JSON.stringify(lstTable);
 
})([3, 5], 8); [[strv,strv],[strv,23],[strv,2318],[strv,233168],
 [strv,23331668],[strv,2333316668],[strv,233333166668],
 [strv,23333331666668],[strv,2333333316666668]]function sm35(n){
	var s=0, inc=[3,2,1,3,1,2,3]
	for (var j=6, i=0; i<n; j+=j==6?-j:1, i+=inc[j]) s+=i
	return s
}function sm35(n){
	return tri(n,3) + tri(n,5) - tri(n,15)
	function tri(n, f) {
		n = Math.floor((n-1) / f)
		return f * n * (n+1) / 2
	}
}for (var i=1, n=10; i<9; n*=10, i+=1) {
	document.write(10, '<sup>', i, '</sup> ',  sm35(n), '<br>')
}(() => {
 
    
    
 
    
    const sumMults = (n, factor) => {
        const n1 = quot(n - 1, factor);
        return quot(factor * n1 * (n1 + 1), 2);
    };
 
    
    const sum35 = n => sumMults(n, 3) + sumMults(n, 5) - sumMults(n, 15);
 
 
    
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const quot = (n, m) => Math.floor(n / m);
 
    
 
    
    return enumFromTo(1, 8)
        .map(n => Math.pow(10, n))
        .reduce((a, x) => (
            a[x.toString()] = sum35(x),
            a
        ), {});
})();{strv:23, strv:2318, strv:233168, strv:23331668,
strv:2333316668, strv:233333166668, strv:23333331666668,
strv:2333333316666668}"
"function sumDigits(n) {
	n += ''
	for (var s=0, i=0, e=n.length; i<e; i+=1) s+=parseInt(n.charAt(i),36)
	return s
}
for (var n of [1, 12345, 0xfe, 'fe', 'f0e', '999ABCXYZ']) document.write(n, ' sum to ', sumDigits(n), '<br>')
 (function () {
    'use strict';
 
    
    function digitsSummed(number) {
 
        
        
        var intMaxBase = 36;
 
        return number
            .toString()
            .split('')
            .reduce(function (a, digit) { 
                return a + parseInt(digit, intMaxBase);
            }, 0);
    }
 
    
 
    return [1, 12345, 0xfe, 'fe', 'f0e', '999ABCXYZ']
        .map(function (x) {
            return x + ' -> ' + digitsSummed(x);
        })
        .join('');
 
})();
 "
"var array = [1, 2, 3, 4, 5],
    sum = 0,
    prod = 1,
    i;
for (i = 0; i < array.length; i += 1) {
    sum += array[i];
    prod *= array[i];
}
alert(sum + ' ' + prod);var array = [1, 2, 3, 4, 5],
    sum = array.reduce(function (a, b) {
        return a + b;
    }, 0),
    prod = array.reduce(function (a, b) {
        return a * b;
    }, 1);
alert(sum + ' ' + prod);(() => {
    'use strict';
 
    
    const sum = xs => xs.reduce((a, x) => a + x, 0);
 
    
    const product = xs => xs.reduce((a, x) => a * x, 1);
 
 
    
    
    const show = x => JSON.stringify(x, null, 2);
 
    return show(
        [sum, product]
        .map(f => f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
    );
})();"
"alert(strv.slice(1));       
alert(strv.slice(0, -1));    
alert(strv.slice(1, -1));   "
"var str = strv;
 
var n = 2;
var m = 3;
 

str.substr(n, m);  
 

str.substr(n);  
str.substring(n);  
 

str.substring(0, str.length - 1);  
 

str.substr(str.indexOf('b'), m);  
 

str.substr(str.indexOf('bc'), m);  {
  strv: strv,
  strv: strv,
  strv: strv,
  strv: strv,
  strv: strv
}"
"(function (strTest) {
 
    
    function strip(s) {
        return s.split('').filter(function (x) {
            var n = x.charCodeAt(0);
 
            return 31 < n && 127 > n;
        }).join('');
    }
 
    return strip(strTest);
 
})(""a00bcdc3"");strv"
"{
    let s = ""  String with spaces    "";
    
    
    console.log(strv + s + strv);
    console.log(strv + s.replace(/^\s+/,'') + strv);
    
    
    console.log(strv + s.replace(/\s+$/,'') + strv);
    console.log(strv + s.trim() + strv);
 }(() => {
    'use strict';
 
    
    let stripStart = s => dropWhile(isSpace, s);
 
    
    let stripEnd = s => dropWhileEnd(isSpace, s);
 
    
    let strip = s => dropAround(isSpace, s);
    
 
 
 
    
 
    
    let dropAround = (p, s) => dropWhile(p, dropWhileEnd(p, s));
 
    
    let dropWhile = (p, xs) => {
        for (var i = 0, lng = xs.length;
            (i < lng) && p(xs[i]); i++) {}
        return xs.slice(i);
    }
 
    
    let dropWhileEnd = (p, s) => {
        for (var i = s.length; i-- && p(s[i]);) {}
        return s.slice(0, i + 1);
    }
 
    
    let isSpace = c => /\s/.test(c);
 
    
    let show = x => JSON.stringify(x, null, 2);
 
 
    
 
    let strText = ""        Much Ado About Nothing     "";
 
    return show([stripStart, stripEnd, strip]
        .map(f => '-->' + f(strText) + '<--'));
 
})();
 "
"function stripComments(s) {
  var re1 = /^\s+|\s+$/g;  
  var re2 = /\s*[#;].+$/g; 
  return s.replace(re1,'').replace(re2,'');
}
 
 
var s1 = 'apples, pears # and bananas';
var s2 = 'apples, pears ; and bananas';
 
alert(stripComments(s1) + '' + stripComments(s2));
 var stripComments = (function () {
  var re1 = /^\s+|\s+$/g;
  var re2 = /\s*[#;].+$/g;
  return function (s) {
    return s.replace(re1,'').replace(re2,'');
  };
}());
 "
"function stripchars(string, chars) {
  return string.replace(RegExp('['+chars+']','g'), '');
}(() => {
    'use strict';
 
    
    const stripChars = (strNeedles, strHayStack) =>
        strHayStack.replace(RegExp(`[${strNeedles}]`, 'g'), '');
 
    
 
    
    const curry = f => a => b => f(a, b);
 
    
 
    const noAEI = curry(stripChars)('aeiAEI');
 
    
    return noAEI('She was a soul stripper. She took my heart!');
 
    
})();(() => {
    'use strict';
 
    
    const stripChars = (strNeedles, strHayStack) =>
        strHayStack.split('')
        .filter(x => !elem(x, strNeedles))
        .join('');
 
    
 
    
    const elem = (x, xs) => xs.indexOf(x) !== -1;
 
    
    const curry = f => a => b => f(a, b);
 
    
 
    const noAEI = curry(stripChars)('aeiAEI');
 
 
    
    return noAEI('She was a soul stripper. She took my heart!');
 
    
})();"
"
var s=strv
s = strv + s
print(s);"
"//-------------------------------------------[ Dancing Links and Algorithm X ]--
/** * The doubly-doubly circularly linked data object. * Data object X */
class DoX {
  /**   * @param {string} V   * @param {!DoX=} H   */
  constructor(V, H) {
    this.V = V;
    this.L = this;
    this.R = this;
    this.U = this;
    this.D = this;
    this.S = 1;
    this.H = H || this;
    H && (H.S += 1);
  }
}
 
/** * Helper function to help build a horizontal doubly linked list. * @param {!DoX} e An existing node in the list. * @param {!DoX} n A new node to add to the right of the existing node. * @return {!DoX} */
const addRight = (e, n) => {
  n.R = e.R;
  n.L = e;
  e.R.L = n;
  return e.R = n;
};
 
/** * Helper function to help build a vertical doubly linked list. * @param {!DoX} e An existing node in the list. * @param {!DoX} n A new node to add below the existing node. */
const addBelow = (e, n) => {
  n.D = e.D;
  n.U = e;
  e.D.U = n;
  return e.D = n;
};
 
/** * Verbatim copy of DK's search algorithm. The meat of the DLX algorithm. * @param {!DoX} h The root node. * @param {!Array<!DoX>} s The solution array. */
const search = function(h, s) {
  if (h.R == h) {
    printSol(s);
  } else {
    let c = chooseColumn(h);
    cover(c);
    for (let r = c.D; r != c; r = r.D) {
      s.push(r);
      for (let j = r.R; r !=j; j = j.R) {
        cover(j.H);
      }
      search(h, s);
      r = s.pop();
      for (let j = r.R; j != r; j = j.R) {
        uncover(j.H);
      }
    }
    uncover(c);
  }
};
 
/** * Verbatim copy of DK's algorithm for choosing the next column object. * @param {!DoX} h * @return {!DoX} */
const chooseColumn = h => {
  let s = Number.POSITIVE_INFINITY;
  let c = h;
  for(let j = h.R; j != h; j = j.R) {
    if (j.S < s) {
      c = j;
      s = j.S;
    }
  }
  return c;
};
 
 
/** * Verbatim copy of DK's cover algorithm * @param {!DoX} c */
const cover = c => {
  c.L.R = c.R;
  c.R.L = c.L;
  for (let i = c.D; i != c; i = i.D) {
    for (let j = i.R; j != i; j = j.R) {
      j.U.D = j.D;
      j.D.U = j.U;
      j.H.S = j.H.S - 1;
    }
  }
};
 
/** * Verbatim copy of DK's cover algorithm * @param {!DoX} c */
const uncover = c => {
  for (let i = c.U; i != c; i = i.U) {
    for (let j = i.L; i != j; j = j.L) {
      j.H.S = j.H.S + 1;
      j.U.D = j;
      j.D.U = j;
    }
  }
  c.L.R = c;
  c.R.L = c;
};
 
//-----------------------------------------------------------[ Print Helpers ]--
/** * Given the standard string format of a grid, print a formatted view of it. * @param {!string|!Array} a */
const printGrid = function(a) {
 
  const getChar = c => {
    let r = Number(c);
    if (isNaN(r)) { return c }
 
    let o = 48;
    if (r > 9 && r < 36) { o = 55 }
    if (r >= 36) { o = 61 }
    return String.fromCharCode(r + o)
  };
 
  a = 'string' == typeof a ? a.split('') : a;
 
  let U = Math.sqrt(a.length);
  let N = Math.sqrt(U);
  let line = new Array(N).fill('+').reduce((p, c) => {
    p.push(... Array.from(new Array(1 + N*2).fill('-')));
    p.push(c);
    return p;
  }, ['+']).join('') + '';
 
  a = a.reduce(function(p, c, i) {
      let d = i && !(i % U), G = i && !(i % N);
      i = !(i % (U * N));
      d && !i && (p += '|| ');
      d && i && (p += '|');
      i && (p = '' + p + line + '| ');
      return '' + p + (G && !d ? '| ' : '') + getChar(c) + ' ';
    }, '') + '|' + line;
  console.log(a);
 
};
 
/** * Given a search solution, print the resultant grid. * @param {!Array<!DoX>} a An array of data objects */
const printSol = a => {
  printGrid(a.reduce((p, c) => {
    let [i, v] = c.V.split(':');
    p[i * 1] = v;
    return p;
  }, new Array(a.length).fill('.')));
};
 
//----------------------------------------------[ Grid to Exact cover Matrix ]--
/** * Helper to get some meta about the grid. * @param {!string} s The standard string representation of a grid. * @return {!Array} */
const gridMeta = s => {
  const g = s.split('');
  const cellCount = g.length;
  const tokenCount = Math.sqrt(cellCount);
  const N = Math.sqrt(tokenCount);
  const g2D = g.map(e => isNaN(e * 1) ?
    new Array(tokenCount).fill(1).map((_, i) => i + 1) :
    [e * 1]);
  return [cellCount, N, tokenCount, g2D];
};
 
/** * Given a cell grid index, return the row, column and box indexes. * @param {!number} n The n-value of the grid. 3 for a 9x9 sudoku. * @return {!function(!number): !Array<!number>} */
const indexesN = n => i => {
    let c = Math.floor(i / (n * n));
    i %= n * n;
    return [c, i, Math.floor(c / n) * n + Math.floor(i / n)];
};
 
/** * Given a puzzle string, reduce it to an exact-cover matrix and use * Donald Knuth's DLX algorithm to solve it. * @param puzString */
const reduceGrid = puzString => {
 
  printGrid(puzString);
  const [
    numCells,   
    N,          
    U,          
    g2D         
                
                
  ] = gridMeta(puzString);
 
  const getIndex = indexesN(N);
 
  /**   * The DLX Header row.   * Its length is 4 times the grid's size. This is to be able to encode   * each of the 4 Sudoku constrains, onto each of the cells of the grid.   * The array is initialised with unlinked DoX nodes, but in the next step   * those nodes are all linked.   * @type {!Array.<!DoX>}   */
  const headRow = new Array(4 * numCells)
    .fill('')
    .map((_, i) => new DoX(`H${i}`));
 
  /**   * The header row root object. This is circularly linked to be to the left   * of the first header object in the header row array.   * It is used as the entry point into the DLX algorithm.   * @type {!DoX}   */
  let H = new DoX('ROOT');
  headRow.reduce((p, c) => addRight(p, c), H);
 
  /**   * Transposed the sudoku puzzle into a exact cover matrix, so it can be passed   * to the DLX algorithm to solve.   */
  for (let i = 0; i < numCells; i++) {
    const [ri, ci, bi] = getIndex(i);
    g2D[i].forEach(num => {
      let id = `${i}:${num}`;
      let candIdx = num - 1;
 
      
      const A = headRow[i];
      const B = headRow[numCells + candIdx + (ri * U)];
      const C = headRow[(numCells * 2) + candIdx + (ci * U)];
      const D = headRow[(numCells * 3) + candIdx + (bi * U)];
 
      
      let rcc = addBelow(A.U, new DoX(id, A));
 
      
      let rnc = addBelow(B.U, addRight(rcc, new DoX(id, B)));
 
      
      let cnc = addBelow(C.U, addRight(rnc, new DoX(id, C)));
 
      
      addBelow(D.U, addRight(cnc, new DoX(id, D)));
    });
  }
  search(H, []);
};
 [
  '819..5.....2...75..371.4.6.4..59.1..7..3.8..2..3.62..7.5.7.921..64...9.....2..438',
  '53..247....2...8..1..7.39.2..8.72.49.2.98..7.79.....8.....3.5.696..1.3...5.69..1.',
  '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..',
  '394..267....3..4..5..69..2..45...9..6.......7..7...58..1..67..8..9..8....264..735',
  '97.3...6..6.75.........8.5.......67.....3.....539..2..7...25.....2.1...8.4...73..',
  '4......6.5...8.9..3....1....2.7....1.9.....4.8....3.5....2....7..6.5...8.1......6',
  '85...24..72......9..4.........1.7..23.5...9...4...........8..7..17..........36.4.',
  '..1..5.7.92.6.......8...6...9..2.4.1.........3.4.8..9...7...3.......7.69.1.8..7..',
  '.9...4..7.....79..8........4.58.....3.......2.....97.6........4..35.....2..6...8.',
  '12.3....435....1....4........54..2..6...7.........8.9...31..5.......9.7.....6...8',
  '9..2..5...4..6..3...3.....6...9..2......5..8...7..4..37.....1...5..2..4...1..6..9',
  '1....7.9..3..2...8..96..5....53..9...1..8...26....4...3......1..4......7..7...3..',
  '12.4..3..3...1..5...6...1..7...9.....4.6.3.....3..2...5...8.7....7.....5.......98',
  '..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9',
  '.......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7.....',
  '....839..1......3...4....7..42.3....6.......4....7..1..2........8...92.....25...6',
  '..3......4...8..36..8...1...4..6..73...9..........2..5..4.7..686........7..6..5..'
].forEach(reduceGrid);
 


let n = 2;
let s = new Array(Math.pow(n, 4)).fill('.').join('');
reduceGrid(s);
 "
"var original = strv;
var little = strv;
var replaced = original.replace(strv, little); //does not change the original string
var X = strv;
var replaced = `Mary had a ${X} lamb`;"
"var stringA = strv
  , stringB = strv
  , q1, q2, q2multi, m
  , q2matches = []
 

q1 = stringA.substring(0, stringB.length) == stringB
 

q2  = stringA.indexOf(stringB)
 

q2multi = new RegExp(stringB,'g')
 
while(m = q2multi.exec(stringA)){
	q2matches.push(m.index)
}
 

q3 = stringA.substr(-stringB.length) == stringB
 
console.log(strv+stringA+strv+stringB+strv + ( q1 ? strv : strv))
console.log(strv+stringB+strv+stringA+strv + (~q2 ? strv+q2+strv : strv))
if (~q2 && q2matches.length > 1){
	console.log(strv+q2matches.length+strv+stringA+strv+(q2matches.length > 1 ? strv : strv)+strv+q2matches.join(', ')+strv)
}
console.log(strv+stringA+strv+stringB+strv   + ( q3 ? strv : strv))"
"var s = strv;
var byteCount = s.length * 2; //26var str1 = strv;
var len1 = str1.length; //13
 
var str2 = ""D834DD2A""; //U+1D12A represented by a UTF-16 surrogate pair
var len2 = str2.length; //2"
"var s = strv
print(s + strv)"
"var s1 = strv;
s1 += strv;
print(s1);
 
var s2 = strv;


print(s2.concat(strv));"
"<script>
var alphabet=new Array(strv,strv,strv) 
var prefixes=new Array(strv,alphabet[0].indexOf(strv),alphabet[0].lastIndexOf(strv)) 
 
function straddle(message){
  var out=strv
  message=message.toUpperCase()
  message=message.replace(/([0-9])/g,strv) 
  for(var i=0;i<message.length;i++){
    var chr=message[i]
	if(chr==strv)continue
	for(var j=0;j<3;j++){
	  var k=alphabet[j].indexOf(chr)
	  if(k<0)continue
	  out+=prefixes[j].toString()+k
	}
	if(chr==strv)out+=message[++i]
  }
  return out
}
 
function unstraddle(message){
  var out=strv
  var n,o
  for(var i=0;i<message.length;i++){
	n=message[i]*1
    switch(n){
	  case prefixes[1]: o=alphabet[1][message[++i]];break
	  case prefixes[2]: o=alphabet[2][message[++i]];break
	  default: o=alphabet[0][n]
	}
	o==strv?out+=message[++i]:out+=o
  }
  return out
}
 
str=strv
document.writeln(str)
document.writeln(straddle(str))
document.writeln(unstraddle(straddle(str)))
</script>"
"alert( strv.toUpperCase() );
alert( strv.toLowerCase() );var string = strv;
var uppercase = string.toUpperCase();
var lowercase = string.toLowerCase();"
"try {
  throw new Error;
} catch(e) {
  alert(e.stack);
}function foo () {
  var stack = strv;
  for (var f = arguments.callee 
       ; f; f = f.caller) {
    stack += """" + f.name;
  }
  alert(stack);
}
foo();"
"(() => {
    'use strict';
 
    
 
    
    const group = xs => groupBy((a, b) => a === b, xs);
 
    
    const groupBy = (f, xs) => {
        const dct = xs.slice(1)
            .reduce((a, x) => {
                const
                    h = a.active.length > 0 ? a.active[0] : undefined,
                    blnGroup = h !== undefined && f(h, x);
 
                return {
                    active: blnGroup ? a.active.concat(x) : [x],
                    sofar: blnGroup ? a.sofar : a.sofar.concat([a.active])
                };
            }, {
                active: xs.length > 0 ? [xs[0]] : [],
                sofar: []
            });
        return dct.sofar.concat(dct.active.length > 0 ? [dct.active] : []);
    };
 
    
    const intercalate = (s, xs) => xs.join(s);
 
    
    return intercalate(strv, group(""gHHH5YY++///"".split(''))
        .map(x => x.join('')));
 
    
})();"
"var stack = [];
stack.push(1)
stack.push(2,3);
print(stack.pop());   
print(stack.length);   function Stack() {
    this.data = new Array();
 
    this.push  = function(element) {this.data.push(element)}
    this.pop   = function() {return this.data.pop()}
    this.empty = function() {return this.data.length == 0}
    this.peek  = function() {return this.data[this.data.length - 1]}
} 
function makeStack() {
  var stack = [];
 
  var popStack = function () {
    return stack.pop();
  };
  var pushStack = function () {
    return stack.push.apply(stack, arguments);
  };
  var isEmpty = function () {
    return stack.length === 0;
  };
  var peekStack = function () {
    return stack[stack.length-1];
  };
 
  return {
    pop: popStack,
    push: pushStack,
    isEmpty: isEmpty,
    peek: peekStack,
    top: peekStack
  };
}
 "
"var voice = new ActiveXObject(strv);
voice.speak(strv);"
"var obj = {
  foo: 1,
  bar: function () { return this.foo; }
};
obj.bar(); function concat() {
  var s = strv;
  for (var i = 0; i < arguments.length; i++) {
    s += arguments[i];
  }
  return s;
}
concat(strv, strv, strv); "
"function Person(name) {
 
    var candidateIndex = 0;
 
    this.name = name;
    this.fiance = null;
    this.candidates = [];
 
    this.rank = function(p) {
        for (i = 0; i < this.candidates.length; i++)
            if (this.candidates[i] === p) return i;
        return this.candidates.length + 1;
    }
 
    this.prefers = function(p) {
        return this.rank(p) < this.rank(this.fiance);
    }
 
    this.nextCandidate = function() {
        if (candidateIndex >= this.candidates.length) return null;
        return this.candidates[candidateIndex++];
    }
 
    this.engageTo = function(p) {
        if (p.fiance) p.fiance.fiance = null;
        p.fiance = this;
        if (this.fiance) this.fiance.fiance = null;
        this.fiance = p;
    }
 
    this.swapWith = function(p) {
        console.log(strv, this.name, p.name);
        var thisFiance = this.fiance;
        var pFiance = p.fiance;
        this.engageTo(pFiance);
        p.engageTo(thisFiance);
    }
}
 
function isStable(guys, gals) {
    for (var i = 0; i < guys.length; i++)
        for (var j = 0; j < gals.length; j++)
            if (guys[i].prefers(gals[j]) && gals[j].prefers(guys[i]))
                return false;
    return true;
}
 
function engageEveryone(guys) {
    var done;
    do {
        done = true;
        for (var i = 0; i < guys.length; i++) {
            var guy = guys[i];
            if (!guy.fiance) {
                done = false;
                var gal = guy.nextCandidate();
                if (!gal.fiance || gal.prefers(guy))
                    guy.engageTo(gal);
            }
        }
    } while (!done);
}
 
function doMarriage() {
 
    var abe  = new Person(strv);
    var bob  = new Person(strv);
    var col  = new Person(strv);
    var dan  = new Person(strv);
    var ed   = new Person(strv);
    var fred = new Person(strv);
    var gav  = new Person(strv);
    var hal  = new Person(strv);
    var ian  = new Person(strv);
    var jon  = new Person(strv);
    var abi  = new Person(strv);
    var bea  = new Person(strv);
    var cath = new Person(strv);
    var dee  = new Person(strv);
    var eve  = new Person(strv);
    var fay  = new Person(strv);
    var gay  = new Person(strv);
    var hope = new Person(strv);
    var ivy  = new Person(strv);
    var jan  = new Person(strv);
 
    abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay];
    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay];
    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan];
    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi];
    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay];
    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay];
    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay];
    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee];
    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve];
    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope];
    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal];
    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal];
    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon];
    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed];
    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob];
    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal];
    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian];
    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred];
    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan];
    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan];
 
    var guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon];
    var gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan];
 
    engageEveryone(guys);
 
    for (var i = 0; i < guys.length; i++) {
        console.log(strv, guys[i].name, guys[i].fiance.name);
    }
    console.log(strv, isStable(guys, gals) ? strv : strv);
    jon.swapWith(fred);
    console.log(strv, isStable(guys, gals) ? strv : strv);
}
 
doMarriage();
 "
"spiralArray = function (edge) {
    var arr = Array(edge),
        x = 0, y = edge,
        total = edge * edge--,
        dx = 1, dy = 0,
        i = 0, j = 0;
    while (y) arr[--y] = [];
    while (i < total) {
        arr[y][x] = i++;
        x += dx; y += dy;
        if (++j == edge) {
            if (dy < 0) {x++; y++; edge -= 2}
            j = dx; dx = -dy; dy = j; j = 0;
       }
    }
    return arr;
}
 

arr = spiralArray(edge = 5);
for (y= 0; y < edge; y++) console.log(arr[y].join(strv));
 (function (n) {
 
  
  function spiral(lngRows, lngCols, nStart) {
    return lngRows ? [range(nStart, (nStart + lngCols) - 1)].concat(
      transpose(
        spiral(lngCols, lngRows - 1, nStart + lngCols)
      ).map(reverse)
    ) : [
      []
    ];
  }
 
  
  function transpose(lst) {
    return lst.length > 1 ? lst[0].map(function (_, col) {
      return lst.map(function (row) {
        return row[col];
      });
    }) : lst;
  }
 
  
  function reverse(lst) {
    return lst.length > 1 ? lst.reduceRight(function (acc, x) {
      return acc.concat(x);
    }, []) : lst;
  }
 
  
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
  
 
  var lstSpiral = spiral(n, n, 0);
 
 
  
  function wikiTable(lstRows, blnHeaderRow, strStyle) {
    return '{| class=strv ' + (
      strStyle ? 'style=""' + strStyle + '""' : ''
    ) + lstRows.map(function (lstRow, iRow) {
      var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
      return '|-' + strDelim + ' ' + lstRow.map(function (v) {
        return typeof v === 'undefined' ? ' ' : v;
      }).join(' ' + strDelim + strDelim + ' ');
    }).join('') + '|}';
  }
 
  return [
    wikiTable(
 
      lstSpiral,
 
      false,
      'text-align:center;width:12em;height:12em;table-layout:fixed;'
    ),
 
    JSON.stringify(lstSpiral)
  ].join('');
 
})(5);[[0,1,2,3,4],[15,16,17,18,5],[14,23,24,19,6],[13,22,21,20,7],[12,11,10,9,8]](n => {
 
    
    
    function spiral(lngRows, lngCols, nStart) {
        return lngRows ? [range(nStart, (nStart + lngCols) - 1)]
            .concat(
                transpose(
                    spiral(lngCols, lngRows - 1, nStart + lngCols)
                )
                .map(reverse)
            ) : [[]];
    }
 
    
    function transpose(xs) {
        return xs[0]
            .map((_, iCol) => xs
                .map((row) => row[iCol]));
    }
 
    
    function reverse(xs) {
        return xs.slice(0)
            .reverse();
    }
 
    
    
    function range(m, n, step) {
        let d = (step || 1) * (n >= m ? 1 : -1);
 
        return Array.from({
            length: Math.floor((n - m) / d) + 1
        }, (_, i) => m + (i * d));
    }
 
 
 
    
 
    
    function replicate(n, a) {
        var v = [a],
            o = '';
 
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o + v;
            n >>= 1;
            v = v + v;
        }
        return o + v;
    }
 
 
    return spiral(n, n, 0)
        .map(
            xs => xs.map(x => {
                let s = `${x}`;
                return replicate(4 - s.length, ' ') + s;
            })
            .join('')
        )
        .join('');
 
})(5);"
"(() => {
    'use strict';
 
    
    let sparkLine = xs => {
            let min = minimumBy(numericOrdering, xs),
                max = maximumBy(numericOrdering, xs),
                range = max - min;
 
            return xs.map(x => ((x - min) * 7) / range)
                .map(
                    n => (n >= 0 && n < 8) ? '▁▂▃▄▅▆▇█'
                    .split('')[Math.round(n)] : undefined
                ).join('');
        },
 
        
        maximumBy = (f, xs) =>
            xs.reduce((a, x) =>
                a === undefined ? x : (
                    f(x, a) > 0 ? x : a
                ),
                undefined
            ),
 
 
        
        minimumBy = (f, xs) =>
            xs.reduce((a, x) =>
                a === undefined ? x : (
                    f(x, a) < 0 ? x : a
                ),
                undefined
            ),
 
        numericOrdering = (a, b) => a < b ? -1 : (a > b ? 1 : 0);
 
    
 
    return [strv,
        strv,
        strv,
        strv
    ].map(
        s => s.split(/[,\s]+/)
        .map(x => parseFloat(x, 10))
    ).map(sparkLine);
 
})();"
"Array.prototype.timeoutSort = function (f) {
	this.forEach(function (n) {
		setTimeout(function () { f(n) }, 5 * n)
	});
}
 [1, 9, 8, 7, 6, 5, 3, 4, 5, 2, 0].timeoutSort(function(n) { document.write(n + 'br'); })"
"function stoogeSort (array, i, j) {
    if (j === undefined) {
        j = array.length - 1;
    }
 
    if (i === undefined) {
        i = 0;
    }
 
    if (array[j] < array[i]) {
        var aux = array[i];
        array[i] = array[j];
        array[j] = aux;
    }
 
    if (j - i > 1) {
        var t = Math.floor((j - i + 1) / 3);
        stoogeSort(array, i, j-t);
        stoogeSort(array, i+t, j);
        stoogeSort(array, i, j-t);
    }
};arr = [9,1,3,10,13,4,2];
stoogeSort(arr);
console.log(arr);"
"var soundex = function (s) {
     var a = s.toLowerCase().split('')
         f = a.shift(),
         r = '',
         codes = {
             a: '', e: '', i: '', o: '', u: '',
             b: 1, f: 1, p: 1, v: 1,
             c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2,
             d: 3, t: 3,
             l: 4,
             m: 5, n: 5,
             r: 6
         };
 
     r = f +
         a
         .map(function (v, i, a) { return codes[v] })
         .filter(function (v, i, a) { return ((i === 0) ? v !== codes[f] : v !== a[i - 1]); })
         .join('');
 
     return (r + '000').slice(0, 4).toUpperCase();
};
 
var tests = {
  strv:     strv,
  strv:     strv,
  strv:    strv,
  strv:    strv,
  strv:       strv,
  strv:       strv,
  strv:     strv,
  strv:       strv,
  strv:       strv,
  strv: strv,
  strv:      strv,
  strv:       strv,
  strv:   strv,
  strv:        strv,
  strv:        strv,
  strv:   strv,
  strv:     strv,
  strv:    strv,
  strv:   strv,
  strv:     strv,
  strv:      strv
  };
 
for (var i in tests)
  if (tests.hasOwnProperty(i)) {
    console.log(
      i +
      '    ' +
      tests[i] +
      '' +
      soundex(i) +
      '' +
      (soundex(i) === tests[i])
    );
}
 




















 
function soundex(t) {
  t = t.toUpperCase().replace(/[^A-Z]/g, '');
  return (t[0] || '0') + t.replace(/[HW]/g, '')
    .replace(/[BFPV]/g, '1')
    .replace(/[CGJKQSXZ]/g, '2')
    .replace(/[DT]/g, '3')
    .replace(/[L]/g, '4')
    .replace(/[MN]/g, '5')
    .replace(/[R]/g, '6')
    .replace(/(.)\1+/g, '$1')
    .substr(1)
    .replace(/[AEOIUHWY]/g, '')
    .concat('000')
    .substr(0, 3);
}
 

[ [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv], [strv, strv],
 [strv, strv], [strv, strv]
].forEach(function(v) {
  var a = v[0], t = v[1], d = soundex(a);
   if (d !== t) {
    console.log('soundex(""' + a + '"") was ' + d + ' should be ' + t);
  }
}); (() => {
    'use strict';
 
    
 
    
    const soundex = (blnNara, name) => {
 
        
        const code = c => ['AEIOU', 'BFPV', 'CGJKQSXZ', 'DT', 'L', 'MN', 'R', 'HW']
            .reduce((a, x, i) =>
                a ? a : (x.indexOf(c) !== -1 ? i.toString() : a), '');
 
        
        const isAlpha = c => {
            const d = c.charCodeAt(0);
            return d > 64 && d < 91;
        };
 
        const s = name.toUpperCase()
            .split('')
            .filter(isAlpha);
 
        return (s[0] || '0') +
            s.map(code)
            .join('')
            .replace(/7/g, blnNara ? '' : '7')
            .replace(/(.)\1+/g, '$1')
            .substr(1)
            .replace(/[07]/g, '')
            .concat('000')
            .substr(0, 3);
    };
 
    
    const curry = f => a => b => f(a, b),
        [simpleSoundex, naraSoundex] = [false, true]
        .map(bln => curry(soundex)(bln));
 
    
    return [
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv]
    ].reduce((a, [name, naraCode]) => {
        const naraTest = naraSoundex(name),
            simpleTest = simpleSoundex(name);
 
        const logNara = naraTest !== naraCode ? (
                `${name} was ${naraTest} should be ${naraCode}`
            ) : '',
            logDelta = (naraTest !== simpleTest ? (
                `${name} -> NARA: ${naraTest} vs Simple: ${simpleTest}`
            ) : '');
 
        return logNara.length || logDelta.length ? (
            a + [logNara, logDelta].join('')
        ) : a;
    }, '');
})();"
"function selectionSort(nums) {
  var len = nums.length;
  for(var i = 0; i < len; i++) {
    var minAt = i;
    for(var j = i + 1; j < len; j++) {
      if(nums[j] < nums[minAt])
        minAt = j;
    }
 
    if(minAt != i) {
      var temp = nums[i];
      nums[i] = nums[minAt];
      nums[minAt] = temp;
    }
  }
  return nums;
}"
"function shellSort (a) {
    for (var h = a.length; h > 0; h = parseInt(h / 2)) {
        for (var i = h; i < a.length; i++) {
            var k = a[i];
            for (var j = i; j >= h && k < a[j - h]; j -= h)
                a[j] = a[j - h];
            a[j] = k;
        }
    }
    return a;
}
 
var a = [];
var n = location.href.match(/\?(\d+)|$/)[1] || 10;
for (var i = 0; i < n; i++)
    a.push(parseInt(Math.random() * 100));
shellSort(a);
document.write(a.join(strv));"
"Array.prototype.pancake_sort = function () {
    for (var i = this.length - 1; i >= 1; i--) {
        
        var max_idx = 0;
        var max = this[0];
        for (var j = 1; j <= i; j++) {
            if (this[j] > max) {
                max = this[j];
                max_idx = j;
            }
        }
 
        if (max_idx == i) 
            continue; 
 
        var new_slice;
 
        
        if (max_idx > 0) {
            new_slice = this.slice(0, max_idx+1).reverse();
            for (var j = 0; j <= max_idx; j++) 
                this[j] = new_slice[j];
        }
 
        
        new_slice = this.slice(0, i+1).reverse();
        for (var j = 0; j <= i; j++) 
            this[j] = new_slice[j];
    }
    return this;
}
ary = [7,6,5,9,8,4,3,1,2,0]
sorted = ary.concat().pancake_sort();"
" 
function insertionSort (a) {
    for (var i = 0; i < a.length; i++) {
        var k = a[i];
        for (var j = i; j > 0 && k < a[j - 1]; j--)
            a[j] = a[j - 1];
        a[j] = k;
    }
    return a;
}
 
var a = [4, 65, 2, -31, 0, 99, 83, 782, 1];
insertionSort(a);
document.write(a.join(strv));"
"function sort(array, less) {
 
  function swap(i, j) {
    var t = array[i];
    array[i] = array[j];
    array[j] = t;
  }
 
  function quicksort(left, right) {
 
    if (left < right) {
      var pivot = array[left + Math.floor((right - right) / 2)],
          left_new = left,
          right_new = right;
 
      do {
        while (less(array[left_new], pivot)) {
          left_new += 1;
        }
        while (less(pivot, array[right_new])) {
          right_new -= 1;
        }
        if (left_new <= right_new) {
          swap(left_new, right_new);
          left_new += 1;
          right_new -= 1;
        }
      } while (left_new <= right_new);
 
      quicksort(left, right_new);
      quicksort(left_new, right);
 
    }
  }
 
  quicksort(0, array.length - 1);
 
  return array;
}var test_array = [10, 3, 11, 15, 19, 1];
var sorted_array = sort(test_array, function(a,b) { return a<b; });[ 1, 3, 10, 11, 15, 19 ](function () {
    'use strict';
 
    
    function quickSort(xs) {
 
        if (xs.length) {
            var h = xs[0],
                t = xs.slice(1),
 
                lessMore = partition(function (x) {
                    return x <= h;
                }, t),
                less = lessMore[0],
                more = lessMore[1];
 
            return [].concat.apply(
                [], [quickSort(less), h, quickSort(more)]
            );
 
        } else return [];
    }
 
 
    
    
    function partition(p, xs) {
        return xs.reduce(function (a, x) {
            return (
                a[p(x) ? 0 : 1].push(x),
                a
            );
        }, [[], []]);
    }
 
    return quickSort([11.8, 14.1, 21.3, 8.5, 16.7, 5.7])
 
})();Array.prototype.quick_sort = function () {
    if (this.length < 2) { return this; }
 
    var pivot = this[Math.round(this.length / 2)];
 
    return this.filter(x => x <  pivot)
               .quick_sort()
               .concat(this.filter(x => x == pivot))
               .concat(this.filter(x => x >  pivot).quick_sort());
};(() => {
    'use strict';
 
    
 
    
    const quickSort = xs =>
        xs.length > 1 ? (() => {
            const
                h = xs[0],
                [less, more] = partition(x => x <= h, xs.slice(1));
            return [].concat.apply(
                [], [quickSort(less), h, quickSort(more)]
            );
        })() : xs;
 
 
    
 
    
    
    const partition = (p, xs) =>
        xs.reduce((a, x) =>
            p(x) ? [a[0].concat(x), a[1]] : [a[0], a[1].concat(x)], [
                [],
                []
            ]);
 
    
    return quickSort([11.8, 14.1, 21.3, 8.5, 16.7, 5.7]);
})();"
"function merge(left, right, arr) {
  var a = 0;
 
  while (left.length && right.length) {
    arr[a++] = (right[0] < left[0]) ? right.shift() : left.shift();
  }
  while (left.length) {
    arr[a++] = left.shift();
  }
  while (right.length) {
    arr[a++] = right.shift();
  }
}
 
function mergeSort(arr) {
  var len = arr.length;
 
  if (len === 1) { return; }
 
  var mid = Math.floor(len / 2),
      left = arr.slice(0, mid),
      right = arr.slice(mid);
 
  mergeSort(left);
  mergeSort(right);
  merge(left, right, arr);
}
 
var arr = [1, 5, 2, 7, 3, 9, 4, 6, 8];
mergeSort(arr); "
"var countSort = function(arr, min, max) {
    var i, z = 0, count = [];
 
    for (i = min; i <= max; i++) {
        count[i] = 0;
    }
 
    for (i=0; i < arr.length; i++) {
        count[arr[i]]++;
    }
 
    for (i = min; i <= max; i++) {
        while (count[i]-- > 0) {
            arr[z++] = i;
        }
    }
 
}
 
var i, ages = [];
 
for (i = 0; i < 100; i++) {
    ages.push(Math.floor(Math.random() * (141)));
}
 
countSort(ages, 0, 140);
 
for (i = 0; i < 100; i++) {
    document.write(ages[i] + strv);
}"
" 
function swap(data, i, j) {
    var tmp = data[i];
    data[i] = data[j];
    data[j] = tmp;
}
 
 function heap_sort(arr) {
    put_array_in_heap_order(arr);
    end = arr.length - 1;
    while(end > 0) {
        swap(arr, 0, end);
        sift_element_down_heap(arr, 0, end);
        end -= 1
    }
}
 
function put_array_in_heap_order(arr) {
    var i;
    i = arr.length / 2 - 1;
    i = Math.floor(i);
    while (i >= 0) {
        sift_element_down_heap(arr, i, arr.length);
        i -= 1;
    }
}
 
function sift_element_down_heap(heap, i, max) {
    var i_big, c1, c2;
    while(i < max) {
        i_big = i;
        c1 = 2*i + 1;
        c2 = c1 + 1;
        if (c1 < max && heap[c1] > heap[i_big])
            i_big = c1;
        if (c2 < max && heap[c2] > heap[i_big])
            i_big = c2;
        if (i_big == i) return;
        swap(heap,i, i_big);
        i = i_big;
    }
}
 
arr = [12, 11, 15, 10, 9, 1, 2, 3, 13, 14, 4, 5, 6, 7, 8,];
heap_sort(arr);
alert(arr);"
" 
  
  function is_array_sorted(arr) {
      var sorted = true;
      for (var i = 0; i < arr.length - 1; i++) {
          if (arr[i] > arr[i + 1]) {
              sorted = false;
              break;
          }
      }
      return sorted;
  }
 
  
  var arr = [4, 9, 0, 3, 1, 5];
 
  var iteration_count = 0;
  var gap = arr.length - 2;
  var decrease_factor = 1.25;
 
  
  while (!is_array_sorted(arr)) {
      
      if (iteration_count > 0)
      
          gap = (gap == 1) ? gap : Math.floor(gap / decrease_factor);
 
      
      var front = 0;
      var back = gap;
      while (back <= arr.length - 1) {
          
          if (arr[front] > arr[back]) {
              var temp = arr[front];
              arr[front] = arr[back];
              arr[back] = temp;
          }
 
          
          front += 1;
          back += 1;
      }
      iteration_count += 1;
  }
 
  
  console.log(arr);
}"
" 
  
strv;
 
let arr = [4, 9, 0, 3, 1, 5];
let isSorted = true;
while (isSorted){
    for (let i = 0; i< arr.length - 1;i++){
            if (arr[i] > arr[i + 1])
             {
                let temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i+1] = temp;
                isSorted = true;
             }
    }
 
    if (!isSorted)
        break;
 
    isSorted = false;
 
    for (let j = arr.length - 1; j > 0; j--){
            if (arr[j-1] > arr[j])
             {
                let temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
                isSorted = true;
             }
    }
}
console.log(arr);
 
}"
"function gnomeSort(a) {
    function moveBack(i) {
        for( ; i > 0 && a[i-1] > a[i]; i--) {
            var t = a[i];
            a[i] = a[i-1];
            a[i-1] = t;
        }
    }
    for (var i = 1; i < a.length; i++) {
        if (a[i-1] > a[i]) moveBack(i);
    }
    return a;
}"
"shuffle = function(v) {
    for(var j, x, i = v.length; i; j = Math.floor(Math.random() * i), x = v[--i], v[i] = v[j], v[j] = x);
    return v;
};
 
isSorted = function(v){
    for(var i=1; i<v.length; i++) {
        if (v[i-1] > v[i]) { return false; }
    }
    return true;
}
 
bogosort = function(v){
    var sorted = false;
    while(sorted == false){
        v = shuffle(v);
        sorted = isSorted(v);
    }
    return v;
}"
"ary = [[strv, strv], [strv, strv], [strv, strv], [strv, strv]]
print(ary);
 
ary.sort(function(a,b){return (a[1]<b[1] ? -1 : (a[1]>b[1] ? 1 : 0))});
print(ary);
 
/* a stable sort will output [strv] */"
"function lengthSorter(a, b) {
  var result = b.length - a.length;
  if (result == 0)
    result = a.localeCompare(b);
  return result;
}
 
var test = [strv, strv, strv, strv, strv, strv, strv, strv];
test.sort(lengthSorter);
alert( test.join(' ') );                      (function () {
    'use strict';
 
    
 
    
 
    
    var compare = function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    };
 
    
    var mappendOrdering = function (a, b) {
        return a !== 0 ? a : b;
    };
 
    
    var on = function (f, g) {
        return function (a, b) {
            return f(g(a), g(b));
        };
    };
 
    
    var flip = function (f) {
        return function (a, b) {
            return f.apply(null, [b, a]);
        };
    };
 
    
    var arrayCopy = function (xs) {
        return xs.slice(0);
    };
 
    
    var show = function (x) {
        return JSON.stringify(x, null, 2);
    };
 
    
    var xs = ['Shanghai', 'Karachi', 'Beijing', 'Sao Paulo', 'Dhaka', 'Delhi', 'Lagos'];
 
    var rs = [{
        name: 'Shanghai',
        pop: 24.2
    }, {
        name: 'Karachi',
        pop: 23.5
    }, {
        name: 'Beijing',
        pop: 21.5
    }, {
        name: 'Sao Paulo',
        pop: 24.2
    }, {
        name: 'Dhaka',
        pop: 17.0
    }, {
        name: 'Delhi',
        pop: 16.8
    }, {
        name: 'Lagos',
        pop: 16.1
    }];
 
    
    var population = function (x) {
        return x.pop;
    };
 
    
    var length = function (xs) {
        return xs.length;
    };
 
    
    var toLower = function (s) {
        return s.toLowerCase();
    };
 
    
    var lengthThenAZ = function (a, b) {
        return mappendOrdering(
            on(compare, length)(a, b),
            on(compare, toLower)(a, b)
        );
    };
 
    
    var descLengthThenAZ = function (a, b) {
        return mappendOrdering(
            on(flip(compare), length)(a, b),
            on(compare, toLower)(a, b)
        );
    };
 
    return show({
        default: arrayCopy(xs)
            .sort(compare),
 
        descendingDefault: arrayCopy(xs)
            .sort(flip(compare)),
 
        byLengthThenAZ: arrayCopy(xs)
            .sort(lengthThenAZ),
 
        byDescendingLengthThenZA: arrayCopy(xs)
            .sort(flip(lengthThenAZ)),
 
        byDescendingLengthThenAZ: arrayCopy(xs)
            .sort(descLengthThenAZ),
 
        byPopulation: arrayCopy(rs)
            .sort(on(compare, population)),
 
        byDescendingPopulation: arrayCopy(rs)
            .sort(on(flip(compare), population))
    });
})();(() => {
    'use strict';
 
    
 
    
    
    const compare = (a, b) => a < b ? -1 : (a > b ? 1 : 0);
 
    
    const mappendOrdering = (a, b) => a !== 0 ? a : b;
 
    
    const on = (f, g) => (a, b) => f(g(a), g(b));
 
    
    const flip = f => (a, b) => f.apply(null, [b, a]);
 
    
    const arrayCopy = (xs) => xs.slice(0);
 
    
    const show = x => JSON.stringify(x, null, 2);
 
 
    
    const xs = ['Shanghai', 'Karachi', 'Beijing', 'Sao Paulo', 'Dhaka', 'Delhi', 'Lagos'];
 
    const rs = [{
        name: 'Shanghai',
        pop: 24.2
    }, {
        name: 'Karachi',
        pop: 23.5
    }, {
        name: 'Beijing',
        pop: 21.5
    }, {
        name: 'Sao Paulo',
        pop: 24.2
    }, {
        name: 'Dhaka',
        pop: 17.0
    }, {
        name: 'Delhi',
        pop: 16.8
    }, {
        name: 'Lagos',
        pop: 16.1
    }]
 
    
    const population = x => x.pop;
 
    
    const length = xs => xs.length;
 
    
    const toLower = s => s.toLowerCase();
 
    
    const lengthThenAZ = (a, b) =>
        mappendOrdering(
            on(compare, length)(a, b),
            on(compare, toLower)(a, b)
        );
 
    
    const descLengthThenAZ = (a, b) =>
        mappendOrdering(
            on(flip(compare), length)(a, b),
            on(compare, toLower)(a, b)
        );
 
    return show({
        default: arrayCopy(xs)
            .sort(compare),
 
        descendingDefault: arrayCopy(xs)
            .sort(flip(compare)),
 
        byLengthThenAZ: arrayCopy(xs)
            .sort(lengthThenAZ),
 
        byDescendingLengthThenZA: arrayCopy(xs)
            .sort(flip(lengthThenAZ)),
 
        byDescendingLengthThenAZ: arrayCopy(xs)
            .sort(descLengthThenAZ),
 
        byPopulation: arrayCopy(rs)
            .sort(on(compare, population)),
 
        byDescendingPopulation: arrayCopy(rs)
            .sort(on(flip(compare), population))
    });
})();"
"var arr = [
  {id: 3, value: strv},
  {id: 2, value: strv},
  {id: 4, value: strv},
  {id: 1, value: 42},
  {id: 5, something: strv} 
];
arr = arr.sort(function(a, b) {return a.id - b.id}); 
 (() => {
    'use strict';
 
    
 
    
    const compare = (a, b) => a < b ? -1 : (a > b ? 1 : 0);
 
    
    const on = (f, g) => (a, b) => f(g(a), g(b));
 
    
    const flip = f => (a, b) => f.apply(null, [b, a]);
 
    
    const arrayCopy = (xs) => xs.slice(0);
 
    
    const show = x => JSON.stringify(x, null, 2);
 
 
    
    const xs = [{
        name: 'Shanghai',
        pop: 24.2
    }, {
        name: 'Karachi',
        pop: 23.5
    }, {
        name: 'Beijing',
        pop: 21.5
    }, {
        name: 'Sao Paulo',
        pop: 24.2
    }, {
        name: 'Dhaka',
        pop: 17.0
    }, {
        name: 'Delhi',
        pop: 16.8
    }, {
        name: 'Lagos',
        pop: 16.1
    }]
 
    
    const population = x => x.pop;
 
    
    const name = x => x.name;
 
    return show({
        byPopulation: arrayCopy(xs)
            .sort(on(compare, population)),
        byDescendingPopulation: arrayCopy(xs)
            .sort(on(flip(compare), population)),
        byName: arrayCopy(xs)
            .sort(on(compare, name)),
        byDescendingName: arrayCopy(xs)
            .sort(on(flip(compare), name))
    });
})();"
"function sort_disjoint(values, indices) {
  var sublist = [];
  indices.sort(function(a, b) { return a > b; });
 
  for (var i = 0; i < indices.length; i += 1) {
    sublist.push(values[indices[i]]);
  }
 
  sublist.sort(function(a, b) { return a < b; });
 
  for (var i = 0; i < indices.length; i += 1) {
    values[indices[i]] = sublist.pop();
  }
 
  return values;
}(function () {
    'use strict';
 
    
    function disjointSort(xs, indices) {
 
        
        var indicesSorted = indices.sort(),
            subsetSorted = indicesSorted
            .map(function (i) {
                return xs[i];
            })
            .sort();
 
        return xs
            .map(function (x, i) {
                var iIndex = indicesSorted.indexOf(i);
 
                return iIndex !== -1 ? (
                    subsetSorted[iIndex]
                ) : x;
            });
    }
 
    return disjointSort([7, 6, 5, 4, 3, 2, 1, 0], [6, 1, 7])
 
})();(() => {
    'use strict';
 
    
    const disjointSort = (xs, indices) => {
 
        
        const indicesSorted = indices.sort(),
            subsetSorted = indicesSorted
            .map(i => xs[i])
            .sort();
 
        return xs
            .map((x, i) => {
                const iIndex = indicesSorted.indexOf(i);
                return iIndex !== -1 ? (
                    subsetSorted[iIndex]
                ) : x;
            });
    };
 
    return disjointSort([7, 6, 5, 4, 3, 2, 1, 0], [6, 1, 7]);
})();"
"(() => {
    'use strict';
 
    
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    }
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const dropWhile = (p, xs) => {
        let i = 0;
        for (let lng = xs.length;
            (i < lng) && p(xs[i]); i++) {}
        return xs.slice(i);
    }
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const take = (n, xs) => xs.slice(0, n);
 
    
    const drop = (n, xs) => xs.slice(n);
 
    
    const floor = Math.floor;
 
    
    const sqrt = Math.sqrt;
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    
    const unwords = xs => xs.join(' ');
 
 
    
 
    
    const primeFactors = n => {
        const fs = take(1, (dropWhile(x => n % x !== 0, range(2, floor(sqrt(n))))));
        return fs.length === 0 ? (
            [n]
        ) : fs.concat(primeFactors(floor(n / head(fs))));
    };
 
    
    const digitSum = ds =>
        ds
        .reduce((a, b) => parseInt(a, 10) + parseInt(b, 10), 0);
 
    
    const isSmith = n => {
        const pfs = primeFactors(n);
        return (head(pfs) !== n) &&
            digitSum(n.toString()
                .split('')) == digitSum(
                concat(pfs.map(x => x.toString()))
                .split('')
            );
    }
 
    
 
    
    const lowSmiths = range(2, 9999)
        .filter(isSmith);
 
    
    const lowSmithCount = lowSmiths.length;
 
    return [
        strv,
            show(lowSmithCount),
            ""First 15 Smith Numbers:"",
            unwords(take(15, lowSmiths)),
            ""Last 12 Smith Numbers below 10000:"",
            unwords(drop(lowSmithCount - 12, lowSmiths))
    ].join('');
})();"
"Array.prototype.bubblesort = function() {
    var done = false;
    while (!done) {
        done = true;
        for (var i = 1; i<this.length; i++) {
            if (this[i-1] > this[i]) {
                done = false;
                [this[i-1], this[i]] = [this[i], this[i-1]]
            }
        }
    }
    return this;
}Array.prototype.bubblesort = function() {
  var done = false;
  while (! done) {
    done = true;
    for (var i = 1; i < this.length; i++) {
      if (this[i - 1] > this[i]) {
        done = false;
        var tmp = this[i - 1];
        this[i - 1] = this[i];
        this[i] = tmp;
      }
    }
  }
  return this;
}var my_arr = [strv, strv, strv, strv, strv, strv, strv];
my_arr.bubblesort();
print(my_arr);"
"(() => {
    'use strict';
 
    
 
    
    const abs = Math.abs;
 
    
    const all = (f, xs) => xs.every(f);
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const delete_ = (x, xs) =>
        deleteBy((a, b) => a === b, x, xs);
 
    
    const deleteBy = (f, x, xs) =>
        xs.length > 0 ? (
            f(x, xs[0]) ? (
                xs.slice(1)
            ) : [xs[0]].concat(deleteBy(f, x, xs.slice(1)))
        ) : [];
 
    
    const enumFromTo = (m, n) => {
        const [tm, tn] = [typeof m, typeof n];
        return tm !== tn ? undefined : (() => {
            const
                blnS = (tm === 'string'),
                [base, end] = [m, n].map(blnS ? (s => s.codePointAt(0)) : id);
            return Array.from({
                length: Math.floor(end - base) + 1
            }, (_, i) => blnS ? String.fromCodePoint(base + i) : m + i);
        })();
    };
 
    
    const id = x => x;
 
    
    const justifyRight = (n, cFiller, strText) =>
        n > strText.length ? (
            (cFiller.repeat(n) + strText)
            .slice(-n)
        ) : strText;
 
    
    const permutations = xs =>
        xs.length ? concatMap(x => concatMap(ys => [
                [x].concat(ys)
            ],
            permutations(delete_(x, xs))), xs) : [
            []
        ];
 
    
    const show = x => JSON.stringify(x);
 
    
    const unlines = xs => xs.join('');
 
    
    const until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    };
 
    
    const unwords = xs => xs.join(' ');
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    };
 
 
    
 
    
    const universe = permutations(enumFromTo(1, 8));
 
    
    const isSolution = ([a, b, c, d, e, f, g, h]) =>
        all(x => abs(x) > 1, [a - d, c - d, g - d, e - d, a - c, c - g, g - e,
            e - a, b - e, d - e, h - e, f - e, b - d, d - h, h - f, f - b
        ]);
 
    
    const firstSolution = universe[until(
        i => isSolution(universe[i]),
        i => i + 1,
        0
    )];
 
    
 
    
    const [a, b, c, d, e, f, g, h] = firstSolution;
 
    return unlines(
        zipWith(
            (a, n) => a + ' = ' + n.toString(),
            enumFromTo('A', 'H'),
            firstSolution
        )
        .concat(
            [
                [],
                [a, b],
                [c, d, e, f],
                [g, h]
            ].map(xs => justifyRight(5, ' ', unwords(xs.map(show))))
        )
    );
})();"
"function int_arr(a, b) {
  return a - b;
}
var numbers = [20, 7, 65, 10, 3, 0, 8, -60];
numbers.sort(int_arr);
document.write(numbers);"
"LinkedList.prototype.insertAfter = function(searchValue, nodeToInsert) {
    if (this._value == searchValue) {
        nodeToInsert.next(this.next());
        this.next(nodeToInsert);
    }
    else if (this.next() == null) 
        throw new Error(0, strv + searchValue + strv)
    else
        this.next().insertAfter(searchValue, nodeToInsert);
}
var list = createLinkedListFromArray(['A','B']);
list.insertAfter('A', new LinkedList('C', null));"
"LinkedList.prototype.traverse = function(func) {
    func(this);
    if (this.next() != null)
        this.next().traverse(func);
}
 
LinkedList.prototype.print = function() {
    this.traverse( function(node) {print(node.value())} );
}
 
var head = createLinkedListFromArray([10,20,30,40]);
head.print();var map = function (fn, list) {
        return list.map(fn);
    },
 
    foldr = function (fn, acc, list) {
        var listr = list.slice();
        listr.reverse();
 
        return listr.reduce(fn, acc);
    },
 
    traverse = function (list, fn) {
        return list.forEach(fn);
    };
 
var range = function (m, n) {
    return Array.apply(null, Array(n - m + 1)).map(
        function (x, i) {
            return m + i;
        }
    );
};
 

map(function (x) {
    return x > 5;
}, range(1, 10));
 

map(function (x) {
    return x + 's';
}, [strv, strv, strv, strv])
 

foldr(function (acc, x) {
    return acc + x;
}, 0, range(1, 10))
 
 
traverse([strv, strv, strv, strv], function (x) {
    console.log(x);
})
/* Apple */
/* Orange */
/* Mango */
/* Pear */"
"function Singleton() {
	if(Singleton._instance) return Singleton._instance;
	this.set(strv);
	Singleton._instance = this;
}
 
Singleton.prototype.set = function(msg) { this.msg = msg; }
Singleton.prototype.append = function(msg) { this.msg += msg; }
Singleton.prototype.get = function() { return this.msg; }
 
 
var a = new Singleton();
var b = new Singleton();
var c = new Singleton();
 
a.set(strv);
b.append(strv);
c.append(strv);
 
document.write( (new Singleton()).get() );"
"function LinkedList(value, next) {
    this._value = value;
    this._next = next;
}
LinkedList.prototype.value = function() {
    if (arguments.length == 1) 
        this._value = arguments[0];
    else
        return this._value;
}
LinkedList.prototype.next = function() {
    if (arguments.length == 1) 
        this._next = arguments[0];
    else
        return this._next;
}
 

function createLinkedListFromArray(ary) {
    var head = new LinkedList(ary[0], null);
    var prev = head;
    for (var i = 1; i < ary.length; i++) {
        var node = new LinkedList(ary[i], null);
        prev.next(node);
        prev = node;
    }
    return head;
}
 
var head = createLinkedListFromArray([10,20,30,40]);"
"

 



 
[1, 2, 3].map(function sierpinskiCarpetOrder(n) {
 
    
    
    var carpet = function (n) {
            var lstN = range(0, Math.pow(3, n) - 1);
 
            
            return lstN.map(function (x) {
                return lstN.map(function (y) {
                    return inCarpet(x, y);
                });
            });
        },
 
        
        
        
        
        inCarpet = function (x, y) {
            return (!x || !y) ? true :
                !(
                    (x % 3 === 1) &&
                    (y % 3 === 1)
                ) && inCarpet(
                    x / 3 | 0,
                    y / 3 | 0
                );
        },
 
        
        
        range = function (m, n) {
            return Array.apply(null, Array(n - m + 1)).map(
                function (x, i) {
                    return m + i;
                }
            );
        };
 
    
    
    return carpet(n).map(function (line) {
        return line.map(function (bool) {
            return bool ? '2588' : ' ';
        }).join('');
    }).join('');
 
}).join('');(() => {
    'use strict';
 
    
    let sierpinskiCarpet = n => {
 
        
        let carpet = n => {
                let xs = range(0, Math.pow(3, n) - 1);
                return xs.map(x => xs.map(y => inCarpet(x, y)));
            },
 
            
 
            
            inCarpet = (x, y) =>
                (!x || !y) ? true : !(
                    (x % 3 === 1) &&
                    (y % 3 === 1)
                ) && inCarpet(
                    x / 3 | 0,
                    y / 3 | 0
                );
 
        return carpet(n)
            .map(line => line.map(bool => bool ? '2588' : ' ')
                .join(''))
            .join('');
    };
 
    
 
    
    let range = (m, n) =>
            Array.from({
                length: Math.floor(n - m) + 1
            }, (_, i) => m + i);
 
    
 
    return [1, 2, 3]
        .map(sierpinskiCarpet);
})();"
document.write(new Date(0).toUTCString());
"(function (order) {
 
    
    
    
    
    function sierpinski(intOrder) {
        return function asciiPascalMod2(intRows) {
            return range(1, intRows - 1)
                .reduce(function (lstRows) {
                    var lstPrevRow = lstRows.slice(-1)[0];
 
                    
                    return lstRows.concat([zipWith(function (left, right) {
                        
                        
                        
 
                        
                        
 
                        return left === right ? strv : strv;
                    }, [' '].concat(lstPrevRow), lstPrevRow.concat(' '))]);
                }, [
                    [strv] 
                ]);
        }(Math.pow(2, intOrder))
 
        
        .reduceRight(function (sofar, lstLine) {
            return {
                triangle: sofar.indent + lstLine.join(strv) + """" +
                    sofar.triangle,
                indent: sofar.indent + strv
            };
        }, {
            triangle: strv,
            indent: strv
        }).triangle;
    };
 
    var zipWith = function (f, xs, ys) {
            return xs.length === ys.length ? xs
                .map(function (x, i) {
                    return f(x, ys[i]);
                }) : undefined;
        },
        range = function (m, n) {
            return Array.apply(null, Array(n - m + 1))
                .map(function (x, i) {
                    return m + i;
                });
        };
 
    
    return sierpinski(order);
 
})(4);
 function triangle(o) {
    var n = 1 << o,
        line = new Array(2 * n),
        i, j, t, u;
    for (i = 0; i < line.length; ++i) line[i] = '&nbsp;';
    line[n] = '*';
    for (i = 0; i < n; ++i) {
        document.write(line.join('') + """");
        u = '*';
        for (j = n - i; j < n + i + 1; ++j) {
            t = (line[j - 1] == line[j + 1] ? '&nbsp;' : '*');
            line[j - 1] = u;
            u = t;
        }
        line[n + i] = t;
        line[n + i + 1] = '*';
    }
}
document.write(""<pre>"");
triangle(6);
document.write(strv);(() => {
    'use strict';
 
    
 
    
    const sierpTriangle = n =>
        
        (n > 0) ? concat(ap([
            map(xs => intercalate(xs, ap(
                [s => concat(replicate(Math.pow(2, (n - 1)), s))], [' ', '-']
            ))),
 
            
            map(xs => intercalate('+', [xs, xs]))
        ], [sierpTriangle(n - 1)])) : ['▲'];
 
 
    
 
    
    const replicate = (n, a) => {
        let v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    const curry = f => a => b => f(a, b);
 
    
    const map = curry((f, xs) => xs.map(f));
 
    
    
    const ap = (fs, xs) => //
        [].concat.apply([], fs.map(f => //
            [].concat.apply([], xs.map(x => [f(x)]))));
 
    
    const unlines = xs => xs.join('');
 
    
    const intercalate = (s, xs) => xs.join(s);
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    return unlines(sierpTriangle(4));
})(); 
(order => {
    
    let sierpinski = intOrder => {
 
        
        let asciiPascalMod2 = nRows =>
            range(1, nRows - 1)
            .reduce(sofar => {
                let lstPrev = sofar.slice(-1)[0];
 
                
                
                
 
                
                
 
                return sofar
                    .concat([zipWith(
                        (left, right) => left === right ? ' ' : '*',
                        [' '].concat(lstPrev),
                        lstPrev.concat(' ')
                    )]);
            }, [
                ['*'] 
            ]);
 
        
        
 
        
        return asciiPascalMod2(Math.pow(2, intOrder))
            .reduceRight((a, x) => {
                return {
                    triangle: a.indent + x.join(' ') + '' + a.triangle,
                    indent: a.indent + ' '
                }
            }, {
                triangle: '',
                indent: ''
            }).triangle
    };
 
    
    let zipWith = (f, xs, ys) =>
            xs.length === ys.length ? (
                xs.map((x, i) => f(x, ys[i]))
            ) : undefined,
 
        
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        };
 
    return sierpinski(order);
 
})(4);"
"(function () {
    'use strict';
 
    function a(bool) {
        console.log('a -->', bool);
 
        return bool;
    }
 
    function b(bool) {
        console.log('b -->', bool);
 
        return bool;
    }
 
 
    var x = a(false) && b(true),
        y = a(true) || b(false),
        z = true ? a(true) : b(false);
 
  return [x, y, z];
})();"
"function dice5()
{
 return 1 + Math.floor(5 * Math.random());
}
 
function dice7()
{
 while (true)
 {
  var dice55 = 5 * dice5() + dice5() - 6;
  if (dice55 < 21)
   return dice55 % 7 + 1;
 }
}
 
distcheck(dice5, 1000000);
print();
distcheck(dice7, 1000000);"
"var a = [];
for (var i = 1; i < 23; i++) a[i] = i + Math.floor(1/2 + Math.sqrt(i));
console.log(a);
 
for (i = 1; i < 1000000; i++) if (Number.isInteger(i + Math.floor(1/2 + Math.sqrt(i))) === false) {
    console.log(strv,i,strv);
}(() => {
 
    
    let nonSquare = n =>
        n + floor(1 / 2 + sqrt(n));
 
 
 
    
    let floor = Math.floor,
 
        
        sqrt = Math.sqrt,
 
        
        isSquare = n => {
            let root = sqrt(n);
 
            return root === floor(root);
        };
 
 
    
    return {
        first22: Array.from({
            length: 22
        }, (_, i) => nonSquare(i + 1)),
 
        firstMillionNotSquare: Array.from({
                length: 10E6
            }, (_, i) => nonSquare(i + 1))
            .filter(isSquare)
            .length === 0
    };
 
})();{
    strv:[2, 3, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15,
               17, 18, 19, 20, 21, 22, 23, 24, 26, 27], 
    strv:true
}"
"example = new Object;
example.foo = function(x) {
    return 42 + x;
};
 
name = strv;
example[name](5)      # => 47"
"function eratosthenes(limit) {
    var primes = [];
    if (limit >= 2) {
        var sqrtlmt = Math.sqrt(limit) - 2;
        var nums = new Array(); 
        for (var i = 2; i <= limit; i++) 
            nums.push(i); 
        for (var i = 0; i <= sqrtlmt; i++) {
            var p = nums[i]
            if (p)
                for (var j = p * p - 2; j < nums.length; j += p)
                    nums[j] = 0;
        }
        for (var i = 0; i < nums.length; i++) {
            var p = nums[i];
            if (p)
                primes.push(p);
        }
    }
    return primes;
}
 
var primes = eratosthenes(100);
 
if (typeof print == strv)
    print = (typeof WScript != strv) ? WScript.Echo : alert;
print(primes);function eratosthenes(limit) {
    var prms = [];
    if (limit >= 2) prms = [2];
    if (limit >= 3) {
        var sqrtlmt = (Math.sqrt(limit) - 3) >> 1;
        var lmt = (limit - 3) >> 1;
        var bfsz = (lmt >> 5) + 1
        var buf = [];
        for (var i = 0; i < bfsz; i++)
            buf.push(0);
        for (var i = 0; i <= sqrtlmt; i++)
            if ((buf[i >> 5] & (1 << (i & 31))) == 0) {
                var p = i + i + 3;
                for (var j = (p * p - 3) >> 1; j <= lmt; j += p)
                    buf[j >> 5] |= 1 << (j & 31);
            }
        for (var i = 0; i <= lmt; i++)
            if ((buf[i >> 5] & (1 << (i & 31))) == 0)
                prms.push(i + i + 3);
    }
    return prms;
}var SoEIncClass = (function () {
    function SoEIncClass() {
        this.n = 0;
    }
    SoEIncClass.prototype.next = function () {
        this.n += 2;
        if (this.n < 7) { 
            if (this.n < 3) { 
                this.n = 1; 
                return 2;
            }
            if (this.n < 5)
                return 3;
            this.dict = {}; 
            this.bps = new SoEIncClass(); 
            this.bps.next(); 
            this.p = this.bps.next(); 
            this.q = this.p * this.p; 
            return 5;
        } else { 
            var s = this.dict[this.n]; 
            if (!s) { 
                if (this.n < this.q) 
                    return this.n; 
                else { 
                    var p2 = this.p << 1; 
                    this.dict[this.n + p2] = p2; 
                    this.p = this.bps.next();
                    this.q = this.p * this.p; 
                    return this.next(); 
                }
            } else { 
                delete this.dict[this.n]; 
                var nxt = this.n + s;
                while (this.dict[nxt]) nxt += s; 
                this.dict[nxt] = s; 
                return this.next(); 
            }
        }
    };
    return SoEIncClass;
})();var gen = new SoEIncClass(); 
for (var i = 1; i < 1000000; i++, gen.next());
var prime = gen.next();
 
if (typeof print == strv)
    print = (typeof WScript != strv) ? WScript.Echo : alert;
print(prime);var SoEPgClass = (function () {
    function SoEPgClass() {
        this.bi = -1; 
    }
    SoEPgClass.prototype.next = function () {
        if (this.bi < 1) {
            if (this.bi < 0) {
                this.bi++;
                this.lowi = 0; 
                this.bpa = [];
                return 2;
            } else { 
                var nxt = 3 + (this.lowi << 1) + 262144;
                this.buf = new Array();
                for (var i = 0; i < 4096; i++) 
                    this.buf.push(0);
                if (this.lowi <= 0) { 
                    for (var i = 0, p = 3, sqr = 9; sqr < nxt; i++, p += 2, sqr = p * p)
                        if ((this.buf[i >> 5] & (1 << (i & 31))) === 0)
                            for (var j = (sqr - 3) >> 1; j < 131072; j += p)
                                this.buf[j >> 5] |= 1 << (j & 31);
                } else { 
                    if (!this.bpa.length) { 
                        this.bps = new SoEPgClass(); 
                        this.bps.next(); 
                        this.bpa.push(this.bps.next()); 
                    }
                    
                    for (var p = this.bpa[this.bpa.length - 1], sqr = p * p; sqr < nxt;
                            p = this.bps.next(), this.bpa.push(p), sqr = p * p) ;
                    for (var i = 0; i < this.bpa.length; i++) {
                        var p = this.bpa[i];
                        var s = (p * p - 3) >> 1;
                        if (s >= this.lowi) 
                            s -= this.lowi;
                        else {
                            var r = (this.lowi - s) % p;
                            s = (r != 0) ? p - r : 0;
                        }
                        for (var j = s; j < 131072; j += p)
                            this.buf[j >> 5] |= 1 << (j & 31);
                    }
                }
            }
        }
        while (this.bi < 131072 && this.buf[this.bi >> 5] & (1 << (this.bi & 31)))
            this.bi++; 
        if (this.bi < 131072) 
            return 3 + ((this.lowi + this.bi++) << 1);
        else { 
            this.bi = 0;
            this.lowi += 131072;
            return this.next(); 
        }
    };
    return SoEPgClass;
})();"
"function is_self_describing(n) {
    var digits = Number(n).toString().split(strv).map(function(elem) {return Number(elem)});
    var len = digits.length;
    var count = digits.map(function(x){return 0});
 
    digits.forEach(function(digit, idx, ary) {
        if (digit >= count.length)
            return false
        count[digit] ++;
    });
 
    return digits.equals(count);
}
 
Array.prototype.equals = function(other) {
    if (this === other)
        return true;  
    if (this.length != other.length)
        return false;
    for (idx in this)
        if (this[idx] !== other[idx])
            return false;
    return true;
}
 
for (var i=1; i<=3300000; i++)
    if (is_self_describing(i))
        print(i);"
"#!/usr/bin/env node
var  fs = require('fs');
var sys = require('sys');
 
var dictFile = process.argv[2] || strv;
 
var dict = {};
fs.readFileSync(dictFile)
  .toString()
  .split('')
  .forEach(function(word) {
    dict[word] = word.split(strv).reverse().join(strv);
  });
 
function isSemordnilap(word) { return dict[dict[word]]; };
 
var semordnilaps = []
for (var key in dict) {
  if (isSemordnilap(key)) {
    var rev = dict[key];
    if (key < rev) {
      semordnilaps.push([key,rev]) ;
    }
  }
}
 
var count = semordnilaps.length;
sys.puts(strv + count + strv +
         dictFile + strv );
 
var indices=[]
for (var i=0; i<count; ++i) {
  if (Math.random() < 1/Math.ceil(i/5.0)) {
    indices[i%5] = i 
  }
}
indices.sort()
for (var i=0; i<5; ++i) {
  sys.puts(semordnilaps[indices[i]]);
}#!/usr/bin/env rhino
 
importPackage (java.io)
 
var dictFile = arguments[0] || strv;
 
var reader = new BufferedReader(new FileReader(dictFile));
var dict = {};
var word;
while (word = reader.readLine()) {
  dict[word] = word.split(strv).reverse().join(strv);
}
 
function isSemordnilap(word) { return dict[dict[word]]; };
 
var semordnilaps = []
for (var key in dict) {
  if (isSemordnilap(key)) {
    var rev = dict[key];
    if (key < rev) {
      semordnilaps.push([key,rev]) ;
    }
  }
}
 
var count = semordnilaps.length;
print(strv + count + strv +
      dictFile + strv );
var indices=[]
for (var i=0; i<count; ++i) {
  if (Math.random() < 1/Math.ceil(i/5.0)) {
     indices[i%5] = i 
  }
}
indices.sort()
for (var i=0; i<5; ++i) {
  print(semordnilaps[indices[i]]);
}"
" 
var set = new Set();
 
set.add(0);
set.add(1);
set.add('two');
set.add('three');
 
set.has(0); //=> true
set.has(3); //=> false
set.has('two'); 
set.has(Math.sqrt(4)); //=> false
set.has('TWO'.toLowerCase()); //=> true
 
set.size; //=> 4
 
set.delete('two');
set.has('two'); //==> false
set.size; //=> 3
 
//iterating set using ES6 for..of
//Set order is preserved in order items are added.
for (var item of set) {
  console.log('item is ' + item);
}"
"[
  { strv: strv,                strv: 21.0  },
  { strv: strv,                strv: 15.2  },
  { strv: strv, strv: 11.3  },
  { strv: strv, strv:  7.55 },
  { strv: strv,            strv:  5.85 },
  { strv: strv,    strv:  4.98 },
  { strv: strv,        strv:  4.7  },
  { strv: strv,           strv:  4.58 },
  { strv: strv,              strv:  4.4  },
  { strv: strv,           strv:  3.98 }
](function () {
    'use strict';
 
    
    function find(f, xs) {
        for (var i = 0, lng = xs.length; i < lng; i++) {
            if (f(xs[i])) return xs[i];
        }
        return undefined;
    }
 
    
    function findIndex(f, xs) {
        for (var i = 0, lng = xs.length; i < lng; i++) {
            if (f(xs[i])) return i;
        }   
        return undefined;
    }
 
 
    var lst = [
      { strv: strv,                strv: 21.0  },
      { strv: strv,                strv: 15.2  },
      { strv: strv, strv: 11.3  },
      { strv: strv, strv:  7.55 },
      { strv: strv,            strv:  5.85 },
      { strv: strv,    strv:  4.98 },
      { strv: strv,        strv:  4.7  },
      { strv: strv,           strv:  4.58 },
      { strv: strv,              strv:  4.4  },
      { strv: strv,           strv:  3.98 }
    ];
 
    return {
        darEsSalaamIndex: findIndex(function (x) {
            return x.name === 'Dar Es Salaam';
        }, lst),
 
        firstBelow5M: find(function (x) {
                return x.population < 5;
            }, lst)
            .name,
 
        firstApop: find(function (x) {
                return x.name.charAt(0) === 'A';
            }, lst)
            .population
    };
 
})();(() => {
    'use strict';
 
    let lst = [
          { strv: strv,                strv: 21.0  },
          { strv: strv,                strv: 15.2  },
          { strv: strv, strv: 11.3  },
          { strv: strv, strv:  7.55 },
          { strv: strv,            strv:  5.85 },
          { strv: strv,    strv:  4.98 },
          { strv: strv,        strv:  4.7  },
          { strv: strv,           strv:  4.58 },
          { strv: strv,              strv:  4.4  },
          { strv: strv,           strv:  3.98 }
        ];
 
    return {
        darEsSalaamIndex: lst.findIndex(x => x.name === 'Dar Es Salaam'),
        firstBelow5M: lst.find(x => x.population < 5)
            .name,
        firstApop: lst.find(x => x.name[0] === 'A')
            .population
    };
 
})();"
"function sedol(input) {
    return input + sedol_check_digit(input);
}
 
var weight = [1, 3, 1, 7, 3, 9, 1];
function sedol_check_digit(char6) {
    if (char6.search(/^[0-9BCDFGHJKLMNPQRSTVWXYZ]{6}$/) == -1)
        throw strv + char6 + strv;
    var sum = 0;
    for (var i = 0; i < char6.length; i++)
        sum += weight[i] * parseInt(char6.charAt(i), 36);
    var check = (10 - sum%10) % 10;
    return check.toString();
}
 
var input = [ 
    '710889', 'B0YBKJ', '406566', 'B0YBLH', '228276',
    'B0YBKL', '557910', 'B0YBKR', '585284', 'B0YBKT',
    strv , strv, strv, strv
];
 
var expected = [ 
    '7108899', 'B0YBKJ7', '4065663', 'B0YBLH2', '2282765',
    'B0YBKL9', '5579107', 'B0YBKR5', '5852842', 'B0YBKT7',
    null, null, '1234563', null
];
 
for (var i in input) {
    try {
        var sedolized = sedol(input[i]);
        if (sedolized == expected[i]) 
            print(sedolized);
        else
            print(strv + input[i] + 
                  strv + sedolized + strv + expected[i]
            );
    }
    catch (e) {
        print(strv + e);
    }
}"
"function sattoloCycle(items) {
    for (var i = items.length; i--> 1;) {
        var j = Math.floor(Math.random() * i);
        var tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }
}"
"var haystack = ['Zig', 'Zag', 'Wally', 'Ronald', 'Bush', 'Krusty', 'Charlie', 'Bush', 'Bozo']
var needles = ['Bush', 'Washington']
 
for (var i in needles) {
    var found = false;
    for (var j in haystack) {
        if (haystack[j] == needles[i]) {
            found = true;
            break;
        }
    }
    if (found)
        print(needles[i] + strv + j + strv);
    else
        throw needles[i] + strv
}for each (var needle in needles) {
    var idx = haystack.indexOf(needle);
    if (idx == -1)
        throw needle + strv
    else
        print(needle + strv + idx + strv);
}
 

 
for each (var elem in haystack) {
    var first_idx = haystack.indexOf(elem);
    var last_idx  = haystack.lastIndexOf(elem);
    if (last_idx > first_idx) {
        print(elem + strv + last_idx + strv);
        break
    }
}(function () {
 
  function findIndex(fnPredicate, list) {
    for (var i = 0, lng = list.length; i < lng; i++) {
      if (fnPredicate(list[i])) {
        return i;
      }
    }
    return Error(strv);
  };
 
  
 
  function matchCaseInsensitive(s, t) {
    return s.toLowerCase() === t.toLowerCase();
  }
 
  var lstHaystack = [
    'Zig', 'Zag', 'Wally', 'Ronald', 'Bush',
    'Krusty', 'Charlie', 'Bush', 'Bozo'
  ],
    lstReversed = lstHaystack.slice(0).reverse(),
    iLast = lstHaystack.length - 1,
    lstNeedles = ['bush', 'washington'];
 
  return {
    'first': lstNeedles.map(function (s) {
      return [s, findIndex(function (t) {
          return matchCaseInsensitive(s, t);
        },
        lstHaystack)];
    }),
 
    'last': lstNeedles.map(function (s) {
      var varIndex = findIndex(function (t) {
          return matchCaseInsensitive(s, t);
        },
        lstReversed);
 
      return [
        s,
        typeof varIndex === 'number' ?
          iLast - varIndex : varIndex
      ];
    })
  }
})();{
  strv: [
    [
      strv,
      4
    ],
    [
      strv,
      strv
    ]
  ],
  strv: [
    [
      strv,
      7
    ],
    [
      strv,
      strv
    ]
  ]
}"
"(function () {
 
    
    function wakeSplit(intNuts, intSailors, intDepth) {
        var nDepth = intDepth !== undefined ? intDepth : intSailors,
            portion = Math.floor(intNuts / intSailors),
            remain = intNuts % intSailors;
 
        return 0 >= portion || remain !== (nDepth ? 1 : 0) ?
            null : nDepth ? wakeSplit(
                intNuts - portion - remain, intSailors, nDepth - 1
            ) : intNuts;
    }
 
    
    return [5, 6, 7].map(function (intSailors) {
        var intNuts = intSailors;
 
        while (!wakeSplit(intNuts, intSailors)) intNuts += 1;
 
        return intNuts;
    });
})();[3121, 233275, 823537](() => {
 
    
    let wakeSplit = (intSailors, intNuts, intDepth) => {
        let nDepth = intDepth !== undefined ? intDepth : intSailors,
            portion = Math.floor(intNuts / intSailors),
            remain = intNuts % intSailors;
 
        return 0 >= portion || remain !== (nDepth ? 1 : 0) ?
            null : nDepth ? wakeSplit(
                intSailors, intNuts - portion - remain, nDepth - 1
            ) : intNuts;
    };
 
 
    //GENERIC FUNCTIONS
 
    
    let curry = f => a => b => f(a, b),
 
        
        until = (p, f, x) => {
            let v = x;
            while (!p(v)) v = f(v);
            return v;
        },
 
        
        succ = x => x + 1;
 
 
    
    return [5, 6, 7].map(intSailors => {
        let intNuts = intSailors,
            test = curry(wakeSplit)(intSailors);
 
        return until(test, succ, intNuts);
 
    });
})();[3121, 233275, 823537]"
"function evalWithX(expr, a, b) {
    var x = a;
    var atA = eval(expr);
    x = b;
    var atB = eval(expr);
    return atB - atA;
}evalWithX('Math.exp(x)', 0, 1) "
" 
var foo = eval('{value: 42}');
eval('var bar = strv;');
 
typeof foo; 
typeof bar; 
 "
"String.prototype.parseSexpr = function() {
	var t = this.match(/\s*(strv]+)/g)
	for (var o, c=0, i=t.length-1; i>=0; i--) {
		var n, ti = t[i].trim()
		if (ti == '""') return
		else if (ti == '(') t[i]='[', c+=1
		else if (ti == ')') t[i]=']', c-=1
		else if ((n=+ti) == ti) t[i]=n
		else t[i] = '' + ti.replace('', '') + ''
		if (i>0 && ti!=']' && t[i-1].trim()!='(' ) t.splice(i,0, ',')
		if (!c) if (!o) o=true; else return
	}
	return c ? undefined : eval(t.join(''))
}
 
Array.prototype.toString = function() {
	var s=''; for (var i=0, e=this.length; i<e; i++) s+=(s?' ':'')+this[i]
	return '('+s+')'
}
 
Array.prototype.toPretty = function(s) {
	if (!s) s = ''
	var r = s + '(<br>'
	var s2 = s + Array(6).join('&nbsp;')
	for (var i=0, e=this.length; i<e; i+=1) { 
		var ai = this[i]
		r += ai.constructor != Array ? s2+ai+'<br>' : ai.toPretty(s2)
	}
	return r + s + ')<br>'
}
 
var str = '((data strv 123 4.5) (data (!@# (4.5) strv)))'
document.write('text:<br>', str.replace(/\n/g,'<br>').replace(/ /g,'&nbsp;'), '<br><br>')
var sexpr = str.parseSexpr()
if (sexpr === undefined) 
	document.write('Invalid s-expr!', '<br>')
else 
	document.write('s-expr:<br>', sexpr, '<br><br>', sexpr.constructor != Array ? '' : 'pretty print:<br>' + sexpr.toPretty())"
" 
function rk4(y, x, dx, f) {
    var k1 = dx * f(x, y),
        k2 = dx * f(x + dx / 2.0,   +y + k1 / 2.0),
        k3 = dx * f(x + dx / 2.0,   +y + k2 / 2.0),
        k4 = dx * f(x + dx,         +y + k3);
 
    return y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0;
}
 
function f(x, y) {
    return x * Math.sqrt(y);
}
 
function actual(x) {
    return (1/16) * (x*x+4)*(x*x+4);
}
 
var y = 1.0,
    x = 0.0,
    step = 0.1,
    steps = 0,
    maxSteps = 101,
    sampleEveryN = 10;
 
while (steps < maxSteps) {
    if (steps%sampleEveryN === 0) {
        console.log(strv + x + "") =  "" + y + "" ± "" + (actual(x) - y).toExponential());
    }
 
    y = rk4(y, x, step, f);
 
    
    
    x = ((x * 10) + (step * 10)) / 10;
    steps += 1;
}
 "
"var langs = ['foo', 'bar', 'baz']; 
var end_tag = '</'+'lang>';
 
var line;
while (line = readline()) {
    line = line.replace(new RegExp('</code>', 'gi'), end_tag);
    for (var i = 0; i < langs.length; i++)
        line = line.replace(new RegExp('<(?:code )?(' + langs[i] + ')>', 'gi'), '<lang $1>')
                   .replace(new RegExp('</' + langs[i] + '>', 'gi'), end_tag);
    print(line);
}"
"(function (strXPath) {
  var xr = document.evaluate(
      strXPath,
      document,
      null, 0, 0
    ),
 
    oNode = xr.iterateNext(),
    lstTasks = [];
 
  while (oNode) {
    lstTasks.push(oNode.title);
    oNode = xr.iterateNext();
  }
 
  return [
    lstTasks.length + strv + document.title,
    ''
  ].concat(lstTasks).join('')
 
})(
  '//*[@id=strv]/div[2]/table/tbody/tr/td/ul/li/a'
);"
"function encode(input) {
    var encoding = [];
    var prev, count, i;
    for (count = 1, prev = input[0], i = 1; i < input.length; i++) {
        if (input[i] != prev) {
            encoding.push([count, prev]);
            count = 1;
            prev = input[i];
        }
        else 
            count ++;
    }
    encoding.push([count, prev]);
    return encoding;
}function encode_re(input) {
    var encoding = [];
    input.match(/(.)\1*/g).forEach(function(substr){ encoding.push([substr.length, substr[0]]) });
    return encoding;
}function decode(encoded) {
    var output = strv;
    encoded.forEach(function(pair){ output += new Array(1+pair[0]).join(pair[1]) })
    return output;
}"
" 



var poly = (x => x*x*x - 3*x*x + 2*x);
 
function sign(x) {
	return (x < 0.0) ? -1 : (x > 0.0) ? 1 : 0;
}
 
function printRoots(f, lowerBound, upperBound, step) {
	var  x = lowerBound, ox = x,
		 y = f(x), oy = y,
		 s = sign(y), os = s;
 
	for (; x <= upperBound ; x += step) {
	    s = sign(y = f(x));
	    if (s == 0) {
			console.log(x);
	    }
	    else if (s != os) {
			var dx = x - ox;
			var dy = y - oy;
			var cx = x - dx * (y / dy);
			console.log(strv + cx);
	    }
	    ox = x; oy = y; os = s;
	}
}
 
printRoots(poly, -1.0, 4, 0.002);
 "
"function Root(angle) {
	with (Math) { this.r = cos(angle); this.i = sin(angle) }
}
 
Root.prototype.toFixed = function(p) {
	return this.r.toFixed(p) + (this.i >= 0 ? '+' : '') + this.i.toFixed(p) + 'i'
}
 
function roots(n) {
	var rs = [], teta = 2*Math.PI/n
	for (var angle=0, i=0; i<n; angle+=teta, i+=1) rs.push( new Root(angle) )
	return rs
}
 
for (var n=2; n<8; n+=1) {
	document.write(n, ': ')
	var rs=roots(n); for (var i=0; i<rs.length; i+=1) document.write( i ? ', ' : '', rs[i].toFixed(5) )
	document.write('<br>')
}
 "
"function rot13(c) {
    return c.replace(/([a-m])|([n-z])/ig, function($0,$1,$2) {
        return String.fromCharCode($1 ? $1.charCodeAt(0) + 13 : $2 ? $2.charCodeAt(0) - 13 : 0) || $0;
    });
}
rot13(strv) 
  
function rot13(value){
  if (!value)
    return strv;
 
  function singleChar(c) {
    if (c.toUpperCase() < strv || c.toUpperCase() > strv)
      return c;
 
    if (c.toUpperCase() <= strv)
      return String.fromCharCode(c.charCodeAt(0) + 13);
 
    return String.fromCharCode(c.charCodeAt(0) - 13);  
  }
 
  return _.map(value.split(strv), singleChar).join(strv);
}
 
describe(strv, function() {
  it(strv, function() {
    expect(rot13()).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
 
 
  it(strv, function() {
    expect(rot13(strv)).toBe(strv);
  });
});
 "
"var roman = {
    map: [
        1000, 'M', 900, 'CM', 500, 'D', 400, 'CD', 100, 'C', 90, 'XC',
        50, 'L', 40, 'XL', 10, 'X', 9, 'IX', 5, 'V', 4, 'IV', 1, 'I',
    ],
    int_to_roman: function(n) {
        var value = '';
        for (var idx = 0; n > 0 && idx < this.map.length; idx += 2) {
            while (n >= this.map[idx]) {
                value += this.map[idx + 1];
                n -= this.map[idx];
            }
        }
        return value;
    }
}
 
roman.int_to_roman(1999); (function () {
    'use strict';
 
 
    
 
    
    function romanTranscription(a) {
        if (typeof a === 'string') {
            var ps = a.split(/\d+/),
                dlm = ps.length > 1 ? ps[1] : undefined;
 
            return (dlm ? a.split(dlm)
                    .map(function (x) {
                        return Number(x);
                    }) : [a])
                .map(roman)
                .join(dlm);
        } else return roman(a);
    }
 
    
    function roman(n) {
        return [[1000, strv], [900, strv], [500, strv], [400, strv], [100,
        strv], [90, strv], [50, strv], [40, strv], [10, strv], [9,
        strv], [5, strv], [4, strv], [1, strv]]
            .reduce(function (a, lstPair) {
                var m = a.remainder,
                    v = lstPair[0];
 
                return (v > m ? a : {
                    remainder: m % v,
                    roman: a.roman + Array(
                            Math.floor(m / v) + 1
                        )
                        .join(lstPair[1])
                });
            }, {
                remainder: n,
                roman: ''
            }).roman;   
    }
 
    
 
    return [2016, 1990, 2008, strv, 2000, 1666].map(
        romanTranscription);
 
})();[strv, strv, strv, strv, strv, strv](() => {
    'use strict';
 
    
    const roman = n => [
            [1000, strv],
            [900, strv],
            [500, strv],
            [400, strv],
            [100,strv],
            [90, strv],
            [50, strv],
            [40, strv],
            [10, strv],
            [9,strv],
            [5, strv],
            [4, strv],
            [1, strv]
        ]
        .reduce((a, lstPair) => {
            const m = a.remainder,
                v = lstPair[0];
            return (v > m ? a : {
                remainder: m % v,
                roman: a.roman + Array(
                        Math.floor(m / v) + 1
                    )
                    .join(lstPair[1])
            });
        }, {
            remainder: n,
            roman: ''
        })
        .roman;
 
    
 
    
    
    const romanTranscription = a => {
        if (typeof a === 'string') {
            const ps = a.split(/\d+/),
                dlm = ps.length > 1 ? ps[1] : undefined;
 
            return (dlm ? a.split(dlm)
                    .map(Number) : [a])
                .map(roman)
                .join(dlm);
        } else return roman(a);
    }
 
    
    return [2016, 1990, 2008, strv, 2000, 1666]
        .map(romanTranscription);
})();[
  strv,
  strv,
  strv,
  strv,
  strv,
  strv
]"
"var strReversed =
""---------- Ice and Fire ------------fire, in end will world the say Someice. in say Somedesire of tasted I've what Fromfire. favor who those with hold I... elided paragraph last ...Frost Robert -----------------------"";
 
function reverseString(s) {
  return s.split('').map(
    function (line) {
      return line.split(/\s/).reverse().join(' ');
    }
  ).join('');
}
 
console.log(
  reverseString(strReversed)
);"
"var Roman = {
  Values: [['M', 1000], ['CM', 900], ['D',  500], ['CD', 400], 
           ['C',  100], ['XC',  90], ['L',  50],  ['XL',  40],  
           ['X',   10], ['IX',   9], ['V',   5],  ['IV',   4],   
           ['I',    1]],
 
  parse: function(str) {
    var result = 0
    for (var i=0; i<Roman.Values.length; ++i) {
      var pair = Roman.Values[i]
      var key = pair[0]
      var value = pair[1]
      var regex = RegExp('^' + key)
      while (str.match(regex)) {
        result += value
        str = str.replace(regex, '')
      }
    }
    return result
  }
}
 
var test_data = ['MCMXC', 'MDCLXVI', 'MMVIII']
for (var i=0; i<test_data.length; ++i) {
  var test_datum = test_data[i]
  print(test_datum + strv + Roman.parse(test_datum)) 
}(function (lstTest) {
 
    var mapping = [[strv, 1000], [strv, 900], [strv, 500], [strv, 400], [strv, 100], [
        strv, 90], [strv, 50], [strv, 40], [strv, 10], [strv, 9], [strv, 5], [strv,
        4], [strv, 1]];
 
    
    function romanValue(s) {
        
        
        function toArabic(lst) {
            return lst.length ? function (xs) {
                var lstParse = chain(mapping, function (lstPair) {
                    return isPrefixOf(
                        lstPair[0], xs
                    ) ? [lstPair[1], drop(lstPair[0].length, xs)] : []
                });
                return lstParse[0] + toArabic(lstParse[1]);
            }(lst) : 0
        }
        return toArabic(s.split(''));
    }
 
    
    function chain(xs, f) {
        return [].concat.apply([], xs.map(f));
    }
 
    
    function isPrefixOf(lstFirst, lstSecond) {
        return lstFirst.length ? (
            lstSecond.length ?
            lstFirst[0] === lstSecond[0] && isPrefixOf(
                lstFirst.slice(1), lstSecond.slice(1)
            ) : false
        ) : true;
    }
 
    
    function drop(n, lst) {
        return n <= 0 ? lst : (
            lst.length ? drop(n - 1, lst.slice(1)) : []
        );
    }
 
    return lstTest.map(romanValue);
 
})(['MCMXC', 'MDCLXVI', 'MMVIII']);[1990, 1666, 2008](function (lstTest) {
 
    function romanValue(s) {
        return s.length ? function () {
            var parse = [].concat.apply([], glyphs.map(function (g) {
                return 0 === s.indexOf(g) ? [trans[g], s.substr(g.length)] : [];
            }));
            return parse[0] + romanValue(parse[1]);
        }() : 0;
    }
 
    var trans = {
            M: 1E3,
            CM: 900,
            D: 500,
            CD: 400,
            C: 100,
            XC: 90,
            L: 50,
            XL: 40,
            X: 10,
            IX: 9,
            V: 5,
            IV: 4,
            I: 1
        },
        glyphs = Object.keys(trans);
 
    return lstTest.map(romanValue);
 
})([strv, strv, strv, strv]);[1990, 1666, 2008]"
"//returns array with three values
var arrBind = function () {
  return [1, 2, 3]; //return array of three items to assign
};
 
//returns object with three named values
var objBind = function () {
  return {foo: strv, bar: strv, baz: strv};
};
 
//keep all three values
var [a, b, c] = arrBind();//assigns a => 1, b => 2, c => 3
//skip a value
var [a, , c] = arrBind();//assigns a => 1, c => 3
//keep final values together as array
var [a, ...rest] = arrBind();//assigns a => 1, rest => [2, 3]
 
 
//same return name
var {foo, bar, baz} = objBind();//assigns foo => strv
//different return name (ignoring baz)
var {baz: foo, buz: bar} = objBind();//assigns baz => strv
//keep rest of values together as object
var {foo, ...rest} = objBind();//assigns foo => strv}"
"strv.split(strv).reverse().join strv//using chained methods
function reverseStr(s) {
  return s.split('').reverse().join('');
}
 
//fast method using for loop
function reverseStr(s) {
  for (var i = s.length - 1, o = ''; i >= 0; o += s[i--]) { }
  return o;
}
 
//fast method using while loop (faster with long strings in some browsers when compared with for loop)
function reverseStr(s) {
  var i = s.length, o = '';
  while (i--) o += s[i];
  return o;
}(() => {
 
    
    
 
    let reverse1 = s => Array.from(s)
        .reduceRight((a, x) => a + (x !== ' ' ? x : ' <- '), ''),
 
        
        
 
        reverse2 = s => s.split('').reverse().join('');
 
 
    return [reverse1, reverse2]
        .map(f => f(strv));
 
})();[strv, strv]"
" 
obj  = new Proxy({}, 
        { get : function(target, prop) 
            { 
                if(target[prop] === undefined) 
                    return function()  {
                        console.log('an otherwise undefined function!!');
                    };
                else 
                    return target[prop];
            }
        });
obj.f()        ///'an otherwise undefined function!!'
obj.l = function() {console.log(45);};
obj.l();       ///45
 var example = new Object;
example.foo = function () {
  alert(strv);
}
example.bar = function () {
  alert(strv);
}
example.__noSuchMethod__ = function (id, args) {
  alert(strv + id);
  if (args.length != 0)
    alert(strv + args);
}
 
example.foo();        
example.bar();        
example.grill();      
example.ding(strv); 
                      "
"String.prototype.repeat = function(n) {
    return new Array(1 + (n || 0)).join(this);
}
 
console.log(strv.repeat(5));   
console.log(strv.repeat(5));  function nreps(s, n) {
  var o = '';
  if (n < 1) return o;
  while (n > 1) {
    if (n & 1) o += s;
    n >>= 1;
    s += s;
  }
  return o + s;
}
 
nreps('ha', 50000);"
"var obj = Object.create({
    name: 'proto',
    proto: true,
    doNothing: function() {}
  }, {
    name: {value: 'obj', writable: true, configurable: true, enumerable: true},
    obj: {value: true, writable: true, configurable: true, enumerable: true},
    'non-enum': {value: 'non-enumerable', writable: true, enumerable: false},
    doStuff: {value: function() {}, enumerable: true}
});
 

function get_property_names(obj) {
    var properties = [];
    for (var p in obj) {
        properties.push(p);
    }
    return properties;
}
 
get_property_names(obj);
//[strv]
 
Object.getOwnPropertyNames(obj);
//[strv]
 
Object.keys(obj);
//[strv]
 
Object.entries(obj);
//[[strv, function()]]
 "
"(() => {
    'use strict';
 
    
 
    
    const repCycles = xs => {
        const n = xs.length;
        return filter(
            cs => xs === takeCycle(n, cs),
            map(concat, tail(inits(take(quot(n, 2), xs))))
        );
    };
 
    
    const cycleReport = xs => {
        const reps = repCycles(xs);
        return [xs, isNull(reps) ? '(n/a)' : last(reps)];
    };
 
 
    
 
    
    const compose = (f, g) => x => f(g(x));
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    const cons = (x, xs) => [x].concat(xs);
 
    
    const curry = f => a => b => f(a, b);
 
    
    const filter = (f, xs) => xs.filter(f);
 
    
    
    const inits = xs => [
            []
        ]
        .concat((typeof xs === 'string' ? xs.split('') : xs)
            .map((_, i, lst) => lst.slice(0, i + 1)));
 
    
    const intercalate = (s, xs) => xs.join(s);
 
    
    const last = xs => xs.length ? xs.slice(-1)[0] : undefined;
 
    
    const map = (f, xs) => xs.map(f);
 
    
    const isNull = xs => (xs instanceof Array) ? xs.length < 1 : undefined;
 
    
    const quot = (n, m) => Math.floor(n / m);
 
    
    const replicate = (n, a) => {
        let v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    const tail = xs => xs.length ? xs.slice(1) : undefined;
 
    
    const take = (n, xs) => xs.slice(0, n);
 
    
    
    const takeCycle = (n, xs) => {
        const lng = xs.length;
        return concat((lng >= n ? xs : replicate(Math.ceil(n / lng), xs)))
            .slice(0, n);
    };
 
    
    const unlines = xs => xs.join('');
 
 
    
    const samples = [strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv
    ];
 
    return unlines(cons('Longest cycle:',
        map(compose(curry(intercalate)(' -> '), cycleReport), samples)));
})();"
"var fso = new ActiveXObject(strv);
fso.MoveFile('input.txt', 'output.txt');
fso.MoveFile('c:/input.txt', 'c:/output.txt');
fso.MoveFolder('docs', 'mydocs');
fso.MoveFolder('c:/docs', 'c:/mydocs');"
"function foo() {...}
foo.toString();

 Math.sqrt.toString();

 "
"
function Super(name) {
    this.name = name;
    this.superOwn = function() { return 'super owned'; };
}
Super.prototype = {
    constructor: Super
    className: 'super',
    toString: function() { return strv + this.name + strv; },
    doSup: function() { return 'did super stuff'; }
}
 
function Sub() {
    Object.getPrototypeOf(this).constructor.apply(this, arguments);
    this.rest = [].slice.call(arguments, 1);
    this.subOwn = function() { return 'sub owned'; };
}
Sub.prototype = Object.assign(
    new Super('prototype'),
    {
        constructor: Sub
        className: 'sub',
        toString: function() { return strv + this.name + strv; },
        doSub: function() { return 'did sub stuff'; }
    });
 
Object.defineProperty(Sub.prototype, 'shush', {
    value: function() { return ' non-enumerable'; },
    enumerable: false 
});
 
var sup = new Super('sup'),
    sub = new Sub('sub', 0, 'I', 'two');
 
Object.defineProperty(sub, 'quiet', {
    value: function() { return 'sub owned non-enumerable'; },
    enumerable: false
});
 

function get_method_names(obj) {
    var methods = [];
    for (var p in obj) {
        if (typeof obj[p] == 'function') {
            methods.push(p);
        }
    }
    return methods;
}
 
get_method_names(sub);
//[strv]
 

function get_property_names(obj) {
    var properties = [];
    for (var p in obj) {
        properties.push(p);
    }
    return properties;
}
 

function get_method_names(obj) {
    return get_property_names(obj)
        .filter(function(p) {return typeof obj[p] == 'function';});
}
 
get_method_names(sub);
//[strv]
 

Object.getOwnPropertyNames(sub)
    .filter(function(p) {return typeof sub[p] == 'function';})
//[strv]
 

Object.keys(sub)
    .filter(function(p) {return typeof sub[p] == 'function';})
//[strv]
 

Object.entries(sub)
    .filter(function(p) {return typeof p[1] == 'function';})
//[[strv, function () {...}]]"
"function unique(ary) {
    
    var u = ary.concat().sort();
    for (var i = 1; i < u.length; ) {
        if (u[i-1] === u[i])
            u.splice(i,1);
        else
            i++;
    }
    return u;
}
 
var ary = [1, 2, 3, strv, strv, strv, 2, 3, 4, strv, strv, strv, strv];
var uniq = unique(ary);
for (var i = 0; i < uniq.length; i++) 
    print(uniq[i] + """" + typeof(uniq[i]));Array.prototype.unique = function() {
    var u = this.concat().sort();
    for (var i = 1; i < u.length; ) {
        if (u[i-1] === u[i])
            u.splice(i,1);
        else
            i++;
    }
    return u;
}
var uniq = [1, 2, 3, strv, strv, strv, 2, 3, 4, strv, strv, strv].unique();Array.prototype.unique = function() {
   return this.sort().reduce( (a,e) => e === a[a.length-1] ? a : (a.push(e), a), [] )
}Array.prototype.unique = function() {
    return [... new Set(this)]
}function uniq(lst) {
  var u = [],
    dct = {},
    i = lst.length,
    v;
 
  while (i--) {
    v = lst[i], dct[v] || (
      dct[v] = u.push(v)
    );
  }
  u.sort(); 
 
  return u;
}(function () {
    'use strict';
 
    
    function nub(xs) {
 
        
        function Eq(a, b) {
            return a === b;
        }
 
        
        function nubBy(fnEq, xs) {
            var x = xs.length ? xs[0] : undefined;
 
            return x !== undefined ? [x].concat(
                nubBy(fnEq, xs.slice(1)
                    .filter(function (y) {
                        return !fnEq(x, y);
                    }))
            ) : [];
        }
 
        return nubBy(Eq, xs);
    }
 
 
    
 
    return [
        nub('4 3 2 8 0 1 9 5 1 7 6 3 9 9 4 2 1 5 3 2'.split(' '))
        .map(function (x) {
            return Number(x);
        }),
        nub('chthonic eleemosynary paronomasiac'.split(''))
        .join('')
    ]
 
})();"
"var subject = strv;
 


var re_PatternToMatch = /Hello (World)/i; 
var re_PatternToMatch2 = new RegExp(strv, strv);
 

var isMatch = re_PatternToMatch.test(subject);
 




var matches = re_PatternToMatch2.exec(subject);var subject = strv;
 


var newSubject = subject.replace(re_PatternToMatch, strv);"
"
Matrix.prototype.toReducedRowEchelonForm = function() {
    var lead = 0;
    for (var r = 0; r < this.rows(); r++) {
        if (this.columns() <= lead) {
            return;
        }
        var i = r;
        while (this.mtx[i][lead] == 0) {
            i++;
            if (this.rows() == i) {
                i = r;
                lead++;
                if (this.columns() == lead) {
                    return;
                }
            }
        }
 
        var tmp = this.mtx[i];
        this.mtx[i] = this.mtx[r];
        this.mtx[r] = tmp;
 
        var val = this.mtx[r][lead];
        for (var j = 0; j < this.columns(); j++) {
            this.mtx[r][j] /= val;
        }
 
        for (var i = 0; i < this.rows(); i++) {
            if (i == r) continue;
            val = this.mtx[i][lead];
            for (var j = 0; j < this.columns(); j++) {
                this.mtx[i][j] -= val * this.mtx[r][j];
            }
        }
        lead++;
    }
    return this;
}
 
var m = new Matrix([
  [ 1, 2, -1, -4],
  [ 2, 3, -1,-11],
  [-2, 0, -3, 22]
]);
print(m.toReducedRowEchelonForm());
print();
 
m = new Matrix([
  [ 1, 2, 3, 7],
  [-4, 7,-2, 7],
  [ 3, 3, 0, 7]
]);
print(m.toReducedRowEchelonForm());"
"Math.E
Math.PI
Math.sqrt(x)
Math.log(x)
Math.exp(x)
Math.abs(x)
Math.floor(x)
Math.ceil(x)
Math.pow(x,y)"
"var fs = require(strv);
 
var readFile = function(path) {
    return fs.readFileSync(path).toString();
};
 
console.log(readFile('file.txt'));"
"var fso=new ActiveXObject(strv);
var f=fso.OpenTextFile(""c:myfile.txt"",1);
var s=f.ReadAll();
f.Close();
try{alert(s)}catch(e){WScript.Echo(s)}var file = document.getElementById(strv).files.item(0); //a file input element
if (file) {
	var reader = new FileReader();
	reader.readAsText(file, strv);
	reader.onload = loadedFile;
	reader.onerror = errorHandler;
}
function loadedFile(event) {
	var fileString = event.target.result;
	alert(fileString);
}
function errorHandler(event) {
	alert(event);
}
 "
"function parseConfig(config) {
    
    
    var regex = /^([A-Z]+)(.*)$/mg;
    var configObject = {};
 
    
    var match;
    while (match = regex.exec(config)) {
        
        
        
        
        var key = match[1], values = match[2].split(strv);
        if (values.length === 1) {
            configObject[key] = values[0];
        }
        else {
            configObject[key] = values.map(function(value){
                return value.trim();
            });
        }
    }
 
    return configObject;
}  {
  strv: strv,
  strv: strv,
  strv: strv,
  strv: [
    strv,
    strv
  ]
}
 "
"(function () {
 
    var xs = 'Solomon Jason Errol Garry Bernard Barry Stephen'.split(' '),
        ns = [44, 42, 42, 41, 41, 41, 39],
 
        sorted = xs.map(function (x, i) {
            return { name: x, score: ns[i] };
        }).sort(function (a, b) {
            var c = b.score - a.score;
            return c ? c : a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
        }),
 
        names = sorted.map(function (x) { return x.name; }),
        scores = sorted.map(function (x) { return x.score; }),
 
        reversed = scores.slice(0).reverse(),
        unique = scores.filter(function (x, i) {
            return scores.indexOf(x) === i;
        });
 
    
 
    var rankings = function (score, index) {
            return {
                name: names[index],
                score: score,
 
                Ordinal: index + 1,
 
                Standard: function (n) {
                    return scores.indexOf(n) + 1;
                }(score),
 
                Modified: function (n) {
                    return reversed.length - reversed.indexOf(n);
                }(score),
 
                Dense: function (n) {
                    return unique.indexOf(n) + 1;
                }(score),
 
                Fractional: function (n) {
                    return (
                        (scores.indexOf(n) + 1) +
                        (reversed.length - reversed.indexOf(n))
                    ) / 2;
                }(score)
            };
        },
 
        tbl = [
            'Name Score Standard Modified Dense Ordinal Fractional'.split(' ')
        ].concat(scores.map(rankings).reduce(function (a, x) {
            return a.concat([
                [x.name, x.score,
                    x.Standard, x.Modified, x.Dense, x.Ordinal, x.Fractional
                ]
            ]);
        }, [])),
 
        //[[a]] -> bool -> s -> s
        wikiTable = function (lstRows, blnHeaderRow, strStyle) {
            return '{| class=strv ' + (
                strStyle ? 'style=""' + strStyle + '""' : ''
            ) + lstRows.map(function (lstRow, iRow) {
                var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
                return '|-' + strDelim + ' ' + lstRow.map(function (v) {
                    return typeof v === 'undefined' ? ' ' : v;
                }).join(' ' + strDelim + strDelim + ' ');
            }).join('') + '|}';
        };
 
    return wikiTable(tbl, true, 'text-align:center');
 
})();((() => {
    const xs = 'Solomon Jason Errol Garry Bernard Barry Stephen'.split(' '),
        ns = [44, 42, 42, 41, 41, 41, 39];
 
    const sorted = xs.map((x, i) => ({
            name: x,
            score: ns[i]
        }))
        .sort((a, b) => {
            const c = b.score - a.score;
            return c ? c : a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
        });
 
    const names = sorted.map(x => x.name),
        scores = sorted.map(x => x.score),
        reversed = scores.slice(0)
        .reverse(),
        unique = scores.filter((x, i) => scores.indexOf(x) === i);
 
    
 
    
    const rankings = (score, index) => ({
        name: names[index],
        score,
        Ordinal: index + 1,
        Standard: scores.indexOf(score) + 1,
        Modified: reversed.length - reversed.indexOf(score),
        Dense: unique.indexOf(score) + 1,
 
        Fractional: (n => (
            (scores.indexOf(n) + 1) +
            (reversed.length - reversed.indexOf(n))
        ) / 2)(score)
    });
 
    
    const tbl = [
            'Name Score Standard Modified Dense Ordinal Fractional'.split(' ')
        ].concat(scores.map(rankings)
        .reduce((a, x) => a.concat([
            [x.name, x.score,
                x.Standard, x.Modified, x.Dense, x.Ordinal, x.Fractional
            ]
        ]), []));
 
    
    const wikiTable = (lstRows, blnHeaderRow, strStyle) =>
        `{| class=strv ${strStyle ? 'style=""' + strStyle + '""' : ''}
        ${lstRows.map((lstRow, iRow) => {
            const strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
            return '|-' + strDelim + ' ' + lstRow
            .map(v => typeof v === 'undefined' ? ' ' : v)
            .join(' ' + strDelim + strDelim + ' ');
        }).join('')}\n|}`;
 
    return wikiTable(tbl, true, 'text-align:center');
}))();"
"function millis() { 
  return (new Date()).getTime();
}
 
/* Executes function 'func' n times, returns array of execution times. */
function benchmark(n, func, args) {
  var times = [];
  for (var i=0; i<n; i++) {
    var m = millis();
    func.apply(func, args);
    times.push(millis() - m);
  }
  return times;
}"
"function rangeExtraction(list) {
  var len = list.length;
  var out = [];
  var i, j;
 
  for (i = 0; i < len; i = j + 1) {
    
    out.push(list[i]);
 
    
    for (var j = i + 1; j < len && list[j] == list[j-1] + 1; j++);
    j--;
 
    if (i == j) {
      
      out.push(strv);
    } else if (i + 1 == j) {
      
      out.push(strv, list[j], strv);
    } else { 
      
      out.push(strv, list[j], strv);
    }
  }
  out.pop(); 
  return out.join(strv);
}
 

print(rangeExtraction([
  0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
  25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
  37, 38, 39
]));(function () {
    'use strict';
 
    
    var rangeFormat = function (xs) {
        return splitBy(function (a, b) {
                return b - a > 1;
            }, xs)
            .map(rangeString)
            .join(',');
    };
 
    
    var rangeString = function (xs) {
        return xs.length > 2 ? [head(xs), last(xs)].map(show)
            .join('-') : xs.join(',');
    };
 
    
 
    
    
 
    
    var splitBy = function (f, xs) {
        if (xs.length < 2) return [xs];
        var h = head(xs),
            lstParts = xs.slice(1)
            .reduce(function (a, x) {
                var acc = a[0],
                    active = a[1],
                    prev = a[2];
 
                return f(prev, x) ? (
                    [acc.concat([active]), [x], x]
                ) : [acc, active.concat(x), x];
            }, [
                [],
                [h], h
            ]);
        return lstParts[0].concat([lstParts[1]]);
    };
 
    
    var head = function (xs) {
        return xs.length ? xs[0] : undefined;
    };
 
    
    var last = function (xs) {
        return xs.length ? xs.slice(-1)[0] : undefined;
    };
 
    
    var show = function (x) {
        return JSON.stringify(x);
    };
 
    
    return rangeFormat([0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29, 30, 31, 32,
        33, 35, 36, 37, 38, 39
    ]);
})();(() => {
    'use strict';
 
    
    const rangeFormat = xs =>
        splitBy((a, b) => b - a > 1, xs)
        .map(rangeString)
        .join(',');
 
    
    const rangeString = xs =>
        xs.length > 2 ? (
            [head(xs), last(xs)].map(show)
            .join('-')
        ) : xs.join(',')
 
 
    
 
    
    
 
    
    const splitBy = (f, xs) => {
        if (xs.length < 2) return [xs];
        const
            h = head(xs),
            lstParts = xs.slice(1)
            .reduce(([acc, active, prev], x) =>
                f(prev, x) ? (
                    [acc.concat([active]), [x], x]
                ) : [acc, active.concat(x), x], [
                    [],
                    [h],
                    h
                ]);
        return lstParts[0].concat([lstParts[1]]);
    };
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const last = xs => xs.length ? xs.slice(-1)[0] : undefined;
 
    
    const show = x => JSON.stringify(x);
 
    
    return rangeFormat([0, 1, 2, 4, 6, 7, 8, 11, 12, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
        37, 38, 39
    ]);
})();"
" 
/** * @return {boolean} true if (lng, lat) is in bounds */
function contains(bounds, lat, lng) {
    //https://rosettacode.org/wiki/Ray-casting_algorithm
    var count = 0;
    for (var b = 0; b < bounds.length; b++) {
        var vertex1 = bounds[b];
        var vertex2 = bounds[(b + 1) % bounds.length];
        if (west(vertex1, vertex2, lng, lat))
            ++count;
    }
    return count % 2;
 
    /**     * @return {boolean} true if (x,y) is west of the line segment connecting A and B     */
    function west(A, B, x, y) {
        if (A.y <= B.y) {
            if (y <= A.y || y > B.y ||
                x >= A.x && x >= B.x) {
                return false;
            } else if (x < A.x && x < B.x) {
                return true;
            } else {
                return (y - A.y) / (x - A.x) > (B.y - A.y) / (B.x - A.x);
            }
        } else {
            return west(B, A, x, y);
        }
    }
}
 
var square = {name: 'square', bounds: [{x: 0, y: 0}, {x: 20, y: 0}, {x: 20, y: 20}, {x: 0, y: 20}]};
var squareHole = {
    name: 'squareHole',
    bounds: [{x: 0, y: 0}, {x: 20, y: 0}, {x: 20, y: 20}, {x: 0, y: 20}, {x: 5, y: 5}, {x: 15, y: 5}, {x: 15, y: 15}, {x: 5, y: 15}]
};
var strange = {
    name: 'strange',
    bounds: [{x: 0, y: 0}, {x: 5, y: 5}, {x: 0, y: 20}, {x: 5, y: 15}, {x: 15, y: 15}, {x: 20, y: 20}, {x: 20, y: 0}]
};
var hexagon = {
    name: 'hexagon',
    bounds: [{x: 6, y: 0}, {x: 14, y: 0}, {x: 20, y: 10}, {x: 14, y: 20}, {x: 6, y: 20}, {x: 0, y: 10}]
};
 
var shapes = [square, squareHole, strange, hexagon];
var testPoints = [{lng: 10, lat: 10}, {lng: 10, lat: 16}, {lng: -20, lat: 10},
    {lng: 0, lat: 10}, {lng: 20, lat: 10}, {lng: 16, lat: 10}, {lng: 20, lat: 20}];
 
for (var s = 0; s < shapes.length; s++) {
    var shape = shapes[s];
    for (var tp = 0; tp < testPoints.length; tp++) {
        var testPoint = testPoints[tp];
        console.log(JSON.stringify(testPoint) + 'in ' + shape.name + '' + contains(shape.bounds, testPoint.lat, testPoint.lng));
    }
}
 "
"function randomNormal() {
  return Math.cos(2 * Math.PI * Math.random()) * Math.sqrt(-2 * Math.log(Math.random()))
}
 
var a = []
for (var i=0; i < 1000; i++){
  a[i] = randomNormal() / 2 + 1
}"
"#!/usr/bin/env js
 
function main() {
    print(rangeExpand('-6,-3--1,3-5,7-11,14,15,17-20'));
}
 
function rangeExpand(rangeExpr) {
 
    function getFactors(term) {
        var matches = term.match(/(-?[0-9]+)-(-?[0-9]+)/);
        if (!matches) return {first:Number(term)};
        return {first:Number(matches[1]), last:Number(matches[2])};
    }
 
    function expandTerm(term) {
        var factors = getFactors(term);
        if (factors.length < 2) return [factors.first];
        var range = [];
        for (var n = factors.first; n <= factors.last;  n++) {
            range.push(n);
        }
        return range;
    }
 
    var result = [];
    var terms = rangeExpr.split(/,/);
    for (var t in terms) {
        result = result.concat(expandTerm(terms[t]));
    }
 
    return result;
}
 
main();
 (function (strTest) {
    'use strict';
 
    
    function expansion(strExpr) {
 
        
        return [].concat.apply([], strExpr.split(',')
            .map(function (x) {
                return x.split('-')
                    .reduce(function (a, s, i, l) {
 
                        
                        
                        return s.length ? i ? a.concat(
                            parseInt(l[i - 1].length ? s :
                                '-' + s, 10)
                        ) : [+s] : a;
                    }, []);
 
                
            })
            .map(function (r) {
                return r.length > 1 ? range.apply(null, r) : r;
            }));
    }
 
 
    
    function range(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (x, i) {
                return m + i;
            });
    }
 
    return expansion(strTest);
 
})('-6,-3--1,3-5,7-11,14,15,17-20');[-6, -3, -2, -1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20](strTest => {
 
    
    let expansion = strExpr =>
 
        
        [].concat.apply([], strExpr.split(',')
            .map(x => x.split('-')
                .reduce((a, s, i, l) =>
 
                    
                    
                    s.length ? i ? a.concat(
                        parseInt(l[i - 1].length ? s :
                            '-' + s, 10)
                    ) : [+s] : a, [])
 
                
            )
            .map(r => r.length > 1 ? range.apply(null, r) : r)),
 
 
 
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        };
 
 
 
    return expansion(strTest);
 
})('-6,-3--1,3-5,7-11,14,15,17-20');[-6, -3, -2, -1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]"
"
function swap(items, firstIndex, secondIndex) {
  var temp = items[firstIndex];
  items[firstIndex] = items[secondIndex];
  items[secondIndex] = temp;
};
 


function partition(array, from, to) {
  
  var pivotIndex = getRandomInt(from, to),
      pivot = array[pivotIndex];
  swap(array, pivotIndex, to);
  pivotIndex = from;
 
  for(var i = from; i <= to; i++) {
    if(array[i] < pivot) {
      swap(array, pivotIndex, i);
      pivotIndex++;
    }
  };
  swap(array, pivotIndex, to);
 
  return pivotIndex;
};
 

function quickselectRecursive(array, from, to, statistic) {
  if(array.length === 0 || statistic > array.length - 1) {
    return undefined;
  };
 
  var pivotIndex = partition(array, from, to);
  if(pivotIndex === statistic) {
    return array[pivotIndex];
  } else if(pivotIndex < statistic) {
    return quickselectRecursive(array, pivotIndex, to, statistic);
  } else if(pivotIndex > statistic) {
    return quickselectRecursive(array, from, pivotIndex, statistic);
  }
};
 
function quickselectIterative(array, k) {
  if(array.length === 0 || k > array.length - 1) {
    return undefined;
  };
 
  var from = 0, to = array.length,
      pivotIndex = partition(array, from, to);
 
  while(pivotIndex !== k) {
    pivotIndex = partition(array, from, to);
    if(pivotIndex < k) {
      from = pivotIndex;
    } else if(pivotIndex > k) {
      to = pivotIndex;
    }
  };
 
  return array[pivotIndex];
};
 
KthElement = {
  find: function(array, element) {
    var k = element - 1;
    return quickselectRecursive(array, 0, array.length, k);
    
    
  }
} 
var array = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4], 
    ks = Array.apply(null, {length: 10}).map(Number.call, Number);
ks.map(k => { KthElement.find(array, k) });[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];(() => {
    'use strict';
 
    
 
    
    const quickSelect = (k, xxs) => {
        const
            [x, xs] = uncons(xxs),
            [ys, zs] = partition(v => v < x, xs),
            l = length(ys);
 
        return (k < l) ? (
            quickSelect(k, ys)
        ) : (k > l) ? (
            quickSelect(k - l - 1, zs)
        ) : x;
    };
 
 
    
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const length = xs => xs.length;
 
    
    const map = (f, xs) => xs.map(f);
 
    
    
    const partition = (p, xs) =>
        xs.reduce((a, x) =>
            p(x) ? [a[0].concat(x), a[1]] : [a[0], a[1].concat(x)], [
                [],
                []
            ]);
 
    
    const uncons = xs => xs.length ? [xs[0], xs.slice(1)] : undefined;
 
 
    
    const v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4];
 
    return map(i => quickSelect(i, v), enumFromTo(0, length(v) - 1));
})();[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
"(function(){print(strv+arguments.callee.toString().replace(/\s/g,'')+strv);})()var code='var q=String.fromCharCode(39);print(strv)';eval(code)(function(){str=[strv].join(String.fromCharCode(34));str=str.replace(/F/,String.fromCharCode(34)+str+String.fromCharCode(34));console.log(str)})()var a=function () {var b=strv+a.toString()+""a()"";alert(b)};a()(function f() {
 
    return '(' + f.toString() + ')();';
 
})();(function f() {
 
    return '(' + f.toString() + ')();';
 
})();(function f() {
 
    console.log('(' + f.toString() + ')();');
 
})();"
"var f = new Array();
print(f.length);
f.push(1,2);         
f.push(3);
f.shift();
f.shift();
print(f.length);
print(f.shift())
print(f.length == 0);
print(f.shift());"
"var fifo = [];
fifo.push(42); 
fifo.push(43);
var x = fifo.shift(); 
alert(x); function FIFO() {
    this.data = new Array();
 
    this.push  = function(element) {this.data.push(element)}
    this.pop   = function() {return this.data.shift()}
    this.empty = function() {return this.data.length == 0}
 
    this.enqueue = this.push;
    this.dequeue = this.pop;
}"
"(() => {
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const gcd = (x, y) => {
        const _gcd = (a, b) => (b === 0 ? a : _gcd(b, a % b)),
            abs = Math.abs;
        return _gcd(abs(x), abs(y));
    }
 
    
    
    const pythTripleCount = (p, maxPerim) => {
        const xs = range(1, Math.floor(maxPerim / 2));
 
        return  concatMap(x =>
                concatMap(y =>
                concatMap(z =>
                (   (x + y + z     <=  maxPerim ) &&
                    (x * x + y * y === z * z    ) &&
                   p(x,  y,  z)                 ) ? [
                                [x, y, z]
                    ] :         [       ], 
                    xs.slice(y)), xs.slice(x)), xs
                )
                .length;
    };
 
    return [10, 100, 1000]
        .map(n => ({
            maxPerimeter: n,
            triples: pythTripleCount(x => true, n),
            primitives: pythTripleCount((x, y, _) => gcd(x, y) === 1, n)
        }));
})();[{strv:10, strv:0, strv:0}, 
 {strv:100, strv:17, strv:7}, 
 {strv:1000, strv:325, strv:70}]"
"(function () {
 
    
    function properDivisors(n) {
        if (n < 2) return [];
        else {
            var rRoot = Math.sqrt(n),
                intRoot = Math.floor(rRoot),
 
                lows = range(1, intRoot).filter(function (x) {
                    return (n % x) === 0;
                });
 
            return lows.concat(lows.slice(1).map(function (x) {
                return n / x;
            }).reverse().slice((rRoot === intRoot) | 0));
        }
    }
 
    
    function range(m, n) {
        var a = Array(n - m + 1),
            i = n + 1;
        while (i--) a[i - 1] = i;
        return a;
    }
 
    var tblOneToTen = [
            ['Number', 'Proper Divisors', 'Count']
        ].concat(range(1, 10).map(function (x) {
            var ds = properDivisors(x);
 
            return [x, ds.join(', '), ds.length];
        })),
 
        dctMostBelow20k = range(1, 20000).reduce(function (a, x) {
            var lng = properDivisors(x).length;
 
            return lng > a.divisorCount ? {
                n: x,
                divisorCount: lng
            } : a;
        }, {
            n: 0,
            divisorCount: 0
        });
 
 
    
    function wikiTable(lstRows, blnHeaderRow, strStyle) {
        return '{| class=strv ' + (
            strStyle ? 'style=""' + strStyle + '""' : ''
        ) + lstRows.map(function (lstRow, iRow) {
            var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
            return '|-' + strDelim + ' ' + lstRow.map(function (v) {
                return typeof v === 'undefined' ? ' ' : v;
            }).join(' ' + strDelim + strDelim + ' ');
        }).join('') + '|}';
    }
 
    return wikiTable(
        tblOneToTen,
        true
    ) + 'Most proper divisors below 20,000:  ' + JSON.stringify(
        dctMostBelow20k
    );
 
})();(() => {
 
    
    let properDivisors = n => {
            let rRoot = Math.sqrt(n),
                intRoot = Math.floor(rRoot),
                blnPerfectSquare = rRoot === intRoot,
 
                lows = range(1, intRoot)
                .filter(x => (n % x) === 0);
 
            
            
            return lows.concat(lows
                    .map(x => n / x)
                    .reverse()
                    .slice(blnPerfectSquare | 0)
                )
                .slice(0, -1); 
        },
 
        
        range = (m, n) => Array.from({
            length: (n - m) + 1
        }, (_, i) => m + i);
 
 
 
    return {
        properDivisorsOf1to10: range(1, 10)
            .reduce((a, x) => (
                a[x.toString()] = properDivisors(x),
                a
            ), {}),
 
        intMaxDivisorsUnder20k: range(1, 20000)
            .reduce((a, x) => {
                let intDivisors = properDivisors(x)
                    .length;
 
                return intDivisors >= a.divisors ? {
                    max: x,
                    divisors: intDivisors
                } : a;
 
            }, {
                max: 0,
                divisors: 0
            })
    };
 
})();{
  strv:{
    strv:[], strv:[1], strv:[1], strv:[1, 2], strv:[1], 
    strv:[1, 2, 3], strv:[1], strv:[1, 2, 4], strv:[1, 3], strv:[1, 2, 5]
  }, 
  strv:{strv:18480, strv:79}
}"
"if (some_condition) 
    quit();"
"function foo() {
  return arguments.callee.name;
}(function(){alert(arguments.callee.name);}())#!/usr/bin/env node
/*jslint nodejs:true */
 
function main() {
	var program = __filename;
	console.log(strv + program);
}
 
if (!module.parent) { main(); }"
"var Quaternion = (function() {
    
    
    
    function Q(a) {
	a.__proto__ = proto;
	return a;
    }
 
    
    
    
    
    function Quaternion() {
	return Q(Array.prototype.slice.call(arguments, 0, 4));
    }
 
    
    const proto = {
	
	__proto__ : [0,0,0,0],
 
	
	
	get a() this[0],
	get b() this[1],
	get c() this[2],
	get d() this[3],
 
	
	norm : function() Math.sqrt(this.map(function(x) x*x).reduce(function(x,y) x+y)),
	negate : function() Q(this.map(function(x) -x)),
	conjugate : function() Q([ this[0] ].concat(this.slice(1).map(function(x) -x))),
	add : function(x) {
	    if (strv === typeof x) {
		return Q([ this[0] + x ].concat(this.slice(1)));
	    } else {
		return Q(this.map(function(v,i) v+x[i]));
	    }
	},
	mul : function(r) {
	    var q = this;
	    if (strv === typeof r) {
		return Q(q.map(function(e) e*r));
	    } else {
		return Q([ q[0] * r[0] - q[1] * r[1] - q[2] * r[2] - q[3] * r[3],
			   q[0] * r[1] + q[1] * r[0] + q[2] * r[3] - q[3] * r[2],
			   q[0] * r[2] - q[1] * r[3] + q[2] * r[0] + q[3] * r[1],
			   q[0] * r[3] + q[1] * r[2] - q[2] * r[1] + q[3] * r[0] ]);
	    }
	},
	equals : function(q) this.every(function(v,i) v === q[i]),
	toString : function() (this[0] + strv + this[1] + strv+this[2] + strv + this[3] + strv).replace(/\+ -/g, '- ')
    };
 
    Quaternion.prototype = proto;
    return Quaternion;
})();var q = Quaternion(1,2,3,4);
var q1 = Quaternion(2,3,4,5);
var q2 = Quaternion(3,4,5,6);
var r = 7;
 
console.log(strv+q);
console.log(strv+q1);
console.log(strv+q2);
console.log(strv+r);
console.log(strv+q.norm());
console.log(strv+q.negate());
console.log(strv+q.conjugate());
console.log(strv+q.add(r));
console.log(strv+q1.add(q2));
console.log(strv+q.mul(r));
console.log(strv+q1.mul(q2));
console.log(strv+q2.mul(q1));
console.log(strv + (q1.mul(q2).equals(q2.mul(q1)) ? strv : strv) + strv);"
"var probabilities = {
    aleph:  1/5.0,
    beth:   1/6.0,
    gimel:  1/7.0,
    daleth: 1/8.0,
    he:     1/9.0,
    waw:    1/10.0,
    zayin:  1/11.0,
    heth:   1759/27720
};
 
var sum = 0;
var iterations = 1000000;
var cumulative = {};
var randomly = {};
for (var name in probabilities) {
    sum += probabilities[name];
    cumulative[name] = sum;
    randomly[name] = 0;
}
for (var i = 0; i < iterations; i++) {
    var r = Math.random();
    for (var name in cumulative) {
        if (r <= cumulative[name]) {
            randomly[name]++;
            break;
        }
    }
}
for (var name in probabilities) 
    
    WScript.Echo(name + """" + probabilities[name] + """" + randomly[name]/iterations);(() => {
    'use strict';
 
    
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map(row => row[iCol]));
 
    
    const justifyLeft = (n, cFiller, strText) =>
        n > strText.length ? (
            (strText + cFiller.repeat(n))
            .substr(0, n)
        ) : strText;
 
    
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    };
 
    
    const subtract = (x, y) => y - x;
 
    
    const scanl1 = (f, xs) =>
        xs.length > 0 ? scanl(f, xs[0], xs.slice(1)) : [];
 
    
    const scanl = (f, startValue, xs) =>
        xs.reduce((a, x) => {
            const v = f(a.acc, x);
            return {
                acc: v,
                scan: a.scan.concat(v)
            };
        }, {
            acc: startValue,
            scan: [startValue]
        })
        .scan;
 
    
    const unwords = xs => xs.join(' ');
 
 
    
 
    
    const samples = n =>
        Array.from({
            length: n
        }, Math.random);
 
    
    const thresholds = scanl1(
            (a, b) => a + b, [5, 6, 7, 8, 9, 10, 11].map(x => 1 / x)
        )
        .concat(1);
 
    
    const expected = limits =>
        limits.map((x, i, xs) => i > 0 ? (x - xs[i - 1]) : x);
 
    
    const dataBinCounts = (thresholds, samples) => {
        const
            lng = samples.length,
            xs = thresholds
            .map(x => lng - samples.filter(v => v > x)
                .length);
        return zipWith(subtract, [0].concat(xs), xs.concat(lng));
    };
 
    
    const intSamples = 1000000;
 
    
    const aligned = x => justifyLeft(12, ' ', isNaN(x) ? x : x.toFixed(7));
 
    return transpose([
            ['', 'Aleph', 'Beit', 'Gimel', 'Dalet', 'He', 'Vav', 'Zayin', 'Chet']
            .map(curry(justifyLeft)(7, ' ')),
 
            ['Expected'].concat(expected(thresholds))
            .map(aligned),
 
            ['Observed'].concat(dataBinCounts(thresholds, samples(intSamples))
                .map(x => x / intSamples))
            .map(aligned)
        ])
        .map(unwords)
        .join('');
})();"
"function isPrime(n) {
  if (n == 2 || n == 3 || n == 5 || n == 7) {
    return true;
  } else if ((n < 2) || (n % 2 == 0)) {
    return false;
  } else {
    for (var i = 3; i <= Math.sqrt(n); i += 2) {
      if (n % i == 0)
        return false;
    }
    return true;
  }
}"
"function run_factorize(input, output) {
    var n = new BigInteger(input.value, 10);
    var TWO = new BigInteger(strv, 10);
    var divisor = new BigInteger(strv, 10);
    var prod = false;
 
    if (n.compareTo(TWO) < 0) 
        return; 
 
    output.value = strv;
 
    while (true) {
        var qr = n.divideAndRemainder(TWO);
        if (qr[1].equals(BigInteger.ZERO)) {
            if (prod) 
                output.value += strv; 
            else 
                prod = true; 
            output.value += strv;
            n = qr[0];
        }
        else 
            break; 
    }
 
    while (!n.equals(BigInteger.ONE)) {
        var qr = n.divideAndRemainder(divisor);
        if (qr[1].equals(BigInteger.ZERO)) {
            if (prod) 
                output.value += strv; 
            else 
                prod = true; 
            output.value += divisor;
            n = qr[0];
        }
        else 
            divisor = divisor.add(TWO); 
    }
}function run_factorize(n) {
	if (n <= 3)
			return [n];
 
	var ans = [];
	var done = false;
	while (!done)
	{
		if (n%2 === 0){
				ans.push(2);
				n /= 2;
				continue;
		}
		if (n%3 === 0){
				ans.push(3);
				n /= 3;
				continue;
		}
		if ( n === 1)
			return ans;
		var sr = Math.sqrt(n);
		done = true;
		
		for (var i=6; i<=sr; i+=6){
				if (n%(i-1) === 0){ 
						ans.push( (i-1) );
						n /= (i-1);
						done = false;
						break;
				}
				if (n%(i+1) === 0){ 
						ans.push( (i+1) );
						n /= (i+1);
						done = false;
						break;
				}
		}
	}
	ans.push( n );
	return ans;
}function factors(n) {
  if (!n || n < 2)
    return [];
 
  var f = [];
  for (var i = 2; i <= n; i++){
    while (n % i === 0){
      f.push(i);
      n /= i;
    }
  }
 
  return f;
};
 /// <reference path=strv />
 
describe(strv, function() {
  it(strv, function() {
    expect(factors()).toEqual([]);
  });
 
  it(strv, function() {
    expect(factors(1)).toEqual([]);
  });
 
  it(strv, function() {
    expect(factors(2)).toEqual([2]);
  });
 
  it(strv, function() {
    expect(factors(3)).toEqual([3]);
  });
 
  it(strv, function() {
    expect(factors(4)).toEqual([2, 2]);
  });
 
  it(strv, function() {
    expect(factors(5)).toEqual([5]);
  });
 
  it(strv, function() {
    expect(factors(6)).toEqual([2, 3]);
  });
 
  it(strv, function() {
    expect(factors(7)).toEqual([7]);
  });
 
  it(strv, function() {
    expect(factors(8)).toEqual([2, 2, 2]);
  });
 
  it(strv, function() {
    expect(factors(2*2*2*3*3*7*11*17))
      .toEqual([2, 2, 2, 3, 3, 7, 11, 17]);
  });
 
  it(strv, function() {
    expect(factors(997)).toEqual([997]);
  });
});
 "
"function getScaleFactor(v) {
 
  var values = ['0.10','0.18','0.26','0.32','0.38','0.44','0.50','0.54',
                '0.58','0.62','0.66','0.70','0.74','0.78','0.82','0.86',
                '0.90','0.94','0.98','1.00'];
 
  return values[(v * 100 - 1) / 5 | 0];
}"
"function clone(obj){
    if (obj == null || typeof(obj) != 'object')
        return obj;
 
    var temp = {};
    for (var key in obj)
        temp[key] = clone(obj[key]);
    return temp;
}"
"(() => {
    'use strict';
 
    
    const popCount = n =>
        n.toString(2)
        .split('')
        .reduce((a, x) => a + (x === '1' ? 1 : 0), 0);
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
    
    const until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    }
 
 
    
    return {
        popCounts: range(0, 30)
            .map(x => popCount(Math.pow(3, x))),
 
        evenThenOdd: until(
            m => m.evod[0].length >= 30 && m.evod[1].length >= 30,
            m => ({
                x: m.x + 1,
                evod: popCount(m.x) % 2 === 0 ? (
                    [m.evod[0].concat(m.x), m.evod[1]]
                ) : [m.evod[0], m.evod[1].concat(m.x)]
            }), {
                x: 0,
                evod: [
                    [],
                    []
                ]
            }
        ).evod
    };
})();{strv:[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25, 25],
strv:[
[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58], 
[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]]}"
"/* create new Point in one of these ways: *    var p = new Point(x,y); *    var p = new Point(a_point); * default value for x,y is 0 */
function Point() {
    var arg1 = arguments[0];
    var arg2 = arguments[1];
 
    if (arg1 instanceof Point) {
        this.x = arg1.x;
        this.y = arg1.y;
    }
    else { 
        this.x = arg1 == null ? 0 : arg1;
        this.y = arg2 == null ? 0 : arg1;
    } 
 
    this.set_x = function(_x) {this.x = _x;}
    this.set_y = function(_y) {this.y = _y;}
}
 
Point.prototype.print = function() {
    var out = strv + this.x + strv + this.y + strv;
    print(out);
}
 
/* create new Circle in one of these ways: *    var c = new Circle(x,y,r); *    var c = new Circle(a_circle); *    var c = new Circle(a_point,r); * default value for x,y,r is 0 */
function Circle() {
    var arg1 = arguments[0];
    var arg2 = arguments[1];
    var arg3 = arguments[2];
 
    if (arg1 instanceof Circle) {
        this.x = arg1.x;
        this.y = arg1.y;
        this.r = arg1.r;
    }
    else if (arg1 instanceof Point) {
        this.x = arg1.x;
        this.y = arg1.y;
        this.r = arg2 == null ? 0 : arg2;
    }
    else { 
        this.x = arg1 == null ? 0 : arg1;
        this.y = arg2 == null ? 0 : arg2;
        this.r = arg3 == null ? 0 : arg3;
    } 
 
    this.set_x = function(_x) {this.x = _x;}
    this.set_y = function(_y) {this.y = _y;}
    this.set_r = function(_r) {this.r = _r;}
}
 
Circle.prototype.print = function() {
    var out = strv + this.x + strv + this.y + strv + this.r + strv;
    print(out);
}"
"function Card(pip, suit) {
    this.pip = pip;
    this.suit = suit; 
 
    this.toString = function () {
        return this.pip + ' ' + this.suit;
    };
}
 
function Deck() {
    var pips = '2 3 4 5 6 7 8 9 10 Jack Queen King Ace'.split(' ');
    var suits = 'Clubs Hearts Spades Diamonds'.split(' ');
    this.deck = [];
    for (var i = 0; i < suits.length; i++)
        for (var j = 0; j < pips.length; j++)
            this.deck.push(new Card(pips[j], suits[i]));
 
    this.toString = function () {
        return '[' + this.deck.join(', ') + ']';
    };
 
    this.shuffle = function () {
        for (var i = 0; i < this.deck.length; i++)
            this.deck[i] = this.deck.splice(
                parseInt(this.deck.length * Math.random()), 1, this.deck[i])[0];
    };
 
    this.deal = function () {
        return this.deck.shift();
    };
}"
"(function (p) {
  return [
    p.split('').reverse().join(''),
 
    p.split(' ').map(function (x) {
        return x.split('').reverse().join('');
    }).join(' '),
 
    p.split(' ').reverse().join(' ')
 
  ].join('');
 
})('rosetta code phrase reversal');(() => {
    'use strict';
 
    
    const words = s => s.split(/\s+/);
 
    
    const unwords = xs => xs.join(' ');
 
    
    const reverse = xs =>
        typeof xs === 'string' ? (
            xs.split('')
            .reverse()
            .join('')
        ) : xs.slice(0)
        .reverse();
 
    
    const map = (f, xs) => xs.map(f);
 
 
    
    
    const show = x => JSON.stringify(x, null, 2);
 
    const strPhrase = 'rosetta code phrase reversal';
 
    return show({
        reversedString: reverse(strPhrase),
        eachWordReversed: unwords(map(reverse, words(strPhrase))),
        wordOrderReversed: unwords(reverse(words(strPhrase)))
    });
})();"
"public array function powerset(required array data)
{
  var ps = [strv];
  var d = arguments.data;
  var lenData = arrayLen(d);
  var lenPS = 0;
  for (var i=1; i LTE lenData; i++)
  {
    lenPS = arrayLen(ps);
    for (var j = 1; j LTE lenPS; j++)
    {
      arrayAppend(ps, listAppend(ps[j], d[i]));
    }
  }
  return ps;
}
 
var res = powerset([1,2,3,4]);function powerset(ary) {
    var ps = [[]];
    for (var i=0; i < ary.length; i++) {
        for (var j = 0, len = ps.length; j < len; j++) {
            ps.push(ps[j].concat(ary[i]));
        }
    }
    return ps;
}
 
var res = powerset([1,2,3,4]);
 
load('json2.js');
print(JSON.stringify(res));(function () {
 
   
 
    function powerset(xs) {
        return xs.reduceRight(function (a, x) {
            return a.concat(a.map(function (y) {
                return [x].concat(y);
            }));
        }, [[]]);
    }
 
 
    
    return {
        '[1,2,3] ->': powerset([1, 2, 3]),
        'empty set ->': powerset([]),
        'set which contains only the empty set ->': powerset([[]])
    }
 
})();{
 strv:[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]],
 strv:[[]],
 strv:[[], [[]]]
}(() => {
    'use strict';
 
    
    const powerset = xs =>
        xs.reduceRight((a, x) => a.concat(a.map(y => [x].concat(y))), [
            []
        ]);
 
 
    
    return {
        '[1,2,3] ->': powerset([1, 2, 3]),
        'empty set ->': powerset([]),
        'set which contains only the empty set ->': powerset([
            []
        ])
    };
})(){strv:[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]], 
strv:[[]], 
strv:[[], [[]]]}"
"(function () {
    'use strict';
 
    
    var permutationsWithRepetition = function (n, as) {
        return as.length > 0 ? (
            foldl1(curry(cartesianProduct)(as), replicate(n, as))
        ) : [];
    };
 
 
    
 
    
    var cartesianProduct = function (xs, ys) {
        return [].concat.apply([], xs.map(function (x) {
            return [].concat.apply([], ys.map(function (y) {
                return [
                    [x].concat(y)
                ];
            }));
        }));
    };
 
    
    var foldl1 = function (f, xs) {
        return xs.length > 0 ? xs.slice(1)
            .reduce(f, xs[0]) : [];
    };
 
    
    var replicate = function (n, a) {
        var v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    var curry = function (f) {
        return function (a) {
            return function (b) {
                return f(a, b);
            };
        };
    };
 
    
    
    var show = function (x) {
        return JSON.stringify(x);
    }; //, null, 2);
 
    return show(permutationsWithRepetition(2, [1, 2, 3]));
 
    //--> [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
})();[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]](function () {
    'use strict';
 
    
    var nthPermutationWithRepn = function (xs, groupSize, index) {
        var intBase = xs.length,
            intSetSize = Math.pow(intBase, groupSize),
            lastIndex = intSetSize - 1; 
 
        if (intBase < 1 || index > lastIndex) return undefined;
 
        var baseElements = unfoldr(function (m) {
                var v = m.new,
                    d = Math.floor(v / intBase);
                return {
                    valid: d > 0,
                    value: xs[v % intBase],
                    new: d
                };
            }, index),
            intZeros = groupSize - baseElements.length;
 
        return intZeros > 0 ? replicate(intZeros, xs[0])
            .concat(baseElements) : baseElements;
    };
 
    
 
    
    var unfoldr = function (mf, v) {
        var xs = [];
        return [until(function (m) {
                return !m.valid;
            }, function (m) {
                var m2 = mf(m);
                return m2.valid && (xs = [m2.value].concat(xs)), m2;
            }, {
                valid: true,
                value: v,
                new: v
            })
            .value
        ].concat(xs);
    };
 
    
    var until = function (p, f, x) {
        var v = x;
        while (!p(v)) {
            v = f(v);
        }
        return v;
    };
 
    
    var replicate = function (n, a) {
        var v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    var show = function (x) {
        return JSON.stringify(x);
    }; //, null, 2);
 
    
    var curry = function (f) {
        for (var lng = arguments.length,
                args = Array(lng > 1 ? lng - 1 : 0),
                iArg = 1; iArg < lng; iArg++) {
            args[iArg - 1] = arguments[iArg];
        }
 
        var intArgs = f.length,
            go = function (xs) {
                return xs.length >= intArgs ? f.apply(null, xs) : function () {
                    return go(xs.concat([].slice.apply(arguments)));
                };
            };
        return go([].slice.call(args, 1));
    };
 
    
    var range = function (m, n) {
        return Array.from({
            length: Math.floor(n - m) + 1
        }, function (_, i) {
            return m + i;
        });
    };
 
    
    
    return show(range(30, 35)
        .map(curry(nthPermutationWithRepn)(['X', 'Y', 'Z'], 4)));
})();(() => {
    'use strict';
 
    
 
    
    
    const replicateM = (n, f) => {
        const loop = x => x <= 0 ? [
            []
        ] : liftA2(cons, f, loop(x - 1));
        return loop(n);
    };
 
    
    
    const liftA2 = (f, a, b) =>
        listApply(a.map(curry(f)), b);
 
    
    
    const listApply = (fs, xs) =>
        [].concat.apply([], fs.map(f =>
        [].concat.apply([], xs.map(x => [f(x)]))));
 
    
    const curry = f => a => b => f(a, b);
 
    
    const cons = (x, xs) => [x].concat(xs);
 
    
    const show = JSON.stringify;
 
    
    return show(
        replicateM(2, [1, 2, 3])
    );
    
})();[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]](() => {
    'use strict';
 
    
    const nthPermutationWithRepn = (xs, groupSize, index) => {
        const
            intBase = xs.length,
            intSetSize = Math.pow(intBase, groupSize),
            lastIndex = intSetSize - 1; 
 
        if (intBase < 1 || index > lastIndex) return undefined;
 
        const
            baseElements = unfoldr(m => {
                const
                    v = m.new,
                    [d, r] = quotRem(v, intBase);
                return {
                    valid: d > 0,
                    value: xs[r],
                    new: d
                };
            }, index),
            intZeros = groupSize - baseElements.length;
 
        return intZeros > 0 ? (
            (replicate(intZeros, xs[0]))
            .concat(baseElements)
        ) : baseElements;
    };
 
 
    
 
    
    const unfoldr = (mf, v) => {
        var xs = [];
        return [until(
                m => !m.valid,
                m => {
                    const m2 = mf(m);
                    return (
                        m2.valid && (xs = [m2.value].concat(xs)),
                        m2
                    );
                }, {
                    valid: true,
                    value: v,
                    new: v,
                }
            )
            .value
        ].concat(xs);
    };
 
    
    const until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    }
 
    
    const replicate = (n, a) => {
        let v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    const quotRem = (m, n) => [Math.floor(m / n), m % n];
 
    
    const show = x => JSON.stringify(x); //, null, 2);
 
    
    const curry = (f, ...args) => {
        const intArgs = f.length,
            go = xs =>
            xs.length >= intArgs ? (
                f.apply(null, xs)
            ) : function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
    
    
    return show(
        range(30, 35)
        .map(
            curry(nthPermutationWithRepn)(['X', 'Y', 'Z'], 4)
        )
    );
})();"
"var array = [1,2,3];
return array[Math.floor(Math.random() * array.length)];"
"(() => {
    'use strict';
 
    
    const shuffleCycleLength = deckSize =>
        firstCycle(shuffle, range(1, deckSize))
        .all.length;
 
    
    const shuffle = xs =>
        concat(zip.apply(null, splitAt(div(length(xs), 2), xs)));
 
    
    const firstCycle = (f, x) =>
        until(
            m => EqArray(x, m.current),
            m => {
                const fx = f(m.current);
                return {
                    current: fx,
                    all: m.all.concat([fx])
                };
            }, {
                current: f(x),
                all: [x]
            }
        );
 
    
    
    const EqArray = (xs, ys) => {
        const [nx, ny] = [xs.length, ys.length];
        return nx === ny ? (
            nx > 0 ? (
                xs[0] === ys[0] && EqArray(xs.slice(1), ys.slice(1))
            ) : true
        ) : false;
    };
 
    
 
    
    const zip = (xs, ys) =>
        xs.slice(0, Math.min(xs.length, ys.length))
        .map((x, i) => [x, ys[i]]);
 
    
    const concat = xs => [].concat.apply([], xs);
 
    
    const splitAt = (n, xs) => [xs.slice(0, n), xs.slice(n)];
 
    
    const div = (x, y) => Math.floor(x / y);
 
    
    const until = (p, f, x) => {
        const go = x => p(x) ? x : go(f(x));
        return go(x);
    }
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    
    const length = xs => xs.length;
 
    
    const maximumBy = (f, xs) =>
        xs.reduce((a, x) => a === undefined ? x : (
            f(x, a) > 0 ? x : a
        ), undefined);
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map((row) => row[iCol]));
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    
    const replicateS = (n, s) => {
        let v = s,
            o = '';
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    const justifyRight = (n, cFiller, strText) =>
        n > strText.length ? (
            (replicateS(n, cFiller) + strText)
            .slice(-n)
        ) : strText;
 
    
    return transpose(transpose([
                ['Deck', 'Shuffles']
            ].concat(
                [8, 24, 52, 100, 1020, 1024, 10000]
                .map(n => [n.toString(), shuffleCycleLength(n)
                    .toString()
                ])))
            .map(col => { 
                const width = length(
                    maximumBy((a, b) => length(a) - length(b), col)
                ) + 2;
 
                return col.map(x => justifyRight(width, ' ', x));
            }))
        .map(row => row.join(''))
        .join('');
})();"
" 
const EPOCH = 1500, TRAINING = 1, TRANSITION = 2, SHOW = 3;
 
var perceptron;
var counter = 0;
var learnRate = 0.02;
var state = TRAINING;
 
function setup() {
    createCanvas( 800, 600 );
    clearBack();
    perceptron = new Perceptron( 2 );
}
 
function draw() {
    switch( state ) {
        case TRAINING: training(); break;
        case TRANSITION: transition(); break;
        case SHOW: show(); break;
    }
}
 
function clearBack() {
    background( 0 );
    stroke( 255 );
    strokeWeight( 4 );
 
    var x = width;
    line( 0, 0, x, lineDef( x ) );
}
 
function transition() {
    clearBack();
    state = SHOW;
}
 
function lineDef( x ) {
    return .75 * x;
}
 
function training() {
    var a = random( width ),
        b = random( height );
 
    lDef = lineDef( a ) > b ? -1 : 1;
 
    perceptron.setInput( [a, b] );
    perceptron.feedForward();
    var pRes = perceptron.getOutput();
    var match = (pRes == lDef);
    var clr;
 
    if( !match ) {
        var err = ( pRes - lDef ) * learnRate;
        perceptron.adjustWeights( err );
 
        clr = color( 255, 0, 0 );
 
    } else {
        clr = color( 0, 255, 0 );
    }
 
    noStroke();
    fill( clr );
    ellipse( a, b, 4, 4 );
 
    if( ++counter == EPOCH ) state = TRANSITION;
}
 
function show() {
    var a = random( width ),
        b = random( height ),
        clr;
 
    perceptron.setInput( [a, b] );
    perceptron.feedForward();
    var pRes = perceptron.getOutput();
 
    if( pRes < 0 )
        clr = color( 255, 0, 0 );
    else 
        clr = color( 0, 255, 0 );
 
    noStroke();
    fill( clr );
    ellipse( a, b, 4, 4 );
}
 
function Perceptron( inNumber ) {
    this.inputs = [];
    this.weights = [];
    this.output;
    this.bias = 1;
 
    
    for( var i = 0; i < inNumber + 1; i++ ) {
        this.weights.push( Math.random() );
    };
 
    this.activation = function( a ) {
        return( Math.tanh( a ) < .5 ? 1 : -1 );
    }
 
    this.feedForward = function() {
        var sum = 0;
        for( var i = 0; i < this.inputs.length; i++ ) {
            sum += this.inputs[i] * this.weights[i];
        }
 
        sum += this.bias * this.weights[this.weights.length - 1];
 
        this.output = this.activation( sum );
    }
 
    this.getOutput = function() {
        return this.output;
    }
 
    this.setInput= function( inputs ) {
        this.inputs = [];
        for( var i = 0; i < inputs.length; i++ ) {
            this.inputs.push( inputs[i] );
        }
    }
 
    this.adjustWeights = function( err ) {
        for( var i = 0; i < this.weights.length - 1; i++ ) {
            this.weights[i] += err * this.inputs[i];
        }
    }
}
 "
"function is_perfect(n)
{
 var sum = 1, i, sqrt=Math.floor(Math.sqrt(n));
 for (i = sqrt-1; i>1; i--)
 {
  if (n % i == 0) {
   sum += i + n/i;
  }
 }
 if(n % sqrt == 0)
  sum += sqrt + (sqrt*sqrt == n ? 0 : n/sqrt);
 return sum === n;
}
 
 
var i;
for (i = 1; i < 10000; i++)
{
 if (is_perfect(i))
  print(i);
}(function (nFrom, nTo) {
 
  function perfect(n) {
    return n === range(1, n - 1).reduce(
      function (a, x) {
        return n % x ? a : a + x;
      }, 0
    );
  }
 
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
  return range(nFrom, nTo).filter(perfect);
 
})(1, 10000);[6, 28, 496, 8128](function (nFrom, nTo) {
 
  function perfect(n) {
    var lows = range(1, Math.floor(Math.sqrt(n))).filter(function (x) {
      return (n % x) === 0;
    });
 
    return n > 1 && lows.concat(lows.map(function (x) {
      return n / x;
    })).reduce(function (a, x) {
      return a + x;
    }, 0) / 2 === n;
  }
 
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
  return range(nFrom, nTo).filter(perfect)
 
})(1, 10000);[6, 28, 496, 8128](function (nFrom, nTo) {
 
  
  
 
  return chain(
    rng(nFrom, nTo),
 
    function mPerfect(n) {
      return (chain(
        rng(1, Math.floor(Math.sqrt(n))),
        function (y) {
          return (n % y) === 0 && n > 1 ? [y, n / y] : [];
        }
      ).reduce(function (a, x) {
        return a + x;
      }, 0) / 2 === n) ? [n] : [];
    }
 
  );
 
  /******************************************************************/
 
  
  function chain(xs, f) {
    return [].concat.apply([], xs.map(f));
  }
 
  function rng(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
})(1, 10000);[6, 28, 496, 8128]((nFrom, nTo) => {
 
    
    let perfect = n => {
            let lows = range(1, Math.floor(Math.sqrt(n)))
                .filter(x => (n % x) === 0);
 
            return n > 1 && lows.concat(lows.map(x => n / x))
                .reduce((a, x) => (a + x), 0) / 2 === n;
        },
 
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        };
 
    return range(nFrom, nTo)
        .filter(perfect);
 
})(1, 10000);[6, 28, 496, 8128]"
"function pso_init(y) {
  var nDims= y.min.length;
  var pos=[], vel=[], bpos=[], bval=[];
  for (var j= 0; j<y.nParticles; j++) {
    pos[j]= bpos[j]= y.min;
    var v= []; for (var k= 0; k<nDims; k++) v[k]= 0;
    vel[j]= v;
    bval[j]= Infinity}
  return {
	iter: 0,
	gbpos: Infinity,
	gbval: Infinity,
	min: y.min,
	max: y.max,
	parameters: y.parameters,
	pos: pos,
	vel: vel,
	bpos: bpos,
	bval: bval,
        nParticles: y.nParticles,
        nDims: nDims}
}
 
function pso(fn, state) {
  var y= state;
  var p= y.parameters;
  var val=[], bpos=[], bval=[], gbval= Infinity, gbpos=[];
  for (var j= 0; j<y.nParticles; j++) {
    
    val[j]= fn.apply(null, y.pos[j]);
    
    if (val[j] < y.bval[j]) {
      bpos[j]= y.pos[j];
      bval[j]= val[j];
    } else {
      bpos[j]= y.bpos[j];
      bval[j]= y.bval[j]}
    if (bval[j] < gbval) {
      gbval= bval[j];
      gbpos= bpos[j]}}
  var rg= Math.random(), vel=[], pos=[];
  for (var j= 0; j<y.nParticles; j++) {
    
    var rp= Math.random(), ok= true;
    vel[j]= [];
    pos[j]= [];
    for (var k= 0; k < y.nDims; k++) {
      vel[j][k]= p.omega*y.vel[j][k] + p.phip*rp*(bpos[j]-y.pos[j]) + p.phig*rg*(gbpos-y.pos[j]);
      pos[j][k]= y.pos[j]+vel[j][k];
      ok= ok && y.min[k]<pos[j][k] && y.max>pos[j][k];}
    if (!ok)
      for (var k= 0; k < y.nDims; k++)
        pos[j][k]= y.min[k] + (y.max[k]-y.min[k])*Math.random()}
  return {
	iter: 1+y.iter,
	gbpos: gbpos,
	gbval: gbval,
	min: y.min,
	max: y.max,
	parameters: y.parameters,
	pos: pos,
	vel: vel,
	bpos: bpos,
	bval: bval,
        nParticles: y.nParticles,
        nDims: y.nDims}
}
 
function display(text) {
  if (document) {
    var o= document.getElementById('o');
    if (!o) {
      o= document.createElement('pre');
      o.id= 'o';
      document.body.appendChild(o)}
    o.innerHTML+= text+'';
    window.scrollTo(0,document.body.scrollHeight);
  }
  if (console.log) console.log(text)
}
 
function reportState(state) {
  var y= state;
  display('');
  display('Iteration: '+y.iter);
  display('GlobalBestPosition: '+y.gbpos);
  display('GlobalBestValue: '+y.gbval);
}
 
function repeat(fn, n, y) {
  var r=y, old= y;
  if (Infinity == n)
    while ((r= fn(r)) != old) old= r;
  else
    for (var j= 0; j<n; j++) r= fn(r);
  return r
}
 
function mccormick(a,b) {
  return Math.sin(a+b) + Math.pow(a-b,2) + (1 + 2.5*b - 1.5*a)
}
 
state= pso_init({
  min: [-1.5,-3], max:[4,4],
  parameters: {omega: 0, phip: 0.6, phig: 0.3},
  nParticles: 100});
 
reportState(state);
 
state= repeat(function(y){return pso(mccormick,y)}, 40, state);
 
reportState(state); 
Iteration: 0
GlobalBestPosition: Infinity
GlobalBestValue: Infinity
 
Iteration: 40
GlobalBestPosition: -0.5134004259016365,-1.5512442672625184
GlobalBestValue: -1.9114053788600853"
"<html><head><title>Permutations</title></head>
<body><pre id=strv></pre>
<script type=strv>
var d = document.getElementById('result');
 
function perm(list, ret)
{
    if (list.length == 0) {
        var row = document.createTextNode(ret.join(' ') + '');
        d.appendChild(row);
        return;
    }
    for (var i = 0; i < list.length; i++) {
        var x = list.splice(i, 1);
        ret.push(x);
        perm(list, ret);
        ret.pop();
        list.splice(i, 0, x);
    }
}
 
perm([1, 2, 'A', 4], []);
</script></body></html> 
function perm(a) {
    if (a.length < 2) return [a];
    var c, d, b = [];
    for (c = 0; c < a.length; c++) {
        var e = a.splice(c, 1),
            f = perm(a);
        for (d = 0; d < f.length; d++) b.push([e].concat(f[d]));
        a.splice(c, 0, e[0])
    } return b
}
 
console.log(perm(['Aardvarks', 'eat', 'ants']).join(""""));
 Aardvarks,eat,ants
Aardvarks,ants,eat
eat,Aardvarks,ants
eat,ants,Aardvarks
ants,Aardvarks,eat
ants,eat,Aardvarks(function () {
    'use strict';
 
    
    var permutations = function (xs) {
        return xs.length ? concatMap(function (x) {
            return concatMap(function (ys) {
                return [[x].concat(ys)];
            }, permutations(delete_(x, xs)));
        }, xs) : [[]];
    };
 
    
 
    
    var concatMap = function (f, xs) {
        return [].concat.apply([], xs.map(f));
    };
 
    
    var delete_ = function (x, xs) {
        return deleteBy(function (a, b) {
            return a === b;
        }, x, xs);
    };
 
    
    var deleteBy = function (f, x, xs) {
        return xs.length > 0 ? f(x, xs[0]) ? xs.slice(1) : 
        [xs[0]].concat(deleteBy(f, x, xs.slice(1))) : [];
    };
 
    
    return permutations(['Aardvarks', 'eat', 'ants']);
})();[[strv, strv, strv], [strv, strv, strv],
 [strv, strv, strv], [strv, strv, strv], 
[strv, strv, strv], [strv, strv, strv]](() => {
    'use strict';
 
    
    const permutations = xs =>
        xs.length ? concatMap(x => concatMap(ys => [
                [x].concat(ys)
            ],
            permutations(delete_(x, xs))), xs) : [
            []
        ];
 
    
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
    //
    
    
    
 
    
    const delete_ = (x, xs) =>
        xs.length > 0 ? (
            (x === xs[0]) ? (
                xs.slice(1)
            ) : [xs[0]].concat(delete_(x, xs.slice(1)))
        ) : [];
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    return permutations(['Aardvarks', 'eat', 'ants']);
})();[[strv, strv, strv], [strv, strv, strv],
 [strv, strv, strv], [strv, strv, strv], 
[strv, strv, strv], [strv, strv, strv]]"
"(() => {
    'use strict';
 
    
 
    
    
    const pascalMatrix = (f, n) =>
        chunksOf(n, map(compose(bc, f), range([
            [0, 0],
            [n - 1, n - 1]
        ])));
 
    
    
    const bc = ([n, k]) => enumFromTo(1, k)
        .reduce((a, x) => Math.floor((a * (n - x + 1)) / x), 1);
 
 
    
 
    
    const chunksOf = (n, xs) =>
        xs.reduce((a, _, i, xs) =>
            i % n ? a : a.concat([xs.slice(i, i + n)]), []);
 
    
    
    
    const show = JSON.stringify;
 
    
    const swap = ([a, b]) => [b, a];
 
    
    const compose = (f, g) => x => f(g(x));
 
    
    const curry = f => a => b => f(a, b);
 
    
    const cons = (x, xs) => [x].concat(xs);
 
    
    const map = (f, xs) => xs.map(f);
 
    
    const id = x => x;
 
    
    
    const ap = (fs, xs) => //
        [].concat.apply([], fs.map(f => //
            [].concat.apply([], xs.map(x => [f(x)]))));
 
    
    
    
    
    const traverse = (f, xs) => {
        const cons_f = (a, x) => ap(f(x)
            .map(curry(cons)), a);
        return xs.reduceRight(cons_f, [
            []
        ]);
    };
 
    
    
    const sequence = xs => traverse(id, xs);
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const range = ([a, b]) => {
        const [as, bs] = a instanceof Array ? [a, b] : [
                [a],
                [b]
            ],
            an = as.length;
        return (an === bs.length) ? (
            an > 1 ? (
                sequence(as.map((_, i) => enumFromTo(as[i], bs[i])))
            ) : enumFromTo(a, b)
        ) : undefined;
    };
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    };
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    const unlines = xs => xs.join('');
 
 
    
    const matrixSize = 5;
 
    return unlines(
        zipWith(
            (s, xs) => unlines(concat([
                [s], xs.map(show), ['']
            ])), [strv, strv, strv],
            ap(
                map(
                    f => curry(pascalMatrix)(f), [
                        id,                    
                        swap,                  
                        ([a, b]) => [a + b, a] 
                    ]
                ), [matrixSize]
            )
        )
    );
})();"
"var f1 = function (x) { return x * 2; },
    f2 = function (x) { return x * x; },
 
    fs = function (f, s) {
        return function (s) {
            return s.map(f);
        }
    },
 
    fsf1 = fs(f1),
    fsf2 = fs(f2);
 

    [
        fsf1([0, 1, 2, 3]),
        fsf2([0, 1, 2, 3]),
 
        fsf1([2, 4, 6, 8]),
        fsf2([2, 4, 6, 8])
    ]var f1 = function (x) { return x * 2; },
    f2 = function (x) { return x * x; },
 
    fs = function (f) {
        return function () {
            return Array.prototype.slice.call(
                arguments
            ).map(f);
        }
    },
 
    fsf1 = fs(f1),
    fsf2 = fs(f2);
 

    [
        fsf1(0, 1, 2, 3, 4),
        fsf2(0, 1, 2),
        fsf1(2, 4, 6, 8, 10, 12),
        fsf2(2, 4, 6, 8)
    ](() => {
    'use strict';
 
    
 
    
    const curry = f => a => b => f(a, b);
 
    
    const map = curry((f, xs) => xs.map(f));
 
 
    
 
    const
        f1 = x => x * 2,
        f2 = x => x * x,
 
        fs = map,
 
        fsf1 = fs(f1),
        fsf2 = fs(f2);
 
    
    return [
        fsf1([0, 1, 2, 3]),
        fsf2([0, 1, 2, 3]),
 
        fsf1([2, 4, 6, 8]),
        fsf2([2, 4, 6, 8])
    ];
})();(() => {
    'use strict';
 
    
 
    
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat(Array.from(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const map = curry((f, xs) => xs.map(f));
 
    
    const
        f1 = x => x * 2,
        f2 = x => x * x,
 
        fs = map,
 
        fsf1 = fs(f1),
        fsf2 = fs(f2);
 
    
    return [
        fsf1([0, 1, 2, 3]),
        fsf2([0, 1, 2, 3]),
 
        fsf1([2, 4, 6, 8]),
        fsf2([2, 4, 6, 8])
    ];
})();"
"function getImageData(url, callback) {
	var img = document.createElement('img');
	var canvas = document.createElement('canvas');
 
	img.onload = function () {
		canvas.width = img.width;
		canvas.height = img.height;
		var ctx = canvas.getContext('2d');
		ctx.drawImage(img, 0, 0);
		callback(ctx.getImageData(0, 0, img.width, img.height));
	};
 
	img.src = url;
}
 
function compare(firstImage, secondImage, callback) {
	getImageData(firstImage, function (img1) {
		getImageData(secondImage, function (img2) {
			if (img1.width !== img2.width || img1.height != img2.height) {
				callback(NaN);
				return;
			}
 
			var diff = 0;
 
			for (var i = 0; i < img1.data.length / 4; i++) {
				diff += Math.abs(img1.data[4 * i + 0] - img2.data[4 * i + 0]) / 255;
				diff += Math.abs(img1.data[4 * i + 1] - img2.data[4 * i + 1]) / 255;
				diff += Math.abs(img1.data[4 * i + 2] - img2.data[4 * i + 2]) / 255;
			}
 
			callback(100 * diff / (img1.width * img1.height * 3));
		});
	});
}
 
compare('Lenna50.jpg', 'Lenna100.jpg', function (result) {
	console.log(result);
});"
"
function pascalTriangle (rows) {
 
	
	this.rows = rows;
 
	
	this.triangle = new Array();
	for (var r = 0; r < rows; r++) {
		this.triangle[r] = new Array();
		for (var i = 0; i <= r; i++) {
			if (i == 0 || i == r)
				this.triangle[r][i] = 1;
			else
				this.triangle[r][i] = this.triangle[r-1][i-1]+this.triangle[r-1][i];
		}
	}
 
	
	this.print = function(base) {
		if (!base)
			base = 10;
 
		
		var digits = function(n,b) {
			var d = 0;
			while (n >= 1) {
				d++;
				n /= b;
			}
			return d;
		}
 
		
		var spacing = digits(this.triangle[this.rows-1][Math.round(this.rows/2)],base);
 
		
		var insertSpaces = function(s) {
			var buf = strv;
			while (s > 0) {
				s--;
				buf += strv;
			}
			return buf;
		}
 
		
		for (var r = 0; r < this.triangle.length; r++) {
			var l = strv;
			for (var s = 0; s < Math.round(this.rows-1-r); s++) {
				l += insertSpaces(spacing);
			}
			for (var i = 0; i < this.triangle[r].length; i++) {
				if (i != 0)
					l += insertSpaces(spacing-Math.ceil(digits(this.triangle[r][i],base)/2));
				l += this.triangle[r][i].toString(base);
				if (i < this.triangle[r].length-1)
					l += insertSpaces(spacing-Math.floor(digits(this.triangle[r][i],base)/2));
			}
			print(l);
		}
	}
 
}
 

var tri = new pascalTriangle(4);
tri.print();

tri = new pascalTriangle(8);
tri.print(16);(function (n) {
    'use strict';
 
    
 
    
    function pascal(n) {
        return range(1, n - 1)
            .reduce(function (a) {
                var lstPreviousRow = a.slice(-1)[0];
 
                return a
                    .concat(
                        [zipWith(
                            function (a, b) {
                                return a + b
                            }, 
                            [0].concat(lstPreviousRow),
                            lstPreviousRow.concat(0)
                        )]
                    );
            }, [[1]]);
    }
 
 
 
    
 
    
    function zipWith(f, xs, ys) {
        return xs.length === ys.length ? (
            xs.map(function (x, i) {
                return f(x, ys[i]);
            })
        ) : undefined;
    }
 
    
    function range(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (x, i) {
                return m + i;
            });
    }
 
    
    var lstTriangle = pascal(n);
 
 
    
 
    
    function wikiTable(lstRows, blnHeaderRow, strStyle) {
        return '{| class=strv ' + (
                strStyle ? 'style=""' + strStyle + '""' : ''
            ) + lstRows.map(function (lstRow, iRow) {
                var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
                return '|-' + strDelim + ' ' + lstRow.map(function (
                        v) {
                        return typeof v === 'undefined' ? ' ' : v;
                    })
                    .join(' ' + strDelim + strDelim + ' ');
            })
            .join('') + '|}';
    }
 
    var lstLastLine = lstTriangle.slice(-1)[0],
        lngBase = (lstLastLine.length * 2) - 1,
        nWidth = lstLastLine.reduce(function (a, x) {
            var d = x.toString()
                .length;
            return d > a ? d : a;
        }, 1) * lngBase;
 
    return [
    wikiTable(
            lstTriangle.map(function (lst) {
                return lst.join(';;')
                    .split(';');
            })
            .map(function (line, i) {
                var lstPad = Array((lngBase - line.length) / 2);
                return lstPad.concat(line)
                    .concat(lstPad);
            }),
            false,
            'text-align:center;width:' + nWidth + 'em;height:' + nWidth +
            'em;table-layout:fixed;'
    ),
 
    JSON.stringify(lstTriangle)
  ].join('');
})(7);[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]](() => {
    'use strict';
 
    
    let pascal = n =>
            range(1, n - 1)
            .reduce(a => {
                let lstPreviousRow = a.slice(-1)[0];
 
                return a
                    .concat([zipWith((a, b) => a + b,
                        [0].concat(lstPreviousRow),
                        lstPreviousRow.concat(0)
                    )]);
            }, [
                [1]
            ]);
 
    
 
    
    let range = (m, n, step) => {
                let d = (step || 1) * (n >= m ? 1 : -1);
                return Array.from({
                    length: Math.floor((n - m) / d) + 1
                }, (_, i) => m + (i * d));
            },
 
        
        zipWith = (f, xs, ys) =>
            xs.length === ys.length ? (
                xs.map((x, i) => f(x, ys[i]))
            ) : undefined;
 
    
    return pascal(7)
        .reduceRight((a, x) => {
            let strIndent = a.indent;
 
            return {
                rows: strIndent + x
                    .map(n => ('    ' + n).slice(-4))
                    .join('') + '' + a.rows,
                indent: strIndent + '  '
            };
        }, {
            rows: '',
            indent: ''
        }).rows;
})();"
"function Stack() {
  this.dataStore = [];
  this.top = 0;
  this.push = push;
  this.pop = pop;
  this.peek = peek;
  this.length = length;
}
 
function push(element) {
  this.dataStore[this.top++] = element;
}
 
function pop() {
  return this.dataStore[--this.top];
}
 
function peek() {
  return this.dataStore[this.top-1];
}
 
function length() {
  return this.top;
}
 
var infix = strv;
infix = infix.replace(/\s+/g, ''); 
 
var s = new Stack();
var ops = strv;
var precedence = {strv:4, strv:3, strv:3, strv:2, strv:2};
var associativity = {strv:strv, strv:strv, strv:strv, strv:strv, strv:strv};
var token;
var postfix = strv;
var o1, o2;
 
for (var i = 0; i < infix.length; i++) {
  token = infix[i];
  if (token >= strv && token <= strv) { 
    postfix += token + strv;
  }
  else if (ops.indexOf(token) != -1) { 
    o1 = token;
    o2 = s.peek();
    while (ops.indexOf(o2)!=-1 && ( 
      
      (associativity[o1] == strv && (precedence[o1] <= precedence[o2]) ) || 
      
      
      (associativity[o1] == strv && (precedence[o1] < precedence[o2])) 
      )){
        postfix += o2 + strv; 
        s.pop(); 
        o2 = s.peek(); 
    }
    s.push(o1); 
  }
  else if (token == strv) { 
    s.push(token); 
  }
  else if (token == strv) { 
    while (s.peek() != strv){ 
      postfix += s.pop() + strv;
    }
    s.pop(); 
  }
}
while (s.length()>0){
  postfix += s.pop() + strv;
}
print(postfix);"
"const Associativity = {
    /** a / b / c = (a / b) / c */
    left: 0,
    /** a ^ b ^ c = a ^ (b ^ c) */
    right: 1,
    /** a + b + c = (a + b) + c = a + (b + c) */
    both: 2,
};
const operators = {
    '+': { precedence: 2, associativity: Associativity.both },
    '-': { precedence: 2, associativity: Associativity.left },
    '*': { precedence: 3, associativity: Associativity.both },
    '/': { precedence: 3, associativity: Associativity.left },
    '^': { precedence: 4, associativity: Associativity.right },
};
class NumberNode {
    constructor(text) { this.text = text; }
    toString() { return this.text; }
}
class InfixNode {
    constructor(fnname, operands) {
        this.fnname = fnname;
        this.operands = operands;
    }
    toString(parentPrecedence = 0) {
        const op = operators[this.fnname];
        const leftAdd = op.associativity === Associativity.right ? 0.01 : 0;
        const rightAdd = op.associativity === Associativity.left ? 0.01 : 0;
        if (this.operands.length !== 2) throw Error(strv);
        const result = this.operands[0].toString(op.precedence + leftAdd)
            +` ${this.fnname} ${this.operands[1].toString(op.precedence + rightAdd)}`;
        if (parentPrecedence > op.precedence) return `( ${result} )`;
        else return result;
    }
}
function rpnToTree(tokens) {
    const stack = [];
    console.log(`input = ${tokens}`);
    for (const token of tokens.split(strv)) {
        if (token in operators) {
            const op = operators[token], arity = 2; 
            if (stack.length < arity) throw Error(strv);
            stack.push(new InfixNode(token, stack.splice(stack.length - arity)));
        }
        else stack.push(new NumberNode(token));
        console.log(`read ${token}, stack = [${stack.join(strv)}]`);
    }
    if (stack.length !== 1) throw Error(strv + stack);
    return stack[0];
}
const tests = [
    [strv, strv],
    [strv, strv],
    [strv, strv] 
];
for (const [inp, oup] of tests) {
    const realOup = rpnToTree(inp).toString();
    console.log(realOup === oup ? strv : strv);
}"
" 
var onmessage = function(event) {   
    postMessage({strv : event.data.n,
                 strv : factor(event.data.n),
                 strv : event.data.id});
};
 
function factor(n) {
    var factors = [];
    for(p = 2; p <= n; p++) {
        if((n % p) == 0) {
            factors[factors.length] = p;
            n /= p;
        }
    }
    return factors;
}
  
var numbers = [12757923, 12878611, 12757923, 15808973, 15780709, 197622519];
var workers = [];
var worker_count = 0;
 
var results = [];
 
for(var i = 0; i < numbers.length; i++) {
    worker_count++;
    workers[i] = new Worker(strv);
    workers[i].onmessage = accumulate;
    workers[i].postMessage({n: numbers[i], id: i});
}
 
function accumulate(event) {
    n = event.data.n;
    factors = event.data.factors;
    id = event.data.id;
    console.log(n + strv + factors);
    results[id] = {n:n, factors:factors};
    
    workers[id].terminate();
    worker_count--;
    if(worker_count == 0)
	reduce();
}
 
function reduce() {
    answer = 0;
    for(i = 1; i < results.length; i++) {
	min = results[i].factors[0];
	largest_min = results[answer].factors[0];
	if(min > largest_min)
	    answer = i;
    }
    n = results[answer].n;
    factors = results[answer].factors;
    console.log(strv + n + strv + factors);
}
 "
"function isPangram(s) {
    var letters = strv
    
    s = s.toLowerCase().replace(/[^a-z]/g,'')
    for (var i = 0; i < 26; i++)
        if (s.indexOf(letters[i]) < 0) return false
    return true
}
 
console.log(isPangram(strv))  
console.log(isPangram(strv))  (() => {
    'use strict';
 
    
    let isPangram = s => {
        let lc = s.toLowerCase();
 
        return 'abcdefghijklmnopqrstuvwxyz'
            .split('')
            .filter(c => lc.indexOf(c) === -1)
            .length === 0;
    };
 
    
    return [
        'is this a pangram',
        'The quick brown fox jumps over the lazy dog'
    ].map(isPangram);
 
})();"
"function isPalindrome(str) {
  return str === str.split(strv).reverse().join(strv);
}
 
console.log(isPalindrome(strv));var isPal = str => str === str.split(strv).reverse().join(strv);(function (strSample) {
 
    
    let isPalindrome = s =>
        s.split('')
        .reverse()
        .join('') === s;
 
 
 
    
 
    
    let lowerCaseNoSpace = s =>
        concatMap(c => c !== ' ' ? [c.toLowerCase()] : [],
            s.split(''))
        .join(''),
 
        
        concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
 
    return isPalindrome(
        lowerCaseNoSpace(strSample)
    );
 
 
})(strv);"
"(() => {
    'use strict';
 
    
 
    
    const compare = (xs, ys) => xs <= ys;
 
 
    
    return [
        compare([1, 2, 1, 3, 2], [1, 2, 0, 4, 4, 0, 0, 0]),
        compare([1, 2, 0, 4, 4, 0, 0, 0], [1, 2, 1, 3, 2])
    ];
 
    
})()
 [false, true]"
"var e = '3 4 2 * 1 5 - 2 3 ^ ^ / +'
var s=[], e=e.split(' ')
for (var i in e) {
	var t=e[i], n=+t
	if (n == t)
		s.push(n)
	else {
		var o2=s.pop(), o1=s.pop()
		switch (t) {
			case '+': s.push(o1+o2); break;
			case '-': s.push(o1-o2); break;
			case '*': s.push(o1*o2); break;
			case '/': s.push(o1/o2); break;
			case '^': s.push(Math.pow(o1,o2)); break;
		}
	}
	document.write(t, ': ', s, '<br>')
}var e = '3 4 2 * 1 5 - 2 3 ^ ^ / +'
eval: {
	document.write(e, '<br>')
	var s=[], e=e.split(' ')
	for (var i in e) {
		var t=e[i], n=+t
		if (!t) continue
		if (n == t)
			s.push(n)
		else {
			if ('+-*/^'.indexOf(t) == -1) {
				document.write(t, ': ', s, '<br>', 'Unknown operator!<br>')
				break eval
			}
			if (s.length<2) {
				document.write(t, ': ', s, '<br>', 'Insufficient operands!<br>')
				break eval
			}
			var o2=s.pop(), o1=s.pop()
			switch (t) {
				case '+': s.push(o1+o2); break
				case '-': s.push(o1-o2); break
				case '*': s.push(o1*o2); break
				case '/': s.push(o1/o2); break
				case '^': s.push(Math.pow(o1,o2))
			}
		}
		document.write(t, ': ', s, '<br>')
	}
	if (s.length>1) {
		document.write('Insufficient operators!<br>')
	}
}"
"(function () {
  'use strict';
 
  
  function partitions(a1, a2, a3) {
    var n = a1 + a2 + a3;
 
    return combos(range(1, n), n, [a1, a2, a3]);
  }
 
  function combos(s, n, xxs) {
    if (!xxs.length) return [[]];
 
    var x = xxs[0],
        xs = xxs.slice(1);
 
    return mb( choose(s, n, x),                 function (l_rest) {
    return mb( combos(l_rest[1], (n - x), xs),  function (r) {
      
      
      return [ [l_rest[0]].concat(r) ];
 
    })});
  }
 
  function choose(aa, n, m) {
    if (!m) return [[[], aa]];
 
    var a = aa[0],
        as = aa.slice(1);
 
    return n === m ? (
      [[aa, []]]
    ) : (
      choose(as, n - 1, m - 1).map(function (xy) {
        return [[a].concat(xy[0]), xy[1]];
      }).concat(choose(as, n - 1, m).map(function (xy) {
        return [xy[0], [a].concat(xy[1])];
      }))
    );
  }
 
  
 
  
  function mb(xs, f) {
    return [].concat.apply([], xs.map(f));
  }
 
  
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
  
 
  return partitions(2, 0, 2);
 
})();[[[1, 2], [], [3, 4]], 
 [[1, 3], [], [2, 4]],
 [[1, 4], [], [2, 3]],
 [[2, 3], [], [1, 4]],
 [[2, 4], [], [1, 3]],
 [[3, 4], [], [1, 2]]]"
" 
function calcPass (pass, nonce) {
	var flag = true;
	var num1 = 0x0;
	var num2 = 0x0;
	var password = parseInt(pass, 10);
 
	for (var c in nonce) {
		c = nonce[c];
		if (c!='0') {
			if (flag) num2 = password;
			flag = false;
		}
		switch (c) {
			case '1':
				num1 = num2 & 0xFFFFFF80;
				num1 = num1 >>> 7;
				num2 = num2 << 25;
				num1 = num1 + num2;
				break;
			case '2':
				num1 = num2 & 0xFFFFFFF0;
				num1 = num1 >>> 4;
				num2 = num2 << 28;
				num1 = num1 + num2;
				break;
			case '3':
				num1 = num2 & 0xFFFFFFF8;
				num1 = num1 >>> 3;
				num2 = num2 << 29;
				num1 = num1 + num2;
				break;
			case '4':
				num1 = num2 << 1;
				num2 = num2 >>> 31;
				num1 = num1 + num2;
				break;
			case '5':
				num1 = num2 << 5;
				num2 = num2 >>> 27;
				num1 = num1 + num2;
				break;
			case '6':
				num1 = num2 << 12;
				num2 = num2 >>> 20;
				num1 = num1 + num2;
				break;
			case '7':
				num1 = num2 & 0x0000FF00;
				num1 = num1 + (( num2 & 0x000000FF ) << 24 );
				num1 = num1 + (( num2 & 0x00FF0000 ) >>> 16 );
				num2 = ( num2 & 0xFF000000 ) >>> 8;
				num1 = num1 + num2;
				break;
			case '8':
				num1 = num2 & 0x0000FFFF;
				num1 = num1 << 16;
				num1 = num1 + ( num2 >>> 24 );
				num2 = num2 & 0x00FF0000;
				num2 = num2 >>> 8;
				num1 = num1 + num2;
				break;
			case '9':
				num1 = ~num2;
				break;
			case '0':
				num1 = num2;
				break;
		}
		num2 = num1;
	}
	return (num1 >>> 0).toString();
}
 
exports.calcPass = calcPass;
 
console.log ('openpass initialization');
function testCalcPass (pass, nonce, expected) {
	var res = calcPass (pass, nonce);
	var m = pass + ' ' + nonce + ' ' + res + ' ' + expected;
	if (res == parseInt(expected, 10))
		console.log ('PASS '+m);
	else
		console.log ('FAIL '+m);
}
 
testCalcPass ('12345', '603356072', '25280520');
testCalcPass ('12345', '410501656', '119537670');
testCalcPass ('12345', '630292165', '4269684735');
testCalcPass ('12345', '523781130', '537331200');
 "
"function sorter(table, options) {
    opts = {}
    opts.ordering = options.ordering || 'lexicographic';
    opts.column   = options.column || 0;
    opts.reverse  = options.reverse || false;
 
    
}
 
sorter(the_data, {reverse: true, ordering: 'numeric'});function sorter(table, ordering = strv, column = 0, reverse = false) {
    
}
 
sorter(the_data,strv);"
"<html style=strv>
  <head>
    <title>Fragment Shader WebGL Example</title>
    <!-- This use of <script> elements is so that we can have multiline text
         without quoting it inside of JavaScript; the web browser doesn't
         actually do anything besides store the text of these. -->
    <script id=strv>
      precision highp float;
      uniform float u_time;
      void main(void) {
        // some gobbledegook
        vec3 foo = vec3(pow(gl_FragCoord.xy, vec2(1.0 + sin(dot(vec4(1.0, 100.0, 0.0, 0.0), gl_FragCoord)))), 0.0);
        foo *= mat3(1.2, 3.9, 1.4, 4.1, 0.2, 1.4, 2.5, 1.6, 7.2);
 
        gl_FragColor = vec4(mod(foo + vec3(u_time), 1.0), 1.0);
      }
    </script>
    <script id=strv>
      attribute vec3 a_position;
      attribute vec4 a_color;
      varying vec4 v_color;
      void main(void) {
        gl_Position = vec4(a_position, 1.0);
        v_color = a_color;
      }
    </script>
    <script type=strv>
      function getShader(gl, id) {
        var scriptElement = document.getElementById(id);
        
        var shader;
        shader= gl.createShader(gl[scriptElement.type.replace('text/x-','').toUpperCase()]);
        
        gl.shaderSource(shader, scriptElement.textContent);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
          throw new Error(gl.getShaderInfoLog(shader));
        return shader;
      }
    </script>
  </head>
  <body style=strv>
    <canvas id=strv></canvas>
    <script type=strv>
      var canvas = document.getElementById(strv);
 
      
      var gl = canvas.getContext(strv)
            || canvas.getContext(strv);
      if (!gl)
        throw new Error(strv);
 
      
      var shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, getShader(gl, strv));
      gl.attachShader(shaderProgram, getShader(gl, strv));
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
        throw new Error(gl.getProgramInfoLog(shaderProgram));
 
      
      gl.useProgram(shaderProgram);
 
      
      var positionAttr = gl.getAttribLocation(shaderProgram, strv);
      
      gl.enableVertexAttribArray(positionAttr);
 
      var timeUniform = gl.getUniformLocation(shaderProgram, strv);
 
      
      var vertices;
      var positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices = [
        -0.5, -0.5, 0,
        +0.5, -0.5, 0,
        -0.5, +0.5, 0
      ]), gl.STATIC_DRAW);
      var numVertices = vertices.length / 3; 
 
      
      gl.clearColor(0.3, 0.3, 0.3, 1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.viewport(0, 0, gl.drawingBufferWidth || canvas.width,
                        gl.drawingBufferHeight || canvas.height);
 
      //Specify the array data to render. 
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionAttr, 3, gl.FLOAT, false, 0, 0);
 
      var t0 = Date.now();
      function frame() {
        gl.uniform1f(timeUniform, (Date.now() - t0) / 1000);
 
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, numVertices);
 
        var e;
        while (e = gl.getError())
          console.log(strv, e);
 
      }
      setInterval(frame, 1000/20);
    </script>
  </body>
</html>"
"var fs = require('fs'), print = require('sys').print;
fs.readFile('./unixdict.txt', 'ascii', function (err, data) {
    var is_ordered = function(word){return word.split('').sort().join('') === word;},
        ordered_words = data.split('').filter(is_ordered).sort(function(a, b){return a.length - b.length}).reverse(),
        longest = [], curr = len = ordered_words[0].length, lcv = 0;
    while (curr === len){
        longest.push(ordered_words[lcv]);
        curr = ordered_words[++lcv].length;
    };
    print(longest.sort().join(', ') + '');
});var http = require('http');
 
http.get({
  host: 'www.puzzlers.org',
  path: '/pub/wordlists/unixdict.txt'
}, function(res) {
  var data = '';
  res.on('data', function(chunk) {
    data += chunk;
  });
  res.on('end', function() {
    var words = data.split('');
    var max = 0;
    var ordered = [];
    words.forEach(function(word) {
      if (word.split('').sort().join('') != word) return;
      if (word.length == max) {
        ordered.push(word);
      } else if (word.length > max) {
        ordered = [word];
        max = word.length;
      }
    });
    console.log(ordered.join(', '));
  });
});"
"(() => {
    'use strict';
 
    
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const deleteFirst = (x, xs) =>
        xs.length > 0 ? (
            x === xs[0] ? (
                xs.slice(1)
            ) : [xs[0]].concat(deleteFirst(x, xs.slice(1)))
        ) : [];
 
    
    const flatten = t => (t instanceof Array ? concatMap(flatten, t) : [t]);
 
    
    const unwords = xs => xs.join(' ');
 
    
    const words = s => s.split(/\s+/);
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    };
 
    //------------------------------------------------------------------------
 
    
 
    
    const disjointOrder = (ms, ns) =>
        flatten(
            zipWith(
                (a, b) => a.concat(b),
                segments(ms, ns),
                ns.concat('')
            )
        );
 
    
    const segments = (ms, ns) => {
        const dct = ms.reduce((a, x) => {
            const wds = a.words,
                blnFound = wds.indexOf(x) !== -1;
 
            return {
                parts: a.parts.concat(blnFound ? [a.current] : []),
                current: blnFound ? [] : a.current.concat(x),
                words: blnFound ? deleteFirst(x, wds) : wds,
            };
        }, {
            words: ns,
            parts: [],
            current: []
        });
 
        return dct.parts.concat([dct.current]);
    };
 
    
    
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map((row) => row[iCol]));
 
    
    const maximumBy = (f, xs) =>
        xs.reduce((a, x) => a === undefined ? x : (
            f(x, a) > 0 ? x : a
        ), undefined);
 
    
    
    const curry = (f, ...args) => {
        const intArgs = f.length,
            go = xs =>
            xs.length >= intArgs ? (
                f.apply(null, xs)
            ) : function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const justifyLeft = (n, cFiller, strText) =>
        n > strText.length ? (
            (strText + replicateS(n, cFiller))
            .substr(0, n)
        ) : strText;
 
    
    const replicateS = (n, s) => {
        let v = s,
            o = '';
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
 
    
    return transpose(transpose([{
                M: 'the cat sat on the mat',
                N: 'mat cat'
            }, {
                M: 'the cat sat on the mat',
                N: 'cat mat'
            }, {
                M: 'A B C A B C A B C',
                N: 'C A C A'
            }, {
                M: 'A B C A B D A B E',
                N: 'E A D A'
            }, {
                M: 'A B',
                N: 'B'
            }, {
                M: 'A B',
                N: 'B A'
            }, {
                M: 'A B B A',
                N: 'B A'
            }].map(dct => [
                dct.M, dct.N,
                unwords(disjointOrder(words(dct.M), words(dct.N)))
            ]))
            .map(col => {
                const width = maximumBy((a, b) => a.length > b.length, col)
                    .length;
                return col.map(curry(justifyLeft)(width, ' '));
            }))
        .map(
            ([a, b, c]) => a + '  ->  ' + b + '  ->  ' + c
        )
        .join('');
})();"
"if (object === null) {
  alert(strv);
  
}
 
typeof null === strv; "
"var bases = [2, 8, 10, 16, 24];
for (var n = 0; n <= 33; n++) {
    var row = [];
    for (var i = 0; i < bases.length; i++)
        row.push( n.toString(bases[i]) );
    print(row.join(', '));
}"
"function endGame(progress) {
    var scoreId = progress.scoreId,
        result = 'You took ' + progress.count + ' attempts to put the digits in order!';
    if (progress.abort === true) {
        result = 'Game aborted.';
    }
    document.getElementById(scoreId).innerHTML = result;
}
 
function reverseFirstN(arr, n) {
    var reversed = arr.slice(0, n).reverse();
    return reversed.concat(arr.slice(n));
}
 
function isSorted(arr) {
    return arr.slice(0).sort().toString() === arr.toString();
}
 
function gameLoop(progress) {
    if (isSorted(progress.arr)) {
        endGame(progress);
    } else {
        var n = parseInt(window.prompt('How many elements to reverse?', ''), 10);
        if (isNaN(n)) {
            progress.abort = true;
        } else {
            progress.arr = reverseFirstN(progress.arr, n);
            progress.innerHTML += '<p>' + progress.arr + '</p>';
            progress.count += 1;
        }
        if (progress.abort !== true) {
            
            setTimeout(function () {
                gameLoop(progress);
            }, 1);
        }
    }
}
 
function knuth_shuffle(a) {
    var n = a.length,
        r,
        temp;
    while (n > 1) {
        r = Math.floor(n * Math.random());
        n -= 1;
        temp = a[n];
        a[n] = a[r];
        a[r] = temp;
    }
    return a;
}
 
function playGame(startId, progressId, scoreId) {
    var progress = document.getElementById(progressId);
    progress.arr = knuth_shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    document.getElementById(startId).innerHTML = '<p>' + progress.arr.toString() + '</p>';
 
    progress.count = 0;
    progress.scoreId = scoreId;
 
    
    setTimeout(function () {
        gameLoop(progress);
    }, 1);
}
 
playGame('start', 'progress', 'score');"
"function caStep(old) {
  var old = [0].concat(old, [0]); 
  var state = []; 
 
  for (var i=1; i<old.length-1; i++) {
    switch (old[i-1] + old[i+1]) {
      case 0: state[i-1] = 0; break;
      case 1: state[i-1] = (old[i] == 1) ? 1 : 0; break;
      case 2: state[i-1] = (old[i] == 1) ? 0 : 1; break;
    }
  }
  return state;
}alert(caStep([0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0]));"
"function nthRoot(num, nArg, precArg) {
  var n = nArg || 2;
  var prec = precArg || 12;
 
  var x = 1; 
  for (var i=0; i<prec; i++) {
    x = 1/n * ((n-1)*x + (num / Math.pow(x, n-1)));
  }
 
  return x;
}"
"+strv; 
+strv; 
 

+strv; 
+strv; parseInt(strv, 16);
parseInt(strv, 16);
parseInt(strv, 8);
parseInt(021, 8);
parseInt(strv, 10);
parseInt(15.99, 10);
parseInt(strv, 16);
parseInt(strv, 2);
parseInt(strv, 10);
parseInt(strv, 10);
parseInt(strv, 10);
parseInt(strv, 13);parseInt(strv, 8); 
parseInt(strv, 2);   parseInt(strv, 16);
parseInt(strv, 16);
parseInt(strv, 16);
parseInt(-10, 16);
parseInt(-15.1, 10)
parseInt(strv, 8);
parseInt(strv, 10);
parseInt(strv, 2);
parseInt(strv, 10);
parseInt(strv, 13);parseInt(strv, 16);parseInt(strv); 
parseInt(strv); "
"function non_continuous_subsequences(ary) {
    var non_continuous = new Array();
    for (var i = 0; i < ary.length; i++) {
        if (! is_array_continuous(ary[i])) {
            non_continuous.push(ary[i]);
        }
    }
    return non_continuous;
}
 
function is_array_continuous(ary) {
    if (ary.length < 2)
        return true;
    for (var j = 1; j < ary.length; j++) {
        if (ary[j] - ary[j-1] != 1) {
            return false;
        }
    }
    return true;
}
 
load('json2.js'); /* http://www.json.org/js.html */
 
print(JSON.stringify( non_continuous_subsequences( powerset([1,2,3,4]))));"
"function makeList(separator) {
  var counter = 1;
 
  function makeItem(item) {
    return counter++ + separator + item + """";
  }
 
  return makeItem(strv) + makeItem(strv) + makeItem(strv);
}
 
console.log(makeList(strv));"
"var code='var q=String.fromCharCode(39);print(strv == readline())'; eval(code)var oFSO = new ActiveXObject(strv);
function readfile(fname) {
	var h = oFSO.OpenTextFile(fname, 1, false);
	var result = h.ReadAll();
	h.Close();
	return result;
}
 
if (0 === WScript.Arguments.UnNamed.Count) {
	WScript.Echo(WScript.ScriptName,strv);
	WScript.Quit();
}
 

var self = readfile(WScript.ScriptFullName);

var whatever = readfile(WScript.Arguments.UnNamed(0));
 

WScript.Echo(self === whatever ? strv : strv);
 "
" 
var nsort = function(input) {
  var e = function(s) {
    return (' ' + s + ' ').replace(/[\s]+/g, ' ').toLowerCase().replace(/[\d]+/, function(d) {
      d = '' + 1e20 + d;
      return d.substring(d.length - 20);
    });
  };
  return input.sort(function(a, b) {
    return e(a).localeCompare(e(b));
  });
};
 
console.log(nsort([
  strv,
  ""file9.txt"",
  strv,
  strv
]));

 "
"function isNarc(x) {
    var str = x.toString(),
        i,
        sum = 0,
        l = str.length;
    if (x < 0) {
        return false;
    } else {
        for (i = 0; i < l; i++) {
            sum += Math.pow(str.charAt(i), l);
        }
    }
    return sum == x;
}
function main(){
    var n = []; 
    for (var x = 0, count = 0; count < 25; x++){
        if (isNarc(x)){
            n.push(x);
            count++;
        }
    }
    return n.join(' '); 
}(() => {
    'use strict';
 
    
    const digits = n => n.toString()
        .split('')
        .map(x => parseInt(x, 10));
 
    
    const pow = Math.pow;
 
    
    const isNarc = n => {
        const
            ds = digits(n),
            len = ds.length;
 
        return ds.reduce((a, x) =>
            a + pow(x, len), 0) === n;
    };
 
    
    const until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    };
 
    return until(
            x => x.narc.length > 24,
            x => ({
                n: x.n + 1,
                narc: (isNarc(x.n) ? x.narc.concat(x.n) : x.narc)
            }), {
                n: 0,
                narc: []
            }
        )
        .narc
})();[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474, 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315](() => {
    'use strict';
 
    
 
    
    const narcissiOfLength = n =>
        n > 0 ? filter(curry(isDaffodil)(n), digitPowerSums(n)) : [0];
 
    
 

const isDaffodil = (e, n) => {
    const
        powerSum = (n, xs) => xs.reduce((a, x) => a + Math.pow(x, n), 0),
        digitList = n => (n > 0) ? (
            cons((n % 10), digitList(Math.floor(n / 10)))
        ) : [],
        ds = digitList(n);
    return e === ds.length && n === powerSum(e, ds);
};
 
    
 
    
    
 
    
    const digitPowerSums = nDigits => {
        const
            digitPowers = map(x => [x, pow(x, nDigits)], enumFromTo(0, 9)),
            treeGrowth = (n, parentPairs) => (n > 0) ? (
                treeGrowth(n - 1,
                    isNull(parentPairs) ? (
                        digitPowers
                    ) : concatMap(([parentDigit, parentSum]) =>
                        map(([leafDigit, leafSum]) => //
                            [leafDigit, parentSum + leafSum],
                            take(parentDigit + 1, digitPowers)
                        ),
                        parentPairs
                    ))
            ) : parentPairs;
        return map(snd, treeGrowth(nDigits, []));
    };
 
    
 
    
    const enumFromTo = (m, n, step) => {
        const d = (step || 1) * (n >= m ? 1 : -1);
        return Array.from({
            length: Math.floor((n - m) / d) + 1
        }, (_, i) => m + (i * d));
    };
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const cons = (x, xs) => [x].concat(xs);
 
    
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const filter = (f, xs) => xs.filter(f);
 
    
    const map = curry((f, xs) => xs.map(f));
 
    
    const isNull = xs => (xs instanceof Array) ? xs.length < 1 : undefined;
 
    
    const length = xs => xs.length;
 
    
    const pow = Math.pow
 
    
    const take = (n, xs) => xs.slice(0, n);
 
    
    
    
    const show = JSON.stringify;
 
    
    const snd = tpl => Array.isArray(tpl) ? tpl[1] : undefined;
 
 
    
 
    
 
    return show(
        //digitPowerSums(3)
        concatMap(narcissiOfLength, enumFromTo(0, 7))
    );
})();"
"k = 26
s = k.toString(16) //gives 1a
i = parseInt('1a',16) //gives 26
//optional special case for hex:
i = +('0x'+s) //hexadecimal base 16, if s='1a' then i=26. 
var baselist = strv, listbase = [];
for(var i = 0; i < baselist.length; i++) listbase[baselist[i]] = i; 
function basechange(snumber, frombase, tobase)
{
 var i, t, to = new Array(Math.ceil(snumber.length * Math.log(frombase) / Math.log(tobase))), accumulator;
 if(1 < frombase < baselist.length || 1 < tobase < baselist.length) console.error(strv);
 while(snumber[0] == baselist[0] && snumber.length > 1) snumber = snumber.substr(1); 
 console.log(strv, snumber, strv, frombase, strv, tobase, strv,
             parseInt(snumber, frombase).toString(tobase));
 for(i = snumber.length - 1, inexp = 1; i > -1; i--, inexp *= frombase)
  for(accumulator = listbase[snumber[i]] * inexp, t = to.length - 1; accumulator > 0 || t >= 0; t--)
  {
   accumulator += listbase[to[t] || 0];
   to[t] = baselist[(accumulator % tobase)  || 0];
   accumulator = Math.floor(accumulator / tobase);
  }
 return to.join('');
}
console.log(strv, basechange(strv, 36, 10)); 

var baselist = strv, listbase = [];
for(var i = 0; i < baselist.length; i++) listbase[baselist[i]] = i; 
function baseconvert(snumber, frombase, tobase) 
{
 var i, t, to, accum = new BigInteger(), inexp = new BigInteger('1', 10), tb = new BigInteger(),
     fb = new BigInteger(), tmp = new BigInteger();
 console.log(strv, snumber, strv, frombase, strv, tobase, strv,
             frombase < 37 && tobase < 37 ? parseInt(snumber, frombase).toString(tobase) : 'too large');
 while(snumber[0] == baselist[0] && snumber.length > 1) snumber = snumber.substr(1); 
 tb.fromInt(tobase);
 fb.fromInt(frombase);
 for(i = snumber.length - 1, to = new Array(Math.ceil(snumber.length * Math.log(frombase) / Math.log(tobase))); i > -1; i--)
 {
  accum = inexp.clone();
  accum.dMultiply(listbase[snumber[i]]);
  for(t = to.length - 1; accum.compareTo(BigInteger.ZERO) > 0 || t >= 0; t--)
  {
   tmp.fromInt(listbase[to[t]] || 0);
   accum = accum.add(tmp);
   to[t] = baselist[accum.mod(tb).intValue()];
   accum = accum.divide(tb);
  }
  inexp = inexp.multiply(fb);
 }
 while(to[0] == baselist[0] && to.length > 1) to = to.slice(1); 
 return to.join('');
}
 (() => {
    'use strict';
 
    
    const toBase = (intBase, n) =>
        intBase < 36 && intBase > 0 ?
        inBaseDigits('0123456789abcdef'.substr(0, intBase), n) : [];
 
 
    
    const inBaseDigits = (digits, n) => {
        const intBase = digits.length;
 
        return unfoldr(maybeResidue => {
                const [divided, remainder] = quotRem(maybeResidue.new, intBase);
 
                return {
                    valid: divided > 0,
                    value: digits[remainder],
                    new: divided
                };
            }, n)
            .reverse()
            .join('');
    };
 
 
    
 
    
    const unfoldr = (mf, v) => {
        var xs = [];
        return (until(
            m => !m.valid,
            m => {
                const m2 = mf(m);
                return (
                    xs = xs.concat(m2.value),
                    m2
                );
            }, {
                valid: true,
                value: v,
                new: v,
            }
        ), xs);
    };
 
    
    const curry = f => a => b => f(a, b);
 
    
    const until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    }
 
    
    const quotRem = (m, n) => [Math.floor(m / n), m % n];
 
    
    const show = x => JSON.stringify(x, null, 2);
 
 
    
 
    
    const inLowerHex = curry(inBaseDigits)('0123456789abcdef');
 
    /// inUpperHex :: Int -> String
    const inUpperHex = curry(inBaseDigits)('0123456789ABCDEF');
 
    
    const inOctal = curry(inBaseDigits)('01234567');
 
    
    const inDevanagariDecimal = curry(inBaseDigits)('०१२३४५६७८९');
 
 
    
    
    const testNumbers = [255, 240];
 
    return testNumbers.map(n => show({
        binary: toBase(2, n),
        base5: toBase(5, n),
        hex: toBase(16, n),
        upperHex: inUpperHex(n),
        octal: inOctal(n),
        devanagariDecimal: inDevanagariDecimal(n)
    }));
})();"
"function example(options) {
  
  opts = {}
  opts.foo = options.foo || 0;
  opts.bar = options.bar || 1;
  opts.grill = options.grill || 'pork chops'
 
  alert(strv + opts.foo + strv + opts.bar + strv + opts.grill);
}
 
example({grill: strv, bar: 3.14});
let
  example = 
            
    ({foo: a=0, bar=1, grill='pork chops'}={}) => (
      console.log('foo is ',a,', bar is ',bar,', and grill is '+grill));
 
example();

example({grill: strv, bar: 3.14});

example({foo:null});
"
"for (let i of [...Array(5000).keys()]
	.filter(n => n == n.toString().split('')
	.reduce((a, b) => a+Math.pow(parseInt(b),parseInt(b)), 0)))
	console.log(i);(function () {
    'use strict';
 
    
    let isMunchausen = n =>
            !isNaN(n) && (
                n.toString()
                .split('')
                .reduce((a, c) => {
                    let d = parseInt(c, 10);
 
                    return a + Math.pow(d, d);
                }, 0) === n
            ),
 
        
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        };
 
 
    return range(1, 5000)
        .filter(isMunchausen);
 
})();[1, 3435]"
"function f(num) {
 return (num === 0) ? 1 : num - m(f(num - 1));
}
 
function m(num) {
 return (num === 0) ? 0 : num - f(m(num - 1));
}
 
function range(m, n) {
  return Array.apply(null, Array(n - m + 1)).map(
    function (x, i) { return m + i; }
  );
}
 
var a = range(0, 19);
 
//return a new array of the results and join with commas to print
console.log(a.map(function (n) { return f(n); }).join(', '));
console.log(a.map(function (n) { return m(n); }).join(', '));var f = num => (num === 0) ? 1 : num - m(f(num - 1));
var m = num => (num === 0) ? 0 : num - f(m(num - 1));
 
function range(m, n) {
  return Array.apply(null, Array(n - m + 1)).map(
    function (x, i) { return m + i; }
  );
}
 
var a = range(0, 19);
 
//return a new array of the results and join with commas to print
console.log(a.map(n => f(n)).join(', '));
console.log(a.map(n => m(n)).join(', '));var range = (m, n) => Array(... Array(n - m + 1)).map((x, i) => m + i)"
"RegExp.escape = function(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, ""$&"");
}
 
multisplit = function(string, seps) {
    var sep_regex = RegExp(_.map(seps, function(sep) { return RegExp.escape(sep); }).join('|'));
    return string.split(sep_regex);
}"
"console.log(function () {
 
  var lstSuffix = 'th st nd rd th th th th th th'.split(' '),
 
    fnOrdinalForm = function (n) {
      return n.toString() + (
        11 <= n % 100 && 13 >= n % 100 ?
        strv : lstSuffix[n % 10]
      );
    },
 
    range = function (m, n) {
      return Array.apply(
        null, Array(n - m + 1)
      ).map(function (x, i) {
        return m + i;
      });
    };
 
  return [[0, 25], [250, 265], [1000, 1025]].map(function (tpl) {
    return range.apply(null, tpl).map(fnOrdinalForm).join(' ');
  }).join('');
 
}());0th 1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th 11th 12th 13th 14th 15th 16th 17th 18th 19th 20th 21st 22nd 23rd 24th 25th
 
250th 251st 252nd 253rd 254th 255th 256th 257th 258th 259th 260th 261st 262nd 263rd 264th 265th
 
1000th 1001st 1002nd 1003rd 1004th 1005th 1006th 1007th 1008th 1009th 1010th 1011th 1012th 1013th 1014th 1015th 1016th 1017th 1018th 1019th 1020th 1021st 1022nd 1023rd 1024th 1025th(function (lstTestRanges) {
    'use strict'
 
    let lstSuffix = 'th st nd rd th th th th th th'.split(' '),
 
        
        ordinalString = n =>
            n.toString() + (
                11 <= n % 100 && 13 >= n % 100 ?
                strv : lstSuffix[n % 10]
            ),
 
        
        range = (m, n) =>
            Array.from({
                length: (n - m) + 1
            }, (_, i) => m + i);
 
 
    return lstTestRanges
        .map(tpl => range
            .apply(null, tpl)
            .map(ordinalString)
        );
 
})([[0, 25], [250, 265], [1000, 1025]]);"
"
Matrix.prototype.inverse = function() {
    if (this.height != this.width) {
        throw strv;
    }   
 
    var I = new IdentityMatrix(this.height);
    for (var i = 0; i < this.height; i++) 
        this.mtx[i] = this.mtx[i].concat(I.mtx[i])
    this.width *= 2;
 
    this.toReducedRowEchelonForm();
 
    for (var i = 0; i < this.height; i++) 
        this.mtx[i].splice(0, this.height);
    this.width /= 2;
 
    return this;
}
 
function ColumnVector(ary) {
    return new Matrix(ary.map(function(v) {return [v]}))
}
ColumnVector.prototype = Matrix.prototype
 
Matrix.prototype.regression_coefficients = function(x) {
    var x_t = x.transpose();
    return x_t.mult(x).inverse().mult(x_t).mult(this);
}
 

var y = new ColumnVector([1,2,3,4,5]);
var x = new ColumnVector([2,1,3,4,5]);
print(y.regression_coefficients(x));
print();
 

y = new ColumnVector([
    52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, 
    63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46
]);
x = new Matrix(
    [1.47,1.50,1.52,1.55,1.57,1.60,1.63,1.65,1.68,1.70,1.73,1.75,1.78,1.80,1.83].map(
        function(v) {return [Math.pow(v,0), Math.pow(v,1), Math.pow(v,2)]}
    )
);
print(y.regression_coefficients(x));"
"var a = new Array(n);
for (var i = 0; i < n; i++)
  a[i] = new Foo();(n => {
 
    let nObjects = n => Array.from({
            length: n + 1
        }, (_, i) => {
            
            return {
                index: i
            };
        });
 
    return nObjects(6);
 
})(6);[{strv:0}, {strv:1}, {strv:2}, {strv:3}, 
{strv:4}, {strv:5}, {strv:6}]"
"(function (m, n) {
 
    
    function range(m, n) {
        return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
            return m + i;
        });
    }
 
    
    function mb(xs, f) {
        return [].concat.apply([], xs.map(f));
    }
 
    var rng = range(m, n),
 
        lstTable = [['x'].concat(   rng )]
                         .concat(mb(rng,   function (x) {
        return       [[x].concat(mb(rng,   function (y) {
 
            return y < x ? [''] : [x * y];               
 
    }))]}));
 
    /*                        FORMATTING OUTPUT                             */
 
    
    function wikiTable(lstRows, blnHeaderRow, strStyle) {
        return '{| class=strv ' + (
            strStyle ? 'style=""' + strStyle + '""' : ''
        ) + lstRows.map(function (lstRow, iRow) {
            var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
            return '|-' + strDelim + ' ' + lstRow.map(function (v) {
                return typeof v === 'undefined' ? ' ' : v;
            }).join(' ' + strDelim + strDelim + ' ');
        }).join('') + '|}';
    }
 
    
    return wikiTable(
        lstTable, true,
        'text-align:center;width:33em;height:33em;table-layout:fixed;'
    ) + '' +
 
    
    JSON.stringify(lstTable);
 
})(1, 12);[[strv,1,2,3,4,5,6,7,8,9,10,11,12],
 [1,1,2,3,4,5,6,7,8,9,10,11,12],
 [2,strv,4,6,8,10,12,14,16,18,20,22,24],
 [3,strv,strv,9,12,15,18,21,24,27,30,33,36],
 [4,strv,strv,strv,16,20,24,28,32,36,40,44,48],
 [5,strv,strv,strv,strv,25,30,35,40,45,50,55,60],
 [6,strv,strv,strv,strv,strv,36,42,48,54,60,66,72],
 [7,strv,strv,strv,strv,strv,strv,49,56,63,70,77,84],
 [8,strv,strv,strv,strv,strv,strv,strv,64,72,80,88,96],
 [9,strv,strv,strv,strv,strv,strv,strv,strv,81,90,99,108],
 [10,strv,strv,strv,strv,strv,strv,strv,strv,strv,100,110,120],
 [11,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,121,132],
 [12,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,144]]"
" 
function array() {
	var dimensions= Array.prototype.slice.call(arguments);
	var N=1, rank= dimensions.length;
	for (var j= 0; j<rank; j++) N*= dimensions[j];
	this.dimensions= dimensions;
	this.values= new Array(N);
}
  
function tobase(base, vals) {
  var r= 0, len= base.length;
  for (j= 0; j < len; j++) {
    r*= base[j];
    r+= vals[j];
  }
  return r;
}
 
function frombase(base, val) {
  var r= new Array(base.length);
  for (j= base.length-1; j>= 0; j--) {
    r[j]= val%base[j];
    val= (val-r[j])/base[j];
  }
  return r;
} 
array.prototype.index= function() {
	var indices= Array.prototype.slice.call(arguments);
	return this.values[tobase(this.dimensions, indices)];
}
  
a= new array(6,7,8,9);
a.index(2,3,5,6);
  
function array(length) {
	var rest= Array.prototype.slice.call(arguments);
	var r= new Array(length);
	if (0<rest.length) {
		for (var j= 0; j<length; j++) {
			r[j]= array.apply(rest);
		}
	}
}"
"function queenPuzzle(rows, columns) {
    if (rows <= 0) {
        return [[]];
    } else {
        return addQueen(rows - 1, columns);
    }
}
 
function addQueen(newRow, columns, prevSolution) {
    var newSolutions = [];
    var prev = queenPuzzle(newRow, columns);
    for (var i = 0; i < prev.length; i++) {
        var solution = prev[i];
        for (var newColumn = 0; newColumn < columns; newColumn++) {
            if (!hasConflict(newRow, newColumn, solution))
                newSolutions.push(solution.concat([newColumn]))
        }
    }
    return newSolutions;
}
 
function hasConflict(newRow, newColumn, solution) {
    for (var i = 0; i < newRow; i++) {
        if (solution[i]     == newColumn          ||
            solution[i] + i == newColumn + newRow || 
            solution[i] - i == newColumn - newRow) {
                return true;
        }
    }
    return false;
}
 
console.log(queenPuzzle(8,8));(() => {
    'use strict';
 
    
 
    
    const queenPuzzle = (nRows, nCols) =>
        nRows <= 0 ? [
            []
        ] : queenPuzzle(nRows - 1, nCols)
        .reduce((a, solution) =>
            append(a, enumFromTo(0, nCols - 1)
                .reduce((b, iCol) =>
                    safe(nRows - 1, iCol, solution) ? (
                        b.concat([solution.concat(iCol)])
                    ) : b, [])
            ), []);
 
    
    const safe = (iRow, iCol, solution) => !any(
        ([sc, sr]) =>
        (iCol === sc) || (sc + sr === iCol + iRow) || (sc - sr === iCol - iRow),
        zip(solution, enumFromTo(0, iRow - 1))
    );
 
    
 
    
    const abs = Math.abs
 
    
    const any = (f, xs) => xs.some(f);
 
    
    const append = (xs, ys) => xs.concat(ys);
 
    
    const chunksOf = (n, xs) =>
        xs.reduce((a, _, i, xs) =>
            i % n ? a : a.concat([xs.slice(i, i + n)]), []);
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const intercalate = curry((s, xs) => xs.join(s));
 
    
    const map = (f, xs) => xs.map(f)
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map(row => row[iCol]));
 
    
    const unlines = xs => xs.join('');
 
    
    const zip = (xs, ys) =>
        xs.slice(0, Math.min(xs.length, ys.length))
        .map((x, i) => [x, ys[i]]);
 
    
    
 
    
    const showSolutions = (nCols, nBoardSize) =>
        intercalate('', map(unlines,
            map(col => map(intercalate(strv), transpose(map(rows =>
                    map(r => concat(concatMap(c =>
                        c === r ? '♛' : '.',
                        enumFromTo(1, rows.length))), rows), col))),
                chunksOf(nCols, queenPuzzle(nBoardSize, nBoardSize))
            )));
 
    return showSolutions(10, 7);
})();"
" 
function multifact(n, deg){
	var result = n;
	while (n >= deg + 1){
		result *= (n - deg);
		n -= deg;
	}
	return result;
}
  
function test (n, deg) {
	for (var i = 1; i <= deg; i ++) {
		var results = '';
		for (var j = 1; j <= n; j ++) {
			results += multifact(j, i) + ' ';
		}
		console.log('Degree ' + i + ': ' + results);
	}
}
  
test(10, 5)
Degree 1: 1 2 6 24 120 720 5040 40320 362880 3628800 
Degree 2: 1 2 3 8 15 48 105 384 945 3840 
Degree 3: 1 2 3 4 10 18 28 80 162 280 
Degree 4: 1 2 3 4 5 12 21 32 45 120 
Degree 5: 1 2 3 4 5 6 14 24 36 50 
 function multifact(n, deg){
    return n <= deg ? n : n * multifact(n - deg, deg);
}function test (n, deg) {
    for (var i = 1; i <= deg; i ++) {
        var results = '';
        for (var j = 1; j <= n; j ++) {
            results += multifact(j, i) + ' ';
        }
        console.log('Degree ' + i + ': ' + results);
    }
} 
test(10, 5)
Degree 1: 1 2 6 24 120 720 5040 40320 362880 3628800 
Degree 2: 1 2 3 8 15 48 105 384 945 3840 
Degree 3: 1 2 3 4 10 18 28 80 162 280 
Degree 4: 1 2 3 4 5 12 21 32 45 120 
Degree 5: 1 2 3 4 5 6 14 24 36 50 "
"document.addEventListener('mousemove', function(e){
  var position = { x: e.clientX, y: e.clientY }
}"
"var encodeMTF = function (word) {
  var init = {wordAsNumbers: [], charList: 'abcdefghijklmnopqrstuvwxyz'.split('')};
 
  return word.split('').reduce(function (acc, char) {
    var charNum = acc.charList.indexOf(char); //get index of char
    acc.wordAsNumbers.push(charNum); //add original index to acc
    acc.charList.unshift(acc.charList.splice(charNum, 1)[0]); //put at beginning of list
    return acc;
  }, init).wordAsNumbers; //return number list
};
 
var decodeMTF = function (numList) {
  var init = {word: '', charList: 'abcdefghijklmnopqrstuvwxyz'.split('')};
 
  return numList.reduce(function (acc, num) {
    acc.word += acc.charList[num];
    acc.charList.unshift(acc.charList.splice(num, 1)[0]); //put at beginning of list
    return acc;
  }, init).word;
};
 
//test our algorithms
var words = ['broood', 'bananaaa', 'hiphophiphop'];
var encoded = words.map(encodeMTF);
var decoded = encoded.map(decodeMTF);
 
//print results
console.log(strv);
console.log(encoded);
console.log(strv);
console.log(decoded);"
"(function () {
    'use strict';
 
    
 
    
    function root(x) {
        return Math.sqrt(x);
    }
 
    
    function addOne(x) {
        return x + 1;
    }
 
    
    function half(x) {
        return x / 2;
    }
 
 
    
 
    function loggingVersion(f, strLog) {
        return function (v) {
            return {
                value: f(v),
                log: strLog
            };
        }
    }
 
    var log_root = loggingVersion(root, strv),
 
        log_addOne = loggingVersion(addOne, strv),
 
        log_half = loggingVersion(half, strv);
 
 
    
 
    
    
    
    function writerUnit(a) {
        return {
            value: a,
            log: strv + JSON.stringify(a)
        };
    }
 
    
    
    
    
 
    
    function writerBind(w, f) {
        var writerB = f(w.value),
            v = writerB.value;
 
        return {
            value: v,
            log: w.log + '' + writerB.log + ' -> ' + JSON.stringify(v)
        };
    }
 
    
 
    
    
    
    function logCompose(lstFunctions, value) {
        return lstFunctions.reduceRight(
            writerBind,
            writerUnit(value)
        );
    }
 
    var half_of_addOne_of_root = function (v) {
        return logCompose(
            [log_half, log_addOne, log_root], v
        );
    };
 
    return half_of_addOne_of_root(5);
})();"
"(function () {
    'use strict';
 
    
 
    
    function reciprocal(n) {
        return 1 / n;
    }
 
    
    function root(n) {
        return Math.sqrt(n);
    }
 
    
    
    function log(n) {
        return Math.log(n);
    }
 
 
    
    
    
 
    function safeVersion(f, fnSafetyCheck) {
        return function (v) {
            return maybe(fnSafetyCheck(v) ? f(v) : undefined);
        }
    }
 
    var safe_reciprocal = safeVersion(reciprocal, function (n) {
        return n !== 0;
    });
 
    var safe_root = safeVersion(root, function (n) {
        return n >= 0;
    });
 
 
    var safe_log = safeVersion(log, function (n) {
        return n > 0;
    });
 
 
    
    
 
    
    
 
    
    function maybe(n) {
        return {
            isValid: (typeof n !== 'undefined'),
            value: n
        };
    }
 
    
    
 
    
    
    
    
    
 
    
    
    
 
    
    function bind(maybeN, mf) {
        return (maybeN.isValid ? mf(maybeN.value) : maybeN);
    }
 
    
    
    
    var rootOneOverFour = bind(
        bind(maybe(4), safe_reciprocal), safe_root
    ).value;
 
    
 
 
    
    
    
    function safeCompose(lstFunctions, value) {
        return lstFunctions
            .reduceRight(function (a, f) {
                return bind(a, f);
            }, maybe(value));
    }
 
    
 
    var safe_log_root_reciprocal = function (n) {
        return safeCompose([safe_log, safe_root, safe_reciprocal], n).value;
    }
 
    return [-2, -1, -0.5, 0, 1 / Math.E, 1, 2, Math.E, 3, 4, 5].map(
        safe_log_root_reciprocal
    );
 
})();"
" 
Array.prototype.bind = function (func) {
  return this.map(func).reduce(function (acc, a) { return acc.concat(a); });
}
 
Array.unit = function (elem) {
  return [elem];
}
 
Array.lift = function (func) {
  return function (elem) { return Array.unit(func(elem)); };
}
 
inc = function (n) { return n + 1; }
doub = function (n) { return 2 * n; }
listy_inc = Array.lift(inc);
listy_doub = Array.lift(doub);
 
[3,4,5].bind(listy_inc).bind(listy_doub); 
 (function (n) {
 
    
 
    
 
 
    
    
    
 
    
    
 
    
 
    return bind(rng(1,     n), function (x) {
    return bind(rng(1 + x, n), function (y) {
    return bind(rng(1 + y, n), function (z) {
 
        return (x * x + y * y === z * z) ? unit([x, y, z]) : [];
 
    })})});
 
 
    
    
    function unit(a) {
        return [a];
    }
 
    
    
    
    
    function bind(xs, f) {
        return [].concat.apply([], xs.map(f));
    }
 
 
 
    
    
    function rng(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (x, i) {
                return m + i;
            });
    }
 
})(25);"
"#!/usr/bin/env node
 
function meaningOfLife() { return 42; }
 
exports.meaningOfLife = meaningOfLife;
 
function main() {
	console.log(strv + meaningOfLife());
}
 
if (!module.parent) { main(); }#!/usr/bin/env node
 
var sm = require(strv);
 
console.log(strv + sm.meaningOfLife());"
"function mcpi(n) {
    var x, y, m = 0;
 
    for (var i = 0; i < n; i += 1) {
        x = Math.random();
        y = Math.random();
 
        if (x * x + y * y < 1) {
            m += 1;
        }
    }
 
    return 4 * m / n;
}
 
console.log(mcpi(1000));
console.log(mcpi(10000));
console.log(mcpi(100000));
console.log(mcpi(1000000));
console.log(mcpi(10000000));(() => {
    'use strict';
 
    
    const monteCarloPi = n =>
        4 * range(1, n)
        .reduce(a => {
            const [x, y] = [rnd(), rnd()];
            return x * x + y * y < 1 ? a + 1 : a;
        }, 0) / n;
 
 
    
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const rnd = Math.random;
 
 
    
    return range(3, 8)
        .map(x => monteCarloPi(Math.pow(10, x)));
 
    
})();
 [3.14, 3.1404, 3.13304, 3.142408, 3.1420304, 3.14156788]"
" 
var globalAudioContext = new webkitAudioContext();
 
function morsecode(text, unit, freq) {
	'use strict';
 
	
	unit = unit ? unit : 0.05;
	freq = freq ? freq : 700;
	var cont = globalAudioContext;
	var time = cont.currentTime;
 
	
	var code = {
		a: '._',    b: '_...',  c: '_._.',  d: '_..',   e: '.',     f: '.._.',
		g: '__.',   h: '....',  i: '..',    j: '.___',  k: '_._',   l: '._..',
		m: '__',    n: '_.',    o: '___',   p: '.__.',  q: '__._',  r: '._.',
		s: '...',   t: '_',     u: '.._',   v: '..._',  w: '.__',   x: '_.._',
		y: '_.__',  z: '__..',  0: '_____', 1: '.____', 2: '..___', 3: '...__',
		4: '...._', 5: '.....', 6: '_....', 7: '__...', 8: '___..', 9: '____.'
	};
 
	
	function makecode(data) {
		for (var i = 0; i <= data.length; i ++) {
			var codedata = data.substr(i, 1).toLowerCase();
			codedata = code[codedata];
			
			if (codedata !== undefined) {
				maketime(codedata);
			}
			
			else {
				time += unit * 7;
			}
		}
	}
 
	
	function maketime(data) {
		for (var i = 0; i <= data.length; i ++) {
			var timedata = data.substr(i, 1);
			timedata = (timedata === '.') ? 1 : (timedata === '_') ? 3 : 0;
			timedata *= unit;
			if (timedata > 0) {
				maketone(timedata);
				time += timedata;
				
				time += unit * 1;
			}
		}
		
		time += unit * 2;
	}
 
	
	function maketone(data) {
		var start = time;
		var stop = time + data;
		
		gain.gain.linearRampToValueAtTime(0, start);
		gain.gain.linearRampToValueAtTime(1, start + (unit / 8));
		gain.gain.linearRampToValueAtTime(1, stop - (unit / 16));
		gain.gain.linearRampToValueAtTime(0, stop);
	}
 
	
	var osci = cont.createOscillator();
	osci.frequency.value = freq;
	var gain = cont.createGainNode();
	gain.gain.value = 0;
	var dest = cont.destination;
	
	osci.connect(gain);
	gain.connect(dest);
	
	osci.start(time);
 
	
	makecode(text);
 
	
	return cont;
}
  
morsecode('Hello World');
 "
" 
function montyhall(tests, doors) {
	'use strict';
	tests = tests ? tests : 1000;
	doors = doors ? doors : 3;
	var prizeDoor, chosenDoor, shownDoor, switchDoor, chosenWins = 0, switchWins = 0;
 
	
	function pick(excludeA, excludeB) {
		var door;
		do {
			door = Math.floor(Math.random() * doors);
		} while (door === excludeA || door === excludeB);
		return door;
	}
 
	
	for (var i = 0; i < tests; i ++) {
 
		
		prizeDoor = pick();
		chosenDoor = pick();
		shownDoor = pick(prizeDoor, chosenDoor);
		switchDoor = pick(chosenDoor, shownDoor);
 
		
		if (chosenDoor === prizeDoor) {
			chosenWins ++;
		} else if (switchDoor === prizeDoor) {
			switchWins ++;
		}
	}
 
	
	return {
		stayWins: chosenWins + ' ' + (100 * chosenWins / tests) + '%',
		switchWins: switchWins + ' ' + (100 * switchWins / tests) + '%'
	};
}
  
montyhall(1000, 3)
Object {stayWins: strv, switchWins: strv}
montyhall(1000, 4)
Object {stayWins: strv, switchWins: strv}
montyhall(1000, 5)
Object {stayWins: strv, switchWins: strv}
  
var totalGames = 10000,
    selectDoor = function () {
	return Math.floor(Math.random() * 3); 
    },
    games = (function () {
	var i = 0, games = [];
 
	for (; i < totalGames; ++i) {
	    games.push(selectDoor()); 
	}
 
	return games;
    }()),
    play = function (switchDoor) {
	var i = 0, j = games.length, winningDoor, randomGuess, totalTimesWon = 0;
 
	for (; i < j; ++i) {
	    winningDoor = games[i];
	    randomGuess = selectDoor();
	    if ((randomGuess === winningDoor && !switchDoor) || 
		(randomGuess !== winningDoor && switchDoor)) 
	    {
		/*		 * If I initially guessed the winning door and didn't switch,		 * or if I initially guessed a losing door but then switched,		 * I've won.		 *		 * The only time I lose is when I initially guess the winning door 		 * and then switch.		 */
 
		totalTimesWon++;
	    }
	}
	return totalTimesWon;
    };
 
/* * Start the simulation */
 
console.log(strv + totalGames + strv);
console.log(strv, play(false));
console.log(strv, play(true));
  
Playing 10000 games
Wins when not switching door 3326
Wins when switching door 6630
 "
"function probablyPrime(n, k) {
	if (n === 2 || n === 3)
		return true;
	if (n % 2 === 0 || n < 2)
		return false;
 
	
	var s = 0, d = n - 1;
	while (d % 2 === 0) {
		d /= 2;
		++s;
	}
 
	WitnessLoop: do {
		
		var x = Math.pow(2 + Math.floor(Math.random() * (n - 3)), d) % n;
 
		if (x === 1 || x === n - 1)
			continue;
 
		for (var i = s - 1; i--;) {
			x = x * x % n;
			if (x === 1)
				return false;
			if (x === n - 1)
				continue WitnessLoop;
		}
 
		return false;
	} while (--k);
 
	return true;
}"
"var modInverse = function(a, b) {
    a %= b;
    for (var x = 1; x < b; x++) {
        if ((a*x)%b == 1) {
            return x;
        }
    }
}"
"function maze(x,y) {
	var n=x*y-1;
	if (n<0) {alert(strv);return;}
	var horiz =[]; for (var j= 0; j<x+1; j++) horiz[j]= [],
	    verti =[]; for (var j= 0; j<x+1; j++) verti[j]= [],
	    here = [Math.floor(Math.random()*x), Math.floor(Math.random()*y)],
	    path = [here],
	    unvisited = [];
	for (var j = 0; j<x+2; j++) {
		unvisited[j] = [];
		for (var k= 0; k<y+1; k++)
			unvisited[j].push(j>0 && j<x+1 && k>0 && (j != here[0]+1 || k != here[1]+1));
	}
	while (0<n) {
		var potential = [[here[0]+1, here[1]], [here[0],here[1]+1],
		    [here[0]-1, here[1]], [here[0],here[1]-1]];
		var neighbors = [];
		for (var j = 0; j < 4; j++)
			if (unvisited[potential[j][0]+1][potential[j][1]+1])
				neighbors.push(potential[j]);
		if (neighbors.length) {
			n = n-1;
			next= neighbors[Math.floor(Math.random()*neighbors.length)];
			unvisited[next[0]+1][next[1]+1]= false;
			if (next[0] == here[0])
				horiz[next[0]][(next[1]+here[1]-1)/2]= true;
			else 
				verti[(next[0]+here[0]-1)/2][next[1]]= true;
			path.push(here = next);
		} else 
			here = path.pop();
	}
	return {x: x, y: y, horiz: horiz, verti: verti};
}
 
function display(m) {
	var text= [];
	for (var j= 0; j<m.x*2+1; j++) {
		var line= [];
		if (0 == j%2)
			for (var k=0; k<m.y*4+1; k++)
				if (0 == k%4) 
					line[k]= '+';
				else
					if (j>0 && m.verti[j/2-1][Math.floor(k/4)])
						line[k]= ' ';
					else
						line[k]= '-';
		else
			for (var k=0; k<m.y*4+1; k++)
				if (0 == k%4)
					if (k>0 && m.horiz[(j-1)/2][k/4-1])
						line[k]= ' ';
					else
						line[k]= '|';
				else
					line[k]= ' ';
		if (0 == j) line[1]= line[2]= line[3]= ' ';
		if (m.x*2-1 == j) line[4*m.y]= ' ';
		text.push(line.join('')+'');
	}
	return text.join('');
}	function step() {
		if (0<n) {			document.getElementById('out').innerHTML= display({x: x, y: y, horiz: horiz, verti: verti, here: here});
			setTimeout(step, 100);
		}
	}
	step();				if (m.here && m.here[0]*2+1 == j && m.here[1]*4+2 == k) 
					line[k]= '#'
				else if (0 == k%4) {			here= next;
			if (1 < neighbors.length) 
				path.push(here); 
'use strict';
/* * Imported from http://rosettacode.org/wiki/Maze_generation#JavaScript * Added asynchronous behaviour to the maze generation. *  * Port by sigmasoldier */
 
/** * Generates the maze asynchronously. * @param {Number} x Width of the maze. * @param {Number} y Height of the maze. * @returns {Promise} finished when resolved. */
function maze(x,y) {
	return new Promise((resolve, reject) => {
		let n=x*y-1;
		if (n<0) {
			reject(new Error(`illegal maze dimensions (${x} x ${y} < 1)`));
		} else {
			let horiz =[]; for (let j= 0; j<x+1; j++) horiz[j]= [];
			let verti =[]; for (let j= 0; j<x+1; j++) verti[j]= [];
			let here = [Math.floor(Math.random()*x), Math.floor(Math.random()*y)];
			let path = [here];
			let unvisited = [];
			for (let j = 0; j<x+2; j++) {
				unvisited[j] = [];
				for (let k= 0; k<y+1; k++)
					unvisited[j].push(j>0 && j<x+1 && k>0 && (j != here[0]+1 || k != here[1]+1));
			}
			while (0<n) {
				let potential = [[here[0]+1, here[1]], [here[0],here[1]+1],
						[here[0]-1, here[1]], [here[0],here[1]-1]];
				let neighbors = [];
				for (let j = 0; j < 4; j++)
					if (unvisited[potential[j][0]+1][potential[j][1]+1])
						neighbors.push(potential[j]);
				if (neighbors.length) {
					n = n-1;
					let next= neighbors[Math.floor(Math.random()*neighbors.length)];
					unvisited[next[0]+1][next[1]+1]= false;
					if (next[0] == here[0])
						horiz[next[0]][(next[1]+here[1]-1)/2]= true;
					else 
						verti[(next[0]+here[0]-1)/2][next[1]]= true;
					path.push(here = next);
				} else 
					here = path.pop();
			}
			resolve({x: x, y: y, horiz: horiz, verti: verti});
		}
	});
}
 
/** * A mere way of generating text. * The text (Since it can be large) is generated in a non-blocking way. * @param {Object} m Maze object. * @param {Stream} writeTo Optinally, include here a function to write to. * @returns {Promise} finished when the text is generated. */
function display(m, writeTo) {
	return new Promise((resolve, reject) => {
		let text = [];
		for (let j= 0; j<m.x*2+1; j++) {
			let line = [];
			if (0 == j%2)
				for (let k=0; k<m.y*4+1; k++)
					if (0 == k%4) 
						line[k] = '+';
					else
						if (j>0 && m.verti[j/2-1][Math.floor(k/4)])
							line[k] = ' ';
						else
							line[k] = '-';
			else
				for (let k=0; k<m.y*4+1; k++)
					if (0 == k%4)
						if (k>0 && m.horiz[(j-1)/2][k/4-1])
							line[k] = ' ';
						else
							line[k] = '|';
					else
						line[k] = ' ';
			if (0 == j) line[1] = line[2] = line[3] = ' ';
			if (m.x*2-1 == j) line[4*m.y]= ' ';
			text.push(line.join('')+'');
		}
		const OUTPUT = text.join('');
		if (typeof writeTo === 'function')
			writeTo(OUTPUT);
		resolve(OUTPUT);
	});
}
 
module.exports = {
  maze: maze,
  display: display
}
  
'use strict';
 
const maze = require('./maze.js');
const X = 20,
  Y = 20;
 
console.log(`Generating a maze of ${X} x ${Y}...`);
const origin = new Date().getTime();
 
maze.maze(X, Y).then((m) => {
  const time = new Date().getTime() - origin;
  console.log(`Done in ${time <= 1000 ? time+'ms' : Math.round(time/1000)+'s'}!`);
  maze.display(m, console.log); //Here you can pass a given stream (ie: stream) and it's write function;
  //An example could be: maze.display(m, stream.write);
}, (err) => console.error(err));
 
 "
"function middleThree(x){
  var n=''+Math.abs(x); var l=n.length-1;
  if(l<2||l%2) throw new Error(x+': Invalid length '+(l+1));
  return n.slice(l/2-1,l/2+2);
}
 
[123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345,
1, 2, -1, -10, 2002, -2002, 0].forEach(function(n){
  try{console.log(n,middleThree(n))}catch(e){console.error(e.message)}
});"
"function select(question, choices) {
    var prompt = strv;
    for (var i in choices) 
        prompt += i + strv + choices[i] + """";
    prompt += question;
 
    var input;
    while (1) {
        WScript.Echo(prompt);
        input = parseInt( WScript.StdIn.readLine() );
        if (0 <= input && input < choices.length)
            break;
        WScript.Echo(""Try again."");
    }
    return input;
}
 
var choices = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock'];
var choice = select(strv, choices);
WScript.Echo(strv + choice + strv + choices[choice]);"
"
function IdentityMatrix(n) {
    this.height = n;
    this.width = n;
    this.mtx = [];
    for (var i = 0; i < n; i++) {
        this.mtx[i] = [];
        for (var j = 0; j < n; j++) {
            this.mtx[i][j] = (i == j ? 1 : 0);
        }
    }
}
IdentityMatrix.prototype = Matrix.prototype;
 


Matrix.prototype.exp = function(n) {
    var result = new IdentityMatrix(this.height);
    for (var i = 1; i <= n; i++) {
        result = result.mult(this);
    }
    return result;
}
 
var m = new Matrix([[3, 2], [2, 1]]);
[0,1,2,3,4,10].forEach(function(e){print(m.exp(e)); print()})"
" 
var arr = [
[55],
[94, 48],
[95, 30, 96],
[77, 71, 26, 67],
[97, 13, 76, 38, 45],
[07, 36, 79, 16, 37, 68],
[48, 07, 09, 18, 70, 26, 06],
[18, 72, 79, 46, 59, 79, 29, 90],
[20, 76, 87, 11, 32, 07, 07, 49, 18],
[27, 83, 58, 35, 71, 11, 25, 57, 29, 85],
[14, 64, 36, 96, 27, 11, 58, 56, 92, 18, 55],
[02, 90, 03, 60, 48, 49, 41, 46, 33, 36, 47, 23],
[92, 50, 48, 02, 36, 59, 42, 79, 72, 20, 82, 77, 42],
[56, 78, 38, 80, 39, 75, 02, 71, 66, 66, 01, 03, 55, 72],
[44, 25, 67, 84, 71, 67, 11, 61, 40, 57, 58, 89, 40, 56, 36],
[85, 32, 25, 85, 57, 48, 84, 35, 47, 62, 17, 01, 01, 99, 89, 52],
[06, 71, 28, 75, 94, 48, 37, 10, 23, 51, 06, 48, 53, 18, 74, 98, 15],
[27, 02, 92, 23, 08, 71, 76, 84, 15, 52, 92, 63, 81, 10, 44, 10, 69, 93]
];
 
while (arr.length !== 1) {
  var len = arr.length;
  var row = [];
  var current = arr[len-2];
  var currentLen = current.length - 1;
  var end = arr[len-1];
 
  for ( var i = 0; i <= currentLen; i++ ) {
    row.push(Math.max(current[i] + end[i] || 0, current[i] + end[i+1] || 0) )
  }
 
  arr.pop();
  arr.pop();
 
  arr.push(row);
}
 
console.log(arr);
  
[ [ 1320 ] ]
 (function () {
 
  
  
  function foldr1(f, lst) {
    return lst.length > 1 ? (
      f(lst[0], foldr1(f, lst.slice(1)))
    ) : lst[0];
  }
 
  
  
  function zipWith3(f, xs, ys, zs) {
    return zs.length ? [f(xs[0], ys[0], zs[0])].concat(
      zipWith3(f, xs.slice(1), ys.slice(1), zs.slice(1))) : [];
  }
 
  
  
  return foldr1(
    function (xs, ys) {
      return zipWith3(
        function (x, y, z) {
          return x + (y < z ? z : y);
        },
        xs, ys, ys.slice(1) 
      );
    }, [
        [55],
        [94, 48],
        [95, 30, 96],
        [77, 71, 26, 67],
        [97, 13, 76, 38, 45],
        [07, 36, 79, 16, 37, 68],
        [48, 07, 09, 18, 70, 26, 06],
        [18, 72, 79, 46, 59, 79, 29, 90],
        [20, 76, 87, 11, 32, 07, 07, 49, 18],
        [27, 83, 58, 35, 71, 11, 25, 57, 29, 85],
        [14, 64, 36, 96, 27, 11, 58, 56, 92, 18, 55],
        [02, 90, 03, 60, 48, 49, 41, 46, 33, 36, 47, 23],
        [92, 50, 48, 02, 36, 59, 42, 79, 72, 20, 82, 77, 42],
        [56, 78, 38, 80, 39, 75, 02, 71, 66, 66, 01, 03, 55, 72],
        [44, 25, 67, 84, 71, 67, 11, 61, 40, 57, 58, 89, 40, 56, 36],
        [85, 32, 25, 85, 57, 48, 84, 35, 47, 62, 17, 01, 01, 99, 89, 52],
        [06, 71, 28, 75, 94, 48, 37, 10, 23, 51, 06, 48, 53, 18, 74, 98, 15],
        [27, 02, 92, 23, 08, 71, 76, 84, 15, 52, 92, 63, 81, 10, 44, 10, 69, 93]
    ]
  )[0];
 
})();1320(() => {
    'use strict';
 
    
 
    
    const maxPathSum = xss =>
        head(foldr1((ys, xs) =>
            zipWith3((a, b, c) =>
                a + max(b, c),
                xs, ys, tail(ys)),
            xss));
 
 
    
 
    
    const foldr1 = (f, xs) =>
        xs.length > 0 ? init(xs)
        .reduceRight(f, last(xs)) : [];
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const init = xs => xs.length ? xs.slice(0, -1) : undefined;
 
    
    const last = xs => xs.length ? xs.slice(-1)[0] : undefined;
 
    
    const max = (a, b) => b > a ? b : a;
 
    
    const minimum = xs =>
        xs.reduce((a, x) => (x < a || a === undefined ? x : a), undefined);
 
    
    const tail = xs => xs.length ? xs.slice(1) : undefined;
 
    
    const zipWith3 = (f, xs, ys, zs) =>
        Array.from({
            length: minimum([xs.length, ys.length, zs.length])
        }, (_, i) => f(xs[i], ys[i], zs[i]));
 
 
    
    return maxPathSum([
        [55],
        [94, 48],
        [95, 30, 96],
        [77, 71, 26, 67],
        [97, 13, 76, 38, 45],
        [7, 36, 79, 16, 37, 68],
        [48, 7, 9, 18, 70, 26, 6],
        [18, 72, 79, 46, 59, 79, 29, 90],
        [20, 76, 87, 11, 32, 7, 7, 49, 18],
        [27, 83, 58, 35, 71, 11, 25, 57, 29, 85],
        [14, 64, 36, 96, 27, 11, 58, 56, 92, 18, 55],
        [2, 90, 3, 60, 48, 49, 41, 46, 33, 36, 47, 23],
        [92, 50, 48, 2, 36, 59, 42, 79, 72, 20, 82, 77, 42],
        [56, 78, 38, 80, 39, 75, 2, 71, 66, 66, 1, 3, 55, 72],
        [44, 25, 67, 84, 71, 67, 11, 61, 40, 57, 58, 89, 40, 56, 36],
        [85, 32, 25, 85, 57, 48, 84, 35, 47, 62, 17, 1, 1, 99, 89, 52],
        [6, 71, 28, 75, 94, 48, 37, 10, 23, 51, 6, 48, 53, 18, 74, 98, 15],
        [27, 2, 92, 23, 8, 71, 76, 84, 15, 52, 92, 63, 81, 10, 44, 10, 69, 93]
    ]);
})();"
"
Matrix.prototype.mult = function(other) {
    if (this.width != other.height) {
        throw strv;
    }
 
    var result = [];
    for (var i = 0; i < this.height; i++) {
        result[i] = [];
        for (var j = 0; j < other.width; j++) {
            var sum = 0;
            for (var k = 0; k < this.width; k++) {
                sum += this.mtx[i][k] * other.mtx[k][j];
            }
            result[i][j] = sum;
        }
    }
    return new Matrix(result); 
}
 
var a = new Matrix([[1,2],[3,4]])
var b = new Matrix([[-3,-8,3],[-2,1,4]]);
print(a.mult(b));(function () {
    'use strict';
 
    
    function matrixMultiply(a, b) {
        var bCols = transpose(b);
 
        return a.map(function (aRow) {
            return bCols.map(function (bCol) {
                return dotProduct(aRow, bCol);
            });
        });
    }
 
    
    function dotProduct(xs, ys) {
        return sum(zipWith(product, xs, ys));
    }
 
    return matrixMultiply(
        [[-1,  1,  4],
         [ 6, -4,  2],
         [-3,  5,  0],
         [ 3,  7, -2]],
 
        [[-1,  1,  4,  8],
         [ 6,  9, 10,  2],
         [11, -4,  5, -3]]
    );
 
    
    
 
 
    
 
    
    function zipWith(f, xs, ys) {
        return xs.length === ys.length ? (
            xs.map(function (x, i) {
                return f(x, ys[i]);
            })
        ) : undefined;
    }
 
    
    function transpose(lst) {
        return lst[0].map(function (_, iCol) {
            return lst.map(function (row) {
                return row[iCol];
            });
        });
    }
 
    
    function sum(xs) {
        return xs.reduce(function (a, x) {
            return a + x;
        }, 0);
    }
 
    
    function product(a, b) {
        return a * b;
    }
 
})();[[51, -8, 26, -18], [-8, -38, -6, 34], 
      [33, 42, 38, -14], [17, 74, 72, 44]]((() => {
    'use strict';
 
    
    const matrixMultiply = (a, b) => {
        const bCols = transpose(b);
        return a.map(aRow => bCols.map(bCol => dotProduct(aRow, bCol)));
    }
 
    
    const dotProduct = (xs, ys) => sum(zipWith(product, xs, ys));
 
 
    
 
    
    const zipWith = (f, xs, ys) =>
        xs.length === ys.length ? (
            xs.map((x, i) => f(x, ys[i]))
        ) : undefined;
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map(row => row[iCol]));
 
    
    const sum = xs =>
        xs.reduce((a, x) => a + x, 0);
 
    
    const product = (a, b) => a * b;
 
 
    
    return matrixMultiply(
        [
            [-1, 1, 4],
            [6, -4, 2],
            [-3, 5, 0],
            [3, 7, -2]
        ],
 
        [
            [-1, 1, 4, 8],
            [6, 9, 10, 2],
            [11, -4, 5, -3]
        ]
    );
 
    
    
}))();[[51, -8, 26, -18], [-8, -38, -6, 34], 
[33, 42, 38, -14], [17, 74, 72, 44]]"
"var path = require('path');
var fs = require('fs');
 
function mkdirp (p, cb) {
    cb = cb || function () {};
    p = path.resolve(p);
 
    fs.mkdir(p, function (er) {
        if (!er) {
            return cb(null);
        }
        switch (er.code) {
            case 'ENOENT':
                
                mkdirp(path.dirname(p), function (er) {
                    if (er) cb(er);
                    else mkdirp(p, cb);
                });
                break;
 
                
            default:
                cb(er);
                break;
        }
    });
}"
"

var mapRange = function(from, to, s) {
  return to[0] + (s - from[0]) * (to[1] - to[0]) / (from[1] - from[0]);
};
 
var range = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (var i = 0; i < range.length; i++) {
  range[i] = mapRange([0, 10], [-1, 0], range[i]);
}
 
console.log(range);var mapRange = function(from, to, s) {
  
  var a1 = from[0];
  var a2 = from[from.length - 1];
  var b1 = to[0];
  var b2 = to[to.length - 1];
  return b1 + (s - a1) * (b2 - b1) / (a2 - a1);
};
 

var fromRange = _.range(0, 11);
var toRange = _.range(-1, 1);
 

fromRange = fromRange.map(function(s) {
  return mapRange(fromRange, toRange, s);
});
 
console.log(fromRange);"
"var Таблица_замен = [
  [ 4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3],
  [14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9],
  [ 5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11],
  [ 7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3],
  [ 6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2],
  [ 4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14],
  [13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12],
  [ 1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12]];
 
function ОсновнойШаг(блок_текста, элемент_ключа) {
  var N = блок_текста.slice(0);
  var X = элемент_ключа;
  var S = (N[0] + X) & 0xFFFFFFFF;
  var ячейка; var нов_S = 0;
  for (var сч = 0; сч < 4; сч++) {
    ячейка = (S >>> (сч << 3)) & 0xFF;
    нов_S += (Таблица_замен[сч*2][ячейка & 0x0F] + (Таблица_замен[сч*2+1][ячейка >>> 4] << 4)) << (сч << 3);
  }
  S = (((нов_S << 11) + (нов_S >>> 21)) & 0xFFFFFFFF) ^ N[1];
  N[1] = N[0]; N[0] = S;
  return N;
}"
"function Matrix(ary) {
    this.mtx = ary
    this.height = ary.length;
    this.width = ary[0].length;
}
 
Matrix.prototype.toString = function() {
    var s = []
    for (var i = 0; i < this.mtx.length; i++) 
        s.push( this.mtx[i].join(strv) );
    return s.join("""");
}
 

Matrix.prototype.transpose = function() {
    var transposed = [];
    for (var i = 0; i < this.width; i++) {
        transposed[i] = [];
        for (var j = 0; j < this.height; j++) {
            transposed[i][j] = this.mtx[j][i];
        }
    }
    return new Matrix(transposed);
}
 
var m = new Matrix([[1,1,1,1],[2,4,8,16],[3,9,27,81],[4,16,64,256],[5,25,125,625]]);
print(m);
print();
print(m.transpose()); 
(function () {
    'use strict';
 
    function transpose(lst) {
        return lst[0].map(function (_, iCol) {
            return lst.map(function (row) {
                return row[iCol];
            })
        });
    }
 
    return transpose(
        [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]
    );
 
})();
 (() => {
    'use strict';
 
    
    let transpose = xs =>
        xs[0].map((_, iCol) => xs.map((row) => row[iCol]));
 
 
 
    
    return transpose([
        [1, 2],
        [3, 4],
        [5, 6]
    ]);
})();[[1, 3, 5], [2, 4, 6]]"
"(() => {
    'use strict';
 
    
    const doubleEvenMagicSquare = n => {
        if (n % 4 > 0) return undefined;
 
        
        const truthSeries = n => {
            if (n <= 0) return [true];
            const xs = truthSeries(n - 1);
            return xs.concat(xs.map(x => !x));
        };
 
        const sqr = n * n,
            scale = curry(replicate)(n / 4),
            power = Math.log2(sqr),
            sequence = isInt(power) ? truthSeries(power) : (
                flatten(
                    scale(
                        splitEvery(4, truthSeries(4))
                        .map(scale)
                    )
                )
            );
 
        return splitEvery(n, sequence
            .map((x, i) => x ? i + 1 : sqr - i));
    };
 
 
    
 
    
    const flatten = t => (t instanceof Array ? concatMap(flatten, t) : [t]);
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const splitEvery = (n, xs) => {
        if (xs.length <= n) return [xs];
        const [h, t] = [xs.slice(0, n), xs.slice(n)];
        return [h].concat(splitEvery(n, t));
    }
 
    
    const curry = f => a => b => f(a, b);
 
    
    const replicate = (n, a) => {
        let v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    const isInt = x => x === Math.floor(x);
 
 
    
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map((row) => row[iCol]));
 
    
    const diagonals = xs => {
        const nRows = xs.length,
            nCols = (nRows > 0 ? xs[0].length : 0);
        const cell = (x, y) => xs[y][x];
 
        if (nRows === nCols) {
            const ns = range(0, nCols - 1);
            return [zipWith(cell, ns, ns), zipWith(cell, ns, reverse(ns))];
        } else return [
            [],
            []
        ];
    };
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    }
 
    
    const reverse = (xs) => xs.slice(0)
        .reverse()
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const all = (f, xs) => xs.every(f);
 
    
    const show = x => JSON.stringify(x);
 
    
    const justifyRight = (n, cFiller, strText) =>
        n > strText.length ? (
            (cFiller.repeat(n) + strText)
            .slice(-n)
        ) : strText;
 
    
 
    //return doubleEvenMagicSquare(8)
 
    return [4, 8, 12]
        .map(n => {
            const lines = doubleEvenMagicSquare(n);
            const sums = lines.concat(
                    transpose(lines)
                    .concat(diagonals(lines))
                )
                .map(xs => xs.reduce((a, b) => a + b, 0));
            const sum = sums[0];
            return [
                strv + n.toString(),
                strv + sum.toString(),
                strv +
                all(x => x === sum, sums)
                .toString() + '',
                lines.map(
                    xs => xs.map(
                        x => justifyRight(3, ' ', x.toString())
                    )
                    .join('  '))
                .join('')
            ].join('')
        })
        .join('');
})();"
"function mandelIter(cx, cy, maxIter) {
  var x = 0.0;
  var y = 0.0;
  var xx = 0;
  var yy = 0;
  var xy = 0;
 
  var i = maxIter;
  while (i-- && xx + yy <= 4) {
    xy = x * y;
    xx = x * x;
    yy = y * y;
    x = xx - yy + cx;
    y = xy + xy + cy;
  }
  return maxIter - i;
}
 
function mandelbrot(canvas, xmin, xmax, ymin, ymax, iterations) {
  var width = canvas.width;
  var height = canvas.height;
 
  var ctx = canvas.getContext('2d');
  var img = ctx.getImageData(0, 0, width, height);
  var pix = img.data;
 
  for (var ix = 0; ix < width; ++ix) {
    for (var iy = 0; iy < height; ++iy) {
      var x = xmin + (xmax - xmin) * ix / (width - 1);
      var y = ymin + (ymax - ymin) * iy / (height - 1);
      var i = mandelIter(x, y, iterations);
      var ppos = 4 * (width * iy + ix);
 
      if (i > iterations) {
        pix[ppos] = 0;
        pix[ppos + 1] = 0;
        pix[ppos + 2] = 0;
      } else {
        var c = 3 * Math.log(i) / Math.log(iterations - 1.0);
 
        if (c < 1) {
          pix[ppos] = 255 * c;
          pix[ppos + 1] = 0;
          pix[ppos + 2] = 0;
        }
        else if ( c < 2 ) {
          pix[ppos] = 255;
          pix[ppos + 1] = 255 * (c - 1);
          pix[ppos + 2] = 0;
        } else {
          pix[ppos] = 255;
          pix[ppos + 1] = 255;
          pix[ppos + 2] = 255 * (c - 2);
        }
      }
      pix[ppos + 3] = 255;
    }
  }
 
  ctx.putImageData(img, 0, 0);
}
 
var canvas = document.createElement('canvas');
canvas.width = 900;
canvas.height = 600;
 
document.body.insertBefore(canvas, document.body.childNodes[0]);
 
mandelbrot(canvas, -2, 1, -1, 1, 1000);"
"(function () {
 
  
  function magic(n) {
    return n % 2 ? rotation(
      transposed(
        rotation(
          table(n)
        )
      )
    ) : null;
  }
 
  
  function rotation(lst) {
    return lst.map(function (row, i) {
      return rotated(
        row, ((row.length + 1) / 2) - (i + 1)
      );
    })
  }
 
  
  function transposed(lst) {
    return lst[0].map(function (col, i) {
      return lst.map(function (row) {
        return row[i];
      })
    });
  }
 
  
  function rotated(lst, n) {
    var lng = lst.length,
      m = (typeof n === 'undefined') ? 1 : (
        n < 0 ? lng + n : (n > lng ? n % lng : n)
      );
 
    return m ? (
      lst.slice(-m).concat(lst.slice(0, lng - m))
    ) : lst;
  }
 
  
  function table(n) {
    var rngTop = rng(1, n);
 
    return rng(0, n - 1).map(function (row) {
      return rngTop.map(function (x) {
        return row * n + x;
      });
    });
  }
 
  
  function rng(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(
      function (x, i) {
        return m + i;
      });
  }
 
  /******************** TEST WITH 3, 5, 11 ***************************/
 
  
  function wikiTable(lstRows, blnHeaderRow, strStyle) {
    var css = strStyle ? 'style=""' + strStyle + '""' : '';
 
    return '{| class=strv ' + css + lstRows.map(
      function (lstRow, iRow) {
        var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|'),
          strDbl = strDelim + strDelim;
 
        return '|-' + strDelim + ' ' + lstRow.join(' ' + strDbl + ' ');
      }).join('') + '|}';
  }
 
  return [3, 5, 11].map(
    function (n) {
      var w = 2.5 * n;
      return 'magic(' + n + ')' + wikiTable(
        magic(n), false, 'text-align:center;width:' + w + 'em;height:' + w + 'em;table-layout:fixed;'
      )
    }
  ).join('')
})();(() => {
    'use strict';
 
    
    const magicSquare = n =>
        n % 2 !== 0 ? (
            compose([cycledRows, transpose, cycledRows, rangeSquare])(n)
        ) : [];
 
    
    const rangeSquare = n =>
        splitEvery(n, range(1, n * n));
 
    
    
    
    
    const cycledRows = rows => {
        const d = Math.floor(rows.length / 2);
        return zip(range(d, -d), rows)
            .map(x => listCycle(...x));
    };
 
    
    const listCycle = (n, xs) => {
        const d = -(n % xs.length);
        return (d !== 0 ? xs.slice(d)
            .concat(xs.slice(0, d)) : xs);
    };
 
    
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map(row => row[iCol]));
 
    
    const compose = fs => x => fs.reduceRight((a, f) => f(a), x);
 
    
    const zip = (xs, ys) =>
        xs.slice(0, Math.min(xs.length, ys.length))
        .map((x, i) => [x, ys[i]]);
 
    
    const range = (m, n, step) => {
        const d = (step || 1) * (n >= m ? 1 : -1);
        return Array.from({
            length: Math.floor((n - m) / d) + 1
        }, (_, i) => m + (i * d));
    };
 
    
    const splitEvery = (n, xs) => {
        if (xs.length <= n) return [xs];
        const [h, t] = [xs.slice(0, n), xs.slice(n)];
        return [h].concat(splitEvery(n, t));
    };
 
    
 
    
    const unlines = xs => xs.join('');
 
    
    const intercalate = (s, xs) => xs.join(s);
 
    
    const show = JSON.stringify;
 
    return intercalate('', [3, 5, 7]
        .map(magicSquare)
        .map(xs => unlines(xs.map(show))));
})();"
"function a(k, x1, x2, x3, x4, x5) {
  function b() {
    k -= 1;
    return a(k, b, x1, x2, x3, x4);
  }
  return (k > 0) ? b() : x4() + x5();
}
 

function x(n) {
  return function () {
    return n;
  };
}
alert(a(10, x(1), x(-1), x(-1), x(1), x(0)));var x = n => () => n;
 
var a = (k, x1, x2, x3, x4, x5) => {
  var b = () => return a(--k, b, x1, x2, x3, x4); //decrement k before use
  return (k > 0) ? b() : x4() + x5();
};"
"var n = 1024;
while (n > 0) {
  print(n);
  n /= 2;
}function loopWhile(varValue, fnDelta, fnTest) {
  'use strict';
  var d = fnDelta(varValue);
 
  return fnTest(d) ? [d].concat(
    loopWhile(d, fnDelta, fnTest)
  ) : [];
}
 
console.log(
  loopWhile(
    1024,
    function (x) {
      return Math.floor(x/2);
    },
    function (x) {
      return x > 0;
    }
  ).join('')
);512
256
128
64
32
16
8
4
2
1"
"//LZW Compression/Decompression for Strings
var LZW = {
    compress: function (uncompressed) {
        strv;
        
        var i,
            dictionary = {},
            c,
            wc,
            w = strv,
            result = [],
            dictSize = 256;
        for (i = 0; i < 256; i += 1) {
            dictionary[String.fromCharCode(i)] = i;
        }
 
        for (i = 0; i < uncompressed.length; i += 1) {
            c = uncompressed.charAt(i);
            wc = w + c;
            //Do not use dictionary[wc] because javascript arrays 
            //will return values for array['pop'], array['push'] etc
           
            if (dictionary.hasOwnProperty(wc)) {
                w = wc;
            } else {
                result.push(dictionary[w]);
                
                dictionary[wc] = dictSize++;
                w = String(c);
            }
        }
 
        
        if (w !== strv) {
            result.push(dictionary[w]);
        }
        return result;
    },
 
 
    decompress: function (compressed) {
        strv;
        
        var i,
            dictionary = [],
            w,
            result,
            k,
            entry = strv,
            dictSize = 256;
        for (i = 0; i < 256; i += 1) {
            dictionary[i] = String.fromCharCode(i);
        }
 
        w = String.fromCharCode(compressed[0]);
        result = w;
        for (i = 1; i < compressed.length; i += 1) {
            k = compressed[i];
            if (dictionary[k]) {
                entry = dictionary[k];
            } else {
                if (k === dictSize) {
                    entry = w + w.charAt(0);
                } else {
                    return null;
                }
            }
 
            result += entry;
 
            
            dictionary[dictSize++] = w + entry.charAt(0);
 
            w = entry;
        }
        return result;
    }
}, 
    comp = LZW.compress(strv),
    decomp = LZW.decompress(comp);
document.write(comp + '<br>' + decomp);"
for (;;) console.log(strv);while (true) console.log(strv);
"mod10check = function(cc) {
  return $A(cc).reverse().map(Number).inject(0, function(s, d, i) {
    return s + (i % 2 == 1 ? (d == 9 ? 9 : (d * 2) % 9) : d);
  }) % 10 == 0;
};
['49927398716','49927398717','1234567812345678','1234567812345670'].each(function(i){alert(mod10check(i))});var LuhnCheck = (function()
{
	var luhnArr = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];
	return function(str)
	{
		var counter = 0;
		var incNum;
		var odd = false;
		var temp = String(str).replace(/[^\d]/g, strv);
		if ( temp.length == 0)
			return false;
		for (var i = temp.length-1; i >= 0; --i)
		{
			incNum = parseInt(temp.charAt(i), 10);
			counter += (odd = !odd)? incNum : luhnArr[incNum];
		}
		return (counter%10 == 0);
	}
})();function luhn(str){
	return str.split('').reduceRight(function(prev, curr, idx){
		prev = parseInt(prev, 10);
		if ((idx + 1) % 2 !== 0) {
			curr = (curr * 2).toString().split('').reduce(function(p, c){ return parseInt(p, 10) + parseInt(c, 10)});
		}
		return prev + parseInt(curr, 10);
	}) % 10 === 0;
}var luhn10 = function(a,b,c,d,e) {
  for(d = +a[b = a.length-1], e=0; b--;)
    c = +a[b], d += ++e % 2 ? 2 * c % 10 + (c > 4) : c;
  return !(d%10)
};
 

luhn10('4111111111111111') 
 

luhn10('4111111111111112') 
 "
"function loop_plus_half(start, end) {
    var str = '',
        i;
    for (i = start; i <= end; i += 1) {
        str += i;
        if (i === end) {
          break;
        }
        str += ', ';
    }
    return str;
}
 
alert(loop_plus_half(1, 10));function range(m, n) {
  return Array.apply(null, Array(n - m + 1)).map(
    function (x, i) {
      return m + i;
    }
  );
}
 
console.log(
  range(1, 10).join(', ')
);1, 2, 3, 4, 5, 6, 7, 8, 9, 10function range(m, n) {
  return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
    return m + i;
  });
}
 
console.log(
  (function (nFrom, nTo) {
    var iLast = nTo - 1;
 
    return range(nFrom, nTo).reduce(
      function (accumulator, n, i) {
        return accumulator +
          n.toString() +
 
          (i < iLast ? ', ' : ''); 
 
      }, ''
    )
  })(1, 10)
);1, 2, 3, 4, 5, 6, 7, 8, 9, 10var s=1, e=10
for (var i=s; i<=e; i+=1) {
	document.write( i==s ? '' : ', ', i )
}var s=1, e=10
for (;; s+=1) {
	document.write( s )
	if (s==e) break
	document.write( ', ' )
}"
"
var a = [[2, 12, 10, 4], [18, 11, 9, 3], [14, 15, 7, 17], [6, 19, 8, 13], [1, 20, 16, 5]];
 
outer_loop:
for (var i in a) {
    print(strv + i);
    for (var j in a[i]) {
        print(strv + a[i][j]);
        if (a[i][j] == 20) 
            break outer_loop;
    }
}
print(strv);var lst = [[2, 12, 10, 4], [18, 11, 9, 3], [14, 15, 7, 17], [6, 19, 8, 13], [1,
  20, 16, 5]];
 
var takeWhile = function (lst, fnTest) {
    'use strict';
    var varHead = lst.length ? lst[0] : null;
 
    return varHead ? (
      fnTest(varHead) ? [varHead].concat(
        takeWhile(lst.slice(1), fnTest)
      ) : []
    ) : []
  },
 
  
  notTwenty = function (n) {
    return n !== 20;
  },
 
  
  
  lstChecked = takeWhile(lst, function (group) {
    return takeWhile(
      group,
      notTwenty
    ).length === 4;
  });
 
 

 
console.log(
  
  lstChecked.concat(
    takeWhile(
      lst[lstChecked.length], notTwenty
    )
  )
  
  .reduce(function (a, x) {
    return a.concat(x);
  }).join('')
);2
12
10
4
18
11
9
3
14
15
7
17
6
19
8
13
6
19
8
13
1"
"var output = '',
    i;
for (i = 2; i <= 8; i += 2) {
   output += i + ', ';
}
output += 'who do we appreciate?';
document.write(output);


function range() {
  var lngArgs = arguments.length,
    lngMore = lngArgs - 1;
 
  iMin = lngMore ? arguments[0] : 1;
  iMax = arguments[lngMore ? 1 : 0];
  dI = lngMore > 1 ? arguments[2] : 1;
 
  return lngArgs ? Array.apply(null, Array(
    Math.floor((iMax - iMin) / dI) + 1
  )).map(function (_, i) {
    return iMin + (dI * i);
  }) : [];
}
 
console.log(
  range(2, 8, 2).join(', ') + ', who do we appreciate ?'
);"
"strv.split(' ').forEach(
  function (x) {
    console.log(x);
  }
);console.log(strv.split(' ').map(
  function (x) {
    return x.toUpperCase(x);
  }
).join(''));console.log(
  strv.split(' ').reduce(
    function (a, x, i, lst) {
      return lst.length - i + '. ' + x + '' + a;
    }, ''
  )
)for (var a in o) {
    print(o[a]);
}for (var a in o) {
    if (o.hasOwnProperty(a)) {
        print(o[a]);
    }
}h = {strv:1, strv:2, strv:3}
for (x in h) print(x);
/*twoonethree*/
 
for each (y in h) print(y);
/*213*/h = {strv:1, strv:2, strv:3}
for (x in h) print(x);
/*twoonethree*/
 
for (y of h) print(y);
/*213*/"
"var val = 0;
do {
  print(++val);
} while (val % 6);function doWhile(varValue, fnBody, fnTest) {
  'use strict';
  var d = fnBody(varValue); 
 
  return fnTest(d) ? [d].concat(
    doWhile(d, fnBody, fnTest)
  ) : [d];
}
 
console.log(
  doWhile(0,           
    function (x) {     
      return x + 1;
    },
    function (x) {     
      return x % 6;
    }
  ).join('')
);1
2
3
4
5
6function range(m, n) {
  'use strict';
  return Array.apply(null, Array(n - m + 1)).map(
    function (x, i) {
      return m + i;
    }
  );
}
 
function takeWhile(lst, fnTest) {
 'use strict';
  var varHead = lst.length ? lst[0] : null;
 
  return varHead ? (
    fnTest(varHead) ? [varHead].concat(
      takeWhile(lst.slice(1), fnTest)
    ) : []
  ) : []
}
 
console.log(
  takeWhile(
    range(1, 100),
    function (x) {
      return x % 6;
    }
  ).join('')
);1
2
3
4
5(() => {
    'use strict';
 
    
    function unfoldr(mf, v) {
        for (var lst = [], a = v, m;
            (m = mf(a)) && m.valid;) {
            lst.push(m.value), a = m.new;
        }
        return lst;
    }
 
    
    function until(p, f, x) {
        let v = x;
        while(!p(v)) v = f(v);
        return v;
    }
 
    let result1 = unfoldr(
        x => {
            return {
                value: x,
                valid: (x % 6) !== 0,
                new: x + 1
            }
        },
        1
    );
 
    let result2 = until(
        m => (m.n % 6) === 0,
        m => {
            return {
                n : m.n + 1,
                xs : m.xs.concat(m.n)
            };
        },
        {
            n: 1,
            xs: []
        }
    ).xs;
 
    return [result1, result2];
})();
 [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]"
"for (var i=10; i>=0; --i) print(i);for (var i = 11; i--;) console.log(i);var i = 11;
while (i--) console.log(i);function range(m, n) {
  return Array.apply(null, Array(n - m + 1)).map(
    function (x, i) {
      return m + i;
    }
  );
}
 
range(0, 10).reverse().forEach(
  function (x) {
    console.log(x);
  }
);console.log(
  range(0, 10).reverse().map(
    function (x) {
      return x;
    }
  ).join('')
);console.log(
    range(0, 10).reverse().join('')
);"
"var i, j;
for (i = 1; i <= 5; i += 1) {
  s = '';
  for (j = 0; j < i; j += 1)
    s += '*';
  document.write(s + '<br>');
}function range(i) {
  return i ? range(i - 1).concat(i) : [];
}
 
range(5) --> [1, 2, 3, 4, 5]var s = '';
 
range(5).forEach(
  function (line) {
    range(line).forEach(
      function () { s += '*'; }
    );
    s += '';
  }
);
 
console.log(s);console.log(
  range(5).reduce(
    function (a, n) {
      return a + Array(n + 1).join('*') + '';
    }, ''
  )
);console.log(
  range(5).map(function(a) {
    return Array(a + 1).join('*');
  }).join('')
);for (let i: number = 0; i < 5; ++i) {
    let line: string = strv
    for(let j: number = 0; j <= i; ++j) {
        line += strv
    }
    console.log(line)
}
 "
"var output = strv;
for (var i = 1; i <= 10; i++) {
  output += i; 
  if (i % 5 == 0) {
    print(output);
    output = strv;
    continue;
  } 
  output += strv;
}function rng(n) {
  return n ? rng(n - 1).concat(n) : [];
}
 
console.log(
  rng(10).reduce(
    function (a, x) {
      return a + x.toString() + (x % 5 ? ', ' : '');
    }, ''
  )
);1, 2, 3, 4, 5
6, 7, 8, 9, 10
 "
"for (;;) {
  var a = Math.floor(Math.random() * 20);
  print(a);
  if (a == 10) 
    break;
  a = Math.floor(Math.random() * 20);
  print(a);
}(function streamTillInitialTen() {
    var nFirst = Math.floor(Math.random() * 20);
 
    console.log(nFirst);
 
    if (nFirst === 10) return true;
 
    console.log(
        Math.floor(Math.random() * 20)
    );
 
    return streamTillInitialTen();
})();console.log(
  (function streamTillInitialTen() {
    var nFirst = Math.floor(Math.random() * 20);
 
    if (nFirst === 10) return [10];
 
    return [
      nFirst,
      Math.floor(Math.random() * 20)
    ].concat(
      streamTillInitialTen()
    );
  })().join('')
);"
"var a = [strv,strv,strv],
    b = [strv,strv,strv],
    c = [1,2,3],
    output = strv,
    i;
for (i = 0; i < a.length; i += 1) {
    output += a[i] + b[i] + c[i] + """";
}var lstOut = ['', '', ''];
 
[[strv, strv, strv], [strv, strv, strv], [strv, strv, strv]].forEach(
  function (a) {
    [0, 1, 2].forEach(
      function (i) {
        
        lstOut[i] += a[i];
      }
    );
  }
);
 
(function (lstArrays) {
 
    return lstArrays.reduce(
        function (a, e) {
            return [
                a[0] + e[0],
                a[1] + e[1],
                a[2] + e[2]
            ];
        }, ['', '', ''] 
    ).join('');
 
})([
    [strv, strv, strv],
    [strv, strv, strv],
    [strv, strv, strv]
]);(function (x, y, z) {
 
    
    
    function zipWith3(f, xs, ys, zs) {
        return zs.length ? [f(xs[0], ys[0], zs[0])].concat(
            zipWith3(f, xs.slice(1), ys.slice(1), zs.slice(1))) : [];
    }
 
    function concat(x, y, z) {
        return ''.concat(x, y, z);
    }
 
    return zipWith3(concat, x, y, z).join('')
 
})([strv, strv, strv], [strv, strv, strv], [1, 2, 3]);(function () {
    'use strict';
 
    
    function zipListsWith(f, xss) {
        return (xss.length ? xss[0] : [])
            .map(function (_, i) {
                return f(xss.map(function (xs) {
                    return xs[i];
                }));
            });
    }
 
 
 
 
    
 
    
    function concat(lst) {
        return ''.concat.apply('', lst);
    }
 
 
    
 
    return zipListsWith(
        concat, 
        [[strv, strv, strv], [strv, strv, strv], [1, 2, 3]]
    )
    .join('');
 
})();aA1
bB2
cC3"
"function lookandsay(str) {
    return str.replace(/(.)\1*/g, function(seq, p1){return seq.length.toString() + p1})
}
 
var num = strv;
for (var i = 10; i > 0; i--) {
    alert(num);
    num = lookandsay(num);
}function lookSay(digits) {
    var result = '',
        chars = (digits + ' ').split(''),
        lastChar = chars[0],
        times = 0;
 
    chars.forEach(function(nextChar) {
        if (nextChar === lastChar) {
            times++;
        }
        else {
            result += (times + '') + lastChar;
            lastChar = nextChar;
            times = 1;
        }
    });
 
    return result;
}
 
(function output(seed, iterations) {
    for (var i = 0; i < iterations; i++) {
        console.log(seed);
        seed = lookSay(seed);
    }
})(strv, 10);"
"function lcs(a, b) {
  var aSub = a.substr(0, a.length - 1);
  var bSub = b.substr(0, b.length - 1);
 
  if (a.length === 0 || b.length === 0) {
    return '';
  } else if (a.charAt(a.length - 1) === b.charAt(b.length - 1)) {
    return lcs(aSub, bSub) + a.charAt(a.length - 1);
  } else {
    var x = lcs(a, bSub);
    var y = lcs(aSub, b);
    return (x.length > y.length) ? x : y;
  }
} 
var longest = (xs, ys) => (xs.length > ys.length) ? xs : ys;
 
var lcs = (xx, yy) => {
  if (!xx.length || !yy.length) { return ''; }
 
  var x = xx[0],
      y = yy[0];
  xs = xx.slice(1);
  ys = yy.slice(1);
 
  return (x === y) ? lcs(xs, ys) :
                     longest(lcs(xx, ys), lcs(xs, yy));
};function lcs(x,y){
	var s,i,j,m,n,
		lcs=[],row=[],c=[],
		left,diag,latch;
	//make sure shorter string is the column string
	if(m<n){s=x;x=y;y=s;}
	m = x.length;
	n = y.length;
	//build the c-table
	for(j=0;j<n;row[j++]=0);
	for(i=0;i<m;i++){
		c[i] = row = row.slice();
		for(diag=0,j=0;j<n;j++,diag=latch){
			latch=row[j];
			if(x[i] == y[j]){row[j] = diag+1;}
			else{
				left = row[j-1]||0;
				if(left>row[j]){row[j] = left;}
			}
		}
	}
	i--,j--;
	//row[j] now contains the length of the lcs
	//recover the lcs from the table
	while(i>-1&&j>-1){
		switch(c[i][j]){
			default: j--;
				lcs.unshift(x[i]);
			case (i&&c[i-1][j]): i--;
				continue;
			case (j&&c[i][j-1]): j--;
		}
	}
	return lcs.join('');
}	var t=i;
	while(i>-1&&j>-1){
		switch(c[i][j]){
			default:i--,j--;
				continue;
			case (i&&c[i-1][j]):
				if(t!==i){lcs.unshift(x.substring(i+1,t+1));}
				t=--i;
				continue;
			case (j&&c[i][j-1]): j--;
				if(t!==i){lcs.unshift(x.substring(i+1,t+1));}
				t=i;
		}
	}
	if(t!==i){lcs.unshift(x.substring(i+1,t+1));}function lcs_greedy(x,y){
  var p1, i, idx,
      symbols = {},
      r = 0,
      p = 0,
      l = 0,
      m = x.length,
      n = y.length,
      s = new Buffer((m < n) ? n : m);
 
  p1 = popsym(0);
 
  for (i = 0; i < m; i++) {
    p = (r === p) ? p1 : popsym(i);
    p1 = popsym(i + 1);
    if (p > p1) {
      i += 1;
      idx = p1;
    } else {
      idx = p;
    }
 
    if (idx === n) {
      p = popsym(i);
    } else {
      r = idx;
      s[l] = x.charCodeAt(i);
      l += 1;
    }
  }
  return s.toString('utf8', 0, l);
 
  function popsym(index) {
    var s = x[index],
        pos = symbols[s] + 1;
 
    pos = y.indexOf(s, ((pos > r) ? pos : r));
    if (pos === -1) { pos = n; }
    symbols[s] = pos;
    return pos;
  }
}lcs_greedy('bcaaaade', 'deaaaabc'); "
"(function () {
    'use strict';
 
    function lcp() {
        var lst = [].slice.call(arguments),
            n = lst.length ? takewhile(same, zip.apply(null, lst)).length : 0;
 
        return n ? lst[0].substr(0, n) : '';
    }
 
 
    
    function takewhile(p, lst) {
        var x = lst.length ? lst[0] : null;
        return x !== null && p(x) ? [x].concat(takewhile(p, lst.slice(1))) : [];
    }
 
    
    
    function zip() {
        var lngLists = arguments.length,
            lngMin = Infinity,
            lstZip = [],
            arrTuple = [],
            lngLen, i, j;
 
        for (i = lngLists; i--;) {
            lngLen = arguments[i].length;
            if (lngLen < lngMin) lngMin = lngLen;
        }
 
        for (i = 0; i < lngMin; i++) {
            arrTuple = [];
            for (j = 0; j < lngLists; j++) {
                arrTuple.push(arguments[j][i]);
            }
            lstZip.push(arrTuple);
        }
        return lstZip;
    }
 
    
    function same(lst) {
        return (lst.reduce(function (a, x) {
            return a === x ? a : null;
        }, lst[0])) !== null;
    }
 
 
    
 
    return [
        lcp(strv, strv, strv) === strv,
        lcp(strv, strv) === strv,
        lcp(strv, strv) === strv,
        lcp(strv) === strv,
        lcp(strv) === strv,
        lcp(strv, strv) === strv,
        lcp(strv, strv) == strv
    ];
 
})();[true, true, true, true, true, true, true]

function zip() {
    var args = [].slice.call(arguments),
        lngMin = args.reduce(function (a, x) {
            var n = x.length;
            return n < a ? n : a;
        }, Infinity);
 
    if (lngMin) {
        return args.reduce(function (a, v) {
            return (
                typeof v === 'string' ? v.split('') : v
            ).slice(0, lngMin).map(a ? function (x, i) {
                return a[i].concat(x);
            } : function (x) {
                return [x];
            });
        }, null)
    } else return [];
}"
" 
 
var _ = require('underscore');
function findIndex(input){
	var len = input.length;
	var maxSeqEndingHere = _.range(len).map(function(){return 1;});
	for(var i=0; i<len; i++)
		for(var j=i-1;j>=0;j--)
			if(input[i] > input[j] && maxSeqEndingHere[j] >= maxSeqEndingHere[i])
				maxSeqEndingHere[i] = maxSeqEndingHere[j]+1;
	return maxSeqEndingHere;
}
 
function findSequence(input, result){
	var maxValue = Math.max.apply(null, result);
	var maxIndex = result.indexOf(Math.max.apply(Math, result));
	var output = [];
	output.push(input[maxIndex]);
	for(var i = maxIndex ; i >= 0; i--){
		if(maxValue==0)break;
		if(input[maxIndex] > input[i]  && result[i] == maxValue-1){
			output.push(input[i]);
			maxValue--;
		}
	}
	output.reverse();
	return output;
}
 
 
var x = [0, 7, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
var y = [3, 2, 6, 4, 5, 1];
 
var result = findIndex(x);
var final = findSequence(x, result);
console.log(final);
 
var result1 = findIndex(y);
var final1 = findSequence(y, result1);
console.log(final1);
 "
"function logic(a,b) {
  print(strv + (a && b));
  print(strv + (a || b));
  print(strv + (!a));
}!logic:
  (a? b?)
    [
    println(strv a and b)
    println(strv  a or b)
    println(strv   not a)
    println(strv a xor b)
    println(strv a nand b)
    println(strv a nor b)
    println(strv a nxor b)
    ]
 logic(true false)"
"(function () {
    return strv
})();
 
 
(function() {
    return ""03b103b203b303b4 4e2d95f4676570b94e2d6587 d83ddc2b 05d005d105d205d3"";
})();"
"
 
(function (n) {
 
    return mb(r(1,     n), function (x) {  
    return mb(r(1 + x, n), function (y) {  
    return mb(r(1 + y, n), function (z) {  
 
       return x * x + y * y === z * z ? [[x, y, z]] : [];
 
    })})});
 
 
    
 
    
    function mb(xs, f) {
        return [].concat.apply([], xs.map(f));
    }
 
    
    
 
    
    function r(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (n, x) {
                return m + x;
            });
    }
 
})(100);function range(begin, end) {
    for (let i = begin; i < end; ++i) 
        yield i;
}
 
function triples(n) {
    return [[x,y,z] for each (x in range(1,n+1)) 
                     for each (y in range(x,n+1)) 
                     for each (z in range(y,n+1)) 
                     if (x*x + y*y == z*z) ]
}
 
for each (var triple in triples(20))
    print(triple);(n => {
    'use strict';
 
    
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const pure = x => [x];
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
    
 
    
 
    return  concatMap(x =>
            concatMap(y =>
            concatMap(z =>
 
                x * x + y * y === z * z ? pure([x, y, z]) : [],
 
            enumFromTo(y, n)),
            enumFromTo(x, n)),
            enumFromTo(1, n));
})(20);[[3, 4, 5], [5, 12, 13], [6, 8, 10], [8, 15, 17], [9, 12, 15], [12, 16, 20]]"
"if ( 727 == 0x2d7 && 
     727 == 01327 )
    window.alert(strv);"
"function mult(strNum1,strNum2){
 
    var a1 = strNum1.split(strv).reverse();
    var a2 = strNum2.toString().split(strv).reverse();
    var aResult = new Array;
 
    for ( var iterNum1 = 0; iterNum1 < a1.length; iterNum1++ ) {
        for ( var iterNum2 = 0; iterNum2 < a2.length; iterNum2++ ) {
            var idxIter = iterNum1 + iterNum2;    
            aResult[idxIter] = a1[iterNum1] * a2[iterNum2] + ( idxIter >= aResult.length ? 0 : aResult[idxIter] );
 
            if ( aResult[idxIter] > 9 ) {    
                aResult[idxIter + 1] = Math.floor( aResult[idxIter] / 10 ) + ( idxIter + 1 >= aResult.length ? 0 : aResult[idxIter + 1] );
                aResult[idxIter] -= Math.floor( aResult[idxIter] / 10 ) * 10;
            }
        }
    }
    return aResult.reverse().join(strv);
}
 
 
mult('18446744073709551616', '18446744073709551616')(function () {
    'use strict';
 
    
    
    
 
 
    
    function longMult(num1, num2) {
        return largeIntegerString(
            digitProducts(digits(num1), digits(num2))
        );
    }
 
 
 
    
    function digitProducts(xs, ys) {
        return multTable(xs, ys)
            .map(function (zs, i) {
                return Array.apply(null, Array(i))
                    .map(function () {
                        return 0;
                    })
                    .concat(zs);
            })
            .reduce(function (a, x) {
                if (a) {
                    var lng = a.length;
 
                    return x.map(function (y, i) {
                        return y + (i < lng ? a[i] : 0);
                    })
 
                } else return x;
            })
    }
 
 
    
    function largeIntegerString(lstColumnValues) {
        var dctProduct = lstColumnValues
            .reduceRight(function (a, x) {
                var intSum = x + a.carried,
                    intDigit = intSum % 10;
 
                return {
                    digits: intDigit
                        .toString() + a.digits,
                    carried: (intSum - intDigit) / 10
                };
            }, {
                digits: '',
                carried: 0
            });
 
        return (dctProduct.carried > 0 ? (
            dctProduct.carried.toString()
        ) : '') + dctProduct.digits;
    }
 
 
    
    function multTable(xs, ys) {
        return ys.map(function (y) {
            return xs.map(function (x) {
                return x * y;
            })
        });
    }
 
    
    function digits(n) {
        return (typeof n === 'string' ? n : n.toString())
            .split('')
            .map(function (x) {
                return parseInt(x, 10);
            });
    }
 
 
    
    
 
 
    return {
        fromIntegerStrings: longMult(
            '18446744073709551616',
            '18446744073709551616'
        ),
        fromBoundedIntegers: longMult(
            18446744073709551616,
            18446744073709551616
        )
    };
 
})();"
"function levenshtein(a, b) {
  var t = [], u, i, j, m = a.length, n = b.length;
  if (!m) { return n; }
  if (!n) { return m; }
  for (j = 0; j <= n; j++) { t[j] = j; }
  for (i = 1; i <= m; i++) {
    for (u = [i], j = 1; j <= n; j++) {
      u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : Math.min(t[j - 1], t[j], u[j - 1]) + 1;
    } t = u;
  } return u[n];
}
 

[ ['', '', 0],
  ['yo', '', 2],
  ['', 'yo', 2],
  ['yo', 'yo', 0],
  ['tier', 'tor', 2],
  ['saturday', 'sunday', 3],
  ['mist', 'dist', 1],
  ['tier', 'tor', 2],
  ['kitten', 'sitting', 3],
  ['stop', 'tops', 2],
  ['rosettacode', 'raisethysword', 8],
  ['mississippi', 'swiss miss', 8]
].forEach(function(v) {
  var a = v[0], b = v[1], t = v[2], d = levenshtein(a, b);
  if (d !== t) {
    console.log('levenstein(""' + a + 'strv' + b + '"") was ' + d + ' should be ' + t);
  }
});(() => {
    'use strict';
 
    
    const levenshtein = (sa, sb) => {
        const [s1, s2] = [sa.split(''), sb.split('')];
 
        return last(s2.reduce((ns, c) => {
            const [n, ns1] = uncons(ns);
 
            return scanl(
                (z, [c1, x, y]) =>
                minimum(
                    [y + 1, z + 1, x + fromEnum(c1 != c)]
                ),
                n + 1,
                zip3(s1, ns, ns1)
            );
        }, range(0, s1.length)));
    };
 
 
    /*********************************************************************/
    
 
    
    const minimum = xs =>
        xs.reduce((a, x) => (x < a || a === undefined ? x : a), undefined);
 
    
    const fromEnum = x => {
        const type = typeof x;
        return type === 'boolean' ? (
            x ? 1 : 0
        ) : (type === 'string' ? x.charCodeAt(0) : undefined);
    };
 
    
    const uncons = xs => xs.length ? [xs[0], xs.slice(1)] : undefined;
 
    
    const scanl = (f, a, xs) => {
        for (var lst = [a], lng = xs.length, i = 0; i < lng; i++) {
            a = f(a, xs[i], i, xs), lst.push(a);
        }
        return lst;
    };
 
    
    const zip3 = (xs, ys, zs) =>
        xs.slice(0, Math.min(xs.length, ys.length, zs.length))
        .map((x, i) => [x, ys[i], zs[i]]);
 
    
    const last = xs => xs.length ? xs.slice(-1) : undefined;
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    /*********************************************************************/
    
    return [
        [strv, strv],
        [strv, strv],
        [strv, strv],
        [strv, strv]
    ].map(pair => levenshtein.apply(null, pair));
 
    
})();[3, 3, 8, 8]"
"(function(txt) {
 
    var cs = txt.split(''),
        i = cs.length,
        dct =  {},
        c = '',
        keys;
 
    while (i--) {
        c = cs[i];
        dct[c] = (dct[c] || 0) + 1;
    }
 
    keys = Object.keys(dct);
    keys.sort();
    return keys.map(function (c) { return [c, dct[c]]; });
 
})(""Not all that Mrs. Bennet, however, with the assistance of her fivedaughters, could ask on the subject, was sufficient to draw from herhusband any satisfactory description of Mr. Bingley. They attacked himin various ways--with barefaced questions, ingenious suppositions, anddistant surmises; but he eluded the skill of them all, and they were atlast obliged to accept the second-hand intelligence of their neighbour,Lady Lucas. Her report was highly favourable. Sir William had beendelighted with him. He was quite young, wonderfully handsome, extremelyagreeable, and, to crown the whole, he meant to be at the next assemblywith a large party. Nothing could be more delightful! To be fond ofdancing was a certain step towards falling in love; and very livelyhopes of Mr. Bingley's heart were entertained.""); [[strv, 121], [strv, 1], [strv, 1], [strv, 13], [strv, 3], [strv, 9], [strv, 2], 
[strv, 3], [strv, 2], [strv, 2], [strv, 3], [strv, 2], [strv, 1], [strv, 2], [strv, 1], 
[strv, 53], [strv, 13], [strv, 17], [strv, 29], [strv, 82], [strv, 17], [strv, 16], [strv, 36],
[strv, 44], [strv, 1], [strv, 3], [strv, 34], [strv, 11], [strv, 41], [strv, 40], [strv, 8], 
[strv, 2], [strv, 35], [strv, 39], [strv, 55], [strv, 20], [strv, 7], [strv, 17], [strv, 2], [strv, 16]]"
" 


function pmat01(mat, color) {
  
  var cvs = document.getElementById('canvId');
  var ctx = cvs.getContext(strv); 
  var w = cvs.width; var h = cvs.height;
  var m = mat[0].length; var n = mat.length;
  
  ctx.fillStyle=strv; ctx.fillRect(0,0,w,h);
  ctx.fillStyle=color;
  
  for(var i=0; i<m; i++) {
    for(var j=0; j<n; j++) {
      if(mat[i][j]==1) { ctx.fillRect(i,j,1,1)};
    }//fend j
  }//fend i
}//func end


function ckpbfmat(m,ord) {
  var rm=m;
  for(var i=1; i<ord; i++) {rm=mkp(rm,m)};
  //matpp2doc('R 4 ordd',rm,'*'); // ASCII strv - if you wish to try.
  return(rm);
}

function cpmat(m,ord,color) {
  var kpr;
  kpr=ckpbfmat(m,ord);
  pmat01(kpr,color);
}


function matpp2doc(title,mat,chr) {
  var i,j,re='',e; var m=mat.length; var n=mat[0].length;
  document.write('&nbsp;&nbsp;<b>'+title+'</b>:<pre>');
  for(var i=0; i<m; i++) {
    for(var j=0; j<n; j++) {
      e='&nbsp;'; if(mat[i][j]==1) {e=chr}; re+=e; 
    }//fend j
    document.write('&nbsp;&nbsp;'+re+'<br />'); re='';
  }//fend i
  document.write('</pre>');
}


mkp=(a,b)=>a.map(a=>b.map(b=>a.map(y=>b.map(x=>r.push(y*x)),t.push(r=[]))),t=[])&&t;
 "
"function LCM(A)  
{   
    var n = A.length, a = Math.abs(A[0]);
    for (var i = 1; i < n; i++)
     { var b = Math.abs(A[i]), c = a;
       while (a && b){ a > b ? a %= b : b %= a; } 
       a = Math.abs(c*A[i])/(a+b);
     }
    return a;
}
 
/* For example:   LCM([-50,25,-45,-18,90,447]) -> 67050*/(() => {
    'use strict';
 
    
    let gcd = (x, y) => {
        let _gcd = (a, b) => (b === 0 ? a : _gcd(b, a % b)),
            abs = Math.abs;
        return _gcd(abs(x), abs(y));
    }
 
    
    let lcm = (x, y) =>
        x === 0 || y === 0 ? 0 : Math.abs(Math.floor(x / gcd(x, y)) * y);
 
    
    return lcm(12, 18);
 
})();"
"var isLeapYear = function (year) { return (year % 100 === 0) ? (year % 400 === 0) : (year % 4 === 0); };
var isLeapYear = function (year) { return new Date(year, 1, 29).getDate() === 29; };"
" 




mkp=(a,b)=>a.map(a=>b.map(b=>a.map(y=>b.map(x=>r.push(y*x)),t.push(r=[]))),t=[])&&t;


function matl2cons(title,mat) {console.log(title); console.log(mat.join`\n`)}

function pttl2doc(title) {document.write('<b>'+title+'</b><br />')}

function matp2doc(title,mat) {
  document.write('<b>'+title+'</b>:<br />');
  for (var i = 0; i < mat.length; i++) {
    document.write('&nbsp;&nbsp;'+mat[i].join(' ')+'<br />');
  }
}
  




function mkp2(a,b) {
  var m=a.length, n=a[0].length, p=b.length, q=b[0].length;
  var rtn=m*p, ctn=n*q; var r=new Array(rtn);
  for (var i=0; i<rtn; i++) {r[i]=new Array(ctn)
    for (var j=0;j<ctn;j++) {r[i][j]=0}
  }
  for (var i=0; i<m; i++) {
    for (var j=0; j<n; j++) {
      for (var k=0; k<p; k++) {
        for (var l=0; l<q; l++) {
          r[p*i+k][q*j+l]=a[i][j]*b[k][l];
        }}}}//all4forend
  return(r);
}


function matl2cons(title,mat) {console.log(title); console.log(mat.join`\n`)}

function pttl2doc(title) {document.write('<b>'+title+'</b><br>')}

function matp2doc(title,mat) {
  document.write('<b>'+title+'</b>:<br>');
  for (var i=0; i < mat.length; i++) {
    document.write('&nbsp;&nbsp;'+mat[i].join(' ')+'<br>');
  }
}
 (() => {
    'use strict';
 
    
 
    
    const concat = xs => [].concat.apply([], xs);
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const map = curry((f, xs) => xs.map(f));
 
    
    const show = x => JSON.stringify(x); //, null, 2);
 
    
    const transpose = xs =>
        xs[0].map((_, col) => xs.map(row => row[col]));
 
    
    const unlines = xs => xs.join('');
 
 
    
 
    
    const kprod = (xs, ys) =>
        concatMap(
            m => map(concat, transpose(m)),
            map(map(f(ys)), xs)
        );
 
    
    
    const f = curry((mx, n) => map(map(x => x * n), mx));
 
    
    return unlines(map(rows => unlines(map(show, rows)), [
        kprod([
            [1, 2],
            [3, 4]
        ], [
            [0, 5],
            [6, 7]
        ]), [], 
        kprod([
            [0, 1, 0],
            [1, 1, 1],
            [0, 1, 0]
        ], [
            [1, 1, 1, 1],
            [1, 0, 0, 1],
            [1, 1, 1, 1]
        ])
    ]));
})();"
" (function () {
     'use strict';
 
     
     function maxCombine(xs) {
         return parseInt(
             xs.sort(
                 function (x, y) {
                     var a = x.toString(),
                         b = y.toString(),
                         ab = parseInt(a + b),
                         ba = parseInt(b + a);
 
                     return ab > ba ? -1 : (ab < ba ? 1 : 0);
                 }
             )
             .join(''), 10
         );
     }
 
     return [
        [1, 34, 3, 98, 9, 76, 45, 4],
        [54, 546, 548, 60]
     ].map(maxCombine);
 
 })();
 var maxCombine = (a) => +(a.sort((x, y) => +(strv + y + x) - +(strv + x + y)).join(''));
 

console.log([
  [1, 34, 3, 98, 9, 76, 45, 4],
  [54, 546, 548, 60]
].map(maxCombine));"
"function knuthShuffle(arr) {
    var rand, temp, i;
 
    for (i = arr.length - 1; i > 0; i -= 1) {
        rand = Math.floor((i + 1) * Math.random());//get random between zero and i (inclusive)
        temp = arr[rand];//swap i and the zero-indexed number
        arr[rand] = arr[i];
        arr[i] = temp;
    }
    return arr;
}
 
var res = {
    '1,2,3': 0, '1,3,2': 0,
    '2,1,3': 0, '2,3,1': 0,
    '3,1,2': 0, '3,2,1': 0
};
 
for (var i = 0; i < 100000; i++) {
    res[knuthShuffle([1,2,3]).join(',')] += 1;
}
 
for (var key in res) {
    print(key + """" + res[key]);
}(lst => {
 
    
    let knuthShuffle = lst =>
        range(0, lst.length - 1)
        .reduceRight((a, i) => {
            let iRand = i ? randomInteger(0, i) : 0,
                tmp = a[iRand];
 
            return iRand !== i ?  (
                a[iRand] = a[i],
                a[i] = tmp,
                a
            ) : a;
        }, lst),
 
        
        randomInteger = (low, high) =>
        low + Math.floor(
            (Math.random() * ((high - low) + 1))
        ),
 
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        };
 
 
    return knuthShuffle(lst);
 
})(
    'alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu'
    .split(' ')
  );[strv, strv, strv, strv, strv, strv, 
strv, strv, strv, strv, strv, strv](lst => {
 
    
    function knuthShuffle(lst) {
        let lng = lst.length;
 
        return lng ? range(0, lng - 1)
            .reduceRight((a, i) => {
                let iRand = i > 0 ? randomInteger(0, i) : 0;
 
                return i !== iRand ? swapped(a, i, iRand) : a;
            }, lst) : [];
    };
 
 
    
 
    
    let swapped = (lst, iFrom, iTo) => {
            let [iLow, iHigh] = iTo > iFrom ? (
                    [iFrom, iTo]
            ) : [iTo, iFrom];
 
            return iLow !== iHigh ? (
                    [].concat(
                        (iLow > 0 ? lst.slice(0, iLow) : []), 
                        lst[iHigh],                           
                        lst.slice(iLow + 1, iHigh),           
                        lst[iLow],                            
                        lst.slice(iHigh + 1)                  
                    )                         
                ) : lst.slice(0) 
        },
 
        
        randomInteger = (low, high) =>
        low + Math.floor(
            (Math.random() * ((high - low) + 1))
        ),
 
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        };
 
 
    return knuthShuffle(lst);
 
})(
    'alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu'
    .split(' ')
);[strv, strv, strv, strv, strv, strv, 
strv, strv, strv, strv, strv, strv]"
" 

var canvas = document.createElement('canvas');
canvas.id = 'globalCanvas';
document.body.appendChild(canvas);
 
function langtonant(antx, optx) {
	'use strict';
	var x, y, i;
 
	
	var opts = {
		gridsize: 100,
		pixlsize: 4,
		interval: 4
	};
	for (i in optx) {
		opts[i] = optx[i];
	}
 
	
	var ants = [{
		x: 50,
		y: 50,
		d: 0
	}];
	for (i in antx) {
		ants[i] = antx[i];
	}
 
	
	var grid = [];
	for (x = 0; x < opts.gridsize; x ++) {
		grid[x] = [];
		for (y = 0; y < opts.gridsize; y ++) {
			grid[x][y] = true;
		}
	}
 
	
	var dirs = [
		{x: 1, y: 0},
		{x: 0, y: -1},
		{x: -1, y: 0},
		{x: 0, y: 1}
	];
 
	
	var canv = document.getElementById('globalCanvas');
	var cont = canv.getContext('2d');
	canv.width = opts.gridsize * opts.pixlsize;
	canv.height = opts.gridsize * opts.pixlsize;
 
	
	var pixlblac = cont.createImageData(opts.pixlsize, opts.pixlsize);
	for (i = 0; i < (opts.pixlsize * opts.pixlsize * 4); i += 4) {
		pixlblac.data[i + 3] = 255;
	}
	var pixlwhit = cont.createImageData(opts.pixlsize, opts.pixlsize);
	for (i = 0; i < (opts.pixlsize * opts.pixlsize * 4); i += 4) {
		pixlwhit.data[i + 3] = 0;
	}
 
	
	function simulate() {
		var sane = true;
 
		
		for (i = 0; i < ants.length; i ++) {
			var n = ants[i];
 
			
			if (grid[n.x][n.y]) {
				grid[n.x][n.y] = false;
				cont.putImageData(pixlblac, n.x * opts.pixlsize, n.y * opts.pixlsize);
				n.d --;
			} else {
				grid[n.x][n.y] = true;
				cont.putImageData(pixlwhit, n.x * opts.pixlsize, n.y * opts.pixlsize);
				n.d ++;
			}
 
			
			n.d += dirs.length;
			n.d %= dirs.length;
 
			
			n.x += dirs[n.d].x;
			n.y += dirs[n.d].y;
 
			
			sane = (n.x < 0 || n.x > opts.gridsize || n.y < 0 || n.y > opts.gridsize) ? false : sane;
		}
 
		
		if (sane) {
			setTimeout(simulate, opts.interval);
		}
	}
 
	simulate();
}
  
langtonant({}, {
	gridsize: 100,
	pixlsize: 4,
	interval: 4
});
  
langtonant([
	{
		x: (100 / 2) + 7,
		y: (100 / 2) + 7,
		d: 1
	}, {
		x: (100 / 2) + 7,
		y: (100 / 2) - 7,
		d: 2
	}, {
		x: (100 / 2) - 7,
		y: (100 / 2) - 7,
		d: 3
	}, {
		x: (100 / 2) - 7,
		y: (100 / 2) + 7,
		d: 0
	}
]);
  
///////////////////

///////////////////
 

_.each(_.keys(_), k => window[k === 'isNaN' ? '_isNaN' : k] = _[k]);
 
const
WORLD_WIDTH  = 100,
WORLD_HEIGHT = 100,
PIXEL_SIZE   = 4,
DIRTY_COLOR  = '#000',
VIRGIN_COLOR = '#fff',
RUNS         = 10000,
SPEED        = 50,
 

DIRECTIONS = [0, 1,    2,    3],
 
displayWorld = (world) => each(world, (row, rowidx) => {
  each(row, (cell, cellidx) => {
    canvas.fillStyle = cell === 1 ? DIRTY_COLOR : VIRGIN_COLOR;
    canvas.fillRect(rowidx * PIXEL_SIZE, cellidx * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
  });
}),
 
moveAnt = (world, ant) => {
  world[ant.x][ant.y] = world[ant.x][ant.y] === 1 ? 0 : 1;
  ant.dir             = DIRECTIONS[(4 + ant.dir + (world[ant.x][ant.y] === 0 ? 1 : -1)) % 4];
  switch (ant.dir) {
    case DIRECTIONS[0]:
      ant.y -= 1;
      break;
    case DIRECTIONS[1]:
      ant.x -= 1;
      break;
    case DIRECTIONS[2]:
      ant.y += 1;
      break;
    case DIRECTIONS[3]:
      ant.x += 1;
      break;
  }
 
  return [world, ant];
},
 
updateWorld = (world, ant, runs) => {
  [world, ant] = moveAnt(world, ant);
  displayWorld(world);
 
  if (runs > 0) setTimeout(partial(updateWorld, world, ant, --runs), SPEED);
},
 
canvas = document.getElementById('c').getContext('2d');
 
let
world = map(range(WORLD_HEIGHT), i => map(range(WORLD_WIDTH), partial(identity, 0))),
ant   = {
  x:   WORLD_WIDTH  / 2,
  y:   WORLD_HEIGHT / 2,
  dir: DIRECTIONS[0]
};
 
canvas.canvas.width  = WORLD_WIDTH  * PIXEL_SIZE;
canvas.canvas.height = WORLD_HEIGHT * PIXEL_SIZE;
 
updateWorld(world, ant, RUNS);
 "
"document.onkeydown = function(evt) {
  if (evt.keyCode === 118) {
    alert(strv);
    return false;
  }
}"
"var gold = { 'value': 2500, 'weight': 2.0, 'volume': 0.002 },
    panacea = { 'value': 3000, 'weight': 0.3, 'volume': 0.025 },
    ichor = { 'value': 1800, 'weight': 0.2, 'volume': 0.015 },
 
    items = [gold, panacea, ichor],
    knapsack = {'weight': 25, 'volume': 0.25},
    max_val = 0,
    solutions = [],
    g, p, i, item, val;
 
for (i = 0; i < items.length; i += 1) {
    item = items[i];
    item.max = Math.min(
        Math.floor(knapsack.weight / item.weight),
        Math.floor(knapsack.volume / item.volume)
    );
}
 
for (g = 0; g <= gold.max; g += 1) {
    for (p = 0; p <= panacea.max; p += 1) {
        for (i = 0; i <= ichor.max; i += 1) {
            if (i * ichor.weight + g * gold.weight + p * panacea.weight > knapsack.weight) {
                continue;
            }
            if (i * ichor.volume + g * gold.volume + p * panacea.volume > knapsack.volume) {
                continue;
            }
            val = i * ichor.value + g * gold.value + p * panacea.value;
            if (val > max_val) {
                solutions = [];
                max_val = val;
            }
            if (val === max_val) {
                solutions.push([g, p, i]);
            }
        }
    }
}
 
document.write(strv + max_val + '<br>');
for (i = 0; i < solutions.length; i += 1) {
    item = solutions[i];
    document.write(strv + item[0] + strv + item[1] + strv + item[2] + strv);
}
 
output:
<pre>maximum value: 54500
(gold: 11, panacea: 0, ichor: 15)
(gold: 11, panacea: 3, ichor: 10)
(gold: 11, panacea: 6, ichor: 5)
(gold: 11, panacea: 9, ichor: 0)</pre>"
"var keypress = require('keypress');
 
keypress(process.stdin);
 
process.stdin.on('keypress', function (ch, key) {
    if (key && (key.name === 'y' || key.name === 'n')) {
       console.log('Reply:' + key.name);
    }
});
 
process.stdin.setRawMode(true);
process.stdin.resume();document.body.addEventListener('keyup', function (e) {
  var key = String.fromCharCode(e.keyCode).toLowerCase();
  if (key === 'y' || key === 'n') {
    console.log('response is: ' + key);
  }
}, false);"
"<html><head><title></title></head><body></body></html>
 
<script type=strv>
var data= [
  {name: 'map',                    weight:  9, value:150, pieces:1},
  {name: 'compass',                weight: 13, value: 35, pieces:1},
  {name: 'water',                  weight:153, value:200, pieces:2},
  {name: 'sandwich',               weight: 50, value: 60, pieces:2},
  {name: 'glucose',                weight: 15, value: 60, pieces:2},
  {name: 'tin',                    weight: 68, value: 45, pieces:3},
  {name: 'banana',                 weight: 27, value: 60, pieces:3},
  {name: 'apple',                  weight: 39, value: 40, pieces:3},
  {name: 'cheese',                 weight: 23, value: 30, pieces:1},
  {name: 'beer',                   weight: 52, value: 10, pieces:3},
  {name: 'suntan, cream',          weight: 11, value: 70, pieces:1},
  {name: 'camera',                 weight: 32, value: 30, pieces:1},
  {name: 'T-shirt',                weight: 24, value: 15, pieces:2},
  {name: 'trousers',               weight: 48, value: 10, pieces:2},
  {name: 'umbrella',               weight: 73, value: 40, pieces:1},
  {name: 'waterproof, trousers',   weight: 42, value: 70, pieces:1},
  {name: 'waterproof, overclothes',weight: 43, value: 75, pieces:1},
  {name: 'note-case',              weight: 22, value: 80, pieces:1},
  {name: 'sunglasses',             weight:  7, value: 20, pieces:1},
  {name: 'towel',                  weight: 18, value: 12, pieces:2},
  {name: 'socks',                  weight:  4, value: 50, pieces:1},
  {name: 'book',                   weight: 30, value: 10, pieces:2}
];
 
function findBestPack() {
	var m= [[0]]; 
	var b= [[0]]; 
	var opts= [0]; 
	var P= [1]; 
	var choose= 0;
	for (var j= 0; j<data.length; j++) {
		opts[j+1]= opts[j]+data[j].pieces; 
		P[j+1]= P[j]*(1+data[j].pieces); 
	}
	for (var j= 0; j<opts[data.length]; j++) {
		m[0][j+1]= b[0][j+1]= 0; 
	}
	for (var w=1; w<=400; w++) {
		m[w]= [0];
		b[w]= [0];
		for (var j=0; j<data.length; j++) {
			var N= data[j].pieces; 
			var base= opts[j]; 
			for (var n= 1; n<=N; n++) {
				var W= n*data[j].weight; 
				var s= w>=W ?1 :0; 
				var v= s*n*data[j].value; 
				var I= base+n; 
				var wN= w-s*W; 
				var C= n*P[j] + b[wN][base]; 
				m[w][I]= Math.max(m[w][I-1], v+m[wN][base]); 
				choose= b[w][I]= m[w][I]>m[w][I-1] ?C :b[w][I-1];
			}
		}
	}
	var best= [];
	for (var j= data.length-1; j>=0; j--) {
		best[j]= Math.floor(choose/P[j]);
		choose-= best[j]*P[j];
	}
	var out='<table><tr><td><b>Count</b></td><td><b>Item</b></td><th>unit weight</th><th>unit value</th>';
	var wgt= 0;
	var val= 0;
	for (var i= 0; i<best.length; i++) {
		if (0==best[i]) continue;
		out+='</tr><tr><td>'+best[i]+'</td><td>'+data[i].name+'</td><td>'+data[i].weight+'</td><td>'+data[i].value+'</td>'
		wgt+= best[i]*data[i].weight;
		val+= best[i]*data[i].value;
	}
	out+= '</tr></table><br/>Total weight: '+wgt;
	out+= '<br/>Total value: '+val;
	document.body.innerHTML= out;
}
findBestPack();
</script>"
" 
gw.lang.reflect.json.Json#fromJson( String json ) : javax.script.Bindings
 {
  strv: strv,
  strv: 39,
  strv: {
    strv: 9604,
    strv: strv,
    strv: strv,
    strv: strv
  },
  strv: [
    {
      strv: strv,
      strv: strv
    },
    {
      strv: strv,
      strv: strv
    }
  ]
}
  
var personUrl = new URL( strv )
var person: Dynamic = personUrl.JsonContent
print( person.Name )
  
personUrl.JsonContent
  
print( person.toStructure( strv, false ) )
  
structure Person {
  static function fromJson( jsonText: String ): Person {
    return gw.lang.reflect.json.Json.fromJson( jsonText ) as Person
  }
  static function fromJsonUrl( url: String ): Person {
    return new java.net.URL( url ).JsonContent
  }
  static function fromJsonUrl( url: java.net.URL ): Person {
    return url.JsonContent
  }
  static function fromJsonFile( file: java.io.File ) : Person {
    return fromJsonUrl( file.toURI().toURL() )
  }
  property get Address(): Address
  property get Hobby(): List<Hobby>
  property get Age(): Integer
  property get Name(): String
  structure Address {
    property get Number(): Integer
    property get State(): String
    property get Street(): String
    property get City(): String
  }
  structure Hobby {
    property get Category(): String
    property get Name(): String
  }
}
  
var person = Person.fromJsonUrl( personUrl )
print( person.Name )
print( person.Address.City )
print( person.Hobby[0].Name )
  
print( person.toJson() ) 
print( person.toGosu() ) 
print( person.toXml() ) 
  
var clone = eval( person.toGosu() )
 var data = JSON.parse('{ strv] }');
 
var sample = { strv: [1,2], strv: strv };
var json_string = JSON.stringify(sample);//--------------------------------------



//--------------------------------------
function json_decode (json){
  var o;
  eval('o='+json);
  return _json_decode_val(o);
}
 
function _json_decode_val (o){
  if (o==null) return undefined;
  switch(typeof(o)){
    case strv:
      if (o instanceof Array){
        var v = list();
        var cnt = o.length;
        for (i=0;i<cnt;i++){
          v.add(_json_decode_val(o[i]));
        }
      }else{
        var v = propList();
        for (var i in o){
          var p = i;
          v.setAProp(_json_decode_val(p), _json_decode_val(o[i]));
        }
      }
      return v;
    case strv:
      
      if (o.substr(0,7)=='__sym__') return symbol(o.substr(7));
      return o;
    default:
      return o;
  }
}
 
function _json_escape_string (str){
  var hash={"""":"""", strv:""/"", """":""n"", """":""t"", """":""r"", """":""b"", """":""f"", """":""""};
  var patt = strv; for (i in hash) patt+=i;patt+=strv;
  return str.replace(RegExp(patt, strv), function(c){
    return hash[c]
  });
}"
"function isKaprekar( n, bs ) {
	if ( n < 1 ) return false
	if ( n == 1 ) return true
	bs = bs || 10
	var s = (n * n).toString(bs)
	for (var i=1, e=s.length; i<e; i+=1) {
		var a = parseInt(s.substr(0, i), bs)
		var b = parseInt(s.substr(i), bs)
		if (b && a + b == n) return true
	}
	return false
}function isKaprekar( n, bs ) {
	if ( n < 1 ) return false
	if ( n == 1 ) return true
	bs = bs || 10
	for (var a=n*n, b=0, s=1; a; s*=bs) {
		b += a%bs*s
		a = Math.floor(a/bs)
		if (b && a + b == n) return true
	}
	return false
}function kaprekar( s, e, bs, pbs ) {
	bs = bs || 10; pbs = pbs || 10
	const toString = n => n.toString(pbs).toUpperCase()
	document.write('start:',toString(s), ' end:',toString(e), ' base:',bs, ' printBase:',pbs, '<br>' )
	for (var k=0, n=s; n<=e; n+=1) if (isKaprekar(n, bs)) k+=1, document.write(toString(n), ' ') 
	document.write('<br>found ', k, ' numbers<br><br>')
}
 
kaprekar( 1, 99 )
kaprekar( 1, 255, 16)
kaprekar( 1, 255, 16, 16)
kaprekar( 1, 288, 17, 17)"
"var jortSort = function( array ) {
 
  
  var originalArray = array.slice(0);
  array.sort( function(a,b){return a - b} );
 
  
  for (var i = 0; i < originalArray.length; ++i) {
    if (originalArray[i] !== array[i]) return false;
  }
 
  return true;
};"
"var Josephus = {
  init: function(n) {
    this.head = {};
    var current = this.head;
    for (var i = 0; i < n-1; i++) {
      current.label = i+1;
      current.next = {prev: current};
      current = current.next;
    }
    current.label = n;
    current.next = this.head;
    this.head.prev = current;
    return this;
  },
  kill: function(spacing) {
    var current = this.head;
    while (current.next !== current) {
      for (var i = 0; i < spacing-1; i++) {
        current = current.next;
      }
      current.prev.next = current.next;
      current.next.prev = current.prev;
      current = current.next;
    }
    return current.label;
  }
}function Josephus(n, k, s) {
	s = s | 1
	for (var ps=[], i=n; i--; ) ps[i]=i
	for (var ks=[], i=--k; ps.length>s; i=(i+k)%ps.length) ks.push(ps.splice(i, 1))
	document.write((arguments.callee+'').split(/\s|\(/)[1], '(', [].slice.call(arguments, 0), ') -> ', ps, ' / ', ks.length<45?ks:ks.slice(0,45)+',...' , '<br>')
	return [ps, ks]
}"
"var obj;
 
function sum(o, lo, hi, term) {
  var tmp = 0;
  for (o.val = lo; o.val <= hi; o.val++)
    tmp += term();
  return tmp;
}
 
obj = {val: 0};
alert(sum(obj, 1, 100, function() {return 1 / obj.val}));"
"/*global portviz:false, _:false */
/* * 0-1 knapsack solution, recursive, memoized, approximate. * * credits: * * the Go implementation here: *   http://rosettacode.org/mw/index.php?title=Knapsack_problem/0-1 * * approximation details here: *   http://math.mit.edu/~goemans/18434S06/knapsack-katherine.pdf */
portviz.knapsack = {};
(function() {
  this.combiner = function(items, weightfn, valuefn) {
    
    var _epsilon = 0.01;
    var _p = _.max(_.map(items,valuefn));
    var _k = _epsilon * _p / items.length;
 
    var _memo = (function(){
      var _mem = {};
      var _key = function(i, w) {
        return i + '::' + w;
      };
      return {
        get: function(i, w) {
          return _mem[_key(i,w)];
        },
        put: function(i, w, r) {
          _mem[_key(i,w)]=r;
          return r;
        }
      };
    })();
 
    var _m = function(i, w) {
 
      i = Math.round(i);
      w = Math.round(w);
 
 
      if (i < 0 || w === 0) {
        
        return {items: [], totalWeight: 0, totalValue: 0};
      }
 
      var mm = _memo.get(i,w);
      if (!_.isUndefined(mm)) {
        return mm;
      }
 
      var item = items[i];
      if (weightfn(item) > w) {
        //item does not fit, try the next item
        return _memo.put(i, w, _m(i-1, w));
      }
      
      
      var excluded = _m(i-1, w);
      
      var included = _m(i-1, w - weightfn(item));
      if (included.totalValue + Math.floor(valuefn(item)/_k) > excluded.totalValue) {
        
        
        var i1 = included.items.slice();
        i1.push(item);
        return _memo.put(i, w,
          {items: i1,
           totalWeight: included.totalWeight + weightfn(item),
           totalValue: included.totalValue + Math.floor(valuefn(item)/_k)});
      }
      //better off excluding it
      return _memo.put(i,w, excluded);
    };
    return {
      /* one point */
      one: function(maxweight) {
        var scaled = _m(items.length - 1, maxweight);
        return {
          items: scaled.items,
          totalWeight: scaled.totalWeight,
          totalValue: scaled.totalValue * _k
        };
      },
      /* the entire EF */
      ef: function(maxweight, step) {
        return _.map(_.range(0, maxweight+1, step), function(weight) {
          var scaled = _m(items.length - 1, weight);
          return {
            items: scaled.items,
            totalWeight: scaled.totalWeight,
            totalValue: scaled.totalValue * _k
          };
        });
      }
    };
  };
}).apply(portviz.knapsack);
 
/*global portviz:false, _:false */
/* * after rosettacode.org/mw/index.php?title=Knapsack_problem/0-1 */
var allwants = [
  {name:strv, weight:9, value: 150},
  {name:strv, weight:13, value: 35},
  {name:strv, weight:153, value: 200},
  {name:strv, weight: 50, value: 160},
  {name:strv, weight:15, value: 60},
  {name:strv, weight:68, value: 45},
  {name:strv, weight:27, value: 60},
  {name:strv, weight:39, value: 40},
  {name:strv, weight:23, value: 30},
  {name:strv, weight:52, value: 10},
  {name:strv, weight:11, value: 70},
  {name:strv, weight:32, value: 30},
  {name:strv, weight:24, value: 15},
  {name:strv, weight:48, value: 10},
  {name:strv, weight:73, value: 40},
  {name:strv, weight:42, value: 70},
  {name:strv, weight:43, value: 75},
  {name:strv, weight:22, value: 80},
  {name:strv, weight:7, value: 20},
  {name:strv, weight:18, value: 12},
  {name:strv, weight:4, value: 50},
  {name:strv, weight:30, value: 10}
];
 
var near = function(actual, expected, tolerance) {
  if (expected === 0 && actual === 0) return true;
  if (expected === 0) {
    return Math.abs(expected - actual) / actual < tolerance;
  }
  return Math.abs(expected - actual) / expected < tolerance;
};
 
test(strv, function() {
  var combiner =
    portviz.knapsack.combiner(allwants,
      function(x){return x.weight;},
      function(x){return x.value;});
  var oneport = combiner.one(400);
  ok(near(oneport.totalValue, 1030, 0.01), strv);
  ok(near(oneport.totalValue, 1030, 0.01), strv);
  equal(oneport.totalWeight, 396, strv);
});
 
test(strv, function() {
  var combiner =
    portviz.knapsack.combiner(allwants,
      function(x){return x.weight;},
      function(x){return x.value;});
  var ef = combiner.ef(400, 1);
  equal(ef.length, 401, strv);
  ef = combiner.ef(400, 40);
  equal(ef.length, 11, strv);
  var expectedTotalValue = [
    0,
    330,
    445,
    590,
    685,
    755,
    810,
    860,
    902,
    960,
    1030
  ] ;
  _.each(ef, function(element, index) {
    
    ok(near(element.totalValue, expectedTotalValue[index], 0.15),
      'actual ' + element.totalValue + ' expected ' + expectedTotalValue[index]);
  });
  deepEqual(_.pluck(ef, 'totalWeight'), [
    0,
    39,
    74,
    118,
    158,
    200,
    236,
    266,
    316,
    354,
    396
  ]);
  deepEqual(_.map(ef, function(x){return x.items.length;}), [
    0,
    4,
    6,
    7,
    9,
    10,
    10,
    12,
    14,
    11,
    12
   ]);
});"
if (typeof bloop !== strv) { ... }if (strv in Math) { ... }
"$ java -cp js.jar org.mozilla.javascript.tools.shell.Main
Rhino 1.7 release 2 2009 03 22
js> function f(a,b,s) {return a + s + s + b;}
js> f('Rosetta', 'Code', ':')
Rosetta::Code
js> quit()
$"
"var text_stream = WScript.StdIn;
var i = 0;
 
while ( ! text_stream.AtEndOfStream ) {
    var line = text_stream.ReadLine();
    
    WScript.echo(++i + strv + line);
}"
"var i = 0;
 
while (true)
    document.write(++i + ' ');"
" 

function compare(a, b) {
  if (a==b) print(a + strv + b);
  if (a < b) print(a + strv + b);
  if (a > b) print(a + strv + b);
}
 



function compare (a, b) {
  if (typeof a === typeof b) {
    if (a === b) {
      document.writeln(a + strv + b);
    }
    if (a < b) {
      document.writeln(a + strv + b);
    }
    if (a > b) {
      document.writeln(a + strv + b);
    }
  } else {
    
    print(a + strv + (typeof a) + strv + b + strv + (typeof b) + strv);
  }
}
 "
"function Animal() {
    
}function Dog() {
    
}
Dog.prototype = new Animal();function Cat() {
    
}
Cat.prototype = new Animal();function Collie() {
    
}
Collie.prototype = new Dog();function Lab() {
    
}
Lab.prototype = new Dog();Animal.prototype.speak = function() {print(strv)};
 
var lab = new Lab();
lab.speak();  "
"InfinityNumber.POSITIVE_INFINITY
Number.NEGATIVE_INFINITYisFinite(x)"
"var s = document.createElement('script');
s.type = 'application/javascript';
 

s.src = 'http://code.jquery.com/jquery-1.6.2.js';
document.body.appendChild(s);$.getScript(strv);require([strv], function($) { /* ... */ });var $ = require('$');import $ from strv;"
"let s = '9999';
let splusplus = (+s+1)+strv
 
console.log([splusplus, typeof splusplus]) (() => {
    'use strict';
 
    
    const stringSucc = s =>
        isNaN(s) ? undefined : (Number(s) + 1).toString();
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    return show(
        ['2', '4', '8', '16', 'anomaly'].map(stringSucc)
    );
})();"
"


function convolve(imageIn, kernel, callback) {
    var dim = Math.sqrt(kernel.length),
        pad = Math.floor(dim / 2);
 
    if (dim % 2 !== 1) {
        return callback(new RangeError(strv), null);
    }
 
    var w = imageIn.width,
        h = imageIn.height,
        can = document.createElement('canvas'),
        cw,
        ch,
        ctx,
        imgIn, imgOut,
        datIn, datOut;
 
    can.width = cw = w + pad * 2; 
    can.height = ch = h + pad * 2; 
 
    ctx = can.getContext('2d');
    ctx.fillStyle = '#000'; 
    ctx.fillRect(0, 0, cw, ch);
    ctx.drawImage(imageIn, pad, pad);
 
    imgIn = ctx.getImageData(0, 0, cw, ch);
    datIn = imgIn.data;
 
    imgOut = ctx.createImageData(w, h);
    datOut = imgOut.data;
 
    var row, col, pix, i, dx, dy, r, g, b;
 
    for (row = pad; row <= h; row++) {
        for (col = pad; col <= w; col++) {
            r = g = b = 0;
 
            for (dx = -pad; dx <= pad; dx++) {
                for (dy = -pad; dy <= pad; dy++) {
                    i = (dy + pad) * dim + (dx + pad); 
                    pix = 4 * ((row + dy) * cw + (col + dx)); 
                    r += datIn[pix++] * kernel[i];
                    g += datIn[pix++] * kernel[i];
                    b += datIn[pix  ] * kernel[i];
                }
            }
 
            pix = 4 * ((row - pad) * w + (col - pad)); 
            datOut[pix++] = (r + .5) ^ 0;
            datOut[pix++] = (g + .5) ^ 0;
            datOut[pix++] = (b + .5) ^ 0;
            datOut[pix  ] = 255; 
        }
    }
 
    
    can.width = w;
    can.height = h;
 
    ctx.putImageData(imgOut, 0, 0);
 
    var imageOut = new Image();
 
    imageOut.addEventListener('load', function () {
        callback(null, imageOut);
    });
 
    imageOut.addEventListener('error', function (error) {
        callback(error, null);
    });
 
    imageOut.src = can.toDataURL('image/png');
}"
"<body>
<canvas id='c'></canvas>
 
<script>
var canvas = document.getElementById('c');
var ctx = canvas.getContext('2d');
 
var w = canvas.width = 320;
var h = canvas.height = 240;
var t1 = new Date().getTime();
var frame_count = 0;
ctx.font = 'normal 400 24px/2 Unknown Font, sans-serif';
var img = ctx.createImageData(w, h);
 
var index_init = 0;
for (var x = 0; x < w; x++) {
    for (var y = 0; y < h; y++) {
        img.data[index_init + 3] = 255; 
        index_init += 4;
    }
}
 
function animate() {
    var index = 0;
    for (var x = 0; x < w; x++) {
        for (var y = 0; y < h; y++) {
            var value = (Math.random() > 0.5) ? 255 : 0;
            img.data[index    ] = value;
            img.data[index + 1] = value;
            img.data[index + 2] = value;
            
            index += 4;
        }
    }
 
    ctx.putImageData(img, 0, 0);
 
    frame_count++;
    if (frame_count % 50 == 0) {
        var fps = frame_count / (new Date().getTime() - t1) * 1000;
        window.status = fps.toFixed(2) + strv;
    }
 
    setTimeout(animate, 0);
}
 
animate();
</script>
</body>"
"function idMatrix(n) {
    return Array.apply(null, new Array(n))
        .map(function (x, i, xs) {
            return xs.map(function (_, k) {
                return i === k ? 1 : 0;
            })
        });
}(() => {
 
    
    const idMatrix = n => Array.from({
            length: n
        }, (_, i) => Array.from({
            length: n
        }, (_, j) => i !== j ? 0 : 1));
 
    
    const show = JSON.stringify;
 
    
    return idMatrix(5)
        .map(show)
        .join('');
})();"
"var ibanLen = { 
	NO:15, BE:16, DK:18, FI:18, FO:18, GL:18, NL:18, MK:19,
	SI:19, AT:20, BA:20, EE:20, KZ:20, LT:20, LU:20, CR:21,
	CH:21, HR:21, LI:21, LV:21, BG:22, BH:22, DE:22, GB:22,
	GE:22, IE:22, ME:22, RS:22, AE:23, GI:23, IL:23, AD:24,
	CZ:24, ES:24, MD:24, PK:24, RO:24, SA:24, SE:24, SK:24,
	VG:24, TN:24, PT:25, IS:26, TR:26, FR:27, GR:27, IT:27,
	MC:27, MR:27, SM:27, AL:28, AZ:28, CY:28, DO:28, GT:28,
	HU:28, LB:28, PL:28, BR:29, PS:29, KW:30, MU:30, MT:31
}
 
function isValid(iban) {
	iban = iban.replace(/\s/g, '')
	if (!iban.match(/^[\dA-Z]+$/)) return false
	var len = iban.length
	if (len != ibanLen[iban.substr(0,2)]) return false
	iban = iban.substr(4) + iban.substr(0,4)
	for (var s='', i=0; i<len; i+=1) s+=parseInt(iban.charAt(i),36)
	for (var m=s.substr(0,15)%97, s=s.substr(15); s; s=s.substr(13)) m=(m+s.substr(0,13))%97
	return m == 1
}
 
document.write(isValid('GB82 WEST 1234 5698 7654 32'), '<br>') 
document.write(isValid('GB82 WEST 1.34 5698 7654 32'), '<br>') 
document.write(isValid('GB82 WEST 1234 5698 7654 325'), '<br>') 
document.write(isValid('GB82 TEST 1234 5698 7654 32'), '<br>') 
document.write(isValid('SA03 8000 0000 6080 1016 7519'), '<br>') 
 "
" 
(function(url,callback){//on some browsers you can check certificate information.
xhr=new XMLHttpRequest();
xhr.open('GET',url,true);
xhr.onreadystatechange=function(){if(xhr.readyState==xhr.DONE){callback(xhr)}};
xhr.send();
})('https://sourceforge.net',function(xhr){console.log(xhr.response)})
 "
"var network = new ActiveXObject('WScript.Network');
var hostname = network.computerName;
WScript.echo(hostname);"
"function horner(coeffs, x) {
    return coeffs.reduceRight( function(acc, coeff) { return(acc * x + coeff) }, 0);
}
console.log(horner([-19,7,-4,6],3));  
 "
"function HuffmanEncoding(str) {
    this.str = str;
 
    var count_chars = {};
    for (var i = 0; i < str.length; i++) 
        if (str[i] in count_chars) 
            count_chars[str[i]] ++;
        else 
            count_chars[str[i]] = 1;
 
    var pq = new BinaryHeap(function(x){return x[0];});
    for (var ch in count_chars) 
        pq.push([count_chars[ch], ch]);
 
    while (pq.size() > 1) {
        var pair1 = pq.pop();
        var pair2 = pq.pop();
        pq.push([pair1[0]+pair2[0], [pair1[1], pair2[1]]]);
    }
 
    var tree = pq.pop();
    this.encoding = {};
    this._generate_encoding(tree[1], strv);
 
    this.encoded_string = strv
    for (var i = 0; i < this.str.length; i++) {
        this.encoded_string += this.encoding[str[i]];
    }
}
 
HuffmanEncoding.prototype._generate_encoding = function(ary, prefix) {
    if (ary instanceof Array) {
        this._generate_encoding(ary[0], prefix + strv);
        this._generate_encoding(ary[1], prefix + strv);
    }
    else {
        this.encoding[ary] = prefix;
    }
}
 
HuffmanEncoding.prototype.inspect_encoding = function() {
    for (var ch in this.encoding) {
        print(strv + ch + strv + this.encoding[ch])
    }
}
 
HuffmanEncoding.prototype.decode = function(encoded) {
    var rev_enc = {};
    for (var ch in this.encoding) 
        rev_enc[this.encoding[ch]] = ch;
 
    var decoded = strv;
    var pos = 0;
    while (pos < encoded.length) {
        var key = strv
        while (!(key in rev_enc)) {
            key += encoded[pos];
            pos++;
        }
        decoded += rev_enc[key];
    }
    return decoded;
}var s = strv;
print(s);
 
var huff = new HuffmanEncoding(s);
huff.inspect_encoding();
 
var e = huff.encoded_string;
print(e);
 
var t = huff.decode(e);
print(t);
 
print(strv + (s==t));"
"var hofst_10k = function(n) {
	var memo = [1, 1];
 
	var a = function(n) {
		var result = memo[n-1];
		if (typeof result !== 'number') {
			result = a(a(n-1))+a(n-a(n-1));	
			memo[n-1] = result;
		}	
		return result;
	}
	return a;
}();
 
var maxima_between_twos = function(exp) {
	var current_max = 0;
	for(var i = Math.pow(2,exp)+1; i < Math.pow(2,exp+1); i += 1) {
		current_max = Math.max(current_max, hofst_10k(i)/i);
	}
	return current_max;
}
 
for(var i = 1; i <= 20; i += 1) {
	console.log(strv+i+strv+(i+1)+strv+maxima_between_twos(i)+"""");
}"
"var hofstadterQ = function() {
   var memo = [1,1,1];
   var Q    = function (n) {
      var result = memo[n];
      if (typeof result !== 'number') {
         result  = Q(n - Q(n-1)) + Q(n - Q(n-2));
         memo[n] = result;
      }
      return result;
   };
   return Q;
}();
 
for (var i = 1; i <=10; i += 1) {
   console.log('Q('+ i +') = ' + hofstadterQ(i));
}
 
console.log('Q(1000) = ' + hofstadterQ(1000));
 (() => {
    'use strict';
 
    
    const hofQSeq = x =>
        x > 2 ? tail(foldl((Q, n) =>
            n < 3 ? Q : Q.concat(
                Q[n - Q[n - 1]] + Q[n - Q[n - 2]]
            ), [0, 1, 1],
            range(1, x))) : (x > 0 ? take(x, [1, 1]) : undefined);
 
 
    
 
    
    const foldl = (f, a, xs) => xs.reduce(f, a),
 
        
        range = (m, n) =>
            Array.from({
                length: Math.floor(n - m) + 1
            }, (_, i) => m + i),
 
        
        tail = xs => xs.length ? xs.slice(1) : undefined,
 
        
        last = xs => xs.length ? xs.slice(-1)[0] : undefined,
 
        
        take = (n, xs) => xs.slice(0, n);
 
    
    return {
        firstTen: hofQSeq(10),
        thousandth: last(hofQSeq(1000)),
        'Q<Q-1UpTo10E5': hofQSeq(100000)
            .reduce((a, x, i, xs) => x < xs[i - 1] ? a + 1 : a, 0)
    };
})();{strv:[1, 1, 2, 3, 3, 4, 5, 5, 6, 6], 
 strv:502,
 strv:49798}"
"var R = [null, 1];
var S = [null, 2];
 
var extend_sequences = function (n) {
	var current = Math.max(R[R.length-1],S[S.length-1]);
	var i;
	while (R.length <= n || S.length <= n) {
		i = Math.min(R.length, S.length) - 1;
		current += 1;
		if (current === R[i] + S[i]) {
			R.push(current);
		} else {
			S.push(current);
		}
	}
}
 
var ffr = function(n) {
	extend_sequences(n);
	return R[n];
};
 
var ffs = function(n) {
	extend_sequences(n);
	return S[n];
};
 
for (var i = 1; i <=10; i += 1) {
   console.log('R('+ i +') = ' + ffr(i));
}
 
var int_array = [];
 
for (var i = 1; i <= 40; i += 1) {
	int_array.push(ffr(i));
}
for (var i = 1; i <= 960; i += 1) {
	int_array.push(ffs(i));
}
 
int_array.sort(function(a,b){return a-b;});
 
for (var i = 1; i <= 1000; i += 1) {
	if (int_array[i-1] !== i) { 
		throw strv 
	} else { console.log(strv); }
}"
"var req = new XMLHttpRequest();
req.onload = function() {
  console.log(this.responseText);
};
 
req.open('get', 'http://rosettacode.org', true);
req.send()$.get('http://rosettacode.org', function(data) {
  console.log(data);
};"
"function first (func) {
  return func();
}
 
function second () {
  return strv;
}
 
var result = first(second);
result = first(function () { return strv; });>>> var array = [2, 4, 5, 13, 18, 24, 34, 97];
>>> array
[2, 4, 5, 13, 18, 24, 34, 97]
 

>>> array.filter(function (x) { return x < 10 });
[2, 4, 5]
 

>>> array.filter(function (x) { return x < 30 });
[2, 4, 5, 13, 18, 24]
 

>>> array.filter(function (x) { return x < 100 });
[2, 4, 5, 13, 18, 24, 34, 97]
 

>>> array.map(function (x) { return x * 2 });
[4, 8, 10, 26, 36, 48, 68, 194]
 

>>> array.sort(function (a, b) { return a > b });
[2, 4, 5, 13, 18, 24, 34, 97]
 

>>> array.sort(function (a, b) { return a < b });
[97, 34, 24, 18, 13, 5, 4, 2]"
"var http = require('http');
 
http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Goodbye, World!');
}).listen(8080, '127.0.0.1');"
WScript.StdErr.WriteLine(strv);console.warn(strv)console.error(strv)//only works if console object existsthrow new Error(strv)//Should work in any browser
" 
window.onload = function(){	
    var list = [];
    var j = 0;	
    for(var c = 1; c <= 200; c++)
        for(var b = 1; b <= c; b++)
            for(var a = 1; a <= b; a++)
	        if(gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c)))							
		    list[j++] = new Array(a, b, c, a + b + c, heronArea(a, b, c));
    sort(list);	
    document.write(strv + list.length + strv);
    for(var i = 0; i < 10; i++)
	document.write(strv + list[i][0] + strv + list[i][1] + strv + list[i][2] + strv + list[i][3] + strv + list[i][4] + strv);
    document.write(strv);
    for(var i = 0; i < list.length; i++)
	if(list[i][4] == 210)
	    document.write(strv + list[i][0] + strv + list[i][1] + strv + list[i][2] + strv + list[i][3] + strv + list[i][4] + strv);    		
    function heronArea(a, b, c){
	var s = (a + b + c)/ 2;
	return Math.sqrt(s *(s -a)*(s - b)*(s - c));		
    }	
    function isHeron(h){
        return h % 1 == 0 && h > 0;
    }	
    function gcd(a, b){
	var leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;		
	while(leftover != 0){
	    leftover = dividend % divisor;
	    if(leftover > 0){
		dividend = divisor;
		divisor = leftover;
	    }
	}		
	return divisor;
    }	
    function sort(list){
	var swapped = true;
	var temp = [];
	while(swapped){
	    swapped = false;
	    for(var i = 1; i < list.length; i++){
		if(list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){
		    temp = list[i];
		    list[i] = list[i - 1];
		    list[i - 1] = temp;
		    swapped = true;
		}				
	    }			
	}
    }
}
 (function (n) {
 
  var chain = function (xs, f) {                  
      return [].concat.apply([], xs.map(f));
    },
 
    hArea = function (x, y, z) {
      var s = (x + y + z) / 2,
        a = s * (s - x) * (s - y) * (s - z);
      return a ? Math.sqrt(a) : 0;
    },
 
    gcd = function (m, n) { return n ? gcd(n, m % n) : m; },
 
    rng = function (m, n) {
      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
        return m + i;
      });
    },
 
    sum = function (a, x) { return a + x; };
 
  
 
  var lstHeron = chain( rng(1, n), function (x) {
          return chain( rng(x, n), function (y) {
          return chain( rng(y, n), function (z) {
 
        return (
          (x + y > z) &&
          gcd(gcd(x, y), z) === 1 &&            
          (function () {                        
            var a = hArea(x, y, z);
            return a && (a === parseInt(a, 10))
          })()
        ) ? [[x, y, z]] : [];                   
 
  })})}).sort(function (a, b) {
    var dArea = hArea.apply(null, a) - hArea.apply(null, b);
    if (dArea) return dArea;
    else {
      var dPerim = a.reduce(sum, 0) - b.reduce(sum, 0);
      return dPerim ? dPerim : (a[2] - b[2]);
    }
  });
 
  
 
  var lstColumns = ['Sides Perimeter Area'.split(' ')],
    fnData = function (lst) {
      return [JSON.stringify(lst), lst.reduce(sum, 0), hArea.apply(null, lst)];
    },
    wikiTable = function (lstRows, blnHeaderRow, strStyle) {
      return '{| class=strv ' + (
        strStyle ? 'style=""' + strStyle + '""' : ''
      ) + lstRows.map(function (lstRow, iRow) {
        var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
        return '|-' + strDelim + ' ' + lstRow.map(function (v) {
          return typeof v === 'undefined' ? ' ' : v;
        }).join(' ' + strDelim + strDelim + ' ');
      }).join('') + '|}';
    };
 
  return 'Found: ' + lstHeron.length +
    ' primitive Heronian triangles with sides up to ' + n + '.' +
    '(Showing first 10, sorted by increasing area, ' +
    'perimeter, and longest side)' +
    wikiTable(
      lstColumns.concat(lstHeron.slice(0, 10).map(fnData)),
      true
    ) + '' +
    'All primitive Heronian triangles in this range where area = 210' +
    '(also in order of increasing perimeter and longest side)' +
    wikiTable(
      lstColumns.concat(lstHeron.filter(function (x) {
        return 210 === hArea.apply(null, x);
      }).map(fnData)),
      true
    ) + '';
 
})(200);"
"
var fs = require('fs');

var lp = fs.openSync('/dev/lp0', 'w');
fs.writeSync(lp, 'Hello, world!');
fs.close(lp); 
document.write(strv);
print(); //Opens a dialog.
 "
process.stdout.write(strv);
document.write(strv);print('Hello world!');WScript.Echo(strv);console.log(strv)print(strv)strv
"(() => {
    'use strict';
 
    
    let hashJoin = (tblA, tblB, strJoin) => {
 
        let [jA, jB] = strJoin.split('='),
            M = tblB.reduce((a, x) => {
                let id = x[jB];
                return (
                    a[id] ? a[id].push(x) : a[id] = [x],
                    a
                );
            }, {});
 
        return tblA.reduce((a, x) => {
            let match = M[x[jA]];
            return match ? (
                a.concat(match.map(row => dictConcat(x, row)))
            ) : a;
        }, []);
    },
 
    
    dictConcat = (dctA, dctB) => {
        let ok = Object.keys;
        return ok(dctB).reduce(
            (a, k) => (a['B_' + k] = dctB[k]) && a,
            ok(dctA).reduce(
                (a, k) => (a['A_' + k] = dctA[k]) && a, {}
            )
        );
    };
 
 
    
    let lstA = [
        { age: 27, name: 'Jonah' },
        { age: 18, name: 'Alan' },
        { age: 28, name: 'Glory' },
        { age: 18, name: 'Popeye' },
        { age: 28, name: 'Alan' }
    ],
    lstB = [
        { character: 'Jonah', nemesis: 'Whales' },
        { character: 'Jonah', nemesis: 'Spiders' },
        { character: 'Alan', nemesis: 'Ghosts' },
        { character:'Alan', nemesis: 'Zombies' },
        { character: 'Glory', nemesis: 'Buffy' },
        { character: 'Bob', nemesis: 'foo' }
    ];
 
    return hashJoin(lstA, lstB, 'name=character');
 
})();
 "
"function haversine() {
       var radians = Array.prototype.map.call(arguments, function(deg) { return deg/180.0 * Math.PI; });
       var lat1 = radians[0], lon1 = radians[1], lat2 = radians[2], lon2 = radians[3];
       var R = 6372.8; 
       var dLat = lat2 - lat1;
       var dLon = lon2 - lon1;
       var a = Math.sin(dLat / 2) * Math.sin(dLat /2) + Math.sin(dLon / 2) * Math.sin(dLon /2) * Math.cos(lat1) * Math.cos(lat2);
       var c = 2 * Math.asin(Math.sqrt(a));
       return R * c;
}
console.log(haversine(36.12, -86.67, 33.94, -118.40));((x, y) => {
    'use strict';
 
    
    let haversine = ([lat1, lon1], [lat2, lon2]) => {
        
        let [pi, asin, sin, cos, sqrt, pow, round] =
            ['PI', 'asin', 'sin', 'cos', 'sqrt', 'pow', 'round']
            .map(k => Math[k]),
 
            
            [rlat1, rlat2, rlon1, rlon2] = [lat1, lat2, lon1, lon2]
            .map(x => x / 180 * pi),
 
            dLat = rlat2 - rlat1,
            dLon = rlon2 - rlon1,
            radius = 6372.8; 
 
        
        return round(
            radius * 2 * asin(
                sqrt(
                    pow(sin(dLat / 2), 2) +
                    pow(sin(dLon / 2), 2) *
                    cos(rlat1) * cos(rlat2)
                )
            ) * 100
        ) / 100;
    };
 
    
    return haversine(x, y);
 
    
 
})([36.12, -86.67], [33.94, -118.40]);"
 alert(strv);
" 
var keys = ['a', 'b', 'c'];
var values = [1, 2, 3];
var map = {};
for(var i = 0; i < keys.length; i += 1) {
  map[ keys[i] ] = values[i];
}
  
function arrToObj(keys, vals) {
  var map = {};
  keys.forEach(function (key, index) {
    map[key] = val[index];
  });
  return map;
}
  
function arrToObj(keys, vals) {
  return keys.reduce(function(map, key, index) {
    map[key] = vals[index];
    return map;
  }, {});
}
 "
"function happy(number) {
    var m, digit ;
    var cycle = [] ;
 
    while(number != 1 && cycle[number] !== true) {
        cycle[number] = true ;
        m = 0 ;
        while (number > 0) {
            digit = number % 10 ;
            m += digit * digit ;
            number = (number  - digit) / 10 ;
        }
        number = m ;
    }
    return (number == 1) ;
}
 
var cnt = 8 ;
var number = 1 ;
 
while(cnt-- > 0) {
    while(!happy(number))
        number++ ;
    document.write(number + strv) ;
    number++ ;
}(() => {
    'use strict';
 
    
    function isHappy(n) {
        let f = n => n.toString()
            .split('')
            .reduce((a, x) => a + Math.pow(parseInt(x, 10), 2), 0),
            p = (s, n) => n === 1 ? true : (
                s.has(n) ? false : p(s.add(n), f(n))
            );
        return p(new Set(), n);
    }
 
    
 
    
    let range = (m, n) => Array.from({
        length: Math.floor(n - m) + 1
    }, (_, i) => m + i);
 
    return range(1, 50)
        .filter(isHappy)
        .slice(0, 8);
})()[1, 7, 10, 13, 19, 23, 28, 31](() => {
    'use strict';
 
    
    let isHappy = n => {
        let f = n => n.toString()
            .split('')
            .reduce((a, x) => a + Math.pow(parseInt(x, 10), 2), 0),
            p = (s, n) => n === 1 ? true : (
                s.has(n) ? false : p(s.add(n), f(n))
            );
        return p(new Set(), n);
    },
 
    
    until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    };
 
    return until(
        m => m.xs.length === 8,
        m => {
            let n = m.n;
            return {
                n: n + 1,
                xs: isHappy(n) ? m.xs.concat(n) : m.xs
            };
        }, {
            n: 1,
            xs: []
        }
    ).xs;
})();
 [1, 7, 10, 13, 19, 23, 28, 31]"
"(function(){
    var count=0
        secs=0
 
    var i= setInterval( function (){
        count++
        secs+=0.5
        console.log(count)
    }, 500);
 
    process.on('SIGINT', function() {
        clearInterval(i)
        console.log(secs+' seconds elapsed');
        process.exit()
    });
})();
 "
"function isHarshad(n) {
    var s = 0;
    var n_str = new String(n);
    for (var i = 0; i < n_str.length; ++i) {
        s += parseInt(n_str.charAt(i));
    }
    return n % s === 0;
}
 
var count = 0;
var harshads = [];
 
for (var n = 1; count < 20; ++n) {
    if (isHarshad(n)) {
        count++;
        harshads.push(n);
    }
}
 
console.log(harshads.join(strv));
 
var h = 1000;
while (!isHarshad(++h));
console.log(h);
 (() => {
    'use strict';
 
    
 
    
    const nHarshads = n => {
 
        
        const isHarshad = n => 0 === n % sum(digitList(n));
 
        return until(
                dct => dct.nth === n,
                dct => {
                    const
                        next = succ(dct.i),
                        blnHarshad = isHarshad(next);
                    return {
                        i: next,
                        hs: blnHarshad ? dct.hs.concat(next) : dct.hs,
                        nth: dct.nth + (blnHarshad ? 1 : 0)
                    };
                }, {
                    i: 0,
                    hs: [],
                    nth: 0
                }
            )
            .hs;
    };
 
    
 
    
    const digitList = n =>
        n > 0 ? [n % 10].concat(digitList(Math.floor(n / 10))) : [];
 
    
    const dropWhile = (p, xs) => {
        let i = 0;
        for (let lng = xs.length;
            (i < lng) && p(xs[i]); i++) {}
        return xs.slice(i);
    };
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    
    const succ = x => x + 1
 
    
    const sum = xs => xs.reduce((a, x) => a + x, 0);
 
    
    const until = (p, f, x) => {
        const go = x => p(x) ? x : go(f(x));
        return go(x);
    };
 
    
    return show({
        firstTwenty: nHarshads(20),
        firstOver1000: head(dropWhile(x => x <= 1000, nHarshads(1000)))
    });
})();"
" 
function PowersGenerator(m) {
	var n=0;
	while(1) {
		yield Math.pow(n, m);
		n += 1;	
	}
}
 
function FilteredGenerator(g, f){
	var value = g.next();
	var filter = f.next();
 
	while(1) {
		if( value < filter ) {
			yield value;
			value = g.next();
		} else if ( value > filter ) {
			filter = f.next();
		} else {
			value = g.next();
			filter = f.next();
		}
	}	
}
 
 
 
var squares = PowersGenerator(2);
var cubes = PowersGenerator(3);
 
var filtered = FilteredGenerator(squares, cubes);
 
 
 
for( var x = 0; x < 20; x++ ) filtered.next()
for( var x = 20; x < 30; x++ ) console.logfiltered.next());
 
 function* nPowerGen(n) {
  let e = 0;
  while (1) { e++ && (yield Math.pow(e, n)); }
}
 
function* filterGen(gS, gC, skip=0) {
  let s = 0; 
  let c = 0; 
  let n = 0; 
 
  while(1) {
    s = gS.next().value;
    s > c && (c = gC.next().value);
    s == c ?
      c = gC.next().value :
      n++ && n > skip && (yield s);
  }
}
 
const filtered = filterGen(nPowerGen(2), nPowerGen(3), skip=20);
for (let n = 0; n < 10; n++) {
  console.log(filtered.next().value)
}"
"#!/usr/bin/env js
 
var DONE = RIGHT = 0, HIGH = 1, LOW = -1;
 
function main() {
    showInstructions();
    while (guess(1, 100) !== DONE);
}
 
function guess(low, high) {
    if (low > high) {
        print(strv);
        return DONE;
    }
 
    var g = Math.floor((low + high) / 2);
    var result = getResult(g);
    switch (result) {
        case RIGHT:
            return DONE;
        case LOW:
            return guess(g + 1, high);
        case HIGH:
            return guess(low, g - 1);
    }
}
 
function getResult(g) {
    while(true) {
        putstr('Is it ' + g + '? ');
        var ans = readline().toUpperCase().replace(/^\s+/, '') + ' ';
        switch (ans[0]) {
            case 'R':
                print('I got it! Thanks for the game.');
                return RIGHT;
            case 'L': 
                return LOW;
            case 'H':
                return HIGH;
            default:
                print('Please tell me if I am strv.');
        }
    }
}
 
function showInstructions() {
    print('Think of a number between 1 and 100 and I will try to guess it.');
    print('After I guess, type strv, and then press enter.');
    putstr(strv);
    readline();
}
 
main();
 "
"function hailstone (n) {
    var seq = [n];
    while (n > 1) {
        n = n % 2 ? 3 * n + 1 : n / 2;
        seq.push(n);
    }
    return seq;
}
 

var h = hailstone(27), hLen = h.length;
print(strv + h.slice(0, 4).join(strv) + strv
    + h.slice(hLen - 4, hLen).join(strv) + strv + hLen);
 

for (var n, max = 0, i = 100000; --i;) {
    var seq = hailstone(i), sLen = seq.length;
    if (sLen > max) {
        n = i;
        max = sLen;
    }
}
print(strv + max + strv + n);(function () {
 
  
  
  function hailstone(n) {
    return n === 1 ? [1] : (
      [n].concat(
        hailstone(n % 2 ? n * 3 + 1 : n / 2)
      )
    )
  }
 
  var lstCollatz27 = hailstone(27);
 
  return {
    length: lstCollatz27.length,
    sequence: lstCollatz27
  };
 
})();{strv:112,strv:[27,82,41,124,62,31,94,47,142,71,214,
107,322,161,484,242,121,364,182,91,274,137,412,206,103,310,155,466,233,700,350,
175,526, 263,790,395,1186,593,1780,890,445,1336,668,334,167,502,251,754,377,
1132,566,283,850,425,1276,638,319,958,479,1438,719,2158,1079,3238,1619,4858,
2429,7288,3644,1822,911,2734,1367,4102,2051,6154,3077,9232,4616,2308,1154,577,
1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,106,53,160,80,
40,20,10,5,16,8,4,2,1]}(function () {
 
  function memoized(fn) {
    var dctMemo = {};
 
    return function (x) {
      var varValue = dctMemo[x];
 
      if ('u' === (typeof varValue)[0])
        dctMemo[x] = varValue = fn(x);
      return varValue;
    };
  }
  
  
  function hailstone(n) {
    return n === 1 ? [1] : (
      [n].concat(
        hailstone(n % 2 ? n * 3 + 1 : n / 2)
      )
    )
  }
 
   
  
 
  var fnCollatz = memoized(hailstone);
 
  
  
  function range(m, n) {
    var a = Array(n - m + 1),
      i = n + 1;
    while (i--) a[i - 1] = i;
    return a;
  }
 
  
  function longestBelow(n) {
    return range(1, n).reduce(
      function (a, x, i) {
        var lng = fnCollatz(x).length;
 
        return lng > a.l ? {
          n: i + 1,
          l: lng
        } : a
 
      }, {
        n: 0,
        l: 0
      }
    )
  }
 
  return longestBelow(100000);
 
})();
{strv:77031, strv:351}(function (n) {
 
  var dctMemo = {};
 
  
  
  function collatzLength(n) {
    var i = 1,
      a = n,
      lng;
 
    while (a !== 1) {
      lng = dctMemo[a];
      if ('u' === (typeof lng)[0]) {
        a = (a % 2 ? 3 * a + 1 : a / 2);
        i++;
      } else return lng + i - 1;
    }
    return i;
  }
 
  
  
  function range(m, n) {
    var a = Array(n - m + 1),
      i = n + 1;
    while (i--) a[i - 1] = i;
    return a;
  }
 
  
  function longestBelow(n) {
 
    return range(1, n).reduce(
      function (a, x) {
 
        var lng = dctMemo[x] || (dctMemo[x] = collatzLength(x));
 
        return lng > a.l ? {
          n: x,
          l: lng
        } : a
 
      }, {
        n: 0,
        l: 0
      }
    )
  }
 
  return [100000, 1000000, 10000000].map(longestBelow);
 
})();[
  {strv:77031, strv:351},   
  {strv:837799, strv:525},  
  {strv:8400511, strv:686}  
]longestBelow(100000000)
-> {strv:63728127, strv:950}(() => {
    const dctMemo = {};
 
    
    
    const collatzLength = n => {
        let i = 1;
        let a = n;
        let lng;
 
        while (a !== 1) {
            lng = dctMemo[a];
            if ('u' === (typeof lng)[0]) {
                a = (a % 2 ? 3 * a + 1 : a / 2);
                i++;
            } else return lng + i - 1;
        }
        return i;
    };
 
    
    const range = (m, n, delta) => {
        const blnUp = n > m,
            d = blnUp ? (delta || 1) : -(delta || 1),
            lng = Math.abs(Math.floor((blnUp ? n - m : m - n) / d) + 1),
            a = Array(lng);
        let i = lng;
 
        while (i--) a[i] = (d * i) + m;
        return a;
    };
 
    
    const longestBelow = n =>
        range(1, n)
        .reduce(
            (a, x) => {
                const lng = dctMemo[x] || (dctMemo[x] = collatzLength(x));
 
                return lng > a.l ? {
                    n: x,
                    l: lng
                } : a
 
            }, {
                n: 0,
                l: 0
            }
        );
 
    
    
    const show = x => JSON.stringify(x, null, 2);
 
    return show(
        [100000, 1000000, 10000000].map(longestBelow)
    );
})();"
"function hamming() {
    var queues = {2: [], 3: [], 5: []};
    var base;
    var next_ham = 1;
    while (true) {
        yield next_ham;
 
        for (base in queues) {queues[base].push(next_ham * base)}
 
        next_ham = [ queue[0] for each (queue in queues) ].reduce(function(min, val) {
            return Math.min(min,val)
        });
 
        for (base in queues) {if (queues[base][0] == next_ham) queues[base].shift()}
    }
}
 
var ham = hamming();
var first20=[], i=1;
 
for (; i <= 20; i++) 
    first20.push(ham.next());
print(first20.join(', '));
print('...');
for (; i <= 1690; i++) 
    ham.next();
print(i + strv + ham.next());<html>
<head></head>
<body>
    <div id=strv></div>
</body>
<script src=strv></script>
<script src=strv></script>
<script type=strv>
    var _primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
 
    function log(text) {
        $('#main').append(text + """");
    }
 
    function big(exponents) {
        var i, e, val = bigInt.one;
        for (i = 0; i < exponents.length; i++)
            for (e = 0; e < exponents[i]; e++)
                val = val.times(_primes[i]);
        return val.toString();
    }
 
    function hamming(n, nprimes) {
        var i, iter, p, q, min, equal, x;
 
        var hammings = new Array(n);                            
        hammings[0] = new Array(nprimes);
        for (p = 0; p < nprimes; p++) {
            hammings[0][p] = 0;
        }
 
        var hammlogs = new Array(n);                            
        hammlogs[0] = 0;
 
        var primelogs = new Array(nprimes);                     
        var listlogs  = new Array(nprimes);                     
        for (p = 0; p < nprimes; p++) {
            primelogs[p] = listlogs[p] = Math.log(_primes[p]);
        }
 
        var indexes = new Array(nprimes);                       
        for (p = 0; p < nprimes; p++) {
            indexes[p] = 0;
        }
 
        var listheads = new Array(nprimes);                     
        for (p = 0; p < nprimes; p++) {
            listheads[p] = new Array(nprimes);
            for (q = 0; q < nprimes; q++) {
                listheads[p][q] = 0;
            }
            listheads[p][p] = 1;
        }
 
        for (iter = 1; iter < n; iter++) {
            min = 0;
            for (p = 1; p < nprimes; p++)
                if (listlogs[p] < listlogs[min])
                    min = p;
            hammlogs[iter] = listlogs[min];                     
            hammings[iter] = listheads[min].slice();
            for (p = 0; p < nprimes; p++) {                     
                equal = true;                                   
                for (i = 0; i < nprimes; i++) {
                    if (hammings[iter][i] != listheads[p][i]) {
                        equal = false;
                        break;
                    }
                }
                if (equal) {                                    
                    x = ++indexes[p];                           
                    listheads[p] = hammings[x].slice();         
                    listheads[p][p] += 1;                       
                    listlogs[p] = hammlogs[x] + primelogs[p];   
                }
            }
        }
 
        return hammings[n - 1];
    }
 
    $(document).ready(function() {
        var i, nprimes;
        var t = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,1691,1000000];
 
        for (nprimes = 3; nprimes <= 4; nprimes++) {
            var start = new Date();
            log('<h1>' + _primes[nprimes - 1] + '-Smooth:' + '</h1>');
            log('<table>');
            for (i = 0; i < t.length; i++)
                log('<tr>' + '<td>' + t[i] + ':' + '</td><td>' + big(hamming(t[i], nprimes)) + '</td>');
            var end = new Date();
            log('<tr>' + '<td>' + 'Elapsed time:' + '</td><td>' + (end-start)/1000 + ' seconds' +  '</td>');
            log('</table>');
        }
    });
</script>
</html>"
"(function (cFrom, cTo) {
 
  function cRange(cFrom, cTo) {
    var iStart = cFrom.charCodeAt(0);
 
    return Array.apply(
      null, Array(cTo.charCodeAt(0) - iStart + 1)
    ).map(function (_, i) {
 
      return String.fromCharCode(iStart + i);
 
    });
  }
 
  return cRange(cFrom, cTo);
 
})('a', 'z');[strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv](function (lstRanges) {
 
  function cRange(cFrom, cTo) {
    var iStart = cFrom.codePointAt(0);
 
    return Array.apply(
      null, Array(cTo.codePointAt(0) - iStart + 1)
    ).map(function (_, i) {
 
      return String.fromCodePoint(iStart + i);
 
    });
  }
 
  return lstRanges.map(function (lst) {
    return cRange(lst[0], lst[1]);
  });
 
})([
  ['a', 'z'],
  ['🐐', '🐟']
]);[[strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv],
 [strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv]]var letters = []
for (var i = 97; i <= 122; i++) {
    letters.push(String.fromCodePoint(i))
}(lstRanges => {
 
    
    function charRange(cFrom, cTo) {
        let [m, n] = [cFrom, cTo]
        .map(s => s.codePointAt(0));
 
        return Array.from({
            length: (n - m) + 1
        }, (_, i) => String.fromCodePoint(m + i));
    }
 
 
 
    
    return lstRanges
        .map(([from, to]) => charRange(from, to).join(' '))
        .join('')
 
})([['a', 'z'], ['א','ת'],['α', 'ω'],['🐐', '🐟']]);"
"function swap(arr) {
  var tmp = arr[0];
  arr[0] = arr[1];
  arr[1] = tmp;
}function swap(aName, bName) {
  eval('(function(){ arguments[0] = aName; aName = bName; bName = arguments[0] })()'
    .replace(/aName/g, aName)
    .replace(/bName/g, bName)
  )
}
var x = 1
var y = 2
swap('x', 'y')
 "
"function ch960startPos() {
  var rank = new Array(8),
      
      d = function(num) { return Math.floor(Math.random() * ++num) },
      emptySquares = function() {
        var arr = [];
        for (var i = 0; i < 8; i++) if (rank[i] == undefined) arr.push(i);
        return arr;
      };
  
  rank[d(2) * 2] = strv;
  
  rank[d(2) * 2 + 1] = strv;
  
  rank[emptySquares()[d(5)]] = strv;
  
  rank[emptySquares()[d(4)]] = strv;
  
  rank[emptySquares()[d(3)]] = strv;
  
  for (var x = 1; x <= 3; x++) rank[emptySquares()[0]] = x==2 ? strv : strv;
  return rank;
}
 

for (var x = 1; x <= 10; x++) console.log(ch960startPos().join(strv));"
"function fizz(d, e) {
  return function b(a) {
    return a ? b(a - 1).concat(a) : [];
  }(e).reduce(function (b, a) {
    return b + (d.reduce(function (b, c) {
      return b + (a % c[0] ? strv : c[1]);
    }, strv) || a.toString()) + """";
  }, strv);
}function fizz(lstRules, lngMax) {
 
    return (
        function rng(i) {
            return i ? rng(i - 1).concat(i) : []
        }
    )(lngMax).reduce(
        function (strSeries, n) {
 
            
            
            return strSeries + (
                lstRules.reduce(
                    function (str, tplNumWord) {
                        return str + (
                            n % tplNumWord[0] ? '' : tplNumWord[1]
                        )
                    }, ''
                ) || n.toString()
            ) + '';
 
        }, ''
    );
}
 
fizz([[3, 'Fizz'], [5, 'Buzz'], [7, 'Baxx']], 20);(() => {
 
    
    const fizz = (lstRules, lngMax) => range(1, lngMax)
        .reduce((strSeries, n) =>
 
            
            
            strSeries + (
                lstRules
                .reduce((str, tplNumWord) =>
                    str + (
                        n % tplNumWord[0] ? '' : tplNumWord[1]
                    ),
                    ''
                ) || n.toString()
            ) + '', ''
        );
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
    return fizz([
        [3, 'Fizz'],
        [5, 'Buzz'],
        [7, 'Baxx']
    ], 20);
 
})();"
"
function lusolve(A, b, update) {
	var lu = ludcmp(A, update)
	if (lu === undefined) return 
	return lubksb(lu, b, update)
}
 

function ludcmp(A, update) {
	
	var d = true
	var n = A.length
	var idx = new Array(n) 
	var vv = new Array(n)  
 
	for (var i=0; i<n; i++) {
		var max = 0
		for (var j=0; j<n; j++) {
			var temp = Math.abs(A[i][j])
			if (temp > max) max = temp
		}
		if (max == 0) return 
		vv[i] = 1 / max 
	}
 
	if (!update) { 
		var Acpy = new Array(n)
		for (var i=0; i<n; i++) {		
			var Ai = A[i] 
			Acpyi = new Array(Ai.length)
			for (j=0; j<Ai.length; j+=1) Acpyi[j] = Ai[j]
			Acpy[i] = Acpyi
		}
		A = Acpy
	}
 
	var tiny = 1e-20 
	for (var i=0; ; i++) {
		for (var j=0; j<i; j++) {
			var sum = A[j][i]
			for (var k=0; k<j; k++) sum -= A[j][k] * A[k][i];
			A[j][i] = sum
		}
		var jmax = 0
		var max = 0;
		for (var j=i; j<n; j++) {
			var sum = A[j][i]
			for (var k=0; k<i; k++) sum -= A[j][k] * A[k][i];
			A[j][i] = sum
			var temp = vv[j] * Math.abs(sum)
			if (temp >= max) {
				max = temp
				jmax = j
			}
		}
		if (i <= jmax) {
			for (var j=0; j<n; j++) {
				var temp = A[jmax][j]
				A[jmax][j] = A[i][j]
				A[i][j] = temp
			}
			d = !d;
			vv[jmax] = vv[i]
		}
		idx[i] = jmax;
		if (i == n-1) break;
		var temp = A[i][i]
		if (temp == 0) A[i][i] = temp = tiny
		temp = 1 / temp
		for (var j=i+1; j<n; j++) A[j][i] *= temp
	}
	return {A:A, idx:idx, d:d}
}
 

function lubksb(lu, b, update) {
	
	
	var A = lu.A
	var idx = lu.idx
	var n = idx.length
 
	if (!update) { 
		var bcpy = new Array(n) 
		for (var i=0; i<b.length; i+=1) bcpy[i] = b[i]
		b = bcpy
	}
 
	for (var ii=-1, i=0; i<n; i++) {
		var ix = idx[i]
		var sum = b[ix]
		b[ix] = b[i]
		if (ii > -1)
			for (var j=ii; j<i; j++) sum -= A[i][j] * b[j]
		else if (sum)
			ii = i
		b[i] = sum
	}
	for (var i=n-1; i>=0; i--) {
		var sum = b[i]
		for (var j=i+1; j<n; j++) sum -= A[i][j] * b[j]
		b[i] = sum / A[i][i]
	}
	return b 
}
 
document.write(
	lusolve(
		[
			[1.00, 0.00, 0.00,  0.00,  0.00,   0.00],
                	[1.00, 0.63, 0.39,  0.25,  0.16,   0.10],
                	[1.00, 1.26, 1.58,  1.98,  2.49,   3.13],
                	[1.00, 1.88, 3.55,  6.70, 12.62,  23.80],
                	[1.00, 2.51, 6.32, 15.88, 39.90, 100.28],
                	[1.00, 3.14, 9.87, 31.01, 97.41, 306.02]
		],
    		[-0.01, 0.61, 0.91,  0.99,  0.60,   0.02]
	)
)"
" 

function List() {}
 
List.prototype.push = function() {
  return [].push.apply(this, arguments);
};
 
List.prototype.pop = function() {
  return [].pop.call(this);
};
 
var l = new List();
l.push(5);
l.length; 
l[0]; 5
l.pop(); 
l.length; 
 

function List() {
  this.push.apply(this, arguments);
}
 
List.prototype.push = function() {
  return [].push.apply(this, arguments);
};
 
List.prototype.pop = function() {
  return [].pop.call(this);
};
 
var l = new List(5, 10, 15);
l.length; 
l[0]; 5
l.pop(); 
l.length; 
 
  

class List {
  push() {
    return [].push.apply(this, arguments);
  }
  pop() {
    return [].pop.call(this);  
  }
}
 
var l = new List();
l.push(5);
l.length; 
l[0]; 5
l.pop(); 
l.length; 
 
 
 

class List {
  constructor(...args) {
    this.push(...args);
  }
  push() {
    return [].push.apply(this, arguments);
  }
  pop() {
    return [].pop.call(this);  
  }
}
 
var l = new List(5, 10, 15);
l.length; 
l[0]; 5
l.pop(); 
l.length; 
 "
"function reverseDomain(domain) {
    return domain.split('.').reverse().join('.');
}"
" 
function gamma(x){
	var p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
		771.32342877765313, -176.61502916214059, 12.507343278686905,
		-0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
 
	var g = 7;
	if(x < 0.5){
		return Math.PI / (Math.sin(Math.PI * x)*gamma(1-x));
	}
 
	x -= 1;
	var a = p[0];
	var t = x+g+0.5;
	for(var i = 1; i < p.length; i++){
		a += p[i]/(x+i);
	}
 
	return Math.sqrt(2*Math.PI)*Math.pow(t, x+0.5)*Math.exp(-t)*a;
}
 "
"function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}var id = compose(Math.sin, Math.asin);
print(id(0.5)); (function () {
    'use strict';
 
 
    
    function iterativeComposed(fs) {
 
        return function (x) {
            var i = fs.length,
                e = x;
 
            while (i--) e = fs[i](e);
            return e;
        }
    }
 
    
    function foldComposed(fs) {
 
        return function (x) {
            return fs
                .reduceRight(function (a, f) {
                    return f(a);
                }, x);
        };
    }
 
 
    var sqrt = Math.sqrt,
 
        succ = function (x) {
            return x + 1;
        },
 
        half = function (x) {
            return x / 2;
        };
 
 
    
 
    return [iterativeComposed, foldComposed]
        .map(function (compose) {
 
            
            return compose([half, succ, sqrt])(5);
 
        });
})();
 (() => {
    'use strict';
 
    
    let compose = fs => x => fs.reduceRight((a, f) => f(a), x);
 
    
    let sqrt = Math.sqrt,
 
        succ = x => x + 1,
 
        half = x => x / 2;
 
    return compose([half, succ, sqrt])(5);
 
    
})();(() => {
    'use strict';
 
    
    const compose = (f, g) => x => g(f(x));
 
 
    
    const
        sqrt = Math.sqrt,
        succ = x => x + 1,
        half = x => x / 2;
 
    const
        succSqrt = compose(sqrt, succ),
        halfSuccSqrt = compose(succSqrt, half);
 
    return halfSuccSqrt(5);
})();"
"function multiply(a, b) { 
  return a*b; 
}var multiply = function(a, b) {
    return a * b;
};var multiply = function multiply(a, b) {
    return a * b;
};var o = {
  multiply: function(a, b) {
    return a * b;
  }
};var o = {
  get foo() {
    return 1;
  }, 
  set bar(value) {
    
  }
};var multiply = (a, b) => a * b;
var multiply = (a, b) => { return a * b };
 var o = {
  multiply(a, b) {
    return a * b;
  }
};function * generator() {
  yield 1;
}"
" 
var num = new Array();
var den = new Array();
var val ;
 
function compile(prog){
  var regex = /\s*(\d*)\s*\/\s*(\d*)\s*(.*)/m;
  while(regex.test(prog)){
    num.push(regex.exec(prog)[1]);
    den.push(regex.exec(prog)[2]);
    prog = regex.exec(prog)[3];
  }
}
 
function dump(prog){
  for(var i=0; i<num.length; i++)
    document.body.innerHTML += num[i]+strv+den[i]+strv;
  document.body.innerHTML += strv;
}
 
function step(val){
  var i=0;
  while(i<den.length && val%den[i] != 0) i++;
  return num[i]*val/den[i];
}
 
function exec(val){
  var i = 0;
  while(val && i<limit){
    document.body.innerHTML += i+strv+val+strv;
    val = step(val);
    i ++;
  }
}
 

compile(strv);
dump(); 
var limit = 15;
exec(2);
 "
"<html>
<body>
<canvas id=strv></canvas>
 
<script type=strv>
var elem = document.getElementById('canvas');
var context = elem.getContext('2d');
 
context.fillStyle = '#000';
context.lineWidth = 1;
 
var deg_to_rad = Math.PI / 180.0;
var depth = 9;
 
function drawLine(x1, y1, x2, y2, brightness){
  context.moveTo(x1, y1);
  context.lineTo(x2, y2);
}
 
function drawTree(x1, y1, angle, depth){
  if (depth !== 0){
    var x2 = x1 + (Math.cos(angle * deg_to_rad) * depth * 10.0);
    var y2 = y1 + (Math.sin(angle * deg_to_rad) * depth * 10.0);
    drawLine(x1, y1, x2, y2, depth);
    drawTree(x2, y2, angle - 20, depth - 1);
    drawTree(x2, y2, angle + 20, depth - 1);
  }
}
 
context.beginPath();
drawTree(300, 500, -90, depth);
context.closePath();
context.stroke();
</script>
 
</body>
</html>
var canvas: HTMLCanvasElement = document.createElement('canvas')
canvas.width = 600
canvas.height = 500
document.body.appendChild(canvas)
var ctx: CanvasRenderingContext2D = canvas.getContext('2d')
ctx.fillStyle = '#000'
ctx.lineWidth = 1
 

const degToRad: number = Math.PI / 180.0
const totalDepth: number = 9
 
/** Helper function that draws a line on the canvas */
function drawLine(x1: number, y1: number, x2: number, y2: number): void {
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
}
 
/** Draws a branch at the given point and angle and then calls itself twice */
function drawTree(x1: number, y1: number, angle: number, depth: number): void {
    if (depth !== 0) {
        let x2: number = x1 + (Math.cos(angle * degToRad) * depth * 10.0)
        let y2: number = y1 + (Math.sin(angle * degToRad) * depth * 10.0)
        drawLine(x1, y1, x2, y2)
        drawTree(x2, y2, angle - 20, depth - 1)
        drawTree(x2, y2, angle + 20, depth - 1)
    }
}
 

ctx.beginPath()
drawTree(300, 500, -90, totalDepth)
ctx.closePath()
ctx.stroke()
 
 "
"(() => {
    'use strict';
 
    
    const forwardDifference = (n, xs) => {
        const fd = xs => zipWith((a, b) => a - b, tail(xs), xs);
        return until(
                m => m.index < 1,
                m => ({
                    index: m.index - 1,
                    list: fd(m.list)
                }), {
                    index: n,
                    list: xs
                }
            )
            .list;
    };
 
 
    
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    };
 
    
    const until = (p, f, x) => {
        const go = x => p(x) ? x : go(f(x));
        return go(x);
    };
 
    
    const tail = xs => xs.length ? xs.slice(1) : undefined;
 
 
    
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const show = x => JSON.stringify(x);
 
    
    const test = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73];
 
    return range(1, 9)
        .map(x => `${x}    ${show(forwardDifference(x, test))}`)
        .join('');
})();"
" 
function acceptedBinFormat(bin) {
    if (bin == 1 || bin === 0 || bin === '0')
        return true;
    else
        return bin;
}
 
function arePseudoBin() {
    var args = [].slice.call(arguments), len = args.length;
    while(len--)
        if (acceptedBinFormat(args[len]) !== true)
            throw new Error('argument must be 0, 0, 1, or 1, argument ' + len + ' was ' + args[len]);
    return true;
}
  



 
function not(a) {
    if (arePseudoBin(a))
        return a == 1 ? 0 : 1;
}
 
function and(a, b) {
    if (arePseudoBin(a, b))
        return a + b < 2 ? 0 : 1;
}
 
function nand(a, b) {
    if (arePseudoBin(a, b))
        return not(and(a, b));
}
 
function or(a, b) {
    if (arePseudoBin(a, b))
        return nand(nand(a,a), nand(b,b));
}
 
function xor(a, b) {
    if (arePseudoBin(a, b))
        return nand(nand(nand(a,b), a), nand(nand(a,b), b));
}
 
function halfAdder(a, b) {
    if (arePseudoBin(a, b))
        return { carry: and(a, b), sum: xor(a, b) };
}
 
function fullAdder(a, b, c) {
    if (arePseudoBin(a, b, c)) {
        var h0 = halfAdder(a, b), 
            h1 = halfAdder(h0.sum, c);
        return {carry: or(h0.carry, h1.carry), sum: h1.sum };
    }
}
 
function fourBitAdder(a, b) {
    if (typeof a.length == 'undefined' || typeof b.length == 'undefined')
        throw new Error('bad values');
    
    
    var inA = Array(4), 
        inB = Array(4), 
        out = Array(4), 
        i = 4, 
        pass;
 
    while (i--) {
        inA[i] = a[i] != 1 ? 0 : 1;
        inB[i] = b[i] != 1 ? 0 : 1;
    }
 
    
    
    
 
    pass = halfAdder(inA[3], inB[3]);
    out[3] = pass.sum;
    pass = fullAdder(inA[2], inB[2], pass.carry);
    out[2] = pass.sum;
    pass = fullAdder(inA[1], inB[1], pass.carry);
    out[1] = pass.sum;
    pass = fullAdder(inA[0], inB[0], pass.carry);
    out[0] = pass.sum;
    return out.join('');
}
 fourBitAdder('1010', '0101');  

var outer = inner = 16, a, b;
 
while(outer--) {
    a = (8|outer).toString(2);
    while(inner--) {
        b = (8|inner).toString(2);
        console.log(a + ' + ' + b + ' = ' + fourBitAdder(a, b));
    }
    inner = outer;
}
 "
"var graph = [];
for (i = 0; i < 10; ++i) {
  graph.push([]);
  for (j = 0; j < 10; ++j)
    graph[i].push(i == j ? 0 : 9999999);
}
 
for (i = 1; i < 10; ++i) {
  graph[0][i] = graph[i][0] = parseInt(Math.random() * 9 + 1);
}
 
for (k = 0; k < 10; ++k) {
  for (i = 0; i < 10; ++i) {
    for (j = 0; j < 10; ++j) {
      if (graph[i][j] > graph[i][k] + graph[k][j])
        graph[i][j] = graph[i][k] + graph[k][j]
    }
  }
}
 
console.log(graph);"
"var n = 123;
var str = (strv + n).slice(-5);
alert(str);"
"(function () {
    'use strict';
 
    
 
    
    function floyd(n) {
        return snd(mapAccumL(function (start, row) {
            return [start + row + 1, enumFromTo(start, start + row)];
        }, 1, enumFromTo(0, n - 1)));
    };
 
    
    function showFloyd(xss) {
        var ws = map(compose([succ, length, show]), last(xss));
        return unlines(map(function (xs) {
            return concat(zipWith(function (w, x) {
                return justifyRight(w, ' ', show(x));
            }, ws, xs));
        }, xss));
    };
 
 
    
 
    
    function compose(fs) {
        return function (x) {
            return fs.reduceRight(function (a, f) {
                return f(a);
            }, x);
        };
    };
 
    
    function concat(xs) {
        if (xs.length > 0) {
            var unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    function enumFromTo(m, n) {
        return Array.from({
            length: Math.floor(n - m) + 1
        }, function (_, i) {
            return m + i;
        });
    };
 
    
    function justifyRight(n, cFiller, strText) {
        return n > strText.length ? (cFiller.repeat(n) + strText)
            .slice(-n) : strText;
    };
 
    
    function last(xs) {
        return xs.length ? xs.slice(-1)[0] : undefined;
    };
 
    
    function length(xs) {
        return xs.length;
    };
 
    
    function map(f, xs) {
        return xs.map(f);
    };
 
    
    
    
    
 
    
    function mapAccumL(f, acc, xs) {
        return xs.reduce(function (a, x) {
            var pair = f(a[0], x);
 
            return [pair[0], a[1].concat([pair[1]])];
        }, [acc, []]);
    };
 
    
    
    
    var show = JSON.stringify;
 
    
    function snd(tpl) {
        return Array.isArray(tpl) ? tpl[1] : undefined;
    };
 
    
    function succ(x) {
        return x + 1;
    };
 
    
    function unlines(xs) {
        return xs.join('');
    };
 
    
    function zipWith(f, xs, ys) {
        var ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map(function (x, i) {
                return f(x, ys[i]);
            });
    };
 
    
 
    return unlines(map(function (n) {
        return showFloyd(floyd(n)) + '';
    }, [5, 14]));
})();(() => {
    'use strict';
 
    
 
    
    const floyd = n => snd(mapAccumL(
        (start, row) => [start + row + 1, enumFromTo(start, start + row)],
        1, enumFromTo(0, n - 1)
    ));
 
    
    const showFloyd = xss => {
        const ws = map(compose([succ, length, show]), last(xss));
        return unlines(
            map(xs => concat(zipWith(
                    (w, x) => justifyRight(w, ' ', show(x)), ws, xs
                )),
                xss
            )
        );
    };
 
    
 
    
    const compose = fs => x => fs.reduceRight((a, f) => f(a), x);
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const justifyRight = (n, cFiller, strText) =>
        n > strText.length ? (
            (cFiller.repeat(n) + strText)
            .slice(-n)
        ) : strText;
 
    
    const last = xs => xs.length ? xs.slice(-1)[0] : undefined;
 
    
    const length = xs => xs.length;
 
    
    const map = (f, xs) => xs.map(f)
 
    
    
    
    
 
    
    const mapAccumL = (f, acc, xs) =>
        xs.reduce((a, x) => {
            const pair = f(a[0], x);
 
            return [pair[0], a[1].concat([pair[1]])];
        }, [acc, []]);
 
    
    
    
    const show = JSON.stringify;
 
    
    const snd = tpl => Array.isArray(tpl) ? tpl[1] : undefined;
 
    
    const succ = x => x + 1
 
    
    const unlines = xs => xs.join('');
 
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    };
 
    
 
    return unlines(map(n => showFloyd(floyd(n)) + '', [5, 14]))
})();#!/usr/bin/env js
 
function main() {
    print('Floyd 5:');
    floyd(5);
    print('Floyd 14:');
    floyd(14);
}
 
 
function padLeft(s, w) {
    for (s = String(s); s.length < w; s = ' ' + s);
    return s;
}
 
 
function floyd(nRows) {
    var lowerLeft = nRows * (nRows - 1) / 2 + 1;
    var lowerRight = nRows * (nRows + 1) / 2;
 
    var colWidths = [];
    for (var col = lowerLeft; col <= lowerRight; col++) {
        colWidths.push(String(col).length);
    }
 
    var  num = 1;
    for (var row = 0; row < nRows; row++) {
        var line = [];
        for (var col = 0; col <= row; col++, num++) {
            line.push(padLeft(num, colWidths[col]));
        }
        print(line.join(' '));
    }
}
 
main();"
"strv
 
const _ = require('lodash');
 
const WIDTH_ARGUMENT_POSITION  = 2;
const HEIGHT_ARGUMENT_POSITION = 3;
const TREE_PROBABILITY         = 0.5;
const NEW_TREE_PROBABILITY     = 0.01;
const BURN_PROBABILITY         = 0.0001;
const CONSOLE_RED              = '1b[31m';
const CONSOLE_GREEN            = '1b[32m';
const CONSOLE_COLOR_CLOSE      = '1b[91m';
const CONSOLE_CLEAR            = '001B[2J001B[0;0f';
const NEIGHBOURS               = [
    [-1, -1],
    [-1,  0],
    [-1,  1],
    [ 0, -1],
    [ 0,  1],
    [ 1, -1],
    [ 1,  0],
    [ 1,  1]
];
const PRINT_DECODE             = {
    ' ': ' ',
    'T': `${CONSOLE_GREEN}T${CONSOLE_COLOR_CLOSE}`,
    'B': `${CONSOLE_RED}T${CONSOLE_COLOR_CLOSE}`,
};
const CONDITIONS = {
    'T': (forest, y, x) => Math.random() < BURN_PROBABILITY || burningNeighbour(forest, y, x) ? 'B' : 'T',
    ' ':  () => Math.random() < NEW_TREE_PROBABILITY ? 'T' : ' ',
    'B':  () => ' '
};
 
const WIDTH  = process.argv[WIDTH_ARGUMENT_POSITION]  || 20;
const HEIGHT = process.argv[HEIGHT_ARGUMENT_POSITION] || 10;
 
const update = forest => {
    return _.map(forest, (c, ci) => {
        return _.map(c, (r, ri) => {
            return CONDITIONS[r](forest, ci, ri);
        });
    });
}
 
const printForest = forest => {
    process.stdout.write(CONSOLE_CLEAR);
    _.each(forest, c => {
        _.each(c, r => {
            process.stdout.write(PRINT_DECODE[r]);
        });
        process.stdout.write('');
    })
}
 
const burningNeighbour = (forest, y, x) => {
    return _(NEIGHBOURS)
           .map(n => _.isUndefined(forest[y + n[0]]) ? null : forest[y + n[0]][x + n[1]])
           .any(_.partial(_.isEqual, 'B'));
};
 
let forest = _.times(HEIGHT, () => _.times(WIDTH, () => Math.random() < TREE_PROBABILITY ? 'T' : ' '));
 
setInterval(() => {
    forest = update(forest);
    printForest(forest)
}, 20);
 
 var forest = {
    X: 50,
    Y: 50,
    propTree: 0.5,
    propTree2: 0.01,
    propBurn: 0.0001,
    t: [],
    c: ['rgb(255,255,255)', 'rgb(0,255,0)', 'rgb(255,0,0)']
};
 
for(var i = 0; i < forest.Y; i++) {
    forest.t[i] = [];
    for(var j = 0; j < forest.Y; j++) {
        forest.t[i][j] = Math.random() < forest.propTree ? 1 : 0;
    }
}
 
function afterLoad(forest) {
    var canvas = document.getElementById('canvas');
    var c = canvas.getContext('2d');
    for(var i = 0; i < forest.X; i++) {
        for(var j = 0; j < forest.Y; j++) {
            c.fillStyle = forest.c[forest.t[i][j]];
            c.fillRect(10*j, 10*i, 10*j+9, 10*i+9);
        }
    }
}
 
function doStep(forest) {
    var to = [];
    for(var i = 0; i < forest.Y; i++) {
        to[i] = forest.t[i].slice(0);
    }
 
    //indices outside the array are undefined; which converts to 0=empty on forced typecast
    for(var i = 0; i < forest.Y; i++) {
        for(var j = 0; j < forest.Y; j++) {
            if(0 == to[i][j]) {
                forest.t[i][j] = Math.random() < forest.propTree2 ? 1 : 0;
            } else if(1 == to[i][j]) {
                if(
                    ((i>0) && (2 == to[i-1][j])) ||
                    ((i<forest.Y-1) && (2 == to[i+1][j])) ||
                    ((j>0) && (2 == to[i][j-1])) ||
                    ((j<forest.X-1) && (2 == to[i][j+1]))
                    ) {
                    forest.t[i][j] = 2;
                } else {
                    forest.t[i][j] = Math.random() < forest.propBurn ? 2 : 1;
                }
            } else if(2 == to[i][j]) {
                //If it burns, it gets empty ...
                forest.t[i][j] = 0;
            }
        }
    }
 
}
 
window.setInterval(function(){
    doStep(forest);
    afterLoad(forest);
}, 100);
 "
"function numOfRows(board) { return board.length; }
function numOfCols(board) { return board[0].length; }
function boardToString(board) {
    
    var header = '   ';
    for (var c = 0; c < numOfCols(board); c++)
        header += c + ' ';
 
    
    var sideboard = [];
    for (var r = 0; r < numOfRows(board); r++) {
        sideboard.push(r + ' [' + board[r].join(' ') + ']');
    }
 
    return header + '' + sideboard.join('');
}
function flipRow(board, row) {
    for (var c = 0; c < numOfCols(board); c++) {
        board[row][c] = 1 - board[row][c];
    }
}
function flipCol(board, col) {
    for (var r = 0; r < numOfRows(board); r++) {
        board[r][col] = 1 - board[r][col];
    }
}
 
function playFlippingBitsGame(rows, cols) {
    rows = rows | 3;
    cols = cols | 3;
    var targetBoard = [];
    var manipulatedBoard = [];
    
    for (var r = 0; r < rows; r++) {
        targetBoard.push([]);
        manipulatedBoard.push([]);
        for (var c = 0; c < cols; c++) {
            targetBoard[r].push(Math.floor(Math.random() * 2));
            manipulatedBoard[r].push(targetBoard[r][c]);
        }
    }
    
    while (boardToString(targetBoard) == boardToString(manipulatedBoard)) {
        var scrambles = rows * cols;
        while (scrambles-- > 0) {
            if (0 == Math.floor(Math.random() * 2)) {
                flipRow(manipulatedBoard, Math.floor(Math.random() * rows));
            }
            else {
                flipCol(manipulatedBoard, Math.floor(Math.random() * cols));
            }
        }
    }
    
    alert(
        'Try to match both boards.' +
        'Enter `r<num>` or `c<num>` to manipulate a row or col or enter `q` to quit.'
        );
    var input = '', letter, num, moves = 0;
    while (boardToString(targetBoard) != boardToString(manipulatedBoard) && input != 'q') {
        input = prompt(
            'Target:' + boardToString(targetBoard) +
            '' +
            'Board:' + boardToString(manipulatedBoard)
            );
        try {
            letter = input.charAt(0);
            num = parseInt(input.slice(1));
            if (letter == 'q')
				break;
            if (isNaN(num)
                || (letter != 'r' && letter != 'c')
                || (letter == 'r' && num >= rows)
                || (letter == 'c' && num >= cols)
                ) {
                throw new Error('');
            }
            if (letter == 'r') {
                flipRow(manipulatedBoard, num);
            }
            else {
                flipCol(manipulatedBoard, num);
            }
            moves++;
        }
        catch(e) {
            alert('Uh-oh, there seems to have been an input error');
        }
    }
    if (input == 'q') {
        alert('~~ Thanks for playing ~~');
    }
    else {
        alert('Completed in ' + moves + ' moves.');
    }
}"
"function flatten(list) {
  return list.reduce(function (acc, val) {
    return acc.concat(val.constructor === Array ? flatten(val) : val);
  }, []);
}(function () {
    'use strict';
 
    
    function flatten(t) {
        return (t instanceof Array ? concatMap(flatten, t) : t);
    }
 
    
    function concatMap(f, xs) {
        return [].concat.apply([], xs.map(f));
    }
 
    return flatten(
        [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]
    );
 
})();    
    function flatten(a) {
        return a instanceof Array ? [].concat.apply([], a.map(flatten)) : a;
    }(function () {
    'use strict';
 
    
    function flatten(a) {
        return a instanceof Array ? [].concat.apply([], a.map(flatten)) : a;
    }
 
    return flatten(
        [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]
    );
 
})();let flatten = list => list.reduce(
    (a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []
);function flatten(list) {
  for (let i = 0; i < list.length; i++) {
    while (true) {
      if (Array.isArray(list[i])) {
      	list.splice(i, 1, ...list[i]);
      } else {
      	break;
      }
    }
  }
  return list;
}"
"permute = function(v, m){ //v1.0
    for(var p = -1, j, k, f, r, l = v.length, q = 1, i = l + 1; --i; q *= i);
    for(x = [new Array(l), new Array(l), new Array(l), new Array(l)], j = q, k = l + 1, i = -1;
        ++i < l; x[2][i] = i, x[1][i] = x[0][i] = j /= --k);
    for(r = new Array(q); ++p < q;)
        for(r[p] = new Array(l), i = -1; ++i < l; !--x[1][i] && (x[1][i] = x[0][i],
            x[2][i] = (x[2][i] + 1) % l), r[p][i] = m ? x[3][i] : v[x[3][i]])
            for(x[3][i] = x[2][i], f = 0; !f; f = !f)
                for(j = i; j; x[3][--j] == x[2][i] && (x[3][i] = x[2][i] = (x[2][i] + 1) % l, f = 1));
    return r;
};
 
list = [ 'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB',
        'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA',
        'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'];
 
all = permute(list[0].split('')).map(function(elem) {return elem.join('')});
 
missing = all.filter(function(elem) {return list.indexOf(elem) == -1});
print(missing);  (function (strList) {
 
    
    function permutations(xs) {
        return xs.length ? (
            chain(xs, function (x) {
                return chain(permutations(deleted(x, xs)), function (ys) {
                    return [[x].concat(ys).join('')];
                })
            })) : [[]];
    }
 
    
    
    function chain(xs, f) {
        return [].concat.apply([], xs.map(f));
    }
 
    
    function deleted(x, xs) {
        return xs.length ? (
            x === xs[0] ? xs.slice(1) : [xs[0]].concat(
                deleted(x, xs.slice(1))
            )
        ) : [];
    }
 
    
    var lstSubSet = strList.split('');
 
    
    
    return chain(permutations('ABCD'.split('')), function (x) {
        return lstSubSet.indexOf(x) === -1 ? [x] : [];
    });
 
})(
    'ABCDCABDACDBDACBBCDAACBDADCBCDABDABCBCADCADBCDBACBADABDCADBCBDCADCBABACDBADCBDACCBDADBCADCAB'
);[strv](() => {
    'use strict';
 
    
    let transpose = xs =>
        xs[0].map((_, iCol) => xs
            .map((row) => row[iCol]));
 
 
    let xs = 'ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB' +
        ' DABC BCAD CADB CDBA CBAD ABDC ADBC BDCA DCBA' +
        ' BACD BADC BDAC CBDA DBCA DCAB'
 
    return transpose(xs.split(' ')
            .map(x => x.split('')))
        .map(col => col.reduce((a, x) => ( 
            a[x] = (a[x] || 0) + 1,
            a
        ), {}))
        .map(dct => { 
            let ks = Object.keys(dct),
                xs = ks.map(k => dct[k]),
                mean = xs.reduce((a, b) => a + b, 0) / xs.length;
 
            return ks.reduce(
                (a, k) => a ? a : (dct[k] < mean ? k : undefined),
                undefined
            );
        })
        .join(''); 
 
    
})();(() => {
    'use strict';
 
    
 
    
    const missingPermutation = xs =>
        map(
            
            compose([
                sort,
                group,
                curry(minimumBy)(comparing(length)),
                head
            ]),
 
            
            transpose(map(stringChars, xs))
        )
        .join('');
 
 
    
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map(row => row[iCol]));
 
    
    const sort = xs => xs.sort();
 
    
    const group = xs => groupBy((a, b) => a === b, xs);
 
    
    const groupBy = (f, xs) => {
        const dct = xs.slice(1)
            .reduce((a, x) => {
                const
                    h = a.active.length > 0 ? a.active[0] : undefined,
                    blnGroup = h !== undefined && f(h, x);
 
                return {
                    active: blnGroup ? a.active.concat(x) : [x],
                    sofar: blnGroup ? a.sofar : a.sofar.concat([a.active])
                };
            }, {
                active: xs.length > 0 ? [xs[0]] : [],
                sofar: []
            });
        return dct.sofar.concat(dct.active.length > 0 ? [dct.active] : []);
    };
 
    
    const length = xs => xs.length;
 
    
    const comparing = f =>
        (x, y) => {
            const
                a = f(x),
                b = f(y);
            return a < b ? -1 : a > b ? 1 : 0
        };
 
    
    const minimumBy = (f, xs) =>
        xs.reduce((a, x) => a === undefined ? x : (
            f(x, a) < 0 ? x : a
        ), undefined);
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const map = (f, xs) => xs.map(f)
 
    
    const compose = fs => x => fs.reduce((a, f) => f(a), x);
 
    
    const curry = f => a => b => f(a, b);
 
    
    const stringChars = s => s.split('');
 
 
    
 
    return missingPermutation([strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv, strv
    ]);
 
    
})();"
"(() => {
    'use strict';
 
    
 
    
    const maybeIntersection = ([
        [ax, ay],
        [bx, by]
    ], [
        [px, py],
        [qx, qy]
    ]) => {
        const
            abDX = ax - bx,
            pqDX = px - qx,
            abDY = ay - by,
            pqDY = py - qy,
            determinant = abDX * pqDY - abDY * pqDX;
 
        return determinant !== 0 ? ({
            valid: true,
            value: (() => {
                const
                    abD = ax * by - ay * bx,
                    pqD = px * qy - py * qx;
                return [
                    (abD * pqDX - abDX * pqD) / determinant,
                    (abD * pqDY - abDY * pqD) / determinant
                ];
            })()
        }) : {
            valid: false
        };
    };
 
    
    
    const ab = [
        [4.0, 0.0],
        [6.0, 10.0]
    ];
 
    
    const pq = [
        [0.0, 3.0],
        [10.0, 7.0]
    ];
 
    
    const intersection = maybeIntersection(ab, pq);
 
    return intersection.valid ? (
        JSON.stringify(intersection.value)
    ) : '(Parallel lines – no intersection)';
})();"
"
var cube = function (x) {
  return Math.pow(x, 3);
};
var cuberoot = function (x) {
  return Math.pow(x, 1 / 3);
};
 

var compose = function (f, g) {
  return function (x) {
    return f(g(x));
  };
};
 

var fun = [Math.sin, Math.cos, cube];
var inv = [Math.asin, Math.acos, cuberoot];
 
for (var i = 0; i < 3; i++) {
  
  console.log(compose(inv[i], fun[i])(0.5));
}
var cube = x => Math.pow(x, 3);
 
var cuberoot = x => Math.pow(x, 1 / 3);
 
 

var compose = (f, g) => (x => f(g(x)));
 

var fun = [ Math.sin, Math.cos, cube ];
var inv = [ Math.asin, Math.acos, cuberoot ];
 
for (var i = 0; i < 3; i++) {
  
  console.log(compose(inv[i], fun[i])(0.5));
}"
"function lastSundayOfEachMonths(year) {
	var lastDay = [31,28,31,30,31,30,31,31,30,31,30,31]
	if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) lastDay[2] = 29
	for (var date = new Date(), month=0; month<12; month+=1) {
		date.setFullYear(year, month, lastDay[month])
		date.setDate(date.getDate()-date.getDay())
		document.write(date.toISOString().substring(0,10), '<br>')
	}   
}
 
lastSundayOfEachMonths(2013)(function () {
    'use strict';
 
    
    function lastSundaysOfYear(y) {
        return lastWeekDaysOfYear(y, days.sunday);
    }
 
    
    function lastWeekDaysOfYear(y, iWeekDay) {
        return [
                31,
                0 === y % 4 && 0 !== y % 100 || 0 === y % 400 ? 29 : 28,
                31, 30, 31, 30, 31, 31, 30, 31, 30, 31
            ]
            .map(function (d, m) {
                var dte = new Date(Date.UTC(y, m, d));
 
                return new Date(Date.UTC(
                    y, m, d - (
                        (dte.getDay() + (7 - iWeekDay)) % 7
                    )
                ));
            });
    }
 
    
    function isoDateString(dte) {
        return dte.toISOString()
            .substr(0, 10);
    }
 
    
    function range(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (x, i) {
                return m + i;
            });
    }
 
    
    function transpose(lst) {
        return lst[0].map(function (_, iCol) {
            return lst.map(function (row) {
                return row[iCol];
            });
        });
    }
 
    var days = {
        sunday: 0,
        monday: 1,
        tuesday: 2,
        wednesday: 3,
        thursday: 4,
        friday: 5,
        saturday: 6
    }
 
    
 
    return transpose(
            range(2012, 2016)
            .map(lastSundaysOfYear)
        )
        .map(function (row) {
            return row
                .map(isoDateString)
                .join('');
        })
        .join('');
 
})();(() => {
    'use strict'
 
    
    const lastWeekDaysOfYear = (iWeekDay, y) => [
            31,
            0 === y % 4 && 0 !== y % 100 || 0 === y % 400 ? 29 : 28,
            31, 30, 31, 30, 31, 31, 30, 31, 30, 31
        ]
        .map((d, m) =>
            new Date(Date.UTC(
                y, m, d - ((new Date(Date.UTC(y, m, d))
                    .getDay() + (7 - iWeekDay)) % 7))));
 
    const days = {
        sunday: 0,
        monday: 1,
        tuesday: 2,
        wednesday: 3,
        thursday: 4,
        friday: 5,
        saturday: 6
    };
 
    
 
    
    const curry = f => a => b => f(a, b);
 
    
    const isoDateString = dte =>
        dte.toISOString()
        .substr(0, 10);
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const transpose = lst =>
        lst[0].map((_, iCol) =>
            lst.map(row => row[iCol]));
 
    
    return transpose(
            range(2015, 2019)
            .map(curry(lastWeekDaysOfYear)(days.sunday))
        )
        .map(row => row
            .map(isoDateString)
            .join(''))
        .join('');
})();"
" 
function recurse(depth)
{
 try
 {
  return recurse(depth + 1);
 }
 catch(ex)
 {
  return depth;
 }
}
 
var maxRecursion = recurse(1);
document.write(strv + maxRecursion);"
"var arr = [1,2,3,4,5];
var evens = arr.filter(function(a) {return a % 2 == 0});var arr = [1,2,3,4,5];
var evens = [];
for (var i=0, ilen=arr.length; i<ilen; i++)
      if (arr[i] % 2 == 0)
              evens.push(arr[i]);var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var evens = [i for (i in numbers) if (i % 2 == 0)];
 
function range(limit) {
  for(var i = 0; i < limit; i++) {
    yield i;
  }
}
 
var evens2 = [i for (i in range(100)) if (i % 2 == 0)];Functional.select(strv, [1,2,3,4])   (() => {
    'use strict';
 
    
    const isEven = n => n % 2 === 0;
 
 
    
 
    return [1,2,3,4,5,6,7,8,9]
        .filter(isEven);
 
    
})();[2, 4, 6, 8]"
"(() => {
    'use strict';
 
    
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const compose = (f, g) => x => f(g(x));
 
    
    const listApply = (fs, xs) =>
        [].concat.apply([], fs.map(f =>
        [].concat.apply([], xs.map(x => [f(x)]))));
 
    
    const pure = x => [x];
 
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const transpose = xs =>
        xs[0].map((_, iCol) => xs.map(row => row[iCol]));
 
    
    const reverse = xs =>
        typeof xs === 'string' ? (
            xs.split('')
            .reverse()
            .join('')
        ) : xs.slice(0)
        .reverse();
 
    
    const take = (n, xs) => xs.slice(0, n);
 
    
    const drop = (n, xs) => xs.slice(n);
 
    
    const maximum = xs =>
        xs.reduce((a, x) => (x > a || a === undefined ? x : a), undefined);
 
    
    const quotRem = (m, n) => [Math.floor(m / n), m % n];
 
    
    const length = xs => xs.length;
 
    
    const justifyLeft = (n, cFiller, strText) =>
        n > strText.length ? (
            (strText + cFiller.repeat(n))
            .substr(0, n)
        ) : strText;
 
    
    const unwords = xs => xs.join(' ');
 
    
    const unlines = xs => xs.join('');
 
 
    
 
    
    const show = n => n.toString(10);
    const showBinary = n => n.toString(2);
    const showTernary = n => n.toString(3);
 
    
    const readBase3 = s => parseInt(s, 3);
 
    
    const base3Palindrome = n => {
        const s = showTernary(n);
        return s + '1' + reverse(s);
    };
 
    
    const isBinPal = n => {
        const
            s = showBinary(n),
            [q, r] = quotRem(s.length, 2);
        return (r !== 0) && drop(q + 1, s) === reverse(take(q, s));
    };
 
    
    const solutions = [0, 1].concat(range(1, 10E5)
        .map(compose(readBase3, base3Palindrome))
        .filter(isBinPal));
 
    
 
    
    const cols = transpose(
        [
            ['Decimal', 'Ternary', 'Binary']
        ].concat(
            solutions.map(
                compose(
                    xs => listApply([show, showTernary, showBinary], xs),
                    pure
                )
            )
        )
    );
 
    return unlines(
        transpose(cols.map(col => col.map(
            curry(justifyLeft)(maximum(col.map(length)) + 1, ' ')
        )))
        .map(unwords));
})();"
"var fizzBuzz = function () {
  var i, output;
  for (i = 1; i < 101; i += 1) {
    output = '';
    if (!(i % 3)) { output += 'Fizz'; }
    if (!(i % 5)) { output += 'Buzz'; }
    console.log(output || i);//empty string is false, so we short-circuit
  }
};for (var i = 1; i <= 100; i++) {
  console.log({
    truefalse: 'Fizz', 
    falsetrue: 'Buzz', 
    truetrue: 'FizzBuzz'
  }[(i%3==0) + '' + (i%5==0)] || i)
}for(i=1;i<101;i++)console.log((x=(i%3?'':'Fizz')+(i%5?'':'Buzz'))?x:i);for(i=1;i<101;i++)console.log((i%3?'':'Fizz')+(i%5?'':'Buzz')||i)(function rng(i) {
    return i ? rng(i - 1).concat(i) : []
})(100).map(
    function (n) {
        return n % 3 ? (
            n % 5 ? n : strv
        ) : (
            n % 5 ? strv : strv
        )
    }
).join(' ')(() => {
 
    
    const fizzBuzz = n =>
        caseOf(n, [
            [x => x % 15 === 0, strv],
            [x => x % 3 === 0, strv],
            [x => x % 5 === 0, strv]
        ], n.toString());
 
 
 
    
 
    
    const caseOf = (e, pvs, otherwise) =>
        pvs.reduce((a, [p, v]) =>
            a !== otherwise ? a : (p(e) ? v : a), otherwise);
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
    
    return range(1, 100)
        .map(fizzBuzz)
        .join('');
})(); 
1.to 100
  [
  println(
    if idx.mod(15) = 0 [strv]
      idx.mod(3) = 0 [strv]
      idx.mod(5) = 0 [strv]
      else [idx])
  ]
  
1.to 100
  [
  !str: strv
  if idx.mod(3) = 0 [str += strv]
  if idx.mod(5) = 0 [str += strv]
  println(if str.empty? [idx] else [str])
  ]
  
1.to 100
  [
  !str: if idx.mod(3) = 0 [strv] else [strv]
  if idx.mod(5) = 0 [str += strv]
  println(if str.empty? [idx] else [str])
  ]
 function Fizzbuzz(n) {
    for (local i = 1; i <= n; i += 1) {
        if (i % 15 == 0)
            print (""FizzBuzz"")
        else if (i % 5 == 0)
            print (""Buzz"")
        else if (i % 3 == 0)
            print (""Fizz"")
        else {
            print (i + """")
        }
    }
}
Fizzbuzz(100);"
"var fso = new ActiveXObject(strv);
fso.GetFile('input.txt').Size;
fso.GetFile('c:/input.txt').Size;var file = document.getElementById(strv).files.item(0); //a file input element
if (file) {
	var reader = new FileReader();
	reader.readAsText(file, strv);
	reader.onload = loadedFile;
	reader.onerror = errorHandler;
}
function loadedFile(event) {
	var fileString = event.target.result;
	alert(fileString.length);
}
function errorHandler(event) {
	alert(event);
}"
"var fso = new ActiveXObject(strv);
var f = fso.GetFile('input.txt');
var mtime = f.DateLastModified;var file = document.getElementById(strv).files.item(0);
var last_modified = file.lastModifiedDate;"
"function startsOnFriday(month, year)
{
 
 return new Date(year, month, 1).getDay() === 5;
}
function has31Days(month, year)
{
 return new Date(year, month, 31).getDate() === 31;
}
function checkMonths(year)
{
 var month, count = 0;
 for (month = 0; month < 12; month += 1)
 {
  if (startsOnFriday(month, year) && has31Days(month, year))
  {
   count += 1;
   document.write(year + ' ' + month + '<br>');
  }
 }
 return count;
}
function fiveWeekends()
{
 var
  startYear = 1900,
  endYear = 2100,
  year,
  monthTotal = 0,
  yearsWithoutFiveWeekends = [],
  total = 0;
 for (year = startYear; year <= endYear; year += 1)
 {
  monthTotal = checkMonths(year);
  total += monthTotal;
  
  if (monthTotal === 0)
   yearsWithoutFiveWeekends.push(year);
 }
 document.write('Total number of months: ' + total + '<br>');
 document.write('<br>');
 document.write(yearsWithoutFiveWeekends + '<br>');
 document.write('Years with no five-weekend months: ' + yearsWithoutFiveWeekends.length + '<br>');
}
fiveWeekends();var Months = [
  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
  'Jul', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'
];
 
var leap = 0,
  
  offset = [3,0,3,2,3,2,3,3,2,3,2,3],
 
  
  longMonths = [1,3,5,7,8,10,12],
 
  startYear = 1900,
  year = startYear,
  endYear = 2100,
 
  
  day = 1,
 
  totalPerYear = 0,
  total = 0,
  without = 0;
 
for (; year < endYear + 1; year++) {
  leap = totalPerYear = 0;
 
  if (year % 4 === 0) {
    if (year % 100 === 0) {
      if (year % 400 === 0) {
        leap = 1;
      }
    } else {
      leap = 1;
    }
  }
 
  for (var i = 0; i < offset.length; i++) {
    for (var j = 0; day === 5 && j < longMonths.length; j++) {
      if (i + 1 === longMonths[j]) {
        console.log(year + '-' + Months[i]);
        totalPerYear++;
        total++;
        break;
      }
    }
 
    
    if (i == 1) {
      day = (day + leap) % 7; 
    } else {
      day = (day + offset[i]) % 7;
    }
  }
 
  if (totalPerYear === 0) {
    without++;
  }
}
 
console.log('Number of months that have five full weekends from 1900 to 2100: ' + total);
console.log('Number of years without any five full weekend months: ' + without);(function () {
    'use strict';
 
 
    
    function longMonthsStartingFriday(y) {
        return [0, 2, 4, 6, 7, 9, 11]
            .filter(function (m) {
                return (new Date(Date.UTC(y, m, 1)))
                    .getDay() === 5;
            });
    }
 
 
    
    function range(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (x, i) {
                return m + i;
            });
    }
 
    var lstNames = [
            'January', '', 'March', '', 'May', '',
            'July', 'August', '', 'October', '', 'December'
        ],
 
        lstYears = range(1900, 2100),
 
        lstFullMonths = lstYears
        .reduce(function (a, y) {
            var strYear = y.toString();
 
            return a.concat(
                longMonthsStartingFriday(y)
                .map(function (m) {
                    return strYear + ' ' + lstNames[m];
                })
            );
        }, []),
 
        lstLeanYears = lstYears
        .filter(function (y) {
            return longMonthsStartingFriday(y)
                .length === 0;
        });
 
    return JSON.stringify({
            number: lstFullMonths.length,
            firstFive: lstFullMonths.slice(0, 5),
            lastFive: lstFullMonths.slice(-5),
            leanYearCount: lstLeanYears.length
        },
        null, 2
    );
 
})();"
" 


function pFibowFractal(n,len,canvasId,color) {
  
  var canvas = document.getElementById(canvasId);
  var ctx = canvas.getContext(strv); 
  var w = canvas.width; var h = canvas.height;
  var fwv,fwe,fn,tx,x=10,y=10,dx=len,dy=0,nr;
  
  ctx.fillStyle=strv; ctx.fillRect(0,0,w,h);
  ctx.beginPath();
  ctx.moveTo(x,y);
  fwv=fibword(n); fn=fwv.length;
  
  for(var i=0; i<fn; i++) {
    ctx.lineTo(x+dx,y+dy); fwe=fwv[i]; 
    if(fwe==strv) {tx=dx; nr=i%2;
      if(nr==0) {dx=-dy;dy=tx} else {dx=dy;dy=-tx}};
    x+=dx; y+=dy;
  }//fend i
  ctx.strokeStyle = color; ctx.stroke();
}//func end

function fibword(n) {
  var f1=strv,f2=strv,fw,fwn,n2,i;
  if (n<5) {n=5}; n2=n+2;
  for (i=0; i<n2; i++) {fw=f2+f1;f1=f2;f2=fw};
  return(fw)
}
 "
"//makes outputting a table possible in environments 
//that don't support console.table() 
function console_table(xs) {
    function pad(n,s) {
        var res = s;
        for (var i = s.length; i < n; i++)
            res += strv;
        return res;
    }
 
    if (xs.length === 0)
        console.log(strv);
    else {
        var widths = [];
        var cells = [];
        for (var i = 0; i <= xs.length; i++)
            cells.push([]);
 
        for (var s in xs[0]) {
            var len = s.length;
            cells[0].push(s);
 
            for (var i = 0; i < xs.length; i++) {
                var ss = strv + xs[i][s];
                len = Math.max(len, ss.length);
                cells[i+1].push(ss);
            }
            widths.push(len);
        }
        var s = strv;
        for (var x = 0; x < cells.length; x++) {
            for (var y = 0; y < widths.length; y++)
                s += strv + pad(widths[y], cells[x][y]);
            s += ""|"";
        }
        console.log(s);
    }
}
 
//returns the entropy of a string as a number 
function entropy(s) {
     //create an object containing each individual char
	//and the amount of iterations per char 
    function prob(s) {
        var h = Object.create(null);
        s.split('').forEach(function(c) {
           h[c] && h[c]++ || (h[c] = 1); 
        });
        return h;
    }
 
    s = s.toString(); //just in case 
    var e = 0, l = s.length, h = prob(s);
 
    for (var i in h ) {
        var p = h[i]/l;
        e -= p * Math.log(p) / Math.log(2);
    }
    return e;
}
 
//creates Fibonacci Word to n as described on Rosetta Code
//see rosettacode.org/wiki/Fibonacci_word
function fibWord(n) {
    var wOne = strv, wTwo = strv, wNth = [wOne, wTwo], w = strv, o = [];
 
    for (var i = 0; i < n; i++) {
        if (i === 0 || i === 1) {
            w = wNth[i];
        } else {
            w = wNth[i - 1] + wNth[i - 2];
            wNth.push(w);
        }
        var l = w.length;
        var e = entropy(w);
 
        if (l <= 21) {
        	o.push({
            	N: i + 1,
            	Length: l,
            	Entropy: e,
            	Word: w
        	});
        } else {
        	o.push({
            	N: i + 1,
            	Length: l,
            	Entropy: e,
            	Word: strv
        	});
        }            
    }
 
    try {
    	console.table(o);
    } catch (err) {
    	console_table(o);
    }
}
 
fibWord(37);"
"var fso = new ActiveXObject(strv);
var ForReading = 1, ForWriting = 2;
var f_in = fso.OpenTextFile('input.txt', ForReading);
var f_out = fso.OpenTextFile('output.txt', ForWriting, true);
 


 
while ( ! f_in.AtEndOfStream) {
    
    f_out.WriteLine( f_in.ReadLine() );
}
 
f_in.Close();
f_out.Close(); 
var fs = require('fs');
require('util').pump(fs.createReadStream('input.txt', {flags:'r'}), fs.createWriteStream('output.txt', {flags:'w+'}));
 "
"function fib(arity, len) {
    return nacci(nacci([1,1], arity, arity), arity, len);
}
 
function lucas(arity, len) {
    return nacci(nacci([2,1], arity, arity), arity, len);
}
 
function nacci(a, arity, len) {
    while (a.length < len) {
        var sum = 0;
        for (var i = Math.max(0, a.length - arity); i < a.length; i++)
            sum += a[i];
        a.push(sum);
    }
    return a;
}
 
function main() {
    for (var arity = 2; arity <= 10; arity++)
        console.log(strv + arity + strv + fib(arity, 15));
    for (var arity = 2; arity <= 10; arity++)
        console.log(strv + arity + strv + lucas(arity, 15));
}
 
main();"
"/*complex fast fourier transform and inverse fromhttp://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B*/
function icfft(amplitudes)
{
	var N = amplitudes.length;
	var iN = 1 / N;
 
	//conjugate if imaginary part is not 0
	for(var i = 0 ; i < N; ++i)
		if(amplitudes[i] instanceof Complex)
			amplitudes[i].im = -amplitudes[i].im;
 
	//apply fourier transform
	amplitudes = cfft(amplitudes)
 
	for(var i = 0 ; i < N; ++i)
	{
		//conjugate again
		amplitudes[i].im = -amplitudes[i].im;
		//scale
		amplitudes[i].re *= iN;
		amplitudes[i].im *= iN;
	}
	return amplitudes;
}
 
function cfft(amplitudes)
{
	var N = amplitudes.length;
	if( N <= 1 )
		return amplitudes;
 
	var hN = N / 2;
	var even = [];
	var odd = [];
	even.length = hN;
	odd.length = hN;
	for(var i = 0; i < hN; ++i)
	{
		even[i] = amplitudes[i*2];
		odd[i] = amplitudes[i*2+1];
	}
	even = cfft(even);
	odd = cfft(odd);
 
	var a = -2*Math.PI;
	for(var k = 0; k < hN; ++k)
	{
		if(!(even[k] instanceof Complex))
			even[k] = new Complex(even[k], 0);
		if(!(odd[k] instanceof Complex))
			odd[k] = new Complex(odd[k], 0);
		var p = k/N;
		var t = new Complex(0, a * p);
		t.cexp(t).mul(odd[k], t);
		amplitudes[k] = even[k].add(t, odd[k]);
		amplitudes[k + hN] = even[k].sub(t, even[k]);
	}
	return amplitudes;
}
 
//test code
//console.log( cfft([1,1,1,1,0,0,0,0]) );
//console.log( icfft(cfft([1,1,1,1,0,0,0,0])) );/*basic complex number arithmetic from http://rosettacode.org/wiki/Fast_Fourier_transform#Scala*/
function Complex(re, im) 
{
	this.re = re;
	this.im = im || 0.0;
}
Complex.prototype.add = function(other, dst)
{
	dst.re = this.re + other.re;
	dst.im = this.im + other.im;
	return dst;
}
Complex.prototype.sub = function(other, dst)
{
	dst.re = this.re - other.re;
	dst.im = this.im - other.im;
	return dst;
}
Complex.prototype.mul = function(other, dst)
{
	//cache re in case dst === this
	var r = this.re * other.re - this.im * other.im;
	dst.im = this.re * other.im + this.im * other.re;
	dst.re = r;
	return dst;
}
Complex.prototype.cexp = function(dst)
{
	var er = Math.exp(this.re);
	dst.re = er * Math.cos(this.im);
	dst.im = er * Math.sin(this.im);
	return dst;
}
Complex.prototype.log = function()
{
	/*	although 'It's just a matter of separating out the real and imaginary parts of jw.' is not a helpful quote	the actual formula I found here and the rest was just fiddling / testing and comparing with correct results.	http://cboard.cprogramming.com/c-programming/89116-how-implement-complex-exponential-functions-c.html#post637921	*/
	if( !this.re )
		console.log(this.im.toString()+'j');
	else if( this.im < 0 )
		console.log(this.re.toString()+this.im.toString()+'j');
	else
		console.log(this.re.toString()+'+'+this.im.toString()+'j');
}"
"function factors(num)
{
 var
  n_factors = [],
  i;
 
 for (i = 1; i <= Math.floor(Math.sqrt(num)); i += 1)
  if (num % i === 0)
  {
   n_factors.push(i);
   if (num / i !== i)
    n_factors.push(num / i);
  }
 n_factors.sort(function(a, b){return a - b;});  
 return n_factors;
}
 
factors(45);  
factors(53);  
factors(64);  
function chain(xs, f) {
  return [].concat.apply([], xs.map(f));
}
 

function range(m, n) {
  return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
    return m + i;
  });
}
 
function factors_naive(n) {
  return chain( range(1, n), function (x) {       
    return n % x ? [] : [x];                      
  });
}
 
factors_naive(6)[1, 2, 3, 6]console.log(
  (function (lstTest) {
 
    
    function integerFactors(n) {
      var rRoot = Math.sqrt(n),
        intRoot = Math.floor(rRoot),
 
        lows = range(1, intRoot).filter(function (x) {
          return (n % x) === 0;
        });
 
      
      return lows.concat(lows.map(function (x) {
        return n / x;
      }).reverse().slice((rRoot === intRoot) | 0));
    }
 
    
    function range(m, n) {
      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
        return m + i;
      });
    }
 
    /*************************** TESTING *****************************/
 
    
    function alignedTable(lstRows, lngPad, fnAligned) {
      var lstColWidths = range(0, lstRows.reduce(function (a, x) {
        return x.length > a ? x.length : a;
      }, 0) - 1).map(function (iCol) {
        return lstRows.reduce(function (a, lst) {
          var w = lst[iCol] ? lst[iCol].toString().length : 0;
          return (w > a) ? w : a;
        }, 0);
      });
 
      return lstRows.map(function (lstRow) {
        return lstRow.map(function (v, i) {
          return fnAligned(v, lstColWidths[i] + lngPad);
        }).join('')
      }).join('');
    }
 
    function alignRight(n, lngWidth) {
      var s = n.toString();
      return Array(lngWidth - s.length + 1).join(' ') + s;
    }
 
    
    return 'integerFactors(n)' + alignedTable(
      lstTest.map(integerFactors).map(function (x, i) {
        return [lstTest[i], '-->'].concat(x);
      }), 2, alignRight
    ) + '';
 
  })([25, 45, 53, 64, 100, 102, 120, 12345, 32766, 32767])
);integerFactors(n)
 
     25  -->  1   5  25
     45  -->  1   3   5    9   15    45
     53  -->  1  53
     64  -->  1   2   4    8   16    32    64
    100  -->  1   2   4    5   10    20    25     50  100
    102  -->  1   2   3    6   17    34    51    102
    120  -->  1   2   3    4    5     6     8     10   12   15   20   24    30     40     60    120
  12345  -->  1   3   5   15  823  2469  4115  12345
  32766  -->  1   2   3    6   43    86   127    129  254  258  381  762  5461  10922  16383  32766
  32767  -->  1   7  31  151  217  1057  4681  32767
 (function (lstTest) {
    'use strict';
 
    
 
    
    let integerFactors = (n) => {
            let rRoot = Math.sqrt(n),
                intRoot = Math.floor(rRoot),
 
                lows = range(1, intRoot)
                .filter(x => (n % x) === 0);
 
            
            
            return lows.concat(lows
                .map(x => n / x)
                .reverse()
                .slice((rRoot === intRoot) | 0)
            );
        },
 
        
        range = (m, n) => Array.from({
            length: (n - m) + 1
        }, (_, i) => m + i);
 
 
 
 
 
    /*************************** TESTING *****************************/
 
    
    let alignedTable = (lstRows, lngPad, fnAligned) => {
            var lstColWidths = range(
                    0, lstRows
                    .reduce(
                        (a, x) => (x.length > a ? x.length : a),
                        0
                    ) - 1
                )
                .map((iCol) => lstRows
                    .reduce((a, lst) => {
                        let w = lst[iCol] ? lst[iCol].toString()
                            .length : 0;
                        return (w > a) ? w : a;
                    }, 0));
 
            return lstRows.map((lstRow) =>
                    lstRow.map((v, i) => fnAligned(
                        v, lstColWidths[i] + lngPad
                    ))
                    .join('')
                )
                .join('');
        },
 
        alignRight = (n, lngWidth) => {
            let s = n.toString();
            return Array(lngWidth - s.length + 1)
                .join(' ') + s;
        };
 
    
    return 'integerFactors(n)' + alignedTable(lstTest
        .map(integerFactors)
        .map(
            (x, i) => [lstTest[i], '-->'].concat(x)
        ), 2, alignRight
    ) + '';
 
})([25, 45, 53, 64, 100, 102, 120, 12345, 32766, 32767]);"
"
static function hq9plus(code:String):String {
	var out:String = strv;
	var acc:Int = 0;
	for (position in 0 ... code.length) switch (code.charAt(position)) {
		case strv, strv: out += ""Hello, World!"";
		case strv, strv: out += '$code';
		case strv:
			var quantity:Int = 99;
			while (quantity > 1) {
				out += '$quantity bottles of beer on the wall, $quantity bottles of beer.';
				out += 'Take one down and pass it around, ${--quantity} bottles of beer.';
			}
			out += ""1 bottle of beer on the wall, 1 bottle of beer."" +
				""Take one down and pass it around, no more bottles of beer on the wall."" +
				""No more bottles of beer on the wall, no more bottles of beer."" +
				""Go to the store and buy some more, 99 bottles of beer on the wall."";
		case strv: acc++;
	}
	return out;
}function hq9plus(code) {
  var out = '';
  var acc = 0;
 
  for (var i=0; i<code.length; i++) {
    switch (code.charAt(i)) {
      case 'H': out += ""hello, world""; break;
      case 'Q': out += code + """"; break;
      case '9':
        for (var j=99; j>1; j--) {
          out += j + strv + j + "" bottles of beer."";
          out += strv + (j-1) + "" bottles of beer."";
        }
        out += ""1 bottle of beer on the wall, 1 bottle of beer."" +
            ""Take one down and pass it around, no more bottles of beer on the wall."" +
            ""No more bottles of beer on the wall, no more bottles of beer."" +
            ""Go to the store and buy some more, 99 bottles of beer on the wall."";
        break;
      case '+': acc++; break;
    }
  }
  return out;
}"
"var shell = new ActiveXObject(strv);
shell.run(strv);runCommand(strv, strv, strv, ""d:"");
print(strv);
var options = {
    
    args: [strv, strv, ""d:""],
    
    output: ''
};
runCommand(strv, options);
print(options.output);"
"fac = (n) ->
  [1..n].reduce (x,y) -> x*yfunction factorial(n) {
  //check our edge case
  if (n < 0) { throw strv; }
 
  var sum = 1;
  //we skip zero and one since both are 1 and are identity
  while (n > 1) {
    sum *= n;
    n -= 1;
  }
  return sum;
}(function(x) {
 
  var memo = {};
 
  function factorial(n) {
    return n < 2 ? 1 : memo[n] || (memo[n] = n * factorial(n - 1));
  }
 
  return factorial(x);
 
})(18);6402373705728000(function () {
    'use strict';
 
    
    function factorial(x) {
 
        return range(1, x)
            .reduce(function (a, b) {
                return a * b;
            }, 1);
    }
 
 
 
    
    function range(m, n) {
        var a = Array(n - m + 1),
            i = n + 1;
 
        while (i-- > m) a[i - m] = i;
        return a;
    }
 
 
    return factorial(18);
 
})();6402373705728000var factorial = n => (n < 2) ? 1 : n * factorial(n - 1);(function (n) {
    'use strict';
 
    
    let factorial = (n) => range(1, n).reduce(product, 1);
 
 
    
    let product = (a, b) => a * b,
 
        
        range = (m, n) =>
            Array.from({
                length: (n - m) + 1
            }, (_, i) => m + i)
 
 
    return factorial(n);
 
})(18);"
"function U() {}
U.prototype.toString = function(){return this.className;}
 
function U0() { 
    this.className = arguments.callee.name; 
}
U0.prototype = new U();
 
function U1() {
    this.className = arguments.callee.name; 
}
U1.prototype = new U();
 
function foo() {
    for (var i = 1; i <= 2; i++) {
        try {
            bar();
        }
        catch(e if e instanceof U0) {
            print(strv + e);
        }
    }
}
 
function bar() {
    baz();
}
 
function baz() {
    
    baz = function() {throw(new U1());}
    throw(new U0());
}
 
foo();"
"function fib(n) {
  return function(n,a,b) {
    return n>0 ? arguments.callee(n-1,b,a+b) : a;
  }(n,0,1);
}function fib(n) {
  var a = 0, b = 1, t;
  while (n-- > 0) {
    t = a;
    a = b;
    b += t;
    console.log(a);
  }
  return a;
}var fib = (function(cache){
    return cache = cache || {}, function(n){
        if (cache[n]) return cache[n];
        else return cache[n] = n == 0 ? 0 : n < 0 ? -fib(-n)
            : n <= 2 ? 1 : fib(n-2) + fib(n-1);
    };
})();
 (function () {
    'use strict';
 
    function fib(n) {
        return Array.apply(null, Array(n + 1))
            .map(function (_, i, lst) {
                return lst[i] = (
                    i ? i < 2 ? 1 :
                    lst[i - 2] + lst[i - 1] :
                    0
                );
            })[n];
    }
 
    return fib(32);
 
})();function Y(dn) {
    return (function(fn) {
        return fn(fn);
    }(function(fn) {
        return dn(function() {
            return fn(fn).apply(null, arguments);
        });
    }));
}
var fib = Y(function(fn) {
    return function(n) {
        if (n === 0 || n === 1) {
            return n;
        }
        return fn(n - 1) + fn(n - 2);
    };
});function* fibonacciGenerator() {
    var prev = 0;
    var curr = 1;
    while (true) {
        yield curr;
        curr = curr + prev;
        prev = curr - prev;
    }
}
var fib = fibonacciGenerator();(() => {
    'use strict';
 
    
 
    
    function fib(n) {
        return mapAccumL(([a, b]) => [
            [b, a + b], b
        ], [0, 1], range(1, n))[0][0];
    };
 
    
 
    
    let mapAccumL = (f, acc, xs) => {
        return xs.reduce((a, x) => {
            let pair = f(a[0], x);
 
            return [pair[0], a[1].concat(pair[1])];
        }, [acc, []]);
    }
 
    
    let range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
    
    return fib(32);
 
    
})();(() => {
    'use strict';
 
    
    let fib = n => range(1, n)
        .reduce(([a, b]) => [b, a + b], [0, 1])[0];
 
 
    
 
    
    let range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
    
    return fib(32);
 
    
})();42.fibonacci
() Integer
  [
  if this < 2 [this] else [[this - 1].fibonacci + [this - 2].fibonacci]
  ]
(Integer n) Integer
  [
  if n < 2 [n] else [fibonacci(n - 1) + fibonacci(n - 2)]
  ]
() Integer
  [
  if this < 2
    [this]
  else
    [
    !prev: 1
    !next: 1
    2.to_pre this
      [
      !sum :  prev + next
      prev := next
      next := sum
      ]
 
    next
    ]    
  ]

() Integer
  [
  if this < 2
    [this]
  else
    [
    !prev: 1
    !next: 1
    !sum
    !count: this - 2
    loop
      [
      if count = 0 [exit]
      count--
      sum  : prev + next
      prev : next
      next : sum
      ]
 
    next
    ]    
  ]"
"YUI().use('event-custom', function(Y) {
    
    Y.on('my:event', function () {
        alert(strv);
    });
    
    setTimeout(function () {
        Y.fire('my:event');
    }, 1000);
});YUI().use('node-event-simulate', function(Y) {
    
    Y.one(strv).on(strv, function (e) {
        alert(strv);
    });
    
    setTimeout(function () {
        Y.one(strv).simulate(strv);
    }, 1000);
});"
"function mersenne_factor(p){
  var limit, k, q
  limit = Math.sqrt(Math.pow(2,p) - 1)
  k = 1
  while ((2*k*p - 1) < limit){
    q = 2*k*p + 1
    if (isPrime(q) && (q % 8 == 1 || q % 8 == 7) && trial_factor(2,p,q)){
      return q 
    }
    k++
  }
  return null
}
 
function isPrime(value){
  for (var i=2; i < value; i++){
    if (value % i == 0){
      return false
    }
    if (value % i != 0){
      return true;
	 }
  }
}
 
function trial_factor(base, exp, mod){
  var square, bits
  square = 1
  bits = exp.toString(2).split('')
  for (var i=0,ln=bits.length; i<ln; i++){
    square = Math.pow(square, 2) * (bits[i] == 1 ? base : 1) % mod
  }
  return (square == 1)
}
 
function check_mersenne(p){
  var f, result
  console.log(strv+p+strv+p+strv)
  f = mersenne_factor(p)
  console.log(f == null ? strv : strv+f)
}"
"function doStuff() {
  throw new Error('Not implemented!');
}try {
  element.attachEvent('onclick', doStuff);
}
catch(e if e instanceof TypeError) {
  element.addEventListener('click', doStuff, false);
}
finally {
  eventSetup = true;
}"
"function binom(n, k) {
    var coeff = 1;
    for (var i = n-k+1; i <= n; i++) coeff *= i;
    for (var i = 1;     i <= k; i++) coeff /= i;
    return coeff;
}
print(binom(5,3));"
"var eulers_sum_of_powers = function (iMaxN) {
 
    var aPow5 = [];
    var oPow5ToN = {};
 
    for (var iP = 0; iP <= iMaxN; iP++) {
        var iPow5 = Math.pow(iP, 5);
        aPow5.push(iPow5);
        oPow5ToN[iPow5] = iP;
    }
 
    for (var i0 = 1; i0 <= iMaxN; i0++) {
        for (var i1 = 1; i1 <= i0; i1++) {
            for (var i2 = 1; i2 <= i1; i2++) {
                for (var i3 = 1; i3 <= i2; i3++) {
                    var iPow5Sum = aPow5[i0] + aPow5[i1] + aPow5[i2] + aPow5[i3];
                    if (typeof oPow5ToN[iPow5Sum] != 'undefined') {
                        return {
                            i0: i0,
                            i1: i1,
                            i2: i2,
                            i3: i3,
                            iSum: oPow5ToN[iPow5Sum]
                        };
                    }
                }
            }
        }
    }
 
};
 
var oResult = eulers_sum_of_powers(250);
 
console.log(oResult.i0 + '^5 + ' + oResult.i1 + '^5 + ' + oResult.i2 +
    '^5 + ' + oResult.i3 + '^5 = ' + oResult.iSum + '^5');var N=1000, first=false
var ns={}, npv=[]
for (var n=0; n<=N; n++) {
	var np=Math.pow(n,5); ns[np]=n; npv.push(np)
}
loop:
for (var a=1;   a<=N; a+=1) 
for (var b=a+1; b<=N; b+=1)
for (var c=b+1; c<=N; c+=1)
for (var d=c+1; d<=N; d+=1) {
	var x = ns[ npv[a]+npv[b]+npv[c]+npv[d] ]
	if (!x) continue
	print( [a, b, c, d, x] )
	if (first) break loop
}
function print(c) {
	var e='<sup>5</sup>', ep=e+' + '
	document.write(c[0], ep, c[1], ep, c[2], ep, c[3], e, ' = ', c[4], e, '<br>')
}var N=1000, first=false
var npv=[], M=30 
for (var n=0; n<=N; n+=1) npv[n]=Math.pow(n, 5)
var mx=1+npv[N]; while(n<=N+M) npv[n++]=mx
 
loop:
for (var a=1;   a<=N; a+=1)
for (var b=a+1; b<=N; b+=1)
for (var c=b+1; c<=N; c+=1)
for (var t=npv[a]+npv[b]+npv[c], d=c+1, x=t%M+d; (n=t+npv[d])<mx; d+=1, x+=1) {
	while (npv[x]<=n) x+=M; x-=M 
	if (npv[x] != n) continue
	print( [a, b, c, d, x] )
	if (first) break loop;
}
function print(c) {
	var e='<sup>5</sup>', ep=e+' + '
	document.write(c[0], ep, c[1], ep, c[2], ep, c[3], e, ' = ', c[4], e, '<br>')
}var N=1000, first=false
var dxs={}, pow=Math.pow 
for (var d=1; d<=N; d+=1)
	for (var dp=pow(d,5), x=d+1; x<=N; x+=1)
		dxs[pow(x,5)-dp]=[d,x]
loop:
for (var a=1; a<N; a+=1)
for (var ap=pow(a,5), b=a+1; b<N; b+=1) 
for (var abp=ap+pow(b,5), c=b+1; c<N; c+=1) {
	var dx = dxs[ abp+pow(c,5) ]
	if (!dx || c >= dx[0]) continue
	print( [a, b, c].concat( dx ) )  
	if (first) break loop
}
function print(c) {
	var e='<sup>5</sup>', ep=e+' + '
	document.write(c[0], ep, c[1], ep, c[2], ep, c[3], e, ' = ', c[4], e, '<br>')
}var N=1000, first=false
var is={}, ipv=[], ijs={}, ijpv=[], pow=Math.pow
for (var i=1; i<=N; i+=1) {
	var ip=pow(i,5); is[ip]=i; ipv.push(ip)
	for (var j=i+1; j<=N; j+=1) {
		var ijp=ip+pow(j,5); ijs[ijp]=[i,j]; ijpv.push(ijp)
	} 
}
ijpv.sort( function (a,b) {return a - b } )
loop:
for (var i=0, ei=ipv.length; i<ei; i+=1)
for (var xp=ipv[i], j=0, je=ijpv.length; j<je; j+=1) {
	var cdp = ijpv[j]
	if (cdp >= xp) break
	var cd = ijs[xp-cdp]
	if (!cd) continue
	var ab = ijs[cdp]
	if (ab[1] >= cd[0]) continue
	print( [].concat(ab, cd, is[xp]) )
	if (first) break loop
}
function print(c) {
	var e='<sup>5</sup>', ep=e+' + '
	document.write(c[0], ep, c[1], ep, c[2], ep, c[3], e, ' = ', c[4], e, '<br>')
}(() => {
    'use strict';
 
    const eulersSumOfPowers = intMax => {
        const
            pow = Math.pow,
            xs = range(0, intMax)
            .map(x => pow(x, 5)),
            dct = xs.reduce((a, x, i) =>
                (a[x] = i,
                    a
                ), {});
 
        for (let a = 1; a <= intMax; a++) {
            for (let b = 2; b <= a; b++) {
                for (let c = 3; c <= b; c++) {
                    for (let d = 4; d <= c; d++) {
                        const sumOfPower = dct[xs[a] + xs[b] + xs[c] + xs[d]];
                        if (sumOfPower !== undefined) {
                            return [a, b, c, d, sumOfPower];
                        }
                    }
                }
            }
        }
        return undefined;
    };
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const soln = eulersSumOfPowers(250);
    return soln ? soln.slice(0, 4)
        .map(x => `${x}^5`)
        .join(' + ') + ` = ${soln[4]}^5` : 'No solution found.'
 
})();"
"function isEven( i ) {
  return (i & 1) === 0;
}
 function isEven( i ) {
  return i % 2 === 0;
}
 

function isEven( i ) {
  return !(i % 2);
}
const isEven = x => !(x % 2)(() => {
    'use strict';
 
    
    const even = x => (x % 2) === 0;
 
    
    const odd = x => !even(x);
 
 
    
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const show = JSON.stringify;
 
    
    const xs = range(-6, 6);
 
    return show([xs.filter(even), xs.filter(odd)]);
})();"
" 


function eulersMethod(f, x1, y1, x2, h) {
	
	console.log(""X|Y"");
	console.log(strv);
 
	
	var x=x1, y=y1;
 
	
	
	while ((x<x2 && x1<x2) || (x>x2 && x1>x2)) {
		
		console.log("""" + x + ""|"" + y);
 
		
		y += h*f(x, y)
		x += h;
	}
 
	return y;
}
 
function cooling(x, y) {
	return -0.07 * (y-20);
}
 
eulersMethod(cooling, 0, 100, 100, 10);
 "
"var shell = new ActiveXObject(strv);
var env = shell.Environment(strv);
WScript.echo('SYSTEMROOT=' + env.item('SYSTEMROOT'));"
"
 
/* Compatibility code to reduce an array * Source: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Reduce */
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function (fun /*, initialValue */ ) {
        strv;
 
        if (this === void 0 || this === null) throw new TypeError();
 
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== strv) throw new TypeError();
 
        
        if (len == 0 && arguments.length == 1) throw new TypeError();
 
        var k = 0;
        var accumulator;
        if (arguments.length >= 2) {
            accumulator = arguments[1];
        } else {
            do {
                if (k in t) {
                    accumulator = t[k++];
                    break;
                }
 
                
                if (++k >= len) throw new TypeError();
            }
            while (true);
        }
 
        while (k < len) {
            if (k in t) accumulator = fun.call(undefined, accumulator, t[k], k, t);
            k++;
        }
 
        return accumulator;
    };
}
 
/* Compatibility code to map an array * Source: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map */
if (!Array.prototype.map) {
    Array.prototype.map = function (fun /*, thisp */ ) {
        strv;
 
        if (this === void 0 || this === null) throw new TypeError();
 
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== strv) throw new TypeError();
 
        var res = new Array(len);
        var thisp = arguments[1];
        for (var i = 0; i < len; i++) {
            if (i in t) res[i] = fun.call(thisp, t[i], i, t);
        }
 
        return res;
    };
}
 
/* ------------------------------------- Generator ------------------------------------- * Generates a fixed length gene sequence via a gene strategy object. * The gene strategy object must have two functions: *	- strv: returns create a new gene  *	- strv: returns mutation of an existing gene   */
function Generator(length, mutationRate, geneStrategy) {
    this.size = length;
    this.mutationRate = mutationRate;
    this.geneStrategy = geneStrategy;
}
 
Generator.prototype.spawn = function () {
    var genes = [],
        x;
    for (x = 0; x < this.size; x += 1) {
        genes.push(this.geneStrategy.create());
    }
    return genes;
};
 
Generator.prototype.mutate = function (parent) {
    return parent.map(function (char) {
        if (Math.random() > this.mutationRate) {
            return char;
        }
        return this.geneStrategy.mutate(char);
    }, this);
};
 
/* ------------------------------------- Population ------------------------------------- * Helper class that holds and spawns a new population. */
function Population(size, generator) {
    this.size = size;
    this.generator = generator;
 
    this.population = [];
    
    for (var x = 0; x < this.size; x += 1) {
        this.population.push(this.generator.spawn());
    }
}
 
Population.prototype.spawn = function (parent) {
    this.population = [];
    for (var x = 0; x < this.size; x += 1) {
        this.population.push(this.generator.mutate(parent));
    }
};
 
/* ------------------------------------- Evolver ------------------------------------- * Attempts to converge a population based a fitness strategy object. * The fitness strategy object must have three function   *	- strv: returns a score for an individual. *	- strv: return true if scoreA is better (ie more fit) then scoreB *	- strv: return true if score is acceptable (ie we have successfully converged).  */
function Evolver(size, generator, fitness) {
    this.done = false;
    this.fitness = fitness;
    this.population = new Population(size, generator);
}
 
Evolver.prototype.getFittest = function () {
    return this.population.population.reduce(function (best, individual) {
        var currentScore = this.fitness.score(individual);
        if (best === null || this.fitness.compare(currentScore, best.score)) {
            return {
                score: currentScore,
                individual: individual
            };
        } else {
            return best;
        }
    }, null);
};
 
Evolver.prototype.doGeneration = function () {
    this.fittest = this.getFittest();
    this.done = this.fitness.done(this.fittest.score);
    if (!this.done) {
        this.population.spawn(this.fittest.individual);
    }
};
 
Evolver.prototype.run = function (onCheckpoint, checkPointFrequency) {
    checkPointFrequency = checkPointFrequency || 10; 
    var generation = 0;
    while (!this.done) {
        this.doGeneration();
        if (generation % checkPointFrequency === 0) {
            onCheckpoint(generation, this.fittest);
        }
        generation += 1;
    }
    onCheckpoint(generation, this.fittest);
    return this.fittest;
};
 

window.Generator = Generator;
window.Evolver = Evolver;
 
 

Array.prototype.zip = function (b, func) {
    var result = [],
        max = Math.max(this.length, b.length),
        x;
    for (x = 0; x < max; x += 1) {
        result.push(func(this[x], b[x]));
    }
    return result;
};
 
var target = strv, geneStrategy, fitness, target, generator, evolver, result;
 
geneStrategy = {
    
    characterSet: strv.split(strv),
 
    /*        Pick a random character from the characterSet    */
    create: function getRandomGene() {
        var randomNumber = Math.floor(Math.random() * this.characterSet.length);
        return this.characterSet[randomNumber];
    }
};
geneStrategy.mutate = geneStrategy.create; 
fitness = {
    
    target: target.split(strv),
    equal: function (geneA, geneB) {
        return (geneA === geneB ? 0 : 1);
    },
    sum: function (runningTotal, value) {
        return runningTotal + value;
    },
 
    /*        We give one point to for each corect letter    */
    score: function (genes) {
        var diff = genes.zip(this.target, this.equal); 
        return diff.reduce(this.sum, 0); 
    },
    compare: function (scoreA, scoreB) {
        return scoreA <= scoreB; 
    },
    done: function (score) {
        return score === 0; 
    }
};
 
generator = new Generator(target.length, 0.05, geneStrategy);
evolver = new Evolver(100, generator, fitness);
 
function showProgress(generation, fittest) {
    document.write(strv + generation + strv + fittest.individual.join(strv) + strv + fittest.score + strv);
}
result = evolver.run(showProgress);"
" 

 
var f = strv;
 
if(f == strv){
    f = strv;
}
 "
"function equilibrium(a) {
  var N = a.length, i, l = [], r = [], e = []
  for (l[0] = a[0], r[N - 1] = a[N - 1], i = 1; i<N; i++)
    l[i] = l[i - 1] + a[i], r[N - i - 1] = r[N - i] + a[N - i - 1]
  for (i = 0; i < N; i++)
    if (l[i] === r[i]) e.push(i)
  return e
}
 

[ [-7, 1, 5, 2, -4, 3, 0], 
  [2, 4, 6], 
  [2, 9, 2], 
  [1, -1, 1, -1, 1, -1, 1], 
  [1], 
  [] 
].forEach(function(x) {
  console.log(equilibrium(x))
});(() => {
    'use strict';
 
    
    const equilibriumIndices = xs =>
        foldr((a, [x, y], i) =>
            x === y ? [i].concat(a) : a, [],
            zip(
                scanl1(plus, xs), 
                scanr1(plus, xs)  
            )
        );
 
 
    
 
    
    const scanl1 = (f, xs) =>
        xs.length > 0 ? scanl(f, xs[0], xs.slice(1)) : [];
 
    
    const scanr1 = (f, xs) =>
        xs.length > 0 ? scanr(f, xs.slice(-1)[0], xs.slice(0, -1)) : [];
 
    
    const scanl = (f, startValue, xs) =>
        xs.reduce((a, x) => {
            const v = f(a.acc, x);
            return {
                acc: v,
                scan: a.scan.concat(v)
            };
        }, {
            acc: startValue,
            scan: [startValue]
        })
        .scan;
 
    
    const scanr = (f, startValue, xs) =>
        xs.reduceRight((a, x) => {
            const v = f(a.acc, x);
            return {
                acc: v,
                scan: [v].concat(a.scan)
            };
        }, {
            acc: startValue,
            scan: [startValue]
        })
        .scan;
 
    
    const zip = (xs, ys) =>
        xs.slice(0, Math.min(xs.length, ys.length))
        .map((x, i) => [x, ys[i]]);
 
    
    const foldr = (f, a, xs) => xs.reduceRight(f, a);
 
    
    const tail = xs => xs.length ? xs.slice(1) : undefined;
 
    
    const plus = (a, b) => a + b;
 
 
    
    return [
        [-7, 1, 5, 2, -4, 3, 0],
        [2, 4, 6],
        [2, 9, 2],
        [1, -1, 1, -1, 1, -1, 1],
        [1],
        []
    ].map(equilibriumIndices);
 
    
})();[[3,6],[],[1],[0,1,2,3,4,5,6],[0],[]]"
"const pi = 3.1415;
const msg = strv;"
"var eth = {
 
	halve : function ( n ){  return Math.floor(n/2);  },
	double: function ( n ){  return 2*n;              },
	isEven: function ( n ){  return n%2 === 0);       },
 
	mult: function ( a , b ){
		var sum = 0, a = [a], b = [b];
 
		while ( a[0] !== 1 ){
			a.unshift( eth.halve( a[0] ) );
			b.unshift( eth.double( b[0] ) );
		}
 
		for( var i = a.length - 1; i > 0 ; i -= 1 ){
 
			if( !eth.isEven( a[i] ) ){
				sum += b[i];
			}
		}		
		return sum + b[0];
	}
}
function ethMult(m, n) {
  var o = !isNaN(m) ? 0 : ''; 
  if (n < 1) return o;
  while (n > 1) {
    if (n & 1) o += m;  
    n >>= 1;            
    m += m;             
  }
  return o + m;
}
 
ethMult(17, 34)ethMult('Ethiopian', 34)"
"(function(shannon) {
  
  function process(s, evaluator) {
    var h = Object.create(null), k;
    s.split('').forEach(function(c) {
      h[c] && h[c]++ || (h[c] = 1); });
    if (evaluator) for (k in h) evaluator(k, h[k]);
    return h;
  };
  
  shannon.entropy = function(s) {
    var sum = 0,len = s.length;
    process(s, function(k, f) {
      var p = f/len;
      sum -= p * Math.log(p) / Math.log(2);
    });
    return sum;
  };
})(window.shannon = window.shannon || {});
 

function logEntropy(s) {
  console.log('Entropy of ""' + s + '"" in bits per symbol:', shannon.entropy(s));
}
 
logEntropy('1223334444');
logEntropy('0');
logEntropy('01');
logEntropy('0123');
logEntropy('01234567');
logEntropy('0123456789abcdef');"
"var s = strv;
var s = new String();s == strv
s.length == 0
!s
!Boolean(s)!!s
s != strv
s.length != 0
s.length > 0
Boolean(s)"
"var net = require('net');
 
var server = net.createServer(function(conn) {
  console.log(strv + conn.remoteAddress + strv + conn.remotePort);
  conn.setEncoding(strv);
  var buffer = strv;
 
  conn.on(strv, function(data) {
    for(var i = 0; i <= data.length; i++) {
      var char = data.charAt(i);
      buffer += char;
      if(char == """") {
        conn.write(buffer);
        buffer = strv;
      }
    }
  });
});
 
server.listen(12321, strv);"
"var varname = 'foo';  
var value = 42;
eval('var ' + varname + '=' + value);var varname = prompt('Variable name:');
var value = 42;
this[varname] = value;"
"DoublyLinkedList.prototype.getTail = function() {
    var tail;
    this.traverse(function(node){tail = node;});
    return tail;
} 
DoublyLinkedList.prototype.traverseBackward = function(func) {
    func(this);
    if (this.prev() != null)
        this.prev().traverseBackward(func);
}
DoublyLinkedList.prototype.printBackward = function() {
    this.traverseBackward( function(node) {print(node.value())} );
}
 
var head = createDoublyLinkedListFromArray([10,20,30,40]);
head.print();
head.getTail().printBackward();"
"DoublyLinkedList.prototype.insertAfter = function(searchValue, nodeToInsert) {
    if (this._value == searchValue) {
        var after = this.next();
        this.next(nodeToInsert);
        nodeToInsert.prev(this);
        nodeToInsert.next(after);
        after.prev(nodeToInsert);
    }
    else if (this.next() == null) 
        throw new Error(0, strv + searchValue + strv)
    else
        this.next().insertAfter(searchValue, nodeToInsert);
}
 
var list = createDoublyLinkedListFromArray(['A','B']);
list.insertAfter('A', new DoublyLinkedList('C', null, null));"
"var sec_old = 0;
function update_clock() {
	var t = new Date();
	var arms = [t.getHours(), t.getMinutes(), t.getSeconds()];
	if (arms[2] == sec_old) return;
	sec_old = arms[2];
 
	var c = document.getElementById('clock');
	var ctx = c.getContext('2d');
	ctx.fillStyle = strv;
	ctx.fillRect(0, 0, c.width, c.height);
	ctx.fillStyle = strv;
	ctx.fillRect(3, 3, c.width - 6, c.height - 6);
	ctx.lineCap = 'round';
 
	var orig = { x: c.width / 2, y: c.height / 2 };
	arms[1] += arms[2] / 60;
	arms[0] += arms[1] / 60;
	draw_arm(ctx, orig, arms[0] * 30, c.width/2.5 - 15, c.width / 20,  strv);
	draw_arm(ctx, orig, arms[1] * 6,  c.width/2.2 - 10, c.width / 30,  strv);
	draw_arm(ctx, orig, arms[2] * 6,  c.width/2.0 - 6,  c.width / 100, strv);
}
 
function draw_arm(ctx, orig, deg, len, w, style)
{
	ctx.save();
	ctx.lineWidth = w;
	ctx.lineCap = 'round';
	ctx.translate(orig.x, orig.y);
	ctx.rotate((deg - 90) * Math.PI / 180);
	ctx.strokeStyle = style;
	ctx.beginPath();
	ctx.moveTo(-len / 10, 0);
	ctx.lineTo(len, 0);
	ctx.stroke();
	ctx.restore();
}
 
function init_clock() {
	var clock = document.createElement('canvas');
	clock.width = 100;
	clock.height = 100;
	clock.id = strv;
	document.body.appendChild(clock);
 
	window.setInterval(update_clock, 200);
}"
"<!DOCTYPE html>
<html>
<head>
<meta charset=strv>
<title>Draw a sphere</title>
<script>
var light=[30,30,-50],gR,gk,gambient;
 
function normalize(v){
	var len=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
	v[0]/=len;
	v[1]/=len;
	v[2]/=len;
	return v;
}
 
function dot(x,y){
	var d=x[0]*y[0]+x[1]*y[1]+x[2]*y[2];
	return d<0?-d:0;
}
 
function draw_sphere(R,k,ambient){
	var i,j,intensity,b,vec,x,y,cvs,ctx,imgdata,idx;
	cvs=document.getElementById(strv);
	ctx=cvs.getContext(strv);
	cvs.width=cvs.height=2*Math.ceil(R)+1;
	imgdata=ctx.createImageData(2*Math.ceil(R)+1,2*Math.ceil(R)+1);
	idx=0;
	for(i=Math.floor(-R);i<=Math.ceil(R);i++){
		x=i+.5;
		for(j=Math.floor(-R);j<=Math.ceil(R);j++){
			y=j+.5;
			if(x*x+y*y<=R*R){
				vec=[x,y,Math.sqrt(R*R-x*x-y*y)];
				vec=normalize(vec);
				b=Math.pow(dot(light,vec),k)+ambient;
				intensity=(1-b)*256;
				if(intensity<0)intensity=0;
				if(intensity>=256)intensity=255;
				imgdata.data[idx++]=imgdata.data[idx++]=255-~~(intensity); //RG
				imgdata.data[idx++]=imgdata.data[idx++]=255; //BA
			} else {
				imgdata.data[idx++]=imgdata.data[idx++]=imgdata.data[idx++]=imgdata.data[idx++]=255; //RGBA
			}
		}
	}
	ctx.putImageData(imgdata,0,0);
}
 
light=normalize(light);
</script>
</head>
<body onload=strv>
R=<input type=strv id=strv name=strv min=strv max=strv value=strv step=strv onchange=strv>
<label for=strv id=strv>200</label><br>
k=<input type=strv id=strv name=strv min=strv max=strv value=strv step=strv onchange=strv>
<label for=strv id=strv>4</label><br>
ambient=<input type=strv id=strv name=strv min=strv max=strv value=strv step=strv onchange=strv>
<label for=strv id=strv>0.2</label><br>
<canvas id=strv>Unsupportive browser...</canvas><br>
</body>
</html>"
"function DoublyLinkedList(value, next, prev) {
    this._value = value;
    this._next = next;
    this._prev = prev;
}

DoublyLinkedList.prototype = new LinkedList();
 
DoublyLinkedList.prototype.prev = function() {
    if (arguments.length == 1) 
        this._prev = arguments[0];
    else
        return this._prev;
}
 
function createDoublyLinkedListFromArray(ary) {
    var node, prev, head = new DoublyLinkedList(ary[0], null, null);
    prev = head;
    for (var i = 1; i < ary.length; i++) {
        node = new DoublyLinkedList(ary[i], null, prev);
        prev.next(node);
        prev = node;
    }
    return head;
}
 
var head = createDoublyLinkedListFromArray([10,20,30,40]);"
"var DRAGON = (function () {
   
   
 
   var matrix = {
      mult: function ( m, v ) {
         return [ m[0][0] * v[0] + m[0][1] * v[1],
                  m[1][0] * v[0] + m[1][1] * v[1] ];
      },
 
      minus: function ( a, b ) {
         return [ a[0]-b[0], a[1]-b[1] ];
      },
 
      plus: function ( a, b ) {
         return [ a[0]+b[0], a[1]+b[1] ];
      }
   };
 
 
   
   
 
   
   var toSVGpath = function (a, b) {  
      return strv + a[0] + strv + a[1] + strv + b[0] + strv + b[1];
   };
 
 
   
   
 
   
   var fractalMakeDragon = function (svgid, ptA, ptC, state, lr, interval) {
 
      
      var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute( strv,  strv); 
      path.setAttribute( strv, toSVGpath(ptA, ptC) );
 
      
      var svg = document.getElementById(svgid); 
      svg.appendChild(path);
 
      
      if (state > 1) {
 
         
         var growNewPoint = function (ptA, ptC, lr) {
            var left  = [[ 1/2,-1/2 ], 
                         [ 1/2, 1/2 ]]; 
 
            var right = [[ 1/2, 1/2 ],
                         [-1/2, 1/2 ]];
 
            return matrix.plus(ptA, matrix.mult( lr ? left : right, 
                                                 matrix.minus(ptC, ptA) ));
         }; 
 
         var ptB = growNewPoint(ptA, ptC, lr, state);
 
         
         var recurse = function () {
            
            svg.removeChild(path);
 
            
            fractalMakeDragon(svgid, ptB, ptA, state-1, lr, interval);
            fractalMakeDragon(svgid, ptB, ptC, state-1, lr, interval);
         };
 
         window.setTimeout(recurse, interval);
      }
   };
 
 
   
   
   return {
      fractal: fractalMakeDragon
 
      
      
      
      
      
      
      
 
      
      
      
      
      
   };
 
}());"
"'use strict';
 
function sum(array) {
    return array.reduce(function (a, b) {
        return a + b;
    });
}
 
function square(x) {
    return x * x;
}
 
function mean(array) {
    return sum(array) / array.length;
}
 
function averageSquareDiff(a, predictions) {
    return mean(predictions.map(function (x) {
        return square(x - a);
    }));
}
 
function diversityTheorem(truth, predictions) {
    var average = mean(predictions);
    return {
        'average-error': averageSquareDiff(truth, predictions),
        'crowd-error': square(truth - average),
        'diversity': averageSquareDiff(average, predictions)
    };
}
 
console.log(diversityTheorem(49, [48,47,51]))
console.log(diversityTheorem(49, [48,47,51,42]))
 (() => {
    'use strict';
 
    
    const mean = xs => {
        const lng = xs.length;
 
        return lng > 0 ? (
            xs.reduce((a, b) => a + b, 0) / lng
        ) : undefined;
    }
 
    
    const meanErrorSquared = (observed, predictions) =>
        mean(predictions.map(x => Math.pow(x - observed, 2)));
 
 
    
    
    const diversityValues = (observed, predictions) => {
        const predictionMean = mean(predictions);
 
        return {
            'mean-error': meanErrorSquared(observed, predictions),
            'crowd-error': Math.pow(observed - predictionMean, 2),
            'diversity': meanErrorSquared(predictionMean, predictions)
        };
    }
 
 
    
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    return show([{
        observed: 49,
        predictions: [48, 47, 51]
    }, {
        observed: 49,
        predictions: [48, 47, 51, 42]
    }].map(x => {
        const dctData = diversityValues(x.observed, x.predictions),
            dct = {};
 
        return (
            Object.keys(dctData)
            .forEach(k => dct[k] = dctData[k].toPrecision(3)),
            dct
        );
    }));
})();"
"var net = require('net')
 
var server = net.createServer(function (c){
  c.write('hello')
  c.pipe(c) 
})
 
server.listen(3000, 'localhost')
 var net = require('net')
 
conn = net.createConnection(3000, '192.168.1.x')
 
conn.on('connect', function(){
	console.log('connected')
	conn.write('test')
})
 
conn.on('data', function(msg){
	console.log(msg.toString())
})"
"function dot_product(ary1, ary2) {
    if (ary1.length != ary2.length)
        throw strv;
    var dotprod = 0;
    for (var i = 0; i < ary1.length; i++)
        dotprod += ary1[i] * ary2[i];
    return dotprod;
}
 
print(dot_product([1,3,-5],[4,-2,-1])); 
print(dot_product([1,3,-5],[4,-2,-1,0])); function dotp(x,y) {
    function dotp_sum(a,b) { return a + b; }
    function dotp_times(a,i) { return x[i] * y[i]; }
    if (x.length != y.length)
        throw strv;
    return x.map(dotp_times).reduce(dotp_sum,0);
}
 
dotp([1,3,-5],[4,-2,-1]); 
dotp([1,3,-5],[4,-2,-1,0]); (() => {
    'use strict';
 
    
    const dotProduct = (xs, ys) => {
        const sum = xs => xs ? xs.reduce((a, b) => a + b, 0) : undefined;
 
        return xs.length === ys.length ? (
            sum(zipWith((a, b) => a * b, xs, ys))
        ) : undefined;
    }
 
    
    const zipWith = (f, xs, ys) => {
        const ny = ys.length;
        return (xs.length <= ny ? xs : xs.slice(0, ny))
            .map((x, i) => f(x, ys[i]));
    }
 
    return dotProduct([1, 3, -5], [4, -2, -1]);
})();3"
"/// Digital root of 'x' in base 'b'.
/// @return {addpers, digrt}
function digitalRootBase(x,b) {
   if (x < b)
      return {addpers:0, digrt:x};
 
   var fauxroot = 0;
   while (b <= x) {
      x = (x / b) | 0;
      fauxroot += x % b;
   }
 
   var rootobj = digitalRootBase(fauxroot,b);
   rootobj.addpers += 1;
   return rootobj;
}"
"var fso = new ActiveXObject(strv);
 
fso.DeleteFile('input.txt');
fso.DeleteFile('c:/input.txt');
 
fso.DeleteFolder('docs');
fso.DeleteFolder('c:/docs');var fso = new ActiveXObject(strv);
var f;
f = fso.GetFile('input.txt');
f.Delete();
f = fso.GetFile('c:/input.txt');
f.Delete();
f = fso.GetFolder('docs');
f.Delete();
f = fso.GetFolder('c:/docs');
f.Delete();const fs = require('fs');
fs.unlinkSync('myfile.txt');const fs = require('fs');
fs.unlink('myfile.txt', ()=>{
  console.log(strv);
})"
"(() => {
    'use strict';
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const and = xs => {
        let i = xs.length;
        while (i--)
            if (!xs[i]) return false;
        return true;
    }
 
    
    const nubBy = (p, xs) => {
        const x = xs.length ? xs[0] : undefined;
        return x !== undefined ? [x].concat(
            nubBy(p, xs.slice(1)
                .filter(y => !p(x, y)))
        ) : [];
    }
 
    
 
    const floors = range(1, 5);
 
    return  concatMap(b =>
            concatMap(c =>
            concatMap(f =>
            concatMap(m =>
            concatMap(s =>
                and([ 
                    nubBy((a, b) => a === b, [b, c, f, m, s]) 
                    .length === 5,
                    b !== 5, c !== 1, f !== 1, f !== 5,
                    m > c, Math.abs(s - f) > 1, Math.abs(c - f) > 1
                ]) ? [{
                    Baker: b,
                    Cooper: c,
                    Fletcher: f,
                    Miller: m,
                    Smith: s
                }] : [],
                floors), floors), floors), floors), floors);
 
    
})();[{strv:3, strv:2, strv:4, strv:5, strv:1}](() => {
    'use strict';
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const and = xs => {
        let i = xs.length;
        while (i--)
            if (!xs[i]) return false;
        return true;
    }
 
    
    const permutations = xs =>
        xs.length ? concatMap(x => concatMap(ys => [
                [x].concat(ys)
            ],
            permutations(delete_(x, xs))), xs) : [
            []
        ];
 
    
    const delete_ = (x, xs) =>
        deleteBy((a, b) => a === b, x, xs);
 
    
    const deleteBy = (f, x, xs) =>
        xs.reduce((a, y) => f(x, y) ? a : a.concat(y), []);
 
    
 
    const floors = range(1, 5);
 
    return concatMap(([c, b, f, m, s]) =>
        and([ 
            b !== 5, c !== 1, f !== 1, f !== 5,
            m > c, Math.abs(s - f) > 1, Math.abs(c - f) > 1
        ]) ? [{
            Baker: b,
            Cooper: c,
            Fletcher: f,
            Miller: m,
            Smith: s
        }] : [], permutations(floors));
 
    
})();
 [{strv:3, strv:2, strv:4, strv:5, strv:1}]"
"function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
var value = strv; 
if (isNumeric(value)) {
  
}
//Or, in web browser in address field:

 "
" 
/** * All Hail Discordia! - this script prints Discordian date using system date. * * lang: JavaScript * author: jklu * contributors: JamesMcGuigan * * changelog: * - Modified to return same output syntax as unix ddate + module.exports - James McGuigan, 2/Chaos/3183 * * source: https://rosettacode.org/wiki/Discordian_date#JavaScript */
var seasons = [
  strv, strv, strv,
  strv, strv
];
var weekday = [
  strv, strv, strv,
  strv, strv
];
 
var apostle = [
  strv, strv, strv,
  strv, strv
];
 
var holiday = [
  strv, strv, strv,
  strv, strv
];
 
 
Date.prototype.isLeapYear = function() {
  var year = this.getFullYear();
  if( (year & 3) !== 0 ) { return false; }
  return ((year % 100) !== 0 || (year % 400) === 0);
};
 

Date.prototype.getDOY = function() {
  var dayCount  = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var mn        = this.getMonth();
  var dn        = this.getDate();
  var dayOfYear = dayCount[mn] + dn;
  if( mn > 1 && this.isLeapYear() ) { dayOfYear++; }
  return dayOfYear;
};
 
Date.prototype.isToday = function() {
  var today = new Date();
  return this.getDate()     === today.getDate()
      && this.getMonth()    === today.getMonth()
      && this.getFullYear() === today.getFullYear()
  ;
};
 
function discordianDate(date) {
  if( !date ) { date = new Date(); }
 
  var y                = date.getFullYear();
  var yold             = y + 1166;
  var dayOfYear        = date.getDOY();
  var celebrateHoliday = null;
 
  if( date.isLeapYear() ) {
    if( dayOfYear == 60 ) {
      celebrateHoliday = strv;
    }
    else if( dayOfYear > 60 ) {
      dayOfYear--;
    }
  }
  dayOfYear--;
 
  var divDay = Math.floor(dayOfYear / 73);
 
  var seasonDay = (dayOfYear % 73) + 1;
  if( seasonDay == 5 ) {
    celebrateHoliday = apostle[divDay];
  }
  if( seasonDay == 50 ) {
    celebrateHoliday = holiday[divDay];
  }
 
  var season    = seasons[divDay];
  var dayOfWeek = weekday[dayOfYear % 5];
 
  var nth = (seasonDay % 10 == 1) ? 'st'
          : (seasonDay % 10 == 2) ? 'nd'
          : (seasonDay % 10 == 3) ? 'rd'
                                  : 'th';
 
  return strv //(date.isToday() ? strv : '')
         + dayOfWeek
         + strv + seasonDay + nth
         + strv + season
         + strv + yold
         + (celebrateHoliday ? strv + celebrateHoliday + strv : '')
    ;
}
 
function test(y, m, d, result) {
  console.assert((discordianDate(new Date(y, m, d)) == result), [y, m, d, discordianDate(new Date(y, m, d)), result]);
}
 

if( require.main === module ) {
  console.log(discordianDate(new Date(Date.now())));
  test(2010, 6, 22, strv);
  test(2012, 1, 28, strv);
  test(2012, 1, 29, strv);
  test(2012, 2,  1, strv);
  test(2010, 0,  5, strv);
  test(2011, 4,  3, strv);
  test(2015, 9, 19, strv);
}
 
module.exports = discordianDate;
  
console.log(discordianDate(new Date(Date.now())));
strv
 "
" 
var deepcopy = function(o){
  return JSON.parse(JSON.stringify(src));
};
 
var src = {foo:0,bar:[0,1]};
print(JSON.stringify(src));
var dst = deepcopy(src);
print(JSON.stringify(src));
  
var deepcopy = function(o){
  return eval(uneval(o));
};
var src = {foo:0,bar:[0,1]};
src['baz'] = src;
print(uneval(src));
var dst = deepcopy(src);
print(uneval(src));
 "
"function divByZero(dividend,divisor)
{
	var quotient=dividend/divisor;
        if(isNaN(quotient)) return 0; //Can be changed to whatever is desired by the programmer to be 0, false, or Infinity
        return quotient; //Will return Infinity or -Infinity in cases of, for example, 5/0 or -7/0 respectively
}
alert(divByZero(0,0));"
"<html>
<head></head>
<body>
    <form id=strv></form>
    <br/>Possible solutions:
    <ul id=strv></ul>
</body>
<script src=strv></script>
<script type=strv>
    var questions = [
        { bools:[1,1,1,1,0,0,0,0], text:strv },
        { bools:[1,1,0,0,1,1,0,0], text:strv },
        { bools:[1,0,1,0,1,0,1,0], text:strv },
    ];
    var answers = [
        { bools:[0,0,1,0,0,0,0,0], text:strv },
        { bools:[1,0,1,0,0,0,0,0], text:strv },
        { bools:[1,0,1,0,1,0,1,0], text:strv },
        { bools:[1,1,0,0,1,1,0,0], text:strv },
        { bools:[0,1,0,1,0,0,0,0], text:strv },
    ]
 
    $(document).ready(function() {
        
        var value = questions[0].bools.length;
        for (var i = 0; i < questions.length; i++) {
            value /= 2;
            var el = '<br /><input type=strv' + value + '"">' + questions[i].text;
            $(strv).append(el);
        }
 
        
        $('input:checkbox').change(function() {
 
            
            var sum = 0;
            $('input:checkbox:checked').each(function () {
                sum += Number(this.value);
            });
 
            
            var index = questions[0].bools.length - sum - 1;
 
            
            $('#ul').html('');
 
            
            for (var i = 0; i < answers.length; i++) {
                if (answers[i].bools[index]) {
                    $('#ul').append('<li>' + answers[i].text + '</li>')
                }
            }
        });
    });
</script>
</html>"
"function Num(n){
    n = Math.floor(n);
    if(isNaN(n))
        throw new TypeError(strv);
    if(n < 1 || n > 10)
        throw new TypeError(strv);
    this._value = n;
}
Num.prototype.valueOf = function() { return this._value; }
Num.prototype.toString = function () { return this._value.toString();}
 
var w = new Num(3), x = new Num(4);
 
WScript.Echo(w + x); //7
WScript.Echo(x - w); //1
WScript.Echo(w * x); //12
WScript.Echo(w / x); //0.75
WScript.Echo(w < x); //true
WScript.Echo(x < w); //false
 
var y = new Num(0); //TypeError
var z = new Num(11); //TypeError
 "
"function Delegator() {
  this.delegate = null ;
  this.operation = function(){
    if(this.delegate && typeof(this.delegate.thing) == 'function')
      return this.delegate.thing() ;
    return 'default implementation' ;
  }
}
 
function Delegate() {
  this.thing = function(){
    return 'Delegate Implementation' ;
  }
}
 
function testDelegator(){
  var a = new Delegator() ;
  document.write(a.operation() + """") ;
 
  a.delegate = 'A delegate may be any object' ; 
  document.write(a.operation() + """") ;
 
  a.delegate = new Delegate() ;
  document.write(a.operation() + """") ;
}"
" 
<!DOCTYPE html>
<html>
<body style=strv>
  <canvas id=strv width=strv height=strv style=strv>
    Your browser does not support the HTML5 canvas tag.
  </canvas>
  <script>
    var c = document.getElementById(strv);
    var ctx = c.getContext(strv);
    //Fill the canvas with a dark gray background
    ctx.fillStyle = strv;
    ctx.fillRect(0,0,250,250);
 
    
    var grd = ctx.createRadialGradient(225,175,190,225,150,130);
    grd.addColorStop(0,strv);
    grd.addColorStop(1,strv);
    //Apply gradient and fill circle
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(125,125,105,0,2*Math.PI);
    ctx.fill();
 
    
    var grd = ctx.createLinearGradient(75,90,102,90);
    grd.addColorStop(0,strv);
    grd.addColorStop(1,strv);
    //Apply gradient and fill circle
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(90,90,30,0,2*Math.PI);
    ctx.fill();
 
    //Add another small circle on top of the previous one to enhance the strv
    ctx.fillStyle = strv;
    ctx.beginPath();
    ctx.arc(80,90,17,0,2*Math.PI);
    ctx.fill();
  </script> 
</body>
</html>
 
 "
"function nim() {
  var x=0, a=arguments, l=a.length, r=[];
  for (var j=0; j<l; j++) x^=a[j];
  for (var j=0; j<l; j++) r[j]= Math.max(0,a[j]-(x^a[j]));
  return r;
}function m(a){x=0
l=a.length
r=[]
for(j=0;j<l;j++)x^=a[j]
for(j=0;j<l;j++)r[j]=Math.max(0,a[j]-(x^a[j]))
return r}m([4,7,2,2,1])
[0, 2, 2, 2, 0]"
"strv;
/* * Microsoft C Run-time-Library-compatible Random Number Generator * Copyright by Shlomi Fish, 2011. * Released under the MIT/X11 License * ( http://en.wikipedia.org/wiki/MIT_License ). * */
/* This uses Joose 2.x-or-above, an object system for JavaScript - http://code.google.com/p/joose-js/ . */
 
Class('MSRand', {
    has: {
        seed: { is: rw, },
    },
    methods: {
        rand: function() {
            this.setSeed((this.getSeed() * 214013 + 2531011) & 0x7FFFFFFF);
            return ((this.getSeed() >> 16) & 0x7fff);
        },
        max_rand: function(mymax) {
            return this.rand() % mymax;
        },
        shuffle: function(deck) {
            if (deck.length) {
                var i = deck.length;
                while (--i) {
                    var j = this.max_rand(i+1);
                    var tmp = deck[i];
                    deck[i] = deck[j];
                    deck[j] = tmp;
                }
            }
            return deck;
        },
    },
});
 
/* * Microsoft Windows Freecell / Freecell Pro boards generation. * * See: * * - http://rosettacode.org/wiki/Deal_cards_for_FreeCell * * - http://www.solitairelaboratory.com/mshuffle.txt * * Under MIT/X11 Licence. * * */
 
function deal_ms_fc_board(seed) {
    var randomizer = new MSRand({ seed: seed });
    var num_cols = 8;
 
    var _perl_range = function(start, end) {
        var ret = [];
 
        for (var i = start; i <= end; i++) {
            ret.push(i);
        }
 
        return ret;
    };
 
    var columns = _perl_range(0, num_cols-1).map(function () { return []; });
    var deck = _perl_range(0, 4*13-1);
 
    randomizer.shuffle(deck);
 
    deck = deck.reverse()
 
    for (var i = 0; i < 52; i++) {
        columns[i % num_cols].push(deck[i]);
    }
 
    var render_card = function (card) {
        var suit = (card % 4);
        var rank = Math.floor(card / 4);
 
        return strv.charAt(rank) + strv.charAt(suit);
    }
 
    var render_column = function(col) {
        return strv + col.map(render_card).join(strv) + """";
    }
 
    return columns.map(render_column).join(strv);
}
 "
" function addN(n) {
    var curry = function(x) {
        return x + n;
    };
    return curry;
 }
 
 add2 = addN(2);
 alert(add2);
 alert(add2(7));(function () {
 
    
    function curry(f) {
        return function (a) {
            return function (b) {
                return f(a, b);
            };
        };
    }
 
 
    
 
    
    function product(a, b) {
        return a * b;
    }
 
    
    
 
    
    
 
    //return typeof curry(product)(7)(9)
    
 
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        .map(curry(product)(7))
 
    
 
})();
 [7, 14, 21, 28, 35, 42, 49, 56, 63, 70](function () {
 
    
    
    function extraCurry(f) {
 
        
        function _curry(xs) {
            return xs.length >= intArgs ? (
                f.apply(null, xs)
            ) : function () {
                return _curry(xs.concat([].slice.apply(arguments)));
            };
        }
 
        var intArgs = f.length;
 
        return _curry([].slice.call(arguments, 1));
    }
 
 
    
 
    
    function product3(a, b, c) {
        return a * b * c;
    }
 
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        .map(extraCurry(product3)(7)(2))
 
    
 
})();[14, 28, 42, 56, 70, 84, 98, 112, 126, 140](a,b) => expr_using_a_and_ba => b => expr_using_a_and_blet
  fix = 
    f => (f => f(f))(g => f((...a) => g(g)(...a))),
  curry =
    f => (
      fix(
        z => (n,...a) => (
          n>0
          ?b => z(n-1,...a,b)
          :f(...a)))
      (f.length)),
  curryrest =
    f => (
      fix(
        z => (n,...a) => (
          n>0
          ?b => z(n-1,...a,b)
          :(...b) => f(...a,...b)))
      (f.length)),
  curriedmax=curry(Math.max),
  curryrestedmax=curryrest(Math.max);
print(curriedmax(8)(4),curryrestedmax(8)(4)(),curryrestedmax(8)(4)(9,7,2));

 (() => {
 
    
    let curry = f => a => b => f(a, b);
 
 
    
 
    
    let product = (a, b) => a * b,
 
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        }
 
 
    return range(1, 10)
        .map(curry(product)(7))
 
    
 
})();[7, 14, 21, 28, 35, 42, 49, 56, 63, 70](() => {
 
    
    
    let extraCurry = (f, ...args) => {
        let intArgs = f.length;
 
        
        let _curry = (xs, ...arguments) =>
            xs.length >= intArgs ? (
                f.apply(null, xs)
            ) : function () {
                return _curry(xs.concat([].slice.apply(arguments)));
            };
 
        return _curry([].slice.call(args, 1));
    };
 
    
 
    
    let product3 = (a, b, c) => a * b * c;
 
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        .map(extraCurry(product3)(7)(2))
 
    
 
})();[14, 28, 42, 56, 70, 84, 98, 112, 126, 140]"
"function add12hours(dateString) {
 
  
  var parts = dateString.split(/\s+/),
      date  = parts[1],
      month = parts[0],
      year  = parts[2],
      time  = parts[3];
 
  var hr    = Number(time.split(':')[0]),
      min   = Number(time.split(':')[1].replace(/\D/g,'')),
      ampm  = time && time.match(/[a-z]+$/i)[0],
      zone  = parts[4].toUpperCase();
 
  var months = ['January','February','March','April','May','June',
                'July','August','September','October','November','December'];
  var zones  = {'EST': 300, 'AEST': -600}; 
 
  
  month = months.indexOf(month);
  if (month === -1) { return; }
 
  
  hr += (ampm.toLowerCase() === 'pm') ? 24 : 12
 
  
  var localTime = new Date(year, month, date);
  localTime.setHours(hr, min, 0, 0);
 
  
  
  localTime.setMinutes(localTime.getMinutes() + zones[zone] - localTime.getTimezoneOffset() );
  return localTime;
}
 
var inputDateString = 'March 7 2009 7:30pm EST';
 
console.log(
  'Input: ' + inputDateString + '' +
  '+12hrs in local time: ' + add12hours(inputDateString)
 );"
"for (var year = 2008; year <= 2121; year++){
    var xmas = new Date(year, 11, 25)
    if ( xmas.getDay() === 0 )
        console.log(year)
}(function () {
    'use strict';
 
    
    function isXmasSunday(year) {
        return (new Date(year, 11, 25))
            .getDay() === 0;
    }
 
    
    function range(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (_, i) {
                return m + i;
            });
    }
 
    return range(2008, 2121)
        .filter(isXmasSunday);
 
})();(() => {
    'use strict';
 
    
    const xmasIsSunday = year => (new Date(year, 11, 25))
            .getDay() === 0;
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
 
 
    return range(2008, 2121)
        .filter(xmasIsSunday);
 
})();[2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]"
"var now = new Date(),
    weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    months   = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    fmt1 = now.getFullYear() + '-' + (1 + now.getMonth()) + '-' + now.getDate(),
    fmt2 = weekdays[now.getDay()] + ', ' + months[now.getMonth()] + ' ' + now.getDate() + ', ' + now.getFullYear();
console.log(fmt1);
console.log(fmt2);"
"var keyError = new Error(strv) ;
 
function FixedKeyDict(obj)
{    
    var myDefault = new Object() ;
    var myData    = new Object() ;
    for(k in obj) {
        myDefault[k] = obj[k] ;
        myData[k]    = obj[k] ;
    }
 
    var gotKey = function(k) {
        for(kk in myDefault) {
            if(kk == k) return true ;
        }
        return false ;        
    } ;
 
    this.hasKey = gotKey ;
 
    var checkKey = function(k) {
        if(!gotKey(k))
            throw keyError ;
    } ;
 
    this.getItem = function(k) {
        checkKey(k) ;
        return myData[k];
    } ;
 
    this.setItem = function(k, v) {
        checkKey(k) ;
        myData[k] = v ;
    } ;
 
    this.resetItem = function(k) {
        checkKey(k) ;
        myData[k] = myDefault[k] ;      
    } ;
 
    this.delItem = this.resetItem ;
 
    this.clear   = function() {
        for(k in myDefault)
            myData[k] = myDefault[k] ;
    } ;
 
    this.iterator = function() {
        for(k in myDefault)
            yield (k);            
    } ;
 
    this.clone    = function() {
        return new FixedKeyDict(myDefault) ;
    }
 
    this.toStr = function() {
        var s = strv ;
        for(key in myData)
            s = s + key + strv + myData[key] + strv ;
        return strv + s + strv ;
    } ; 
} 
const BR = ""<BR>""
 
var pl = function(s) {
    document.write(s + BR) ;
} ;
 
pl(strv) ;
 
var o = { foo:101, bar:102 } ;
 
var h = new FixedKeyDict(o) ;
pl(strv) ;
pl(strv + h.toStr()) ;
pl(strv + h.getItem(strv)) ;
pl(strv + h.hasKey(strv)) ;
pl(strv + h.hasKey(strv)) ;
h.setItem(strv, 999) ;
pl(strv + h.toStr()) ;
pl(strv) ;
for(k in h.iterator())
    pl(strv + k + strv + h.getItem(k)) ;
var g = h.clone() ;
pl(strv) ;
pl(strv + g.toStr()) ;
pl(strv + h.toStr()) ;
h.clear() ;
pl(strv) ;
pl(strv + h.toStr()) ;
try {
    h.setItem(strv, 666 ) ;
} catch(e) {
    pl(strv + e.message) ;
}
 "
"function running_stddev() {
    var n = 0;
    var sum = 0.0;
    var sum_sq = 0.0;
    return function(num) {
        n++;
        sum += num;
        sum_sq += num*num;
        return Math.sqrt( (sum_sq / n) - Math.pow(sum / n, 2) );
    }
}
 
var sd = running_stddev();
var nums = [2,4,4,4,5,5,7,9];
var stddev = [];
for (var i in nums) 
    stddev.push( sd(nums[i]) );
 

WScript.Echo(stddev.join(', ');(function (xs) {
 
    return xs.reduce(function (a, x, i) {
        var n = i + 1,
            sum_ = a.sum + x,
            squaresSum_ = a.squaresSum + (x * x);
 
        return {
            sum: sum_,
            squaresSum: squaresSum_,
            stages: a.stages.concat(
                Math.sqrt((squaresSum_ / n) - Math.pow((sum_ / n), 2))
            )
        };
 
    }, {
        sum: 0,
        squaresSum: 0,
        stages: []
    }).stages
 
})([2, 4, 4, 4, 5, 5, 7, 9]);[0, 1, 0.9428090415820626, 0.8660254037844386, 
0.9797958971132716, 1, 1.3997084244475297, 2]"
"(function () {
    'use strict';
 
    
    function splitRegex(rgx, s) {
        return s.split(rgx);
    }
 
    
    function lines(s) {
        return s.split(/[\r\n]/);
    }
 
    
    function unlines(xs) {
        return xs.join('');
    }
 
    
    
    
 
    
    function readFile(strPath) {
        var error = $(),
            str = ObjC.unwrap(
                $.NSString.stringWithContentsOfFileEncodingError(
                    $(strPath)
                    .stringByStandardizingPath,
                    $.NSUTF8StringEncoding,
                    error
                )
            );
        return error.code ? error.localizedDescription : str;
    }
 
    
    
    
 
    
    function writeFile(strPath, strText) {
        $.NSString.alloc.initWithUTF8String(strText)
            .writeToFileAtomicallyEncodingError(
                $(strPath)
                .stringByStandardizingPath, false,
                $.NSUTF8StringEncoding, null
            );
    }
 
    
 
    var delimCSV = /,\s*/g;
 
    var strSummed = unlines(
        lines(readFile('~/csvSample.txt'))
        .map(function (x, i) {
            var xs = x ? splitRegex(delimCSV, x) : [];
 
            return (xs.length ? xs.concat(
                
                i > 0 ? xs.reduce(
                    function (a, b) {
                        return a + parseInt(b, 10);
                    }, 0
                ).toString() : 'SUM'
            ) : []).join(',');
        })
    );
 
    return (
        writeFile('~/csvSampleSummed.txt', strSummed),
        strSummed
    );
 
})();"
"var csv = ""Character,Speech"" +
	   ""The multitude,The messiah! Show us the messiah!"" +
	   ""Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>"" +
	   ""The multitude,Who are you?"" +
	   ""Brians mother,I'm his mother; that's who!"" +
	   strv;
 
var lines = csv.replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/""/g, '&quot;')
    .split(/[\n\r]/)
    .map(function(line) { return line.split(',')})
    .map(function(row) {return '<tr><td>' + row[0] + '</td><td>' + row[1] + '</td></tr>';});
 
console.log('<table><thead>'      + lines[0] +
            '</thead><tbody>' + lines.slice(1).join('') +
            '</tbody></table>');
 
 "
"var width = Number(prompt(strv));
var height = Number(prompt(strv));
 
//make 2D array
var arr = new Array(height);
 
for (var i = 0; i < h; i++) {
  arr[i] = new Array(width);
}
 
//set value of element
a[0][0] = 'foo';
//print value of element
console.log('arr[0][0] = ' + arr[0][0]);
 
//cleanup array
arr = void(0);"
"function countSubstring(str, subStr) {
    var matches = str.match(new RegExp(subStr, strv));
    return matches ? matches.length : 0;
}"
" 
var matrix = [
	[2, -1,  5,  1],
	[3,  2,  2, -6],
	[1,  3,  3, -1],
	[5, -2, -3,  3]
];
var freeTerms = [-3, -32, -47, 49];
 
var result = cramersRule(matrix,freeTerms);
console.log(result);
 
/** * Compute Cramer's Rule * @param  {array} matrix    x,y,z, etc. terms * @param  {array} freeTerms * @return {array}           solution for x,y,z, etc. */
function cramersRule(matrix,freeTerms) {
	var det = detr(matrix),
		returnArray = [],
		i,
		tmpMatrix;
 
	for(i=0; i < matrix[0].length; i++) {
		var tmpMatrix = insertInTerms(matrix, freeTerms,i)
		returnArray.push(detr(tmpMatrix)/det)
	}
	return returnArray;
}
 
/** * Inserts single dimensional array into * @param  {array} matrix multidimensional array to have ins inserted into * @param  {array} ins single dimensional array to be inserted vertically into matrix * @param  {array} at  zero based offset for ins to be inserted into matrix * @return {array}     New multidimensional array with ins replacing the at column in matrix */
function insertInTerms(matrix, ins, at) {
	var tmpMatrix = clone(matrix),
		i;
	for(i=0; i < matrix.length; i++) {
		tmpMatrix[i][at] = ins[i];
	}
	return tmpMatrix;
}
/** * Compute the determinate of a matrix.  No protection, assumes square matrix * function borrowed, and adapted from MIT Licensed numericjs library (www.numericjs.com) * @param  {array} m Input Matrix (multidimensional array) * @return {number}   result rounded to 2 decimal */
function detr(m) {
	var ret = 1,
		k,
		A=clone(m),
		n=m[0].length,
		alpha;
 
	for(var j =0; j < n-1; j++) {
		k=j;
		for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
		if(k !== j) {
		    temp = A[k]; A[k] = A[j]; A[j] = temp;
		    ret *= -1;
		}
		Aj = A[j];
		for(i=j+1;i<n;i++) {
			Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
	    }
    return Math.round(ret*A[j][j]*100)/100;
}
 
/** * Clone two dimensional Array using ECMAScript 5 map function and EcmaScript 3 slice * @param  {array} m Input matrix (multidimensional array) to clone * @return {array}   New matrix copy */
function clone(m) {
	return m.map(function(a){return a.slice();});
}
 
 "
"function countcoins(t, o) {
    'use strict';
    var targetsLength = t + 1;
    var operandsLength = o.length;
    t = [1];
 
    for (var a = 0; a < operandsLength; a++) {
        for (var b = 1; b < targetsLength; b++) {
 
            
            t[b] = t[b] ? t[b] : 0;
 
            
            t[b] += (b < o[a]) ? 0 : t[b - o[a]];
        }
    }
 
    return t[targetsLength - 1];
}countcoins(100, [1,5,10,25]);
242function countcoins(t, o) {
    'use strict';
    var operandsLength = o.length;
    var solutions = 0;
 
    function permutate(a, x) {
 
        
        if (a === t) {
            solutions++;
        }
 
        
        else if (a < t) {
            for (var i = 0; i < operandsLength; i++) {
                if (i >= x) {
                    permutate(o[i] + a, i);
                }
            }
        }
    }
 
    permutate(0, 0);
    return solutions;
}countcoins(100, [1,5,10,25]);
242var amount = 100,
    coin = [1, 5, 10, 25]
var t = [1];
for (t[amount] = 0, a = 1; a < amount; a++) t[a] = 0 
for (var i = 0, e = coin.length; i < e; i++)
    for (var ci = coin[i], a = ci; a <= amount; a++)
        t[a] += t[a - ci]
document.write(t[amount])"
"<html><head><title>Table maker</title><script type=strv>
 

Node.prototype.a = function (e) { this.appendChild(e); return this }
 
function ce(tag, txt) {
	var x = document.createElement(tag);
	x.textContent = (txt === undefined) ? '' : txt;
	return x;
}
 
function make_table(cols, rows) {
	var tbl = ce('table', ''), tr = ce('tr'), th;
 
	tbl.a(tr.a(ce('th')));
 
	var z = 'Z'.charCodeAt(0);
	for (var l = z - cols + 1; l <= z; l++)
		tr.a(ce('th', String.fromCharCode(l)));
 
	for (var r = 1; r <= rows; r++) {
		tbl.a(tr = ce('tr').a(ce('th', r)));
		for (var c = 0; c < cols; c++)
			tr.a(ce('td', Math.floor(Math.random() * 10000)));
	}
 
	document.body
		.a(ce('style',
			'td, th {border: 1px solid #696;' +
			'padding:.4ex} td {text-align: right }' +
			'table { border-collapse: collapse}'))
		.a(tbl);
}
</script></head>
<body><script>make_table(5, 4)</script></body></html>(function (lngCols, lngRows) {
 
  //range(5, 20) --> [5..20]
  //range('a', 'n') --> ['a'..'n']
  function range(m, n) {
    var blnAlpha = typeof m === 'string',
      iFirst = blnAlpha ? m.charCodeAt(0) : m,
      lstInt = Array.apply(
        null,
        Array((blnAlpha ? n.charCodeAt(0) : n) - iFirst + 1)
      ).map(function (x, i) {
        return iFirst + i;
      });
 
    return blnAlpha ? lstInt.map(
      function (x) {
        return String.fromCharCode(x);
      }
    ) : lstInt;
  }
 
  
  var strFirstCol = String.fromCharCode('Z'.charCodeAt(0) - (lngCols - 1));
 
  var lstData = [[''].concat(range(strFirstCol, 'Z'))].concat(
      range(1, lngRows).map(
        function (row) {
          return [row].concat(
            range(1, lngCols).map(
              function () {
                return Math.floor(
                  Math.random() * 9999
                );
              }
            )
          );
        }
      )
    );
 
  return [
    '<table>',
 
    '  <thead style = strv>',
    '    ' + lstData[0].reduce(
          function (a, s) {
            return a + '<th>' + s + '</th>';
          }, '<tr>'
        ) + '</tr>',
    '  </thead>',
 
    '  <tbody style = strv>',
      lstData.slice(1).map(
        function (row) {
          return '    ' + row.reduce(
            function (a, s) {
              return a + '<td>' + s + '</td>';
            }, '<tr>'
          ) + '</tr>';
        }
      ).join(''),
    '  </tbody>',
 
    '</table>'
  ].join('');
 
})(3, 4); 
 "
"for (var n = 0; n < 1e14; n++) { 
    document.writeln(n.toString(8)); 
}"
"for(i = 1; i <= 10; i++)
    console.log(i + strv + factor(i).join(strv));
 
function factor(n) {
    var factors = [];
    if (n == 1) return [1];
    for(p = 2; p <= n; ) {
	if((n % p) == 0) {
	    factors[factors.length] = p;
	    n /= p;
	}
	else p++;
    }
    return factors;
}"
"var container = {myString: strv};
var containerCopy = container; 
 
containerCopy.myString = strv; var a = strv;
var b = a; 
 
b = strv "
"(function () {
    'use strict';
 
    
    function angloDuration(intSeconds) {
        return zip(
                weekParts(intSeconds), 
                ['wk', 'd', 'hr', 'min','sec']
            )
            .reduce(function (a, x) {
                return a.concat(x[0] ? (
                    [(x[0].toString() + ' ' + x[1])]
                ) : []);
            }, [])
            .join(', ');
    }
 
 
 
    
    function weekParts(intSeconds) {
 
        return [undefined, 7, 24, 60, 60]
            .reduceRight(function (a, x) {
                var intRest = a.remaining,
                    intMod = isNaN(x) ? intRest : intRest % x;
 
                return {
                    remaining:(intRest - intMod) / (x || 1),
                    parts: [intMod].concat(a.parts)
                };
            }, {
                remaining: intSeconds,
                parts: []
            })
            .parts
    }
 
    
 
    
    function zip(xs, ys) {
        return xs.length === ys.length ? (
            xs.map(function (x, i) {
                return [x, ys[i]];
            })
        ) : undefined;
    }
 
    
 
    return [7259, 86400, 6000000]
        .map(function (intSeconds) {
            return intSeconds.toString() +
                '    ->    ' + angloDuration(intSeconds);
        })
        .join('');
 
})();
 ((localNames) => {
 
    
    const compoundDuration = (labels, intSeconds) =>
        weekParts(intSeconds)
        .map((v, i) => [v, labels[i]])
        .reduce((a, x) =>
            a.concat(x[0] ? [`${x[0]} ${x[1] || '?'}`] : []), []
        )
        .join(', '),
 
        
        weekParts = intSeconds => [0, 7, 24, 60, 60]
        .reduceRight((a, x) => {
            let r = a.rem,
                mod = x !== 0 ? r % x : r;
 
            return {
                rem: (r - mod) / (x || 1),
                parts: [mod].concat(a.parts)
            };
        }, {
            rem: intSeconds,
            parts: []
        })
        .parts;
 
 
    
    return [7259, 86400, 6E6]
        .map(intSeconds =>
            `${intSeconds} -> ${compoundDuration(localNames, intSeconds)}`
        )
        .join("""");
 
})([strv, strv, strv, strv, strv]);"
"self.addEventListener('message', function (event) {
  self.postMessage(event.data);
  self.close();
}, false);var words = [strv, strv, strv];
var workers = [];
 
for (var i = 0; i < words.length; i++) {
  workers[i] = new Worker(strv);
  workers[i].addEventListener('message', function (event) {
    console.log(event.data);
  }, false);
  workers[i].postMessage(words[i]);
}"
"<html><head><title>Circle</title></head>
<body>
<canvas id=strv width=strv height=strv></canvas>
<script type=strv>
 
var cv = document.getElementById('cv');
var ctx = cv.getContext('2d');
 
var w = cv.width;
var h = cv.height;
 
//draw circles
ctx.fillStyle = 'rgba(0, 255, 200, .3)';
ctx.strokeStyle = 'rgba(0,0,0,.1)';
ctx.beginPath();
ctx.arc(w/2, h/2, 150, 0, Math.PI*2, true); 
ctx.arc(w/2, h/2, 100, 0, Math.PI*2, false);
ctx.closePath();
ctx.fill();
 

ctx.beginPath();
for (var i = 10; i < w; i += 10) {
	ctx.moveTo(i, 0);
	ctx.lineTo(i, h);
	ctx.moveTo(0, i);
	ctx.lineTo(w, i);
}
ctx.closePath();
ctx.stroke();
 
//draw points
ctx.fillStyle = 'navy';
var pts = 0;
while (pts < 100) {
	var x = Math.floor(Math.random() * 31) - 15;
	var y = Math.floor(Math.random() * 31) - 15;
	var r = x * x + y * y;
	if (r < 100 || r > 225) continue;
	x = x * 10 + w/2;
	y = y * 10 + h/2;
	ctx.fillRect(x - 2, y - 2, 4, 4);
	pts++;
}
 
</script></body></html>"
"function allEqual(a) {
  var out = true, i = 0;
  while (++i<a.length) {
    out = out && (a[i-1] === a[i]);
  } return out;
}
 
function azSorted(a) {
  var out = true, i = 0;
  while (++i<a.length) {
    out = out && (a[i-1] < a[i]);
  } return out;
}
 
var e = ['AA', 'AA', 'AA', 'AA'], s = ['AA', 'ACB', 'BB', 'CC'], empty = [], single = ['AA'];
console.log(allEqual(e)); 
console.log(allEqual(s)); 
console.log(allEqual(empty)); 
console.log(allEqual(single)); 
console.log(azSorted(e)); 
console.log(azSorted(s)); 
console.log(azSorted(empty)); 
console.log(azSorted(single)); 
 (() => {
    'use strict';
 
    
    let allEqual = xs => and(zipWith(equal, xs, xs.slice(1))),
 
        
        azSorted = xs => and(zipWith(azBefore, xs, xs.slice(1))),
 
        
        equal = (a, b) => a === b,
 
        
        azBefore = (a, b) => a.toLowerCase() <= b.toLowerCase();
 
 
    
 
    
    let and = xs => xs.reduceRight((a, x) => a && x, true),
 
        
        zipWith = (f, xs, ys) => {
            let ny = ys.length;
            return (xs.length <= ny ? xs : xs.slice(0, ny))
                .map((x, i) => f(x, ys[i]));
        };
 
 
    
 
    let lists = [
        ['isiZulu', 'isiXhosa', 'isiNdebele', 'Xitsonga',
            'Tshivenda', 'Setswana', 'Sesotho sa Leboa', 'Sesotho',
            'English', 'Afrikaans'
        ],
        ['Afrikaans', 'English', 'isiNdebele', 'isiXhosa',
            'isiZulu', 'Sesotho', 'Sesotho sa Leboa', 'Setswana',
            'Tshivenda', 'Xitsonga',
        ],
        ['alpha', 'alpha', 'alpha', 'alpha', 'alpha', 'alpha',
            'alpha', 'alpha', 'alpha', 'alpha', 'alpha', 'alpha'
        ]
    ];
 
    return {
        allEqual: lists.map(allEqual),
        azSorted: lists.map(azSorted)
    };
 
})();{
  strv: [
    false,
    false,
    true
  ],
  strv: [
    false,
    true,
    true
  ]
}"
"//using object literal syntax
var point = {x : 1, y : 2};
 
//using constructor
var Point = function (x, y) {
  this.x = x;
  this.y = y;
};
point = new Point(1, 2);
 
//using ES6 class syntax
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}
point = new Point(1, 2);"
"if( s == strv ) {
    foo();
} else if( s == strv ) {
    bar();
} else {
    deusEx();
}switch(object) {
    case 1:
        one();
        break;
    case 2:
    case 3:
    case 4:
        twoThreeOrFour();
        break;
    case 5:
        five();
        break;
    default:
        everythingElse();
}var num = window.obj ? obj.getNumber() : null;function takeWhile(lst, fnTest) {
    'use strict';
    var varHead = lst.length ? lst[0] : null;
 
    return varHead ? (
        fnTest(varHead) ? [varHead].concat(
            takeWhile(lst.slice(1), fnTest)
        ) : []
    ) : [];
}"
"function GameOfLife () {
 
	this.init = function (turns,width,height) {
		this.board = new Array(height);
		for (var x = 0; x < height; x++) {
			this.board[x] = new Array(width);
			for (var y = 0; y < width; y++) {
				this.board[x][y] = Math.round(Math.random());
			}
		}
		this.turns = turns;
	}
 
	this.nextGen = function() {
		this.boardNext = new Array(this.board.length);
		for (var i = 0; i < this.board.length; i++) {
			this.boardNext[i] = new Array(this.board[i].length);
		}
		for (var x = 0; x < this.board.length; x++) {
			for (var y = 0; y < this.board[x].length; y++) {
				var n = 0;
				for (var dx = -1; dx <= 1; dx++) {
					for (var dy = -1; dy <= 1; dy++) {
						if ( dx == 0 && dy == 0){}
						else if (typeof this.board[x+dx] !== 'undefined'
								&& typeof this.board[x+dx][y+dy] !== 'undefined'
								&& this.board[x+dx][y+dy]) {
							n++;
						}
					}	
				}
				var c = this.board[x][y];
				switch (n) {
					case 0:
					case 1:
						c = 0;
						break;
					case 2:
						break; 
					case 3:
						c = 1;
						break;
					default:
						c = 0;
				}
				this.boardNext[x][y] = c;
			}
		}
		this.board = this.boardNext.slice();
	}
 
	this.print = function() {
		for (var x = 0; x < this.board.length; x++) {
			var l = strv;
			for (var y = 0; y < this.board[x].length; y++) {
				if (this.board[x][y])
					l += strv;
				else
					l += strv;
			}
			print(l);
		}
	}
 
	this.start = function() {
		for (var t = 0; t < this.turns; t++) {
			print(""---Turn ""+(t+1));
			this.print();
			this.nextGen()
		}
	}
 
}
 
 
var game = new GameOfLife();
 
print(""---3x3 Blinker over three turns."");
game.init(3);
game.board = [
	[0,0,0],
	[1,1,1],
	[0,0,0]];
game.start();
 
print(""---10x6 Glider over five turns."");
game.init(5);
game.board = [
	[0,0,0,0,0,0,0,0,0,0],
	[0,0,1,0,0,0,0,0,0,0],
	[0,0,0,1,0,0,0,0,0,0],
	[0,1,1,1,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0,0,0]];
game.start();
 
print(""---Random 5x10"");
game.init(5,5,10);
game.start(); 
<html> 
	<head> 
		<title></title> 
		<script type=strv> 
 
function GameOfLife () {
 
	this.init = function (turns,width,height) {
		this.board = new Array(height);
		for (var x = 0; x < height; x++) {
			this.board[x] = new Array(width);
			for (var y = 0; y < width; y++) {
				this.board[x][y] = Math.round(Math.random());
			}
		}
		this.turns = turns;
	}
 
	this.nextGen = function() {
		this.boardNext = new Array(this.board.length);
		for (var i = 0; i < this.board.length; i++) {
			this.boardNext[i] = new Array(this.board[i].length);
		}
		for (var x = 0; x < this.board.length; x++) {
			for (var y = 0; y < this.board[x].length; y++) {
				var n = 0;
				for (var dx = -1; dx <= 1; dx++) {
					for (var dy = -1; dy <= 1; dy++) {
						if ( dx == 0 && dy == 0){}
						else if (typeof this.board[x+dx] !== 'undefined'
								&& typeof this.board[x+dx][y+dy] !== 'undefined'
								&& this.board[x+dx][y+dy]) {
							n++;
						}
					}	
				}
				var c = this.board[x][y];
				switch (n) {
					case 0:
					case 1:
						c = 0;
						break;
					case 2:
						break; 
					case 3:
						c = 1;
						break;
					default:
						c = 0;
				}
				this.boardNext[x][y] = c;
			}
		}
		this.board = this.boardNext.slice();
	}
 
	this.print = function(ctx,w,h) {
		if (!w)
			w = 8;
		if (!h)
			h = 8;
		for (var x = 0; x < this.board.length; x++) {
			var l = strv;
			for (var y = 0; y < this.board[x].length; y++) {
				if (this.board[x][y])
				
				
					ctx.fillStyle = strv;
				else
					ctx.fillStyle = strv;
				ctx.fillRect(y*h,x*w,h,w);
			}
		}
	}
 
	this.start = function(ctx,w,h) {
		for (var t = 0; t < this.turns; t++) {
			this.print(ctx,w,h);
			this.nextGen()
		}
	}
 
}
 
function init() {
	
	document.title = strv;
 
	
	var blinker = new GameOfLife();
	blinker.board = [
		[0,1,0],
		[0,1,0],
		[0,1,0]];
 
	var glider = new GameOfLife();
	glider.board = [
		[0,0,0,0,0,0],
		[0,0,1,0,0,0],
		[0,0,0,1,0,0],
		[0,1,1,1,0,0],
		[0,0,0,0,0,0],
		[0,0,0,0,0,0]];
 
	var random = new GameOfLife();
	random.init(null,8,8);
 
	
	blinker.canvas = document.getElementById('blinker');
	glider.canvas = document.getElementById('glider');
	random.canvas = document.getElementById('random');
	if (blinker.canvas.getContext && glider.canvas.getContext && random.canvas.getContext) {
		blinker.ctx = blinker.canvas.getContext('2d');
		glider.ctx = glider.canvas.getContext('2d');
		random.ctx = random.canvas.getContext('2d');
	} else {
		return 1;
	}
 
 
	
	setInterval(function(){run(glider,glider.ctx,25,25)},250);
	setInterval(function(){run(blinker,blinker.ctx,25,25)},250);
	setInterval(function(){run(random,random.ctx,25,25)},250);
	return 0;
}
 
function run(game,ctx,w,h) {
	game.print(ctx,w,h);
	game.nextGen()
 
	return 0;
}
 
		</script> 
	</head> 
	<body onLoad=strv> 
		3x3 Blinker<br> 
		<canvas id=strv> 
			No canvas support found!
		</canvas><br><br> 
		6x6 Glider<br> 
		<canvas id=strv> 
			No canvas support found!
		</canvas><br><br> 
		8x8 Random<br> 
		<canvas id=strv> 
			No canvas support found!
		</canvas><br> 
	</body> 
</html> 
const _ = require('lodash');
 
///////////////////

///////////////////
 

_.each(_.keys(_), k => global[k === 'isNaN' ? '_isNaN' : k] = _[k]);
 
///////////////

///////////////
const WORLD_WIDTH  = 3,
      WORLD_HEIGHT = 3,
      displayWorld = (world) => console.log(map(world, x => x.join(' ')).join('') + ''),
 
      aliveNeighbours = (world, x, y) => chain(range(-1, 2))
                                          .reduce((acc, i) => acc.concat(map(range(-1, 2), ii => [i, ii])), [])
                                          .reject(partial(isEqual, [0, 0]))
                                          .map(i => {
                                            try {
                                              return world[x + i[0]][y + i[1]];
                                            } catch (err) {
                                              return null;
                                            }
                                          })
                                          .compact()
                                          .value()
                                          .length,
 
      isAlive = (cell, numAliveNeighbours) => (cell === 1 && inRange(numAliveNeighbours, 2, 4)) || (cell === 0 && numAliveNeighbours === 3) ? 1 : 0,
      updateWorld = (world) => map(world, (row, rowidx) => map(row, (cell, colidx) => isAlive(cell, aliveNeighbours(world, rowidx, colidx))));
 
 

let world = [[0, 0, 0], [1, 1, 1], [0, 0, 0]];
 
setInterval(() => {
  world = updateWorld(world)
  displayWorld(world);
}, 1000);
 "
"var objArgs = WScript.Arguments;
for (var i = 0; i < objArgs.length; i++)
   WScript.Echo(objArgs.Item(i));import System;
var argv:String[] = Environment.GetCommandLineArgs();
for (var i in argv)
  print(argv[i]);for (var i = 0; i < arguments.length; i++)
    print(arguments[i]);"
n = n + 1; /* This isa multi linecommentand another line in the comment*/
"function quibble(words) {
  return strv + 
    words.slice(0, words.length-1).join(strv) +
   (words.length > 1 ? strv : strv) +
   (words[words.length-1] || '') +
  strv;
}
 
[[], [strv], [strv, strv], [strv, strv, strv, strv]].forEach(
  function(s) {
    console.log(quibble(s));
  }
);(() => {
    'use strict';
 
    
 
    
    const quibble = xs =>
        (xs.length > 1) ? (
            intercalate(
                strv,
                ap(
                    [compose([intercalate(strv), reverse, tail]), head], //
                    [reverse(xs)]
                )
            )
        ) : concat(xs);
 
 
    
 
    
    
    const ap = (fs, xs) => //
        [].concat.apply([], fs.map(f => //
            [].concat.apply([], xs.map(x => [f(x)]))));
 
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const intercalate = curry((s, xs) => xs.join(s));
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    const compose = fs => x => fs.reduceRight((a, f) => f(a), x);
 
    
    const map = curry((f, xs) => xs.map(f));
 
    
    const reverse = xs =>
        typeof xs === 'string' ? (
            xs.split('')
            .reverse()
            .join('')
        ) : xs.slice(0)
        .reverse();
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const tail = xs => xs.length ? xs.slice(1) : undefined;
 
    
    const append = (xs, ys) => xs.concat(ys);
 
    
    const words = s => s.split(/\s+/);
 
    
    const unlines = xs => xs.join('');
 
 
    
    return unlines(
        map(
            compose([x => '{' + x + '}', quibble]),
            append([
                [],
                [strv],
                [strv, strv],
                [strv, strv, strv, strv]
            ], map(
                words, [
                    strv, strv, strv, strv
                ]
            ))
        ));
})();"
"<html><head><title>Donuts</title></head>
<body><pre id='x'></pre><script type=strv>
function disp(x) {
	var e = document.createTextNode(x + '');
	document.getElementById('x').appendChild(e);
}
 
function pick(n, got, pos, from, show) {
	var cnt = 0;
	if (got.length == n) {
		if (show) disp(got.join(' '));
		return 1;
	}
	for (var i = pos; i < from.length; i++) {
		got.push(from[i]);
		cnt += pick(n, got, i, from, show);
		got.pop();
	}
	return cnt;
}
 
disp(pick(2, [], 0, [strv, strv, strv], true) + strv);
disp(strv + pick(3, [], 0, strv.split(''), false) + strv);
</script></body></html>(function () {
 
  
  function combsWithRep(n, lst) {
    return n ? (
      lst.length ? combsWithRep(n - 1, lst).map(function (t) {
        return [lst[0]].concat(t);
      }).concat(combsWithRep(n, lst.slice(1))) : []
    ) : [[]];
  };
 
  
  
 
  
  function memoized(fn) {
    m = {};
    return function (x) {
      var args = [].slice.call(arguments),
        strKey = args.join('-');
 
      v = m[strKey];
      if ('u' === (typeof v)[0])
        m[strKey] = v = fn.apply(null, args);
      return v;
    }
  }
 
  
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
 
  return [
 
      combsWithRep(2, [strv, strv, strv]),
 
    
      memoized(combsWithRep)(3, range(1, 10)).length
    ];
 
})();[
 [[strv, strv], [strv, strv], [strv, strv],
  [strv, strv], [strv, strv], [strv, strv]],
 220
](() => {
    'use strict';
 
    
 
    
    const combsWithRep = (k, xs) => {
        const comb = (n, ys) => {
            if (0 === n) return ys;
            if (isNull(ys)) return comb(n - 1, map(pure, xs));
 
            return comb(n - 1, concatMap(zs => {
                const h = head(zs);
                return map(x => [x].concat(zs), dropWhile(x => x !== h, xs));
            }, ys));
        };
        return comb(k, []);
    };
 
    
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const dropWhile = (p, xs) => {
        let i = 0;
        for (let lng = xs.length;
            (i < lng) && p(xs[i]); i++) {}
        return xs.slice(i);
    };
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const head = xs => xs.length ? xs[0] : undefined;
 
    
    const isNull = xs => (xs instanceof Array) ? xs.length < 1 : undefined;
 
    
    const length = xs => xs.length;
 
    
    const map = (f, xs) => xs.map(f);
 
    
    const pure = x => [x];
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    
    return show({
        twoFromThree: combsWithRep(2, ['iced', 'jam', 'plain']),
        threeFromTen: length(combsWithRep(3, enumFromTo(0, 9)))
    });
})();"
"var funcs = [];
for (var i = 0; i < 10; i++) {
    funcs.push( (function(i) {
                     return function() { return i * i; }
                })(i) );
}
window.alert(funcs[3]()); <script type=strv>
var funcs = [];
for (var i = 0; i < 10; i++) {
    let (i = i) {
        funcs.push( function() { return i * i; } );
    }
}
window.alert(funcs[3]()); 
</script>strv;
let funcs = [];
for (let i = 0; i < 10; ++i) {
    funcs.push((i => () => i*i)(i));
}
console.log(funcs[3]());(function () {
    'use strict';
 
    
    function range(m, n) {
        return Array.apply(null, Array(n - m + 1))
            .map(function (x, i) {
                return m + i;
            });
    }
 
    var lstFns = range(0, 10)
        .map(function (i) {
            return function () {
                return i * i;
            };
        })
 
    return lstFns[3]();
 
})();let funcs = [...Array(10).keys()].map(i => () => i*i);"
"function bitprint(u) {
  var s=strv;
  for (var n=0; u; ++n, u>>=1)
    if (u&1) s+=n+strv;
  return s;
}
function bitcount(u) {
  for (var n=0; u; ++n, u=u&(u-1));
  return n;
}
function comb(c,n) {
  var s=[];
  for (var u=0; u<1<<n; u++)
    if (bitcount(u)==c)
      s.push(bitprint(u))
  return s.sort();
}
comb(3,5)function combinations(arr, k){
    var i,
    subI,
    ret = [],
    sub,
    next;
    for(i = 0; i < arr.length; i++){
        if(k === 1){
            ret.push( [ arr[i] ] );
        }else{
            sub = combinations(arr.slice(i+1, arr.length), k-1);
            for(subI = 0; subI < sub.length; subI++ ){
                next = sub[subI];
                next.unshift(arr[i]);
                ret.push( next );
            }
        }
    }
    return ret;
}
combinations([0,1,2,3,4], 3); 

 
combinations([strv, strv, strv, strv], 3); 

 (function () {
 
  function comb(n, lst) {
    if (!n) return [[]];
    if (!lst.length) return [];
 
    var x = lst[0],
        xs = lst.slice(1);
 
    return comb(n - 1, xs).map(function (t) {
      return [x].concat(t);
    }).concat(comb(n, xs));
  }
 
 
  
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
  return comb(3, range(0, 4))
 
    .map(function (x) {
      return x.join(' ');
    }).join('');
 
})();(function (n) {
 
  
  function comb(n, lst) {
    if (!n) return [[]];
    if (!lst.length) return [];
 
    var x = lst[0],
      xs = lst.slice(1);
 
    return comb(n - 1, xs).map(function (t) {
      return [x].concat(t);
    }).concat(comb(n, xs));
  }
 
  
  function memoized(fn) {
    m = {};
    return function (x) {
      var args = [].slice.call(arguments),
        strKey = args.join('-');
 
      v = m[strKey];
      if ('u' === (typeof v)[0])
        m[strKey] = v = fn.apply(null, args);
      return v;
    }
  }
 
  
  function range(m, n) {
    return Array.apply(null, Array(n - m + 1)).map(function (x, i) {
      return m + i;
    });
  }
 
  var fnMemoized = memoized(comb),
    lstRange = range(0, 4);
 
  return fnMemoized(n, lstRange)
 
  .map(function (x) {
    return x.join(' ');
  }).join('');
 
})(3);0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4(function (n) {
    'use strict';
 
    
    let comb = (n, xs) => {
            if (n < 1) return [[]];
            if (xs.length === 0) return [];
 
            let h = xs[0],
                tail = xs.slice(1);
 
            return comb(n - 1, tail)
                .map((t) => [h].concat(t))
                .concat(comb(n, tail));
        },
 
        
        
        memoized = (f) => {
            let m = {};
 
            return function (x) {
                let args = [].slice.call(arguments),
                    strKey = args.join('-'),
                    v = m[strKey];
 
                return (
                    (v === undefined) &&
                    (m[strKey] = v = f.apply(null, args)),
                    v
                );
            }
        },
 
        range = (m, n) =>
            Array.from({
                length: (n - m) + 1
            }, (_, i) => m + i);
 
    return memoized(comb)(n, range(0, 4))
})(3);(() => {
    'use strict';
 
    
 
    
    const comb = (m, n) => combinations(m, enumFromTo(0, n - 1));
 
    
    const combinations = (k, xs) =>
        sort(filter(xs => k === xs.length, subsequences(xs)));
 
 
    
 
    
    const cons = (x, xs) => [x].concat(xs);
 
    
    const enumFromTo = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const filter = (f, xs) => xs.filter(f);
 
    
    const foldr = (f, a, xs) => xs.reduceRight(f, a);
 
    
    const isNull = xs => (xs instanceof Array) ? xs.length < 1 : undefined;
 
    
    const show = x => JSON.stringify(x) //, null, 2);
 
    
    const sort = xs => xs.sort();
 
    
    const stringChars = s => s.split('');
 
    
    const subsequences = xs => {
 
        
        const nonEmptySubsequences = xxs => {
            if (isNull(xxs)) return [];
            const [x, xs] = uncons(xxs);
            const f = (r, ys) => cons(ys, cons(cons(x, ys), r));
 
            return cons([x], foldr(f, [], nonEmptySubsequences(xs)));
        };
 
        return nonEmptySubsequences(
            (typeof xs === 'string' ? stringChars(xs) : xs)
        );
    };
 
    
    const uncons = xs => xs.length ? [xs[0], xs.slice(1)] : undefined;
 
 
    
    return show(
        comb(3, 5)
    );
})();"
"(() => {
    'use strict';
 
    
 
    
    const zip = (xs, ys) =>
        xs.slice(0, Math.min(xs.length, ys.length))
        .map((x, i) => [x, ys[i]]);
 
    
    const zip3 = (xs, ys, zs) =>
        xs.slice(0, Math.min(xs.length, ys.length, zs.length))
        .map((x, i) => [x, ys[i], zs[i]]);
 
    
    const words = s => s.split(/\s+/);
    const chars = s => s.split('');
 
    
    const quot = (m, n) => Math.floor(m / n);
 
    
    
    
    const show = JSON.stringify;
 
    
    const concat = xs => {
        if (xs.length > 0) {
            const unit = typeof xs[0] === 'string' ? '' : [];
            return unit.concat.apply(unit, xs);
        } else return [];
    };
 
    
    const justifyLeft = (n, cFiller, strText) =>
        n > strText.length ? (
            (strText + cFiller.repeat(n))
            .substr(0, n)
        ) : strText;
 
    
    const unlines = xs => xs.join('');
 
    
    const intercalate = (s, xs) => xs.join(s);
 
    
    const map = (f, xs) => xs.map(f);
 
 
    
    
    const ats = zip(
        chars(strv), 
        words(strv)
    );
 
    
    const ads = zip(
        chars(strv), 
        words(strv)
    );
 
    
    const aws = zip3(
        chars(strv), 
        words(strv),
        words(strv)
    );
 
    
    const axs = zip3(
        chars(strv), 
        words(strv),
        words(strv)
    );
 
    
    const ays = zip(
        chars(strv), 
        words(strv)
    );
 
    
    const zodiac = y => {
        const
            iYear = y - 4,
            iStem = iYear % 10,
            iBranch = iYear % 12,
            [hStem, pStem] = ats[iStem],
            [hBranch, pBranch] = ads[iBranch],
            [hElem, pElem, eElem] = aws[quot(iStem, 2)],
            [hAnimal, pAnimal, eAnimal] = axs[iBranch],
            [hYinyang, pYinyang] = ays[iYear % 2];
        return [
            [show(y), hStem + hBranch, hElem, hAnimal, hYinyang],
            ['', pStem + pBranch, pElem, pAnimal, pYinyang],
            ['', show((iYear % 60) + 1) + '/60', eElem, eAnimal, '']
        ];
    };
 
    
    
    const fieldWidths = [
        [6, 10, 7, 8, 3],
        [6, 11, 8, 8, 4],
        [6, 11, 8, 8, 4]
    ];
 
    
    const showYear = y =>
        unlines(map(
            row => concat(map(([n, s]) => justifyLeft(n, ' ', s), row)),
            map(
                ([ns, xs]) => zip(ns, xs),
                zip(fieldWidths, zodiac(y))
            )
        ));
 
    
    return intercalate(
        '',
        map(showYear, [1935, 1938, 1968, 1972, 1976, 1984, 2017])
    );
})();"
"const hDist = (p1, p2) => Math.hypot(...p1.map((e, i) => e - p2[i])) / 2;
const pAng = (p1, p2) => Math.atan(p1.map((e, i) => e - p2[i]).reduce((p, c) => c / p, 1));
const solveF = (p, r) => t => [r*Math.cos(t) + p[0], r*Math.sin(t) + p[1]];
const diamPoints = (p1, p2) => p1.map((e, i) => e + (p2[i] - e) / 2);
 
const findC = (...args) => {
  const [p1, p2, s] = args;
  const solve = solveF(p1, s);
  const halfDist = hDist(p1, p2);
 
  let msg = `p1: ${p1}, p2: ${p2}, r:${s} Result: `;
  switch (Math.sign(s - halfDist)) {
    case 0:
      msg += s ? `Points on diameter. Circle at: ${diamPoints(p1, p2)}` :
        'Radius Zero';
      break;
    case 1:
      if (!halfDist) {
        msg += 'Coincident point. Infinite solutions';
      }
      else {
        let theta = pAng(p1, p2);
        let theta2 = Math.acos(halfDist / s);
        [1, -1].map(e => solve(theta + e * theta2)).forEach(
          e => msg += `Circle at ${e} `);
      }
      break;
    case -1:
      msg += 'No intersection. Points further apart than circle diameter';
      break;
  }
  return msg;
};
 
 
[
  [[0.1234, 0.9876], [0.8765, 0.2345], 2.0],
  [[0.0000, 2.0000], [0.0000, 0.0000], 1.0],
  [[0.1234, 0.9876], [0.1234, 0.9876], 2.0],
  [[0.1234, 0.9876], [0.8765, 0.2345], 0.5],
  [[0.1234, 0.9876], [0.1234, 0.9876], 0.0]
].forEach((t,i) => console.log(`Test: ${i}: ${findC(...t)}`));
  
Test: 0: p1: 0.1234,0.9876, p2: 0.8765,0.2345, r:2 Result: Circle at 1.8631118016581891,1.974211801658189 Circle at -0.863211801658189,-0.7521118016581889 
Test: 1: p1: 0,2, p2: 0,0, r:1 Result: Points on diameter. Circle at: 0,1
Test: 2: p1: 0.1234,0.9876, p2: 0.1234,0.9876, r:2 Result: Coincident point. Infinite solutions
Test: 3: p1: 0.1234,0.9876, p2: 0.8765,0.2345, r:0.5 Result: No intersection. Points further apart than circle diameter
Test: 4: p1: 0.1234,0.9876, p2: 0.1234,0.9876, r:0 Result: Radius Zero
 "
"//Constructor function.
function Car(brand, weight) {
  this.brand = brand;
  this.weight = weight || 1000; 
}
Car.prototype.getPrice = function() { 
  return this.price;
}
 
function Truck(brand, size) {
  this.car = Car;
  this.car(brand, 2000); 
  this.size = size; 
}
Truck.prototype = Car.prototype; 
 
var cars = [ 
  new Car(strv),
  new Truck(strv, 2)
];
for (var i=0; i<cars.length; i++) {
  alert(cars[i].brand + strv + cars[i].weight + strv + cars[i].size + strv +
      (cars[i] instanceof Car) + strv + (cars[i] instanceof Truck));
}class Car {
  /**   * A few brands of cars   * @type {string[]}   */
  static brands = ['Mazda', 'Volvo'];
 
  /**   * Weight of car   * @type {number}   */
  weight = 1000;
 
  /**   * Brand of car   * @type {string}   */
  brand;
 
  /**   * Price of car   * @type {number}   */
  price;
 
  /**   * @param {string} brand - car brand   * @param {number} weight - mass of car   */
  constructor(brand, weight) {
    if (brand) this.brand = brand;
    if (weight) this.weight = weight
  }
 
  /**   * Drive   * @param distance - distance to drive   */
  drive(distance = 10) {
    console.log(`A ${this.brand} ${this.constructor.name} drove ${distance}cm`);
  }
 
  /**   * Formatted stats string   */
  get formattedStats() {
    let out =
      `Type: ${this.constructor.name.toLowerCase()}`
      + `\nBrand: ${this.brand}`
      + `\nWeight: ${this.weight}`;
 
    if (this.size) out += `\nSize: ${this.size}`;
 
    return out
  }
}
 
class Truck extends Car {
  /**   * Size of truck   * @type {number}   */
  size;
 
  /**   * @param {string} brand - car brand   * @param {number} size - size of car   */
  constructor(brand, size) {
    super(brand, 2000);
    if (size) this.size = size;
  }
}
 
let myTruck = new Truck('Volvo', 2);
console.log(myTruck.formattedStats);
myTruck.drive(40);class Car 
{
  //Constructor function.
  function this(brand, weight, price = 0) {
    this.brand = brand;
    this.weight = weight || 1000; 
    this._price = price;
  }
  property price(v) 
  {
    get { return this._price; } 
    set { this._price = v; }    
  }
  function toString() { 
    return String.printf(strv,this.brand);
  }
}
 
class Truck : Car 
{
  function this(brand, size) {
    super(brand, 2000); 
    this.size = size; 
  }
}
 
var cars = [ 
  new Car(strv),
  new Truck(strv, 2, 30000)
];
for (var (i,car) in cars) 
{
  stdout.printf(strv, i, car.brand, car.price, car.weight, car.size,
                 car instanceof Car, car instanceof Truck);
}"
"var array = [];
array.push('abc');
array.push(123);
array.push(new MyClass);
console.log( array[2] );var obj = {};
obj['foo'] = 'xyz'; //equivalent to: obj.foo = 'xyz';
obj['bar'] = new MyClass; //equivalent to: obj.bar = new MyClass;
obj['1x; ~~:-b'] = 'text'; //no equivalent
console.log(obj['1x; ~~:-b']);"
"function distance(p1, p2) {
  var dx = Math.abs(p1.x - p2.x);
  var dy = Math.abs(p1.y - p2.y);
  return Math.sqrt(dx*dx + dy*dy);
}
 
function bruteforceClosestPair(arr) {
  if (arr.length < 2) {
    return Infinity;
  } else {
    var minDist = distance(arr[0], arr[1]);
    var minPoints = arr.slice(0, 2);
 
    for (var i=0; i<arr.length-1; i++) {
      for (var j=i+1; j<arr.length; j++) {
        if (distance(arr[i], arr[j]) < minDist) {
          minDist = distance(arr[i], arr[j]);
          minPoints = [ arr[i], arr[j] ];
        }
      }
    }
    return {
      distance: minDist,
      points: minPoints
    };
  }
} 
 
var Point = function(x, y) {
	this.x = x;
	this.y = y;
};
Point.prototype.getX = function() {
	return this.x;
};
Point.prototype.getY = function() {
	return this.y;
};
 
var mergeSort = function mergeSort(points, comp) {
	if(points.length < 2) return points;
 
 
	var n = points.length,
		i = 0,
		j = 0,
		leftN = Math.floor(n / 2),
		rightN = leftN;
 
 
	var leftPart = mergeSort( points.slice(0, leftN), comp),
		rightPart = mergeSort( points.slice(rightN), comp );
 
	var sortedPart = [];
 
	while((i < leftPart.length) && (j < rightPart.length)) {
		if(comp(leftPart[i], rightPart[j]) < 0) {
			sortedPart.push(leftPart[i]);
			i += 1;
		}
		else {
			sortedPart.push(rightPart[j]);
			j += 1;
		}
	}
	while(i < leftPart.length) {
		sortedPart.push(leftPart[i]);
		i += 1;
	}
	while(j < rightPart.length) {
		sortedPart.push(rightPart[j]);
		j += 1;
	}
	return sortedPart;
};
 
var closestPair = function _closestPair(Px, Py) {
	if(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };
	if(Px.length < 3) {
		//find euclid distance
		var d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );
		return {
			distance: d,
			pair: [ Px[0], Px[1] ]
		};
	}
 
	var	n = Px.length,
		leftN = Math.floor(n / 2),
		rightN = leftN;
 
	var Xl = Px.slice(0, leftN),
		Xr = Px.slice(rightN),
		Xm = Xl[leftN - 1],
		Yl = [],
		Yr = [];
	//separate Py
	for(var i = 0; i < Py.length; i += 1) {
		if(Py[i].x <= Xm.x)
			Yl.push(Py[i]);
		else
			Yr.push(Py[i]);
	}
 
	var dLeft = _closestPair(Xl, Yl),
		dRight = _closestPair(Xr, Yr);
 
	var minDelta = dLeft.distance,
		closestPair = dLeft.pair;
	if(dLeft.distance > dRight.distance) {
		minDelta = dRight.distance;
		closestPair = dRight.pair;
	}
 
 
	//filter points around Xm within delta (minDelta)
	var closeY = [];
	for(i = 0; i < Py.length; i += 1) {
		if(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);
	}
	//find min within delta. 8 steps max
	for(i = 0; i < closeY.length; i += 1) {
		for(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {
			var d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );
			if(d < minDelta) {
				minDelta = d;
				closestPair = [ closeY[i], closeY[j] ]
			}
		}
	}
 
	return {
		distance: minDelta,
		pair: closestPair
	};
};
 
 
var points = [
	new Point(0.748501, 4.09624),
	new Point(3.00302, 5.26164),
	new Point(3.61878,  9.52232),
	new Point(7.46911,  4.71611),
	new Point(5.7819,   2.69367),
	new Point(2.34709,  8.74782),
	new Point(2.87169,  5.97774),
	new Point(6.33101,  0.463131),
	new Point(7.46489,  4.6268),
	new Point(1.45428,  0.087596)
];
 
var sortX = function (a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }
var sortY = function (a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }
 
var Px = mergeSort(points, sortX);
var Py = mergeSort(points, sortY);
 
console.log(JSON.stringify(closestPair(Px, Py))) 
 
var points2 = [new Point(37100, 13118), new Point(37134, 1963), new Point(37181, 2008), new Point(37276, 21611), new Point(37307, 9320)];
 
Px = mergeSort(points2, sortX);
Py = mergeSort(points2, sortY);
 
console.log(JSON.stringify(closestPair(Px, Py))); 
 
 "
"var net = require(strv);
var sys = require(strv);
var EventEmitter = require(strv).EventEmitter;
 
/******************************************************************************* * ChatServer * * Manages connections, users, and chat messages. ******************************************************************************/
 
function ChatServer() {
  this.chatters = {};
  this.server   = net.createServer(this.handleConnection.bind(this));
  this.server.listen(1212, strv);
}
 
ChatServer.prototype.isNicknameLegal = function(nickname) {
  
  
  if(nickname.replace(/[A-Za-z0-9]*/, '') != strv) {
    return false
  }
  for(used_nick in this.chatters) {
    if(used_nick == nickname) {
      return false;
    }
  }
  return true;
};
 
ChatServer.prototype.handleConnection = function(connection) {
  console.log(strv + connection.remoteAddress);
  connection.setEncoding(strv);
 
  var chatter = new Chatter(connection, this);
  chatter.on(strv, this.handleChat.bind(this));
  chatter.on(strv, this.handleJoin.bind(this));
  chatter.on(strv, this.handleLeave.bind(this));
};
 
ChatServer.prototype.handleChat = function(chatter, message) {
  this.sendToEveryChatterExcept(chatter, chatter.nickname + strv + message);
};
 
ChatServer.prototype.handleJoin = function(chatter) {
  console.log(chatter.nickname + strv);
  this.sendToEveryChatter(chatter.nickname + strv);
  this.addChatter(chatter);
};
 
ChatServer.prototype.handleLeave = function(chatter) {
  console.log(chatter.nickname + strv);
  this.removeChatter(chatter);
  this.sendToEveryChatter(chatter.nickname + strv);
};
 
ChatServer.prototype.addChatter = function(chatter) {
  this.chatters[chatter.nickname] = chatter;
};
 
ChatServer.prototype.removeChatter = function(chatter) {
  delete this.chatters[chatter.nickname];
};
 
ChatServer.prototype.sendToEveryChatter = function(data) {
  for(nickname in this.chatters) {
    this.chatters[nickname].send(data);
  }
};
 
ChatServer.prototype.sendToEveryChatterExcept = function(chatter, data) {
  for(nickname in this.chatters) {
    if(nickname != chatter.nickname) {
      this.chatters[nickname].send(data);
    }
  }
};
 
/******************************************************************************* * Chatter * * Represents a single user/connection in the chat server. ******************************************************************************/
 
function Chatter(socket, server) {
  EventEmitter.call(this);
 
  this.socket     = socket;
  this.server     = server;
  this.nickname   = strv;
  this.lineBuffer = new SocketLineBuffer(socket);
 
  this.lineBuffer.on(strv, this.handleNickname.bind(this));
  this.socket.on(strv, this.handleDisconnect.bind(this));
 
  this.send(strv);
};
 
sys.inherits(Chatter, EventEmitter);
 
Chatter.prototype.handleNickname = function(nickname) {
  if(server.isNicknameLegal(nickname)) {
    this.nickname = nickname;
    this.lineBuffer.removeAllListeners(strv);
    this.lineBuffer.on(strv, this.handleChat.bind(this));
    this.send(strv + nickname + strv);
    this.emit(strv, this);
  } else {
    this.send(strv);
    this.send(strv);
  }
};
 
Chatter.prototype.handleChat = function(line) {
  this.emit(strv, this, line);
};
 
Chatter.prototype.handleDisconnect = function() {
  this.emit(strv, this);
};
 
Chatter.prototype.send = function(data) {
  this.socket.write(data + """");
};
 
/******************************************************************************* * SocketLineBuffer * * Listens for and buffers incoming data on a socket and emits a 'line' event * whenever a complete line is detected. ******************************************************************************/
 
function SocketLineBuffer(socket) {
  EventEmitter.call(this);
 
  this.socket = socket;
  this.buffer = strv;
 
  this.socket.on(strv, this.handleData.bind(this));
};
 
sys.inherits(SocketLineBuffer, EventEmitter);
 
SocketLineBuffer.prototype.handleData = function(data) {
  for(var i = 0; i < data.length; i++) {
    var char = data.charAt(i);
    this.buffer += char;
    if(char == """") {
      this.buffer = this.buffer.replace("""", strv);
      this.buffer = this.buffer.replace("""", strv);
      this.emit(strv, this.buffer);
      this.buffer = strv;
    }
  }
};
 

server = new ChatServer();"
"console.log('a'.charCodeAt(0)); 
console.log(String.fromCharCode(97)); ['字'.codePointAt(0), '🐘'.codePointAt(0)][23383, 128024][23383, 128024].map(function (x) {
	return String.fromCodePoint(x);
})[strv, strv]"
"<html>
 
<head>
 
<meta charset=strv>
 
<title>Chaos Game</title>
 
</head>
 
<body>
 
<p>
<canvas id=strv width=400 height=346></canvas>
</p>
 
<p>
<button onclick=strv>Click here to see a Sierpiński triangle</button>
</p>
 
<script>
 
function chaosGame() {
    var canv = document.getElementById('sierpinski').getContext('2d');
    var x = Math.random() * 400;
    var y = Math.random() * 346;
    for (var i=0; i<30000; i++) {
        var vertex = Math.floor(Math.random() * 3);
        switch(vertex) {
            case 0:
                x = x / 2;
                y = y / 2;
                canv.fillStyle = 'green';
                break;
            case 1:
                x = 200 + (200 - x) / 2
                y = 346 - (346 - y) / 2
                canv.fillStyle = 'red';
                break;
            case 2:
                x = 400 - (400 - x) / 2
                y = y / 2;
                canv.fillStyle = 'blue';
        }
        canv.fillRect(x,y, 1,1);
    }
}
 
</script>
 
</body>
 
</html>"
"var fso = new ActiveXObject(strv);
 
fso.FileExists('input.txt');
fso.FileExists('c:/input.txt');
fso.FolderExists('docs');
fso.FolderExists('c:/docs');"
"var n = 15;
for (var t = [0, 1], i = 1; i <= n; i++) {
    for (var j = i; j > 1; j--) t[j] += t[j - 1];
    t[i + 1] = t[i];
    for (var j = i + 1; j > 1; j--) t[j] += t[j - 1];
    document.write(i == 1 ? '' : ', ', t[i + 1] - t[i]);
}(() => {
    'use strict';
 
    
 
    
    let catalanSeries = n => {
        let alternate = xs => xs.reduce(
                (a, x, i) => i % 2 === 0 ? a.concat([x]) : a, []
            ),
            diff = xs => xs.length > 1 ? xs[0] - xs[1] : xs[0];
 
        return alternate(pascal(n * 2))
            .map((xs, i) => diff(drop(i, xs)));
    }
 
    
 
    
    let pascal = n => until(
            m => m.level <= 1,
            m => {
                let nxt = zipWith(
                    (a, b) => a + b, [0].concat(m.row), m.row.concat(0)
                );
                return {
                    row: nxt,
                    triangle: m.triangle.concat([nxt]),
                    level: m.level - 1
                }
            }, {
                level: n,
                row: [1],
                triangle: [
                    [1]
                ]
            }
        )
        .triangle;
 
 
    
 
    
    let zipWith = (f, xs, ys) =>
        xs.length === ys.length ? (
            xs.map((x, i) => f(x, ys[i]))
        ) : undefined;
 
    
    let until = (p, f, x) => {
        let v = x;
        while (!p(v)) v = f(v);
        return v;
    }
 
    
    let drop = (n, xs) => xs.slice(n);
 
    
    let tail = xs => xs.length ? xs.slice(1) : undefined;
 
    return tail(catalanSeries(16));
})();[1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845]"
"var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 
function add(a, b) {
    return a + b;
}
 
var summation = nums.reduce(add);
 
function mul(a, b) {
    return a * b;
}
 
var product = nums.reduce(mul, 1);
 
var concatenation = nums.reduce(add, strv);
 
console.log(summation, product, concatenation);(function (xs) {
    'use strict';
 
    
    function foldl(f, acc, xs) {
        return xs.reduce(f, acc);
    }
 
    
    function foldr(f, acc, xs) {
        return xs.reduceRight(f, acc);
    }
 
    
    return [foldl, foldr].map(function (f) {
        return f(function (acc, x) {
            return acc + (x * 2).toString() + ' ';
        }, [], xs);
    });
 
})([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 
console.log(nums.reduce((a, b) => a + b, 0)); 
console.log(nums.reduce((a, b) => a * b, 1)); 
console.log(nums.reduce((a, b) => a + b, '')); "
"function main(s, e, bs, pbs) {
    bs = bs || 10;
    pbs = pbs || 10
    document.write('start:', toString(s), ' end:', toString(e),
        ' base:', bs, ' printBase:', pbs)
    document.write('<br>castOutNine: ');
    castOutNine()
    document.write('<br>kaprekar: ');
    kaprekar()
    document.write('<br><br>')
 
    function castOutNine() {
        for (var n = s, k = 0, bsm1 = bs - 1; n <= e; n += 1)
            if (n % bsm1 == (n * n) % bsm1) k += 1,
                document.write(toString(n), ' ')
        document.write('<br>trying ', k, ' numbers instead of ', n = e - s + 1,
            ' numbers saves ', (100 - k / n * 100)
            .toFixed(3), '%')
    }
 
    function kaprekar() {
        for (var n = s; n <= e; n += 1)
            if (isKaprekar(n)) document.write(toString(n), ' ')
 
        function isKaprekar(n) {
            if (n < 1) return false
            if (n == 1) return true
            var s = (n * n)
                .toString(bs)
            for (var i = 1, e = s.length; i < e; i += 1) {
                var a = parseInt(s.substr(0, i), bs)
                var b = parseInt(s.substr(i), bs)
                if (b && a + b == n) return true
            }
            return false
        }
    }
 
    function toString(n) {
        return n.toString(pbs)
            .toUpperCase()
    }
}
main(1, 10 * 10 - 1)
main(1, 16 * 16 - 1, 16)
main(1, 17 * 17 - 1, 17)
main(parseInt('10', 17), parseInt('gg', 17), 17, 17)(() => {
    'use strict';
 
    
    const co9 = n =>
        n <= 8 ? n : co9(
            digits(10, n)
            .reduce((a, x) => x !== 9 ? a + x : a, 0)
        );
 
    
 
    
    const digits = (base, n) => {
        if (n < base) return [n];
        const [q, r] = quotRem(n, base);
        return [r].concat(digits(base, q));
    };
 
    
    const quotRem = (m, n) => [Math.floor(m / n), m % n];
 
    
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    const squared = n => Math.pow(n, 2);
 
    
    const show = x => JSON.stringify(x, null, 2);
 
    
    return show({
        test1: co9(232345), //-> 1
        test2: co9(34234234), //-> 7
        test3: co9(232345 + 34234234) === co9(232345) + co9(34234234), //-> true
        test4: co9(232345 * 34234234) === co9(232345) * co9(34234234), //-> true,
        task2: range(1, 100)
            .filter(n => co9(n) === co9(squared(n))),
        task3: (k => range(1, 100)
            .filter(n => (n % k) === (squared(n) % k)))(16)
    });
})();"
"var dog = strv;
var Dog = strv;
var DOG = strv;
document.write(strv + dog + strv + Dog + strv + DOG + strv);"
x.y()
"<html><head><title>Catalan</title></head>
<body><pre id='x'></pre><script type=strv>
function disp(x) {
	var e = document.createTextNode(x + '');
	document.getElementById('x').appendChild(e);
}
 
var fc = [], c2 = [], c3 = [];
function fact(n) { return fc[n] ? fc[n] : fc[n] = (n ? n * fact(n - 1) : 1); }
function cata1(n) { return Math.floor(fact(2 * n) / fact(n + 1) / fact(n) + .5); }
function cata2(n) {
	if (n == 0) return 1;
	if (!c2[n]) {
		var s = 0;
		for (var i = 0; i < n; i++) s += cata2(i) * cata2(n - i - 1);
		c2[n] = s;
	}
	return c2[n];
}
function cata3(n) {
	if (n == 0) return 1;
	return c3[n] ? c3[n] : c3[n] = (4 * n - 2) * cata3(n - 1) / (n + 1);
}
 
disp(strv);
for (var i = 0; i <= 15; i++)
	disp(i + '' + cata1(i) + '' + cata2(i) + '' + cata3(i));
 
</script></body></html>"
"#!/usr/bin/env js
 
function main() {
    var len = 4;
    playBullsAndCows(len);
}
 
function playBullsAndCows(len) {
    var num = pickNum(len);
    
    showInstructions(len);
    var nGuesses = 0;
    while (true) {
        nGuesses++;
        var guess = getGuess(nGuesses, len);
        var census = countBovine(num, guess);
        showScore(census.bulls, census.cows);
        if (census.bulls == len) {
            showFinalResult(nGuesses);
            return;
        }
    }
}
 
function showScore(nBulls, nCows) {
    print('    Bulls: ' + nBulls + ', cows: ' + nCows);
}
 
function showFinalResult(guesses) {
    print('You win!!! Guesses needed: ' + guesses);
}
 
function countBovine(num, guess) {
    var count = {bulls:0, cows:0};
    var g = guess.join('');
    for (var i = 0; i < num.length; i++) {
        var digPresent = g.search(num[i]) != -1;
        if (num[i] == guess[i]) count.bulls++;
        else if (digPresent) count.cows++;
    }
    return count;
}
 
function getGuess(nGuesses, len) {
    while (true) {
        putstr('Your guess #' + nGuesses + ': ');
        var guess = readline();
        guess = String(parseInt(guess)).split('');
        if (guess.length != len) {
            print('  You must enter a ' + len + ' digit number.');
            continue;
        }
        if (hasDups(guess)) {
            print('  No digits can be duplicated.');
            continue;
        }    
        return guess;
    }
}
 
function hasDups(ary) {
    var t = ary.concat().sort();
    for (var i = 1; i < t.length; i++) {
        if (t[i] == t[i-1]) return true;
    }
    return false;
}
 
function showInstructions(len) {
    print();
    print('Bulls and Cows Game');
    print('-------------------');
    print('  You must guess the ' + len + ' digit number I am thinking of.');
    print('  The number is composed of the digits 1-9.');
    print('  No digit appears more than once.');
    print('  After each of your guesses, I will tell you:');
    print('    The number of bulls (digits in right place)');
    print('    The number of cows (correct digits, but in the wrong place)');
    print();
}
 
function pickNum(len) {
    var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    nums.sort(function(){return Math.random() - 0.5});
    return nums.slice(0, len);
}
 
main();
 "
"var foo = function() { return arguments.length };
foo() 
foo(1, 2, 3) var squares = [1, 2, 3].map(function (n) { return n * n });  
var make_adder = function(m) {
    return function(n) { return m + n }
};
var add42 = make_adder(42);
add42(10) foo.toString()
strv
alert.toString()
strvvar mutate = function(victim) {
    victim[0] = null;
    victim = 42;
};
var foo = [1, 2, 3];
mutate(foo) "
"function caesar (text, shift) {
  return text.toUpperCase().replace(/[^A-Z]/g,'').replace(/[A-Z]/g, function(a) {
    return String.fromCharCode(65+(a.charCodeAt(0)-65+shift)%26);
  });
}
 

var text = 'veni, vidi, vici';
for (var i = 0; i<26; i++) {
  console.log(i+': '+caesar(text,i));
}var caesar = (text, shift) => text
  .toUpperCase()
  .replace(/[^A-Z]/g, '')
  .replace(/[A-Z]/g, a =>
    String.fromCharCode(65 + (a.charCodeAt(0) - 65 + shift) % 26));((key, strPlain) => {
 
    
    let caesar = (k, s) => s.split('')
        .map(c => tr(
            inRange(['a', 'z'], c) ? 'a' :
            inRange(['A', 'Z'], c) ? 'A' : 0,
            k, c
        ))
        .join('');
 
    
    let unCaesar = (k, s) => caesar(26 - (k % 26), s);
 
    
    let tr = (base, offset, char) =>
        base ? (
            String.fromCharCode(
                ord(base) + (
                    ord(char) - ord(base) + offset
                ) % 26
            )
        ) : char;
 
    
    let inRange = ([min, max], v) => !(v < min || v > max);
 
    
    let ord = c => c.charCodeAt(0);
 
    
    let range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
    let strCipher = caesar(key, strPlain),
        strDecode = unCaesar(key, strCipher);
 
    return [strCipher, ' -> ', strDecode];
 
})(114, 'Curio, Cesare venne, e vide e vinse ? ');function replace(input: string, key: number) : string {
	return input.replace(/([a-z])/g, 
		($1) => String.fromCharCode(($1.charCodeAt(0) + key + 26 - 97) % 26 + 97)
		).replace(/([A-Z])/g, 
		($1) => String.fromCharCode(($1.charCodeAt(0) + key + 26 - 65) % 26 + 65));
}
 

var str = 'The five boxing wizards jump quickly';
var encoded = replace(str, 3);
var decoded = replace(encoded, -3);
 
console.log('Enciphered: ' + encoded);
console.log('Deciphered: ' + decoded);"
"(function () {
  'use strict'
 
  
  
  function bracePair(tkns, iPosn, iNest, lstCommas) {
    if (iPosn >= tkns.length || iPosn < 0) return null;
 
    var t = tkns[iPosn],
      n = (t === '{') ? iNest + 1 : (t === '}' ? iNest - 1 : iNest),
      lst = (t === ',' && iNest === 1) ? lstCommas.concat(iPosn) : lstCommas;
 
    return n ? bracePair(tkns, iPosn + 1, n, lst) : {
      close: iPosn,
      commas: lst
    };
  }
 
  
  function andTree(dctSofar, tkns) {
    if (!tkns.length) return [dctSofar, []];
 
    var dctParse = dctSofar ? dctSofar : {
        fn: and,
        args: []
      },
 
      head = tkns[0],
      tail = head ? tkns.slice(1) : [],
 
      dctBrace = head === '{' ? bracePair(
        tkns, 0, 0, []
      ) : null,
 
      lstOR = dctBrace && dctBrace.close && dctBrace.commas.length ? (
        splitAt(dctBrace.close + 1, tkns)
      ) : null;
 
    return andTree({
      fn: and,
      args: dctParse.args.concat(
        lstOR ? orTree(dctParse, lstOR[0], dctBrace.commas) : head
      )
    }, lstOR ? lstOR[1] : tail);
  }
 
  
  function orTree(dctSofar, tkns, lstCommas) {
    if (!tkns.length) return [dctSofar, []];
    var iLast = lstCommas.length;
 
    return {
      fn: or,
      args: splitsAt(
        lstCommas, tkns
      ).map(function (x, i) {
        var ts = x.slice(1, i === iLast ? -1 : void 0);
 
        return ts.length ? ts : [''];
      }).map(function (ts) {
        return ts.length > 1 ? andTree(null, ts)[0] : ts[0];
      })
    };
  }
 
  
  function tokens(str) {
    
    var toS = function (x) {
      return x.toString();
    };
 
    return str.split(/(\\\\)/).filter(toS).reduce(function (a, s) {
      return a.concat(s.charAt(0) === '' ? s : s.split(
        /(\\*[{,}])/
      ).filter(toS));
    }, []);
  }
 
  
  
  function and(args) {
    var lng = args.length,
      head = lng ? args[0] : null,
      lstHead = strv === typeof head ? [head] : head;
 
    return lng ? (
      1 < lng ? lstHead.reduce(function (a, h) {
        return a.concat(and(args.slice(1)).map(function (t) {
          return h + t;
        }));
      }, []) : lstHead
    ) : [];
  }
 
  
  
  function or(args) {
    return args.reduce(function (a, b) {
      return a.concat(b);
    }, []);
  }
 
  
  function splitAt(n, lst) {
    return n < lst.length + 1 ? [lst.slice(0, n), lst.slice(n)] : [lst, []];
  }
 
  
  function splitsAt(lstN, lst) {
    return lstN.reduceRight(function (a, x) {
      return splitAt(x, a[0]).concat(a.slice(1));
    }, [lst]);
  }
 
  
  function evaluated(e) {
    return typeof e === 'string' ? e :
      e.fn(e.args.map(evaluated));
  }
 
  
  function pp(e) {
    return JSON.stringify(e, function (k, v) {
      return typeof v === 'function' ? (
        '[function ' + v.name + ']'
      ) : v;
    }, 2)
  }
 
 
  
 
  
  function expansions(s) {
    
    var dctParse = andTree(null, tokens(s))[0];
 
    
    console.log(pp(dctParse));
 
    
    return evaluated(dctParse);
  }
 
 
  
  var lstTests = [
    '~/{Downloads,Pictures}/*.{jpg,gif,png}',
    'It{{em,alic}iz,erat}e{d,}, please.',
    '{,{,gotta have{ ,, again, }}more }cowbell!',
    '{}} some }{,{{ edge, edge} ,}{ cases, {here} }'
  ];
 
 
  
  
 
  return lstTests.map(function (s) {
    return s + '' + expansions(s).map(function (x) {
      return '   ' + x;
    }).join('');
  }).join('');
 
})();{
  strv: strv,
  strv: [
    strv,
    {
      strv: strv,
      strv: [
        {
          strv: strv,
          strv: [
            {
              strv: strv,
              strv: [
                strv,
                strv
              ]
            },
            strv
          ]
        },
        strv
      ]
    },
    strv,
    {
      strv: strv,
      strv: [
        strv,
        strv
      ]
    },
    strv,
    strv
  ]
}"
"function brownian(canvasId, messageId) {
  var canvas = document.getElementById(canvasId);
  var ctx = canvas.getContext(strv);
 
  
  var drawPos = true;
  var seedResolution = 50;
  var clearShade = 0; 
 
  
  var width = canvas.width;
  var height = canvas.height;
  var cx = width/2;
  var cy = height/2;
  var clearStyle = strv+clearShade+strv+clearShade+strv+clearShade+strv;
 
  
  function radius(x,y) {
    return Math.sqrt((x-cx)*(x-cy)+(y-cx)*(y-cy));
  }
  function test(x, y) {
    if (x < 0 || y < 0 || x >= width || y >= height)
      return false;
    var data = ctx.getImageData(x, y, 1, 1).data;
    return data[0] != clearShade || data[1] != clearShade || data[2] != clearShade;
  }
  var shade = 120;
  function setc(x, y, c) {
    //var imgd = ctx.createImageData(1, 1);
    //var pix = imgd.data;
    //pix[0] = pix[1] = pix[2] = c == 255 ? 255 : shade;
    //pix[3] = 255;
    //shade = (shade + 1) % 254;
    //ctx.putImageData(imgd, x, y);
    //ctx.fillStyle = strv;
    shade = (shade + 0.02) % 360;
    if (c) {
      ctx.fillStyle = strv+shade+strv;
    } else {
      ctx.fillStyle = clearStyle;
    }
    ctx.fillRect (x, y, 1, 1);
  }
  function set(x,y) {
    setc(x,y,true);
  }
  function clear(x,y) {
    setc(x,y,false);
  }
 
  
  ctx.fillStyle = clearStyle;
  ctx.fillRect (0, 0, width, height);
 
  
  var x;
  var y;
 
  
  var closeRadius = 1;
 
  
  set(cx, cy);
 
  
  function newpos() {
    
    
    
    
    
    
    
    //
    
    x = Math.floor(Math.random()*(width/seedResolution))*seedResolution;
    y = Math.floor(Math.random()*(height/seedResolution))*seedResolution;
  }
  newpos();
 
  var animation;
  animation = window.setInterval(function () {
    if (drawPos) clear(x,y);
    for (var i = 0; i < 10000; i++) {
      var ox = x;
      var oy = y;
 
      
      
      switch (Math.floor(Math.random()*8)) {
        case 0: x++; break;
        case 1: x--; break;
        case 2: y++; break;
        case 3: y--; break;
        case 4: x++; y++; break;
        case 5: x--; y++; break;
        case 6: x++; y--; break;
        case 7: x--; y--; break;
      }
      if (x < 0 || y < 0 ||
          x >= width || y >= height ||
          radius(x,y) > closeRadius+seedResolution+2) {
        
        
        var progress = 1000;
        do {
          newpos();
          progress--;
        } while ((test(x-1,y-1) || test(x,y-1) || test(x+1,y-1) ||
                  test(x-1,y  ) || test(x,y  ) || test(x+1,y  ) ||
                  test(x-1,y+1) || test(x,y+1) || test(x+1,y+1)) && progress > 0);
        if (progress <= 0) {
          document.getElementById(messageId).appendChild(
              document.createTextNode(strv));
          clearInterval(animation);
          break;
        }
      }
      if (test(x, y)) {
        
        set(ox,oy);
        closeRadius = Math.max(closeRadius, radius(ox,oy));
        newpos();
      }
   }
   if (drawPos) set(x,y);
  }, 1);
 
}"
" 
  function draw() {
    var canvas = document.getElementById(strv);
    context = canvas.getContext(strv);
 
    bezier3(20, 200, 700, 50, -300, 50, 380, 150);


  }
 
  
  function bezier3(x1, y1, x2, y2, x3, y3, x4, y4) {
    var px = [], py = [];
    for (var i = 0; i <= b3Seg; i++) {
      var d = i / b3Seg;
      var a = 1 - d;
      var b = a * a;
      var c = d * d;
      a = a * b;
      b = 3 * b * d;
      c = 3 * a * c;
      d = c * d;
      px[i] = parseInt(a * x1 + b * x2 + c * x3 + d * x4);
      py[i] = parseInt(a * y1 + b * y2 + c * y3 + d * y4);
    }
    var x0 = px[0];
    var y0 = py[0];
    for (i = 1; i <= b3Seg; i++) {
      var x = px[i];
      var y = py[i];
      drawPolygon(context, [[x0, y0], [x, y]], strv, strv);
      x0 = x;
      y0 = y;
    }
  }
function drawPolygon(context, polygon, strokeStyle, fillStyle) {
  context.strokeStyle = strokeStyle;
  context.beginPath();
 
  context.moveTo(polygon[0][0],polygon[0][1]);
  for (i = 1; i < polygon.length; i++)
    context.lineTo(polygon[i][0],polygon[i][1]);
 
  context.closePath();
  context.stroke();
 
  if (fillStyle == undefined)
    return;
  context.fillStyle = fillStyle;
  context.fill();
}
 "
"function createRow(i, point, heading) {
    var tr = document.createElement('tr'),
        td;
 
    td = document.createElement('td');
    td.appendChild(document.createTextNode(i));
    tr.appendChild(td);
 
    td = document.createElement('td');
    point = point.substr(0, 1).toUpperCase() + point.substr(1);
    td.appendChild(document.createTextNode(point));
    tr.appendChild(td);
 
    td = document.createElement('td');
    td.appendChild(document.createTextNode(heading));
    tr.appendChild(td);
 
    return tr;
}
 
function getPoint(i) {
    var j = i % 8,
        i = Math.floor(i / 8) % 4,
        cardinal = ['north', 'east', 'south', 'west'],
        pointDesc = ['1', '1 by 2', '1-C', 'C by 1', 'C', 'C by 2', '2-C', '2 by 1'],
        str1, str2, strC;
 
    str1 = cardinal[i];
    str2 = cardinal[(i + 1) % 4];
    strC = (str1 === 'north' || str1 === 'south') ? str1 + str2 : str2 + str1;
    return pointDesc[j].replace('1', str1).replace('2', str2).replace('C', strC);
}
 
var i,
    heading,
    table = document.createElement('table'),
    tbody = document.createElement('tbody'),
    tr;
for (i = 0; i <= 32; i += 1) {
    heading = i * 11.25 + [0, 5.62, -5.62][i % 3];
    tr = createRow(i % 32 + 1, getPoint(i), heading + '°');
    tbody.appendChild(tr);
}
table.appendChild(tbody);
document.body.appendChild(table);
 (() => {
    'use strict';
 
    
 
    
    let toTitle = s => s.length ? (s[0].toUpperCase() + s.slice(1)) : '';
 
    
 
    
    
    
    
 
    
    let compassKeys = depth => {
        let urCompass = ['N', 'S', 'N'],
            subdivision = (compass, n) => n <= 1 ? (
                compass
            ) : subdivision( 
                
                compass.reduce((a, x, i, xs) => {
                    if (i > 0) {
                        return (n === depth) ? (
                            a.concat([x === 'N' ? 'W' : 'E'], x)
                        ) : a.concat([xs[i - 1] + x, x]);
                    } else return a.concat(x);
                }, []),
                n - 1
            );
        return subdivision(urCompass, depth)
            .slice(0, -1);
    };
 
    
    let lstLangs = [{
        'name': 'English',
        expansions: {
            N: 'north',
            S: 'south',
            E: 'east',
            W: 'west',
            b: ' by ',
            '-': '-'
        },
        'N': 'N',
        'NNNE': 'NbE',
        'NNE': 'N-NE',
        'NNENE': 'NEbN',
        'NE': 'NE',
        'NENEE': 'NEbE',
        'NEE': 'E-NE',
        'NEEE': 'EbN',
        'E': 'E',
        'EEES': 'EbS',
        'EES': 'E-SE',
        'EESES': 'SEbE',
        'ES': 'SE',
        'ESESS': 'SEbS',
        'ESS': 'S-SE',
        'ESSS': 'SbE',
        'S': 'S',
        'SSSW': 'SbW',
        'SSW': 'S-SW',
        'SSWSW': 'SWbS',
        'SW': 'SW',
        'SWSWW': 'SWbW',
        'SWW': 'W-SW',
        'SWWW': 'WbS',
        'W': 'W',
        'WWWN': 'WbN',
        'WWN': 'W-NW',
        'WWNWN': 'NWbW',
        'WN': 'NW',
        'WNWNN': 'NWbN',
        'WNN': 'N-NW',
        'WNNN': 'NbW'
    }, {
        'name': 'Chinese',
        'N': '北',
        'NNNE': '北微东',
        'NNE': '东北偏北',
        'NNENE': '东北微北',
        'NE': '东北',
        'NENEE': '东北微东',
        'NEE': '东北偏东',
        'NEEE': '东微北',
        'E': '东',
        'EEES': '东微南',
        'EES': '东南偏东',
        'EESES': '东南微东',
        'ES': '东南',
        'ESESS': '东南微南',
        'ESS': '东南偏南',
        'ESSS': '南微东',
        'S': '南',
        'SSSW': '南微西',
        'SSW': '西南偏南',
        'SSWSW': '西南微南',
        'SW': '西南',
        'SWSWW': '西南微西',
        'SWW': '西南偏西',
        'SWWW': '西微南',
        'W': '西',
        'WWWN': '西微北',
        'WWN': '西北偏西',
        'WWNWN': '西北微西',
        'WN': '西北',
        'WNWNN': '西北微北',
        'WNN': '西北偏北',
        'WNNN': '北微西'
    }];
 
    
    let pointIndex = (power, degrees) => {
        let nBoxes = (power ? Math.pow(2, power) : 32);
        return Math.ceil(
            (degrees + (360 / (nBoxes * 2))) % 360 * nBoxes / 360
        ) || 1;
    };
 
    
    let pointNames = (precision, iBox) => {
        let k = compassKeys(precision)[iBox - 1];
        return lstLangs.map(dctLang => {
            let s = dctLang[k] || k, 
                dctEx = dctLang.expansions;
 
            return dctEx ? toTitle(s.split('')
                    .map(c => dctEx[c])
                    .join(precision > 5 ? ' ' : ''))
                .replace(/  /g, ' ') : s;
        });
    };
 
    
    let maximumBy = (f, xs) =>
        xs.reduce((a, x) => a === undefined ? x : (
            f(x, a) > 0 ? x : a
        ), undefined);
 
    
    let justifyLeft = (n, cFiller, strText) =>
        n > strText.length ? (
            (strText + replicate(n, cFiller)
                .join(''))
            .substr(0, n)
        ) : strText;
 
    
    let justifyRight = (n, cFiller, strText) =>
        n > strText.length ? (
            (replicate(n, cFiller)
                .join('') + strText)
            .slice(-n)
        ) : strText;
 
    
    let replicate = (n, a) => {
        let v = [a],
            o = [];
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    };
 
    
    let transpose = xs =>
        xs[0].map((_, iCol) => xs.map((row) => row[iCol]));
 
    
    
    let length = xs => xs.length;
 
    
    let compareByLength = (a, b) => {
        let [na, nb] = [a, b].map(length);
        return na < nb ? -1 : na > nb ? 1 : 0;
    };
 
    
    let maxLen = xs => maximumBy(compareByLength, xs)
        .length;
 
    
    let compassTable = (precision, xs) => {
        if (precision < 1) return undefined;
        else {
            let intPad = 2;
 
            let lstIndex = xs.map(x => pointIndex(precision, x)),
                lstStrIndex = lstIndex.map(x => x.toString()),
                nIndexWidth = maxLen(lstStrIndex),
                colIndex = lstStrIndex.map(
                    x => justifyRight(nIndexWidth, ' ', x)
                );
 
            let lstAngles = xs.map(x => x.toFixed(2) + '°'),
                nAngleWidth = maxLen(lstAngles) + intPad,
                colAngles = lstAngles.map(x => justifyRight(nAngleWidth, ' ', x));
 
            let lstTrans = transpose(
                    lstIndex.map(i => pointNames(precision, i))
                ),
                lstTransWidths = lstTrans.map(x => maxLen(x) + 2),
                colsTrans = lstTrans
                .map((lstLang, i) => lstLang
                    .map(x => justifyLeft(lstTransWidths[i], ' ', x))
                );
 
            return transpose([colIndex]
                    .concat([colAngles], [replicate(lstIndex.length, strv)])
                    .concat(colsTrans))
                .map(x => x.join(''))
                .join('');
        }
    }
 
    
    let xs = [0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37,
        84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75,
        185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13,
        270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37,
        354.38
    ];
 
    
    
    
    
    
 
    return compassTable(5, xs); 
})();"
"function bitwise(a, b){
   alert(strv + (a & b));
   alert(strv+ (a | b));
   alert(strv+ (a ^ b));
   alert(strv + ~a);
   alert(strv + (a << b)); 
   alert(strv + (a >> b)); 
   alert(strv + (a >>> b)); 
}"
"//String creation
var str='';
//or 
str2=new String();
 
 
//String assignment
str=strv;
//or
str2=', Hey there'; //can use "" or '
str=str+str2;//concantenates
//string deletion
delete str2;//this will return true or false, true when it has been successfully deleted, it shouldn't/won't work when the variable has been declared with the keyword 'var', you don't have to initialize variables with the var keyword in JavaScript, but when you do, you cannot 'delete' them. However JavaScript garbage collects, so when the function returns, the variable declared on the function is erased.
 
//String comparison
str!==strv; //!== not equal-> returns true there's also !===
str==strv; //returns true
//compares 'byte' by 'byte'
strv>strv; //returns true, when using > or < operators it converts the string to an array and evalues the first index that is higher than another. (using unicode values) in this case 'Z' char code is 90 (decimal) and 'A' char code is 65, therefore making one string strv than the other.
 
//String cloning and copying
string=str;//Strings are immutable therefore when you assign a string to a variable another one is created. So for two variables to have the 'same' string you have to add that string to an object, and get/set the string from that object
 
//Check if a string is empty
Boolean(''); //returns false
''[0]; //returns undefined
''.charCodeAt(); //returns NaN
''==0; //returns true 
''===0; //returns false
''==false; //returns true
 
//Append byte to String
str+=""40"";//using + operator before the equal sign on a string makes it equal to str=str+strv
 
//Extract a substring from a string
//str is strv
str.substr(3); //returns strv
str.substr(-5); //returns strv negative values just go to the end
str.substr(7,9); //returns strv index of 7 + 9 characters after the 7
str.substring(3); //same as substr
str.substring(-5); //negative values don't work on substring same as substr(0)
str.substring(7,9); //returns strv that is, whatever is between index 7 and index 9, same as substring(9,7)
 
//Replace every occurence of x byte with another string
str3=strv;
str3.replace(/,/g,'') //Regex ,returns the same string with the , replaced by \n 
str4=str3.replace(/./g,function(index){//it also supports callback functions, the function will be called when a match has been found..
return index==','?'':index;//returns replacement
})
 
//Join Strings
[str,strv,str3].join(strv/*this is the character that will glue the strings*/)//we can join an array of strings
str3+str4; 
str.concat('',str4); //concantenate them"
"function bline(x0, y0, x1, y1) {
 
  var dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  var dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1; 
  var err = (dx>dy ? dx : -dy)/2;
 
  while (true) {
    setPixel(x0,y0);
    if (x0 === x1 && y0 === y1) break;
    var e2 = err;
    if (e2 > -dx) { err -= dy; x0 += sx; }
    if (e2 < dy) { err += dx; y0 += sy; }
  }
}"
"function binary_search_recursive(a, value, lo, hi) {
  if (hi < lo) { return null; }
 
  var mid = Math.floor((lo + hi) / 2);
 
  if (a[mid] > value) {
    return binary_search_recursive(a, value, lo, mid - 1);
  }
  if (a[mid] < value) {
    return binary_search_recursive(a, value, mid + 1, hi);
  }
  return mid;
}function binary_search_iterative(a, value) {
  var mid, lo = 0,
      hi = a.length - 1;
 
  while (lo <= hi) {
    mid = Math.floor((lo + hi) / 2);
 
    if (a[mid] > value) {
      hi = mid - 1;
    } else if (a[mid] < value) {
      lo = mid + 1;
    } else {
      return mid;
    }
  }
  return null;
}"
"(function(){//ECMAScript doesn't have an internal base64 function or method, so we have to do it ourselves, isn't that exciting?
    function stringToArrayUnicode(str){for(var i=0,l=str.length,n=[];i<l;i++)n.push(str.charCodeAt(i));return n;}
    function generateOnesByLength(n){//Attempts to generate a binary number full of ones given a length.. they don't redefine each other that much.
        var x=0;
        for(var i=0;i<n;i++){
            x<<=1;x|=1;//I don't know if this is performant faster than Math.pow but seriously I don't think I'll need Math.pow, do I?
        }
        return x;
    }
    function paf(_offset,_offsetlength,_number){//I don't have any name for this function at ALL, but I will explain what it does, it takes an offset, a number and returns the base64 number and the offset of the next number.
        //the next function will be used to extract the offset of the number..
        var a=6-_offsetlength,b=8-a;//Oh god, 8 is HARDCODED! Because 8 is the number of bits in a byte!!!
        //And 6 is the mini-byte used by wikipedia base64 article... at least on 2013.
        //I imagine this code being read in 2432 or something, that probably won't happen..
        return [_number&generateOnesByLength(b),b,(_offset<<a)|(_number>>b)];//offset & offsetlength & number 
    }
    function toBase64(uint8array){//of bits, each value may not have more than 255 bits... //a normal strv should work fine too..
        //From 0x29 to 0x5a plus from 0x61 to 0x7A AND from 0x30 to 0x39
        //Will not report errors if an array index has a value bigger than 255.. it will likely fail.
        var a=[],i,output=[];
        for(i=0x41;i<=0x5a;i++){//A-Z
            a.push(String.fromCharCode(i));
        }
        for(i=0x61;i<=0x7A;i++){//a-z
            a.push(String.fromCharCode(i));
        }
        for(i=0x30;i<=0x39;i++){//0-9
            a.push(String.fromCharCode(i));
        }
        a.push('+','/');
        var offset=0,offsetLength=0,x;
        for(var i=0,l=uint8array.length;i<l;i++){
            if(offsetLength==6){//if offsetlength is 6 that means that a whole offset is occupying the space of a byte, can you believe it.
                offsetLength=0;
                output.push(a[offset]);
                offset=0;
                i--;
                continue;
            }
            x=paf(offset,offsetLength,uint8array[i]);
            offset=x[0];
            offsetLength=x[1];
            output.push(a[x[2]]);
        }
        if(offsetLength){
            if(offsetLength==6){
                output.push(a[offset]);
            }else{
                var y=(6-offsetLength)/2;
                x=paf(offset,offsetLength,0);
                offset=x[0];
                output.push(a[x[2]]);
                switch (y){
                    case 2:output.push('=');//This thingy right here, you know.. the offsets also, no break statement;
                    case 1:output.push('=');break;
                }
            }
        }
        return output.join('');//You can change it so the result is an array instead!!!!
    }
 
    //Usage
 
    return toBase64(stringToArrayUnicode(strv))
}())window.btoa(strv);//Will throw error if any unicode character is larger than 255 it's counterpart it's the window.atobvar http = require('http');
var options = {
  host: 'rosettacode.org',
  path: '/favicon.ico'
};
callback = function(response) {
  var str = '';
  response.on('data', function (chunk) {
    str += chunk;
  });
  response.on('end', function () {
    console.log(new Buffer(str).toString('base64'));//Base64 encoding right here.
  });
}
 "
" 

var canvas = document.createElement(strv),
    ctx = canvas.getContext(strv),
    width = 400, height = 400;
 
ctx.canvas.width = width;
ctx.canvas.height = height;
 

document.body.appendChild(canvas);
 

var img = document.createElement(strv);
img.onload = function(){
    
    ctx.drawImage(img, 0, 0);
};
img.src = strv;
 

ctx.fillStyle = strv;
ctx.fillRect(0, 0, width, height);
 



ctx.fillStyle = strv;
ctx.fillRect(width / 2, height / 2, 1, 1);
 "
"function toBinary(number) {
  return new Number(number).toString(2);
}
var demoValues = [5, 50, 9000];
for (var i=0; i<demoValues.length; ++i) {
  print(toBinary(demoValues[i])); 
}console.log(
 
    [5, 50, 9000].map(function (n) {
        return (n).toString(2);
    }).join('')
 
)println(5.binary)
println(50.binary)
println(9000.binary)"
" 

//6/17/16 aev
function pBarnsleyFern(canvasId,lim) {
  
  var canvas = document.getElementById(canvasId);
  var ctx = canvas.getContext(strv);
  var w = canvas.width;
  var h = canvas.height;
  var x=0.,y=0.,xw=0.,yw=0.,r;
  
  function randgp(max) {return Math.floor(Math.random()*max)}
  
  ctx.fillStyle=strv; ctx.fillRect(0,0,w,h);
  
  for(var i=0; i<lim; i++) {
    r=randgp(100);
    if (r<=1) {xw=0;yw=0.16*y;}
    else if (r<=8) {xw=0.2*x-0.26*y;yw=0.23*x+0.22*y+1.6;}
    else if (r<=15) {xw=-0.15*x+0.28*y;yw=0.26*x+0.24*y+0.44;}
    else {xw=0.85*x+0.04*y;yw=-0.04*x+0.85*y+1.6;}
    x=xw;y=yw; ctx.fillStyle=strv; ctx.fillRect(x*50+260,-y*50+540,1,1);
  }//fend i
}
 "
"

//


  n = 519
 


// % is for modulo operation
// != is for strv
  while ( ((n * n) % 1000000) != 269696 )
    n = n + 1
 



  console.log(n)
 "
"function raze(a) { 
    var r= [];
    for (var j= 0; j<a.length; j++)
        for (var k= 0; k<a[j].length; k++)  r.push(a[j][k]);
    return r;
}
function shuffle(y) {
    var len= y.length;
    for (var j= 0; j < len; j++) {
        var i= Math.floor(Math.random()*len);
        var t= y[i];
        y[i]= y[j];
        y[j]= t;
    }
    return y;
}
function bestShuf(txt) {
    var chs= txt.split('');
    var gr= {};
    var mx= 0;
    for (var j= 0; j<chs.length; j++) {
        var ch= chs[j];
        if (null == gr[ch])  gr[ch]= [];
        gr[ch].push(j);
        if (mx < gr[ch].length)  mx++;
    }
    var inds= [];
    for (var ch in gr)  inds.push(shuffle(gr[ch]));
    var ndx= raze(inds);
    var cycles= [];
    for (var k= 0; k < mx; k++)  cycles[k]= [];
    for (var j= 0; j<chs.length; j++)  cycles[j%mx].push(ndx[j]);
    var ref= raze(cycles);
    for (var k= 0; k < mx; k++)  cycles[k].push(cycles[k].shift());
    var prm= raze(cycles);
    var shf= [];
    for (var j= 0; j<chs.length; j++)  shf[ref[j]]= chs[prm[j]];
    return shf.join('');
}
 
function disp(ex) {
    var r= bestShuf(ex);
    var n= 0;
    for (var j= 0; j<ex.length; j++)
        n+= ex.substr(j, 1) == r.substr(j,1) ?1 :0;
    return ex+', '+r+', ('+n+')';
}"
"function simple_moving_averager(period) {
    var nums = [];
    return function(num) {
        nums.push(num);
        if (nums.length > period)
            nums.splice(0,1);  
        var sum = 0;
        for (var i in nums)
            sum += nums[i];
        var n = period;
        if (nums.length < period)
            n = nums.length;
        return(sum/n);
    }
}
 
var sma3 = simple_moving_averager(3);
var sma5 = simple_moving_averager(5);
var data = [1,2,3,4,5,5,4,3,2,1];
for (var i in data) {
    var n = data[i];
    
    WScript.Echo(strv + n + strv + sma3(n) + strv + sma5(n));
}
Array.prototype.simpleSMA=function(N) {
return this.map(
  function(el,index, _arr) { 
      return _arr.filter(
      function(x2,i2) { 
        return i2 <= index && i2 > index - N;
        })
      .reduce(
      function(current, last, index, arr){ 
        return (current + last); 
        })/index || 1;
      }); 
};
 
g=[0,1,2,3,4,5,6,7,8,9,10];
console.log(g.simpleSMA(3));
console.log(g.simpleSMA(5));
console.log(g.simpleSMA(g.length));"
"function root_mean_square(ary) {
    var sum_of_squares = ary.reduce(function(s,x) {return (s + x*x)}, 0);
    return Math.sqrt(sum_of_squares / ary.length);
}
 
print( root_mean_square([1,2,3,4,5,6,7,8,9,10]) ); (() => {
    'use strict';
 
 
    
    const rootMeanSquare = xs => 
       Math.sqrt(
            xs.reduce(
                (a, x) => (a + x * x),
                0
           ) / xs.length
        );
 
 
    return rootMeanSquare([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
 
     
})();"
"function shuffle(str) {
  var a = str.split(''), b, c = a.length, d
  while (c) b = Math.random() * c-- | 0, d = a[c], a[c] = a[b], a[b] = d
  return a.join('')
}
 
function isBalanced(str) {
  var a = str, b
  do { b = a, a = a.replace(/\[\]/g, '') } while (a != b)
  return !a
}
 
var M = 20
while (M-- > 0) {
  var N = Math.random() * 10 | 0, bs = shuffle('['.repeat(N) + ']'.repeat(N))
  console.log('""' + bs + '"" is ' + (isBalanced(bs) ? '' : 'un') + 'balanced')
}(() => {
    'use strict';
 
    
    let randomBrackets = n => range(1, n)
        .map(() => Math.random() < 0.5 ? '[' : ']')
        .join('');
 
    
    let imbalance = strBrackets => {
 
        
        
 
        
        let errorIndex = (xs, iDepth, iIndex) => {
            if (xs.length > 0) {
                let tail = xs.slice(1),
                    iNext = iDepth + (xs[0] === '[' ? 1 : -1);
 
                if (iNext < 0) return iIndex; 
                else return tail.length ? errorIndex(
                        tail, iNext, iIndex + 1
                    ) : iNext === 0 ? -1 : iIndex; 
 
            } else return iDepth === 0 ? -1 : iIndex;
        };
 
        return errorIndex(strBrackets.split(''), 0, 0);
    };
 
 
    
 
    
    let range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);
 
    
 
    let lngPairs = 6,
        strPad = Array(lngPairs * 2 + 4)
        .join(' ');
 
    return range(0, lngPairs)
        .map(n => {
            let w = n * 2,
                s = randomBrackets(w),
                i = imbalance(s),
                blnOK = i === -1;
 
            return strv + s + strv + strPad.slice(w + 2) +
                (blnOK ? 'OK' : 'problem') +
                (blnOK ? '' : '' + Array(i + 2)
                    .join(' ') + '^');
        })
        .join('');
})();
 "
"<title> AudioAlarm </title>
<script>
    var a=prompt(strv, strv);
    var b=prompt(strv, strv);
    document.write(strv+a+strv+b+strv)
</script>"
"function mode(ary) {
    var counter = {};
    var mode = [];
    var max = 0;
    for (var i in ary) {
        if (!(ary[i] in counter))
            counter[ary[i]] = 0;
        counter[ary[i]]++;
 
        if (counter[ary[i]] == max) 
            mode.push(ary[i]);
        else if (counter[ary[i]] > max) {
            max = counter[ary[i]];
            mode = [ary[i]];
        }
    }
    return mode; 
}
 
mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);  
mode([1, 2, 4, 4, 1]);  "
"function median(ary) {
    if (ary.length == 0)
        return null;
    ary.sort(function (a,b){return a - b})
    var mid = Math.floor(ary.length / 2);
    if ((ary.length % 2) == 1)  
        return ary[mid];
    else 
        return (ary[mid - 1] + ary[mid]) / 2;
}
 
median([]);   
median([5,3,4]);  
median([5,4,2,3]);  
median([3,4,1,-8.4,7.2,4,1,1.2]);  (() => {
    'use strict';
 
    
    function median(xs) {
        
        let nth = (xxs, n) => {
                if (xxs.length > 0) {
                    let [x, xs] = uncons(xxs), 
                        [ys, zs] = partition(y => y < x, xs),
                        k = ys.length;
 
                    return k === n ? x : (
                        k > n ? nth(ys, n) : nth(zs, n - k - 1)
                    );
                } else return undefined;
            },
            n = xs.length;
 
        return even(n) ? (
            (nth(xs, div(n, 2)) + nth(xs, div(n, 2) - 1)) / 2
        ) : nth(xs, div(n, 2));
    }
 
 
 
    
 
    
    let partition = (p, xs) =>
        xs.reduce((a, x) =>
            p(x) ? [a[0].concat(x), a[1]] : [a[0], a[1].concat(x)], [
                [],
                []
            ]),
 
        
        uncons = xs => xs.length ? [xs[0], xs.slice(1)] : undefined,
 
        
        even = n => n % 2 === 0,
 
        
        div = (x, y) => Math.floor(x / y);
 
    return [
        [],
        [5, 3, 4],
        [5, 4, 2, 3],
        [3, 4, 1, -8.4, 7.2, 4, 1, 1.2]
    ].map(median);
})();[
  null,
  4,
  3.5,
  2.1
]"
"(function () {
    'use strict';
 
    
    function arithmetic_mean(ns) {
        return (
            ns.reduce( 
                function (sum, n) {
                    return (sum + n);
                },
                0
            ) / ns.length
        );
    }
 
    
    function geometric_mean(ns) {
        return Math.pow(
            ns.reduce( 
                function (product, n) {
                    return (product * n);
                },
                1
            ),
            1 / ns.length
        );
    }
 
    
    function harmonic_mean(ns) {
        return (
            ns.length / ns.reduce( 
                function (invSum, n) {
                    return (invSum + (1 / n));
                },
                0
            )
        );
    }
 
    var values = [arithmetic_mean, geometric_mean, harmonic_mean]
        .map(function (f) {
            return f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        }),
        mean = {
            Arithmetic: values[0], 
            Geometric: values[1], 
            Harmonic: values[2] 
        }
 
    return JSON.stringify({
        values: mean,
        test: strv +
            (
                mean.Arithmetic >= mean.Geometric &&
                mean.Geometric >= mean.Harmonic ? strv : strv
            )
    }, null, 2);
 
})();
 {
  strv: {
    strv: 5.5,
    strv: 4.528728688116765,
    strv: 3.414171521474055
  },
  strv: strv
}(() => {
 
    
    const arithmeticMean = xs =>
        xs.reduce((sum, n) => sum + n, 0) / xs.length;
 
    
    const geometricMean = xs =>
        Math.pow(xs.reduce((product, x) => product * x, 1), 1 / xs.length);
 
    
    const harmonicMean = xs =>
        xs.length / xs.reduce((invSum, n) => invSum + (1 / n), 0);
 
 
    
    const values = [arithmeticMean, geometricMean, harmonicMean]
        .map(f => f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])),
 
        mean = {
            Arithmetic: values[0],
            Geometric: values[1],
            Harmonic: values[2]
        };
 
    return JSON.stringify({
        values: mean,
        test: `is A >= G >= H ? ${mean.Arithmetic >= mean.Geometric &&
            mean.Geometric >= mean.Harmonic ? strv : strv}`
    }, null, 2);
 
})();{
  strv: {
    strv: 5.5,
    strv: 4.528728688116765,
    strv: 3.414171521474055
  },
  strv: strv
}"
"<script>
var j = prompt(strv, strv);
for(i=0; i<j; i++) {
    document.write(strv)
}
</script>"
"function mean(array)
{
 var sum = 0, i;
 for (i = 0; i < array.length; i++)
 {
  sum += array[i];
 }
  return array.length ? sum / array.length : 0;
}
 
alert( mean( [1,2,3,4,5] ) );   
alert( mean( [] ) );            function mean(array) {
    var sum = 0;
    array.forEach(function(value){
        sum += value;
        });
    return array.length ? sum / array.length : 0;
    }
 
alert( mean( [1,2,3,4,5] ) );   function mean(array) {
    return !array.length ? 0
        : array.reduce(function(pre, cur, i) {
            return (pre * i + cur) / (i + 1);
            });
    }
 
alert( mean( [1,2,3,4,5] ) );   
alert( mean( [] ) );            
 Array.prototype.mean = function() {
    return !this.length ? 0
        : this.reduce(function(pre, cur, i) {
            return (pre * i + cur) / (i + 1);
            });
    }
 
alert( [1,2,3,4,5].mean() );   
alert( [].mean() );            
 function mean(a)
{
 return a.length ? Functional.reduce('+', 0, a) / a.length : 0;
}(sample => {
 
    
    let mean = lst => {
        let lng = lst.length;
 
        return lng ? (
            lst.reduce((a, b) => a + b, 0) / lng
        ) : NaN;
    };
 
    return mean(sample);
 
})([1, 2, 3, 4, 5, 6, 7, 8, 9]);5"
"var myhash = {}; //a new, empty object
myhash[strv] = 3;
myhash.world = 6; //obj.name is equivalent to obj[strv] for certain values of name
myhash[strv] = 9;
 
//iterate using for..in loop
for (var key in myhash) {
  //ensure key is in object and not in prototype
  if (myhash.hasOwnProperty(key)) {
    console.log(strv + key + '. Value is: ' + myhash[key]);
  }
}
 
//iterate using ES5.1 Object.keys() and Array.prototype.Map()
var keys = Object.keys(); //get Array of object keys (doesn't get prototype keys)
keys.map(function (key) {
  console.log(strv + key + '. Value is: ' + myhash[key]);
});"
"
var emptyMap = new HashMap<String, Integer>()
 

var map = {strv->50, strv->40, strv->30, strv->38}
 

map[strv] = 51
 

var x = map[strv]
 

map.remove(strv)
 

for(entry in map.entrySet()) {
  print(strv) 
}
 

map.eachKey(\ k ->print(map[k]))
map.eachValue(\ v ->print(v))
map.eachKeyAndValue(\ k, v -> print(strv))
var filtered = map.filterByValues(\ v ->v < 50)
 

class Person {
  var name: String
  var age: int 
}

var scott = new Person()
scott[strv] = strv
scott[strv] = 29var assoc = {};
 
assoc['foo'] = 'bar';
assoc['another-key'] = 3;
 

assoc.thirdKey = 'we can also do this!';
assoc[2] = strv;
 
//using JavaScript's object literal notation
var assoc = {
  foo: 'bar',
  'another-key': 3 //the key can either be enclosed by quotes or not
};
 
//iterating keys
for (var key in assoc) {
  
  if (assoc.hasOwnProperty(key)) {
    alert('key:""' + key + 'strv' + assoc[key] + '""');
  }
}var map = new Map(),
    fn = function () {},
    obj = {};
 
map.set(fn, 123);
map.set(obj, 'abc');
map.set('key', 'val');
map.set(3, x => x + x);
 
map.get(fn); //=> 123
map.get(function () {}); //=> undefined because not the same function
map.get(obj); //=> 'abc'
map.get({}); //=> undefined because not the same object
map.get('key'); //=> 'val'
map.get(3); //=> (x => x + x)
 
map.size; //=> 4
 
//iterating using ES6 for..of syntax
for (var key of map.keys()) {
  console.log(key + ' => ' + map.get(key));
}"
"function sum(a) {
    s = 0;
    for (var i in a) s += a[i];
    return s;
} 
 
function degToRad(a) {
    return Math.PI/180*a;
}
 
function meanAngleDeg(a) {
    return 180/Math.PI*Math.atan2(sum(a.map(degToRad).map(Math.sin))/a.length,sum(a.map(degToRad).map(Math.cos))/a.length);
}
 
var a = [350, 10], b = [90, 180, 270, 360],  c =[10, 20, 30];
console.log(meanAngleDeg(a));
console.log(meanAngleDeg(b));
console.log(meanAngleDeg(c));"
"console.log(['apple', 'orange'].length);function last(lst) {
    return lst[lst.length - 1];
}function last(lst) {
    return lst.reduce(function (a, x) {
        return x;
    }, null);
}function last(list, defaultValue) {
   return list.length ?list[list.length-1] :defaultValue;
}function last(list, defaultValue) {
    return list.slice(-1)[0] || defaultValue;
}"
"var a = parseInt(get_input(strv), 10);
var b = parseInt(get_input(strv), 10);
 
WScript.Echo(strv + a);
WScript.Echo(strv + b);
WScript.Echo(strv        + (a + b));
WScript.Echo(strv + (a - b));
WScript.Echo(strv    + (a * b));
WScript.Echo(strv   + (a / b | 0)); 
WScript.Echo(strv  + (a % b));
 
function get_input(prompt) {
    output(prompt);
    try {
        return WScript.StdIn.readLine();
    } catch(e) {
        return readline();
    }
}
function output(prompt) {
    try {
        WScript.Echo(prompt);
    } catch(e) {
        print(prompt);
    }
}"
"
function Rational(numerator, denominator) {
    if (denominator === undefined)
        denominator = 1;
    else if (denominator == 0)
        throw strv;
 
    this.numer = numerator;
    if (this.numer == 0)
        this.denom = 1;
    else
        this.denom = denominator;
 
    this.normalize();
}
 

Rational.prototype.numerator   = function() {return this.numer};
Rational.prototype.denominator = function() {return this.denom};
 

Rational.prototype.dup = function() {
    return new Rational(this.numerator(), this.denominator()); 
};
 

Rational.prototype.toString = function() {
    if (this.denominator() == 1) {
        return this.numerator().toString();
    } else {
        
        return this.numerator() + '/' + this.denominator()
    }
};
Rational.prototype.toFloat  = function() {return eval(this.toString())}
Rational.prototype.toInt    = function() {return Math.floor(this.toFloat())};
 

Rational.prototype.normalize = function() {
    
    var a=Math.abs(this.numerator()), b=Math.abs(this.denominator())
    while (b != 0) {
        var tmp = a;
        a = b;
        b = tmp % b;
    }
    
 
    this.numer /= a;
    this.denom /= a;
    if (this.denom < 0) {
        this.numer *= -1;
        this.denom *= -1;
    }
    return this;
}
 


Rational.prototype.abs = function() {
    return new Rational(Math.abs(this.numerator()), this.denominator());
};
 


Rational.prototype.inv = function() {
    return new Rational(this.denominator(), this.numerator());
};
 
//

 

Rational.prototype.add = function() {
    for (var i = 0; i < arguments.length; i++) {
        this.numer = this.numer * arguments[i].denominator() + this.denom * arguments[i].numerator();
        this.denom = this.denom * arguments[i].denominator();
    }
    return this.normalize();
};
 

Rational.prototype.subtract = function() {
    for (var i = 0; i < arguments.length; i++) {
        this.numer = this.numer * arguments[i].denominator() - this.denom * arguments[i].numerator();
        this.denom = this.denom * arguments[i].denominator();
    }
    return this.normalize();
};
 


Rational.prototype.neg = function() {
    return (new Rational(0)).subtract(this);
};
 

Rational.prototype.multiply = function() {
    for (var i = 0; i < arguments.length; i++) {
        this.numer *= arguments[i].numerator();
        this.denom *= arguments[i].denominator();
    }
    return this.normalize();
};
 

Rational.prototype.divide = function(rat) {
    return this.multiply(rat.inv());
}
 
 


Rational.prototype.inc = function() {
    this.numer += this.denominator();
    return this.normalize();
}
 


Rational.prototype.dec = function() {
    this.numer -= this.denominator();
    return this.normalize();
}
 
//

 
Rational.prototype.isZero = function() {
    return (this.numerator() == 0);
}
Rational.prototype.isPositive = function() {
    return (this.numerator() > 0);
}
Rational.prototype.isNegative = function() {
    return (this.numerator() < 0);
}
 
Rational.prototype.eq = function(rat) {
    return this.dup().subtract(rat).isZero();
}
Rational.prototype.ne = function(rat) {
    return !(this.eq(rat));
}
Rational.prototype.lt = function(rat) {
    return this.dup().subtract(rat).isNegative();
}
Rational.prototype.gt = function(rat) {
    return this.dup().subtract(rat).isPositive();
}
Rational.prototype.le = function(rat) {
    return !(this.gt(rat));
}
Rational.prototype.ge = function(rat) {
    return !(this.lt(rat));
}function assert(cond, msg) { if (!cond) throw msg; }
 
print('testing')
var a, b, c, d, e, f;
 
//test creation
a = new Rational(0); assert(a.toString() == strv, strv)
a = new Rational(2); assert(a.toString() == strv, strv)
a = new Rational(1,2); assert(a.toString() == strv, strv)
b = new Rational(2,-12); assert(b.toString() == strv, strv)
f = new Rational(0,9)
 
a = new Rational(1,3)
b = new Rational(1,2)
c = new Rational(1,3)
 
assert(!(a.eq(b)), strv)
assert(a.eq(c), strv)
assert(a.ne(b), strv)
assert(!(a.ne(c)), strv)
assert(a.lt(b), strv)
assert(!(b.lt(a)), strv)
assert(!(a.lt(c)), strv)
assert(!(a.gt(b)), strv)
assert(b.gt(a), strv)
assert(!(a.gt(c)), strv)
 
assert(a.le(b), strv)
assert(!(b.le(a)), strv)
assert(a.le(c), strv)
assert(!(a.ge(b)), strv)
assert(b.ge(a), strv)
assert(a.ge(c), strv)
 
a = new Rational(1,2)
b = new Rational(1,6)
a.add(b); assert(a.eq(new Rational(2,3)), strv)
c = a.neg(); assert(a.eq(new Rational(2,3)), strv)
             assert(c.eq(new Rational(2,-3)), strv)
d = c.abs(); assert(c.eq(new Rational(-2,3)), strv)
             assert(d.eq(new Rational(2,3)), strv)
b.subtract(a); assert(b.eq(new Rational(-1,2)), strv)
 
c = a.neg().abs(); assert(c.eq(a), strv)
c = (new Rational(-1,3)).inv(); assert(c.toString() == '-3', strv)
try {
    e = f.inv();
    throw strv +f + '.inv() = ' + e
} catch (e) {
    assert(e == strv, strv)
}
 
b = new Rational(1,6)
b.add(new Rational(2,3), new Rational(4,2)); assert(b.toString() == strv, strv);
 
a = new Rational(1,3);
b = new Rational(1,6)
c = new Rational(5,6);
d = new Rational(1/5);
e = new Rational(2);
f = new Rational(0,9);
 
 
assert(c.dup().multiply(d).eq(b), strv)
assert(c.dup().multiply(d,e).eq(a), strv)
assert(c.dup().multiply(d,e,f).eq(f), strv)
 
c.divide(new Rational(5));
assert(c.eq(b), strv)
 
try {
    e = c.divide(f)
    throw strv + c + strv + f + '= ' + e
} catch (e) {
    assert(e == strv, strv)
}
 
 
print('all tests passed');function factors(num) {
    var factors = new Array();
    var sqrt = Math.floor(Math.sqrt(num)); 
    for (var i = 1; i <= sqrt; i++) {
        if (num % i == 0) {
            factors.push(i);
            if (num / i != i) 
                factors.push(num / i);
        }
    }
    factors.sort(function(a,b){return a-b});  
    return factors;
}
 
function isPerfect(n) {
    var sum = new Rational(0);
    var fctrs = factors(n);
    for (var i = 0; i < fctrs.length; i++) 
        sum.add(new Rational(1, fctrs[i]));
 
    
    return sum.toFloat() == 2.0;
}
 

for (var n = 2; n < Math.pow(2,19); n++)
    if (isPerfect(n))
        print(strv + n);
 

var n = Math.pow(2,12) * (Math.pow(2,13) - 1);
if (isPerfect(n))
    print(strv + n);"
"var a = [1,2,3],
    b = [4,5,6],
    c = a.concat(b); //=> [1,2,3,4,5,6](function () {
    'use strict';
 
    
    function concat(xs) {
        return [].concat.apply([], xs);
    }
 
 
   return concat(
      [[strv, strv, strv], 
      [strv, strv, strv], 
      [strv, strv, strv]]
  );
 
})();"
"function agm(a0, g0) {
    var an = (a0 + g0) / 2,
        gn = Math.sqrt(a0 * g0);
    while (Math.abs(an - gn) > tolerance) {
        an = (an + gn) / 2, gn = Math.sqrt(an * gn)
    }
    return an;
}
 
agm(1, 1 / Math.sqrt(2));(() => {
    'use strict';
 
    
 
    
    let agm = (a, g) => {
            let abs = Math.abs,
                sqrt = Math.sqrt;
 
            return until(
                    m => abs(m.an - m.gn) < tolerance,
                    m => {
                        return {
                            an: (m.an + m.gn) / 2,
                            gn: sqrt(m.an * m.gn)
                        };
                    }, {
                        an: (a + g) / 2,
                        gn: sqrt(a * g)
                    }
                )
                .an;
        },
 
        
 
        
        until = (p, f, x) => {
            let v = x;
            while (!p(v)) v = f(v);
            return v;
        };
 
 
    
 
    let tolerance = 0.000001;
 
 
    return agm(1, 1 / Math.sqrt(2));
 
})();0.8472130848351929"
"
var myArray = new Array();
 

var myArray1 = new Array(5);
 

var myArray2 = new Array(strv,strv);
 

var myArray3 = [strv, strv];
 

myArray3[2] = 5;
 
var x = myArray[2] + myArray.length;   
 

myArray3.push('Test');
 

var y = [0,1,,];  
 "
"function Complex(r, i) {
	this.r = r;
	this.i = i;
}
 
Complex.add = function() {
	var num = arguments[0];
 
	for(var i = 1, ilim = arguments.length; i < ilim; i += 1){
		num.r += arguments[i].r;
		num.i += arguments[i].i;
	}
 
	return num;
}
 
Complex.multiply = function() {
	var num = arguments[0];
 
	for(var i = 1, ilim = arguments.length; i < ilim; i += 1){
		num.r = (num.r * arguments[i].r) - (num.i * arguments[i].i);
		num.i = (num.i * arguments[i].r) - (num.r * arguments[i].i);
	}
 
	return num;
}
 
Complex.negate = function (z) {
	return new Complex(-1*z.r, -1*z.i);
}
 
Complex.invert = function(z) {
	var denom = Math.pow(z.r,2) + Math.pow(z.i,2);
	return new Complex(z.r/denom, -1*z.i/denom);
}
 
Complex.conjugate = function(z) {
	return new Complex(z.r, -1*z.i);
}
 

 
 
Complex.prototype.toString = function() {
	return this.r === 0 && this.i === 0
          ? strv
          : (this.r !== 0 ? this.r : strv) 
          + ((this.r !== 0 || this.i < 0) && this.i !== 0 
              ? (this.i > 0 ? strv : strv) 
              : strv ) + ( this.i !== 0 ? Math.abs(this.i) + strv : strv ); 
}
 
Complex.prototype.getMod = function() {
	return Math.sqrt( Math.pow(this.r,2) , Math.pow(this.i,2) )
}"
"function evalArithmeticExp(s) {
  s = s.replace(/\s/g,'').replace(/^\+/,'');
  var rePara = /\([^\(\)]*\)/;
  var exp = s.match(rePara);
 
  while (exp = s.match(rePara)) {
    s = s.replace(exp[0], evalExp(exp[0]));
  }
  return evalExp(s);
 
  function evalExp(s) {
    s = s.replace(/[\(\)]/g,'');
    var reMD = /\d+\.?\d*\s*[\*\/]\s*[+-]?\d+\.?\d*/;
    var reM = /\*/;
    var reAS = /-?\d+\.?\d*\s*[\+-]\s*[+-]?\d+\.?\d*/;
    var reA  = /\d\+/;
    var exp;
 
    while (exp = s.match(reMD)) {
      s = exp[0].match(reM)? s.replace(exp[0], multiply(exp[0])) : s.replace(exp[0], divide(exp[0]));
    }
 
    while (exp = s.match(reAS)) {
      s = exp[0].match(reA)? s.replace(exp[0], add(exp[0])) : s.replace(exp[0], subtract(exp[0]));
    }
 
    return '' + s;
 
    function multiply(s, b) {
      b = s.split('*');
      return b[0] * b[1];
    }
 
    function divide(s, b) {
      b = s.split('/');
      return b[0] / b[1];
    }
 
    function add(s, b) {
      s = s.replace(/^\+/,'').replace(/\++/,'+');
      b = s.split('+');
      return Number(b[0]) + Number(b[1]);
    }
 
    function subtract(s, b) {
      s = s.replace(/\+-|-\+/g,'-');
 
      if (s.match(/--/)) {
        return add(s.replace(/--/,'+'));
      }
      b = s.split('-');
      return b.length == 3? -1 * b[1] - b[2] : b[0] - b[1];
    }
  }
}"
"function fibo(n) {
  if (n < 0) { throw strv; }
 
  return (function(n) {
    return (n < 2) ? 1 : arguments.callee(n-1) + arguments.callee(n-2);
  })(n);
}function fibo(n) {
  if (n < 0) { throw strv; }
 
  return (function fib(n) {
    return (n < 2) ? 1 : fib(n-1) + fib(n-2);
  })(n);
}"
"function map(a, func) {
  var ret = [];
  for (var i = 0; i < a.length; i++) {
    ret[i] = func(a[i]);
  }
  return ret;
}
 
map([1, 2, 3, 4, 5], function(v) { return v * v; });[1, 2, 3, 4, 5].map(function(v) { return v * v; });[1, 2, 3, 4, 5].map(v => v * v);var a = [1, 2, 3, 4, 5];
a.map(function(v) { return v * v; })
 var a = [1, 2, 3, 4, 5];
a.map( :v: v*v );
 "
"<html><head>
  <title>Pendulum</title>
</head><body style=strv>
 
<canvas id=strv width=strv height=strv>
  <p>Sorry, your browser does not support the &lt;canvas&gt; used to display the pendulum animation.</p>
</canvas>
<script>
  function PendulumSim(length_m, gravity_mps2, initialAngle_rad, timestep_ms, callback) {
    var velocity = 0;
    var angle = initialAngle_rad;
    var k = -gravity_mps2/length_m;
    var timestep_s = timestep_ms / 1000;
    return setInterval(function () {
      var acceleration = k * Math.sin(angle);
      velocity += acceleration * timestep_s;
      angle    += velocity     * timestep_s;
      callback(angle);
    }, timestep_ms);
  }
 
  var canvas = document.getElementById('canvas');
  var context = canvas.getContext('2d');
  var prev=0;
  var sim = PendulumSim(1, 9.80665, Math.PI*99/100, 10, function (angle) {
    var rPend = Math.min(canvas.width, canvas.height) * 0.47;
    var rBall = Math.min(canvas.width, canvas.height) * 0.02;
    var rBar = Math.min(canvas.width, canvas.height) * 0.005;
    var ballX = Math.sin(angle) * rPend;
    var ballY = Math.cos(angle) * rPend;
 
    context.fillStyle = strv;
    context.globalCompositeOperation = strv;
    context.fillRect(0, 0, canvas.width, canvas.height);
 
    context.fillStyle = strv;
    context.strokeStyle = strv+Math.max(0,1-Math.abs(prev-angle)*10)+strv;
    context.globalCompositeOperation = strv;
 
    context.save();
      context.translate(canvas.width/2, canvas.height/2);
      context.rotate(angle);
 
      context.beginPath();
      context.rect(-rBar, -rBar, rBar*2, rPend+rBar*2);
      context.fill();
      context.stroke();
 
      context.beginPath();
      context.arc(0, rPend, rBall, 0, Math.PI*2, false);
      context.fill();
      context.stroke();
    context.restore();
    prev=angle;
  });
</script>
 
</body></html><html>
	<head>
		<title>Swinging Pendulum Simulation</title>
	</head>
	<body><center>
		<svg id=strv height=strv width=strv>
			<line id=strv x1=strv y1=strv x2=strv y2=strv stroke=strv stroke-width=strv />
			<circle id=strv cx=strv cy=strv r=strv fill=strv />
		</svg>
		<br>
		Initial angle:<input id=strv type=strv min=strv max=strv onchange=strv/>(degrees)
		<br>
		<button type=strv onclick=strv>Start</button>
		<button type=strv onclick=strv>Stop</button>
		<button type=strv onclick=strv>Reset</button>
		<script>
			in_angle.value = 0;
			var cx = 150, cy = 50;
			var radius = 100; 
			var g = 981; 
			var angle = 0; 
			var vel = 0; 
			var dx = 0.02; 
			var acc, vel, penx, peny;
			var timerFunction = null;
			function stopAnimation() {
				if(timerFunction != null){
					clearInterval(timerFunction);
					timerFunction = null;
				}
			}
			function startAnimation() {
				if(!timerFunction) timerFunction = setInterval(swing, dx * 1000);
			}
			function swing(){
				acc = g * Math.cos(angle) * dx;
				vel += acc * dx;
				angle += vel * dx;
				setPenPos();
			}
			function setPenPos(){
				penx = cx + radius * Math.cos(angle);
				peny = cy + radius * Math.sin(angle);
				scene.getElementById(strv).setAttribute(strv, penx);
				scene.getElementById(strv).setAttribute(strv, peny);
				scene.getElementById(strv).setAttribute(strv, penx);
				scene.getElementById(strv).setAttribute(strv, peny);
			}
			function reset(){
				var val = parseInt(in_angle.value)*0.0174532925199;
				if (val) angle = val;
				else angle = 0;
				acc = 0;
				vel = 0;
				setPenPos();
			}
			function condReset(){
				if (!timerFunction) reset();
			}
		</script>
	</body>
</html>"
"function relativeBearing(b1Rad, b2Rad)
{
	b1y = Math.cos(b1Rad);
	b1x = Math.sin(b1Rad);
	b2y = Math.cos(b2Rad);
	b2x = Math.sin(b2Rad);
	crossp = b1y * b2x - b2y * b1x;
	dotp = b1x * b2x + b1y * b2y;
	if(crossp > 0.)
		return Math.acos(dotp);
	return -Math.acos(dotp);
}
 
function test()
{
	var deg2rad = 3.14159265/180.0;
	var rad2deg = 180.0/3.14159265;
	return ""Input in -180 to +180 range""
		+relativeBearing(20.0*deg2rad, 45.0*deg2rad)*rad2deg+""""
		+relativeBearing(-45.0*deg2rad, 45.0*deg2rad)*rad2deg+""""
		+relativeBearing(-85.0*deg2rad, 90.0*deg2rad)*rad2deg+""""
		+relativeBearing(-95.0*deg2rad, 90.0*deg2rad)*rad2deg+""""
		+relativeBearing(-45.0*deg2rad, 125.0*deg2rad)*rad2deg+""""
		+relativeBearing(-45.0*deg2rad, 145.0*deg2rad)*rad2deg+""""
 
		+relativeBearing(29.4803*deg2rad, -88.6381*deg2rad)*rad2deg+""""
		+relativeBearing(-78.3251*deg2rad, -159.036*deg2rad)*rad2deg+""""
 
		+ ""Input in wider range""
		+relativeBearing(-70099.74233810938*deg2rad, 29840.67437876723*deg2rad)*rad2deg+""""
		+relativeBearing(-165313.6666297357*deg2rad, 33693.9894517456*deg2rad)*rad2deg+""""
		+relativeBearing(1174.8380510598456*deg2rad, -154146.66490124757*deg2rad)*rad2deg+""""
		+relativeBearing(60175.77306795546*deg2rad, 42213.07192354373*deg2rad)*rad2deg+"""";
 
}(() => {
 
    
    const bearingDelta = (ar, br) => {
        const [ax, ay] = [sin(ar), cos(ar)], [bx, by] = [sin(br), cos(br)],
 
        
        sign = ((ay * bx) - (by * ax)) > 0 ? +1 : -1;
 
        
        return sign * acos((ax * bx) + (ay * by));
    };
 
    
    const [Pi, sin, cos, acos] = ['PI', 'sin', 'cos', 'acos']
    .map(k => Math[k]),
        degRad = x => Pi * x / 180.0,
        radDeg = x => 180.0 * x / Pi;
 
 
    
 
    
    const justifyRight = (n, cFiller, strText) =>
        n > strText.length ? (
            (cFiller.repeat(n) + strText)
            .slice(-n)
        ) : strText;
 
    
    const showMap = (da, db) =>
        justifyRight(6, ' ', `${da}° +`) +
        justifyRight(11, ' ', ` ${db}°  ->  `) +
        justifyRight(7, ' ', `${(radDeg(bearingDelta(degRad(da), degRad(db))))
            .toPrecision(4)}°`);
 
    return [
            [20, 45],
            [-45, 45],
            [-85, 90],
            [-95, 90],
            [-45, 125],
            [-45, 145]
        ].map(xy => showMap(...xy))
        .join('');
})();"
"<html> <head>
    <title>RC: Basic Animation</title>
    <script type=strv>
        function animate(id) {
            var element = document.getElementById(id);
            var textNode = element.childNodes[0]; 
 
            var text = textNode.data;
            var reverse = false;
 
            element.onclick = function () { reverse = !reverse; };
 
            setInterval(function () {
                if (reverse)
                    text = text.substring(1) + text[0];
                else
                    text = text[text.length - 1] + text.substring(0, text.length - 1);
                textNode.data = text;
            }, 100);
        }
    </script>
</head> <body onload=strv>
    <pre id=strv>Hello World! </pre>
</body> </html><svg xmlns=strv
     width=strv>
    <script type=strv>
        function animate(element) {
            var textNode = element.childNodes[0]; 
            var text = textNode.data;
            var reverse = false;
 
            element.onclick = function () { reverse = !reverse; };
 
            setInterval(function () {
                if (reverse)
                    text = text.substring(1) + text[0];
                else
                    text = text[text.length - 1] + text.substring(0, text.length - 1);
                textNode.data = text;
            }, 100);
        }
    </script>
 
    <rect width=strv/>
    <text x=strv>Hello World! </text>
</svg>"
"#!/usr/bin/env js
 
function main() {
    var wordList = read('unixdict.txt').split(/\s+/);
    var anagrams = findAnagrams(wordList);
    var derangedAnagrams = findDerangedAnagrams(anagrams);
    var longestPair = findLongestDerangedPair(derangedAnagrams);
    print(longestPair.join(' '));
 
}
 
function findLongestDerangedPair(danas) {
    var longestLen = danas[0][0].length;
    var longestPair = danas[0];
    for (var i in danas) {
        if (danas[i][0].length > longestLen) {
            longestLen = danas[i][0].length;
            longestPair = danas[i];
        }
    }
    return longestPair;
}
 
function findDerangedAnagrams(anagrams) {
    var deranged = [];
 
    function isDeranged(w1, w2) {
        for (var c = 0; c < w1.length; c++) {
            if (w1[c] == w2[c]) {
                return false;
            }
        }
        return true;
    }
 
    function findDeranged(anas) {
        for (var a = 0; a < anas.length; a++) {
            for (var b = a + 1; b < anas.length; b++) {
                if (isDeranged(anas[a], anas[b])) {
                    deranged.push([anas[a], anas[b]]);
                }   
            }
        }
    }
 
    for (var a in anagrams) {
        var anas = anagrams[a];
        findDeranged(anas);
    }
 
    return deranged;
}
 
function findAnagrams(wordList) {
    var anagrams = {};
 
    for (var wordNum in wordList) {
        var word = wordList[wordNum];
        var key = word.split('').sort().join('');
        if (!(key in anagrams)) {
            anagrams[key] = [];
        }
        anagrams[key].push(word);
    }
 
    for (var a in anagrams) {
        if (anagrams[a].length < 2) {
            delete(anagrams[a]);
        }
    }
 
    return anagrams;
}
 
main();
 
 <html><head><title>Intoxication</title></head>
<body><pre id='x'></pre>
<script type=strv>
 
function show(t) {
	var l = document.createTextNode(t + '');
	document.getElementById('x').appendChild(l);
}
 

var words = null;
var req = new XMLHttpRequest();
req.open('GET', 'file:///tmp/unixdict.txt', false);
req.send(null);
words = req.responseText.split('');
 
var idx = {};
for (var i = 0; i < words.length; i++) {
	var t = words[i].split('').sort().join('');
	if (idx[t]) idx[t].push(words[i]);
	else	    idx[t] = [words[i]];
}
 
var best = '';
var best_pair;
for (var i in idx) {
	if (i.length <= best.length) continue;
	if (idx[i].length == 1) continue;
 
	var a = idx[i], got = null;
	for (var j = 0, l1 = a[j]; j < a.length && !got; j++) {
		for (var k = j + 1, l2 = a[k]; k < a.length && !got; k++)
			for (var m = 0; m < l1.length || !(got = [l2]); m++)
				if (l1[m] == l2[m]) break;
		if (got) got.push(l1);
	}
 
	if (got) {
		best_pair = got;
		best = got[0];
	}
}
 
show(best_pair);
</script></body></html>"
"(function (max) {
 
    
    function properDivisors(n) {
        if (n < 2) return [];
        else {
            var rRoot = Math.sqrt(n),
                intRoot = Math.floor(rRoot),
 
                lows = range(1, intRoot).filter(function (x) {
                    return (n % x) === 0;
                });
 
            return lows.concat(lows.slice(1).map(function (x) {
                return n / x;
            }).reverse().slice((rRoot === intRoot) | 0));
        }
    }
 
    
    function range(m, n) {
        var a = Array(n - m + 1),
            i = n + 1;
        while (i--) a[i - 1] = i;
        return a;
    }
 
    
    
    
 
    var pairs = range(1, max).map(function (x) {
        return properDivisors(x).reduce(function (a, d) {
            return a + d;
        }, 0)
    }).reduce(function (a, m, i, lst) {
        var n = i + 1;
 
        return (m > n) && lst[m - 1] === n ? a.concat([[n, m]]) : a;
    }, []);
 
    
    function wikiTable(lstRows, blnHeaderRow, strStyle) {
        return '{| class=strv ' + (
            strStyle ? 'style=""' + strStyle + '""' : ''
        ) + lstRows.map(function (lstRow, iRow) {
            var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');
 
            return '|-' + strDelim + ' ' + lstRow.map(function (v) {
                return typeof v === 'undefined' ? ' ' : v;
            }).join(' ' + strDelim + strDelim + ' ');
        }).join('') + '|}';
    }
 
    return wikiTable(
        [['N', 'M']].concat(pairs),
        true,
        'text-align:center'
    ) + '' + JSON.stringify(pairs);
 
})(20000);[[220,284],[1184,1210],[2620,2924],[5020,5564],
 [6232,6368],[10744,10856],[12285,14595],[17296,18416]](max => {
 
    
    let amicablePairsUpTo = max =>
        range(1, max)
        .map(x => properDivisors(x)
            .reduce((a, b) => a + b, 0))
        .reduce((a, m, i, lst) => {
            let n = i + 1;
 
            return (m > n) && lst[m - 1] === n ?
                a.concat([[n, m]]) : a;
        }, []),
 
 
        
        properDivisors = n => {
            if (n < 2) return [];
            else {
                let rRoot = Math.sqrt(n),
                    intRoot = Math.floor(rRoot),
                    blnPerfectSquare = rRoot === intRoot,
 
                    lows = range(1, intRoot)
                    .filter(x => (n % x) === 0);
 
                return lows.concat(lows.slice(1)
                    .map(x => n / x)
                    .reverse()
                    .slice(blnPerfectSquare | 0));
            }
        },
 
        
        range = (m, n, step) => {
            let d = (step || 1) * (n >= m ? 1 : -1);
 
            return Array.from({
                length: Math.floor((n - m) / d) + 1
            }, (_, i) => m + (i * d));
        }
 
 
    return amicablePairsUpTo(max);
 
})(20000);[[220, 284], [1184, 1210], [2620, 2924], [5020, 5564], 
[6232, 6368], [10744, 10856], [12285, 14595], [17296, 18416]]"
"function ambRun(func) {
    var choices = [];
    var index;
 
    function amb(values) {
        if (values.length == 0) {
            fail();
        }
        if (index == choices.length) {
            choices.push({i: 0,
                          count: values.length});
        }
        var choice = choices[index++];
        return values[choice.i];
    }
 
    function fail() { throw fail; }
 
    while (true) {
        try {
            index = 0;
            return func(amb, fail);
        } catch (e) {
            if (e != fail) {
                throw e;
            }
            var choice;
            while ((choice = choices.pop()) && ++choice.i == choice.count) {}
            if (choice == undefined) {
                return undefined;
            }
            choices.push(choice);
        }
    }
}
 
ambRun(function(amb, fail) {
    function linked(s1, s2) {
        return s1.slice(-1) == s2.slice(0, 1);
    }
 
    var w1 = amb([strv, strv, strv]);
    var w2 = amb([strv, strv, strv]);
    if (!linked(w1, w2)) fail();
 
    var w3 = amb([strv, strv, strv]);
    if (!linked(w2, w3)) fail();
 
    var w4 = amb([strv, strv]);
    if (!linked(w3, w4)) fail();
 
    return [w1, w2, w3, w4].join(' ');
});  "
"function almostPrime (n, k) {
    var divisor = 2, count = 0
    while(count < k + 1 && n != 1) {
        if (n % divisor == 0) {
            n = n / divisor
            count = count + 1
        } else {
            divisor++
        }
    }
    return count == k
}
 
for (var k = 1; k <= 5; k++) {
    document.write(strv, k, strv)
    var count = 0, n = 0
    while (count <= 10) {
        n++
        if (almostPrime(n, k)) {
            document.write(n, strv)
            count++
        }
    }
}"
" 
var justification=strv,
input=[strv,
strv,
strv,
strv,
strv,
strv],
x,y,cols,max,cols=0,diff,left,right
 
String.prototype.repeat=function(n){return new Array(1 + parseInt(n)).join(this);}
 
for(x=0;x<input.length;x++) {
 input[x]=input[x].split(strv);
 if(input[x].length>cols) cols=input[x].length;
}
for(x=0;x<cols;x++) {
 max=0;
 for(y=0;y<input.length;y++) if(input[y][x]&&max<input[y][x].length) max=input[y][x].length;
 for(y=0;y<input.length;y++) 
  if(input[y][x]) {
   diff=(max-input[y][x].length)/2;
   left=strv.repeat(Math.floor(diff));
   right=strv.repeat(Math.ceil(diff));
   if(justification==strv) {right+=left;left=strv}
   if(justification==strv) {left+=right;right=strv}
   input[y][x]=left+input[y][x]+right;
  }
}
for(x=0;x<input.length;x++) input[x]=input[x].join(strv);
input=input.join("""");
document.write(input);//break up each string by '$'. The assumption is that the user wants the trailing $.
var data = [
  strv,
  strv,
  strv,
  strv,
  strv,
  strv
].map(function (str) { return str.split('$'); })
 
//boilerplate: get longest array or string in array
var getLongest = function (arr) {
  return arr.reduce(function (acc, item) { return acc.length > item.length ? acc : item; }, 0);
};
 
//boilerplate: this function would normally be in a library like underscore, lodash, or ramda
var zip = function (items, toInsert) {
  toInsert = (toInsert === undefined) ? null : toInsert;
  var longestItem = getLongest(items);
  return longestItem.map(function (_unused, index) {
    return items.map(function (item) {
      return item[index] === undefined ? toInsert : item[index];
    });
  });
};
 
//here's the part that's not boilerplate
var makeColumns = function (formatting, data) {
  var zipData = zip(data, '');
  var makeSpaces = function (num) { return new Array(num + 1).join(' '); };
  var formattedCols = zipData.map(function (column) {
    var maxLen = getLongest(column).length;//find the maximum word length
    if (formatting === 'left') {
      return column.map(function (word) { return word + makeSpaces(maxLen - word.length); });
    } else if (formatting === 'right') {
      return column.map(function (word) { return makeSpaces(maxLen - word.length) + word; });
    } else {
      return column.map(function (word) {
        var spaces = maxLen - word.length,
            first = ~~(spaces / 2),
            last = spaces - first;
        return makeSpaces(first) + word + makeSpaces(last);
      });
    }
  });
 
  return zip(formattedCols).map(function (row) { return row.join(' '); }).join('');
};(function (strText) {
    'use strict';
 
    
    function transpose(lst) {
        return lst[0].map(function (_, iCol) {
            return lst.map(function (row) {
                return row[iCol];
            })
        });
    }
 
    
    function zipWith(f, xs, ys) {
        return xs.length === ys.length ? (
            xs.map(function (x, i) {
                return f(x, ys[i]);
            })
        ) : undefined;
    }
 
    
    function maximumBy(f, xs) {
        return xs.reduce(function (a, x) {
            return a === undefined ? x : (
                f(x) > f(a) ? x : a
            );
        }, undefined)
    }
 
    
    function widest(lst) {
        return maximumBy(length, lst)
            .length;
    }
 
    
    function fullRow(lst, n) {
        return lst.concat(Array.apply(null, Array(n - lst.length))
            .map(function () {
                return ''
            }));
    }
 
    
    function nreps(s, n) {
        var o = '';
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o += s;
            n >>= 1;
            s += s;
        }
        return o + s;
    }
 
    
    function unwords(xs) {
        return xs.join('  ');
    }
 
    
    function unlines(xs) {
        return xs.join('');
    }
 
    
    function length(xs) {
        return xs.length;
    }
 
    
    function padWords(n, lstWords, eAlign) {
        return lstWords.map(function (w) {
            var lngPad = n - w.length;
 
            return (
                    (eAlign === eCenter) ? (function () {
                        var lngHalf = Math.floor(lngPad / 2);
 
                        return [
                            nreps(' ', lngHalf), w,
                            nreps(' ', lngPad - lngHalf)
                        ];
                    })() : (eAlign === eLeft) ? 
                        ['', w, nreps(' ', lngPad)] :
                        [nreps(' ', lngPad), w, '']
                )
                .join('');
        });
    }
 
    
 
    var eLeft = -1,
        eCenter = 0,
        eRight = 1;
 
    var lstRows = strText.split('')
        .map(function (x) {
            return x.split('$');
        }),
 
        lngCols = widest(lstRows),
        lstCols = transpose(lstRows.map(function (r) {
            return fullRow(r, lngCols)
        })),
        lstColWidths = lstCols.map(widest);
 
    
 
    return [eLeft, eRight, eCenter]
        .map(function (eAlign) {
            var fPad = function (n, lstWords) {
                return padWords(n, lstWords, eAlign);
            };
 
            return transpose(
                    zipWith(fPad, lstColWidths, lstCols)
                )
                .map(unwords);
        })
        .map(unlines)
        .join('');
 
})(
    ""Given$a$text$file$of$many$lines,$where$fields$within$a$line$are$delineated$by$a$single$'dollar'$character,$write$a$programthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$column$are$separated$by$at$least$one$space.Further,$allow$for$each$word$in$a$column$to$be$either$left$justified,$right$justified,$or$center$justified$within$its$column.""
);"
"e = {}       
e.foo = 1
e[strv] = 2    "
"function Integrator(sampleIntervalMS) {
    var inputF = function () { return 0.0 };
    var sum = 0.0;
 
    var t1 = new Date().getTime();
    var input1 = inputF(t1 / 1000);
 
    function update() {
        var t2 = new Date().getTime();
        var input2 = inputF(t2 / 1000);
        var dt = (t2 - t1) / 1000;
 
        sum += (input1 + input2) * dt / 2;
 
        t1 = t2;
        input1 = input2;
    }
 
    var updater = setInterval(update, sampleIntervalMS);
 
    return ({
        input: function (newF) { inputF = newF },
        output: function () { return sum },
        shutdown: function () { clearInterval(updater) },
    });
}"
"var fs = require('fs');
var words = fs.readFileSync('unixdict.txt', 'UTF-8').split('');
 
var i, item, max = 0,
    anagrams = {};
 
for (i = 0; i < words.length; i += 1) {
  var key = words[i].split('').sort().join('');
  if (!anagrams.hasOwnProperty(key)) {//check if property exists on current obj only
      anagrams[key] = [];
  }
  var count = anagrams[key].push(words[i]); //push returns new array length
  max = Math.max(count, max);
}
 
//note, this returns all arrays that match the maximum length
for (item in anagrams) {
  if (anagrams.hasOwnProperty(item)) {//check if property exists on current obj only
    if (anagrams[item].length === max) {
        console.log(anagrams[item].join(' '));
    }
  }
}var fs = require('fs');
var dictionary = fs.readFileSync('unixdict.txt', 'UTF-8').split('');
 
//group anagrams
var sortedDict = dictionary.reduce(function (acc, word) {
  var sortedLetters = word.split('').sort().join('');
  if (acc[sortedLetters] === undefined) { acc[sortedLetters] = []; }
  acc[sortedLetters].push(word);
  return acc;
}, {});
 
//sort list by frequency
var keysSortedByFrequency = Object.keys(sortedDict).sort(function (keyA, keyB) {
  if (sortedDict[keyA].length < sortedDict[keyB].length) { return 1; }
  if (sortedDict[keyA].length > sortedDict[keyB].length) { return -1; }
  return 0;
});
 
//print first 10 anagrams by frequency
keysSortedByFrequency.slice(0, 10).forEach(function (key) {
  console.log(sortedDict[key].join(' '));
});"
"function accumulator(sum) {
  return function(n) {
    return sum += n;
  }
}
var x = accumulator(1);
x(5);
console.log(accumulator(3).toString() + '<br>');
console.log(x(2.3));let accumulator = sum => (n => sum += n);
let x = accumulator(1);
console.log(x(5));
accumulator(3);
console.log(x(2.3));function accumulator(sum) function(n) sum += n;
var x = accumulator(1);
x(5);
console.log(accumulator(3).toSource());
console.log(x(2.3));"
"function ack(m, n) {
 return m === 0 ? n + 1 : ack(m - 1, n === 0  ? 1 : ack(m, n - 1));
}"
"for (var dpa=[1,0,0], n=2; n<=20000; n+=1) {
    for (var ds=0, d=1, e=n/2+1; d<e; d+=1) if (n%d==0) ds+=d
    dpa[ds<n ? 0 : ds==n ? 1 : 2]+=1
}
document.write('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2], '<br>' )for (var dpa=[1,0,0], n=2; n<=20000; n+=1) {
    for (var ds=1, d=2, e=Math.sqrt(n); d<e; d+=1) if (n%d==0) ds+=d+n/d
    if (n%e==0) ds+=e
    dpa[ds<n ? 0 : ds==n ? 1 : 2]+=1
}
document.write('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2], '<br>' )function primes(t) {
    var ps = {2:true, 3:true}
    next: for (var n=5, i=2; n<=t; n+=i, i=6-i) {
        var s = Math.sqrt( n )
        for ( var p in ps ) {
            if ( p > s ) break
            if ( n % p ) continue
            continue next
        }
        ps[n] = true
    }
    return ps
}
 
function factorize(f, t) {
    var cs = {}, ps = primes(t)
    for (var n=f; n<=t; n++) if (!ps[n]) cs[n] = factors(n)
    return cs
    function factors(n) {
        for ( var p in ps ) if ( n % p == 0 ) break
        var ts = {}
        ts[p] = 1
        if ( ps[n /= p] ) {
            if ( !ts[n]++ ) ts[n]=1 
        }
        else {
            var fs = cs[n]
            if ( !fs ) fs = cs[n] = factors(n)
            for ( var e in fs ) ts[e] = fs[e] + (e==p)
        }
        return ts
    }
}
 
function pContrib(p, e) {
    for (var pc=1, n=1, i=1; i<=e; i+=1) pc+=n*=p;
    return pc
}
 
for (var dpa=[1,0,0], t=20000, cs=factorize(2,t), n=2; n<=t; n+=1) {
    var ds=1, fs=cs[n]
    if (fs) {
        for (var p in fs) ds *= pContrib(p, fs[p])
        ds -= n
    }
    dpa[ds<n ? 0 : ds==n ? 1 : 2]+=1
}
document.write('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2], '<br>' )(() => {
    'use strict';
 
    const
    
        divisors = n => range(1, Math.floor(n / 2))
            .filter(x => n % x === 0),
 
        
        classOf = n => compare(divisors(n)
            .reduce((a, b) => a + b, 0), n),
 
        classTypes = {
            deficient: -1,
            perfect: 0,
            abundant: 1
        };
 
    
    const
    
        compare = (a, b) =>
            a < b ? -1 : (a > b ? 1 : 0),
 
        
        range = (m, n) =>
            Array.from({
                length: Math.floor(n - m) + 1
            }, (_, i) => m + i);
 
    
 
    
    const classes = range(1, 20000)
        .map(classOf);
 
    return Object.keys(classTypes)
        .map(k => k + strv + classes
            .filter(x => x === classTypes[k])
            .length.toString())
        .join('');
})();"
"var i, p, pascal, primerow, primes, show, _i;
 
pascal = function() {
  var a;
  a = [];
  return function() {
    var b, i;
    if (a.length === 0) {
      return a = [1];
    } else {
      b = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(a[i] + a[i + 1]);
        }
        return _results;
      })();
      return a = [1].concat(b).concat([1]);
    }
  };
};
 
show = function(a) {
  var degree, i, sgn, show_x, str, _i, _ref;
  show_x = function(e) {
    switch (e) {
      case 0:
        return strv;
      case 1:
        return strv;
      default:
        return strv + e;
    }
  };
  degree = a.length - 1;
  str = strv + degree + strv;
  sgn = 1;
  for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    str += ' ' + (sgn > 0 ? strv : strv) + ' ' + a[i] + show_x(degree - i);
    sgn = -sgn;
  }
  return str;
};
 
primerow = function(row) {
  var degree;
  degree = row.length - 1;
  return row.slice(1, degree).every(function(x) {
    return x % degree === 0;
  });
};
 
p = pascal();
 
for (i = _i = 0; _i <= 7; i = ++_i) {
  console.log(show(p()));
}
 
p = pascal();
 
p();
 
p();
 
primes = (function() {
  var _j, _results;
  _results = [];
  for (i = _j = 1; _j <= 49; i = ++_j) {
    if (primerow(p())) {
      _results.push(i + 1);
    }
  }
  return _results;
})();
 
console.log(strv);
 
console.log(strv + primes);function pascal(n) {
	var cs = []; if (n) while (n--) coef(); return coef
	function coef() {
		if (cs.length === 0) return cs = [1];
		for (var t=[1,1], i=cs.length-1; i; i-=1) t.splice( 1, 0, cs[i-1]+cs[i] ); return cs = t
	}
}
 
function show(cs) {
	for (var s='', sgn=true, i=0, deg=cs.length-1; i<=deg; sgn=!sgn, i+=1) {
		s += ' ' + (sgn ? '+' : '-') + cs[i] + (e => e==0 ? '' : e==1 ? 'x' : 'x<sup>' + e + '</sup>')(deg-i)
	}
	return '(x-1)<sup>' + deg + '</sup> =' + s;
}
 
function isPrime(cs) {
	var deg=cs.length-1; return cs.slice(1, deg).every( function(c) { return c % deg === 0 } )
}
 
var coef=pascal(); for (var i=0; i<=7; i+=1) document.write(show(coef()), '<br>')
 
document.write('<br>Primes: ');
for (var coef=pascal(2), n=2; n<=50; n+=1) if (isPrime(coef())) document.write(' ', n)function coef(n) {
 	for (var c=[1], i=0; i<n; c[0]=-c[0], i+=1) {
		c[i+1]=1; for (var j=i; j; j-=1) c[j] = c[j-1]-c[j]		
	}
	return c
}
 
function show(cs)	{
	var s='', n=cs.length-1
	do s += (cs[n]>0 ? ' +' : ' ') + cs[n] + (n==0 ? '' : n==1 ? 'x' :'x<sup>'+n+'</sup>'); while (n--)
	return s
}
 
function isPrime(n) {
	var cs=coef(n), i=n-1; while (i-- && cs[i]%n == 0);
	return i < 1
}
 
for (var n=0; n<=7; n++) document.write('(x-1)<sup>',n,'</sup> = ', show(coef(n)), '<br>')
 
document.write('<br>Primes: ');
for (var n=2; n<=50; n++) if (isPrime(n)) document.write(' ', n)"
"var blocks = strv;
 
function CheckWord(blocks, word) {
   
   if(word !== /([a-z]*)/i.exec(word)[1]) return false;
   
   for(var i = 0; i < word.length; ++i)
   {
      
      var letter = word.charAt(i);
      
      var length = blocks.length;
      
      var reg = eval(strv+letter+strv+letter+strv);
      
      //var reg = new RegExp(strv);
      
      blocks = blocks.replace(reg, strv);
      
      if(blocks.length === length) return false;
   }
   
   return true;
};
 
var words = [
   strv,
   strv, 
   strv, 
   strv, 
   strv, 
   strv, 
   strv 
];
 
for(var i = 0;i<words.length;++i)
   console.log(words[i] + strv + CheckWord(blocks, words[i]));
 (function (strWords) {
 
    var strBlocks =
        'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM',
        blocks = strBlocks.split(' ');
 
    function abc(lstBlocks, strWord) {
        var lngChars = strWord.length;
 
        if (!lngChars) return [];
 
        var b = lstBlocks[0],
            c = strWord[0];
 
        return chain(lstBlocks, function (b) {
            return (b.indexOf(c.toUpperCase()) !== -1) ? [
                (b + ' ').concat(
                    abc(removed(b, lstBlocks), strWord.slice(1)))
            ] : [];
        })
    }
 
    
    function chain(xs, f) {
        return [].concat.apply([], xs.map(f));
    }
 
    
    function removed(x, xs) {
        var h = xs.length ? xs[0] : null,
            t = h ? xs.slice(1) : [];
 
        return h ? (
            h === x ? t : [h].concat(removed(x, t))
        ) : [];
    }
 
    function solution(strWord) {
        var strAttempt = abc(blocks, strWord)[0].split(',')[0];
 
        
        return strWord + ((strAttempt.length === strWord.length * 3) ?
            ' -> ' + strAttempt : ': [no solution]');
    }
 
    return strWords.split(' ').map(solution).join('');
 
})('A bark BooK TReAT COMMON squAD conFUSE');A -> NA 
bark -> BO NA RE XK 
BooK: [no solution]
TReAT -> GT RE ER NA TG 
COMMON: [no solution]
squAD -> FS DQ HU NA QD 
conFUSE -> CP BO NA FS HU FS RElet characters = strv;
let blocks = characters.split(strv).map(pair => pair.split(strv));
 
function isWordPossible(word) {
  var letters = [...word.toUpperCase()];
  var length = letters.length;
  var copy = new Set(blocks);
 
  for (let letter of letters) {
    for (let block of copy) {
      let index = block.indexOf(letter);
 
      if (index !== -1) {
        length--;
        copy.delete(block);
        break;  
      }
    }
 
  }
  return !length;
}    
 
[ 
  strv, 
  strv, 
  strv, 
  strv, 
  strv, 
  strv, 
  strv 
].forEach(word => console.log(`${word}: ${isWordPossible(word)}`));
 (() => {
    'use strict';
 
    
 
    
    const spellWith = (blocks, wordChars) =>
        (isNull(wordChars)) ? [
            []
        ] :
        (() => {
            const [x, xs] = uncons(wordChars);
            return concatMap(
                b => elem(x, b) ? concatMap(
                    bs => [cons(b, bs)],
                    spellWith(
                        deleteBy(
                            (p, q) => (p[0] === q[0]) && (p[1] === q[1]),
                            b, blocks
                        ),
                        xs
                    )
                ) : [],
                blocks
            );
        })();
 
    
 
    
    const compose = fs => x => fs.reduceRight((a, f) => f(a), x);
 
    
    const concatMap = (f, xs) => [].concat.apply([], xs.map(f));
 
    
    const cons = (x, xs) => [x].concat(xs);
 
    
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat([].slice.apply(arguments)));
            };
        return go([].slice.call(args, 1));
    };
 
    
    const deleteBy = (f, x, xs) =>
        xs.length > 0 ? (
            f(x, xs[0]) ? (
                xs.slice(1)
            ) : [xs[0]].concat(deleteBy(f, x, xs.slice(1)))
        ) : [];
 
    
    const elem = (x, xs) => xs.indexOf(x) !== -1;
 
    
    const isNull = xs => (xs instanceof Array) ? xs.length < 1 : undefined;
 
    
    const map = (f, xs) => xs.map(f);
 
    
    const not = b => !b;
 
    
    const show = x => JSON.stringify(x); //, null, 2);
 
    
    const stringChars = s => s.split('');
 
    
    const toUpper = s => s.toUpperCase();
 
    
    const uncons = xs => xs.length ? [xs[0], xs.slice(1)] : undefined;
 
    
    const unlines = xs => xs.join('');
 
    
    const words = s => s.split(/\s+/);
 
    
    
    const blocks = words(
        strv
    );
 
    return unlines(map(
        x => show([x, compose(
            [not, isNull, curry(spellWith)(blocks), stringChars, toUpper]
        )(x)]), [strv, strv, strv, strv, strv, strv, strv, strv]
    ));
})();"
" 
(function () {
    var cache = [
        [1]
    ];
//this was never needed.
   /* function PyRange(start, end, step) {        step = step || 1;        if (!end) {            end = start;            start = 0;        }        var arr = [];        for (var i = start; i < end; i += step) arr.push(i);        return arr;    }*/ 
 
    function cumu(n) {
        var /*ra = PyRange(cache.length, n + 1),*/ //Seems there is a better version for this
            r, l, x, Aa, Mi;
       
       for (l=cache.length;l<n+1;l++) {
            r = [0];



            for(x=1;x<l+1;x++){

                r.push(r[r.length - 1] + (Aa = cache[l - x < 0 ? cache.length - (l - x) : l - x])[(Mi = Math.min(x, l - x)) < 0 ? Aa.length - Mi : Mi]);
            }
            cache.push(r);
        }
        return cache[n];
    }
 
    function row(n) {
        var r = cumu(n),

            leArray = [],
            i;

        for (i=0;i<n;i++) {

            leArray.push(r[i + 1] - r[i]);
        }
        return leArray;
    }
 
    console.log(strv);
    for (iterator = 1; iterator < 12; iterator++) {
        console.log(row(iterator));
    }
 
    console.log(strv)[23, 123, 1234, 12345].foreach(function (a) {
        var s = cumu(a);
        console.log(a, s[s.length - 1]);
    });
})()
 "
"process.openStdin().on (
    'data',
    function (line) {
        var xs = String(line).match(/^\s*(\d+)\s+(\d+)\s*/)
        console.log (
            xs ? Number(xs[1]) + Number(xs[2]) : 'usage: <number> <number>'
        )
        process.exit()
    }
)process.stdin.on(strv, buffer => {
  console.log(
    (buffer + strv).trim().split(strv).map(Number).reduce((a, v) => a + v, 0)
  );
});
 "
"var ar=[],order=[0,1,2],op=[],val=[];
var NOVAL=9999,oper=strv,out;
 
function rnd(n){return Math.floor(Math.random()*n)}
 
function say(s){
 try{document.write(s+strv)}
 catch(e){WScript.Echo(s)}
}
 
function getvalue(x,dir){
 var r=NOVAL;
 if(dir>0)++x;
 while(1){
  if(val[x]!=NOVAL){
   r=val[x];
   val[x]=NOVAL;
   break;
  }
  x+=dir;
 }
 return r*1;
}
 
function calc(){
 var c=0,l,r,x;
 val=ar.join('/').split('/');
 while(c<3){
  x=order[c];
  l=getvalue(x,-1);
  r=getvalue(x,1);
  switch(op[x]){
   case 0:val[x]=l+r;break;
   case 1:val[x]=l-r;break;
   case 2:val[x]=l*r;break;
   case 3:
   if(!r||l%r)return 0;
   val[x]=l/r;
  }
  ++c;
 }
 return getvalue(-1,1);
}
 
function shuffle(s,n){
 var x=n,p=eval(s),r,t;
 while(x--){
  r=rnd(n);
  t=p[x];
  p[x]=p[r];
  p[r]=t;
 }
}
 
function parenth(n){
 while(n>0)--n,out+='(';
 while(n<0)++n,out+=')';
}
 
function getpriority(x){
 for(var z=3;z--;)if(order[z]==x)return 3-z;
 return 0;
}
 
function showsolution(){
 var x=0,p=0,lp=0,v=0;
 while(x<4){
  if(x<3){
   lp=p;
   p=getpriority(x);
   v=p-lp;
   if(v>0)parenth(v);
  }
  out+=ar[x];
  if(x<3){
   if(v<0)parenth(v);
   out+=oper.charAt(op[x]);
  }
  ++x;
 }
 parenth(-p);
 say(out);
}
 
function solve24(s){
 var z=4,r;
 while(z--)ar[z]=s.charCodeAt(z)-48;
 out=strv;
 for(z=100000;z--;){
  r=rnd(256);
  op[0]=r&3;
  op[1]=(r>>2)&3;
  op[2]=(r>>4)&3;
  shuffle(strv,4);
  shuffle(strv,3);
  if(calc()!=24)continue;
  showsolution();
  break;
 }
}
 
solve24(strv);
solve24(strv);
solve24(strv);"
" 
function twentyfour(numbers, input) {
    var invalidChars = /[^\d\+\*\/\s-\(\)]/;
 
    var validNums = function(str) {
        
        
        var mnums = numbers.slice();
        mnums.sort();
 
        
        return str.replace(/[^\d\s]/g, strv)
            .trim()
            .split(/\s+/)
            .map(function(n) { return parseInt(n, 10); })
            .sort()
            .every(function(v, i) { return v === mnums[i]; });
    };
 
    var validEval = function(input) {
        try {
            return eval(input);
        } catch (e) {
            return {error: e.toString()};
        }
    };
 
    if (input.trim() === strv) return strv;
    if (input.match(invalidChars)) return ""Invalid chars used, try again. Use only: + - * / ( )"";
    if (!validNums(input)) return strv;
    var calc = validEval(input);
    if (typeof calc !== 'number') return strv;
    if (calc !== 24) return strv + String(calc) + strv;
    return input + strv;
};
 

 
while (true) {
    var numbers = [1, 2, 3, 4].map(function() {
        return Math.floor(Math.random() * 8 + 1);
    });
 
    var input = prompt(
        ""Your numbers are:"" + numbers.join(strv) +
        ""Enter expression. (use only + - * / and parens)."", +strv, strv);
 
    if (input === 'x') {
        break;
    }
    alert(twentyfour(numbers, input));
}
 "
"var beer = 99;
while (beer > 0) {
  var verse = [
    beer + strv,
    beer + strv,
    strv,  
    (beer - 1) + strv
  ].join("""");
 
  console.log(verse);
 
  beer--;
}
 let beer = 99;
while (beer > 0) {
  let verse = `${beer} bottles of beer on the wall,
  ${beer} bottles of beer!
  Take one down, pass it around
  ${beer-1} bottles of beer on the wall`;
 
  console.log(verse);
  beer--;
}var bottles = 99;
var songTemplate  = ""{X} bottles of beer on the wall "" +
                    ""{X} bottles of beer ""+
                    ""Take one down, pass it around ""+
                    ""{X-1} bottles of beer on the wall "";
 
function song(x, txt) {
  return txt.replace(/\{X\}/gi, x).replace(/\{X-1\}/gi, x-1) + (x > 1 ? song(x-1, txt) : strv);
}
 
console.log(song(bottles, songTemplate));
var beer; while ((beer = typeof beer === strv ? 99 : beer) > 0) document.write( beer + strv + (beer != 1 ? strv : strv) + strv + beer + strv + (beer != 1 ? strv : strv) + strv + (--beer) + strv + (beer != 1 ? strv : strv) + strv );function Bottles(count) {
  this.count = count || 99;
}
 
Bottles.prototype.take = function() {
  var verse = [
    this.count + strv,
    this.count + strv,
    strv,  
    (this.count - 1) + strv
  ].join("""");
 
  console.log(verse);
 
  this.count--;
};
 
Bottles.prototype.sing = function() {
  while (this.count) { 
    this.take(); 
  }
};
 
var bar = new Bottles(99);
bar.sing();function bottleSong(n) {
  if (!isFinite(Number(n)) || n == 0) n = 100;
  var a  = '%% bottles of beer',
      b  = ' on the wall',
      c  = 'Take one down, pass it around',
      r  = '<br>'
      p  = document.createElement('p'),
      s  = [],
      re = /%%/g;
 
  while(n) {
    s.push((a+b+r+a+r+c+r).replace(re, n) + (a+b).replace(re, --n));
  }
  p.innerHTML = s.join(r+r);
  document.body.appendChild(p);
}
 
window.onload = bottleSong;!bottles: (Integer num) [num.String += if num=1 [strv] else [strv]]
99.to 1
  [
  print(
    bottles(idx) "" of beer on the wall""
    bottles(idx) "" of beer""
    ""Take one down, pass it around""
    bottles(idx-1) "" of beer on the wall"")
  ] 
var beer = 99;
while (beer > 0)
{
 stdout.printf( ""%d bottles of beer on the wall"", beer);
 stdout.printf( ""%d bottles of beer"", beer);
 stdout.println( strv );
 stdout.printf( ""%d bottles of beer on the wall"", --beer );
}
 "
" 
var doors=[];
for(var i=0;i<100;i++)
 doors[i]=false;             //create doors
for(var i=1;i<=100;i++)
 for(var i2=i-1,g;i2<100;i2+=i)
  doors[i2]=!doors[i2];      //toggle doors
for(var i=1;i<=100;i++)      //read doors
 console.log(strv,i,doors[i-1]?strv:strv)
 (function (n) {
    'use strict';
 
 
    
    function finalDoors(n) {
        var lstRange = range(1, n);
 
        return lstRange
            .reduce(function (a, _, k) {
                var m = k + 1;
 
                return a.map(function (x, i) {
                    var j = i + 1;
 
                    return [j, j % m ? x[1] : !x[1]];
                });
            }, zip(
                lstRange,
                replicate(n, false)
            ));
    };
 
 
 
    
 
    
    function zip(xs, ys) {
        return xs.length === ys.length ? (
            xs.map(function (x, i) {
                return [x, ys[i]];
            })
        ) : undefined;
    }
 
    
    function replicate(n, a) {
        var v = [a],
            o = [];
 
        if (n < 1) return o;
        while (n > 1) {
            if (n & 1) o = o.concat(v);
            n >>= 1;
            v = v.concat(v);
        }
        return o.concat(v);
    }
 
    
    
    function range(m, n, delta) {
        var d = delta || 1,
            blnUp = n > m,
            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,
            a = Array(lng),
            i = lng;
 
        if (blnUp)
            while (i--) a[i] = (d * i) + m;
        else
            while (i--) a[i] = m - (d * i);
 
        return a;
    }
 
 
    return finalDoors(n)
        .filter(function (tuple) {
            return tuple[1];
        })
        .map(function (tuple) {
            return {
                door: tuple[0],
                open: tuple[1]
            };
        });
 
})(100);[{strv:1, strv:true}, {strv:4, strv:true}, {strv:9, strv:true}, {strv:16, strv:true}, {strv:25, strv:true}, {strv:36, strv:true}, {strv:49, strv:true}, {strv:64, strv:true}, {strv:81, strv:true}, {strv:100, strv:true}]for (var door = 1; door <= 100; door++) {
  var sqrt = Math.sqrt(door);
  if (sqrt === (sqrt | 0)) {
    console.log(strv, door);
  }
}for(var door=1;i<10/*Math.sqrt(100)*/;i++){
 console.log(strv,i*i);
}(function (n) {
    'use strict';
 
    return range(1, 100)
        .filter(function (x) {
            return integerFactors(x)
                .length % 2;
        });
 
    function integerFactors(n) {
        var rRoot = Math.sqrt(n),
            intRoot = Math.floor(rRoot),
 
            lows = range(1, intRoot)
            .filter(function (x) {
                return (n % x) === 0;
            });
 
        
        return lows.concat(lows.map(function (x) {
                return n / x;
            })
            .reverse()
            .slice((rRoot === intRoot) | 0));
    }
 
    
    
    function range(m, n, delta) {
        var d = delta || 1,
            blnUp = n > m,
            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,
            a = Array(lng),
            i = lng;
 
        if (blnUp)
            while (i--) a[i] = (d * i) + m;
        else
            while (i--) a[i] = m - (d * i);
 
        return a;
    }
 
})(100);(function (n) {
    'use strict';
 
    return perfectSquaresUpTo(100);
 
    function perfectSquaresUpTo(n) {
        return range(1, Math.floor(Math.sqrt(n)))
            .map(function (x) {
                return x * x;
            });
    }
 
    
 
    
    
    function range(m, n, delta) {
        var d = delta || 1,
            blnUp = n > m,
            lng = Math.floor((blnUp ? n - m : m - n) / d) + 1,
            a = Array(lng),
            i = lng;
 
        if (blnUp)
            while (i--) a[i] = (d * i) + m;
        else
            while (i--) a[i] = m - (d * i);
        return a;
    }
 
})(100);[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 
Array.apply(null, { length: 100 })
  .map((v, i) => i + 1)
    .forEach(door => { 
      var sqrt = Math.sqrt(door); 
 
      if (sqrt === (sqrt | 0)) {
        console.log(strv, door);
      } 
    });
[ for (i of Array.apply(null, { length: 100 })) i ].forEach((_, i) => { 
  var door = i + 1
  var sqrt = Math.sqrt(door); 
 
  if (sqrt === (sqrt | 0)) {
    console.log(strv, door);
  } 
});(function (n) {
 
 
    
    
 
    return perfectSquaresUpTo(n);
 
 
    
    function perfectSquaresUpTo(n) {
        return range(1, Math.floor(Math.sqrt(n)))
            .map(x => x * x);
    }
 
 
    
 
    
    
    function range(m, n, step) {
        let d = (step || 1) * (n >= m ? 1 : -1);
 
        return Array.from({
            length: Math.floor((n - m) / d) + 1
        }, (_, i) => m + (i * d));
    }
 
})(100);[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"
