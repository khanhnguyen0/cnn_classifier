keywords
"NSAssert(a == 42, @strv);NSAssert1(a == 42, @strv, a); # has 1 formatting arg, so use NSAssertstrv"
" *arr1 = @[@1, @2, @3]; *arr2 = @[@4, @5, @6]; *arr3 = [arr1 arrayByAddingObjectsFromArray:arr2]; *arr1 = @[@1, @2, @3]; *arr2 = @[@4, @5, @6]; *arr3 = [ arrayWithArray:arr1];[arr3 addObjectsFromArray:arr2];"
" *dict = [ dictionaryWithObjectsAndKeys:    @strv, @strv,    [ numberWithUnsignedInt:42], @strv,    [ null], @strv,    nil]; *dict = @{    @strv: @strv,    @strv: @42,    @strv: [ null],    }; *dict = [ dictionary];[dict setObject:@strv forKey:@strv];[dict setObject:[ numberWithInt:42] forKey:@strv]; *name = [dict objectForKey:@strv];unsigned age = [dict objectForKey:@strv] unsignedIntValue];id missing = [dict objectForKey:@strv];"
"#import <Foundation/Foundation.h>#import <objc/runtime.h> static void *fooKey = &fooKey; 
 int main (int argc, const char *argv[]) {    @autoreleasepool {         id e = [[ alloc] init];         
        objc_setAssociatedObject(e, fooKey, @1, OBJC_ASSOCIATION_RETAIN);         
         *associatedObject = objc_getAssociatedObject(e, fooKey);        NSLog(@strv, associatedObject);     }    return 0;}#import <Foundation/Foundation.h>#import <objc/runtime.h> int main (int argc, const char *argv[]) {    @autoreleasepool {         id e = [[ alloc] init];         
        objc_setAssociatedObject(e, @selector(foo), @1, OBJC_ASSOCIATION_RETAIN);         
         *associatedObject = objc_getAssociatedObject(e, @selector(foo));        NSLog(@strv, associatedObject);     }    return 0;}"
"#import <Foundation/Foundation.h> @interface AnonymousRecursion :  { }- ( *)fibonacci:( *)n;@end @implementation AnonymousRecursion- ( *)fibonacci:( *)n {  int i = [n intValue];  if (i < 0)    @throw [ exceptionWithName:NSInvalidArgumentException                                 reason:@strv                               userInfo:nil];  int result;  if (i < 2)    result = 1;  else    result = [[self performSelector:_cmd withObject:@(i-1)] intValue]           + [[self performSelector:_cmd withObject:@(i-2)] intValue];  return @(result);}@end int main (int argc, const char *argv[]) {  @autoreleasepool {     AnonymousRecursion *dummy = [[AnonymousRecursion alloc] init];    NSLog(@strv, [dummy fibonacci:@8]);   }  return 0;}#import <Foundation/Foundation.h> int fib(int n) {    if (n < 0)        @throw [ exceptionWithName:NSInvalidArgumentException                                 reason:@strv                               userInfo:nil];    int (^f)(int);    __block __weak int (^weak_f)(int); 
    weak_f = f = ^(int n) {        if (n < 2)            return 1;        else            return weak_f(n-1) + weak_f(n-2);    };    return f(n);} int main (int argc, const char *argv[]) {  @autoreleasepool {     NSLog(@strv, fib(8));   }  return 0;}#import <Foundation/Foundation.h> int fib(int n) {    if (n < 0)        @throw [ exceptionWithName:NSInvalidArgumentException                                 reason:@strv                               userInfo:nil];    __block int (^f)(int);    f = ^(int n) {        if (n < 2)            return 1;        else            return f(n-1) + f(n-2);    };    return f(n);} int main (int argc, const char *argv[]) {  @autoreleasepool {     NSLog(@strv, fib(8));   }  return 0;}"
"
 
 *firstArray = [[ alloc] initWithObjects:@strv, @strv, @strv, nil]; 


 *secondArray = [firstArray mutableCopy]; 
[secondArray replaceObjectAtIndex:1 withObject:@strv]; 
NSLog(@strv, [secondArray objectAtIndex:0]); 
[firstArray release];[secondArray release]; 

 *thirdArray = @[ @strv, @strv, @strv, @1, @2, @3 ]; "
"#import <Foundation/Foundation.h> @interface RCRationalNumber : { @private  int numerator;  int denominator;  BOOL autoSimplify;  BOOL withSign;}+(instancetype)valueWithNumerator:(int)num andDenominator: (int)den;+(instancetype)valueWithDouble: (double)fnum;+(instancetype)valueWithInteger: (int)inum;+(instancetype)valueWithRational: (RCRationalNumber *)rnum;-(instancetype)initWithNumerator: (int)num andDenominator: (int)den;-(instancetype)initWithDouble: (double)fnum precision: (int)prec;-(instancetype)initWithInteger: (int)inum;-(instancetype)initWithRational: (RCRationalNumber *)rnum;-(NSComparisonResult)compare: (RCRationalNumber *)rnum;-(id)simplify: (BOOL)act;-(void)setAutoSimplify: (BOOL)v;-(void)setWithSign: (BOOL)v;-(BOOL)autoSimplify;-(BOOL)withSign;-( *)description;
-(id)multiply: (RCRationalNumber *)rnum;-(id)divide: (RCRationalNumber *)rnum;-(id)add: (RCRationalNumber *)rnum;-(id)sub: (RCRationalNumber *)rnum;-(id);-(id)neg;-(id)mod: (RCRationalNumber *)rnum;-(int)sign;-(BOOL)isNegative;-(id)reciprocal;
-(int)numerator;-(int)denominator;//setter-(void)setNumerator: (int)num;-(void)setDenominator: (int)num;
-(double)number;-(int)integer;@end#import <Foundation/Foundation.h>#import <math.h>#import strv 

 static int lcm(int a, int b){  return a / gcd(a,b) * b;} @implementation RCRationalNumber
-(instancetype)init{  NSLog(@strv);  return [self initWithInteger: 1];} -(instancetype)initWithNumerator: (int)num andDenominator: (int)den{  if ((self = [super init]) != nil) {    if (den == 0) {      NSLog(@strv);      return nil;    }    [self setNumerator: num];    [self setDenominator: den];    [self setWithSign: YES];    [self setAutoSimplify: YES];    [self simplify: YES];  }  return self;} -(instancetype)initWithInteger:(int)inum{  return [self initWithNumerator: inum andDenominator: 1];} -(instancetype)initWithDouble: (double)fnum precision: (int)prec{  if ( prec > 9 ) prec = 9;  double p = (10.0, (double)prec);  int nd = (int)(fnum * p);  return [self initWithNumerator: nd andDenominator: (int)p ];} -(instancetype)initWithRational: (RCRationalNumber *)rnum{  return [self initWithNumerator: [rnum numerator] andDenominator: [rnum denominator]];} 
-(NSComparisonResult)compare: (RCRationalNumber *)rnum{  if ( [self number] > [rnum number] ) return NSOrderedDescending;  if ( [self number] < [rnum number] ) return NSOrderedAscending;  return NSOrderedSame;} 
-( *)description{  [self simplify: [self autoSimplify]];  return [ stringWithFormat: @strv, [self isNegative] ? @strv : 		     ( [self withSign] ? @strv : @strv ),		   ([self numerator]), [self denominator]];} 
-(void)setAutoSimplify: (BOOL)v{  autoSimplify = v;  [self simplify: v];}-(void)setWithSign: (BOOL)v{  withSign = v;} 
-(BOOL)autoSimplify{  return autoSimplify;} -(BOOL)withSign{  return withSign;} 
-(id)simplify: (BOOL)act{  if ( act ) {    int common = gcd([self numerator], [self denominator]);    [self setNumerator: [self numerator]/common];    [self setDenominator: [self denominator]/common];  }  return self;} 
-(id)multiply: (RCRationalNumber *)rnum{  int newnum = [self numerator] * [rnum numerator];  int newden = [self denominator] * [rnum denominator];  return [RCRationalNumber valueWithNumerator: newnum			   andDenominator: newden];} -(id)divide: (RCRationalNumber *)rnum{  return [self multiply: [rnum reciprocal]];} -(id)add: (RCRationalNumber *)rnum{  int common = lcm([self denominator], [rnum denominator]);  int resnum = common / [self denominator] * [self numerator] +    common / [rnum denominator] * [rnum numerator];  return [RCRationalNumber valueWithNumerator: resnum andDenominator: common];} -(id)sub: (RCRationalNumber *)rnum{  return [self add: [rnum neg]];} -(id)mod: (RCRationalNumber *)rnum{  return [[self divide: rnum] 	   sub: [RCRationalNumber valueWithInteger: [[self divide: rnum] integer]]];} 
-(id)neg{  return [RCRationalNumber valueWithNumerator: -1*[self numerator]			   andDenominator: [self denominator]];} -(id){  return [RCRationalNumber valueWithNumerator: ([self numerator])			   andDenominator: [self denominator]];} -(id)reciprocal{  return [RCRationalNumber valueWithNumerator: [self denominator]			   andDenominator: [self numerator]];} 
-(int)sign{  return ([self numerator] < 0) ? -1 : 1;} 
-(BOOL)isNegative{  return [self numerator] < 0;} 
-(double)number{  return (double)[self numerator] / (double)[self denominator];} 
-(int)integer{  return [self numerator] / [self denominator];} 
-(void)setNumerator: (int)num{  numerator = num;} -(void)setDenominator: (int)num{  if ( num < 0 ) numerator = -numerator;  denominator = (num);} 
-(int)numerator{  return numerator;} -(int)denominator{  return denominator;} 
+(instancetype)valueWithNumerator:(int)num andDenominator: (int)den{  return [[self alloc] initWithNumerator: num andDenominator: den];} +(instancetype)valueWithDouble: (double)fnum{  return [[self alloc] initWithDouble: fnum];} +(instancetype)valueWithInteger: (int)inum{  return [[self alloc] initWithInteger: inum];} +(instancetype)valueWithRational: (RCRationalNumber *)rnum{  return [[self alloc] initWithRational: rnum];}@end#import <Foundation/Foundation.h>#import strv#import <math.h> int main(){  @autoreleasepool {     int i;    for(i=2; i < 0x80000; i++) {      int candidate = i;      RCRationalNumber *sum = [RCRationalNumber valueWithNumerator: 1 			                            andDenominator: candidate];      int factor;      for(factor=2; factor < ((double)candidate); factor++) {        if ( (candidate % factor) == 0 ) { 	  sum = [[sum add: [RCRationalNumber valueWithNumerator: 1					         andDenominator: factor]]		  add: [RCRationalNumber valueWithNumerator: 1					     andDenominator: (candidate/factor)]];        }      }      if ( [sum denominator] == 1 ) {        (""Sum of recipr. factors of %d = %d exactly %s"",	       candidate, [sum integer], ([sum integer]==1) ? strv : strv);      }    }   }  return 0;}"
"#import <Foundation/Foundation.h> typedef double (^Accumulator)(double); Accumulator accumulator_factory(double initial) {    __block double sum = initial;    Accumulator acc = ^(double n){        return sum += n;    };    return acc;} int main (int argc, const char * argv[]) {    @autoreleasepool {         Accumulator x = accumulator_factory(1);        x(5);        accumulator_factory(3);        NSLog(@strv, x(2.3));     }    return 0;}"
"#import <Foundation/Foundation.h> int main(){    @autoreleasepool {        int bottles = 99;        do        {            NSLog(@""%i bottles of beer on the wall"", bottles);            NSLog(@""%i bottles of beer"", bottles);            NSLog(@""Take one down, pass it around"");            NSLog(@""%i bottles of beer on the wall"", --bottles);        } while (bottles > 0);     }    return 0;}"
" #import <Foundation/Foundation.h> int main()  square := 1, increment = 3   for int door in 1 .. 100    (strv, door)     if door == square      (strv)      square += increment      increment += 2    else      (strv)   return 0 "
" *dir = NSHomeDirectory(); *de = [[ defaultManager] enumeratorAtPath:dir]; for ( *file in de)  if ([[file pathExtension] isEqualToString:@strv])    NSLog(@strv, file);"
"#include <Foundation/Foundation.h>#include <AppKit/AppKit.h> @interface Win : {}- (void)applicationDidFinishLaunching: ( *)notification;- (BOOL)applicationShouldTerminateAfterLastWindowClosed: ( *)notification;@end  @implementation Win : -(instancetype) init{  if ((self = [super     initWithContentRect: NSMakeRect(0, 0, 800, 600)    styleMask: (NSTitledWindowMask | NSClosableWindowMask)    backing: NSBackingStoreBuffered    defer: NO])) {     [self setTitle: @strv];    [self center];  }  return self;} - (void)applicationDidFinishLaunching: ( *)notification{  [self orderFront: self];} - (BOOL)applicationShouldTerminateAfterLastWindowClosed: ( *)notification{  return YES;}@end int main(){  @autoreleasepool {     [ sharedApplication];    Win *mywin = [[Win alloc] init];    [NSApp setDelegate: mywin];    [NSApp runModalForWindow: mywin];   }  return EXIT_SUCCESS;}"
"#import <Foundation/Foundation.h> typedef int (^Func)(int)typedef Func (^FuncFunc)(Func)typedef Func (^RecursiveFunc)(id) 
 Func fix(FuncFunc f)  Func r(RecursiveFunc g)    int s(int x)      return g(g)(x)    return f(s)  return r(r) int main(int argc, const char *argv[])  autoreleasepool     Func almost_fac(Func f)      return (int n | return n <= 1 ? 1 : n * f(n - 1))     Func almost_fib(Func f)      return (int n | return n <= 2 ? 1 : f(n - 1) + f(n - 2))     fib := fix(almost_fib)    fac := fix(almost_fac)     Log('fib(10) = %d', fib(10))    Log('fac(10) = %d', fac(10))   return 0#import <Foundation/Foundation.h> typedef int (^Func)(int);typedef Func (^FuncFunc)(Func);typedef Func (^RecursiveFunc)(id); 
 Func Y(FuncFunc f) {  RecursiveFunc r =  ^(id y) {    RecursiveFunc w = y; 
    return f(^(int x) {      return w(w)(x);    });  };  return r(r);} int main (int argc, const char *argv[]) {  @autoreleasepool {     Func fib = Y(^Func(Func f) {      return ^(int n) {        if (n <= 2) return 1;        return  f(n - 1) + f(n - 2);      };    });    Func fac = Y(^Func(Func f) {      return ^(int n) {        if (n <= 1) return 1;        return n * f(n - 1);      };    });     Func fib = fix(almost_fib);    Func fac = fix(almost_fac);    NSLog(@strv, fib(10));    NSLog(@strv, fac(10));   }  return 0;}Func Y(FuncFunc f) {  return ^(int x) {    return f(Y(f))(x);  };}"
" *dir = @strv; 
 *contents = [[ defaultManager] directoryContentsAtPath:dir];
 *contents = [[ defaultManager] contentsOfDirectoryAtPath:dir error:NULL]; for ( *file in contents)  if ([[file pathExtension] isEqualToString:@strv])    NSLog(@strv, file);"
"#include <stdarg.h> void logObjects(id firstObject, ...) 
{  va_list args;  (args, firstObject);  id obj;  for (obj = firstObject; obj != nil; obj = (args, id))    NSLog(@strv, obj);  (args);} 
logObjects(@strv, @strv, @strv, @strv, nil);logObjects(@4, @3, @strv, nil);"
" *normal = @strv; *encoded = [normal stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSLog(@strv, encoded); *normal = @strv; *encoded = [normal stringByAddingPercentEncodingWithAllowedCharacters:[ alphanumericCharacterSet]];NSLog(@strv, encoded);"
" *encoded = @strv; *normal = [encoded stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSLog(@strv, normal); *encoded = @strv; *normal = [encoded stringByRemovingPercentEncoding];NSLog(@strv, normal);"
"//

//

// #import <Foundation/Foundation.h>double f(double x); double f(double x) {    return ((x), 0.5) + 5*((x, 3)); } int main (int argc, const char * argv[]){    @autoreleasepool {         *input = [[ alloc] initWithCapacity:0];         (strv, ""Instructions: please enter 11 numbers."");        for(int i = 0; i < 11; i++) {            double userInput = 0.0;            (strv, strv);            (strv, &userInput);            [input addObject: @(userInput)];        }         for(int i = 10; i >= 0; i--) {            double x = [input[i] doubleValue];            double y = f(x);            (""f(%.2f) ="", x);            if(y < 400.0) {                (""%.2f"", y);            } else {                (""%s"", strv);            }        }    }    return 0;} "
"#import <Foundation/Foundation.h> int main(int argc, const char * argv[]){    @autoreleasepool {        if(argc > 1)        {             *arg1 = [ stringWithCString:argv[1] encoding:NSUTF8StringEncoding];             
            double kelvin = [arg1 doubleValue];             NSLog(@strv,kelvin);            NSLog(@""C %.2f"", kelvin - 273.15);            NSLog(@""F %.2f"", (kelvin * 1.8) - 459.67);            NSLog(@strv, kelvin * 1.8);        }    }    return 0;}"
"#import <Foundation/NSObject.h> @interface TowersOfHanoi:  {	int pegFrom;	int pegTo;	int pegVia;	int numDisks;} -(void) setPegFrom: (int) from andSetPegTo: (int) to andSetPegVia: (int) via andSetNumDisks: (int) disks;-(void) movePegFrom: (int) from andMovePegTo: (int) to andMovePegVia: (int) via andWithNumDisks: (int) disks;@end#import strv@implementation TowersOfHanoi -(void) setPegFrom: (int) from andSetPegTo: (int) to andSetPegVia: (int) via andSetNumDisks: (int) disks {	pegFrom = from;	pegTo = to;	pegVia = via;	numDisks = disks;} -(void) movePegFrom: (int) from andMovePegTo: (int) to andMovePegVia: (int) via andWithNumDisks: (int) disks {	if (disks == 1) {            (""Move disk from pole %i to pole %i"", from, to);        } else { 			[self movePegFrom: from andMovePegTo: via andMovePegVia: to andWithNumDisks: disks-1];			[self movePegFrom: from andMovePegTo: to andMovePegVia: via andWithNumDisks: 1];			[self movePegFrom: via andMovePegTo: to andMovePegVia: from andWithNumDisks: disks-1];        }} @end#import <stdio.h>#import strv int main( int argc, const char *argv[] ) {	@autoreleasepool { 		TowersOfHanoi *tower = [[TowersOfHanoi alloc] init]; 		int from = 1;		int to = 3;		int via = 2;		int disks = 3; 		[tower setPegFrom: from andSetPegTo: to andSetPegVia: via andSetNumDisks: disks]; 		[tower movePegFrom: from andMovePegTo: to andMovePegVia: via andWithNumDisks: disks]; 	}	return 0;}"
 *text = @strv; *tokens = [text componentsSeparatedByString:@strv]; *result = [tokens componentsJoinedByString:@strv];NSLog(result);
"NSLog(@strv, [ date]);NSLog(@strv, [ calendarDate]);"
"#import <Foundation/Foundation.h> int main(int argc, const char *argv[]) {  @autoreleasepool {     * setA = [ setWithObjects:@strv, @strv, @strv, @strv, @strv, nil];    * setB = [ setWithObjects:@strv, @strv, @strv, @strv, @strv, nil];     
    NSLog(@strv, setA);    NSLog(@strv, setB);     
    * notInSetA = [ setWithSet:setB];    [notInSetA minusSet:setA];    * notInSetB = [ setWithSet:setA];    [notInSetB minusSet:setB];     
    * symmetricDifference = [ setWithSet:notInSetA];    [symmetricDifference unionSet:notInSetB];     
    NSLog(@strv, notInSetA);    NSLog(@strv, notInSetB);    NSLog(@strv, symmetricDifference);   }  return 0;}"
"#import <Foundation/Foundation.h> @interface  (RCExt)-( *) ltrim;-( *) rtrim;-( *) trim;@end @implementation  (RCExt)-( *) ltrim{  NSInteger i;   *cs = [ whitespaceAndNewlineCharacterSet];  for(i = 0; i < [self length]; i++)  {    if ( ![cs characterIsMember: [self characterAtIndex: i]] ) break;  }  return [self substringFromIndex: i];} -( *) rtrim{  NSInteger i;   *cs = [ whitespaceAndNewlineCharacterSet];  for(i = [self length] -1; i >= 0; i--)  {    if ( ![cs characterIsMember: [self characterAtIndex: i]] ) break;      }  return [self substringToIndex: (i+1)];} -( *) trim{  return [self 	   stringByTrimmingCharactersInSet:	     [ whitespaceAndNewlineCharacterSet]];}@end int main(){  @autoreleasepool {      *s = @strv;     NSLog(@strv, s);    NSLog(@strv, [s ltrim]);    NSLog(@strv, [s rtrim]);    NSLog(@strv, [s trim]);   }  return 0;}"
"@interface  (StripCharacters)- ( *) stripCharactersInSet: ( *) chars;@end @implementation  (StripCharacters)- ( *) stripCharactersInSet: ( *) chars {    return [[self componentsSeparatedByCharactersInSet:chars] componentsJoinedByString:@strv];}@end     *aString = @strv;    * chars = [ characterSetWithCharactersInString:@strv];     
    NSLog(@strv, [aString stripCharactersInSet:chars]);"
"- (float) sum:( *)array{ 	int i, sum, value;	sum = 0;	value = 0; 	for (i = 0; i < [array count]; i++) {		value = [[array objectAtIndex: i] intValue];		sum += value;	} 	return suml;}- (float) prod:( *)array{ 	int i, prod, value;	prod = 0;	value = 0; 	for (i = 0; i < [array count]; i++) {		value = [[array objectAtIndex: i] intValue];		prod *= value;	} 	return suml;}"
"[@strv hasPrefix:@strv] //returns true[@strv hasSuffix:@strv] //returns falseint loc = [@strv rangeOfString:@strv].location //returns -1loc = [@strv rangeOfString:@strv].location //returns 0loc = [@strv rangeOfString:@strv options:0 range:NSMakeRange(loc+1, [@strv length]-(loc+1))].location //returns 2"
"#import <Foundation/Foundation.h> int main(){  @autoreleasepool {      *s = @strv;    (""%s%s"", [s UTF8String], strv);      *s2 = [s stringByAppendingString:@strv];    
    ([s2 UTF8String]);    /* or */     *s3 = [ stringWithString: s];    [s3 appendString: @strv];    ([s3 UTF8String]);   }  return 0;}"
"#include <execinfo.h> void *frames[128];int len = backtrace(frames, 128);char **symbols = backtrace_symbols(frames, len);for (int i = 0; i < len; ++i) {    NSLog(@strv, symbols[i]);}(symbols); *symbols = [ callStackSymbols];for ( *symbol in symbols) {    NSLog(@strv, symbol);}"
"

unsigned int numberOfCharacters = [@strv length];  
int realCharacterCount = [s lengthOfBytesUsingEncoding: NSUTF32StringEncoding] / 4;int byteCount = [@strv length] * 2; 


unsigned numberOfBytes =   [@strv lengthOfBytesUsingEncoding: NSUTF8StringEncoding]; 
"
"NSLog(@strv, @strv.uppercaseString);NSLog(@strv, @strv.lowercaseString); NSLog(@strv, @strv.capitalizedString); 
"
"#import <Foundation/Foundation.h> int main(int argc, char **argv){     *queue = [[ alloc] init];    while (--argc) {        int i = (argv[argc]);        [queue addOperationWithBlock: ^{            sleep(i);            NSLog(@""%d"", i);        }];    }    [queue waitUntilAllOperationsAreFinished];}#import <Foundation/Foundation.h> int main(int argc, char **argv){    while (--argc) {        int i = (argv[argc]);        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, i * NSEC_PER_SEC),                       dispatch_get_main_queue(),                       ^{ NSLog(@""%d"", i); });    }}"
" *stack = [ array]; 
 [stack addObject:value]; 
 id value = [stack lastObject];[stack removeLastObject]; 
 [stack count] == 0 
"
"//--------------------------------------------------------------------
 @interface Person :  {    NSUInteger _candidateIndex;}@property (nonatomic, strong)   *   name;@property (nonatomic, strong)   *    prefs;@property (nonatomic, weak)     Person*     fiance;@end @implementation Person+ (instancetype)named:( *)name {    return [[self alloc] initWithName:name];}- (instancetype)initWithName:( *)name {    if ((self = [super init])) {        _name = name;        _prefs = nil;        _fiance = nil;        _candidateIndex = 0;    }    return self;}- (BOOL)prefers:(Person *)p {    return [_prefs indexOfObject:p] < [_prefs indexOfObject:_fiance];}- (Person *)nextCandidateNotYetProposedTo {    if (_candidateIndex >= _prefs.count) return nil;    return _prefs[_candidateIndex++];}- (void)engageTo:(Person *)p {    if (p.fiance) p.fiance.fiance = nil;    p.fiance = self;    if (self.fiance) self.fiance.fiance = nil;    self.fiance = p;}- ( *)description {    return _name;}@end //-------------------------------------------------------------------- BOOL isStable( *men) {     *women = ((Person *)men[0]).prefs;    for (Person *guy in men) {        for (Person *gal in women) {            if ([guy prefers:gal] && [gal prefers:guy])                return NO;        }    }    return YES;} //-------------------------------------------------------------------- void doMarriage() {    Person *abe  = [Person named:@strv];    Person *bob  = [Person named:@strv];    Person *col  = [Person named:@strv];    Person *dan  = [Person named:@strv];    Person *ed   = [Person named:@strv];    Person *fred = [Person named:@strv];    Person *gav  = [Person named:@strv];    Person *hal  = [Person named:@strv];    Person *ian  = [Person named:@strv];    Person *jon  = [Person named:@strv];    Person *abi  = [Person named:@strv];    Person *bea  = [Person named:@strv];    Person *cath = [Person named:@strv];    Person *dee  = [Person named:@strv];    Person *eve  = [Person named:@strv];    Person *fay  = [Person named:@strv];    Person *gay  = [Person named:@strv];    Person *hope = [Person named:@strv];    Person *ivy  = [Person named:@strv];    Person *jan  = [Person named:@strv];     abe.prefs  = @[ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay ];    bob.prefs  = @[ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay ];    col.prefs  = @[ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan ];    dan.prefs  = @[ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi ];    ed.prefs   = @[ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay ];    fred.prefs = @[ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay ];    gav.prefs  = @[ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay ];    hal.prefs  = @[ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee ];    ian.prefs  = @[ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve ];    jon.prefs  = @[ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope ];    abi.prefs  = @[ bob, fred, jon, gav, ian, abe, dan, ed, col, hal ];    bea.prefs  = @[ bob, abe, col, fred, gav, dan, ian, ed, jon, hal ];    cath.prefs = @[ fred, bob, ed, gav, hal, col, ian, abe, dan, jon ];    dee.prefs  = @[ fred, jon, col, abe, ian, hal, gav, dan, bob, ed ];    eve.prefs  = @[ jon, hal, fred, dan, abe, gav, col, ed, ian, bob ];    fay.prefs  = @[ bob, abe, ed, ian, jon, dan, fred, gav, col, hal ];    gay.prefs  = @[ jon, gav, hal, fred, bob, abe, col, ed, dan, ian ];    hope.prefs = @[ gav, jon, bob, abe, ian, dan, hal, ed, col, fred ];    ivy.prefs  = @[ ian, col, hal, gav, fred, bob, abe, ed, jon, dan ];    jan.prefs  = @[ ed, hal, gav, abe, bob, jon, col, ian, fred, dan ];      *men = abi.prefs;     NSUInteger freeMenCount = men.count;    while (freeMenCount > 0) {        for (Person *guy in men) {            if (guy.fiance == nil) {                Person *gal = [guy nextCandidateNotYetProposedTo];                if (gal.fiance == nil) {                    [guy engageTo:gal];                    freeMenCount--;                } else if ([gal prefers:guy]) {                    [guy engageTo:gal];                }            }        }    }     for (Person *guy in men) {        (""%s is engaged to %s"", [guy.name UTF8String], [guy.fiance.name UTF8String]);    }    (""Stable = %d"", (int)isStable(men));     (""Switching fred & jon's partners"");    [fred engageTo:abi];    [jon engageTo:bea];    (""Stable = %d"", (int)isStable(men));} //-------------------------------------------------------------------- int main(int argc, const char * argv[]){    @autoreleasepool {        doMarriage();    }    return 0;}"
- ( *) bubbleSort:( *)unsorted {    BOOL done = false;     while (!done) {        done = true;        for (int i = 1; i < unsorted.count; i++) {            if ( [[unsorted objectAtIndex:i-1] integerValue] > [[unsorted objectAtIndex:i] integerValue] ) {                [unsorted exchangeObjectAtIndex:i withObjectAtIndex:i-1];                done = false;            }        }    }     return unsorted;} 
"#import <Foundation/Foundation.h> void quicksortInPlace(MutableArray array, const long first, const long last)  if first >= last    return  Value pivot = array[(first + last) / 2]  left := first  right := last  while left <= right    while array[left] < pivot      left++    while array[right] > pivot      right--    if left <= right      array.exchangeObjectAtIndex: left++, withObjectAtIndex: right--   quicksortInPlace(array, first, right)  quicksortInPlace(array, left, last) Array quicksort(Array unsorted)  a := []  a.addObjectsFromArray: unsorted  quicksortInPlace(a, 0, a.count - 1)  return a  int main(int argc, const char * argv[])  autoreleasepool    a := [1, 3, 5, 7, 9, 8, 6, 4, 2]    Log( 'Unsorted: %@', a)    Log( 'Sorted: %@', quicksort(a) )    b := ['Emil', 'Peg', 'Helen', 'Juergen', 'David', 'Rick', 'Barb', 'Mike', 'Tom']    Log( 'Unsorted: %@', b)    Log( 'Sorted: %@', quicksort(b) )   return 0#import <Foundation/Foundation.h> implementation Array (Quicksort)   plus: Array array, return Array =     self.arrayByAddingObjectsFromArray: array   filter: BOOL (^)(id) predicate, return Array    array := []    for id item in self      if predicate(item)        array.addObject: item    return array.copy   quicksort, return Array = self    if self.count > 1            id x = self[self.count / 2]      lesser := self.filter: (id y | return y < x)      greater := self.filter: (id y | return y > x)      return lesser.quicksort + [x] + greater.quicksort end int main()  autoreleasepool    a := [1, 3, 5, 7, 9, 8, 6, 4, 2]    Log( 'Unsorted: %@', a)    Log( 'Sorted: %@', a.quicksort )    b := ['Emil', 'Peg', 'Helen', 'Juergen', 'David', 'Rick', 'Barb', 'Mike', 'Tom']    Log( 'Unsorted: %@', b)    Log( 'Sorted: %@', b.quicksort )   return 0void quicksortInPlace( *array, NSInteger first, NSInteger last, NSComparator comparator) {    if (first >= last) return;    id pivot = array[(first + last) / 2];    NSInteger left = first;    NSInteger right = last;    while (left <= right) {        while (comparator(array[left], pivot) == NSOrderedAscending)            left++;        while (comparator(array[right], pivot) == NSOrderedDescending)            right--;        if (left <= right)            [array exchangeObjectAtIndex:left++ withObjectAtIndex:right--];    }    quicksortInPlace(array, first, right, comparator);    quicksortInPlace(array, left, last, comparator);} * quicksort( *unsorted, NSComparator comparator) {     *a = [ arrayWithArray:unsorted];    quicksortInPlace(a, 0, a.count - 1, comparator);    return a;} int main(int argc, const char * argv[]) {    @autoreleasepool {         *a = @[ @1, @3, @5, @7, @9, @8, @6, @4, @2 ];        NSLog(@strv, a);        NSLog(@strv, quicksort(a, ^(id x, id y) { return [x compare:y]; }));         *b = @[ @strv, @strv, @strv, @strv, @strv, @strv, @strv, @strv, @strv ];        NSLog(@strv, b);        NSLog(@strv, quicksort(b, ^(id x, id y) { return [x compare:y]; }));    }    return 0;}"
"#import <Foundation/Foundation.h> #define esign(X) (((X)>0)?1:(((X)<0)?-1:0)) int main(){  @autoreleasepool {      *arr =    [      arrayWithArray: [@strv                       componentsSeparatedByString: @strv]     ];     [arr sortUsingComparator: ^NSComparisonResult(id obj1, id obj2){      NSComparisonResult l = esign((int)([obj1 length] - [obj2 length]));      return l ? -l 
               : [obj1 caseInsensitiveCompare: obj2];     }];     for(  *str in arr )    {      NSLog(@strv, str);    }   }  return EXIT_SUCCESS;}#import <Foundation/Foundation.h> @interface  (CustomComp)- (NSComparisonResult)my_compare: (id)obj;@end #define esign(X) (((X)>0)?1:(((X)<0)?-1:0))@implementation  (CustomComp)- (NSComparisonResult)my_compare: (id)obj{  NSComparisonResult l = esign((int)([self length] - [obj length]));  return l ? -l 
           : [self caseInsensitiveCompare: obj];}@end int main(){  @autoreleasepool {      *arr =       [         arrayWithArray: [@strv                           componentsSeparatedByString: @strv]       ];     [arr sortUsingSelector: @selector(my_compare:)];     for (  *str in arr )    {      NSLog(@strv, str);    }   }  return EXIT_SUCCESS;}#import <Foundation/Foundation.h> int main(){  @autoreleasepool {      *strings = [@strv componentsSeparatedByString:@strv];      *sd1 = [[ alloc] initWithKey:@strv ascending:NO];     *sd2 = [[ alloc] initWithKey:@strv ascending:YES];      *sorted = [strings sortedArrayUsingDescriptors:@[sd1, sd2]];    NSLog(@strv, sorted);   }   return 0;}"
"#import <Foundation/Foundation.h> @interface DisjointSublistView :  {   *array;  int *indexes;  int num_indexes;}- (instancetype)initWithArray:( *)a andIndexes:( *)ind;@end @implementation DisjointSublistView- (instancetype)initWithArray:( *)a andIndexes:( *)ind {  if ((self = [super init])) {    array = a;    num_indexes = [ind count];    indexes = (num_indexes * (int));    for (NSUInteger i = [ind firstIndex], j = 0; i != NSNotFound; i = [ind indexGreaterThanIndex:i], j++)      indexes[j] = i;  }  return self;}- (void)dealloc {  (indexes);}- (NSUInteger)count { return num_indexes; }- (id)objectAtIndex:(NSUInteger)i { return array[indexes[i]]; }- (void)replaceObjectAtIndex:(NSUInteger)i withObject:(id)x { array[indexes[i]] = x; }@end @interface  (SortDisjoint)- (void)sortDisjointSublist:( *)indexes usingSelector:(SEL)comparator;@end@implementation  (SortDisjoint)- (void)sortDisjointSublist:( *)indexes usingSelector:(SEL)comparator {  DisjointSublistView *d = [[DisjointSublistView alloc] initWithArray:self andIndexes:indexes];  [d sortUsingSelector:comparator];}@end int main(int argc, const char *argv[]) {  @autoreleasepool {      *a = [@[@7, @6, @5, @4, @3, @2, @1, @0] mutableCopy];     *ind = [ indexSet];    [ind addIndex:6]; [ind addIndex:1]; [ind addIndex:7];    [a sortDisjointSublist:ind usingSelector:@selector(compare:)];    NSLog(@strv, a);   }  return 0;}"
" *nums = @[@2, @4, @3, @1, @2]; *sorted = [nums sortedArrayUsingSelector:@selector(compare:)];"
"@interface Pair :  {     *name;     *value;}+(instancetype)pairWithName:( *)n value:( *)v;-(instancetype)initWithName:( *)n value:( *)v;-( *)name;-( *)value;@end @implementation Pair+(instancetype)pairWithName:( *)n value:( *)v {    return [[self alloc] initWithName:n value:v];}-(instancetype)initWithName:( *)n value:( *)v {    if ((self = [super init])) {        name = n;        value = v;    }    return self;}-( *)name { return name; }-( *)value { return value; }-( *)description {    return [ stringWithFormat:@strv, name, value];}@end int main() {    @autoreleasepool {          *pairs = @[                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv],                       [Pair pairWithName:@strv value:@strv]];         
         *sd = [[ alloc] initWithKey:@strv ascending:YES];         
        
         *sorted = [pairs sortedArrayUsingDescriptors:@[sd]];        NSLog(@strv, sorted);     }     return 0;}"
"
 
 *oStream;[ getStreamsToHost:[ hostWithName:@strv] port:256 inputStream:NULL outputStream:&oStream];[oStream setDelegate:self];[oStream scheduleInRunLoop:[ currentRunLoop] forMode:NSDefaultRunLoopMode];[oStream open];  
- (void)stream:( *)aStream handleEvent:(NSStreamEvent)streamEvent {     *oStream = ( *)aStream;    if (streamEvent == NSStreamEventHasBytesAvailable) {         *str = @strv;        const char *rawstring = [str UTF8String];        [oStream write:rawstring maxLength:(rawstring)];        [oStream close];    }}"
"#import <Foundation/Foundation.h> int main(){  @autoreleasepool {     NSTimeInterval sleeptime;    (strv);    (strv, &sleeptime);     NSLog(@strv);    [ sleepForTimeInterval: sleeptime];    NSLog(@strv);   }  return 0;}"
"RCListElement *current;for(current=first_of_the_list; current != nil; current = [current next] ){  
  
}"
#import <Foundation/Foundation.h> @interface RCListElement<T> : {  RCListElement<T> *next;  T datum;}- (RCListElement<T> *)next;- (T)datum;- (RCListElement<T> *)setNext: (RCListElement<T> *)nx;- (void)setDatum: (T)d;@end @implementation RCListElement- (RCListElement *)next{  return next;}- (id)datum{  return datum;}- (RCListElement *)setNext: (RCListElement *)nx{  RCListElement *p = next;  next = nx;  return p;}- (void)setDatum: (id)d{  datum = d;}@end
"
@interface SomeSingleton : {  
} + (SomeSingleton *)sharedInstance; @end
@implementation SomeSingleton + (SomeSingleton *) sharedInstance{   static SomeSingleton *sharedInstance = nil;   if (!sharedInstance) {      sharedInstance = [[SomeSingleton alloc] init];   }   return sharedInstance;} - (id)copyWithZone:(NSZone *)zone{    return self;} - (id)retain{    return self;} - (unsigned)retainCount{    return UINT_MAX;} - (oneway void)release{    
} - (id)autorelease{    return self;} @end+ (SomeSingleton *) sharedInstance{   static SomeSingleton *sharedInstance = nil;   @synchronized(self) {      if (!sharedInstance) {         sharedInstance = [[SomeSingleton alloc] init];      }   }   return sharedInstance;}+ (SomeSingleton *) sharedInstance{   static SomeSingleton *sharedInstance = nil;   static dispatch_once_t onceToken;   dispatch_once(&onceToken, ^{      sharedInstance = [[SomeSingleton alloc] init];   });   return sharedInstance;}"
"#import <Foundation/Foundation.h> int main(int argc, const char *argv[]) {  @autoreleasepool {      *t = [ dateWithTimeIntervalSinceReferenceDate:0];     *dateFormatter = [[ alloc] init];    [dateFormatter setTimeZone:[ timeZoneWithName:@strv]];    [dateFormatter setDateFormat:@strv];    NSLog(@strv, [dateFormatter stringFromDate:t]);   }  return 0;}"
"#include <Foundation/Foundation.h>#include <AppKit/AppKit.h> @interface ClickMe : {   *_button;   *_text;  int _counter;}- (void)applicationDidFinishLaunching: ( *)notification;- (BOOL)applicationShouldTerminateAfterLastWindowClosed: ( *)notification;- (void)advanceCounter: (id)sender;@end@implementation ClickMe : -(instancetype) init{   *button = [[ alloc] init];  [button setButtonType: NSToggleButton];  [button setTitle: @strv];  [button sizeToFit];  [button setTarget: self];  [button setAction: @selector(advanceCounter:)];  NSRect buttonRect = [button frame];    *text = [[ alloc] 	   initWithFrame: NSMakeRect(buttonRect.origin.x, buttonRect.size.height,				     buttonRect.size.width, buttonRect.size.height)];  [text setAlignment: NSCenterTextAlignment];  [text setEditable: NO];  [text setStringValue: @strv];  [text sizeToFit];   
  [button     setFrameSize: NSMakeSize( [text frame].size.width, buttonRect.size.height ) ];   int totalWindowHeight = buttonRect.size.height + [text frame].size.height;   if ((self = [super initWithContentRect: NSMakeRect(100, 100, 				    [text frame].size.width, totalWindowHeight)        styleMask: (NSTitledWindowMask | NSClosableWindowMask)      backing: NSBackingStoreBuffered      defer: NO])) {    _counter = 0;    _button = button;    _text = text;     [[self contentView] addSubview: _text];    [[self contentView] addSubview: _button];     [self setTitle: @strv];    [self center];  }  return self;}  - (void)applicationDidFinishLaunching: ( *)notification{  [self orderFront: self];} - (BOOL)applicationShouldTerminateAfterLastWindowClosed: ( *)notification{  return YES;} - (void)advanceCounter: (id)sender{  [_text setStringValue: [ stringWithFormat: @strv, ++_counter]];}@end  int main(){  @autoreleasepool {     *app =  [ sharedApplication];    ClickMe *clickme = [[ClickMe alloc] init];    [app setDelegate: clickme];    [app run];  }  return 0;}"
"#import <Cocoa/Cocoa.h>#import <CommonCrypto/CommonDigest.h>  int main(int argc, char ** argv) {     * msg = @strv;    unsigned char buf[CC_SHA256_DIGEST_LENGTH];    const char * rc = [msg cStringUsingEncoding:NSASCIIStringEncoding];    if (! CC_SHA256(rc, (rc), buf)) {        NSLog(@strv);        return -1;    }     * res = [ stringWithCapacity:(CC_SHA256_DIGEST_LENGTH * 2)];    for (int i = 0; i < CC_SHA256_DIGEST_LENGTH; ++i) {        [res appendFormat:@strv, buf[i]];    }    NSLog(@strv, res);    return 0;} "
"#import <Foundation/Foundation.h> @interface Example : - ( *)foo;@end @implementation Example- ( *)foo {  return @42;}@end int main (int argc, const char *argv[]) {  @autoreleasepool {     id example = [[Example alloc] init];    SEL selector = @selector(foo); 
    NSLog(@strv, [example performSelector:selector]);   }  return 0;}"
"#import <Foundation/Foundation.h> int main (int argc, const char *argv[]) {  @autoreleasepool {      *s1 = [ setWithObjects:@strv, @strv, @strv, @strv, @strv, nil];     *s2 = [ setWithObjects:@strv, @strv, @strv, @strv, @strv, @strv, nil];     *s3 = [ setWithObjects:@strv, @strv, @strv, nil];     *s4 = [ setWithObjects:@strv, @strv, @strv, nil];    NSLog(@strv, s1);    NSLog(@strv, s2);    NSLog(@strv, s3);    NSLog(@strv, s4);     
    NSLog(@strv, [s1 containsObject:@strv]);    NSLog(@strv, [s1 containsObject:@strv]);     
     *s12 = [ setWithSet:s1];    [s12 unionSet:s2];    NSLog(@strv, s12);     
     *s1i2 = [ setWithSet:s1];    [s1i2 intersectSet:s2];    NSLog(@strv, s1i2);     
     *s1_2 = [ setWithSet:s1];    [s1_2 minusSet:s2];    NSLog(@strv, s1_2);     
    NSLog(@strv, [s3 isSubsetOfSet:s1]);     
    NSLog(@strv, [s3 isEqualToSet:s4]);     
    NSLog(@strv, [s1 count]);     
    NSLog(@strv, [s1 intersectsSet:s2]);     
     *mut_s1 = [ setWithSet:s1];    [mut_s1 addObject:@strv];    NSLog(@strv, mut_s1);    [mut_s1 addObject:@strv];    NSLog(@strv, mut_s1);    [mut_s1 removeObject:@strv];    NSLog(@strv, mut_s1);   }  return 0;}"
"#include <Foundation/Foundation.h> 
@interface Dummy : - (void)grill;- (void)ding:( *)s;@end @interface Example : - (void)foo;- (void)bar;@end @implementation Example- (void)foo {  NSLog(@strv);} - (void)bar {  NSLog(@strv);} - (void)forwardInvocation:( *)inv {  NSLog(@strv, NSStringFromSelector([inv selector]));  NSUInteger n = [[inv methodSignature] numberOfArguments];  for (NSUInteger i = 0; i < n-2; i++) { 
    id __unsafe_unretained arg;          
                                         
                                         
    [inv getArgument:&arg atIndex:i+2];    NSLog(@strv, i, arg);  }} 

- ( *)methodSignatureForSelector:(SEL)aSelector {  int numArgs = [[NSStringFromSelector(aSelector) componentsSeparatedByString:@strv] count] - 1;  
  
  
  
  return [ signatureWithObjCTypes:          [[@strv stringByPaddingToLength:numArgs+3 withString:@strv startingAtIndex:0] UTF8String]];}@end int main(){  @autoreleasepool {     id example = [[Example alloc] init];     [example foo];          
    [example bar];          
    [example grill];        
    [example ding:@strv]; 
                            
   }  return 0;}"
" *haystack = @[@strv,@strv,@strv,@strv,@strv,@strv,@strv,@strv,@strv];for (id needle in @[@strv,@strv]) {    int index = [haystack indexOfObject:needle];    if (index == NSNotFound)        NSLog(@strv, needle);    else        NSLog(@strv, index, needle);}"
"#import <Foundation/Foundation.h> @interface  (Extended)-( *)reverseString;@end @implementation  (Extended)-( *) reverseString{    NSUInteger len = [self length];     *rtr=[ stringWithCapacity:len];    
     while (len > (NSUInteger)0) {         unichar uch = [self characterAtIndex:--len];         [rtr appendString:[ stringWithCharacters:&uch length:1]];    }    return rtr;}@endint main(){    @autoreleasepool {          *test = [@strv reverseString];         NSLog(@strv, test);     }    return 0;}#import <Foundation/Foundation.h> @interface  (Extended)-( *)reverseString;@end @implementation  (Extended)-( *)reverseString{	NSInteger l = [self length] - 1;	 *ostr = [ stringWithCapacity:[self length]];	while (l >= 0)	{		NSRange range = [self rangeOfComposedCharacterSequenceAtIndex:l];		[ostr appendString:[self substringWithRange:range]];		l -= range.length;	}	return ostr;}@endint main(){    @autoreleasepool {          *test = [@strv reverseString];         NSLog(@strv, test);     }    return 0;}"
" *fm = [ defaultManager]; 
[fm movePath:@strv toPath:@strv handler:nil];[fm movePath:@strv toPath:@strv handler:nil]; 
[fm moveItemAtPath:@strv toPath:@strv error:NULL];[fm moveItemAtPath:@strv toPath:@strv error:NULL];"
"@interface  (RosettaCodeAddition)- ( *) repeatStringByNumberOfTimes: (NSUInteger) times;@end @implementation  (RosettaCodeAddition)- ( *) repeatStringByNumberOfTimes: (NSUInteger) times {    return [@strv stringByPaddingToLength:[self length]*times withString:self startingAtIndex:0];}@end    
    
     *aString = [@strv repeatStringByNumberOfTimes:5];     
    NSLog(@strv, aString);"
" *items = [ arrayWithObjects:@strv, @strv, @strv, @strv, @strv, nil];  *unique = [ setWithArray:items];"
"#import <Foundation/Foundation.h>#import <objc/runtime.h> @interface Foo :  {  int exampleIvar;}@property (nonatomic) double exampleProperty;@end@implementation Foo- (instancetype)init {  self = [super init];  if (self) {    exampleIvar = 42;    _exampleProperty = 3.14;  }  return self;}@end int main() {  id obj = [[Foo alloc] init];  Class clazz = [obj class];   NSLog(@""nstance variables:"");  unsigned int ivarCount;  Ivar *ivars = class_copyIvarList(clazz, &ivarCount);  for (unsigned int i = 0; i < ivarCount; i++) {    Ivar ivar = ivars[i];    const char *name = ivar_getName(ivar);    const char *typeEncoding = ivar_getTypeEncoding(ivar);    
    
    
    id value = [obj valueForKey:@(name)];    NSLog(@""%s%s%@"", name, typeEncoding, value);  }  (ivars);   NSLog(@strv);  NSLog(@strv);  unsigned int propCount;  objc_property_t *properties = class_copyPropertyList([Foo class], &propCount);  for (unsigned int i = 0; i < propCount; i++) {    objc_property_t p = properties[i];    const char *name = property_getName(p);    const char *attributes = property_getAttributes(p);    
    
    
    id value = [obj valueForKey:@(name)];    NSLog(@""%s%s%@"", name, attributes, value);  }  (properties);   return 0;}"
" *str = @strv; *regex = @strv; 
 *pred = [ predicateWithFormat:@strv, regex]; if ([pred evaluateWithObject:str]) {    NSLog(@strv);} *str = @strv;if ([str rangeOfString:@strv options:NSRegularExpressionSearch].location != NSNotFound) {    NSLog(@strv);} *orig = @strv; *result = [orig stringByReplacingOccurrencesOfString:@strv                                                   withString:@strv                                                      options:NSRegularExpressionSearch                                                        range:NSMakeRange(0, [orig length])];NSLog(@strv, result);NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@strv                                                                       options:0                                                                         error:NULL]; *str = @strv;if ([regex rangeOfFirstMatchInString:str                             options:0                               range:NSMakeRange(0, [str length])     ].location != NSNotFound) {    NSLog(@strv);}for (NSTextCheckingResult *match in [regex matchesInString:str                                                   options:0                                                     range:NSMakeRange(0, [str length])                                     ]) {    
    
} *orig = @strv;NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@strv                                                                       options:0                                                                         error:NULL]; *result = [regex stringByReplacingMatchesInString:orig                                                   options:0                                                     range:NSMakeRange(0, [orig length])                                              withTemplate:@strv];NSLog(@strv, result);"
"#import <Foundation/Foundation.h>#import <objc/runtime.h> @interface Foo : @end@implementation Foo- (int)bar:(double)x {  return 42;}@end int main() {  unsigned int methodCount;  Method *methods = class_copyMethodList([Foo class], &methodCount);  for (unsigned int i = 0; i < methodCount; i++) {    Method m = methods[i];    SEL selector = method_getName(m);    const char *typeEncoding = method_getTypeEncoding(m);    NSLog(@""%@%s"", NSStringFromSelector(selector), typeEncoding);  }  (methods);  return 0;}"
"     /*** 0. PREPARATION    */    
    
     (""echo Hello, World! > ~/HelloRosetta"");       /*** 1. THE TASK      */    
    
     *filePath = [NSHomeDirectory() stringByAppendingPathComponent:@strv];     
    
    
    
    
     *anError;     
    
     *aString = [ stringWithContentsOfFile:filePath                                                  encoding:NSUTF8StringEncoding                                                     error:&anError];     
    
    if (!aString) {        NSLog(@strv, [anError localizedDescription]);    } else {        NSLog(@strv, aString);    } "
 *path = [ stringWithString:@strv]; *error = nil; *words = [[ alloc] initWithContentsOfFile:path                                               encoding:NSUTF8StringEncoding error:&error]; * lines = [words componentsSeparatedByCharactersInSet:[ newlineCharacterSet]];
"#import <Foundation/Foundation.h> int main(int argc, char **argv) {	@autoreleasepool { 		char *program = argv[0];		(""Program: %s"", program); 		
		 *program2 = [[ processInfo] processName];		NSLog(@""Program: %@"", program2); 	} 	return 0;}"
"#import <Foundation/Foundation.h>  *extractRanges( *nums) {   *indexSet = [[ alloc] init];  for ( *n in nums) {    if ([n integerValue] < 0)      @throw [ exceptionWithName:NSInvalidArgumentException reason:@strv userInfo:nil];    [indexSet addIndex:[n unsignedIntegerValue]];  }   *s = [[ alloc] init];  [indexSet enumerateRangesUsingBlock:^(NSRange range, BOOL *stop) {    if (s.length)      [s appendString:@strv];    if (range.length == 1)      [s appendFormat:@strv, range.location];    else if (range.length == 2)      [s appendFormat:@strv, range.location, range.location+1];    else      [s appendFormat:@strv, range.location, range.location+range.length-1];  }];  return s;} int main() {  @autoreleasepool {     NSLog(@strv, extractRanges(@[@0, @1, @2, @4, @6, @7, @8, @11, @12, @14,                                 @15, @16, @17, @18, @19, @20, @21, @22, @23, @24,                                 @25, @27, @28, @29, @30, @31, @32, @33, @35, @36,                                 @37, @38, @39]));   }  return 0;}"
"@interface T : - (void)identify;@end @implementation T- (void)identify {    NSLog(@strv);}- (id)copyWithZone:(NSZone *)zone {    T *copy = [[[self class] allocWithZone:zone] init]; 
                                                        
                                                        
                                                        
    return copy;}@end @interface S : T@end @implementation S- (void)identify{    NSLog(@strv);}@end int main(){    @autoreleasepool {         T *original = [[S alloc] init];        T *another = [original copy];        [another identify]; 
     }    return 0;}"
"#import <Foundation/Foundation.h> @interface RCPoint :  {  int x, y;}-(instancetype)initWithX:(int)x0;-(instancetype)initWithX:(int)x0 andY:(int)y0;-(instancetype)initWithPoint:(RCPoint *)p;@property (nonatomic) int x;@property (nonatomic) int y;@end @implementation RCPoint@synthesize x, y;-(instancetype)initWithX:(int)x0 { return [self initWithX:x0 andY:0]; }-(instancetype)initWithX:(int)x0 andY:(int)y0 {  if ((self = [super init])) {    x = x0;    y = y0;  }  return self;}-(instancetype)initWithPoint:(RCPoint *)p { return [self initWithX:p.x andY:p.y]; }-( *)description { return [ stringWithFormat:@strv, self, x, y]; }@end @interface RCCircle : RCPoint {  int r;}-(instancetype)initWithCenter:(RCPoint *)p andRadius:(int)r0;-(instancetype)initWithX:(int)x0 andY:(int)y0 andRadius:(int)r0;-(instancetype)initWithCircle:(RCCircle *)c;@property (nonatomic) int r;@end @implementation RCCircle@synthesize r;-(instancetype)initWithCenter:(RCPoint *)p andRadius:(int)r0 {  if ((self = [super initWithPoint:p])) {    r = r0;  }  return self;}-(instancetype)initWithX:(int)x0 andY:(int)y0 andRadius:(int)r0 {  if ((self = [super initWithX:x0 andY:y0])) {    r = r0;  }  return self;}-(instancetype)initWithCircle:(RCCircle *)c { return [self initWithX:c.x andY:c.y andRadius:c.r]; }-( *)description { return [ stringWithFormat:@strv, self, x, y, r]; }@end int main(int argc, const char *argv[]) {  @autoreleasepool {     NSLog(@strv, [[RCPoint alloc] init]);    NSLog(@strv, [[RCPoint alloc] initWithX:3]);    NSLog(@strv, [[RCPoint alloc] initWithX:3 andY:4]);    NSLog(@strv, [[RCCircle alloc] init]);    NSLog(@strv, [[RCCircle alloc] initWithX:3]);    NSLog(@strv, [[RCCircle alloc] initWithX:3 andY:4]);    NSLog(@strv, [[RCCircle alloc] initWithX:3 andY:4 andRadius:7]);    RCPoint *p = [[RCPoint alloc] initWithX:1 andY:2];      NSLog(@strv, [[RCCircle alloc] initWithPoint:p]);    NSLog(@strv, [[RCCircle alloc] initWithCenter:p andRadius:7]);    NSLog(@strv, p.x); 
    p.x = 8;    NSLog(@strv, p.x); 
   }  return 0;}"
"#import <Foundation/Foundation.h> const void *PQRetain(CFAllocatorRef allocator, const void *ptr) {  return (__bridge_retained const void *)(__bridge id)ptr;}void PQRelease(CFAllocatorRef allocator, const void *ptr) {  (void)(__bridge_transfer id)ptr;}CFComparisonResult PQCompare(const void *ptr1, const void *ptr2, void *unused) {  return [(__bridge id)ptr1 compare:(__bridge id)ptr2];} @interface Task :  {  int priority;   *name;}- (instancetype)initWithPriority:(int)p andName:( *)n;- (NSComparisonResult)compare:(Task *)other;@end @implementation Task- (instancetype)initWithPriority:(int)p andName:( *)n {  if ((self = [super init])) {    priority = p;    name = [n copy];  }  return self;}- ( *)description {  return [ stringWithFormat:@strv, priority, name];}- (NSComparisonResult)compare:(Task *)other {  if (priority == other->priority)    return NSOrderedSame;  else if (priority < other->priority)    return NSOrderedAscending;  else    return NSOrderedDescending;}@end int main (int argc, const char *argv[]) {  @autoreleasepool {     CFBinaryHeapCallBacks callBacks = {0, PQRetain, PQRelease, NULL, PQCompare};    CFBinaryHeapRef pq = CFBinaryHeapCreate(NULL, 0, &callBacks, NULL);     CFBinaryHeapAddValue(pq, [[Task alloc] initWithPriority:3 andName:@strv]);    CFBinaryHeapAddValue(pq, [[Task alloc] initWithPriority:4 andName:@strv]);    CFBinaryHeapAddValue(pq, [[Task alloc] initWithPriority:5 andName:@strv]);    CFBinaryHeapAddValue(pq, [[Task alloc] initWithPriority:1 andName:@strv]);    CFBinaryHeapAddValue(pq, [[Task alloc] initWithPriority:2 andName:@strv]);     while (CFBinaryHeapGetCount(pq) != 0) {      Task *task = (id)CFBinaryHeapGetMinimum(pq);      NSLog(@strv, task);      CFBinaryHeapRemoveMinimumValue(pq);    }     CFRelease(pq);   }  return 0;}"
@interface Tree<T> :  {  T value;  Tree<T> *left;  Tree<T> *right;} - (void)replaceAll:(T)v;@end @implementation Tree- (void)replaceAll:(id)v {  value = v;  [left replaceAll:v];  [right replaceAll:v];}@end
"#import <Foundation/Foundation.h> 
@interface Animal :  <NSCoding>{   *animalName;  int numberOfLegs;}- (instancetype) initWithName: (*)name andLegs: (NSInteger)legs;- (void) dump;@end @implementation Animal- (instancetype) initWithName: (*)name andLegs: (NSInteger)legs{  if ((self = [super init])) {    animalName = name;    numberOfLegs = legs;  }  return self;}- (void) dump{  NSLog(@strv, animalName, numberOfLegs);}
- (void) encodeWithCoder: (*)coder{  [coder encodeObject: animalName forKey: @strv];  [coder encodeInt: numberOfLegs forKey: @strv];}- (instancetype) initWithCoder: (*)coder{  if ((self = [super init])) {    animalName = [coder decodeObjectForKey: @strv];    numberOfLegs = [coder decodeIntForKey: @strv];  }  return self;}@end @interface Mammal : Animal <NSCoding>{  BOOL hasFur;   *eatenList;}- (instancetype) initWithName: (*)name hasFur: (BOOL)fur;- (void) addEatenThing: (*)thing;@end @implementation Mammal- (instancetype) init{  if ((self = [super init])) {    hasFur = NO;    eatenList = [[ alloc] initWithCapacity: 10];  }  return self;}- (instancetype) initWithName: (*)name hasFur: (BOOL)fur{  if ((self = [super initWithName: name andLegs: 4])) {    hasFur = fur;    eatenList = [[ alloc] initWithCapacity: 10];  }  return self;}- (void) addEatenThing: (*)thing{  [eatenList addObject: thing];}- (void) dump{  [super dump];  NSLog(@strv, (hasFur) ? @strv : @strv );  NSLog(@strv, [eatenList count]);  for ( id element in eatenList )    NSLog(@strv, element);  NSLog(@strv);}
- (void) encodeWithCoder: (*)coder{  [super encodeWithCoder: coder];  [coder encodeBool: numberOfLegs forKey: @strv];  [coder encodeObject: eatenList forKey: @strv];}- (instancetype) initWithCoder: (*)coder{  if ((self = [super initWithCoder: coder])) {    hasFur = [coder decodeBoolForKey: @strv];    eatenList = [coder decodeObjectForKey: @strv];  }  return self;}@end  int main(){  @autoreleasepool {     
    Animal *anAnimal = [[Animal alloc]	         initWithName: @strv	         andLegs: 7	        ];    
    
     
    Mammal *aMammal = [[Mammal alloc]	        initWithName: @strv	        hasFur: YES	       ];    
    [aMammal addEatenThing: @strv];    [aMammal addEatenThing: @strv];    [aMammal addEatenThing: @strv];     
    NSLog(@strv);    [anAnimal dump];     
    NSLog(@strv);    [aMammal dump];     
     *data = [[ alloc] init];     *arch = [[ alloc]			      initForWritingWithMutableData: data];    [arch encodeObject: anAnimal forKey: @strv];    [arch encodeObject: aMammal forKey: @strv];    [arch finishEncoding];    [data writeToFile: @strv atomically: YES];     
     *ldata = [[ alloc]		       initWithContentsOfFile: @strv];    NSKeyedUnarchived *darch = [[ alloc]	                         initForReadingWithData: ldata];    Animal *archivedAnimal = [darch decodeObjectForKey: @strv];    Mammal *archivedMammal = [darch decodeObjectForKey: @strv];    [darch finishDecoding];     
    NSLog(@"""");    NSLog(@strv);    [archivedAnimal dump];    NSLog(@strv);    [archivedMammal dump];   }  return EXIT_SUCCESS;}"
"
if (object == nil) {   NSLog(strv);}[nil fooBar];"
#import <Foundation/Foundation.h> + ( *)powerSetForArray:( *)array {	UInt32 subsetCount = 1 << array.count;	 *subsets = [ arrayWithCapacity:subsetCount];	for(int subsetIndex = 0; subsetIndex < subsetCount; subsetIndex++) {		 *subset = [[ alloc] init];		for (int itemIndex = 0; itemIndex < array.count; itemIndex++) {			if((subsetIndex >> itemIndex) & 0x1) {				[subset addObject:array[itemIndex]];			}		}				[subsets addObject:subset];	}	return subsets;}
" *makeList( *separator) {  __block int counter = 1;    *(^makeItem)( *) = ^( *item) {    return [ stringWithFormat:@""%d%@%@"", counter++, separator, item];  };   return [ stringWithFormat:@strv, makeItem(@strv), makeItem(@strv), makeItem(@strv)];} int main() {  NSLog(@strv, makeList(@strv));  return 0;}"
"@interface Demo :  {    
} - (double) hypotenuseOfX: (double)x andY: (double)y;- (double) hypotenuseOfX: (double)x andY: (double)y andZ: (double)z; @end@implementation Demo - (double) hypotenuseOfX: (double)x andY: (double)y {    return hypot(x,y);}- (double) hypotenuseOfX: (double)x andY: (double)y andZ: (double)z {    return hypot(hypot(x, y), z);} @endDemo *example = [[Demo alloc] init];double h = [example hypotenuseOfX:1.23 andY:3.79];"
"#import <Foundation/Foundation.h> int main() {  @autoreleasepool {      *numberFormatter = [[ alloc] init];    numberFormatter.numberStyle = NSNumberFormatterSpellOutStyle;    numberFormatter.locale = [[ alloc] initWithLocaleIdentifier:@strv];     for ( *n in @[@900000001, @1234567890, @-987654321, @0, @3.14]) {      NSLog(@strv, [numberFormatter stringFromNumber:n]);    }   }  return 0;}"
"typedef enum { kOrdNone, kOrdLex, kOrdByAddress, kOrdNumeric } SortOrder; @interface MyArray :  {}
@end @implementation MyArray - (void)sort {    [self sortWithOrdering:kOrdLex onColumn:0 reversed:NO];} - (void)sortWithOrdering:(SortOrder)ord {    [self sortWithOrdering:ord onColumn:0 reversed:NO];} - (void)sortWithOrdering:(SortOrder)ord onColumn:(int)col {    [self sortWithOrdering:ord onColumn:col reversed:NO];} - (void)sortWithOrdering:(SortOrder)ord onColumn:(int)col reversed:(BOOL)rev {    
} @end"
" *m = [[ alloc] init]; [m lock]; 
 if ([m tryLock]) { 
  
} else {  
} [m unlock];"
"#import <objc/Object.h> @interface ScriptedMain: Object {} + (int)meaningOfLife; @end#import strv#import <Foundation/Foundation.h> @implementation ScriptedMain + (int)meaningOfLife {	return 42;} @end int __attribute__((weak)) main(int argc, char **argv) {	@autoreleasepool { 		(""Main: The meaning of life is %d"", [ScriptedMain meaningOfLife]); 	} 	return 0;}#import strv#import <Foundation/Foundation.h> int main(int argc, char **argv) {	@autoreleasepool { 		(""Test: The meaning of life is %d"", [ScriptedMain meaningOfLife]); 	} 	return 0;}"
"#import <Foundation/Foundation.h> @interface Hofstadter : + (int)M: (int)n;+ (int)F: (int)n;@end @implementation Hofstadter+ (int)M: (int)n{  if ( n == 0 ) return 0;  return n - [self F: [self M: (n-1)]];}+ (int)F: (int)n{  if ( n == 0 ) return 1;  return n - [self M: [self F: (n-1)]];}@end int main(){  int i;   for(i=0; i < 20; i++) {    (strv, [Hofstadter F: i]);  }  ("""");  for(i=0; i < 20; i++) {    (strv, [Hofstadter M: i]);  }  ("""");  return 0;}"
" *myString = @strv; *digest = [[myString dataUsingEncoding:NSUTF8StringEncoding] md5Digest]; 
NSLog(@strv, [digest hexadecimalRepresentation]);#import <CommonCrypto/CommonDigest.h>  *myString = @strv; *data = [myString dataUsingEncoding:NSUTF8StringEncoding]; 
unsigned char digest[CC_MD5_DIGEST_LENGTH];if (CC_MD5([data bytes], [data length], digest)) {     *hex = [ string];    for (int i = 0; i < CC_MD5_DIGEST_LENGTH; i++) {        [hex appendFormat: @strv, (int)(digest[i])];    }    NSLog(@strv, hex);}#include <openssl/md5.h>  *myString = @strv; *data = [myString dataUsingEncoding:NSUTF8StringEncoding]; 
unsigned char digest[MD5_DIGEST_LENGTH];if (MD5([data bytes], [data length], digest)) {     *hex = [ string];    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {        [hex appendFormat: @strv, (int)(digest[i])];    }    NSLog(@strv, hex);}"
"#import <Foundation/Foundation.h> typedef NSInteger (^IntegerBlock)(void); NSInteger A (NSInteger kParam, IntegerBlock x1, IntegerBlock x2, IntegerBlock x3, IntegerBlock x4, IntegerBlock x5) {    __block NSInteger k = kParam;    __block __weak IntegerBlock weak_B;    IntegerBlock B;    weak_B = B = ^ {        return A(--k, weak_B, x1, x2, x3, x4);    };    return k <= 0 ? x4() + x5() : B();} IntegerBlock K (NSInteger n) {    return ^{return n;};} int main (int argc, const char * argv[]) {    @autoreleasepool {        NSInteger result = A(10, K(1), K(-1), K(-1), K(1), K(0));        NSLog(@""%d"", result);    }    return 0;}#import <Foundation/Foundation.h> typedef NSInteger (^IntegerBlock)(void); NSInteger A (NSInteger kParam, IntegerBlock x1, IntegerBlock x2, IntegerBlock x3, IntegerBlock x4, IntegerBlock x5) {    __block NSInteger k = kParam;    __block IntegerBlock B;    B = ^ {        return A(--k, B, x1, x2, x3, x4);    };    return k <= 0 ? x4() + x5() : B();} IntegerBlock K (NSInteger n) {    return [[^{return n;} copy] autorelease];} int main (int argc, const char * argv[]) {     *pool = [[ alloc] init];    NSInteger result = A(10, K(1), K(-1), K(-1), K(1), K(0));    NSLog(@""%d"", result);    [pool drain];    return 0;}@protocol IntegerFun <NSObject>-(NSInteger)call;@end NSInteger A (NSInteger kParam, id<IntegerFun> x1, id<IntegerFun> x2, id<IntegerFun> x3, id<IntegerFun> x4, id<IntegerFun> x5); @interface B_Class :  <IntegerFun> {  NSInteger *k;  id<IntegerFun> x1, x2, x3, x4;}-(id)initWithK:(NSInteger *)k x1:(id<IntegerFun>)x1 x2:(id<IntegerFun>)x2 x3:(id<IntegerFun>)x3 x4:(id<IntegerFun>)x4;@end @implementation B_Class-(id)initWithK:(NSInteger *)_k x1:(id<IntegerFun>)_x1 x2:(id<IntegerFun>)_x2 x3:(id<IntegerFun>)_x3 x4:(id<IntegerFun>)_x4 {  if ((self = [super init])) {    k = _k;    x1 = [_x1 retain];    x2 = [_x2 retain];    x3 = [_x3 retain];    x4 = [_x4 retain];  }  return self;}-(void)dealloc {  [x1 release];  [x2 release];  [x3 release];  [x4 release];  [super dealloc];}-(NSInteger)call {  return A(--*k, self, x1, x2, x3, x4);}@end NSInteger A (NSInteger k, id<IntegerFun> x1, id<IntegerFun> x2, id<IntegerFun> x3, id<IntegerFun> x4, id<IntegerFun> x5) {  id<IntegerFun> B = [[[B_Class alloc] initWithK:&k x1:x1 x2:x2 x3:x3 x4:x4] autorelease];  return k <= 0 ? [x4 call] + [x5 call] : [B call];} @interface K :  <IntegerFun> {  NSInteger n;}-(id)initWithN:(NSInteger)n;@end @implementation K-(id)initWithN:(NSInteger)_n {  if ((self = [super init])) {    n = _n;  }  return self;}-(NSInteger)call {  return n;}@end int main(int argc, const char *argv[]) {   *pool = [[ alloc] init];   NSInteger result = A(10,                       [[[K alloc] initWithN:1] autorelease],                       [[[K alloc] initWithN:-1] autorelease],                       [[[K alloc] initWithN:-1] autorelease],                       [[[K alloc] initWithN:1] autorelease],                       [[[K alloc] initWithN:0] autorelease]);  NSLog(@""%ld"", result);   [pool release];  return 0;}"
"#import <Foundation/Foundation.h>#import <stdio.h> @interface LZWCompressor : {  @private     *iostream;     *dict;    NSUInteger codemark;} -(instancetype) init;-(instancetype) initWithArray: ( *) stream;-(BOOL) compressData: ( *) string;-(void) setArray: ( *) stream;-( *) getArray;@end @implementation LZWCompressor :  -(instancetype) init{   self = [super init];   if ( self )   {      iostream = nil;      codemark = 256;      dict = [[ alloc] initWithCapacity: 512];   }   return self;} -(instancetype) initWithArray: ( *) stream{   self = [self init];   if ( self )   {      [self setArray: stream];   }   return self;} -(void) setArray: ( *) stream{   iostream = stream;} -(BOOL) compressData: ( *) string;{    
    for(NSUInteger i=0; i < 256; i++)    {       unsigned char j = i;        *s = [ dataWithBytes: &j length: 1];       dict[s] = @(i);    }      *w = [ data];     for(NSUInteger i=0; i < [string length]; i++)    {        *wc = [ dataWithData: w];       [wc appendData: [string subdataWithRange: NSMakeRange(i, 1)]];       if ( dict[wc] != nil )       {          w = wc;       } else {          [iostream addObject: dict[w]];          dict[wc] = @(codemark);          codemark++;          w = [string subdataWithRange: NSMakeRange(i, 1)];       }    }    if ( [w length] != 0 )    {       [iostream addObject: dict[w]];    }    return YES;} -( *) getArray{  return iostream;} @end *text = @strv; int main(){  @autoreleasepool {      *array = [[ alloc] init];    LZWCompressor *lzw = [[LZWCompressor alloc]                          initWithArray: array ];    if ( lzw )    {       [lzw compressData: [text dataUsingEncoding: NSUTF8StringEncoding]];       for ( id obj in array )       {          (""%u"", [obj unsignedIntValue]);       }    }   }  return EXIT_SUCCESS;}"
"- ( *) toCharArray { 	 *characters = [[ alloc] initWithCapacity:[self length]];	for (int i=0; i < [self length]; i++) {		 *ichar  = [ stringWithFormat:@strv, [self characterAtIndex:i]];		[characters addObject:ichar];	} 	return characters;} + (BOOL) luhnCheck:( *)stringToTest { 	 *stringAsChars = [stringToTest toCharArray]; 	BOOL isOdd = YES;	int oddSum = 0;	int evenSum = 0; 	for (int i = [stringToTest length] - 1; i >= 0; i--) { 		int digit = [( *)stringAsChars[i] intValue]; 		if (isOdd) 			oddSum += digit;		else 			evenSum += digit/5 + (2*digit) % 10; 		isOdd = !isOdd;				 	} 	return ((oddSum + evenSum) % 10 == 0);} BOOL test0 = [self luhnCheck:@strv]; //Result = YESBOOL test1 = [self luhnCheck:@strv]; //Result = NOBOOL test2 = [self luhnCheck:@strv]; //Result = NO				   BOOL test3 = [self luhnCheck:@strv]; //Result = YES"
"#import <Foundation/Foundation.h> @interface Node :  {@public  id val;  Node *back;}@end @implementation Node@end @interface  (LIS)- ( *)longestIncreasingSubsequenceWithComparator:(NSComparator)comparator;@end @implementation  (LIS)- ( *)longestIncreasingSubsequenceWithComparator:(NSComparator)comparator {   *pileTops = [[ alloc] init];  
  for (id x in self) {    Node *node = [[Node alloc] init];    node->val = x;    int i = [pileTops indexOfObject:node                      inSortedRange:NSMakeRange(0, [pileTops count])                            options:NSBinarySearchingInsertionIndex|NSBinarySearchingFirstEqual                    usingComparator:^NSComparisonResult(Node *node1, Node *node2) {                      return comparator(node1->val, node2->val);                    }];    if (i != 0)      node->back = pileTops[i-1];    pileTops[i] = node;  }   
   *result = [[ alloc] init];  for (Node *node = [pileTops lastObject]; node; node = node->back)    [result addObject:node->val];  return [[result reverseObjectEnumerator] allObjects];}@end int main(int argc, const char *argv[]) {  @autoreleasepool {    for ( *d in @[@[@3, @2, @6, @4, @5, @1],         @[@0, @8, @4, @12, @2, @10, @6, @14, @1, @9, @5, @13, @3, @11, @7, @15]])      NSLog(@strv, d,            [d longestIncreasingSubsequenceWithComparator:^NSComparisonResult(id obj1, id obj2) {        return [obj1 compare:obj2];      }]);  }  return 0;}"
" *collect;//...for(Type i in collect){   NSLog(@strv, i);} *collect;//... *enm = [collect objectEnumerator];id i;while( (i = [enm nextObject]) ) {  
}"
"#import <Foundation/Foundation.h> typedef  *(^SOfN)(id); SOfN s_of_n_creator(int n) {   *sample = [[ alloc] initWithCapacity:n];  __block int i = 0;  return [^(id item) {    i++;    if (i <= n) {      [sample addObject:item];    } else if (() % i < n) {      sample[() % n] = item;    }    return sample;  } copy];} int main(int argc, const char *argv[]) {  @autoreleasepool {      *bin = [[ alloc] init];    for (int trial = 0; trial < 100000; trial++) {      SOfN s_of_n = s_of_n_creator(3);       *sample;      for (int i = 0; i < 10; i++)        sample = s_of_n(@(i));      [bin addObjectsFromArray:sample];    }    NSLog(@strv, bin);   }  return 0;}"
"#import <Foundation/Foundation.h> -(*)lookAndSay:( *)word{    if (!word) {        return nil;    }     *result = [ new];     char repeat = [word characterAtIndex:0];    int times = 1;    word = [ stringWithFormat:@strv,[word substringFromIndex:1] ];     for (NSInteger index = 0; index < word.length; index++) {        char actual = [word characterAtIndex:index];        if (actual != repeat) {            [result appendFormat:@strv, times, repeat];            times = 1;            repeat = actual;        } else {            times ++;        }    }     return [result copy];} - (void)applicationDidFinishLaunching:( *)aNotification{     *num = @strv;    for (int i=1;i<=10;i++) {        NSLog(@strv, num);         num = [self lookAndSay:num];    }} "
@strv
"@interface  (levenshteinDistance)- (NSUInteger)levenshteinDistanceToString:( *)string;@end @implementation  (levenshteinDistance)- (NSUInteger)levenshteinDistanceToString:( *)string {    NSUInteger sl = [self length];    NSUInteger tl = [string length];    NSUInteger *d = ((*d), (sl+1) * (tl+1)); #define d(i, j) d[((j) * sl) + (i)]    for (NSUInteger i = 0; i <= sl; i++) {        d(i, 0) = i;    }    for (NSUInteger j = 0; j <= tl; j++) {        d(0, j) = j;    }    for (NSUInteger j = 1; j <= tl; j++) {        for (NSUInteger i = 1; i <= sl; i++) {            if ([self characterAtIndex:i-1] == [string characterAtIndex:j-1]) {                d(i, j) = d(i-1, j-1);            } else {                d(i, j) = MIN(d(i-1, j), MIN(d(i, j-1), d(i-1, j-1))) + 1;            }        }    }     NSUInteger r = d(sl, tl);#undef d     (d);     return r;}@end"
"#import <Foundation/Foundation.h> @interface  (KnuthShuffle)- (void)knuthShuffle;@end@implementation  (KnuthShuffle)- (void)knuthShuffle {  for (NSUInteger i = self.count-1; i > 0; i--) {    NSUInteger j = arc4random_uniform(i+1);    [self exchangeObjectAtIndex:i withObjectAtIndex:j];  }}@end int main() {  @autoreleasepool {     *x = [ arrayWithObjects:@0, @1, @2, @3, @4, @5, @6, @7, @8, @9, nil];    [x knuthShuffle];    NSLog(@strv, x);  }  return 0;}"
"#import <Foundation/Foundation.h> int main (int argc, const char *argv[]) {  @autoreleasepool {      *data = [ dataWithContentsOfFile:@(argv[1])];     *string = [[ alloc] initWithData:data encoding:NSUTF8StringEncoding];     *countedSet = [[ alloc] init];    NSUInteger len = [string length];    for (NSUInteger i = 0; i < len; i++) {      unichar c = [string characterAtIndex:i];      if ([[ letterCharacterSet] characterIsMember:c])        [countedSet addObject:@(c)];    }    for ( *chr in countedSet) {      NSLog(@strv, (unichar)[chr integerValue], [countedSet countForObject:chr]);    }   }  return 0;}"
" *jsonString = @""{ foo: 1, bar: [10, apples] }"";id obj = [NSJSONSerialization     JSONObjectWithData: [jsonString dataUsingEncoding: NSUTF8StringEncoding]               options: 0                 error: NULL];NSLog(@strv, obj);  *dict = @{ @strv: @[@1, @2], @strv: @strv}; *jsonData = [NSJSONSerialization dataWithJSONObject: dict                                                   options: 0                                                     error: NULL]; *jsonString2 = [[ alloc] initWithData: jsonData                                              encoding: NSUTF8StringEncoding];NSLog(@strv, jsonString2); "
@interface Camera :  {}@end @implementation Camera@end @interface MobilePhone :  {}@end @implementation MobilePhone@end @interface CameraPhone :  {  Camera *camera;  MobilePhone *phone;}@end @implementation CameraPhone -(instancetype)init {  if ((self = [super init])) {    camera = [[Camera alloc] init];    phone = [[MobilePhone alloc] init];  }  return self;} -(void)forwardInvocation:( *)anInvocation {  SEL aSelector = [anInvocation selector];  if ([camera respondsToSelector:aSelector])    [anInvocation invokeWithTarget:camera];  else if ([phone respondsToSelector:aSelector])    [anInvocation invokeWithTarget:phone];  else    [self doesNotRecognizeSelector:aSelector];} -( *)methodSignatureForSelector:(SEL)aSelector {  return [camera methodSignatureForSelector:aSelector]  ?: [phone methodSignatureForSelector:aSelector]  ?: [super methodSignatureForSelector:aSelector];} -(BOOL)respondsToSelector:(SEL)aSelector {  return [camera respondsToSelector:aSelector]  || [phone respondsToSelector:aSelector]  || [super respondsToSelector:aSelector];  } @end
"@interface Animal : {  
}
@end @interface Dog : Animal{  
}
@end @interface Lab : Dog{  
}
@end @interface Collie : Dog{  
}
@end @interface Cat : Animal{  
}
@end"
"#import <Foundation/Foundation.h> int main()   i := (int)'123' + 1  s := @(i).description   Log( '%@', s )  return 0 *s = @strv;int i = [s intValue] + 1;s = [ stringWithFormat:@strv, i]"
" NSLog(@strv, [[ processInfo] hostName]);  2010-09-16 16:20:00.000 Playground[1319:a0f] sierra117.local 
 "
"switch (NSHostByteOrder()) {  case NS_BigEndian:    NSLog(@strv, @strv);    break;  case NS_LittleEndian:    NSLog(@strv, @strv);    break;  case NS_UnknownByteOrder:    NSLog(@strv, @strv);    break;} switch ([NSRunningApplication currentApplication].executableArchitecture) {  case NSBundleExecutableArchitectureI386:    NSLog(@strv, @strv);    break;   case NSBundleExecutableArchitectureX86_64:    NSLog(@strv, @strv);    break;   case NSBundleExecutableArchitecturePPC:    NSLog(@strv, @strv);    break;   case NSBundleExecutableArchitecturePPC64:    NSLog(@strv, @strv);    break;   default:    NSLog(@strv, @strv);    break;}"
"#import <Foundation/Foundation.h> int main (int argc, const char * argv[]) {    @autoreleasepool {                 *error;         *response;         *data = [ sendSynchronousRequest:[ requestWithURL:[ URLWithString:@strv]]                                                returningResponse:&response                                                            error:&error];         NSLog(@strv, [[ alloc] initWithData:data                                              encoding:NSUTF8StringEncoding]);     }    return 0;}"
"#import <Foundation/Foundation.h> typedef double (^mfunc)(double, double); @interface  (HornerRule)- (double)horner: (double)x;- ( *)reversedArray;- (double)injectDouble: (double)s with: (mfunc)op;@end @implementation  (HornerRule)- ( *)reversedArray{  return [[self reverseObjectEnumerator] allObjects];}  - (double)injectDouble: (double)s with: (mfunc)op{  double sum = s;  for(* el in self) {    sum = op(sum, [el doubleValue]);  }  return sum;} - (double)horner: (double)x{  return [[self reversedArray] injectDouble: 0.0 with: ^(double s, double a) { return s * x + a; } ];}@end int main(){  @autoreleasepool {      *coeff = @[@-19.0, @7.0, @-4.0, @6.0];    (""%f"", [coeff horner: 3.0]);   }  return 0;}"
"#import <Foundation/Foundation.h>  @interface HuffmanTree :  {	int freq;}-(instancetype)initWithFreq:(int)f;@property (nonatomic, readonly) int freq;@end @implementation HuffmanTree@synthesize freq; 
-(instancetype)initWithFreq:(int)f {	if (self = [super init]) {		freq = f;	}	return self;}@end  const void *HuffmanRetain(CFAllocatorRef allocator, const void *ptr) {	return (__bridge_retained const void *)(__bridge id)ptr;}void HuffmanRelease(CFAllocatorRef allocator, const void *ptr) {	(void)(__bridge_transfer id)ptr;}CFComparisonResult HuffmanCompare(const void *ptr1, const void *ptr2, void *unused) {	int f1 = ((__bridge HuffmanTree *)ptr1).freq;	int f2 = ((__bridge HuffmanTree *)ptr2).freq;	if (f1 == f2)		return kCFCompareEqualTo;	else if (f1 > f2)		return kCFCompareGreaterThan;	else		return kCFCompareLessThan;}  @interface HuffmanLeaf : HuffmanTree {	char value; 
}@property (readonly) char value;-(instancetype)initWithFreq:(int)f character:(char)c;@end @implementation HuffmanLeaf@synthesize value;-(instancetype)initWithFreq:(int)f character:(char)c {	if (self = [super initWithFreq:f]) {		value = c;	}	return self;}@end  @interface HuffmanNode : HuffmanTree {	HuffmanTree *left, *right; 
}@property (readonly) HuffmanTree *left, *right;-(instancetype)initWithLeft:(HuffmanTree *)l right:(HuffmanTree *)r;@end @implementation HuffmanNode@synthesize left, right;-(instancetype)initWithLeft:(HuffmanTree *)l right:(HuffmanTree *)r {	if (self = [super initWithFreq:l.freq+r.freq]) {		left = l;		right = r;	}	return self;}@end  HuffmanTree *buildTree( *chars) { 	CFBinaryHeapCallBacks callBacks = {0, HuffmanRetain, HuffmanRelease, NULL, HuffmanCompare};	CFBinaryHeapRef trees = CFBinaryHeapCreate(NULL, 0, &callBacks, NULL); 	
	
	for ( *ch in chars) {		int freq = [chars countForObject:ch];		if (freq > 0)			CFBinaryHeapAddValue(trees, (__bridge const void *)[[HuffmanLeaf alloc] initWithFreq:freq character:(char)[ch intValue]]);	} 	NSCAssert(CFBinaryHeapGetCount(trees) > 0, @strv);	
	while (CFBinaryHeapGetCount(trees) > 1) {		
		HuffmanTree *a = (__bridge HuffmanTree *)CFBinaryHeapGetMinimum(trees);		CFBinaryHeapRemoveMinimumValue(trees);		HuffmanTree *b = (__bridge HuffmanTree *)CFBinaryHeapGetMinimum(trees);		CFBinaryHeapRemoveMinimumValue(trees); 		
		CFBinaryHeapAddValue(trees, (__bridge const void *)[[HuffmanNode alloc] initWithLeft:a right:b]);	}	HuffmanTree *result = (__bridge HuffmanTree *)CFBinaryHeapGetMinimum(trees);	CFRelease(trees);	return result;} void printCodes(HuffmanTree *tree,  *prefix) {	NSCAssert(tree != nil, @strv);	if ([tree isKindOfClass:[HuffmanLeaf class]]) {		HuffmanLeaf *leaf = (HuffmanLeaf *)tree; 		
		NSLog(@""%c%d%@"", leaf.value, leaf.freq, prefix); 	} else if ([tree isKindOfClass:[HuffmanNode class]]) {		HuffmanNode *node = (HuffmanNode *)tree; 		
		[prefix appendString:@strv];		printCodes(node.left, prefix);		[prefix deleteCharactersInRange:NSMakeRange([prefix length]-1, 1)]; 		
		[prefix appendString:@strv];		printCodes(node.right, prefix);		[prefix deleteCharactersInRange:NSMakeRange([prefix length]-1, 1)];	}} int main(int argc, const char * argv[]) {    @autoreleasepool { 	 *test = @strv; 	
	 *chars = [[ alloc] init];	int n = [test length];	for (int i = 0; i < n; i++)		[chars addObject:@([test characterAtIndex:i])]; 	
	HuffmanTree *tree = buildTree(chars); 	
	NSLog(@""SYMBOLWEIGHTHUFFMAN CODE"");	printCodes(tree, [ string]);     }    return 0;}"
"#import <Foundation/Foundation.h> int main(){   (stderr, ""Goodbye, World!"");   (""Goodbye, World!"", stderr);   NSLog(@strv);   return 0;}"
" #import <Foundation/Foundation.h> int main() {    @autoreleasepool {        NSLog(@strv);    }}  #import <Foundation/Foundation.h> int main() {    @autoreleasepool {         *standardOutput = [ fileHandleWithStandardOutput];         *message = @""Hello, World!"";        [standardOutput writeData:[message dataUsingEncoding:NSUTF8StringEncoding]];    }}  #import <Foundation/Foundation.h> int main() {    @autoreleasepool {         *message = @""Hello, World!"";        (strv, message.UTF8String);    }} "
 *alert = [[ alloc] init];[alert setMessageText:@strv];[alert runModal];UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@strv message:nil delegate:nil cancelButtonTitle:@strv otherButtonTitles:nil];[alert show];
+ (double) distanceBetweenLat1:(double)lat1 lon1:(double)lon1                          lat2:(double)lat2 lon2:(double)lon2 {    //degrees to radians    double lat1rad = lat1 * M_PI/180;     double lon1rad = lon1 * M_PI/180;    double lat2rad = lat2 * M_PI/180;    double lon2rad = lon2 * M_PI/180;     //deltas    double dLat = lat2rad - lat1rad;    double dLon = lon2rad - lon1rad;     double a = (dLat/2) * (dLat/2) + (dLon/2) * (dLon/2) * (lat1rad) * (lat2rad);    double c = 2 * ((a));    double R = 6372.8;    return R * c;}
" *keys = @[@strv, @strv, @strv]; *values = @[@1, @2, @3]; *dict = [ dictionaryWithObjects:values forKeys:keys];"
"#import <Foundation/Foundation.h> @interface GuessNumberFakeArray :  {  int lower, upper;}- (instancetype)initWithLower:(int)l andUpper:(int)u;@end @implementation GuessNumberFakeArray- (instancetype)initWithLower:(int)l andUpper:(int)u {  if ((self = [super init])) {    lower = l;    upper = u;  }  return self;}- (NSUInteger)count { return upper-lower; }- (id)objectAtIndex:(NSUInteger)i {  (strv, lower + (int)i);  char input[2] = strv;  (strv, input);  switch ((input[0])) {    case 'l':      return @-1;    case 'h':      return @1;    case 'c':      return @0;  }  return nil;}@end #define LOWER 0#define UPPER 100 int main(int argc, const char *argv[]) {  @autoreleasepool {     (""Instructions:""           ""Think of integer number from %d (inclusive) to %d (exclusive) and""           ""I will guess it. After each guess, you respond with L, H, or C depending""           ""on if my guess was too low, too high, or correct."",           LOWER, UPPER);    NSUInteger result = [[[GuessNumberFakeArray alloc] initWithLower:LOWER andUpper:UPPER]                         indexOfObject:[ numberWithInt: 0]                         inSortedRange:NSMakeRange(0, UPPER - LOWER)                               options:0                       usingComparator:^(id x, id y){ return [x compare: y]; }];    if (result == NSNotFound)      (""That is impossible."");    else      (strv, LOWER + (int)result);   }  return 0;}"
" #import <Foundation/Foundation.h> int main(int argc, const char * argv[]){     @autoreleasepool {         NSLog(@""I'm thinking of a number between 1 - 10. Can you guess what it is?"");         int rndNumber = arc4random_uniform(10) + 1;         
        //NSLog(@strv, rndNumber);         int userInput;         do {             NSLog(@""Input the number below"");            (strv, &userInput);             if (userInput > 10) {                 NSLog(@""Please enter a number less than 10"");            }             if (userInput > 10 || userInput != rndNumber) {                 NSLog(@strv, userInput);             } else {                 NSLog(@strv, userInput);            }         } while (userInput > 10 || userInput != rndNumber);    }    return 0;} "
"#include <Foundation/Foundation.h> typedef id (^Function)(id); 
typedef double (*func_t)(double);Function encapsulate(func_t f) {  return ^(id x) { return @(f([x doubleValue])); };} Function compose(Function a, Function b) {  return ^(id x) { return a(b(x)); };} 
double my_f(double x){  return x+1.0;} double my_g(double x){  return x*x;}  int main(){  @autoreleasepool {     Function f = encapsulate(my_f);    Function g = encapsulate(my_g);     Function composed = compose(f, g);     (""g(2.0) = %lf"", [g(@2.0) doubleValue]);    (""f(2.0) = %lf"", [f(@2.0) doubleValue]);    (""f(g(2.0)) = %lf"", [composed(@2.0) doubleValue]);   }  return 0;}"
"NSLog(@strv, 7.125);NSLog(@strv, [ stringWithFormat:@strv, 7.125]);"
"#import <Foundation/Foundation.h> @interface  (WithMaximum)- (id)maximumValue;@end @implementation  (WithMaximum)- (id)maximumValue{  if ( [self count] == 0 ) return nil;  id maybeMax = self[0];  for ( id el in self ) {    if ( [maybeMax respondsToSelector: @selector(compare:)] &&	 [el respondsToSelector: @selector(compare:)]       &&	 [el isKindOfClass: [ class]]               &&	 [maybeMax isKindOfClass: [ class]] ) {      if ( [maybeMax compare: el] == NSOrderedAscending )	maybeMax = el;    } else { return nil; }  }  return maybeMax;}@endint main(){  @autoreleasepool {     *collection = @[@1, @2, @10, @5, @10.5];     NSLog(@strv, [collection maximumValue]);  }  return 0;}"
" *numbers = [ arrayWithObjects:[ numberWithInt:1],                                             [ numberWithInt:2],                                             [ numberWithInt:3],                                             [ numberWithInt:4],                                             [ numberWithInt:5], nil]; *evens = [numbers objectsAtIndexes:[numbers indexesOfObjectsPassingTest:  ^BOOL(id obj, NSUInteger idx, BOOL *stop) { return [obj intValue] % 2 == 0; } ]]; *numbers = [ arrayWithObjects:[ numberWithInt:1],                                             [ numberWithInt:2],                                             [ numberWithInt:3],                                             [ numberWithInt:4],                                             [ numberWithInt:5], nil]; *isEven = [ predicateWithFormat:@strv]; *evens = [numbers filteredArrayUsingPredicate:isEven];#import <Foundation/Foundation.h> @interface  ( ExtFunc )-(int) modulo2;@end @implementation  ( ExtFunc )-(int) modulo2{  return [self intValue] % 2;}@end int main(){   *pool = [[ alloc] init];    *numbers = [ arrayWithObjects:[ numberWithInt:1],                                               [ numberWithInt:2],                                               [ numberWithInt:3],                                               [ numberWithInt:4],                                               [ numberWithInt:5], nil];    *isEven = [ predicateWithFormat:@strv];   *evens = [numbers filteredArrayUsingPredicate:isEven];   NSLog(@strv, evens);    [pool release];  return 0;}"
" *fm = [ defaultManager]; 
NSLog(@strv, [[fm fileAttributesAtPath:@strv traverseLink:YES] fileModificationDate]);[fm changeFileAttributes:[ dictionaryWithObject:[ date] forKey:NSFileModificationDate]                  atPath:@strv]; 
NSLog(@strv, [[fm attributesOfItemAtPath:@strv error:NULL] fileModificationDate]);[fm setAttributes:[ dictionaryWithObject:[ date] forKey:NSFileModificationDate]     ofItemAtPath:@strv error:NULL];"
" *fm = [ defaultManager]; 
NSLog(@strv, [[fm fileAttributesAtPath:@strv traverseLink:YES] fileSize]); 
NSLog(@strv, [[fm attributesOfItemAtPath:@strv error:NULL] fileSize]);"
"#import <Foundation/Foundation.h> int main()  autoreleasepool     for int i in 1 .. 100      s := ''      if i % 3 == 0        s << 'Fizz'      if i % 5 == 0        s << 'Buzz'      Log( '(%d) %@', i, s )   return 0"
[[ defaultManager] copyItemAtPath:@strv toPath:@strv error:NULL]; *data = [ dataWithContentsOfFile:@strv]; [data writeToFile:@strv atomically:YES];
"void runls(){    [[ launchedTaskWithLaunchPath:@strv        arguments:@[]] waitUntilExit];}void runSystemCommand( *cmd){    [[ launchedTaskWithLaunchPath:@strv        arguments:@[@strv, cmd]]        waitUntilExit];}#import <Foundation/Foundation.h> void runSystemCommand( *cmd){    [[ launchedTaskWithLaunchPath:@strv        arguments:@[@strv, cmd]]        waitUntilExit];} int main(int argc, const char **argv){    @autoreleasepool {       runSystemCommand(@strv);    }    return 0;}"
"@interface U0 :  { }@end@interface U1 :  { }@end@implementation U0@end@implementation U1@end void foo();void bar(int i);void baz(int i); void foo() {  for (int i = 0; i <= 1; i++) {    @try {      bar(i);    } @catch (U0 *e) {      NSLog(@strv);    }  }} void bar(int i) {  baz(i); 
} void baz(int i) {  if (i == 0)    @throw [U0 new];  else    @throw [U1 new];}  int main (int argc, const char * argv[]) {  @autoreleasepool {     foo();   }  return 0;}"
"@interface MyException :  {  //Put specific info in here}@end- (void)foo {  @throw [ exceptionWithName:@strv                                 reason:@strv  userInfo:nil];}@try {  [self foo];}@catch (MyException *exc) {  //Catch only your specified type of exception}@catch ( *exc) {  //Catch any NSException or subclass  NSLog(@strv, [exc name], [exc reason]);  }@catch (id exc) {  //Catch any kind of object}@finally {  //This code is always executed after exiting the try block}"
"-(long)fibonacci:(int)position{    long result = 0;    if (position < 2) {        result = position;    } else {        result = [self fibonacci:(position -1)] + [self fibonacci:(position -2)];    }    return result;    }+(long)fibonacci:(int)index {    long beforeLast = 0, last = 1;    while (index > 0) {        last += beforeLast;        beforeLast = last - beforeLast;        --index;    }    return last;}"
"typedef NS_ENUM(NSInteger, fruits) { apple, banana, cherry }; typedef NS_ENUM(NSInteger, fruits) { apple = 0, banana = 1, cherry = 2 };"
[[[ processInfo] environment] objectForKey:@strv]
"#import <stdio.h> BOOL iseven(int x){  return (x&1) == 0;} @interface EthiopicMult : + (int)mult: (int)plier by: (int)plicand;+ (int)halve: (int)a;+ (int)double: (int)a;@end @implementation EthiopicMult+ (int)mult: (int)plier by: (int)plicand{  int r = 0;  while(plier >= 1) {    if ( !iseven(plier) ) r += plicand;    plier = [EthiopicMult halve: plier];    plicand = [EthiopicMult double: plicand];  }  return r;} + (int)halve: (int)a{  return (a>>1);} + (int)double: (int)a{  return (a<<1);}@end int main(){  @autoreleasepool {    (""%d"", [EthiopicMult mult: 17 by: 34]);  }  return 0;}"
"int main(int argc, const char **argv) {    return 0;}#import <Cocoa/Cocoa.h> int main( int argc, const char *argv[] ){  @autoreleasepool {    [ sharedApplication];  }  return 0;}"
"/*!
 @function add
 @abstract Adds two numbers
 @discussion Use add to sum two numbers.
 @param a an integer.
 @param b another integer.
 @return the sum of a and b
 */int add(int a, int b) {    return a + b;}"
"#import <stdio.h>#import <stdint.h>#import <stdlib.h>#import <string.h>#import <Foundation/Foundation.h> 


@interface VResult : { @private  double value;  BOOL valid;}+(instancetype)new: (double)v isValid: (BOOL)y;-(instancetype)init: (double)v isValid: (BOOL)y;-(BOOL)isValid;-(double)value;@end @implementation VResult+(instancetype)new: (double)v isValid: (BOOL)y{  return [[self alloc] init: v isValid: y];}-(instancetype)init: (double)v isValid: (BOOL)y{  if ((self == [super init])) {    value = v;    valid = y;  }  return self;}-(BOOL)isValid { return valid; }-(double)value { return value; }@end  @interface RCVector : { @private  double *vec;  uint32_t size;}+(instancetype)newWithArray: (double *)v ofLength: (uint32_t)l; -(instancetype)initWithArray: (double *)v ofLength: (uint32_t)l;-(VResult *)dotProductWith: (RCVector *)v;-(uint32_t)size;-(double *)array;-(void);@end @implementation RCVector+(instancetype)newWithArray: (double *)v ofLength: (uint32_t)l{  return [[self alloc] initWithArray: v ofLength: l];}-(instancetype)initWithArray: (double *)v ofLength: (uint32_t)l{  if ((self = [super init])) {    size = l;    vec = ((double) * l);    if ( vec == NULL )      return nil;    (vec, v, (double)*l);  }  return self;}-(void)dealloc{  (vec);}-(uint32_t)size { return size; }-(double *)array { return vec; }-(VResult *)dotProductWith: (RCVector *)v{  double r = 0.0;  uint32_t i, s;  double *v1;  if ( [self size] != [v size] ) return [VResult new: r isValid: NO];  s = [self size];  v1 = [v array];  for(i = 0; i < s; i++) {    r += vec[i] * v1[i];  }  return [VResult new: r isValid: YES];}@end double val1[] = { 1, 3, -5 };double val2[] = { 4,-2, -1 };  int main(){  @autoreleasepool {    RCVector *v1 = [RCVector newWithArray: val1 ofLength: (val1)/(double)];    RCVector *v2 = [RCVector newWithArray: val2 ofLength: (val1)/(double)];    VResult *r = [v1 dotProductWith: v2];    if ( [r isValid] ) {      (""%lf"", [r value]);    } else {      (stderr, ""length of vectors differ"");    }  }  return 0;}"
"#import <Foundation/Foundation.h>

@protocol ActionObjectProtocol- ( *)sendMessage: ( *)msg;@end#import <Foundation/Foundation.h>#import strv @interface ActionObject :  <ActionObjectProtocol>  
@end#import <Foundation/Foundation.h>#import strv @implementation ActionObject-( *)sendMessage: ( *)msg{  NSLog(@strv, msg);  return @strv;}@end#import <Foundation/Foundation.h>#import strv int main (void){  @autoreleasepool {     ActionObject *action = [[ActionObject alloc] init];      *port = ( *)[ port];    
    
     *connect = [   	      connectionWithReceivePort: port  	      sendPort: port]; 
     [connect setRootObject: action];     /* strv the object ActionObject as DistributedAction; on GNUstep
       the Name Server that allows the resolution of the registered name
       is bound to port 538 */    if (![connect registerName:@strv  	       withNameServer: [ sharedInstance] ])     {      NSLog(@strv);      (EXIT_FAILURE);    }     NSLog(@strv);     [[ currentRunLoop] run];   }  return 0;}#import <Foundation/Foundation.h>#import strv int main(void){  @autoreleasepool {     id <ActionObjectProtocol> action = (id <ActionObjectProtocol>)      [        rootProxyForConnectionWithRegisteredName: @strv         host: @strv        usingNameServer: [ sharedInstance] ];     if (action == nil)    {      NSLog(@strv);      (EXIT_FAILURE);    }      *args = [[ processInfo] arguments];     if ([args count] == 1)    {      NSLog(@strv);      (EXIT_FAILURE);    }      *msg = args[1];     
    
    
     *backmsg = [action sendMessage: msg];    NSLog(strv, backmsg);   }  return 0;}"
" *fm = [ defaultManager]; 
[fm removeFileAtPath:@strv handler:nil];[fm removeFileAtPath:@strv handler:nil];[fm removeFileAtPath:@strv handler:nil];[fm removeFileAtPath:@strv handler:nil]; 
[fm removeItemAtPath:@strv error:NULL];[fm removeItemAtPath:@strv error:NULL];[fm removeItemAtPath:@strv error:NULL];[fm removeItemAtPath:@strv error:NULL];"
"if( [[ scannerWithString:@strv] scanFloat:NULL] )	NSLog( @""-123.4e5 is numeric"" );else	NSLog( @""-123.4e5 is not numeric"" );if( [[ scannerWithString:@strv] scanFloat:NULL] )	NSLog( @""Not a number is numeric"" );else	NSLog( @""Not a number is not numeric"" );

BOOL isNumeric( *s){    *sc = [ scannerWithString: s];   if ( [sc scanFloat:NULL] )   {      return [sc isAtEnd];   }   return NO;}BOOL isNumericI( *s){   NSUInteger len = [s length];   NSUInteger i;   BOOL status = NO;    for(i=0; i < len; i++)   {       unichar singlechar = [s characterAtIndex: i];       if ( (singlechar == ' ') && (!status) )       {         continue;       }       if ( ( singlechar == '+' ||              singlechar == '-' ) && (!status) ) { status=YES; continue; }       if ( ( singlechar >= '0' ) &&            ( singlechar <= '9' ) )       {          status = YES;       } else {          return NO;       }   }   return (i == len) && status;}"
"#import <Foundation/Foundation.h> @interface Delegator :  {     id delegate;} - (id)delegate;- (void)setDelegate:(id)obj;- ( *)operation; @end @implementation Delegator - (id)delegate {     return delegate;} - (void)setDelegate:(id)obj {     delegate = obj; 
} - ( *)operation {     if ([delegate respondsToSelector:@selector(thing)])        return [delegate thing];     return @strv;} @end 
@interface  (DelegatorDelegating) - ( *)thing; @end @interface Delegate :  
 @end @implementation Delegate - ( *)thing {     return @strv;} @end 

int main() {     
    Delegator *a = [[Delegator alloc] init];    NSLog(@""%d"", [[a operation] isEqualToString:@strv]);     
    [a setDelegate:@strv];    NSLog(@""%d"", [[a operation] isEqualToString:@strv]);     
    Delegate *d = [[Delegate alloc] init];    [a setDelegate:d];    NSLog(@""%d"", [[a operation] isEqualToString:@strv]);     return 0;}#import <Foundation/Foundation.h> 
@protocol DelegatorDelegatingProtocol    - ( *)thing;@end @interface Delegator :     @property (weak) id delegate;    - ( *)operation;@end@implementation Delegator    - ( *)operation {        if ([self.delegate respondsToSelector: @selector(thing)])            return [self.delegate thing];         return @strv;    }@end @interface Delegate :     <DelegatorDelegatingProtocol>@end@implementation Delegate    - ( *)thing { return @strv; }@end 
int main() {    @autoreleasepool {        
        Delegator *a = [Delegator new];        NSLog(@strv, [a operation]);    
         
        a.delegate = @strv;        NSLog(@strv, [a operation]);    
         
        Delegate *d = [Delegate new];        a.delegate = d;        NSLog(@strv, [a operation]);    
    }    return 0;}"
"#define RMAX32 ((1U << 31) - 1) //-------------------------------------------------------------------- @interface Rand : -(instancetype) initWithSeed: (int)seed;-(int) next;@property (nonatomic) long seed;@end @implementation Rand-(instancetype) initWithSeed: (int)seed {    if ((self = [super init])) {        self.seed = seed;    }    return self;}-(int) next {    return (int) ((_seed = (_seed * 214013 + 2531011) & RMAX32) >> 16);}@end //-------------------------------------------------------------------- @interface Card : -(instancetype) initWithSequence: (int)n;-(instancetype) initWithValue: (int)v suit: (int)s;@property (nonatomic) int value;@property (nonatomic) int suit;@end @implementation Card-(instancetype) initWithSequence: (int)n {    return [self initWithValue:n/4 suit:n%4];}-(instancetype) initWithValue: (int)v suit: (int)s {    if ((self = [super init])) {        _value = v;  _suit = s;    }    return self;}-( *) description {    static  * const kSuits = @strv;    static  * const kValues = @strv;    return [ stringWithFormat:@strv,            [kValues characterAtIndex:_value],            [kSuits characterAtIndex:_suit]];}@end //-------------------------------------------------------------------- @interface Deck : -(instancetype) initWithSeed: (int)seed;@property (nonatomic, strong)  *cards;@end @implementation Deck-(instancetype) initWithSeed: (int)seed {    if ((self = [super init])) {        Rand *r = [[Rand alloc] initWithSeed:seed];        _cards = [ array];        for (int i = 0; i < 52; i++)            [_cards addObject:[[Card alloc] initWithSequence:51 - i]];        for (int i = 0; i < 51; i++)            [_cards exchangeObjectAtIndex:i withObjectAtIndex:51 - [r next] % (52 - i)];    }    return self;}-( *) description {     *s = [ string];    for (int i = 0; i < [_cards count]; i++) {        [s appendString:[_cards[i] description]];        [s appendString:i%8==7 ? @"""" : @strv];    }    return s;}@end //-------------------------------------------------------------------- int main(int argc, const char * argv[]){    @autoreleasepool {        NSLog(@""Deck 1%@"", [[Deck alloc] initWithSeed:1]);        NSLog(@""Deck 617%@"", [[Deck alloc] initWithSeed:617]);    }    return 0;}"
"#import <Foundation/Foundation.h> int main(){   @autoreleasepool {      for(NSUInteger i=2008; i<2121; i++)      {          *d = [[ alloc]                               initWithYear: i                              month: 12                              day: 25                              hour: 0 minute: 0 second:0                               timeZone: [ timeZoneWithAbbreviation:@strv] ];         if ( [d dayOfWeek] == 0 )         {              (""25 Dec %u is Sunday"", i);         }      }    }   return 0;}"
"NSLog(@strv, [ date]);NSLog(@strv, [[ date] descriptionWithCalendarFormat:@strv timeZone:nil locale:nil]);NSLog(@strv, [[ date] descriptionWithCalendarFormat:@strv timeZone:nil locale:nil]);NSLog(@strv, [ date]); *dateFormatter = [[NSDateFormat alloc] init];[dateFormatter setDateFormat:@strv];NSLog(@strv, [dateFormatter stringFromDate:[ date]]);[dateFormatter setDateFormat:@strv];NSLog(@strv, [dateFormatter stringFromDate:[ date]]);"
"#import <Foundation/Foundation.h> int main(){  @autoreleasepool {    int num1, num2;    (strv, &num1, &num2);     NSLog(@strv, num1, num2);      *arr = [ arrayWithCapacity: (num1*num2)];    
    for(int i=0; i < (num1*num2); i++) [arr addObject: @0];     
    for(int i=0; i < num1; i++) {      for(int j=0; j < num2; j++) {        arr[i*num2+j] = @(i*j);      }    }     
    NSLog(@strv, arr[1*num2+3]);  }  return 0;}"
"#import <Foundation/Foundation.h> @interface SDAccum : {  double sum, sum2;  unsigned int num;}-(double)value: (double)v;-(unsigned int)count;-(double)mean;-(double)variance;-(double)stddev;@end @implementation SDAccum-(double)value: (double)v{  sum += v;  sum2 += v*v;  num++;  return [self stddev];}-(unsigned int)count{  return num;}-(double)mean{  return (num>0) ? sum/(double)num : 0.0;}-(double)variance{  double m = [self mean];  return (num>0) ? (sum2/(double)num - m*m) : 0.0;}-(double)stddev{  return ([self variance]);}@end int main(){  @autoreleasepool {     double v[] = { 2,4,4,4,5,5,7,9 };     SDAccum *sdacc = [[SDAccum alloc] init];     for(int i=0; i < (v)/(*v) ; i++)      (""adding %fstddev = %f"", v[i], [sdacc value: v[i]]);   }  return 0;}#import <Foundation/Foundation.h> typedef double (^Func)(double); 
 Func sdCreator() {  __block int n = 0;  __block double sum = 0;  __block double sum2 = 0;  return ^(double x) {    sum += x;    sum2 += x*x;    n++;    return (sum2/n - sum*sum/n/n);  };} int main(){  @autoreleasepool {     double v[] = { 2,4,4,4,5,5,7,9 };     Func sdacc = sdCreator();     for(int i=0; i < (v)/(*v) ; i++)      (""adding %fstddev = %f"", v[i], sdacc(v[i]));   }  return 0;}"
" *fm = [ defaultManager]; [fm createFileAtPath:@strv contents:[ data] attributes:nil];
[fm createDirectoryAtPath:@strv attributes:nil];
[fm createDirectoryAtPath:@strv withIntermediateDirectories:NO attributes:nil error:NULL];"
"@interface  (CountSubstrings)- (NSUInteger)occurrencesOfSubstring:( *)subStr;@end @implementation  (CountSubstrings)- (NSUInteger)occurrencesOfSubstring:( *)subStr {  return [[self componentsSeparatedByString:subStr] count] - 1;}@end int main(int argc, const char *argv[]) {  @autoreleasepool {     NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);    NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);    NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);   }  return 0;}@interface  (CountSubstrings)- (NSUInteger)occurrencesOfSubstring:( *)subStr;@end @implementation  (CountSubstrings)- (NSUInteger)occurrencesOfSubstring:( *)subStr {  return ([self length] - [[self stringByReplacingOccurrencesOfString:subStr withString:@strv] length]) / [subStr length];}@end int main(int argc, const char *argv[]) {  @autoreleasepool {     NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);    NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);    NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);   }  return 0;}@interface  (CountSubstrings)- (NSUInteger)occurrencesOfSubstring:( *)subStr;@end @implementation  (CountSubstrings)- (NSUInteger)occurrencesOfSubstring:( *)subStr {  NSUInteger count = 0;  for (NSRange range = [self rangeOfString:subStr]; range.location != NSNotFound;       range.location += range.length,       range = [self rangeOfString:subStr options:0                             range:NSMakeRange(range.location, [self length] - range.location)])    count++;  return count;}@end int main(int argc, const char *argv[]) {  @autoreleasepool {     NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);    NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);    NSLog(@strv, [@strv occurrencesOfSubstring:@strv]);   }  return 0;}"
@protocol Eatable- (void)eat;@end@interface FoodBox<T : id<Eatable>> : @end
 *original = @strv; *new = [original copy]; *anotherNew = [ stringWithString:original]; *newMutable = [original mutableCopy]; *original = [ stringWithString:@strv]; *immutable = [original copy]; *anotherImmutable = [ stringWithString:original]; *mutable = [original mutableCopy];const char *cstring = strv; *string = [ stringWithUTF8String:cstring];char bytes[] = strv; *string = [[ alloc] initWithBytes:bytes length:9 encoding:NSASCIIStringEncoding];
" *args = [[ processInfo] arguments];NSLog(@strv, [args objectAtIndex:0]);NSLog(@strv, [args count] - 1);for (i = 1; i < [args count]; ++i){    NSLog(@strv, i, [args objectAtIndex:i]);}"
"#import <Foundation/Foundation.h> void show_collection(id coll){  for ( id el in coll )  {    if ( [coll isKindOfClass: [ class]] ) {      NSLog(@strv, el, [coll countForObject: el]);    } else if ( [coll isKindOfClass: [ class]] ) {      NSLog(@strv, el, coll[el]);    } else {      NSLog(@strv, el);    }  }  ("""");} int main(){  @autoreleasepool {     
     *set = [[ alloc] init];    
    [set addObject: @strv];    [set addObject: @10];    [set addObjectsFromArray: @[@strv, @20, @10, @strv] ];    
    show_collection(set);     
     *cset = [[ alloc] init];    
    [cset addObject: @strv];    [cset addObject: @strv];    [cset addObject: @strv];    
    show_collection(cset);     
     *dict = [[ alloc] init];    
    dict[@strv] = @4;    dict[@strv] = @8;    
    show_collection(dict);   }  return EXIT_SUCCESS;}"
" *funcs = [[ alloc] init];for (int i = 0; i < 10; i++) {  [funcs addObject:[^ { return i * i; } copy]];} int (^foo)(void) = funcs[3];NSLog(@strv, foo()); 
 "
"
static int myClassVariable = 0; @interface MyClass : {    int variable; 
} - (int)variable; 
 @end@implementation MyClass 
- (instancetype)init{    if (self = [super init]) {        variable = 0; 
    }    return self;} - (int)variable{    return variable;} @end
MyClass *mc = [[MyClass alloc] init]; 
[mc variable];"
" *fm = [ defaultManager];NSLog(@strv, [fm fileExistsAtPath:@strv] ? @strv : @strv);NSLog(@strv, [fm fileExistsAtPath:@strv] ? @strv : @strv);"
"
[MyClass method:someParameter];
id foo = [MyClass class];[foo method:someParameter]; 
[myInstance method:someParameter]; 
[myInstance methodWithRed:arg1 green:arg2 blue:arg3]; 
[myInstance method];"
"#import <Foundation/Foundation.h> @interface Example :  {@private   *_name;}- (instancetype)initWithName:( *)name;@end @implementation Example- ( *)description {  return [ stringWithFormat:@strv, _name];}- (instancetype)initWithName:( *)name {  if ((self = [super init])) {    _name = [name copy];  }  return self;}@end int main (int argc, const char * argv[]) {  @autoreleasepool{     Example *foo = [[Example alloc] initWithName:@strv];     
    NSLog(@strv, [foo valueForKey:@strv]);     
    [foo setValue:@strv forKey:@strv];    NSLog(@strv, foo);   }  return 0;}#import <Foundation/Foundation.h> @interface Example :  {@private   *_name;}- (instancetype)initWithName:( *)name;@end @implementation Example- ( *)description {  return [ stringWithFormat:@strv, _name];}- (instancetype)initWithName:( *)name {  if ((self = [super init])) {    _name = [name copy];  }  return self;}@end @interface Example (HackName)- ( *)getName;- (void)setNameTo:( *)newName;@end @implementation Example (HackName)- ( *)getName {  return _name;}- (void)setNameTo:( *)newName {  _name = [newName copy];}@end int main (int argc, const char * argv[]) {  @autoreleasepool{     Example *foo = [[Example alloc] initWithName:@strv];     
    NSLog(@strv, [foo getName]);     
    [foo setNameTo:@strv];    NSLog(@strv, foo);   }  return 0;}#import <Foundation/Foundation.h>#import <objc/runtime.h> @interface Example :  {@private   *_name;}- (instancetype)initWithName:( *)name;@end @implementation Example- ( *)description {  return [ stringWithFormat:@strv, _name];}- (instancetype)initWithName:( *)name {  if ((self = [super init])) {    _name = [name copy];  }  return self;}@end int main (int argc, const char * argv[]) {  @autoreleasepool{     Example *foo = [[Example alloc] initWithName:@strv];     
    Ivar nameField = class_getInstanceVariable([foo class], strv);    NSLog(@strv, object_getIvar(foo, nameField));     
    object_setIvar(foo, nameField, @strv);    NSLog(@strv, foo);   }  return 0;}"
"#import <Foundation/Foundation.h> int main(int argc, const char *argv[]) {  @autoreleasepool {     *data = [ dataWithContentsOfURL:[ URLWithString:@strv]];    NSLog(@strv, [data base64Encoding]);  }  return 0;}"
"#import <Foundation/Foundation.h> @interface MovingAverage :  {	unsigned int period;	 *window;	double sum;}- (instancetype)initWithPeriod:(unsigned int)thePeriod;@end @implementation MovingAverage 
- (instancetype)init {	self = [super init];	if(self) {		period = 10;		window = [[ alloc] init];		sum = 0.0;	}	return self;} 
- (instancetype)initWithPeriod:(unsigned int)thePeriod {	self = [super init];	if(self) {		period = thePeriod;		window = [[ alloc] init];		sum = 0.0;	}	return self;} 
- (void)add:(double)val {	sum += val;	[window addObject:@(val)];	if([window count] > period) {		 *n = window[0];		sum -= [n doubleValue];		[window removeObjectAtIndex:0];	}} 
- (double)avg {	if([window count] == 0) {		return 0; 
	}	return sum / [window count];} 
- (void)setPeriod:(unsigned int)thePeriod {	
	if(thePeriod < [window count]) {		for(int i = 0; i < thePeriod; ++i) {			 *n = window[0];			sum -= [n doubleValue];			[window removeObjectAtIndex:0];		}	}	period = thePeriod;} 
- (unsigned int)period {	return period;} 
- (void)clear {	[window removeAllObjects];	sum = 0;} @end int main (int argc, const char * argv[]) {	@autoreleasepool {		double testData[10] = {1,2,3,4,5,5,4,3,2,1};		int periods[2] = {3,5};		for(int i = 0; i < 2; ++i) {			MovingAverage *ma = [[MovingAverage alloc] initWithPeriod:periods[i]];			for(int j = 0; j < 10; ++j) {				[ma add:testData[j]];				NSLog(@strv, testData[j], [ma avg]);			}			NSLog(@"""");		}	}	return 0;}"
#import <Foundation/Foundation.h> @interface  (Mode)- ( *)mode;@end @implementation  (Mode)- ( *)mode {     *seen = [ setWithArray:self];    int max = 0;     *maxElems = [ array];    for ( obj in seen ) {        int count = [seen countForObject:obj];        if (count > max) {            max = count;            [maxElems removeAllObjects];            [maxElems addObject:obj];        } else if (count == max) {            [maxElems addObject:obj];        }    }    return maxElems;}@end
" *myDict = [ dictionaryWithObjectsAndKeys:                        [ numberWithInt:13], @strv,                        [ numberWithInt:31], @strv,                        [ numberWithInt:71], @strv, nil]; 
for (id key in myDict) {    NSLog(@strv, key);} 
for (id value in [myDict objectEnumerator]) {    NSLog(@strv, value);} *myDict = [ dictionaryWithObjectsAndKeys:                        [ numberWithInt:13], @strv,                        [ numberWithInt:31], @strv,                        [ numberWithInt:71], @strv, nil]; 
 *enm = [myDict keyEnumerator];id key;while ((key = [enm nextObject])) {    NSLog(@strv, key);} 
enm = [myDict objectEnumerator];id value;while ((value = [enm nextObject])) {    NSLog(@strv, value);} *myDict = [ dictionaryWithObjectsAndKeys:                        [ numberWithInt:13], @strv,                        [ numberWithInt:31], @strv,                        [ numberWithInt:71], @strv, nil]; 
[myDict enumerateKeysAndObjectsUsingBlock: ^(id key, id value, BOOL *stop) {    NSLog(@strv, key, value);}];"
"#import <Foundation/Foundation.h> @interface  (BinarySearch)


- (NSInteger) binarySearch:(id)key;@end @implementation  (BinarySearch)- (NSInteger) binarySearch:(id)key {  NSInteger lo = 0;  NSInteger hi = [self count] - 1;  while (lo <= hi) {    NSInteger mid = lo + (hi - lo) / 2;    id midVal = self[mid];    switch ([midVal compare:key]) {    case NSOrderedAscending:      lo = mid + 1;      break;    case NSOrderedDescending:      hi = mid - 1;      break;    case NSOrderedSame:      return mid;    }  }  return NSNotFound;}@end int main(){  @autoreleasepool {      *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];    NSLog(@strv, [a binarySearch:@6]); 
   }  return 0;}#import <Foundation/Foundation.h> @interface  (BinarySearchRecursive)


- (NSInteger) binarySearch:(id)key inRange:(NSRange)range;@end @implementation  (BinarySearchRecursive)- (NSInteger) binarySearch:(id)key inRange:(NSRange)range {  if (range.length == 0)    return NSNotFound;  NSInteger mid = range.location + range.length / 2;  id midVal = self[mid];  switch ([midVal compare:key]) {  case NSOrderedAscending:    return [self binarySearch:key                      inRange:NSMakeRange(mid + 1, NSMaxRange(range) - (mid + 1))];  case NSOrderedDescending:    return [self binarySearch:key                      inRange:NSMakeRange(range.location, mid - range.location)];  default:    return mid;  }}@end int main(){  @autoreleasepool {      *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];    NSLog(@strv, [a binarySearch:@6]); 
   }  return 0;}#import <Foundation/Foundation.h> int main(){  @autoreleasepool {      *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];    NSLog(@strv, [a indexOfObject:@6                                      inSortedRange:NSMakeRange(0, [a count])                                            options:0                                    usingComparator:^(id x, id y){ return [x compare: y]; }]); 
   }  return 0;}#import <Foundation/Foundation.h> CFComparisonResult myComparator(const void *x, const void *y, void *context) {  return [(__bridge id)x compare:(__bridge id)y];} int main(int argc, const char *argv[]) {  @autoreleasepool {      *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];    NSLog(@strv, CFArrayBSearchValues((__bridge CFArrayRef)a,                                                        CFRangeMake(0, [a count]),                                                        (__bridge const void *)@6,                                                        myComparator,                                                        NULL)); 
   }  return 0;}"
