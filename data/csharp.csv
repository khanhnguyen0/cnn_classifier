keywords
"using System;using System.Collections.Generic;using System.Linq; class Program{    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)    {        var left = 0;        var right = sequence.Sum();        var index = 0;        foreach (var element in sequence)        {            right -= element;            if (left == right)            {                yield return index;            }            left += element;            index++;        }    }     static void Main()    {        foreach (var index in EquilibriumIndices([] { -7, 1, 5, 2, -4, 3, 0 }))        {            Console.WriteLine(index);        }    }}"
" Bitmap tImage =  Bitmap(strv); for (int x = 0; x < tImage.Width; x++){	for (int y = 0; y < tImage.Height; y++)	{		Color tCol = tImage.GetPixel(x, y); 		// L = 0.2126·R + 0.7152·G + 0.0722·B 		double L = 0.2126 * tCol.R + 0.7152 * tCol.G + 0.0722 * tCol.B;		tImage.SetPixel(x, y, Color.FromArgb(Convert.ToInt32(L), Convert.ToInt32(L), Convert.ToInt32(L)));	}} // SavetImage.Save(strv); "
" static void Main(){	Console.WriteLine(strv, 1, 1, gcd(1, 1));	Console.WriteLine(strv, 1, 10, gcd(1, 10));	Console.WriteLine(strv, 10, 100, gcd(10, 100));	Console.WriteLine(strv, 5, 50, gcd(5, 50));	Console.WriteLine(strv, 8, 24, gcd(8, 24));	Console.WriteLine(strv, 36, 17, gcd(36, 17));	Console.WriteLine(strv, 36, 18, gcd(36, 18));	Console.WriteLine(strv, 36, 19, gcd(36, 19));	for (int x = 1; x < 36; x++)	{		Console.WriteLine(strv, 36, x, gcd(36, x));	}	Console.Read();} 


static int gcd(int a, int b){    while (b != 0) b = a % (a = b);    return a;}  static void Main(string[] args){	Console.WriteLine(strv, 1, 1, gcd(1, 1));	Console.WriteLine(strv, 1, 10, gcd(1, 10));	Console.WriteLine(strv, 10, 100, gcd(10, 100));	Console.WriteLine(strv, 5, 50, gcd(5, 50));	Console.WriteLine(strv, 8, 24, gcd(8, 24));	Console.WriteLine(strv, 36, 17, gcd(36, 17));	Console.WriteLine(strv, 36, 18, gcd(36, 18));	Console.WriteLine(strv, 36, 19, gcd(36, 19));	for (int x = 1; x < 36; x++)	{		Console.WriteLine(strv, 36, x, gcd(36, x));	}	Console.Read();} // Greatest Common Denominator using Euclidian Algorithm// Gist: https://gist.github.com/SecretDeveloper/6c426f8993873f1a05f7static int gcd(int a, int b){		return b==0 ? a : gcd(b, a % b);} "
using System.Linq; values.Max();
"public static int[,] ZigZag(int n){    int[,] result =  int[n, n];    int i = 0, j = 0;    int d = -1; // -1 for top-right move, +1 for bottom-left move    int start = 0, end = n * n - 1;    do    {        result[i, j] = start++;        result[n - i - 1, n - j - 1] = end--;         i += d; j -= d;        if (i < 0)        {            i++; d = -d; // top reached, reverse        }        else if (j < 0)        {            j++; d = -d; // left reached, reverse        }    } while (start < end);    if (start == end)        result[i, j] = start;    return result;}"
"using System; namespace ZeroToTheZeroeth{    class Program    {        static void Main(string[] args)        {            double k = Math.Pow(0, 0);            Console.Write(strv, k);                   }    }}"
" using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace Zeckendorf{    class Program    {        private static uint Fibonacci(uint n)        {            if (n < 2)            {                return n;            }            else            {                return Fibonacci(n - 1) + Fibonacci(n - 2);            }        }         private static string Zeckendorf(uint num)        {            IList<uint> fibonacciNumbers =  List<uint>();            uint fibPosition = 2;             uint currentFibonaciNum = Fibonacci(fibPosition);             do            {                fibonacciNumbers.Add(currentFibonaciNum);                currentFibonaciNum = Fibonacci(++fibPosition);            } while (currentFibonaciNum <= num);             uint temp = num;            StringBuilder output =  StringBuilder();             foreach (uint item in fibonacciNumbers.Reverse())            {                if (item <= temp)                {                    output.Append(strv);                    temp -= item;                }                else                {                    output.Append(strv);                }            }             return output.ToString();        }         static void Main(string[] args)        {            for (uint i = 1; i <= 20; i++)            {                string zeckendorfRepresentation = Zeckendorf(i);                Console.WriteLine(string.Format(strv, i, zeckendorfRepresentation));            }             Console.ReadKey();        }    }} "
"using System;using System.Collections.Generic;using System.Linq;using Microsoft.SolverFoundation.Solvers; using static System.Console; namespace Zebra{    enum HouseColour { Blue, Green, White, Red, Yellow };    enum Drink { Beer, Coffee, Milk, Tea, Water };    enum Nationality { English, Danish, German, Norwegian, Swedish };    enum Smoke { Blend, BlueMaster, Dunhill, PallMall, Prince };    enum Pet { Bird, Cat, Dog, Horse, Zebra };     internal class Program    {        static void Main()        {            var solver = ConstraintSystem.CreateSolver();            var constraints =  ZebraPuzzleConstraints(solver);            solver = AddConstraintsToSolver(solver, constraints);             var solution = solver.Solve( ConstraintSolverParams());            var solutionTable = ConvertToSolutionTable(solution, constraints);             WriteZebraSolutionToConsole(solutionTable);            WriteSolutionForAllTheHousesToConsole(solutionTable);        }         private static ConstraintSystem AddConstraintsToSolver(            ConstraintSystem solver, ZebraPuzzleConstraints constraints)        {            solver.AddConstraints(                constraints.TheEnglishManLivesInTheRedHouse());            solver.AddConstraints(                constraints.TheSwedeHasADog());            solver.AddConstraints(                constraints.TheDaneDrinksTea());            solver.AddConstraints(                constraints.TheGreenHouseIsImmediatelyLeftOfTheWhiteHouse());            solver.AddConstraints(                constraints.TheyDrinkCoffeeInTheGreenHouse());            solver.AddConstraints(                constraints.TheManWhoSmokesPallMallHasBirds());            solver.AddConstraints(                constraints.InTheYellowHouseTheySmokeDunhill());            solver.AddConstraints(                constraints.InTheMiddleHouseTheyDrinkMilk());            solver.AddConstraints(                constraints.TheNorwegianLivesInTheFirstHouse());            solver.AddConstraints(                constraints.TheManWhoSmokesBlendInHouseNextToHouseWithCats());            solver.AddConstraints(                constraints.InHouseNextToHouseWhereHaveAHorseSmokeDunhill());            solver.AddConstraints(                constraints.TheManWhoSmokesBlueMasterDrinksBeer());            solver.AddConstraints(                constraints.TheGermanSmokesPrince());            solver.AddConstraints(                constraints.TheNorwegianLivesNextToTheBlueHouse());            solver.AddConstraints(                constraints.TheyDrinkWaterInHouseNextToHouseWhereSmokeBlend());             return solver;        }         private static SolutionTable ConvertToSolutionTable(            ConstraintSolverSolution solution,             ZebraPuzzleConstraints constraints)        {            return  SolutionTable(constraints.HouseNumbers.Select(                houseNumber =>  SolutionRow                (                    houseNumber + 1,                    (HouseColour)DetermineTermFromSolution(solution,                         constraints.ColourMatrix, houseNumber,                         constraints.HouseNumbers),                    (Drink)DetermineTermFromSolution(solution,                     constraints.DrinkMatrix, houseNumber,                         constraints.HouseNumbers),                    (Nationality)DetermineTermFromSolution(solution,                         constraints.NationalityMatrix, houseNumber,                         constraints.HouseNumbers),                    (Smoke)DetermineTermFromSolution(solution,                     constraints.SmokeMatrix, houseNumber,                         constraints.HouseNumbers),                    (Pet)DetermineTermFromSolution(solution,                         constraints.PetMatrix, houseNumber,                         constraints.HouseNumbers)                )).ToList());        }         private static void WriteZebraSolutionToConsole(SolutionTable solution)        {            var ownerNationality = solution.Rows                .Where(row => row.Pet.Equals(Pet.Zebra))                .Select(owner => owner.Nationality).Single();             WriteLine(strv, ownerNationality,                 Environment.NewLine);        }         private static void WriteSolutionForAllTheHousesToConsole(            SolutionTable solution)        {            WriteLine(strv);            WriteLine(strv);            solution.Rows.ForEach(                row => WriteLine(strv,                row.HouseNumber, row.HouseColour, row.Drink, row.Nationality,                row.Smoke, row.Pet));        }         static int DetermineTermFromSolution(            ConstraintSolverSolution solution,             CspTerm[][] terms,             int currentHouseNumber,             IEnumerable<int> houseNubmers)        {            if (solution == null) throw  ArgumentNullException(strv);            if (terms == null) throw  ArgumentNullException(strv);             foreach (var houseNumber in houseNubmers)            {                object term;                solution.TryGetValue(terms[currentHouseNumber][houseNumber],                    out term);                 if ((int)term == 1)                    return houseNumber;            }            return 0;        }    }     internal class SolutionTable    {        public SolutionTable(List<SolutionRow> rows)        {            Rows = rows;        }         public List<SolutionRow> Rows { get; private set; }    }     class SolutionRow    {        public SolutionRow(int houseNumber, HouseColour houseColor,             Drink drink, Nationality nationality, Smoke smoke, Pet pet)        {            HouseNumber = houseNumber;            HouseColour = houseColor;            Drink = drink;            Nationality = nationality;            Smoke = smoke;            Pet = pet;        }         public int HouseNumber { get; private set; }        public HouseColour HouseColour { get; private set; }        public Drink Drink { get; private set; }        public Nationality Nationality { get; private set; }        public Smoke Smoke { get; private set; }        public Pet Pet { get; private set; }    }     class ZebraPuzzleConstraints    {        CspTerm[][] CreateConstrainSystemMatrix(ConstraintSystem system)        {            var size = HouseNumbers.Count;            var matrix = system.CreateBooleanArray( object(), size, size);             Enumerable.Range(0, size).ToList().ForEach(i =>            {                var row = system.CreateBooleanVector( object(), size);                var column = system.CreateBooleanVector( object(), size);                 Enumerable.Range(0, size).ToList().ForEach(j =>                {                    row[j] = matrix[i][j];                    column[j] = matrix[j][i];                });                 system.AddConstraints(system.Equal(1, system.Sum(row)));                system.AddConstraints(system.Equal(1, system.Sum(column)));            });             return matrix;        }         public List<int> HouseNumbers { get; private set; }        public ConstraintSystem Solver { get; private set; }        public CspTerm[][] ColourMatrix { get; private set; }        public CspTerm[][] DrinkMatrix { get; private set; }        public CspTerm[][] NationalityMatrix { get; private set; }        public CspTerm[][] SmokeMatrix { get; private set; }        public CspTerm[][] PetMatrix { get; private set; }         public ZebraPuzzleConstraints(ConstraintSystem solver)        {            Solver = solver;            HouseNumbers = ThereAreFiveHouses();             ColourMatrix = CreateConstrainSystemMatrix(Solver);            DrinkMatrix = CreateConstrainSystemMatrix(Solver);            NationalityMatrix = CreateConstrainSystemMatrix(Solver);            SmokeMatrix = CreateConstrainSystemMatrix(Solver);            PetMatrix = CreateConstrainSystemMatrix(Solver);        }         public static List<int> ThereAreFiveHouses()        {            return  List<int> { 0, 1, 2, 3, 4 };        }         public CspTerm[] TheDaneDrinksTea()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                Solver.Equal(DrinkMatrix[houseNumber][(int)Drink.Tea],                NationalityMatrix[houseNumber][(int)Nationality.Danish])))                .ToArray();        }         public CspTerm[] TheSwedeHasADog()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                PetMatrix[houseNumber][(int)Pet.Dog],                NationalityMatrix[houseNumber][(int)Nationality.Swedish]))                .ToArray();        }         public CspTerm[] TheEnglishManLivesInTheRedHouse()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                ColourMatrix[houseNumber][(int)HouseColour.Red],                NationalityMatrix[houseNumber][(int)Nationality.English]))                .ToArray();        }         public CspTerm[] TheGreenHouseIsImmediatelyLeftOfTheWhiteHouse()        {            var constraints =  List<CspTerm>            {                Solver.Equal(0, ColourMatrix[0][(int) HouseColour.White]),                Solver.Equal(ColourMatrix[1][(int)HouseColour.White],                     ColourMatrix[0][(int)HouseColour.Green])            };             Enumerable.Range(1, 3).ToList()                .ForEach(houseNumber => constraints.Add(Solver.Equal(                    ColourMatrix[houseNumber + 1][(int)HouseColour.White],                    ColourMatrix[houseNumber][(int)HouseColour.Green])));             return constraints.ToArray();        }         public CspTerm[] TheyDrinkCoffeeInTheGreenHouse()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                DrinkMatrix[houseNumber][(int)Drink.Coffee],                ColourMatrix[houseNumber][(int)HouseColour.Green]))                .ToArray();        }         public CspTerm[] TheManWhoSmokesPallMallHasBirds()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                SmokeMatrix[houseNumber][(int)Smoke.PallMall],                PetMatrix[houseNumber][(int)Pet.Bird]))                .ToArray();        }         public CspTerm[] InTheYellowHouseTheySmokeDunhill()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                SmokeMatrix[houseNumber][(int)Smoke.Dunhill],                ColourMatrix[houseNumber][(int)HouseColour.Yellow]))                .ToArray();        }         public CspTerm[] InTheMiddleHouseTheyDrinkMilk()        {            const int middleHouseNumber = 2;            return []            {                Solver.Equal(1,DrinkMatrix[middleHouseNumber][(int)Drink.Milk])            };        }         public CspTerm[] TheManWhoSmokesBlendInHouseNextToHouseWithCats()        {            var constraints =  List<CspTerm>            {                Solver.Greater(1, Solver.Sum(                    SmokeMatrix[0][(int) Smoke.Blend],                    PetMatrix[0][(int) Pet.Cat]) - Solver.Sum(                        SmokeMatrix[1][(int) Smoke.Blend],                        PetMatrix[1][(int) Pet.Cat])),                  Solver.Greater(1, Solver.Sum(                    SmokeMatrix[4][(int)Smoke.Blend],                    PetMatrix[4][(int)Pet.Cat]) - Solver.Sum(                        SmokeMatrix[3][(int)Smoke.Blend],                        PetMatrix[3][(int)Pet.Cat]))            };             Enumerable.Range(1, 3).ToList()                .ForEach(houseNumber => constraints.Add(                    Solver.Greater(1, Solver.Sum(                        SmokeMatrix[houseNumber][(int)Smoke.Blend],                        PetMatrix[houseNumber][(int)Pet.Cat]) - Solver.Sum(                            SmokeMatrix[houseNumber - 1][(int)Smoke.Blend],                            SmokeMatrix[houseNumber + 1][(int)Smoke.Blend],                            PetMatrix[houseNumber - 1][(int)Pet.Cat],                            PetMatrix[houseNumber + 1][(int)Pet.Cat]))));             return constraints.ToArray();        }         public CspTerm[] TheManWhoSmokesBlueMasterDrinksBeer()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                SmokeMatrix[houseNumber][(int)Smoke.BlueMaster],                DrinkMatrix[houseNumber][(int)Drink.Beer]))                .ToArray();        }         public CspTerm[] TheGermanSmokesPrince()        {            return HouseNumbers.Select(houseNumber => Solver.Equal(                SmokeMatrix[houseNumber][(int)Smoke.Prince],                NationalityMatrix[houseNumber][(int)Nationality.German]))                .ToArray();        }         public CspTerm TheNorwegianLivesInTheFirstHouse()        {            const int firstHouseNumber = 0;            return Solver.Equal(1, NationalityMatrix[firstHouseNumber][                (int)Nationality.Norwegian]);        }         public CspTerm[] TheNorwegianLivesNextToTheBlueHouse()        {            var constraints =  List<CspTerm>            {                Solver.Greater(1, Solver.Sum(                    NationalityMatrix[0][(int) Nationality.Norwegian],                    ColourMatrix[0][(int) HouseColour.Blue]) - Solver.Sum(                        NationalityMatrix[1][(int) Nationality.Norwegian],                        ColourMatrix[1][(int) HouseColour.Blue])),                 Solver.Greater(1, Solver.Sum(                    NationalityMatrix[4][(int) Nationality.Norwegian],                    ColourMatrix[4][(int) HouseColour.Blue]) - Solver.Sum(                        NationalityMatrix[3][(int) Nationality.Norwegian],                        ColourMatrix[3][(int) HouseColour.Blue]))            };             Enumerable.Range(1, 3).ToList()                .ForEach(houseNumber => constraints.Add(                    Solver.Greater(1, Solver.Sum(                        NationalityMatrix[houseNumber][                            (int)Nationality.Norwegian],                        ColourMatrix[houseNumber][(int)HouseColour.Blue])                        - Solver.Sum(                            NationalityMatrix[houseNumber - 1][                                (int)Nationality.Norwegian],                            NationalityMatrix[houseNumber + 1][                                (int)Nationality.Norwegian],                            ColourMatrix[houseNumber - 1][                                (int)HouseColour.Blue],                            ColourMatrix[houseNumber + 1][                                (int)HouseColour.Blue]))));             return constraints.ToArray();        }         public CspTerm[] TheyDrinkWaterInHouseNextToHouseWhereSmokeBlend()        {            var constraints =  List<CspTerm>            {             Solver.Greater(1, Solver.Sum(                SmokeMatrix[4][(int)Smoke.Blend],                DrinkMatrix[4][(int)Drink.Water]) - Solver.Sum(                    SmokeMatrix[3][(int)Smoke.Blend],                    DrinkMatrix[3][(int)Drink.Water])),                 Solver.Greater(1, Solver.Sum(                SmokeMatrix[0][(int)Smoke.Blend],                DrinkMatrix[0][(int)Drink.Water]) - Solver.Sum(                    SmokeMatrix[1][(int)Smoke.Blend],                    DrinkMatrix[1][(int)Drink.Water]))            };             Enumerable.Range(1, 3).ToList()                .ForEach(houseNumber => constraints.Add(                Solver.Greater(1, Solver.Sum(                SmokeMatrix[houseNumber][(int)Smoke.Blend],                DrinkMatrix[houseNumber][(int)Drink.Water]) - Solver.Sum(                    SmokeMatrix[houseNumber - 1][(int)Smoke.Blend],                    SmokeMatrix[houseNumber + 1][(int)Smoke.Blend],                    DrinkMatrix[houseNumber - 1][(int)Drink.Water],                    DrinkMatrix[houseNumber + 1][(int)Drink.Water]))));             return constraints.ToArray();        }         public CspTerm[] InHouseNextToHouseWhereHaveAHorseSmokeDunhill()        {            var constraints =  List<CspTerm>            {                Solver.Greater(1, Solver.Sum(                    SmokeMatrix[0][(int) Smoke.Dunhill],                    PetMatrix[0][(int) Pet.Horse]) - Solver.Sum(                        SmokeMatrix[1][(int) Smoke.Dunhill],                        PetMatrix[1][(int) Pet.Horse])),                 Solver.Greater(1, Solver.Sum(                    SmokeMatrix[4][(int) Smoke.Dunhill],                    PetMatrix[4][(int) Pet.Horse]) - Solver.Sum(                        SmokeMatrix[3][(int) Smoke.Dunhill],                        PetMatrix[3][(int) Pet.Horse]))            };             Enumerable.Range(1, 3).ToList()                .ForEach(houseNumber => constraints.Add(                    Solver.Greater(1, Solver.Sum(                    SmokeMatrix[houseNumber][(int)Smoke.Dunhill],                    PetMatrix[houseNumber][(int)Pet.Horse]) - Solver.Sum(                        SmokeMatrix[houseNumber - 1][(int)Smoke.Dunhill],                        SmokeMatrix[houseNumber + 1][(int)Smoke.Dunhill],                        PetMatrix[houseNumber - 1][(int)Pet.Horse],                        PetMatrix[houseNumber + 1][(int)Pet.Horse]))));             return constraints.ToArray();        }    }}"
"     public partial class Form1 : Form    {        public Form1()        {            InitializeComponent();            Paint += Form1_Paint;        }         private void Form1_Paint(object sender, PaintEventArgs e)        {            Graphics g = e.Graphics;            g.SmoothingMode = System..SmoothingMode.AntiAlias;             DrawTaijitu(g,  Point(50, 50), 200, true);            DrawTaijitu(g,  Point(10, 10), 60, true);        }         private void DrawTaijitu(Graphics g, Point pt, int width, bool hasOutline)        {            g.FillPie(Brushes.Black, pt.X, pt.Y, width, width, 90, 180);            g.FillPie(Brushes.White, pt.X, pt.Y, width, width, 270, 180);            float headSize = Convert.ToSingle(width * 0.5);            float headXPosition = Convert.ToSingle(pt.X + (width * 0.25));            g.FillEllipse(Brushes.Black, headXPosition, Convert.ToSingle(pt.Y), headSize, headSize);            g.FillEllipse(Brushes.White, headXPosition, Convert.ToSingle(pt.Y + (width * 0.5)), headSize, headSize);            float headBlobSize = Convert.ToSingle(width * 0.125);            float headBlobXPosition = Convert.ToSingle(pt.X + (width * 0.4375));            g.FillEllipse(Brushes.White, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.1875)), headBlobSize, headBlobSize);            g.FillEllipse(Brushes.Black, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.6875)), headBlobSize, headBlobSize);            if (hasOutline) g.DrawEllipse(Pens.Black, pt.X, pt.Y, width, width);        }    }"
XmlReader XReader; // Either read the xml from a string ...XReader = XmlReader.Create( StringReader(strv)); // ... or read it from the file system.XReader = XmlReader.Create(strv); // Create a XPathDocument object (which implements the IXPathNavigable interface)// which is optimized for XPath operation. (very fast).IXPathNavigable XDocument =  XPathDocument(XReader); // Create a Navigator to navigate through the document.XPathNavigator Nav = XDocument.CreateNavigator();Nav = Nav.SelectSingleNode(strv); // Move to the first element of the selection. (if available).if(Nav.MoveToFirst()){  Console.WriteLine(Nav.OuterXml); // The outer xml of the first item element.} // Get an iterator to loop over multiple selected nodes.XPathNodeIterator Iterator = XDocument.CreateNavigator().Select(strv); while (Iterator.MoveNext()){  Console.WriteLine(Iterator.Current.Value);} Iterator = XDocument.CreateNavigator().Select(strv); // Use a generic list.List<string> NodesValues =  List<string>(); while (Iterator.MoveNext()){  NodesValues.Add(Iterator.Current.Value);} // Convert the generic list to an array and output the count of items.Console.WriteLine(NodesValues.ToArray().Length);
"using System;using System.Collections.Generic;using System.Linq;using System.Xml.Linq; class Program{    static string CreateXML(Dictionary<string, string> characterRemarks)    {        var remarks = characterRemarks.Select(r =>  XElement(strv, r.Value,  XAttribute(strv, r.Key)));        var xml =  XElement(strv, remarks);        return xml.ToString();    }     static void Main(string[] args)    {        var characterRemarks =  Dictionary<string, string>        {            { strv, strv },            { strv, ""Burns: When chapman billies leave the street ..."" },            { strv, strv }        };         string xml = CreateXML(characterRemarks);        Console.WriteLine(xml);    }}"
"using System;using System.Net;using System.Text.RegularExpressions;using System.Collections.Generic; class YahooSearch {    private string query;    private string content;    private int page;     const string yahoo = strv;     public YahooSearch(string query) : this(query, 0) { }     public YahooSearch(string query, int page) {        this.query = query;        this.page = page;        this.content =  WebClient()            .DownloadString(                string.Format(yahoo + strv, query, this.page * 10 + 1)            );    }     public YahooResult[] Results {        get {            List<YahooResult> results =  List<YahooResult>();             Func<string, string, string> substringBefore = (str, before) =>            {                int iHref = str.IndexOf(before);                return iHref < 0 ? strv : str.Substring(0, iHref);            };            Func<string, string, string> substringAfter = (str, after) =>            {                int iHref = str.IndexOf(after);                return iHref < 0 ? strv : str.Substring(iHref + after.Length);            };            Converter<string, string> getText = p =>                 Regex.Replace(p, strv, x => strv);             Regex rx =  Regex(@""
                <li>
                    <div \s class=""strv"">
                        <div>
                            <h3>
                                <a  (?'LinkAttributes'[^>]+)>
                                    (?'LinkText' .*?)
                                (?></a>)
                            </h3>
                        </div>
                        <div  class=""strv"">
                            (?'Abstract' .*?)
                        (?></div>)
                        .*?
                    (?></div>)
                </li>"",                RegexOptions.IgnorePatternWhitespace                | RegexOptions.ExplicitCapture            );            foreach (Match e in rx.Matches(this.content)) {                string rurl = getText(substringBefore(substringAfter(                    e.Groups[strv].Value, @strvstrv), @strvstrv));                string rtitle = getText(e.Groups[strv].Value);                string rcontent = getText(e.Groups[strv].Value);                 results.Add( YahooResult(rurl, rtitle, rcontent));            }            return results.ToArray();        }    }     public YahooSearch NextPage() {        return  YahooSearch(this.query, this.page + 1);    }     public YahooSearch GetPage(int page) {        return  YahooSearch(this.query, page);    }} class YahooResult {    public string URL { get; set; }    public string Title { get; set; }    public string Content { get; set; }     public YahooResult(string url, string title, string content) {        this.URL = url;        this.Title = title;        this.Content = content;    }     public override string ToString()    {        return string.Format(""Title: {0}Link:  {1}Text:  {2}"",            Title, URL, Content);    }} // Usage:  class Prog {    static void Main() {        foreach (int page in [] { 0, 1 })        {            YahooSearch x =  YahooSearch(strv, page);             foreach (YahooResult result in x.Results)            {                Console.WriteLine(result);            }        }    }} "
"using System.Xml;using System.Xml.Serialization;[XmlRoot(strv)]public class ExampleXML{    [XmlElement(strv)]    public string element = strv;    static void Main(string[] args)    {        var xmlnamespace =  XmlSerializerNamespaces();        xmlnamespace.Add(strv, strv); //used to stop default namespaces from printing        var writer = XmlWriter.Create(strv);         XmlSerializer((ExampleXML)).Serialize(writer,  ExampleXML(), xmlnamespace);    }    //Output: <?xml version=strv?><root><element>Some text here</element></root>}"
" using System;using System.Xml;using System.Xml.Schema;using System.IO; public class Test{	public static void Main()	{		// your code goes here		XmlSchemaSet sc =  XmlSchemaSet();		sc.Add(null, strv);		XmlReaderSettings settings =  XmlReaderSettings();		settings.ValidationType = ValidationType.Schema;		settings.Schemas = sc;		settings.ValidationEventHandler +=  ValidationEventHandler(ValidationCallBack);		// Create the XmlReader object.		XmlReader reader = XmlReader.Create(strv, settings);		// Parse the file.		while (reader.Read()); 		// will call event handler if invalid		Console.WriteLine(strv);	} 	// Display any validation errors.	private static void ValidationCallBack(object sender, ValidationEventArgs e) {		Console.WriteLine(strv, e.Message);	}} "
 class Program{    static void Main(string[] args)    {           XDocument xmlDoc = XDocument.Load(strv);        var query = from p in xmlDoc.Descendants(strv)                    select p.Attribute(strv);         foreach (var item in query)        {            Console.WriteLine(item.Value);        }        Console.ReadLine();    }  } 
"using System.Diagnostics; namespace RC{  internal class Program  {    public static void Main()    {      string sSource  = strv;      string sLog     = strv;      string sEvent   = strv;       if (!EventLog.SourceExists(sSource))        EventLog.CreateEventSource(sSource, sLog);       EventLog.WriteEntry(sSource, sEvent);      EventLog.WriteEntry(sSource, sEvent, EventLogEntryType.Information);    }  }}"
"using System; static class YCombinator<T> {  delegate Func<T, T> Recursive(Recursive recursive);  public static Func<Func<Func<T, T>, Func<T, T>>, Func<T, T>> Fix =    f => ((Recursive)(g =>        (f(x => g(g)(x)))))((Recursive)(g => f(x => g(g)(x))));} class Program {  static Func<int, int> fac =    YCombinator<int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));  static Func<int, int> fib =    YCombinator<int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));   static void Main() {    Console.WriteLine(fac(10));    Console.WriteLine(fib(10));  }}"
"using System.IO; class Program{    static void Main(string[] args)    {        var x =  double[] { 1, 2, 3, 1e11 };        var y =  double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };         int xprecision = 3;        int yprecision = 5;         string formatString = strv + xprecision + ""}{1:G"" + yprecision + strv;         using (var outf =  StreamWriter(strv))            for (int i = 0; i < x.Length; i++)                outf.WriteLine(formatString, x[i], y[i]);    }}"
"System..File.WriteAllText(strv, strv);"
"namespace RosettaCode.WordWrap{    using System;    using System.Collections.Generic;     internal static class Program    {        private const string LoremIpsum = @""
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien
vel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu
pharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus
consectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque
penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt
purus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel
felis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta
tortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,
condimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed
venenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu
nibh."";         private static void Main()        {            foreach (var lineWidth in [] { 72, 80 })            {                Console.WriteLine( string('-', lineWidth));                Console.WriteLine(Wrap(LoremIpsum, lineWidth));            }        }         private static string Wrap(string text, int lineWidth)        {            return string.Join(string.Empty,                               Wrap(                                   text.Split( char[0],                                              StringSplitOptions                                                  .RemoveEmptyEntries),                                   lineWidth));        }         private static IEnumerable<string> Wrap(IEnumerable<string> words,                                                int lineWidth)        {            var currentWidth = 0;            foreach (var word in words)            {                if (currentWidth != 0)                {                    if (currentWidth + word.Length < lineWidth)                    {                        currentWidth++;                        yield return strv;                    }                    else                    {                        currentWidth = 0;                        yield return Environment.NewLine;                    }                }                currentWidth += word.Length;                yield return word;            }        }    }}"
using System;using System.Windows.Forms; public class Window {    [STAThread]    static void Main() {        Form form =  Form();         form.Text = strv;        form.Disposed += delegate { Application.Exit(); };         form.Show();        Application.Run();    }}
"class Program    {        static void Main(string[] args)        {            WebClient wc =  WebClient();            Stream myStream = wc.OpenRead(strv);            string html = strv;            using (StreamReader sr =  StreamReader(myStream))            {                while (sr.Peek() >= 0)                {                    html = sr.ReadLine();                    if (html.Contains(strv))                    {                        break;                    }                }             }            Console.WriteLine(html.Remove(0, 4));             Console.ReadLine();        }    } "
"using System;using System.Collections.Generic;using System.IO;using System.Linq; namespace RosettaRecursiveDirectory{    class Program    {        static IEnumerable<FileInfo> TraverseDirectory(string rootPath, Func<FileInfo, bool> Pattern)        {            var directoryStack =  Stack<DirectoryInfo>();            directoryStack.Push( DirectoryInfo(rootPath));            while (directoryStack.Count > 0)            {                var dir = directoryStack.Pop();                try                {                    foreach (var i in dir.GetDirectories())                        directoryStack.Push(i);                }                catch (UnauthorizedAccessException) {                    continue; // We don't have access to this directory, so skip it                }                foreach (var f in dir.GetFiles().Where(Pattern)) // strv is a function                    yield return f;            }        }        static void Main(string[] args)        {            // Print the full path of all .wmv files that are somewhere in the C:\Windows directory or its subdirectories            foreach (var file in TraverseDirectory(@strv, f => f.Extension == strv))                Console.WriteLine(file.FullName);            Console.WriteLine(strv);        }    }} "
"using System;using System.IO; namespace DirectoryWalk{    class Program    {        static void Main(string[] args)        {            string[] filePaths = Directory.GetFiles(@strv, strv);            foreach (string filename in filePaths)                Console.WriteLine(filename);                    }    }} "
" using System; namespace VigenereCipher{    class VCipher    {        public string encrypt(string txt, string pw, int d)        {            int pwi = 0, tmp;            string ns = strv;            txt = txt.ToUpper();            pw = pw.ToUpper();            foreach (char t in txt)            {                if (t < 65) continue;                tmp = t - 65 + d * (pw[pwi] - 65);                if (tmp < 0) tmp += 26;                ns += Convert.ToChar(65 + ( tmp % 26) );                if (++pwi == pw.Length) pwi = 0;            }             return ns;        }    };     class Program    {        static void Main(string[] args)        {            VCipher v =  VCipher();             string s0 = strv,                   pw = strv;             Console.WriteLine(s0 + """" + pw + """");            string s1 = v.encrypt(s0, pw, 1);            Console.WriteLine(strv + s1);            s1 = v.encrypt(s1, strv, -1);            Console.WriteLine(strv + s1);            Console.WriteLine(""Press any key to continue..."");            Console.ReadKey();        }    }} "
"using System;using System.Collections.Generic;using System.Linq; namespace RosettaVectors{    public class Vector    {        public double[] store;        public Vector(IEnumerable<double> init)        {            store = init.ToArray();        }        public Vector(double x, double y)        {            store =  double[] { x, y };        }        static public Vector operator+(Vector v1, Vector v2)        {            return  Vector(v1.store.Zip(v2.store, (a, b) => a + b));        }        static public Vector operator -(Vector v1, Vector v2)        {            return  Vector(v1.store.Zip(v2.store, (a, b) => a - b));        }        static public Vector operator *(Vector v1, double scalar)        {            return  Vector(v1.store.Select(x => x * scalar));        }        static public Vector operator /(Vector v1, double scalar)        {            return  Vector(v1.store.Select(x => x / scalar));        }        public override string ToString()        {            return string.Format(strv, string.Join(strv, store));        }    }    class Program    {        static void Main(string[] args)        {            var v1 =  Vector(5, 7);            var v2 =  Vector(2, 3);            Console.WriteLine(v1 + v2);            Console.WriteLine(v1 - v2);            Console.WriteLine(v1 * 11);            Console.WriteLine(v1 / 2);            // Works with arbitrary size vectors, too.            var lostVector =  Vector( double[] { 4, 8, 15, 16, 23, 42 });            Console.WriteLine(lostVector * 7);            Console.ReadLine();        }    }} "
"using System; class Program {    static void Main(string[] args) {        PrintAll(strv, strv, 123, 5.6);    }     static void PrintAll(params object[] varargs) {        foreach (var i in varargs) {            Console.WriteLine(i);        }    }}"
"using System;using System.Windows.Media.Media3D; class VectorProducts{    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)    {        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));    }     static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)    {        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));    }     static void Main()    {        var a =  Vector3D(3, 4, 5);        var b =  Vector3D(4, 3, 5);        var c =  Vector3D(-5, -12, -13);         Console.WriteLine(Vector3D.DotProduct(a, b));        Console.WriteLine(Vector3D.CrossProduct(a, b));        Console.WriteLine(ScalarTripleProduct(a, b, c));        Console.WriteLine(VectorTripleProduct(a, b, c));    }}"
"namespace Vlq{  using System;  using System.Collections.Generic;  using System.Linq;   public static class VarLenQuantity  {    public static ulong ToVlq(ulong integer)    {      var array =  byte[8];      var buffer = ToVlqCollection(integer)        .SkipWhile(b => b == 0)        .Reverse()        .ToArray();      Array.Copy(buffer, array, buffer.Length);      return BitConverter.ToUInt64(array, 0);    }     public static ulong FromVlq(ulong integer)    {      var collection = BitConverter.GetBytes(integer).Reverse();      return FromVlqCollection(collection);    }     public static IEnumerable<byte> ToVlqCollection(ulong integer)    {      if (integer > Math.Pow(2, 56))        throw  OverflowException(strv);       var index = 7;      var significantBitReached = false;      var mask = 0x7fUL << (index * 7);      while (index >= 0)      {        var buffer = (mask & integer);        if (buffer > 0 || significantBitReached)        {          significantBitReached = true;          buffer >>= index * 7;          if (index > 0)            buffer |= 0x80;          yield return (byte)buffer;        }        mask >>= 7;        index--;      }    }      public static ulong FromVlqCollection(IEnumerable<byte> vlq)    {      ulong integer = 0;      var significantBitReached = false;       using (var enumerator = vlq.GetEnumerator())      {        int index = 0;        while (enumerator.MoveNext())        {          var buffer = enumerator.Current;          if (buffer > 0 || significantBitReached)          {            significantBitReached = true;            integer <<= 7;            integer |= (buffer & 0x7fUL);          }           if (++index == 8 || (significantBitReached && (buffer & 0x80) != 0x80))            break;        }      }      return integer;    }     public static void Main()    {      var integers =  ulong[] { 0x7fUL << 7 * 7, 0x80, 0x2000, 0x3FFF, 0x4000, 0x200000, 0x1fffff };       foreach (var original in integers)      {        Console.WriteLine(strv, original);         //collection        var seq = ToVlqCollection(original);        Console.WriteLine(strv, seq.Select(b => b.ToString(strv)).Aggregate(string.Concat));         var decoded = FromVlqCollection(seq);        Console.WriteLine(strv, decoded);         //ints        var encoded = ToVlq(original);        Console.WriteLine(strv, encoded);         decoded = FromVlq(encoded);        Console.WriteLine(strv, decoded);         Console.WriteLine();      }      Console.WriteLine(strv);      Console.ReadKey();    }  }}"
"int j;int p, a, d;int a = 4;int b;int c = Func(a); b = 5;"
 class Program{    static void Main(string[] args)    {        int i = (int);        Console.WriteLine(i);        Console.ReadLine();    }       } 
"using System; namespace RosettaVampireNumber{    class Program    {        static void Main(string[] args)        {            int i, j, n;            ulong x;            var f =  ulong[16];            var bigs =  ulong[] { 16758243290880UL, 24959017348650UL, 14593825548650UL, 0 };            ulong[] tens =  ulong[20];            tens[0] = 1;            for (i = 1; i < 20; i++)                tens[i] = tens[i - 1] * 10;             for (x = 1, n = 0; n < 25; x++)            {                if ((j = fangs(x, f, tens)) == 0) continue;                Console.Write(++n + strv);                show_fangs(x, f, j);            }             Console.WriteLine();            for (i = 0; bigs[i] > 0 ; i++)            {                if ((j = fangs(bigs[i], f, tens)) > 0)                    show_fangs(bigs[i], f, j);                else                    Console.WriteLine(bigs[i] + strv);            }            Console.ReadLine();        }         private static void show_fangs(ulong x, ulong[] f, int cnt)        {            Console.Write(x);             int i;            for (i = 0; i < cnt; i++)                Console.Write(strv + f[i] + strv + (x / f[i]));            Console.WriteLine();        }         private static int fangs(ulong x, ulong[] f, ulong[] tens)        {            int n = 0;            int nd = ndigits(x);            if ((nd & 1) > 0) return 0;            nd /= 2;             ulong lo, hi;            lo = Math.Max(tens[nd - 1], (x + tens[nd] - 2) / (tens[nd] - 1));            hi = Math.Min(x / lo, (ulong) Math.Sqrt(x));             ulong a, b, t = dtally(x);            for (a = lo; a <= hi; a++)            {                b = x / a;                if (a * b == x && ((a % 10) > 0 || (b % 10) > 0) && t == dtally(a) + dtally(b))                    f[n++] = a;            }             return n;        }         private static ulong dtally(ulong x)        {            ulong t = 0;            while (x > 0)            {                t += 1UL << (int)((x % 10) * 6);                x /= 10;            }             return t;        }         private static int ndigits(ulong x)        {            int n = 0;            while (x > 0)            {                n++;                x /= 10;            }            return n;        }    }}"
" using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace VanDerCorput{    
    
    
    
    
    
    
    
    
    
    
    
    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>    {        
        
        
        public int Base { get; private set; }         
        
        
        public long Count { get; private set; }         
        
        
        
        
        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {            if (iBase < 2)                throw  ArgumentOutOfRangeException(strv, strv + iBase);            Base = iBase;            Count = count;        }         
        
        
        
        
        
        public Tuple<long,long> Compute(long n)        {            long p = 0, q = 1;            long numerator, denominator;            while (n != 0)            {                p = p * Base + (n % Base);                q *= Base;                n /= Base;            }            numerator = p;            denominator = q;            while (p != 0)             {                 n = p;                 p = q % p;                 q = n;             }            numerator /= q;            denominator /= q;            return  Tuple<long,long>(numerator, denominator);        }         
        
        
        
        
        
        public static Tuple<long, long> Compute(int iBase, long n)        {            var seq =  VanDerCorputSequence(iBase);            return seq.Compute(n);        }         
        
        
        
        
        public IEnumerator<Tuple<long, long>> GetEnumerator()        {            long iSequenceIndex = 0L;            while (iSequenceIndex < Count)            {                yield return Compute(iSequenceIndex);                iSequenceIndex++;            }        }         System..IEnumerator System..IEnumerable.GetEnumerator()        {            return GetEnumerator();        }    }     class Program    {        static void Main(string[] args)        {            TestBasesTwoThroughFive();             Console.WriteLine(strv);            Console.ReadLine();        }         static void TestBasesTwoThroughFive()        {            foreach (var seq in Enumerable.Range(2, 5).Select(x =>  VanDerCorputSequence(x, 10))) // Just the first 10 elements of the each sequence            {                Console.Write(strv + seq.Base + strv);                foreach(var vc in seq)                     Console.Write(strv + vc.Item1 + strv + vc.Item2);                Console.WriteLine();            }        }    }}  "
using System; namespace C_Sharp_Console {     class example {         static void Main() {            string word;            int num;             Console.Write(strv);            num = Console.Read();            Console.Write(strv);            word = Console.ReadLine();        }    }}
"using System; namespace RosettaUrlParse{    class Program    {        static void ParseUrl(string url)        {            var u =  Uri(url);            Console.WriteLine(strv, u.AbsoluteUri);            Console.WriteLine(strv, u.Scheme);            Console.WriteLine(strv, u.DnsSafeHost);            Console.WriteLine(strv, u.Port);            Console.WriteLine(strv, u.LocalPath);            Console.WriteLine(strv, u.Query);            Console.WriteLine(strv, u.Fragment);            Console.WriteLine();        }        static void Main(string[] args)        {            ParseUrl(strv);            ParseUrl(strv);            ParseUrl(""jdbc:mysql://test_user::3306/sakila?profileSQL=true"");            ParseUrl(strv);            ParseUrl(strv);            ParseUrl(strv);            ParseUrl(""mailto:"");            ParseUrl(strv);            ParseUrl(strv);            ParseUrl(strv);            ParseUrl(strv);        }    }} "
using System; namespace URLEncode{    internal class Program    {        private static void Main(string[] args)        {            Console.WriteLine(Decode(strv));        }         private static string Decode(string uri)        {            return Uri.UnescapeDataString(uri);        }    }}
class Program{    static void Main()    {        var Δ = 1;        Δ++;        System.Console.WriteLine(Δ);            }}
string foo = null;int i = null;int? answer = null;if (answer == null) {    answer = 42;}Nullable<int> answer =  Nullable<int>();if (!answer.HasValue) {    answer =  Nullable<int>(42);}
"public static int[] TwoSum(int[] numbers, int sum){    var map =  Dictionary<int, int>();    for (var i = 0; i < numbers.Length; i++)    {       	var key = sum - numbers[i];       	if (map.ContainsKey(key))            return [] { map[key], i };        map.Add(numbers[i], i);    }    return Array.Empty<int>();}"
"using System;using System.Collections.Generic;using System.Linq; public static class TwelveStatements{    public static void Main() {        Func<Statements, bool>[] checks = {            st => st[1],            st => st[2] == (7.To(12).Count(i => st[i]) == 3),            st => st[3] == (2.To(12, by: 2).Count(i => st[i]) == 2),            st => st[4] == st[5].Implies(st[6] && st[7]),            st => st[5] == (!st[2] && !st[3] && !st[4]),            st => st[6] == (1.To(12, by: 2).Count(i => st[i]) == 4),            st => st[7] == (st[2] != st[3]),            st => st[8] == st[7].Implies(st[5] && st[6]),            st => st[9] == (1.To(6).Count(i => st[i]) == 3),            st => st[10] == (st[11] && st[12]),            st => st[11] == (7.To(9).Count(i => st[i]) == 1),            st => st[12] == (1.To(11).Count(i => st[i]) == 4)        };         for (Statements statements =  Statements(0); statements.Value < 4096; statements++) {            int count = 0;            int falseIndex = 0;            for (int i = 0; i < checks.Length; i++) {                if (checks[i](statements)) count++;                else falseIndex = i;            }            if (count == 0) Console.WriteLine($strvAll wrong:strv);            else if (count == 11) Console.WriteLine($strvWrong at {falseIndex + 1}:strv);            else if (count == 12) Console.WriteLine($strvAll correct:strv);        }    }     struct Statements    {            public Statements(int value) : this() { Value = value; }         public int Value { get; }         public bool this[int index] => (Value & (1 << index - 1)) != 0;         public static Statements operator ++(Statements statements) =>  Statements(statements.Value + 1);         public override string ToString() {            Statements copy = this; //Cannot access 'this' in anonymous method...            return string.Join(strv, from i in 1.To(12) select copy[i] ? strv : strv);        }     }     //Extension methods    static bool Implies(this bool x, bool y) => !x || y;     static IEnumerable<int> To(this int start, int end, int by = 1) {        while (start <= end) {            yield return start;            start += by;        }    } }"
"using System;using System.Diagnostics; namespace RosettaCode{  internal class Program  {    public static bool IsPrime(int n)    {      if (n<2) return false;      if (n<4) return true;      if (n%2==0) return false;      if (n<9) return true;      if (n%3==0) return false;      var r = (int) Math.Sqrt(n);      var f = 6-1;      while (f<=r)      {        if (n%f==0 ||n%(f+2)==0)          return false;        f += 6;      }      return true;    }     private static bool IsRightTruncatable(int n)    {      for (;;)      {        n /= 10;        if (n==0)          return true;        if (!IsPrime(n))          return false;      }    }     private static bool IsLeftTruncatable(int n)    {      string c = n.ToString();      if (c.Contains(strv))        return false;      for (int i = 1; i<c.Length; i++)        if (!IsPrime(Convert.ToInt32(c.Substring(i))))          return false;      return true;    }     private static void Main()    {      var sb =  Stopwatch();      sb.Start();      int lt = 0, rt = 0;      for (int i = 1000000; i>0; --i)      {        if (IsPrime(i))        {          if (rt==0 && IsRightTruncatable(i))            rt = i;          else if (lt==0 && IsLeftTruncatable(i))            lt = i;          if (lt!=0 && rt!=0)            break;        }      }      sb.Stop();      Console.WriteLine(strv,                        lt, rt, sb.ElapsedMilliseconds);    }  }}"
"public  void move(int n, int from, int to, int via) {   if (n == 1) {     System.Console.WriteLine(strv + from + strv + to);   } else {     move(n - 1, from, via, to);     move(1, from, to, via);     move(n - 1, via, to, from);   } }"
"using System;using System.Text;using System.Collections.Generic; public class TokenizeAStringWithEscaping{    public static void Main() {        string testcase = strv;        foreach (var token in testcase.Tokenize(separator: '|', escape: '^')) {            Console.WriteLine(strv + token); //Adding a : so we can see empty lines        }    }} public static class Extensions{    public static IEnumerable<string> Tokenize(this string input, char separator, char escape) {        if (input == null) yield break;        var buffer =  StringBuilder();        bool escaping = false;        foreach (char c in input) {            if (escaping) {                buffer.Append(c);                escaping = false;            } else if (c == escape) {                escaping = true;            } else if (c == separator) {                yield return buffer.Flush();            } else {                buffer.Append(c);            }        }        if (buffer.Length > 0 || input[input.Length-1] == separator) yield return buffer.Flush();    }     public static string Flush(this StringBuilder stringBuilder) {        string result = stringBuilder.ToString();        stringBuilder.Clear();        return result;    }}"
"using System;using System.Collections.Generic;using System.Linq; class Node{    int Value;    Node Left;    Node Right;     Node(int value = default(int), Node left = default(Node), Node right = default(Node))    {        Value = value;        Left = left;        Right = right;    }     IEnumerable<int> Preorder()    {        yield return Value;        if (Left != null)            foreach (var value in Left.Preorder())                yield return value;        if (Right != null)            foreach (var value in Right.Preorder())                yield return value;    }     IEnumerable<int> Inorder()    {        if (Left != null)            foreach (var value in Left.Inorder())                yield return value;        yield return Value;        if (Right != null)            foreach (var value in Right.Inorder())                yield return value;    }     IEnumerable<int> Postorder()    {        if (Left != null)            foreach (var value in Left.Postorder())                yield return value;        if (Right != null)            foreach (var value in Right.Postorder())                yield return value;        yield return Value;    }     IEnumerable<int> LevelOrder()    {        var queue =  Queue<Node>();        queue.Enqueue(this);        while (queue.Any())        {            var node = queue.Dequeue();            yield return node.Value;            if (node.Left != null)                queue.Enqueue(node.Left);            if (node.Right != null)                queue.Enqueue(node.Right);        }    }     static void Main()    {        var tree =  Node(1,  Node(2,  Node(4,  Node(7)),  Node(5)),  Node(3,  Node(6,  Node(8),  Node(9))));        foreach (var traversal in  Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })            Console.WriteLine(""{0}:{1}"", traversal.Method.Name, string.Join(strv, traversal()));    }}"
"using System;using System.Collections.Generic;using System.Linq; public class Program{	class Employee	{		public Employee(string name, string id, int salary, string department)		{			Name = name;			Id = id;			Salary = salary;			Department = department;		} 		public string Name { get; private set; }		public string Id { get; private set; }		public int Salary { get; private set; }		public string Department { get; private set; } 		public override string ToString()		{			return String.Format(""{0, -25}{1}{2}"", Name, Id, Salary);		}	} 	private static void Main(string[] args)	{		var employees =  List<Employee>			            {				             Employee(strv, strv, 32000, strv),				             Employee(strv, strv, 47000, strv),				             Employee(strv, strv, 53500, strv),				             Employee(strv, strv, 18000, strv),				             Employee(strv, strv, 27800, strv),				             Employee(strv, strv, 41500, strv),				             Employee(strv, strv, 49500, strv),				             Employee(strv, strv, 21900, strv),				             Employee(strv, strv, 15900, strv),				             Employee(strv, strv, 19250, strv),				             Employee(strv, strv, 27000, strv),				             Employee(strv, strv, 57000, strv),				             Employee(strv, strv, 29900, strv)			            }; 		DisplayTopNPerDepartment(employees, 2);	} 	static void DisplayTopNPerDepartment(IEnumerable<Employee> employees, int n)	{		var topSalariesByDepartment =			from employee in employees			group employee by employee.Department			into g			select 				    {					    Department = g.Key,					    TopEmployeesBySalary = g.OrderByDescending(e => e.Salary).Take(n)				    }; 		foreach (var x in topSalariesByDepartment)		{			Console.WriteLine(strv + x.Department);			foreach (var employee in x.TopEmployeesBySalary)				Console.WriteLine(employee);			Console.WriteLine(strv);		}	}}"
"string str = strv; // or Regex.Split ( strv );// (Regex is in System.Text.RegularExpressions namespace)string[] strings = str.Split(',');foreach (string s in strings){    Console.WriteLine (s + strv);}"
"using System;using System.Security.Cryptography; namespace RosettaTOTP{    public class TOTP_SHA1    {        private byte[] K;        public TOTP_SHA1()        {            GenerateKey();        }        public void GenerateKey()        {            using (RandomNumberGenerator rng =  RNGCryptoServiceProvider())            {                /*    Keys SHOULD be of the length of the HMAC output to facilitate
                      interoperability.*/                K =  byte[HMACSHA1.Create().HashSize / 8];                rng.GetBytes(K);            }        }        public int HOTP(UInt64 C, int digits = 6)        {            var hmac = HMACSHA1.Create();            hmac.Key = K;            hmac.ComputeHash(BitConverter.GetBytes(C));            return Truncate(hmac.Hash, digits);        }        public UInt64 CounterNow(int T1 = 30)        {            var secondsSinceEpoch = (DateTime.UtcNow -  DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;            return (UInt64)Math.Floor(secondsSinceEpoch / T1);        }        private int DT(byte[] hmac_result)        {            int offset = hmac_result[19] & 0xf;            int bin_code = (hmac_result[offset] & 0x7f) << 24               | (hmac_result[offset + 1] & 0xff) << 16               | (hmac_result[offset + 2] & 0xff) << 8               | (hmac_result[offset + 3] & 0xff);            return bin_code;        }         private int Truncate(byte[] hmac_result, int digits)        {            var Snum = DT(hmac_result);            return Snum % (int)Math.Pow(10, digits);        }    }      class Program    {        static void Main(string[] args)        {            var totp =  TOTP_SHA1();            Console.WriteLine(totp.HOTP(totp.CounterNow()));        }    }} "
"using System; namespace RosettaCode {    class Program {        static void Main(string[] args) {            Console.WriteLine(strv);            Console.WriteLine(strv, Math.Sin(Math.PI / 3));            Console.WriteLine(strv, Math.Cos(Math.PI / 3));            Console.WriteLine(strv, Math.Tan(Math.PI / 3));            Console.WriteLine(strv, Math.Asin(0.5));            Console.WriteLine(strv, Math.Acos(0.5));            Console.WriteLine(strv, Math.Atan(0.5));            Console.WriteLine(strv);            Console.WriteLine(strv);            Console.WriteLine(strv, Math.Sin(60 * Math.PI / 180));            Console.WriteLine(strv, Math.Cos(60 * Math.PI / 180));            Console.WriteLine(strv, Math.Tan(60 * Math.PI / 180));            Console.WriteLine(strv, Math.Asin(0.5) * 180/ Math.PI);            Console.WriteLine(strv, Math.Acos(0.5) * 180 / Math.PI);            Console.WriteLine(strv, Math.Atan(0.5) * 180 / Math.PI);             Console.ReadLine();        }    }}"
"using System;using System.Linq;using System.Threading;using System.Diagnostics; class Program {    static void Main(string[] args) {        Stopwatch sw =  Stopwatch();         sw.Start();        DoSomething();        sw.Stop();         Console.WriteLine(strv, sw.Elapsed.TotalMilliseconds);    }     static void DoSomething() {        Thread.Sleep(1000);         Enumerable.Range(1, 10000).Where(x => x % 2 == 0).Sum();  // Sum even numers from 1 to 10000    }}using System;using System.Linq;using System.Threading; class Program {    static void Main(string[] args) {        DateTime start, end;         start = DateTime.Now;        DoSomething();        end = DateTime.Now;         Console.WriteLine(strv + (end - start).TotalMilliseconds + strv);    }         static void DoSomething() {        Thread.Sleep(1000);         Enumerable.Range(1, 10000).Where(x => x % 2 == 0).Sum();  // Sum even numers from 1 to 10000    }}"
"using System; public class TwelveDaysOfChristmas {     public static void Main() {         string[] days =  string[12] {            strv, strv, strv, strv, strv, strv, strv, strv, strv,            strv, strv, strv,        };         string[] gifts =  string[12] {            strv,            strv,            strv,            strv,            strv,            strv,            strv,            strv,            strv,            strv,            strv,            strv        };         for ( int i = 0; i < 12; i++ ) {             Console.WriteLine(strv + days[i] + strv);             int j = i + 1;            while ( j-- > 0 )                Console.WriteLine(gifts[j]);             Console.WriteLine();             if ( i == 0 )                gifts[0] = strv;        }     } }"
"using System;using System.Collections.Generic;using System.Text.RegularExpressions;using System.IO; namespace TextProc2{    class Program    {        static void Main(string[] args)        {            Regex multiWhite =  Regex(@strv);            Regex dateEx =  Regex(@strv);            Regex valEx =  Regex(@strv);            Regex flagEx =  Regex(@strv);             int missformcount = 0, totalcount = 0;            Dictionary<int, string> dates =  Dictionary<int, string>();             using (StreamReader sr =  StreamReader(strv))            {                string line = sr.ReadLine();                while (line != null)                {                    line = multiWhite.Replace(line, @strv);                                        string[] splitLine = line.Split(' ');                    if (splitLine.Length != 49)                        missformcount++;                    if (!dateEx.IsMatch(splitLine[0]))                                                missformcount++;                                        else                        dates.Add(totalcount + 1, dateEx.Match(splitLine[0]).ToString());                    int err = 0;                                        for (int i = 1; i < splitLine.Length; i++)                    {                        if (i%2 != 0)                        {                            if (!valEx.IsMatch(splitLine[i]))                                                          err++;                        }                        else                        {                            if (!flagEx.IsMatch(splitLine[i]))                                err++;                                                                                }                                            }                    if (err != 0) missformcount++;                    line = sr.ReadLine();                    totalcount++;                                    }            }             int goodEntries = totalcount - missformcount;            Dictionary<string,List<int>> dateReverse =  Dictionary<string,List<int>>();             foreach (KeyValuePair<int, string> kvp in dates)            {                if (!dateReverse.ContainsKey(kvp.Value))                    dateReverse[kvp.Value] =  List<int>();                dateReverse[kvp.Value].Add(kvp.Key);            }             Console.WriteLine(goodEntries + strv + totalcount);             foreach (KeyValuePair<string, List<int>> kvp in dateReverse)            {                if (kvp.Value.Count > 1)                    Console.WriteLine(strv, kvp.Key, string.Join(strv, kvp.Value));                                }        }    }}"
" using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.IO; namespace TextProc3{    class Program    {        static void Main(string[] args)        {                        string line;            int count = 0, maxcount = 0;            List<string> times =  List<string>();            System..StreamReader file =  StreamReader(strv);            while ((line = file.ReadLine()) != null)            {                string[] lineelements = line.Split(' ');                                switch (lineelements[1])                {                    case strv:                        count--;                        break;                    case strv:                        count++;                        if (count > maxcount)                        {                            maxcount = count;                            times.Clear();                            times.Add(lineelements[3]);                        }else if(count == maxcount){                            times.Add(lineelements[3]);                        }                        break;                }                            }            file.Close();            Console.WriteLine(maxcount);            foreach (string time in times)            {                Console.WriteLine(time);            }        }    }} "
" using Microsoft.VisualStudio.TestTools.UnitTesting;using PalindromeDetector.ConsoleApp; namespace PalindromeDetector.VisualStudioTests{    [TestClass]    public class VSTests    {        [TestMethod]        public void PalindromeDetectorCanUnderstandPalindrome()        {            //Microsoft.VisualStudio.QualityTools.UnitTestFramework v4.0.30319            bool expected = true;            bool actual;            actual = Program.IsPalindrome(strv);            Assert.AreEqual(expected, actual);            actual = Program.IsPalindromeNonRecursive(strv);            Assert.AreEqual(expected, actual);            actual = Program.IsPalindrome(strv);            Assert.AreEqual(expected, actual);            actual = Program.IsPalindromeNonRecursive(strv);            Assert.AreEqual(expected, actual);        }        [TestMethod]        public void PalindromeDetecotryCanUnderstandNonPalindrome()        {            bool notExpected = true;            bool actual = Program.IsPalindrome(strv);            Assert.AreNotEqual(notExpected, actual);            actual = Program.IsPalindromeNonRecursive(strv);            Assert.AreNotEqual(notExpected, actual);        }    }} using NUnit.Framework;using PalindromeDetector.ConsoleApp; namespace PalindromeDetector.VisualStudioTests{    [TestFixture]    public class NunitTests    {        [Test]        public void PalindromeDetectorCanUnderstandPalindrome()        {            //nunit.framework v2.0.50727            bool expected = true;            bool actual;            actual = Program.IsPalindrome(strv);            Assert.AreEqual(expected, actual);            actual = Program.IsPalindromeNonRecursive(strv);            Assert.AreEqual(expected, actual);            actual = Program.IsPalindrome(strv);            Assert.AreEqual(expected, actual);            actual = Program.IsPalindromeNonRecursive(strv);            Assert.AreEqual(expected, actual);        }        [Test]        public void PalindromeDetectorUnderstandsNonPalindrome()        {            bool notExpected = true;            bool actual;            actual = Program.IsPalindrome(strv);            Assert.AreEqual(notExpected, actual);            actual = Program.IsPalindromeNonRecursive(strv);            Assert.AreEqual(notExpected, actual);        }    }}"
"// the simple version:System.Console.Write(""""); // will beepSystem..Thread.Sleep(1000); // will wait for 1 secondSystem.Console.Beep(); // will beep a second timeSystem..Thread.Sleep(1000); // System.Console.Beep() also accepts (int)hertz and (int)duration in milliseconds:System.Console.Beep(440, 2000); // default strv for 2 seconds "
"using System; 





public static class NullableBoolExtension{    public static bool? Implies(this bool? left, bool? right)    {        return !left | right;    }     public static bool? IsEquivalentTo(this bool? left, bool? right)    {        return left.HasValue && right.HasValue ? left == right : default(bool?);    }     public static string Format(this bool? value)    {        return value.HasValue ? value.Value.ToString() : strv;    }} public class Program{    private static void Main()    {        var values = [] { true, default(bool?), false };         foreach (var left in values)        {            Console.WriteLine(strv, left.Format(), (!left).Format());            foreach (var right in values)            {                Console.WriteLine(strv, left.Format(), right.Format(), (left & right).Format());                Console.WriteLine(strv, left.Format(), right.Format(), (left | right).Format());                Console.WriteLine(strv, left.Format(), right.Format(), left.Implies(right).Format());                Console.WriteLine(strv, left.Format(), right.Format(), left.IsEquivalentTo(right).Format());            }        }    }}"
static void Main(string[] args){    Console.Write(strv);    System..Thread.Sleep(5000);    Console.CursorVisible = false;    Console.WriteLine();    Console.Write(strv);    System..Thread.Sleep(5000);}
 static void Main(string[] args){    int bufferHeight = Console.BufferHeight;    int bufferWidth = Console.BufferWidth;    int windowHeight = Console.WindowHeight;    int windowWidth = Console.WindowWidth;     Console.Write(strv);    Console.WriteLine(bufferHeight);    Console.Write(strv);    Console.WriteLine(bufferWidth);    Console.Write(strv);    Console.WriteLine(windowHeight);    Console.Write(strv);    Console.WriteLine(windowWidth);    Console.ReadLine();} 
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace RosettaTicTacToe{  class Program  {     /*================================================================
     *Pieces (players and board)
     *================================================================*/    static string[][] Players =  string[][] {        string[] { strv, strv }, // computer player       string[] { strv, strv }     // human player    };     const int Unplayed = -1;    const int Computer = 0;    const int Human = 1;     // GameBoard holds index into Players[] (0 or 1) or Unplayed (-1) if location not yet taken    static int[] GameBoard =  int[9];     static int[] corners =  int[] { 0, 2, 6, 8 };     static int[][] wins =  int[][] {        int[] { 0, 1, 2 },  int[] { 3, 4, 5 },  int[] { 6, 7, 8 },        int[] { 0, 3, 6 },  int[] { 1, 4, 7 },  int[] { 2, 5, 8 },        int[] { 0, 4, 8 },  int[] { 2, 4, 6 } };      /*================================================================
     *Main Game Loop (this is what runs/controls the game)
     *================================================================*/    static void Main(string[] args)    {      while (true)      {        Console.Clear();        Console.WriteLine(strv);        initializeGameBoard();        displayGameBoard();        int currentPlayer = rnd.Next(0, 2);  // current player represented by Players[] index of 0 or 1        Console.WriteLine(""The first move goes to {0} who is playing {1}s."", playerName(currentPlayer), playerToken(currentPlayer));        while (true)        {          int thisMove = getMoveFor(currentPlayer);          if (thisMove == Unplayed)          {            Console.WriteLine(strv, playerName(currentPlayer));            break;          }          playMove(thisMove, currentPlayer);          displayGameBoard();          if (isGameWon())          {            Console.WriteLine(strv, playerName(currentPlayer));            break;          }          else if (isGameTied())          {            Console.WriteLine(strv);            break;          }          currentPlayer = getNextPlayer(currentPlayer);        }        if (!playAgain())          return;      }    }     /*================================================================
     *Move Logic
     *================================================================*/    static int getMoveFor(int player)    {      if (player == Human)        return getManualMove(player);      else      {        //int selectedMove = getManualMove(player);        //int selectedMove = getRandomMove(player);        int selectedMove = getSemiRandomMove(player);        //int selectedMove = getBestMove(player);        Console.WriteLine(strv, playerName(player), selectedMove + 1);        return selectedMove;      }    }     static int getManualMove(int player)    {      while (true)      {        Console.Write(strv, playerName(player));        ConsoleKeyInfo keyInfo = Console.ReadKey();        Console.WriteLine();  // keep the display pretty        if (keyInfo.Key == ConsoleKey.Escape)          return Unplayed;        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)        {          int move = keyInfo.KeyChar - '1';  // convert to between 0..8, a GameBoard index position.          if (GameBoard[move] == Unplayed)            return move;          else            Console.WriteLine(strv, move + 1);        }        else          Console.WriteLine(""Illegal move, please select again."");      }    }     static int getRandomMove(int player)    {      int movesLeft = GameBoard.Count(position => position == Unplayed);      int x = rnd.Next(0, movesLeft);      for (int i = 0; i < GameBoard.Length; i++)  // walk board ...      {        if (GameBoard[i] == Unplayed && x < 0)    // until we reach the unplayed move.          return i;        x--;      }      return Unplayed;    }     // plays random if no winning move or needed block.    static int getSemiRandomMove(int player)    {      int posToPlay;      if (checkForWinningMove(player, out posToPlay))        return posToPlay;      if (checkForBlockingMove(player, out posToPlay))        return posToPlay;      return getRandomMove(player);    }     // purposely not implemented (this is the thinking part).    static int getBestMove(int player)    {      return -1;    }     static bool checkForWinningMove(int player, out int posToPlay)    {      posToPlay = Unplayed;      foreach (var line in wins)        if (twoOfThreeMatchPlayer(player, line, out posToPlay))          return true;      return false;    }     static bool checkForBlockingMove(int player, out int posToPlay)    {      posToPlay = Unplayed;      foreach (var line in wins)        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))          return true;      return false;    }     static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)    {      int cnt = 0;      posToPlay = int.MinValue;      foreach (int pos in line)      {        if (GameBoard[pos] == player)          cnt++;        else if (GameBoard[pos] == Unplayed)          posToPlay = pos;      }      return cnt == 2 && posToPlay >= 0;    }     static void playMove(int boardPosition, int player)    {      GameBoard[boardPosition] = player;    }     static bool isGameWon()    {      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));    }     static bool takenBySamePlayer(int a, int b, int c)    {      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];    }     static bool isGameTied()    {      return !GameBoard.Any(spot => spot == Unplayed);    }     /*================================================================
     *Misc Methods
     *================================================================*/    static Random rnd =  Random();     static void initializeGameBoard()    {      for (int i = 0; i < GameBoard.Length; i++)        GameBoard[i] = Unplayed;    }     static string playerName(int player)    {      return Players[player][0];    }     static string playerToken(int player)    {      return Players[player][1];    }     static int getNextPlayer(int player)    {      return (player + 1) % 2;    }     static void displayGameBoard()    {      Console.WriteLine(strv, pieceAt(0), pieceAt(1), pieceAt(2));      Console.WriteLine(strv);      Console.WriteLine(strv, pieceAt(3), pieceAt(4), pieceAt(5));      Console.WriteLine(strv);      Console.WriteLine(strv, pieceAt(6), pieceAt(7), pieceAt(8));      Console.WriteLine();    }     static string pieceAt(int boardPosition)    {      if (GameBoard[boardPosition] == Unplayed)        return (boardPosition + 1).ToString();  // display 1..9 on board rather than 0..8      return playerToken(GameBoard[boardPosition]);    }     private static bool playAgain()    {      Console.WriteLine(""Do you want to play again?"");      return Console.ReadKey(false).Key == ConsoleKey.Y;    }  } }"
class Program{    static void Main()    {        System.Console.WriteLine(strv);    }}
"static void Main(string[] args){    //There will be a 3 second pause between each cursor movement.    Console.Write(""     Cursor is here -->   "");    System..Thread.Sleep(3000);    Console.CursorLeft = Console.CursorLeft - 1; //Console.CursorLeft += -1 is an alternative.    System..Thread.Sleep(3000);    Console.CursorLeft = Console.CursorLeft + 1;    System..Thread.Sleep(3000);    Console.CursorTop = Console.CursorTop - 1;    System..Thread.Sleep(3000);    Console.CursorTop = Console.CursorTop + 1;    System..Thread.Sleep(3000);    Console.CursorLeft = 0; //Move the cursor far left.    System..Thread.Sleep(3000);    Console.CursorLeft = Console.BufferWidth - 1;    /* BufferWidth represents the number of characters wide the console area is.
        * The exact value may vary on different systems.
        * As the cursor position is a 0 based index we must subtract 1 from buffer width or we move the cursor out of bounds.
        * In some cases WindowWidth may be preferable (however in this demonstration window and buffer should be the same).
        */     System..Thread.Sleep(3000);    Console.SetCursorPosition(0,0); //I have used an alternative method for moving the cursor here which I feel is cleaner for the task at hand.    System..Thread.Sleep(3000);    Console.SetCursorPosition(Console.BufferWidth-1, Console.WindowHeight-1); //Buffer height is usually longer than the window so window has been used instead.    System..Thread.Sleep(3000);} "
 static void Main(string[] args){    Console.ForegroundColor = ConsoleColor.Red;    Console.BackgroundColor = ConsoleColor.Yellow;    Console.WriteLine(strv);    Console.ForegroundColor = ConsoleColor.White;    Console.BackgroundColor = ConsoleColor.Black;    Console.WriteLine(strv);    Console.ResetColor();    Console.WriteLine(strv);    Console.ReadKey();} 
"static void Main(string[] args){    Console.SetCursorPosition(3, 6);    Console.Write(strv);}"
System.Console.Clear();
"using System;using System.Collections.Generic; class Node{	public int LowLink { get; set; }	public int Index { get; set; }		public int N { get; } 	public Node(int n)	{		N = n;		Index = -1;		LowLink = 0;	}} class Graph{	public HashSet<Node> V { get; }	public Dictionary<Node, HashSet<Node>> Adj { get; } 	
	
	
	public void Tarjan()	{		var index = 0; // number of nodes		var S =  Stack<Node>(); 		Action<Node> StrongConnect = null;		StrongConnect = (v) =>		{			// Set the depth index for v to the smallest unused index			v.Index = index;			v.LowLink = index; 			index++;			S.Push(v); 			// Consider successors of v			foreach (var w in Adj[v])				if (w.Index < 0)				{					// Successor w has not yet been visited; recurse on it					StrongConnect(w);					v.LowLink = Math.Min(v.LowLink, w.LowLink);				}				else if (S.Contains(w))					// Successor w is in stack S and hence in the current SCC					v.LowLink = Math.Min(v.LowLink, w.Index); 			// If v is a root node, pop the stack and generate an SCC			if (v.LowLink == v.Index)			{				Console.Write(strv); 				Node w;				do				{					w = S.Pop();					Console.Write(w.N + strv);				} while (w != v); 				Console.WriteLine();			}		}; 		foreach (var v in V)			if (v.Index < 0)				StrongConnect(v);	}	}"
"using System; namespace TemperatureConversion{    class Program    {        static Func<double, double> ConvertKelvinToFahrenheit = x => (x * 1.8) - 459.67;        static Func<double, double> ConvertKelvinToRankine = x => x * 1.8;        static Func<double, double> ConvertKelvinToCelsius = x => x = 273.13;         static void Main(string[] args)        {            Console.Write(strv);            string inputVal = Console.ReadLine();            double kelvinTemp = 0f;             if (double.TryParse(inputVal, out kelvinTemp))            {                Console.WriteLine(string.Format(strv, kelvinTemp));                Console.WriteLine(string.Format(strv, ConvertKelvinToFahrenheit(kelvinTemp)));                Console.WriteLine(string.Format(strv, ConvertKelvinToRankine(kelvinTemp)));                Console.WriteLine(string.Format(strv, ConvertKelvinToCelsius(kelvinTemp)));                Console.ReadKey();            }            else            {                Console.WriteLine(strv + inputVal);            }        }    }}"
"using System;using System.IO;using System.Text; namespace RosettaCode{  internal class Program  {    private const string FileName = strv;     private static void Main(string[] args)    {      if (args.Length==0)      {        string txt = File.ReadAllText(FileName);        Console.WriteLine(txt);      }      else      {        var sb =  StringBuilder();        sb.Append(DateTime.Now).Append("""");        foreach (string s in args)          sb.Append(s).Append(strv);        sb.Append("""");         if (File.Exists(FileName))          File.AppendAllText(FileName, sb.ToString());        else          File.WriteAllText(FileName, sb.ToString());      }    }  }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace TaxicabNumber{    class Program    {        static void Main(string[] args)        {            IDictionary<long, IList<Tuple<int, int>>> taxicabNumbers = GetTaxicabNumbers(2006);            PrintTaxicabNumbers(taxicabNumbers);            Console.ReadKey();        }         private static IDictionary<long, IList<Tuple<int, int>>> GetTaxicabNumbers(int length)        {            SortedList<long, IList<Tuple<int, int>>> sumsOfTwoCubes =  SortedList<long, IList<Tuple<int, int>>>();             for (int i = 1; i < int.MaxValue; i++)            {                for (int j = 1; j < int.MaxValue; j++)                {                    long sum = (long)(Math.Pow((double)i, 3) + Math.Pow((double)j, 3));                     if (!sumsOfTwoCubes.ContainsKey(sum))                    {                        sumsOfTwoCubes.Add(sum,  List<Tuple<int, int>>());                    }                     sumsOfTwoCubes[sum].Add( Tuple<int, int>(i, j));                     if (j >= i)                    {                        break;                    }                }                 // Found that you need to keep going for a while after the length, because higher i values fill in gaps                if (sumsOfTwoCubes.Count(t => t.Value.Count >= 2) >= length * 1.1)                {                    break;                }            }             IDictionary<long, IList<Tuple<int, int>>> values = (from t in sumsOfTwoCubes where t.Value.Count >= 2 select t)                .Take(2006)                .ToDictionary(u => u.Key, u => u.Value);             return values;        }         private static void PrintTaxicabNumbers(IDictionary<long, IList<Tuple<int, int>>> values)        {            int i = 1;             foreach (long taxicabNumber in values.Keys)            {                StringBuilder output =  StringBuilder().AppendFormat(""{0,10}{1,4}"", i, taxicabNumber);                 foreach (Tuple<int, int> numbers in values[taxicabNumber])                {                    output.AppendFormat(""= {0}^3 + {1}^3"", numbers.Item1, numbers.Item2);                }                 if (i <= 25 || (i >= 2000 && i <= 2006))                {                    Console.WriteLine(output.ToString());                }                 i++;            }        }    }}"
Console.WriteLine(DateTime.Now);
"using System;using System.Threading.Tasks;using System.Collections.Concurrent;using System.IO; namespace SynchronousConcurrency{    class Program    {        static void Main(string[] args)        {            BlockingCollection<string> toWriterTask =  BlockingCollection<string>();            BlockingCollection<int> fromWriterTask =  BlockingCollection<int>();            Task writer = Task.Factory.StartNew(() => ConsoleWriter(toWriterTask, fromWriterTask));            Task reader = Task.Factory.StartNew(() => FileReader(fromWriterTask, toWriterTask));            Task.WaitAll(writer, reader);        }        static void ConsoleWriter(BlockingCollection<string> input, BlockingCollection<int> output)        {            int nLines = 0;            string line;            while ((line = input.Take()) != null)            {                Console.WriteLine(line);                ++nLines;            }            output.Add(nLines);        }        static void FileReader(BlockingCollection<int> input, BlockingCollection<string> output)        {            StreamReader file =  StreamReader(strv); // TODO: check exceptions            string line;            while ((line = file.ReadLine()) != null)            {                output.Add(line);             }            output.Add(null); // EOF            Console.WriteLine(strv + input.Take());        }    }}"
"using System;using System.Collections.Generic;using System.Linq; class Program{    static void Main(string[] args)    {        // All unique expressions that have a plus sign in front of the 1; calculated in parallel        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i =>  Expression(i, 1));        // All unique expressions that have a minus sign in front of the 1; calculated in parallel        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i =>  Expression(i, -1));        var expressions = expressionsPlus.Concat(expressionsMinus);        var results =  Dictionary<int, List<Expression>>();        foreach (var e in expressions)        {            if (results.Keys.Contains(e.Value))                results[e.Value].Add(e);            else                results[e.Value] =  List<Expression>() { e };        }        Console.WriteLine(strv);        foreach (Expression e in results[100])            Console.WriteLine(strv + e);        Console.WriteLine(strv);        var summary = results.Keys.Select(k =>  Tuple<int, int>(k, results[k].Count));        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);        Console.WriteLine(strv + maxSols.Item1 + strv + maxSols.Item2 + strv);        Console.WriteLine(strv);        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));        Console.WriteLine(strv + lowestPositive);        Console.WriteLine(strv);        var highest = from k in results.Keys                      orderby k descending                      select k;        foreach (var x in highest.Take(10))            Console.WriteLine(strv + x);    }}public enum Operations { Plus, Minus, Join };public class Expression{    protected Operations[] Gaps;    // 123456789 => there are 8 strv between each number    
    public int Value; // What this expression sums up to    protected int _one;     public Expression(int serial, int one)    {        _one = one;        Gaps =  Operations[8];        // This represents strv as a base 3 number, each Gap expression being a base-three digit        int divisor = 2187; // == Math.Pow(3,7)        int times;        for (int i = 0; i < 8; i++)        {            times = Math.DivRem(serial, divisor, out serial);            divisor /= 3;            if (times == 0)                Gaps[i] = Operations.Join;            else if (times == 1)                Gaps[i] = Operations.Minus;            else                Gaps[i] = Operations.Plus;        }        // go ahead and calculate the value of this expression        // because this is going to be done in a parallel thread (save time)        Value = Evaluate();    }    public override string ToString()    {        string ret = _one.ToString();        for (int i = 0; i < 8; i++)        {            switch (Gaps[i])            {                case Operations.Plus:                    ret += strv;                    break;                case Operations.Minus:                    ret += strv;                    break;            }            ret += (i + 2);        }        return ret;    }    private int Evaluate()        /* Calculate what this expression equals */    {        var numbers =  int[9];        int nc = 0;        var operations =  List<Operations>();        int a = 1;        for (int i = 0; i < 8; i++)        {            if (Gaps[i] == Operations.Join)                a = a * 10 + (i + 2);            else            {                if (a > 0)                {                    if (nc == 0)                        a *= _one;                    numbers[nc++] = a;                    a = i + 2;                }                operations.Add(Gaps[i]);            }        }        if (nc == 0)            a *= _one;        numbers[nc++] = a;        int ni = 0;        int left = numbers[ni++];        foreach (var operation in operations)        {            int right = numbers[ni++];            if (operation == Operations.Plus)                left = left + right;            else                left = left - right;        }        return left;    }}"
"class Program{    static void Main(string[] args)    {        // Create and fill a list of number 1 to 1000         List<double> myList =  List<double>();        for (double i = 1; i < 1001; i++)        {            myList.Add(i);        }        // Calculate the sum of 1/x^2         var sum = myList.Sum(x => 1/(x*x));         Console.WriteLine(sum);        Console.ReadLine();    }}class Program{    static void Main(string[] args)    {        double sum = Enumerable.Range(1, 1000).Sum(x => 1.0 / (x * x));         Console.WriteLine(sum);        Console.ReadLine();    }}"
"using System;using System.Collections.Generic;using System.Linq; class Program{    static int SumOfSquares(IEnumerable<int> list)    {        return list.Sum(x => x * x);    }    static void Main(string[] args)    {        Console.WriteLine(SumOfSquares( int[] { 4, 8, 15, 16, 23, 42 })); // 2854        Console.WriteLine(SumOfSquares( int[] { 1, 2, 3, 4, 5 })); // 55        Console.WriteLine(SumOfSquares( int[] { })); // 0    }}"
" using System;using System.Collections.Generic;using System.Numerics; namespace RosettaCode{    class Program    {        static void Main()        {            List<BigInteger> candidates =  List<BigInteger>( BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });            candidates.Add(BigInteger.Parse(strv));             foreach (BigInteger candidate in candidates)            {                BigInteger c = candidate - 1;                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);                 Console.WriteLine(strv, c, answer3 + answer5 - answer15);            }             Console.ReadKey(true);        }         private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)        {            BigInteger largest = candidate;            while (largest % n > 0)                largest--;            BigInteger totalCount = (largest / n);            BigInteger pairCount = totalCount / 2;            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);            BigInteger pairSum = largest + n;            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);        }     }} "
"using System;using System.Collections.Generic;using System.Linq; namespace RosettaCode.SymmetricDifference{    public static class IEnumerableExtension    {        public static IEnumerable<T> SymmetricDifference<T>(this IEnumerable<T> @this, IEnumerable<T> that)        {            return @this.Except(that).Concat(that.Except(@this));        }    }     class Program    {        static void Main()        {            var a = [] { strv, strv, strv, strv };            var b = [] { strv, strv, strv, strv };             foreach (var element in a.SymmetricDifference(b))            {                Console.WriteLine(element);            }        }    }}"
"using System;using System.Linq;using System.Collections.Generic; public class Program{    public static void Main()    {        const int maxSum = 100;        var pairs = (            from X in 2.To(maxSum / 2 - 1)            from Y in (X + 1).To(maxSum - 2).TakeWhile(y => X + y <= maxSum)            select  { X, Y, S = X + Y, P = X * Y }            ).ToHashSet();         Console.WriteLine(pairs.Count);         var uniqueP = pairs.GroupBy(pair => pair.P).Where(g => g.Count() == 1).Select(g => g.Key).ToHashSet();         pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Any(pair => uniqueP.Contains(pair.P))).SelectMany(g => g));        Console.WriteLine(pairs.Count);         pairs.ExceptWith(pairs.GroupBy(pair => pair.P).Where(g => g.Count() > 1).SelectMany(g => g));        Console.WriteLine(pairs.Count);         pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Count() > 1).SelectMany(g => g));        Console.WriteLine(pairs.Count);         foreach (var pair in pairs) Console.WriteLine(pair);    }} public static class Extensions{    public static IEnumerable<int> To(this int start, int end) {        for (int i = start; i <= end; i++) yield return i;    }     public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) =>  HashSet<T>(source);}"
"namespace RosettaCode.SumDigitsOfAnInteger{    using System;    using System.Collections.Generic;    using System.Linq;     internal static class Program    {        
        
        
        
        
        
        
        
        
        private static IEnumerable<int> Digits(this int number, int @base = 10)        {            while (number != 0)            {                int digit;                number = Math.DivRem(number, @base, out digit);                yield return digit;            }        }         
        
        
        
        
        
        private static int SumOfDigits(this int number, int @base = 10)        {            return number.Digits(@base).Sum();        }         
        
        
        private static void Main()        {            foreach (var example in                []                {                     {Number = 1, Base = 10},                     {Number = 12345, Base = 10},                     {Number = 123045, Base = 10},                     {Number = 0xfe, Base = 0x10},                     {Number = 0xf0e, Base = 0x10}                })            {                Console.WriteLine(example.Number.SumOfDigits(example.Base));            }        }    }}"
"int sum = 0, prod = 1;int[] arg = { 1, 2, 3, 4, 5 };foreach (int value in arg) {  sum += value;  prod *= value;}int[] arg = { 1, 2, 3, 4, 5 };int sum = arg.Sum();int prod = arg.Aggregate((runningProduct, nextFactor) => runningProduct * nextFactor);"
"using System;using System.IO;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace SubstitutionCipherProject{    class SubstitutionCipher    {        static void Main(string[] args)        {            doEncDec(""e:source.txt"", strv, true);            doEncDec(strv, strv, false);            Console.WriteLine(strv);            Console.ReadKey();        }        static void doEncDec(String source, String target, bool IsEncrypt)        {            ITransform trans;             if (IsEncrypt)                trans =  Encrypt();            else                trans =  Decrypt();             FileInfo sfi =  FileInfo(source);            FileStream sstream = sfi.OpenRead();            StreamReader sr =  StreamReader(sstream);             FileInfo tfi =  FileInfo(target);            FileStream tstream = tfi.OpenWrite();            TransformWriter tw =  TransformWriter(tstream, trans);            StreamWriter sw =  StreamWriter(tw);             String line;            while ((line = sr.ReadLine()) != null)                sw.WriteLine(line);            sw.Close();        }    }    public interface ITransform    {        byte transform(byte ch);    }    public class Encrypt : ITransform    {        const String str = strv;        byte ITransform.transform(byte ch)        {            if (char.IsLower((char)ch))                ch = (byte)str[ch - (byte)'a'];            return ch;        }    }    class Decrypt : ITransform    {        const String str = strv;        byte ITransform.transform(byte ch)        {            if (char.IsLower((char)ch))                ch = (byte)(str.IndexOf((char)ch) + 'a');            return ch;        }    }    class TransformWriter : Stream, IDisposable    {        private Stream outs;        private ITransform trans;         public TransformWriter(Stream s, ITransform t)        {            this.outs = s;            this.trans = t;        }         public override bool CanRead        {            get { return false; }        }         public override bool CanSeek        {            get { return false; }        }         public override bool CanWrite        {            get { return true; }        }        public override void Flush()        {            outs.Flush();        }         public override long Length        {            get { return outs.Length; }        }        public override long Position        {            get            {                return outs.Position;            }            set            {                outs.Position = value;            }        }        public override long Seek(long offset, SeekOrigin origin)        {            return outs.Seek(offset, origin);        }         public override void SetLength(long value)        {            outs.SetLength(value);        }         public override void Write(byte[] buf, int off, int len)        {            for (int i = off; i < off + len; i++)                buf[i] = trans.transform(buf[i]);            outs.Write(buf, off, len);        }         void IDisposable.Dispose()        {            outs.Dispose();        }         public override void Close()        {            outs.Close();        }         public override int Read(byte[] cbuf, int off, int count)        {            return outs.Read(cbuf, off, count);        }    }}"
 public class SubtractiveGenerator {    public static int MAX = 1000000000;    private int[] state;    private int pos;     private int mod(int n) {        return ((n % MAX) + MAX) % MAX;    }     public SubtractiveGenerator(int seed) {        state =  int[55];         int[] temp =  int[55];        temp[0] = mod(seed);        temp[1] = 1;        for(int i = 2; i < 55; ++i)            temp[i] = mod(temp[i - 2] - temp[i - 1]);         for(int i = 0; i < 55; ++i)            state[i] = temp[(34 * (i + 1)) % 55];         pos = 54;        for(int i = 55; i < 220; ++i)            next();    }     public int next() {        int temp = mod(state[(pos + 1) % 55] - state[(pos + 32) % 55]);        pos = (pos + 1) % 55;        state[pos] = temp;        return temp;    }     static void Main(string[] args) {        SubtractiveGenerator gen =  SubtractiveGenerator(292929);        for(int i = 220; i < 230; ++i)            Console.WriteLine(i.ToString() + strv + gen.next().ToString());    }} 
using System; public class TrimExample{    public static void Main(String[] args)    {        const string toTrim = strv;        Console.WriteLine(Wrap(toTrim.TrimStart()));        Console.WriteLine(Wrap(toTrim.TrimEnd()));        Console.WriteLine(Wrap(toTrim.Trim()));    }     private static string Wrap(string s)    {        return strv + s + strv;    }}
" using System.Text.RegularExpressions; string RemoveComments(string str, string delimiter)        {            //regular expression to find a character (delimiter) and             //      replace it and everything following it with an empty string.            //.Trim() will remove all beginning and ending white space.            return Regex.Replace(str, delimiter + strv, string.Empty).Trim();        } "
"using System;     class Program    {        private static string BlockCommentStrip(string commentStart, string commentEnd, string sampleText)        {            while (sampleText.IndexOf(commentStart) > -1 && sampleText.IndexOf(commentEnd, sampleText.IndexOf(commentStart) + commentStart.Length) > -1)            {                int start = sampleText.IndexOf(commentStart);                int end = sampleText.IndexOf(commentEnd, start + commentStart.Length);                sampleText = sampleText.Remove(                    start,                    (end + commentEnd.Length) - start                    );            }            return sampleText;        }    }"
" using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace RosettaCode{    class Program    {        static void Main(string[] args)        {            string test = strv;            Console.WriteLine(strv, test);            Console.WriteLine(strv, StripControlChars(test));            Console.WriteLine(strv, StripExtended(test));        }         static string StripControlChars(string arg)        {            char[] arrForm = arg.ToCharArray();            StringBuilder buffer =  StringBuilder(arg.Length);//This many chars at most             foreach(char ch in arrForm)                if (!Char.IsControl(ch)) buffer.Append(ch);//Only add to buffer if not a control char             return buffer.ToString();        }         static string StripExtended(string arg)        {            StringBuilder buffer =  StringBuilder(arg.Length); //Max length            foreach(char ch in arg)            {                UInt16 num = Convert.ToUInt16(ch);//In .NET, chars are UTF-16                //The basic characters have the same code points as ASCII, and the extended characters are bigger                if((num >= 32u) && (num <= 126u)) buffer.Append(ch);            }            return buffer.ToString();        }    }} "
"using System;namespace SubString{    class Program    {        static void Main(string[] args)        {            string s = strv;            const int n = 3;            const int m = 2;            const char c = '3';            const string z = strv;             Console.WriteLine(s.Substring(n, m));            Console.WriteLine(s.Substring(n, s.Length - n));            Console.WriteLine(s.Substring(0, s.Length - 1));            Console.WriteLine(s.Substring(s.IndexOf(c,0,s.Length), m));            Console.WriteLine(s.Substring(s.IndexOf(z, 0, s.Length), m));        }    }} "
"using System; class SudokuSolver{    private int[] grid;     public SudokuSolver(String s)    {        grid =  int[81];        for (int i = 0; i < s.Length; i++)        {            grid[i] = int.Parse(s[i].ToString());        }    }     public void solve()    {        try        {            placeNumber(0);            Console.WriteLine(strv);        }        catch (Exception ex)        {            Console.WriteLine(ex.Message);            Console.WriteLine(this);        }    }     public void placeNumber(int pos)    {        if (pos == 81)        {            throw  Exception(strv);        }        if (grid[pos] > 0)        {            placeNumber(pos + 1);            return;        }        for (int n = 1; n <= 9; n++)        {            if (checkValidity(n, pos % 9, pos / 9))            {                grid[pos] = n;                placeNumber(pos + 1);                grid[pos] = 0;            }        }    }     public bool checkValidity(int val, int x, int y)    {        for (int i = 0; i < 9; i++)        {            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)                return false;        }        int startX = (x / 3) * 3;        int startY = (y / 3) * 3;        for (int i = startY; i < startY + 3; i++)        {            for (int j = startX; j < startX + 3; j++)            {                if (grid[i * 9 + j] == val)                    return false;            }        }        return true;    }     public override string ToString()    {        string sb = strv;        for (int i = 0; i < 9; i++)        {            for (int j = 0; j < 9; j++)            {                sb += (grid[i * 9 + j] + strv);                if (j == 2 || j == 5)                    sb += (strv);            }            sb += ('');            if (i == 2 || i == 5)                sb += (""------+-------+------"");        }        return sb;    }     public static void Main(String[] args)    {         SudokuSolver(strv +                         strv +                         strv +                         strv +                         strv +                         strv +                         strv +                         strv +                         strv).solve();        Console.Read();    }}using Microsoft.SolverFoundation.Solvers; namespace Sudoku{    class Program    {        private static int[,] B =  int[,] {{9,7,0, 3,0,0, 0,6,0},                                              {0,6,0, 7,5,0, 0,0,0},                                              {0,0,0, 0,0,8, 0,5,0},                                               {0,0,0, 0,0,0, 6,7,0},                                              {0,0,0, 0,3,0, 0,0,0},                                              {0,5,3, 9,0,0, 2,0,0},                                               {7,0,0, 0,2,5, 0,0,0},                                              {0,0,2, 0,1,0, 0,0,8},                                              {0,4,0, 0,0,7, 3,0,0}};         private static CspTerm[] GetSlice(CspTerm[][] sudoku, int Ra, int Rb, int Ca, int Cb)        {            CspTerm[] slice =  CspTerm[9];            int i = 0;            for (int row = Ra; row < Rb + 1; row++)                for (int col = Ca; col < Cb + 1; col++)                {                    {                        slice[i++] = sudoku[row][col];                    }                }            return slice;        }         static void Main(string[] args)        {            ConstraintSystem S = ConstraintSystem.CreateSolver();            CspDomain Z = S.CreateIntegerInterval(1, 9);            CspTerm[][] sudoku = S.CreateVariableArray(Z, strv, 9, 9);            for (int row = 0; row < 9; row++)            {                for (int col = 0; col < 9; col++)                {                    if (B[row, col] > 0)                    {                        S.AddConstraints(S.Equal(B[row, col], sudoku[row][col]));                    }                }                S.AddConstraints(S.Unequal(GetSlice(sudoku, row, row, 0, 8)));            }            for (int col = 0; col < 9; col++)            {                S.AddConstraints(S.Unequal(GetSlice(sudoku, 0, 8, col, col)));            }            for (int a = 0; a < 3; a++)            {                for (int b = 0; b < 3; b++)                {                    S.AddConstraints(S.Unequal(GetSlice(sudoku, a * 3, a * 3 + 2, b * 3, b * 3 + 2)));                }            }            ConstraintSolverSolution soln = S.Solve();            object[] h =  object[9];            for (int row = 0; row < 9; row++)            {                if ((row % 3) == 0) System.Console.WriteLine();                for (int col = 0; col < 9; col++)                {                    soln.TryGetValue(sudoku[row][col], out h [col]);                }                System.Console.WriteLine(strv, h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8]);            }        }    }}"
using System; namespace PrependString{    class Program    {        static void Main(string[] args)        {            string str = strv;            str = strv + str;            Console.WriteLine(str);            Console.ReadKey();        }    }}
"using System; public static string RemoveCharactersFromString(string testString, string removeChars){    char[] charAry = removeChars.ToCharArray();    string returnString = testString;    foreach (char c in charAry)    {        while (returnString.IndexOf(c) > -1)        {            returnString = returnString.Remove(returnString.IndexOf(c), 1);        }    }    return returnString;}"
class Program{    static void Main()    {        string extra = strv;        string formatted = $strv;        System.Console.WriteLine(formatted);    }}
using System; class Program {    static void Main(string[] args) {        var s = strv;        Console.Write(s);        Console.WriteLine(strv);        var s2 = s + strv;        Console.WriteLine(s2);    }}
" class Program{	public static void Main (string[] args)	{		var value = strv.StartsWith(strv);		value = strv.EndsWith(strv); //returns false		value = strv.Contains(strv); //returns false		value = strv.Contains(strv); //returns true		int loc = strv.IndexOf(strv); //returns -1		loc = strv.IndexOf(strv); //returns 0		loc = strv.IndexOf(strv,loc+1); //returns 2	}} "
string s = strv;int characterLength = s.Length;using System.Text; string s = strv;int byteLength = Encoding.Unicode.GetByteCount(s);int utf8ByteLength = Encoding.UTF8.GetByteCount(s);
class Program{    static void Main(string[] args)    {        string x = strv;        x += strv;        System.Console.WriteLine(x);    }}
" class Program{    static void Main(string[] args)    {        string input;        Console.Write(strv);        input = Console.ReadLine();        stringCase(input);    }     private static void stringCase(string str)    {        char[] chars = str.ToCharArray();        string newStr = strv;         foreach (char i in chars)            if (char.IsLower(i))                newStr += char.ToUpper(i);            else                newStr += char.ToLower(i);        Console.WriteLine(strv, newStr);    }}System.Console.WriteLine(System..CultureInfo.CurrentCulture.TextInfo.ToTitleCase(strv));"
"using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; class Program{    static void Main()    {        const string data =        strv +        strv +        strv +        strv +        strv +        strv +        strv;         int[] ints = data.Split(' ').Select(int.Parse).ToArray();         StemAndLeafPlot(ints);         Console.ReadKey();    }     public static void StemAndLeafPlot(int[] arr)    {        int stemMax = arr.Max() / 10;        int stemMin = arr.Min() / 10;        Array.Sort(arr);         for (int i = stemMin; i <= stemMax; i++)        {            Console.Write(strv, i);            foreach (var t in arr)            {                if (t < 10 * i)                    continue;                if (t >= 10 * (i + 1))                    break;                Console.Write(strv, t % 10);            }            Console.WriteLine(strv);        }    }}"
void step_up() {    while (!step()) step_up();}
"using System;using MathNet.Numerics.Distributions;using MathNet.Numerics.Statistics; class Program{    static void RunNormal(int sampleSize)    {        double[] X =  double[sampleSize];        var norm =  Normal( Random());        norm.Samples(X);         const int numBuckets = 10;        var histogram =  Histogram(X, numBuckets);        Console.WriteLine(strv, sampleSize);        for (int i = 0; i < numBuckets; i++)        {            string bar =  String('#', (int)(histogram[i].Count * 360 / sampleSize));            Console.WriteLine(strv, histogram[i].LowerBound, bar);        }        var statistics =  DescriptiveStatistics(X);        Console.WriteLine(strv + statistics.Mean);        Console.WriteLine(strv + statistics.StandardDeviation);        Console.WriteLine();    }    static void Main(string[] args)    {        RunNormal(100);        RunNormal(1000);        RunNormal(10000);    }}"
using System;using System.Diagnostics; class Program{    static void Inner()    {        Console.WriteLine( StackTrace());    }     static void Middle()    {        Inner();    }     static void Outer()    {        Middle();    }     static void Main()    {        Outer();    }}
"using System;using MathNet.Numerics.Statistics; class Program{    static void Run(int sampleSize)    {        double[] X =  double[sampleSize];        var r =  Random();        for (int i = 0; i < sampleSize; i++)            X[i] = r.NextDouble();         const int numBuckets = 10;        var histogram =  Histogram(X, numBuckets);        Console.WriteLine(strv, sampleSize);        for (int i = 0; i < numBuckets; i++)        {            string bar =  String('#', (int)(histogram[i].Count * 360 / sampleSize));            Console.WriteLine(strv, histogram[i].LowerBound, bar);        }        var statistics =  DescriptiveStatistics(X);        Console.WriteLine(strv + statistics.Mean);        Console.WriteLine(strv + statistics.StandardDeviation);        Console.WriteLine();    }    static void Main(string[] args)    {        Run(100);        Run(1000);        Run(10000);    }}"
using SpeechLib; namespace Speaking_Computer{  public class Program  {    private static void Main()    {      var voice =  SpVoice();      voice.Speak(strv);    }  }}
// Non-Generic StackSystem..Stack stack =  System..Stack();stack.Push( obj );bool isEmpty = stack.Count == 0;object top = stack.Peek(); // Peek without Popping.top = stack.Pop(); // Generic StackSystem..Generic.Stack<Foo> stack =  System..Generic.Stack<Foo>();stack.Push( Foo());bool isEmpty = stack.Count == 0;Foo top = stack.Peek(); // Peek without Popping.top = stack.Pop();
"public int[,] Spiral(int n) {    int[,] result =  int[n, n];     int pos = 0;    int count = n;    int value = -n;    int sum = -1;     do {        value = -1 * value / n;        for (int i = 0; i < count; i++) {            sum += value;            result[sum / n, sum % n] = pos++;        }        value *= n;        count--;        for (int i = 0; i < count; i++) {            sum += value;            result[sum / n, sum % n] = pos++;        }    } while (count > 0);     return result;}  // Method to print arrays, pads numbers so they line up in columnspublic void PrintArray(int[,] array) {    int n = (array.GetLength(0) * array.GetLength(1) - 1).ToString().Length + 1;     for (int i = 0; i < array.GetLength(0); i++) {        for (int j = 0; j < array.GetLength(1); j++) {            Console.Write(array[i, j].ToString().PadLeft(n, ' '));        }        Console.WriteLine();    }} using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks; namespace spiralmat{    class spiral    {        public static int lev;        int lev_lim, count, bk, cd, low, l, m;        spiral()        {            lev = lev_lim = count = bk = cd = low = l = m = 0;        }         void level(int n1, int r, int c)        {            lev_lim = n1 % 2 == 0 ? n1 / 2 : (n1 + 1) / 2;            if ((r <= lev_lim) && (c <= lev_lim))                lev = Math.Min(r, c);            else            {                bk = r > c ? (n1 + 1) - r : (n1 + 1) - c;                low = Math.Min(r, c);                if (low <= lev_lim)                    cd = low;                lev = cd < bk ? cd : bk;            }        }         int func(int n2, int xo, int lo)        {            l = xo;            m = lo;            count = 0;            level(n2, l, m);             for (int ak = 1; ak < lev; ak++)                count += 4 * (n2 - 1 - 2 * (ak - 1));            return count;        }         public static void Main(string[] args)        {            spiral ob =  spiral();            Console.WriteLine(strv);            int n = int.Parse(Console.ReadLine());            Console.WriteLine(""The Matrix of {0} x {1} Order is=>"", n, n);            for (int i = 1; i <= n; i++)            {                for (int j = 1; j <= n; j++)                    Console.Write(strv,		                  ob.func(n, i, j)				  + Convert.ToInt32(				    ((j >= i) && (i == lev)) 				      ? ((j - i) + 1) 				      : ((j == ((n + 1) - lev) && (i > lev) && (i <= j)))				        ? (n - 2 * (lev - 1) + (i - 1) - (n - j))					: ((i == ((n + 1) - lev) && (j < i)))					  ? ((n - 2 * (lev - 1)) + ((n - 2 * (lev - 1)) - 1) + (i - j))					  : ((j == lev) && (i > lev) && (i < ((n + 1) - lev)))					    ? ((n - 2 * (lev - 1)) + ((n - 2 * (lev - 1)) - 1) + ((n - 2 * (lev - 1)) - 1) + (((n + 1) - lev) - i))					    : 0));                Console.WriteLine();            }            Console.ReadKey();        }    }} "
"using System;using System.Collections.Generic;using System.Linq;using System.Threading; class Program{    static void ThreadStart(object item)    {        Thread.Sleep(1000 * (int)item);        Console.WriteLine(item);    }     static void SleepSort(IEnumerable<int> items)    {        foreach (var item in items)        {             Thread(ThreadStart).Start(item);        }    }     static void Main(string[] arguments)    {        SleepSort(arguments.Select(int.Parse));    }}var input = [] { 1, 9, 2, 1, 3 }; foreach (var n in input)	Task.Run(() =>	{		Thread.Sleep(n * 1000);		Console.WriteLine(n);	}); "
"using System;using System.Collections.Generic; namespace StableMarriage{    class Person    {        private int _candidateIndex;        public string Name { get; set; }        public List<Person> Prefs { get; set; }        public Person Fiance { get; set; }         public Person(string name) {            Name = name;            Prefs = null;            Fiance = null;            _candidateIndex = 0;        }        public bool Prefers(Person p) {            return Prefs.FindIndex(o => o == p) < Prefs.FindIndex(o => o == Fiance);        }        public Person NextCandidateNotYetProposedTo() {            if (_candidateIndex >= Prefs.Count) return null;            return Prefs[_candidateIndex++];        }        public void EngageTo(Person p) {            if (p.Fiance != null) p.Fiance.Fiance = null;            p.Fiance = this;            if (Fiance != null) Fiance.Fiance = null;            Fiance = p;        }    }     static class MainClass    {        static public bool IsStable(List<Person> men) {            List<Person> women = men[0].Prefs;            foreach (Person guy in men) {                foreach (Person gal in women) {                    if (guy.Prefers(gal) && gal.Prefers(guy))                        return false;                }            }            return true;        }         static void DoMarriage() {            Person abe  =  Person(strv);            Person bob  =  Person(strv);            Person col  =  Person(strv);            Person dan  =  Person(strv);            Person ed   =  Person(strv);            Person fred =  Person(strv);            Person gav  =  Person(strv);            Person hal  =  Person(strv);            Person ian  =  Person(strv);            Person jon  =  Person(strv);            Person abi  =  Person(strv);            Person bea  =  Person(strv);            Person cath =  Person(strv);            Person dee  =  Person(strv);            Person eve  =  Person(strv);            Person fay  =  Person(strv);            Person gay  =  Person(strv);            Person hope =  Person(strv);            Person ivy  =  Person(strv);            Person jan  =  Person(strv);             abe.Prefs  =  List<Person>() {abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay};            bob.Prefs  =  List<Person>() {cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay};            col.Prefs  =  List<Person>() {hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan};            dan.Prefs  =  List<Person>() {ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi};            ed.Prefs   =  List<Person>() {jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay};            fred.Prefs =  List<Person>() {bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay};            gav.Prefs  =  List<Person>() {gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay};            hal.Prefs  =  List<Person>() {abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee};            ian.Prefs  =  List<Person>() {hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve};            jon.Prefs  =  List<Person>() {abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope};            abi.Prefs  =  List<Person>() {bob, fred, jon, gav, ian, abe, dan, ed, col, hal};            bea.Prefs  =  List<Person>() {bob, abe, col, fred, gav, dan, ian, ed, jon, hal};            cath.Prefs =  List<Person>() {fred, bob, ed, gav, hal, col, ian, abe, dan, jon};            dee.Prefs  =  List<Person>() {fred, jon, col, abe, ian, hal, gav, dan, bob, ed};            eve.Prefs  =  List<Person>() {jon, hal, fred, dan, abe, gav, col, ed, ian, bob};            fay.Prefs  =  List<Person>() {bob, abe, ed, ian, jon, dan, fred, gav, col, hal};            gay.Prefs  =  List<Person>() {jon, gav, hal, fred, bob, abe, col, ed, dan, ian};            hope.Prefs =  List<Person>() {gav, jon, bob, abe, ian, dan, hal, ed, col, fred};            ivy.Prefs  =  List<Person>() {ian, col, hal, gav, fred, bob, abe, ed, jon, dan};            jan.Prefs  =  List<Person>() {ed, hal, gav, abe, bob, jon, col, ian, fred, dan};             List<Person> men =  List<Person>(abi.Prefs);             int freeMenCount = men.Count;            while (freeMenCount > 0) {                foreach (Person guy in men) {                    if (guy.Fiance == null) {                        Person gal = guy.NextCandidateNotYetProposedTo();                        if (gal.Fiance == null) {                            guy.EngageTo(gal);                            freeMenCount--;                        } else if (gal.Prefers(guy)) {                            guy.EngageTo(gal);                        }                    }                }            }             foreach (Person guy in men) {                Console.WriteLine(strv, guy.Name, guy.Fiance.Name);            }            Console.WriteLine(strv, IsStable(men));             Console.WriteLine(""Switching fred & jon's partners"");            Person jonsFiance = jon.Fiance;            Person fredsFiance = fred.Fiance;            fred.EngageTo(jonsFiance);            jon.EngageTo(fredsFiance);            Console.WriteLine(strv, IsStable(men));        }         public static void Main(string[] args)        {            DoMarriage();        }    }}"
"using System; namespace RadixSort{    class Program    {        static void Sort(int[] old)        {            int i, j;            int[] tmp =  int[old.Length];            for (int shift = 31; shift > -1; --shift)            {                j = 0;                for (i = 0; i < old.Length; ++i)                {                    bool move = (old[i] << shift) >= 0;                    if (shift == 0 ? !move : move)  // shift the 0's to old's head                        old[i-j] = old[i];                    else                            // move the 1's to tmp                        tmp[j++] = old[i];                }                Array.Copy(tmp, 0, old, old.Length-j, j);            }        }        static void Main(string[] args)        {            int[] old =  int[] { 2, 5, 1, -3, 4 };            Console.WriteLine(string.Join(strv, old));            Sort(old);            Console.WriteLine(string.Join(strv, old));            Console.Read();        }    }}"
"class SelectionSort<T> where T : IComparable {    public T[] Sort(T[] list) {        int k;        T temp;         for (int i = 0; i < list.Length; i++) {            k = i;            for (int j=i + 1; j < list.Length; j++) {                if (list[j].CompareTo(list[k]) < 0) {                    k = j;                }            }            temp = list[i];            list[i] = list[k];            list[k] = temp;        }         return list;    }}String[] str = { strv, strv, strv, strv, strv, strv, strv, strv }; SelectionSort<String> mySort =  SelectionSort<string>(); String[] result = mySort.Sort(str); for (int i = 0; i < result.Length; i++) {    Console.WriteLine(result[i]);}"
"namespace Sort {  using System;   public class MergeSort<T> where T : IComparable {    #region Constants    private const Int32 mergesDefault = 6;    private const Int32 insertionLimitDefault = 12;    #endregion     #region Properties    protected Int32[] Positions { get; set; }     private Int32 merges;    public Int32 Merges {      get { return merges; }      set {        // A minimum of 2 merges are required        if (value > 1)          merges = value;        else          throw  ArgumentOutOfRangeException();         if (Positions == null || Positions.Length != merges)          Positions =  Int32[merges];      }    }     public Int32 InsertionLimit { get; set; }    #endregion     #region Constructors    public MergeSort(Int32 merges, Int32 insertionLimit) {      Merges = merges;      InsertionLimit = insertionLimit;    }     public MergeSort()      : this(mergesDefault, insertionLimitDefault) {    }    #endregion     #region Sort Methods    public void Sort(T[] entries) {      // Allocate merge buffer      var entries2 =  T[entries.Length];      Sort(entries, entries2, 0, entries.Length - 1);    }     // Top-Down K-way Merge Sort    public void Sort(T[] entries1, T[] entries2, Int32 first, Int32 last) {      var length = last + 1 - first;      if (length < 2)        return;      else if (length < InsertionLimit) {        InsertionSort<T>.Sort(entries1, first, last);        return;      }       var left = first;      var size = ceiling(length, Merges);      for (var remaining = length; remaining > 0; remaining -= size, left += size) {        var right = left + Math.Min(remaining, size) - 1;        Sort(entries1, entries2, left, right);      }       Merge(entries1, entries2, first, last);      Array.Copy(entries2, first, entries1, first, length);    }    #endregion     #region Merge Methods    public void Merge(T[] entries1, T[] entries2, Int32 first, Int32 last) {      Array.Clear(Positions, 0, Merges);      // This implementation has a quadratic time dependency on the number of merges      for (var index = first; index <= last; index++)        entries2[index] = remove(entries1, first, last);    }     private T remove(T[] entries, Int32 first, Int32 last) {      var entry = default(T);      var found = (Int32?)null;      var length = last + 1 - first;       var index = 0;      var left = first;      var size = ceiling(length, Merges);      for (var remaining = length; remaining > 0; remaining -= size, left += size, index++) {        var position = Positions[index];        if (position < Math.Min(remaining, size)) {          var next = entries[left + position];          if (!found.HasValue || entry.CompareTo(next) > 0) {            found = index;            entry = next;          }        }      }       // Remove entry      Positions[found.Value]++;      return entry;    }    #endregion     #region Math Methods    private static Int32 ceiling(Int32 numerator, Int32 denominator) {      return (numerator + denominator - 1) / denominator;    }    #endregion  }  #region Insertion Sort  static class InsertionSort<T> where T : IComparable {    public static void Sort(T[] entries, Int32 first, Int32 last) {      for (var i = first + 1; i <= last; i++) {        var entry = entries[i];        var j = i;        while (j > first && entries[j - 1].CompareTo(entry) > 0)          entries[j] = entries[--j];        entries[j] = entry;      }    }  }  #endregion}  using Sort;  using System;   class Program {    static void Main(String[] args) {      var entries =  Int32[] { 7, 5, 2, 6, 1, 4, 2, 6, 3 };      var sorter =  MergeSort<Int32>();      sorter.Sort(entries);      Console.WriteLine(String.Join(strv, entries));    }  }"
public static void gnomeSort(ref int[] a){    int i = 1;    int j = 2;     while (i < a.Length)    {        if (a[i - 1] <= a[i])        {            i = j;            j++;        }        else        {            int tmp = a[i - 1];            a[i - 1] = a[i];            a[i] = tmp;            i -= 1;            if (i == 0)            {                i = 1;                j = 2;            }        }    }}
"namespace Sort {  using System;   static class InsertionSort<T> where T : IComparable {    public static void Sort(T[] entries) {      Sort(entries, 0, entries.Length - 1);    }     public static void Sort(T[] entries, Int32 first, Int32 last) {      for (var i = first + 1; i <= last; i++) {        var entry = entries[i];        var j = i;         while (j > first && entries[j - 1].CompareTo(entry) > 0)          entries[j] = entries[--j];         entries[j] = entry;      }    }  }}  using Sort;  using System;   class Program {    static void Main(String[] args) {      var entries =  Int32[] { 3, 9, 4, 6, 8, 1, 7, 2, 5 };      InsertionSort<Int32>.Sort(entries);      Console.WriteLine(String.Join(strv, entries));    }  }"
"//// The Tripartite conditional enables Bentley-McIlroy 3-way Partitioning.// This performs additional compares to isolate islands of keys equal to// the pivot value.  Use unless key-equivalent classes are of small size.//#define Tripartite namespace Sort {  using System;   class QuickSort<T> where T : IComparable {    #region Constants    private const Int32 insertionLimitDefault = 12;    #endregion     #region Properties    public Int32 InsertionLimit { get; set; }    protected Random Random { get; set; }    #endregion     #region Constructors    public QuickSort(Int32 insertionLimit, Random random) {      InsertionLimit = insertionLimit;      Random = random;    }     public QuickSort(Int32 insertionLimit)      : this(insertionLimit,  Random()) {    }     public QuickSort()      : this(insertionLimitDefault) {    }    #endregion     #region Sort Methods    public void Sort(T[] entries) {      Sort(entries, 0, entries.Length - 1);    }     public void Sort(T[] entries, Int32 first, Int32 last) {      var length = last + 1 - first;      while (length > 1) {        if (length < InsertionLimit) {          InsertionSort<T>.Sort(entries, first, last);          return;        }         var median = pivot(entries, first, last);         var left = first;        var right = last;        partition(entries, median, ref left, ref right);         var leftLength = right + 1 - first;        var rightLength = last + 1 - left;         //        // First recurse over shorter partition, then loop        // on the longer partition to elide tail recursion.        //        if (leftLength < rightLength) {          Sort(entries, first, right);          first = left;          length = rightLength;        }        else {          Sort(entries, left, last);          last = right;          length = leftLength;        }      }    }     private T pivot(T[] entries, Int32 first, Int32 last) {      var length = last + 1 - first;      var logLen = (Int32)Math.Log10(length);      var pivotSamples = 2 * logLen + 1;      var sampleSize = Math.Min(pivotSamples, length);      var right = first + sampleSize - 1;      for (var left = first; left <= right; left++) {        // Random sampling avoids pathological cases        var random = Random.Next(left, last + 1);        // Sample without replacement        Swap(entries, left, random);      }       InsertionSort<T>.Sort(entries, first, right);      var median = entries[first + sampleSize / 2];      return median;    }     private static void partition(T[] entries, T median, ref Int32 left, ref Int32 right) {      var first = left;      var last = right;#if Tripartite      var leftMedian = first;      var rightMedian = last;#endif      while (true) {        //[Assert]There exists some index >= left where entries[index] >= median        //[Assert]There exists some index <= right where entries[index] <= median        // So, there is no need for left or right bound checks        while (median.CompareTo(entries[left]) > 0) left++;        while (median.CompareTo(entries[right]) < 0) right--;         //[Assert]entries[right] <= median <= entries[left]        if (right <= left) break;         Swap(entries, left, right);#if Tripartite        swapOut(entries, median, left, right, ref leftMedian, ref rightMedian);#endif        left++;        right--;        //[Assert]entries[first:left - 1] <= median <= entries[right + 1:last]      }       if (left == right) {        left++;        right--;      }      //[Assert]right < left#if Tripartite      swapIn(entries, ref left, ref right, leftMedian, rightMedian, first, last);#endif      //[Assert]entries[first:right] <= median <= entries[left:last]      //[Assert]entries[right + 1:left - 1] == median when non-empty    }     private static void swapOut(T[] entries, T median, Int32 left, Int32 right,                                ref Int32 leftMedian, ref Int32 rightMedian) {      if (median.CompareTo(entries[left]) == 0) Swap(entries, leftMedian++, left);      if (median.CompareTo(entries[right]) == 0) Swap(entries, right, rightMedian--);    }     private static void swapIn(T[] entries, ref Int32 left, ref Int32 right,                               Int32 leftMedian, Int32 rightMedian, Int32 first, Int32 last) {      // Restore median entries      for (var prefix = first; prefix < leftMedian;)        Swap(entries, prefix++, right--);      for (var suffix = last; rightMedian < suffix;)        Swap(entries, left++, suffix--);    }     public static void Swap(T[] entries, Int32 index1, Int32 index2) {      if (index1 != index2) {        var entry = entries[index1];        entries[index1] = entries[index2];        entries[index2] = entry;      }    }  }  #endregion   #region Insertion Sort  static class InsertionSort<T> where T : IComparable {    public static void Sort(T[] entries, Int32 first, Int32 last) {      for (var i = first + 1; i <= last; i++) {        var entry = entries[i];        var j = i;        while (j > first && entries[j - 1].CompareTo(entry) > 0)          entries[j] = entries[--j];        entries[j] = entry;      }    }  }  #endregion}  using Sort;  using System;   class Program {    static void Main(String[] args) {      var entries =  Int32[] { 1, 3, 5, 7, 9, 8, 6, 4, 2 };      var sorter =  QuickSort<Int32>();      sorter.Sort(entries);      Console.WriteLine(String.Join(strv, entries));    }  }using System;using System.Collections.Generic;using System.Linq; namespace QSort{    class QSorter    {        private static IEnumerable<IComparable> empty =  List<IComparable>();         public static IEnumerable<IComparable> QSort(IEnumerable<IComparable> iEnumerable)        {            if(iEnumerable.Any())            {                var pivot = iEnumerable.First();                return QSort(iEnumerable.Where((anItem) => pivot.CompareTo(anItem) > 0)).                    Concat(iEnumerable.Where((anItem) => pivot.CompareTo(anItem) == 0)).                    Concat(QSort(iEnumerable.Where((anItem) => pivot.CompareTo(anItem) < 0)));            }            return empty;        }    }}"
"using System;using System.Linq; namespace CountingSort{    class Program    {        static void Main(string[] args)        {            Random rand =  Random();                                   // Just for creating a test array            int[] arr =  int[100];                                     // of random numbers            for (int i = 0; i < 100; i++) { arr[i] = rand.Next(0, 100); } // ...             int[] newarr = countingSort(arr, arr.Min(), arr.Max());        }         private static int[] countingSort(int[] arr, int min, int max)        {            int[] count =  int[max - min + 1];            int z = 0;             for (int i = 0; i < count.Length; i++) { count[i] = 0; }            for (int i = 0; i < arr.Length; i++) { count[arr[i] - min]++; }                        for (int i = min; i <= max; i++)            {                while (count[i - min]-- > 0)                {                    arr[z] = i;                    z++;                                    }            }            return arr;        }    }}"
"using System; namespace CombSort{    class Program    {        static void Main(string[] args)        {            int[] unsorted =  int[] { 3, 5, 1, 9, 7, 6, 8, 2, 4 };            Console.WriteLine(string.Join(strv, combSort(unsorted)));        }        public static int[] combSort(int[] input)        {            double gap = input.Length;            bool swaps = true;            while (gap > 1 || swaps)            {                gap /= 1.247330950103979;                if (gap < 1) { gap = 1; }                int i = 0;                swaps = false;                while (i + gap < input.Length)                {                    int igap = i + (int)gap;                    if (input[i] > input[igap])                    {                        int swap = input[i];                        input[i] = input[igap];                        input[igap] = swap;                        swaps = true;                    }                    i++;                }            }            return input;        }    }}"
"using System;using System.Collections.Generic;using System.Text; public class HeapSortClass{    public static void HeapSort<T>(T[] array)    {        HeapSort<T>(array, 0, array.Length, Comparer<T>.Default);    }     public static void HeapSort<T>(T[] array, int offset, int length, IComparer<T> comparer)    {        HeapSort<T>(array, offset, length, comparer.Compare);    }     public static void HeapSort<T>(T[] array, int offset, int length, Comparison<T> comparison)    {        // build binary heap from all items        for (int i = 0; i < length; i++)        {            int index = i;            T item = array[offset + i]; // use next item             // and move it on top, if greater than parent            while (index > 0 &&                comparison(array[offset + (index - 1) / 2], item) < 0)            {                int top = (index - 1) / 2;                array[offset + index] = array[offset + top];                index = top;            }            array[offset + index] = item;        }         for (int i = length - 1; i > 0; i--)        {            // delete max and place it as last            T last = array[offset + i];            array[offset + i] = array[offset];             int index = 0;            // the last one positioned in the heap            while (index * 2 + 1 < i)            {                int left = index * 2 + 1, right = left + 1;                 if (right < i && comparison(array[offset + left], array[offset + right]) < 0)                {                    if (comparison(last, array[offset + right]) > 0) break;                     array[offset + index] = array[offset + right];                    index = right;                }                else                {                    if (comparison(last, array[offset + left]) > 0) break;                     array[offset + index] = array[offset + left];                    index = left;                }            }            array[offset + index] = last;        }    }     static void Main()    {        // usage        byte[] r = {5, 4, 1, 2};        HeapSort(r);         string[] s = { strv, strv, strv, strv };        HeapSort(s, 0, s.Length, StringComparer.CurrentCultureIgnoreCase);    }}"
"using System;using System.Collections.Generic; namespace RosettaCode.BubbleSort{    public static class BubbleSortMethods    {        //The strv keyword before the method parameter identifies this as a C# extension        //method, which can be called using instance method syntax on any generic list,        //without having to modify the generic List<T> code provided by the .NET framework.        public static void BubbleSort<T>(this List<T> list) where T : IComparable        {            bool madeChanges;            int itemCount = list.Count;            do            {                madeChanges = false;                itemCount--;                for (int i = 0; i < itemCount; i++)                {                    if (list[i].CompareTo(list[i + 1]) > 0)                    {                        T temp = list[i + 1];                        list[i + 1] = list[i];                        list[i] = temp;                        madeChanges = true;                    }                }            } while (madeChanges);        }    }     //A short test program to demonstrate the BubbleSort. The compiler will change the    //call to testList.BubbleSort() into one to BubbleSortMethods.BubbleSort<T>(testList).    class Program    {        static void Main()        {            List<int> testList =  List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };            testList.BubbleSort();            foreach (var t in testList) Console.Write(t + strv);        }    }}"
"public static void cocktailSort(int[] A)    {        bool swapped;        do        {            swapped = false;            for (int i = 0; i <= A.Length - 2; i++)            {                if (A[i] > A[i + 1])                {                    //test whether the two elements are in the wrong order                    int temp = A[i];                    A[i] = A[i + 1];                    A[i + 1] = temp;                    swapped = true;                }            }            if (!swapped)            {                //we can exit the outer loop here if no swaps occurred.                break;            }            swapped = false;            for (int i = A.Length - 2; i >= 0; i--)            {                if (A[i] > A[i + 1])                {                    int temp = A[i];                    A[i] = A[i + 1];                    A[i + 1] = temp;                    swapped = true;                }            }            //if no elements have been swapped, then the list is sorted        } while (swapped);    }"
"using System;using System.Collections.Generic; namespace RosettaCode.BogoSort{    public static class BogoSorter    {        public static void Sort<T>(List<T> list) where T:IComparable        {            while (!list.isSorted())            {                list.Shuffle();            }        }         private static bool isSorted<T>(this IList<T> list) where T:IComparable        {            if(list.Count<=1)                return true;            for (int i = 1 ; i < list.Count; i++)                if(list[i].CompareTo(list[i-1])<0) return false;            return true;        }         private static void Shuffle<T>(this IList<T> list)        {            Random rand =  Random();            for (int i = 0; i < list.Count; i++)            {                int swapIndex = rand.Next(list.Count);                T temp = list[swapIndex];                list[swapIndex] = list[i];                list[i] = temp;            }        }    }     class TestProgram    {        static void Main()        {            List<int> testList =  List<int> { 3, 4, 1, 8, 7, 4, -2 };            BogoSorter.Sort(testList);            foreach (int i in testList) Console.Write(i + strv);        }     }}"
"using System;using System.Collections.Generic; namespace RosettaCode {    class SortCustomComparator {        // Driver program        public void CustomSort() {            String[] items = { strv, strv, strv, strv, strv, strv, strv, strv };            List<String> list =  List<string>(items);             DisplayList(strv, list);             list.Sort(CustomCompare);            DisplayList(strv, list);             list.Sort();            DisplayList(strv, list);        }         // Custom compare        public int CustomCompare(String x, String y) {            int result = -x.Length.CompareTo(y.Length);            if (result == 0) {                result = x.ToLower().CompareTo(y.ToLower());            }             return result;        }         // Output routine        public void DisplayList(String header, List<String> theList) {            Console.WriteLine(header);            Console.WriteLine(strv.PadLeft(header.Length, '*'));            foreach (String str in theList) {                Console.WriteLine(str);            }            Console.WriteLine();        }    }}using System;using System.Collections.Generic;using System.Linq; namespace RosettaCode{	class SortCustomComparator	{		// Driver program		public void CustomSort()		{			List<string> list =  List<string> { strv, strv, strv, strv, strv, strv, strv, strv }; 			DisplayList(strv, list); 			var descOrdered = from l in list					  orderby l.Length descending 					  select l;			DisplayList(strv, descOrdered); 			var ascOrdered = from l in list					 orderby l					 select l;			DisplayList(strv, ascOrdered);		} 		// Output routine		public void DisplayList(String header, IEnumerable<string> theList)		{			Console.WriteLine(header);			Console.WriteLine(strv.PadLeft(header.Length, '*'));			foreach (String str in theList)			{				Console.WriteLine(str);			}			Console.WriteLine();		}	}} "
"using System;using System.Linq;using System.Collections.Generic; public class Test{    public static void Main()    {        var list =  List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };        list.SortSublist(6, 1, 7);        Console.WriteLine(string.Join(strv, list));    }} public static class Extensions{    public static void SortSublist<T>(this List<T> list, params int[] indices)        where T : IComparable<T>    {        var sublist = indices.OrderBy(i => i)            .Zip(indices.Select(i => list[i]).OrderBy(v => v),                (Index, Value) =>  { Index, Value });         foreach (var entry in sublist) {            list[entry.Index] = entry.Value;        }    } }"
"using System;using System.Collections.Generic; public class Program {    static void Main() {        int[] unsorted = { 6, 2, 7, 8, 3, 1, 10, 5, 4, 9 };        Array.Sort(unsorted);    }}"
"using System;using System.IO;using System.Net.Sockets; class Program {    static void Main(string[] args) {        TcpClient tcp =  TcpClient(strv, 256);        StreamWriter writer =  StreamWriter(tcp.GetStream());         writer.Write(strv);        writer.Flush();         tcp.Close();    }}using System.Text;using System.Net.Sockets; namespace SocketClient{    class Program    {        static void Main(string[] args)        {            var sock =  Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);            sock.Connect(strv, 1000);            sock.Send(Encoding.ASCII.GetBytes(strv));            sock.Close();        }    }}"
"using System;using System.Collections.Generic;using System.Linq; class Program{            struct Entry    {        public Entry(string name, double value) { Name = name; Value = value; }        public string Name;        public double Value;    }     static void Main(string[] args)    {        var Elements =  List<Entry>        {             Entry(strv, 83.798),  Entry(strv, 9.012182),  Entry(strv, 28.0855),             Entry(strv, 58.933195),  Entry(strv, 78.96),  Entry(strv, 72.64)        };         var sortedElements = Elements.OrderBy(e => e.Name);         foreach (Entry e in sortedElements)            Console.WriteLine(strv, e.Name, e.Value);    }}"
"static void InsertAfter(Link prev, int i){    prev.next =  Link() { item = i, next = prev.next };}static void Main(){    //Create A(5)->B(7)    var A =  Link() { item = 5 };    InsertAfter(A, 7);    //Insert C between A and B    InsertAfter(A, 15);}"
using System;using System.Threading; class Program{    static void Main(string[] args)    {        int sleep = Convert.ToInt32(Console.ReadLine());        Console.WriteLine(strv);        Thread.Sleep(sleep); //milliseconds        Console.WriteLine(strv);    }}
//current is the first Link in the listwhile(current != null){     System.Console.WriteLine(current.item);    current = current.next;}
"class Link{    public int Item { get; set; }    public Link Next { get; set; }     //A constructor is not neccessary, but could be useful    public Link(int item, Link next = null) {        Item = item;        Next = next;    }}"
"public sealed class Singleton1 //Lazy: Yes ||| Thread-safe: Yes ||| Uses locking: Yes{    private static Singleton1 instance;    private static readonly object lockObj =  object();     public static Singleton1 Instance {        get {            lock(lockObj) {                if (instance == null) {                    instance =  Singleton1();                }            }            return instance;        }    }}public sealed class Singleton2 //Lazy: Yes ||| Thread-safe: Yes ||| Uses locking: Yes, but only once{    private static Singleton2 instance;    private static readonly object lockObj =  object();     public static Singleton2 Instance {        get {            if (instance == null) {                lock(lockObj) {                    if (instance == null) {                        instance =  Singleton2();                    }                }            }            return instance;        }    }}public sealed class Singleton3 //Lazy: Yes, but not completely ||| Thread-safe: Yes ||| Uses locking: No{    private static Singleton3 Instance { get; } =  Singleton3();     static Singleton3() { }}public sealed class Singleton4 //Lazy: Yes ||| Thread-safe: Yes ||| Uses locking: No{    public static Singleton4 Instance => SingletonHolder.instance;     private class SingletonHolder    {        static SingletonHolder() { }         internal static readonly Singleton4 instance =  Singleton4();    }}public sealed class Singleton5 //Lazy: Yes ||| Thread-safe: Yes ||| Uses locking: No{    private static readonly Lazy<Singleton5> lazy =  Lazy<Singleton5>(() =>  Singleton5());     public static Singleton5 Instance => lazy.Value;}"
using System.Windows.Forms; class RosettaForm : Form{    RosettaForm()    {        var clickCount = 0;         var label =  Label();        label.Text = strv;        label.Dock = DockStyle.Top;        Controls.Add(label);         var button =  Button();        button.Text = strv;        button.Dock = DockStyle.Bottom;        button.Click += delegate                        {                            clickCount++;                            label.Text = strv + clickCount + strv;                        };        Controls.Add(button);    }     static void Main()    {        Application.Run( RosettaForm());    }} 
using System; class Program{    static void Main()    {        Console.WriteLine( DateTime());    }}
"using System;using System.Collections; namespace RosettaCode {    class SierpinskiTriangle {        int len;        BitArray b;         public SierpinskiTriangle(int n) {            if (n < 1) {                throw  ArgumentOutOfRangeException(strv);            }            len = 1 << (n+1);            b =  BitArray(len+1, false);            b[len>>1] = true;        }         public void Display() {            for (int j = 0; j < len / 2; j++) {                for (int i = 0; i < b.Count; i++) {                    Console.Write(strv, b[i] ? strv : strv);                }                Console.WriteLine();                NextGen();            }        }         private void NextGen() {            BitArray next =  BitArray(b.Count, false);            for (int i = 0; i < b.Count; i++) {                if (b[i]) {                    next[i - 1] = next[i - 1] ^ true;                    next[i + 1] = next[i + 1] ^ true;                }            }            b = next;        }    }}namespace RosettaCode {    class Program {        static void Main(string[] args) {            SierpinskiTriangle t =  SierpinskiTriangle(4);            t.Display();        }    }}using static System.Console;class Sierpinsky{    static void Main(string[] args)    {        int order;        if(!int.TryParse(args.Length > 0 ? args[0] : strv, out order)) order = 4;        int size = (1 << order);        for (int y = size - 1; y >= 0; y--, WriteLine())        {            for (int i = 0; i < y; i++) Write(' ');            for (int x = 0; x + y < size; x++)                Write((x & y) != 0 ? strv : strv);        }    }}using System;using System.Collections.Generic;using System.Linq; class Program{    public static List<String> Sierpinski(int n)    {        var lines =  List<string> { strv };        string space = strv;         for (int i = 0; i < n; i++)        {            lines = lines.Select(x => space + x + space)                         .Concat(lines.Select(x => x + strv + x)).ToList();            space += space;        }         return lines;    }     static void Main(string[] args)    {        foreach (string s in Sierpinski(4))            Console.WriteLine(s);    }}using System;using System.Collections.Generic;using System.Linq; class Program{    static List<string> Sierpinski(int n)    {	return Enumerable.Range(0, n).Aggregate(	    List<string>(){strv},	     (p, i) => {		string SPACE = strv.PadRight((int)Math.Pow(2, i)); 		var temp =   List<string>(from x in p select SPACE + x + SPACE);		temp.AddRange(from x in p select x + strv + x); 		return temp;	     }	);    }     static void Main ()    {	foreach(string s in Sierpinski(4)) { Console.WriteLine(s); }    }}"
"using System; class Program{    static bool a(bool value)    {        Console.WriteLine(strv);        return value;    }     static bool b(bool value)    {        Console.WriteLine(strv);        return value;    }     static void Main()    {        foreach (var i in [] { false, true })        {            foreach (var j in [] { false, true })            {                Console.WriteLine(strv, i, j, a(i) && b(j));                Console.WriteLine();                Console.WriteLine(strv, i, j, a(i) || b(j));                Console.WriteLine();            }        }    }}"
"using System;using System.Collections.Generic;using System.Linq; class Program{    static List<string> NextCarpet(List<string> carpet)    {        return carpet.Select(x => x + x + x)                     .Concat(carpet.Select(x => x + x.Replace('#', ' ') + x))                     .Concat(carpet.Select(x => x + x + x)).ToList();    }     static List<string> SierpinskiCarpet(int n)    {        return Enumerable.Range(1, n).Aggregate( List<string> { strv }, (carpet, _) => NextCarpet(carpet));    }     static void Main(string[] args)    {        foreach (string s in SierpinskiCarpet(3))            Console.WriteLine(s);    }}"
"using System;using System.Security.Cryptography;using System.Text;using Microsoft.VisualStudio.TestTools.UnitTesting; namespace RosettaCode.SHA256{    [TestClass]    public class SHA256ManagedTest    {        [TestMethod]        public void TestComputeHash()        {            var buffer = Encoding.UTF8.GetBytes(strv);            var hashAlgorithm =  SHA256Managed();            var hash = hashAlgorithm.ComputeHash(buffer);            Assert.AreEqual(                strv,                BitConverter.ToString(hash));        }    }}"
"using System;using System.Collections;using System.Collections.Generic; namespace SieveOfEratosthenes{    class Program    {        static void Main(string[] args)        {            int maxprime = int.Parse(args[0]);            var primelist = GetAllPrimesLessThan(maxprime);            foreach (int prime in primelist)            {                Console.WriteLine(prime);            }            Console.WriteLine(strv + primelist.Count);            Console.ReadLine();        }         private static List<int> GetAllPrimesLessThan(int maxPrime)        {            var primes =  List<int>();            var maxSquareRoot = (int)Math.Sqrt(maxPrime);            var eliminated =  BitArray(maxPrime + 1);             for (int i = 2; i <= maxPrime; ++i)            {                if (!eliminated[i])                {                    primes.Add(i);                    if (i <= maxSquareRoot)                    {                        for (int j = i * i; j <= maxPrime; j += i)                        {                            eliminated[j] = true;                        }                    }                }            }            return primes;        }    }}using System;using System.Collections;using System.Collections.Generic;using System.Linq;using PrimeT = System.UInt32;  class PrimesBird : IEnumerable<PrimeT> {    private struct CIS<T> {      public T v; public Func<CIS<T>> cont;      public CIS(T v, Func<CIS<T>> cont) {        this.v = v; this.cont = cont;      }    }    private CIS<PrimeT> pmlts(PrimeT p) {      Func<PrimeT, CIS<PrimeT>> fn = null;      fn = (c) =>  CIS<PrimeT>(c, () => fn(c + p));      return fn(p * p);    }    private CIS<CIS<PrimeT>> allmlts(CIS<PrimeT> ps) {      return  CIS<CIS<PrimeT>>(pmlts(ps.v), () => allmlts(ps.cont())); }    private CIS<PrimeT> merge(CIS<PrimeT> xs, CIS<PrimeT> ys) {      var x = xs.v; var y = ys.v;      if (x < y) return  CIS<PrimeT>(x, () => merge(xs.cont(), ys));      else if (y < x) return  CIS<PrimeT>(y, () => merge(xs, ys.cont()));      else return  CIS<PrimeT>(x, () => merge(xs.cont(), ys.cont()));    }    private CIS<PrimeT> cmpsts(CIS<CIS<PrimeT>> css) {      return  CIS<PrimeT>(css.v.v, () => merge(css.v.cont(), cmpsts(css.cont()))); }    private CIS<PrimeT> minusat(PrimeT n, CIS<PrimeT> cs) {      var nn = n; var ncs = cs;      for (; ; ++nn) {        if (nn >= ncs.v) ncs = ncs.cont();        else return  CIS<PrimeT>(nn, () => minusat(++nn, ncs));      }    }    private CIS<PrimeT> prms() {      return  CIS<PrimeT>(2, () => minusat(3, cmpsts(allmlts(prms())))); }    public IEnumerator<PrimeT> GetEnumerator() {      for (var ps = prms(); ; ps = ps.cont()) yield return ps.v;    }    IEnumerator IEnumerable.GetEnumerator() { return (IEnumerator)GetEnumerator(); }  }using System;using System.Collections;using System.Collections.Generic;using System.Linq;using PrimeT = System.UInt32;  class PrimesTreeFold : IEnumerable<PrimeT> {    private struct CIS<T> {      public T v; public Func<CIS<T>> cont;      public CIS(T v, Func<CIS<T>> cont) {        this.v = v; this.cont = cont;      }    }    private CIS<PrimeT> pmlts(PrimeT p) {      var adv = p + p;      Func<PrimeT, CIS<PrimeT>> fn = null;      fn = (c) =>  CIS<PrimeT>(c, () => fn(c + adv));      return fn(p * p);    }    private CIS<CIS<PrimeT>> allmlts(CIS<PrimeT> ps) {      return  CIS<CIS<PrimeT>>(pmlts(ps.v), () => allmlts(ps.cont()));    }    private CIS<PrimeT> merge(CIS<PrimeT> xs, CIS<PrimeT> ys) {      var x = xs.v; var y = ys.v;      if (x < y) return  CIS<PrimeT>(x, () => merge(xs.cont(), ys));      else if (y < x) return  CIS<PrimeT>(y, () => merge(xs, ys.cont()));      else return  CIS<PrimeT>(x, () => merge(xs.cont(), ys.cont()));    }    private CIS<CIS<PrimeT>> pairs(CIS<CIS<PrimeT>> css) {      var nxtcss = css.cont();      return  CIS<CIS<PrimeT>>(merge(css.v, nxtcss.v), () => pairs(nxtcss.cont())); }    private CIS<PrimeT> cmpsts(CIS<CIS<PrimeT>> css) {      return  CIS<PrimeT>(css.v.v, () => merge(css.v.cont(), cmpsts(pairs(css.cont()))));    }    private CIS<PrimeT> minusat(PrimeT n, CIS<PrimeT> cs) {      var nn = n; var ncs = cs;      for (; ; nn += 2) {        if (nn >= ncs.v) ncs = ncs.cont();        else return  CIS<PrimeT>(nn, () => minusat(nn + 2, ncs));      }    }    private CIS<PrimeT> oddprms() {      return  CIS<PrimeT>(3, () => minusat(5, cmpsts(allmlts(oddprms()))));    }    public IEnumerator<PrimeT> GetEnumerator() {      yield return 2;      for (var ps = oddprms(); ; ps = ps.cont()) yield return ps.v;    }    IEnumerator IEnumerable.GetEnumerator() { return (IEnumerator)GetEnumerator(); }  }namespace PriorityQ {  using KeyT = System.UInt32;  using System;  using System.Collections.Generic;  using System.Linq;  class Tuple<K, V> { // for DotNet 3.5 without Tuple's    public K Item1; public V Item2;    public Tuple(K k, V v) { Item1 = k; Item2 = v; }    public override string ToString() {      return strv + Item1.ToString() + strv + Item2.ToString() + strv;    }  }  class MinHeapPQ<V> {    private struct HeapEntry {      public KeyT k; public V v;      public HeapEntry(KeyT k, V v) { this.k = k; this.v = v; }    }    private List<HeapEntry> pq;    private MinHeapPQ() { this.pq =  List<HeapEntry>(); }    private bool mt { get { return pq.Count == 0; } }    private Tuple<KeyT, V> pkmn {      get {        if (pq.Count == 0) return null;        else {          var mn = pq[0];          return  Tuple<KeyT, V>(mn.k, mn.v);        }      }    }    private void psh(KeyT k, V v) { // add extra very high item if none      if (pq.Count == 0) pq.Add( HeapEntry(UInt32.MaxValue, v));      var i = pq.Count; pq.Add(pq[i - 1]); // copy bottom item...      for (var ni = i >> 1; ni > 0; i >>= 1, ni >>= 1) {        var t = pq[ni - 1];        if (t.k > k) pq[i - 1] = t; else break;      }      pq[i - 1] =  HeapEntry(k, v);    }    private void siftdown(KeyT k, V v, int ndx) {      var cnt = pq.Count - 1; var i = ndx;      for (var ni = i + i + 1; ni < cnt; ni = ni + ni + 1) {        var oi = i; var lk = pq[ni].k; var rk = pq[ni + 1].k;        var nk = k;        if (k > lk) { i = ni; nk = lk; }        if (nk > rk) { ni += 1; i = ni; }        if (i != oi) pq[oi] = pq[i]; else break;      }      pq[i] =  HeapEntry(k, v);    }    private void rplcmin(KeyT k, V v) {      if (pq.Count > 1) siftdown(k, v, 0); }    public static MinHeapPQ<V> empty { get { return  MinHeapPQ<V>(); } }    public static Tuple<KeyT, V> peekMin(MinHeapPQ<V> pq) { return pq.pkmn; }    public static MinHeapPQ<V> push(KeyT k, V v, MinHeapPQ<V> pq) {      pq.psh(k, v); return pq; }    public static MinHeapPQ<V> replaceMin(KeyT k, V v, MinHeapPQ<V> pq) {      pq.rplcmin(k, v); return pq; }}using System;using System.Collections;using System.Collections.Generic;using System.Linq;using PrimeT = System.UInt32;  class PrimesPQ : IEnumerable<PrimeT> {    private IEnumerator<PrimeT> nmrtr() {      MinHeapPQ<PrimeT> pq = MinHeapPQ<PrimeT>.empty;      PrimeT bp = 3; PrimeT q = 9;      IEnumerator<PrimeT> bps = null;      yield return 2; yield return 3;      for (var n = (PrimeT)5; ; n += 2) {        if (n >= q) { // always equal or less...          if (q <= 9) {            bps = nmrtr();            bps.MoveNext(); bps.MoveNext(); } // move to 3...          bps.MoveNext(); var nbp = bps.Current; q = nbp * nbp;          var adv = bp + bp; bp = nbp;          pq = MinHeapPQ<PrimeT>.push(n + adv, adv, pq);        }        else {          var pk = MinHeapPQ<PrimeT>.peekMin(pq);          var ck = (pk == null) ? q : pk.Item1;          if (n >= ck) {            do { var adv = pk.Item2;                  pq = MinHeapPQ<PrimeT>.replaceMin(ck + adv, adv, pq);                  pk = MinHeapPQ<PrimeT>.peekMin(pq); ck = pk.Item1;            } while (n >= ck);          }          else yield return n;        }      }    }    public IEnumerator<PrimeT> GetEnumerator() { return nmrtr(); }    IEnumerator IEnumerable.GetEnumerator() { return (IEnumerator)GetEnumerator(); }  }using System;using System.Collections;using System.Collections.Generic;using System.Linq;using PrimeT = System.UInt32;  class PrimesDict : IEnumerable<PrimeT> {    private IEnumerator<PrimeT> nmrtr() {      Dictionary<PrimeT, PrimeT> dct =  Dictionary<PrimeT, PrimeT>();      PrimeT bp = 3; PrimeT q = 9;      IEnumerator<PrimeT> bps = null;      yield return 2; yield return 3;      for (var n = (PrimeT)5; ; n += 2) {        if (n >= q) { // always equal or less...          if (q <= 9) {            bps = nmrtr();            bps.MoveNext(); bps.MoveNext();          } // move to 3...          bps.MoveNext(); var nbp = bps.Current; q = nbp * nbp;          var adv = bp + bp; bp = nbp;          dct.Add(n + adv, adv);        }        else {          if (dct.ContainsKey(n)) {            PrimeT nadv; dct.TryGetValue(n, out nadv); dct.Remove(n); var nc = n + nadv;            while (dct.ContainsKey(nc)) nc += nadv;            dct.Add(nc, nadv);          }          else yield return n;        }      }    }    public IEnumerator<PrimeT> GetEnumerator() { return nmrtr(); }    IEnumerator IEnumerable.GetEnumerator() { return (IEnumerator)GetEnumerator(); }  }using System;using System.Collections;using System.Collections.Generic;using System.Linq;using PrimeT = System.UInt32;  class PrimesPgd : IEnumerable<PrimeT> {    private const int PGSZ = 1 << 14; // L1 CPU cache size in bytes    private const int BFBTS = PGSZ * 8; // in bits    private const int BFRNG = BFBTS * 2;    public IEnumerator<PrimeT> nmrtr() {      IEnumerator<PrimeT> bps = null;      List<uint> bpa =  List<uint>();      uint[] cbuf =  uint[PGSZ / 4]; // 4 byte words      yield return 2;      for (var lowi = (PrimeT)0; ; lowi += BFBTS) {        for (var bi = 0; ; ++bi) {          if (bi < 1) {            if (bi < 0) { bi = 0; yield return 2; }            PrimeT nxt = 3 + lowi + lowi + BFRNG;            if (lowi <= 0) { // cull very first page              for (int i = 0, p = 3, sqr = 9; sqr < nxt; i++, p += 2, sqr = p * p)                if ((cbuf[i >> 5] & (1 << (i & 31))) == 0)                  for (int j = (sqr - 3) >> 1; j < BFBTS; j += p)                    cbuf[j >> 5] |= 1u << j;            }            else { // cull for the rest of the pages              Array.Clear(cbuf, 0, cbuf.Length);              if (bpa.Count == 0) { // inite secondar base primes stream                bps = nmrtr(); bps.MoveNext(); bps.MoveNext();                bpa.Add((uint)bps.Current); bps.MoveNext();              } // add 3 to base primes array              // make sure bpa contains enough base primes...              for (PrimeT p = bpa[bpa.Count - 1], sqr = p * p; sqr < nxt; ) {                p = bps.Current; bps.MoveNext(); sqr = p * p; bpa.Add((uint)p);              }              for (int i = 0, lmt = bpa.Count - 1; i < lmt; i++) {                var p = (PrimeT)bpa[i]; var s = (p * p - 3) >> 1;                // adjust start index based on page lower limit...                if (s >= lowi) s -= lowi;                else {                  var r = (lowi - s) % p;                  s = (r != 0) ? p - r : 0;                }                for (var j = (uint)s; j < BFBTS; j += p)                  cbuf[j >> 5] |= 1u << ((int)j);              }            }          }          while (bi < BFBTS && (cbuf[bi >> 5] & (1 << (bi & 31))) != 0) ++bi;          if (bi < BFBTS) yield return 3 + (((PrimeT)bi + lowi) << 1);          else break; // outer loop for next page segment...        }      }    }    public IEnumerator<PrimeT> GetEnumerator() { return nmrtr(); }    IEnumerator IEnumerable.GetEnumerator() { return (IEnumerator)GetEnumerator(); }  }    static void Main(string[] args) {      Console.WriteLine(PrimesXXX().ElementAt(1000000 - 1)); // zero based indexing...    }"
 using System; public class SevenSidedDice{    Random random =  Random();         static void Main(string[] args)		{			SevenSidedDice sevenDice =  SevenSidedDice();			Console.WriteLine(strv+ sevenDice.seven());            Console.Read();		} 		int seven()		{			int v=21;			while(v>20)				v=five()+five()*5-6;			return 1+v%7;		} 		int five()		{        return 1 + random.Next(5);		}}
"using System;using System.Security.Cryptography;using System.Text;using Microsoft.VisualStudio.TestTools.UnitTesting; namespace RosettaCode.SHA1{    [TestClass]    public class SHA1CryptoServiceProviderTest    {        [TestMethod]        public void TestComputeHash()        {            var input =  UTF8Encoding().GetBytes(strv);            var output =  SHA1CryptoServiceProvider().ComputeHash(input);            Assert.AreEqual(                strv,                BitConverter.ToString(output));        }    }}"
"using System;using System.Linq;using System.Collections.Generic; public class SetConsolidation{    public static void Main()    {        var setCollection1 = [] {[] {strv, strv}, [] {strv, strv}};        var setCollection2 = [] {[] {strv, strv}, [] {strv, strv}};        var setCollection3 = [] {[] {strv, strv}, [] {strv, strv}, [] {strv, strv}};        var setCollection4 = [] {[] {strv, strv, strv}, [] {strv, strv}, [] {strv, strv},            [] {strv, strv}, [] {strv, strv, strv}};        var input = [] {setCollection1, setCollection2, setCollection3, setCollection4};         foreach (var sets in input) {            Console.WriteLine(strv);            Console.WriteLine(string.Join(strv, sets.Select(s => strv + string.Join(strv, s) + strv)));            Console.WriteLine(strv);            Console.WriteLine(string.Join(strv, ConsolidateSets1(sets).Select(s => strv + string.Join(strv, s) + strv)));            Console.WriteLine(strv);            Console.WriteLine(string.Join(strv, ConsolidateSets2(sets).Select(s => strv + string.Join(strv, s) + strv)));            Console.WriteLine();        }    }     
    
    
    
    private static IEnumerable<IEnumerable<T>> ConsolidateSets1<T>(IEnumerable<IEnumerable<T>> sets,        IEqualityComparer<T> comparer = null)    {        if (comparer == null) comparer = EqualityComparer<T>.Default;        var elements =  Dictionary<T, Node<T>>();        foreach (var set in sets) {            Node<T> top = null;            foreach (T value in set) {                Node<T> element;                if (elements.TryGetValue(value, out element)) {                    if (top != null) {                        var newTop = element.FindTop();                        top.Parent = newTop;                        element.Parent = newTop;                        top = newTop;                    } else {                        top = element.FindTop();                    }                } else {                    elements.Add(value, element =  Node<T>(value));                    if (top == null) top = element;                    else element.Parent = top;                }            }        }        foreach (var g in elements.Values.GroupBy(element => element.FindTop().Value))            yield return g.Select(e => e.Value);    }     private class Node<T>    {        public Node(T value, Node<T> parent = null) {            Value = value;            Parent = parent ?? this;        }         public T Value { get; }        public Node<T> Parent { get; set; }         public Node<T> FindTop() {            var top = this;            while (top != top.Parent) top = top.Parent;            //Set all parents to the top element to prevent repeated iteration in the future            var element = this;            while (element.Parent != top) {                var parent = element.Parent;                element.Parent = top;                element = parent;            }            return top;        }    }     
    
    
    
    private static IEnumerable<IEnumerable<T>> ConsolidateSets2<T>(IEnumerable<IEnumerable<T>> sets,        IEqualityComparer<T> comparer = null)    {        if (comparer == null) comparer = EqualityComparer<T>.Default;        var currentSets = sets.Select(s =>  HashSet<T>(s)).ToList();        int previousSize;        do {            previousSize = currentSets.Count;            for (int i = 0; i < currentSets.Count - 1; i++) {                for (int j = currentSets.Count - 1; j > i; j--) {                    if (currentSets[i].Overlaps(currentSets[j])) {                        currentSets[i].UnionWith(currentSets[j]);                        currentSets.RemoveAt(j);                    }                }            }        } while (previousSize > currentSets.Count);        foreach (var set in currentSets) yield return set.Select(value => value);    }}"
"using System;using System.Diagnostics; namespace sons{    class Program    {        static void Main(string[] args)        {            for (int i = 1; i < 23; i++)                            Console.WriteLine(nonsqr(i));                         for (int i = 1; i < 1000000; i++)            {                double j = Math.Sqrt(nonsqr(i));                Debug.Assert(j != Math.Floor(j),strv);            }                    }         static int nonsqr(int i)        {            return (int)(i + Math.Floor(0.5 + Math.Sqrt(i)));        }    }}"
"using System; class Example{    public int foo(int x)    {        return 42 + x;    }} class Program{    static void Main(string[] args)    {        var example =  Example();        var method = strv;         var result = (int)example.GetType().GetMethod(method).Invoke(example,  object[]{ 5 });        Console.WriteLine(strv, method, result);    }} "
" static void Main(string[] args){    //First of all construct the SMTP client     SmtpClient SMTP =  SmtpClient(strv, 587); //I have provided the URI and port for GMail, replace with your providers SMTP details    SMTP.EnableSsl = true; //Required for gmail, may not for your provider, if your provider does not require it then use false.    SMTP.DeliveryMethod = SmtpDeliveryMethod.Network;    SMTP.Credentials =  NetworkCredential(strv, strv);    MailMessage Mail =  MailMessage("""", """");      //Then we construct the message     Mail.Subject = strv;    Mail.Body = strv; //The body contains the string for your email    //using strv you can put an HTML page in your message body     //Then we use the SMTP client to send the message     SMTP.Send(Mail);     Console.WriteLine(strv);} "
using System;using System.IO; Console.WriteLine(Path.GetTempFileName());
"using System;using System.Collections.Generic;using System.Linq;using System.Text; class Program{    static void PrintCollection(IEnumerable<int> x)    {        Console.WriteLine(string.Join(strv, x));    }    static void Main(string[] args)    {        Console.OutputEncoding = Encoding.UTF8;        Console.WriteLine(strv);        var A =  HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };        var B =  HashSet<int> { 2, 5, 8, 11, 12, 13, 17, 18, 20 };         PrintCollection(A);        PrintCollection(B);         Console.WriteLine(""Test m ∈ S -- m is an element in set S"");        Console.WriteLine(strv, A.Contains(14));        Console.WriteLine(strv, A.Contains(15));         Console.WriteLine(strv);        var aUb = A.Union(B);        PrintCollection(aUb);         Console.WriteLine(strv);        var aDb = A.Except(B);        PrintCollection(aDb);         Console.WriteLine(strv);        Console.WriteLine(A.IsSubsetOf(B));        var C =  HashSet<int> { 14, 17, 18 };        Console.WriteLine(C.IsSubsetOf(A));         Console.WriteLine(strv);        Console.WriteLine(A.SetEquals(B));        var D =  HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };        Console.WriteLine(A.SetEquals(D));         Console.WriteLine(strv);        Console.WriteLine(A.IsProperSubsetOf(B));        Console.WriteLine(C.IsProperSubsetOf(A));         Console.WriteLine(strv);        A.Add(10);        B.Remove(12);        PrintCollection(A);        PrintCollection(B);         Console.ReadKey();    }}"
using System; namespace RosettaCode.SetOfRealNumbers{    public class Set<TValue>    {        public Set(Predicate<TValue> contains)        {            Contains = contains;        }         public Predicate<TValue> Contains        {            get;            private set;        }         public Set<TValue> Union(Set<TValue> set)        {            return  Set<TValue>(value => Contains(value) || set.Contains(value));        }         public Set<TValue> Intersection(Set<TValue> set)        {            return  Set<TValue>(value => Contains(value) && set.Contains(value));        }         public Set<TValue> Difference(Set<TValue> set)        {            return  Set<TValue>(value => Contains(value) && !set.Contains(value));        }    }}using Microsoft.VisualStudio.TestTools.UnitTesting;using RosettaCode.SetOfRealNumbers; namespace RosettaCode.SetOfRealNumbersTest{    [TestClass]    public class SetTest    {        [TestMethod]        public void TestUnion()        {            var set =                 Set<double>(value => 0d < value && value <= 1d).Union(                     Set<double>(value => 0d <= value && value < 2d));            Assert.IsTrue(set.Contains(0d));            Assert.IsTrue(set.Contains(1d));            Assert.IsFalse(set.Contains(2d));        }         [TestMethod]        public void TestIntersection()        {            var set =                 Set<double>(value => 0d <= value && value < 2d).Intersection(                     Set<double>(value => 1d < value && value <= 2d));            Assert.IsFalse(set.Contains(0d));            Assert.IsFalse(set.Contains(1d));            Assert.IsFalse(set.Contains(2d));        }         [TestMethod]        public void TestDifference()        {            var set =                 Set<double>(value => 0d <= value && value < 3d).Difference(                     Set<double>(value => 0d < value && value < 1d));            Assert.IsTrue(set.Contains(0d));            Assert.IsTrue(set.Contains(1d));            Assert.IsTrue(set.Contains(2d));             set =                 Set<double>(value => 0d <= value && value < 3d).Difference(                     Set<double>(value => 0d <= value && value <= 1d));            Assert.IsFalse(set.Contains(0d));            Assert.IsFalse(set.Contains(1d));            Assert.IsTrue(set.Contains(2d));        }    }}
"using System;using System.Net;using System.Collections.Generic;using System.Linq;using System.IO; public class Semordnilap{    public static void Main() {        var results = FindSemordnilaps(strv).ToList();        Console.WriteLine(results.Count);        var random =  Random();        Console.WriteLine(strv);        foreach (string s in results.OrderBy(_ => random.Next()).Distinct().Take(5)) Console.WriteLine(s + strv + Reversed(s));    }     private static IEnumerable<string> FindSemordnilaps(string url) {        var found =  HashSet<string>();        foreach (string line in GetLines(url)) {            string reversed = Reversed(line);            //Not taking advantage of the fact the input file is sorted            if (line.CompareTo(reversed) != 0) {                if (found.Remove(reversed)) yield return reversed;                else found.Add(line);            }        }    }     private static IEnumerable<string> GetLines(string url) {        WebRequest request = WebRequest.Create(url);        using (var reader =  StreamReader(request.GetResponse().GetResponseStream(), true)) {            while (!reader.EndOfStream) {                yield return reader.ReadLine();            }        }    }     private static string Reversed(string value) =>  string(value.Reverse().ToArray());}"
"static int[] sedol_weights = { 1, 3, 1, 7, 3, 9 };static int sedolChecksum(string sedol){    int len = sedol.Length;    int sum = 0;     if (len == 7) //SEDOL code already checksummed?        return (int)sedol[6];     if ((len > 7) || (len < 6) || System..Regex.IsMatch(sedol, strv)) //invalid SEDOL        return -1;     for (int i = 0; i < 6; i++)    {        if (Char.IsDigit(sedol[i]))            sum += (((int)sedol[i] - 48) * sedol_weights[i]);         else if (Char.IsLetter(sedol[i]))            sum += (((int)Char.ToUpper(sedol[i]) - 55) * sedol_weights[i]);         else            return -1;     }     return (10 - (sum % 10)) % 10;}"
"using System;using System.Collections.Generic; namespace RosettaSearchListofRecords{    class Program    {        static void Main(string[] args)        {            var dataset =  List<Dictionary<string, object>>() {                 Dictionary<string, object>   {{ strv , strv},                {strv, 21.0  }},                 Dictionary<string, object>   {{ strv , strv},                {strv, 15.2  }},                 Dictionary<string, object>   {{ strv , strv}, {strv, 11.3  }},                 Dictionary<string, object>   {{ strv , strv}, {strv,  7.55 }},                 Dictionary<string, object>   {{ strv , strv},            {strv,  5.85 }},                 Dictionary<string, object>   {{ strv , strv},    {strv,  4.98 }},                 Dictionary<string, object>   {{ strv , strv},        {strv,  4.7  }},                 Dictionary<string, object>   {{ strv , strv},           {strv,  4.58 }},                 Dictionary<string, object>   {{ strv , strv},              {strv,  4.4  }},                 Dictionary<string, object>   {{ strv , strv},           {strv,  3.98 }}            };             // Find the (zero-based) index of the first city in the list whose name is strv            var index = dataset.FindIndex(x => ((string)x[strv]) == strv);            Console.WriteLine(index);             // Find the name of the first city in this list whose population is less than 5 million             var name = (string)dataset.Find(x => (double)x[strv] < 5.0)[strv];            Console.WriteLine(name);             // Find the population of the first city in this list whose name starts with the letter strv             var aNamePopulation = (double)dataset.Find(x => ((string)x[strv]).StartsWith(strv))[strv];            Console.WriteLine(aNamePopulation);        }    }}"
private static readonly Random Rand =  Random(); void sattoloCycle<T>(IList<T> items) {    for (var i = items.Count; i-- > 1;) {        int j = Rand.Next(i);        var tmp = items[i];        items[i] = items[j];        items[j] = tmp;    }}
"using System;using System.Collections.Generic; class Program {    static void Main(string[] args) {        List<string> haystack =  List<string>() { strv, strv, strv, strv, strv, strv, strv, strv, strv };         foreach (string needle in  string[] { strv, strv }) {            int index = haystack.IndexOf(needle);             if (index < 0) Console.WriteLine(strv,needle);                            else Console.WriteLine(strv,index,needle);        }    }}"
"using System;using System.Numerics;using System.Text; class Program{    static void Main(string[] args)    {        BigInteger n = BigInteger.Parse(strv);        BigInteger e = 65537;        BigInteger d = BigInteger.Parse(strv);         const string plaintextstring = strv;        byte[] plaintext = ASCIIEncoding.ASCII.GetBytes(plaintextstring);        BigInteger pt =  BigInteger(plaintext);        if (pt > n)            throw  Exception();         BigInteger ct = BigInteger.ModPow(pt, e, n);        Console.WriteLine(strv + ct);         BigInteger dc = BigInteger.ModPow(ct, d, n);        Console.WriteLine(strv + dc);         string decoded = ASCIIEncoding.ASCII.GetString(dc.ToByteArray());        Console.WriteLine(strv + decoded);    }}"
" using System;using System.Collections.Generic;using System.Linq; namespace Same_Fringe{	class Program	{		static void Main()		{			var rnd =  Random(110456);			var randList = Enumerable.Range(0, 20).Select(i => rnd.Next(1000)).ToList();			var bt1 =  BinTree<int>(randList);			// Shuffling will create a tree with the same values but different topology			Shuffle(randList, 428);			var bt2 =  BinTree<int>(randList);			Console.WriteLine(bt1.CompareTo(bt2) ? strv : strv);			// Insert a 0 in the first tree which should cause a failure			bt1.Insert(0);			Console.WriteLine(bt1.CompareTo(bt2) ? strv : strv);		} 		static void Shuffle<T>(List<T> values, int seed)		{			var rnd =  Random(seed); 			for (var i = 0; i < values.Count - 2; i++)			{				var iSwap = rnd.Next(values.Count - i) + i;				var tmp = values[iSwap];				values[iSwap] = values[i];				values[i] = tmp;			}		}	} 	// Define other methods and classes here	class BinTree<T> where T:IComparable	{		private BinTree<T> _left;		private BinTree<T> _right;		private T _value; 		private BinTree<T> Left		{			get { return _left; }		} 		private BinTree<T> Right		{			get { return _right; }		} 		// On interior nodes, any value greater than or equal to Value goes in the		// right subtree, everything else in the left.		private T Value		{			get { return _value; }		} 		public bool IsLeaf { get { return Left == null; } } 		private BinTree(BinTree<T> left, BinTree<T> right, T value)		{			_left = left;			_right = right;			_value = value;		} 		public BinTree(T value) : this(null, null, value) { } 		public BinTree(IEnumerable<T> values)		{			// ReSharper disable PossibleMultipleEnumeration			_value = values.First();			foreach (var value in values.Skip(1))			{				Insert(value);			}			// ReSharper restore PossibleMultipleEnumeration		} 		public void Insert(T value)		{			if (IsLeaf)			{				if (value.CompareTo(Value) < 0)				{					_left =  BinTree<T>(value);					_right =  BinTree<T>(Value);				}				else				{					_left =  BinTree<T>(Value);					_right =  BinTree<T>(value);					_value = value;				}			}			else			{				if (value.CompareTo(Value) < 0)				{					Left.Insert(value);				}				else				{					Right.Insert(value);				}			}		} 		public IEnumerable<T> GetLeaves()		{			if (IsLeaf)			{				yield return Value;				yield break;			}			foreach (var val in Left.GetLeaves())			{				yield return val;			}			foreach (var val in Right.GetLeaves())			{				yield return val;			}		} 		internal bool CompareTo(BinTree<T> other)		{			return other.GetLeaves().Zip(GetLeaves(), (t1, t2) => t1.CompareTo(t2) == 0).All(f => f);		}	}} "
"       public static void Main(string[] args)       {           string input = strv;           Console.WriteLine(Encode(input));//Outputs: 12W1B12W3B24W1B14W           Console.WriteLine(Decode(Encode(input)));//Outputs: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW           Console.ReadLine();       }       public static string Encode(string s)       {           StringBuilder sb =  StringBuilder();           int count = 1;           char current =s[0];           for(int i = 1; i < s.Length;i++)           {               if (current == s[i])               {                   count++;               }               else               {                   sb.AppendFormat(strv, count, current);                   count = 1;                   current = s[i];               }           }           sb.AppendFormat(strv, count, current);           return sb.ToString();       }       public static string Decode(string s)       {           string a = strv;           int count = 0;           StringBuilder sb =  StringBuilder();           char current = char.MinValue;           for(int i = 0; i < s.Length; i++)           {               current = s[i];               if (char.IsDigit(current))                   a += current;               else               {                   count = int.Parse(a);                   a = strv;                   for (int j = 0; j < count; j++)                       sb.Append(current);               }           }           return sb.ToString();       }using System;using System.Text.RegularExpressions; public class Program{    private delegate void fOk(bool ok, string message);     public static int Main(string[] args)    {        const string raw = strv;        const string code = strv;         fOk Ok = delegate(bool ok, string message)        {            Console.WriteLine(strv, ok ? strv : strv, message);        };        Ok(code.Equals(Encode(raw)), strv);        Ok(raw.Equals(Decode(code)), strv);        return 0;    }     public static string Encode(string input)    {        return Regex.Replace(input, @strv, delegate(Match m)        {            return string.Concat(m.Value.Length, m.Groups[1].Value);        });    }     public static string Decode(string input)    {        return Regex.Replace(input, @strv, delegate(Match m)        {            return  string(m.Groups[2].Value[0], int.Parse(m.Groups[1].Value));        });    }}"
using System;using System.IO;using System.Linq;using System.Text; class Program{    static char Rot13(char c)    {        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')        {            return (char)(c + 13);        }        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')        {            return (char)(c - 13);        }        return c;    }     static string Rot13(string s)    {        return  StringBuilder().Append(s.Select(Rot13).ToArray()).ToString();    }      static void Main(string[] args)    {        foreach (var file in args.Where(file => File.Exists(file)))        {            Console.WriteLine(Rot13(File.ReadAllText(file)));        }        if (!args.Any())        {            Console.WriteLine(Rot13(Console.In.ReadToEnd()));        }    }}
"using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Net;using System.Text.RegularExpressions; class Program{    static void Main(string[] args)    {        string get1 =  WebClient().DownloadString(strv);        string get2 =  WebClient().DownloadString(strv);         ArrayList langs =  ArrayList();        Dictionary<string, int> qtdmbr =  Dictionary<string, int>();         MatchCollection match1 =  Regex(""title:Category:(.+?)"").Matches(get1);        MatchCollection match2 =  Regex(""title=Category:(.+?)>.+?</a>[^(]*((d+) members)"").Matches(get2);         foreach (Match lang in match1) langs.Add(lang.Groups[1].Value);         foreach (Match match in match2)        {            if (langs.Contains(match.Groups[1].Value))            {                qtdmbr.Add(match.Groups[1].Value, Int32.Parse(match.Groups[2].Value));            }        }         string[] test = qtdmbr.OrderByDescending(x => x.Value).Select(x => String.Format(strv, x.Value, x.Key)).ToArray();         int count = 1;         foreach (string i in test)        {            Console.WriteLine(strv, count, i);            count++;        }    }}using System;using System.Net;using System.Linq;using System.Text.RegularExpressions;using System.Collections.Generic; class Category {    private string _title;    private int _members;     public Category(string title, int members) {        _title = title;        _members = members;    }     public string Title {        get {            return _title;        }    }     public int Members {        get {            return _members;        }    }} class Program {    static void Main(string[] args) {        string get1 =  WebClient().DownloadString(strv);        string get2 =  WebClient().DownloadString(strv);         MatchCollection match1 =  Regex(""title:Category:(.+?)"").Matches(get1);        MatchCollection match2 =  Regex(""title=Category:(.+?)>.+?</a>[^(]*((d+) members)"").Matches(get2);         string[] valids = match1.Cast<Match>().Select(x => x.Groups[1].Value).ToArray();        List<Category> langs =  List<Category>();         foreach (Match match in match2) {            string category = match.Groups[1].Value;            int members = Int32.Parse(match.Groups[2].Value);             if (valids.Contains(category)) langs.Add( Category(category, members));        }         langs = langs.OrderByDescending(x => x.Members).ToList();        int count = 1;         foreach (Category i in langs) {            Console.WriteLine(strv, count, i.Members, i.Title);            count++;        }    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text.RegularExpressions;using System.Net; class Program {    static List<string> GetTitlesFromCategory(string category) {        string searchQueryFormat = strv;        List<string> results =  List<string>();        string cmcontinue = string.Empty;         do {            string cmContinueKeyValue;             //append continue variable as needed            if (cmcontinue.Length > 0)                cmContinueKeyValue = String.Format(strv, cmcontinue);            else                cmContinueKeyValue = String.Empty;             //execute query            string query = String.Format(searchQueryFormat, category, cmContinueKeyValue);            string content =  WebClient().DownloadString(query);             results.AddRange( Regex(""title:(.+?)"").Matches(content).Cast<Match>().Select(x => x.Groups[1].Value));             //detect if more results are available            cmcontinue = Regex.Match(content, @strvstrvstrvstrvstrvstrv, RegexOptions.IgnoreCase).Groups[strv].Value;                        } while (cmcontinue.Length > 0);         return results;    }     static string[] GetUnimplementedTasksFromLanguage(string language) {        List<string> alltasks = GetTitlesFromCategory(strv);        List<string> lang = GetTitlesFromCategory(language);         return alltasks.Where(x => !lang.Contains(x)).ToArray();    }     static void Main(string[] args) {        string[] unimpl = GetUnimplementedTasksFromLanguage(args[0]);         foreach (string i in unimpl) Console.WriteLine(i);    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Numerics; class Program{    static IEnumerable<Complex> RootsOfUnity(int degree)    {        return Enumerable            .Range(0, degree)            .Select(element => Complex.FromPolarCoordinates(1, 2 * Math.PI * element / degree));    }     static void Main()    {        var degree = 3;        foreach (var root in RootsOfUnity(degree))        {            Console.WriteLine(root);        }    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text.RegularExpressions;using System.Net; class Task {    private string _task;    private int _examples;     public Task(string task, int examples) {        _task = task;        _examples = examples;    }     public string Name {        get { return _task; }    }     public int Examples {        get { return _examples; }    }     public override string ToString() {        return String.Format(strv, this._task, this._examples);    }} class Program {    static List<string> GetTitlesFromCategory(string category, WebClient wc) {        string content = wc.DownloadString(            String.Format(strv, category)        );         return  Regex(""title:(.+?)"").Matches(content).Cast<Match>().Select(x => x.Groups[1].Value.Replace(""/"", strv)).ToList();    }     static string GetSourceCodeFromPage(string page, WebClient wc) {        return wc.DownloadString(            String.Format(strv, page)        );    }     static void Main(string[] args) {        WebClient wc =  WebClient();        List<Task> tasks =  List<Task>();        List<string> tasknames = GetTitlesFromCategory(strv, wc);         foreach (string task in tasknames) {            string content = GetSourceCodeFromPage(task, wc);            int count =  Regex(strv, RegexOptions.IgnoreCase).Matches(content).Count;            Task t =  Task(task, count);             Console.WriteLine(t);            tasks.Add(t);        }         Console.WriteLine(""Total: {0} examples."", tasks.Select(x => x.Examples).Sum());    }}"
"using System;using System.Numerics; class QuadraticRoots{    static Tuple<Complex, Complex> Solve(double a, double b, double c)    {        var q = -(b + Math.Sign(b) * Complex.Sqrt(b * b - 4 * a * c)) / 2;        return Tuple.Create(q / a, c / q);    }     static void Main()    {        Console.WriteLine(Solve(1, -1E20, 1));    }}"
"using System;using System.Security.Cryptography;using System.Text; class Program{    static void Main(string[] args)    {        string text = strv;        byte[] bytes = Encoding.ASCII.GetBytes(text);        RIPEMD160 myRIPEMD160 = RIPEMD160Managed.Create();        byte[] hashValue = myRIPEMD160.ComputeHash(bytes);        var hexdigest = BitConverter.ToString(hashValue).Replace(strv, strv).ToLower();        Console.WriteLine(hexdigest);        Console.ReadLine();    }}"
"using System;class Program{    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };    static string[] rum = { strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv };     static string ToRoman(uint number)    {        string value = strv;        for (int i = 0; i < nums.Length && number != 0; i++)        {            while (number >= nums[i])            {                number -= nums[i];                value += rum[i];            }        }        return value;    }     static void Main()    {        for (uint number = 1; number <= 1 << 10; number *= 2)        {            Console.WriteLine(strv, number, ToRoman(number));        }    }} Func<int, string> toRoman = (number) =>   Dictionary<int, string>  {    {1000, strv},    {900, strv},    {500, strv},    {400, strv},    {100, strv},    {90, strv},    {50, strv},    {40, strv},    {10, strv},    {9, strv},    {5, strv},    {4, strv},    {1, strv}  }.Aggregate( string('I', number), (m, _) => m.Replace( string('I', _.Key), _.Value)); "
"using System;using System.Collections.Generic; namespace Roman{    internal class Program    {        private static void Main(string[] args)        {            // Decode and print the numerals.            Console.WriteLine(strv, strv, Decode(strv));            Console.WriteLine(strv, strv, Decode(strv));            Console.WriteLine(strv, strv, Decode(strv));        }         // Dictionary to hold our numerals and their values.        private static readonly Dictionary<char, int> RomanDictionary =  Dictionary<char, int>                                                                            {                                                                                {'I', 1},                                                                                {'V', 5},                                                                                {'X', 10},                                                                                {'L', 50},                                                                                {'C', 100},                                                                                {'D', 500},                                                                                {'M', 1000}                                                                            };         private static int Decode(string roman)        {            /* Make the input string upper-case,
             * because the dictionary doesn't support lower-case characters. */            roman = roman.ToUpper();             /* total = the current total value that will be returned.
             * minus = value to subtract from next numeral. */            int total = 0, minus = 0;             for (int i = 0; i < roman.Length; i++) // Iterate through characters.            {                // Get the value for the current numeral. Takes subtraction into account.                int thisNumeral = RomanDictionary[roman[i]] - minus;                 /* Checks if this is the last character in the string, or if the current numeral
                 * is greater than or equal to the next numeral. If so, we will reset our minus
                 * variable and add the current numeral to the total value. Otherwise, we will
                 * subtract the current numeral from the next numeral, and continue. */                if (i >= roman.Length - 1 ||                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])                {                    total += thisNumeral;                    minus = 0;                }                else                {                    minus = thisNumeral;                }            }             return total; // Return the total.        }    }}"
"using System; public class ReverseWordsInString{    public static void Main()    {        string[] lines = {                strv,                strv,                strv,                strv,                strv,                strv,                strv,                strv,                strv,                strv };         foreach(string line in lines)         {            string[] words = line.Split(' ');            Array.Reverse(words);             foreach(string word in words)            {                //String.Split() adds empty strings to the array. We must check                if(word.Length != 0)                     Console.Write(word + strv);            }            Console.WriteLine();        }    }}"
"using System;using System.Dynamic; class Example : DynamicObject{    public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)    {        result = null;         Console.WriteLine(strv, binder.Name);        return true;    }} class Program{    static void Main(string[] args)    {        dynamic ex =  Example();         ex.Foo();        ex.Bar();    }}"
private static string ReverseString(string input){	char[] inputChars = input.ToCharArray();	Array.Reverse(inputChars);	return  string(inputChars);}return  string(input.Reverse().ToArray());
"using System;using System.IO; public class Rosetta{    /* C# 6 version:
    public static void Main() => RemoveLines(strv, start: 1, count: 2);
    */     public static void Main() {        RemoveLines(strv, start: 1, count: 2);    }     static void RemoveLines(string filename, int start, int count = 1) {        //Reads and writes one line at a time, so no memory overhead.        File.WriteAllLines(filename, File.ReadAllLines(filename)            .Where((line, index) => index < start - 1 || index >= start + count - 1));    }}"
"string s = strv.PadLeft(5, 'X').Replace(strv, strv);string s =  String('X', 5).Replace(strv, strv);string s = String.Join(strv,  string[5 + 1]);string s = String.Concat(Enumerable.Repeat(strv, 5));string s = strv.PadLeft(5, '*');string s =  String('*', 5);"
"using System;using System.IO; class Program {    static void Main(string[] args) {        File.Move(strv,strv);        File.Move(@strv,@strv);         Directory.Move(strv,strv);        Directory.Move(@strv,@strv);    }}"
"int[] nums = { 1, 1, 2, 3, 4, 4 };List<int> unique =  List<int>();foreach (int n in nums)    if (!unique.Contains(n))        unique.Add(n);int[] nums = {1, 1, 2, 3, 4, 4};int[] unique = nums.Distinct().ToArray();"
"using System;using System.Reflection; public class Rosetta{    public static void Main()    {        //Let's get all methods, not just public ones.        BindingFlags flags = BindingFlags.Instance | BindingFlags.Static            | BindingFlags.Public | BindingFlags.NonPublic            | BindingFlags.DeclaredOnly;         foreach (var method in (TestForMethodReflection).GetMethods(flags))            Console.WriteLine(method.Name);    }     class TestForMethodReflection    {        public void MyPublicMethod() {}        private void MyPrivateMethod() {}         public static void MyPublicStaticMethod() {}        private static void MyPrivateStaticMethod() {}    } }"
"using System;using System.Text.RegularExpressions; class Program {    static void Main(string[] args) {        string str = strv;         if ( Regex(strv).IsMatch(str)) {            Console.WriteLine(strv);        }         str =  Regex(strv).Replace(str, strv);        Console.WriteLine(str);    }}"
"using System.IO; class Program{    static void Main(string[] args)    {        var fileContents = File.ReadAllText(""c:autoexec.bat"");    }} "
"using System; class Program {    static void Main(string[] args) {                Console.WriteLine(Math.E); //E        Console.WriteLine(Math.PI); //PI        Console.WriteLine(Math.Sqrt(10)); //Square Root        Console.WriteLine(Math.Log(10)); // Logarithm        Console.WriteLine(Math.Log10(10)); // Base 10 Logarithm        Console.WriteLine(Math.Exp(10)); // Exponential        Console.WriteLine(Math.Abs(10)); //Absolute value        Console.WriteLine(Math.Floor(10.0)); //Floor        Console.WriteLine(Math.Ceiling(10.0)); //Ceiling        Console.WriteLine(Math.Pow(2, 5)); // Exponentiation    }}"
"foreach (string readLine in File.ReadLines(strv))  DoSomething(readLine);using System;using System.IO;using System.Text; namespace RosettaCode{  internal class Program  {    private static void Main()    {      var sb =  StringBuilder();      string F = strv;       // Read a file, line by line.      try      {        foreach (string readLine in File.ReadLines(F))        {          // Use the data in some way...          sb.Append(readLine);          sb.Append("""");        }      }      catch (Exception exception)      {        Console.WriteLine(exception.Message);        Environment.Exit(1);      }       // Preset the results      Console.WriteLine(sb.ToString());    }  }}"
"using System;using System.Collections.Generic;using System.Linq; class RangeExtraction{    static void Main()    {        const string testString = strv;        var result = String.Join(strv, RangesToStrings(GetRanges(testString)));        Console.Out.WriteLine(result);    }     public static IEnumerable<IEnumerable<int>> GetRanges(string testString)    {        var numbers = testString.Split([] { ',' }).Select(x => Convert.ToInt32(x));        var current =  List<int>();        foreach (var n in numbers)        {            if (current.Count == 0)            {                current.Add(n);            }            else            {                if (current.Max() + 1 == n)                {                    current.Add(n);                }                else                {                    yield return current;                    current =  List<int> { n };                }            }        }        yield return current;    }     public static IEnumerable<string> RangesToStrings(IEnumerable<IEnumerable<int>> ranges)    {        foreach (var range in ranges)        {            if (range.Count() == 1)            {                yield return range.Single().ToString();            }            else if (range.Count() == 2)            {                yield return range.Min() + strv + range.Max();            }            else            {                yield return range.Min() + strv + range.Max();            }        }    }} using System;using System.Collections.Generic;using System.Linq; namespace RangeExtraction {  internal static class ListExtensions {    internal static string ExtractRange(this IEnumerable<int> values) {      var list = values.Distinct().OrderBy(_ => _).ToArray();      var ranges =  int[0][].AsEnumerable();      var current = 0;      for (var i = 1; ; ++i) {        if (i >= list.Length) {          ranges = ranges.Concat([] { [] { i != current ? current : i - 1, i - 1 } });          break;        }        if (list[i] == list[i - 1] + 1)          continue;        ranges = ranges.Concat([] { [] { current, i - 1 } });        current = i;      }      return string.Join(strv, ranges.Select(r => string.Format(r[0] == r[1] ? strv : strv, list[r[0]], list[r[1]])));    }  }   internal class Program {    private static readonly IList<int> VALUES = [] {      0, 1, 2,      4,      6, 7, 8,      11, 12,      14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,      27, 28, 29, 30, 31, 32, 33,      35, 36, 37, 38, 39    };     private static void Main(string[] args) {      var rangestr = VALUES.ExtractRange();      Console.WriteLine(strv, string.Join(strv, VALUES.Select(_=>_.ToString())));      Console.WriteLine(""ranges = {0}"", rangestr);    }  }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text.RegularExpressions; class Program{    static void Main(string[] args)    {        var rangeString = strv;        var matches = Regex.Matches(rangeString, @strv);        var values =  List<string>();         foreach (var m in matches.OfType<Match>())        {            if (m.Groups[1].Success)            {                values.Add(m.Value);                continue;            }             var start = Convert.ToInt32(m.Groups[strv].Value);            var end = Convert.ToInt32(m.Groups[strv].Value) + 1;             values.AddRange(Enumerable.Range(start, end - start).Select(v => v.ToString()));        }         Console.WriteLine(string.Join(strv, values));    }}using System;using System.Collections.Generic;using System.Linq; namespace RangeExpansion {  internal static class StringExtensions {    internal static IEnumerable<int> ExpandRange(this string s) {      return s.Split(',')        .Select(rstr => {          int start;          if (int.TryParse(rstr, out start))            return  {Start = start, End = start};          var istr =  string((strv.Any(_ => rstr[0] == _)            ? rstr.Take(1).Concat(rstr.Skip(1).TakeWhile(char.IsDigit))            : rstr.TakeWhile(char.IsDigit)            ).ToArray());          rstr = rstr.Substring(istr.Length + 1, (rstr.Length - istr.Length) - 1);          return  {Start = int.Parse(istr), End = int.Parse(rstr)};        }).SelectMany(_ => Enumerable.Range(_.Start, _.End - _.Start + 1));    }  }   internal static class Program {    private static void Main() {      const string RANGE_STRING = strv;      var values = RANGE_STRING.ExpandRange().ToList();      var vstr = string.Join(strv, values.Select(_ => _.ToString()));      Console.WriteLine(vstr);    }  }}"
"using System; namespace rref{    class Program    {        static void Main(string[] args)        {            int[,] matrix =  int[3, 4]{                {  1, 2, -1,  -4 },                {  2, 3, -1, -11 },                { -2, 0, -3,  22 }            };            matrix = rref(matrix);           }         private static int[,] rref(int[,] matrix)        {                        int lead = 0, rowCount = matrix.GetLength(0), columnCount = matrix.GetLength(1);            for (int r = 0; r < rowCount; r++)            {                if (columnCount <= lead) break;                int i = r;                while (matrix[i, lead] == 0)                {                    i++;                    if (i == rowCount)                    {                        i = r;                        lead++;                        if (columnCount == lead)                        {                        lead--;                        break;                        }                    }                }                for (int j = 0; j < columnCount; j++)                {                    int temp = matrix[r, j];                    matrix[r, j] = matrix[i, j];                    matrix[i, j] = temp;                }                int div = matrix[r, lead];                if(div != 0)                    for (int j = 0; j < columnCount; j++) matrix[r, j] /= div;                                for (int j = 0; j < rowCount; j++)                {                    if (j != r)                    {                        int sub = matrix[j, lead];                        for (int k = 0; k < columnCount; k++) matrix[j, k] -= (sub * matrix[r, k]);                    }                }                lead++;            }            return matrix;        }    }}"
" private static double randomNormal(){	return Math.Cos(2 * Math.PI * tRand.NextDouble()) * Math.Sqrt(-2 * Math.Log(tRand.NextDouble()));}  static Random tRand =  Random(); static void Main(string[] args){	double[] a =  double[1000]; 	double tAvg = 0;	for (int x = 0; x < a.Length; x++)	{		a[x] = randomNormal() / 2 + 1;		tAvg += a[x];	} 	tAvg /= a.Length;	Console.WriteLine(strv + tAvg.ToString()); 	double s = 0;	for (int x = 0; x < a.Length; x++)	{		s += Math.Pow((a[x] - tAvg), 2);	}	s = Math.Sqrt(s / 1000); 	Console.WriteLine(strv + s.ToString()); 	Console.ReadLine();} "
"using System;using System.Security.Cryptography; private static int GetRandomInt(){  int result = 0;  var rng =  RNGCryptoServiceProvider();  var buffer =  byte[4];   rng.GetBytes(buffer);  result = BitConverter.ToInt32(buffer, 0);   return result;} const long m = 2147483647L;const long a = 48271L;const long q = 44488L;const long r = 3399L;static long r_seed = 12345678L; public static byte gen(){   long hi = r_seed / q;   long lo = r_seed - q * hi;   long t = a * lo - r * hi;       if (t > 0)           r_seed = t;       else           r_seed = t + m;       return (byte)r_seed;} public static void ParkMiller(byte[] arr){   byte[] arr =  byte[10900000];    for (int i = 0; i < arr.Length; i++)                {                                              arr[i] = gen();                }}"
"using System;using System.Collections.Generic; namespace RosettaCode{    class Program    {        static void Main()        {            // Create a queue and strv items into it            Queue<int> queue  =  Queue<int>();            queue.Enqueue(1);            queue.Enqueue(3);            queue.Enqueue(5);             // strv items from the queue in FIFO order            Console.WriteLine(queue.Dequeue()); // 1            Console.WriteLine(queue.Dequeue()); // 3            Console.WriteLine(queue.Dequeue()); // 5             // To tell if the queue is empty, we check the count            bool empty = queue.Count == 0;            Console.WriteLine(empty); // strv             // If we try to pop from an empty queue, an exception            // is thrown.            try            {                queue.Dequeue();            }            catch (InvalidOperationException exception)            {                Console.WriteLine(exception.Message); // strv            }        }    }}"
"// ----------------------------------------------------------------------------------------------//  //  Program.cs - QuickSelect//  // ---------------------------------------------------------------------------------------------- using System;using System.Collections.Generic;using System.Linq; namespace QuickSelect{    internal static class Program    {        #region Static Members         private static void Main()        {            var inputArray = [] {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};            // Loop 10 times            Console.WriteLine( strv );            for( var i = 0 ; i < 10 ; i++ )            {                Console.Write( inputArray.NthSmallestElement( i ) );                if( i < 9 )                    Console.Write( strv );            }            Console.WriteLine();             // And here is then more effective way to get N smallest elements from vector in order by using quick select algorithm            // Basically we are here just sorting array (taking 10 smallest from array which length is 10)            Console.WriteLine( strv );            Console.WriteLine( string.Join( strv, inputArray.TakeSmallest( 10 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );            // Here we are actually doing quick select once by taking only 4 smallest from array.             Console.WriteLine( strv );            Console.WriteLine( string.Join( strv, inputArray.TakeSmallest( 4 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );            Console.WriteLine( strv );            Console.ReadKey();        }         #endregion    }     internal static class ArrayExtension    {        #region Static Members         
        
        
        
        
        
        
        public static IEnumerable<T> TakeSmallest<T>( this T[] array, int count ) where T : IComparable<T>        {            if( count < 0 )                throw  ArgumentOutOfRangeException( strv, strv );            if( count == 0 )                return  T[0];            if( array.Length <= count )                return array;             return QuickSelectSmallest( array, count - 1 ).Take( count );        }         
        
        
        
        
        
        
        public static T NthSmallestElement<T>( this T[] array, int n ) where T : IComparable<T>        {            if( n < 0 || n > array.Length - 1 )                throw  ArgumentOutOfRangeException( strv, n, string.Format( strv, array.Length - 1, n ) );            if( array.Length == 0 )                throw  ArgumentException( strv, strv );            if( array.Length == 1 )                return array[ 0 ];             return QuickSelectSmallest( array, n )[ n ];        }         
        
        
        
        
        
        
        private static T[] QuickSelectSmallest<T>( T[] input, int n ) where T : IComparable<T>        {            // Let's not mess up with our input array            // For very large arrays - we should optimize this somehow - or just mess up with our input            var partiallySortedArray = (T[]) input.Clone();             // Initially we are going to execute quick select to entire array            var startIndex = 0;            var endIndex = input.Length - 1;             // Selecting initial pivot            // Maybe we are lucky and array is sorted initially?            var pivotIndex = n;             // Loop until there is nothing to loop (this actually shouldn't happen - we should find our value before we run out of values)            var r =  Random();            while( endIndex > startIndex )            {                pivotIndex = QuickSelectPartition( partiallySortedArray, startIndex, endIndex, pivotIndex );                if( pivotIndex == n )                    // We found our n:th smallest value - it is stored to pivot index                    break;                if( pivotIndex > n )                    // Array before our pivot index have more elements that we are looking for                                        endIndex = pivotIndex - 1;                else                                        // Array before our pivot index has less elements that we are looking for                                        startIndex = pivotIndex + 1;                 // Omnipotent beings don't need to roll dices - but we do...                // Randomly select a new pivot index between end and start indexes (there are other methods, this is just most brutal and simplest)                pivotIndex = r.Next( startIndex,  endIndex );            }            return partiallySortedArray;        }         
        
        
        
        
        
        
        
        
        
        
        
        private static int QuickSelectPartition<T>( this T[] array, int startIndex, int endIndex, int pivotIndex ) where T : IComparable<T>        {            var pivotValue = array[ pivotIndex ];            // Initially we just assume that value in pivot index is largest - so we move it to end (makes also for loop more straight forward)            array.Swap( pivotIndex, endIndex );            for( var i = startIndex ; i < endIndex ; i++ )            {                if( array[ i ].CompareTo( pivotValue ) > 0 )                    continue;                 // Value stored to i was smaller than or equal with pivot value - let's move it to start                array.Swap( i, startIndex );                // Move start one index forward                 startIndex++;            }            // Start index is now pointing to index where we should store our pivot value from end of array            array.Swap( endIndex, startIndex );            return startIndex;        }         private static void Swap<T>( this T[] array, int index1, int index2 )        {            if( index1 == index2 )                return;             var temp = array[ index1 ];            array[ index1 ] = array[ index2 ];            array[ index2 ] = temp;        }         #endregion    }}"
"class Program { static void Main() { var s = strv; System.Console.WriteLine(s, (char)34, s); } }"
"using System;using MathNet.Numerics.LinearAlgebra;using MathNet.Numerics.LinearAlgebra.Double;  class Program{     static void Main(string[] args)    {        Matrix<double> A = DenseMatrix.OfArray( double[,]        {                {  12,  -51,    4 },                {   6,  167,  -68 },                {  -4,   24,  -41 }        });        Console.WriteLine(strv);        Console.WriteLine(A);        var qr = A.QR();        Console.WriteLine();        Console.WriteLine(strv);        Console.WriteLine(qr.Q);        Console.WriteLine();        Console.WriteLine(strv);        Console.WriteLine(qr.R);    }}"
"public class FIFO<T>{  class Node  {    public T Item { get; set; }    public Node Next { get; set; }  }  Node first = null;  Node last = null;  public void push(T item)  {    if (empty())    {      //Uses object initializers to set fields of new node      first =  Node() { Item = item, Next = null };      last = first;    }    else    {      last.Next =  Node() { Item = item, Next = null };      last = last.Next;    }  }  public T pop()  {    if (first == null)      throw  System.Exception(strv);     if (last == first)      last = null;    T temp = first.Item;    first = first.Next;    return temp;  }  public bool empty()  {    return first == null;  }}"
"using System; struct Quaternion : IEquatable<Quaternion>{    public readonly double A, B, C, D;     public Quaternion(double a, double b, double c, double d)    {        this.A = a;        this.B = b;        this.C = c;        this.D = d;    }     public double Norm()    {        return Math.Sqrt(A * A + B * B + C * C + D * D);    }     public static Quaternion operator -(Quaternion q)    {        return  Quaternion(-q.A, -q.B, -q.C, -q.D);    }     public Quaternion Conjugate()    {        return  Quaternion(A, -B, -C, -D);    }     // implicit conversion takes care of real*quaternion and real+quaternion    public static implicit operator Quaternion(double d)    {        return  Quaternion(d, 0, 0, 0);    }     public static Quaternion operator +(Quaternion q1, Quaternion q2)    {        return  Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);    }     public static Quaternion operator *(Quaternion q1, Quaternion q2)    {        return  Quaternion(            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);    }     public static bool operator ==(Quaternion q1, Quaternion q2)    {        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;    }     public static bool operator !=(Quaternion q1, Quaternion q2)    {        return !(q1 == q2);    }     #region Object Members     public override bool Equals(object obj)    {        if (obj  Quaternion)            return Equals((Quaternion)obj);         return false;    }     public override int GetHashCode()    {        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();    }     public override string ToString()    {        return string.Format(strv, A, B, C, D);    }     #endregion     #region IEquatable<Quaternion> Members     public bool Equals(Quaternion other)    {        return other == this;    }     #endregion}using System; static class Program{    static void Main(string[] args)    {        Quaternion q =  Quaternion(1, 2, 3, 4);        Quaternion q1 =  Quaternion(2, 3, 4, 5);        Quaternion q2 =  Quaternion(3, 4, 5, 6);        double r = 7;         Console.WriteLine(strv, q);        Console.WriteLine(strv, q1);        Console.WriteLine(strv, q2);        Console.WriteLine(strv, r);         Console.WriteLine(strv, q.Norm());        Console.WriteLine(strv, q1.Norm());        Console.WriteLine(strv, q2.Norm());         Console.WriteLine(strv, -q);        Console.WriteLine(strv, q.Conjugate());         Console.WriteLine(strv, q + r);        Console.WriteLine(strv, q1 + q2);        Console.WriteLine(strv, q2 + q1);         Console.WriteLine(strv, q * r);        Console.WriteLine(strv, q1 * q2);        Console.WriteLine(strv, q2 * q1);         Console.WriteLine(strv, (q1 * q2) == (q2 * q1) ? strv : strv);    }}"
if (problem){   Environment.Exit(1);}
"namespace RosettaCode.ProperDivisors{    using System;    using System.Collections.Generic;    using System.Linq;     internal static class Program    {        private static IEnumerable<int> ProperDivisors(int number)        {            return                Enumerable.Range(1, number / 2)                    .Where(divisor => number % divisor == 0);        }         private static void Main()        {            foreach (var number in Enumerable.Range(1, 10))            {                Console.WriteLine(strv, number,                    string.Join(strv, ProperDivisors(number)));            }             var record = Enumerable.Range(1, 20000).Select(number =>             {                Number = number,                Count = ProperDivisors(number).Count()            }).OrderByDescending(currentRecord => currentRecord.Count).First();            Console.WriteLine(strv, record.Number, record.Count);        }    }}"
using System;namespace ProgramName{	class Program	{		static void Main(string[] args)		{			Console.Write(Environment.CommandLine);		}	}}using System;namespace ProgramName{	class Program	{		static void Main(string[] args)		{			// Extracts the filename from the full path			System..FileInfo exeInfo =  System..FileInfo(System.Windows.Forms.Application.ExecutablePath);			Console.Write(exeInfo.Name); 			// Writes all arguments to the console			foreach (string argument in args)			{				Console.Write(strv + argument);			}		}	}}
" using System; namespace ApolloniusProblemCalc{    class Program    {        static float rs = 0;        static float xs = 0;        static float ys = 0;         public static void Main(string[] args)        {            float gx1;            float gy1;            float gr1;            float gx2;            float gy2;            float gr2;            float gx3;            float gy3;            float gr3;             //----------Enter values for the given circles here----------            gx1 = 0;            gy1 = 0;            gr1 = 1;            gx2 = 4;            gy2 = 0;            gr2 = 1;            gx3 = 2;            gy3 = 4;            gr3 = 2;            //-----------------------------------------------------------             for (int i = 1; i <= 8; i++)            {                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);                  if (i == 1)                {                    Console.WriteLine(strv + i + strv + xs.ToString());                    Console.WriteLine(strv + i + strv + ys.ToString());                    Console.WriteLine(i + strv + rs.ToString());                }                else if (i == 2)                {                    Console.WriteLine(strv + i + strv + xs.ToString());                    Console.WriteLine(strv + i + strv + ys.ToString());                    Console.WriteLine(i + strv + rs.ToString());                }                else if(i == 3)                {                    Console.WriteLine(strv + i + strv + xs.ToString());                    Console.WriteLine(strv + i + strv + ys.ToString());                    Console.WriteLine(i + strv + rs.ToString());                }                else                {                    Console.WriteLine(strv + i + strv + xs.ToString());                    Console.WriteLine(strv + i + strv + ys.ToString());                    Console.WriteLine(i + strv + rs.ToString());                }                 Console.WriteLine();            }              Console.ReadKey(true);        }         private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)        {            float s1 = 1;            float s2 = 1;            float s3 = 1;             if (calcCounter == 2)            {                s1 = -1;                s2 = -1;                s3 = -1;            }            else if (calcCounter == 3)            {                s1 = 1;                s2 = -1;                s3 = -1;            }            else if (calcCounter == 4)            {                s1 = -1;                s2 = 1;                s3 = -1;            }            else if (calcCounter == 5)            {                s1 = -1;                s2 = -1;                s3 = 1;            }            else if (calcCounter == 6)            {                s1 = 1;                s2 = 1;                s3 = -1;            }            else if (calcCounter == 7)            {                s1 = -1;                s2 = 1;                s3 = 1;            }            else if (calcCounter == 8)            {                s1 = 1;                s2 = -1;                s3 = 1;            }             //This calculation to solve for the solution circles is cited from the Java version             float v11 = 2 * x2 - 2 * x1;            float v12 = 2 * y2 - 2 * y1;            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;            float v14 = 2 * s2 * r2 - 2 * s1 * r1;             float v21 = 2 * x3 - 2 * x2;            float v22 = 2 * y3 - 2 * y2;            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;            float v24 = 2 * s3 * r3 - 2 * s2 * r2;             float w12 = v12 / v11;            float w13 = v13 / v11;            float w14 = v14 / v11;             float w22 = v22 / v21 - w12;            float w23 = v23 / v21 - w13;            float w24 = v24 / v21 - w14;             float P = -w23 / w22;            float Q = w24 / w22;            float M = -w12 * P - w13;            float N = w14 - w12 * Q;             float a = N * N + Q * Q - 1;            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;             float D = b * b - 4 * a * c;             rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));            xs = M + N * rs;            ys = P + Q * rs;        }    }} "
" using System; class Program{    static long TRIALS = 1000000L;    private class Expv    {        public string name;        public int probcount;        public double expect;        public double mapping;         public Expv(string name, int probcount, double expect, double mapping)        {            this.name = name;            this.probcount = probcount;            this.expect = expect;            this.mapping = mapping;        }    }     static Expv[] items = {         Expv(strv, 0, 0.0, 0.0),  Expv(strv, 0, 0.0, 0.0),         Expv(strv, 0, 0.0, 0.0),  Expv(strv, 0, 0.0, 0.0),	 Expv(strv, 0, 0.0, 0.0),     Expv(strv, 0, 0.0, 0.0),	 Expv(strv, 0, 0.0, 0.0),  Expv(strv, 0, 0.0, 0.0)    };     static void Main(string[] args)    {        double rnum, tsum = 0.0;        Random random =  Random();         for (int i = 0, rnum = 5.0; i < 7; i++, rnum += 1.0)        {            items[i].expect = 1.0 / rnum;            tsum += items[i].expect;        }        items[7].expect = 1.0 - tsum;         items[0].mapping = 1.0 / 5.0;        for (int i = 1; i < 7; i++)            items[i].mapping = items[i - 1].mapping + 1.0 / ((double)i + 5.0);        items[7].mapping = 1.0;         for (int i = 0; i < TRIALS; i++)        {            rnum = random.NextDouble();            for (int j = 0; j < 8; j++)                if (rnum < items[j].mapping)                {                    items[j].probcount++;                    break;                }        }         Console.WriteLine(strv, TRIALS);        Console.Write(strv);        for (int i = 0; i < 8; i++)            Console.Write(items[i].name.PadRight(9));        Console.WriteLine();        Console.Write(strv);        for (int i = 0; i < 8; i++)            Console.Write(strv, items[i].expect);        Console.WriteLine();        Console.Write(strv);        for (int i = 0; i < 8; i++)            Console.Write(strv, (double)items[i].probcount / (double)TRIALS);        Console.WriteLine();    }} "
static bool isPrime(int n)        {            if (n <= 1) return false;            for (int i = 2; i * i <= n; i++)                            if (n % i == 0) return false;                        return true;        }
"using System; namespace PriorityQueue{    class Program    {        static void Main(string[] args)        {            PriorityQueue PQ =  PriorityQueue();            PQ.push(3, strv);            PQ.push(4, strv);            PQ.push(5, strv);            PQ.push(1, strv);            PQ.push(2, strv);             while (!PQ.Empty)            {                var Val = PQ.pop();                Console.WriteLine(Val[0] + strv + Val[1]);            }            Console.ReadKey();        }    }     class PriorityQueue    {        private System..SortedList PseudoQueue;         public bool Empty        {            get            {                return PseudoQueue.Count == 0;            }        }         public PriorityQueue()        {            PseudoQueue =  System..SortedList();        }         public void push(object Priority, object Value)        {            PseudoQueue.Add(Priority, Value);        }         public object[] pop()        {            object[] ReturnValue = { null, null };            if (PseudoQueue.Count > 0)            {                ReturnValue[0] = PseudoQueue.GetKey(0);                ReturnValue[1] = PseudoQueue.GetByIndex(0);                 PseudoQueue.RemoveAt(0);            }            return ReturnValue;        }    }}namespace PriorityQ {  using KeyT = UInt32;  using System;  using System.Collections.Generic;  using System.Linq;  class Tuple<K, V> { // for DotNet 3.5 without Tuple's    public K Item1; public V Item2;    public Tuple(K k, V v) { Item1 = k; Item2 = v; }    public override string ToString() {      return strv + Item1.ToString() + strv + Item2.ToString() + strv;    }  }  class MinHeapPQ<V> {    private struct HeapEntry {      public KeyT k; public V v;      public HeapEntry(KeyT k, V v) { this.k = k; this.v = v; }    }    private List<HeapEntry> pq;    private MinHeapPQ() { this.pq =  List<HeapEntry>(); }    private bool mt { get { return pq.Count == 0; } }    private int sz {      get {        var cnt = pq.Count;        return (cnt == 0) ? 0 : cnt - 1;      }    }    private Tuple<KeyT, V> pkmn {      get {        if (pq.Count == 0) return null;        else {          var mn = pq[0];          return  Tuple<KeyT, V>(mn.k, mn.v);        }      }    }    private void psh(KeyT k, V v) { // add extra very high item if none      if (pq.Count == 0) pq.Add( HeapEntry(UInt32.MaxValue, v));      var i = pq.Count; pq.Add(pq[i - 1]); // copy bottom item...      for (var ni = i >> 1; ni > 0; i >>= 1, ni >>= 1) {        var t = pq[ni - 1];        if (t.k > k) pq[i - 1] = t; else break;      }      pq[i - 1] =  HeapEntry(k, v);    }    private void siftdown(KeyT k, V v, int ndx) {      var cnt = pq.Count - 1; var i = ndx;      for (var ni = i + i + 1; ni < cnt; ni = ni + ni + 1) {        var oi = i; var lk = pq[ni].k; var rk = pq[ni + 1].k;        var nk = k;        if (k > lk) { i = ni; nk = lk; }        if (nk > rk) { ni += 1; i = ni; }        if (i != oi) pq[oi] = pq[i]; else break;      }      pq[i] =  HeapEntry(k, v);    }    private void rplcmin(KeyT k, V v) {      if (pq.Count > 1) siftdown(k, v, 0);    }    private void dltmin() {      var lsti = pq.Count - 2;      if (lsti <= 0) pq.Clear();      else {        var lkv = pq[lsti];        pq.RemoveAt(lsti); siftdown(lkv.k, lkv.v, 0);      }    }    private void reheap(int i) {      var lfti = i + i + 1;      if (lfti < sz) {        var rghti = lfti + 1; reheap(lfti); reheap(rghti);        var ckv = pq[i]; siftdown(ckv.k, ckv.v, i);      }    }    private void bld(IEnumerable<Tuple<KeyT, V>> sq) {      var sqm = from e in sq                select  HeapEntry(e.Item1, e.Item2);      pq = sqm.ToList<HeapEntry>();      var sz = pq.Count;      if (sz > 0) {        var lkv = pq[sz - 1];        pq.Add( HeapEntry(KeyT.MaxValue, lkv.v));        reheap(0);      }    }    private IEnumerable<Tuple<KeyT, V>> sq() {      return from e in pq             where e.k != KeyT.MaxValue             select  Tuple<KeyT, V>(e.k, e.v); }    private void adj(Func<KeyT, V, Tuple<KeyT, V>> f) {      var cnt = pq.Count - 1;      for (var i = 0; i < cnt; ++i) {        var e = pq[i];        var r = f(e.k, e.v);        pq[i] =  HeapEntry(r.Item1, r.Item2);      }      reheap(0);    }    public static MinHeapPQ<V> empty { get { return  MinHeapPQ<V>(); } }    public static bool isEmpty(MinHeapPQ<V> pq) { return pq.mt; }    public static int size(MinHeapPQ<V> pq) { return pq.sz; }    public static Tuple<KeyT, V> peekMin(MinHeapPQ<V> pq) { return pq.pkmn; }    public static MinHeapPQ<V> push(KeyT k, V v, MinHeapPQ<V> pq) {      pq.psh(k, v); return pq; }    public static MinHeapPQ<V> replaceMin(KeyT k, V v, MinHeapPQ<V> pq) {      pq.rplcmin(k, v); return pq; }    public static MinHeapPQ<V> deleteMin(MinHeapPQ<V> pq) { pq.dltmin(); return pq; }    public static MinHeapPQ<V> merge(MinHeapPQ<V> pq1, MinHeapPQ<V> pq2) {      return fromSeq(pq1.sq().Concat(pq2.sq())); }    public static MinHeapPQ<V> adjust(Func<KeyT, V, Tuple<KeyT, V>> f, MinHeapPQ<V> pq) {      pq.adj(f); return pq; }    public static MinHeapPQ<V> fromSeq(IEnumerable<Tuple<KeyT, V>> sq) {      var pq =  MinHeapPQ<V>(); pq.bld(sq); return pq; }    public static Tuple<Tuple<KeyT, V>, MinHeapPQ<V>> popMin(MinHeapPQ<V> pq) {      var rslt = pq.pkmn; if (rslt == null) return null;      pq.dltmin(); return  Tuple<Tuple<KeyT, V>, MinHeapPQ<V>>(rslt, pq); }    public static IEnumerable<Tuple<KeyT, V>> toSeq(MinHeapPQ<V> pq) {      for (; !pq.mt; pq.dltmin()) yield return pq.pkmn; }    public static IEnumerable<Tuple<KeyT, V>> sort(IEnumerable<Tuple<KeyT, V>> sq) {      return toSeq(fromSeq(sq)); }  }}    static void Main(string[] args) {      Tuple<uint, string>[] ins = {  Tuple<uint,string>(3u, strv),                                     Tuple<uint,string>(4u, strv),                                     Tuple<uint,string>(5u, strv),                                     Tuple<uint,string>(1u, strv),                                     Tuple<uint,string>(2u, strv) };       var spq = ins.Aggregate(MinHeapPQ<string>.empty, (pq, t) => MinHeapPQ<string>.push(t.Item1, t.Item2, pq));      foreach (var e in MinHeapPQ<string>.toSeq(spq)) Console.WriteLine(e); Console.WriteLine();       foreach (var e in MinHeapPQ<string>.sort(ins)) Console.WriteLine(e); Console.WriteLine();       var npq = MinHeapPQ<string>.fromSeq(ins);      foreach (var e in MinHeapPQ<string>.toSeq(MinHeapPQ<string>.merge(npq, npq)))        Console.WriteLine(e); Console.WriteLine();       var npq = MinHeapPQ<string>.fromSeq(ins);      foreach (var e in MinHeapPQ<string>.toSeq(MinHeapPQ<string>.merge(npq, npq)))        Console.WriteLine(e);       foreach (var e in MinHeapPQ<string>.toSeq(MinHeapPQ<string>.adjust((k, v) =>  Tuple<uint,string>(6u - k, v), npq)))        Console.WriteLine(e); Console.WriteLine();    }"
using System;using System.Collections.Generic; namespace PrimeDecomposition{    class Program    {        static void Main(string[] args)        {            GetPrimes(12);        }         static List<int> GetPrimes(decimal n)        {            List<int> storage =  List<int>();            while (n > 1)            {                int i = 1;                while (true)                {                    if (IsPrime(i))                    {                                                if (((decimal)n / i) == Math.Round((decimal) n / i))                        {                            n /= i;                            storage.Add(i);                                                        break;                        }                    }                    i++;                }            }            return storage;        }         static bool IsPrime(int n)        {            if (n <= 1) return false;            for (int i = 2; i <= Math.Sqrt(n); i++)                if (n % i == 0) return false;            return true;        }    }}using System.Collections.Generic; namespace PrimeDecomposition{	public class Primes	{ 		public List<int> FactorsOf(int n)		{			var factors =  List<int>(); 			for (var divisor = 2; n > 1; divisor++)				for (; n % divisor == 0; n /= divisor)					factors.Add(divisor); 			return factors;		}}
" using System;using System.Linq; namespace PopulationCount{    class Program    {        private static int PopulationCount(long n)        {            string binaryn = Convert.ToString(n, 2);            return binaryn.ToCharArray().Where(t => t == '1').Count();        }         static void Main(string[] args)        {            Console.WriteLine(strv);            Console.Write(strv);             int count = 0;             while (count < 30)            {                double n = Math.Pow(3f, (double)count);                int popCount = PopulationCount((long)n);                Console.Write(string.Format(strv, popCount));                count++;            }             Console.WriteLine();            Console.Write(strv);             count = 0;            int i = 0;             while (count < 30)            {                int popCount = PopulationCount(i);                 if (popCount % 2 == 0)                {                    count++;                    Console.Write(string.Format(strv, i));                }                 i++;            }             Console.WriteLine();            Console.Write(strv);             count = 0;            i = 0;             while (count < 30)            {                int popCount = PopulationCount(i);                 if (popCount % 2 != 0)                {                    count++;                    Console.Write(string.Format(strv, i));                }                 i++;            }             Console.ReadKey();        }    }} "
using System; class T{    public virtual string Name()    {        return strv;    }     public virtual T Clone()    {        return  T();    }} class S : T{    public override string Name()    {        return strv;    }     public override T Clone()    {        return  S();    }} class Program{    static void Main()    {        T original =  S();        T clone = original.Clone();         Console.WriteLine(original.Name());        Console.WriteLine(clone.Name());    }}
 static void Main(string[] args){	int p; 	p = 1;	Console.WriteLine(strv + p);	Value(ref p);	Console.WriteLine(strv + p); 	p = 1;	Console.WriteLine(strv + p);	Value(p);	Console.WriteLine(strv + p); 	Console.ReadLine();} private static void Value(ref int Value){	Value += 1;}private static void Value(int Value){	Value += 1;} 
using System;using System.Threading;using System.Media; class Program{    static void Main(string[] args)    {        //load sound file        SoundPlayer s1 =  SoundPlayer(); //        s1.SoundLocation = file; // or strv         //play        s1.Play();              //play for 0.1 seconds        s1.Play();        Thread.Sleep(100);        s1.Stop();         //loops        s1.PlayLooping();    }}
"namespace ConsoleApplication1{    class Program    {        static void Main(string[] args)        {            for (int x = 0; x < 10; x++)            {                Console.WriteLine(strv, ((double)x) / 10, SpecialRound(((double)x) / 10));            }             Console.WriteLine();             for (int x = 0; x < 10; x++)            {                Console.WriteLine(strv, ((double)x) / 10 + 0.05, SpecialRound(((double)x) / 10 + 0.05));            }             Console.WriteLine();            Console.WriteLine(strv, 1.01, SpecialRound(1.01));             Console.Read();        }         private static double SpecialRound(double inValue)        {            if (inValue > 1) return 1;             double[] Splitters =  double[] {                    0.00 , 0.06 , 0.11 , 0.16 , 0.21 ,                    0.26 , 0.31 , 0.36 , 0.41 , 0.46 ,                    0.51 , 0.56 , 0.61 , 0.66 , 0.71 ,                    0.76 , 0.81 , 0.86 , 0.91 , 0.96 };             double[] replacements =  double[] {                     0.10 , 0.18 , 0.26 , 0.32 , 0.38 ,                    0.44 , 0.50 , 0.54 , 0.58 , 0.62 ,                     0.66 , 0.70 , 0.74 , 0.78 , 0.82 ,                     0.86 , 0.90 , 0.94 , 0.98 , 1.00 };             for (int x = 0; x < Splitters.Length - 1; x++)            {                if (inValue >= Splitters[x] &&                    inValue < Splitters[x + 1])                {                    return replacements[x];                }            }             return inValue;        }    }}"
" public IEnumerable<IEnumerable<T>> GetPowerSet<T>(List<T> list){    return from m in Enumerable.Range(0, 1 << list.Count)                  select                      from i in Enumerable.Range(0, list.Count)                      where (m & (1 << i)) != 0                      select list[i];} public void PowerSetofColors(){    var colors =  List<KnownColor> { KnownColor.Red, KnownColor.Green,         KnownColor.Blue, KnownColor.Yellow };     var result = GetPowerSet(colors);     Console.Write( string.Join( Environment.NewLine,         result.Select(subset =>             string.Join(strv, subset.Select(clr => clr.ToString()).ToArray())).ToArray()));}     public IEnumerable<IEnumerable<T>> GetPowerSet<T>(IEnumerable<T> input) {    var seed =  List<IEnumerable<T>>() { Enumerable.Empty<T>() }      as IEnumerable<IEnumerable<T>>;     return input.Aggregate(seed, (a, b) =>      a.Concat(a.Select(x => x.Concat( List<T>() { b }))));  } "
" using System.Drawing; public class Pinstripe{    static void Main(string[] args)    {        var pinstripe = MakePinstripeImage(1366, 768);        pinstripe.Save(strv);    }     public static Bitmap MakePinstripeImage(int width, int height)    {        var image =  Bitmap(width, height);        var quarterHeight = height / 4;         for (var y = 0; y < height; y++)        {            var stripeWidth = (y / quarterHeight) + 1;             for (var x = 0; x < width; x++)            {                var color = ((x / stripeWidth) % 2) == 0 ? Color.White : Color.Black;                image.SetPixel(x, y, color);            }        }         return image;    }} "
"using System;class Point{  protected int x, y;  public Point() : this(0) {}  public Point(int x) : this(x,0) {}  public Point(int x, int y) { this.x = x; this.y = y; }  public int X { get { return x; } set { x = value; } }  public int Y { get { return y; } set { y = value; } }  public virtual void print() { System.Console.WriteLine(strv); }} public class Circle : Point{  private int r;  public Circle(Point p) : this(p,0) { }  public Circle(Point p, int r) : base(p) { this.r = r; }  public Circle() : this(0) { }  public Circle(int x) : this(x,0) { }  public Circle(int x, int y) : this(x,y,0) { }  public Circle(int x, int y, int r) : base(x,y) { this.r = r; }  public int R { get { return r; } set { r = value; } }  public override void print() { System.Console.WriteLine(strv); }   public static void main(String args[])  {    Point p =  Point();    Point c =  Circle();    p.print();    c.print();  }}"
" using System;using System.IO; namespace Pig { 	class Roll {		public int TotalScore{get;set;}		public int RollScore{get;set;}		public bool Continue{get;set;}	} 	class Player {		public String Name{get;set;}		public int Score {get;set;}		Random rand; 		public Player() {			Score = 0;			rand =  Random();		} 		public Roll Roll(int LastScore){			Roll roll =  Roll();			roll.RollScore = rand.Next(6) + 1; 			if(roll.RollScore == 1){				roll.TotalScore = 0;				roll.Continue = false;				return roll;			} 			roll.TotalScore = LastScore + roll.RollScore;			roll.Continue = true;			return roll;		} 		public void FinalizeTurn(Roll roll){			Score = Score + roll.TotalScore;		}	} 	public class Game {				public static void Main(String[] argv){			String input = null;			Player[] players =  Player[2]; 			// Game loop			while(true){												Console.Write(strv);				while(input == null){					input = Console.ReadLine();					if(input.ToLowerInvariant() == strv){						players[0] =  Player();						players[1] =  Player();						Console.Write(strv);						input = Console.ReadLine();						players[0].Name = input;						Console.Write(strv);						input = Console.ReadLine();						players[1].Name = input;						Console.WriteLine(players[0].Name + strv + players[1].Name + strv);					} else if (input.ToLowerInvariant() == strv){						goto Goodbye; /* Not considered harmful */					} else {						input = null;						Console.Write(strv);					}				} 				// Play the game				int currentPlayer = 0;				Roll roll = null;				bool runTurn = true;				while(runTurn){					Player p = players[currentPlayer];					roll = p.Roll( (roll !=null) ? roll.TotalScore : 0 );					if(roll.Continue){						if(roll.TotalScore + p.Score > 99){							Console.WriteLine(strv + p.Name + strv + roll.RollScore + strv + (roll.TotalScore + p.Score) + strv);							runTurn = false;						} else {							Console.Write(p.Name + strv + roll.RollScore + strv + roll.TotalScore + strv + (roll.TotalScore + p.Score) + strv);							input = Console.ReadLine();							if(input.ToLowerInvariant() == strv){								// Do nothing							} else if (input.ToLowerInvariant() == strv){								p.FinalizeTurn(roll);								currentPlayer = Math.Abs(currentPlayer - 1);											Console.WriteLine();							Console.WriteLine(players[0].Name + strv + players[0].Score + strv + players[1].Name + strv + players[1].Score);													Console.WriteLine(players[currentPlayer].Name + strv);								roll = null;							} else {								input = null;								Console.Write(strv);							}						}					} else {						Console.WriteLine(p.Name + @"", you rolled a 1 and lost your points for this turn.
Your current score:	"" + p.Score);						Console.WriteLine();						Console.WriteLine(players[0].Name + strv + players[0].Score + strv + players[1].Name + strv + players[1].Score);						currentPlayer = Math.Abs(currentPlayer - 1);					}				}  				input = null;			}			Goodbye:			Console.WriteLine(strv);			System.Environment.Exit(0);		}	}} "
"using System;using System.Collections.Generic; class RandomElementPicker {  static void Main() {    var list =  List<int>([]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});    var rng =  Random();    var randomElement = list[rng.Next(list.Count)];    Console.WriteLine(strv, randomElement);  }}"
"using System;using System.Linq;namespace ConsoleApplication{    class Program    {        static void Main(string[] args)        {            //Reverse() is an extension method on IEnumerable<char>.            //The constructor takes a char[], so we have to call ToArray()            Func<string, string> reverse = s =>  string(s.Reverse().ToArray());             string phrase = strv;            //Reverse the string            Console.WriteLine(reverse(phrase));            //Reverse each individual word in the string, maintaining original string order.            Console.WriteLine(string.Join(strv, phrase.Split(' ').Select(word => reverse(word))));            //Reverse the order of each word of the phrase, maintaining the order of characters in each word.            Console.WriteLine(string.Join(strv, phrase.Split(' ').Reverse()));        }    }}"
"using System;using System.Numerics; namespace PiCalc {    internal class Program {        private readonly BigInteger FOUR =  BigInteger(4);        private readonly BigInteger SEVEN =  BigInteger(7);        private readonly BigInteger TEN =  BigInteger(10);        private readonly BigInteger THREE =  BigInteger(3);        private readonly BigInteger TWO =  BigInteger(2);         private BigInteger k = BigInteger.One;        private BigInteger l =  BigInteger(3);        private BigInteger n =  BigInteger(3);        private BigInteger q = BigInteger.One;        private BigInteger r = BigInteger.Zero;        private BigInteger t = BigInteger.One;         public void CalcPiDigits() {            BigInteger nn, nr;            bool first = true;            while (true) {                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {                    Console.Write(n);                    if (first) {                        Console.Write(strv);                        first = false;                    }                    nr = TEN*(r - (n*t));                    n = TEN*(THREE*q + r)/t - (TEN*n);                    q *= TEN;                    r = nr;                } else {                    nr = (TWO*q + r)*l;                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);                    q *= k;                    t *= l;                    l += TWO;                    k += BigInteger.One;                    n = nn;                    r = nr;                }            }        }         private static void Main(string[] args) {             Program().CalcPiDigits();        }    }}using System;using System.Collections.Generic;using System.Linq;using System.Numerics; namespace EnumeratePi {  class Program {    private const int N = 60;    private const string ZS = strv;    static void Main() {      Console.WriteLine(strv);      Console.WriteLine( string('=', N + 13));       Console.WriteLine(strv, string.Concat(PiDigits(10).Take(N).Select(_ => _.ToString(strv))));      Console.WriteLine(strv, string.Concat(PiDigits(2).Take(N).Select(_ => _.ToString(strv))));      Console.WriteLine(strv, string.Concat(PiDigits(4).Take(N).Select(_ => _.ToString(strv))));      Console.WriteLine(strv, string.Concat(PiDigits(8).Take(N).Select(_ => _.ToString(strv))));      Console.WriteLine(strv, string.Concat(PiDigits(16).Take(N).Select(_ => _.ToString(strv))));      Console.WriteLine(strv, string.Concat(PiDigits(26).Take(N).Select(_ => (char) ('A' + _))));      Console.WriteLine(strv, string.Concat(PiDigits(ZS.Length).Take(N).Select(_ => ZS[(int)_])));       Console.WriteLine(strv, string.Concat(PiDigits(0x10).Take(N/2).Select(_ => string.Format(strv, _))));      Console.WriteLine(strv, string.Concat(PiDigits(0x100).Take(N/3).Select(_ => string.Format(strv, _))));      Console.WriteLine(strv, string.Concat(PiDigits(0x10000).Take(N/5).Select(_ => string.Format(strv, _))));      Console.WriteLine(strv, string.Concat(PiDigits(0x100000000).Take(N/9).Select(_ => string.Format(strv, _))));       Console.WriteLine( string('=', N + 13));      Console.WriteLine(strv);      Console.ReadKey();    }     
    
    
    static IEnumerable<long> PiDigits(long b = 10) {      BigInteger        k = 1,        l = 3,        n = 3,        q = 1,        r = 0,        t = 1        ;       // skip integer part      var nr = b * (r - t * n);      n = b * (3 * q + r) / t - b * n;      q *= b;      r = nr;       for (; ; ) {        var tn = t * n;        if (4 * q + r - t < tn) {          yield return (long)n;          nr = b * (r - tn);          n = b * (3 * q + r) / t - b * n;          q *= b;        } else {          t *= l;          nr = (2 * q + r) * l;          var nn = (q * (7 * k) + 2 + r * l) / t;          q *= k;          l += 2;          ++k;          n = nn;        }        r = nr;      }    }  }}"
"using System;using System.Linq; namespace PerniciousNumbers{    class Program    {        public static int PopulationCount(long n)        {            int cnt = 0;            do            {                if ((n & 1) != 0)                 {                    cnt++;                }            } while ((n >>= 1) > 0);             return cnt;        }          public static bool isPrime(int x)        {            if (x <= 2 || (x & 1) == 0)            {                return x == 2;            }             var limit = Math.Sqrt(x);            for (int i = 3; i <= limit; i += 2)            {                if (x % i == 0)                {                    return false;                }            }             return true;        }         private static IEnumerable<int> Pernicious(int start, int count, int take)        {            return Enumerable.Range(start, count).Where(n => isPrime(PopulationCount(n))).Take(take);        }         static void Main(string[] args)        {            foreach (var n in Pernicious(0, int.MaxValue, 25))            {                Console.Write(strv, n);            }             Console.WriteLine();             foreach (var n in Pernicious(888888877, 11, 11))            {                Console.Write(strv, n);            }             Console.ReadKey();        }    }}"
"using System;using System.Drawing; class Program{    static void Main()    {        Bitmap img1 =  Bitmap(strv);        Bitmap img2 =  Bitmap(strv);         if (img1.Size != img2.Size)        {            Console.Error.WriteLine(strv);            return;        }         float diff = 0;         for (int y = 0; y < img1.Height; y++)        {            for (int x = 0; x < img1.Width; x++)            {                diff += (float)Math.Abs(img1.GetPixel(x, y).R - img2.GetPixel(x, y).R) / 255;                diff += (float)Math.Abs(img1.GetPixel(x, y).G - img2.GetPixel(x, y).G) / 255;                diff += (float)Math.Abs(img1.GetPixel(x, y).B - img2.GetPixel(x, y).B) / 255;            }        }         Console.WriteLine(strv, 100 * diff / (img1.Width * img1.Height * 3));    }}"
"static void Main(string[] args){	Console.WriteLine(strv); 	for (int x = 0; x < 33550337; x++)	{		if (IsPerfect(x))			Console.WriteLine(x + strv);	} 	Console.ReadLine();} static bool IsPerfect(int num) {	int sum = 0;	for (int i = 1; i < num; i++)	{		if (num % i == 0)			sum += i;	} 	return sum == num ;}static void Main(string[] args){	Console.WriteLine(strv); 	for (int x = 0; x < 33550337; x++)	{		if (IsPerfect(x))			Console.WriteLine(x + strv);	} 	Console.ReadLine();} static bool IsPerfect(int num) {	return Enumerable.Range(1, num - 1).Sum(n => num % n == 0 ? n : 0 ) == num;}"
"public class Permutations<T>{    public static System..Generic.IEnumerable<T[]> AllFor(T[] array)    {        if (array == null || array.Length == 0)        {            yield return  T[0];        }        else        {            for (int pick = 0; pick < array.Length; ++pick)            {                T item = array[pick];                int i = -1;                T[] rest = System.Array.FindAll<T>(                    array, delegate(T p) { return ++i != pick; }                );                foreach (T[] restPermuted in AllFor(rest))                {                    i = -1;                    yield return System.Array.ConvertAll<T, T>(                        array,                        delegate(T p) {                            return ++i == 0 ? item : restPermuted[i - 1];                        }                    );                }            }        }    }}namespace Permutations_On_RosettaCode{    class Program    {        static void Main(string[] args)        {            string[] list = strv.Split();            foreach (string[] permutation in Permutations<string>.AllFor(list))            {                System.Console.WriteLine(string.Join(strv, permutation));            }        }    }}"
"using System;using System.Linq; class Program{    const string Lower = strv;    const string Upper = strv;    const string Digits = strv;    const string Symbols = ""!#$%&'()*+,-./:;<=>?@[]^_{|}~"";    static readonly string[] Full = {Lower, Upper, Digits, Symbols, Lower + Upper + Digits + Symbols};     const string Similar = strv;    static readonly string[] Excluded = Full.Select(x =>  string(x.Except(Similar).ToArray())).ToArray();     static Random _rng =  Random();    static string[] _symbolSet = Full;     static void Main(string[] args)    {        int length = 12, count = 1;        try        {            foreach (var x in args.Select(arg => arg.Split(':')))            {                switch (x[0])                {                    case strv: length = int.Parse(x[1]); break;                    case strv: count = int.Parse(x[1]); break;                    case strv: _rng =  Random(x[1].GetHashCode()); break;                    case strv: _symbolSet = bool.Parse(x[1]) ? Excluded : Full; break;                    default: throw  FormatException(strv);                }            }        }        catch { ShowUsage(); return; }        try        {            for (int i = 0; i < count; i++)                Console.WriteLine(GeneratePass(length));        }        catch (Exception ex) { Console.WriteLine(strv + ex.Message); }    }     static void ShowUsage()    {        Console.WriteLine(strv);        Console.WriteLine(""-l: the length of the generated passwords"");        Console.WriteLine(""-c: the number of passwords to generate"");        Console.WriteLine(""-s: seed for the random number generator"");        Console.WriteLine(""-x: exclude similar characters: "" + Similar);        Console.WriteLine(""Example: PASSGEN -l:10 -c:5 -s:Sample Seed -x:true"");    }     static string GeneratePass(int length)    {        var minLength = _symbolSet.Length - 1;        if(length < minLength)            throw  Exception(strv + minLength + strv);         int[] usesRemaining = Enumerable.Repeat(1, _symbolSet.Length).ToArray();        usesRemaining[minLength] = length - minLength;        var password =  char[length];        for (int ii = 0; ii < length; ii++)        {            int set = _rng.Next(0, _symbolSet.Length);            if (usesRemaining[set] > 0)            {                usesRemaining[set]--;                password[ii] = _symbolSet[set][_rng.Next(0, _symbolSet[set].Length)];            }            else ii--;        }        return  string(password);    }}"
"using System;using System.Linq;using System.Collections.Generic; public struct Card{    public Card(string rank, string suit) : this()    {        Rank = rank;        Suit = suit;    }     public string Rank { get; }    public string Suit { get; }     public override string ToString() => $strv;} public class Deck : IEnumerable<Card>{    static readonly string[] ranks = { strv, strv, strv, strv, strv,        strv, strv, strv, strv, strv, strv, strv, strv };    static readonly string[] suits = { strv, strv, strv, strv };    readonly List<Card> cards;     public Deck() {        cards = (from suit in suits                from rank in ranks                select  Card(rank, suit)).ToList();    }     public int Count => cards.Count;     public void Shuffle() {        // using Knuth Shuffle (see at http://rosettacode.org/wiki/Knuth_shuffle)        var random =  Random();        for (int i = 0; i < cards.Count; i++) {            int r = random.Next(i, cards.Count);            var temp = cards[i];            cards[i] = cards[r];            cards[r] = temp;        }    }     public Card Deal() {        int last = cards.Count - 1;        Card card = cards[last];        //Removing from the front will shift the other items back 1 spot,        //so that would be an O(n) operation. Removing from the back is O(1).        cards.RemoveAt(last);        return card;    }     public IEnumerator<Card> GetEnumerator() {        //Reverse enumeration of the list so that they are returned in the order they would be dealt.        //LINQ's Reverse() copies the entire list. Let's avoid that.        for (int i = cards.Count - 1; i >= 0; i--)            yield return cards[i];    }     System..IEnumerator System..IEnumerable.GetEnumerator() => GetEnumerator();}"
"using System;using System.Collections.Generic;using System.Linq; class PartialFunctionApplication{    static Func<T1, TResult> PartiallyApply<T1, T2, TResult>(Func<T1, T2, TResult> function, T2 argument2)    {        return argument1 => function(argument1, argument2);    }     static void Main()    {        var fs = (Func<IEnumerable<int>, Func<int, int>, IEnumerable<int>>)Enumerable.Select;        var f1 = (Func<int, int>)(n => n * 2);        var f2 = (Func<int, int>)(n => n * n);        var fsf1 = PartiallyApply(fs, f1);        var fsf2 = PartiallyApply(fs, f2);         var s = [] { 0, 1, 2, 3 };        Console.WriteLine(string.Join(strv, fsf1(s)));        Console.WriteLine(string.Join(strv, fsf2(s)));         s = [] { 2, 4, 6, 8 };        Console.WriteLine(string.Join(strv, fsf1(s)));        Console.WriteLine(string.Join(strv, fsf2(s)));    }}"
" using System.Data.Sql;using System.Data.SqlClient; namespace ConsoleApplication1{    class Program    {        static void Main(string[] args)        {            SqlConnection tConn =  SqlConnection(strv);             SqlCommand tCommand =  SqlCommand();            tCommand.Connection = tConn;            tCommand.CommandText = strv;             tCommand.Parameters.Add( SqlParameter(strv, System..SqlDbType.VarChar).Value = strv);            tCommand.Parameters.Add( SqlParameter(strv, System..SqlDbType.Int).Value = strv);            tCommand.Parameters.Add( SqlParameter(strv, System..SqlDbType.Bit).Value = true);            tCommand.Parameters.Add( SqlParameter(strv, System..SqlDbType.Int).Value = strv);             tCommand.ExecuteNonQuery();        }    }} "
"namespace RosettaCode {    class BinaryTree<T> {        public T value;        public BinaryTree<T> left;        public BinaryTree<T> right;         public BinaryTree(T value) {            this.value = value;        }         public BinaryTree<U> Map<U>(Func<T,U> f) {            BinaryTree<U> Tree =  BinaryTree<U>(f(this.value));            if (left != null) {                Tree.left = left.Map(f);            }            if (right != null) {                Tree.right = right.Map(f);            }                  return Tree;        }    }}namespace RosettaCode {    class Program {        static void Main(string[] args) {            BinaryTree<int> b =  BinaryTree<int>(6);            b.left =  BinaryTree<int>(5);            b.right =  BinaryTree<int>(7);            BinaryTree<double> b2 = b.Map(x => x * 10.0);        }    }}"
"using System;using System.Linq;using System.Text;using System.Threading.Tasks; class Program{    static void Main(string[] args)    {        Parallel.For(0, 26, a => {            byte[] password =  byte[5];            byte[] hash;            byte[] one = StringHashToByteArray(strv);            byte[] two = StringHashToByteArray(strv);            byte[] three = StringHashToByteArray(strv);            password[0] = (byte)(97 + a);            var sha = System..SHA256.Create();            for (password[1] = 97; password[1] < 123; password[1]++)                for (password[2] = 97; password[2] < 123; password[2]++)                    for (password[3] = 97; password[3] < 123; password[3]++)                        for (password[4] = 97; password[4] < 123; password[4]++)                        {                            hash = sha.ComputeHash(password);                            if (matches(one, hash) || matches(two, hash) || matches(three, hash))                                Console.WriteLine(Encoding.ASCII.GetString(password) + strv                                    + BitConverter.ToString(hash).ToLower().Replace(strv, strv));                        }        });    }    static byte[] StringHashToByteArray(string s)    {        return Enumerable.Range(0, s.Length / 2).Select(i => (byte)Convert.ToInt16(s.Substring(i * 2, 2), 16)).ToArray();    }    static bool matches(byte[] a, byte[] b)    {        for (int i = 0; i < 32; i++)            if (a[i] != b[i])                return false;        return true;    }}"
"using System;using System.Collections.Generic;using System.Linq; class Program{    public static List<int> PrimeFactors(int number)    {        var primes =  List<int>();        for (int div = 2; div <= number; div++)        {            while (number % div == 0)            {                primes.Add(div);                number = number / div;            }        }        return primes;    }     static void Main(string[] args)    {        int[] n = { 12757923, 12878611, 12757923, 15808973, 15780709, 197622519 };        // Calculate each of those numbers' prime factors, in parallel        var factors = n.AsParallel().Select(PrimeFactors).ToList();        // Make a new list showing the smallest factor for each        var smallestFactors = factors.Select(thisNumbersFactors => thisNumbersFactors.Min()).ToList();        // Find the index that corresponds with the largest of those factors        int biggestFactor = smallestFactors.Max();        int whatIndexIsThat = smallestFactors.IndexOf(biggestFactor);        Console.WriteLine(strv, n[whatIndexIsThat], biggestFactor);        Console.WriteLine(string.Join(strv, factors[whatIndexIsThat]));    }}using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks; private static void Main(string[] args){  int j = 0, m = 0;  decimal[] n = {12757923, 12878611, 12757923, 15808973, 15780709, 197622519};  var l =  List<int>[n.Length];   Parallel.For(0, n.Length, i => { l[i] = getPrimes(n[i]); });   for (int i = 0; i<n.Length; i++)    if (l[i].Min()>m)    {      m = l[i].Min();      j = i;    }   Console.WriteLine(strv, n[j]);  foreach (int list in l[j])    Console.Write(strv+list);}"
"using System; namespace RosettaCode {     class PascalsTriangle {         public static void CreateTriangle(int n) {            if (n > 0) {                for (int i = 0; i < n; i++) {                    int c = 1;                    Console.Write(strv.PadLeft(2 * (n - 1 - i)));                    for (int k = 0; k <= i; k++) {                        Console.Write(strv, c.ToString().PadLeft(3));                        c = c * (i - k) / (k + 1);                    }                    Console.WriteLine();                }            }        }         public static void Main() {            CreateTriangle(8);        }    }}"
"using System;using System.Linq; static class Program{    static bool IsPangram(this string text, string alphabet = strv)    {        return alphabet.All(text.ToLower().Contains);    }     static void Main(string[] arguments)    {        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());    }}using System; namespace PangrammChecker{    public class PangrammChecker    {        public static bool IsPangram(string str)        {            bool[] isUsed =  bool[26];            int ai = (int)'a';            int total = 0;            for (CharEnumerator en = str.ToLower().GetEnumerator(); en.MoveNext(); )            {                int d = (int)en.Current - ai;                if (d >= 0 && d < 26)                    if (!isUsed[d])                    {                        isUsed[d] = true;                        total++;                    }            }            return (total == 26);        }    }     class Program    {        static void Main(string[] args)        {            string str1 = strv;            string str2 = strv;            Console.WriteLine(strv, str1,                PangrammChecker.IsPangram(str1)?strv:strv);            Console.WriteLine(strv, str2,                PangrammChecker.IsPangram(str2)?strv:strv);            Console.WriteLine(strv);            Console.ReadLine();        }    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Globalization;using System.Threading; namespace RPNEvaluator{    class RPNEvaluator    {        static void Main(string[] args)        {            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;             string rpn = strv;            Console.WriteLine(""{0}"", rpn);             decimal result = CalculateRPN(rpn);            Console.WriteLine(""Result is {0}"", result);        }         static decimal CalculateRPN(string rpn)        {            string[] rpnTokens = rpn.Split(' ');            Stack<decimal> stack =  Stack<decimal>();            decimal number = decimal.Zero;             foreach (string token in rpnTokens)            {                if (decimal.TryParse(token, out number))                {                    stack.Push(number);                }                else                {                    switch (token)                    {                        case strv:                        case strv:                            {                                number = stack.Pop();                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));                                break;                            }                        case strv:                            {                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));                                break;                            }                        case strv:                            {                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));                                break;                            }                        case strv:                            {                                stack.Push(stack.Pop() * stack.Pop());                                break;                            }                        case strv:                            {                                number = stack.Pop();                                stack.Push(stack.Pop() / number);                                break;                            }                        case strv:                            {                                stack.Push(stack.Pop() + stack.Pop());                                break;                            }                        case strv:                            {                                number = stack.Pop();                                stack.Push(stack.Pop() - number);                                break;                            }                        default:                            Console.WriteLine(strv);                            break;                    }                }                PrintState(stack);            }             return stack.Pop();        }         static void PrintState(Stack<decimal> stack)        {            decimal[] arr = stack.ToArray();             for (int i = arr.Length - 1; i >= 0; i--)            {                Console.Write(strv, arr[i]);            }             Console.WriteLine();        }    }}"
"using System;using System.Linq;using System.Net; static class Program{    static void Main(string[] args)    {        WebClient client =  WebClient();        string text = client.DownloadString(strv);        string[] words = text.Split( char[] { '', '' }, StringSplitOptions.RemoveEmptyEntries);         var query = from w in words                    where IsOrderedWord(w)                    group w by w.Length into ows                    orderby ows.Key descending                    select ows;         Console.WriteLine(string.Join(strv, query.First().ToArray()));    }     private static bool IsOrderedWord(string w)    {        for (int i = 1; i < w.Length; i++)            if (w[i] < w[i - 1])                return false;         return true;    }}"
"using System; class Program{    static string Reverse(string value)    {        char[] chars = value.ToCharArray();        Array.Reverse(chars);        return  string(chars);    }     static bool IsPalindrome(string value)    {        return value == Reverse(value);    }     static void Main(string[] args)    {        Console.WriteLine(IsPalindrome(strv));    }}using System;using System.Linq; class Program{	static bool IsPalindrome(string text)	{		return text ==  String(text.Reverse().ToArray());	} 	static void Main(string[] args)	{		Console.WriteLine(IsPalindrome(strv));	}} using System; static class Program{    //As an extension method (must be declared in a static class)    static bool IsPalindrome(this string sentence)    {        for (int l = 0, r = sentence.Length - 1; l < r; l++, r--)            if (sentence[l] != sentence[r]) return false;        return true;    }     static void Main(string[] args)    {        Console.WriteLine(strv.IsPalindrome());    }}"
"namespace RosettaCode.OrderTwoNumericalLists{    using System;    using System.Collections.Generic;     internal static class Program    {        private static bool IsLessThan(this IEnumerable<int> enumerable,            IEnumerable<int> otherEnumerable)        {            using (                IEnumerator<int> enumerator = enumerable.GetEnumerator(),                    otherEnumerator = otherEnumerable.GetEnumerator())            {                while (true)                {                    if (!otherEnumerator.MoveNext())                    {                        return false;                    }                     if (!enumerator.MoveNext())                    {                        return true;                    }                     if (enumerator.Current == otherEnumerator.Current)                    {                        continue;                    }                     return enumerator.Current < otherEnumerator.Current;                }            }        }         private static void Main()        {            Console.WriteLine(                [] {1, 2, 1, 3, 2}.IsLessThan([] {1, 2, 0, 4, 4, 0, 0, 0}));        }    }}"
"using OpenTK;using OpenTK.Graphics;namespace OpenGLTest{    class Program    {        static void Main(string[] args)        {            //Create the OpenGL window            GameWindow window =  GameWindow(640, 480, GraphicsMode.Default, strv);             GL.MatrixMode(MatrixMode.Projection);            GL.LoadIdentity();            GL.Ortho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0);            GL.MatrixMode(MatrixMode.Modelview);             //Add event handler to render to the window when called            window.RenderFrame +=  RenderFrameEvent(a_RenderFrame);            //Starts the window's updating/rendering events            window.Run();        }        static void a_RenderFrame(GameWindow sender, RenderFrameEventArgs e)        {            GL.ClearColor(0.3f, 0.3f, 0.3f, 0f);            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);             GL.ShadeModel(ShadingModel.Smooth);             GL.LoadIdentity();            GL.Translate(-15.0f, -15.0f, 0.0f);             GL.Begin(BeginMode.Triangles);            GL.Color3(1.0f, 0.0f, 0.0f);            GL.Vertex2(0.0f, 0.0f);            GL.Color3(0.0f, 1.0f, 0.0f);            GL.Vertex2(30f, 0.0f);            GL.Color3(0.0f, 0.0f, 1.0f);            GL.Vertex2(0.0f, 30.0f);            GL.End();            //Swaps the buffers on the window so that what we draw becomes visible            sender.SwapBuffers();        }    }}"
"using System; namespace OldLady{    internal class Program    {        private const string reason = strv;        private static readonly string[] creatures = {strv, strv, strv, strv, strv, strv, strv, strv};         private static readonly string[] comments =        {            ""I don't know why she swallowed that fly.Perhaps she'll die"",            strv,            strv,            strv,            strv,            strv,            strv,            strv        };         private static void Main()        {            int max = creatures.Length;            for (int i = 0; i < max; i++)            {                Console.WriteLine(strv, creatures[i]);                Console.WriteLine(comments[i]);                for (int j = i; j > 0 && i < max - 1; j--)                {                    Console.WriteLine(reason, creatures[j], creatures[j - 1]);                    if (j == 1)                    {                        Console.WriteLine(comments[j - 1]);                    }                }            }            Console.Read();        }    }}"
"     class Program    {        private static Random rnd =  Random();        public static int one_of_n(int n)        {            int currentChoice = 1;            for (int i = 2; i <= n; i++)            {                double outerLimit = 1D / (double)i;                if (rnd.NextDouble() < outerLimit)                    currentChoice = i;            }            return currentChoice;        }         static void Main(string[] args)        {            Dictionary<int, int> results =  Dictionary<int, int>();            for (int i = 1; i < 11; i++)                results.Add(i, 0);             for (int i = 0; i < 1000000; i++)            {                int result = one_of_n(10);                results[result] = results[result] + 1;            }             for (int i = 1; i < 11; i++)                Console.WriteLine(""{0}{1}"", i, results[i]);            Console.ReadLine();        }    } "
"using System;using System.IO;using System.Collections.Generic;using System.Runtime.Serialization.Formatters.Binary; namespace Object_serialization{  [Serializable] public class Being  {    public bool Alive { get; set; }  }   [Serializable] public class Animal: Being  {    public Animal() { }     public Animal(long id, string name, bool alive = true)    {      Id = id;      Name = name;      Alive = alive;    }     public long Id { get; set; }    public string Name { get; set; }     public void Print() { Console.WriteLine(strv,      Name, Id, Alive ? strv : strv); }  }    internal class Program  {    private static void Main()    {      string path =         Environment.GetFolderPath(Environment.SpecialFolder.Desktop)+""objects.dat"";       var n =  List<Animal>              {                 Animal(1, strv),                 Animal(2, strv),                 Animal(7, strv),                 Animal(3, strv, alive: false)              };       foreach(Animal animal in n)        animal.Print();       using(var stream =  FileStream(path, FileMode.Create, FileAccess.Write))         BinaryFormatter().Serialize(stream, n);       n.Clear();      Console.WriteLine(strv);      List<Animal> m;       using(var stream =  FileStream(path, FileMode.Open, FileAccess.Read))        m = (List<Animal>)  BinaryFormatter().Deserialize(stream);       foreach(Animal animal in m)        animal.Print();    }  }}"
"using System;using System.Collections.Generic; namespace prog{	class MainClass	{			const int n_iter = 10;		static int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 }; 		public static void Main (string[] args)		{			for( int i=0; i<f.Length; i++ )				Console.Write( f[i]==0 ? strv : strv );			Console.WriteLine(strv);			 			int[] g =  int[f.Length];			for( int n=n_iter; n!=0; n-- )			{				for( int i=1; i<f.Length-1; i++ )				{					if ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];					else if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;					else g[i] = 0;				}				g[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;				g[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0; 				int[] tmp = f;				f = g;				g = tmp; 				for( int i=0; i<f.Length; i++ )					Console.Write( f[i]==0 ? strv : strv );				Console.WriteLine(strv);			}					}	}}"
"using System;using System.Linq; class Program{    static void Main(string[] args)    {        var r =  Random();         var tries = 1;        var sorted = Enumerable.Range(1, 9).ToList();        var values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();         while (Enumerable.SequenceEqual(sorted, values)) {            values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();        }         //values = strv.Split().Select(x => int.Parse(x)).ToList();         while (!Enumerable.SequenceEqual(sorted, values))        {            Console.Write(strv, tries, String.Join(strv, values));             values.Reverse(0, int.Parse(Console.ReadLine()));            tries += 1;        }         Console.WriteLine(""You took {0} attempts to put the digits in order!"", tries - 1);        Console.ReadLine();    }}class Program{	static void Main(string[] args)	{		int[] values =  int[9];		Random tRandom =  Random();		int tries = 0; 		for (int x = 0; x < values.Length; x++)		{			values[x] = x + 1;		} 		values = RandomPermutation<int>(values); 		do		{			Console.Write(strv);			for (int x = 0; x < values.Length; x++)			{				Console.Write(strv);				Console.Write(values[x]);			}			Console.WriteLine(strv); 			string tIn = strv;			do			{				tIn = Console.ReadLine();			} while (tIn.Length != 1); 			int nums = Convert.ToInt32(tIn.ToString()); 			int[] newValues =  int[9];			for (int x = nums; x < newValues.Length; x++)			{				// Move those not reversing				newValues[x] = values[x];			}			for (int x = 0; x < nums; x++)			{				// Reverse the rest				newValues[x] = values[nums - 1 - x];			}			values = newValues;			tries++;		} while (!check(values)); 		Console.WriteLine(strv);		Console.WriteLine(strv + tries); 		Console.Read();	} 	public static bool check(int[] p) 	{		// Check all items		for (int x = 0; x < p.Length - 1; x++)		{			if (p[x + 1] <= p[x])				return false;		} 		return true;	} 	public static T[] RandomPermutation<T>(T[] array)	{		T[] retArray =  T[array.Length];		array.CopyTo(retArray, 0); 		Random random =  Random();		for (int i = 0; i < array.Length; i += 1)		{			int swapIndex = random.Next(i, array.Length);			if (swapIndex != i)			{				T temp = retArray[i];				retArray[i] = retArray[swapIndex];				retArray[swapIndex] = temp;			}		} 		return retArray;	}}"
"using System;using System.Collections.Generic;using System.Linq; public class Interval{    public Interval(double leftEndpoint, double size)    {        LeftEndpoint = leftEndpoint;        RightEndpoint = leftEndpoint + size;    }     public double LeftEndpoint    {        get;        set;    }     public double RightEndpoint    {        get;        set;    }     public double Size    {        get        {            return RightEndpoint - LeftEndpoint;        }    }     public double Center    {        get        {            return (LeftEndpoint + RightEndpoint) / 2;        }    }     public IEnumerable<Interval> Subdivide(int subintervalCount)    {        double subintervalSize = Size / subintervalCount;        return Enumerable.Range(0, subintervalCount).Select(index =>  Interval(LeftEndpoint + index * subintervalSize, subintervalSize));    }} public class DefiniteIntegral{    public DefiniteIntegral(Func<double, double> integrand, Interval domain)    {        Integrand = integrand;        Domain = domain;    }     public Func<double, double> Integrand    {        get;        set;    }     public Interval Domain    {        get;        set;    }     public double SampleIntegrand(ApproximationMethod approximationMethod, Interval subdomain)    {        switch (approximationMethod)        {            case ApproximationMethod.RectangleLeft:                return Integrand(subdomain.LeftEndpoint);            case ApproximationMethod.RectangleMidpoint:                return Integrand(subdomain.Center);            case ApproximationMethod.RectangleRight:                return Integrand(subdomain.RightEndpoint);            case ApproximationMethod.Trapezium:                return (Integrand(subdomain.LeftEndpoint) + Integrand(subdomain.RightEndpoint)) / 2;            case ApproximationMethod.Simpson:                return (Integrand(subdomain.LeftEndpoint) + 4 * Integrand(subdomain.Center) + Integrand(subdomain.RightEndpoint)) / 6;            default:                throw  NotImplementedException();        }    }     public double Approximate(ApproximationMethod approximationMethod, int subdomainCount)    {        return Domain.Size * Domain.Subdivide(subdomainCount).Sum(subdomain => SampleIntegrand(approximationMethod, subdomain)) / subdomainCount;    }     public enum ApproximationMethod    {        RectangleLeft,        RectangleMidpoint,        RectangleRight,        Trapezium,        Simpson    }} public class Program{    private static void TestApproximationMethods(DefiniteIntegral integral, int subdomainCount)    {        foreach (DefiniteIntegral.ApproximationMethod approximationMethod in Enum.GetValues((DefiniteIntegral.ApproximationMethod)))        {            Console.WriteLine(integral.Approximate(approximationMethod, subdomainCount));        }    }     public static void Main()    {        TestApproximationMethods( DefiniteIntegral(x => x * x * x,  Interval(0, 1)), 10000);        TestApproximationMethods( DefiniteIntegral(x => 1 / x,  Interval(1, 99)), 1000);        TestApproximationMethods( DefiniteIntegral(x => x,  Interval(0, 5000)), 500000);        TestApproximationMethods( DefiniteIntegral(x => x,  Interval(0, 6000)), 6000000);    }}"
"if (foo == null)    Console.WriteLine(strv);int? x = 12;x = null;Console.WriteLine(name ?? strv); //Without the null coalescing operator, this would instead be written as://if(name == null){//	Console.WriteLine(strv);//}else{//	Console.WriteLine(name);//}"
"using System; class NumberNamer {    static readonly string[] incrementsOfOne =            { strv,    strv,     strv,       strv,    strv,              strv,    strv,     strv,     strv,    strv,              strv,     strv,  strv,    strv, strv,              strv, strv, strv, strv, strv };     static readonly string[] incrementsOfTen =            { strv,      strv,      strv,  strv, strv,              strv, strv, strv, strv, strv };     const string millionName = strv,                 thousandName = strv,                 hundredName = strv,                 andName = strv;      public static string GetName( int i ) {        string output = strv;        if( i >= 1000000 ) {            output += ParseTriplet( i / 1000000 ) + strv + millionName;            i %= 1000000;            if( i == 0 ) return output;        }         if( i >= 1000 ) {            if( output.Length > 0 ) {                output += strv;            }            output += ParseTriplet( i / 1000 ) + strv + thousandName;            i %= 1000;            if( i == 0 ) return output;        }         if( output.Length > 0 ) {            output += strv;        }        output += ParseTriplet( i );        return output;    }      static string ParseTriplet( int i ) {        string output = strv;        if( i >= 100 ) {            output += incrementsOfOne[i / 100] + strv + hundredName;            i %= 100;            if( i == 0 ) return output;        }         if( output.Length > 0 ) {            output += strv + andName + strv;        }        if( i >= 20 ) {            output += incrementsOfTen[i / 10];            i %= 10;            if( i == 0 ) return output;        }         if( output.Length > 0 ) {            output += strv;        }        output += incrementsOfOne[i];        return output;    }}  class Program { // Test class    static void Main( string[] args ) {        Console.WriteLine( NumberNamer.GetName( 1 ) );        Console.WriteLine( NumberNamer.GetName( 234 ) );        Console.WriteLine( NumberNamer.GetName( 31337 ) );        Console.WriteLine( NumberNamer.GetName( 987654321 ) );    }} "
" using System; namespace NonDecimalRadicesOutput{    class Program    {        static void Main(string[] args)        {            for (int i = 0; i < 42; i++)            {                string binary = Convert.ToString(i, 2);                string octal = Convert.ToString(i, 8);                string hexadecimal = Convert.ToString(i, 16);                Console.WriteLine(string.Format(strv, i, binary, octal, hexadecimal));            }             Console.ReadKey();        }    }} "
" static void Main(string[] args){	Console.WriteLine(NthRoot(81,2,.001));        Console.WriteLine(NthRoot(1000,3,.001));        Console.ReadLine();} public static double NthRoot(double A,int n,  double p){	double _n= (double) n;	double[] x =  double[2];			x[0] = A;	x[1] = A/_n;	while(Math.Abs(x[0] -x[1] ) > p)	{		x[1] = x[0];		x[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1))); 	}	return x[0];} "
"using System; class Program{    static void Main()    {        var value = strv;        var fromBases = [] { 2, 8, 10, 16 };        var toBase = 10;        foreach (var fromBase in fromBases)        {            Console.WriteLine(strv,                value, fromBase, Convert.ToInt32(value, fromBase), toBase);        }    }}"
" public static class BaseConverter {     
    
    
    
    
    
    public static long stringToLong(string s, int b) {         if ( b < 2 || b > 36 )            throw  ArgumentException(strv, strv);          {             int slen = s.Length;            long result = 0;            bool isNegative = false;             for ( int i = 0; i < slen; i++ ) {                 char c = s[i];                int num;                 if ( c == '-' ) {                    // Negative sign                    if ( i != 0 )                        throw  ArgumentException(strv, strv);                     isNegative = true;                    continue;                }                 if ( c > 0x2F && c < 0x3A )                    // Numeric character (subtract from 0x30 ('0') to get numerical value)                    num = c - 0x30;                else if ( c > 0x40 && c < 0x5B )                    // Uppercase letter                    // Subtract from 0x41 ('A'), then add 10                    num = c - 0x37;  // 0x37 = 0x41 - 10                else if ( c > 0x60 && c < 0x7B )                    // Lowercase letter                    // Subtract from 0x61 ('a'), then add 10                    num = c - 0x57;  // 0x57 = 0x61 - 10                else                    throw  ArgumentException(strv + c + strv, strv);                 // Check that the digit is allowed by the base.                 if ( num >= b )                    throw  ArgumentException(strv + c + strv + b, strv);                 // Multiply the result by the base, then add the next digit                 result *= b;                result += num;             }             if ( isNegative )                result = -result;             return result;         }     }     
    
    
    
    
    
    public static string longToString(long n, int b) {         // This uses StringBuilder, so it only works with .NET 4.0 or higher. For earlier versions, the StringBuilder        // can be replaced with simple string concatenation.         if ( b < 2 || b > 36 )            throw  ArgumentException(strv, strv);         // If the base is 10, call ToString() directly, which returns a base-10 string.         if ( b == 10 )            return n.ToString();          {            long longBase = b;             StringBuilder sb =  StringBuilder();             if ( n < 0 ) {                // Negative numbers                n = -n;                sb.Append('-');            }             long div = 1;            while ( n / div >= b )                // Continue multiplying the dividend by the base until it reaches the greatest power of                // the base which is less than or equal to the number.                div *= b;             while ( true ) {                byte digit = (byte) (n / div);                 if ( digit < 10 )                    // Numeric character (0x30 = '0')                    sb.Append((char) (digit + 0x30));                else                    // Alphabetic character (for digits > 10) (0x61 = 'a')                    sb.Append((char) (digit + 0x57));  // 0x61 - 10                 if ( div == 1 )                    // Stop when the dividend reaches 1                    break;                 n %= div;                div /= b;            }             return sb.ToString();        }     } } "
"string MakeList(string separator){    var counter = 1;     var makeItem =  Func<string, string>((item) => {        return counter++ + separator + item + """";    });     return makeItem(strv) + makeItem(strv) + makeItem(strv);} Console.WriteLine(MakeList(strv));"
" using System;using System.IO;using System.Text;using System.Text.RegularExpressions;namespace Narcisisst{	class Program	{		public static void Main(string[] args)		{			const string path = @strv;			string[] thisFile = Directory.GetFiles(path , strv);			StringBuilder sb =  StringBuilder(); 				foreach (string readLine in File.ReadLines(thisFile[0]))				{					sb.Append(readLine);					sb.Append("""");				} 			Console.WriteLine(sb);			string input =String.Empty;			       	input = Console.ReadLine();			       	Console.WriteLine((Regex.IsMatch(sb.ToString(),input))?strv:strv);			       	Console.ReadKey();			 }	}} "
" using System; namespace Narcissistic{    class Narcissistic    {        public bool isNarcissistic(int z)        {            if (z < 0) return false;            string n = z.ToString();            int t = 0, l = n.Length;            foreach (char c in n)                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));             return t == z;        }    }     class Program    {        static void Main(string[] args)        {            Narcissistic n =  Narcissistic();            int c = 0, x = 0;            while (c < 25)            {                if (n.isNarcissistic(x))                {                    if (c % 5 == 0) Console.WriteLine();                    Console.Write(strv, x);                    c++;                }                x++;            }            Console.WriteLine(""Press any key to continue..."");            Console.ReadKey();        }    }}  //Narcissistic numbers: Nigel Galloway: February 17th., 2015using System;using System.Collections.Generic;using System.Linq; namespace RC {    public static class NumberEx {        public static IEnumerable<int> Digits(this int n) {            List<int> digits =  List<int>();            while (n > 0) {                digits.Add(n % 10);                n /= 10;            }            return digits.AsEnumerable();        }    }     class Program {        static void Main(string[] args) {            foreach (int N in Enumerable.Range(0, Int32.MaxValue).Where(k => {                var digits = k.Digits();                return digits.Sum(x => Math.Pow(x, digits.Count())) == k;            }).Take(25)) {                System.Console.WriteLine(N);            }        }    }} "
"using System; namespace NamedParams{    class Program    {        static void AddWidget(string parent, float x = 0, float y = 0, string text = strv)        {            Console.WriteLine(strv, parent, x, y, text);        }         static void Main(string[] args)        {            AddWidget(strv, 320, 240, strv);            AddWidget(strv, text: strv);            AddWidget(strv, 500);            AddWidget(strv, text: strv, y: 400);        }    }}"
" class Program{    private static string Ordinalize(int i)    {        i = Math.Abs(i);         if ([] {11, 12, 13}.Contains(i%100))            return i + strv;         switch (i%10)        {            case 1:                return i + strv;            case 2:                return i + strv;            case 3:                return i + strv;            default:                return i + strv;        }    }     static void Main()    {        Console.WriteLine(string.Join(strv, Enumerable.Range(0, 26).Select(Ordinalize)));        Console.WriteLine(string.Join(strv, Enumerable.Range(250, 16).Select(Ordinalize)));        Console.WriteLine(string.Join(strv, Enumerable.Range(1000, 26).Select(Ordinalize)));    }} "
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace NQueens{    class Program    {        const int N = 8;         static bool Allowed(bool[,] board, int x, int y)        {            for (int i=0; i<=x; i++)            {                if (board[i,y] || (i <= y && board[x-i,y-i]) || (y+i < N && board[x-i,y+i]))                {                    return false;                }            }            return true;        }         static bool FindSolution(bool[,] board, int x)        {            for (int y = 0; y < N; y++)            {                if (Allowed(board, x, y))                {                    board[x, y] = true;                    if (x == N-1 || FindSolution(board, x + 1))                    {                        return true;                    }                    board[x, y] = false;                }            }            return false;        }         static void Main(string[] args)        {            bool[,] board =  bool[N, N];             if (FindSolution(board, 0))            {                for (int i = 0; i < N; i++)                {                    for (int j = 0; j < N; j++)                    {                        Console.Write(board[i, j] ? strv : strv);                    }                    Console.WriteLine(strv);                }            }            else            {                Console.WriteLine(strv + N + strv);            }             Console.ReadKey(true);        }    }}"
"using System.Drawing;using System.Drawing.Imaging;using System.Linq; class XORPattern{    static void Main()    {        var size = 0x100;        var black = Color.Black.ToArgb();        var palette = Enumerable.Range(black, size).Select(Color.FromArgb).ToArray();        using (var image =  Bitmap(size, size))        {            for (var x = 0; x < size; x++)            {                for (var y = 0; y < size; y++)                {                    image.SetPixel(x, y, palette[x ^ y]);                }            }            image.Save(strv, ImageFormat.Png);        }    }}"
"Func<char, int> toInt = c => c-'0'; foreach (var i in Enumerable.Range(1,5000)	.Where(n => n == n.ToString()		.Sum(x => Math.Pow(toInt(x), toInt(x)))))	Console.WriteLine(i);"
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace Multisplit{    internal static class Program    {        private static void Main(string[] args)        {            foreach (var s in strv.Multisplit(true, strv, strv, strv)) // Split the string and return the separators.            {                Console.Write(s); // Write the returned substrings and separators to the console.            }            Console.WriteLine();        }         private static IEnumerable<string> Multisplit(this string s, bool returnSeparators = false,                                                      params string[] delimiters)        {            var currentString =  StringBuilder(); /* Initiate the StringBuilder. This will hold the current string to return
                                                      * once we find a separator. */             int index = 0; // Initiate the index counter at 0. This tells us our current position in the string to read.             while (index < s.Length) // Loop through the string.            {                // This will get the highest priority separator found at the current index, or null if there are none.                string foundDelimiter =                    (from delimiter in delimiters                     where s.Length >= index + delimiter.Length &&                           s.Substring(index, delimiter.Length) == delimiter                     select delimiter).FirstOrDefault();                 if (foundDelimiter != null)                {                    yield return currentString.ToString(); // Return the current string.                    if (returnSeparators) // Return the separator, if the user specified to do so.                        yield return                            string.Format(""{{{0}, ({1}, {2})}}"",                                          foundDelimiter,                                          index, index + foundDelimiter.Length);                    currentString.Clear(); // Clear the current string.                    index += foundDelimiter.Length; // Move the index past the current separator.                }                else                {                    currentString.Append(s[index++]); // Add the character at this index to the current string.                }            }             if (currentString.Length > 0)                yield return currentString.ToString(); // If we have anything left over, return it.        }    }}"
namespace RosettaCode {    class Hofstadter {        static public int F(int n) {            int result = 1;            if (n > 0) {                result = n - M(F(n-1));            }             return result;        }         static public int M(int n) {            int result = 0;            if (n > 0) {                result = n - F(M(n - 1));            }             return result;        }    }}
"using System;using MathNet.Numerics.LinearRegression;using MathNet.Numerics.LinearAlgebra;using MathNet.Numerics.LinearAlgebra.Double; class Program{    static void Main(string[] args)    {        var col = DenseVector.OfArray( double[] { 1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65,            1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83 });        var X = DenseMatrix.OfColumns( Vector<double>[] { col.PointwisePower(0), col, col.PointwisePower(2) });        var y = DenseVector.OfArray( double[] { 52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,            61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46 });        var β = MultipleRegression.QR(X, y);        Console.WriteLine(β);    }}"
using System; namespace multtbl{    class Program    {        static void Main(string[] args)        {            Console.Write(strv.PadRight(4));            for (int i = 1; i <= 12; i++)                Console.Write(i.ToString(strv).PadLeft(4));             Console.WriteLine();            Console.Write(strv);             for (int i = 1; i <= 12; i++)                Console.Write(strv);             Console.WriteLine();            for (int row = 1; row <= 12; row++)            {                Console.Write(row.ToString(strv).PadLeft(3).PadRight(4));                for (int col = 1; col <= 12; col++)                {                    if (row <= col)                        Console.Write((row * col).ToString(strv).PadLeft(4));                    else                        Console.Write(strv.PadLeft(4));                }                 Console.WriteLine();            }             Console.WriteLine();            Console.ReadLine();        }    }} 
"namespace RosettaCode.Multifactorial{    using System;    using System.Linq;     internal static class Program    {        private static void Main()        {            Console.WriteLine(string.Join(Environment.NewLine,                                          Enumerable.Range(1, 5)                                                    .Select(                                                        degree =>                                                        string.Join(strv,                                                                    Enumerable.Range(1, 10)                                                                              .Select(                                                                                  number =>                                                                                  Multifactorial(number, degree))))));        }         private static int Multifactorial(int number, int degree)        {            if (degree < 1)            {                throw  ArgumentOutOfRangeException(strv);            }             var count = 1 + (number - 1) / degree;            if (count < 1)            {                throw  ArgumentOutOfRangeException(strv);            }             return Enumerable.Range(0, count)                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));        }    }}"
"using System;using System.Linq;using System.Collections.Generic; List<Foo> foos = Enumerable.Range(1, n).Select(x =>  Foo()).ToList();"
 using System;using System.Windows.Forms;static class Program{    [STAThread]    static void Main()    {        Console.WriteLine(Control.MousePosition.X);        Console.WriteLine(Control.MousePosition.Y);    }} 
"using System;using System.Collections.Generic; namespace Morse{    class Morse    {        static void Main(string[] args)        {            string word = strv;            Dictionary<string, string> Codes =  Dictionary<string, string>            {                {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                 {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                 {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                 {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                 {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                 {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},                 {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv}                };             foreach (char c in word.ToCharArray())            {                string rslt = Codes[c.ToString()].Trim();                foreach (char c2 in rslt.ToCharArray())                {                    if (c2 == '.')                        Console.Beep(1000, 250);                    else                        Console.Beep(1000, 750);                }                System..Thread.Sleep(50);            }        }    }} "
"using System;using System.Drawing;using System.Windows.Forms; class MineFieldModel{    public int RemainingMinesCount{        get{            var count = 0;            ForEachCell((i,j)=>{                if (Mines[i,j] && !Marked[i,j])                    count++;            });            return count;        }    }     public bool[,] Mines{get; private set;}    public bool[,] Opened{get;private set;}    public bool[,] Marked{get; private set;}    public int[,] Values{get;private set; }    public int Width{ get{return Mines.GetLength(1);} }     public int Height{ get{return Mines.GetLength(0);} }     public MineFieldModel(bool[,] mines)    {        this.Mines = mines;        this.Opened =  bool[Height, Width]; // filled with 'false' by default        this.Marked =  bool[Height, Width];        this.Values = CalculateValues();    }     private int[,] CalculateValues()    {        int[,] values =  int[Height, Width];        ForEachCell((i,j) =>{            var value = 0;            ForEachNeighbor(i,j, (i1,j1)=>{                if (Mines[i1,j1])                    value++;            });            values[i,j] = value;        });        return values;    }     // Helper method for iterating over cells    public void ForEachCell(Action<int,int> action)    {        for (var i = 0; i < Height; i++)        for (var j = 0; j < Width; j++)            action(i,j);    }     // Helper method for iterating over cells' neighbors    public void ForEachNeighbor(int i, int j, Action<int,int> action)    {        for (var i1 = i-1; i1 <= i+1; i1++)        for (var j1 = j-1; j1 <= j+1; j1++)                           if (InBounds(j1, i1) && !(i1==i && j1 ==j))                action(i1, j1);    }     private bool InBounds(int x, int y)    {        return y >= 0 && y < Height && x >=0 && x < Width;    }     public event Action Exploded = delegate{};    public event Action Win = delegate{};    public event Action Updated = delegate{};     public void OpenCell(int i, int j){        if(!Opened[i,j]){            if (Mines[i,j])                Exploded();            else{                OpenCellsStartingFrom(i,j);                Updated();                CheckForVictory();            }        }    }     void OpenCellsStartingFrom(int i, int j)    {            Opened[i,j] = true;            ForEachNeighbor(i,j, (i1,j1)=>{                if (!Mines[i1,j1] && !Opened[i1,j1] && !Marked[i1,j1])                    OpenCellsStartingFrom(i1, j1);            });    }     void CheckForVictory(){        int notMarked = 0;        int wrongMarked = 0;        ForEachCell((i,j)=>{            if (Mines[i,j] && !Marked[i,j])                notMarked++;            if (!Mines[i,j] && Marked[i,j])                wrongMarked++;        });         if (notMarked == 0 && wrongMarked == 0)            Win();    }     public void Mark(int i, int j){        if (!Opened[i,j])            Marked[i,j] = true;            Updated();            CheckForVictory();    }} class MineFieldView: UserControl{    public const int CellSize = 40;     MineFieldModel _model;    public MineFieldModel Model{        get{ return _model; }        set        {             _model = value;             this.Size =  Size(_model.Width * CellSize+1, _model.Height * CellSize+2);        }    }     public MineFieldView(){        //Enable double-buffering to eliminate flicker        this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint | ControlStyles.DoubleBuffer,true);        this.Font =  Font(FontFamily.GenericSansSerif, 14, FontStyle.Bold);         this.MouseUp += (o,e)=>{            Point cellCoords = GetCell(e.Location);            if (Model != null)            {                if (e.Button == MouseButtons.Left)                    Model.OpenCell(cellCoords.Y, cellCoords.X);                else if (e.Button == MouseButtons.Right)                    Model.Mark(cellCoords.Y, cellCoords.X);            }        };    }     Point GetCell(Point coords)    {        var rgn = ClientRectangle;        var x = (coords.X - rgn.X)/CellSize;        var y = (coords.Y - rgn.Y)/CellSize;        return  Point(x,y);    }     static readonly Brush MarkBrush =  SolidBrush(Color.Blue);    static readonly Brush ValueBrush =  SolidBrush(Color.Black);    static readonly Brush UnexploredBrush =  SolidBrush(SystemColors.Control);    static readonly Brush OpenBrush =  SolidBrush(SystemColors.ControlDark);      protected override void OnPaint(PaintEventArgs e)    {        base.OnPaint(e);        var g = e.Graphics;        if (Model != null)        {            Model.ForEachCell((i,j)=>            {                var bounds =  Rectangle(j * CellSize, i * CellSize, CellSize, CellSize);                if (Model.Opened[i,j])                {                    g.FillRectangle(OpenBrush, bounds);                    if (Model.Values[i,j] > 0)                    {                        DrawStringInCenter(g, Model.Values[i,j].ToString(), ValueBrush, bounds);                    }                }                 else                 {                    g.FillRectangle(UnexploredBrush, bounds);                    if (Model.Marked[i,j])                    {                        DrawStringInCenter(g, strv, MarkBrush, bounds);                    }                    var outlineOffset = 1;                    var outline =  Rectangle(bounds.X+outlineOffset, bounds.Y+outlineOffset, bounds.Width-2*outlineOffset, bounds.Height-2*outlineOffset);                    g.DrawRectangle(Pens.Gray, outline);                }                g.DrawRectangle(Pens.Black, bounds);            });        }     }     static readonly StringFormat FormatCenter =  StringFormat                            {                                LineAlignment = StringAlignment.Center,                                Alignment=StringAlignment.Center                            };     void DrawStringInCenter(Graphics g, string s, Brush brush, Rectangle bounds)    {        PointF center =  PointF(bounds.X + bounds.Width/2, bounds.Y + bounds.Height/2);        g.DrawString(s, this.Font, brush, center, FormatCenter);    } } class MineSweepForm: Form{     MineFieldModel CreateField(int width, int height){        var field =  bool[height, width];        int mineCount = (int)(0.2 * height * width);        var rnd =  Random();        while(mineCount > 0)        {            var x = rnd.Next(width);            var y = rnd.Next(height);            if (!field[y,x])            {                field[y,x] = true;                mineCount--;            }        }        return  MineFieldModel(field);    }     public MineSweepForm()    {        var model = CreateField(6, 4);        var counter =  Label{ };        counter.Text = model.RemainingMinesCount.ToString();        var view =  MineFieldView                        {                             Model = model, BorderStyle = BorderStyle.FixedSingle,                        };        var stackPanel =  FlowLayoutPanel                        {                            Dock = DockStyle.Fill,                            FlowDirection = FlowDirection.TopDown,                            Controls = {counter, view}                        };        this.Controls.Add(stackPanel);        model.Updated += delegate{            view.Invalidate();            counter.Text = model.RemainingMinesCount.ToString();        };        model.Exploded += delegate {            MessageBox.Show(strv);            Close();        };        model.Win += delegate {            MessageBox.Show(strv);            view.Enabled = false;        };     }} class Program{    static void Main()    {        Application.Run( MineSweepForm());    }}"
"using System; class Program{    static void Main(string[] args)    {        int switchWins = 0;        int stayWins = 0;         Random gen =  Random();         for(int plays = 0; plays < 1000000; plays++ )        {            int[] doors = {0,0,0};//0 is a goat, 1 is a car             var winner = gen.Next(3);            doors[winner] = 1; //put a winner in a random door 	    int choice = gen.Next(3); //pick a door, any door	    int shown; //the shown door	    do            {	        shown = gen.Next(3);	    }            while (doors[shown] == 1 || shown == choice); //don't show the winner or the choice 	    stayWins += doors[choice]; //if you won by staying, count it             //the switched (last remaining) door is (3 - choice - shown), because 0+1+2=3            switchWins += doors[3 - choice - shown];        }         Console.Out.WriteLine(strv + stayWins + strv);        Console.Out.WriteLine(strv + switchWins + strv);    }}"
"using System; class Program {    static double MonteCarloPi(int n) {        int inside = 0;        Random r =  Random();         for (int i = 0; i < n; i++) {            if (Math.Pow(r.NextDouble(), 2)+ Math.Pow(r.NextDouble(), 2) <= 1) {                inside++;            }        }         return 4.0 * inside / n;    }     static void Main(string[] args) {        int value = 1000;        for (int n = 0; n < 5; n++) {            value *= 10;            Console.WriteLine(strv, value.ToString(strv).PadLeft(11, ' '), MonteCarloPi(value));        }    }}"
"public static class RabinMiller{    public static bool IsPrime(int n, int k)    {	if(n < 2)        {	    return false;        }	if(n != 2 && n % 2 == 0)        {	    return false;        }	int s = n - 1;	while(s % 2 == 0)        {	    s >>= 1;        }        Random r =  Random();	for (int i = 0; i < k; i++)        {            double a = r.Next((int)n - 1) + 1;            int temp = s;            int mod = (int)Math.Pow(a, (double)temp) % n;            while(temp != n - 1 && mod != 1 && mod != n - 1)            {		mod = (mod * mod) % n;		temp = temp * 2;            }	    if(mod != n - 1 && temp % 2 == 0)            {		return false;            }        }	return true;    }}// Miller-Rabin primality test as an extension method on the BigInteger type.// Based on the Ruby implementation on this page.public static class BigIntegerExtensions{  public static bool IsProbablePrime(this BigInteger source, int certainty)  {    if(source == 2 || source == 3)      return true;    if(source < 2 || source % 2 == 0)      return false;     BigInteger d = source - 1;    int s = 0;     while(d % 2 == 0)    {      d /= 2;      s += 1;    }     // There is no built-in method for generating random BigInteger values.    // Instead, random BigIntegers are constructed from randomly generated    // byte arrays of the same length as the source.    RandomNumberGenerator rng = RandomNumberGenerator.Create();    byte[] bytes =  byte[source.ToByteArray().LongLength];    BigInteger a;     for(int i = 0; i < certainty; i++)    {      do      {        // This may raise an exception in Mono 2.10.8 and earlier.        // http://bugzilla.xamarin.com/show_bug.cgi?id=2761        rng.GetBytes(bytes);        a =  BigInteger(bytes);      }      while(a < 2 || a >= source - 2);       BigInteger x = BigInteger.ModPow(a, d, source);      if(x == 1 || x == source - 1)        continue;       for(int r = 1; r < s; r++)      {        x = BigInteger.ModPow(x, 2, source);        if(x == 1)          return false;        if(x == source - 1)          break;      }       if(x != source - 1)        return false;    }     return true;  }}"
"using System;using System.Threading;using System.Threading.Tasks; namespace RosettaCode{  internal sealed class Program  {    private static void Worker(object arg, int id)    {      var sem = arg as SemaphoreSlim;      sem.Wait();      Console.WriteLine(strv, id);      Thread.Sleep(2*1000);      Console.WriteLine(strv, id);      sem.Release();    }     private static void Main()    {      var semaphore =  SemaphoreSlim(Environment.ProcessorCount*2, int.MaxValue);       Console.WriteLine(strv, Environment.ProcessorCount);      Console.WriteLine(""This program will use {0} semaphores."", semaphore.CurrentCount);       Parallel.For(0, Environment.ProcessorCount*3, y => Worker(semaphore, y));    }  }}"
" using System;using System.Collections.Generic; public class Menu{        static void Main(string[] args)        {            List<string> menu_items =  List<string>() { strv, strv, strv, strv };            //List<string> menu_items = new List<string>();            Console.WriteLine(PrintMenu(menu_items));            Console.ReadLine();        }        private static string PrintMenu(List<string> items)        {            if (items.Count == 0)                return strv;             string input = strv;            int i = -1;            do            {                for (int j = 0; j < items.Count; j++)                    Console.WriteLine(strv, j, items[j]);                 Console.WriteLine(strv);                input = Console.ReadLine();             } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);            return items[i];        }} "
"using System;using System.Runtime.InteropServices; public unsafe class Program{    public static unsafe void HeapMemory()    {        const int HEAP_ZERO_MEMORY = 0x00000008;        const int size = 1000;        int ph = GetProcessHeap();        void* pointer = HeapAlloc(ph, HEAP_ZERO_MEMORY, size);        if (pointer == null)            throw  OutOfMemoryException();        Console.WriteLine(HeapSize(ph, 0, pointer));        HeapFree(ph, 0, pointer);    }     public static unsafe void StackMemory()    {        byte* buffer = stackalloc byte[1000];        // buffer is automatically discarded when the method returns    }    public static void Main(string[] args)    {        HeapMemory();        StackMemory();    }    [DllImport(strv)]    static extern void* HeapAlloc(int hHeap, int flags, int size);    [DllImport(strv)]    static extern bool HeapFree(int hHeap, int flags, void* block);    [DllImport(strv)]    static extern int GetProcessHeap();    [DllImport(strv)]    static extern int HeapSize(int hHeap, int flags, void* block); }"
" 	public class MD5	{		/***********************VARIABLES************************************/  		/***********************Statics**************************************/		
		
		
		protected readonly static uint []  T = uint[64] 			{	0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,				0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,                0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,                0x6b901122,0xfd987193,0xa679438e,0x49b40821,				0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,                0xd62f105d,0x2441453,0xd8a1e681,0xe7d3fbc8,                0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,				0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,                0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,                0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,                0x289b7ec6,0xeaa127fa,0xd4ef3085,0x4881d05,				0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,                0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,                0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,                0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,				0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391}; 		/*****instance variables**************/		
		
		///	512 bits chunks as 16 32 bit word		
		protected  uint [] X =  uint [16];	 		
		
		
		protected Digest dgFingerPrint;			 		
		
		
		protected	byte [] m_byteInput;		   		/**********************EVENTS AND DELEGATES*******************************************/ 		public delegate void ValueChanging (object sender,MD5ChangingEventArgs Changing);		public delegate void ValueChanged (object sender,MD5ChangedEventArgs Changed);  		public event ValueChanging OnValueChanging;		public event ValueChanged  OnValueChanged;   		/********************************************************************/		/***********************PROPERTIES ***********************/		
		///gets or sets as string		
		public string Value		{			get			{ 				string st ;				char [] tempCharArray=  Char[m_byteInput.Length]; 				for(int i =0; i<m_byteInput.Length;i++)					tempCharArray[i]=(char)m_byteInput[i]; 				st=  String(tempCharArray);				return st;			}			set			{				
				if (this.OnValueChanging !=null)					this.OnValueChanging(this, MD5ChangingEventArgs(value));  				m_byteInput= byte[value.Length];				for (int i =0; i<value.Length;i++)					m_byteInput[i]=(byte)value[i];				dgFingerPrint=CalculateMD5Value();				 				
				if (this.OnValueChanged !=null)					this.OnValueChanged(this, MD5ChangedEventArgs(value,dgFingerPrint.ToString())); 			}		}		 		
		
		
		public byte [] ValueAsByte		{			get			{				byte [] bt =  byte[m_byteInput.Length];				for (int i =0; i<m_byteInput.Length;i++)					bt[i]=m_byteInput[i];				return bt;          }			set			{				
				if (this.OnValueChanging !=null)					this.OnValueChanging(this, MD5ChangingEventArgs(value)); 				m_byteInput= byte[value.Length];				for (int i =0; i<value.Length;i++)					m_byteInput[i]=value[i];				dgFingerPrint=CalculateMD5Value();  				
				if (this.OnValueChanged !=null)					this.OnValueChanged(this, MD5ChangedEventArgs(value,dgFingerPrint.ToString()));			}		} 		//gets the signature/figner print as string		public  string FingerPrint		{			get			{				return dgFingerPrint.ToString();			}		}  		/*************************************************************************/		
		
		
		public MD5()		{						Value=strv;		}  		/******************************************************************************/		/*********************METHODS**************************/ 		
		
		
		
		protected Digest CalculateMD5Value()		{			/***********vairable declaration**************/			byte [] bMsg;	//buffer to hold bits			uint N;			//N is the size of msg as  word (32 bit) 			Digest dg = Digest();			//  the value to be returned 			// create a buffer with bits padded and length is alos padded			bMsg=CreatePaddedBuffer(); 			N=(uint)(bMsg.Length*8)/32;		//no of 32 bit blocks 			for (uint  i=0; i<N/16;i++)			{				CopyBlock(bMsg,i);				PerformTransformation(ref dg.A,ref dg.B,ref dg.C,ref dg.D);			}			return dg;		} 		/********************************************************
		 * TRANSFORMATIONS :  FF , GG , HH , II  acc to RFC 1321
		 * where each Each letter represnets the aux function used
		 *********************************************************/   		
		
		
		protected void TransF(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )		{			a = b + MD5Helper.RotateLeft((a + ((b&c) | (~(b)&d)) + X[k] + T[i-1]), s);		} 		
		
		
		protected void TransG(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )		{			a = b + MD5Helper.RotateLeft((a + ((b&d) | (c & ~d) ) + X[k] + T[i-1]), s);		} 		
		
		
		protected void TransH(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )		{			a = b + MD5Helper.RotateLeft((a + (b^c^d) + X[k] + T[i-1]), s);		} 		
		
		
		protected void TransI(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )		{			a = b + MD5Helper.RotateLeft((a + (c^(b|~d))+ X[k] + T[i-1]), s);		}   		
		
		
		
		
		
		
		protected void PerformTransformation(ref uint A,ref uint B,ref uint C, ref uint D)		{			//// saving  ABCD  to be used in end of loop 			uint AA,BB,CC,DD; 			AA=A;				BB=B;			CC=C;			DD=D; 			/* Round 1 
				* [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
				* [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
				* [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
				* [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]
				*  * */			TransF(ref A,B,C,D,0,7,1);TransF(ref D,A,B,C,1,12,2);TransF(ref C,D,A,B,2,17,3);TransF(ref B,C,D,A,3,22,4);			TransF(ref A,B,C,D,4,7,5);TransF(ref D,A,B,C,5,12,6);TransF(ref C,D,A,B,6,17,7);TransF(ref B,C,D,A,7,22,8);			TransF(ref A,B,C,D,8,7,9);TransF(ref D,A,B,C,9,12,10);TransF(ref C,D,A,B,10,17,11);TransF(ref B,C,D,A,11,22,12);			TransF(ref A,B,C,D,12,7,13);TransF(ref D,A,B,C,13,12,14);TransF(ref C,D,A,B,14,17,15);TransF(ref B,C,D,A,15,22,16);			/** rOUND 2
				**[ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
				*[ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
				*[ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
				*[ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]
			*/			TransG(ref A,B,C,D,1,5,17);TransG(ref D,A,B,C,6,9,18);TransG(ref C,D,A,B,11,14,19);TransG(ref B,C,D,A,0,20,20);			TransG(ref A,B,C,D,5,5,21);TransG(ref D,A,B,C,10,9,22);TransG(ref C,D,A,B,15,14,23);TransG(ref B,C,D,A,4,20,24);			TransG(ref A,B,C,D,9,5,25);TransG(ref D,A,B,C,14,9,26);TransG(ref C,D,A,B,3,14,27);TransG(ref B,C,D,A,8,20,28);			TransG(ref A,B,C,D,13,5,29);TransG(ref D,A,B,C,2,9,30);TransG(ref C,D,A,B,7,14,31);TransG(ref B,C,D,A,12,20,32);			/*  rOUND 3
				* [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
				* [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
				* [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
				* [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]
			 * */			TransH(ref A,B,C,D,5,4,33);TransH(ref D,A,B,C,8,11,34);TransH(ref C,D,A,B,11,16,35);TransH(ref B,C,D,A,14,23,36);			TransH(ref A,B,C,D,1,4,37);TransH(ref D,A,B,C,4,11,38);TransH(ref C,D,A,B,7,16,39);TransH(ref B,C,D,A,10,23,40);			TransH(ref A,B,C,D,13,4,41);TransH(ref D,A,B,C,0,11,42);TransH(ref C,D,A,B,3,16,43);TransH(ref B,C,D,A,6,23,44);			TransH(ref A,B,C,D,9,4,45);TransH(ref D,A,B,C,12,11,46);TransH(ref C,D,A,B,15,16,47);TransH(ref B,C,D,A,2,23,48);			/*ORUNF  4
				*[ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
				*[ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
				*[ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
				*[ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]
						 * */			TransI(ref A,B,C,D,0,6,49);TransI(ref D,A,B,C,7,10,50);TransI(ref C,D,A,B,14,15,51);TransI(ref B,C,D,A,5,21,52);			TransI(ref A,B,C,D,12,6,53);TransI(ref D,A,B,C,3,10,54);TransI(ref C,D,A,B,10,15,55);TransI(ref B,C,D,A,1,21,56);			TransI(ref A,B,C,D,8,6,57);TransI(ref D,A,B,C,15,10,58);TransI(ref C,D,A,B,6,15,59);TransI(ref B,C,D,A,13,21,60);			TransI(ref A,B,C,D,4,6,61);TransI(ref D,A,B,C,11,10,62);TransI(ref C,D,A,B,2,15,63);TransI(ref B,C,D,A,9,21,64);  			A=A+AA;			B=B+BB;			C=C+CC;			D=D+DD;  		}  		
		
		
		
		
		protected byte[] CreatePaddedBuffer()		{			uint pad;		//no of padding bits for 448 mod 512 			byte [] bMsg;	//buffer to hold bits			ulong sizeMsg;		//64 bit size pad			uint sizeMsgBuff;	//buffer size in multiple of bytes			int temp=(448-((m_byteInput.Length*8)%512)); //temporary   			pad = (uint )((temp+512)%512);		//getting no of bits to  be pad			if (pad==0)				///pad is in bits				pad=512;			//at least 1 or max 512 can be added 			sizeMsgBuff= (uint) ((m_byteInput.Length)+ (pad/8)+8);			sizeMsg=(ulong)m_byteInput.Length*8;			bMsg= byte[sizeMsgBuff];	///no need to pad with 0 coz new bytes 			// are already initialize to 0 :)    			////copying string to buffer 			for (int i =0; i<m_byteInput.Length;i++)				bMsg[i]=m_byteInput[i]; 			bMsg[m_byteInput.Length]|=0x80;		///making first bit of padding 1, 			//wrting the size value			for (int i =8; i >0;i--)				bMsg[sizeMsgBuff-i]=(byte) (sizeMsg>>((8-i)*8) & 0x00000000000000ff); 			return bMsg;		}  		
		
		
		
		
		protected void CopyBlock(byte[] bMsg,uint block)		{ 			block=block<<6;			for (uint j=0; j<61;j+=4)			{				X[j>>2]=(((uint) bMsg[block+(j+3)]) <<24 ) |						(((uint) bMsg[block+(j+2)]) <<16 ) |						(((uint) bMsg[block+(j+1)]) <<8 ) |						(((uint) bMsg[block+(j)]) ) ; 			}		}	}   System..MD5CryptoServiceProvider x =  System..MD5CryptoServiceProvider();byte[] bs = System..Encoding.UTF8.GetBytes(password);bs = x.ComputeHash(bs); //this function is not in the above classdefinitionSystem..StringBuilder s =  System..StringBuilder();foreach (byte b in bs){   s.Append(b.ToString(strv).ToLower());} password = s.ToString(); "
"using System; namespace RosettaCode{    class Program    {        static void Main(string[] args)        {            string text = Math.Abs(int.Parse(Console.ReadLine())).ToString();            Console.WriteLine(text.Length < 2 || text.Length % 2 == 0 ? strv : text.Substring((text.Length - 3) / 2, 3));        }    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text;static class Md4{    public static string Md4Hash(this string input)    {        // get padded uints from bytes        List<byte> bytes = Encoding.ASCII.GetBytes(input).ToList();        uint bitCount = (uint)(bytes.Count) * 8;        bytes.Add(128);        while (bytes.Count % 64 != 56) bytes.Add(0);        var uints =  List<uint>();        for (int i = 0; i + 3 < bytes.Count; i += 4)            uints.Add(bytes[i] | (uint)bytes[i + 1] << 8 | (uint)bytes[i + 2] << 16 | (uint)bytes[i + 3] << 24);        uints.Add(bitCount);        uints.Add(0);         // run rounds        uint a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476;        Func<uint, uint, uint> rol = (x, y) => x << (int)y | x >> 32 - (int)y;        for (int q = 0; q + 15 < uints.Count; q += 16)        {            var chunk = uints.GetRange(q, 16);            uint aa = a, bb = b, cc = c, dd = d;            Action<Func<uint, uint, uint, uint>, uint[]> round = (f, y) =>            {                foreach (uint i in [] { y[0], y[1], y[2], y[3] })                {                    a = rol(a + f(b, c, d) + chunk[(int)(i + y[4])] + y[12], y[8]);                    d = rol(d + f(a, b, c) + chunk[(int)(i + y[5])] + y[12], y[9]);                    c = rol(c + f(d, a, b) + chunk[(int)(i + y[6])] + y[12], y[10]);                    b = rol(b + f(c, d, a) + chunk[(int)(i + y[7])] + y[12], y[11]);                }            };            round((x, y, z) => (x & y) | (~x & z),  uint[] { 0, 4, 8, 12, 0, 1, 2, 3, 3, 7, 11, 19, 0 });            round((x, y, z) => (x & y) | (x & z) | (y & z),  uint[] { 0, 1, 2, 3, 0, 4, 8, 12, 3, 5, 9, 13, 0x5a827999 });            round((x, y, z) => x ^ y ^ z,  uint[] { 0, 2, 1, 3, 0, 8, 4, 12, 3, 9, 11, 15, 0x6ed9eba1 });            a += aa; b += bb; c += cc; d += dd;        }         // return hex encoded string        byte[] outBytes = [] { a, b, c, d }.SelectMany(BitConverter.GetBytes).ToArray();        return BitConverter.ToString(outBytes).Replace(strv, strv).ToLower();    }    static void Main() { Console.WriteLine(strv.Md4Hash()); }}"
"using System.Text;using System.Security.Cryptography; byte[] data = Encoding.ASCII.GetBytes(strv);byte[] hash = MD5.Create().ComputeHash(data);Console.WriteLine(BitConverter.ToString(hash).Replace(strv, strv).ToLower());"
" using System; namespace RosetaCode{	class MainClass	{		public static void Main (string[] args)		{			int[,] list =  int[18,19];			string input = @""55
	                        94 48
	                       95 30 96
	                     77 71 26 67
	                    97 13 76 38 45
	                  07 36 79 16 37 68
	                 48 07 09 18 70 26 06
	               18 72 79 46 59 79 29 90
	              20 76 87 11 32 07 07 49 18
	            27 83 58 35 71 11 25 57 29 85
	           14 64 36 96 27 11 58 56 92 18 55
	         02 90 03 60 48 49 41 46 33 36 47 23
	        92 50 48 02 36 59 42 79 72 20 82 77 42
	      56 78 38 80 39 75 02 71 66 66 01 03 55 72
	     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
	   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
	  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
	27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93"";			var charArray = input.Split (''); 			for (int i=0; i < charArray.Length; i++) {				var numArr = charArray[i].Trim().Split(' '); 				for (int j = 0; j<numArr.Length; j++)				{					int number = Convert.ToInt32 (numArr[j]);					list [i, j] = number;				}			} 			for (int i = 16; i >= 0; i--) {				for (int j = 0; j < 18; j++) {					list[i,j] = Math.Max(list[i, j] + list[i+1, j], list[i,j] + list[i+1, j+1]);				}			}			Console.WriteLine (string.Format(strv, list [0, 0]));		}	}}  "
"using System;using System.Linq; public class MapRange{    public static void Main() {        foreach (int i in Enumerable.Range(0, 11))            Console.WriteLine($strv);    }     static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);}"
"using System;using System.Text; namespace prog{	class MainClass	{								public static void Main (string[] args)		{			double[,] m = { {1,2,3},{4,5,6},{7,8,9} }; 			double[,] t = Transpose( m );	 			for( int i=0; i<t.GetLength(0); i++ )			{				for( int j=0; j<t.GetLength(1); j++ )							Console.Write( t[i,j] + strv );				Console.WriteLine(strv);			}		} 		public static double[,] Transpose( double[,] m )		{			double[,] t =  double[m.GetLength(1),m.GetLength(0)];			for( int i=0; i<m.GetLength(0); i++ )				for( int j=0; j<m.GetLength(1); j++ )					t[j,i] = m[i,j];			 			return t;		}	}}"
"using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Text;using System.Drawing; namespace MazeGeneration{    public static class Extensions    {        public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> source, Random rng)        {            var e = source.ToArray();            for (var i = e.Length - 1; i >= 0; i--)            {                var swapIndex = rng.Next(i + 1);                yield return e[swapIndex];                e[swapIndex] = e[i];            }        }         public static CellState OppositeWall(this CellState orig)        {            return (CellState)(((int) orig >> 2) | ((int) orig << 2)) & CellState.Initial;        }         public static bool HasFlag(this CellState cs,CellState flag)        {            return ((int)cs & (int)flag) != 0;        }    }     [Flags]    public enum CellState    {        Top = 1,        Right = 2,        Bottom = 4,        Left = 8,        Visited = 128,        Initial = Top | Right | Bottom | Left,    }     public struct RemoveWallAction    {        public Point Neighbour;        public CellState Wall;    }     public class Maze    {        private readonly CellState[,] _cells;        private readonly int _width;        private readonly int _height;        private readonly Random _rng;         public Maze(int width, int height)        {            _width = width;            _height = height;            _cells =  CellState[width, height];            for(var x=0; x<width; x++)                for(var y=0; y<height; y++)                    _cells[x, y] = CellState.Initial;            _rng =  Random();            VisitCell(_rng.Next(width), _rng.Next(height));        }         public CellState this[int x, int y]        {            get { return _cells[x,y]; }            set { _cells[x,y] = value; }        }         public IEnumerable<RemoveWallAction> GetNeighbours(Point p)        {            if (p.X > 0) yield return  RemoveWallAction {Neighbour =  Point(p.X - 1, p.Y), Wall = CellState.Left};            if (p.Y > 0) yield return  RemoveWallAction {Neighbour =  Point(p.X, p.Y - 1), Wall = CellState.Top};            if (p.X < _width-1) yield return  RemoveWallAction {Neighbour =  Point(p.X + 1, p.Y), Wall = CellState.Right};            if (p.Y < _height-1) yield return  RemoveWallAction {Neighbour =  Point(p.X, p.Y + 1), Wall = CellState.Bottom};        }         public void VisitCell(int x, int y)        {            this[x,y] |= CellState.Visited;            foreach (var p in GetNeighbours( Point(x, y)).Shuffle(_rng).Where(z => !(this[z.Neighbour.X, z.Neighbour.Y].HasFlag(CellState.Visited))))            {                this[x, y] -= p.Wall;                this[p.Neighbour.X, p.Neighbour.Y] -= p.Wall.OppositeWall();                VisitCell(p.Neighbour.X, p.Neighbour.Y);            }        }         public void Display()        {            var firstLine = string.Empty;            for (var y = 0; y < _height; y++)            {                var sbTop =  StringBuilder();                var sbMid =  StringBuilder();                for (var x = 0; x < _width; x++)                {                    sbTop.Append(this[x, y].HasFlag(CellState.Top) ? strv : strv);                    sbMid.Append(this[x, y].HasFlag(CellState.Left) ? strv : strv);                }                if (firstLine == string.Empty)                    firstLine = sbTop.ToString();                Debug.WriteLine(sbTop + strv);                Debug.WriteLine(sbMid + strv);                Debug.WriteLine(sbMid + strv);            }            Debug.WriteLine(firstLine);        }    }     class Program    {        static void Main(string[] args)        {            var maze =  Maze(20, 20);            maze.Display();        }    }} "
System..Directory.CreateDirectory(path)
"using System;using System.Drawing;using System.Drawing.Imaging;using System.Threading;using System.Windows.Forms; 


public class MandelbrotSetForm : Form{    const double MaxValueExtent = 2.0;    Thread thread;     static double CalcMandelbrotSetColor(ComplexNumber c)    {        // from http://en.wikipedia.org/w/index.php?title=Mandelbrot_set        const int MaxIterations = 1000;        const double MaxNorm = MaxValueExtent * MaxValueExtent;         int iteration = 0;        ComplexNumber z =  ComplexNumber();        do        {            z = z * z + c;            iteration++;        } while (z.Norm() < MaxNorm && iteration < MaxIterations);        if (iteration < MaxIterations)            return (double)iteration / MaxIterations;        else            return 0; // black    }     static void GenerateBitmap(Bitmap bitmap)    {        double scale = 2 * MaxValueExtent / Math.Min(bitmap.Width, bitmap.Height);        for (int i = 0; i < bitmap.Height; i++)        {            double y = (bitmap.Height / 2 - i) * scale;            for (int j = 0; j < bitmap.Width; j++)            {                double x = (j - bitmap.Width / 2) * scale;                double color = CalcMandelbrotSetColor( ComplexNumber(x, y));                bitmap.SetPixel(j, i, GetColor(color));            }        }    }     static Color GetColor(double value)    {        const double MaxColor = 256;        const double ContrastValue = 0.2;        return Color.FromArgb(0, 0,            (int)(MaxColor * Math.Pow(value, ContrastValue)));    }     public MandelbrotSetForm()    {        // form creation        this.Text = strv;        this.BackColor = System..Color.Black;        this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;        this.MaximizeBox = false;        this.StartPosition = FormStartPosition.CenterScreen;        this.FormBorderStyle = FormBorderStyle.FixedDialog;        this.ClientSize =  Size(640, 640);        this.Load +=  System.EventHandler(this.MainForm_Load);    }     void MainForm_Load(object sender, EventArgs e)    {        thread =  Thread(thread_Proc);        thread.IsBackground = true;        thread.Start(this.ClientSize);    }     void thread_Proc(object args)    {        // start from small image to provide instant display for user        Size size = (Size)args;        int width = 16;        while (width * 2 < size.Width)        {            int height = width * size.Height / size.Width;            Bitmap bitmap =  Bitmap(width, height, PixelFormat.Format24bppRgb);            GenerateBitmap(bitmap);            this.BeginInvoke( SetNewBitmapDelegate(SetNewBitmap), bitmap);            width *= 2;            Thread.Sleep(200);        }        // then generate final image        Bitmap finalBitmap =  Bitmap(size.Width, size.Height, PixelFormat.Format24bppRgb);        GenerateBitmap(finalBitmap);        this.BeginInvoke( SetNewBitmapDelegate(SetNewBitmap), finalBitmap);    }     void SetNewBitmap(Bitmap image)    {        if (this.BackgroundImage != null)            this.BackgroundImage.Dispose();        this.BackgroundImage = image;    }     delegate void SetNewBitmapDelegate(Bitmap image);     static void Main()    {        Application.Run( MandelbrotSetForm());    }} struct ComplexNumber{    public double Re;    public double Im;     public ComplexNumber(double re, double im)    {        this.Re = re;        this.Im = im;    }     public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y)    {        return  ComplexNumber(x.Re + y.Re, x.Im + y.Im);    }     public static ComplexNumber operator *(ComplexNumber x, ComplexNumber y)    {        return  ComplexNumber(x.Re * y.Re - x.Im * y.Im,            x.Re * y.Im + x.Im * y.Re);    }     public double Norm()    {        return Re * Re + Im * Im;    }}"
"using System;using System.Net;using System.Net.Http;using System.Threading.Tasks; class Program{    static async Task<string> LookupMac(string MacAddress)    {        var uri =  Uri(strv + WebUtility.UrlEncode(MacAddress));        using (var wc =  HttpClient())            return await wc.GetStringAsync(uri);    }    static void Main(string[] args)    {        foreach (var mac in  string[] { strv, strv, strv })            Console.WriteLine(mac + """" + LookupMac(mac).Result);        Console.ReadLine();    }}"
"public class Matrix{	int n;	int m;	double[,] a; 	public Matrix(int n, int m)	{		if (n <= 0 || m <= 0)			throw  ArgumentException(strv);		this.n = n;		this.m = m;		a =  double[n, m];	} 	//indices start from one	public double this[int i, int j]	{		get { return a[i - 1, j - 1]; }		set { a[i - 1, j - 1] = value; }	} 	public int N { get { return n; } }	public int M { get { return m; } } 	public static Matrix operator*(Matrix _a, Matrix b)	{		int n = _a.N;		int m = b.M;		int l = _a.M;		if (l != b.N)			throw  ArgumentException(strv);		Matrix result =  Matrix(_a.N, b.M);		for(int i = 0; i < n; i++)			for (int j = 0; j < m; j++)			{				double sum = 0.0;				for (int k = 0; k < l; k++)					sum += _a.a[i, k]*b.a[k, j];				result.a[i, j] = sum;			}		return result;	}}"
"     public static class Luhn    {        public static bool LuhnCheck(this string cardNumber)        {            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());        }         private static bool LuhnCheck(this int[] digits)        {            return GetCheckValue(digits) == 0;        }         private static int GetCheckValue(int[] digits)        {            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;        }    }     public static class TestProgram    {        public static void Main()        {            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};            foreach (var testNumber in testNumbers)                Console.WriteLine(strv, testNumber, testNumber.ToString().LuhnCheck() ? strv : strv);        }    } using System;using System.Linq; namespace Luhn{    class Program    {        public static bool luhn(long n)        {            long nextdigit, sum = 0;                        bool alt = false;                        while (n != 0)            {                                nextdigit = n % 10;                if (alt)                {                    nextdigit *= 2;                    nextdigit -= (nextdigit > 9) ? 9 : 0;                }                sum += nextdigit;                alt = !alt;                n /= 10;            }            return (sum % 10 == 0);        }         public static bool luhnLinq(long n)        {            string s = n.ToString();            return s.Select((c, i) => (c - '0') << ((s.Length - i - 1) & 1)).Sum(n => n > 9 ? n - 9 : n) % 10 == 0;        }         static void Main(string[] args)        {                        long[] given =  long[] {49927398716, 49927398717, 1234567812345678, 1234567812345670};            foreach (long num in given)            {                string valid = (luhn(num)) ? strv : strv;                Console.WriteLine(num + valid);            }         }    }} using System;namespace Luhn_Test{	public static class Extensions 	{		public static string Reverse(this string s )		{		    char[] charArray = s.ToCharArray();		    Array.Reverse( charArray );		    return  string( charArray );		}	}	class Program	{		public static bool Luhn(long x)		{			long s1=0;			long s2=0;			bool STATE=x%10!=0; // If it ends with zero, we want the order to be the other way around			x=long.Parse(x.ToString().Reverse());			while (x!=0)			{				s1+=STATE?x%10:0;				s2+=STATE?0:((x%10)*2>9)?(((x%10)*2/10)+((x%10)*2)%10):((x%10)*2); 				STATE=!STATE; //Switch state				x/=10; //Cut the last digit and continue			}			return ((s1+s2)%10==0); //Check if it ends with zero, if so, return true, otherwise,false.		}		public static void Main(string[] args)		{			long[] ks = {1234567812345670, 49927398717, 1234567812345678 ,1234567812345670 };			foreach (long k in ks)			{			Console.WriteLine(strv,k,Luhn(k)?strv:strv);				}		Start:			try { 			Console.WriteLine(strv);			long x=long.Parse(Console.ReadLine());			Console.WriteLine(strv,Luhn(x)?strv:strv);			goto Start;			}			catch (FormatException)			{				goto Start;			}					}	}}  using System;using System.Linq; public class CreditCardLogic{    static Func<char, int> charToInt = c => c - '0';     static Func<int, int> doubleDigit = n => (n * 2).ToString().Select(charToInt).Sum();     static Func<int, bool> isOddIndex = index => index % 2 == 0;     public static bool LuhnCheck(string creditCardNumber)    {        var checkSum = creditCardNumber            .Select(charToInt)            .Reverse()            .Select((digit, index) => isOddIndex(index) ? digit : doubleDigit(digit))            .Sum();         return checkSum % 10 == 0;    }} "
"using System; delegate T Func<T>(); class ManOrBoy{    static void Main()    {        Console.WriteLine(A(10, C(1), C(-1), C(-1), C(1), C(0)));    }     static Func<int> C(int i)    {        return delegate { return i; };    }     static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)    {        Func<int> b = null;        b = delegate { k--; return A(k, b, x1, x2, x3, x4); };        return k <= 0 ? x4() + x5() : b();    }} using System; class ManOrBoy{    static void Main()    {        Console.WriteLine(A(10, () => 1, () => -1, () => -1, () => 1, () => 0));    }     static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)    {        Func<int> b = null;        b = () => { k--; return A(k, b, x1, x2, x3, x4); };        return k <= 0 ? x4() + x5() : b();    }}"
"using System;using System.Linq;using System.Text;using System.Text.RegularExpressions; namespace MadLibs_RosettaCode{	class Program	{		static void Main(string[] args)		{			string madLibs = @""Write a program to create a Mad Libs like story.
The program should read an arbitrary multiline story from input.
The story will be terminated with a blank line.
Then, find each replacement to be made within the story, 
ask the user for a word to replace it with, and make all the replacements.
Stop when there are none left and print the final story.
The input should be an arbitrary story in the form:
<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.
Given this example, it should then ask for a name, 
a he or she and a noun (<name> gets replaced both times with the same value).""; 			StringBuilder sb =  StringBuilder();			Regex pattern =  Regex(@strv);			string storyLine;			string replacement; 			Console.WriteLine(madLibs + Environment.NewLine + Environment.NewLine);			Console.WriteLine(strv); 			// Continue to get input while empty line hasn't been entered.			do			{				storyLine = Console.ReadLine();				sb.Append(storyLine + Environment.NewLine);			} while (!string.IsNullOrEmpty(storyLine) && !string.IsNullOrWhiteSpace(storyLine)); 			// Retrieve only the unique regex matches from the user entered story.			Match nameMatch = pattern.Matches(sb.ToString()).OfType<Match>().Where(x => x.Value.Equals(strv)).Select(x => x.Value).Distinct() as Match;			if(nameMatch != null)			{				do				{					Console.WriteLine(strv + nameMatch.Value);					replacement = Console.ReadLine();				} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));				sb.Replace(nameMatch.Value, replacement);			} 			foreach (Match match in pattern.Matches(sb.ToString()))			{				replacement = string.Empty;				// Guarantee we get a non-whitespace value for the replacement				do				{					Console.WriteLine(strv + match.Value);					replacement = Console.ReadLine();				} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement)); 				int location = sb.ToString().IndexOf(match.Value);				sb.Remove(location, match.Value.Length).Insert(location, replacement);			} 			Console.WriteLine(Environment.NewLine + Environment.NewLine + strv);			Console.WriteLine(sb.ToString());		}	}} "
"using System;using System.Collections.Generic;using System.Numerics;using System.Threading.Tasks; namespace LucasLehmerTestForRosettaCode{    public class LucasLehmerTest    {        static BigInteger ZERO =  BigInteger(0);        static BigInteger ONE =  BigInteger(1);        static BigInteger TWO =  BigInteger(2);        static BigInteger FOUR =  BigInteger(4);         private static bool isMersennePrime(int p)         {            if (p % 2 == 0) return (p == 2);            else {                for (int i = 3; i <= (int)Math.Sqrt(p); i += 2)                    if (p % i == 0) return false; //not prime                BigInteger m_p = BigInteger.Pow(TWO, p) - ONE;                BigInteger s = FOUR;                for (int i = 3; i <= p; i++)                    s = (s * s - TWO) % m_p;                return s == ZERO;            }         }         public static int[] GetMersennePrimeNumbers(int upTo)        {            List<int> response =  List<int>();            Parallel.For(2, upTo, i => {                if (isMersennePrime(i)) response.Add(i);            });            response.Sort();            return response.ToArray();        }         static void Main(string[] args)        {            int[] mersennePrimes = LucasLehmerTest.GetMersennePrimeNumbers(11213);            foreach (int mp in mersennePrimes)                Console.Write(strv + mp+strv);            Console.ReadLine();        }    }}"
"using System;using System.Linq;using System.Collections.Generic; public class Program{    public static void Main()    {        Console.WriteLine(strv);        Console.WriteLine(string.Join(strv, LudicNumbers(150).Take(25)));        Console.WriteLine();         Console.WriteLine($strv);        Console.WriteLine();         foreach (var ludic in LudicNumbers(22000).Skip(1999).Take(6)                .Select((n, i) => $strv)) {            Console.WriteLine(ludic);        }        Console.WriteLine();         Console.WriteLine(strv);        var queue =  Queue<int>(5);        foreach (int x in LudicNumbers(255)) {            if (queue.Count == 5) queue.Dequeue();            queue.Enqueue(x);            if (x - 6 < 250 && queue.Contains(x - 6) && queue.Contains(x - 4)) {                Console.WriteLine($strv);            }        }    }     public static IEnumerable<int> LudicNumbers(int limit) {        yield return 1;        //Like a linked list, but with value types.        //Create 2 extra entries at the start to avoid ugly index calculations        //and another at the end to avoid checking for index-out-of-bounds.        Entry[] values = Enumerable.Range(0, limit + 1).Select(n =>  Entry(n)).ToArray();        for (int i = 2; i < limit; i = values[i].Next) {            yield return values[i].N;            int start = i;            while (start < limit) {                Unlink(values, start);                for (int step = 0; step < i && start < limit; step++)                    start = values[start].Next;            }        }    }     static void Unlink(Entry[] values, int index) {        values[values[index].Prev].Next = values[index].Next;        values[values[index].Next].Prev = values[index].Prev;    } } struct Entry{    public Entry(int n) : this() {        N = n;        Prev = n - 1;        Next = n + 1;    }     public int N { get; }    public int Prev { get; set; }    public int Next { get; set; }}"
int i = 1024;while(i > 0){   System.Console.WriteLine(i);   i /= 2;}
using System; class Program{    static void Main(string[] args)    {        for (int i = 1; ; i++)        {            Console.Write(i);            if (i == 10) break;            Console.Write(strv);        }        Console.WriteLine();    }}
while (true){    Console.WriteLine(strv);}
"using System; class Program {    static void Main(string[] args) {        int[,] a =  int[10, 10];        Random r =  Random();         for (int i = 0; i < 10; i++) {            for (int j = 0; j < 10; j++) {                a[i, j] = r.Next(0, 20) + 1;            }        }         for (int i = 0; i < 10; i++) {            for (int j = 0; j < 10; j++) {                Console.Write(strv, a[i, j]);                if (a[i, j] == 20) {                    goto Done;                }            }            Console.WriteLine();        }    Done:        Console.WriteLine();    }}using System;using System.Collections.Generic;using System.Linq; class Program {    static void Main(string[] args) {            int[,] a =  int[10, 10];            Random r =  Random();             // prepare linq statement with two 'from' which makes nested loop            var pairs = from i in Enumerable.Range(0, 10)                        from j in Enumerable.Range(0, 10)                        select  { i = i, j = j};             // iterates through the full nested loop with a sigle foreach statement            foreach (var p in pairs)            {                a[p.i, p.j] = r.Next(0, 20) + 1;            }             // iterates through the nested loop until find element = 20            pairs.Any(p => { Console.Write(strv, a[p.i, p.j]); return a[p.i, p.j] == 20; });            Console.WriteLine();    }}"
"string[] things = {strv, strv, strv}; foreach (string thing in things){    Console.WriteLine(thing);}"
using System; class Program {    static void Main(string[] args)    {        for (int i = 0; i < 5; i++)        {            for (int j = 0; j <= i; j++)            {                Console.Write(strv);            }            Console.WriteLine();        }    }}
for (int i = 10; i >= 0; i--){   Console.WriteLine(i);}(doseq [x (range 10 -1 -1)] (println x))
"using System; class Program {    static void Main(string[] args) {            for (int i = 2; i <= 8; i+= 2) {                    Console.Write(strv, i);        }         Console.WriteLine(strv);    }}"
using System; class Program {    static void Main(string[] args) {        for (int i = 1; i <= 10; i++) {            Console.Write(i);             if (i % 5 == 0) {                Console.WriteLine();                continue;            }             Console.Write(strv);        }    }}
int a = 0; do{    a += 1;    Console.WriteLine(a);} while (a % 6 != 0);
class Program{    static void Main(string[] args)    {        Random random =  Random();        while (true)        {            int a = random.Next(20);            Console.WriteLine(a);            if (a == 10)                break;            int b = random.Next(20)            Console.WriteLine(b);        }         Console.ReadLine();    }       }
"using System; namespace LongestCommonSubstring{    class Program    {        static void Main(string[] args)        {            Console.WriteLine(lcs(strv, strv));            Console.ReadKey(true);        }         public static string lcs(string a, string b)        {            var lengths =  int[a.Length, b.Length];            int greatestLength = 0;            string output = strv;            for (int i = 0; i < a.Length; i++)            {                for (int j = 0; j < b.Length; j++)                {                    if (a[i] == b[j])                    {                        lengths[i, j] = i == 0 || j == 0 ? 1 : lengths[i - 1, j - 1] + 1;                        if (lengths[i, j] > greatestLength)                        {                            greatestLength = lengths[i, j];                            output = a.Substring(i - greatestLength + 1, greatestLength);                        }                    }                    else                    {                        lengths[i, j] = 0;                    }                }            }            return output;        }    }}//C# program tests the LCSUBSTR (Longest Common Substring) subroutine.using System;namespace LongestCommonSubstring{    class Program    {        static void Main(string[] args)        {            string a = args.Length >= 1 ? args[0] : strv;                                             /*get two arguments (strings).   */            string b = args.Length == 2 ? args[1] : strv;            if (a == strv) a = strv;                                                         /*use this string for a default. */            if (b == strv) b = strv;                                                   /* strv     */            Console.WriteLine(strv, a);                                                 /*echo string  A  to screen.     */            Console.WriteLine(strv, b);                                                 /*echo string  B  to screen.     */            Console.WriteLine(strv, LCsubstr(a, b));                                    /*tell Longest Common Substring. */            Console.ReadKey(true);        }                                                                                           /*stick a fork in it, we're done.*/         /*─────────────────────────────────LCSUBSTR subroutine─────────────────────────────────*/        public static string LCsubstr(string x, string y)                                           /*Longest Common Substring.      */        {            string output = strv;            int lenx = x.Length;                                                                    /*shortcut for using the X length*/            for (int j = 0; j < lenx; j++)                                                          /*step through start points in X.*/            {                for (int k = lenx - j; k > -1; k--)                                                 /*step through string lengths.   */                {                    string common = x.Substring(j, k);                                              /*extract a common substring.    */                    if (y.IndexOf(common) > -1 && common.Length > output.Length) output = common;   /*longest?*/                }                                                                                   /*k*/            }                                                                                       /*j*/            return output;                                                                          /*$  is strv if no common string.  */        }    }}//C# program tests the LCS (Longest Common Substring) subroutine.using System;namespace LongestCommonSubstring{    class Program    {        static void Main(string[] args)        {            string a = args.Length >= 1 ? args[0] : strv;                                             /*get two arguments (strings).   */            string b = args.Length == 2 ? args[1] : strv;            if (a == strv) a = strv;                                                         /*use this string for a default. */            if (b == strv) b = strv;                                                   /* strv     */            Console.WriteLine(strv, a);                                                 /*echo string  A  to screen.     */            Console.WriteLine(strv, b);                                                 /*echo string  B  to screen.     */            Console.WriteLine(strv, lcs(a, b));                                              /*tell Longest Common Substring. */            Console.ReadKey(true);        }                                                                                           /*stick a fork in it, we're done.*/         /*─────────────────────────────────LCS subroutine─────────────────────────────────*/        private static string lcs(string a, string b)        {           if(b.Length<a.Length){ string t=a; a=b; b=t; }           for (int n = a.Length; n > 0; n--)           {              for (int m = a.Length-n; m <= a.Length-n; m++)              {                  string s=a.Substring(m,n);                  if(b.Contains(s)) return(s);              }           }           return strv;        }        } "
"using System;using System.Text;using System.Linq; class Program{    static string lookandsay(string number)    {        StringBuilder result =  StringBuilder();         char repeat = number[0];        number = number.Substring(1, number.Length-1)+strv;        int times = 1;         foreach (char actual in number)        {            if (actual != repeat)            {                result.Append(Convert.ToString(times)+repeat);                times = 1;                repeat = actual;            }            else            {                times += 1;            }        }        return result.ToString();    }     static void Main(string[] args)    {        string num = strv;          foreach (int i in Enumerable.Range(1, 10)) {             Console.WriteLine(num);             num = lookandsay(num);                     }    }} using System;using System.Text.RegularExpressions; namespace RosettaCode_Cs_LookAndSay{    public class Program    {        public static int Main(string[] args)        {            Array.Resize<string>(ref args, 2);            string ls = args[0] ?? strv;            int n;            if (!int.TryParse(args[1], out n)) n = 10;            do {                Console.WriteLine(ls);                if (--n <= 0) break;                ls = say(look(ls));            } while(true);             return 0;        }         public static string[] look(string input)        {            int i = -1;            return Array.FindAll(Regex.Split(input, @strv),                delegate(string p) { ++i; i %= 3; return i == 1; }            );        }         public static string say(string[] groups)        {            return string.Concat(                Array.ConvertAll<string, string>(groups,                    delegate(string p) { return string.Concat(p.Length, p[0]); }                )            );        }    }}"
"class Program{    static void Main(string[] args)    {        char[] a = { 'a', 'b', 'c' };        char[] b = { 'A', 'B', 'C' };        int[] c = { 1, 2, 3 };        int min = Math.Min(a.Length, b.Length);        min = Math.Min(min, c.Length);        for (int i = 0; i < min; i++)            Console.WriteLine(strv, a[i], b[i], c[i]);    }             } int[] numbers = { 1, 2, 3, 4 };string[] words = { strv, strv, strv };Console.WriteLine(numbers.Zip(words, (first, second) => first + strv + second));   Console.WriteLine(([] { 1, 2, 3, 4 }).Zip([] { strv, strv, strv }, (f, s) => f + strv + s));          public static void Multiloop(char[] A, char[] B, int[] C)        {            var max = Math.Max(Math.Max(A.Length, B.Length), C.Length);            for (int i = 0; i < max; i++)               Console.WriteLine($strv);        } Multiloop( char[] { 'a', 'b', 'c', 'd' },  char[] { 'A', 'B', 'C' },  int[] { 1, 2, 3, 4, 5 });"
"using System; namespace LCS{    class Program    {        static void Main(string[] args)        {            string word1 = strv;            string word2 = strv;             Console.WriteLine(lcsBack(word1, word2));            Console.ReadKey();        }         public static string lcsBack(string a, string b)        {            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);             if (a.Length == 0 || b.Length == 0)                            return strv;            else if (a[a.Length - 1] == b[b.Length - 1])                return lcsBack(aSub, bSub) + a[a.Length - 1];            else            {                string x = lcsBack(a, bSub);                string y = lcsBack(aSub, b);                return (x.Length > y.Length) ? x : y;            }        }    }}"
"using System; namespace LogicalOperations{    class Program    {        static void Main(string[] args)        {            bool a = true, b = false;            Console.WriteLine(strv, a && b);            Console.WriteLine(strv, a || b);            Console.WriteLine(strv, !a);            Console.WriteLine(strv, a ^ b);        }    }}"
"using System;using System.Numerics; class Program {    static void Main() {        BigInteger pow2_64 = BigInteger.Pow(2, 64);        BigInteger result = BigInteger.Multiply(pow2_64, pow2_64);        Console.WriteLine(result);    }}"
int a = 42;int b = 0x2a;byte x = 500;
"using System.Linq; static class Program{  static void Main()  {    var ts =      from a in Enumerable.Range(1, 20)      from b in Enumerable.Range(a, 21 - a)      from c in Enumerable.Range(b, 21 - b)      where a * a + b * b == c * c      select  { a, b, c };       foreach (var t in ts)        System.Console.WriteLine(strv, t.a, t.b, t.c);  }} "
"string path = @strv;string multiline = @""Line 1.
Line 2.
Line 3."";"
" using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace FreeCellDeals{    public class LCG    {        private int _state;        public bool Microsoft { get; set;}        public bool BSD        {            get            {                return !Microsoft;            }            set            {                Microsoft = !value;            }        }         public LCG(bool microsoft = true)        {            _state = (int)DateTime.Now.Ticks;            Microsoft = microsoft;        }         public LCG(int n, bool microsoft = true)        {            _state = n;            Microsoft = microsoft;        }         public int Next()        {            if (BSD)            {                return _state = (1103515245 * _state + 12345) & int.MaxValue;            }            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;        }         public IEnumerable<int> Seq()        {            while (true)            {                yield return Next();            }        }    }     class Program    {        static void Main()        {            LCG ms =  LCG(0, true);            LCG bsd =  LCG(0,false);            Console.WriteLine(strv);            ms.Seq().Take(10).ToList().ForEach(Console.WriteLine);            Console.WriteLine(""BSD"");            bsd.Seq().Take(10).ToList().ForEach(Console.WriteLine);            Console.ReadKey();        }    }} "
" using System;using System.Numerics; namespace LeftFactorial{    class Program    {        static void Main(string[] args)        {            for (int i = 0; i <= 10; i++)            {                Console.WriteLine(string.Format(strv, i, LeftFactorial(i)));            }             for (int j = 20; j <= 110; j += 10)            {                Console.WriteLine(string.Format(strv, j, LeftFactorial(j)));            }             for (int k = 1000; k <= 10000; k += 1000)            {                Console.WriteLine(string.Format(strv, k, LeftFactorial(k).ToString().Length));            }             Console.ReadKey();        }         private static BigInteger Factorial(int number)        {            BigInteger accumulator = 1;             for (int factor = 1; factor <= number; factor++)            {                accumulator *= factor;            }             return accumulator;        }         private static BigInteger LeftFactorial(int n)        {            BigInteger result = 0;             for (int i = 0; i < n; i++)            {                result += Factorial(i);            }             return result;        }    }}  using System;using System.Numerics; namespace LeftFactorial{    class Program    {        static void Main(string[] args)        {            for (int i = 0; i <= 10; i++)            {                Console.WriteLine(string.Format(strv, i, LeftFactorial(i)));            }             for (int j = 20; j <= 110; j += 10)            {                Console.WriteLine(string.Format(strv, j, LeftFactorial(j)));            }             for (int k = 1000; k <= 10000; k += 1000)            {                Console.WriteLine(string.Format(strv, k, LeftFactorial(k).ToString().Length));            }             Console.ReadKey();        }         private static BigInteger LeftFactorial(int n)        {            BigInteger result = 0;            BigInteger subResult = 1;             for (int i = 0; i < n; i++)            {                if (i == 0)                {                    subResult = 1;                }                else                {                    subResult *= i;                }                 result += subResult;            }             return result;        }    }} "
"using System;using System.Collections.Generic;using System.IO;using System.Linq; class Program{    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)    {        var dictionary =  SortedDictionary<TItem, int>();        foreach (var item in items)        {            if (dictionary.ContainsKey(item))            {                dictionary[item]++;            }            else            {                dictionary[item] = 1;            }        }        return dictionary;    }     static void Main(string[] arguments)    {        var file = arguments.FirstOrDefault();        if (File.Exists(file))        {            var text = File.ReadAllText(file);            foreach (var entry in GetFrequencies(text))            {                Console.WriteLine(strv, entry.Key, entry.Value);            }        }    }} var freq =  from c in str            where char.IsLetter(c)            orderby c            group c by c into g            select g.Key + strv + g.Count(); foreach(var g in freq)    Console.WriteLine(g); "
"using System; namespace LevenshteinDistance{    class Program    {        static int LevenshteinDistance(string s, string t)        {            int n = s.Length;            int m = t.Length;            int[,] d =  int[n + 1, m + 1]; 	    if (n == 0)	    {		return m;	    } 	    if (m == 0)	    {		return n;	    }             for (int i = 0; i <= n; i++)                d[i, 0] = i;            for (int j = 0; j <= m; j++)                d[0, j] = j;             for (int j = 1; j <= m; j++)                for (int i = 1; i <= n; i++)                    if (s[i - 1] == t[j - 1])                        d[i, j] = d[i - 1, j - 1];  //no operation                    else                        d[i, j] = Math.Min(Math.Min(                            d[i - 1, j] + 1,    //a deletion                            d[i, j - 1] + 1),   //an insertion                            d[i - 1, j - 1] + 1 //a substitution                            );            return d[n, m];        }         static void Main(string[] args)        {            if (args.Length == 2)                Console.WriteLine(strv,                    args[0], args[1], LevenshteinDistance(args[0], args[1]));            else                Console.WriteLine(""Usage:-LevenshteinDistance <string1> <string2>"");        }    }}"
"using System; class Program{    static void Main()    {        foreach (var year in [] { 1900, 1994, 1996, DateTime.Now.Year })        {            Console.WriteLine(strv,                              year,                              DateTime.IsLeapYear(year) ? string.Empty : strv);        }    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace ConsoleApplication1{    class Program    {        static void Main(string[] args)        {            string pokemon_names = @""audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask"";             string[] pokemon = pokemon_names.Split( char[]{' ',''});            List<string> chain =  List<string>(pokemon.Length);             for (int i = 0; i < pokemon.Length; i++)            {                swap(ref pokemon[0], ref pokemon[i]);                Search( pokemon, chain, 1 );                               swap(ref pokemon[0], ref pokemon[i]);            }             foreach (string s in chain)                Console.WriteLine(s);             Console.ReadKey();        }         static void Search(string[] pokemon, List<string> longest_chain, int len )        {            if (len > longest_chain.Count)            {                longest_chain.Clear();                for (int i = 0; i < len; i++)                    longest_chain.Add(pokemon[i]);            }             char lastchar = pokemon[len - 1][pokemon[len-1].Length - 1];            for (int i = len; i < pokemon.Length; i++)            {                if (pokemon[i][0] == lastchar)                {                    swap(ref pokemon[i], ref pokemon[len]);                    Search(pokemon, longest_chain, len + 1);                    swap(ref pokemon[i], ref pokemon[len]);                }            }        }         static void swap(ref string s1, ref string s2)        {            string tmp = s1;            s1 = s2;            s2 = tmp;        }    }}"
"using System;using System.Collections.Generic; class Node{	public enum Colors	{		Black, White, Gray	} 	public Colors color { get; set; }	public int N { get; } 	public Node(int n)	{		N = n;		color = Colors.White;	}} class Graph{	public HashSet<Node> V { get; }	public Dictionary<Node, HashSet<Node>> Adj { get; } 	
	
	
	public void Kosaraju()	{		var L =  HashSet<Node>(); 		Action<Node> Visit = null;		Visit = (u) =>		{			if (u.color == Node.Colors.White)			{				u.color = Node.Colors.Gray; 				foreach (var v in Adj[u])					Visit(v); 				L.Add(u);			}		}; 		Action<Node, Node> Assign = null;		Assign = (u, root) =>		{			if (u.color != Node.Colors.Black)			{				if (u == root)					Console.Write(strv); 				Console.Write(u.N + strv);				u.color = Node.Colors.Black; 				foreach (var v in Adj[u])					Assign(v, root); 				if (u == root)					Console.WriteLine();			}		}; 		foreach (var u in V)			Visit(u); 		foreach (var u in L)			Assign(u, u);	}}"
"Using System;class Program{    static int gcd(int m, int n)    {        return n == 0 ? Math.Abs(m) : gcd(n, n % m);    }    static int lcm(int m, int n)    {        return Math.Abs(m * n) / gcd(m, n);    }    static void Main()    {        Console.WriteLine(strv + lcm(12,18));    }} "
"using System;using System.Collections.Generic;using System.Linq; class Program{    static void Main(string[] args)    {        var source1 =  int[] { 1, 34, 3, 98, 9, 76, 45, 4 };        var source2 =  int[] { 54, 546, 548, 60 };         var largest1 = LargestPossibleSequence(source1);        var largest2 = LargestPossibleSequence(source2);         Console.WriteLine(strv, largest1);        Console.WriteLine(strv, largest2);    }     static long LargestPossibleSequence(int[] ints)    {        return long.Parse(string.Join(strv, ints.OrderBy(i => i,  IntConcatenationComparer()).Reverse()));    }} class IntConcatenationComparer : IComparer<int>{    public int Compare(int x, int y)    {        var xy = int.Parse(x.ToString() + y.ToString());        var yx = int.Parse(y.ToString() + x.ToString());         return xy - yx;    }} "
"using System;using System.Collections.Generic;using System.Globalization;using System.Linq; namespace RosettaCode.LastFridaysOfYear{    internal static class Program    {        private static IEnumerable<DateTime> LastFridaysOfYear(int year)        {            for (var month = 1; month <= 12; month++)            {                var date =  DateTime(year, month, 1).AddMonths(1).AddDays(-1);                while (date.DayOfWeek != DayOfWeek.Friday)                {                    date = date.AddDays(-1);                }                yield return date;            }        }         private static void Main(string[] arguments)        {            int year;            var argument = arguments.FirstOrDefault();            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))            {                year = DateTime.Today.Year;            }             foreach (var date in LastFridaysOfYear(year))            {                Console.WriteLine(date.ToString(strv, CultureInfo.InvariantCulture));            }        }    }}"
"using System;using System.Collections.Generic; namespace prog{	class MainClass	{			const int N = 8; 		readonly static int[,] moves = { {+1,-2},{+2,-1},{+2,+1},{+1,+2},			                         {-1,+2},{-2,+1},{-2,-1},{-1,-2} };		struct ListMoves		{			public int x, y;						public ListMoves( int _x, int _y ) { x = _x; y = _y; }		}		 		public static void Main (string[] args)		{			int[,] board =  int[N,N];			board.Initialize(); 			int x = 0,						// starting position			    y = 0; 			List<ListMoves> list =  List<ListMoves>(N*N);			list.Add(  ListMoves(x,y) ); 			do			{												if ( Move_Possible( board, x, y ) )				{															int move = board[x,y];										board[x,y]++;					x += moves[move,0];					y += moves[move,1];								list.Add(  ListMoves(x,y) );											}				else				{										if ( board[x,y] >= 8 )					{												board[x,y] = 0;																						list.RemoveAt(list.Count-1);												if ( list.Count == 0 )						{							Console.WriteLine( strv );							return;						}								x = list[list.Count-1].x;						y = list[list.Count-1].y;											}					board[x,y]++;				}							}			while( list.Count < N*N ); 			int last_x = list[0].x,			    last_y = list[0].y;			string letters = strv;			for( int i=1; i<list.Count; i++ )			{								Console.WriteLine( string.Format(strv, i) + letters[last_x] + (last_y+1) + strv + letters[list[i].x] + (list[i].y+1) ); 				last_x = list[i].x;				last_y = list[i].y;			}		} 		static bool Move_Possible( int[,] board, int cur_x, int cur_y )		{						if ( board[cur_x,cur_y] >= 8 ) 				return false; 			int new_x = cur_x + moves[board[cur_x,cur_y],0],			    new_y = cur_y + moves[board[cur_x,cur_y],1]; 			if ( new_x >= 0 && new_x < N && new_y >= 0 && new_y < N && board[new_x,new_y] == 0 )				return true; 			return false;		}	}}"
"using System; namespace LangtonAnt{    public struct Point    {        public int X;        public int Y;         public Point(int x, int y)        {            X = x;            Y = y;        }    }     enum Direction    {        North, East, West, South    }     public class Langton    {        public readonly bool [,] IsBlack;        private Point _origin;        private Point _antPosition =  Point(0, 0);        public bool OutOfBounds { get; set;}         // I don't see any mention of what direction the ant is supposed to start out in        private Direction _antDirection = Direction.East;         private readonly Direction[] _leftTurn = [] { Direction.West, Direction.North, Direction.South, Direction.East };        private readonly Direction[] _rightTurn = [] { Direction.East, Direction.South, Direction.North, Direction.West };        private readonly int[] _xInc = [] { 0, 1,-1, 0};        private readonly int[] _yInc = [] {-1, 0, 0, 1};         public Langton(int width, int height, Point origin)        {            _origin = origin;            IsBlack =  bool[width, height];            OutOfBounds = false;        }         public Langton(int width, int height) : this(width, height,  Point(width / 2, height / 2)) {}         private void MoveAnt()        {            _antPosition.X += _xInc[(int)_antDirection];            _antPosition.Y += _yInc[(int)_antDirection];        }         public Point Step()        {            if (OutOfBounds)            {                throw  InvalidOperationException(strv);            }            Point ptCur =  Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);            bool leftTurn = IsBlack[ptCur.X, ptCur.Y];            int iDirection = (int) _antDirection;            _antDirection = leftTurn ? _leftTurn[iDirection] : _rightTurn[iDirection];            IsBlack[ptCur.X, ptCur.Y] = !IsBlack[ptCur.X, ptCur.Y];            MoveAnt();            ptCur =  Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);            OutOfBounds =                 ptCur.X < 0 ||                ptCur.X >= IsBlack.GetUpperBound(0) ||                ptCur.Y < 0 ||                ptCur.Y >= IsBlack.GetUpperBound(1);            return _antPosition;        }    }    class Program    {        static void Main()        {            Langton ant =  Langton(100, 100);             while (!ant.OutOfBounds) ant.Step();             for (int iRow = 0; iRow < 100; iRow++)            {                for (int iCol = 0; iCol < 100; iCol++)                {                    Console.Write(ant.IsBlack[iCol, iRow] ? strv : strv);                }                Console.WriteLine();            }             Console.ReadKey();        }    }} "
"/*Knapsack
 
  This model finds the integer optimal packing of a knapsack
 
  Nigel_Galloway
  January 29th., 2012
*/using Microsoft.SolverFoundation.Services; namespace KnapU{    class Item {        public string Name {get; set;}        public int Value {get; set;}        public double Weight {get; set;}        public double Volume {get; set;}         public Item(string name, int value, double weight, double volume) {            Name = name;            Value = value;            Weight = weight;            Volume = volume;        }    }     class Program    {        static void Main(string[] args)        {            SolverContext context = SolverContext.GetContext();            Model model = context.CreateModel();            Item[] Knapsack =  Item[] {                 Item(strv, 3000, 0.3, 0.025),                 Item(strv, 1800, 0.2, 0.015),                 Item(strv, 2500, 2.0, 0.002)            };            Set items =  Set(Domain.Any, strv);            Decision take =  Decision(Domain.IntegerNonnegative, strv, items);            model.AddDecision(take);            Parameter value =  Parameter(Domain.IntegerNonnegative, strv, items);            value.SetBinding(Knapsack, strv, strv);            Parameter weight =  Parameter(Domain.RealNonnegative, strv, items);            weight.SetBinding(Knapsack, strv, strv);            Parameter volume =  Parameter(Domain.RealNonnegative, strv, items);            volume.SetBinding(Knapsack, strv, strv);            model.AddParameters(value, weight, volume);            model.AddConstraint(strv, Model.Sum(Model.ForEach(items, t => take[t] * weight[t])) <= 25);            model.AddConstraint(strv, Model.Sum(Model.ForEach(items, t => take[t] * volume[t])) <= 0.25);            model.AddGoal(strv, GoalKind.Maximize, Model.Sum(Model.ForEach(items, t => take[t] * value[t])));            Solution solution = context.Solve( SimplexDirective());            Report report = solution.GetReport();            System.Console.Write(strv, report);        }    }}"
string chr = string.Empty;if(Console.KeyAvailable)  chr = Console.ReadKey().Key.ToString();
"using System;using System.Collections.Generic; namespace Tests_With_Framework_4{ class Bag : IEnumerable<Bag.Item>        {            List<Item> items;            const int MaxWeightAllowed = 400;             public Bag()            {                items =  List<Item>();            }             void AddItem(Item i)            {                if ((TotalWeight + i.Weight) <= MaxWeightAllowed)                    items.Add(i);            }             public void Calculate(List<Item> items)            {                foreach (Item i in Sorte(items))                {                    AddItem(i);                }            }             List<Item> Sorte(List<Item> inputItems)            {                List<Item> choosenItems =  List<Item>();                for (int i = 0; i < inputItems.Count; i++)                {                    int j = -1;                    if (i == 0)                    {                        choosenItems.Add(inputItems[i]);                    }                    if (i > 0)                    {                        if (!RecursiveF(inputItems, choosenItems, i, choosenItems.Count - 1, false, ref j))                        {                            choosenItems.Add(inputItems[i]);                        }                    }                }                return choosenItems;            }             bool RecursiveF(List<Item> knapsackItems, List<Item> choosenItems, int i, int lastBound, bool dec, ref int indxToAdd)            {                if (!(lastBound < 0))                {                    if ( knapsackItems[i].ResultWV < choosenItems[lastBound].ResultWV )                    {                        indxToAdd = lastBound;                    }                    return RecursiveF(knapsackItems, choosenItems, i, lastBound - 1, true, ref indxToAdd);                }                if (indxToAdd > -1)                {                    choosenItems.Insert(indxToAdd, knapsackItems[i]);                    return true;                }                return false;            }             #region IEnumerable<Item> Members            IEnumerator<Item> IEnumerable<Item>.GetEnumerator()            {                foreach (Item i in items)                    yield return i;            }            #endregion             #region IEnumerable Members            System..IEnumerator System..IEnumerable.GetEnumerator()            {                return items.GetEnumerator();            }            #endregion             public int TotalWeight            {                get                {                    var sum = 0;                    foreach (Item i in this)                    {                        sum += i.Weight;                    }                    return sum;                }            }             public class Item            {                public string Name { get; set; } public int Weight { get; set; } public int Value { get; set; } public int ResultWV { get { return  Weight-Value; } }                public override string ToString()                {                    return strv + Name + strv + Weight + strv + Value + strv + ResultWV;                }            }        }     class Program    {        static void Main(string[] args)        {List<Bag.Item> knapsackItems =  List<Bag.Item>();            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 9, Value = 150 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 153, Value = 200 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 13, Value = 35 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 50, Value = 160 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 15, Value = 60 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 68, Value = 45 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 27, Value = 60 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 39, Value = 40 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 23, Value = 30 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 52, Value = 10 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 11, Value = 70 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 32, Value = 30 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 24, Value = 15 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 48, Value = 10 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 73, Value = 40 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 42, Value = 70 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 22, Value = 80 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 7, Value = 20 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 18, Value = 12 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 4, Value = 50 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 30, Value = 10 });            knapsackItems.Add( Bag.Item() { Name = strv, Weight = 43, Value = 75 });             Bag b =  Bag();            b.Calculate(knapsackItems);            b.All(x => { Console.WriteLine(x); return true; });            Console.WriteLine(b.Sum(x => x.Weight));            Console.ReadKey();        }    }}"
"if (x > 0) goto positive;    else goto negative; positive:    Console.WriteLine(""pos""); goto both; negative:    Console.WriteLine(""neg""); both:    ...goto (x > 0 ? positive : negative);for (i = 0; ...) {    for (j = 0; ...) {        if (condition_met) goto finish;    }}goto danger;for (i = 0; i < 10; i++) {    danger: /* unless you jumped here with i set to a proper value */    Console.WriteLine(strv, i);} int i = 0;tryAgain:try {    i++;    if (i < 10) goto tryAgain;}catch {    goto tryAgain;}finally {    goto end; // This is completely unnecessary, just here to demonstrate.}end: "
"public static void KnuthShuffle<T>(T[] array){    System.Random random =  System.Random();    for (int i = 0; i < array.Length; i++)    {        int j = random.Next(i, array.Length); // Don't select from the entire array on subsequent loops        T temp = array[i]; array[i] = array[j]; array[j] = temp;    }}"
"using System.Drawing;// Note: You have to add the System.Drawing assembly //  (right-click strv Add Reference, Assemblies, Framework,//    System.Drawing, OK)using System.Linq; namespace RosettaJuliaSet{    class Program    {        static void Main(string[] args)        {            const int w = 800;            const int h = 600;            const int zoom = 1;            const int maxiter = 255;            const int moveX = 0;            const int moveY = 0;            const double cX = -0.7;            const double cY = 0.27015;            double zx, zy, tmp;            int i;             var colors = (from c in Enumerable.Range(0, 256)                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();             var bitmap =  Bitmap(w, h);            for (int x = 0; x < w; x++)            {                for (int y = 0; y < h; y++)                {                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;                    i = maxiter;                    while (zx * zx + zy * zy < 4 && i > 1)                    {                        tmp = zx * zx - zy * zy + cX;                        zy = 2.0 * zx * zy + cY;                        zx = tmp;                        i -= 1;                    }                    bitmap.SetPixel(x, y, colors[i]);                }            }            bitmap.Save(strv);        }    }}          public struct CalculatedPoint        {            public int x;            public int y;            public int i;        }         static void MultiThreaded()        {            const int w = 800;            const int h = 600;            const int zoom = 1;            const int maxiter = 255;            const int moveX = 0;            const int moveY = 0;            const double cX = -0.7;            const double cY = 0.27015;             // Precalculate a pallette of 256 colors            var colors = (from c in Enumerable.Range(0, 256)                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();             // The strv below invokes PLINQ, making evaluation parallel using as many cores as            // are available.            var calculatedPoints = Enumerable.Range(0, w * h).AsParallel().Select(xy =>              {                  double zx, zy, tmp;                  int x, y;                  int i = maxiter;                  y = xy / w;                  x = xy % w;                  zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;                  zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;                  while (zx * zx + zy * zy < 4 && i > 1)                  {                      tmp = zx * zx - zy * zy + cX;                      zy = 2.0 * zx * zy + cY;                      zx = tmp;                      i -= 1;                  }                  return  CalculatedPoint { x = x, y = y, i = i };              });             // Bitmap is not multi-threaded, so main thread needs to read in the results as they            // come in and plot the pixels.            var bitmap =  Bitmap(w, h);            foreach (CalculatedPoint cp in calculatedPoints)                bitmap.SetPixel(cp.x, cp.y, colors[cp.i]);            bitmap.Save(strv);        }"
"using System; class Program{  public static bool JortSort<T>(T[] array) where T : IComparable, IEquatable<T>  {    // sort the array    T[] originalArray = (T[]) array.Clone();    Array.Sort(array);     // compare to see if it was originally sorted    for (var i = 0; i < originalArray.Length; i++)    {      if (!Equals(originalArray[i], array[i]))      {        return false;      }    }     return true;  }}"
"using System;using System.Collections.Generic; public class KaprekarNumbers {     
    
    
    public static void Main() {        int count = 0;         foreach ( ulong i in _kaprekarGenerator(999999) ) {            Console.WriteLine(i);            count++;        }         Console.WriteLine(strv, count);    }     
    
    
    
    
    private static IEnumerable<ulong> _kaprekarGenerator(ulong max) {         ulong next = 1;         // 1 is always a Kaprekar number.        yield return next;         for ( next = 2; next <= max; next++ ) {             ulong square = next * next;             for ( ulong check = 10; check <= 10000000000000000000; check *= 10 ) {                // Check the square against each power of 10 from 10^1 to 10^19 (highest which can be                // represented by a ulong)                 // If the power of 10 to be checked against is greater than or equal to the square, stop checking                if ( square <= check )                    break;                 // Given a power of 10 as 10^n, the remainder when dividing the square number by that power                // of 10 is equal to the last n digits of the number (starting from the right) and the                // quotient gives the remaining digits.                // If the last n digits are all zeroes, then the remainder will be zero, which is not                // accepted.                 ulong r = square % check;                ulong q = (square - r) / check;                 if ( r != 0 && q + r == next ) {                    yield return next;                    break;                }            }         }     } }"
"using System; class JensensDevice{        public static double Sum(ref int i, int lo, int hi, Func<double> term)    {        double temp = 0.0;        for (i = lo; i <= hi; i++)        {            temp += term();        }        return temp;    }     static void Main()    {        int i = 0;        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));    }}"
"using System;using System.Reflection; namespace Rosetta_Introspection{	static public class Program	{		static public int bloop = -10;		static public int bloop2 = -20; 		public static void Main()		{			var asm = Assembly.GetExecutingAssembly();			var version = int.Parse(asm.ImageRuntimeVersion.Split('.')[0].Substring(1));			if (version < 4)			{				Console.WriteLine(strv);				return;			} 			FieldInfo bloopField = null; 			foreach (var type in asm.GetExportedTypes())			{				foreach (var field in type.GetFields())				{					if (field.Name != strv)					{						continue;					}					bloopField = field;					if (bloopField.FieldType != (int))					{						throw  InvalidProgramException(strv);					}					break;				}				if (bloopField != null)				{					break;				}			} 			if (bloopField == null)			{				throw  InvalidProgramException(strv);			}			foreach (var refAsm in AppDomain.CurrentDomain.GetAssemblies())			{				foreach (var type in refAsm.GetExportedTypes())				{					if (type.Name == strv)					{						var absMethod = type.GetMethod(strv,  Type[] { (int) });						if (absMethod != null)						{							Console.WriteLine(strv, absMethod.Invoke(null,  object[] { bloopField.GetValue(null) }));						}					}				}			} 			int intCount = 0;			int total = 0; 			foreach (var type in asm.GetExportedTypes())			{				foreach (var field in type.GetFields())				{					if (field.FieldType == (int))					{						intCount++;						total += (int)field.GetValue(null);					}				}			}			Console.WriteLine(strv, intCount, total);			Console.ReadKey();		}	}} "
using System;using System.Numerics; class Program{    static void Main()    {        BigInteger i = 1;        while (true)        {            Console.WriteLine(i++);        }    }}
"using System;using System.Collections.Generic;using System.Web.Script.Serialization; class Program{    static void Main()    {        var people =  Dictionary<string, object> {{strv, strv}, {strv, strv}};        var serializer =  JavaScriptSerializer();         var json = serializer.Serialize(people);        Console.WriteLine(json);         var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);        Console.WriteLine(deserialized[strv]);         var jsonObject = serializer.DeserializeObject(@strvstrvstrvstrvstrvstrvstrv);        var data = jsonObject as Dictionary<string, object>;        var array = data[strv] as object[];        Console.WriteLine(array[1]);    }}"
"using System;using System.Collections.Generic;using System.IO;using System.Linq; class InvertedIndex{    static Dictionary<TItem, IEnumerable<TKey>> Invert<TKey, TItem>(Dictionary<TKey, IEnumerable<TItem>> dictionary)    {        return dictionary            .SelectMany(keyValuePair => keyValuePair.Value.Select(item =>  KeyValuePair<TItem, TKey>(item, keyValuePair.Key)))            .GroupBy(keyValuePair => keyValuePair.Key)            .ToDictionary(group => group.Key, group => group.Select(keyValuePair => keyValuePair.Value));    }     static void Main()    {        Console.Write(strv);        var files = Console.ReadLine();        Console.Write(strv);        var find = Console.ReadLine();        var dictionary = files.Split().ToDictionary(file => file, file => File.ReadAllText(file).Split().AsEnumerable());        Console.WriteLine(strv, find, string.Join(strv, Invert(dictionary)[find]));    }}"
using System; public class IntegerOverflow{    public static void Main() {         {            Console.WriteLine(strv);            Console.WriteLine(-(-2147483647 - 1));            Console.WriteLine(2000000000 + 2000000000);            Console.WriteLine(-2147483647 - 2147483647);            Console.WriteLine(46341 * 46341);            Console.WriteLine((-2147483647 - 1) / -1);            Console.WriteLine();             Console.WriteLine(strv);            Console.WriteLine(-(-9223372036854775807L - 1));            Console.WriteLine(5000000000000000000L + 5000000000000000000L);            Console.WriteLine(-9223372036854775807L - 9223372036854775807L);            Console.WriteLine(3037000500L * 3037000500L);            Console.WriteLine((-9223372036854775807L - 1) / -1);            Console.WriteLine();             Console.WriteLine(strv);            //Negating a 32-bit unsigned integer will convert it to a signed 64-bit integer.            Console.WriteLine(-4294967295U);            Console.WriteLine(3000000000U + 3000000000U);            Console.WriteLine(2147483647U - 4294967295U);            Console.WriteLine(65537U * 65537U);            Console.WriteLine();             Console.WriteLine(strv);            // The - operator cannot be applied to 64-bit unsigned integers; it will always give a compile-time error.            //Console.WriteLine(-18446744073709551615UL);            Console.WriteLine(10000000000000000000UL + 10000000000000000000UL);            Console.WriteLine(9223372036854775807UL - 18446744073709551615UL);            Console.WriteLine(4294967296UL * 4294967296UL);            Console.WriteLine();        }         int i = 2147483647;        Console.WriteLine(i + 1);        try {             { Console.WriteLine(i + 1); }        } catch (OverflowException) {            Console.WriteLine(strv);        }    } }
"using System; class Program{    static void Main()    {        int a = int.Parse(Console.ReadLine());        int b = int.Parse(Console.ReadLine());        if (a < b)            Console.WriteLine(strv, a, b);        if (a == b)            Console.WriteLine(strv, a, b);        if (a > b)            Console.WriteLine(strv, a, b);    }}"
"interface ICamera {    // ...} class MobilePhone {    // ...} class CameraPhone: ICamera, MobilePhone {    // ...}"
using System;using System.IO; class Program{    static void Main(string[] args)    {        using (var b =  StreamReader(strv))  //or any other Stream        {            string line;            while ((line = b.ReadLine()) != null)                Console.WriteLine(line);        }    }} 
class Animal{   /* ... */   // ...} class Dog : Animal{   /* ... */   // ...} class Lab : Dog{   /* ... */   // ...} class Collie : Dog{   /* ... */  // ... } class Cat : Animal{   /* ... */  // ... }
using System; class Program{    static double PositiveInfinity()    {        return double.PositiveInfinity;    }     static void Main()    {        Console.WriteLine(PositiveInfinity());    }}
"/* The C# language specification does not give a mechanism for 'including' one source file within another,
 * likely because there is no need - all code compiled within one 'assembly' (individual IDE projects
 * are usually compiled to separate assemblies) can 'see' all other code within that assembly.
 */"
"using System;using System.Collections.Generic;using System.ComponentModel;using System.Drawing;using System.Drawing.Imaging;using System.Linq;using System.Runtime.InteropServices;using System.Windows.Forms; class Program{    static Size size =  Size(320, 240);    static Rectangle rectsize =  Rectangle( Point(0, 0), size);    static int numpixels = size.Width * size.Height;    static int numbytes = numpixels * 3;     static PictureBox pb;    static BackgroundWorker worker;     static double time = 0;    static double frames = 0;    static Random rand =  Random();     static byte tmp;    static byte white = 255;    static byte black = 0;    static int halfmax = int.MaxValue / 2; // more voodoo! calling Next() is faster than Next(2)!     static IEnumerable<byte> YieldVodoo()    {        // Yield 3 times same number (i.e 255 255 255) for numpixels times.          for (int i = 0; i < numpixels; i++)        {            tmp = rand.Next() < halfmax ? black : white; // no more lists!               // no more loops! yield! yield! yield!            yield return tmp;            yield return tmp;            yield return tmp;        }    }     static Image Randimg()    {        // Low-level bitmaps          var bitmap =  Bitmap(size.Width, size.Height);        var data = bitmap.LockBits(rectsize, ImageLockMode.WriteOnly, PixelFormat.Format24bppRgb);         Marshal.Copy(            YieldVodoo().ToArray<byte>(),// source            0, // start            data.Scan0, // scan0 is a pointer to low-level bitmap data            numbytes); // number of bytes in source         bitmap.UnlockBits(data);        return bitmap;    }     [STAThread]    static void Main()    {        var form =  Form();         form.AutoSize = true;        form.Size =  Size(0, 0);        form.Text = strv;         form.FormClosed += delegate        {            Application.Exit();        };         worker =  BackgroundWorker();         worker.DoWork += delegate        {            System..Thread.Sleep(500); // remove try/catch, just wait a bit before looping             while (true)            {                var a = DateTime.Now;                pb.Image = Randimg();                var b = DateTime.Now;                 time += (b - a).TotalSeconds;                frames += 1;                 if (frames == 30)                {                    Console.WriteLine(strv, frames, time, frames / time);                     time = 0;                    frames = 0;                }            }        };         worker.RunWorkerAsync();         FlowLayoutPanel flp =  FlowLayoutPanel();        form.Controls.Add(flp);         pb =  PictureBox();        pb.Size = size;         flp.AutoSize = true;        flp.Controls.Add(pb);         form.Show();        Application.Run();    }}"
string s = strv;s = (int.Parse(s) + 1).ToString();
" using System;using System.Linq; namespace IdentityMatrix{    class Program    {        static void Main(string[] args)        {            if (args.Length != 1)            {                Console.WriteLine(strv);                return;            }            int n;            if (!int.TryParse(args[0], out n))            {                Console.WriteLine(strv);                return;            }             var identity =                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();            foreach (var row in identity)            {                foreach (var elem in row)                {                    Console.Write(strv + elem);                }                Console.WriteLine();            }            Console.ReadKey();        }    }} "
 using System;using System.Net; class Program{    class MyWebClient : WebClient    {        protected override WebRequest GetWebRequest(Uri address)        {            HttpWebRequest request = (HttpWebRequest)base.GetWebRequest(address);            request.ClientCertificates.Add( X509Certificate());            return request;        }    }    static void Main(string[] args)    {        var client =  MyWebClient();         var data = client.DownloadString(strv);         Console.WriteLine(data);    }} 
"    public class IbanValidator : IValidateTypes    {        public ValidationResult Validate(string value)        {            // Check if value is missing            if (string.IsNullOrEmpty(value))                return ValidationResult.ValueMissing;             if (value.Length < 2)                return ValidationResult.ValueTooSmall;             var countryCode = value.Substring(0, 2).ToUpper();             int lengthForCountryCode;             var countryCodeKnown = Lengths.TryGetValue(countryCode, out lengthForCountryCode);            if (!countryCodeKnown)            {                return ValidationResult.CountryCodeNotKnown;            }             // Check length.            if (value.Length < lengthForCountryCode)                return ValidationResult.ValueTooSmall;             if (value.Length > lengthForCountryCode)                return ValidationResult.ValueTooBig;             value = value.ToUpper();            var newIban = value.Substring(4) + value.Substring(0, 4);             newIban = Regex.Replace(newIban, @strv, match => (match.Value[0] - 55).ToString());             var remainder = BigInteger.Parse(newIban) % 97;             if (remainder != 1)                return ValidationResult.ValueFailsModule97Check;             return ValidationResult.IsValid;        }         public enum ValidationResult        {            IsValid,            ValueMissing,            ValueTooSmall,            ValueTooBig,            ValueFailsModule97Check,            CountryCodeNotKnown        }         private static readonly IDictionary<string, int> Lengths =  Dictionary<string, int>        {            {strv, 28},            {strv, 24},            {strv, 20},            {strv, 28},            {strv, 16},            {strv, 22},            {strv, 20},            {strv, 29},            {strv, 22},            {strv, 21},            {strv, 21},            {strv, 28},            {strv, 24},            {strv, 18},            {strv, 28},            {strv, 20},            {strv, 18},            {strv, 18},            {strv, 27},            {strv, 22},            {strv, 22},            {strv, 23},            {strv, 27},            {strv, 18},            {strv, 28},            {strv, 28},            {strv, 26},            {strv, 22},            {strv, 23},            {strv, 27},            {strv, 20},            {strv, 30},            {strv, 21},            {strv, 28},            {strv, 21},            {strv, 20},            {strv, 20},            {strv, 19},            {strv, 31},            {strv, 27},            {strv, 30},            {strv, 27},            {strv, 24},            {strv, 22},            {strv, 18},            {strv, 15},            {strv, 24},            {strv, 29},            {strv, 28},            {strv, 25},            {strv, 24},            {strv, 27},            {strv, 24},            {strv, 22},            {strv, 24},            {strv, 19},            {strv, 24},            {strv, 24},            {strv, 21},            {strv, 24},            {strv, 26},            {strv, 23},            {strv, 22},            {strv, 24}        };    }    public class When_the_IbanValidator_is_told_to_Validate    {        [Fact]        public void It_should_return_an_error_when_there_is_no_value_provided()        {            // Assert            const string value = strv;            var validator =  IbanValidator();             // Act            var result = validator.Validate(value);             // Assert            Assert.Equal(ValidationResult.ValueMissing, result);        }         [Fact]        public void It_should_return_an_error_when_the_value_length_is_to_short()        {            // Assert            const string value = strv;            var validator =  IbanValidator();             // Act            var result = validator.Validate(value);             // Assert            Assert.Equal(ValidationResult.ValueTooSmall, result);        }         [Fact]        public void It_should_return_an_error_when_the_value_length_is_to_big()        {            // Assert            const string value = strv;            var validator =  IbanValidator();             // Act            var result = validator.Validate(value);             // Assert            Assert.Equal(ValidationResult.ValueTooBig, result);        }         [Fact]        public void It_should_return_an_error_when_the_value_fails_the_module_check()        {            // Assert            const string value = strv;            var validator =  IbanValidator();             // Act            var result = validator.Validate(value);             // Assert            Assert.Equal(ValidationResult.ValueFailsModule97Check, result);        }         [Fact]        public void It_should_return_an_error_when_an_unkown_country_prefix_used()        {            // Assert            const string value = strv;            var validator =  IbanValidator();             // Act            var result = validator.Validate(value);             // Assert            Assert.Equal(ValidationResult.CountryCodeNotKnown, result);        }         [Fact]        public void It_should_return_valid_when_a_valid_value_is_provided()        {            // Assert            const string value = strv;            var validator =  IbanValidator();             // Act            var result = validator.Validate(value);             // Assert            Assert.Equal(ValidationResult.IsValid, result);        }         [Fact]        public void It_should_return_valid_when_a_valid_foreign_value_is_provided()        {            // Assert            const string value = strv;            var validator =  IbanValidator();             // Act            var result = validator.Validate(value);             // Assert            Assert.Equal(ValidationResult.IsValid, result);        }    }"
" using System;using System.Net; class Program{    static void Main(string[] args)    {        var client =  WebClient();         // credentials of current user:        client.Credentials = CredentialCache.DefaultCredentials;        // or specify credentials manually:        client.Credentials =  NetworkCredential(strv, strv);         var data = client.DownloadString(strv);         Console.WriteLine(data);    }} "
 using System;using System.Net; class Program{    static void Main(string[] args)    {        var client =  WebClient();        var data = client.DownloadString(strv);         Console.WriteLine(data);    }} 
 using System;using System.Text;using System.Net; class Program{    static void Main(string[] args)    {        WebClient wc =  WebClient();        string content = wc.DownloadString(strv);        Console.WriteLine(content);    }} 
"using System;using System.Collections.Generic; namespace Huffman_Encoding{    public class PriorityQueue<T> where T : IComparable    {        protected List<T> LstHeap =  List<T>();         public virtual int Count        {            get { return LstHeap.Count; }        }         public virtual void Add(T val)        {            LstHeap.Add(val);            SetAt(LstHeap.Count - 1, val);            UpHeap(LstHeap.Count - 1);        }         public virtual T Peek()        {            if (LstHeap.Count == 0)            {                throw  IndexOutOfRangeException(strv);            }             return LstHeap[0];        }         public virtual T Pop()        {            if (LstHeap.Count == 0)            {                throw  IndexOutOfRangeException(strv);            }             T valRet = LstHeap[0];             SetAt(0, LstHeap[LstHeap.Count - 1]);            LstHeap.RemoveAt(LstHeap.Count - 1);            DownHeap(0);            return valRet;        }         protected virtual void SetAt(int i, T val)        {            LstHeap[i] = val;        }         protected bool RightSonExists(int i)        {            return RightChildIndex(i) < LstHeap.Count;        }         protected bool LeftSonExists(int i)        {            return LeftChildIndex(i) < LstHeap.Count;        }         protected int ParentIndex(int i)        {            return (i - 1) / 2;        }         protected int LeftChildIndex(int i)        {            return 2 * i + 1;        }         protected int RightChildIndex(int i)        {            return 2 * (i + 1);        }         protected T ArrayVal(int i)        {            return LstHeap[i];        }         protected T Parent(int i)        {            return LstHeap[ParentIndex(i)];        }         protected T Left(int i)        {            return LstHeap[LeftChildIndex(i)];        }         protected T Right(int i)        {            return LstHeap[RightChildIndex(i)];        }         protected void Swap(int i, int j)        {            T valHold = ArrayVal(i);            SetAt(i, LstHeap[j]);            SetAt(j, valHold);        }         protected void UpHeap(int i)        {            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)            {                Swap(i, ParentIndex(i));                i = ParentIndex(i);            }        }         protected void DownHeap(int i)        {            while (i >= 0)            {                int iContinue = -1;                 if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)                {                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);                }                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)                {                    iContinue = LeftChildIndex(i);                }                 if (iContinue >= 0 && iContinue < LstHeap.Count)                {                    Swap(i, iContinue);                }                 i = iContinue;            }        }    }     internal class HuffmanNode<T> : IComparable    {        internal HuffmanNode(double probability, T value)        {            Probability = probability;            LeftSon = RightSon = Parent = null;            Value = value;            IsLeaf = true;        }         internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)        {            LeftSon = leftSon;            RightSon = rightSon;            Probability = leftSon.Probability + rightSon.Probability;            leftSon.IsZero = true;            rightSon.IsZero = false;            leftSon.Parent = rightSon.Parent = this;            IsLeaf = false;        }         internal HuffmanNode<T> LeftSon { get; set; }        internal HuffmanNode<T> RightSon { get; set; }        internal HuffmanNode<T> Parent { get; set; }        internal T Value { get; set; }        internal bool IsLeaf { get; set; }         internal bool IsZero { get; set; }         internal int Bit        {            get { return IsZero ? 0 : 1; }        }         internal bool IsRoot        {            get { return Parent == null; }        }         internal double Probability { get; set; }         public int CompareTo(object obj)        {            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);        }    }     public class Huffman<T> where T : IComparable    {        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary =  Dictionary<T, HuffmanNode<T>>();        private readonly HuffmanNode<T> _root;         public Huffman(IEnumerable<T> values)        {            var counts =  Dictionary<T, int>();            var priorityQueue =  PriorityQueue<HuffmanNode<T>>();            int valueCount = 0;             foreach (T value in values)            {                if (!counts.ContainsKey(value))                {                    counts[value] = 0;                }                counts[value]++;                valueCount++;            }             foreach (T value in counts.Keys)            {                var node =  HuffmanNode<T>((double) counts[value] / valueCount, value);                priorityQueue.Add(node);                _leafDictionary[value] = node;            }             while (priorityQueue.Count > 1)            {                HuffmanNode<T> leftSon = priorityQueue.Pop();                HuffmanNode<T> rightSon = priorityQueue.Pop();                var parent =  HuffmanNode<T>(leftSon, rightSon);                priorityQueue.Add(parent);            }             _root = priorityQueue.Pop();            _root.IsZero = false;        }         public List<int> Encode(T value)        {            var returnValue =  List<int>();            Encode(value, returnValue);            return returnValue;        }         public void Encode(T value, List<int> encoding)        {            if (!_leafDictionary.ContainsKey(value))            {                throw  ArgumentException(strv);            }            HuffmanNode<T> nodeCur = _leafDictionary[value];            var reverseEncoding =  List<int>();            while (!nodeCur.IsRoot)            {                reverseEncoding.Add(nodeCur.Bit);                nodeCur = nodeCur.Parent;            }             reverseEncoding.Reverse();            encoding.AddRange(reverseEncoding);        }         public List<int> Encode(IEnumerable<T> values)        {            var returnValue =  List<int>();             foreach (T value in values)            {                Encode(value, returnValue);            }            return returnValue;        }         public T Decode(List<int> bitString, ref int position)        {            HuffmanNode<T> nodeCur = _root;            while (!nodeCur.IsLeaf)            {                if (position > bitString.Count)                {                    throw  ArgumentException(strv);                }                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;            }            return nodeCur.Value;        }         public List<T> Decode(List<int> bitString)        {            int position = 0;            var returnValue =  List<T>();             while (position != bitString.Count)            {                returnValue.Add(Decode(bitString, ref position));            }            return returnValue;        }    }     internal class Program    {        private const string Example = strv;         private static void Main()        {            var huffman =  Huffman<char>(Example);            List<int> encoding = huffman.Encode(Example);            List<char> decoding = huffman.Decode(encoding);            var outString =  string(decoding.ToArray());            Console.WriteLine(outString == Example ? strv : strv);             var chars =  HashSet<char>(Example);            foreach (char c in chars)            {                encoding = huffman.Encode(c);                Console.Write(strv, c);                foreach (int bit in encoding)                {                    Console.Write(strv, bit);                }                Console.WriteLine();            }            Console.ReadKey();        }    }}"
"static void Main(){  Console.WriteLine(strv,(int));   if (BitConverter.IsLittleEndian)    Console.WriteLine(strv);  else    Console.WriteLine(strv);}"
"using System;using System.Linq; class Program{    static double Horner(double[] coefficients, double variable)    {        return coefficients.Reverse().Aggregate(                (accumulator, coefficient) => accumulator * variable + coefficient);    }     static void Main()    {        Console.WriteLine(Horner([] { -19.0, 7.0, -4.0, 6.0 }, 3.0));    }}"
System..Dns.GetHostName();
"using System;using System.Collections.Generic;using System.Linq;using System.Windows;using System.Windows.Controls;using System.Windows.Input;using System.Windows.Media;using System.Windows.Shapes; ////////////////////////////////////////////////////////////////////////////////////////////////////// namespace: Honeycombs//// summary:	WPF implementation of Rosetta Code Honeycombs task.  Uses Polygon shapes as hexes.//////////////////////////////////////////////////////////////////////////////////////////////////// namespace Honeycombs{    public partial class MainWindow    {        private const int RowCount = 4;        private const int ColCount = 5;        private const int LabelSize = 20;        private readonly char[] _permutedChars;         public MainWindow()        {            if (RowCount * ColCount > 26)#pragma warning disable 162            {                throw  ArgumentException(strv);            }#pragma warning restore 162            _permutedChars = GetPermutedChars(RowCount * ColCount);             // VS Generated code not included            InitializeComponent();        }         private static char[] GetPermutedChars(int characterCount)        {            const string allChars = strv;            var rnd =  Random();            var chars =  char[allChars.Length];             for (int i = 0; i < allChars.Length; i++)            {                chars[i] = allChars[i];            }             for (int i = 0; i < characterCount; i++)            {                int swapIndex = rnd.Next() % (allChars.Length - i);                char tmp = chars[swapIndex + i];                chars[swapIndex + i] = chars[i];                chars[i] = tmp;            }            return chars;        }         private void SetHexProperties(UIElementCollection hexes, double cellSize)        {            int charIndex = 0;            List<Polygon> hexList = hexes.Cast<Polygon>().ToList();             foreach (Polygon element in hexList)            {                SetHexProperties(element, _permutedChars[charIndex++], cellSize);            }        }         private void SetHexProperties(Polygon hex, char charToSet, double cellSize)        {            var tag = (Tuple<int, int, double, double>) hex.Tag;            double cellX = tag.Item3;            double cellY = tag.Item4;             // We place the text in a grid centered on the hex.            // The grid will then center the text within itself.             var centeringGrid =  Grid();            centeringGrid.Width = centeringGrid.Height = 2 * cellSize;            centeringGrid.SetValue(Canvas.LeftProperty, cellX - cellSize);            centeringGrid.SetValue(Canvas.TopProperty, cellY - cellSize);            centeringGrid.IsHitTestVisible = false;            HoneycombCanvas.Children.Add(centeringGrid);             var label =  TextBlock                {                    Text =  string(charToSet, 1),                    FontFamily =  FontFamily(strv),                    FontSize = LabelSize                };            label.HorizontalAlignment = HorizontalAlignment.Center;            label.VerticalAlignment = VerticalAlignment.Center;            label.IsHitTestVisible = false;            centeringGrid.Children.Add(label);             // Reset the tag to keep track of the character in the hex            hex.Tag = charToSet;            hex.Fill =  SolidColorBrush(Colors.Yellow);            hex.Stroke =  SolidColorBrush(Colors.Black);            hex.StrokeThickness = cellSize / 10;             // Mouse down event handler for the hex            hex.MouseDown += hex_MouseDown;        }         private void hex_MouseDown(object sender, MouseButtonEventArgs e)        {            var hex = sender as Shape;            if (hex == null)            {                throw  InvalidCastException(strv);            }             // Get the letter for this hex            var ch = (char) hex.Tag;             // Add it to our Letters TextBlock            Letters.Text = Letters.Text + ch;             // Color the hex magenta            hex.Fill =  SolidColorBrush(Colors.Magenta);             // Remove the mouse down event handler so we won't hit on this hex again            hex.MouseDown -= hex_MouseDown;        }         private static void GetCombSize(double actualHeight, double actualWidth, int columns, int rows,                                        out double cellSize, out double combHeight, out double combWidth)        {            double columnFactor = (3 * columns + 1) / 2.0;            double rowFactor = (Math.Sqrt(3) * (2 * rows + 1)) / 2.0;            double cellFromWidth = actualWidth / columnFactor;            double cellFromHeight = actualHeight / rowFactor;            cellSize = Math.Min(cellFromWidth, cellFromHeight);            combWidth = cellSize * columnFactor;            combHeight = cellSize * rowFactor;        }         private static void AddCells(Canvas canvas, double cellSize, int columns, int rows)        {            double rowHeight = cellSize * Math.Sqrt(3) / 2;             for (int row = 0; row < rows; row++)            {                AddRow(rowHeight, canvas, cellSize, columns, row);                rowHeight += cellSize * Math.Sqrt(3);            }        }         private static void AddRow(double rowHeight, Canvas canvas, double cellSize, int columnCount, int row)        {            double cellX = cellSize;            double cellHeight = cellSize * Math.Sqrt(3);             for (int col = 0; col < columnCount; col++)            {                double cellY = rowHeight + ((col & 1) == 1 ? cellHeight / 2 : 0);                Polygon hex = GetCenteredHex(cellSize, cellX, cellY, cellHeight);                hex.Tag = Tuple.Create(col, row, cellX, cellY);                canvas.Children.Add(hex);                cellX += 3 * cellSize / 2;            }        }         private static Polygon GetCenteredHex(double cellSize, double cellX, double cellY, double cellHeight)        {            var hex =  Polygon();            hex.Points.Add( Point(cellX - cellSize, cellY));            hex.Points.Add( Point(cellX - cellSize / 2, cellY + cellHeight / 2));            hex.Points.Add( Point(cellX + cellSize / 2, cellY + cellHeight / 2));            hex.Points.Add( Point(cellX + cellSize, cellY));            hex.Points.Add( Point(cellX + cellSize / 2, cellY - cellHeight / 2));            hex.Points.Add( Point(cellX - cellSize / 2, cellY - cellHeight / 2));            return hex;        }         private void Window_Loaded(object sender, RoutedEventArgs e)        {            double combHeight, combWidth, cellSize;             // Get sizes that will fit within our window            GetCombSize(Main.ActualHeight, Main.ActualWidth, ColCount, RowCount, out cellSize, out combHeight,                        out combWidth);             // Set the canvas size appropriately            HoneycombCanvas.Width = combWidth;            HoneycombCanvas.Height = combHeight;             // Add the cells to the canvas            AddCells(HoneycombCanvas, cellSize, ColCount, RowCount);             // Set the cells to look like we want them            SetHexProperties(HoneycombCanvas.Children, cellSize);        }    }}"
"using System; namespace RosettaCode{  internal sealed class Program  {    private static void Main()    {      Func<double> getDouble = () => Convert.ToDouble(Console.ReadLine());      double h = 0, lat, lng, lme, slat, hra, hla;       Console.Write(strv);      lat = getDouble();      Console.Write(strv);      lng = getDouble();      Console.Write(strv);      lme = getDouble();       slat = Math.Sin(lat*2*Math.PI/360);      Console.WriteLine(""    sine of latitude:   {0:0.000}"", slat);      Console.WriteLine(""    diff longitude:     {0:0.000}"", lng-lme);      Console.WriteLine(strv);      for (h = -6; h<6; h++)      {        hra = 15*h;        hra -= lng-lme;        hla = Math.Atan(slat*Math.Tan(hra*2*Math.PI/360))*360/(2*Math.PI);        Console.WriteLine(strv, h, hra, hla);      }    }  }}"
" using System;using System.Linq; namespace HofstadterConway{    class Program    {        static int[] GenHofstadterConway(int max)        {            int[] result =  int[max];            result[0]=result[1]=1;            for (int ix = 2; ix < max; ix++)                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];            return result;        }         static void Main(string[] args)        {            double[] adiv =  double[1 << 20];            {                int[] a = GenHofstadterConway(1 << 20);                for (int i = 0; i < 1 << 20; i++)                    adiv[i] = a[i] / (double)(i + 1);            }            for (int p = 2; p <= 20; p++)            {                var max = Enumerable.Range(                     (1 << (p - 1)) - 1,                     (1 << p) - (1 << (p - 1))                     )                     .Select(ix =>  { I = ix + 1, A = adiv[ix] })                     .OrderByDescending(x => x.A)                     .First();                Console.WriteLine(strv,                    p - 1, p, max.A, max.I);            }            Console.WriteLine(strv,                Enumerable.Range(0, 1 << 20)                    .Last(i => (adiv[i] > 0.55)) + 1                );        }    }} "
"using System;using System.Collections.Generic;using System.Linq; namespace HofstadterFigureFigure{	class HofstadterFigureFigure	{		readonly List<int> _r =  List<int>() {1};		readonly List<int> _s =  List<int>(); 		public IEnumerable<int> R()		{			int iR = 0;			while (true)			{				if (iR >= _r.Count)				{					Advance();				}				yield return _r[iR++];			}		} 		public IEnumerable<int> S()		{			int  = 0;			while (true)			{				if ( >= _s.Count)				{					Advance();				}				yield return _s[++];			}		} 		private void Advance()		{			int rCount = _r.Count;			int oldR = _r[rCount - 1];			int sVal; 			// Take care of first two cases specially since S won't be larger than R at that point			switch (rCount)			{				case 1:					sVal = 2;					break;				case 2:					sVal = 4;					break;				default:					sVal = _s[rCount - 1];					break;			}			_r.Add(_r[rCount - 1] + sVal);			int newR = _r[rCount];			for (int  = oldR + 1;  < newR; ++)			{				_s.Add();			}		}	} 	class Program	{		static void Main()		{			var hff =  HofstadterFigureFigure();			var rs = hff.R();			var arr = rs.Take(40).ToList(); 			foreach(var v in arr.Take(10))			{				Console.WriteLine(strv, v);			} 			var hs =  HashSet<int>(arr);			hs.UnionWith(hff.S().Take(960));			Console.WriteLine(hs.Count == 1000 ? strv : strv);		}	}} "
"using System;using System.Collections;using System.Collections.Specialized;using System.Linq; internal class Program{    private static readonly OrderedDictionary _holidayOffsets =  OrderedDictionary                                                                    {                                                                        {strv, 0},                                                                        {strv, 39},                                                                        {strv, 49},                                                                        {strv, 56},                                                                        {strv, 60},                                                                    };     static void Main(string[] args)    {        Console.WriteLine(strv);        for (int year = 400; year <= 2100; year += 100)            OutputHolidays(year);         Console.WriteLine();        Console.WriteLine(strv);        for (int year = 2010; year <= 2020; year += 1)            OutputHolidays(year);    }     static void OutputHolidays(int year)    {        var easter = CalculateEaster(year);        var holidays = from kp in _holidayOffsets.OfType<DictionaryEntry>()                       let holiday = easter.AddDays(Convert.ToInt32(kp.Value))                       select kp.Key + strv + string.Format(strv, holiday);        Console.WriteLine(strv, year, string.Join(strv, holidays.ToArray()));    }     static DateTime CalculateEaster(int year)    {        var a = year % 19;        var b = year / 100;        var c = year %100;        var d = b / 4;        var e = b % 4;        var f = (b + 8) / 25;        var g = (b - f + 1) / 3;        var h = (19 * a + b - d - g + 15) % 30;        var i = c / 4;        var k = c % 4;        var l = (32 + 2 * e + 2 * i - h - k) % 7;        var m = (a + 11 * h + 22 * l) / 451;        var numerator = h + l - 7 * m + 114;        var month = numerator / 31;        var day = (numerator % 31) + 1;        return  DateTime(year, month, day);    }} "
"using System;using System.Collections.Generic; namespace heron{    class Program{        static void Main(string[] args){                       List<int[]> list =  List<int[]>();            for (int c = 1; c <= 200; c++)                for (int b = 1; b <= c; b++)                    for (int a = 1; a <= b; a++)                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))                            list.Add( int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});            sort(list);            Console.WriteLine(strv + list.Count + ""First ten when ordered by increasing area, then perimeter,then maximum sides:SidesPerimeterArea"");            for(int i = 0; i < 10; i++)                Console.WriteLine(list[i][0] + """" + list[i][1] + """" + list[i][2] + """" + list[i][3] + """" + list[i][4]);            Console.WriteLine(""Perimeter = 210SidesPerimeterArea"");            foreach (int[] i in list)                if (i[4] == 210)                    Console.WriteLine(i[0] + """" + i[1] + """" + i[2] + """" + i[3] + """" + i[4]);             }        static bool isHeron(double heronArea){            return heronArea % 1 == 0 && heronArea != 0;        }        static double heronArea(int a, int b, int c){            double s = (a + b + c) / 2d;            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));        }        static int gcd(int a, int b){            int remainder = 1, dividend, divisor;            dividend = a > b ? a : b;            divisor = a > b ? b : a;            while (remainder != 0){                remainder = dividend % divisor;                if (remainder != 0){                    dividend = divisor;                    divisor = remainder;                }            }            return divisor;        }        static void sort(List<int[]> list){            int[] temp =  int[5];            bool changed = true;            while(changed){                changed = false;                for (int i = 1; i < list.Count; i++)                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){                        temp = list[i];                        list[i] = list[i - 1];                        list[i - 1] = temp;                        changed = true;                    }                            }        }    }}"
"using System.Text;using System.Net.Sockets;using System.Net; namespace WebServer{    class GoodByeWorld    {                static void Main(string[] args)        {            const string msg = ""<html><body>Goodbye, world!</body></html>"";                    const int port = 8080;            bool serverRunning = true;             TcpListener tcpListener =  TcpListener(IPAddress.Any, port);            tcpListener.Start();             while (serverRunning)            {                Socket socketConnection = tcpListener.AcceptSocket();                byte[] bMsg = Encoding.ASCII.GetBytes(msg.ToCharArray(), 0, (int)msg.Length);                socketConnection.Send(bMsg);                socketConnection.Disconnect(true);            }        }    }}namespace Webserver{  using System;  using Nancy;  using Nancy.Hosting.Self;   public class HelloWorldModule : NancyModule  {    public HelloWorldModule()    {      this.Get[strv] = parameters => strv;    }     public static void Main()    {      var uri =  Uri(strv);      using (var host =  NancyHost(uri))      {        host.Start();        Console.WriteLine(strv);        Console.WriteLine(strv);        Console.ReadLine();      }    }  }}"
static class StdErr{    static void Main(string[] args)    {        Console.Error.WriteLine(strv);    }}
"using System;delegate int Func2(int a, int b);class Program{    static int Add(int a, int b)    {        return a + b;    }     static int Mul(int a, int b)    {        return a * b;    }     static int Div(int a, int b)    {        return a / b;    }     static int Call(Func2 f, int a, int b)    {        return f(a, b);    }     static void Main()    {        int a = 6;        int b = 2;         Func2 add =  Func2(Add);        Func2 mul =  Func2(Mul);        Func2 div =  Func2(Div);         Console.WriteLine(strv, a, b, Call(add, a, b));        Console.WriteLine(strv, a, b, Call(mul, a, b));        Console.WriteLine(strv, a, b, Call(div, a, b));    }}using System;delegate int Func2(int a, int b);class Program{    static int Call(Func2 f, int a, int b)    {        return f(a, b);    }     static void Main()    {        int a = 6;        int b = 2;         Console.WriteLine(strv, a, b, Call(delegate(int x, int y) { return x + y; }, a, b));        Console.WriteLine(strv, a, b, Call(delegate(int x, int y) { return x * y; }, a, b));        Console.WriteLine(strv, a, b, Call(delegate(int x, int y) { return x / y; }, a, b));    }}using System;class Program{    static int Call(Func<int, int, int> f, int a, int b)    {        return f(a, b);    }     static void Main()    {        int a = 6;        int b = 2;         Console.WriteLine(strv, a, b, Call((x, y) => x + y, a, b));        Console.WriteLine(strv, a, b, Call((x, y) => x * y, a, b));        Console.WriteLine(strv, a, b, Call((x, y) => x / y, a, b));    }}"
using System; class Program{    static void Main(string[] args)    {        //Using Console.WriteLine() will append a newline        Console.WriteLine(strv);         //Using Console.Write() will not append a newline        Console.Write(strv);    }}
namespace HelloWorld{    class Program    {        static void Main(string[] args)        {            System.Console.WriteLine(strv);        }    }}
"public static class Haversine {  public static double calculate(double lat1, double lon1, double lat2, double lon2) {    var R = 6372.8; // In kilometers    var dLat = toRadians(lat2 - lat1);    var dLon = toRadians(lon2 - lon1);    lat1 = toRadians(lat1);    lat2 = toRadians(lat2);     var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);    var c = 2 * Math.Asin(Math.Sqrt(a));    return R * 2 * Math.Asin(Math.Sqrt(a));  }   public static double toRadians(double angle) {    return Math.PI * angle / 180.0;  }} void Main() {  Console.WriteLine(String.Format(strv, 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));} // Returns: The distance between coordinates 36.12,-86.67 and 33.94,-118.4 is: 2887.25995060711 "
using System;using System.Windows.Forms; class Program {    static void Main(string[] args) {        Application.EnableVisualStyles(); //Optional.        MessageBox.Show(strv);    }}using Gtk;using GtkSharp; public class GoodbyeWorld {  public static void Main(string[] args) {    Gtk.Window window =  Gtk.Window();    window.Title = strv;    window.DeleteEvent += delegate { Application.Quit(); };    window.ShowAll();    Application.Run();  }}
" using System;using System.Collections.Generic; namespace Harshad{    class Program    {        public static bool IsHarshad(int n)        {            char[] inputChars = n.ToString().ToCharArray();            IList<byte> digits =  List<byte>();             foreach (char digit in inputChars)            {                digits.Add((byte)Char.GetNumericValue(digit));            }             if (n < 1)            {                return false;            }             int sum = 0;             foreach (byte digit in digits)            {                sum += digit;            }             return n % sum == 0;        }         static void Main(string[] args)        {            int i = 1;            int count = 0;             while (true)            {                if (IsHarshad(i))                {                    count++;                     if (count <= 20)                    {                        Console.Write(string.Format(strv, i));                    }                    else if (i > 1000)                    {                        Console.Write(string.Format(strv, i));                        break;                    }                }                 i++;            }             Console.ReadKey();        }    }} "
"using System;using System.Collections.Generic;using System.Linq; namespace HashJoin{    public class AgeName    {        public AgeName(byte age, string name)        {            Age = age;            Name = name;        }        public byte Age { get; private set; }        public string Name { get; private set; }    }     public class NameNemesis    {        public NameNemesis(string name, string nemesis)        {            Name = name;            Nemesis = nemesis;        }        public string Name { get; private set; }        public string Nemesis { get; private set; }    }     public class DataContext    {        public DataContext()        {            AgeName =  List<AgeName>();            NameNemesis =  List<NameNemesis>();        }        public List<AgeName> AgeName { get; set; }        public List<NameNemesis> NameNemesis { get; set; }    }     public class AgeNameNemesis    {        public AgeNameNemesis(byte age, string name, string nemesis)        {            Age = age;            Name = name;            Nemesis = nemesis;        }        public byte Age { get; private set; }        public string Name { get; private set; }        public string Nemesis { get; private set; }    }     class Program    {        public static void Main()        {            var data = GetData();            var result = ExecuteHashJoin(data);            WriteResultToConsole(result);        }         private static void WriteResultToConsole(List<AgeNameNemesis> result)        {            result.ForEach(ageNameNemesis => Console.WriteLine(strv,                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));        }         private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)        {            return (data.AgeName.Join(data.NameNemesis,                 ageName => ageName.Name, nameNemesis => nameNemesis.Name,                (ageName, nameNemesis) =>  AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))                .ToList();        }         private static DataContext GetData()        {            var context =  DataContext();             context.AgeName.AddRange( [] {                     AgeName(27, strv),                      AgeName(18, strv),                      AgeName(28, strv),                      AgeName(18, strv),                      AgeName(28, strv)                });             context.NameNemesis.AddRange([]            {                 NameNemesis(strv, strv),                 NameNemesis(strv, strv),                 NameNemesis(strv, strv),                 NameNemesis(strv, strv),                 NameNemesis(strv, strv)            });             return context;        }    }}"
"using System; //DateTime, Console, Environment classesclass Program{    static DateTime start;    static void Main(string[] args)    {        start = DateTime.Now;        //Add event handler for Ctrl+C command        Console.CancelKeyPress +=  ConsoleCancelEventHandler(Console_CancelKeyPress);        int counter = 0;        while (true)        {            Console.WriteLine(++counter);            System..Thread.Sleep(500);        }    }    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)    {        var end = DateTime.Now;        Console.WriteLine(strv, (end - start).TotalMilliseconds / 1000);        Environment.Exit(0);    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace HappyNums{    class Program    {        public static bool ishappy(int n)        {            List<int> cache =  List<int>();            int sum = 0;            while (n != 1)            {                if (cache.Contains(n))                {                    return false;                }                cache.Add(n);                while (n != 0)                {                    int digit = n % 10;                    sum += digit * digit;                    n /= 10;                }                n = sum;                sum = 0;            }           return true;                    }         static void Main(string[] args)        {            int num = 1;            List<int> happynums =  List<int>();             while (happynums.Count < 8)            {                if (ishappy(num))                {                    happynums.Add(num);                }                num++;            }            Console.WriteLine(strv + string.Join(strv, happynums));        }    }}"
"System..HashTable h =  System..HashTable(); string[] arg_keys = {strv,strv,strv};string[] arg_values = {strv, strv, strv}; //Some basic error checkingint arg_length = 0;if ( arg_keys.Length == arg_values.Length ) {  arg_length = arg_keys.Length;} for( int i = 0; i < arg_length; i++ ){  h.add( arg_keys[i], arg_values[i] ); }for( int i = 0; i < arg_length; i++ ){  h[ arg_keys[i] ] = arg_values[i]; }"
"using System;using System.Numerics;using System.Linq; namespace Hamming {     class MainClass {         public static BigInteger Hamming(int n) {            BigInteger two = 2, three = 3, five = 5;            var h =  BigInteger[n];            h[0] = 1;            BigInteger x2 = 2, x3 = 3, x5 = 5;            int i = 0, j = 0, k = 0;             for (int index = 1; index < n; index++) {                h[index] = BigInteger.Min(x2, BigInteger.Min(x3, x5));                if (h[index] == x2) x2 = two * h[++i];                if (h[index] == x3) x3 = three * h[++j];                if (h[index] == x5) x5 = five * h[++k];            }            return h[n - 1];        }         public static void Main(string[] args) {            Console.WriteLine(string.Join(strv, Enumerable.Range(1, 20).ToList().Select(x => Hamming(x))));            Console.WriteLine(Hamming(1691));            Console.WriteLine(Hamming(1000000));        }    }}using System;using System.Numerics;using System.Linq; namespace Hamming {     class MainClass {         public static BigInteger[] Hamming(int n, int[] a) {            var primes = a.Select(x => (BigInteger)x).ToArray();            var values = a.Select(x => (BigInteger)x).ToArray();            var indexes =  int[a.Length];            var results =  BigInteger[n];            results[0] = 1;            for (int iter = 1; iter < n; iter++) {                results[iter] = values[0];                for (int p = 1; p < primes.Length; p++)                    if (results[iter] > values[p])                        results[iter] = values[p];                for (int p = 0; p < primes.Length; p++)                    if (results[iter] == values[p])                        values[p] = primes[p] * results[++indexes[p]];            }            return results;        }         public static void Main(string[] args) {            foreach (int[] primes in  int[][] {  int[] {2,3,5},  int[] {2,3,5,7} }) {                Console.WriteLine(strv, primes.Last());                Console.WriteLine(string.Join(strv, Hamming(20, primes)));                Console.WriteLine(Hamming(1691, primes).Last());                Console.WriteLine(Hamming(1000000, primes).Last());                Console.WriteLine();            }        }    }}using System;using System.Linq;using System.Numerics; namespace HammingFast {     class MainClass {         private static int[] _primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };         public static BigInteger Big(int[] exponents) {            BigInteger val = 1;            for (int i = 0; i < exponents.Length; i++)                for (int e = 0; e < exponents[i]; e++)                    val = val * _primes[i];            return val;        }         public static int[] Hamming(int n, int nprimes) {            var hammings  =  int[n, nprimes];                    // array of hamming #s we generate            var hammlogs  =  double[n];                          // log values for above            var primelogs =  double[nprimes];                    // pre-calculated prime log values            var indexes   =  int[nprimes];                       // intermediate hamming values as indexes into hammings            var listheads =  int[nprimes, nprimes];              // intermediate hamming list heads            var listlogs  =  double[nprimes];                    // log values of list heads            for (int p = 0; p < nprimes; p++) {                listheads[p, p] = 1;                                // init list heads to prime values                primelogs[p]    = Math.Log(_primes[p]);             // pre-calc prime log values                listlogs[p]     = Math.Log(_primes[p]);             // init list head log values            }            for (int iter = 1; iter < n; iter++) {                int min = 0;                                        // find index of min item in list heads                for (int p = 1; p < nprimes; p++)                    if (listlogs[p] < listlogs[min])                        min = p;                hammlogs[iter] = listlogs[min];                     // that's the next hamming number                for (int i = 0; i < nprimes; i++)                    hammings[iter, i] = listheads[min, i];                for (int p = 0; p < nprimes; p++) {                 // update each list head if it matches new value                    bool equal = true;                              // test each exponent to see if number matches                    for (int i = 0; i < nprimes; i++) {                        if (hammings[iter, i] != listheads[p, i]) {                            equal = false;                            break;                        }                    }                    if (equal) {                                    // if it matches...                        int x = ++indexes[p];                       // set index to next hamming number                        for (int i = 0; i < nprimes; i++)           // copy each hamming exponent                            listheads[p, i] = hammings[x, i];                        listheads[p, p] += 1;                       // increment exponent = mult by prime                        listlogs[p] = hammlogs[x] + primelogs[p];   // add log(prime) to log(value) = mult by prime                    }                }            }             var result =  int[nprimes];            for (int i = 0; i < nprimes; i++)                result[i] = hammings[n - 1, i];            return result;        }         public static void Main(string[] args) {            foreach (int np in  int[] { 3, 4, 5 }) {                Console.WriteLine(strv, _primes[np - 1]);                Console.WriteLine(string.Join(strv, Enumerable.Range(1, 20).Select(x => Big(Hamming(x, np)))));                Console.WriteLine(Big(Hamming(1691, np)));                Console.WriteLine(Big(Hamming(1000000, np)));                Console.WriteLine();            }        }    }}using System;using System.Collections.Generic;using System.Linq;using System.Numerics; namespace HammingTest{    class HammingNode    {        public double log;        public int[] exponents;        public HammingNode next;        public int series;    }     class HammingListEnumerator : IEnumerable<BigInteger>    {        private int[] primes;        private double[] primelogs;        private HammingNode next;        private HammingNode[] values;        private HammingNode[] indexes;         public HammingListEnumerator(IEnumerable<int> seeds)        {            // Ensure our seeds are properly ordered, and generate their log values            primes = seeds.OrderBy(x => x).ToArray();            primelogs = primes.Select(x => Math.Log10(x)).ToArray();            // Start at 1 (log(1)=0, exponents are all 0, series = none)            next =  HammingNode { log = 0, exponents =  int[primes.Length], series = primes.Length };            // Set all exponent sequences to the start, and calculate the first value for each exponent            indexes =  HammingNode[primes.Length];            values =  HammingNode[primes.Length];            for(int i = 0; i < primes.Length; ++i)            {                indexes[i] = next;                values[i] = AddExponent(next, i);            }        }         // Make a copy of a node, and increment the specified exponent value        private HammingNode AddExponent(HammingNode node, int i)        {            HammingNode ret =  HammingNode { log = node.log + primelogs[i], exponents = (int[])node.exponents.Clone(), series = i };            ++ret.exponents[i];            return ret;        }         private void GetNext()        {            // Find which exponent value is the lowest            int min = 0;            for(int i = 1; i < values.Length; ++i)                if(values[i].log < values[min].log)                    min = i;             // Add it to the end of the 'list', and move to it            next.next = values[min];            next = values[min];             // Find the next node in an allowed sequence (skip those that would be duplicates)             HammingNode val = indexes[min].next;            while(val.series < min)                val = val.next;             // Keep the current index, and calculate the next value in the series for that exponent            indexes[min] = val;            values[min] = AddExponent(val, min);        }         // Skip values without having to calculate the BigInteger value from the exponents        public HammingListEnumerator Skip(int count)        {            for(int i = count; i > 0; --i)                GetNext();             return this;        }         // Calculate the BigInteger value from the exponents        internal BigInteger ValueOf(HammingNode n)        {            BigInteger val = 1;            for(int i = 0; i < n.exponents.Length; ++i)                for(int e = 0; e < n.exponents[i]; e++)                    val = val * primes[i];            return val;        }         public IEnumerator<BigInteger> GetEnumerator()        {            while(true)            {                yield return ValueOf(next);                GetNext();            }        }         System..IEnumerator System..IEnumerable.GetEnumerator()        {            return this.GetEnumerator();        }    }     class Program    {        static void Main(string[] args)        {            foreach(int[] primes in  int[][] {                  int[] { 2, 3, 5 },                 int[] { 2, 3, 5, 7 },                 int[] { 2, 3, 5, 7, 9}})            {                HammingListEnumerator hammings =  HammingListEnumerator(primes);                System..Debug.WriteLine(strv, primes.Last());                System..Debug.WriteLine(String.Join(strv, hammings.Take(20).ToArray()));                System..Debug.WriteLine(hammings.Skip(1691 - 20).First());                System..Debug.WriteLine(hammings.Skip(1000000 - 1691).First());                System..Debug.WriteLine(strv);            }        }    }} using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Numerics; namespace Hamming {   class Hammings : IEnumerable<BigInteger> {    private class LazyList<T> {      public T v; public Lazy<LazyList<T>> cont;      public LazyList(T v, Lazy<LazyList<T>> cont) {        this.v = v; this.cont = cont;      }    }    private uint[] primes;    private Hammings() { } // must have an argument!!!    public Hammings(uint[] prms) { this.primes = prms; }    private LazyList<BigInteger> merge(LazyList<BigInteger> xs,                                       LazyList<BigInteger> ys) {      if (xs == null) return ys; else {        var x = xs.v; var y = ys.v;        if (BigInteger.Compare(x, y) < 0) {          var cont =  Lazy<LazyList<BigInteger>>(() =>                       merge(xs.cont.Value, ys));          return  LazyList<BigInteger>(x, cont);        }        else {          var cont =  Lazy<LazyList<BigInteger>>(() =>                       merge(xs, ys.cont.Value));          return  LazyList<BigInteger>(y, cont);        }      }    }    private LazyList<BigInteger> llmult(uint mltplr,                                        LazyList<BigInteger> ll) {            return  LazyList<BigInteger>(mltplr * ll.v,                                       Lazy<LazyList<BigInteger>>(() =>                                        llmult(mltplr, ll.cont.Value)));    }    public IEnumerator<BigInteger> GetEnumerator() {      Func<LazyList<BigInteger>,uint,LazyList<BigInteger>> u =        (acc, p) => { LazyList<BigInteger> r = null;                      var cont =  Lazy<LazyList<BigInteger>>(() => r);                      r =  LazyList<BigInteger>(1, cont);                      r = this.merge(acc, llmult(p, r));                      return r; };      yield return 1;      for (var stt = primes.Aggregate(null, u); ; stt = stt.cont.Value)        yield return stt.v;    }    IEnumerator IEnumerable.GetEnumerator() {      return this.GetEnumerator();    }  }   class Program {    static void Main(string[] args) {      Console.WriteLine(""Calculates the Hamming sequence of numbers."");       var primes =  uint[] { 5, 3, 2 };      Console.WriteLine(String.Join(strv, ( Hammings(primes)).Take(20).ToArray()));      Console.WriteLine(( Hammings(primes)).ElementAt(1691 - 1));       var n = 1000000;       var elpsd = -DateTime.Now.Ticks;       var num = ( Hammings(primes)).ElementAt(n - 1);       elpsd += DateTime.Now.Ticks;       Console.WriteLine(num);      Console.WriteLine(strv, n, elpsd / 10000);       Console.Write(""Press any key to exit:"");      Console.ReadKey(true);      Console.WriteLine();    }  }}using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Numerics; class HammingsLogArr : IEnumerable<Tuple<uint, uint, uint>> {  public static BigInteger trival(Tuple<uint, uint, uint> tpl) {    BigInteger rslt = 1;    for (var i = 0; i < tpl.Item1; ++i) rslt *= 2;    for (var i = 0; i < tpl.Item2; ++i) rslt *= 3;    for (var i = 0; i < tpl.Item3; ++i) rslt *= 5;    return rslt;  }  private const double lb3 = 1.5849625007211561814537389439478; // Math.Log(3) / Math.Log(2);  private const double lb5 = 2.3219280948873623478703194294894; // Math.Log(5) / Math.Log(2);  private struct logrep {    public uint x2, x3, x5;    public double lg;    public logrep(uint x, uint y, uint z, double lg) {      this.x2 = x; this.x3 = y; this.x5 = z; this.lg = lg;    }    public static bool operator <(logrep x, logrep y) {      return x.lg < y.lg;    }    public static bool operator >(logrep x, logrep y) {      return x.lg > y.lg;    }    public logrep mul2() {      return  logrep(this.x2 + 1, this.x3, this.x5, this.lg + 1.0);    }    public logrep mul3() {      return  logrep(this.x2, this.x3 + 1, this.x5, this.lg + lb3);    }    public logrep mul5() {      return  logrep(this.x2, this.x3, this.x5 + 1, this.lg + lb5);    }  }  public IEnumerator<Tuple<uint, uint, uint>> GetEnumerator() {    var one =  logrep();    var m =  List<logrep>(); var h =  List<logrep>();    var x5 = one.mul5();    var mrg = one.mul3();    var x53 = one.mul3().mul3(); // already advanced one step    var x532 = one.mul2();    var i = 0; var j = 0;    yield return Tuple.Create(0u, 0u, 0u); // trivial case for one representation    while (true) {      if (i >= h.Capacity >> 1) { h.RemoveRange(0, i); i = 0; } // assume capacity stays the same...      if (x532 < mrg) { h.Add(x532); x532 = h[i].mul2(); i++; }      else {        h.Add(mrg);        if (j >= m.Capacity) { m.RemoveRange(0, j); j = 0; }        if (x53 < x5) { mrg = x53; x53 = m[j].mul3(); j++; }        else { mrg = x5; x5 = x5.mul5(); }        m.Add(mrg);      }      var rslt = h[h.Count - 1];      yield return Tuple.Create(rslt.x2, rslt.x3, rslt.x5);    }  }  IEnumerator IEnumerable.GetEnumerator() {    return this.GetEnumerator();  }} class Program {  static void Main(string[] args) {    Console.WriteLine(String.Join(strv, ( HammingsLogArr()).Take(20)                                        .Select(t => HammingsLogArr.trival(t))                                        .ToArray()));    Console.WriteLine(HammingsLogArr.trival(NthHamming.findNth(1691)));     var n = 1000000UL;    var elpsd = -DateTime.Now.Ticks;     var rslt = ( HammingsLogArr()).ElementAt((int)n - 1);     elpsd += DateTime.Now.Ticks;     Console.WriteLine(strv, rslt.Item1, rslt.Item2, rslt.Item3);    var lgrthm = Math.Log10(2.0) * ((double)rslt.Item1 +                  ((double)rslt.Item2 * Math.Log(3.0) + (double)rslt.Item3 * Math.Log(5.0)) / Math.Log(2.0));    var pwr = Math.Floor(lgrthm); var mntsa = Math.Pow(10.0, lgrthm - pwr);    Console.WriteLine(strv, mntsa, pwr);    var s = HammingsLogArr.trival(rslt).ToString();    var lngth = s.Length;    Console.WriteLine(strv, lngth);    if (lngth <= 10000) {      var i = 0;      for (; i < lngth - 100; i += 100) Console.WriteLine(s.Substring(i, 100));      Console.WriteLine(s.Substring(i));    }    Console.WriteLine(strv, n, elpsd / 10000);     Console.Write(""Press any key to exit:"");    Console.ReadKey(true);    Console.WriteLine();  }}using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Numerics; static class NthHamming {  public static BigInteger trival(Tuple<uint, uint, uint> tpl) {    BigInteger rslt = 1;    for (var i = 0; i < tpl.Item1; ++i) rslt *= 2;    for (var i = 0; i < tpl.Item2; ++i) rslt *= 3;    for (var i = 0; i < tpl.Item3; ++i) rslt *= 5;    return rslt;  }   private struct logrep {    public uint x2, x3, x5;    public double lg;    public logrep(uint x, uint y, uint z, double lg) {      this.x2 = x; this.x3 = y; this.x5 = z; this.lg = lg;    }  }   private const double lb3 = 1.5849625007211561814537389439478; // Math.Log(3) / Math.Log(2);  private const double lb5 = 2.3219280948873623478703194294894; // Math.Log(5) / Math.Log(2);  private const double fctr = 6.0 * lb3 * lb5;  private const double crctn = 2.4534452978042592646620291867186; // Math.Log(Math.sqrt(30.0)) / Math.Log(2.0)   public static Tuple<uint, uint, uint> findNth(UInt64 n) {    if (n < 1) throw  Exception(strv);    if (n < 2) return Tuple.Create(0u, 0u, 0u); // trivial case for argument of one    var lgest = Math.Pow(fctr * (double)n, 1.0/3.0) - crctn; // from WP formula    var frctn = (n < 1000000000) ? 0.509 : 0.105;    var lghi = Math.Pow(fctr * ((double)n + frctn * lgest), 1.0/3.0) - crctn;    var lglo = 2.0 * lgest - lghi; // upper and lower bound of upper strv    var count = 0UL; // need 64 bit precision in case...    var bnd =  List<logrep>();    for (uint k = 0, klmt = (uint)(lghi / lb5) + 1; k < klmt; ++k) {      var p = (double)k * lb5;      for (uint j = 0, jlmt = (uint)((lghi - p) / lb3) + 1; j < jlmt; ++j) {        var q = p + (double)j * lb3;        var ir = lghi - q;        var lg = q + Math.Floor(ir); // current log2 value (estimated)        count += (ulong)ir + 1;        if (lg >= lglo) bnd.Add( logrep((UInt32)ir, j, k, lg));      }    }    if (n > count) throw  Exception(strv);    var ndx = (int)(count - n);    if (ndx >= bnd.Count) throw  Exception(strv);    bnd.Sort((a, b) => (b.lg < a.lg) ? -1 : 1); // sort in decending order     var rslt = bnd[ndx];    return Tuple.Create(rslt.x2, rslt.x3, rslt.x5);  }} class Program {  static void Main(string[] args) {    Console.WriteLine(String.Join(strv, Enumerable.Range(1,20).Select(i =>                                          NthHamming.trival(NthHamming.findNth((ulong)i))).ToArray()));    Console.WriteLine(NthHamming.trival(( HammingsLogArr()).ElementAt(1691 - 1)));     var n = 1000000000000UL;    var elpsd = -DateTime.Now.Ticks;     var rslt = NthHamming.findNth(n);     elpsd += DateTime.Now.Ticks;     Console.WriteLine(strv, rslt.Item1, rslt.Item2, rslt.Item3);    var lgrthm = Math.Log10(2.0) * ((double)rslt.Item1 +                  ((double)rslt.Item2 * Math.Log(3.0) + (double)rslt.Item3 * Math.Log(5.0)) / Math.Log(2.0));    var pwr = Math.Floor(lgrthm); var mntsa = Math.Pow(10.0, lgrthm - pwr);    Console.WriteLine(strv, mntsa, pwr);    var s = HammingsLogArr.trival(rslt).ToString();    var lngth = s.Length;    Console.WriteLine(strv, lngth);    if (lngth <= 10000) {      var i = 0;      for (; i < lngth - 100; i += 100) Console.WriteLine(s.Substring(i, 100));      Console.WriteLine(s.Substring(i));    }    Console.WriteLine(strv, n, elpsd / 10000);     Console.Write(""Press any key to exit:"");    Console.ReadKey(true);    Console.WriteLine();  }}"
"using System; using System.ComponentModel; using System.Windows.Forms;  class RosettaInteractionForm : Form{        // Model used for DataBinding.    // Notifies bound controls about Value changes.    class NumberModel: INotifyPropertyChanged    {         Random rnd =  Random();         // initialize event with empty delegate to avoid checks on null        public event PropertyChangedEventHandler PropertyChanged = delegate {};         int _value;        public int Value        {            get { return _value; }            set             {                 _value = value;                // Notify bound control about value change                PropertyChanged(this,  PropertyChangedEventArgs(strv));            }        }         public void ResetToRandom(){            Value = rnd.Next(5000);        }    }     NumberModel model =  NumberModel{ Value = 0};     RosettaInteractionForm()        {        //MaskedTextBox is a TextBox variety with built-in input validation        var tbNumber =  MaskedTextBox                        {                             Mask=strv,            // allow 4 decimal digits only                            ResetOnSpace = false,   // don't enter spaces                            Dock = DockStyle.Top    // place at the top of form                        };        // bound TextBox.Text to NumberModel.Value;        tbNumber.DataBindings.Add(strv, model, strv);         var btIncrement =  Button{Text = strv, Dock = DockStyle.Bottom};        btIncrement.Click += delegate                        {                            model.Value++;                        };        var btDecrement =  Button{Text = strv, Dock = DockStyle.Bottom};        btDecrement.Click += delegate                        {                            model.Value--;                        };        var btRandom =  Button{ Text=strv, Dock = DockStyle.Bottom };        btRandom.Click += delegate                        {                            if (MessageBox.Show(strv, strv, MessageBoxButtons.YesNo) == DialogResult.Yes)                                model.ResetToRandom();                        };        Controls.Add(tbNumber);        Controls.Add(btIncrement);        Controls.Add(btDecrement);        Controls.Add(btRandom);    }    static void Main()    {        Application.Run( RosettaInteractionForm());    }} "
"using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading; //Remember to add this if you want the game to pause in RealisticGuess.Start() namespace ConsoleApplication1{    class RealisticGuess //Simulates a guessing game between two people. Guessing efficiency is not a goal.    {        private int max;        private int min;        private int guess;         public void Start()        {            Console.Clear();            string input;             try            {                Console.WriteLine(strv);                input = Console.ReadLine();                min = Convert.ToInt32(input);                Console.WriteLine(strv);                input = Console.ReadLine();                max = Convert.ToInt32(input);            }            catch (FormatException)            {                Console.WriteLine(strv);                Console.ReadKey(true);                Start();            }            Console.WriteLine(strv, min, max);            Thread.Sleep(2500);            Console.WriteLine(strv);            Console.WriteLine(strv);            Console.ReadKey(true);            Guess(min, max);        }        public void Guess(int min, int max)        {            int counter = 1;            string userAnswer;            bool correct = false;            Random rand =  Random();             while (correct == false)            {                guess = rand.Next(min, max);                Console.Clear();                Console.WriteLine(strv, guess);                Console.WriteLine(strv);                userAnswer = Console.ReadLine();                if (userAnswer != strv && userAnswer != strv && userAnswer != strv && userAnswer != strv)                {                    Console.WriteLine(strv);                    Console.WriteLine(strv);                    userAnswer = Console.ReadLine();                }                if (userAnswer == strv || userAnswer == strv)                {                    correct = true;                }                if (userAnswer == strv || userAnswer == strv)                {                    counter++;                    if (max == min)                    {                        Console.WriteLine(strv);  //This message should never pop up if the user enters good data.                        Console.ReadKey(true);                                                          //It handles the game-breaking exception that occurs                        Guess(1, 101);                                                                  //when the max guess number is the same as the min number.                    }                    Console.WriteLine(strv);                    userAnswer = Console.ReadLine();                    if (userAnswer != strv && userAnswer != strv && userAnswer != strv && userAnswer != strv)                    {                        Console.WriteLine(strv);                        Console.WriteLine(strv);                        userAnswer = Console.ReadLine();                    }                    if (userAnswer == strv || userAnswer == strv)                    {                        max = guess;                    }                    if (userAnswer == strv || userAnswer == strv)                    {                        min = guess;                    }                }            }            if (correct == true)            {                EndAndLoop(counter);            }        }         public void EndAndLoop(int iterations)        {            string userChoice;            bool loop = false;            Console.WriteLine(strv, iterations);            while (loop == false)            {                Console.WriteLine(strv);                userChoice = Console.ReadLine();                if (userChoice != strv && userChoice != strv && userChoice != strv && userChoice != strv)                {                    Console.WriteLine(strv);                }                if (userChoice == strv || userChoice == strv)                {                    Start();                }                if (userChoice == strv || userChoice == strv)                {                    Environment.Exit(1);                }            }        }    }    class Program    {        static void Main(string[] args)        {            Console.Title = strv;            RealisticGuess game =  RealisticGuess();            game.Start();        }    }} "
"using System; class Program{    static void Main(string[] args)    {        const int from = 1;        const int to = 10;         int randomNumber =  Random().Next(from, to);        int guessedNumber;         Console.Write(strv, from, to);        while (true)        {            Console.Write(strv);            if (int.TryParse(Console.ReadLine(), out guessedNumber))            {                if (guessedNumber == randomNumber)                {                    Console.WriteLine(strv);                    break;                }                else                {                    Console.WriteLine(strv, (guessedNumber > randomNumber) ? strv : strv);                }            }            else            {                Console.WriteLine(strv);            }        }         Console.WriteLine();        Console.WriteLine(strv);        Console.ReadKey();    }} "
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace Hailstone{    class Program    {        public static List<int> hs(int n,List<int> seq)        {            List<int> sequence = seq;            sequence.Add(n);            if (n == 1)            {                return sequence;            }else{                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;                return hs(newn, sequence);            }                                }         static void Main(string[] args)        {            int n = 27;            List<int> sequence = hs(n, List<int>());            Console.WriteLine(sequence.Count + strv);            List<int> start = sequence.GetRange(0, 4);            List<int> end = sequence.GetRange(sequence.Count - 4, 4);            Console.WriteLine(strv + string.Join(strv, start) + strv + string.Join(strv, end));                        int number = 0, longest = 0;                        for (int i = 1; i < 100000; i++)            {                int count = (hs(i,  List<int>())).Count;                if (count > longest)                {                    longest = count;                    number = i;                }            }            Console.WriteLine(strv + number + strv + longest);       }    }}using System;using System.Collections.Generic; namespace ConsoleApplication1{    class Program    {        public static void Main()        {            int longestChain = 0, longestNumber = 0;             var recursiveLengths =  Dictionary<int, int>();             const int maxNumber = 100000;             for (var i = 1; i <= maxNumber; i++)            {                var chainLength = Hailstone(i, recursiveLengths);                if (longestChain >= chainLength)                     continue;                 longestChain = chainLength;                longestNumber = i;            }            Console.WriteLine(strv, maxNumber, longestNumber, longestChain);        }         private static int Hailstone(int num, Dictionary<int, int> lengths)        {            if (num == 1)                 return 1;             while (true)            {                if (lengths.ContainsKey(num))                    return lengths[num];                 lengths[num] = 1 + ((num%2 == 0) ? Hailstone(num/2, lengths) : Hailstone((3*num) + 1, lengths));            }        }    }}"
"using System; class GuessTheNumberGame{    static void Main()    {        bool numberCorrect = false;        Random randomNumberGenerator =  Random();        int randomNumber = randomNumberGenerator.Next(1, 10+1);         Console.WriteLine(strv);        do        {            Console.Write(strv);            int userGuess = int.Parse(Console.ReadLine());             if (userGuess == randomNumber)            {                numberCorrect = true;                Console.WriteLine(strv);            }            else                Console.WriteLine(strv);        } while (!numberCorrect);    }};"
"using System;using System.Drawing;using System.Windows.Forms;static class Program { static void Main() { Application.Run( FullScreen()); } }public sealed class FullScreen : Form{    const int ColorCount = 256;    public FullScreen()    {        FormBorderStyle = FormBorderStyle.None;        WindowState = FormWindowState.Maximized;        KeyPress += (s, e) => Application.Exit();        BackgroundImage = ColorBars(Screen.FromControl(this).Bounds);    }    private static Bitmap ColorBars(Rectangle size)    {        var colorBars =  Bitmap(size.Width, size.Height);        Func<int, int, int> forwardColor = (x, divs) => (int)(x * ((float)divs / size.Width)) * ColorCount / divs;        Func<int, int, int> reverseColor = (x, divs) => ColorCount - 1 - forwardColor(x, divs);        Action<int, int, int> setGray = (x, y, gray) => colorBars.SetPixel(x, y, Color.FromArgb(gray, gray, gray));        Action<int, int, int> setForward = (x, y, divs) => setGray(x, y, forwardColor(x, divs));        Action<int, int, int> setReverse = (x, y, divs) => setGray(x, y, reverseColor(x, divs));        int verticalStripe = size.Height / 4;        for (int x = 0; x < size.Width; x++)        {            for (int y = 0; y < verticalStripe; y++) setForward(x, y, 8);            for (int y = verticalStripe; y < verticalStripe * 2; y++) setReverse(x, y, 16);            for (int y = verticalStripe * 2; y < verticalStripe * 3; y++) setForward(x, y, 32);            for (int y = verticalStripe * 3; y < verticalStripe * 4; y++) setReverse(x, y, 64);        }        return colorBars;    }}"
"using System; namespace Tests_With_Framework_4{    class Program    {        static void Main(string[] args)        {            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;             for (int i = 0; i < length; i++)            {                sum = 0;                for (int k = i; k < length; k++)                {                    sum += integers[k];                    if (sum > maxsum)                    {                        maxsum = sum;                        beginmax = i;                        endmax = k;                    }                }            }             for (int i = beginmax; i <= endmax; i++)                Console.WriteLine(integers[i]);             Console.ReadKey();        }    }}"
" using System.Collections.Generic;using System.IO; class Program {    static void Main() {        var files =  List<string> {            strv,            strv        };        foreach (string file in files) {            File.WriteAllText(file, File.ReadAllText(file).Replace(strv, strv));        }    }} "
"using System;using System.Collections.Generic;using System.Linq; static class Program {    static void Main() {        Func<int, IEnumerable<int>> ms = m => Infinite().Select(i => (int)Math.Pow(i, m));        var squares = ms(2);        var cubes = ms(3);        var filtered = squares.Where(square => cubes.First(cube => cube >= square) != square);        var final = filtered.Skip(20).Take(10);        foreach (var i in final) Console.WriteLine(i);    }     static IEnumerable<int> Infinite() {        var i = 0;        while (true) yield return i++;    }}"
"namespace RosettaCode.GenerateLowerCaseASCIIAlphabet{    using System;    using System.Collections.Generic;     internal class Program    {        private static IEnumerable<char> Alphabet        {            get            {                for (var character = 'a'; character <= 'z'; character++)                {                    yield return character;                }            }        }         private static void Main()        {            Console.WriteLine(string.Join(string.Empty, Alphabet));        }    }}"
 using System; public class GeneralFizzBuzz{    public static void Main()     {        int i;        int j;        int k;         int limit;         string iString;        string jString;        string kString;         Console.WriteLine(strv);        i = Convert.ToInt32(Console.ReadLine());        Console.WriteLine(strv);        iString = Console.ReadLine();         Console.WriteLine(strv);        j = Convert.ToInt32(Console.ReadLine());        Console.WriteLine(strv);        jString = Console.ReadLine();         Console.WriteLine(strv);        k = Convert.ToInt32(Console.ReadLine());        Console.WriteLine(strv);        kString = Console.ReadLine();         Console.WriteLine(strv);        limit = Convert.ToInt32(Console.ReadLine());         for(int n = 1; n<= limit; n++)        {            bool flag = true;            if(n%i == 0)            {                Console.Write(iString);                flag = false;            }             if(n%j == 0)            {                Console.Write(jString);                flag = false;            }             if(n%k == 0)            {                Console.Write(kString);                flag = false;            }            if(flag)                Console.Write(n);            Console.WriteLine();        }    }} 
"static void Swap<T>(ref T a, ref T b){    T temp = a;    a = b;    b = temp;}//Usage:int a = 1;int b = 2;Swap(ref a, ref b); //type is inferred.int a = 1;int b = 2;(a, b) = (b, a); //Swapping "
"using System;using System.Numerics; static int g = 7;static double[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,	     771.32342877765313, -176.61502916214059, 12.507343278686905,	     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7}; Complex Gamma(Complex z){    // Reflection formula    if (z.Real < 0.5)	{        return Math.PI / (Complex.Sin( Math.PI * z) * Gamma(1 - z));	}    else	{        z -= 1;        Complex x = p[0];        for (var i = 1; i < g + 2; i++)		{            x += p[i]/(z+i);		}        Complex t = z + g + 0.5;        return Complex.Sqrt(2 * Math.PI) * (Complex.Pow(t, z + 0.5)) * Complex.Exp(-t) * x;	}} "
"




private static string ReverseDomainNameNotation(string domain){    return string.Join(strv, domain.Split('.').Reverse());}"
"using System;class Program{    static void Main(string[] args)    {        Func<int, int> outfunc = Composer<int, int, int>.Compose(functA, functB);        Console.WriteLine(outfunc(5)); //Prints 100    }    static int functA(int i) { return i * 10; }    static int functB(int i) { return i + 5; }    class Composer<A, B, C>    {        public static Func<C, A> Compose(Func<B, A> a, Func<C, B> b)        {            return delegate(C i) { return a(b(i)); };        }    }}"
"static double multiply(double a, double b){    return a * b;}Func<double, double, double> multiply = ((a,b) => a*b);"
" class Program    {          static void Main(string[] args)        {             float myNumbers = 7.125F;             string strnumber = Convert.ToString(myNumbers);             Console.WriteLine(strnumber.PadLeft(9, '0'));             Console.ReadLine();        }        } "
"using System;using System.Collections.Generic;using System.Linq; class Program{    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)    {        switch (order)        {            case 0u:                return sequence;            case 1u:                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);            default:                return ForwardDifference(ForwardDifference(sequence), order - 1u);        }    }     static void Main()    {        IEnumerable<int> sequence = [] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };        do        {            Console.WriteLine(string.Join(strv, sequence));        } while ((sequence = ForwardDifference(sequence)).Any());    }}"
" using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace RosettaCodeTasks.FourBitAdder{	public struct BitAdderOutput	{		public bool S { get; set; }		public bool C { get; set; }		public override string ToString ( )		{			return strv + ( S ? strv : strv ) + strv + ( C ? strv : strv );		}	}	public struct Nibble	{		public bool _1 { get; set; }		public bool _2 { get; set; }		public bool _3 { get; set; }		public bool _4 { get; set; }		public override string ToString ( )		{			return ( _4 ? strv : strv )				+ ( _3 ? strv : strv )				+ ( _2 ? strv : strv )				+ ( _1 ? strv : strv );		}	}	public struct FourBitAdderOutput	{		public Nibble N { get; set; }		public bool C { get; set; }		public override string ToString ( )		{			return N.ToString ( ) + strv + ( C ? strv : strv );		}	} 	public static class LogicGates	{		// Basic Gates		public static bool Not ( bool A ) { return !A; }		public static bool And ( bool A, bool B ) { return A && B; }		public static bool Or ( bool A, bool B ) { return A || B; } 		// Composite Gates		public static bool Xor ( bool A, bool B ) {	return Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }	} 	public static class ConstructiveBlocks	{		public static BitAdderOutput HalfAdder ( bool A, bool B )		{			return  BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };		} 		public static BitAdderOutput FullAdder ( bool A, bool B, bool CI )		{			BitAdderOutput HA1 = HalfAdder ( CI, A );			BitAdderOutput HA2 = HalfAdder ( HA1.S, B ); 			return  BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };		} 		public static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )		{ 			BitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );			BitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );			BitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );			BitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C ); 			return  FourBitAdderOutput ( ) { N =  Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };		} 		public static void Test ( )		{			Console.WriteLine ( strv ); 			for ( int i = 0; i < 256; i++ )			{				Nibble A =  Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };				Nibble B =  Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };				if ( (i & 1) == 1)				{					A._1 = true;				}				if ( ( i & 2 ) == 2 )				{					A._2 = true;				}				if ( ( i & 4 ) == 4 )				{					A._3 = true;				}				if ( ( i & 8 ) == 8 )				{					A._4 = true;				}				if ( ( i & 16 ) == 16 )				{					B._1 = true;				}				if ( ( i & 32 ) == 32)				{					B._2 = true;				}				if ( ( i & 64 ) == 64 )				{					B._3 = true;				}				if ( ( i & 128 ) == 128 )				{					B._4 = true;				} 				Console.WriteLine ( strv, A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) ); 			} 			Console.WriteLine ( );		} 	}}  "
"using System;using System.Drawing;using System.Drawing.Drawing2D;using System.Threading;using System.Windows.Forms; namespace ForestFire{    class Program : Form    {        private static readonly Random rand =  Random();        private Bitmap img;         public Program(int w, int h, int f, int p)        {            Size =  Size(w, h);            StartPosition = FormStartPosition.CenterScreen;             Thread t =  Thread(() => fire(f, p));            t.Start();             FormClosing += (object sender, FormClosingEventArgs e) => { t.Abort(); t = null; };        }         private void fire(int f, int p)        {            int clientWidth = ClientRectangle.Width;            int clientHeight = ClientRectangle.Height;            int cellSize = 10;             img =  Bitmap(clientWidth, clientHeight);            Graphics g = Graphics.FromImage(img);             CellState[,] state = InitializeForestFire(clientWidth, clientHeight);             uint generation = 0;             do            {                g.FillRectangle(Brushes.White, 0, 0, img.Width, img.Height);                state = StepForestFire(state, f, p);                 for (int y = 0; y < clientHeight - cellSize; y += cellSize)                {                    for (int x = 0; x < clientWidth - cellSize; x += cellSize)                    {                        switch (state[y, x])                        {                            case CellState.Empty:                                break;                            case CellState.Tree:                                g.FillRectangle(Brushes.DarkGreen, x, y, cellSize, cellSize);                                break;                            case CellState.Burning:                                g.FillRectangle(Brushes.DarkRed, x, y, cellSize, cellSize);                                break;                        }                    }                }                 Thread.Sleep(500);                 Invoke((MethodInvoker)Refresh);             } while (generation < uint.MaxValue);             g.Dispose();        }         private CellState[,] InitializeForestFire(int width, int height)        {            // Create our state array, initialize all indices as Empty, and return it.            var state =  CellState[height, width];            state.Initialize();            return state;        }         private enum CellState : byte        {            Empty = 0,            Tree = 1,            Burning = 2        }         private CellState[,] StepForestFire(CellState[,] state, int f, int p)        {            /* Clone our old state, so we can write to our new state
             * without changing any values in the old state. */            var newState = (CellState[,])state.Clone();             int numRows = state.GetLength(0);            int numCols = state.GetLength(1);             for (int r = 1; r < numRows - 1; r++)            {                for (int c = 1; c < numCols - 1; c++)                {                    /* 
                     * Check the current cell.
                     * 
                     * If it's empty, give it a 1/p chance of becoming a tree.
                     * 
                     * If it's a tree, check to see if any neighbors are burning.
                     * If so, set the cell's state to burning, otherwise give it
                     * a 1/f chance of combusting.
                     * 
                     * If it's burning, set it to empty.
                     */                    switch (state[r, c])                    {                        case CellState.Empty:                            if (rand.Next(0, p) == 0)                                newState[r, c] = CellState.Tree;                            break;                         case CellState.Tree:                            if (NeighborHasState(state, r, c, CellState.Burning) || rand.Next(0, f) == 0)                                newState[r, c] = CellState.Burning;                            break;                         case CellState.Burning:                            newState[r, c] = CellState.Empty;                            break;                    }                }            }             return newState;        }         private bool NeighborHasState(CellState[,] state, int x, int y, CellState value)        {            // Check each cell within a 1 cell radius for the specified value.            for (int r = -1; r <= 1; r++)            {                for (int c = -1; c <= 1; c++)                {                    if (r == 0 && c == 0)                        continue;                     if (state[x + r, y + c] == value)                        return true;                }            }             return false;        }         protected override void OnPaint(PaintEventArgs e)        {            base.OnPaint(e);            e.Graphics.DrawImage(img, 0, 0);        }         [STAThread]        static void Main(string[] args)        {            Application.Run( Program(w: 500, h: 500, f: 2, p: 5));        }    }}"
"class Program{    static void Main()    {        for (uint i = 1; i <= 100; i++) {            string s = null;             if (i % 3 == 0)                s = strv;             if (i % 5 == 0)                s += strv;             System.Console.WriteLine(s ?? i.ToString());        }    }}using System;using System.Linq; namespace FizzBuzz{    class Program    {        static void Main(string[] args)        {            Enumerable.Range(1, 100)                .Select(a => String.Format(strv, a % 3 == 0 ? strv : string.Empty, a % 5 == 0 ? strv : string.Empty))                .Select((b, i) => String.IsNullOrEmpty(b) ? (i + 1).ToString() : b)                .ToList()                .ForEach(Console.WriteLine);        }    }}using System;using System.Globalization;using System.Linq; namespace FizzBuzz{    class Program    {        static void Main()        {            Enumerable.Range(1, 100)                .GroupBy(e => e % 15 == 0 ? strv : e % 5 == 0 ? strv : e % 3 == 0 ? strv : string.Empty)                .SelectMany(item => item.Select(x =>  {                     Value = x,                     Display = String.IsNullOrEmpty(item.Key) ? x.ToString(CultureInfo.InvariantCulture) : item.Key                 }))                .OrderBy(x => x.Value)                .Select(x => x.Display)                .ToList()                .ForEach(Console.WriteLine);        }    }}using System; namespace FizzBuzz{    class Program    {        static void Main(string[] args)        {            for (int i = 1; i <= 100; i++)            {                if (i % 15 == 0)                {                    Console.WriteLine(strv);                }                else if (i % 3 == 0)                {                    Console.WriteLine(strv);                }                else if (i % 5 == 0)                {                    Console.WriteLine(strv);                }                else                {                    Console.WriteLine(i);                }            }        }    }}using System;using System.Globalization; namespace Rosettacode{    class Program    {        static void Main()        {            for (var number = 0; number < 100; number++)            {                if ((number % 3) == 0 & (number % 5) == 0)                {                    //For numbers which are multiples of both three and five print strv.                    Console.WriteLine(strv);                    continue;                }                 if ((number % 3) == 0) Console.WriteLine(strv);                if ((number % 5) == 0) Console.WriteLine(strv);                if ((number % 3) != 0 && (number % 5) != 0) Console.WriteLine(number.ToString(CultureInfo.InvariantCulture));                 if (number % 5 == 0)                {                    Console.WriteLine(Environment.NewLine);                }            }        }    }}using System;using System.Collections;using System.Collections.Generic;using System.Globalization;using System.Linq;using Microsoft.VisualStudio.TestTools.UnitTesting; namespace FizzBuzz{    [TestClass]    public class FizzBuzzTest    {        private FizzBuzz fizzBuzzer;         [TestInitialize]        public void Initialize()        {            fizzBuzzer =  FizzBuzz();        }         [TestMethod]        public void Give4WillReturn4()        {            Assert.AreEqual(strv, fizzBuzzer.FizzBuzzer(4));        }         [TestMethod]        public void Give9WillReturnFizz()        {            Assert.AreEqual(strv, fizzBuzzer.FizzBuzzer(9));        }         [TestMethod]        public void Give25WillReturnBuzz()        {            Assert.AreEqual(strv, fizzBuzzer.FizzBuzzer(25));        }         [TestMethod]        public void Give30WillReturnFizzBuzz()        {            Assert.AreEqual(strv, fizzBuzzer.FizzBuzzer(30));        }         [TestMethod]        public void First15()        {            ICollection expected =  ArrayList                {strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv};             var actual = Enumerable.Range(1, 15).Select(x => fizzBuzzer.FizzBuzzer(x)).ToList();             CollectionAssert.AreEqual(expected, actual);        }         [TestMethod]        public void From1To100_ToShowHowToGet100()        {            const int expected = 100;            var actual = Enumerable.Range(1, 100).Select(x => fizzBuzzer.FizzBuzzer(x)).ToList();             Assert.AreEqual(expected, actual.Count);        }    }     public class FizzBuzz    {        private delegate string Xzzer(int value);        private readonly IList<Xzzer> _functions =  List<Xzzer>();         public FizzBuzz()        {            _functions.Add(x => x % 3 == 0 ? strv : strv);            _functions.Add(x => x % 5 == 0 ? strv : strv);        }         public string FizzBuzzer(int value)        {            var result = _functions.Aggregate(String.Empty, (current, function) => current + function.Invoke(value));            return String.IsNullOrEmpty(result) ? value.ToString(CultureInfo.InvariantCulture) : result;        }    }}using System;using System.Linq; namespace FizzBuzz{  class Program  {    static void Main(string[] args)    {         Enumerable.Range(1, 100).ToList().ForEach(i => Console.WriteLine(i % 5 == 0 ? string.Format(i % 3 == 0 ? strv : strv, strv) : string.Format(i%3 == 0 ? strv : i.ToString())));    }  }}"
" using System;using System.Collections;using System.Linq; namespace RosettaCodeTasks{	static class FlattenList	{		public static ArrayList Flatten(this ArrayList List)		{			ArrayList NewList =  ArrayList ( ); 			NewList.AddRange ( List ); 			while ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )			{				int index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );				ArrayList Temp = (ArrayList)NewList[index];				NewList.RemoveAt ( index );				NewList.InsertRange ( index, Temp );			} 			return NewList;		}	}}  using System;using System.Collections; namespace RosettaCodeTasks{	class Program	{		static void Main ( string[ ] args )		{ 			ArrayList Parent =  ArrayList ( );			Parent.Add (  ArrayList ( ) );			((ArrayList)Parent[0]).Add ( 1 );			Parent.Add ( 2 );			Parent.Add (  ArrayList ( ) );			( (ArrayList)Parent[2] ).Add (  ArrayList ( ) );			( (ArrayList)( (ArrayList)Parent[2] )[0] ).Add ( 3 );			( (ArrayList)( (ArrayList)Parent[2] )[0] ).Add ( 4 );			( (ArrayList)Parent[2] ).Add ( 5 );			Parent.Add (  ArrayList ( ) );			( (ArrayList)Parent[3] ).Add (  ArrayList ( ) );			( (ArrayList)( (ArrayList)Parent[3] )[0] ).Add (  ArrayList ( ) );			Parent.Add (  ArrayList ( ) );			( (ArrayList)Parent[4] ).Add (  ArrayList ( ) );			( (ArrayList)( (ArrayList)Parent[4] )[0] ).Add (  ArrayList ( ) ); 			( (ArrayList)( (ArrayList)( (ArrayList)( (ArrayList)Parent[4] )[0] )[0] ) ).Add ( 6 );			Parent.Add ( 7 );			Parent.Add ( 8 );			Parent.Add (  ArrayList ( ) );  			foreach ( Object o in Parent.Flatten ( ) )			{				Console.WriteLine ( o.ToString ( ) );			}		} 	}}   	public static class Ex {		public static List<object> Flatten(this List<object> list) { 			var result =  List<object>();			foreach (var item in list) {				if (item  List<object>) {					result.AddRange(Flatten(item as List<object>));				} else {					result.Add(item);				}			}			return result;		}		public static string Join<T>(this List<T> list, string glue) {			return string.Join(glue, list.Select(i => i.ToString()).ToArray());		}	} 	class Program { 		static void Main(string[] args) {			var list =  List<object>{ List<object>{1}, 2,  List<object>{ List<object>{3,4}, 5},  List<object>{ List<object>{ List<object>{}}},  List<object>{ List<object>{ List<object>{6}}}, 7, 8,  List<object>{}}; 			Console.WriteLine(strv + list.Flatten().Join(strv) + strv);			Console.ReadLine();		}	} "
"using System;using System.Linq; class Program{    static void Main(string[] args)    {        double x, xi, y, yi, z, zi;        x = 2.0;        xi = 0.5;        y = 4.0;        yi = 0.25;        z = x + y;        zi = 1.0 / (x + y);         var numlist = [] { x, y, z };        var numlisti = [] { xi, yi, zi };        var multiplied = numlist.Zip(numlisti, (n1, n2) =>                       {                           Func<double, double> multiplier = m => n1 * n2 * m;                           return multiplier;                       });         foreach (var multiplier in multiplied)            Console.WriteLine(multiplier(0.5));    }} "
"using System; namespace _5_Weekends{    class Program    {        const int FIRST_YEAR = 1900;        const int LAST_YEAR = 2100;        static int[] _31_MONTHS = { 1, 3, 5, 7, 8, 10, 12 };          static void Main(string[] args)        {            int totalNum = 0;            int totalNo5Weekends = 0;             for (int year = FIRST_YEAR; year <= LAST_YEAR; year++)            {                bool has5Weekends = false;                 foreach (int month in _31_MONTHS)                {                    DateTime firstDay =  DateTime(year, month, 1);                    if (firstDay.DayOfWeek == DayOfWeek.Friday)                    {                        totalNum++;                        has5Weekends = true;                        Console.WriteLine(firstDay.ToString(strv));                    }                }                 if (!has5Weekends) totalNo5Weekends++;            }            Console.WriteLine(strv, FIRST_YEAR, LAST_YEAR, totalNum);            Console.WriteLine(strv, totalNo5Weekends);        }    }}using System;using System.Linq;using System.Collections.Generic; public class Program{    public static void Main()    {        const int startYear = 1900, endYear = 2100;         var query = (            from year in startYear.To(endYear)            from month in 1.To(12)            where DateTime.DaysInMonth(year, month) == 31            select  DateTime(year, month, 1) into date            where date.DayOfWeek == DayOfWeek.Friday            select date)            .ToList();         Console.WriteLine(strv + query.Count);        Console.WriteLine();        Console.WriteLine(strv);        for (int i = 0; i < 5; i++)            Console.WriteLine(query[i].ToString(strv));        Console.WriteLine(strv);        for (int i = query.Count - 5; i < query.Count; i++)            Console.WriteLine(query[i].ToString(strv));        Console.WriteLine();        Console.WriteLine(strv);        Console.WriteLine(string.Join(strv, startYear.To(endYear).Except(query.Select(dt => dt.Year))));    }} public static class IntExtensions{    public static IEnumerable<int> To(this int start, int end) => Enumerable.Range(start, end - start + 1);}"
"using System;using System.Drawing;public class Program{    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {        float a1 = e1.Y - s1.Y;        float b1 = s1.X - e1.X;        float c1 = a1 * s1.X + b1 * s1.Y;         float a2 = e2.Y - s2.Y;        float b2 = s2.X - e2.X;        float c2 = a2 * s2.X + b2 * s2.Y;         float delta = a1 * b2 - a2 * b1;        //If lines are parallel, the result will have Infinity values.        return  PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);    }     static void Main() {        Func<float, float, PointF> p = (x, y) =>  PointF(x, y);        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));    }}"
"using System;using System.Collections.Generic; namespace MissingPermutation{    class Program    {        static void Main()        {            string[] given =  string[] { strv, strv, strv, strv,                                             strv, strv, strv, strv,                                             strv, strv, strv, strv,                                             strv, strv, strv, strv,                                             strv, strv, strv, strv,                                             strv, strv, strv };             List<string> result =  List<string>();            permuteString(ref result, strv, strv);             foreach (string a in result)                            if (Array.IndexOf(given, a) == -1)                    Console.WriteLine(a + strv);        }         public static void permuteString(ref List<string> result, string beginningString, string endingString)        {            if (endingString.Length <= 1)            {                                 result.Add(beginningString + endingString);            }            else            {                for (int i = 0; i < endingString.Length; i++)                {                                         string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                                    }            }        }    }}using System;using System.Linq; public class Test{    public static void Main()    {        var input =  [] {strv,strv,strv,strv,strv,            strv,strv,strv,strv,strv,strv,            strv,strv,strv,strv,strv,strv,            strv,strv,strv,strv,strv,strv};         int[] values = {0,0,0,0};        foreach (string s in input)            for (int i = 0; i < 4; i++)                values[i] ^= s[i];        Console.WriteLine(string.Join(strv, values.Select(i => (char)i)));    }}"
"using System; class Program{    delegate Func<A,C> Composer<A,B,C>(Func<B,C> f, Func<A,B> g);     static void Main(string[] args)    {        Func<double, double> cube = x => Math.Pow(x, 3);        Func<double, double> croot = x => Math.Pow(x, (double)1/3);         var fun = [] { Math.Sin, Math.Cos, cube };        var inv = [] { Math.Asin, Math.Acos, croot };        Composer<double, double, double> compose = (f, g) => delegate(double x) { return f(g(x)); };         for (var i = 0; i < fun.Length; ++i)        {            Console.WriteLine(compose(fun[i],inv[i])(0.5));        }    }} "
"using System; namespace LastSundayOfEachMonth{    class Program    {        static void Main()        {            Console.Write(strv);             string strYear = Console.ReadLine();            int year = Convert.ToInt32(strYear);             DateTime date;            for (int i = 1; i <= 12; i++)            {                date =  DateTime(year, i, DateTime.DaysInMonth(year, i), System..CultureInfo.CurrentCulture.Calendar);                while (date.DayOfWeek != DayOfWeek.Sunday)                {                    date = date.AddDays(-1);                }                Console.WriteLine(date.ToString(strv));            }        }    }} "
"using System;using System.Text; public class FloydsTriangle{    internal static void Main(string[] args)    {        int count;        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)        {            Console.WriteLine(MakeTriangle(count));        }        else        {            Console.WriteLine(MakeTriangle(5));            Console.WriteLine();            Console.WriteLine(MakeTriangle(14));        }    }     public static string MakeTriangle(int rows)    {        int maxValue = (rows * (rows + 1)) / 2;        int digit = 0;        StringBuilder output =  StringBuilder();         for (int row = 1; row <= rows; row++)        {            for (int column = 0; column < row; column++)            {                int colMaxDigit = (maxValue - rows) + column + 1;                if (column > 0)                {                    output.Append(' ');                }                 digit++;                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));            }             output.AppendLine();        }         return output.ToString();    }}"
" using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace RosettaCodeTasks{ 	class Program	{		static void Main ( string[ ] args )		{			FindCommonDirectoryPath.Test ( );		} 	} 	class FindCommonDirectoryPath	{		public static void Test ( )		{			Console.WriteLine ( strv );			Console.WriteLine ( );			List<string> PathSet1 =  List<string> ( );			PathSet1.Add ( strv );			PathSet1.Add ( strv );			PathSet1.Add ( strv );			Console.WriteLine(strv);			foreach ( string path in PathSet1 )			{				Console.WriteLine ( path );			}			Console.WriteLine ( strv, FindCommonPath ( strv, PathSet1 ) );		}		public static string FindCommonPath ( string Separator, List<string> Paths )		{			string CommonPath = String.Empty;			List<string> SeparatedPath = Paths				.First ( str => str.Length == Paths.Max ( st2 => st2.Length ) )				.Split (  string[ ] { Separator }, StringSplitOptions.RemoveEmptyEntries )				.ToList ( ); 			foreach ( string PathSegment in SeparatedPath.AsEnumerable ( ) )			{				if ( CommonPath.Length == 0 && Paths.All ( str => str.StartsWith ( PathSegment ) ) )				{					CommonPath = PathSegment;				}				else if ( Paths.All ( str => str.StartsWith ( CommonPath + Separator + PathSegment ) ) )				{					CommonPath += Separator + PathSegment;				}				else				{					break;				}			} 			return CommonPath;		}	}}  "
using System;class RecursionLimit{  static void Main(string[] args)  {    Recur(0);  }   private static void Recur(int i)   {    Console.WriteLine(i);    Recur(i + 1);  }}
using System;using System.IO; class Program{    static void Main(string[] args)    {        Console.WriteLine( FileInfo(strv).Length);        Console.WriteLine( FileInfo(strv).Length);    }} 
"using System;using System.IO; Console.WriteLine(File.GetLastWriteTime(strv));File.SetLastWriteTime(strv, DateTime.Now);"
"ArrayList array =  ArrayList(  int[] { 1, 2, 3, 4, 5 } );ArrayList evens =  ArrayList();foreach( int i in array ){        if( (i%2) == 0 )                evens.Add( i );}foreach( int i in evens )       System.Console.WriteLine( i.ToString() );List<int> array =  List<int>(  int[] { 1, 2, 3, 4, 5 } );List<int> evens = array.FindAll( delegate( int i ) { return (i%2)==0; } );foreach( int i in evens )       System.Console.WriteLine( i.ToString() );IEnumerable<int> array =  List<int>(  int[] { 1, 2, 3, 4, 5 } );IEnumerable<int> evens = array.Where( delegate( int i ) { return (i%2)==0; } );foreach( int i in evens )       System.Console.WriteLine( i.ToString() );int[] array = { 1, 2, 3, 4, 5 };int[] evens = array.Where(i => (i % 2) == 0).ToArray(); foreach (int i in evens)    Console.WriteLine(i);"
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace Fibonacci{    class Program    {        static void Main(string[] args)        {            PrintNumberSequence(strv, GetNnacciNumbers(2, 10));            PrintNumberSequence(strv, GetLucasNumbers(10));            PrintNumberSequence(strv, GetNnacciNumbers(3, 10));            PrintNumberSequence(strv, GetNnacciNumbers(4, 10));            Console.ReadKey();        }         private static IList<ulong> GetLucasNumbers(int length)        {            IList<ulong> seedSequence =  List<ulong>() { 2, 1 };            return GetFibLikeSequence(seedSequence, length);        }         private static IList<ulong> GetNnacciNumbers(int seedLength, int length)        {            return GetFibLikeSequence(GetNacciSeed(seedLength), length);        }         private static IList<ulong> GetNacciSeed(int seedLength)        {            IList<ulong> seedSquence =  List<ulong>() { 1 };             for (uint i = 0; i < seedLength - 1; i++)            {                seedSquence.Add((ulong)Math.Pow(2, i));            }             return seedSquence;        }         private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)        {            IList<ulong> sequence =  List<ulong>();             int count = seedSequence.Count();             if (length <= count)            {                sequence = seedSequence.Take((int)length).ToList();            }            else            {                sequence = seedSequence;                 for (int i = count; i < length; i++)                {                    ulong num = 0;                     for (int j = 0; j < count; j++)                    {                        num += sequence[sequence.Count - 1 - j];                    }                     sequence.Add(num);                }            }             return sequence;        }         private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)        {            StringBuilder output =  StringBuilder(Title).Append(strv);             foreach (long item in numbersequence)            {                output.AppendFormat(strv, item);            }             Console.WriteLine(output.ToString());        }    }}"
"using System;using System.Collections.Generic;using System.IO;using System.Text; class Program{    public class FastaEntry    {        public string Name { get; set; }        public StringBuilder Sequence { get; set; }    }     static IEnumerable<FastaEntry> ParseFasta(StreamReader fastaFile)    {        FastaEntry f = null;        string line;        while ((line = fastaFile.ReadLine()) != null)        {            // ignore comment lines            if (line.StartsWith(strv))                continue;             if (line.StartsWith(strv))            {                if (f != null)                    yield return f;                f =  FastaEntry { Name = line.Substring(1), Sequence =  StringBuilder() };            }            else if (f != null)                f.Sequence.Append(line);        }        yield return f;    }     static void Main(string[] args)    {        try        {            using (var fastaFile =  StreamReader(strv))            {                foreach (FastaEntry f in ParseFasta(fastaFile))                    Console.WriteLine(strv, f.Name, f.Sequence);            }        }        catch (FileNotFoundException e)        {            Console.WriteLine(e);        }        Console.ReadLine();    }}"
"using System.IO; using (var reader =  StreamReader(strv))using (var writer =  StreamWriter(strv)){    var text = reader.ReadToEnd();    writer.Write(text);}using System.IO; var text = File.ReadAllText(strv);File.WriteAllText(strv, text);"
" public static ulong Fib(uint n) {    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);}  public static ulong Fib(uint n) {    return Fib(0, 1, n);} private static ulong Fib(ulong a, ulong b, uint n) {    return (n < 1)? a :(n == 1)?  b : Fib(b, a + b, n - 1);}  public static ulong Fib(uint x) {    if (x == 0) return 0;     ulong prev = 0;    ulong next = 1;    for (int i = 1; i < x; i++)    {        ulong sum = prev + next;        prev = next;        next = sum;    }    return next;}  public static IEnumerable<long> Fibs(uint x) {    IList<ulong> fibs =  List<ulong>();     ulong prev = -1;    ulong next = 1;    for (int i = 0; i < x; i++)    {     long sum = prev + next;        prev = next;        next = sum;        fibs.Add(sum);     }    return fibs;}  public static IEnumerable<ulong> Fibs(uint x) {    ulong prev = -1;    ulong next = 1;    for (uint i = 0; i < x; i++) {        ulong sum = prev + next;        prev = next;        next = sum;        yield return sum;    }}  private static double Phi = ((1d + Math.Sqrt(5d))/2d);private static double D = 1d/Math.Sqrt(5d); ulong Fib(uint n) {    if(n > 92) throw  ArgumentOutOfRangeException(strv, n, strv);     return (ulong)((Phi^n) - (1d - Phi)^n))*D);}  public static ulong Fib(uint n) {    var M =  Matrix(1,0,0,1);    var N =  Matrix(1,1,1,0);    for (uint i = 1; i < n; i++) M *= N;    return (ulong)M[0][0];}  private static Matrix M;private static readonly Matrix N =  Matrix(1,1,1,0); public static ulong Fib(uint n) {    M =  Matrix(1,0,0,1);    MatrixPow(n-1);    return (ulong)M[0][0];} private static void MatrixPow(double n){    if (n > 1) {        MatrixPow(n/2);        M *= M;    }    if (n % 2 == 0) M *= N;}  private static int[] fibs =  int[]{ -1836311903, 1134903170,   -701408733, 433494437, -267914296, 165580141, -102334155,   63245986, -39088169, 24157817, -14930352, 9227465, -5702887,   3524578, -2178309, 1346269, -832040, 514229, -317811, 196418,   -121393, 75025, -46368, 28657, -17711, 10946, -6765, 4181,   -2584, 1597, -987, 610, -377, 233, -144, 89, -55, 34, -21, 13,   -8, 5, -3, 2, -1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,   144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711,  28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040,  1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817,  39088169, 63245986, 102334155, 165580141, 267914296, 433494437,  701408733, 1134903170, 1836311903}; public static int Fib(int n) {    if(n < -46 || n > 46) throw  ArgumentOutOfRangeException(strv, n, strv)    return fibs[n+46];} "
using System; namespace prog{	class MainClass	{		public static void Main (string[] args)		{			int q = 929;			if ( !isPrime(q) ) return;			int r = q;			while( r > 0 ) 				r <<= 1;			int d = 2 * q + 1;			do			{				int i = 1;				for( int p=r; p!=0; p<<=1 )				{					i = (i*i) % d;					if (p < 0) i *= 2;					if (i > d) i -= d;				}				if (i != 1) d += 2 * q; else break;							}			while(true); 			Console.WriteLine(strv+q+strv+d+strv); 		} 		static bool isPrime(int n)		{			if ( n % 2 == 0 ) return n == 2;			if ( n % 3 == 0 ) return n == 3;			int d = 5;			while( d*d <= n )			{				if ( n % d == 0 ) return false;				d += 2;				if ( n % d == 0 ) return false;				d += 4;			}			return true;		}	}}
"using System;using System.Linq;using System.Collections.Generic; public static class Extension{    public static List<int> Factors(this int me)    {        return Enumerable.Range(1, me).Where(x => me % x == 0).ToList();    }} class Program{    static void Main(string[] args)    {        Console.WriteLine(String.Join(strv, 45.Factors()));            }}static void Main(string[] args){	do	{		Console.WriteLine(strv);		Int64 p = 0;		do		{			try			{				p = Convert.ToInt64(Console.ReadLine());				break;			}			catch (Exception)			{ } 		} while (true); 		Console.WriteLine(strv + ((int)Math.Sqrt(p)).ToString() + strv);		for (int x = 1; x <= (int)Math.Sqrt(p); x++)		{			if (p % x == 0)				Console.WriteLine(strv + x.ToString() + strv + p.ToString() + strv + x.ToString() + strv + (p / x).ToString());		} 		Console.WriteLine(strv);	} while (true);}"
" using System;using System.Collections.Generic;using System.Linq; class Program{    static void RunCode(string code)    {        int accumulator = 0;        var opcodes =  Dictionary<char, Action>        {            {'H', () => Console.WriteLine(strv))},            {'Q', () => Console.WriteLine(code) },            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(""{0} bottles of beer on the wall{0} bottles of beerTake one down, pass it around{1} bottles of beer on the wall"", n, n-1)).Aggregate((a,b) => a + """" + b))},            {'+', () => accumulator++ }        }         foreach(var c in code)            opcodes[c]();    }} "
" static void Main(string[] args){	Console.WriteLine(strv + Expon(5, 5));	Console.WriteLine(strv + Expon(5.5, 5));	Console.ReadLine();} static double Expon(int Val, int Pow) {	return Math.Pow(Val, Pow);}static double Expon(double Val, int Pow){	return Math.Pow(Val, Pow);} "
"using System; class Program{    static int Factorial(int number)    {        if(number < 0)             throw  ArgumentOutOfRangeException(nameof(number), number, strv);         var accumulator = 1;        for (var factor = 1; factor <= number; factor++)        {            accumulator *= factor;        }        return accumulator;    }     static void Main()    {        Console.WriteLine(Factorial(10));    }}using System; class Program{    static int Factorial(int number)    {        if(number < 0)             throw  ArgumentOutOfRangeException(nameof(number), number, strv);         return number == 0 ? 1 : number * Factorial(number - 1);    }     static void Main()    {        Console.WriteLine(Factorial(10));    }}using System; class Program{    static int Factorial(int number)    {        if(number < 0)             throw  ArgumentOutOfRangeException(nameof(number), number, strv);         return Factorial(number, 1);    }     static int Factorial(int number, int accumulator)    {        if(number < 0)             throw  ArgumentOutOfRangeException(nameof(number), number, strv);        if(accumulator < 1)             throw  ArgumentOutOfRangeException(nameof(accumulator), accumulator, strv);         return number == 0 ? accumulator : Factorial(number - 1, number * accumulator);    }     static void Main()    {        Console.WriteLine(Factorial(10));    }}using System;using System.Linq; class Program{    static int Factorial(int number)    {        return Enumerable.Range(1, number).Aggregate((accumulator, factor) => accumulator * factor);    }     static void Main()    {        Console.WriteLine(Factorial(10));    }}"
"using System.Diagnostics; namespace Execute{    class Program    {        static void Main(string[] args)        {            Process.Start(strv, strv);        }    }}using System;   class Execute {     static void Main() {         System..Process proc =  System..Process();         proc.EnableRaisingEvents=false;         proc.StartInfo.FileName=strv;         proc.Start();    } }"
using System; //Used for Exception and Console classesclass Exceptions{  class U0 : Exception { }  class U1 : Exception { }  static int i;  static void foo()  {    for (i = 0; i < 2; i++)      try      {        bar();      }      catch (U0) {        Console.WriteLine(strv);      }  }  static void bar()  {    baz();  }  static void baz(){    if (i == 0)      throw  U0();    throw  U1();  }   public static void Main()  {    foo();  }}
"using System;using System.Timers; class Program{    static void Main()    {        var timer =  Timer(1000);        timer.Elapsed +=  ElapsedEventHandler(OnElapsed);        Console.WriteLine(DateTime.Now);        timer.Start();        Console.ReadLine();    }     static void OnElapsed(object sender, ElapsedEventArgs eventArgs)    {        Console.WriteLine(eventArgs.SignalTime);        ((Timer)sender).Stop();    }}"
public class MyException : Exception{  // data with info about exception};void foo(){  throw MyException();}try {  foo();}catch (MyException e){  // handle exceptions of type MyException and derived}catch{  // handle any type of exception not handled by above catches}
"namespace RosettaCode{    using System;     public static class EvenOrOdd    {        public static bool IsEvenBitwise(this int number)        {            return (number & 1) == 0;        }         public static bool IsOddBitwise(this int number)        {            return (number & 1) != 0;        }         public static bool IsEvenRemainder(this int number)        {            int remainder;            Math.DivRem(number, 2, out remainder);            return remainder == 0;        }         public static bool IsOddRemainder(this int number)        {            int remainder;            Math.DivRem(number, 2, out remainder);            return remainder != 0;        }         public static bool IsEvenModulo(this int number)        {            return (number % 2) == 0;        }         public static bool IsOddModulo(this int number)        {            return (number % 2) != 0;        }    }}"
"using System; namespace BinomialCoefficients{    class Program    {        static void Main(string[] args)        {            ulong n = 1000000, k = 3;            ulong result = biCoefficient(n, k);            Console.WriteLine(strv, n, k, result);            Console.ReadLine();        }         static int fact(int n)        {            if (n == 0) return 1;            else return n * fact(n - 1);        }         static ulong biCoefficient(ulong n, ulong k)        {            if (k > n - k)            {                k = n - k;            }             ulong c = 1;            for (uint i = 0; i < k; i++)            {                c = c * (n - i);                c = c / (i + 1);            }            return c;        }    }}"
"using System; namespace prog{	class MainClass	{		const float T0 = 100f;		const float TR = 20f;		const float k = 0.07f;		readonly static float[] delta_t = {2.0f,5.0f,10.0f};		const int n = 100; 		public delegate float func(float t);		static float NewtonCooling(float t)		{			return -k * (t-TR);					} 		public static void Main (string[] args)		{			func f =  func(NewtonCooling); 			for(int i=0; i<delta_t.Length; i++)			{				Console.WriteLine(strv + delta_t[i]);				Euler(f,T0,n,delta_t[i]);			}		} 		public static void Euler(func f, float y, int n, float h)		{			for(float x=0; x<=n; x+=h)			{				Console.WriteLine("""" + x + """" + y);				y += h * f(y);				}		}	}}"
using System; namespace RosettaCode {    class Program {        static void Main() {            string temp = Environment.GetEnvironmentVariable(strv);            Console.WriteLine(strv + temp);        }    }}
"enum fruits { apple, banana, cherry } enum fruits { apple = 0, banana = 1, cherry = 2 } enum fruits : int { apple = 0, banana = 1, cherry = 2 } [FlagsAttribute]enum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }"
"using System;using System.Collections.Generic;using System.Linq; static class Program {    static Random Rng =  Random((int)DateTime.Now.Ticks);     static char NextCharacter(this Random self) {        const string AllowedChars = strv;        return AllowedChars[self.Next() % AllowedChars.Length];    }     static string NextString(this Random self, int length) {        return String.Join(strv, Enumerable.Repeat(' ', length)            .Select(c => Rng.NextCharacter()));    }     static int Fitness(string target, string current) {        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();    }     static string Mutate(string current, double rate) {        return String.Join(strv, from c in current               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);    }     static void Main(string[] args) {        const string target = strv;        const int C = 100;        const double P = 0.05;         // Start with a random string the same length as the target.        string parent = Rng.NextString(target.Length);         Console.WriteLine(strv,             parent, Fitness(target, parent));        int i = 0;         while (parent != target) {            // Create C mutated strings + the current parent.            var candidates = (from child in Enumerable.Repeat(parent, C)                              select Mutate(child, P))                              .Concat(Enumerable.Repeat(parent, 1));             // Sort the strings by the fitness function.            var sorted = from candidate in candidates                         orderby Fitness(target, candidate) descending                         select candidate;             // New parent is the most fit candidate.            parent = sorted.First();             ++i;            Console.WriteLine(strv,                 i, parent, Fitness(target, parent));        }         Console.WriteLine(strv, i, parent);    }}"
" using System;using System.Collections.Generic;namespace Entropy{	class Program	{		public static double logtwo(double num)		{			return Math.Log(num)/Math.Log(2);		}		public static void Main(string[] args)		{		label1:			string input = Console.ReadLine();			double infoC=0;			Dictionary<char,double> table =  Dictionary<char, double>();  			foreach (char c in input)			{				if (table.ContainsKey(c))					table[c]++;				    else				    	table.Add(c,1); 			}			double freq;			foreach (KeyValuePair<char,double> letter in table)			{				freq=letter.Value/input.Length;				infoC+=freq*logtwo(freq);			}			infoC*=-1;			Console.WriteLine(strv,input,infoC);			goto label1; 		}	}} using System;namespace Entropy{	 class Program	{		public static double logtwo(double num)		{			return Math.Log(num)/Math.Log(2);		}		static double Contain(string x,char k)		{			double count=0;			foreach (char Y in x)			{				if(Y.Equals(k))					count++;			}			return count;		}		public static void Main(string[] args)		{		label1:			string input = Console.ReadLine();			double infoC=0;			double freq;			string k=strv;			foreach (char c1 in input)			{				if (!(k.Contains(c1.ToString())))					k+=c1;			}			foreach (char c in k)			{				freq=Contain(input,c)/(double)input.Length;				infoC+=freq*logtwo(freq);			}			infoC/=-1;			Console.WriteLine(strv,input,infoC);			goto label1; 		}	}}"
" using System;using System.Linq; namespace RosettaCode.Tasks{	public static class EthiopianMultiplication_Task	{		public static void Test ( )		{			Console.WriteLine ( strv );			int A = 17, B = 34;			Console.WriteLine ( strv, A, B, EM_Recursion ( A, B ) );			Console.WriteLine ( strv, A, B, EM_Linq ( A, B ) );			Console.WriteLine ( strv, A, B, EM_Loop ( A, B ) );			Console.WriteLine ( );		} 		public static int Halve ( this int p_Number )		{			return p_Number >> 1;		}		public static int Double ( this int p_Number )		{			return p_Number << 1;		}		public static bool IsEven ( this int p_Number )		{			return ( p_Number % 2 ) == 0;		} 		public static int EM_Recursion ( int p_NumberA, int p_NumberB )		{			//     Anchor Point,                Recurse to find the next row                                 Sum it with the second number according to the rules			return p_NumberA == 1 ? p_NumberB : EM_Recursion ( p_NumberA.Halve ( ), p_NumberB.Double ( ) ) + ( p_NumberA.IsEven ( ) ? 0 : p_NumberB );		}		public static int EM_Linq ( int p_NumberA, int p_NumberB )		{			// Creating a range from 1 to x where x the number of times p_NumberA can be halved.			// This will be 2^x where 2^x <= p_NumberA. Basically, ln(p_NumberA)/ln(2).			return Enumerable.Range ( 1, Convert.ToInt32 ( Math.Log ( p_NumberA, Math.E ) / Math.Log ( 2, Math.E ) ) + 1 )				// For every item (Y) in that range, create a new list, comprising the pair (p_NumberA,p_NumberB) Y times.				.Select ( ( item ) => Enumerable.Repeat (  { Col1 = p_NumberA, Col2 = p_NumberB }, item )					// The aggregate method iterates over every value in the target list, passing the accumulated value and the current item's value.					.Aggregate ( ( agg_pair, orig_pair ) =>  { Col1 = agg_pair.Col1.Halve ( ), Col2 = agg_pair.Col2.Double ( ) } ) )				// Remove all even items				.Where ( pair => !pair.Col1.IsEven ( ) )				// And sum!				.Sum ( pair => pair.Col2 );		}		public static int EM_Loop ( int p_NumberA, int p_NumberB )		{			int RetVal = 0;			while ( p_NumberA >= 1 )			{				RetVal += p_NumberA.IsEven ( ) ? 0 : p_NumberB;				p_NumberA = p_NumberA.Halve ( );				p_NumberB = p_NumberB.Double ( );			}			return RetVal;		}	}}"
using System; class Program {    static void Main (string[] args) {        string example = string.Empty;        if (string.IsNullOrEmpty(example)) { }        if (!string.IsNullOrEmpty(example)) { }    }} 
"using System;using System.IO; class Program{    static void Main( string[] args )    {        foreach ( string dir in args )        {            Console.WriteLine( strv, dir, IsDirectoryEmpty( dir ) ? strv : strv );        }    }     private static bool IsDirectoryEmpty( string dir )    {        return ( Directory.GetFiles( dir ).Length == 0 &&            Directory.GetDirectories( dir ).Length == 0 );    }} "
" using System;using System.Collections;namespace ElementaryCellularAutomaton{    class Automata    {        BitArray cells, ncells;        const int MAX_CELLS = 19;         public void run()        {            cells =  BitArray(MAX_CELLS);            ncells =  BitArray(MAX_CELLS);            while (true)            {                Console.Clear();                Console.WriteLine(strv);                doRule(int.Parse(Console.ReadLine()));                Console.WriteLine(strv);                Console.ReadKey();            }        }         private byte getCells(int index)        {            byte b;            int i1 = index - 1,                i2 = index,                i3 = index + 1;             if (i1 < 0) i1 = MAX_CELLS - 1;            if (i3 >= MAX_CELLS) i3 -= MAX_CELLS;             b = Convert.ToByte(                4 * Convert.ToByte(cells.Get(i1)) +                2 * Convert.ToByte(cells.Get(i2)) +                Convert.ToByte(cells.Get(i3)));            return b;        }         private string getBase2(int i)        {            string s = Convert.ToString(i, 2);            while (s.Length < 8)            { s = strv + s; }            return s;        }         private void doRule(int rule)        {            Console.Clear();            string rl = getBase2(rule);            cells.SetAll(false);            ncells.SetAll(false);            cells.Set(MAX_CELLS / 2, true);             Console.WriteLine(strv + rule + ""----------"");             for (int gen = 0; gen < 51; gen++)            {                Console.Write(strv, gen + strv);                 foreach (bool b in cells)                    Console.Write(b ? strv : strv);                 Console.WriteLine(strv);                 int i = 0;                while (true)                {                    byte b = getCells(i);                    ncells[i] = '1' == rl[7 - b] ? true : false;                    if (++i == MAX_CELLS) break;                }                 i = 0;                foreach (bool b in ncells)                    cells[i++] = b;            }            Console.WriteLine(strv);        }     };    class Program    {        static void Main(string[] args)        {            Automata t =  Automata();            t.run();        }    }} "
class P{static void Main(){}}
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace RosettaCode{    class Program    {        static void QuickSort(IComparable[] elements, int left, int right)        {            int i = left, j = right;            IComparable pivot = elements[left + (right - left) / 2];             while (i <= j)            {                while (elements[i].CompareTo(pivot) < 0) i++;                while (elements[j].CompareTo(pivot) > 0) j--;                 if (i <= j)                {                    // Swap                    IComparable tmp = elements[i];                    elements[i] = elements[j];                    elements[j] = tmp;                    i++;                    j--;                }            }             // Recursive calls            if (left < j) QuickSort(elements, left, j);            if (i < right) QuickSort(elements, i, right);        }        const int NUMBALLS = 5;        static void Main(string[] args)        {            Func<string[], bool> IsSorted = (ballList) =>                {                    int state = 0;                    for (int i = 0; i < NUMBALLS; i++)                    {                        if (int.Parse(ballList[i]) < state)                            return false;                        if (int.Parse(ballList[i]) > state)                            state = int.Parse(ballList[i]);                    }                    return true;                };            Func<string[], string> PrintOut = (ballList2) =>                {                    StringBuilder str =  StringBuilder();                    for (int i = 0; i < NUMBALLS; i++)                        str.Append(int.Parse(ballList2[i]) == 0 ? strv : int.Parse(ballList2[i]) == 1 ? strv : strv);                    return str.ToString();                };            bool continueLoop = true;            string[] balls =  string[NUMBALLS]; // 0 = r, 1 = w, 2 = b            Random numberGenerator =  Random();            do // Enforce that we start with non-sorted balls            {                // Generate balls                for (int i = 0; i < NUMBALLS; i++)                    balls[i] = numberGenerator.Next(3).ToString();                 continueLoop = IsSorted(balls);                if (continueLoop)                    Console.WriteLine(strv, PrintOut(balls));            } while (continueLoop);            Console.WriteLine(strv, PrintOut(balls));            QuickSort(balls, 0, NUMBALLS - 1); // Sort them using quicksort            Console.WriteLine(strv, IsSorted(balls) ? strv : strv, PrintOut(balls));        }    }} "
"using System.Net.Sockets;using System.Threading; namespace ConsoleApplication1{    class Program    {        static TcpListener listen;        static Thread serverthread;         static void Main(string[] args)        {            listen =  TcpListener(System..IPAddress.Parse(strv), 12321);            serverthread =  Thread( ThreadStart(DoListen));            serverthread.Start();        }         private static void DoListen()        {            // Listen            listen.Start();            Console.WriteLine(strv);             while (true)            {                Console.WriteLine(strv);                TcpClient client = listen.AcceptTcpClient();                Console.WriteLine(strv);                 // New thread with client                Thread clientThread =  Thread( ParameterizedThreadStart(DoClient));                clientThread.Start(client);            }        }         private static void DoClient(object client)        {            // Read data            TcpClient tClient = (TcpClient)client;             Console.WriteLine(strv, Thread.CurrentThread.ManagedThreadId);            do            {                if (!tClient.Connected)                {                     tClient.Close();                    Thread.CurrentThread.Abort();       // Kill thread.                }                 if (tClient.Available > 0)                {                    // Resend                    byte pByte = (byte)tClient.GetStream().ReadByte();                    Console.WriteLine(strv, Thread.CurrentThread.ManagedThreadId, pByte);                    tClient.GetStream().WriteByte(pByte);                }                 // Pause                Thread.Sleep(100);            } while (true);        }    }}"
using System;using System.Collections.Generic; namespace RosettaCode.DoublyLinkedList{    internal static class Program    {        private static void Main()        {            var list =  LinkedList<char>(strv);             var current = list.First;            do            {                Console.WriteLine(current.Value);            } while ((current = current.Next) != null);             Console.WriteLine();             current = list.Last;            do            {                Console.WriteLine(current.Value);            } while ((current = current.Previous) != null);        }    }}
"static void InsertAfter(Link prev, int i){    if (prev.next != null)    {        prev.next.prev =  Link() { item = i, prev = prev, next = prev.next };        prev.next = prev.next.prev;    }    else        prev.next =  Link() { item = i, prev = prev };}static void Main(){    //Create A(5)->B(7)    var A =  Link() { item = 5 };    InsertAfter(A, 7);    //Insert C(15) between A and B    InsertAfter(A, 15);}"
"class Link{    public int Item { get; set; }    public Link Prev { get; set; }    public Link Next { get; set; }     //A constructor is not neccessary, but could be useful    public Link(int item, Link prev = null, Link next = null) {        Item = item;        Prev = prev;        Next = next;    }}"
"


public static class XMLSystem{    static XMLSystem()    {        // Constructor    }     
    
    
    
    
    public static XmlDocument GetXML(string name)     {        return null;    }}"
"using System;using System.Collections.Generic;using System.Drawing;using System.Drawing.Drawing2D;using System.Windows.Forms; public class DragonCurve : Form{    private List<int> turns;    private double startingAngle, side;     public DragonCurve(int iter)    {        Size =  Size(800, 600);        StartPosition = FormStartPosition.CenterScreen;        DoubleBuffered = true;        BackColor = Color.White;         startingAngle = -iter * (Math.PI / 4);        side = 400 / Math.Pow(2, iter / 2.0);         turns = getSequence(iter);    }     private List<int> getSequence(int iter)    {        var turnSequence =  List<int>();        for (int i = 0; i < iter; i++)        {            var copy =  List<int>(turnSequence);            copy.Reverse();            turnSequence.Add(1);            foreach (int turn in copy)            {                turnSequence.Add(-turn);            }        }        return turnSequence;    }     protected override void OnPaint(PaintEventArgs e)    {        base.OnPaint(e);        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;         double angle = startingAngle;        int x1 = 230, y1 = 350;        int x2 = x1 + (int)(Math.Cos(angle) * side);        int y2 = y1 + (int)(Math.Sin(angle) * side);        e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);        x1 = x2;        y1 = y2;        foreach (int turn in turns)        {            angle += turn * (Math.PI / 2);            x2 = x1 + (int)(Math.Cos(angle) * side);            y2 = y1 + (int)(Math.Sin(angle) * side);            e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);            x1 = x2;            y1 = y2;        }    }     [STAThread]    static void Main()    {        Application.Run( DragonCurve(14));    }}"
"using System;using System.Drawing;using System.Drawing.Drawing2D;using System.Windows.Forms; public class Clock : Form{    static readonly float degrees06 = (float)Math.PI / 30;    static readonly float degrees30 = degrees06 * 5;    static readonly float degrees90 = degrees30 * 3;     readonly int margin = 20;     private Point p0;     public Clock()    {        Size =  Size(500, 500);        StartPosition = FormStartPosition.CenterScreen;        Resize += (sender, args) => ResetSize();        ResetSize();        var timer =  Timer() { Interval = 1000, Enabled = true };        timer.Tick += (sender, e) => Refresh();        DoubleBuffered = true;    }     private void ResetSize()    {        p0 =  Point(ClientRectangle.Width / 2, ClientRectangle.Height / 2);        Refresh();    }     protected override void OnPaint(PaintEventArgs e)    {        base.OnPaint(e);        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;         drawFace(e.Graphics);         var time = DateTime.Now;        int second = time.Second;        int minute = time.Minute;        int hour = time.Hour;         float angle = degrees90 - (degrees06 * second);        DrawHand(e.Graphics, Pens.Red, angle, 0.95);         float minsecs = (minute + second / 60.0F);        angle = degrees90 - (degrees06 * minsecs);        DrawHand(e.Graphics, Pens.Black, angle, 0.9);         float hourmins = (hour + minsecs / 60.0F);        angle = degrees90 - (degrees30 * hourmins);        DrawHand(e.Graphics, Pens.Black, angle, 0.6);    }     private void drawFace(Graphics g)    {        int radius = Math.Min(p0.X, p0.Y) - margin;        g.FillEllipse(Brushes.White, p0.X - radius, p0.Y - radius, radius * 2, radius * 2);         for (int h = 0; h < 12; h++)            DrawHand(g, Pens.LightGray, h * degrees30, -0.05);         for (int m = 0; m < 60; m++)            DrawHand(g, Pens.LightGray, m * degrees06, -0.025);    }     private void DrawHand(Graphics g, Pen pen, float angle, double size)    {        int radius = Math.Min(p0.X, p0.Y) - margin;         int x0 = p0.X + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Cos(angle)));        int y0 = p0.Y + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Sin(-angle)));         int x1 = p0.X + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Cos(angle));        int y1 = p0.Y + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Sin(-angle));         g.DrawLine(pen, x0, y0, x1, y1);    }     [STAThread]    static void Main()    {        Application.Run( Clock());    }}"
"static void Main(string[] args){	Console.WriteLine(DotProduct( decimal[] { 1, 3, -5 },  decimal[] { 4, -2, -1 }));	Console.Read();} private static decimal DotProduct(decimal[] vec1, decimal[] vec2) {	if (vec1 == null)		return 0; 	if (vec2 == null)		return 0; 	if (vec1.Length != vec2.Length)		return 0; 	decimal tVal = 0;	for (int x = 0; x < vec1.Length; x++)	{		tVal += vec1[x] * vec2[x];	} 	return tVal;}public static decimal DotProduct(decimal[] a, decimal[] b) {    return a.Zip(b, (x, y) => x * y).Sum();}"
" using System;using System.Linq;using System.Collections.Generic; public class MainClass {    static double Square(double x) => x * x;     static double AverageSquareDiff(double a, IEnumerable<double> predictions)        => predictions.Select(x => Square(x - a)).Average();     static void DiversityTheorem(double truth, IEnumerable<double> predictions)    {        var average = predictions.Average();        Console.WriteLine($@""average-error: {AverageSquareDiff(truth, predictions)}
crowd-error: {Square(truth - average)}
diversity: {AverageSquareDiff(average, predictions)}"");    }     public static void Main() {	DiversityTheorem(49,  []{48d,47,51});    	DiversityTheorem(49,  []{48d,47,51,42});    }}"
" using System;using System.IO;using System.Net;using System.Net.Sockets;using System.Runtime.Serialization.Formatters.Binary;using System.Threading.Tasks; using static System.Console; class DistributedProgramming{    const int Port = 555;     async static Task RunClient()    {        WriteLine(strv);        var client =  TcpClient();        await client.ConnectAsync(strv, Port);         using (var stream = client.GetStream())        {            WriteLine(strv);            var data = Serialize( SampleData());            await stream.WriteAsync(data, 0, data.Length);             WriteLine(strv);            var buffer =  byte[80000];            var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);            var thanks = (string)Deserialize(buffer, bytesRead);            WriteLine(thanks);        }         client.Close();    }     async static Task RunServer()    {        WriteLine(strv);        var listener =  TcpListener(IPAddress.Any, Port);        listener.Start();        var client = await listener.AcceptTcpClientAsync();         using (var stream = client.GetStream())        {            WriteLine(strv);            var buffer =  byte[80000];            var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);            var data = (SampleData)Deserialize(buffer, bytesRead);            WriteLine($strv);             WriteLine(strv);            var thanks = Serialize(strv);            await stream.WriteAsync(thanks, 0, thanks.Length);        }         client.Close();        listener.Stop();        Write(strv);        ReadKey();    }     static byte[] Serialize(object data)    {        using (var mem =  MemoryStream())        {             BinaryFormatter().Serialize(mem, data);            return mem.ToArray();        }    }     static object Deserialize(byte[] data, int length)    {        using (var mem =  MemoryStream(data, 0, length))        {            return  BinaryFormatter().Deserialize(mem);        }    }     static void Main(string[] args)    {        if (args.Length == 0) return;         switch (args[0])        {            case strv: RunClient().Wait(); break;            case strv: RunServer().Wait(); break;        }    }} [Serializable]class SampleData{    public decimal Latitude = 44.33190m;    public decimal Longitude = 114.84129m;    public string Loot = strv;} "
         private string LookupDns(string s)        {            try            {                System..IPHostEntry ip = System..Dns.GetHostEntry(s);                 string result = ip.AddressList[0].ToString();                 for (int i = 1; i < ip.AddressList.Length; ++i)                    result += strv + ip.AddressList[i].ToString();                 return result;            }            catch (System..SocketException se)            {                return se.Message;            }        } 
"using System;using System.Collections.Generic;using System.Linq; class Program{    static Tuple<int, int> DigitalRoot(long num)    {        int mp = 0;        while (num > 9)        {            num = num.ToString().ToCharArray().Select(x => x - '0').Aggregate((a, b) => a * b);            mp++;        }        return  Tuple<int, int>(mp, (int)num);    }    static void Main(string[] args)    {        foreach (long num in  long[] { 123321, 7739, 893, 899998 })        {            var t = DigitalRoot(num);            Console.WriteLine(strv, num, t.Item1, t.Item2);        }         const int twidth = 5;        List<long>[] table =  List<long>[10];        for (int i = 0; i < 10; i++)            table[i] =  List<long>();        long number = -1;        while (table.Any(x => x.Count < twidth))         {            var t = DigitalRoot(++number);            if (table[t.Item2].Count < twidth)                table[t.Item2].Add(number);        }        for (int i = 0; i < 10; i++)            Console.WriteLine(strv, i, string.Join(strv, table[i]));    }}"
"public class Program{    public static void Main()    {        const int count = 5;        const int Baker = 0, Cooper = 1, Fletcher = 2, Miller = 3, Smith = 4;        string[] names = { nameof(Baker), nameof(Cooper), nameof(Fletcher), nameof(Miller), nameof(Smith) };         Func<int[], bool>[] constraints = {            floorOf => floorOf[Baker] != count-1,            floorOf => floorOf[Cooper] != 0,            floorOf => floorOf[Fletcher] != count-1 && floorOf[Fletcher] != 0,            floorOf => floorOf[Miller] > floorOf[Cooper],            floorOf => Math.Abs(floorOf[Smith] - floorOf[Fletcher]) > 1,            floorOf => Math.Abs(floorOf[Fletcher] - floorOf[Cooper]) > 1,        };         var solver =  DinesmanSolver();        foreach (var tenants in solver.Solve(count, constraints)) {            Console.WriteLine(string.Join(strv, tenants.Select(t => names[t])));        }    }} public class DinesmanSolver{    public IEnumerable<int[]> Solve(int count, params Func<int[], bool>[] constraints) {        foreach (int[] floorOf in Permutations(count)) {            if (constraints.All(c => c(floorOf))) {                yield return Enumerable.Range(0, count).OrderBy(i => floorOf[i]).ToArray();            }        }    }     static IEnumerable<int[]> Permutations(int length) {        if (length == 0) {            yield return  int[0];            yield break;        }        bool forwards = false;        foreach (var permutation in Permutations(length - 1)) {            for (int i = 0; i < length; i++) {                yield return permutation.InsertAt(forwards ? i : length - i - 1, length - 1).ToArray();            }            forwards = !forwards;        }    }} static class Extensions{    public static IEnumerable<T> InsertAt<T>(this IEnumerable<T> source, int position, T newElement) {        if (source == null) throw  ArgumentNullException(nameof(source));        if (position < 0) throw  ArgumentOutOfRangeException(nameof(position));        return InsertAtIterator(source, position, newElement);    }     private static IEnumerable<T> InsertAtIterator<T>(IEnumerable<T> source, int position, T newElement) {        int index = 0;        foreach (T element in source) {            if (index == position) yield return newElement;            yield return element;            index++;        }        if (index < position) throw  ArgumentOutOfRangeException(nameof(position));        if (index == position) yield return newElement;    }}"
"using System;using System.Net;using System.Net.Sockets; class Program {            static void Main(string[] args) {                try {            TcpListener server =  TcpListener(IPAddress.Any, 12345);            server.Start();        }          catch (SocketException e) {            if (e.SocketErrorCode == SocketError.AddressAlreadyInUse) {                Console.Error.WriteLine(strv);            }        }    }} // Use this class in your process to guard against multiple instancesusing System;using System.Threading; 




public class RunOnce : IDisposable{	public RunOnce( string name )	{		m_name = name;		AlreadyRunning = false; 		bool created_new = false; 		m_mutex =  Mutex( false, m_name, out created_new ); 		AlreadyRunning = !created_new;	} 	~RunOnce()	{		DisposeImpl( false );	} 	public bool AlreadyRunning	{		get { return m_already_running; }		private set { m_already_running = value; }	} 	private void DisposeImpl( bool is_disposing )	{		GC.SuppressFinalize( this ); 		if( is_disposing )		{			m_mutex.Close();		}	} 	#region IDisposable Members 	public void Dispose()	{		DisposeImpl( true );	} 	#endregion 	private string m_name;	private bool m_already_running;	private Mutex m_mutex;} class Program{    // Example code to use this    static void Main( string[] args )    {        using ( RunOnce ro =  RunOnce( strv ) )        {            if ( ro.AlreadyRunning )            {                Console.WriteLine( strv );                return;            }             // Program logic        }    }}"
"public static bool IsNumeric(string s){    double Result;    return double.TryParse(s, out Result);  // TryParse routines were added in Framework version 2.0.}         string value = strv;if (IsNumeric(value)) {  // do something}public static bool IsNumeric(string s){  try  {    Double.Parse(s);    return true;  }  catch  {    return false;  }}"
"using System;using System.Linq; class Program{    static Tuple<int, int> DigitalRoot(long num)    {        int additivepersistence = 0;        while (num > 9)        {            num = num.ToString().ToCharArray().Sum(x => x - '0');            additivepersistence++;        }        return  Tuple<int, int>(additivepersistence, (int)num);    }    static void Main(string[] args)    {        foreach (long num in  long[] { 627615, 39390, 588225, 393900588225 })        {            var t = DigitalRoot(num);            Console.WriteLine(strv, num, t.Item1, t.Item2);        }    }}"
"using System; interface IOperable{    string Operate();} class Inoperable{} class Operable : IOperable{    public string Operate()    {        return strv;    }} class Delegator : IOperable{    object Delegate;     public string Operate()    {        var operable = Delegate as IOperable;        return operable != null ? operable.Operate() : strv;    }     static void Main()    {        var delegator =  Delegator();        foreach (var @delegate in  object[] { null,  Inoperable(),  Operable() })        {            delegator.Delegate = @delegate;            Console.WriteLine(delegator.Operate());        }    }}"
using System;using System.IO; namespace RosettaCode {    class Program {        static void Main() {            try {                File.Delete(strv);                Directory.Delete(strv);                File.Delete(@strv);                Directory.Delete(@strv);            } catch (Exception exception) {                Console.WriteLine(exception.Message);            }        }    }}
public struct TinyInt{    private const int minimalValue = 1;    private const int maximalValue = 10;     private readonly int value;     private TinyInt(int i)    {        if (minimalValue > i || i > maximalValue)        {            throw  System.ArgumentOutOfRangeException();        }        value = i;    }     public static implicit operator int(TinyInt i)    {        return i.value;    }     public static implicit operator TinyInt(int i)    {        return  TinyInt(i);    }}
"using System; namespace prog{	class MainClass	{		class MyClass : ICloneable		{			public MyClass() { f =  int[3]{2,3,5}; c = '1'; } 			public object Clone()			{								MyClass cpy = (MyClass) this.MemberwiseClone();				cpy.f = (int[]) this.f.Clone();							return cpy;			} 			public char c;			public int[] f;		} 		public static void Main( string[] args )		{			MyClass c1 =  MyClass();			MyClass c2 = (MyClass) c1.Clone();		}	}}"
"using System;using System.Collections.Generic;using System.Text; namespace FreeCellDeals{    public class RNG    {        private int _state;         public RNG()        {            _state = (int)DateTime.Now.Ticks;        }         public RNG(int n)        {            _state = n;        }        public int Next()        {            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;        }    }     public enum Rank    {        Ace,        One,        Two,        Three,        Four,        Five,        Six,        Seven,        Eight,        Nine,        Ten,        Jack,        Queen,        King    }     public enum Suit    {        Clubs,        Diamonds,        Hearts,        Spades    }     public class Card    {        private const string Ranks = strv;        private const string Suits = strv;         private Rank _rank;        public Rank Rank        {            get            {                return _rank;            }            set            {                if ((int)value < 0 || (int)value > 12)                {                    throw  InvalidOperationException(strv);                }                _rank = value;            }        }         private Suit _suit;        public Suit Suit        {            get            {                return _suit;            }            set            {                if ((int)value < 0 || (int)value > 3)                {                    throw  InvalidOperationException(strv);                }                _suit = value;            }        }         public Card(Rank rank, Suit suit)        {            Rank = rank;            Suit = suit;        }         public int NRank()        {            return (int) Rank;        }         public int NSuit()        {            return (int) Suit;        }         public override string ToString()        {            return  string([] {Ranks[NRank()], Suits[NSuit()]});        }    }     public class FreeCellDeal    {        public List<Card> Deck { get; private set; }         public FreeCellDeal(int iDeal)        {            RNG rng =  RNG(iDeal);             List<Card> rDeck =  List<Card>();            Deck =  List<Card>();             for (int rank = 0; rank < 13; rank++)            {                for (int suit = 0; suit < 4; suit++)                {                    rDeck.Add( Card((Rank)rank, (Suit)suit));                }            }             // Normally we deal from the front of a deck.  The algorithm strv from the back so we reverse the            // deck here to more conventionally deal from the front/start of the array.            for (int iCard = 51; iCard >= 0; iCard--)            {                int iSwap = rng.Next() % (iCard + 1);                Deck.Add(rDeck[iSwap]);                rDeck[iSwap] = rDeck[iCard];            }        }         public override string ToString()        {            StringBuilder sb =  StringBuilder();            for (int iRow = 0; iRow < 6; iRow++ )            {                for (int iCol = 0; iCol < 8; iCol++)                {                    sb.AppendFormat(strv, Deck[iRow * 8 + iCol]);                }                sb.Append("""");            }            for (int iCard = 48; iCard < 52; iCard++)            {                sb.AppendFormat(strv, Deck[iCard]);            }            return sb.ToString();        }    }     class Program    {        static void Main()        {            Console.WriteLine( FreeCellDeal(1));            Console.WriteLine();            Console.WriteLine( FreeCellDeal(617));        }    }} using System;using System.Text; namespace FreeCellConsole{	public class Rand {		long _seed;		public Rand(int seed=1) {			_seed = seed;		}		public int Next() {			return (int) ((_seed = (_seed * 214013 + 2531011) & int.MaxValue) >> 16);		}	} 	public class Card {		private static readonly string kSuits = strv;		private static readonly string kValues = strv;		public int Value { get; set; }		public int Suit { get; set; }		public Card(int rawvalue=0) : this(rawvalue / 4, rawvalue % 4) {		}		public Card(int value, int suit) {			Value = value;  Suit = suit;		}		public override string ToString() {			return string.Format(strv, kValues[Value], kSuits[Suit]);		}	} 	public class Deck {		public Card[] Cards;		public Deck(int seed) {			var r =  Rand(seed);			Cards =  Card[52];			for (int i=0; i < 52; i++)				Cards[i] =  Card(51 - i);			for (int i=0; i < 51; i++) {				int j = 51 - r.Next() % (52 - i);				Card tmp = Cards[i];  Cards[i] = Cards[j];  Cards[j] = tmp;			}		}		public override string ToString() {			var sb =  StringBuilder();			for (int i=0; i < Cards.Length; i++) {				sb.Append(Cards[i].ToString());				sb.Append(i % 8 == 7 ? """" : strv);			}			return sb.ToString();		}	} 	class Program {		public static void Main(string[] args) {			Console.WriteLine(""Deck 1{0}"",  Deck(1));			Console.WriteLine(""Deck 617{0}"",  Deck(617));		}	}} "
using System; namespace RosettaCode {    class Program {        static void Main(string[] args) {            int x = 1;            int y = 0;            try {               int z = x / y;            } catch (DivideByZeroException e) {                Console.WriteLine(e);            }         }    }}
"using System; class Program{    static void Main(string[] args)    {        for (int i = 2008; i <= 2121; i++)        {            DateTime date =  DateTime(i, 12, 25);            if (date.DayOfWeek == DayOfWeek.Sunday)            {                Console.WriteLine(date.ToString(strv));            }        }    }}using System;using System.Linq; class Program{    static void Main(string[] args)    {        string[] days = Enumerable.Range(2008, 2121 - 2007)            .Select(year =>  DateTime(year, 12, 25))            .Where(day => day.DayOfWeek == DayOfWeek.Sunday)            .Select(day => day.ToString(strv)).ToArray();         foreach (string day in days) Console.WriteLine(day);    }}using System;using System.Linq; class Program{    static void Main(string[] args)    {        Enumerable.Range(2008, 113).ToList()        .ConvertAll(ent =>  DateTime(ent, 12, 25))        .Where(ent => ent.DayOfWeek.Equals(DayOfWeek.Sunday)).ToList()        .ForEach(ent => Console.WriteLine(ent.ToString(strv)));    }}"
"class Program{    static void Main(string[] args)    {        CultureInfo ci=CultureInfo.CreateSpecificCulture(strv);        string dateString = strv;        string format = strv;        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(strv,strv),format,ci) ;        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;        Console.WriteLine(newDateTime.ToString(format).Replace(strv,strv)); //probably not the best way to do this         Console.ReadLine();    }}"
using System; namespace RosettaCode.DateFormat{    class Program    {        static void Main(string[] args)        {            DateTime today = DateTime.Now.Date;            Console.WriteLine(today.ToString(strv));            Console.WriteLine(today.ToString(strv));        }    }}
"  // First file: Cycles.cs// Author: Paul Anton Chernoch using System; namespace DetectCycles{  
  
  
  public class Cycles<T> where T : IEquatable<T>  {    
    
    
    
    
    
    
    
    
    
    
    
    
    public static Tuple<int,int> FindCycle(T x0, Func<T,T> yielder)    {      int power, lambda;      T tortoise, hare;      power = lambda = 1;      tortoise = x0;      hare = yielder(x0);       // Find lambda, the cycle length      while (!tortoise.Equals (hare)) {        if (power == lambda) {          tortoise = hare;          power *= 2;          lambda = 0;          }        hare = yielder (hare);        lambda += 1;      }       // Find mu, the zero-based index of the start of the cycle      var mu = 0;      tortoise = hare = x0;      for (var times = 0; times < lambda; times++)         hare = yielder (hare);       while (!tortoise.Equals (hare))       {        tortoise = yielder (tortoise);        hare = yielder (hare);        mu += 1;      }       return  Tuple<int,int> (lambda, mu);    }  }} // Second file: Program.cs using System; namespace DetectCycles{	class MainClass	{		public static void Main (string[] args)		{			// A recurrence relation to use in testing			Func<int,int> sequence = (int _x) => (_x * _x + 1) % 255; 			// Display the first 41 numbers in the test series			var x = 3;			Console.Write(x);			for (var times = 0; times < 40; times++) 			{				x = sequence(x);				Console.Write(String.Format(strv, x));			}			Console.WriteLine(); 			// Test the FindCycle method			var cycle = Cycles<int>.FindCycle(3, sequence);			var clength = cycle.Item1;			var cstart = cycle.Item2;			Console.Write(String.Format(""Cycle length = {0}Start index = {1}"", clength, cstart));		}	}}  "
"using System;using System.Collections.Generic; namespace Currency{    class Program    {        static void Main(string[] args)        {            MenuItem hamburger =  MenuItem() { Name = strv, Price = 5.5M };            MenuItem milkshake =  MenuItem() { Name = strv, Price = 2.86M };             IList<CartItem> cart =  List<CartItem>();            cart.Add( CartItem() { item = hamburger, quantity = 4000000000000000 });            cart.Add( CartItem() { item = milkshake, quantity = 2 });             decimal total = CalculateTotal(cart);             Console.WriteLine(string.Format(strv, total));             // Add Tax            decimal tax = total * 0.0765M;             Console.WriteLine(string.Format(strv, tax));             total += tax;             Console.WriteLine(string.Format(strv, total));        }         private static decimal CalculateTotal(IList<CartItem> cart)        {            decimal total = 0M;             foreach (CartItem item in cart)            {                total += item.quantity * item.item.Price;            }             return total;        }         private struct MenuItem        {            public string Name { get; set; }            public decimal Price { get; set; }        }         private struct CartItem        {            public MenuItem item { get; set; }            public decimal quantity { get; set; }        }    }}"
public delegate int Plus(int y); public delegate Plus CurriedPlus(int x);public static CurriedPlus plus =       delegate(int x) {return delegate(int y) {return x + y;};};static void Main(){    int sum = plus(3)(4); // sum = 7    int sum2= plus(2)(plus(3)(4)) // sum2 = 9}
"using System;using System.Collections.Generic;using System.Linq; namespace standardDeviation{    class Program    {        static void Main(string[] args)        {            List<double> nums =  List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };            for (int i = 1; i <= nums.Count; i++)                            Console.WriteLine(sdev(nums.GetRange(0, i)));        }         static double sdev(List<double> nums)        {            List<double> store =  List<double>();            foreach (double n in nums)                store.Add((n - nums.Average()) * (n - nums.Average()));                        return Math.Sqrt(store.Sum() / store.Count);        }    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.IO; namespace CSV{    class CSV    {        private Dictionary<Tuple<int, int>, string> _data;        private int _rows;        private int _cols;         public int Rows { get { return _rows; } }        public int Cols { get { return _cols; } }         public CSV()        {            Clear();        }         public void Clear()        {            _rows = 0;            _cols = 0;            _data =  Dictionary<Tuple<int, int>, string>();        }         public void Open(StreamReader stream, char delim = ',')        {            string line;            int col = 0;            int row = 0;             Clear();             while ((line = stream.ReadLine()) != null)            {                if (line.Length > 0)                {                    string[] values = line.Split(delim);                    col = 0;                    foreach (var value in values)                    {                        this[col,row] = value;                        col++;                    }                    row++;                }            }            stream.Close();        }         public void Save(StreamWriter stream, char delim = ',')        {            for (int row = 0; row < _rows; row++)            {                for (int col = 0; col < _cols; col++)                {                    stream.Write(this[col, row]);                    if (col < _cols - 1)                    {                        stream.Write(delim);                    }                }                stream.WriteLine();            }            stream.Flush();            stream.Close();        }         public string this[int col, int row]        {            get            {                try                {                    return _data[ Tuple<int, int>(col, row)];                }                catch                {                    return strv;                }            }             set            {                _data[ Tuple<int, int>(col, row)] = value.ToString().Trim();                _rows = Math.Max(_rows, row + 1);                _cols = Math.Max(_cols, col + 1);            }        }         static void Main(string[] args)        {            CSV csv =  CSV();             csv.Open( StreamReader(@strv));            csv[0, 0] = strv;            csv[1, 1] = strv;            csv[2, 2] = strv;            csv[3, 3] = strv;            csv[4, 4] = strv;            csv.Save( StreamWriter(@strv));        }    }}"
" class Program    {        static void Main(string[] args)        {            Console.WriteLine(strv);            string s = Console.ReadLine();             int[,] myArray= int[(int)s[0],(int)s[2]];            myArray[0, 0] = 2;            Console.WriteLine(myArray[0, 0]);             Console.ReadLine();        }    }"
"     
    
    
    public class Crc32    {        #region Constants        
        
        
        private const UInt32 s_generator = 0xEDB88320;        #endregion         #region Constructors        
        
        
        public Crc32()        {            // Constructs the checksum lookup table. Used to optimize the checksum.            m_checksumTable = Enumerable.Range(0, 256).Select(i =>            {                var tableEntry = (uint)i;                for (var j = 0; j < 8; ++j)                {                    tableEntry = ((tableEntry & 1) != 0)                        ? (s_generator ^ (tableEntry >> 1))                         : (tableEntry >> 1);                }                return tableEntry;            }).ToArray();        }        #endregion         #region Methods        
        
        
        
        
        public UInt32 Get<T>(IEnumerable<T> byteStream)        {            try            {                // Initialize checksumRegister to 0xFFFFFFFF and calculate the checksum.                return ~byteStream.Aggregate(0xFFFFFFFF, (checksumRegister, currentByte) =>                           (m_checksumTable[(checksumRegister & 0xFF) ^ Convert.ToByte(currentByte)] ^ (checksumRegister >> 8)));            }            catch (FormatException e)            {                throw  CrcException(strv, e);            }            catch (InvalidCastException e)            {                throw  CrcException(strv, e);            }            catch (OverflowException e)            {                throw  CrcException(strv, e);            }        }        #endregion         #region Fields        
        
        
        private readonly UInt32[] m_checksumTable;         #endregion    } "
"     // Adapted from http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/    class Program    {        static long Count(int[] C, int m, int n)        {            var table =  long[n + 1];            table[0] = 1;            for (int i = 0; i < m; i++)                for (int j = C[i]; j <= n; j++)                    table[j] += table[j - C[i]];            return table[n];        }        static void Main(string[] args)        {            var C =  int[] { 1, 5, 10, 25 };            int m = C.Length;            int n = 100;            Console.WriteLine(Count(C, m, n));  //242            Console.ReadLine();        }    } "
using System;using System.IO; class Program {    static void Main(string[] args) {        File.Create(strv);        File.Create(@strv);         Directory.CreateDirectory(strv);        Directory.CreateDirectory(@strv);    }}
"using System;using System.Text; namespace prog{	class MainClass	{				public static void Main (string[] args)		{			StringBuilder s =  StringBuilder();			Random rnd =  Random(); 			s.AppendLine(strv);			s.AppendLine(""<thead align = right>"");			s.Append(strv);			for(int i=0; i<3; i++)				s.Append(strv + strv[i] + strv);			s.AppendLine(strv);			s.AppendLine(strv);			s.AppendLine(""<tbody align = right>"");			for( int i=0; i<3; i++ )			{				s.Append(strv+i+strv);				for( int j=0; j<3; j++ )					s.Append(strv+rnd.Next(10000)+strv);								s.AppendLine(strv);			}			s.AppendLine(strv);			s.AppendLine(strv); 			Console.WriteLine( s );		}	}}using System;using System.Text;using System.Xml; namespace N{	public class T	{		public static void Main()		{			var headers =  [] { strv, strv, strv, strv }; 			var cols = headers.Select(name =>				 XElement(					strv,					name,					 XAttribute(strv, strv)				)			); 			var rows = Enumerable.Range(0, 4).Select(ri =>				 XElement(					strv,					 XElement(strv, ri),					Enumerable.Range(0, 4).Select(ci =>						 XElement(							strv,							ci,							 XAttribute(strv, strv)						)					)				)			); 			var xml =  XElement(				strv, 				 XElement(					strv, 					 XElement(strv,    cols),					 XElement(strv, rows)				)			); 			Console.WriteLine(xml.ToString());		}	}} "
using System;using System.Collections.Generic; namespace prog{	class MainClass	{		public static void Main (string[] args)		{			for( int i=1; i<=22; i++ )			{								List<int> f = Factorize(i);				Console.Write( i + strv + f[0] );				for( int j=1; j<f.Count; j++ )				{					Console.Write( strv + f[j] );				}				Console.WriteLine();			}		} 		public static List<int> Factorize( int n )		{			List<int> l =  List<int>(); 			if ( n == 1 )			{				l.Add(1);			}			else			{				int k = 2;				while( n > 1 ) 				{					while( n % k == 0 )					{						l.Add( k );						n /= k;					}					k++;				}			}						return l;		}		}}
string src = strv;string dst = src;
"using System;using System.Collections.Generic; class Program{    static IEnumerable<int> r2cf(int n1, int n2)    {        while (Math.Abs(n2) > 0)        {            int t1 = n1 / n2;            int t2 = n2;            n2 = n1 - t1 * n2;            n1 = t2;            yield return t1;        }    }     static void spit(IEnumerable<int> f)    {        foreach (int n in f) Console.Write(strv, n);        Console.WriteLine();    }     static void Main(string[] args)    {        spit(r2cf(1, 2));        spit(r2cf(3, 1));        spit(r2cf(23, 8));        spit(r2cf(13, 11));        spit(r2cf(22, 7));        spit(r2cf(-151, 77));        for (int scale = 10; scale <= 10000000; scale *= 10)        {            spit(r2cf((int)(Math.Sqrt(2) * scale), scale));        }        spit(r2cf(31, 10));        spit(r2cf(314, 100));         spit(r2cf(3142, 1000));        spit(r2cf(31428, 10000));        spit(r2cf(314285, 100000));        spit(r2cf(3142857, 1000000));        spit(r2cf(31428571, 10000000));        spit(r2cf(314285714, 100000000));    }} "
"using System; class Program{    static void Main()    {        var number = 0;        do        {            Console.WriteLine(Convert.ToString(number, 8));        } while (++number > 0);    }}"
" using System;using System.Text;using System.Threading; namespace ConwaysGameOfLife{    // Plays Conway's Game of Life on the console with a random initial state.    class Program    {        // The delay in milliseconds between board updates.        private const int DELAY = 50;         // The cell colors.        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;         // The color of the cells that are off of the board.        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;         private const char EMPTY_BLOCK_CHAR = ' ';        private const char FULL_BLOCK_CHAR = '2588';         // Holds the current state of the board.        private static bool[,] board;         // The dimensions of the board in cells.        private static int width = 32;        private static int height = 32;         // True if cell rules can loop around edges.        private static bool loopEdges = true;          static void Main(string[] args)        {            // Use initializeRandomBoard for a larger, random board.            initializeDemoBoard();             initializeConsole();             // Run the game until the Escape key is pressed.            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {                Program.drawBoard();                Program.updateBoard();                 // Wait for a bit between updates.                Thread.Sleep(DELAY);            }        }         // Sets up the Console.        private static void initializeConsole()        {            Console.BackgroundColor = EXTRA_COLOR;            Console.Clear();             Console.CursorVisible = false;             // Each cell is two characters wide.            // Using an extra row on the bottom to prevent scrolling when drawing the board.            int width = Math.Max(Program.width, 8) * 2 + 1;            int height = Math.Max(Program.height, 8) + 1;            Console.SetWindowSize(width, height);            Console.SetBufferSize(width, height);             Console.BackgroundColor = DEAD_COLOR;            Console.ForegroundColor = LIVE_COLOR;        }         // Creates the initial board with a random state.        private static void initializeRandomBoard()        {            var random =  Random();             Program.board =  bool[Program.width, Program.height];            for (var y = 0; y < Program.height; y++) {                for (var x = 0; x < Program.width; x++) {                    // Equal probability of being true or false.                    Program.board[x, y] = random.Next(2) == 0;                }            }        }         // Creates a 3x3 board with a blinker.        private static void initializeDemoBoard()        {            Program.width = 3;            Program.height = 3;             Program.loopEdges = false;             Program.board =  bool[3, 3];            Program.board[1, 0] = true;            Program.board[1, 1] = true;            Program.board[1, 2] = true;        }         // Draws the board to the console.        private static void drawBoard()        {            // One Console.Write call is much faster than writing each cell individually.            var builder =  StringBuilder();             for (var y = 0; y < Program.height; y++) {                for (var x = 0; x < Program.width; x++) {                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;                     // Each cell is two characters wide.                    builder.Append(c);                    builder.Append(c);                }                builder.Append('');            }             // Write the string to the console.            Console.SetCursorPosition(0, 0);            Console.Write (builder.ToString());        }         // Moves the board to the next state based on Conway's rules.        private static void updateBoard()        {            // A temp variable to hold the next state while it's being calculated.            bool[,] newBoard =  bool[Program.width, Program.height];             for (var y = 0; y < Program.height; y++) {                for (var x = 0; x < Program.width; x++) {                    var n = countLiveNeighbors(x, y);                    var c = Program.board[x, y];                     // A live cell dies unless it has exactly 2 or 3 live neighbors.                    // A dead cell remains dead unless it has exactly 3 live neighbors.                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;                }            }             // Set the board to its new state.            Program.board = newBoard;        }         // Returns the number of live neighbors around the cell at position (x,y).        private static int countLiveNeighbors(int x, int y)        {            // The number of live neighbors.            int value = 0;             // This nested loop enumerates the 9 cells in the specified cells neighborhood.            for (var j = -1; j <= 1; j++) {                // If loopEdges is set to false and y+j is off the board, continue.                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {                    continue;                }                 // Loop around the edges if y+j is off the board.                int k = (y + j + Program.height) % Program.height;                 for (var i = -1; i <= 1; i++) {                    // If loopEdges is set to false and x+i is off the board, continue.                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {                        continue;                    }                     // Loop around the edges if x+i is off the board.                    int h = (x + i + Program.width) % Program.width;                     // Count the neighbor cell at (h,k) if it is alive.                    value += Program.board[h, k] ? 1 : 0;                }            }             // Subtract 1 if (x,y) is alive since we counted it as a neighbor.            return value - (Program.board[x, y] ? 1 : 0);        }    }}  "
"using System;using System.Collections.Generic;using System.Linq; namespace ConvertSecondsToCompoundDuration{  class Program  {    static void Main( string[] args )    {      foreach ( string arg in args )      {        int duration ;        bool isValid = int.TryParse( arg , out duration ) ;         if ( !isValid     ) { Console.Error.WriteLine( strv           , arg ) ; }        if ( duration < 0 ) { Console.Error.WriteLine( strv , arg ) ; }         Console.WriteLine();        Console.WriteLine( strv , duration , FormatAsDuration(duration) ) ;       }    }     private static string FormatAsDuration( int duration )    {      if ( duration < 0 ) throw  ArgumentOutOfRangeException(strv) ;      return string.Join( strv , GetDurationParts(duration)  ) ;    }     private static IEnumerable<string> GetDurationParts( int duration )    {      var parts = []      {         { Name=strv , Length = 7*24*60*60*1 , } ,         { Name=strv  , Length =   24*60*60*1 , } ,         { Name=strv  , Length =      60*60*1 , } ,         { Name=strv  , Length =         60*1 , } ,         { Name=strv  , Length =            1 , } ,      } ;       foreach ( var part in parts )      {        int n = Math.DivRem( duration , part.Length , out duration ) ;        if ( n > 0 ) yield return string.Format( strv , n , part.Name ) ;      }     }   } }private static string ConvertToCompoundDuration(int seconds){    if (seconds < 0) throw  ArgumentOutOfRangeException(nameof(seconds));    if (seconds == 0) return strv;     TimeSpan span = TimeSpan.FromSeconds(seconds);    int[] parts = {span.Days / 7, span.Days % 7, span.Hours, span.Minutes, span.Seconds};    string[] units = {strv, strv, strv, strv, strv};     return string.Join(strv,        from index in Enumerable.Range(0, units.Length)        where parts[index] > 0        select parts[index] + units[index]);}"
"using System;using System.Diagnostics;using System.Drawing; namespace RosettaConstrainedRandomCircle{    class Program    {        static void Main(string[] args)        {            var points =  Point[404];            int i = 0;            for (int y = -15; y <= 15; y++)                for (int x = -15; x <= 15 && i < 404; x++)                {                    var c = Math.Sqrt(x * x + y * y);                    if (10 <= c && c <= 15)                    {                        points[i++] =  Point(x, y);                    }                }             var bm =  Bitmap(600, 600);            var g = Graphics.FromImage(bm);            var brush =  SolidBrush(Color.Magenta);             var r =  System.Random();            for (int count = 0; count < 100; count++)            {                var p = points[r.Next(403)];                g.FillEllipse(brush,  Rectangle(290 + 19 * p.X, 290 + 19 * p.Y, 10, 10));            }            const string filename = strv;            bm.Save(filename);            Process.Start(filename);        }    }}"
"interface IEatable{    void Eat();}using System.Collections.Generic; class FoodBox<T> where T : IEatable{    List<T> food;}class Apple : IEatable{    public void Eat()    {        System.Console.WriteLine(strv);    }}using System..Generic class FoodMakingBox<T> where T : IEatable, (){    List<T> food;     void Make(int numberOfFood)    {        this.food =  List<T>();        for (int i = 0; i < numberOfFood; i++)        {            this.food.Add( T());        }    }}"
" static Random tRand =  Random(); static void Main(string[] args){	Thread t =  Thread( ParameterizedThreadStart(WriteText));	t.Start(strv); 	t =  Thread( ParameterizedThreadStart(WriteText));	t.Start(strv); 	t =  Thread( ParameterizedThreadStart(WriteText));	t.Start(strv); 	Console.ReadLine();} private static void WriteText(object p){	Thread.Sleep(tRand.Next(1000, 4000));	Console.WriteLine(p);} "
"struct Point{  public int x, y;  public Point(int x, int y) {    this.x = x;    this.y = y;  }}"
" static string[] inputs = {	strv,	strv,	""-in Aus$+1411.8millions"",	strv}; void Main(){	inputs.Select(s => Commatize(s, 0, 3, strv))              .ToList()              .ForEach(Console.WriteLine);} string Commatize(string text, int startPosition, int interval, string separator){	var matches = Regex.Matches(text.Substring(startPosition), strv);	var x = matches.Cast<Match>().Select(match => Commatize(match, interval, separator, text)).ToList();	return string.Join(strv, x);}  string Commatize(Match match, int interval, string separator, string original){	if (match.Length <= interval)		return original.Substring(match.Index,                 match.Index == original.Length ? 0 : Math.Max(match.Length, 1)); 	return string.Join(separator, match.Value.Split(interval));} public static class Extension{	public static string[] Split(this string source, int interval)	{		return SplitImpl(source, interval).ToArray();	} 	static IEnumerable<string>SplitImpl(string source, int interval)	{		for	(int i = 1; i < source.Length; i++)		{			if (i % interval != 0) continue; 			yield return source.Substring(i - interval, interval);		}	}} "
"public static bool[] CompareAListOfStrings(List<string> strings) {    return strings.Count < 2 ?  [] { true, true }        :  [] {            strings.Distinct().Count() < 2,            Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)    };}"
" using System;using System.IO;using System.Linq;using System.Collections.Generic;  namespace Rosetta {     public enum TokenType {        End_of_input, Op_multiply, Op_divide, Op_mod, Op_add, Op_subtract,        Op_negate, Op_not, Op_less, Op_lessequal, Op_greater, Op_greaterequal,        Op_equal, Op_notequal, Op_assign, Op_and, Op_or, Keyword_if,        Keyword_else, Keyword_while, Keyword_print, Keyword_putc, LeftParen, RightParen,        LeftBrace, RightBrace, Semicolon, Comma, Identifier, Integer, String, None    }     
    
    
    public class Token {        public TokenType Type { get; set; }        public int Line { get; set; }        public int Position { get; set; }        public string Value { get; set; }        public override string ToString() {            if (Type == TokenType.Integer || Type == TokenType.Identifier) {                return String.Format(strv, Line, Position, Type.ToString(), Value);            } else if (Type == TokenType.String) {                return String.Format(""{0,-5}  {1,-5}   {2,-14}     {3}"", Line, Position, Type.ToString(), Value.Replace("""", ""n""));            }            return String.Format(strv, Line, Position, Type.ToString());        }    }     
    
    
    public class LexicalScanner {         // character classes         private const string _letters = strv;                private const string _numbers = strv;        private const string _identifier = _letters + _numbers + strv;        private const string _whitespace = "" "";         // mappings from string keywords to token type         private Dictionary<string, TokenType> _keywordTokenTypeMap =  Dictionary<string, TokenType>() {            { strv, TokenType.Keyword_if },            { strv, TokenType.Keyword_else },            { strv, TokenType.Keyword_while },            { strv, TokenType.Keyword_print },            { strv, TokenType.Keyword_putc }        };         // mappings from simple operators to token type        private Dictionary<string, TokenType> _operatorTokenTypeMap =  Dictionary<string, TokenType>() {            { strv, TokenType.Op_add },            { strv, TokenType.Op_subtract },            { strv, TokenType.Op_multiply },            { strv, TokenType.Op_divide },            { strv, TokenType.Op_mod },            { strv, TokenType.Op_assign },            { strv, TokenType.Op_less },            { strv, TokenType.Op_greater },            { strv, TokenType.Op_not },        };         private List<string> _keywords;        private string _operators = strv;         private string _code;        private List<Token> tokens =  List<Token>();         private int _line = 1;        private int _position = 1;         public string CurrentCharacter {            get {                try {                    return _code.Substring(0, 1);                } catch (ArgumentOutOfRangeException) {                    return strv;                }            }        }         
        
        
        
        public LexicalScanner (string code) {            _code = code;            _keywords = _keywordTokenTypeMap.Keys.ToList();        }         
        
        
        
        private void advance(int characters=1) {            try {                // reset position when there is a newline                if (CurrentCharacter == """") {                    _position = 0;                    _line++;                }                 _code = _code.Substring(characters, _code.Length - characters);                _position += characters;            } catch (ArgumentOutOfRangeException) {                _code = strv;            }        }         
        
        
        
        
        
        public void error(string message, int line, int position) {            // output error to the console and exit            Console.WriteLine(String.Format(strv, message, line, position));            Environment.Exit(1);        }         
        
        
        
        
        
        
        
        
        
        
        
        
        
        public bool match(string recogniseClass, string matchClass, TokenType tokenType,                           string notNextClass=null, int maxLen=Int32.MaxValue, bool exact=false,                           bool discard=false, int offset=0) {             // if we've hit the end of the file, there's no more matching to be done            if (CurrentCharacter == strv)                return false;             // store _current_ line and position so that our vectors point at the start            // of each token            int line = _line;            int position = _position;             // special case exact tokens to avoid needing to worry about backtracking            if (exact) {                if (_code.StartsWith(recogniseClass)) {                    if (!discard)                         tokens.Add( Token() { Type = tokenType, Value = recogniseClass, Line = line, Position = position - offset});                       advance(recogniseClass.Length);                    return true;                }                return false;            }             // first match - denotes the token type usually            if (!recogniseClass.Contains(CurrentCharacter))                return false;             string tokenValue = CurrentCharacter;            advance();             // follow match while we haven't exceeded maxLen and there are still characters            // in the code stream            while ((matchClass ?? strv).Contains(CurrentCharacter) && tokenValue.Length <= maxLen && CurrentCharacter != strv) {                tokenValue += CurrentCharacter;                advance();            }             // ensure that any incompatible characters are not next to the token            // eg 42fred is invalid, and neither recognized as a number nor an identifier.            // _letters would be the notNextClass            if (notNextClass != null && notNextClass.Contains(CurrentCharacter))                error(strv + CurrentCharacter, _line, _position);             // only add tokens to the stack that aren't marked as discard - dont want            // things like open and close quotes/comments            if (!discard) {                Token token =  Token() { Type = tokenType, Value = tokenValue, Line = line, Position = position - offset };                tokens.Add(token);            }             return true;        }         
        
        
        
        public List<Token> scan() {             while (CurrentCharacter != strv) {                // match whitespace                match(_whitespace, _whitespace, TokenType.None, discard: true);                 // match integers                match(_numbers, _numbers, TokenType.Integer, notNextClass:_letters);                 // match identifiers and keywords                if (match(_letters, _identifier, TokenType.Identifier)) {                    Token match = tokens.Last();                    if (_keywords.Contains(match.Value))                        match.Type = _keywordTokenTypeMap[match.Value];                }                 // match string similarly to comments without allowing newlines                // this token doesn't get discarded though                if (match("""", null, TokenType.String, discard:true)) {                    string value = strv;                    int position = _position;                    while (!match("""", null, TokenType.String, discard:true)) {                        // not allowed newlines in strings                        if (CurrentCharacter == """")                            error(strv, _line, _position);                        // end of file reached before finding end of string                        if (CurrentCharacter == strv)                            error(strv, _line, _position);                         value += CurrentCharacter;                         // deal with escape sequences - we only accept newline (\n)                        if (value.Length >= 2) {                            string lastCharacters = value.Substring(value.Length - 2, 2);                            if (lastCharacters[0] == '') {                                if (lastCharacters[1] != 'n') {                                    error(strv, _line, position);                                }                                value = value.Substring(0, value.Length - 2).ToString() + """";                            }                        }                         advance();                    }                    tokens.Add( Token() { Type = TokenType.String, Value = value, Line = _line, Position = position - 1});                }                 // match string literals                if (match(strv, null, TokenType.Integer, discard:true)) {                    int value;                    int position = _position;                    value = CurrentCharacter.ToCharArray()[0];                    advance();                     // deal with empty literals ''                    if (value == '')                        error(strv, _line, _position);                     // deal with escaped characters, only need to worry about \n and \\                    // throw werror on any other                    if (value == '') {                        if (CurrentCharacter == strv) {                            value = '';                        } else if (CurrentCharacter == """") {                            value = '';                        } else {                            error(strv, _line, _position - 1);                        }                        advance();                    }                     // if we haven't hit a closing ' here, there are two many characters                    // in the literal                    if (!match(strv, null, TokenType.Integer, discard: true))                        error(strv, _line, _position);                     tokens.Add( Rosetta.Token() { Type = TokenType.Integer, Value = value.ToString(), Line = _line, Position = position - 1 });                }                 // match comments by checking for starting token, then advancing                 // until closing token is matched                if (match(strv, null, TokenType.None, exact: true, discard: true)) {                    while (!match(strv, null, TokenType.None, exact: true, discard: true)) {                        // reached the end of the file without closing comment!                        if (CurrentCharacter == strv)                            error(strv, _line, _position);                        advance();                    }                    continue;                }                 // match complex operators                match(strv, null, TokenType.Op_lessequal, exact: true);                match(strv, null, TokenType.Op_greaterequal, exact: true);                match(strv, null, TokenType.Op_equal, exact: true);                match(strv, null, TokenType.Op_notequal, exact: true);                match(strv, null, TokenType.Op_and, exact: true);                match(strv, null, TokenType.Op_or, exact: true);                 // match simple operators                if (match(_operators, null, TokenType.None, maxLen:1)) {                    Token match = tokens.Last();                    match.Type = _operatorTokenTypeMap[match.Value];                }                 // brackets, braces and separators                match(strv, null, TokenType.LeftParen, exact: true);                match(strv, null, TokenType.RightParen, exact: true);                match(strv, null, TokenType.LeftBrace, exact: true);                match(strv, null, TokenType.RightBrace, exact: true);                match(strv, null, TokenType.Semicolon, exact: true);                match(strv, null, TokenType.Comma, exact: true);             }             // end of file token            tokens.Add( Rosetta.Token() { Type = TokenType.End_of_input, Line = _line, Position = _position });             return tokens;        }         static void Main (string[] args) {            StreamReader inputFile;             // if we passed in a filename, read code from that, else            // read code from stdin            if (args.Length > 0) {                string path = args[0];                try {                    inputFile =  StreamReader(path);                } catch (IOException) {                    inputFile =  StreamReader(Console.OpenStandardInput(8192));                }            } else {                inputFile =  StreamReader(Console.OpenStandardInput(8192));            }             string code = inputFile.ReadToEnd();             // strip windows line endings out            code = code.Replace("""", strv);             LexicalScanner scanner =  LexicalScanner(code);            List<Token> tokens = scanner.scan();             foreach(Token token in tokens) {                Console.WriteLine(token.ToString());            }               }    }} "
"//This is a comment.//This is other comment. /* This is a comment too. */ /* This is a 
multi-line
comment */"
"if (condition){   // Some Task} if (condition){  // Some Task}else if (condition2){  // Some Task}else{  // Some Task}// if condition is true var will be set to 1, else 2.int var = condition ? 1 : 2;switch (value){   case 1:          // Some task          break;  // Breaks are required in C#.   case 2:   case 3:         // Some task         break;   default: // If no other case is matched.         // Some task         break;}switch (value){   case 1:          // Some task          goto case 2; // will cause the code indicated in case 2 to be executed.   case 2:          // Some task          break;   case 3:         // Some task         break;   default: // If no other case is matched.         // Some task         break;}"
"using System; namespace RosettaCode {    class Program {        static void Main(string[] args) {            for (int i = 0; i < args.Length; i++)                Console.WriteLine(String.Format(strv, i, args[i]));        }    }}using System; namespace RosettaCode {    class Program {        static void Main() {            string[] args = Environment.GetCommandLineArgs();            for (int i = 0; i < args.Length; i++)                Console.WriteLine(String.Format(strv, i, args[i]));        }    }}"
" using System;using System.Collections.Generic;using System.Linq; public static class MultiCombinations{    private static void Main()    {        var set =  List<string> { strv, strv, strv };        var combinations = GenerateCombinations(set, 2);         foreach (var combination in combinations)        {            string combinationStr = string.Join(strv, combination);            Console.WriteLine(combinationStr);        }         var donuts = Enumerable.Range(1, 10).ToList();         int donutsCombinationsNumber = GenerateCombinations(donuts, 3).Count;         Console.WriteLine(strv, donutsCombinationsNumber);    }     private static List<List<T>> GenerateCombinations<T>(List<T> combinationList, int k)    {        var combinations =  List<List<T>>();         if (k == 0)        {            var emptyCombination =  List<T>();            combinations.Add(emptyCombination);             return combinations;        }         if (combinationList.Count == 0)        {            return combinations;        }         T head = combinationList[0];        var copiedCombinationList =  List<T>(combinationList);         List<List<T>> subcombinations = GenerateCombinations(copiedCombinationList, k - 1);         foreach (var subcombination in subcombinations)        {            subcombination.Insert(0, head);            combinations.Add(subcombination);        }         combinationList.RemoveAt(0);        combinations.AddRange(GenerateCombinations(combinationList, k));         return combinations;    }} "
"using System;using System.Linq; namespace CommaQuibbling{    internal static class Program    {        #region Static Members	private static string Quibble(string[] input)	{            return                String.Format(strv,                    String.Join(strv,                        input.Reverse().Zip(                             [] { strv, strv }.Concat(Enumerable.Repeat(strv, int.MaxValue)),                            (x, y) => x + y).Reverse()));	}          private static void Main()        {            Console.WriteLine( Quibble(  string[] {} ) );            Console.WriteLine( Quibble( [] {strv} ) );            Console.WriteLine( Quibble( [] {strv, strv} ) );            Console.WriteLine( Quibble( [] {strv, strv, strv, strv} ) );             Console.WriteLine( strv );            Console.ReadKey();        }         #endregion    }}"
"using System;using System.Collections.Generic; public class Program{    public static IEnumerable<int[]> Combinations(int m, int n)    {            int[] result =  int[m];            Stack<int> stack =  Stack<int>();            stack.Push(0);             while (stack.Count > 0)           {                int index = stack.Count - 1;                int value = stack.Pop();                 while (value < n)                {                    result[index++] = ++value;                    stack.Push(value);                     if (index == m)                     {                        yield return result;                        break;                    }                }            }    }     static void Main()    {        foreach (int[] c in Combinations(3, 5))        {            Console.WriteLine(string.Join(strv, c));            Console.WriteLine();        }    }} using System;using System.Collections.Generic; public class Program{  public static IEnumerable<int[]> FindCombosRec(int[] buffer, int done, int begin, int end)  {    for (int i = begin; i < end; i++)    {      buffer[done] = i;       if (done == buffer.Length - 1)        yield return buffer;      else        foreach (int[] child in FindCombosRec(buffer, done+1, i+1, end))          yield return child;    }  }   public static IEnumerable<int[]> FindCombinations(int m, int n)  {    return FindCombosRec( int[m], 0, 0, n);  }   static void Main()  {    foreach (int[] c in FindCombinations(3, 5))    {      for (int i = 0; i < c.Length; i++)      {        Console.Write(c[i] + strv);      }      Console.WriteLine();    }  }} "
"using System;using System.Drawing;using System.Windows.Forms; class Program{    static Color GetPixel(Point position)    {        using (var bitmap =  Bitmap(1, 1))        {            using (var graphics = Graphics.FromImage(bitmap))            {                graphics.CopyFromScreen(position,  Point(0, 0),  Size(1, 1));            }            return bitmap.GetPixel(0, 0);        }    }     static void Main()    {        Console.WriteLine(GetPixel(Cursor.Position));    }}"
"using System;using System.Linq; class Program{    static void Main()    {        var captor = (Func<int, Func<int>>)(number => () => number * number);        var functions = Enumerable.Range(0, 10).Select(captor);        foreach (var function in functions.Take(9))        {            Console.WriteLine(function());        }    }} using System;using System.Collections.Generic; class Program{    static void Main( string[] args )    {        List<Func<int>> l =  List<Func<int>>();        for ( int i = 0; i < 10; ++i )        {            // This is key to avoiding the closure trap, because            // the anonymous delegate captures a reference to             // outer variables, not their value.  So we create 10            // variables, and each created anonymous delegate             // has references to that variable, not the loop variable            var captured_val = i;            l.Add( delegate() { return captured_val * captured_val; } );        }         l.ForEach( delegate( Func<int> f ) { Console.WriteLine( f() ); } );    }} "
" // Creates and initializes a new integer Arrayint[] intArray =  int[5] { 1, 2, 3, 4, 5 };//same asint[] intArray =  int[]{ 1, 2, 3, 4, 5 };//same asint[] intArray = { 1, 2, 3, 4, 5 }; //Arrays are zero-basedstring[] stringArr =  string[5];stringArr[0] = strv;  //Create and initialize ArrayListArrayList myAl =  ArrayList { strv, strv, strv }; //Create ArrayList and add some valuesArrayList myAL =  ArrayList();      myAL.Add(strv);      myAL.Add(strv);      myAL.Add(strv);   //Create and initialize ListList<string> myList =  List<string> { strv, strv, strv }; //Create List and add some valuesList<string> myList2 =  List<string>();            myList2.Add(strv);            myList2.Add(strv);            myList2.Add(strv);  //Create an initialize HashtableHashtable myHt =  Hashtable() { { strv, strv }, { strv, strv } }; //Create Hashtable and add some Key-Value pairs.Hashtable myHt2 =  Hashtable();	myHt2.Add(strv, strv);	myHt2.Add(strv, strv);  //Create an initialize DictionaryDictionary<string, string> dict =  Dictionary<string, string>() { { strv, strv }, { strv, strv } };//Create Dictionary and add some Key-Value pairs.Dictionary<string, string> dict2 =  Dictionary<string, string>();	dict2.Add(strv, strv);	dict2.Add(strv, strv); "
"class Segment{    public Segment(PointF p1, PointF p2)    {        P1 = p1;        P2 = p2;    }     public readonly PointF P1;    public readonly PointF P2;     public float Length()    {        return (float)Math.Sqrt(LengthSquared());    }     public float LengthSquared()    {        return (P1.X - P2.X) * (P1.X - P2.X)            + (P1.Y - P2.Y) * (P1.Y - P2.Y);    }}Segment Closest_BruteForce(List<PointF> points){    int n = points.Count;    var result = Enumerable.Range( 0, n-1)        .SelectMany( i => Enumerable.Range( i+1, n-(i+1) )            .Select( j =>  Segment( points[i], points[j] )))            .OrderBy( seg => seg.LengthSquared())            .First();     return result;} public static Segment MyClosestDivide(List<PointF> points){   return MyClosestRec(points.OrderBy(p => p.X).ToList());} private static Segment MyClosestRec(List<PointF> pointsByX){   int count = pointsByX.Count;   if (count <= 4)      return Closest_BruteForce(pointsByX);    // left and right lists sorted by X, as order retained from full list   var leftByX = pointsByX.Take(count/2).ToList();   var leftResult = MyClosestRec(leftByX);    var rightByX = pointsByX.Skip(count/2).ToList();   var rightResult = MyClosestRec(rightByX);    var result = rightResult.Length() < leftResult.Length() ? rightResult : leftResult;    // There may be a shorter distance that crosses the divider   // Thus, extract all the points within result.Length either side   var midX = leftByX.Last().X;   var bandWidth = result.Length();   var inBandByX = pointsByX.Where(p => Math.Abs(midX - p.X) <= bandWidth);    // Sort by Y, so we can efficiently check for closer pairs   var inBandByY = inBandByX.OrderBy(p => p.Y).ToArray();    int iLast = inBandByY.Length - 1;   for (int i = 0; i < iLast; i++ )   {      var pLower = inBandByY[i];       for (int j = i + 1; j <= iLast; j++)      {         var pUpper = inBandByY[j];          // Comparing each point to successivly increasing Y values         // Thus, can terminate as soon as deltaY is greater than best result         if ((pUpper.Y - pLower.Y) >= result.Length())            break;          if (Segment.Length(pLower, pUpper) < result.Length())            result =  Segment(pLower, pUpper);      }   }    return result;} var randomizer =  Random(10);var points = Enumerable.Range( 0, 10000).Select( i =>  PointF( (float)randomizer.NextDouble(), (float)randomizer.NextDouble())).ToList();Stopwatch sw = Stopwatch.StartNew();var r1 = Closest_BruteForce(points);sw.Stop();Debugger.Log(1, strv, string.Format(strv, sw.Elapsed.TotalMilliseconds));Stopwatch sw2 = Stopwatch.StartNew();var result2 = Closest_Recursive(points);sw2.Stop();Debugger.Log(1, strv, string.Format(strv,sw2.Elapsed.TotalMilliseconds));Assert.Equal(r1.Length(), result2.Length());         Segment Closest_BruteForce(List<PointF> points)        {            Trace.Assert(points.Count >= 2);             int count = points.Count;             // Seed the result - doesn't matter what points are used            // This just avoids having to do null checks in the main loop below            var result =  Segment(points[0], points[1]);            var bestLength = result.Length();             for (int i = 0; i < count; i++)                for (int j = i + 1; j < count; j++)                    if (Segment.Length(points[i], points[j]) < bestLength)                    {                        result =  Segment(points[i], points[j]);                        bestLength = result.Length();                    }             return result;        }         Segment Closest(List<PointF> points)        {            Trace.Assert(points.Count >= 2);             int count = points.Count;            points.Sort((lhs, rhs) => lhs.X.CompareTo(rhs.X));             var result =  Segment(points[0], points[1]);            var bestLength = result.Length();             for (int i = 0; i < count; i++)            {                var from = points[i];                 for (int j = i + 1; j < count; j++)                {                    var to = points[j];                     var dx = to.X - from.X;                    if (dx >= bestLength)                    {                        break;                    }                     if (Segment.Length(from, to) < bestLength)                    {                        result =  Segment(from, to);                        bestLength = result.Length();                    }                }            }             return result;        } "
"using System;public class CirclesOfGivenRadiusThroughTwoPoints{    public static void Main()    {        double[][] values =  double[][] {             [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },             [] { 0.0,       2.0,    0.0,    0.0,   1 },             [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },             [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },             [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }        };         foreach (var a in values) {            var p =  Point(a[0], a[1]);            var q =  Point(a[2], a[3]);            Console.WriteLine($strv);            try {                var centers = FindCircles(p, q, a[4]);                Console.WriteLine("""" + string.Join(strv, centers));            } catch (Exception ex) {                Console.WriteLine("""" + ex.Message);            }        }    }     static Point[] FindCircles(Point p, Point q, double radius) {        if(radius < 0) throw  ArgumentException(strv);        if(radius == 0) {            if(p == q) return  [] { p };            else throw  InvalidOperationException(strv);        }        if (p == q) throw  InvalidOperationException(strv);         double sqDistance = Point.SquaredDistance(p, q);        double sqDiameter = 4 * radius * radius;        if (sqDistance > sqDiameter) throw  InvalidOperationException(strv);         Point midPoint =  Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);        if (sqDistance == sqDiameter) return  [] { midPoint };         double d = Math.Sqrt(radius * radius - sqDistance / 4);        double distance = Math.Sqrt(sqDistance);        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;        return  [] {             Point(midPoint.X - oy, midPoint.Y + ox),             Point(midPoint.X + oy, midPoint.Y - ox)        };    }     public struct Point    {        public Point(double x, double y) : this() {            X = x;            Y = y;        }         public double X { get; }        public double Y { get; }         public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;         public static double SquaredDistance(Point p, Point q) {            double dx = q.X - p.X, dy = q.Y - p.Y;            return dx * dx + dy * dy;        }         public override string ToString() => $strv;     }	}"
public class MyClass{    public MyClass()    {    }    public void SomeMethod()    {    }    private int _variable;    public int Variable    {        get { return _variable; }        set { _variable = value; }    }    public static void Main()    {        // instantiate it        MyClass instance =  MyClass();        // invoke the method        instance.SomeMethod();        // set the variable        instance.Variable = 99;        // get the variable        System.Console.WriteLine( strv + instance.Variable.ToString() );    }}
using System.IO; Console.WriteLine(File.Exists(strv));Console.WriteLine(File.Exists(strv));Console.WriteLine(Directory.Exists(strv));Console.WriteLine(Directory.Exists(strv));
"using System.Diagnostics;using System.Drawing; namespace RosettaChaosGame{    class Program    {        static void Main(string[] args)        {            var bm =  Bitmap(600, 600);             var referencePoints =  Point[] {                 Point(0, 600),                 Point(600, 600),                 Point(300, 81)            };            var r =  System.Random();            var p =  Point(r.Next(600), r.Next(600));            for (int count = 0; count < 10000; count++)            {                bm.SetPixel(p.X, p.Y, Color.Magenta);                int i = r.Next(3);                p.X = (p.X + referencePoints[i].X) / 2;                p.Y = (p.Y + referencePoints[i].Y) / 2;            }            const string filename = strv;            bm.Save(filename);            Process.Start(filename);        }    }}"
using System; namespace RosettaCode.CharacterCode{    class Program    {        static void Main(string[] args)        {            Console.WriteLine((int) 'a');   //Prints strv            Console.WriteLine((char) 97);   //Prints strv        }    }}
"var nums = Enumerable.Range(1, 10); int summation = nums.Aggregate((a, b) => a + b); int product = nums.Aggregate((a, b) => a * b); string concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString()); Console.WriteLine(strv, summation, product, concatenation);"
" int n = 15;List<int> t =  List<int>() { 0, 1 };for (int i = 1; i <= n; i++){    for (var j = i; j > 1; j--) t[j] += t[j - 1];    t.Add(t[i]);    for (var j = i + 1; j > 1; j--) t[j] += t[j - 1];    Console.Write(((i == 1) ? strv : strv) + (t[i + 1] - t[i]));} "
"namespace CatalanNumbers{    
    
    
    public class CatalanNumberGenerator    {        private static double Factorial(double n)        {            if (n == 0)                return 1;             return n * Factorial(n - 1);        }         public double FirstOption(double n)        {            const double topMultiplier = 2;            return Factorial(topMultiplier * n) / (Factorial(n + 1) * Factorial(n));        }         public double SecondOption(double n)        {            if (n == 0)            {                return 1;            }            double sum = 0;            double i = 0;            for (; i <= (n - 1); i++)            {                sum += SecondOption(i) * SecondOption((n - 1) - i);            }            return sum;        }         public double ThirdOption(double n)        {            if (n == 0)            {                return 1;            }            return ((2 * (2 * n - 1)) / (n + 1)) * ThirdOption(n - 1);        }    }}  // Program.csusing System;using System.Configuration; // Main program// Be sure to add the following to the App.config file and add a reference to System.Configuration:// <?xml version=strv ?>// <configuration>//  <appSettings>//    <clear/>//    <add key=strv/>//  </appSettings>// </configuration>namespace CatalanNumbers{    class Program    {        static void Main(string[] args)        {            CatalanNumberGenerator generator =  CatalanNumberGenerator();            int i = 0;            DateTime initial;            DateTime final;            TimeSpan ts;             try            {                initial = DateTime.Now;                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[strv]); i++)                {                    Console.WriteLine(strv, i, generator.FirstOption(i));                }                final = DateTime.Now;                ts = final - initial;                Console.WriteLine(""It took {0}.{1} to execute"", ts.Seconds, ts.Milliseconds);                 i = 0;                initial = DateTime.Now;                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[strv]); i++)                {                    Console.WriteLine(strv, i, generator.SecondOption(i));                }                final = DateTime.Now;                ts = final - initial;                Console.WriteLine(""It took {0}.{1} to execute"", ts.Seconds, ts.Milliseconds);                    i = 0;                initial = DateTime.Now;                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[strv]); i++)                {                    Console.WriteLine(strv, i, generator.ThirdOption(i));                }                final = DateTime.Now;                ts = final - initial;                Console.WriteLine(strv, ts.Seconds, ts.Milliseconds, ts.TotalMilliseconds);                Console.ReadLine();            }            catch (Exception ex)            {                Console.WriteLine(strv, i);                Console.WriteLine(ex.Message);                Console.ReadLine();            }        }    }}"
using System.Runtime.InteropServices; class Program {    [DllImport(strv)]    public static extern int fakefunction(int args);     static void Main(string[] args) {        int r = fakefunction(10);    }}
// StaticMyClass.Method(someParameter); // InstancemyInstance.Method(someParameter);
" using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace BullsAndCows{    class Program    {        const int ANSWER_SIZE = 4;         static IEnumerable<string> Permutations(int size)        {            if (size > 0)            {                foreach (string s in Permutations(size - 1))                    foreach (char n in strv)                        if (!s.Contains(n))                            yield return s + n;            }            else                yield return strv;        }         static IEnumerable<T> Shuffle<T>(IEnumerable<T> source)        {            Random random =  Random();            List<T> list = source.ToList();            while (list.Count > 0)            {                int ix = random.Next(list.Count);                yield return list[ix];                list.RemoveAt(ix);            }        }         static bool ReadBullsCows(out int bulls, out int cows)        {            string[] input = Console.ReadLine().Split(',').ToArray();            bulls = cows = 0;            if (input.Length < 2)                return false;            else                return int.TryParse(input[0], out bulls)                    && int.TryParse(input[1], out cows);        }         static void Main(string[] args)        {            Console.WriteLine(strv);            Console.WriteLine(strv);            Console.WriteLine();            List<string> answers = Shuffle(Permutations(ANSWER_SIZE)).ToList();            while (answers.Count > 1)            {                string guess = answers[0];                Console.Write(strv, guess);                int bulls, cows;                if (!ReadBullsCows(out bulls, out cows))                    Console.WriteLine(strv);                else                    for (int ans = answers.Count - 1; ans >= 0; ans--)                    {                        int tb = 0, tc = 0;                        for (int ix = 0; ix < ANSWER_SIZE; ix++)                            if (answers[ans][ix] == guess[ix])                                tb++;                            else if (answers[ans].Contains(guess[ix]))                                tc++;                        if ((tb != bulls) || (tc != cows))                            answers.RemoveAt(ans);                    }            }            if (answers.Count == 1)                Console.WriteLine(strv, answers[0]);            else                Console.WriteLine(strv);        }    }} "
"  using System;using System.Collections.Generic; using System.Linq;using System.Text; namespace CalendarStuff{     class Program    {        static void Main(string[] args)        {            Console.WindowHeight = 46;            Console.Write(buildMonths( DateTime(1969, 1, 1)));            Console.Read();         }        private static string buildMonths(DateTime date)        {            StringBuilder sb =  StringBuilder();            sb.AppendLine(center(strv, 24 * 3));            sb.AppendLine();            sb.AppendLine(center(date.Year.ToString(), 24 * 3));             List<DateTime> dts =  List<DateTime>();            while (true)            {                dts.Add(date);                if (date.Year != ((date = date.AddMonths(1)).Year))                {                    break;                }            }            var jd = dts.Select(a => buildMonth(a).GetEnumerator()).ToArray();             int sCur=0;            while (sCur<dts.Count)            {                sb.AppendLine();                int curMonth=0;                 var j = jd.Where(a => curMonth++ >= sCur && curMonth - 1 < sCur + 3).ToArray(); //grab the next 3                sCur += j.Length;                 bool breakOut = false;                while (!breakOut)                {                    int inj = 1;                    foreach (var cd in j)                    {                        if (cd.MoveNext())                        {                            sb.Append((cd.Current.Length == 21 ? cd.Current : cd.Current.PadRight(21, ' ')) + strv);                        }                        else                        {                            sb.Append(strv.PadRight(21, ' ') + strv);                            breakOut = true;                        }                        if (inj++ % 3 == 0) sb.AppendLine();                    }                }             }            return sb.ToString();        }          private static IEnumerable<string> buildMonth(DateTime date)        {            yield return center(date.ToString(strv),7*3);            var j = DateTime.DaysInMonth(date.Year, date.Month);            yield return Enum.GetNames((DayOfWeek)).Aggregate(strv, (current, result) => current + (result.Substring(0, 2).ToUpper() + strv));            string cur = strv;            int total = 0;             foreach (var day in Enumerable.Range(-((int)date.DayOfWeek),j + (int)date.DayOfWeek))            {                cur += (day < 0 ? strv : ((day < 9 ? strv : strv) + (day + 1))) +strv;                if (total++ > 0 && (total ) % 7 == 0)                {                    yield return cur;                    cur = strv;                }            }            yield return cur;        }        private static string center(string s, int len)        {            return (s.PadLeft((len - s.Length) / 2 + s.Length, ' ').PadRight((len), ' '));        }     }}  "
"using System;using System.Reflection; public class MyClass{    private int answer = 42;} public class Program{    public static void Main()    {        var myInstance =  MyClass();        var fieldInfo = (MyClass).GetField(strv, BindingFlags.NonPublic | BindingFlags.Instance);        var answer = fieldInfo.GetValue(myInstance);        Console.WriteLine(answer);    }}"
"using System;using System.Drawing; namespace BrownianTree{    class Program    {        static Bitmap BrownianTree(int size, int numparticles)        {            Bitmap bmp =  Bitmap(size, size);            Rectangle bounds =  Rectangle { X = 0, Y = 0, Size = bmp.Size };            using (Graphics g = Graphics.FromImage(bmp))            {                g.Clear(Color.Black);            }            Random rnd =  Random();            bmp.SetPixel(rnd.Next(size), rnd.Next(size), Color.White);            Point pt =  Point(), newpt =  Point();            for (int i = 0; i < numparticles; i++)            {                pt.X = rnd.Next(size);                pt.Y = rnd.Next(size);                do                {                    newpt.X = pt.X + rnd.Next(-1, 2);                    newpt.Y = pt.Y + rnd.Next(-1, 2);                    if (!bounds.Contains(newpt))                    {                        pt.X = rnd.Next(size);                        pt.Y = rnd.Next(size);                    }                    else if (bmp.GetPixel(newpt.X, newpt.Y).R > 0)                    {                        bmp.SetPixel(pt.X, pt.Y, Color.White);                        break;                    }                    else                    {                        pt = newpt;                    }                } while (true);            }            return bmp;        }         static void Main(string[] args)        {            BrownianTree(300, 3000).Save(strv);        }    }}"
"using System; namespace BullsnCows{    class Program    {         static void Main(string[] args)        {            int[] nums =  int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };            KnuthShuffle<int>(ref nums);            int[] chosenNum =  int[4];            Array.Copy(nums, chosenNum, 4);             Console.WriteLine(strv);            while (!game(Console.ReadLine(), chosenNum))            {                Console.WriteLine(strv);            }             Console.ReadKey();        }         public static void KnuthShuffle<T>(ref T[] array)        {            System.Random random =  System.Random();            for (int i = 0; i < array.Length; i++)            {                int j = random.Next(array.Length);                T temp = array[i]; array[i] = array[j]; array[j] = temp;            }        }         public static bool game(string guess, int[] num)        {            char[] guessed = guess.ToCharArray();            int bullsCount = 0, cowsCount = 0;             if (guessed.Length != 4)            {                Console.WriteLine(strv);                return false;            }             for (int i = 0; i < 4; i++)            {                int curguess = (int) char.GetNumericValue(guessed[i]);                if (curguess < 1 || curguess > 9)                {                    Console.WriteLine(strv);                    return false;                }                if (curguess == num[i])                {                    bullsCount++;                }                else                {                    for (int j = 0; j < 4; j++)                    {                        if (curguess == num[j])                            cowsCount++;                    }                }            }             if (bullsCount == 4)            {                Console.WriteLine(strv);                return true;            }            else            {                Console.WriteLine(strv, bullsCount, cowsCount);                return false;            }        }    }} "
"using System;using System.Linq; namespace CaesarCypher{    class Program    {        static char Encrypt(char ch, int code)        {            if (!char.IsLetter(ch)) return ch;             char offset = char.IsUpper(ch) ? 'A' : 'a';            return (char)((ch + code - offset) % 26 + offset);        }         static string Encrypt(string input, int code)        {            return  string(input.Select(ch => Encrypt(ch, code)).ToArray());        }         static string Decrypt(string input, int code)        {            return Encrypt(input, 26 - code);        }         const string TestCase = strv;         static void Main()        {            string str = TestCase;             Console.WriteLine(str);            str = Encrypt(str, 5);            Console.WriteLine(strv + str);            str = Decrypt(str, 5);            Console.WriteLine(strv + str);            Console.ReadKey();        }    }}"
"using System;using System.IO; public class BitReader{    uint readData = 0;    int startPosition = 0;    int endPosition = 0;     public int InBuffer    {        get { return endPosition - startPosition; }    }     private Stream stream;     public Stream BaseStream    {        get { return stream; }    }     public BitReader(Stream stream)    {        this.stream = stream;    }     void EnsureData(int bitCount)    {        int readBits = bitCount - InBuffer;        while (readBits > 0)        {            int b = BaseStream.ReadByte();             if (b < 0) throw  InvalidOperationException(strv);             readData |= ((uint)b << endPosition);            endPosition += 8;            readBits -= 8;        }    }     public bool ReadBit()    {        return Read(1) > 0;    }     public int Read(int bitCount)    {        EnsureData(bitCount);         int result = (int)(readData >> startPosition) & ((1 << bitCount) - 1);        startPosition += bitCount;        if (endPosition == startPosition)        {            endPosition = startPosition = 0;            readData = 0;        }        else if (startPosition >= 8)        {            readData >>= startPosition;            endPosition -= startPosition;            startPosition = 0;        }         return result;    }     public void Align()    {        endPosition = startPosition = 0;        readData = 0;    }} public class BitWriter{    uint data = 0;    int dataLength = 0;    Stream stream;     public Stream BaseStream    {        get { return stream; }    }     public int BitsToAligment    {        get { return (32 - dataLength) % 8; }    }     public BitWriter(Stream stream)    {        this.stream = stream;    }     public void WriteBit(bool value)    {        Write(value ? 1 : 0, 1);    }     public void Write(int value, int length)    {        uint currentData = data | ((uint)value << dataLength);        int currentLength = dataLength + length;        while (currentLength >= 8)        {            BaseStream.WriteByte((byte)currentData);            currentData >>= 8;            currentLength -= 8;        }        data = currentData;        dataLength = currentLength;    }     public void Align()    {        if (dataLength > 0)        {            BaseStream.WriteByte((byte)data);             data = 0;            dataLength = 0;        }    }} class Program{    static void Main(string[] args)    {        MemoryStream ms =  MemoryStream();        BitWriter writer =  BitWriter(ms);        writer.WriteBit(true);        writer.Write(5, 3);        writer.Write(0x0155, 11);        writer.Align();         ms.Position = 0;        BitReader reader =  BitReader(ms);        Console.WriteLine(reader.ReadBit());        Console.WriteLine(reader.Read(3));        Console.WriteLine(reader.Read(11).ToString(strv));        reader.Align();    }}"
" using System;using System.Collections.Generic; namespace BoxTheCompass{    class Compass    {        string[] cp =  string[] {strv, strv, strv, strv, strv,strv, 	    strv, strv, strv, strv, strv, strv, strv,             strv, strv, strv, strv, strv, strv, strv,             strv, strv, strv, strv, strv, strv, strv,             strv, strv, strv, strv, strv, strv};         public void compassHeading(float a)        {            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;            Console.WriteLine( strv,h + 1, cp[h], a );        }    };    class Program    {        static void Main(string[] args)       {            Compass c =  Compass();            float[] degs =  float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f,                 118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f,                 253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};             foreach (float d in degs)                c.compassHeading(d);             Console.WriteLine(""Press any key to continue..."");            Console.ReadKey();        }    }} "
"using System;using System.IO;class PPMWriter{    public static void WriteBitmapToPPM(string file, Bitmap bitmap)        {            //Use a streamwriter to write the text part of the encoding            var writer =  StreamWriter(file);            writer.Write(strv + """");            writer.Write(bitmap.Width + strv + bitmap.Height + """");            writer.Write(strv + """");            writer.Close();            //Switch to a binary writer to write the data            var writerB =  BinaryWriter( FileStream(file, FileMode.Append));            for (int x = 0; x < bitmap.Height; x++)                for (int y = 0; y < bitmap.Width; y++)                {                    Color color = bitmap.GetPixel(y, x);                    writerB.Write(color.R);                    writerB.Write(color.G);                    writerB.Write(color.B);                }            writerB.Close();        }}"
"static void bitwise(int a, int b)        {            Console.WriteLine(strv, a & b);            Console.WriteLine(strv, a | b);            Console.WriteLine(strv, a ^ b);            Console.WriteLine(strv, ~a);            Console.WriteLine(strv, a << b);            Console.WriteLine(strv, a >> b); // When the left operand of the >> operator is of a signed integral type,                                                              // the operator performs an arithmetic shift right            uint c = (uint)a;            Console.WriteLine(strv, c >> b); // When the left operand of the >> operator is of an unsigned integral type,                                                             // the operator performs a logical shift right            // there are no rotation operators in C#        }"
"         
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public static void DrawCircle(this GenericImage image, int centerX, int centerY, int radius, Color color)        {            int d = (5 - radius * 4) / 4;            int x = 0;            int y = radius;             do            {                // ensure index is in range before setting (depends on your image implementation)                // in this case we check if the pixel location is within the bounds of the image before setting the pixel                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX + x, centerY + y] = color;                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX + x, centerY - y] = color;                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX - x, centerY + y] = color;                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX - x, centerY - y] = color;                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX + y, centerY + x] = color;                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX + y, centerY - x] = color;                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX - y, centerY + x] = color;                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX - y, centerY - x] = color;                if (d < 0)                {                    d += 2 * x + 1;                }                else                {                    d += 2 * (x - y) + 1;                    y--;                }                x++;            } while (x <= y);        } "
"using System.IO;class PPMReader{    public static Bitmap ReadBitmapFromPPM(string file)    {        var reader =  BinaryReader( FileStream(file, FileMode.Open));        if (reader.ReadChar() != 'P' || reader.ReadChar() != '6')            return null;        reader.ReadChar(); //Eat newline        string widths = strv, heights = strv;        char temp;        while ((temp = reader.ReadChar()) != ' ')            widths += temp;        while ((temp = reader.ReadChar()) >= '0' && temp <= '9')            heights += temp;        if (reader.ReadChar() != '2' || reader.ReadChar() != '5' || reader.ReadChar() != '5')            return null;        reader.ReadChar(); //Eat the last newline        int width = int.Parse(widths),            height = int.Parse(heights);        Bitmap bitmap =  Bitmap(width, height);        //Read in the pixels        for (int y = 0; y < height; y++)            for (int x = 0; x < width; x++)                bitmap.SetPixel(x, y,  Bitmap.Color()                {                    Red = reader.ReadByte(),                    Green = reader.ReadByte(),                    Blue = reader.ReadByte()                });        return bitmap;    }}"
" using System;using System.Collections.Generic;using System.Drawing; namespace FloodFill{    class Program    {        private static bool ColorMatch(Color a, Color b)        {            return (a.ToArgb() & 0xffffff) == (b.ToArgb() & 0xffffff);        }         static void FloodFill(Bitmap bmp, Point pt, Color targetColor, Color replacementColor)        {            Queue<Point> q =  Queue<Point>();            q.Enqueue(pt);            while (q.Count > 0)            {                Point n = q.Dequeue();                if (!ColorMatch(bmp.GetPixel(n.X, n.Y),targetColor))                    continue;                Point w = n, e =  Point(n.X + 1, n.Y);                while ((w.X >= 0) && ColorMatch(bmp.GetPixel(w.X, w.Y),targetColor))                {                    bmp.SetPixel(w.X, w.Y, replacementColor);                    if ((w.Y > 0) && ColorMatch(bmp.GetPixel(w.X, w.Y - 1),targetColor))                        q.Enqueue( Point(w.X, w.Y - 1));                    if ((w.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(w.X, w.Y + 1),targetColor))                        q.Enqueue( Point(w.X, w.Y + 1));                    w.X--;                }                while ((e.X <= bmp.Width - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y),targetColor))                {                    bmp.SetPixel(e.X, e.Y, replacementColor);                    if ((e.Y > 0) && ColorMatch(bmp.GetPixel(e.X, e.Y - 1), targetColor))                        q.Enqueue( Point(e.X, e.Y - 1));                    if ((e.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y + 1), targetColor))                        q.Enqueue( Point(e.X, e.Y + 1));                    e.X++;                }            }        }         static void Main(string[] args)        {            Bitmap bmp =  Bitmap(strv);            FloodFill(bmp,  Point(200, 200), Color.White, Color.Red);            FloodFill(bmp,  Point(100, 100), Color.Black, Color.Blue);            bmp.Save(strv);        }    }} "
"public class Bitmap{    public struct Color    {        public byte Red { get; set; }        public byte Blue { get; set; }        public byte Green { get; set; }    }    Color[,] _imagemap;    public int Width { get { return _imagemap.GetLength(0); } }    public int Height { get { return _imagemap.GetLength(1); } }    public Bitmap(int width, int height)    {        _imagemap =  Color[width, height];    }    public void Fill(Color color)    {        for (int y = 0; y < Height; y++)            for (int x = 0; x < Width; x++)            {                _imagemap[x, y] = color;            }    }    public Color GetPixel(int x, int y)    {        return _imagemap[x, y];    }    public void SetPixel(int x, int y, Color color)    {        _imagemap[x, y] = color;    }}"
"using System; namespace ConsoleApplication7{    class Program    {        public static void Main(string[] args)        {                int[] array;                int needle;                .....                .....                 int index = binarySearch(array, needle, 0, array.Length);                Console.WriteLine(needle + ((index == -1) ? strv : (strv + index)));        }          public static int binarySearch(int[] nums, int check, int lo, int hi){                if(hi < lo){                        return -1; //impossible index for strv                }                int guess = (hi + lo) / 2;                if(nums[guess] > check){                        return binarySearch(nums, check, lo, guess - 1);                }else if(nums[guess]<check){                        return binarySearch(nums, check, guess + 1, hi);                }                return guess;                 }    }}using System; namespace BinarySearch{    class Program    {        static void Main(string[] args)        {             int[] a =  int[] { 2, 4, 6, 8, 9 };            Console.WriteLine(BinarySearchIterative(a, 9));            Console.WriteLine(BinarySearchRecursive(a, 9, 0, a.Length));        }         private static int BinarySearchIterative(int[] a, int val){            int low = 0;            int high = a.Length;            while (low <= high)            {                int mid = (low + high) / 2;                if (a[mid] > val)                    high = mid-1;                else if (a[mid] < val)                    low = mid+1;                else                    return mid;            }            return -1;        }         private static int BinarySearchRecursive(int[] a, int val, int low, int high)        {            if (high < low)                return -1;            int mid = (low + high) / 2;            if (a[mid] > val)                return BinarySearchRecursive(a, val, low, mid - 1);            else if (a[mid] < val)                return BinarySearchRecursive(a, val, mid + 1, high);            else                return mid;        }    }}"
"using System;using System.Drawing;using System.Drawing.Imaging;static class Program{    static void Main()    {         Bitmap(200, 200)            .DrawLine(0, 0, 199, 199, Color.Black).DrawLine(199,0,0,199,Color.Black)            .DrawLine(50, 75, 150, 125, Color.Blue).DrawLine(150, 75, 50, 125, Color.Blue)            .Save(strv, ImageFormat.Png);    }    static Bitmap DrawLine(this Bitmap bitmap, int x0, int y0, int x1, int y1, Color color)    {        int dx = Math.Abs(x1 - x0), sx = x0 < x1 ? 1 : -1;        int dy = Math.Abs(y1 - y0), sy = y0 < y1 ? 1 : -1;        int err = (dx > dy ? dx : -dy) / 2, e2;        for(;;) {            bitmap.SetPixel(x0, y0, color);            if (x0 == x1 && y0 == y1) break;            e2 = err;            if (e2 > -dx) { err -= dy; x0 += sx; }            if (e2 < dy) { err += dx; y0 += sy; }        }        return bitmap;    }}"
" using System;using System.Linq;using System.Security.Cryptography;using NUnit.Framework; namespace BitcoinValidator{    public class ValidateTest    {        [TestCase]        public void ValidateBitcoinAddressTest()        {            Assert.IsTrue(ValidateBitcoinAddress(strv)); // VALID            Assert.IsTrue(ValidateBitcoinAddress(strv)); // VALID            Assert.Throws<Exception>(() => ValidateBitcoinAddress(strv)); // checksum changed, original data            Assert.Throws<Exception>(() => ValidateBitcoinAddress(strv)); // data changed, original checksum            Assert.Throws<Exception>(() => ValidateBitcoinAddress(strv)); // invalid chars            Assert.Throws<Exception>(() => ValidateBitcoinAddress(strv)); // checksum is fine, address too short        }         public static bool ValidateBitcoinAddress(string address)        {            if (address.Length < 26 || address.Length > 35) throw  Exception(strv);            var decoded = DecodeBase58(address);            var d1 = Hash(decoded.SubArray(0, 21));            var d2 = Hash(d1);            if (!decoded.SubArray(21, 4).SequenceEqual(d2.SubArray(0, 4))) throw  Exception(strv);            return true;        }         const string Alphabet = strv;        const int Size = 25;         private static byte[] DecodeBase58(string input)        {            var output =  byte[Size];            foreach (var t in input)            {                var p = Alphabet.IndexOf(t);                if (p == -1) throw  Exception(strv);                var j = Size;                while (--j > 0)                {                    p += 58 * output[j];                    output[j] = (byte)(p % 256);                    p /= 256;                }                if (p != 0) throw  Exception(strv);            }            return output;        }         private static byte[] Hash(byte[] bytes)        {            var hasher =  SHA256Managed();            return hasher.ComputeHash(bytes);        }    }     public static class ArrayExtensions    {        public static T[] SubArray<T>(this T[] data, int index, int length)        {            var result =  T[length];            Array.Copy(data, index, result, 0, length);            return result;        }    }} "
"using System; class Program{    static void Main()    {        //string creation        var x = strv;         //# mark string for garbage collection        x = null;         //# string assignment with a null byte        x = ""ab"";        Console.WriteLine(x);        Console.WriteLine(x.Length); // 3         //# string comparison        if (x == strv)            Console.WriteLine(strv);        else            Console.WriteLine(strv);         if (x.CompareTo(strv) == -1)            Console.WriteLine(strv);         //# string cloning         var c =  char[3];        x.CopyTo(0, c, 0, 3);        object objecty =  string(c);        var y =  string(c);         Console.WriteLine(x == y);      //same as string.equals        Console.WriteLine(x.Equals(y)); //it overrides object.Equals         Console.WriteLine(x == objecty); //uses object.Equals, return false         //# check if empty        var empty = strv;        string nullString = null;        var whitespace = strv;        if (nullString == null && empty == string.Empty &&             string.IsNullOrEmpty(nullString) && string.IsNullOrEmpty(empty) &&            string.IsNullOrWhiteSpace(nullString) && string.IsNullOrWhiteSpace(empty) &&            string.IsNullOrWhiteSpace(whitespace))            Console.WriteLine(strv);         //# append a byte        x = strv;        x += (char)83;        Console.WriteLine(x);         //# substring        var slice = x.Substring(5, 5);        Console.WriteLine(slice);         //# replace bytes        var greeting = x.Replace(strv, strv);        Console.WriteLine(greeting);         //# join strings        var join = greeting + strv + slice;        Console.WriteLine(join);    }}"
"using System; class Program{    static void Main()    {        foreach (var number in [] { 5, 50, 9000 })        {            Console.WriteLine(Convert.ToString(number, 2));        }    }}"
namespace RosettaCode.Base64EncodeData{    using System;    using System.Net;     internal static class Program    {        private static void Main()        {            const string path = strv;             byte[] input;            using (var client =  WebClient())            {                input = client.DownloadData(path);            }             var output = Convert.ToBase64String(input);            Console.WriteLine(output);        }    }}
"using System;using System.Diagnostics;using System.Drawing; namespace RosettaBarnsleyFern{    class Program    {        static void Main(string[] args)        {            const int w = 600;            const int h = 600;            var bm =  Bitmap(w, h);            var r =  Random();            double x = 0;            double y = 0;            for (int count = 0; count < 100000; count++)            {                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);                int roll = r.Next(100);                double xp = x;                if (roll < 1)                {                    x = 0;                    y = 0.16 * y;                } else if (roll < 86)                {                    x = 0.85 * x + 0.04 * y;                    y = -0.04 * xp + 0.85 * y + 1.6;                } else if (roll < 93)                {                    x = 0.2 * x - 0.26 * y;                    y = 0.23 * xp + 0.22 * y + 1.6;                } else                {                    x = -0.15 * x + 0.28 * y;                    y = 0.26 * xp + 0.24 * y + 0.44;                }            }            const string filename = strv;            bm.Save(filename);            Process.Start(filename);        }    }}"
"using System;using System.Text;using System.Collections.Generic; public class BalancedTernary{	public static void Main()	{		BalancedTernary a =  BalancedTernary(strv);		System.Console.WriteLine(strv + a + strv + a.ToLong());		BalancedTernary b =  BalancedTernary(-436);		System.Console.WriteLine(strv + b + strv + b.ToLong());		BalancedTernary c =  BalancedTernary(strv);		System.Console.WriteLine(strv + c + strv + c.ToLong());		BalancedTernary d = a * (b - c);		System.Console.WriteLine(strv + d + strv + d.ToLong());	} 	private enum BalancedTernaryDigit	{		MINUS = -1,		ZERO = 0,		PLUS = 1	} 	private BalancedTernaryDigit[] value; 	// empty = 0	public BalancedTernary()	{		this.value =  BalancedTernaryDigit[0];	} 	// create from String	public BalancedTernary(String str)	{		this.value =  BalancedTernaryDigit[str.Length];		for (int i = 0; i < str.Length; ++i)		{			switch (str[i])			{				case '-':					this.value[i] = BalancedTernaryDigit.MINUS;					break;				case '0':					this.value[i] = BalancedTernaryDigit.ZERO;					break;				case '+':					this.value[i] = BalancedTernaryDigit.PLUS;					break;				default:					throw  ArgumentException(strv + str[i]);			}		}		Array.Reverse(this.value);	} 	// convert long integer	public BalancedTernary(long l)	{		List<BalancedTernaryDigit> value =  List<BalancedTernaryDigit>();		int sign = Math.Sign(l);		l = Math.Abs(l); 		while (l != 0)		{			byte rem = (byte)(l % 3);			switch (rem)			{				case 0:				case 1:					value.Add((BalancedTernaryDigit)rem);					l /= 3;					break;				case 2:					value.Add(BalancedTernaryDigit.MINUS);					l = (l + 1) / 3;					break;			}		} 		this.value = value.ToArray();		if (sign < 0)		{			this.Invert();		}	} 	// copy constructor	public BalancedTernary(BalancedTernary origin)	{		this.value =  BalancedTernaryDigit[origin.value.Length];		Array.Copy(origin.value, this.value, origin.value.Length);	} 	// only for internal use	private BalancedTernary(BalancedTernaryDigit[] value)	{		int end = value.Length - 1;		while (value[end] == BalancedTernaryDigit.ZERO)			--end;		this.value =  BalancedTernaryDigit[end + 1];		Array.Copy(value, this.value, end + 1);	} 	// invert the values	private void Invert()	{		for (int i=0; i < this.value.Length; ++i)		{			this.value[i] = (BalancedTernaryDigit)(-(int)this.value[i]);		}	} 	// convert to string	override public String ToString()	{		StringBuilder result =  StringBuilder();		for (int i = this.value.Length - 1; i >= 0; --i)		{			switch (this.value[i])			{				case BalancedTernaryDigit.MINUS:					result.Append('-');					break;				case BalancedTernaryDigit.ZERO:					result.Append('0');					break;				case BalancedTernaryDigit.PLUS:					result.Append('+');					break;			}		}		return result.ToString();	} 	// convert to long	public long ToLong()	{		long result = 0;		int digit;		for (int i = 0; i < this.value.Length; ++i)		{			result += (long)this.value[i] * (long)Math.Pow(3.0, (double)i);		}		return result;	} 	// unary minus	public static BalancedTernary operator -(BalancedTernary origin)	{		BalancedTernary result =  BalancedTernary(origin);		result.Invert();		return result;	} 	// addition of digits	private static BalancedTernaryDigit carry = BalancedTernaryDigit.ZERO;	private static BalancedTernaryDigit Add(BalancedTernaryDigit a, BalancedTernaryDigit b)	{		if (a != b)		{			carry = BalancedTernaryDigit.ZERO;			return (BalancedTernaryDigit)((int)a + (int)b);		}		else		{			carry = a;			return (BalancedTernaryDigit)(-(int)b);		}	} 	// addition of balanced ternary numbers	public static BalancedTernary operator +(BalancedTernary a, BalancedTernary b)	{		int maxLength = Math.Max(a.value.Length, b.value.Length);		BalancedTernaryDigit[] resultValue =  BalancedTernaryDigit[maxLength + 1];		for (int i=0; i < maxLength; ++i)		{			if (i < a.value.Length)			{				resultValue[i] = Add(resultValue[i], a.value[i]);				resultValue[i+1] = carry;			}			else			{				carry = BalancedTernaryDigit.ZERO;			} 			if (i < b.value.Length)			{				resultValue[i] = Add(resultValue[i], b.value[i]);				resultValue[i+1] = Add(resultValue[i+1], carry);			}		}		return  BalancedTernary(resultValue);	} 	// subtraction of balanced ternary numbers	public static BalancedTernary operator -(BalancedTernary a, BalancedTernary b)	{		return a + (-b);	} 	// multiplication of balanced ternary numbers	public static BalancedTernary operator *(BalancedTernary a, BalancedTernary b)	{		BalancedTernaryDigit[] longValue = a.value;		BalancedTernaryDigit[] shortValue = b.value;		BalancedTernary result =  BalancedTernary();		if (a.value.Length < b.value.Length)		{			longValue = b.value;			shortValue = a.value;		} 		for (int i = 0; i < shortValue.Length; ++i)		{			if (shortValue[i] != BalancedTernaryDigit.ZERO)			{				BalancedTernaryDigit[] temp =  BalancedTernaryDigit[i + longValue.Length];				for (int j = 0; j < longValue.Length; ++j)				{					temp[i+j] = (BalancedTernaryDigit)((int)shortValue[i] * (int)longValue[j]);				}				result = result +  BalancedTernary(temp);			}		}		return result;	}}"
"using System;using System.Linq; class Program{    static bool IsBalanced(string text, char open = '[', char close = ']')    {        var level = 0;        foreach (var character in text)        {            if (character == close)            {                if (level == 0)                {                    return false;                }                level--;            }            if (character == open)            {                level++;            }        }        return level == 0;    }     static string RandomBrackets(int count, char open = '[', char close = ']')    {        var random =  Random();        return string.Join(string.Empty,                ( string(open, count) +  string(close, count)).OrderBy(c => random.Next()));    }     static void Main()    {        for (var count = 0; count < 9; count++)        {            var text = RandomBrackets(count);            Console.WriteLine(""{0} is {1}balanced."", text, IsBalanced(text) ? string.Empty : strv);        }    }}                        // simple solution                       string input = Console.ReadLine();			if (input.Length % 2 != 0)			{				Console.WriteLine(strv);				return;			}			for (int i = 0; i < input.Length; i++)			{				if (i < input.Length - 1)				{					if (input[i] == '[' && input[i + 1] == ']')					{						input = input.Remove(i, 2);						i = -1;					}				} 			}			if (input.Length == 0)				Console.WriteLine(strv);			else				Console.WriteLine(strv);  "
"namespace Babbage_Problem{    class iterateNumbers    {        public iterateNumbers()        {            long baseNumberSquared = 0; //the base number multiplied by itself            long baseNumber = 0;  //the number to be squared, this one will be iterated             do  //this sets up the loop            {                baseNumber += 1; //add one to the base number                baseNumberSquared = baseNumber * baseNumber; //multiply the base number by itself and store the value as baseNumberSquared            }            while (Right6Digits(baseNumberSquared) != 269696); //this will continue the loop until the right 6 digits of the base number squared are 269,696             Console.WriteLine(strv + baseNumber);            Console.WriteLine(strv + baseNumberSquared);         }         private long Right6Digits(long baseNumberSquared)        {             string numberAsString = baseNumberSquared.ToString(); //this is converts the number to a different type so it can be cut up             if (numberAsString.Length < 6) { return baseNumberSquared; }; //if the number doesn't have 6 digits in it, just return it to try again.             numberAsString = numberAsString.Substring(numberAsString.Length - 6);  //this extracts the last 6 digits from the number             return long.Parse(numberAsString); //return the last 6 digits of the number         }    }}}"
" using Mpir.NET;using System; namespace Bernoulli{    class Program    {        private static void bernoulli(mpq_t rop, uint n)        {            mpq_t[] a =  mpq_t[n + 1];             for (uint i = 0; i < n + 1; i++)            {                a[i] =  mpq_t();            }             for (uint m = 0; m <= n; ++m)            {                mpir.mpq_set_ui(a[m], 1, m + 1);                 for (uint j = m; j > 0; --j)                {                    mpir.mpq_sub(a[j - 1], a[j], a[j - 1]);                    mpir.mpq_set_ui(rop, j, 1);                    mpir.mpq_mul(a[j - 1], a[j - 1], rop);                }                 mpir.mpq_set(rop, a[0]);            }        }         static void Main(string[] args)        {            mpq_t rop =  mpq_t();            mpz_t n =  mpz_t();            mpz_t d =  mpz_t();             for (uint  i = 0; i <= 60; ++i)             {                bernoulli(rop, i);                 if (mpir.mpq_cmp_ui(rop, 0, 1) != 0)                 {                    mpir.mpq_get_num(n, rop);                    mpir.mpq_get_den(d, rop);                    Console.WriteLine(string.Format(strv, i, n, d));                }            }             Console.ReadKey();        }    }}  using System;using System.Console;using System.Linq;using MathNet.Numerics; namespace Rosettacode.Rational.CS{    class Program    {        private static readonly Func<int, BigRational> ℚ = BigRational.FromInt;         private static BigRational CalculateBernoulli(int n)        {            var a = InitializeArray(n);             foreach(var m in Enumerable.Range(1,n))            {                a[m] = ℚ(1) / (ℚ(m) + ℚ(1));                 for (var j = m; j >= 1; j--)                {                    a[j-1] = ℚ(j) * (a[j-1] - a[j]);                }            }             return a[0];        }         private static BigRational[] InitializeArray(int n)        {            var a =  BigRational[n + 1];             for (var x = 0; x < a.Length; x++)            {                a[x] = ℚ(x + 1);            }             return a;        }         static void Main()        {            Enumerable.Range(0, 60)                .Select(n =>  {N = n, BernoulliNumber = CalculateBernoulli(n)})                .Where(b => !b.BernoulliNumber.Numerator.IsZero)                .Select(b => string.Format(strv, b.N, b.BernoulliNumber.Numerator, b.BernoulliNumber.Denominator))                .ToList()                .ForEach(WriteLine);        }    }} "
"ShuffledString[] array = {strv, strv, strv}; using System;using System.Text;using System.Collections.Generic; namespace BestShuffle_RC{    public class ShuffledString    {        private string original;        private StringBuilder shuffled;        private int ignoredChars;         public string Original        {            get { return original; }        }         public string Shuffled        {            get { return shuffled.ToString(); }        }         public int Ignored        {            get { return ignoredChars; }        }         private void Swap(int pos1, int pos2)        {            char temp = shuffled[pos1];            shuffled[pos1] = shuffled[pos2];            shuffled[pos2] = temp;        }         //Determine if a swap between these two would put a letter in a strv place        //If true, a swap is OK.         private bool TrySwap(int pos1, int pos2)        {            if (original[pos1] == shuffled[pos2] || original[pos2] == shuffled[pos1])                return false;            else                return true;        }         //Constructor carries out calls Shuffle function.         public ShuffledString(string word)        {            original = word;            shuffled =  StringBuilder(word);            Shuffle();            DetectIgnores();        }         //Does the hard work of shuffling the string.        private void Shuffle()        {            int length = original.Length;            int swaps;            Random rand =  Random();            List<int> used =  List<int>();             for (int i = 0; i < length; i++)            {                swaps = 0;                while(used.Count <= length - i)//Until all possibilities have been tried                {                    int j = rand.Next(i, length - 1);                    //If swapping would make a difference, and wouldn't put a letter in a strv place,                    //and hasn't already been tried, then swap                    if (original[i] != original[j] && TrySwap(i, j) && !used.Contains(j))                    {                        Swap(i, j);                        swaps++;                        break;                    }                    else                        used.Add(j);//If swapping doesn't work, strv the index                }                if (swaps == 0)                {                    //If a letter was ignored (no swap was found), look backward for another change to make                    for (int k = i; k >= 0; k--)                    {                        if (TrySwap(i, k))                            Swap(i, k);                    }                }                //Clear the used indeces                used.Clear();            }        }         //Count how many letters are still in their original places.        private void DetectIgnores()        {            int ignores = 0;            for (int i = 0; i < original.Length; i++)            {                if (original[i] == shuffled[i])                    ignores++;            }             ignoredChars = ignores;        }         //To allow easy conversion of strings.        public static implicit operator ShuffledString(string convert)        {            return  ShuffledString(convert);        }    }     public class Program    {        public static void Main(string[] args)        {            ShuffledString[] words = { strv, strv, strv, strv, strv, strv };             foreach(ShuffledString word in words)                Console.WriteLine(strv, word.Original, word.Shuffled, word.Ignored);             Console.ReadKey();        }    }}  using System;using System.Text;using System.Collections.Generic; namespace BestShuffle_RC{    public class ShuffledString    {        private string original;        private StringBuilder shuffled;        private int ignoredChars;         public string Original        {            get { return original; }        }         public string Shuffled        {            get { return shuffled.ToString(); }        }         public int Ignored        {            get { return ignoredChars; }        }         private void Swap(int pos1, int pos2)        {            char temp = shuffled[pos1];            shuffled[pos1] = shuffled[pos2];            shuffled[pos2] = temp;        }         //Determine if a swap between these two would put a letter in a strv place        //If true, a swap is OK.         private bool TrySwap(int pos1, int pos2)        {            if (original[pos1] == shuffled[pos2] || original[pos2] == shuffled[pos1])                return false;            else                return true;        }         //Constructor carries out calls Shuffle function.         public ShuffledString(string word)        {            original = word;            shuffled =  StringBuilder(word);            Shuffle();            DetectIgnores();        }         //Does the hard work of shuffling the string.        private void Shuffle()        {            int length = original.Length;            int swaps;            Random rand =  Random();            List<int> used =  List<int>();             for (int i = 0; i < length; i++)            {                swaps = 0;                while(used.Count <= length - i)//Until all possibilities have been tried                {                    int j = rand.Next(i, length - 1);                    //If swapping would make a difference, and wouldn't put a letter in a strv place,                    //and hasn't already been tried, then swap                    if (original[i] != original[j] && TrySwap(i, j) && !used.Contains(j))                    {                        Swap(i, j);                        swaps++;                        break;                    }                    else                        used.Add(j);//If swapping doesn't work, strv the index                }                if (swaps == 0)                {                    //If a letter was ignored (no swap was found), look backward for another change to make                    for (int k = i; k >= 0; k--)                    {                        if (TrySwap(i, k))                            Swap(i, k);                    }                }                //Clear the used indeces                used.Clear();            }        }         //Count how many letters are still in their original places.        private void DetectIgnores()        {            int ignores = 0;            for (int i = 0; i < original.Length; i++)            {                if (original[i] == shuffled[i])                    ignores++;            }             ignoredChars = ignores;        }         //To allow easy conversion of strings.        public static implicit operator ShuffledString(string convert)        {            return  ShuffledString(convert);        }    }     public class Program    {        public static void Main(string[] args)        {            ShuffledString[] words = { strv, strv, strv, strv, strv, strv };             foreach(ShuffledString word in words)                Console.WriteLine(strv, word.Original, word.Shuffled, word.Ignored);             Console.ReadKey();        }    }} "
"using System;using System.Collections.Generic;using System.Linq; namespace SMA {    class Program {        static void Main(string[] args) {            var nums = Enumerable.Range(1, 5).Select(n => (double)n);            nums = nums.Concat(nums.Reverse());             var sma3 = SMA(3);            var sma5 = SMA(5);             foreach (var n in nums) {                Console.WriteLine(strv, n, sma3(n), sma5(n));            }        }         static Func<double, double> SMA(int p) {            Queue<double> s =  Queue<double>(p);            return (x) => {                if (s.Count >= p) {                    s.Dequeue();                }                s.Enqueue(x);                return s.Average();            };        }    }}"
"using System; namespace rms{    class Program    {        static void Main(string[] args)        {            int[] x =  int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };            Console.WriteLine(rootMeanSquare(x));        }         private static double rootMeanSquare(int[] x)        {                        double sum = 0;            for (int i = 0; i < x.Length; i++)            {                sum += (x[i]*x[i]);            }            return Math.Sqrt(sum / x.Length);        }    }}using System;using System.Collections.Generic;using System.Linq; namespace rms{    class Program    {        static void Main(string[] args)        {            Console.WriteLine(rootMeanSquare(Enumerable.Range(1, 10)));        }         private static double rootMeanSquare(IEnumerable<int> x)        {            return Math.Sqrt((double)x.Sum(n => n * n) / x.Count());        }    }}"
"using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq; namespace PythMean{    static class Program    {        static void Main(string[] args) {            var nums = from n in Enumerable.Range(1, 10) select (double)n;             var a = nums.Average();            var g = nums.Gmean();            var h = nums.Hmean();             Console.WriteLine(strv, a);            Console.WriteLine(strv, g);            Console.WriteLine(strv, h);             Debug.Assert(a >= g && g >= h);        }         // Geometric mean extension method.        static double Gmean(this IEnumerable<double> n) {            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());        }         // Harmonic mean extension method.        static double Hmean(this IEnumerable<double> n) {            return n.Count() / n.Sum(i => 1.0 / i);        }    }}"
"using System;using System.Collections;using System.Collections.Generic;using System.Linq; namespace Test{    class Program    {         static void Main(string[] args)        {            /*
             * We Use Linq To Determine The Mode
             */            List<int> myList =  List<int>() { 1, 1, 2, 4, 4 };              var query =     from numbers in myList //select the numbers                            group numbers by numbers //group them together so we can get the count                            into groupedNumbers                            select  { Number = groupedNumbers.Key, Count = groupedNumbers.Count() }; //so we got a query            //find the max of the occurence of the mode             int max = query.Max(g => g.Count);            IEnumerable<int> modes = query.Where(x => x.Count == max).Select(x => x.Number);//match the frequence and select the number            foreach (var item in modes)            {                Console.WriteLine(item);            }             Console.ReadLine();        }       }  } "
"using System;using System.Linq; namespace Test{    class Program    {        static void Main()        {            double[] myArr =  double[] { 1, 5, 3, 6, 4, 2 };             myArr = myArr.OrderBy(i => i).ToArray();            // or Array.Sort(myArr) for in-place sort             int mid = myArr.Length / 2;            double median;             if (myArr.Length % 2 == 0)            {                //we know its even                median = (myArr[mid] + myArr[mid - 1]) / 2.0;            }            else            {                //we know its odd                median = myArr[mid];            }             Console.WriteLine(median);            Console.ReadLine();        }    }} "
"using System;using System.Linq;using static System.Math;class Program{    static double MeanAngle(double[] angles)    {        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;        return Atan2(y, x) * 180 / PI;    }    static void Main()    {        Action<double[]> printMean = x => Console.WriteLine(strv, MeanAngle(x));        printMean( double[] { 350, 10 });        printMean( double[] { 90, 180, 270, 360 });        printMean( double[] { 10, 20, 30 });    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace RosettaCode{    class Program    {        static void Main(string[] args)        {            Func<TimeSpan, double> TimeToDegrees = (time) =>                 360 * time.Hours / 24.0 +                360 * time.Minutes / (24 * 60.0) +                360 * time.Seconds / (24 * 3600.0);            Func<List<double>, double> MeanAngle = (angles) =>                {                    double y_part = 0.0d, x_part = 0.0d;                    int numItems = angles.Count;                     for (int i = 0; i < numItems; i++)                    {                        x_part += Math.Cos(angles[i] * Math.PI / 180);                        y_part += Math.Sin(angles[i] * Math.PI / 180);                    }                     return Math.Atan2(y_part / numItems, x_part / numItems) * 180 / Math.PI;                };            Func<double, TimeSpan> TimeFromDegrees = (angle) =>                     TimeSpan(                        (int)(24 * 60 * 60 * angle / 360) / 3600,                         ((int)(24 * 60 * 60 * angle / 360) % 3600 - (int)(24 * 60 * 60 * angle / 360) % 60) / 60,                         (int)(24 * 60 * 60 * angle / 360) % 60);            List<double> digitimes =  List<double>();            TimeSpan digitime;            string input;             Console.WriteLine(strv);            do            {                input = Console.ReadLine();                if (!(string.IsNullOrWhiteSpace(input)))                {                    if (TimeSpan.TryParse(input, out digitime))                        digitimes.Add(TimeToDegrees(digitime));                    else                        Console.WriteLine(strv);                }            } while (!string.IsNullOrWhiteSpace(input));             if(digitimes.Count() > 0)                Console.WriteLine(strv, TimeFromDegrees(360 + MeanAngle(digitimes)));        }    }} "
"using System;using System.Linq; class Program{    static void Main()    {        Console.WriteLine([] { 1, 2, 3 }.Average());    }}using System; class Program{    static void Main(string[] args)    {        double average = 0;         double[] numArray = { 1, 2, 3, 4, 5 };        average = Average(numArray);         Console.WriteLine(average); // Output is 3         // Alternative use        average = Average(1, 2, 3, 4, 5);         Console.WriteLine(average); // Output is still 3        Console.ReadLine();    }     static double Average(params double[] nums)    {        double d = 0;         foreach (double num in nums)            d += num;        return d / nums.Length;    }}"
" using System; //Rand classusing System.Threading; //Thread, Mutex classespublic class ThreadSafeBuckets{    //This class is thread safe, and ensures that all operations on it are atomic.    //Calling threads do not need to ensure safety.    Random rand =  Random();    int[] Buckets;    object[] locks; //Mutexes for each bucket so they can lock individually    public int BucketCount { get; private set; }    public ThreadSafeBuckets(int bucketcount)    {        //Create buckets+mutexes and fill them with a random amount        BucketCount = bucketcount;        Buckets =  int[bucketcount];        locks =  object[bucketcount];        int startingtotal = 0;        for (int i = 0; i < BucketCount; i++)        {            locks[i] =  object();            Buckets[i] = rand.Next(30);            startingtotal += Buckets[i];        }        //Print the starting total        Console.WriteLine(strv + startingtotal);    }    public int GetBucketValue(int i)    {        return Buckets[i];    }    public void Transfer(int i, int j, int amount)    {        //Transfer amount from bucket i to bucket j        if (i > BucketCount || j > BucketCount || i < 0 || j < 0 ||            i == j || amount < 0)            return;         //To prevent deadlock, always lock the lower bucket first        lock (locks[Math.Min(i, j)])            lock (locks[Math.Max(i, j)])            {                //Make sure don't transfer out more than is in the bucket                amount = Math.Min(amount, Buckets[i]);                 //Do the transfer                Buckets[i] -= amount;                Buckets[j] += amount;            }    }     public void PrintBuckets()    {        int counter = 0;        //Lock all the buckets in sequential order and print their contents        for (int i = 0; i < BucketCount; i++)        {            Monitor.Enter(locks[i]);            Console.Write(Buckets[i] + strv);            counter += Buckets[i];        }        //Print the bucket total, then unlock all the mutexes        Console.Write(strv + counter);        Console.WriteLine();         foreach (var l in locks)            Monitor.Exit(l);    }} class Program{    static ThreadSafeBuckets TSBs;     public static void Main(){        //Create the thread-safe bucket list        TSBs =  ThreadSafeBuckets(10);        TSBs.PrintBuckets();        //Create and start the Equalizing Thread         Thread( ThreadStart(EqualizerThread)).Start();        Thread.Sleep(1);        //Create and start the Randamizing Thread         Thread( ThreadStart(RandomizerThread)).Start();        //Use this thread to do the printing        PrinterThread();    }    //EqualizerThread runs on it's own thread and randomly averages two buckets    static void EqualizerThread()    {        Random rand =  Random();        while (true)        {            //Pick two buckets            int b1 = rand.Next(TSBs.BucketCount);            int b2 = rand.Next(TSBs.BucketCount);            //Get the difference            int diff = TSBs.GetBucketValue(b1) - TSBs.GetBucketValue(b2);            //Transfer to equalize            if (diff < 0)                TSBs.Transfer(b2, b1, -diff / 2);            else                TSBs.Transfer(b1, b2, diff/2);        }    }    //RandomizerThread redistributes the values between two buckets    static void RandomizerThread()    {        Random rand =  Random();        while (true)        {            int b1 = rand.Next(TSBs.BucketCount);            int b2 = rand.Next(TSBs.BucketCount);            int diff = rand.Next(TSBs.GetBucketValue(b1));            TSBs.Transfer(b1, b2, diff);        }    }    //PrinterThread prints the current bucket contents    static void PrinterThread()    {        while (true)        {            Thread.Sleep(50); //Only print every few milliseconds to let the other threads work            TSBs.PrintBuckets();        }    }}"
using System.Diagnostics; Debug.Assert(a == 42);
"using System;using System.Collections.Generic; namespace AssocArrays{    class Program    {        static void Main(string[] args)        {             Dictionary<string,int> assocArray =  Dictionary<string,int>();             assocArray[strv] = 1;            assocArray.Add(strv, 2);            assocArray[strv] = 3;             foreach (KeyValuePair<string, int> kvp in assocArray)            {                Console.WriteLine(kvp.Key + strv + kvp.Value);            }             foreach (string key in assocArray.Keys)            {                Console.WriteLine(key);            }             foreach (int val in assocArray.Values)            {                Console.WriteLine(val.ToString());            }        }    }} "
"System..HashTable map =  System..HashTable();map[strv] = strv;Dictionary<string, string> map =  Dictionary<string,string>();map[ strv ] = strv;var map =  Dictionary<string, string> {{strv, strv}};"
" using System; class Program{    public static void Main()    {        var fruit = [] { strv, strv };        Console.WriteLine(fruit.Length);    }}  var fruit = [] { strv, strv };var fruit =  string[] { strv, strv };string[] fruit = [] { strv, strv };string[] fruit =  string[] { strv, strv };string[] fruit = { strv, strv };  using static System.Console; class Program {    public static void Main()    {        WriteLine([] { strv, strv }.Length);    }} "
"using System; namespace RosettaCode{    class Program    {        static void Main(string[] args)        {            int[] a = { 1, 2, 3 };            int[] b = { 4, 5, 6 };             int[] c =  int[a.Length + b.Length];            a.CopyTo(c, 0);            b.CopyTo(c, a.Length);             foreach(int n in c)            {                Console.WriteLine(n.ToString());            }        }    }}using System.Linq; class Program{    static void Main(string[] args)    {        int[] a = { 1, 2, 3 };        int[] b = { 4, 5, 6 };         int[] c = a.Concat(b).ToArray();    }}"
"using System; struct Fraction : IEquatable<Fraction>, IComparable<Fraction>{    public readonly long Num;    public readonly long Denom;     public Fraction(long num, long denom)    {        if (num == 0)        {            denom = 1;        }        else if (denom == 0)        {            throw  ArgumentException(strv, strv);        }        else if (denom < 0)        {            num = -num;            denom = -denom;        }         long d = GCD(num, denom);        this.Num = num / d;        this.Denom = denom / d;    }     private static long GCD(long x, long y)    {        return y == 0 ? x : GCD(y, x % y);    }     private static long LCM(long x, long y)    {        return x / GCD(x, y) * y;    }     public Fraction Abs()    {        return  Fraction(Math.Abs(Num), Denom);    }     public Fraction Reciprocal()    {        return  Fraction(Denom, Num);    }     #region Conversion Operators     public static implicit operator Fraction(long i)    {        return  Fraction(i, 1);    }     public static explicit operator double(Fraction f)    {        return f.Num == 0 ? 0 : (double)f.Num / f.Denom;    }     #endregion     #region Arithmetic Operators     public static Fraction operator -(Fraction f)    {        return  Fraction(-f.Num, f.Denom);    }     public static Fraction operator +(Fraction a, Fraction b)    {        long m = LCM(a.Denom, b.Denom);        long na = a.Num * m / a.Denom;        long nb = b.Num * m / b.Denom;        return  Fraction(na + nb, m);    }     public static Fraction operator -(Fraction a, Fraction b)    {        return a + (-b);    }     public static Fraction operator *(Fraction a, Fraction b)    {        return  Fraction(a.Num * b.Num, a.Denom * b.Denom);    }     public static Fraction operator /(Fraction a, Fraction b)    {        return a * b.Reciprocal();    }     public static Fraction operator %(Fraction a, Fraction b)    {        long l = a.Num * b.Denom, r = a.Denom * b.Num;        long n = l / r;        return  Fraction(l - n * r, a.Denom * b.Denom);    }     #endregion     #region Comparison Operators     public static bool operator ==(Fraction a, Fraction b)    {        return a.Num == b.Num && a.Denom == b.Denom;    }     public static bool operator !=(Fraction a, Fraction b)    {        return a.Num != b.Num || a.Denom != b.Denom;    }     public static bool operator <(Fraction a, Fraction b)    {        return (a.Num * b.Denom) < (a.Denom * b.Num);    }     public static bool operator >(Fraction a, Fraction b)    {        return (a.Num * b.Denom) > (a.Denom * b.Num);    }     public static bool operator <=(Fraction a, Fraction b)    {        return !(a > b);    }     public static bool operator >=(Fraction a, Fraction b)    {        return !(a < b);    }     #endregion     #region Object Members     public override bool Equals(object obj)    {        if (obj  Fraction)            return ((Fraction)obj) == this;        else            return false;    }     public override int GetHashCode()    {        return Num.GetHashCode() ^ Denom.GetHashCode();    }     public override string ToString()    {        return Num.ToString() + strv + Denom.ToString();    }     #endregion     #region IEquatable<Fraction> Members     public bool Equals(Fraction other)    {        return other == this;    }     #endregion     #region IComparable<Fraction> Members     public int CompareTo(Fraction other)    {        return (this.Num * other.Denom).CompareTo(this.Denom * other.Num);    }     #endregion}using System; static class Program{    static void Main(string[] args)    {        int max = 1 << 19;        for (int candidate = 2; candidate < max; candidate++)        {            Fraction sum =  Fraction(1, candidate);            int max2 = (int)Math.Sqrt(candidate);            for (int factor = 2; factor <= max2; factor++)            {                if (candidate % factor == 0)                {                    sum +=  Fraction(1, factor);                    sum +=  Fraction(1, candidate / factor);                }            }             if (sum == 1)                Console.WriteLine(strv, candidate);        }    }}"
"using System;using System.Linq;using System.Drawing;using System.Diagnostics;using System.Drawing.Drawing2D; class Program{    const int width = 380;    const int height = 380;    static PointF archimedeanPoint(int degrees)    {        const double a = 1;        const double b = 9;        double t = degrees * Math.PI / 180;        double r = a + b * t;        return  PointF { X = (float)(width / 2 + r * Math.Cos(t)), Y = (float)(height / 2 + r * Math.Sin(t)) };    }     static void Main(string[] args)    {        var bm =  Bitmap(width, height);        var g = Graphics.FromImage(bm);        g.SmoothingMode = SmoothingMode.AntiAlias;        g.FillRectangle( SolidBrush(Color.White),  Rectangle { X = 0, Y = 0, Width = width, Height = height });        var pen =  Pen(Color.OrangeRed, 1.5f);         var spiral = Enumerable.Range(0, 360 * 3).AsParallel().AsOrdered().Select(archimedeanPoint);        var p0 =  PointF(width / 2, height / 2);        foreach (var p1 in spiral)        {            g.DrawLine(pen, p0, p1);            p0 = p1;        }        g.Save(); // is this really necessary ?        bm.Save(strv);        Process.Start(strv); // Launches default photo viewing app    }} "
"namespace RosettaCode.ArithmeticGeometricMean{    using System;    using System.Collections.Generic;    using System.Globalization;     internal static class Program    {        private static double ArithmeticGeometricMean(double number,                                                      double otherNumber,                                                      IEqualityComparer<double>                                                          comparer)        {            return comparer.Equals(number, otherNumber)                       ? number                       : ArithmeticGeometricMean(                           ArithmeticMean(number, otherNumber),                           GeometricMean(number, otherNumber), comparer);        }         private static double ArithmeticMean(double number, double otherNumber)        {            return 0.5 * (number + otherNumber);        }         private static double GeometricMean(double number, double otherNumber)        {            return Math.Sqrt(number * otherNumber);        }         private static void Main()        {            Console.WriteLine(                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),                                         RelativeDifferenceComparer(1e-5)).                    ToString(CultureInfo.InvariantCulture));        }         private class RelativeDifferenceComparer : IEqualityComparer<double>        {            private readonly double _maximumRelativeDifference;             internal RelativeDifferenceComparer(double maximumRelativeDifference)            {                _maximumRelativeDifference = maximumRelativeDifference;            }             public bool Equals(double number, double otherNumber)            {                return RelativeDifference(number, otherNumber) <=                       _maximumRelativeDifference;            }             public int GetHashCode(double number)            {                return number.GetHashCode();            }             private static double RelativeDifference(double number,                                                     double otherNumber)            {                return AbsoluteDifference(number, otherNumber) /                       Norm(number, otherNumber);            }             private static double AbsoluteDifference(double number,                                                     double otherNumber)            {                return Math.Abs(number - otherNumber);            }             private static double Norm(double number, double otherNumber)            {                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));            }        }    }}"
"namespace RosettaCode.Arithmetic.Complex{    using System;    using System.Numerics;     internal static class Program    {        private static void Main()        {            var number = Complex.ImaginaryOne;            foreach (var result in [] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })            {                Console.WriteLine(result);            }        }    }}using System; public struct ComplexNumber{    public static readonly ComplexNumber i =  ComplexNumber(0.0, 1.0);    public static readonly ComplexNumber Zero =  ComplexNumber(0.0, 0.0);     public double Re;    public double Im;     public ComplexNumber(double re)    {        this.Re = re;        this.Im = 0;    }     public ComplexNumber(double re, double im)    {        this.Re = re;        this.Im = im;    }     public static ComplexNumber operator *(ComplexNumber n1, ComplexNumber n2)    {        return  ComplexNumber(n1.Re * n2.Re - n1.Im * n2.Im,            n1.Im * n2.Re + n1.Re * n2.Im);    }     public static ComplexNumber operator *(double n1, ComplexNumber n2)    {        return  ComplexNumber(n1 * n2.Re, n1 * n2.Im);    }     public static ComplexNumber operator /(ComplexNumber n1, ComplexNumber n2)    {        double n2Norm = n2.Re * n2.Re + n2.Im * n2.Im;        return  ComplexNumber((n1.Re * n2.Re + n1.Im * n2.Im) / n2Norm,            (n1.Im * n2.Re - n1.Re * n2.Im) / n2Norm);    }     public static ComplexNumber operator /(ComplexNumber n1, double n2)    {        return  ComplexNumber(n1.Re / n2, n1.Im / n2);    }     public static ComplexNumber operator +(ComplexNumber n1, ComplexNumber n2)    {        return  ComplexNumber(n1.Re + n2.Re, n1.Im + n2.Im);    }     public static ComplexNumber operator -(ComplexNumber n1, ComplexNumber n2)    {        return  ComplexNumber(n1.Re - n2.Re, n1.Im - n2.Im);    }     public static ComplexNumber operator -(ComplexNumber n)    {        return  ComplexNumber(-n.Re, -n.Im);    }     public static implicit operator ComplexNumber(double n)    {        return  ComplexNumber(n, 0.0);    }     public static explicit operator double(ComplexNumber n)    {        return n.Re;    }     public static bool operator ==(ComplexNumber n1, ComplexNumber n2)    {        return n1.Re == n2.Re && n1.Im == n2.Im;    }     public static bool operator !=(ComplexNumber n1, ComplexNumber n2)    {        return n1.Re != n2.Re || n1.Im != n2.Im;    }     public override bool Equals(object obj)    {        return this == (ComplexNumber)obj;    }     public override int GetHashCode()    {        return Re.GetHashCode() ^ Im.GetHashCode();    }     public override string ToString()    {        return String.Format(strv, Re, Im);    }} public static class ComplexMath{    public static double Abs(ComplexNumber a)    {        return Math.Sqrt(Norm(a));    }     public static double Norm(ComplexNumber a)    {        return a.Re * a.Re + a.Im * a.Im;    }     public static double Arg(ComplexNumber a)    {        return Math.Atan2(a.Im, a.Re);    }     public static ComplexNumber Inverse(ComplexNumber a)    {        double norm = Norm(a);        return  ComplexNumber(a.Re / norm, -a.Im / norm);    }     public static ComplexNumber Conjugate(ComplexNumber a)    {        return  ComplexNumber(a.Re, -a.Im);     }     public static ComplexNumber Exp(ComplexNumber a)    {        double e = Math.Exp(a.Re);        return  ComplexNumber(e * Math.Cos(a.Im), e * Math.Sin(a.Im));    }     public static ComplexNumber Log(ComplexNumber a)    {         return  ComplexNumber(0.5 * Math.Log(Norm(a)), Arg(a));    }     public static ComplexNumber Power(ComplexNumber a, ComplexNumber power)    {        return Exp(power * Log(a));    }     public static ComplexNumber Power(ComplexNumber a, int power)    {        bool inverse = false;        if (power < 0)        {            inverse = true; power = -power;        }         ComplexNumber result = 1.0;        ComplexNumber multiplier = a;        while (power > 0)        {            if ((power & 1) != 0) result *= multiplier;            multiplier *= multiplier;            power >>= 1;        }         if (inverse)            return Inverse(result);        else            return result;    }     public static ComplexNumber Sqrt(ComplexNumber a)    {        return Exp(0.5 * Log(a));    }     public static ComplexNumber Sin(ComplexNumber a)    {        return Sinh(ComplexNumber.i * a) / ComplexNumber.i;    }     public static ComplexNumber Cos(ComplexNumber a)    {        return Cosh(ComplexNumber.i * a);    }     public static ComplexNumber Sinh(ComplexNumber a)    {        return 0.5 * (Exp(a) - Exp(-a));    }     public static ComplexNumber Cosh(ComplexNumber a)    {        return 0.5 * (Exp(a) + Exp(-a));    } } class Program{    static void Main(string[] args)    {        // usage        ComplexNumber i = 2;        ComplexNumber j =  ComplexNumber(1, -2);        Console.WriteLine(i * j);        Console.WriteLine(ComplexMath.Power(j, 2));        Console.WriteLine((double)ComplexMath.Sin(i) + strv + Math.Sin(2));        Console.WriteLine(ComplexMath.Power(j, 0) == 1.0);    }}"
"using System;using System.Diagnostics;using System.Linq;using System.Numerics; static class Program {    static void Main() {        BigInteger n = BigInteger.Pow(5, (int)BigInteger.Pow(4, (int)BigInteger.Pow(3, 2)));        string result = n.ToString();         Debug.Assert(result.Length == 183231);        Debug.Assert(result.StartsWith(strv));        Debug.Assert(result.EndsWith(strv));         Console.WriteLine(strv);        Console.WriteLine(strv,             result.Substring(0, 20),            result.Substring(result.Length - 20, 20)            );         Console.WriteLine(strv, result.Length);    }}"
" int[] numbers =  int[10]; string[] words = { strv, strv, strv };  int[] more_numbers =  int[3]{ 21, 14 ,63 };  int[,] number_matrix =  int[3,2];  string[,] string_matrix = { {strv,strv}, {strv,strv}, {strv,strv} }; string[,] funny_matrix =  string[2,2]{ {strv, strv} , {strv, strv} };int[] array =  int[10]; array[0] = 1;array[1] = 3; Console.WriteLine(array[0]);using System;using System.Collections.Generic; List<int> list =  List<int>(); list.Add(1);list.Add(3); list[0] = 2; Console.WriteLine(list[0]);"
"using System; class Program{    static void Main(string[] args)    {        int a = Convert.ToInt32(args[0]);        int b = Convert.ToInt32(args[1]);         Console.WriteLine(strv, a, b, a + b);        Console.WriteLine(strv, a, b, a - b);        Console.WriteLine(strv, a, b, a * b);        Console.WriteLine(strv, a, b, a / b); // truncates towards 0        Console.WriteLine(strv, a, b, a % b); // matches sign of first operand        Console.WriteLine(strv, a, b, Math.Pow(a, b));    }}"
"using System;using System.IO; namespace AppendPwdRosetta{    class PasswordRecord    {        public string account, password, fullname, office, extension, homephone, email, directory, shell;        public int UID, GID;        public PasswordRecord(string account, string password, int UID, int GID, string fullname, string office, string extension, string homephone,             string email, string directory, string shell)        {            this.account = account; this.password = password; this.UID = UID; this.GID = GID; this.fullname = fullname; this.office = office;            this.extension = extension; this.homephone = homephone; this.email = email; this.directory = directory; this.shell = shell;        }        public override string ToString()        {            var gecos = string.Join(strv,  string[] { fullname, office, extension, homephone, email });            return string.Join(strv,  string[] { account, password, UID.ToString(), GID.ToString(), gecos, directory, shell });        }    }    class Program    {        static void Main(string[] args)        {            var jsmith =  PasswordRecord(strv, strv, 1001, 1000, strv, strv, strv, strv, """",                 strv, strv);            var jdoe =  PasswordRecord(strv, strv, 1002, 1000, strv, strv, strv, strv, """", strv,                 strv);            var xyz =  PasswordRecord(strv, strv, 1003, 1000, strv, strv, strv, strv, """", strv, strv);             // Write these records out in the typical system format.             File.WriteAllLines(strv,  string[] { jsmith.ToString(), jdoe.ToString() });             // Append a new record to the file and close the file again.            File.AppendAllText(strv, xyz.ToString());             // Open the file and demonstrate the new record has indeed written to the end.            string[] lines = File.ReadAllLines(strv);            Console.WriteLine(strv + lines[2]);        }    }} "
"int[] intArray = { 1, 2, 3, 4, 5 };// Simplest method:  LINQ, functionalint[] squares1 = intArray.Select(x => x * x).ToArray(); // Slightly fancier: LINQ, query expressionint[] squares2 = (from x in intArray                  select x * x).ToArray(); // Or, if you only want to call a function on each element, just use foreachforeach (var i in intArray)    Console.WriteLine(i * i);using System;  static class Program{  // Purpose: Apply a callback (or anonymous method) to an Array  // Output: Prints the squares of an int array to the console.  // Compiler: Visual Studio 2005  // Framework: .net 2   [STAThread]  public static void Main()   {    int[] intArray = { 1, 2, 3, 4, 5 };     // Using a callback,    Console.WriteLine(strv);    Array.ForEach<int>(intArray, PrintSquare);     // or using an anonymous method:    Console.WriteLine(strv);    Array.ForEach<int>    (      intArray,      delegate(int value)       {        Console.WriteLine(value * value);          });  }   public static void PrintSquare(int value)   {     Console.WriteLine(value * value);  }}"
" static int Fib(int n){    if (n < 0) throw  ArgumentException(strv, strv);     Func<int, int> fib = null; // Must be known, before we can assign recursively to it.    fib = p => p > 1 ? fib(p - 2) + fib(p - 1) : p;    return fib(n);} "
"using System;using System.Drawing;using System.Windows.Forms; namespace BasicAnimation{  class BasicAnimationForm : Form  {    bool isReverseDirection;    Label textLabel;    Timer timer;     internal BasicAnimationForm()    {      this.Size =  Size(150, 75);      this.Text = strv;       textLabel =  Label();      textLabel.Text = strv;      textLabel.Location =  Point(3,3);      textLabel.AutoSize = true;      textLabel.Click +=  EventHandler(textLabel_OnClick);      this.Controls.Add(textLabel);       timer =  Timer();      timer.Interval = 500;      timer.Tick +=  EventHandler(timer_OnTick);      timer.Enabled = true;       isReverseDirection = false;    }     private void timer_OnTick(object sender, EventArgs e)    {      string oldText = textLabel.Text, newText;      if(isReverseDirection)        newText = oldText.Substring(1, oldText.Length - 1) + oldText.Substring(0, 1);      else        newText = oldText.Substring(oldText.Length - 1, 1) + oldText.Substring(0, oldText.Length - 1);      textLabel.Text = newText;    }     private void textLabel_OnClick(object sender, EventArgs e)    {      isReverseDirection = !isReverseDirection;    }  }    class Program   {      static void Main()      {	Application.Run( BasicAnimationForm());      }   }}"
"public static void Main(){    var lookupTable = File.ReadLines(strv).ToLookup(line => AnagramKey(line));    var query = from a in lookupTable        orderby a.Key.Length descending        let deranged = FindDeranged(a)        where deranged != null        select deranged[0] + strv + deranged[1];    Console.WriteLine(query.FirstOrDefault());} static string AnagramKey(string word) =>  string(word.OrderBy(c => c).ToArray()); static string[] FindDeranged(IEnumerable<string> anagrams) => (    from first in anagrams    from second in anagrams    where !second.Equals(first)        && Enumerable.Range(0, first.Length).All(i => first[i] != second[i])    select  [] { first, second })    .FirstOrDefault(); "
" using System;using System.Drawing;using System.Windows.Forms; class CSharpPendulum{    Form _form;    Timer _timer;     double _angle = Math.PI / 2,            _angleAccel,            _angleVelocity = 0,            _dt = 0.1;     int _length = 50;     [STAThread]    static void Main()    {        var p =  CSharpPendulum();    }     public CSharpPendulum()    {        _form =  Form() { Text = strv, Width = 200, Height = 200 };        _timer =  Timer() { Interval = 30 };         _timer.Tick += delegate(object sender, EventArgs e)        {            int anchorX = (_form.Width / 2) - 12,                anchorY = _form.Height / 4,                ballX = anchorX + (int)(Math.Sin(_angle) * _length),                ballY = anchorY + (int)(Math.Cos(_angle) * _length);             _angleAccel = -9.81 / _length * Math.Sin(_angle);            _angleVelocity += _angleAccel * _dt;            _angle += _angleVelocity * _dt;             Bitmap dblBuffer =  Bitmap(_form.Width, _form.Height);            Graphics g = Graphics.FromImage(dblBuffer);            Graphics f = Graphics.FromHwnd(_form.Handle);             g.DrawLine(Pens.Black,  Point(anchorX, anchorY),  Point(ballX, ballY));            g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);            g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);             f.Clear(Color.White);            f.DrawImage(dblBuffer,  Point(0, 0));            };         _timer.Start();        Application.Run(_form);    }     } "
"using System;using System.Collections.Generic; public class Amb : IDisposable{    List<IValueSet> streams =  List<IValueSet>();    List<IAssertOrAction> assertsOrActions =  List<IAssertOrAction>();    volatile bool stopped = false;     public IAmbValue<T> DefineValues<T>(params T[] values)    {        return DefineValueSet(values);    }     public IAmbValue<T> DefineValueSet<T>(IEnumerable<T> values)    {        ValueSet<T> stream =  ValueSet<T>();        stream.Enumerable = values;        streams.Add(stream);        return stream;    }     public Amb Assert(Func<bool> function)    {        assertsOrActions.Add( AmbAssert()        {            Level = streams.Count,            IsValidFunction = function        });        return this;    }     public Amb Perform(Action action)    {        assertsOrActions.Add( AmbAction()        {            Level = streams.Count,            Action = action        });        return this;    }     public void Stop()    {        stopped = true;    }     public void Dispose()    {        RunLevel(0, 0);        if (!stopped)        {            throw  AmbException();        }    }     void RunLevel(int level, int actionIndex)    {        while (actionIndex < assertsOrActions.Count && assertsOrActions[actionIndex].Level <= level)        {            if (!assertsOrActions[actionIndex].Invoke() || stopped)                return;            actionIndex++;        }        if (level < streams.Count)        {            using (IValueSetIterator iterator = streams[level].CreateIterator())            {                while (iterator.MoveNext())                {                    RunLevel(level + 1, actionIndex);                }            }        }    }     interface IValueSet    {        IValueSetIterator CreateIterator();    }     interface IValueSetIterator : IDisposable    {        bool MoveNext();    }     interface IAssertOrAction    {        int Level { get; }        bool Invoke();    }     class AmbAssert : IAssertOrAction    {        internal int Level;        internal Func<bool> IsValidFunction;         int IAssertOrAction.Level { get { return Level; } }         bool IAssertOrAction.Invoke()        {            return IsValidFunction();        }    }     class AmbAction : IAssertOrAction    {        internal int Level;        internal Action Action;         int IAssertOrAction.Level { get { return Level; } }         bool IAssertOrAction.Invoke()        {            Action(); return true;        }    }     class ValueSet<T> : IValueSet, IAmbValue<T>, IValueSetIterator    {        internal IEnumerable<T> Enumerable;        private IEnumerator<T> enumerator;         public T Value { get { return enumerator.Current; } }         public IValueSetIterator CreateIterator()        {            enumerator = Enumerable.GetEnumerator();            return this;        }         public bool MoveNext()        {            return enumerator.MoveNext();        }         public void Dispose()        {            enumerator.Dispose();        }    }} public interface IAmbValue<T>{    T Value { get; }} public class AmbException : Exception{    public AmbException() : base(strv) { }}    // original problem    using (Amb amb =  Amb())    {        var set1 = amb.DefineValues(strv, strv, strv);        var set2 = amb.DefineValues(strv, strv, strv);        var set3 = amb.DefineValues(strv, strv, strv);        var set4 = amb.DefineValues(strv, strv);         amb.Assert(() => IsJoinable(set1.Value, set2.Value));        amb.Assert(() => IsJoinable(set2.Value, set3.Value));        amb.Assert(() => IsJoinable(set3.Value, set4.Value));         amb.Perform(() =>            {                System.Console.WriteLine(strv, set1.Value, set2.Value, set3.Value, set4.Value);                amb.Stop();            });    }    // problem from http://www.randomhacks.net/articles/2005/10/11/amb-operator    using (Amb amb =  Amb())    {        IAmbValue<int> x = amb.DefineValues(1, 2, 3);        IAmbValue<int> y = amb.DefineValues(4, 5, 6);        amb.Assert(() => x.Value * y.Value == 8);        amb.Perform(() =>            {                System.Console.WriteLine(strv, x.Value, y.Value);                amb.Stop();            });    }"
"using System;using System.Collections.Generic;using System.Linq; namespace RosettaCode.AmicablePairs{    internal static class Program {        private const int Limit = 20000;                 private static void Main()        {            foreach (var pair in GetPairs(Limit))            {                Console.WriteLine(strv, pair.Item1, pair.Item2);            }        }         private static IEnumerable<Tuple<int, int>> GetPairs(int max)        {            List<int> divsums =                Enumerable.Range(0, max + 1).Select(i => ProperDivisors(i).Sum()).ToList();            for(int i=1; i<divsums.Count; i++) {                int sum = divsums[i];                if(i < sum && sum <= divsums.Count && divsums[sum] == i) {                    yield return  Tuple<int, int>(i, sum);                }            }        }         private static IEnumerable<int> ProperDivisors(int number)        {            return                Enumerable.Range(1, number / 2)                    .Where(divisor => number % divisor == 0);        }    }}"
"using System;using System.Collections.Generic;using System.Linq; namespace AlmostPrime{    class Program    {        static void Main(string[] args)        {            foreach (int k in Enumerable.Range(1, 5))            {                KPrime kprime =  KPrime() { K = k };                Console.WriteLine(strv,                    k, string.Join<int>(strv, kprime.GetFirstN(10)));            }        }    }     class KPrime    {        public int K { get; set; }         public bool IsKPrime(int number)        {            int primes = 0;            for (int p = 2; p * p <= number && primes < K; ++p)            {                while (number % p == 0 && primes < K)                {                    number /= p;                    ++primes;                }            }            if (number > 1)            {                ++primes;            }            return primes == K;        }         public List<int> GetFirstN(int n)        {            List<int> result =  List<int>();            for (int number = 2; result.Count < n; ++number)            {                if (IsKPrime(number))                {                    result.Add(number);                }            }            return result;        }    }}"
"using System;using System.IO;using System.Linq;using System.Net;using System.Text.RegularExpressions; namespace Anagram{    class Program    {        const string DICO_URL = strv;         static void Main( string[] args )        {            WebRequest request = WebRequest.Create(DICO_URL);            string[] words;            using (StreamReader sr =  StreamReader(request.GetResponse().GetResponseStream(), true)) {                words = Regex.Split(sr.ReadToEnd(), @strv);            }            var groups = from string w in words                         group w by string.Concat(w.OrderBy(x => x)) into c                         group c by c.Count() into d                         orderby d.Key descending                         select d;            foreach (var c in groups.First()) {                Console.WriteLine(string.Join(strv, c));            }        }    }}"
" using System;    public class AksTest    {        static long[] c =  long[100];         static void Main(string[] args)        {        for (int n = 0; n < 10; n++) {		coef(n);		Console.Write(strv + n + strv);		show(n);		Console.WriteLine(strv);	}	 	   Console.Write(strv);	  for (int n = 1; n <= 63; n++)	     if (is_prime(n))	       Console.Write(n + strv); 	    Console.WriteLine('');            Console.ReadLine();        }         static void coef(int n)        {            int i, j;             if (n < 0 || n > 63) System.Environment.Exit(0);// gracefully deal with range issue             for (c[i = 0] = 1L; i < n; c[0] = -c[0], i++)                for (c[1 + (j = i)] = 1L; j > 0; j--)                    c[j] = c[j - 1] - c[j];        }         static bool is_prime(int n)        {            int i;             coef(n);            c[0] += 1;            c[i = n] -= 1;             while (i-- != 0 && (c[i] % n) == 0) ;             return i < 0;        }         static void show(int n)	    {		    do {                Console.Write(strv + c[n] + strv + n);		    }while (n-- != 0);	    }    } "
unsafe{  int i = 5;  void* address_of_i = &i;}
"using System;class ColumnAlignerProgram{    delegate string Justification(string s, int width);     static string[] AlignColumns(string[] lines, Justification justification)    {        const char Separator = '$';        // build input table and calculate columns count        string[][] table =  string[lines.Length][];        int columns = 0;        for (int i = 0; i < lines.Length; i++)        {            string[] row = lines[i].TrimEnd(Separator).Split(Separator);            if (columns < row.Length) columns = row.Length;            table[i] = row;        }        // create formatted table        string[][] formattedTable =  string[table.Length][];        for (int i = 0; i < formattedTable.Length; i++)        {            formattedTable[i] =  string[columns];        }        for (int j = 0; j < columns; j++)        {            // get max column width            int columnWidth = 0;            for (int i = 0; i < table.Length; i++)            {                if (j < table[i].Length && columnWidth < table[i][j].Length)                    columnWidth = table[i][j].Length;            }            // justify column cells            for (int i = 0; i < formattedTable.Length; i++)            {                if (j < table[i].Length)                    formattedTable[i][j] = justification(table[i][j], columnWidth);                else                     formattedTable[i][j] =  String(' ', columnWidth);            }        }        // create result        string[] result =  string[formattedTable.Length];        for (int i = 0; i < result.Length; i++)        {            result[i] = String.Join(strv, formattedTable[i]);        }        return result;    }     static string JustifyLeft(string s, int width) { return s.PadRight(width); }    static string JustifyRight(string s, int width) { return s.PadLeft(width); }    static string JustifyCenter(string s, int width)     {         return s.PadLeft((width + s.Length) / 2).PadRight(width);     }     static void Main()    {        string[] input = {                strv,            strv,            strv,            strv,            strv,            strv,        };         foreach (string line in AlignColumns(input, JustifyCenter))        {            Console.WriteLine(line);        }    }}"
"// ----------------------------------------------------------------------------------------------//  //  Program.cs - DynamicClassVariable//  //     Mikko Puonti, 2013// // ---------------------------------------------------------------------------------------------- using System;using System.Dynamic; namespace DynamicClassVariable{    internal static class Program    {        #region Static Members         private static void Main()        {            // To enable late binding, we must use dynamic keyword            // ExpandoObject readily implements IDynamicMetaObjectProvider which allows us to do some dynamic magic             dynamic sampleObj =  ExpandoObject();            // Adding a new property            sampleObj.bar = 1;            Console.WriteLine( strv, sampleObj.bar );             // We can also add dynamically methods and events to expando object             // More information: http://msdn.microsoft.com/en-us/library/system.dynamic.expandoobject.aspx            // This sample only show very small part of dynamic language features - there is lot's more             Console.WriteLine( strv );            Console.ReadKey();        }         #endregion    }}"
 // Requires adding a reference to System.DirectoryServices var objDE =  System..DirectoryEntry(strv); 
"using System;using System.Threading.Tasks; using static System..Stopwatch;using static System.Math;using static System..Thread; class ActiveObject{    static double timeScale = 1.0 / Frequency;     Func<double, double> func;    Task updateTask;    double integral;    double value;    long timestamp0, timestamp;     public ActiveObject(Func<double, double> input)    {        timestamp0 = timestamp = GetTimestamp();        func = input;        value = func(0);        updateTask = Integrate();    }     public void ChangeInput(Func<double, double> input)    {        lock (updateTask)        {            func = input;        }    }     public double Value    {        get        {            lock (updateTask)            {                return integral;            }        }    }     async Task Integrate()    {        while (true)        {            await Task.Yield();            var newTime = GetTimestamp();            double newValue;             lock (updateTask)            {                newValue = func((newTime - timestamp0) * timeScale);                integral += (newValue + value) * (newTime - timestamp) * timeScale / 2;            }             timestamp = newTime;            value = newValue;        }    }} class Program{    static Func<double, double> Sine(double frequency) =>        t => Sin(2 * PI * frequency * t);     static void Main(string[] args)    {        var ao =  ActiveObject(Sine(0.5));        Sleep(TimeSpan.FromSeconds(2));        ao.ChangeInput(t => 0);        Sleep(TimeSpan.FromSeconds(0.5));        Console.WriteLine(ao.Value);    }}"
"using System; class Program{    static Func<dynamic, dynamic> Foo(dynamic n)    {        return i => n += i;    }     static void Main(string[] args)    {        var x = Foo(1);        x(5);        Foo(3);        Console.WriteLine(x(2.3));    }}"
"using System;using System.Linq; public class Program{    public static void Main()    {        int abundant, deficient, perfect;        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect);        Console.WriteLine($strv);         ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);        Console.WriteLine($strv);    }} public static class ClassifyNumbers{    //Fastest way    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {        int a = 0, d = 0, p = 0;        //For very large bounds, this array can get big.        int[] sum =  int[bound + 1];        for (int divisor = 1; divisor <= bound / 2; divisor++) {            for (int i = divisor + divisor; i <= bound; i += divisor) {                sum[i] += divisor;            }        }        for (int i = 1; i <= bound; i++) {            if (sum[i] < i) d++;            else if (sum[i] > i) a++;            else p++;        }        abundant = a;        deficient = d;        perfect = p;    }     //Much slower, but doesn't use storage    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {        int a = 0, d = 0, p = 0;        for (int i = 1; i < 20001; i++) {            int sum = Enumerable.Range(1, (i + 1) / 2)                .Where(div => div != i && i % div == 0).Sum();            if (sum < i) d++;            else if (sum > i) a++;            else p++;        }        abundant = a;        deficient = d;        perfect = p;    }}"
abstract class Class1{   public abstract void method1();    public int method2()   {      return 0;   }}
"using System;class Program{    public static long Ackermann(long m, long n)    {        if(m > 0)        {            if (n > 0)                return Ackermann(m - 1, Ackermann(m, n - 1));            else if (n == 0)                return Ackermann(m - 1, 1);        }        else if(m == 0)        {            if(n >= 0)                 return n + 1;        }         throw  System.ArgumentOutOfRangeException();    }     static void Main()    {        for (long m = 0; m <= 3; ++m)        {            for (long n = 0; n <= 4; ++n)            {                Console.WriteLine(strv, m, n, Ackermann(m, n));            }        }    }}"
"using System;using System.Collections.Generic;using System.Linq;using System.Numerics; namespace NamesOfGod{    public class RowSummer    {        const int N = 100000;        public BigInteger[] p;         private void calc(int n)            /* Translated from C */        {            p[n] = 0;             for (int k = 1; k <= n; k++)            {                int d = n - k * (3 * k - 1) / 2;                if (d < 0) break;                 if ((k & 1) != 0) p[n] += p[d];                else p[n] -= p[d];                 d -= k;                if (d < 0) break;                 if ((k & 1) != 0) p[n] += p[d];                else p[n] -= p[d];            }         }        public void PrintSums()            /* translated from C */        {            p =  BigInteger[N + 1];            var idx =  int[] { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };            int at = 0;             p[0] = 1;             for (int i = 1; idx[at] > 0; i++)            {                calc(i);                if (i != idx[at]) continue;                Console.WriteLine(i + "":"" + p[i]);                at++;            }        }    }     public class RowPrinter        /* translated from Python */    {        List<List<int>> cache;        public RowPrinter()        {            cache =  List<List<int>> {  List<int> { 1 } };        }        public List<int> cumu(int n)        {            for (int l = cache.Count; l < n + 1; l++)            {                var r =  List<int> { 0 };                for (int x = 1; x < l + 1; x++)                    r.Add(r.Last() + cache[l - x][Math.Min(x, l - x)]);                cache.Add(r);            }            return cache[n];        }        public List<int> row(int n)        {            var r = cumu(n);            return (from i in Enumerable.Range(0, n) select r[i + 1] - r[i]).ToList();        }        public void PrintRows()        {            var rows = Enumerable.Range(1, 25).Select(x => string.Join(strv, row(x))).ToList();            var widest = rows.Last().Length;            foreach (var r in rows)                Console.WriteLine( String(' ', (widest - r.Length) / 2) + r);        }    }     class Program    {        static void Main(string[] args)         {            var rpr =  RowPrinter();            rpr.PrintRows();            var ros =  RowSummer();            ros.PrintSums();            Console.ReadLine();        }    }} "
"using System;using System.IO;// Needed for the method.using System.Text.RegularExpressions;using System.Collections.Generic; void Main(){   string blocks = strv;   List<string> words =  List<string>() {      strv, strv, strv, strv, strv, strv, strv   };    foreach(var word in words)   {      Console.WriteLine(strv, word, CheckWord(blocks, word));   }} bool CheckWord(string blocks, string word){   for(int i = 0; i < word.Length; ++i)   {      int length = blocks.Length;      Regex rgx =  Regex(strv+word[i]+strv+word[i]+strv, RegexOptions.IgnoreCase);      blocks = rgx.Replace(blocks, strv, 1);      if(blocks.Length == length) return false;   }   return true;} using System.Collections.Generic;using System.Linq; void Main(){	List<string> blocks =	 List<string>() { strv, strv, strv, strv, strv, strv, strv, strv, strv, strv,		strv, strv, strv, strv, strv, strv, strv, strv, strv, strv };	List<string> words =  List<string>() {		strv, strv, strv, strv, strv, strv, strv}; 	var solver =  ABC(blocks); 	foreach( var word in words)	{		Console.WriteLine(strv, word, solver.CanMake(word));	}} class ABC{	readonly Dictionary<char, List<int>> _blockDict =  Dictionary<char, List<int>>();	bool[] _used;	int _nextBlock; 	readonly List<string> _blocks; 	private void AddBlockChar(char c)	{		if (!_blockDict.ContainsKey(c))		{			_blockDict[c] =  List<int>();		}		_blockDict[c].Add(_nextBlock);	} 	private void AddBlock(string block)	{		AddBlockChar(block[0]);		AddBlockChar(block[1]);		_nextBlock++;	} 	public ABC(List<string> blocks)	{		_blocks = blocks;		foreach (var block in blocks)		{			AddBlock(block);		}	} 	public bool CanMake(string word)	{		word = word.ToLower();		if (word.Length > _blockDict.Count)		{			return false;		}		_used =  bool[_blocks.Count];		return TryMake(word);	} 	public bool TryMake(string word)	{		if (word == string.Empty)		{			return true;		}		var blocks = _blockDict[word[0]].Where(b => !_used[b]);		foreach (var block in blocks)		{			_used[block] = true;			if (TryMake(word.Substring(1)))			{				return true;			}			_used[block] = false;		}		return false;	}} "
"using System;using System.Linq; class Program{    static void Main()    {        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());    }}using System; class Program{    static void Main()    {        string input = Console.ReadLine();        int index = input.IndexOf(strv);        int num1 = int.Parse(input.Substring(0, index));        int num2 = int.Parse(input.Substring(index + 1));        int sum = num1 + num2;        Console.WriteLine(sum.ToString());    }}"
"using System;using System.Drawing;using System.Linq;using System.Windows.Forms; public class FifteenPuzzle{    const int gridSize = 4; //Standard 15 puzzle is 4x4    const bool evenSized = gridSize % 2 == 0;    const int blockCount = gridSize * gridSize;    const int last = blockCount - 1;    const int buttonSize = 50;    const int buttonMargin = 3; //default = 3    const int formEdge = 9;    static readonly Random rnd =  Random();    static readonly Font buttonFont =  Font(strv, 15.75F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));    readonly Button[] buttons =  Button[blockCount];    readonly int[] grid =  int[blockCount];    readonly int[] positionOf =  int[blockCount];    int moves = 0;    DateTime start;     public static void Main(string[] args)    {        FifteenPuzzle p =  FifteenPuzzle();        Form f = p.BuildForm();        Application.Run(f);    }     public FifteenPuzzle()    {        for (int i = 0; i < blockCount; i++) {            grid[i] = i;            positionOf[i] = i;        }    }     Form BuildForm()    {        Button startButton =  Button {            Font =  Font(strv, 9.75F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0))),            Size =  Size(86, 23),            Location =  Point(formEdge,                (buttonSize + buttonMargin * 2) * gridSize + buttonMargin + formEdge),            Text = strv,            UseVisualStyleBackColor = true        };        startButton.Click += (sender, e) => Shuffle();         int size = buttonSize * gridSize + buttonMargin * gridSize * 2 + formEdge * 2;        Form form =  Form {            Text = strv,            ClientSize =  Size(width: size, height: size + buttonMargin * 2 + startButton.Height)        };        form.SuspendLayout();        for (int index = 0; index < blockCount; index++) {            Button button =  Button {                Font = buttonFont,                Size =  Size(buttonSize, buttonSize),                //Margin = new Padding(buttonMargin),                Text = (index + 1).ToString(),                UseVisualStyleBackColor = true            };            SetLocation(button, index);            form.Controls.Add(button);            buttons[index] = button;            int i = index;            button.Click += (sender, e) => ButtonClick(i);        }        form.Controls.Add(startButton);        form.ResumeLayout();        return form;    }     void ButtonClick(int i)    {        if (buttons[last].Visible) return;        int target = positionOf[i];        if (positionOf[i] / gridSize == positionOf[last] / gridSize) {            while (positionOf[last] < target) {                Swap(last, grid[positionOf[last] + 1]);                moves++;            }            while (positionOf[last] > target) {                Swap(last, grid[positionOf[last] - 1]);                moves++;            }        } else if (positionOf[i] % gridSize == positionOf[last] % gridSize) {            while (positionOf[last] < target) {                Swap(last, grid[positionOf[last] + gridSize]);                moves++;            }            while (positionOf[last] > target) {                Swap(last, grid[positionOf[last] - gridSize]);                moves++;            }        }        if (Solved()) {            TimeSpan elapsed = DateTime.Now - start;            elapsed = TimeSpan.FromSeconds(Math.Round(elapsed.TotalSeconds, 0));            buttons[last].Visible = true;            MessageBox.Show($strv);        }    }     bool Solved() => Enumerable.Range(0, blockCount - 1).All(i => positionOf[i] == i);     static void SetLocation(Button button, int index)    {        int row = index / gridSize, column = index % gridSize;        button.Location =  Point(            (buttonSize + buttonMargin * 2) * column + buttonMargin + formEdge,            (buttonSize + buttonMargin * 2) * row + buttonMargin + formEdge);    }     void Shuffle()    {        for (int i = 0; i < blockCount; i++) {            int r = rnd.Next(i, blockCount);            int g = grid[r];            grid[r] = grid[i];            grid[i] = g;        }        for (int i = 0; i < blockCount; i++) {            positionOf[grid[i]] = i;            SetLocation(buttons[grid[i]], i);        }        if (!Solvable()) Swap(0, 1); //Swap any 2 blocks         buttons[last].Visible = false;        moves = 0;        start = DateTime.Now;    }     bool Solvable()    {        bool parity = true;        for (int i = 0; i < blockCount - 2; i++) {            for (int j = i + 1; j < blockCount - 1; j++) {                if (positionOf[j] < positionOf[i]) parity = !parity;            }        }        if (evenSized && positionOf[last] / gridSize % 2 == 0) parity = !parity;        return parity;    }     void Swap(int a, int b)    {        Point location = buttons[a].Location;        buttons[a].Location = buttons[b].Location;        buttons[b].Location = location;         int p = positionOf[a];        positionOf[a] = positionOf[b];        positionOf[b] = p;         grid[positionOf[a]] = a;        grid[positionOf[b]] = b;    }}"
"namespace ConsoleApplication1{    using System;    class Program    {        static void Main(string[] args)        {            bool[] doors =  bool[100];             //Close all doors to start.            for (int d = 0; d < 100; d++) doors[d] = false;             //For each pass...            for (int p = 0; p < 100; p++)//number of passes            {                //For each door to toggle...                for (int d = 0; d < 100; d++)//door number                {                    if ((d + 1) % (p + 1) == 0)                    {                        doors[d] = !doors[d];                    }                }            }             //Output the results.            Console.WriteLine(""Passes Completed!!!  Here are the results: "");            for (int d = 0; d < 100; d++)            {                if (doors[d])                {                    Console.WriteLine(String.Format(strv, d + 1));                }                else                {                    Console.WriteLine(String.Format(strv, d + 1));                }            }            Console.ReadKey(true);        }    }}namespace ConsoleApplication1{    using System;    class Program    {        static void Main()        {            //The o variable stores the number of the next OPEN door.            int o = 1;             //The n variable is used to help calculate the next value of the o variable.            int n = 0;             //The d variable determines the door to be output next.            for (int d = 1; d <= 100; d++)            {                Console.Write(strv, d);                if (d == o)                {                    Console.WriteLine(strv);                    n++;                    o += 2 * n + 1;                }                else                    Console.WriteLine(strv);            }            Console.ReadKey(true);        }    }}namespace ConsoleApplication1{    using System;    class Program    {        static void Main(string[] args)        {            //Perform the operation.            bool[] doors =  bool[100];            int n = 0;            int d;            while ((d = (++n * n)) <= 100)                doors[d - 1] = true;             //Perform the presentation.            for (d = 0; d < doors.Length; d++)                Console.WriteLine(strv, d + 1, doors[d] ? strv : strv);            Console.ReadKey(true);        }    }}namespace ConsoleApplication1{    using System;    class Program    {        static void Main()        {            bool[] doors =  bool[100];             //The number of passes can be 1-based, but the number of doors must be 0-based.            for (int p = 1; p <= 100; p++)                for (int d = p - 1; d < 100; d += p)                    doors[d] = !doors[d];            for (int d = 0; d < 100; d++)                Console.WriteLine(strv, d + 1, doors[d] ? strv : strv);            Console.ReadKey(true);        }    }}namespace ConsoleApplication1{    using System;    class Program    {        static void Main()        {            double n;             //If the current door number is the perfect square of an integer, say it is open, else say it is closed.            for (int d = 1; d <= 100; d++)                Console.WriteLine(strv, d, (n = Math.Sqrt(d)) == (int)n ? strv : strv);            Console.ReadKey(true);        }    }}"
"using System; class Program{    static void Main(string[] args)    {        for (int i = 99; i > -1; i--)        {            if (i == 0)            {                Console.WriteLine(strv);                Console.WriteLine(strv);                break;            }            if (i == 1)            {                Console.WriteLine(strv);                Console.WriteLine(strv);                Console.WriteLine();            }            else            {                Console.WriteLine(strv, i);                Console.WriteLine(strv, i - 1);                Console.WriteLine();            }        }    }}using System;class Program{    static void Main()    {        Func<int, bool, string> f = (x, y) =>            $strvNo morestrvstrvsstrv on the wallstrv"")}"";        for (int i = 99; i > 0; i--)            Console.WriteLine($""{f(i, true)}{f(i, false)}Take one down, pass it around{f(i - 1, true)}"");    }}using System;using System.Linq; class Program{    static void Main()    {        var query = from total in Enumerable.Range(0,100).Reverse()                    select (total > 0)                        ? string.Format(""{0} bottles of beer on the wall{0} bottles of beerTake one down, pass it around"", total)                        : string.Format(strv, total);         foreach (var item in query)        {            Console.WriteLine(item);        }    }}using System;using System.Globalization;class Program{    const string Vessel = strv;    const string Beverage = strv;    const string Location = strv;     private static string DefaultAction(ref int bottles)    {        bottles--;        return strv;    }     private static string FallbackAction(ref int bottles)    {        bottles += 99;        return strv;    }     private static string Act(ref int bottles)    {        return bottles > 0 ? DefaultAction(ref bottles) : FallbackAction(ref bottles);    }     static void Main()    {        Func<int, string> plural = b => b == 1 ? strv : strv;        Func<int, string> describeCount = b => b == 0 ? strv : b.ToString();        Func<int, string> describeBottles = b => string.Format(strv, describeCount(b), Vessel, plural(b), Beverage);        Action<string> write = s => Console.WriteLine(CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s));        int bottles = 99;        while (true)        {            write(string.Format(strv, describeBottles(bottles), Location));            write(Act(ref bottles));            write(string.Format(strv, describeBottles(bottles), Location));            write(string.Empty);        }    }}class songs{    static void Main(string[] args)    {        beer(3);    }     private static void beer(int bottles)    {        for (int i = bottles; i > 0; i--)        {            if (i > 1)            {                Console.Write(""{0}{1}{2}{3}"",                    i + strv,                    i + strv,                    strv,                    (i - 1) + strv);            }            else                Console.Write(""{0}{1}{2}{3}"",                    i + strv,                    i + strv,                    strv,                    (i - 1) + strv);        }    }}using System;using System.Linq; class Program{    static void Main()    {        BeerBottles().Take(99).ToList().ForEach(Console.WriteLine);	    }     static IEnumerable<String> BeerBottles()    {        int i = 100;        String f = strv;        Func<int, bool, String> booze = (c , b) =>             String.Format(strv, c>0 ? c.ToString() : strv, (c==1 ? strv : strv), b ? strv : strv);         while (--i >= 1)             yield return String.Format(f, booze(i, true), booze(i, false), booze(i - 1, true));    }}string[] bottles = { 	strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv,			strv };  int bottlesLeft = 99;const int FIRST_LINE_SINGULAR = 98;const int FINAL_LINE_SINGULAR = 97;string firstLine = strv;string finalLine = strv;  for (int i = 0; i < 99; i++){	firstLine = bottlesLeft.ToString() + strv;	if (i != FIRST_LINE_SINGULAR)	    firstLine += strv;	firstLine += strv + bottlesLeft.ToString() + strv;	if (i != FIRST_LINE_SINGULAR)	    firstLine += strv;	firstLine += strv; 	Console.WriteLine(firstLine);	Console.WriteLine(strv + bottles[i] + strv);	bottlesLeft--; 	finalLine = bottlesLeft.ToString() + strv;	if (i != FINAL_LINE_SINGULAR)	    finalLine += strv;	finalLine += strv; 	Console.WriteLine(finalLine);	Console.WriteLine();	Console.ReadLine();}public static void BottlesSong(int numberOfBottles){    if (numberOfBottles > 0)    {        Console.WriteLine(strv, numberOfBottles);        Console.WriteLine(strv, numberOfBottles);        Console.WriteLine(strv);        Console.WriteLine(strv, numberOfBottles - 1);        Console.WriteLine();        BottlesSong(--numberOfBottles);    }}"
