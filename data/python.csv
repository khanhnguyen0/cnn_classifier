keywords
"print 'this line must not have leading indentation!'if True:    print 'example: ', foo(3), len(bar)"
"from collections import deque def simplemovingaverage(period):    assert period == int(period) and period > 0, strv     summ = n = 0.0    values = deque([0.0] * period)     
     def sma(x):        nonlocal summ, n         values.append(x)        summ += x - values.popleft()        n = min(n+1, period)        return summ / n     return smafrom collections import deque class Simplemovingaverage():    def __init__(self, period):        assert period == int(period) and period > 0, strv        self.period = period        self.stream = deque()     def __call__(self, n):        stream = self.stream        stream.append(n)    
        streamlength = len(stream)        if streamlength > self.period:            stream.popleft()            streamlength -= 1        if streamlength == 0:            average = 0        else:            average = sum( stream ) / streamlength         return averageif __name__ == '__main__':    for period in [3, 5]:        print (""SIMPLE MOVING AVERAGE (procedural): PERIOD ="", period)        sma = simplemovingaverage(period)        for i in range(1,6):            print (strv % (i, sma(i)))        for i in range(5, 0, -1):            print (strv % (i, sma(i)))    for period in [3, 5]:        print (""SIMPLE MOVING AVERAGE (class based): PERIOD ="", period)        sma = Simplemovingaverage(period)        for i in range(1,6):            print (strv % (i, sma(i)))        for i in range(5, 0, -1):            print (strv % (i, sma(i)))"
"from PIL import Imageimport colorsysimport math if __name__ == strv: 	im = Image.new(strv, (300,300))	radius = min(im.size)/2.0	centre = im.size[0]/2, im.size[1]/2	pix = im.load() 	for x in range(im.width):		for y in range(im.height):			rx = x - centre[0]			ry = y - centre[1]			s = ((x - centre[0])**2.0 + (y - centre[1])**2.0)**0.5 / radius			if s <= 1.0:				h = ((math.atan2(ry, rx) / math.pi) + 1.0) / 2.0				rgb = colorsys.hsv_to_rgb(h, s, 1.0)				pix[x,y] = tuple([int(round(c*255.0)) for c in rgb]) 	im.show()"
"'''
 Bulls and cows. A game pre-dating, and similar to, Mastermind.
''' import random digits = '123456789'size = 4chosen = ''.join(random.sample(digits,size))#print chosen # Debugprint '''I have chosen a number from %s unique digits from 1 to 9 arranged in a random order.
You need to input a %i digit, unique digit number as a guess at what I have chosen''' % (size, size)guesses = 0while True:    guesses += 1    while True:        
        guess = raw_input('Next guess [%i]: ' % guesses).strip()        if len(guess) == size and \           all(char in digits for char in guess) \           and len(set(guess)) == size:            break        print strv % size    if guess == chosen:        print 'Congratulations you guessed correctly in',guesses,'attempts'        break    bulls = cows = 0    for i in range(size):        if guess[i] == chosen[i]:            bulls += 1        elif guess[i] in chosen:            cows += 1    print '  %i Bulls  %i Cows' % (bulls, cows)"
"from decimal import Decimalfrom fractions import Fractionfor n in (Decimal(0), Fraction(0, 1), complex(0), float(0), int(0)):	try:		n1 = n**n	except:		n1 = '<Raised exception>'	try:		n2 = pow(n, n)	except:		n2 = '<Raised exception>'	print('%8s: ** -> %r; pow -> %r' % (n.__class__.__name__, n1, n2))"
"
 
beforeTxt = '''
1100111
1100111
1100111
1100111
1100110
1100110
1100110
1100110
1100110
1100110
1100110
1100110
1111110
0000000
''' 
smallrc01 = '''
00000000000000000000000000000000
01111111110000000111111110000000
01110001111000001111001111000000
01110000111000001110000111000000
01110001111000001110000000000000
01111111110000001110000000000000
01110111100000001110000111000000
01110011110011101111001111011100
01110001111011100111111110011100
00000000000000000000000000000000
''' rc01 = '''
00000000000000000000000000000000000000000000000000000000000
01111111111111111100000000000000000001111111111111000000000
01111111111111111110000000000000001111111111111111000000000
01111111111111111111000000000000111111111111111111000000000
01111111100000111111100000000001111111111111111111000000000
00011111100000111111100000000011111110000000111111000000000
00011111100000111111100000000111111100000000000000000000000
00011111111111111111000000000111111100000000000000000000000
00011111111111111110000000000111111100000000000000000000000
00011111111111111111000000000111111100000000000000000000000
00011111100000111111100000000111111100000000000000000000000
00011111100000111111100000000111111100000000000000000000000
00011111100000111111100000000011111110000000111111000000000
01111111100000111111100000000001111111111111111111000000000
01111111100000111111101111110000111111111111111111011111100
01111111100000111111101111110000001111111111111111011111100
01111111100000111111101111110000000001111111111111011111100
00000000000000000000000000000000000000000000000000000000000
''' def intarray(binstring):    '''Change a 2D matrix of 01 chars into a list of lists of ints'''    return [[1 if ch == '1' else 0 for ch in line]             for line in binstring.strip().split()] def chararray(intmatrix):    '''Change a 2d list of lists of 1/0 ints into lines of 1/0 chars'''    return ''.join(''.join(str(p) for p in row) for row in intmatrix) def toTxt(intmatrix):    '''Change a 2d list of lists of 1/0 ints into lines of '#' and '.' chars'''    return ''.join(''.join(('#' if p else '.') for p in row) for row in intmatrix) def neighbours(x, y, image):    '''Return 8-neighbours of point p1 of picture, in order'''    i = image    x1, y1, x_1, y_1 = x+1, y-1, x-1, y+1    #print ((x,y))    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  
            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  
 def transitions(neighbours):    n = neighbours + neighbours[0:1]    
    return sum((n1, n2) == (0, 1) for n1, n2 in zip(n, n[1:])) def zhangSuen(image):    changing1 = changing2 = [(-1, -1)]    while changing1 or changing2:        
        changing1 = []        for y in range(1, len(image) - 1):            for x in range(1, len(image[0]) - 1):                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)                if (image[y][x] == 1 and    
                    P4 * P6 * P8 == 0 and   
                    P2 * P4 * P6 == 0 and   
                    transitions(n) == 1 and 
                    2 <= sum(n) <= 6):      
                    changing1.append((x,y))        for x, y in changing1: image[y][x] = 0        
        changing2 = []        for y in range(1, len(image) - 1):            for x in range(1, len(image[0]) - 1):                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)                if (image[y][x] == 1 and    
                    P2 * P6 * P8 == 0 and   
                    P2 * P4 * P8 == 0 and   
                    transitions(n) == 1 and 
                    2 <= sum(n) <= 6):      
                    changing2.append((x,y))        for x, y in changing2: image[y][x] = 0        #print changing1        #print changing2    return image  if __name__ == '__main__':    for picture in (beforeTxt, smallrc01, rc01):        image = intarray(picture)        print('From:%s' % toTxt(image))        after = zhangSuen(image)        print('To thinned:%s' % toTxt(after))"
"def fib():    memo = [1, 2]    while True:        memo.append(sum(memo))        yield memo.pop(0) def sequence_down_from_n(n, seq_generator):    seq = []    for s in seq_generator():        seq.append(s)        if s >= n: break    return seq[::-1] def zeckendorf(n):    if n == 0: return [0]    seq = sequence_down_from_n(n, fib)    digits, nleft = [], n    for s in seq:        if s <= nleft:            digits.append(1)            nleft -= s        else:            digits.append(0)    assert nleft == 0, 'Check all of n is accounted for'    assert sum(x*y for x,y in zip(digits, seq)) == n, 'Assert digits are correct'    while digits[0] == 0:        
        digits.pop(0)    return digits n = 20print('Fibonacci digit multipliers: %r' % sequence_down_from_n(n, fib))for i in range(n + 1):    print('%3i: %8s' % (i, ''.join(str(d) for d in zeckendorf(i))))n = 20def z(n):    if n == 0 : return [0]    fib = [2,1]    while fib[0] < n: fib[0:0] = [sum(fib[:2])]    dig = []    for f in fib:        if f <= n:            dig, n = dig + [1], n - f        else:            dig += [0]    return dig if dig[0] else dig[1:] for i in range(n + 1):    print('%3i: %8s' % (i, ''.join(str(d) for d in z(i))))"
"def zigzag(n):    indexorder = sorted(((x,y) for x in range(n) for y in range(n)),                    key = lambda (x,y): (x+y, -y if (x+y) % 2 else y) )    return {index: n for n,index in enumerate(indexorder)} def printzz(myarray):    n = int(len(myarray)** 0.5 +0.5)    for x in range(n):        for y in range(n):                print strv % myarray[(x,y)],        print printzz(zigzag(6))def zigzag(n):    def move(i, j):        if j < (n - 1):            return max(0, i-1), j+1        else:            return i+1, j    a = [[0] * n for _ in xrange(n)]    x, y = 0, 0    for v in xrange(n * n):        a[y][x] = v        if (x + y) & 1:            x, y = move(x, y)        else:            y, x = move(y, x)    return a from pprint import pprintpprint(zigzag(5))[[0, 1, 5, 6, 14], [2, 4, 7, 13, 15], [3, 8, 12, 16, 21], [9, 11, 17, 20, 22], [10, 18, 19, 23, 24]] COLS = 9def CX(x, ran):  while True:    x += 2 * next(ran)    yield x    x += 1    yield xran = []d = -1for V in CX(1,iter(list(range(0,COLS,2)) + list(range(COLS-1-COLS%2,0,-2)))):  ran.append(iter(range(V, V+COLS*d, d)))  d *= -1for x in range(0,COLS):  for y in range(x, x+COLS):    print(repr(next(ran[y])).rjust(3), end = ' ')  print()  from __future__ import print_function import math  def zigzag( dimension):    ''' generate the zigzag indexes for a square array
        Exploiting the fact that an array is symmetrical around its
        centre
    '''    NUMBER_INDEXES = dimension ** 2    HALFWAY = NUMBER_INDEXES // 2    KERNEL_ODD = dimension & 1     xy = [0 for _ in range(NUMBER_INDEXES)]    
    ix = 0    iy = 0    
    direction = 1    
    
    for i in range(1, HALFWAY + KERNEL_ODD):        if direction > 0:            
            if iy == 0:                
                ix += 1                direction = -1            else:                ix += 1                iy -= 1         else:            
            if ix == 0:                
                iy += 1                direction = 1            else:                ix -= 1                iy += 1        
        xy[iy * dimension + ix] = i     
    
    for i in range(1, NUMBER_INDEXES):        if xy[i] == 0 :            xy[i] = NUMBER_INDEXES - 1 - xy[NUMBER_INDEXES - 1 - i]     return xy  def main(dim):    zz = zigzag(dim)    print( 'zigzag of {}:'.format(dim))    width = int(math.ceil(math.log10(dim**2)))    for j in range(dim):        for i in range(dim):            print('{:{width}}'.format(zz[j * dim + i], width=width), end=' ')        print()  if __name__ == '__main__':    main(5) "
"import mathdef yinyang(n=3):	radii   = [i * n for i in (1, 3, 6)]	ranges  = [list(range(-r, r+1)) for r in radii]	squares = [[ (x,y) for x in rnge for y in rnge]		   for rnge in ranges]	circles = [[ (x,y) for x,y in sqrpoints		     if math.hypot(x,y) <= radius ]		   for sqrpoints, radius in zip(squares, radii)]	m = {(x,y):' ' for x,y in squares[-1]}	for x,y in circles[-1]:		m[x,y] = '*'	for x,y in circles[-1]:		if x>0: m[(x,y)] = '·'	for x,y in circles[-2]:		m[(x,y+3*n)] = '*'		m[(x,y-3*n)] = '·'	for x,y in circles[-3]:		m[(x,y+3*n)] = '·'		m[(x,y-3*n)] = '*'	return ''.join(''.join(m[(x,y)] for x in reversed(ranges[-1])) for y in ranges[-1])from turtle import * mode('logo') def taijitu(r):   '''
  Draw a classic Taoist taijitu of the given radius centered on the current
  turtle position. The strv are placed along the turtle's heading, the
  filled one in front, the open one behind.
  '''   
  r2, r4, r8 = (r >> s for s in (1, 2, 3))   
  x0, y0 = start = pos()  startcolour = color()  startheading = heading()  color('black', 'black')   
  pendown()  circle(r)   
  begin_fill(); circle(r, 180); circle(r2, 180); circle(-r2, 180); end_fill()   
  setheading(0); penup(); goto(-(r4 + r8) + x0, y0); pendown()  begin_fill(); circle(r8); end_fill()   
  color('white', 'white'); setheading(0); penup(); goto(-(r+r4+r8) + x0, y0); pendown()  begin_fill(); circle(r8); end_fill()    
  penup()  setpos(start)  setheading(startheading)  color(*startcolour)  if __name__ == '__main__':   
  reset()  #hideturtle()  penup()  goto(300, 200)  taijitu(200)  penup()  goto(-150, -150)  taijitu(100)  hideturtle()"
" from logpy import *from logpy.core import lallimport time def lefto(q, p, list):	
	
	
	return membero((q,p), zip(list, list[1:])) def nexto(q, p, list):	
	
	
	return conde([lefto(q, p, list)], [lefto(p, q, list)]) houses = var() zebraRules = lall(	
	(eq, 		(var(), var(), var(), var(), var()), houses),	
	(membero,	('Englishman', var(), var(), var(), 'red'), houses),	
	(membero,	('Swede', var(), var(), 'dog', var()), houses),	
	(membero,	('Dane', var(), 'tea', var(), var()), houses),	
	(lefto,		(var(), var(), var(), var(), 'green'),				(var(), var(), var(), var(), 'white'), houses),	
	(membero,	(var(), var(), 'coffee', var(), 'green'), houses),	
	(membero,	(var(), 'Pall Mall', var(), 'birds', var()), houses),	
	(membero,	(var(), 'Dunhill', var(), var(), 'yellow'), houses),	
	(eq,		(var(), var(), (var(), var(), 'milk', var(), var()), var(), var()), houses),	
	(eq,		(('Norwegian', var(), var(), var(), var()), var(), var(), var(), var()), houses),	
	(nexto,		(var(), 'Blend', var(), var(), var()),				(var(), var(), var(), 'cats', var()), houses),	
	(nexto,		(var(), 'Dunhill', var(), var(), var()),				(var(), var(), var(), 'horse', var()), houses),	
	(membero,	(var(), 'Blue Master', 'beer', var(), var()), houses),	
	(membero,	('German', 'Prince', var(), var(), var()), houses),	
	(nexto,		('Norwegian', var(), var(), var(), var()),				(var(), var(), var(), var(), 'blue'), houses),	
	(nexto,		(var(), 'Blend', var(), var(), var()),				(var(), var(), 'water', var(), var()), houses),	
	(membero,	(var(), var(), var(), 'zebra', var()), houses)) t0 = time.time()solutions = run(0, houses, zebraRules)t1 = time.time()dur = t1-t0 count = len(solutions)zebraOwner = [house for house in solutions[0] if 'zebra' in house][0][0] print strv % (count, dur)print strv % zebraOwnerprint strvfor line in solutions[0]:	print str(line) import psyco; psyco.full() class Content: elems= strvBeer Coffee Milk Tea Water
                         Danish English German Norwegian Swedish
                         Blue Green Red White Yellow
                         Blend BlueMaster Dunhill PallMall Prince
                         Bird Cat Dog Horse Zebrastrv.split()class Test: elems= strv.split()class House: elems= strv.split() for c in (Content, Test, House):  c.values = range(len(c.elems))  for i, e in enumerate(c.elems):    exec strv % (c.__name__, e, i) def finalChecks(M):  def diff(a, b, ca, cb):    for h1 in House.values:      for h2 in House.values:        if M[ca][h1] == a and M[cb][h2] == b:          return h1 - h2    assert False   return abs(diff(Content.Norwegian, Content.Blue,                 Test.Person, Test.Color)) == 1 and \         diff(Content.Green, Content.White,              Test.Color, Test.Color) == -1 and \         abs(diff(Content.Horse, Content.Dunhill,                  Test.Pet, Test.Smoke)) == 1 and \         abs(diff(Content.Water, Content.Blend,                  Test.Drink, Test.Smoke)) == 1 and \         abs(diff(Content.Blend, Content.Cat,                  Test.Smoke, Test.Pet)) == 1 def constrained(M, atest):      if atest == Test.Drink:        return M[Test.Drink][House.Three] == Content.Milk      elif atest == Test.Person:        for h in House.values:          if ((M[Test.Person][h] == Content.Norwegian and               h != House.One) or              (M[Test.Person][h] == Content.Danish and               M[Test.Drink][h] != Content.Tea)):            return False        return True      elif atest == Test.Color:        for h in House.values:          if ((M[Test.Person][h] == Content.English and               M[Test.Color][h] != Content.Red) or              (M[Test.Drink][h] == Content.Coffee and               M[Test.Color][h] != Content.Green)):            return False        return True      elif atest == Test.Smoke:        for h in House.values:          if ((M[Test.Color][h] == Content.Yellow and               M[Test.Smoke][h] != Content.Dunhill) or              (M[Test.Smoke][h] == Content.BlueMaster and               M[Test.Drink][h] != Content.Beer) or              (M[Test.Person][h] == Content.German and               M[Test.Smoke][h] != Content.Prince)):            return False        return True      elif atest == Test.Pet:        for h in House.values:          if ((M[Test.Person][h] == Content.Swedish and               M[Test.Pet][h] != Content.Dog) or              (M[Test.Smoke][h] == Content.PallMall and               M[Test.Pet][h] != Content.Bird)):            return False        return finalChecks(M) def show(M):  for h in House.values:    print strv % House.elems[h],    for t in Test.values:      print strv % Content.elems[M[t][h]],    print def solve(M, t, n):  if n == 1 and constrained(M, t):    if t < 4:      solve(M, Test.values[t + 1], 5)    else:      show(M)      return   for i in xrange(n):    solve(M, t, n - 1)    M[t][0 if n % 2 else i], M[t][n - 1] = \      M[t][n - 1], M[t][0 if n % 2 else i] def main():  M = [[None] * len(Test.elems) for _ in xrange(len(House.elems))]  for t in Test.values:    for h in House.values:      M[t][h] = Content.values[t * 5 + h]   solve(M, Test.Drink, 5) main()from itertools import permutations class Number:elems= strv.split()class Color: elems= strv.split()class Drink: elems= strv.split()class Smoke: elems= strv.split()class Pet:   elems= strv.split()class Nation:elems= strv.split() for c in (Number, Color, Drink, Smoke, Pet, Nation):  for i, e in enumerate(c.elems):    exec strv % (c.__name__, e, i) def show_row(t, data):  print strv % (    t.__name__, t.elems[data[0]],    t.elems[data[1]], t.elems[data[2]],    t.elems[data[3]], t.elems[data[4]]) def main():  perms = list(permutations(range(5)))  for number in perms:    if number[Nation.Norvegian] == Number.One: 
      for color in perms:        if color[Nation.British] == Color.Red: 
          if number[color.index(Color.Blue)] == Number.Two: 
            if number[color.index(Color.White)] - number[color.index(Color.Green)] == 1: 
              for drink in perms:                if drink[Nation.Danish] == Drink.Tea: 
                  if drink[color.index(Color.Green)] == Drink.Coffee:  
                    if drink[number.index(Number.Three)] == Drink.Milk: 
                      for smoke in perms:                        if smoke[Nation.German] == Smoke.Prince: 
                          if drink[smoke.index(Smoke.BlueMaster)] == Drink.Beer: 
                            if smoke[color.index(Color.Yellow)] == Smoke.Dunhill: 
                              if number[smoke.index(Smoke.Blend)] - number[drink.index(Drink.Water)] in (1, -1): 
                                for pet in perms:                                  if pet[Nation.Swedish] == Pet.Dog: 
                                    if pet[smoke.index(Smoke.PallMall)] == Pet.Bird: 
                                      if number[pet.index(Pet.Horse)] - number[smoke.index(Smoke.Dunhill)] in (1, -1): 
                                        if number[smoke.index(Smoke.Blend)] - number[pet.index(Pet.Cat)] in (1, -1): 
                                          print strv                                          show_row(Nation, range(5))                                          show_row(Number, number)                                          show_row(Color, color)                                          show_row(Drink, drink)                                          show_row(Smoke, smoke)                                          show_row(Pet, pet)                                          print main()"
"L = {}n = 2 while 1:         if n in L:                P = L[n]                del L[n] 
        else:                print n                P = [n]         for p in P:                npp = n+p                if npp in L:                        L[npp].add(p)                else:                        L[npp] = set([p])         n += 1"
"import urllibimport re def fix(x):    p = re.compile(r'<[^<]*?>')    return p.sub('', x).replace('&amp;', '&') class YahooSearch:    def __init__(self, query, page=1):               self.query = query        self.page = page        self.url = strv %(self.query, ((self.page - 1) * 10 + 1))        self.content = urllib.urlopen(self.url).read()             def getresults(self):        self.results = []         for i in re.findall('<a class=strv>(.+?)</a></h3></div>(.+?)</div>.*?<span class=url>(.+?)</span>', self.content):             title = fix(i[0])            content = fix(i[1])            url = fix(i[2])             self.results.append(YahooResult(title, content, url))         return self.results     def getnextpage(self):        return YahooSearch(self.query, self.page+1)     search_results = property(fget=getresults)    nextpage = property(fget=getnextpage) class YahooResult:    def __init__(self,title,content,url):        self.title = title        self.content = content        self.url = url 
 x = YahooSearch(strv) for result in x.search_results:    print result.title"
"
 from xml.dom import minidom xmlfile = file(strv) 
xmldoc = minidom.parse(xmlfile).documentElement 
xmldoc = minidom.parseString(strvOmniCorp Store #45x10^3strv).documentElement # alternatively, parse a string 
i = xmldoc.getElementsByTagName(strv) 
firstItemElement = i[0] 
 
for j in xmldoc.getElementsByTagName(strv): 
	print j.childNodes[0].data 
 
namesArray = xmldoc.getElementsByTagName(strv) import xml.etree.ElementTree as ET xml = open('inventory.xml').read()doc = ET.fromstring(xml) doc = ET.parse('inventory.xml')  
 
 
item1 = doc.find(strv)  
 
for p in doc.findall(strv):  
    print strv.format(float(p.text))  
 
names = doc.findall(strv)  
 from lxml import etree xml = open('inventory.xml').read()doc = etree.fromstring(xml) doc = etree.parse('inventory.xml')  
 
item1 = doc.xpath(strv) 
for p in doc.xpath(strv):    print strv.format(float(p.text))  
 names = doc.xpath(strv)  
"
"#!/bin/pythonfrom __future__ import print_functionimport lxmlfrom lxml import etree if __name__==strv: 	parser = etree.XMLParser(dtd_validation=True)	schema_root = etree.XML('''
		<xsd:schema xmlns:xsd=strv>
			<xsd:element name=strv/>
		</xsd:schema>
		''')	schema = etree.XMLSchema(schema_root) 	#Good xml	parser = etree.XMLParser(schema = schema)	try:		root = etree.fromstring(strv, parser)		print (strv)	except lxml.etree.XMLSyntaxError as err:		print (err) 	#Bad xml	parser = etree.XMLParser(schema = schema)	try:		root = etree.fromstring(strv, parser)	except lxml.etree.XMLSyntaxError as err:		print (err)"
">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))>>> [ Y(fac)(i) for i in range(10) ][1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))>>> [ Y(fib)(i) for i in range(10) ][0, 1, 1, 2, 3, 5, 8, 13, 21, 34]Y = lambda f: lambda *args: f(Y(f))(*args)def (Y improver)  ((fn(gen) gen.gen)   (fn(gen)     (fn(n)       ((improver gen.gen) n)))) factorial <- (Y (fn(f)                  (fn(n)                    (if zero?.n                      1                      (n * (f n-1)))))) prn factorial.5"
"import xml.dom.minidom doc = strv<Students>
  <Student Name=strv />
  <Student Name=strv />
  <Student Name=strv />
  <Student Name=strv>
    <Pet Type=strv />
  </Student>
  <Student DateOfBirth=strv />
</Students>strv doc = xml.dom.minidom.parseString(doc) for i in doc.getElementsByTagName(strv):    print i.getAttribute(strv)"
"from xml.dom.minidom import getDOMImplementation dom = getDOMImplementation()document = dom.createDocument(None, strv, None) topElement = document.documentElementfirstElement = document.createElement(strv)topElement.appendChild(firstElement)textNode = document.createTextNode(strv)firstElement.appendChild(textNode) xmlString = document.toprettyxml(strv * 4)from xml.etree import ElementTree as et root = et.Element(strv)et.SubElement(root, strv).text = strvxmlString = et.tostring(root)"
"import win32apiimport win32conimport win32evtlogimport win32securityimport win32evtlogutil ph = win32api.GetCurrentProcess()th = win32security.OpenProcessToken(ph, win32con.TOKEN_READ)my_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0] applicationName = strveventID = 1category = 5	
myType = win32evtlog.EVENTLOG_WARNING_TYPEdescr = [strv, strv]data = ""ApplicationData"".encode(strv) win32evtlogutil.ReportEvent(applicationName, eventID, eventCategory=category, 	eventType=myType, strings=descr, data=data, sid=my_sid)"
"strvScript demonstrating drawing of anti-aliased lines using Xiaolin Wu's line
algorithm
 
usage: python xiaolinwu.py [output-file]
 
strvfrom __future__ import divisionimport sys from PIL import Image  def _fpart(x):    return x - int(x) def _rfpart(x):    return 1 - _fpart(x) def putpixel(img, xy, color, alpha=1):    strvPaints color over the background at the point xy in img.
 
    Use alpha for blending. alpha=1 means a completely opaque foreground.
 
    strv    c = tuple(map(lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg)),                  img.getpixel(xy), color))    img.putpixel(xy, c) def draw_line(img, p1, p2, color):    strv    x1, y1, x2, y2 = p1 + p2    dx, dy = x2-x1, y2-y1    steep = abs(dx) < abs(dy)    p = lambda px, py: ((px,py), (py,px))[steep]     if steep:        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx    if x2 < x1:        x1, x2, y1, y2 = x2, x1, y2, y1     grad = dy/dx    intery = y1 + _rfpart(x1) * grad    def draw_endpoint(pt):        x, y = pt        xend = round(x)        yend = y + grad * (xend - x)        xgap = _rfpart(x + 0.5)        px, py = int(xend), int(yend)        putpixel(img, (px, py), color, _rfpart(yend) * xgap)        putpixel(img, (px, py+1), color, _fpart(yend) * xgap)        return px     xstart = draw_endpoint(p(*p1)) + 1    xend = draw_endpoint(p(*p2))     for x in range(xstart, xend):        y = int(intery)        putpixel(img, p(x, y), color, _rfpart(intery))        putpixel(img, p(x, y+1), color, _fpart(intery))        intery += grad  if __name__ == '__main__':    if len(sys.argv) != 2:        print 'usage: python xiaolinwu.py [output-file]'        sys.exit(-1)     blue = (0, 0, 255)    yellow = (255, 255, 0)    img = Image.new(strv, (500,500), blue)    for a in range(10, 431, 60):        draw_line(img, (10, 10), (490, a), yellow)        draw_line(img, (10, 10), (a, 490), yellow)    draw_line(img, (10, 10), (490, 490), yellow)    filename = sys.argv[1]    img.save(filename)    print 'image saved to', filename"
"from itertools import product, combinations, izip scoring = [0, 1, 3]histo = [[0] * 10 for _ in xrange(4)] for results in product(range(3), repeat=6):    s = [0] * 4    for r, g in izip(results, combinations(range(4), 2)):        s[g[0]] += scoring[r]        s[g[1]] += scoring[2 - r]     for h, v in izip(histo, sorted(s)):        h[v] += 1 for x in reversed(histo):    print x"
">>> from xml.etree import ElementTree as ET>>> from itertools import izip>>> def characterstoxml(names, remarks):	root = ET.Element(strv)	for name, remark in izip(names, remarks):		c = ET.SubElement(root, strv, {'name': name})		c.text = remark	return ET.tostring(root) >>> print characterstoxml(	names = [strv, strv, strv],	remarks = [ strv,		    'Burns: strv',		    'Short & shrift' ] ).replace('><','><')"
" with open(filename, 'w') as f:    f.write(data) "
"py = '''
 #####    #   #   #####  #    #   ####   #    #
 #    #    # #      #    #    #  #    #  ##   #
 #    #     #       #    ######  #    #  # #  #
 #####      #       #    #    #  #    #  #  # #
 #          #       #    #    #  #    #  #   ##
 #          #       #    #    #   ####   #    #
''' lines = py.replace('#', '<<<').replace(' ','X').replace('X', '   ').replace('', ' Y').replace('< ', '<>').split('Y')for i, l in enumerate(lines):     print( '   ' * (len(lines) - i) + l) l = 20h = 11 table = [        strv,        strv,        strv,        strv| |     /      | || |  |_   _    | || |   .' ___  |  | || | |_   ___ `.  | || | |_   ___  |  | || | |_   ___  |  | || |  .' ___  |   | || | |_   ||   _| | || |    |_   _|   | || |    |_   _|   | || | |_  ||_  _|  | || |  |_   _|     | || ||_    /   _|| || ||_   _   _| | || |   .'    `.   | || |  |_   __   | || |  .'   '.     | || | |_   __    | || |   /  ___  |  | || | |  _   _  |  | || ||_   _||_   _|| || ||_  _| |_  _| | || ||_   _||_   _|| || | |_  _||_  _| | || | |_  _||_  _| | || |  |  __   _|  | || |   / _ __ `.  | || |              | |strv,        strv| |    / /   | || |    | |_) |   | || |  / .'   |  | || |   | |   `. | || |   | |_  |  | || |   | |_  |  | || | / .'   |   | || |   | |__| |   | || |      | |     | || |      | |     | || |   | |_/ /    | || |    | |       | || |  |      |  | || |  |   | |   | || |  /  .--.   | || |    | |__) |  | || | /  .-.     | || |   | |__) |   | || |  |  (__ |  | || | |_/ | | |  | || |  | |    | |  | || |    / /   | || |  | | /| |  | || |    / /   | || |    / /   | || |  |_/  / /    | || |  |_/____) |  | || |              | |strv,        strv| |   / ____   | || |    |  __'.   | || |  | |         | || |   | |    | | | || |   |  _|  _   | || |   |  _|      | || | | |    ____  | || |   |  __  |   | || |      | |     | || |   _  | |     | || |   |  __'.    | || |    | |   _   | || |  | | /| |  | || |  | | |   | || |  | |    | |  | || |    |  ___/   | || | | |   | |    | || |   |  __ /    | || |   '.___`-.   | || |     | |      | || |  | '    ' |  | || |   / /    | || |  | |/   |  | || |    > `' <    | || |     /    | || |     .'.' _   | || |    /  ___.'  | || |              | |strv,        strv| | _/ /     | || |   _| |__) |  | || |  `.___.' | || |  _| |___.' / | || |  _| |___/ |  | || |  _| |_       | || | `.___]  _| | || |  _| |  | |_  | || |     _| |_    | || |  | |_' |     | || |  _| |    | || |   _| |__/ |  | || | _| |__| |_ | || | _| |_  |_  | || |   `--'  /  | || |   _| |_      | || |  `-'     | || |  _| |    | || |  |`___) |  | || |    _| |_     | || |   `--' /   | || |    ' /     | || |  |   /  |  | || |  _/ /'`  | || |    _|  |_    | || |   _/ /__/ |  | || |    |_|       | || |              | |strv,        strv| ||____|  |____|| || |  |_______/   | || |   `._____.'  | || | |________.'  | || | |_________|  | || | |_____|      | || |  `._____.'   | || | |____||____| | || |    |_____|   | || |  `.___.'     | || | |____||____| | || |  |________|  | || ||_____||_____|| || ||_____|___| | || |   `.____.'   | || |  |_____|     | || |  `.___._|  | || | |____| |___| | || |  |_______.'  | || |   |_____|    | || |    `.__.'    | || |     /      | || |  |__/  _|  | || | |____||____| | || |   |______|   | || |  |________|  | || |    (_)       | || |              | |strv,        strv,        strv,        strv    ] if __name__ == '__main__':    t = raw_input(""Enter the text to convert :"")    if not t :         t = strv     for i in range(h):        txt = strv        for char in t:            
            if char.isalpha():                val = ord(char.upper()) - 65            elif char == strv:                val= 27            else:                val = 26            begin = val*l            end = val*l + l            txt += table[i][begin:end]        print txt "
"import itertoolsdef writedat(filename, x, y, xprecision=3, yprecision=5):    with open(filename,'w') as f:        for a, b in itertools.izip(x, y):            print >> f, ""%.*g%.*g"" % (xprecision, a, yprecision, b)>>> import math>>> x = [1, 2, 3, 1e11]>>> y = map(math.sqrt, x)>>> y[1.0, 1.4142135623730951, 1.7320508075688772, 316227.76601683791]>>> writedat(strv, x, y)>>> 
...>>> for line in open('sqrt.dat'):...   print line,...1       12       1.41423       1.73211e+011  3.1623e+005def writedat(filename, x, y, xprecision=3, yprecision=5):    with open(filename,'w') as f:        for a, b in zip(x, y):            print(""%.*g%.*g"" % (xprecision, a, yprecision, b), file=f)            #or, using the new-style formatting:            #print(strv.format(xprecision, a, yprecision, b), file=f)"
" from tkinter import *import tkinter.messagebox def maximise():	strvget screenwidth and screenheight, and resize window to that size. 
	Also move to 0,0strv	root.geometry(strv.format(root.winfo_screenwidth(), root.winfo_screenheight(), 0, 0)) def minimise():	strvIconify window to the taskbar. When reopened, the window is 
	unfortunately restored to its original state, NOT its most recent state.strv	root.iconify() def delete():	strv	if tkinter.messagebox.askokcancel(strv,strv):		root.quit() root = Tk() mx=Button(root,text=strv,command=maximise)mx.grid()mx.bind(maximise) mn=Button(root,text=strv,command=minimise)mn.grid()mn.bind(minimise) #catch exit events, including strv on title bar.root.protocol(strv,delete) mainloop() "
"def water_collected(tower):    N = len(tower)    highest_left = [0] + [max(tower[:n]) for n in range(1,N)]    highest_right = [max(tower[n:N]) for n in range(1,N)] + [0]    water_level = [max(min(highest_left[n], highest_right[n]) - tower[n], 0)        for n in range(N)]    print(strv, highest_left)    print(strv, highest_right)    print(strv, water_level)    print(strv, tower)    print(strv, sum(water_level))    print(strv)    return sum(water_level) towers = [[1, 5, 3, 7, 2],    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],    [5, 5, 5, 5],    [5, 6, 7, 8],    [8, 7, 7, 6],    [6, 7, 10, 7, 6]] [water_collected(tower) for tower in towers]"
"from Xlib import X, display class Window:    def __init__(self, display, msg):        self.display = display        self.msg = msg         self.screen = self.display.screen()        self.window = self.screen.root.create_window(            10, 10, 100, 100, 1,            self.screen.root_depth,            background_pixel=self.screen.white_pixel,            event_mask=X.ExposureMask | X.KeyPressMask,            )        self.gc = self.window.create_gc(            foreground = self.screen.black_pixel,            background = self.screen.white_pixel,            )         self.window.map()     def loop(self):        while True:            e = self.display.next_event()             if e.type == X.Expose:                self.window.fill_rectangle(self.gc, 20, 20, 10, 10)                self.window.draw_text(self.gc, 10, 50, self.msg)            elif e.type == X.KeyPress:                raise SystemExit  if __name__ == strv:    Window(display.Display(), strv).loop()import xcbfrom xcb.xproto import *import xcb.render def main():  conn = xcb.connect()  conn.render = conn(xcb.render.key)   setup = conn.get_setup()  root = setup.roots[0].root  depth = setup.roots[0].root_depth  visual = setup.roots[0].root_visual  white = setup.roots[0].white_pixel   window = conn.generate_id()  conn.core.CreateWindow(depth, window, root,                         0, 0, 640, 480, 0,                         WindowClass.InputOutput,                         visual,                         CW.BackPixel | CW.EventMask,                         [ white, EventMask.Exposure |                                  EventMask.KeyPress ])   conn.core.MapWindow(window)  conn.flush()   while True:    event = conn.wait_for_event()     if isinstance(event, ExposeEvent):      color = (0, 0, 65535, 65535)      rectangle = (20, 20, 40, 40)      
      
   
      conn.flush()     elif isinstance(event, KeyPressEvent):      break   conn.disconnect() main()"
import urllibpage = urllib.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl')for line in page:    if ' UTC' in line:        print line.strip()[4:]        breakpage.close()
import globfor filename in glob.glob('/foo/bar/*.mp3'):    print(filename)import osfor filename in os.listdir('/foo/bar'):    if filename.endswith('.mp3'):        print(filename)
"  import Tkinter   w = Tkinter.Tk()  w.mainloop()  from wxPython.wx import *   class MyApp(wxApp):    def OnInit(self):      frame = wxFrame(NULL, -1, strv)      frame.Show(true)      self.SetTopWindow(frame)      return true   app = MyApp(0)  app.MainLoop()  import win32ui  from pywin.mfc.dialog import Dialog   d = Dialog(win32ui.IDD_SIMPLE_INPUT)  d.CreateWindow()  import gtk   window = gtk.Window()  window.show()  gtk.main()  from PyQt4.QtGui import *   app = QApplication([])  win = QWidget()  win.show()   app.exec_()"
"'''
Wireworld implementation.
''' from io import StringIOfrom collections import namedtuplefrom pprint import pprint as ppimport copy WW = namedtuple('WW', 'world, w, h')head, tail, conductor, empty = allstates = 'Ht. '  infile = StringIO('''
tH.........
.   .
   ...
.   .
Ht.. ......
''') def readfile(f):    '''file > initial world configuration'''    world  = [row.rstrip('') for row in f]    height = len(world)    width  = max(len(row) for row in world)    
    nonrow = [ strv % (-width, strv) ]    world  = nonrow + \               [ strv % (-width, row) for row in world ] + \               nonrow       world = [list(row) for row in world]    return WW(world, width, height) def newcell(currentworld, x, y):    istate = currentworld[y][x]    assert istate in allstates, 'Wireworld cell set to unknown value strv' % istate    if istate == head:        ostate = tail    elif istate == tail:        ostate = conductor    elif istate == empty:        ostate = empty    else: 
        n = sum( currentworld[y+dy][x+dx] == head                 for dx,dy in ( (-1,-1), (-1,+0), (-1,+1),                                (+0,-1),          (+0,+1),                                (+1,-1), (+1,+0), (+1,+1) ) )        ostate = head if 1 <= n <= 2 else conductor    return ostate def nextgen(ww):    'compute next generation of wireworld'    world, width, height = ww    newworld = copy.deepcopy(world)    for x in range(1, width+1):        for y in range(1, height+1):            newworld[y][x] = newcell(world, x, y)    return WW(newworld, width, height) def world2string(ww):    return ''.join( ''.join(row[1:-1]).rstrip() for row in ww.world[1:-1] ) ww = readfile(infile)infile.close() for gen in range(10):    print ( (""%3i "" % gen) + '=' * (ww.w-4) + '' )    print ( world2string(ww) )    ww = nextgen(ww)"
"import fnmatchimport os rootPath = '/'pattern = '*.mp3' for root, dirs, files in os.walk(rootPath):    for filename in fnmatch.filter(files, pattern):        print( os.path.join(root, filename))from fnmatch import fnmatchimport os, os.path def print_fnmatches(pattern, dir, files):    for filename in files:        if fnmatch(filename, pattern):            print os.path.join(dir, filename) os.path.walk('/', print_fnmatches, '*.mp3')from path import path rootPath = '/'pattern = '*.mp3' d = path(rootPath)for f in d.walkfiles(pattern):  print f"
"from collections import defaultdict costs  = {'W': {'A': 16, 'B': 16, 'C': 13, 'D': 22, 'E': 17},          'X': {'A': 14, 'B': 14, 'C': 13, 'D': 19, 'E': 15},          'Y': {'A': 19, 'B': 19, 'C': 20, 'D': 23, 'E': 50},          'Z': {'A': 50, 'B': 12, 'C': 50, 'D': 15, 'E': 11}}demand = {'A': 30, 'B': 20, 'C': 70, 'D': 30, 'E': 60}cols = sorted(demand.iterkeys())supply = {'W': 50, 'X': 60, 'Y': 50, 'Z': 50}res = dict((k, defaultdict(int)) for k in costs)g = {}for x in supply:    g[x] = sorted(costs[x].iterkeys(), key=lambda g: costs[x][g])for x in demand:    g[x] = sorted(costs.iterkeys(), key=lambda g: costs[g][x]) while g:    d = {}    for x in demand:        d[x] = (costs[g[x][1]][x] - costs[g[x][0]][x]) if len(g[x]) > 1 else costs[g[x][0]][x]    s = {}    for x in supply:        s[x] = (costs[x][g[x][1]] - costs[x][g[x][0]]) if len(g[x]) > 1 else costs[x][g[x][0]]    f = max(d, key=lambda n: d[n])    t = max(s, key=lambda n: s[n])    t, f = (f, g[f][0]) if d[f] > s[t] else (g[t][0], t)    v = min(supply[f], demand[t])    res[f][t] += v    demand[t] -= v    if demand[t] == 0:        for k, n in supply.iteritems():            if n != 0:                g[k].remove(t)        del g[t]        del demand[t]    supply[f] -= v    if supply[f] == 0:        for k, n in demand.iteritems():            if n != 0:                g[k].remove(f)        del g[f]        del supply[f] for n in cols:    print """", n,printcost = 0for g in sorted(costs):    print g, """",    for n in cols:        y = res[g][n]        if y != 0:            print y,        cost += y * costs[g][n]        print """",    printprint ""Total Cost = "", cost"
"from string import uppercasefrom operator import itemgetter def vigenere_decrypt(target_freqs, input):    nchars = len(uppercase)    ordA = ord('A')    sorted_targets = sorted(target_freqs)     def frequency(input):        result = [[c, 0.0] for c in uppercase]        for c in input:            result[c - ordA][1] += 1        return result     def correlation(input):        result = 0.0        freq = frequency(input)        freq.sort(key=itemgetter(1))         for i, f in enumerate(freq):            result += f[1] * sorted_targets[i]        return result     cleaned = [ord(c) for c in input.upper() if c.isupper()]    best_len = 0    best_corr = -100.0     
    
    for i in xrange(2, len(cleaned) // 20):        pieces = [[] for _ in xrange(i)]        for j, c in enumerate(cleaned):            pieces[j % i].append(c)         
        
        corr = -0.5 * i + sum(correlation(p) for p in pieces)         if corr > best_corr:            best_len = i            best_corr = corr     if best_len == 0:        return (strv, strv)     pieces = [[] for _ in xrange(best_len)]    for i, c in enumerate(cleaned):        pieces[i % best_len].append(c)     freqs = [frequency(p) for p in pieces]     key = strv    for fr in freqs:        fr.sort(key=itemgetter(1), reverse=True)         m = 0        max_corr = 0.0        for j in xrange(nchars):            corr = 0.0            c = ordA + j            for frc in fr:                d = (ord(frc[0]) - c + nchars) % nchars                corr += frc[1] * target_freqs[d]             if corr > max_corr:                m = j                max_corr = corr         key += chr(m + ordA)     r = (chr((c - ord(key[i % best_len]) + nchars) % nchars + ordA)         for i, c in enumerate(cleaned))    return (key, strv.join(r))  def main():    encoded = strv
        MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH
        VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD
        ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS
        FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG
        ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ
        ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS
        JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT
        LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST
        MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH
        QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV
        RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW
        TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO
        SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR
        ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX
        BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB
        BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA
        FWAML ZZRXJ EKAHV FASMU LVVUT TGKstrv     english_frequences = [        0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,        0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,        0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,        0.00978, 0.02360, 0.00150, 0.01974, 0.00074]     (key, decoded) = vigenere_decrypt(english_frequences, encoded)    print strv, key    print ""Text:"", decoded main()"
"Python 3.2.3 (default, May  3 2012, 15:54:42) [GCC 4.6.3] on linux2Type strv, strv or strv for more information.>>> help('pprint.pprint')Help on function pprint in pprint: pprint.pprint = pprint(object, stream=None, indent=1, width=80, depth=None)    Pretty-print a Python object to a stream [default is sys.stdout]. >>> from pprint import pprint>>> for tree in [ (1, 2, 3, 4, 5, 6, 7, 8),	          (1, (( 2, 3 ), (4, (5, ((6, 7), 8))))),	          ((((1, 2), 3), 4), 5, 6, 7, 8) ]:	print(""Tree %r can be pprint'd as:"" % (tree, ))	pprint(tree, indent=1, width=1)   Tree (1, 2, 3, 4, 5, 6, 7, 8) can be pprint'd as:
(1,
 2,
 3,
 4,
 5,
 6,
 7,
 8)
 
Tree (1, ((2, 3), (4, (5, ((6, 7), 8))))) can be pprint'd as:(1, ((2,   3),  (4,   (5,    ((6,      7),     8))))) Tree ((((1, 2), 3), 4), 5, 6, 7, 8) can be pprint'd as:
((((1,
    2),
   3),
  4),
 5,
 6,
 7,
 8)
>>> >>> tree = strv,(strv,(strv,strv,(strv,(strv,strv)),strv,(strv,strv,strv,(strv),strv,(strv,strv))),strv,(strv,strv,(strv,(strv),strv,strv),strv))>>> pprint(tree, width=1)('a', ('b0',  ('c1',   'c2',   ('d',    ('ef',     'gh')),   'c3',   ('i1',    'i2',    'i3',    'jj',    'i4',    ('kk',     'm'))),  'b1',  ('C1',   'C2',   ('D1',    'E',    'D2',    'D3'),   'C3')))>>> copypasteoutput = ('a',...  ('b0',...   ('c1',...    'c2',...    ('d',...     ('ef',...      'gh')),...    'c3',...    ('i1',...     'i2',...     'i3',...     'jj',...     'i4',...     ('kk',...      'm'))),...   'b1',...   ('C1',...    'C2',...    ('D1',...     'E',...     'D2',...     'D3'),...    'C3')))>>> tree == copypasteoutputTrue>>> >>> pprint(tree, width=60)('a', ('b0',  ('c1',   'c2',   ('d', ('ef', 'gh')),   'c3',   ('i1', 'i2', 'i3', 'jj', 'i4', ('kk', 'm'))),  'b1',  ('C1', 'C2', ('D1', 'E', 'D2', 'D3'), 'C3')))>>> >>> mixedtree = ['a', ('b0', ('c1', 'c2', ['d', ('ef', 'gh')], 'c3', ('i1', 'i2', ...              'i3', 'jj', 'i4', ['kk', 'm'])), 'b1', ('C1', 'C2', ('D1', 'E', ...              'D2', 'D3'), 'C3'))]>>> pprint(mixedtree, width=1)['a', ('b0',  ('c1',   'c2',   ['d',    ('ef',     'gh')],   'c3',   ('i1',    'i2',    'i3',    'jj',    'i4',    ['kk',     'm'])),  'b1',  ('C1',   'C2',   ('D1',    'E',    'D2',    'D3'),   'C3'))]>>> pprint(mixedtree, width=60)['a', ('b0',  ('c1',   'c2',   ['d', ('ef', 'gh')],   'c3',   ('i1', 'i2', 'i3', 'jj', 'i4', ['kk', 'm'])),  'b1',  ('C1', 'C2', ('D1', 'E', 'D2', 'D3'), 'C3'))]>>> "
"from PIL import Imageimport randomimport math def generate_voronoi_diagram(width, height, num_cells):	image = Image.new(strv, (width, height))	putpixel = image.putpixel	imgx, imgy = image.size	nx = []	ny = []	nr = []	ng = []	nb = []	for i in range(num_cells):		nx.append(random.randrange(imgx))		ny.append(random.randrange(imgy))		nr.append(random.randrange(256))		ng.append(random.randrange(256))		nb.append(random.randrange(256))	for y in range(imgy):		for x in range(imgx):			dmin = math.hypot(imgx-1, imgy-1)			j = -1			for i in range(num_cells):				d = math.hypot(nx[i]-x, ny[i]-y)				if d < dmin:					dmin = d					j = i			putpixel((x, y), (nr[j], ng[j], nb[j]))	image.save(strv, strv)        image.show() generate_voronoi_diagram(500, 500, 25)"
"import mathimport random def GammaInc_Q( a, x):    a1 = a-1    a2 = a-2    def f0( t ):        return t**a1*math.exp(-t)     def df0(t):        return (a1-t)*t**a2*math.exp(-t)     y = a1    while f0(y)*(x-y) >2.0e-8 and y < x: y += .3    if y > x: y = x     h = 3.0e-4    n = int(y/h)    h = y/n    hh = 0.5*h    gamax = h * sum( f0(t)+hh*df0(t) for t in ( h*j for j in xrange(n-1, -1, -1)))     return gamax/gamma_spounge(a) c = Nonedef gamma_spounge( z):    global c    a = 12     if c is None:       k1_factrl = 1.0       c = []       c.append(math.sqrt(2.0*math.pi))       for k in range(1,a):          c.append( math.exp(a-k) * (a-k)**(k-0.5) / k1_factrl )          k1_factrl *= -k     accm = c[0]    for k in range(1,a):        accm += c[k] / (z+k)    accm *= math.exp( -(z+a)) * (z+a)**(z+0.5)    return accm/z; def chi2UniformDistance( dataSet ):    expected = sum(dataSet)*1.0/len(dataSet)    cntrd = (d-expected for d in dataSet)    return sum(x*x for x in cntrd)/expected def chi2Probability(dof, distance):    return 1.0 - GammaInc_Q( 0.5*dof, 0.5*distance) def chi2IsUniform(dataSet, significance):    dof = len(dataSet)-1    dist = chi2UniformDistance(dataSet)    return chi2Probability( dof, dist ) > significance dset1 = [ 199809, 200665, 199607, 200270, 199649 ]dset2 = [ 522573, 244456, 139979,  71531,  21461 ] for ds in (dset1, dset2):    print strv, ds    dof = len(ds)-1    distance =chi2UniformDistance(ds)    print strv % (dof, distance),    prob = chi2Probability( dof, distance)    print strv%prob,    print strv, strvif chi2IsUniform(ds,0.05) else strv"
"from collections import Counterfrom pprint import pprint as pp def distcheck(fn, repeats, delta):    '''
    Bin the answers to fn() and check bin counts are within +/- delta %
    of repeats/bincount'''    bin = Counter(fn() for i in range(repeats))    target = repeats // len(bin)    deltacount = int(delta / 100. * target)    assert all( abs(target - count) < deltacount                for count in bin.values() ), strv % (                    target, deltacount, [ (key, target - count)                                          for key, count in sorted(bin.items()) ]                    )    pp(dict(bin))"
" from itertools import starmap, cycle def encrypt(message, key):     
    
    message = filter(str.isalpha, message.upper())     
    def enc(c,k): return chr(((ord(k) + ord(c) - 2*ord('A')) % 26) + ord('A'))     return strv.join(starmap(enc, zip(message, cycle(key)))) def decrypt(message, key):     
    def dec(c,k): return chr(((ord(c) - ord(k) - 2*ord('A')) % 26) + ord('A'))     return strv.join(starmap(dec, zip(message, cycle(key))))  text = strvkey = strv encr = encrypt(text, key)decr = decrypt(encr, key) print textprint encrprint decr "
"class Vector:    def __init__(self,m,value):        self.m = m        self.value = value        self.angle = math.degrees(math.atan(self.m))        self.x = self.value * math.sin(math.radians(self.angle))        self.y = self.value * math.cos(math.radians(self.angle))     def __add__(self,vector):        strv
        >>> Vector(1,10) + Vector(1,2)
        Vector:
            - Angular coefficient: 1.0
            - Angle: 45.0 degrees
            - Value: 12.0
            - X component: 8.49
            - Y component: 8.49
        strv        final_x = self.x + vector.x        final_y = self.y + vector.y        final_value = pytagoras(final_x,final_y)        final_m = final_y / final_x        return Vector(final_m,final_value)     def __neg__(self):        return Vector(self.m,-self.value)     def __sub__(self,vector):        return self + (- vector)     def __mul__(self,scalar):        strv
        >>> Vector(4,5) * 2
        Vector:
            - Angular coefficient: 4
            - Angle: 75.96 degrees
            - Value: 10
            - X component: 9.7
            - Y component: 2.43
 
        strv        return Vector(self.m,self.value*scalar)     def __div__(self,scalar):        return self * (1 / scalar)     def __repr__(self):        strv
        Returns a nicely formatted list of the properties of the Vector.
 
        >>> Vector(1,10)
        Vector:
            - Angular coefficient: 1
            - Angle: 45.0 degrees
            - Value: 10
            - X component: 7.07
            - Y component: 7.07
 
        strv        return strvVector:
    - Angular coefficient: {}
    - Angle: {} degrees
    - Value: {}
    - X component: {}
    - Y component: {}strv.format(self.m.__round__(2),               self.angle.__round__(2),               self.value.__round__(2),               self.x.__round__(2),               self.y.__round__(2))"
"def tobits(n, _group=8, _sep='_', _pad=False):    'Express n as binary bits with separator'    bits = '{0:b}'.format(n)[::-1]    if _pad:        bits = '{0:0{1}b}'.format(n,                                  ((_group+len(bits)-1)//_group)*_group)[::-1]        answer = _sep.join(bits[i:i+_group]                                 for i in range(0, len(bits), _group))[::-1]        answer = '0'*(len(_sep)-1) + answer    else:        answer = _sep.join(bits[i:i+_group]                           for i in range(0, len(bits), _group))[::-1]    return answer def tovlq(n):    return tobits(n, _group=7, _sep='1_', _pad=True) def toint(vlq):    return int(''.join(vlq.split('_1')), 2)     def vlqsend(vlq):    for i, byte in enumerate(vlq.split('_')[::-1]):        print('Sent byte {0:3}: {1:#04x}'.format(i, int(byte,2)))>>> for n in (254, 255, 256, 257, -2+(1<<16), -1+(1<<16), 1<<16, 1+(1<<16), 0x200000, 0x1fffff ):    print('int: %7i bin: %26s vlq: %35s vlq->int: %7i' % (n, tobits(n,_pad=True), tovlq(n), toint(tovlq(n))))  int:     254 bin:                   11111110 vlq:                   00000001_11111110 vlq->int:     254int:     255 bin:                   11111111 vlq:                   00000001_11111111 vlq->int:     255int:     256 bin:          00000001_00000000 vlq:                   00000010_10000000 vlq->int:     256int:     257 bin:          00000001_00000001 vlq:                   00000010_10000001 vlq->int:     257int:   65534 bin:          11111111_11111110 vlq:          00000011_11111111_11111110 vlq->int:   65534int:   65535 bin:          11111111_11111111 vlq:          00000011_11111111_11111111 vlq->int:   65535int:   65536 bin: 00000001_00000000_00000000 vlq:          00000100_10000000_10000000 vlq->int:   65536int:   65537 bin: 00000001_00000000_00000001 vlq:          00000100_10000000_10000001 vlq->int:   65537int: 2097152 bin: 00100000_00000000_00000000 vlq: 00000001_10000000_10000000_10000000 vlq->int: 2097152int: 2097151 bin: 00011111_11111111_11111111 vlq:          01111111_11111111_11111111 vlq->int: 2097151>>> vlqsend(tovlq(0x200000))Sent byte   0: 0x80Sent byte   1: 0x80Sent byte   2: 0x80Sent byte   3: 0x01>>> vlqsend(tovlq(0x1fffff))Sent byte   0: 0xffSent byte   1: 0xffSent byte   2: 0x7f>>> "
"def crossp(a, b):    '''Cross product of two 3D vectors'''    assert len(a) == len(b) == 3, 'For 3D vectors only'    a1, a2, a3 = a    b1, b2, b3 = b    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1) def dotp(a,b):    '''Dot product of two eqi-dimensioned vectors'''    assert len(a) == len(b), 'Vector sizes must match'    return sum(aterm * bterm for aterm,bterm in zip(a, b)) def scalartriplep(a, b, c):    '''Scalar triple product of three vectors: strv'''    return dotp(a, crossp(b, c)) def vectortriplep(a, b, c):    '''Vector triple product of three vectors: strv'''    return crossp(a, crossp(b, c)) if __name__ == '__main__':    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)    print(strv % (a, b, c))    print(strv % dotp(a,b))    print(strv  % (crossp(a,b),))    print(strv % scalartriplep(a, b, c))    print(strv % (vectortriplep(a, b, c),))"
"def print_all(*things):    for x in things:        print xprint_all(4, 3, 5, 6, 4, 3)print_all(4, 3, 5)print_all(strv, strv, strv, strv)args = [strv, strv, strv, strv]print_all(*args)>>> def printargs(*positionalargs, **keywordargs):	print ""POSITIONAL ARGS:  "" + ""  "".join(repr(x) for x in positionalargs)	print ""KEYWORD ARGS:  "" + '  '.join(		strv % (k,v) for k,v in keywordargs.iteritems())  >>> printargs(1,'a',1+0j, fee='fi', fo='fum')POSITIONAL ARGS:  1  'a'  (1+0j)KEYWORD ARGS:  'fee' = 'fi'  'fo' = 'fum'>>> alist = [1,'a',1+0j]>>> adict = {'fee':'fi', 'fo':'fum'}>>> printargs(*alist, **adict)POSITIONAL ARGS:  1  'a'  (1+0j)KEYWORD ARGS:  'fee' = 'fi'  'fo' = 'fum'>>>"
">>> from array import array>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello 2641'),	('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]>>> for typecode, initializer in argslist:	a = array(typecode, initializer)	print a, 'Size =', a.buffer_info()[1] * a.itemsize	del a  array('l') 	Size = 0array('c', 'hello world') 	Size = 11array('u', u'hello 2641') 	Size = 14array('l', [1, 2, 3, 4, 5]) 	Size = 20array('d', [1.0, 2.0, 3.1400000000000001]) 	Size = 24>>>import syssys.getsizeof(obj)"
">>> def base10change(n, base):	digits = []	while n:		n,remainder = divmod(n, base)		digits.insert(0, remainder)	return digits >>> base10change(11, 2)[1, 0, 1, 1]def vdc(n, base=2):    vdc, denom = 0,1    while n:        denom *= base        n, remainder = divmod(n, base)        vdc += remainder / denom    return vdc>>> [vdc(i) for i in range(10)][0, 0.5, 0.25, 0.75, 0.125, 0.625, 0.375, 0.875, 0.0625, 0.5625]>>> [vdc(i, 3) for i in range(10)][0, 0.3333333333333333, 0.6666666666666666, 0.1111111111111111, 0.4444444444444444, 0.7777777777777777, 0.2222222222222222, 0.5555555555555556, 0.8888888888888888, 0.037037037037037035]>>> >>> from fractions import Fraction>>> Fraction.__repr__ = lambda x: '%i/%i' % (x.numerator, x.denominator)>>> [vdc(i, base=Fraction(2)) for i in range(10)][0, 1/2, 1/4, 3/4, 1/8, 5/8, 3/8, 7/8, 1/16, 9/16]>>> for b in range(3,6):	print('Base', b)	print([vdc(i, base=Fraction(b)) for i in range(10)]) Base 3[0, 1/3, 2/3, 1/9, 4/9, 7/9, 2/9, 5/9, 8/9, 1/27] Base 4[0, 1/4, 1/2, 3/4, 1/16, 5/16, 9/16, 13/16, 1/8, 3/8] Base 5[0, 1/5, 2/5, 3/5, 4/5, 1/25, 6/25, 11/25, 16/25, 21/25]"
"#http://docs.python-requests.org/en/latest/import requestsimport json city = Nonetopic = None def getEvent(url_path, key) :    responseString = strv     params = {'city':city, 'key':key,'topic':topic}    r = requests.get(url_path, params = params)        print(r.url)        responseString = r.text    return responseString  def getApiKey(key_path):    key = strv    f = open(key_path, 'r')    key = f.read()    return key  def submitEvent(url_path,params):    r = requests.post(url_path, data=json.dumps(params))            print(r.text+strv)import eventGetter as egimport json def main():    url_path = strv         #Url to meetup API    key_path = strv                    #Path to api_key.txt    path_code = strv                              #var to store the url_path + the specific api path    key = eg.getApiKey(key_path)         #1-parameter get events example :     print(strv)    path_code = url_path+strv    eg.topic = strv    response = eg.getEvent(path_code, key)    decodeJSON(response)     #2-parameter get events example :    print("""")    print(strv)     path_code = url_path+strv    eg.topic = strv    eg.city = strv    response = eg.getEvent(path_code, key)    decodeJSON(response)      #Get GEO Example :     print("""")    print(strv)    path_code = url_path+strv    eg.topic = strv    eg.city = None    exclude = None    response = eg.getEvent(path_code, key)    decodeGEO(response)      #Exclude topics Example    print("""")    print(strv)    path_code = url_path+strv    eg.topic = strv    eg.city = None    exclude = strv    response = eg.getEvent(path_code, key)    decodeJSONExcluding(response, exclude)   def decodeJSON(response):    j = json.loads(response.encode('ascii','ignore').decode())   #This is a Python Dict (JSON array)    i = 0    results = j['results']    while i<len(results):        event = results[i]        print(strv+str(i))        print(strv+event['name'])        print(strv+event['event_url'])        try :             print(strv+str(event['venue']['city']))        except KeyError :             print(strv)         try :            print(strv+str(event['group']['name']))        except KeyError :            print(strv)                     i+=1  def decodeJSONExcluding(response, exclude):    j = json.loads(response.encode('ascii','ignore').decode())   #This is a Python Dict (JSON array)    i = 0    results = j['results']    while i<len(results):        event = results[i]        if 'description' in event :             if exclude not in str(event['description']) :                 print(strv+str(i))                            print(strv+event['name'])                print(strv+event['event_url'])                try :                     print(strv+str(event['venue']['city']))                except KeyError :                     print(strv)                 try :                    print(strv+str(event['group']['name']))                except KeyError :                    print(strv)                         else :                print(strv+str(i)+strv)         i+=1  def decodeGEO(response):    j = json.loads(response.encode('ascii','ignore').decode())   #This is a Python Dict (JSON array)    i = 0    results = j['results']    while i<len(results):        event = results[i]        print(strv+str(i))                    print(strv+event['name'])        try :             print(strv+str(event['venue']['lat']))            print(strv+str(event['venue']['lon']))        except KeyError :             print(strv)         i+=1   main()"
"def check_isin(a):    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):        return False    s = strv.join(str(int(c, 36)) for c in a)    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +                 sum(ord(c) - 48 for c in s[::-2])) % 10 
def check_isin_alt(a):    if len(a) != 12:        return False    s = []    for i, c in enumerate(a):        if c.isdigit():            if i < 2:                return False            s.append(ord(c) - 48)        elif c.isupper():            if i == 11:                return False            s += divmod(ord(c) - 55, 10)        else:            return False    v = sum(s[::-2])    for k in s[-2::-2]:        k = 2 * k        v += k - 9 if k > 9 else k    return v % 10 == 0 [check_isin(s) for s in [strv, strv, strv, strv,                         strv, strv, strv]] 
"
"from __future__ import division import mathfrom operator import mulfrom itertools import productfrom functools import reduce  def fac(n):    '''
    return the prime factors for n
    >>> fac(600)
    [5, 5, 3, 2, 2, 2]
    >>> fac(1000)
    [5, 5, 5, 2, 2, 2]
    >>>  
    '''    step = lambda x: 1 + x*4 - (x//2)*2    maxq = int(math.floor(math.sqrt(n)))    d = 1    q = n % 2 == 0 and 2 or 3     while q <= maxq and n % q != 0:        q = step(d)        d += 1    res = []    if q <= maxq:        res.extend(fac(n//q))        res.extend(fac(q))     else: res=[n]    return res def fact(n):    '''
    return the prime factors and their multiplicities for n
    >>> fact(600)
    [(2, 3), (3, 1), (5, 2)]
    >>> fact(1000)
    [(2, 3), (5, 3)]
    >>> 
    '''    res = fac(n)    return [(c, res.count(c)) for c in set(res)] def divisors(n):    'Returns all the divisors of n'    factors = fact(n)   
    primes, maxpowers = zip(*factors)    powerranges = (range(m+1) for m in maxpowers)    powers = product(*powerranges)    return (        reduce(mul,               (prime**power for prime, power in zip(primes, powergroup)),               1)        for powergroup in powers) def vampire(n):    fangsets = set( frozenset([d, n//d])                    for d in divisors(n)                    if (len(str(d)) == len(str(n))/2.                        and sorted(str(d) + str(n//d)) == sorted(str(n))                        and (str(d)[-1] == 0) + (str(n//d)[-1] == 0) <=1) )    return sorted(tuple(sorted(fangs)) for fangs in fangsets)  if __name__ == '__main__':    print('First 25 vampire numbers')    count = n = 0    while count <25:        n += 1        fangpairs = vampire(n)        if fangpairs:            count += 1            print('%i: %r' % (n, fangpairs))    print('Specific checks for fangpairs')    for n in (16758243290880, 24959017348650, 14593825548650):        fangpairs = vampire(n)        print('%i: %r' % (n, fangpairs))from math import sqrtfrom itertools import imap, ifilter, islice, count def factor_pairs(n):    return ((x, n // x) for x in xrange(2, int(sqrt(n))) if n % x == 0) def fangs(n):    dlen = lambda x: len(str(x))    half = dlen(n) // 2    digits = lambda (x, y): sorted(str(x) + str(y))    halvesQ = lambda xs: all(y == half for y in imap(dlen, xs))    dn = sorted(str(n))    return [p for p in factor_pairs(n) if halvesQ(p) and dn==digits(p)] def vampiricQ(n):    fn = fangs(n)    return (n, fn) if fn else None for v in islice(ifilter(None, imap(vampiricQ, count())), 0, 25):    print v for n in [16758243290880, 24959017348650, 14593825548650]:    print vampiricQ(n) or str(n) + strv"
" 

def query(buffer_length):    message = b'Here am I'    L = len(message)    return message[0:L*(L <= buffer_length)] "
"import Tkinter,tkSimpleDialog root = Tkinter.Tk()root.withdraw() number = tkSimpleDialog.askinteger(strv, strv)string = tkSimpleDialog.askstring(strv, strv)"
"   string = raw_input(strv)   string = input(strv)   number = input(strv)  
   number = eval(input(strv)) 
   number = float(raw_input(strv))   number = float(input(strv))"
import urllibs = 'http://foo/bar/'s = urllib.quote(s)
"import urllib.parse as up 
 url = up.urlparse('http://user::8081/path/file.html;params?query1=1#fragment') print('url.scheme = ', url.scheme)print('url.netloc = ', url.netloc)print('url.hostname = ', url.hostname)print('url.port = ', url.port)print('url.path = ', url.path)print('url.params = ', url.params)print('url.query = ', url.query)print('url.fragment = ', url.fragment)print('url.username = ', url.username)print('url.password = ', url.password) "
import urllibprint urllib.unquote(strv)
>>> import os>>> print(''.join(sorted(os.listdir('.'))))DLLsDocLICENSE.txtLibNEWS.txtREADME.txtScriptsToolsincludelibspython.exepythonw.exetcl>>> 
>>> Δx = 1>>> Δx += 1>>> print(Δx)2>>> 
"#!/usr/bin/env python
 u = 'abcdé'print(ord(u[-1]))"
"#!/usr/bin/env python #----------------------------------------------------------------------------
#----------------------------------------------------------------------------import reimport string  #----------------------------------------------------------------------------
#----------------------------------------------------------------------------DISABLED_PREFIX = ';'  #----------------------------------------------------------------------------
#----------------------------------------------------------------------------class Option(object):    strvAn option, characterized by its name and its (optional) value. and by
       its status, which can be enabled or disabled.
       If its value is None, it is regarded to as a boolean option with a
       value of true.
    strv     #------------------------------------------------------------------------    def __init__(self, name, value=None, disabled=False,                 disabled_prefix=DISABLED_PREFIX):        strvCreate an Option instance, setting its name to 'name' (always
           converted to a string) and its value to 'value'. If 'disabled' is
           True, the option is considered disabled, otherwise enabled.
           The string 'disabled_prefix' is used as a prefix when generating the
           string representation of the option.
        strv        self.name = str(name)        self.value = value        self.disabled = bool(disabled)        self.disabled_prefix = disabled_prefix     #------------------------------------------------------------------------    def __str__(self):        strvReturn a string representation of the Option instance.
           This always includes the option name, followed by a space and the
           option value (if it is not None). If the option is disabled, the
           whole string is preprendend by the string stored in the instance
           attribute 'disabled_prefix' and a space.
        strv        disabled = ('', '%s ' % self.disabled_prefix)[self.disabled]        value = (' %s' % self.value, '')[self.value is None]        return ''.join((disabled, self.name, value))     #------------------------------------------------------------------------    def get(self):        strvReturn the option value.
           If the stored value is None, the option is regarded to as a
           boolean one and its enabled status is returned. Othrwise its value
           is returned.
        strv        enabled = not bool(self.disabled)        if self.value is None:            value = enabled        else:            value = enabled and self.value        return value  #----------------------------------------------------------------------------
#----------------------------------------------------------------------------class Config(object):    strvA set of configuration options and comment strings.
    strv    
    reOPTION = r'^*(?P<disabled>%s*)*(?P<name>+)(?:+(?P<value>.+?))?*$'     #------------------------------------------------------------------------    def __init__(self, fname=None, disabled_prefix=DISABLED_PREFIX):        strvInitialize a Config instance, optionally reading the contents of
           the configuration file 'fname'.
           The string 'disabled_prefix' is used as a prefix when generating the
           string representation of the options.
        strv        self.disabled_prefix = disabled_prefix        self.contents = []          
        self.options = {}           
        self.creOPTION = re.compile(self.reOPTION % self.disabled_prefix)        if fname:            self.parse_file(fname)     #------------------------------------------------------------------------    def __str__(self):        strvReturn a string representation of the Config instance.
           This is just the concatenation of all the items stored in the
           attribute 'contents'.
        strv        return ''.join(map(str, self.contents))     #------------------------------------------------------------------------    def parse_file(self, fname):        strvParse all the lines of file 'fname' by applying the method
           'parser_lines' on the file contents.
        strv        with open(fname) as f:            self.parse_lines(f)        return self     #------------------------------------------------------------------------    def parse_lines(self, lines):        strvParse all the lines of iterable 'lines' by invoking the method
           'parse_line' for each line in 'lines'.
        strv        for line in lines:            self.parse_line(line)        return self     #------------------------------------------------------------------------    def parse_line(self, line):        strvParse the line 'line', looking for options.
           If an option line is found, spaces are stripped from the start and
           the end of 'line' and any non-printable character is removed as well.
           Only the first occurrence of an option is processed, all the other
           occurrences are ignored. A valid option is added to the instance
           attribute 'contents' (in order to preserve its position among the
           other lines). It is also added to the mapping stored in the instance
           attribute 'options'.
           Any non-option string is added the the instance attribute 'contents',
           except those lines starting with the string stored into the instance
           attribute 'disabled_prefix' which are not followed by any option
           name.
        strv        s = ''.join(c for c in line.strip() if c in string.printable)         moOPTION = self.creOPTION.match(s)        if moOPTION:            name = moOPTION.group('name').upper()            if not name in self.options:                self.add_option(name, moOPTION.group('value'),                                moOPTION.group('disabled'))        else:            if not s.startswith(self.disabled_prefix):                self.contents.append(line.rstrip())        return self     #------------------------------------------------------------------------    def add_option(self, name, value=None, disabled=False):        strvCreate a new Option instance, named 'name' (always converted to
           uppercase) with value 'value' and set its disabled status to
           'disabled'.
           The Option instance is added to the instance attribute 'contents'.
           It is also added to the mapping stored in the instance attribute
           'options'.
        strv        name = name.upper()        opt = Option(name, value, disabled)        self.options[name] = opt        self.contents.append(opt)        return opt     #------------------------------------------------------------------------    def set_option(self, name, value=None, disabled=False):        strvLook for an option named 'name' (always converted to
           uppercase) among the options stored in the instance
           attribute 'options'.
           If it is not found, a new Option instance is created.
           In any case its value is set to 'value' and its disabled
           status to 'disabled'.
        strv        name = name.upper()        opt = self.options.get(name)        if opt:            opt.value = value            opt.disabled = disabled        else:            opt = self.add_option(name, value, disabled)        return opt     #------------------------------------------------------------------------    def enable_option(self, name, value=None):        strvEnable the option named 'name' (always converted to
           uppercase) and set its value to 'value'.
           If the option is not found, it is created and added to the
           end of the instance attribute 'contents'.
        strv        return self.set_option(name, value, False)     #------------------------------------------------------------------------    def disable_option(self, name, value=None):        strvDisable the option named 'name' (always converted to
           uppercase) and set its value to 'value'.
           If the option is not found, it is created and added to the
           end of the instance attribute 'contents'.
        strv        return self.set_option(name, value, True)     #------------------------------------------------------------------------    def get_option(self, name):        strvReturn the value of the option named 'name' (always
           converted to uppercase).
           If the option is not found in the instance attribute
           'options', None is returned. If the stored value is None,
           it is regarded to as a boolean option and its enable status
           is returned. Otherwise its value is returned.
        strv        opt = self.options.get(name.upper())        value = opt.get() if opt else None        return value  #----------------------------------------------------------------------------
#----------------------------------------------------------------------------if __name__ == '__main__':    import sys    cfg = Config(sys.argv[1] if len(sys.argv) > 1 else None)    cfg.disable_option('needspeeling')    cfg.enable_option('seedsremoved')    cfg.enable_option('numberofbananas', 1024)    cfg.enable_option('numberofstrawberries', 62000)    print cfg "
"
try: nameexcept NameError: print strv 
name = strv 
try: nameexcept NameError: print strv 
del name 
try: nameexcept NameError: print strv 
name = 42 
try: nameexcept NameError: print strv 

print strv"
"from __future__ import print_function def run_utm(        state = None,        blank = None,        rules = [],        tape = [],        halt = None,        pos = 0):    st = state    if not tape: tape = [blank]    if pos < 0: pos += len(tape)    if pos >= len(tape) or pos < 0: raise Error( strv)    rules = dict(((s0, v0), (v1, dr, s1)) for (s0, v0, v1, dr, s1) in rules)     while True:        print(st, '', end=strv)        for i, v in enumerate(tape):            if i == pos: print(strv % (v,), end=strv)            else: print(v, end=strv)        print()         if st == halt: break        if (st, tape[pos]) not in rules: break         (v1, dr, s1) = rules[(st, tape[pos])]        tape[pos] = v1        if dr == 'left':            if pos > 0: pos -= 1            else: tape.insert(0, blank)        if dr == 'right':            pos += 1            if pos >= len(tape): tape.append(blank)         st = s1  
 print(""incr machine"")run_utm(    halt = 'qf',	state = 'q0',	tape = list(strv),	blank = 'B',	rules = map(tuple,                [strv.split(),		        strv.split()]        )    ) print(""busy beaver"")run_utm(    halt = 'halt',	state = 'a',	blank = '0',	rules = map(tuple,        [strv.split(),         strv.split(),         strv.split(),         strv.split(),         strv.split(),         strv.split()]        )    ) print(""sorting test"")run_utm(halt = 'STOP',	state = 'A',	blank = '0',	tape = strv.split(),	rules = map(tuple,       [strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split(),		strv.split()]        )    ) "
"from __future__ import print_functionimport random def randN(N):    strv    return lambda: random.randrange(N) == 0 def unbiased(biased):    'uses a biased() generator of 1 or 0, to create an unbiased one'    this, that = biased(), biased()    while this == that: 
        this, that = biased(), biased()    return this         
 if __name__ == '__main__':    from collections import namedtuple     Stats = namedtuple('Stats', 'count1 count0 percent')     for N in range(3, 7):        biased = randN(N)        v = [biased() for x in range(1000000)]        v1, v0 = v.count(1), v.count(0)        print ( strv % (N, Stats(v1, v0, 100. * v1/(v1 + v0))) )         v = [unbiased(biased) for x in range(1000000)]        v1, v0 = v.count(1), v.count(0)        print ( strv % (Stats(v1, v0, 100. * v1/(v1 + v0)), ) )"
" def two_sum(arr, num):    i = 0    j = len(arr) - 1    while i < j:        if arr[i] + arr[j] == num:            return (i, j)        if arr[i] + arr[j] < num:            i += 1        else:            j -= 1    return None  numbers = [0, 2, 11, 19, 90]print(two_sum(numbers, 21))print(two_sum(numbers, 25))  "
"from itertools import product while True:    bexp = input('Boolean expression: ')    bexp = bexp.strip()    if not bexp:        print(""Thank you"")        break    code = compile(bexp, '<string>', 'eval')    names = code.co_names    print('' + ' '.join(names), ':', bexp)    for values in product(range(2), repeat=len(names)):        env = dict(zip(names, values))        print(' '.join(str(v) for v in values), ':', eval(code, env)) "
"
from __future__ import print_function, divisionfrom math import sqrt def cell(n, x, y, start=1):    d, y, x = 0, y - n//2, x - (n - 1)//2    l = 2*max(abs(x), abs(y))    d = (l*3 + x + y) if y >= x else (l - x - y)    return (l - 1)**2 + d + start - 1 def show_spiral(n, symbol='# ', start=1, space=None):    top = start + n*n + 1    is_prime = [False,False,True] + [True,False]*(top//2)    for x in range(3, 1 + int(sqrt(top))):        if not is_prime[x]: continue        for i in range(x*x, top, x*2):            is_prime[i] = False     cell_str = lambda x: f(x) if is_prime[x] else space    f = lambda _: symbol 
     if space == None: space = ' '*len(symbol)     if not len(symbol): 
        max_str = len(str(n*n + start - 1))        if space == None: space = '.'*max_str + ' '        f = lambda x: ('%' + str(max_str) + 'd ')%x     for y in range(n):        print(''.join(cell_str(v) for v in [cell(n, x, y, start) for x in range(n)]))    print() show_spiral(10, symbol=u'♞', space=u'♘') 
show_spiral(9, symbol='', space=' - ')
#show_spiral(1001, symbol='*', start=42)"
" from itertools import product#from pprint import pprint as pp constraintinfo = (    (lambda st: len(st) == 12                 ,(1, 'This is a numbered list of twelve statements')),  (lambda st: sum(st[-6:]) == 3             ,(2, 'Exactly 3 of the last 6 statements are true')),  (lambda st: sum(st[1::2]) == 2            ,(3, 'Exactly 2 of the even-numbered statements are true')),  (lambda st: (st[5]&st[6]) if st[4] else 1 ,(4, 'If statement 5 is true, then statements 6 and 7 are both true')),  (lambda st: sum(st[1:4]) == 0             ,(5, 'The 3 preceding statements are all false')),  (lambda st: sum(st[0::2]) == 4            ,(6, 'Exactly 4 of the odd-numbered statements are true')),  (lambda st: sum(st[1:3]) == 1             ,(7, 'Either statement 2 or 3 is true, but not both')),  (lambda st: (st[4]&st[5]) if st[6] else 1 ,(8, 'If statement 7 is true, then 5 and 6 are both true')),  (lambda st: sum(st[:6]) == 3              ,(9, 'Exactly 3 of the first 6 statements are true')),  (lambda st: (st[10]&st[11])               ,(10, 'The next two statements are both true')),  (lambda st: sum(st[6:9]) == 1             ,(11, 'Exactly 1 of statements 7, 8 and 9 are true')),  (lambda st: sum(st[0:11]) == 4            ,(12, 'Exactly 4 of the preceding statements are true')),)   def printer(st, matches):    if False in matches:        print('Missed by one statement: %i, %s' % docs[matches.index(False)])    else:        print('Full match:')    print('  ' + ', '.join('%i:%s' % (i, 'T' if t else 'F') for i, t in enumerate(st, 1))) funcs, docs = zip(*constraintinfo) full, partial = [], [] for st in product( *([(False, True)] * 12) ):    truths = [bool(func(st)) for func in funcs]    matches = [s == t for s,t in zip(st, truths)]    mcount = sum(matches)    if mcount == 12:        full.append((st, matches))    elif mcount == 11:        partial.append((st, matches)) for stm in full + partial:    printer(*stm)"
" def truncate_file(name, length):    if not os.path.isfile(name):        return False    if length >= os.path.getsize(name):        return False    with open(name, 'ab') as f:        f.truncate(length)        f.close()        return True "
"maxprime = 1000000 def primes(n):    multiples = set()    prime = []    for i in range(2, n+1):        if i not in multiples:            prime.append(i)            multiples.update(set(range(i*i, n+1, i)))    return prime def truncatableprime(n):    'Return a longest left and right truncatable primes below n'    primelist = [str(x) for x in primes(n)[::-1]]    primeset = set(primelist)    for n in primelist:        
        alltruncs = set(n[i:] for i in range(len(n)))        if alltruncs.issubset(primeset):            truncateleft = int(n)            break    for n in primelist:        
        alltruncs = set([n[:i+1] for i in range(len(n))])        if alltruncs.issubset(primeset):            truncateright = int(n)            break    return truncateleft, truncateright print(truncatableprime(maxprime))"
"Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32Type strv, strv or strv for more information.>>> def f(x): return abs(x) ** 0.5 + 5 * x**3 >>> print(', '.join('%s:%s' % (x, v if v<=400 else strv)	           for x,v in ((y, f(float(y))) for y in input('numbers: ').strip().split()[:11][::-1]))) 11 numbers: 1 2 3 4 5 6 7 8 9 10 1111:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0>>> def f(x):    return abs(x) ** 0.5 + 5 * x**3 def ask():    return [float(y)            for y in input('11 numbers: ').strip().split()[:11]] if __name__ == '__main__':    s = ask()    s.reverse()    for x in s:        result = f(x)        if result > 400:            print(' %s:%s' % (x, strv), end='')        else:            print(' %s:%s' % (x, result), end='')    print('')"
"Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32Type strv, strv or strv for more information.>>> from math import degrees, radians, sin, cos, tan, asin, acos, atan, pi>>> rad, deg = pi/4, 45.0>>> print(strv, sin(rad), sin(radians(deg)))Sine: 0.7071067811865475 0.7071067811865475>>> print(strv, cos(rad), cos(radians(deg)))Cosine: 0.7071067811865476 0.7071067811865476>>> print(strv, tan(rad), tan(radians(deg)))Tangent: 0.9999999999999999 0.9999999999999999>>> arcsine = asin(sin(rad))>>> print(strv, arcsine, degrees(arcsine))Arcsine: 0.7853981633974482 44.99999999999999>>> arccosine = acos(cos(rad))>>> print(strv, arccosine, degrees(arccosine))Arccosine: 0.7853981633974483 45.0>>> arctangent = atan(tan(rad))>>> print(strv, arctangent, degrees(arctangent))Arctangent: 0.7853981633974483 45.0>>> "
"try:    from functools import reduceexcept: pass 
def topx(data, tops=None):    'Extract the set of top-level(s) in topological order'    for k, v in data.items():        v.discard(k) 
    if tops is None:        tops = toplevels(data)    return _topx(data, tops, [], set()) def _topx(data, tops, _sofar, _sofar_set):    'Recursive topological extractor'    _sofar += [tops] 
    _sofar_set.union(tops)    depends = reduce(set.union, (data.get(top, set()) for top in tops))    if depends:        _topx(data, depends, _sofar, _sofar_set)    ordered, accum = [], set()    for s in _sofar[::-1]:        ordered += [sorted(s - accum)]        accum |= s    return ordered def printorder(order):    'Prettyprint topological ordering'    if order:        print(strv + ', '.join(str(s) for s in order[0]))    for o in order[1:]:        print(strv + ', '.join(str(s) for s in o)) def toplevels(data):    '''
    Extract all top levels from dependency data
    Top levels are never dependents
    '''    for k, v in data.items():        v.discard(k) 
    dependents = reduce(set.union, data.values())    return  set(data.keys()) - dependents if __name__ == '__main__':    data = dict(        top1  = set('ip1 des1 ip2'.split()),        top2  = set('ip2 des1 ip3'.split()),        des1  = set('des1a des1b des1c'.split()),        des1a = set('des1a1 des1a2'.split()),        des1c = set('des1c1 extra1'.split()),        ip2   = set('ip2a ip2b ip2c ipcommon'.split()),        ip1   = set('ip1a ipcommon extra1'.split()),        )     tops = toplevels(data)    print(strv + ' '.join(tops))     for t in sorted(tops):        print(""The compile order for top level: %s is..."" % t)        printorder(topx(data, set([t])))    if len(tops) > 1:        print(""The compile order for top levels: %s is...""              % ' and '.join(str(s) for s in sorted(tops)) )        printorder(topx(data, tops))"
">>> from itertools import permutations>>> def f1(p):	i = 0	while True:		p0  = p[0]		if p0 == 1: break		p[:p0] = p[:p0][::-1]		i  += 1	return i >>> def fannkuch(n):	return max(f1(list(p)) for p in permutations(range(1, n+1))) >>> for n in range(1, 11): print(n,fannkuch(n)) 1 02 13 24 45 76 107 168 229 3010 38>>> try:    import psyco    psyco.full()except ImportError:    pass best = [0] * 16 def try_swaps(deck, f, s, d, n):    if d > best[n]:        best[n] = d     i = 0    k = 1 << s    while s:        k >>= 1        s -= 1        if deck[s] == -1 or deck[s] == s:            break        i |= k        if (i & f) == i and d + best[s] <= best[n]:            return d    s += 1     deck2 = list(deck)    k = 1    for i2 in xrange(1, s):        k <<= 1        if deck2[i2] == -1:            if f & k: continue        elif deck2[i2] != i2:            continue         deck[i2] = i2        deck2[:i2 + 1] = reversed(deck[:i2 + 1])        try_swaps(deck2, f | k, s, 1 + d, n) def topswops(n):    best[n] = 0    deck0 = [-1] * 16    deck0[0] = 0    try_swaps(deck0, 1, n, 0, n)    return best[n] for i in xrange(1, 13):    print strv % (i, topswops(i))"
"from collections import namedtuple Circle = namedtuple(strv, strv) circles = [    Circle( 1.6417233788,  1.6121789534, 0.0848270516),    Circle(-1.4944608174,  1.2077959613, 1.1039549836),    Circle( 0.6110294452, -0.6907087527, 0.9089162485),    Circle( 0.3844862411,  0.2923344616, 0.2375743054),    Circle(-0.2495892950, -0.3832854473, 1.0845181219),    Circle( 1.7813504266,  1.6178237031, 0.8162655711),    Circle(-0.1985249206, -0.8343333301, 0.0538864941),    Circle(-1.7011985145, -0.1263820964, 0.4776976918),    Circle(-0.4319462812,  1.4104420482, 0.7886291537),    Circle( 0.2178372997, -0.9499557344, 0.0357871187),    Circle(-0.6294854565, -1.3078893852, 0.7653357688),    Circle( 1.7952608455,  0.6281269104, 0.2727652452),    Circle( 1.4168575317,  1.0683357171, 1.1016025378),    Circle( 1.4637371396,  0.9463877418, 1.1846214562),    Circle(-0.5263668798,  1.7315156631, 1.4428514068),    Circle(-1.2197352481,  0.9144146579, 1.0727263474),    Circle(-0.1389358881,  0.1092805780, 0.7350208828),    Circle( 1.5293954595,  0.0030278255, 1.2472867347),    Circle(-0.5258728625,  1.3782633069, 1.3495508831),    Circle(-0.1403562064,  0.2437382535, 1.3804956588),    Circle( 0.8055826339, -0.0482092025, 0.3327165165),    Circle(-0.6311979224,  0.7184578971, 0.2491045282),    Circle( 1.4685857879, -0.8347049536, 1.3670667538),    Circle(-0.6855727502,  1.6465021616, 1.0593087096),    Circle( 0.0152957411,  0.0638919221, 0.9771215985)] def main():    
    x_min = min(c.x - c.r for c in circles)    x_max = max(c.x + c.r for c in circles)    y_min = min(c.y - c.r for c in circles)    y_max = max(c.y + c.r for c in circles)     box_side = 500     dx = (x_max - x_min) / box_side    dy = (y_max - y_min) / box_side     count = 0     for r in xrange(box_side):        y = y_min + r * dy        for c in xrange(box_side):            x = x_min + c * dx            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)                   for circle in circles):                count += 1     print strv, count * dx * dy main()from math import floor, ceil, sqrt def area_scan(prec, circs):    def sect((cx, cy, r), y):        dr = sqrt(r ** 2 - (y - cy) ** 2)        return (cx - dr, cx + dr)     ys = [a[1] + a[2] for a in circs] + [a[1] - a[2] for a in circs]    mins = int(floor(min(ys) / prec))    maxs = int(ceil(max(ys) / prec))     total = 0    for y in (prec * x for x in xrange(mins, maxs + 1)):        right = -float(strv)         for (x0, x1) in sorted(sect((cx, cy, r), y)                               for (cx, cy, r) in circs                               if abs(y - cr) < r):            if x1 <= right:                continue            total += x1 - max(x0, right)            right = x1     return total * prec def main():    circles = [        ( 1.6417233788,  1.6121789534, 0.0848270516),        (-1.4944608174,  1.2077959613, 1.1039549836),        ( 0.6110294452, -0.6907087527, 0.9089162485),        ( 0.3844862411,  0.2923344616, 0.2375743054),        (-0.2495892950, -0.3832854473, 1.0845181219),        ( 1.7813504266,  1.6178237031, 0.8162655711),        (-0.1985249206, -0.8343333301, 0.0538864941),        (-1.7011985145, -0.1263820964, 0.4776976918),        (-0.4319462812,  1.4104420482, 0.7886291537),        ( 0.2178372997, -0.9499557344, 0.0357871187),        (-0.6294854565, -1.3078893852, 0.7653357688),        ( 1.7952608455,  0.6281269104, 0.2727652452),        ( 1.4168575317,  1.0683357171, 1.1016025378),        ( 1.4637371396,  0.9463877418, 1.1846214562),        (-0.5263668798,  1.7315156631, 1.4428514068),        (-1.2197352481,  0.9144146579, 1.0727263474),        (-0.1389358881,  0.1092805780, 0.7350208828),        ( 1.5293954595,  0.0030278255, 1.2472867347),        (-0.5258728625,  1.3782633069, 1.3495508831),        (-0.1403562064,  0.2437382535, 1.3804956588),        ( 0.8055826339, -0.0482092025, 0.3327165165),        (-0.6311979224,  0.7184578971, 0.2491045282),        ( 1.4685857879, -0.8347049536, 1.3670667538),        (-0.6855727502,  1.6465021616, 1.0593087096),        ( 0.0152957411,  0.0638919221, 0.9771215985)]     p = 1e-3    print strv, p, strv % area_scan(p, circles) main()from __future__ import divisionfrom math import sqrtfrom itertools import countfrom pprint import pprint as pptry:    from itertools import izip as zipexcept:    pass 
circles = sorted(set([   
   (1.6417233788,  1.6121789534, 0.0848270516),  (-1.4944608174,  1.2077959613, 1.1039549836),   (0.6110294452, -0.6907087527, 0.9089162485),   (0.3844862411,  0.2923344616, 0.2375743054),  (-0.2495892950, -0.3832854473, 1.0845181219),   (1.7813504266,  1.6178237031, 0.8162655711),  (-0.1985249206, -0.8343333301, 0.0538864941),  (-1.7011985145, -0.1263820964, 0.4776976918),  (-0.4319462812,  1.4104420482, 0.7886291537),   (0.2178372997, -0.9499557344, 0.0357871187),  (-0.6294854565, -1.3078893852, 0.7653357688),   (1.7952608455,  0.6281269104, 0.2727652452),   (1.4168575317,  1.0683357171, 1.1016025378),   (1.4637371396,  0.9463877418, 1.1846214562),  (-0.5263668798,  1.7315156631, 1.4428514068),  (-1.2197352481,  0.9144146579, 1.0727263474),  (-0.1389358881,  0.1092805780, 0.7350208828),   (1.5293954595,  0.0030278255, 1.2472867347),  (-0.5258728625,  1.3782633069, 1.3495508831),  (-0.1403562064,  0.2437382535, 1.3804956588),   (0.8055826339, -0.0482092025, 0.3327165165),  (-0.6311979224,  0.7184578971, 0.2491045282),   (1.4685857879, -0.8347049536, 1.3670667538),  (-0.6855727502,  1.6465021616, 1.0593087096),   (0.0152957411,  0.0638919221, 0.9771215985),   ]), key=lambda x: -x[-1]) def vdcgen(base=2):    'Van der Corput sequence generator'    for n in count():        vdc, denom = 0,1        while n:            denom *= base            n, remainder = divmod(n, base)            vdc += remainder / denom        yield vdc def vdc_2d():    'Two dimensional Van der Corput sequence generator'    for x, y in zip(vdcgen(base=2), vdcgen(base=3)):        yield x, y def bounding_box(circles):    'Return minx, maxx, miny, maxy'    return (min(x - r for x,y,r in circles),            max(x + r for x,y,r in circles),            min(y - r for x,y,r in circles),            max(y + r for x,y,r in circles)           )def circle_is_in_circle(c1, c2):    x1, y1, r1 = c1    x2, y2, r2 = c2    return sqrt((x2 - x1)**2 + (y2 - y1)**2) <= r1 - r2 def remove_covered_circles(circles):    'Takes circles in decreasing radius order. Removes those covered by others'    covered = []    for i, c1 in enumerate(circles):        eliminate = [c2 for c2 in circles[i+1:]                        if circle_is_in_circle(c1, c2)]        if eliminate: covered += [c1, eliminate]        for c in eliminate: circles.remove(c)    #pp(covered)     def main(circles):    print('Originally %i circles' % len(circles))    print('Bounding box: %r' % (bounding_box(circles),))    remove_covered_circles(circles)    print('  down to %i  due to some being wholly covered by others' % len(circles))    minx, maxx, miny, maxy = bounding_box(circles)    
    circles2 = [(x - minx, y - miny, r*r) for x, y, r in circles]    scalex, scaley = abs(maxx - minx), abs(maxy - miny)    pcount, inside, last = 0, 0, ''    for px, py in vdc_2d():        pcount += 1        px *= scalex; py *= scaley        if any((px-cx)**2 + (py-cy)**2 <= cr2 for cx, cy, cr2 in circles2):            inside += 1        if not pcount % 100000:            area = (inside/pcount) * scalex * scaley            print('Points: %8i, Area estimate: %r'                   % (pcount, area))            
            this = '%.4f' % area            if this == last:                break            else:                last = this    print('The value has settled to %s' % this)  if __name__ == '__main__':     main(circles)from collections import namedtuplefrom functools import partialfrom itertools import repeat, imap, izipfrom decimal import Decimal, getcontext 
from dmath import atan2, asin, sin, cos, pi as piCompute getcontext().prec = 40 
sqrt = Decimal.sqrtpi = piCompute()D2 = Decimal(2) Vec = namedtuple(strv, strv)vcross = lambda (a, b), (c, d): a*d - b*cvdot   = lambda (a, b), (c, d): a*c + b*dvadd   = lambda (a, b), (c, d): Vec(a + c, b + d)vsub   = lambda (a, b), (c, d): Vec(a - c, b - d)vlen   = lambda x: sqrt(vdot(x, x))vdist  = lambda a, b: vlen(vsub(a, b))vscale = lambda s, (x, y): Vec(x * s, y * s) def vnorm(v):    l = vlen(v)    return Vec(v.x / l, v.y / l) vangle = lambda (x, y): atan2(y, x) def anorm(a):    if a > pi:  return a - pi * D2    if a < -pi: return a + pi * D2    return             a Circle = namedtuple(strv, strv) def circle_cross((x0, y0, r0), (x1, y1, r1)):    d = vdist(Vec(x0, y0), Vec(x1, y1))    if d >= r0 + r1 or d <= abs(r0 - r1):        return []     s = (r0 + r1 + d) / D2    a = sqrt(s * (s - d) * (s - r0) * (s - r1))    h = D2 * a / d    dr = Vec(x1 - x0, y1 - y0)    dx = vscale(sqrt(r0 ** 2 - h ** 2), vnorm(dr))    ang = vangle(dr) if \          r0 ** 2 + d ** 2 > r1 ** 2 \          else pi + vangle(dr)    da = asin(h / r0)    return map(anorm, [ang - da, ang + da]) 
Angle2 = namedtuple(strv, strv) Arc = namedtuple(strv, strv) arcPoint = lambda (x, y, r), a: \    vadd(Vec(x, y), Vec(r * cos(a), r * sin(a))) arc_start  = lambda (c, (a0, a1)):  arcPoint(c, a0)arc_mid    = lambda (c, (a0, a1)):  arcPoint(c, (a0 + a1) / D2)arc_end    = lambda (c, (a0, a1)):  arcPoint(c, a1)arc_center = lambda ((x, y, r), _): Vec(x, y) arc_area = lambda ((_0, _1, r), (a0, a1)):  r ** 2 * (a1 - a0) / D2 def split_circles(cs):    cSplit = lambda (c, angs): \        imap(Arc, repeat(c), imap(Angle2, angs, angs[1:]))     
    
    in_circle = lambda ((x0, y0), c), (x, y, r): \        c != Circle(x, y, r) and vdist(Vec(x0, y0), Vec(x, y)) < r     def in_any_circle(arc):        return any(in_circle((arc_mid(arc), arc.c), c) for c in cs)     concat_map = lambda f, xs: [y for x in xs for y in f(x)]     f = lambda c: \        (c, sorted([-pi, pi] +                   concat_map(partial(circle_cross, c), cs)))    cAngs = map(f, cs)    arcs = concat_map(cSplit, cAngs)    return filter(lambda ar: not in_any_circle(ar), arcs) 







def make_paths(arcs):    eps = Decimal(strv)    def join_arcs(a, xxs):        if not xxs:            return [a]        x, xs = xxs[0], xxs[1:]        if not a:            return join_arcs([x], xs)        if vdist(arc_start(a[0]), arc_end(a[-1])) < eps:            return [a] + join_arcs([], xxs)        if vdist(arc_end(a[-1]), arc_start(x)) < eps:            return join_arcs(a + [x], xs)        return join_arcs(a, xs + [x])    return join_arcs([], arcs) 
def polyline_area(vvs):    tri_area = lambda a, b, c: vcross(vsub(b, a), vsub(c, b)) / D2    v, vs = vvs[0], vvs[1:]    return sum(tri_area(v, v1, v2) for v1, v2 in izip(vs, vs[1:])) def path_area(arcs):    f = lambda (a, e), arc: \        (a + arc_area(arc), e + [arc_center(arc), arc_end(arc)])    (a, e) = reduce(f, arcs, (0, []))    return a + polyline_area(e) circles_area = lambda cs: \    sum(imap(path_area, make_paths(split_circles(cs)))) def main():    raw_circles = strv
         1.6417233788  1.6121789534 0.0848270516
        -1.4944608174  1.2077959613 1.1039549836
         0.6110294452 -0.6907087527 0.9089162485
         0.3844862411  0.2923344616 0.2375743054
        -0.2495892950 -0.3832854473 1.0845181219
         1.7813504266  1.6178237031 0.8162655711
        -0.1985249206 -0.8343333301 0.0538864941
        -1.7011985145 -0.1263820964 0.4776976918
        -0.4319462812  1.4104420482 0.7886291537
         0.2178372997 -0.9499557344 0.0357871187
        -0.6294854565 -1.3078893852 0.7653357688
         1.7952608455  0.6281269104 0.2727652452
         1.4168575317  1.0683357171 1.1016025378
         1.4637371396  0.9463877418 1.1846214562
        -0.5263668798  1.7315156631 1.4428514068
        -1.2197352481  0.9144146579 1.0727263474
        -0.1389358881  0.1092805780 0.7350208828
         1.5293954595  0.0030278255 1.2472867347
        -0.5258728625  1.3782633069 1.3495508831
        -0.1403562064  0.2437382535 1.3804956588
         0.8055826339 -0.0482092025 0.3327165165
        -0.6311979224  0.7184578971 0.2491045282
         1.4685857879 -0.8347049536 1.3670667538
        -0.6855727502  1.6465021616 1.0593087096
         0.0152957411  0.0638919221 0.9771215985strv.splitlines()     circles = [Circle(*imap(Decimal, row.split()))               for row in raw_circles]    print strv, circles_area(circles) main()"
" 

 நிரல்பாகம் ஹோனாய்(வட்டுகள், முதல்அச்சு, இறுதிஅச்சு,வட்டு)   @(வட்டுகள் == 1 ) ஆனால்     பதிப்பி  “வட்டு ” + str(வட்டு) + “ஐ \t  (” + str(முதல்அச்சு) + “  —> ” +  str(இறுதிஅச்சு)+ “) அச்சிற்கு நகர்த்துக.”  இல்லை   @( [strv, strv,  strv]  இல் அச்சு ) ஒவ்வொன்றாக          @( (முதல்அச்சு != அச்சு)  && (இறுதிஅச்சு  != அச்சு) ) ஆனால்              நடு = அச்சு          முடி  முடி     
    ஹோனாய்(வட்டுகள்-1,   முதல்அச்சு,நடு,வட்டுகள்-1)     
    ஹோனாய்(1, முதல்அச்சு, இறுதிஅச்சு,வட்டுகள்)     
    ஹோனாய்(வட்டுகள்-1, நடு, இறுதிஅச்சு,வட்டுகள்-1)  முடிமுடி ஹோனாய்(4,”அ”,”ஆ”,0) proc hanoi(disks: int, fromTower: string, toTower: string, viaTower: string) =  if disks != 0:    hanoi(disks - 1, fromTower, viaTower, toTower)    echo(strv, disks, strv, fromTower, strv, toTower)    hanoi(disks - 1, viaTower, toTower, fromTower) hanoi(4, strv, strv, strv)def hanoi(ndisks, startPeg=1, endPeg=3):    if ndisks:        hanoi(ndisks-1, startPeg, 6-startPeg-endPeg)        print strv % (ndisks, startPeg, endPeg)        hanoi(ndisks-1, 6-startPeg-endPeg, endPeg) hanoi(ndisks=4)"
">>> 33>>> _*_, _**0.5(9, 1.7320508075688772)>>> "
"from collections import namedtuplefrom sys import stdout Node = namedtuple('Node', 'data, left, right')tree = Node(1,            Node(2,                 Node(4,                      Node(7, None, None),                      None),                 Node(5, None, None)),            Node(3,                 Node(6,                      Node(8, None, None),                      Node(9, None, None)),                 None)) def printwithspace(i):    stdout.write(strv % i) def preorder(node, visitor = printwithspace):    if node is not None:        visitor(node.data)        preorder(node.left, visitor)        preorder(node.right, visitor) def inorder(node, visitor = printwithspace):    if node is not None:        inorder(node.left, visitor)        visitor(node.data)        inorder(node.right, visitor) def postorder(node, visitor = printwithspace):    if node is not None:        postorder(node.left, visitor)        postorder(node.right, visitor)        visitor(node.data) def levelorder(node, more=None, visitor = printwithspace):    if node is not None:        if more is None:            more = []        more += [node.left, node.right]        visitor(node.data)    if more:            levelorder(more[0], more[1:], visitor) stdout.write('  preorder: ')preorder(tree)stdout.write('   inorder: ')inorder(tree)stdout.write(' postorder: ')postorder(tree)stdout.write('levelorder: ')levelorder(tree)stdout.write('')from collections import namedtuplefrom sys import stdout class Node(namedtuple('Node', 'data, left, right')):    __slots__ = ()     def preorder(self, visitor):        if self is not None:            visitor(self.data)            Node.preorder(self.left, visitor)            Node.preorder(self.right, visitor)     def inorder(self, visitor):        if self is not None:            Node.inorder(self.left, visitor)            visitor(self.data)            Node.inorder(self.right, visitor)     def postorder(self, visitor):        if self is not None:            Node.postorder(self.left, visitor)            Node.postorder(self.right, visitor)            visitor(self.data)     def levelorder(self, visitor, more=None):        if self is not None:            if more is None:                more = []            more += [self.left, self.right]            visitor(self.data)        if more:                Node.levelorder(more[0], visitor, more[1:])  def printwithspace(i):    stdout.write(strv % i)  tree = Node(1,            Node(2,                 Node(4,                      Node(7, None, None),                      None),                 Node(5, None, None)),            Node(3,                 Node(6,                      Node(8, None, None),                      Node(9, None, None)),                 None))  if __name__ == '__main__':    stdout.write('  preorder: ')    tree.preorder(printwithspace)    stdout.write('   inorder: ')    tree.inorder(printwithspace)    stdout.write(' postorder: ')    tree.postorder(printwithspace)    stdout.write('levelorder: ')    tree.levelorder(printwithspace)    stdout.write('')"
" def token_with_escape(a, escape = '^', separator = '|'):    '''
        Issue  python -m doctest thisfile.py  to run the doctests.
 
        >>> print(token_with_escape('one^|uno||three^^^^|four^^^|^cuatro|'))
        ['one|uno', '', 'three^^', 'four^|cuatro', '']
    '''    result = []    token = ''    state = 0     for c in a:        if state == 0:            if c == escape:                state = 1            elif c == separator:                result.append(token)                token = ''            else:                token += c        elif state == 1:            token += c            state = 0    result.append(token)    return result "
"from collections import defaultdictfrom heapq import nlargest data = [('Employee Name', 'Employee ID', 'Salary', 'Department'),        ('Tyler Bennett', 'E10297', 32000, 'D101'),        ('John Rappl', 'E21437', 47000, 'D050'),        ('George Woltman', 'E00127', 53500, 'D101'),        ('Adam Smith', 'E63535', 18000, 'D202'),        ('Claire Buckman', 'E39876', 27800, 'D202'),        ('David McClellan', 'E04242', 41500, 'D101'),        ('Rich Holcomb', 'E01234', 49500, 'D202'),        ('Nathan Adams', 'E41298', 21900, 'D050'),        ('Richard Potter', 'E43128', 15900, 'D101'),        ('David Motsinger', 'E27002', 19250, 'D202'),        ('Tim Sampair', 'E03033', 27000, 'D101'),        ('Kim Arlich', 'E10001', 57000, 'D190'),        ('Timothy Grove', 'E16398', 29900, 'D190')] departments = defaultdict(list)for rec in data[1:]:    departments[rec[-1]].append(rec) N = 3format = strv * len(data[0])for department, recs in sorted(departments.items()):    print (strv % department)    print (format % data[0])    for rec in nlargest(N, recs, key=lambda rec: rec[-2]):        print (format % rec)    print('')from collections import namedtuplefrom itertools import groupby N = 2 db = '''Employee Name,Employee ID,Salary,Department
Tyler Bennett,E10297,32000,D101
John Rappl,E21437,47000,D050
George Woltman,E00127,53500,D101
Adam Smith,E63535,18000,D202
Claire Buckman,E39876,27800,D202
David McClellan,E04242,41500,D101
Rich Holcomb,E01234,49500,D202
Nathan Adams,E41298,21900,D050
Richard Potter,E43128,15900,D101
David Motsinger,E27002,19250,D202
Tim Sampair,E03033,27000,D101
Kim Arlich,E10001,57000,D190
Timothy Grove,E16398,29900,D190''' rows = db.split('')DBRecord = namedtuple('DBRecord', rows[0].replace(' ', '_'))records = [ DBRecord(*row.split(',')) for row in rows[1:] ]records.sort(key = lambda record: (record.Department, -float(record.Salary)))print ''.join('  '.join([dpt] + [str(g) for g in grp][:N])                  for dpt, grp in groupby(records,                                          lambda record: record.Department))"
"def legendre(a, p):    return pow(a, (p - 1) // 2, p) def tonelli(n, p):    assert legendre(n, p) == 1, strv    q = p - 1    s = 0    while q % 2 == 0:        q //= 2        s += 1    if s == 1:        return pow(n, (p + 1) // 4, p)    for z in range(2, p):        if p - 1 == legendre(z, p):            break    c = pow(z, q, p)    r = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    t2 = 0    while (t - 1) % p != 0:        t2 = (t * t) % p        for i in range(1, m):            if (t2 - 1) % p == 0:                break            t2 = (t2 * t2) % p        b = pow(c, 1 << (m - i - 1), p)        r = (r * b) % p        c = (b * b) % p        t = (t * c) % p        m = i    return r if __name__ == '__main__':    ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049),	     (665820697, 1000000009), (881398088036, 1000000000039),             (41660815127637347468140745042827704103445750172002, 10**50 + 577)]    for n, p in ttest:        r = tonelli(n, p)        assert (r * r - n) % p == 0        print(strv % (n, p))        print(""  roots : %d %d"" % (r, p - r))"
"try:    from functools import reduceexcept:    pass data = {    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),    'dw01':             set('ieee dw01 dware gtech'.split()),    'dw02':             set('ieee dw02 dware'.split()),    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),    'dw05':             set('dw05 ieee dware'.split()),    'dw06':             set('dw06 ieee dware'.split()),    'dw07':             set('ieee dware'.split()),    'dware':            set('ieee dware'.split()),    'gtech':            set('ieee gtech'.split()),    'ramlib':           set('std ieee'.split()),    'std_cell_lib':     set('ieee std_cell_lib'.split()),    'synopsys':         set(),    } def toposort2(data):    for k, v in data.items():        v.discard(k) 
    extra_items_in_deps = reduce(set.union, data.values()) - set(data.keys())    data.update({item:set() for item in extra_items_in_deps})    while True:        ordered = set(item for item,dep in data.items() if not dep)        if not ordered:            break        yield ' '.join(sorted(ordered))        data = {item: (dep - ordered) for item,dep in data.items()                if item not in ordered}    assert not data, strv % data print (''.join( toposort2(data) ))"
"import sys, timeitdef usec(function, arguments):    modname, funcname = __name__, function.__name__    timer = timeit.Timer(stmt='%(funcname)s(*args)' % vars(),                         setup='from %(modname)s import %(funcname)s; args=%(arguments)r' % vars())    try:        t, N = 0, 1        while t < 0.2:                        t = min(timer.repeat(repeat=3, number=N))                        N *= 10        microseconds = round(10000000 * t / N, 1) 
        return microseconds     except:        timer.print_exc(file=sys.stderr)        raise  def nothing(): pass def identity(x): return xtime 1+130000/1000000  
=> 2"
"text = strvtokens = text.split(',')print ('.'.join(tokens))print ('.'.join('Hello,How,Are,You,Today'.split(',')))"
" m='0'print(m)for i in range(0,6):     m0=m     m=m.replace('0','a')     m=m.replace('1','0')     m=m.replace('a','1')     m=m0+m     print(m)  >>> def thue_morse_digits(digits):...     return  [bin(n).count('1') % 2 for n in range(digits)]... >>> thue_morse_digits(20)[0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1] >>>   >>> def thue_morse_subs(chars):...     ans = '0'...     while len(ans) < chars:...         ans = ans.replace('0', '0_').replace('1', '10').replace('_', '1')...     return ans[:chars]... >>> thue_morse_subs(20)'01101001100101101001' >>>  "
"#!/usr/bin/env python3 import math def thieleInterpolator(x, y):    ρ = [[yi]*(len(y)-i) for i, yi in enumerate(y)]    for i in range(len(ρ)-1):        ρ[i][1] = (x[i] - x[i+1]) / (ρ[i][0] - ρ[i+1][0])    for i in range(2, len(ρ)):        for j in range(len(ρ)-i):            ρ[j][i] = (x[j]-x[j+i]) / (ρ[j][i-1]-ρ[j+1][i-1]) + ρ[j+1][i-2]    ρ0 = ρ[0]    def t(xin):        a = 0        for i in range(len(ρ0)-1, 1, -1):            a = (xin - x[i-1]) / (ρ0[i] - ρ0[i-2] + a)        return y[0] + (xin-x[0]) / (ρ0[1]+a)    return t 
xVal = [i*.05 for i in range(32)]tSin = [math.sin(x) for x in xVal]tCos = [math.cos(x) for x in xVal]tTan = [math.tan(x) for x in xVal]
iSin = thieleInterpolator(tSin, xVal)iCos = thieleInterpolator(tCos, xVal)iTan = thieleInterpolator(tTan, xVal)
print('{:16.14f}'.format(6*iSin(.5)))print('{:16.14f}'.format(3*iCos(.5)))print('{:16.14f}'.format(4*iTan(1)))"
" '''
    Tic-tac-toe game player.
    Input the index of where you wish to place your mark at your turn.
''' import random board = list('123456789')wins = ((0,1,2), (3,4,5), (6,7,8),        (0,3,6), (1,4,7), (2,5,8),        (0,4,8), (2,4,6)) def printboard():    print(''.join(' '.join(board[x:x+3]) for x in(0,3,6))) def score():    for w in wins:        b = board[w[0]]        if b in 'XO' and all (board[i] == b for i in w):            return b, [i+1 for i in w]    return None, None def finished():    return all (b in 'XO' for b in board) def space():    return [ b for b in board if b not in 'XO'] def my_turn(xo):    options = space()    choice = random.choice(options)    board[int(choice)-1] = xo    return choice def your_turn(xo):    options = space()    while True:        choice = input(strv                       % (xo, ''.join(options))).strip()        if choice in options:            break        print( strv )    board[int(choice)-1] = xo    return choice def me(xo='X'):    printboard()    print('I go at', my_turn(xo))    return score()    assert not s[0], ""%s wins across %s"" % s def you(xo='O'):    printboard()    
    print('You went at', your_turn(xo))    return score()    assert not s[0], ""%s wins across %s"" % s  print(__doc__)while not finished():    s = me('X')    if s[0]:        printboard()        print(""%s wins across %s"" % s)        break    if not finished():        s = you('O')        if s[0]:            printboard()            print(""%s wins across %s"" % s)            breakelse:    print('A draw')  '''
    Tic-tac-toe game player.
    Input the index of where you wish to place your mark at your turn.
''' import random board = list('123456789')wins = ((0,1,2), (3,4,5), (6,7,8),        (0,3,6), (1,4,7), (2,5,8),        (0,4,8), (2,4,6)) def printboard():    print('-+-+-'.join('|'.join(board[x:x+3]) for x in(0,3,6))) def score(board=board):    for w in wins:        b = board[w[0]]        if b in 'XO' and all (board[i] == b for i in w):            return b, [i+1 for i in w]    return None def finished():    return all (b in 'XO' for b in board) def space(board=board):    return [ b for b in board if b not in 'XO'] def my_turn(xo, board):    options = space()    choice = random.choice(options)    board[int(choice)-1] = xo    return choice def my_better_turn(xo, board):    'Will return a next winning move or block your winning move if possible'    ox = 'O' if xo =='X' else 'X'    oneblock = None    options  = [int(s)-1 for s in space(board)]    for choice in options:        brd = board[:]        brd[choice] = xo        if score(brd):            break        if oneblock is None:            brd[choice] = ox            if score(brd):                oneblock = choice    else:        choice = oneblock if oneblock is not None else random.choice(options)    board[choice] = xo    return choice+1 def your_turn(xo, board):    options = space()    while True:        choice = input(""Put your %s in any of these positions: %s ""                       % (xo, ''.join(options))).strip()        if choice in options:            break        print( strv )    board[int(choice)-1] = xo    return choice def me(xo='X'):    printboard()    print('I go at', my_better_turn(xo, board))    return score() def you(xo='O'):    printboard()    
    print('You went at', your_turn(xo, board))    return score()  print(__doc__)while not finished():    s = me('X')    if s:        printboard()        print(""%s wins along %s"" % s)        break    if not finished():        s = you('O')        if s:            printboard()            print(""%s wins along %s"" % s)            breakelse:    print('A draw')"
"gifts = '''
A partridge in a pear tree.
Two turtle doves
Three french hens
Four calling birds
Five golden rings
Six geese a-laying
Seven swans a-swimming
Eight maids a-milking
Nine ladies dancing
Ten lords a-leaping
Eleven pipers piping
Twelve drummers drumming'''.split('') days = '''first second third fourth fifth
          sixth seventh eighth ninth tenth
          eleventh twelfth'''.split() for n, day in enumerate(days, 1):    g = gifts[:n][::-1]    print(('On the %s day of ChristmasMy true love gave to me:' % day) +          ''.join(g[:-1]) +          (' and' + g[-1] if n > 1 else g[-1].capitalize()))"
"out, max_out, max_times = 0, -1, []for job in open('mlijobs.txt'):    out += 1 if strv in job else -1    if out > max_out:        max_out, max_times = out, []    if out == max_out:        max_times.append(job.split()[3]) print(strv % max_out)print('  ' + '  '.join(max_times))"
"from collections import defaultdictimport urllib.request CH2NUM = {ch: str(num) for num, chars in enumerate('abc def ghi jkl mno pqrs tuv wxyz'.split(), 2) for ch in chars}URL = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'  def getwords(url): return urllib.request.urlopen(url).read().decode(strv).lower().split() def mapnum2words(words):    number2words = defaultdict(list)    reject = 0    for word in words:        try:            number2words[''.join(CH2NUM[ch] for ch in word)].append(word)        except KeyError:            
            reject += 1    return dict(number2words), reject def interactiveconversions():    global inp, ch, num    while True:        inp = input(""Type a number or a word to get the translation and textonyms: "").strip().lower()        if inp:            if all(ch in '23456789' for ch in inp):                if inp in num2words:                    print(strv.format(inp, ', '.join(                        num2words[inp])))                else:                    print(strv.format(inp))            elif all(ch in CH2NUM for ch in inp):                num = ''.join(CH2NUM[ch] for ch in inp)                print(strv.format(                    inp, ('' if inp in wordset else strv), num, ', '.join(num2words[num])))            else:                print(strv % inp)        else:            print(strv)            break  if __name__ == '__main__':    words = getwords(URL)    print(strv % (len(words), URL))    wordset = set(words)    num2words, reject = mapnum2words(words)    morethan1word = sum(1 for w in num2words if len(num2words[w]) > 1)    maxwordpernum = max(len(values) for values in num2words.values())    print(strv
There are {0} words in {1} which can be represented by the Textonyms mapping.
They require {2} digit combinations to represent them.
{3} digit combinations represent Textonyms.
strv.format(len(words) - reject, URL, len(num2words), morethan1word))     print(""The numbers mapping to the most words map to %i words each:"" % maxwordpernum)    maxwpn = sorted((key, val) for key, val in num2words.items() if len(val) == maxwordpernum)    for num, wrds in maxwpn:        print(strv % (num, ', '.join(wrds)))     interactiveconversions()"
"import reimport zipfileimport StringIO def munge2(readings):    datePat = re.compile(r'{4}-{2}-{2}')   valuPat = re.compile(r'[-+]?++')   statPat = re.compile(r'-?+')   allOk, totalLines = 0, 0   datestamps = set([])   for line in readings:      totalLines += 1      fields = line.split('')      date = fields[0]      pairs = [(fields[i],fields[i+1]) for i in range(1,len(fields),2)]       lineFormatOk = datePat.match(date) and \         all( valuPat.match(p[0]) for p in pairs ) and \         all( statPat.match(p[1]) for p in pairs )      if not lineFormatOk:         print 'Bad formatting', line         continue       if len(pairs)!=24 or any( int(p[1]) < 1 for p in pairs ):         print 'Missing values', line         continue       if date in datestamps:         print 'Duplicate datestamp', line         continue      datestamps.add(date)      allOk += 1    print 'Lines with all readings: ', allOk   print 'Total records: ', totalLines #zfs = zipfile.ZipFile('readings.zip','r')#readings = StringIO.StringIO(zfs.read('readings.txt'))readings = open('readings.txt','r')munge2(readings)import reimport zipfileimport StringIO def munge2(readings, debug=False):    datePat = re.compile(r'{4}-{2}-{2}')   valuPat = re.compile(r'[-+]?++')   statPat = re.compile(r'-?+')   totalLines = 0   dupdate, badform, badlen, badreading = set(), set(), set(), 0   datestamps = set([])   for line in readings:      totalLines += 1      fields = line.split('')      date = fields[0]      pairs = [(fields[i],fields[i+1]) for i in range(1,len(fields),2)]       lineFormatOk = datePat.match(date) and \         all( valuPat.match(p[0]) for p in pairs ) and \         all( statPat.match(p[1]) for p in pairs )      if not lineFormatOk:         if debug: print 'Bad formatting', line         badform.add(date)       if len(pairs)!=24 or any( int(p[1]) < 1 for p in pairs ):         if debug: print 'Missing values', line      if len(pairs)!=24: badlen.add(date)      if any( int(p[1]) < 1 for p in pairs ): badreading += 1       if date in datestamps:         if debug: print 'Duplicate datestamp', line         dupdate.add(date)       datestamps.add(date)    print 'Duplicate dates: ', '  '.join(sorted(dupdate))    print 'Bad format: ', '  '.join(sorted(badform))    print 'Bad number of fields: ', '  '.join(sorted(badlen))    print 'Records with good readings: %i = %5.2f%%' % (      totalLines-badreading, (totalLines-badreading)/float(totalLines)*100 )   print 'Total records: ', totalLines readings = open('readings.txt','r')munge2(readings)"
"import randomimport collections INT_MASK = 0xFFFFFFFF       
 class IsaacRandom(random.Random):    strv
    Random number generator using the ISAAC algorithm.
    strv     def seed(self, seed=None):        strv
        Initialize internal state.
 
        The seed, if given, can be a string, an integer, or an iterable that contains
        integers only. If no seed is given, a fixed default state is set up; unlike
        our superclass, this class will not attempt to randomize the seed from outside sources.
        strv        def mix():            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK         super().seed(0) 
        if seed is not None:            if isinstance(seed, str):                seed = [ord(x) for x in seed]            elif isinstance(seed, collections.Iterable):                seed = [x & INT_MASK for x in seed]            elif isinstance(seed, int):                val = abs(seed)                seed = []                while val:                    seed.append(val & INT_MASK)                    val >>= 32            else:                raise TypeError('Seed must be string, integer or iterable of integer')             
            if len(seed)>256:                del seed[256:]            elif len(seed)<256:                seed.extend([0]*(256-len(seed)))         self.aa = self.bb = self.cc = 0        self.mm = []        init_state = [0x9e3779b9]*8         for _ in range(4):            mix()         for i in range(0, 256, 8):            if seed is not None:                for j in range(8):                    init_state[j] += seed[i+j]                    init_state[j] &= INT_MASK            mix()            self.mm += init_state         if seed is not None:            for i in range(0, 256, 8):                for j in range(8):                    init_state[j] += self.mm[i+j]                    init_state[j] &= INT_MASK                mix()                for j in range(8):                    self.mm[i+j] = init_state[j]         self.rand_count = 256        self.rand_result = [0]*256     def getstate(self):        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result     def setstate(self, state):        super().setstate(state[0])        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state      def _generate(self):        
        
        self.cc = (self.cc + 1) & INT_MASK        self.bb = (self.bb + self.cc) & INT_MASK         for i in range(256):            x = self.mm[i]            mod = i & 3            if mod==0:                self.aa ^= ((self.aa << 13) & INT_MASK)            elif mod==1:                self.aa ^= (self.aa >> 6)            elif mod==2:                self.aa ^= ((self.aa << 2) & INT_MASK)            else: 
                self.aa ^= (self.aa >> 16)            self.aa = (self.mm[i^128] + self.aa) & INT_MASK            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK         self.rand_count = 0     def next_int(self):        strv        if self.rand_count == 256:            self._generate()        result = self.rand_result[self.rand_count]        self.rand_count += 1        return result     def getrandbits(self, k):        strv        result = 0        ints_needed = (k+31)//32        ints_used = 0        while ints_used < ints_needed:            if self.rand_count == 256:                self._generate()            ints_to_take = min(256-self.rand_count, ints_needed)            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:                result = (result << 32) | val            self.rand_count += ints_to_take            ints_used += ints_to_take        result &= ((1<<k)-1)    
        return result     def random(self):        strv        
        return self.getrandbits(53) * (2**-53)     def rand_char(self):        strv        return self.next_int() % 95 + 32     def vernam(self, msg):        strv
        Encrypt/decrypt the given bytes object with the XOR algorithm, using the current generator state.
 
        To decrypt an encrypted string, restore the state of the generator to the state it had
        during encryption, then call this method with the encrypted string.
        strv        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)     
    ENCIPHER = 'encipher'    DECIPHER = 'decipher'     @staticmethod    def _caesar(ciphermode, ch, shift, modulo, start):        if ciphermode == IsaacRandom.DECIPHER:            shift = -shift        n = ((ch-start)+shift) % modulo        if n<0:            n += modulo        return start+n     def caesar(self, ciphermode, msg, modulo, start):        strv
        Encrypt/decrypt a string using the Caesar algorithm.
 
        For decryption to work, the generator must be in the same state it was during encryption,
        and the same modulo and start parameters must be used.
 
        ciphermode must be one of IsaacRandom.ENCIPHER or IsaacRandom.DECIPHER.
        strv        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg) if __name__=='__main__':    import binascii     def hexify(b):        return binascii.hexlify(b).decode('ascii').upper()     MOD = 95    START = 32     msg = 'a Top Secret secret'    key = 'this is my secret key'    isaac_random = IsaacRandom(key)    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)    isaac_random.seed(key)    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')     print('Message:', msg)    print('Key    :', key)    print('XOR    :', hexify(vernam_encoded))    print('XOR dcr:', vernam_decoded)    print('MOD    :', hexify(caesar_encoded))    print('MOD dcr:', caesar_decoded) "
">>> def isint(f):     return complex(f).imag == 0 and complex(f).real.is_integer() >>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))][True, True, True, False, False, False] >>> 
...>>> isint(25.000000)True>>> isint(24.999999)False>>> isint(25.000100)False>>> isint(-2.1e120)True>>> isint(-5e-2)False>>> isint(float('nan'))False>>> isint(float('inf'))False>>> isint(5.0+0.0j)True>>> isint(5-5j)False >>> a = 1.0000000000000001>>> a1.0>>> 1.0 == 1.0000000000000001True"
"def is_palindrome(s):    '''
        >>> is_palindrome('')
        True
        >>> is_palindrome('a')
        True
        >>> is_palindrome('aa')
        True
        >>> is_palindrome('baa')
        False
        >>> is_palindrome('baab')
        True
        >>> is_palindrome('ba_ab')
        True
        >>> is_palindrome('ba_ ab')
        False
        >>> is_palindrome('ba _ ab')
        True
        >>> is_palindrome('ab'*2)
        False
        >>> x = 'ab' *2**15
        >>> len(x)
        65536
        >>> xreversed = x[::-1]
        >>> is_palindrome(x+xreversed)
        True
        >>> len(x+xreversed)
        131072
        >>> 
    '''    return s == s[::-1] def _test():    import doctest    doctest.testmod()    #doctest.testmod(verbose=True) if __name__ == strv:    _test()"
import sys if strv in sys.stdout.encoding:    print(strv)else:    raise Exception(strv)
"import fileinputimport sys nodata = 0;             
nodata_max=-1;          
nodata_maxline=[];      
 tot_file = 0            
num_file = 0            
 infiles = sys.argv[1:] for line in fileinput.input():  tot_line=0;             
  num_line=0;             
   
  field = line.split()  date  = field[0]  data  = [float(f) for f in field[1::2]]  flags = [int(f)   for f in field[2::2]]   for datum, flag in zip(data, flags):    if flag<1:      nodata += 1    else:      
      if nodata_max==nodata and nodata>0:        nodata_maxline.append(date)      if nodata_max<nodata and nodata>0:        nodata_max=nodata        nodata_maxline=[date]      
      nodata=0;       
      tot_line += datum      num_line += 1   
  tot_file += tot_line  num_file += num_line   print strv % (        date,         len(data) -num_line,         num_line, tot_line,         tot_line/num_line if (num_line>0) else 0) print strvprint strv % (strv.join(infiles),)print strv % (tot_file,)print strv % (num_file,)print strv % (tot_file / num_file,) print ""Maximum run(s) of %i consecutive false readings ends at line starting with date(s): %s"" % (    nodata_max, strv.join(nodata_maxline))"
"#!/usr/bin/env python import time print ""33[?1049h33[H""print strv for i in xrange(5, 0, -1):    print strv, i    time.sleep(1) print ""33[?1049l"""
"class Trit(int):    def __new__(cls, value):        if value == 'TRUE':            value = 1        elif value == 'FALSE':            value = 0        elif value == 'MAYBE':            value = -1        return super(Trit, cls).__new__(cls, value // (abs(value) or 1))      def __repr__(self):        if self > 0:            return 'TRUE'        elif self == 0:            return 'FALSE'        return 'MAYBE'     def __str__(self):        return repr(self)     def __bool__(self):        if self > 0:            return True        elif self == 0:            return False        else:            raise ValueError(strv % self)     def __or__(self, other):        if isinstance(other, Trit):            return _ttable[(self, other)][1]        else:            try:                return _ttable[(self, Trit(bool(other)))][1]            except:                return NotImplemented     def __ror__(self, other):        if isinstance(other, Trit):            return _ttable[(self, other)][1]        else:            try:                return _ttable[(self, Trit(bool(other)))][1]            except:                return NotImplemented     def __and__(self, other):        if isinstance(other, Trit):            return _ttable[(self, other)][0]        else:            try:                return _ttable[(self, Trit(bool(other)))][0]            except:                return NotImplemented     def __rand__(self, other):        if isinstance(other, Trit):            return _ttable[(self, other)][0]        else:            try:                return _ttable[(self, Trit(bool(other)))][0]            except:                return NotImplemented     def __xor__(self, other):        if isinstance(other, Trit):            return _ttable[(self, other)][2]        else:            try:                return _ttable[(self, Trit(bool(other)))][2]            except:                return NotImplemented     def __rxor__(self, other):        if isinstance(other, Trit):            return _ttable[(self, other)][2]        else:            try:                return _ttable[(self, Trit(bool(other)))][2]            except:                return NotImplemented     def __invert__(self):        return _ttable[self]     def __getattr__(self, name):        if name in ('_n', 'flip'):            
            
            
            return _ttable[self]        else:            raise AttributeError    TRUE, FALSE, MAYBE = Trit(1), Trit(0), Trit(-1) _ttable = {    
         TRUE: FALSE,        FALSE:  TRUE,        MAYBE: MAYBE,    
        (MAYBE, MAYBE): (MAYBE, MAYBE, MAYBE),        (MAYBE, FALSE): (FALSE, MAYBE, MAYBE),        (MAYBE,  TRUE): (MAYBE,  TRUE, MAYBE),        (FALSE, MAYBE): (FALSE, MAYBE, MAYBE),        (FALSE, FALSE): (FALSE, FALSE, FALSE),        (FALSE,  TRUE): (FALSE,  TRUE,  TRUE),        ( TRUE, MAYBE): (MAYBE,  TRUE, MAYBE),        ( TRUE, FALSE): (FALSE,  TRUE,  TRUE),        ( TRUE,  TRUE): ( TRUE,  TRUE, FALSE),    }  values = ('FALSE', 'TRUE ', 'MAYBE') print(""Trit logical inverse, '~'"")for a in values:    expr = '~%s' % a    print('  %s = %s' % (expr, eval(expr))) for op, ophelp in (('&', 'and'), ('|', 'or'), ('^', 'exclusive-or')):    print(""Trit logical %s, '%s'"" % (ophelp, op))    for a in values:        for b in values:            expr = '%s %s %s' % (a, op, b)            print('  %s = %s' % (expr, eval(expr)))"
"print """""
"#!/usr/bin/env python print ""33[7mReversed33[m Normal"""
print u'00a3'
"import os def get_windows_terminal():    from ctypes import windll, create_string_buffer    h = windll.kernel32.GetStdHandle(-12)    csbi = create_string_buffer(22)    res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)     #return default size if actual size can't be determined    if not res: return 80, 25      import struct    (bufx, bufy, curx, cury, wattr, left, top, right, bottom, maxx, maxy)\    = struct.unpack(strv, csbi.raw)    width = right - left + 1    height = bottom - top + 1     return width, height def get_linux_terminal():    width = os.popen('tput cols', 'r').readline()    height = os.popen('tput lines', 'r').readline()     return int(width), int(height) print get_linux_terminal() if os.name == 'posix' else get_windows_terminal() "
"print(""33[6;3HHello"")from ctypes import * STD_OUTPUT_HANDLE = -11 class COORD(Structure):    pass COORD._fields_ = [(strv, c_short), (strv, c_short)] def print_at(r, c, s):    h = windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)    windll.kernel32.SetConsoleCursorPosition(h, COORD(c, r))     c = s.encode(strv)    windll.kernel32.WriteConsoleA(h, c_char_p(c), len(c), None, None) print_at(6, 3, strv)"
"import curses scr = curses.initscr()
def move_left():	y,x = curses.getyx()	curses.move(y,x-1) 
def move_right():	y,x = curses.getyx()	curses.move(y,x+1) 
def move_up():	y,x = curses.getyx()	curses.move(y-1,x) 
def move_down():	y,x = curses.getyx()	curses.move(y+1,x) 
def move_line_home()		y,x = curses.getyx()	curses.move(y,0) 
def move_line_end()		y,x = curses.getyx()	maxy,maxx = scr.getmaxyx()	curses.move(y,maxx) 
def move_page_home():	curses.move(0,0) 
def move_page_end():	y,x = scr.getmaxyx()	curses.move(y,x) "
"import osos.system(strv)print ""3[2J""from ctypes import * STD_OUTPUT_HANDLE = -11 class COORD(Structure):    pass COORD._fields_ = [(strv, c_short), (strv, c_short)] class SMALL_RECT(Structure):    pass SMALL_RECT._fields_ = [(strv, c_short), (strv, c_short), (strv, c_short), (strv, c_short)] class CONSOLE_SCREEN_BUFFER_INFO(Structure):    pass CONSOLE_SCREEN_BUFFER_INFO._fields_ = [    (strv, COORD),    (strv, COORD),    (strv, c_ushort),    (strv, SMALL_RECT),    (strv, COORD)] def clear_console():    h = windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)     csbi = CONSOLE_SCREEN_BUFFER_INFO()    windll.kernel32.GetConsoleScreenBufferInfo(h, pointer(csbi))    dwConSize = csbi.dwSize.X * csbi.dwSize.Y     scr = COORD(0, 0)    windll.kernel32.FillConsoleOutputCharacterA(h, c_char(bstrv), dwConSize, scr, pointer(c_ulong()))    windll.kernel32.FillConsoleOutputAttribute(h, csbi.wAttributes, dwConSize, scr, pointer(c_ulong()))    windll.kernel32.SetConsoleCursorPosition(h, scr) clear_console()"
" from colorama import init, Fore, Back, Styleinit(autoreset=True) print Fore.RED + strvprint Back.BLUE + Fore.YELLOW + strvprint strv % (Style.BRIGHT, Style.NORMAL)print Fore.YELLOW  + strvprint Fore.CYAN    + strvprint Fore.GREEN   + strvprint Fore.MAGENTA + strvprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + strv * 40 + strv  from ctypes import * windll.Kernel32.GetStdHandle.restype = c_ulongh = windll.Kernel32.GetStdHandle(c_ulong(0xfffffff5))#Default CMD colour = 7def color(colour):    windll.Kernel32.SetConsoleTextAttribute(h, colour) for count in range (0, 16):    color(count)    print strv + str(count) print strvcolor(7)raw_input(strv) "
"from collections import defaultdictfrom itertools import productfrom pprint import pprint as pp cube2n = {x**3:x for x in range(1, 1201)}sum2cubes = defaultdict(set)for c1, c2 in product(cube2n, cube2n):	if c1 >= c2: sum2cubes[c1 + c2].add((cube2n[c1], cube2n[c2])) taxied = sorted((k, v) for k,v in sum2cubes.items() if len(v) >= 2) #pp(len(taxied))  # 2068for t in enumerate(taxied[:25], 1):    pp(t)print('...')    for t in enumerate(taxied[2000-1:2000+6], 2000):    pp(t)cubes, crev = [x**3 for x in range(1,1200)], {}
for x,x3 in enumerate(cubes): crev[x3] = x + 1 sums = sorted(x+y for x in cubes for y in cubes if y < x) idx = 0for i in range(1, len(sums)-1):    if sums[i-1] != sums[i] and sums[i] == sums[i+1]:        idx += 1        if idx > 25 and idx < 2000 or idx > 2006: continue         n,p = sums[i],[]        for x in cubes:            if n-x < x: break            if n-x in crev:                p.append((crev[x], crev[n-x]))        print strv%(idx,n),        for x in p: print strv%x,        printfrom heapq import heappush, heappop def cubesum():    h,n = [],1    while True:        while not h or h[0][0] > n**3: 
            heappush(h, (n**3 + 1, n, 1))            n += 1         (s, x, y) = heappop(h)        yield((s, x, y))        y += 1        if y < x:    
            heappush(h, (x**3 + y**3, x, y)) def taxis():    out = [(0,0,0)]    for s in cubesum():        if s[0] == out[-1][0]:            out.append(s)        else:            if len(out) > 1: yield(out)            out = [s] n = 0for x in taxis():    n += 1    if n >= 2006: break    if n <= 25 or n >= 2000:        print(n, x)"
"import sys, datetime, shutil #sys.argv[1:] = 'go for it'.split()if len(sys.argv) == 1:    try:        f = open('notes.txt', 'r')        shutil.copyfileobj(f, sys.stdout)        f.close()    except IOError:        passelse:    f = open('notes.txt', 'a')    f.write(datetime.datetime.now().isoformat() + '')    f.write(""%s"" % ' '.join(sys.argv[1:]))    f.close()"
">>> import sqlite3>>> conn = sqlite3.connect(':memory:')>>> c = conn.cursor()>>> c.execute('''create table stocks
(date text, trans text, symbol text,
 qty real, price real)''')<sqlite3.Cursor object at 0x013263B0>>>> 
c.execute(strvinsert into stocks
          values ('2006-01-05','BUY','RHAT',100,35.14)strv) <sqlite3.Cursor object at 0x013263B0>>>> for t in [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),          ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),         ]:	c.execute('insert into stocks values (?,?,?,?,?)', t)  <sqlite3.Cursor object at 0x013263B0><sqlite3.Cursor object at 0x013263B0><sqlite3.Cursor object at 0x013263B0>>>> 
>>> c = conn.cursor()>>> c.execute('select * from stocks order by price')<sqlite3.Cursor object at 0x01326530>>>> for row in c:	print row  (u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.140000000000001)(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)(u'2006-04-05', u'BUY', u'MSOFT', 1000.0, 72.0)>>> "
import timeprint time.ctime()
">>> import sqlite3>>> conn = sqlite3.connect(':memory:')>>> conn.execute('''CREATE TABLE address (
	addrID		INTEGER PRIMARY KEY AUTOINCREMENT,
	addrStreet	TEXT NOT NULL,
	addrCity	TEXT NOT NULL,
	addrState	TEXT NOT NULL,
	addrZIP		TEXT NOT NULL
    )''')<sqlite3.Cursor object at 0x013265C0>>>> "
">>> while True:	k = float(input('K ? '))	print(strv	      % (k, k - 273.15, k * 1.8 - 459.67, k * 1.8))  K ? 21.021 Kelvin = -252.15 Celsius = -421.87 Fahrenheit = 37.8 Rankine degrees.K ? 222.2222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.K ? >>> toK = {'C': (lambda c: c + 273.15),           'F': (lambda f: (f + 459.67) / 1.8),           'R': (lambda r: r / 1.8),           'K': (lambda k: k) }>>> while True:	magnitude, unit = input('<value> <K/R/F/C> ? ').split()	k = toK[unit](float(magnitude))	print(strv	      % (k, k - 273.15, k * 1.8 - 459.67, k * 1.8))  <value> <K/R/F/C> ? 222.2 K222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.<value> <K/R/F/C> ? -50.95 C222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.<value> <K/R/F/C> ? -59.71 F222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.<value> <K/R/F/C> ? 399.96 R222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.<value> <K/R/F/C> ? "
"import sysfrom Queue import Queuefrom threading import Thread lines = Queue(1)count = Queue(1) def read(file):    try:        for line in file:            lines.put(line)    finally:        lines.put(None)    print count.get() def write(file):    n = 0    while 1:        line = lines.get()        if line is None:            break        file.write(line)        n += 1    count.put(n) reader = Thread(target=read, args=(open('input.txt'),))writer = Thread(target=write, args=(sys.stdout,))reader.start()writer.start()reader.join()writer.join()count = 0 def reader():    for line in open('input.txt'):        yield line.rstrip()    print('Printed %d lines.' % count) r = reader() 
for line in r:    print(line)    count += 1def reader():    for line in open('input.txt'):        yield line.rstrip()    count = yield None    print('Printed %d lines.' % count) r = reader()  
for count, line in enumerate(r):    if line is None:        break    print(line)try:     r.send(count)except StopIteration:     pass"
"strv  from __future__ import print_function, division from itertools import permutationsfrom math import factorialimport stringimport datetimeimport gc   MAXN = 7  def s_perm0(n):    strv
    Uses greedy algorithm of adding another char (or two, or three, ...)
    until an unseen perm is formed in the last n chars
    strv    allchars = string.ascii_uppercase[:n]    allperms = [''.join(p) for p in permutations(allchars)]    sp, tofind = allperms[0], set(allperms[1:])    while tofind:        for skip in range(1, n):            for trial_add in (''.join(p) for p in permutations(sp[-n:][:skip])):                #print(sp, skip, trial_add)                trial_perm = (sp + trial_add)[-n:]                if trial_perm in tofind:                    #print(sp, skip, trial_add)                    sp += trial_add                    tofind.discard(trial_perm)                    trial_add = None    
                    break            if trial_add is None:                break    assert all(perm in sp for perm in allperms) 
    return sp def s_perm1(n):    strv
    Uses algorithm of concatenating all perms in order if not already part
    of concatenation.
    strv    allchars = string.ascii_uppercase[:n]    allperms = [''.join(p) for p in sorted(permutations(allchars))]    perms, sp = allperms[::], ''    while perms:        nxt = perms.pop()        if nxt not in sp:            sp += nxt    assert all(perm in sp for perm in allperms)    return sp def s_perm2(n):    strv
    Uses algorithm of concatenating all perms in order first-last-nextfirst-
    nextlast... if not already part of concatenation.
    strv    allchars = string.ascii_uppercase[:n]    allperms = [''.join(p) for p in sorted(permutations(allchars))]    perms, sp = allperms[::], ''    while perms:        nxt = perms.pop(0)        if nxt not in sp:            sp += nxt        if perms:            nxt = perms.pop(-1)            if nxt not in sp:                sp += nxt    assert all(perm in sp for perm in allperms)    return sp def _s_perm3(n, cmp):    strv
    Uses algorithm of concatenating all perms in order first,
    next_with_LEASTorMOST_chars_in_same_position_as_last_n_chars, ...
    strv    allchars = string.ascii_uppercase[:n]    allperms = [''.join(p) for p in sorted(permutations(allchars))]    perms, sp = allperms[::], ''    while perms:        lastn = sp[-n:]        nxt = cmp(perms,                  key=lambda pm:                    sum((ch1 == ch2) for ch1, ch2 in zip(pm, lastn)))        perms.remove(nxt)        if nxt not in sp:            sp += nxt    assert all(perm in sp for perm in allperms)    return sp def s_perm3_max(n):    strv
    Uses algorithm of concatenating all perms in order first,
    next_with_MOST_chars_in_same_position_as_last_n_chars, ...
    strv    return _s_perm3(n, max) def s_perm3_min(n):    strv
    Uses algorithm of concatenating all perms in order first,
    next_with_LEAST_chars_in_same_position_as_last_n_chars, ...
    strv    return _s_perm3(n, min)  longest = [factorial(n) * n for n in range(MAXN + 1)]weight, runtime = {}, {}print(__doc__)for algo in [s_perm0, s_perm1, s_perm2, s_perm3_max, s_perm3_min]:    print('###### %s###' % algo.__name__)    print(algo.__doc__)    weight[algo.__name__], runtime[algo.__name__] = 1, datetime.timedelta(0)    for n in range(1, MAXN + 1):        gc.collect()        gc.disable()        t = datetime.datetime.now()        sp = algo(n)        t = datetime.datetime.now() - t        gc.enable()        runtime[algo.__name__] += t        lensp = len(sp)        wt = (lensp / longest[n]) ** 2        print('  For N=%i: SP length %5i Max: %5i Weight: %5.2f'              % (n, lensp, longest[n], wt))        weight[algo.__name__] *= wt    weight[algo.__name__] **= 1 / n  
    weight[algo.__name__] = 1 / weight[algo.__name__]    print('%*s Overall Weight: %5.2f in %.1f seconds.'          % (29, '', weight[algo.__name__], runtime[algo.__name__].total_seconds())) print('###### Algorithms ordered by shortest superpermutations first###')print(''.join('%12s (%.3f)' % kv for kv in                sorted(weight.items(), key=lambda keyvalue: -keyvalue[1]))) print('###### Algorithms ordered by shortest runtime first###')print(''.join('%12s (%.3f)' % (k, v.total_seconds()) for k, v in                sorted(runtime.items(), key=lambda keyvalue: keyvalue[1]))) from array import arrayfrom string import ascii_uppercase, digitsfrom operator import mul try:    import psyco    psyco.full()except:    pass N_MAX = 12 
def fact_sum(n):    return sum(reduce(mul, xrange(1, m + 1), 1) for m in xrange(1, n + 1))  def r(n, superperm, pos, count):    if not n:        return False     c = superperm[pos - n]    count[n] -= 1    if not count[n]:        count[n] = n        if not r(n - 1, superperm, pos, count):            return False     superperm[pos] = c    pos += 1    return True  def super_perm(n, superperm, pos, count, chars = digits + ascii_uppercase):    assert len(chars) >= N_MAX    pos = n    superperm += array(strv, strv) * (fact_sum(n) - len(superperm))     for i in xrange(n + 1):        count[i] = i    for i in xrange(1, n + 1):        superperm[i - 1] = chars[i]     while r(n, superperm, pos, count):        pass  def main():    superperm = array(strv, strv)    pos = 0    count = array(strv, [0]) * N_MAX     for n in xrange(N_MAX):        super_perm(n, superperm, pos, count)        print strv % (n, len(superperm)),        #print superperm.tostring(),        print main()"
">>> setA = {strv, strv, strv, strv}>>> setB = {strv, strv, strv, strv}>>> setA ^ setB 
{'Jim', 'Serena'}>>> setA - setB 
{'Serena'}>>> setB - setA 
{'Jim'}>>> setA | setB 
{'John', 'Bob', 'Jim', 'Serena', 'Mary'}>>> setA & setB 
{'Bob', 'John', 'Mary'}>>> setA = set([strv, strv, strv, strv])>>> setB = set([strv, strv, strv, strv])>>> setA ^ setB 
set(['Jim', 'Serena'])>>> setA - setB 
set(['Serena'])>>> 
>>> setA.symmetric_difference(setB){'Jim', 'Serena'}>>> setA.difference(setB){'Serena'}>>> setB.difference(setA){'Jim'}>>> setA.union(setB){'Jim', 'Mary', 'Serena', 'John', 'Bob'}>>> setA.intersection(setB){'Mary', 'John', 'Bob'}"
" from itertools import product, islice  def expr(p):    return strv.format(*p)  def gen_expr():    op = ['+', '-', '']    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']  def all_exprs():    values = {}    for expr in gen_expr():        val = eval(expr)        if val not in values:            values[val] = 1        else:            values[val] += 1    return values  def sum_to(val):    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):        print(s)  def max_solve():    print(strv.          format(*max(all_exprs().items(), key=lambda x: x[1])))  def min_solve():    values = all_exprs()    for i in range(123456789):        if i not in values:            print(strv.format(i))            return  def highest_sums(n=10):    sums = map(lambda x: x[0],               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))    print(strv.format(list(sums)))  sum_to(100)max_solve()min_solve()highest_sums()  "
" 

 import matplotlib.pyplot as pltfrom math import sin, cos, pi def sgn(x):	return ((x>0)-(x<0))*1 a,b,n=200,200,2.5 
na=2/nstep=100 
piece=(pi*2)/stepxp=[];yp=[] t=0for t1 in range(step+1):	
	x=(abs((cos(t)))**na)*a*sgn(cos(t))	y=(abs((sin(t)))**na)*b*sgn(sin(t))	xp.append(x);yp.append(y)	t+=piece plt.plot(xp,yp) 
plt.title(strv+str(n))plt.show() "
" def clip(subjectPolygon, clipPolygon):   def inside(p):      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])    def computeIntersection():      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]      dp = [ s[0] - e[0], s[1] - e[1] ]      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]      n2 = s[0] * e[1] - s[1] * e[0]       n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]    outputList = subjectPolygon   cp1 = clipPolygon[-1]    for clipVertex in clipPolygon:      cp2 = clipVertex      inputList = outputList      outputList = []      s = inputList[-1]       for subjectVertex in inputList:         e = subjectVertex         if inside(e):            if not inside(s):               outputList.append(computeIntersection())            outputList.append(e)         elif inside(s):            outputList.append(computeIntersection())         s = e      cp1 = cp2   return(outputList) "
"sum(x*x for x in [1, 2, 3, 4, 5])sum(map(lambda x: x*x, [1, 2, 3, 4, 5]))def mySumSquare(n):    return reduce(lambda x,y : x + y, map(lambda x : x*x, range(n+1)))"
"def sum35a(n):    'Direct count'    
    return sum(x for x in range(n) if x%3==0 or x%5==0) def sum35b(n):     strv    
    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15)) def sum35c(n):    'Sum the arithmetic progressions: sum3 + sum5 - sum15'    consts = (3, 5, 15)    
    divs = [(n-1) // c for c in consts]    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]    return sums[0] + sums[1] - sums[2] #testfor n in range(1001):    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)    assert sa == sb == sc  
 print('For n = %7i -> %i' % (n, sc)) 
for p in range(7):    print('For n = %7i -> %i' % (10**p, sum35c(10**p))) 
p = 20print('For n = %20i -> %i' % (10**p, sum35c(10**p)))"
"print ( sum(1.0 / (x * x) for x in range(1, 1001)) )"
"#!/usr/bin/env python from collections import Counter def decompose_sum(s):    return [(a,s-a) for a in range(2,int(s/2+1))] 
all_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100) 
product_counts = Counter(c*d for c,d in all_pairs)unique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)s_pairs = [(a,b) for a,b in all_pairs if    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))] 
product_counts = Counter(c*d for c,d in s_pairs)p_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1] 
sum_counts = Counter(c+d for c,d in p_pairs)final_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1] print(final_pairs)"
" 
 

 நிரல்பாகம் எண்_கூட்டல்( எண் )  தொகை = 0  @( எண் > 0 ) வரை     d = எண்%10;     பதிப்பி strv,d     எண் = (எண்-d)/10;     தொகை  = தொகை  + d  முடி  பின்கொடு தொகை முடி  பதிப்பி எண்_கூட்டல்( 1289)#20பதிப்பி எண்_கூட்டல்( 123456789)
 def toBaseX(num, base):    output = []    while num:        num, rem = divmod(num, base)        output.append(rem)    return output def sumDigits(num, base=10):    if base < 2:        print strv        return    return sum(toBaseX(num, base)) print sumDigits(1)print sumDigits(12345)print sumDigits(123045)print sumDigits(0xfe, 16)print sumDigits(0xf0e, 16) def sumDigits(num, base=10):    return sum([int(x, base) for x in list(str(num))]) print sumDigits(1)print sumDigits(12345)print sumDigits(123045)print sumDigits('fe', 16)print sumDigits(strv, 16)"
"numbers = [1, 2, 3]total = sum(numbers) product = 1for i in numbers:    product *= ifrom operator import mul, addsum = reduce(add, numbers) 
sum = reduce(add, numbers, 0)product = reduce(mul, numbers) 
product = reduce(mul, numbers, 1)from numpy import r_numbers = r_[1:4]total = numbers.sum()product = numbers.prod()import mathtotal = math.fsum(floats)"
" import collectionss= collections.deque(maxlen=55)
seed = 292929 


s.append(seed)s.append(1) 

for n in xrange(2, 55):    s.append((s[n-2] - s[n-1]) % 10**9) 

 r = collections.deque(maxlen=55)for n in xrange(55):    i = (34 * (n+1)) % 55    r.append(s[i])



  def getnextr():    strv    r.append((r[0]-r[31])%10**9)    return r[54] 
for n in xrange(219 - 54):    getnextr() 

for i in xrange(5):    print strv, getnextr() import collections _ten2nine = 10**9 class Subtractive_generator():     def __init__(self, seed=292929):        self.r = collections.deque(maxlen=55)        s = collections.deque(maxlen=55)        s.extend([seed, 1])        s.extend((s[n-2] - s[n-1]) % _ten2nine for n in range(2, 55))        self.r.extend(s[(34 * (n+1)) % 55] for n in range(55))         for n in range(219 - 54):            self()     def __call__(self):        r = self.r        r.append((r[0] - r[31]) % _ten2nine)        return r[54] if __name__ == '__main__':    srand = Subtractive_generator()    print([srand() for i in range(5)])"
"print strv[1:]     
print strv[:-1]     
print strv[1:-1]   
"
" from string import printableimport random EXAMPLE_KEY = ''.join(sorted(printable, key=lambda _:random.random())) def encode(plaintext, key):    return ''.join(key[printable.index(char)] for char in plaintext) def decode(plaintext, key):    return ''.join(printable[key.index(char)] for char in plaintext) original = strvencoded = encode(original, EXAMPLE_KEY)decoded = decode(encoded, EXAMPLE_KEY)print(strvThe original is: {}
Encoding it with the key: {}
Gives: {}
Decoding it by the same key gives: {}strv.format(    original, EXAMPLE_KEY, encoded, decoded))"
"import sys def subleq(a):    i = 0    try:        while i >= 0:            if a[i] == -1:                a[a[i + 1]] = ord(sys.stdin.read(1))            elif a[i + 1] == -1:                print(chr(a[a[i]]), end=strv)            else:                a[a[i + 1]] -= a[a[i]]                if a[a[i + 1]] <= 0:                    i = a[i + 2]                    continue            i += 3    except (ValueError, IndexError, KeyboardInterrupt):        print(strv)        print(a) subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,        114, 108, 100, 33, 10, 0])"
" def initiate():    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])    for i in range(0, 81, 9):        row.append(range(i, i+9))    for i in range(9):        column.append(range(i, 80+i, 9)) def valid(n, pos):    current_row = pos/9    current_col = pos%9    current_box = (current_row/3)*3 + (current_col/3)    for i in row[current_row]:        if (grid[i] == n):            return False    for i in column[current_col]:        if (grid[i] == n):            return False    for i in box[current_box]:        if (grid[i] == n):            return False    return True def solve():    i = 0    proceed = 1    while(i < 81):        if given[i]:            if proceed:                    i += 1            else:                i -= 1        else:            n = grid[i]            prev = grid[i]            while(n < 9):              if (n < 9):                  n += 1              if valid(n, i):                  grid[i] = n                  proceed = 1                  break            if (grid[i] == prev):               grid[i] = 0               proceed = 0            if proceed:               i += 1            else:               i -=1 def inputs():    nextt = 'T'    number = 0    pos = 0    while(not(nextt == 'N' or nextt == 'n')):        print strv,        pos = int(raw_input())        given[pos - 1] = True        print strv,        number = int(raw_input())        grid[pos - 1] = number        print strv        nextt = raw_input()  grid = [0]*81given = [False]*81box = []row = []column = []initiate()inputs()solve()for i in range(9):    print grid[i*9:i*9+9]raw_input() "
">>> s = 'abcdefgh'>>> n, m, char, chars = 2, 3, 'd', 'cd'>>> 
>>> s[n-1:n+m-1]'bcd'>>> 
>>> s[n-1:]'bcdefgh'>>> 
>>> s[:-1]'abcdefg'>>> 
>>> indx = s.index(char)>>> s[indx:indx+m]'def'>>> 
>>> indx = s.index(chars)>>> s[indx:indx+m]'cde'>>>s <- strvs.0=> strv 
def (substr s start len)  (s start start+len)(substr s 3 2)=> strv 
(s 3 nil)=> strv 
(s 3 -1)=> strv 

let start (pos s pat)  (s start start+m)"
>>> s = '    String with spaces        '>>> s'    String with spaces        '>>> s.lstrip()'String with spaces        '>>> s.rstrip()'    String with spaces'>>> s.strip()'String with spaces'>>> 
"stripped = lambda s: strv.join(i for i in s if 31 < ord(i) < 127) print(stripped(""a00bcdc3""))"
">>> marker, line = '#', 'apples, pears # and bananas'>>> line[:line.index(marker)].strip()'apples, pears'>>> >>> marker, line = ';', '  apples, pears ; and bananas'>>> line[:line.index(marker)].strip()'apples, pears'def remove_comments(line, sep):    for s in sep:        line = line.split(s)[0]    return line.strip() 
print remove_comments('apples ; pears # and bananas', ';#')print remove_comments('apples ; pears # and bananas', '!') import re m = re.match(r'^([^#]*)#(.*)$', line)if m:  
    line = m.group(1) "
"#!/usr/bin/env python
 s = strvs = strv + s  
print(s)s <- strvs <- (strv + s)"
"words = { 
	strv: -624,	strv: -925,	strv:	397,	strv: 452,		strv: 870,		strv: -658,	strv: 362,		strv: 590,	strv: 952,	strv: 44,		strv: 645,	strv: 54,	strv: -326,		strv: 376,	strv: 856,	strv: -983,	strv: 170,		strv: -874,	strv: 503,	strv: 915,		strv: -847,	strv: -982,		strv: 999,	strv: 475,	strv: -880,	strv: 756,		strv: 183,	strv: -266,	strv: 423,	strv: -745,	strv: 813} neg = 0pos = 0for (w,v) in words.iteritems():	if v > 0: pos += v	else:     neg += v sums = [0] * (pos - neg + 1) for (w,v) in words.iteritems():	s = sums[:]	if not s[v - neg]: s[v - neg] = (w,) 	for (i, w2) in enumerate(sums):		if w2 and not s[i + v]:			s[i + v] = w2 + (w,) 	sums = s	if s[-neg]:		for x in s[-neg]:			print(x, words[x])		break>>> from itertools import combinations>>> >>> word2weight = {strv: -624, strv: -915, strv: 397, strv: 452,  strv: 870, strv: -658, strv: 362, strv: 590,  strv: 952, strv: 44, strv: 645, strv: 54,  strv: -326, strv: 376, strv: 856, strv: -983,  strv: 170, strv: -874, strv: 503, strv: 915,  strv: -847, strv: -982, strv: 999, strv: 475,  strv: -880, strv: 756, strv: 183, strv: -266,  strv: 423, strv: -745, strv: 813}>>> answer = None>>> for r in range(1, len(word2weight)+1):	if not answer:		for comb in combinations(word2weight, r):			if sum(word2weight[w] for w in comb) == 0:				answer = [(w, word2weight[w]) for w in comb]				break  >>> answer[('archbishop', -915), ('gestapo', 915)]"
"def _commentstripper(txt, delim):    'Strips first nest of block comments'     deliml, delimr = delim    out = ''    if deliml in txt:        indx = txt.index(deliml)        out += txt[:indx]        txt = txt[indx+len(deliml):]        txt = _commentstripper(txt, delim)        assert delimr in txt, 'Cannot find closing comment delimiter in ' + txt        indx = txt.index(delimr)        out += txt[(indx+len(delimr)):]    else:        out = txt    return out def commentstripper(txt, delim=('/*', '*/')):    'Strips nests of block comments'     deliml, delimr = delim    while deliml in txt:        txt = _commentstripper(txt, delim)    return txtdef test():    print('NON-NESTED BLOCK COMMENT EXAMPLE:')    sample = '''  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */
 
   /**
    * Another comment.
    */
    function something() {
    }'''    print(commentstripper(sample))     print('NESTED BLOCK COMMENT EXAMPLE:')    sample = '''  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   *//*
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */
   */
   /**
    * Another comment.
    */
    function something() {
    }'''    print(commentstripper(sample)) if __name__ == '__main__':    test()"
">>> def stripchars(s, chars):...     return s.translate(None, chars)... >>> stripchars(strv, strv)'Sh ws  soul strppr. Sh took my hrt!'>>> import string>>> def stripchars(s, chars):...     return s.translate(string.maketrans(strv, strv), chars)... >>> stripchars(strv, strv)'Sh ws  soul strppr. Sh took my hrt!'>>> def stripchars(s, chars):...     return strv.join(c for c in s if c not in chars)... >>> stripchars(strv, strv)'Sh ws  soul strppr. Sh took my hrt!'>>> import re>>> def stripchars(s, chars):	return re.sub('[%s]+' % re.escape(chars), '', s) >>> stripchars(strv, strv)'Sh ws  soul strppr. Sh took my hrt!'>>> "
>>> original = 'Mary had a %s lamb.'>>> extra = 'little'>>> original % extra'Mary had a little lamb.'>>> original = 'Mary had a {extra} lamb.'>>> extra = 'little'>>> original.format(**locals())'Mary had a little lamb.'>>> original = 'Mary had a {0} lamb.'>>> extra = 'little'>>> original.format(extra)'Mary had a little lamb.'>>> from string import Template>>> original = Template('Mary had a $extra lamb.')>>> extra = 'little'>>> original.substitute(**locals())'Mary had a little lamb.'
"print len('ascii')

print len(u'05d0'.encode('utf-8'))
print len(u'05d0'.encode('iso-8859-8'))
#!/bin/env python
s = ustrvassert len(s) == 5assert len(s.encode('UTF-8')) == 7assert len(s.encode('UTF-16-BE')) == 10 
import syssys.maxunicode 
print len('ascii')
print len(u'05d0') 

print len('d790'.decode('utf-8')) 

print hex(sys.maxunicode), len(unichr(0x1F4A9))
print hex(sys.maxunicode), len(unichr(0x1F4A9))
print(len(b'Hello, World!'))

print(len('05d0'.encode())) 

print(len('05d0'.encode('iso-8859-8')))
#!/bin/env python
s = strvassert len(s) == 5assert len(s.encode('UTF-8')) == 7assert len(s.encode('UTF-16-BE')) == 10 
u=strvassert len(u.encode()) == 28assert len(u.encode('UTF-16-BE')) == 28print(len(strv)) 
import syssys.maxunicode 
print(len('ascii'))
print(len('05d0')) 

print(len(b'd790'.decode('utf-8'))) 

print(hex(sys.maxunicode), len(unichr(0x1F4A9)))
print(hex(sys.maxunicode), len(unichr(0x1F4A9)))
"
"strv.startswith(strv) #returns Truestrv.endswith(strv) #returns Falsestrv in strv #returns Falsestrv in strv #returns Trueloc = strv.find(strv) #returns -1loc = strv.find(strv) #returns 0loc = strv.find(strv,loc+1) #returns 2"
"s1 = strvprint s1 + strv s2 = s1 + strvprint s2s1 = strvprint strv.join([s1, strv, strv]) s2 = strv.join([s1, strv, strv])print s2"
"def compare(a, b):    print(""%r is of type %r and %r is of type %r""          % (a, type(a), b, type(b)))    if a <  b:      print('%r is strictly less than  %r' % (a, b))    if a <= b:      print('%r is less than or equal to %r' % (a, b))    if a >  b:      print('%r is strictly greater than  %r' % (a, b))    if a >= b:      print('%r is greater than or equal to %r' % (a, b))    if a == b:      print('%r is equal to %r' % (a, b))    if a != b:      print('%r is not equal to %r' % (a, b))    if a is b:      print('%r has object identity with %r' % (a, b))    if a is not b:  print('%r has negated object identity with %r' % (a, b)) compare('YUP', 'YUP')compare('BALL', 'BELL')compare('24', '123')compare(24, 123)compare(5.0, 5)"
import heapqimport sys sources = sys.argv[1:]for item in heapq.merge(open(source) for source in sources):    print(item)
"#!/usr/bin/env python
 str = strv;str += strv;print(str)s <- strvs <- (s + strv)"
"T = [[strv, strv, strv, strv, strv, strv, strv, strv, strv, strv, strv],     [strv,   strv, strv, strv, strv,  strv, strv, strv, strv,  strv, strv],     [strv,  strv, strv, strv, strv, strv, strv, strv, strv, strv, strv],     [strv,  strv, strv, strv, strv, strv, strv, strv, strv, strv, strv]] def straddle(s):    return strv.join(L[0]+T[0][L.index(c)] for c in s.upper() for L in T if c in L) def unstraddle(s):    s = iter(s)    for c in s:        if c in [T[2][0], T[3][0]]:            i = [T[2][0], T[3][0]].index(c)            n = T[2 + i][T[0].index(s.next())]            yield s.next() if n == strv else n        else:            yield T[1][T[0].index(c)] O = strvprint strv, straddle(O)print strv, strv.join(unstraddle(straddle(O)))"
"def stern_brocot(predicate=lambda series: len(series) < 20):    strv
    Generates members of the stern-brocot series, in order, returning them when the predicate becomes false
 
    >>> print('The first 10 values:',
              stern_brocot(lambda series: len(series) < 10)[:10])
    The first 10 values: [1, 1, 2, 1, 3, 2, 3, 1, 4, 3]
    >>>
    strv     sb, i = [1, 1], 0    while predicate(sb):        sb += [sum(sb[i:i + 2]), sb[i + 1]]        i += 1    return sb  if __name__ == '__main__':    from fractions import gcd     n_first = 15    print('The first %i values:  ' % n_first,          stern_brocot(lambda series: len(series) < n_first)[:n_first])    print()    n_max = 10    for n_occur in list(range(1, n_max + 1)) + [100]:        print('1-based index of the first occurrence of %3i in the series:' % n_occur,              stern_brocot(lambda series: n_occur not in series).index(n_occur) + 1)              
              
     print()    n_gcd = 1000    s = stern_brocot(lambda series: len(series) < n_gcd)[:n_gcd]    assert all(gcd(prev, this) == 1               for prev, this in zip(s, s[1:])), 'A fraction from adjacent terms is reducible'>>> from itertools import takewhile, tee, islice>>>  from collections import deque>>> from fractions import gcd>>> >>> def stern_brocot():    sb = deque([1, 1])    while True:        sb += [sb[0] + sb[1], sb[1]]        yield sb.popleft()  >>> [s for _, s in zip(range(15), stern_brocot())][1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4]>>> [1 + sum(1 for i in takewhile(lambda x: x != occur, stern_brocot()))     for occur in (list(range(1, 11)) + [100])][1, 3, 5, 9, 11, 33, 19, 21, 35, 39, 1179]>>> prev, this = tee(stern_brocot(), 2)>>> next(this)1>>> all(gcd(p, t) == 1 for p, t in islice(zip(prev, this), 1000))True>>> "
"s = strvprint s.upper() 
print s.lower() 
 print s.swapcase() 
 print strv.capitalize() 
print strv.title() 
 import stringprint string.capwords(strv) 
print strv.title()          
print string.capwords(strv) 
"
"from collections import namedtuplefrom pprint import pprint as ppfrom math import floor Stem = namedtuple('Stem', 'data, leafdigits') data0 = Stem((12, 127, 28, 42, 39, 113, 42, 18, 44, 118, 44, 37, 113, 124, 37,              48, 127, 36, 29, 31, 125, 139, 131, 115, 105, 132, 104, 123, 35,              113, 122, 42, 117, 119, 58, 109, 23, 105, 63, 27, 44, 105, 99,              41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113, 121, 58, 114,              126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27, 43, 117, 116,              27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118, 117, 38, 27,              106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122, 109, 124, 115,              43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34, 133, 45, 120,              30, 127, 31, 116, 146),             1.0) def stemplot(stem):    d = []    interval = int(10**int(stem.leafdigits))    for data in sorted(stem.data):        data = int(floor(data))        stm, lf = divmod(data,interval)        d.append( (int(stm), int(lf)) )    stems, leafs = list(zip(*d))    stemwidth = max(len(str(x)) for x in stems)    leafwidth = max(len(str(x)) for x in leafs)    laststem, out = min(stems) - 1, []    for s,l in d:        while laststem < s:            laststem += 1            out.append('%*i |' % ( stemwidth, laststem))        out.append(' %0*i' % (leafwidth, l))    out.append('Key: Stem multiplier: %i X | Y  =>  %i*X+Y'               % (interval, interval))    return ''.join(out) if __name__ == '__main__':    print( stemplot(data0) )from collections import OrderedDict, Counter x= [12, 127, 28, 42, 39, 113, 42, 18, 44, 118, 44, 37, 113, 124, 37, 48,    127, 36, 29, 31, 125, 139, 131, 115, 105, 132, 104, 123, 35, 113,    122, 42, 117, 119, 58, 109, 23, 105, 63, 27, 44, 105, 99, 41, 128,    121, 116, 125, 32, 61, 37, 127, 29, 113, 121, 58, 114, 126, 53, 114,    96, 25, 109, 7, 31, 141, 46, 13, 27, 43, 117, 116, 27, 7, 68, 40, 31,    115, 124, 42, 128, 52, 71, 118, 117, 38, 27, 106, 33, 117, 116, 111,    40, 119, 47, 105, 57, 122, 109, 124, 115, 43, 120, 43, 27, 27, 18,    28, 48, 125, 107, 114, 34, 133, 45, 120, 30, 127, 31, 116, 146] def stemleaf(x):    d = OrderedDict((((str(v)[:-1],' ')[v<10], Counter()) for v in sorted(x)))    for s in ((str(v),' '+str(v))[v<10] for v in x) : d[s[:-1]][s[-1]]+=1    m=max(len(s) for s in d)    for k in d:        print('%s%s | %s'%(' '*(m-len(k)),k,' '.join(sorted(d[k].elements())))) stemleaf(x) "
"from __future__ import divisionimport matplotlib.pyplot as plt import random mean, stddev, size = 50, 4, 100000data = [random.gauss(mean, stddev) for c in range(size)] mn = sum(data) / sizesd = (sum(x*x for x in data) / size       - (sum(data) / size) ** 2) ** 0.5 print(strv       % (mn, sd, max(data), min(data), size)) plt.hist(data,bins=50)"
"def sd1(numbers):    if numbers:        mean = sum(numbers) / len(numbers)        sd = (sum((n - mean)**2 for n in numbers) / len(numbers))**0.5        return sd, mean    else:        return 0, 0 def sd2(numbers):    if numbers:        sx = sxx = n = 0        for x in numbers:            sx += x            sxx += x*x            n += 1        sd = (n * sxx - sx*sx)**0.5 / n        return sd, sx / n    else:        return 0, 0 def histogram(numbers):    h = [0] * 10    maxwidth = 50 
    for n in numbers:        h[int(n*10)] += 1    mx = max(h)    print()    for n, i in enumerate(h):        print('%3.1f: %s' % (n / 10, '+' * int(i / mx * maxwidth)))    print() if __name__ == '__main__':    import random    for i in range(1, 6):        n = [random.random() for j in range(10**i)]        print(""#### %i numbers##"" % 10**i)        print('  Naive  method: sd: %8.6f, mean: %8.6f' % sd1(n))        print('  Second method: sd: %8.6f, mean: %8.6f' % sd2(n))        histogram(n)"
"def step_up1()  ""Straightforward implementation: keep track of how many level we
   need to ascend, and stop when this count is zero.""  deficit = 1  while deficit > 0:    if step():      deficit -= 1    else:      deficit += 1def step_up2():  strv  while not step():    step_up2() 
"
import traceback def f(): return g()def g(): traceback.print_stack() f()
"from collections import defaultdict states = [strv, strv, strv, strv,strv, strv, strv, strv, strv,strv, strv, strv, strv, strv, strv, strv,strv, strv, strv, strv, strv,strv, strv, strv, strv, strv,strv, strv, strv, strv, strv,strv, strv, strv, strv, strv,strv, strv, strv, strv,strv, strv, strv, strv, strv, strv,strv, strv, strv, strv,

] states = sorted(set(states)) smap = defaultdict(list)for i, s1 in enumerate(states[:-1]):    for s2 in states[i + 1:]:        smap[strv.join(sorted(s1 + s2))].append(s1 + strv + s2) for pairs in sorted(smap.itervalues()):    if len(pairs) > 1:        print strv.join(pairs)"
 import pyttsx engine = pyttsx.init()engine.say(strv)engine.runAndWait() 
"import itertools try: input = raw_inputexcept: pass s = input()groups = []for _, g in itertools.groupby(s):    groups.append(''.join(g))print('      input string:  %s' % s)print('     output string:  %s' % ', '.join(groups))"
"import mysql.connector import hashlib import sys	 import random	  DB_HOST = strv	 DB_USER = strv DB_PASS = strv	 DB_NAME = strv	  def connect_db():	     ''' Try to connect DB and return DB instance, if not, return False '''	     try:	         return mysql.connector.connect(host=DB_HOST, user=DB_USER, passwd=DB_PASS, db=DB_NAME)	     except:	         return False	  def create_user(username, passwd):	     ''' if user was successfully created, returns its ID; returns None on error '''	     db = connect_db()	     if not db:	         print strv        return None     cursor = db.cursor()	      salt = randomValue(16)	 	     passwd_md5 = hashlib.md5(salt+passwd).hexdigest()	      
    try:	         cursor.execute(strv, (username, salt, passwd_md5))         cursor.execute(strv, (username,) )         id = cursor.fetchone()        db.commit()        cursor.close()        db.close()        return id[0]	     except:	         print 'Username was already taken. Please select another'	         return None def authenticate_user(username, passwd):	     db = connect_db()	     if not db:	         print strv        return False     cursor = db.cursor()	      cursor.execute(strv, (username,))     row = cursor.fetchone()    cursor.close()    db.close()    if row is None:     
        return False    salt = row[0]    correct_md5 = row[1]    tried_md5 = hashlib.md5(salt+passwd).hexdigest()    return correct_md5 == tried_md5 def randomValue(length):	     ''' Creates random value with given length'''	     salt_chars = 'abcdefghijklmnopqrstuvwxyz0123456789'     return ''.join(random.choice(salt_chars) for x in range(length)) if __name__ == '__main__':	     user = randomValue(10)    passwd = randomValue(16)	      new_user_id = create_user(user, passwd)    if new_user_id is None:        print 'Failed to create user %s' % user        sys.exit(1)    auth = authenticate_user(user, passwd)	     if auth:	         print 'User %s authenticated successfully' % user	     else:	         print 'User %s failed' % user "
"def spiral(n):    dx,dy = 1,0            
    x,y = 0,0              
    myarray = [[None]* n for j in range(n)]    for i in xrange(n**2):        myarray[x][y] = i        nx,ny = x+dx, y+dy        if 0<=nx<n and 0<=ny<n and myarray[nx][ny] == None:            x,y = nx,ny        else:            dx,dy = -dy,dx            x,y = x+dx, y+dy    return myarray def printspiral(myarray):    n = range(len(myarray))    for y in n:        for x in n:            print strv % myarray[x][y],        print printspiral(spiral(5))def spiral(n):    def spiral_part(x, y, n):        if x == -1 and y == 0:            return -1        if y == (x+1) and x < (n // 2):            return spiral_part(x-1, y-1, n-1) + 4*(n-y)        if x < (n-y) and y <= x:            return spiral_part(y-1, y, n) + (x-y) + 1        if x >= (n-y) and y <= x:            return spiral_part(x, y-1, n) + 1        if x >= (n-y) and y > x:            return spiral_part(x+1, y, n) + 1        if x < (n-y) and y > x:            return spiral_part(x, y-1, n) - 1     array = [[0] * n for j in xrange(n)]    for x in xrange(n):        for y in xrange(n):            array[x][y] = spiral_part(y, x, n)    return array for row in spiral(5):    print strv.join(strv % x for x in row)def rot_right(a):    return zip(*a[::-1]) def sp(m, n, start = 0):    strv Generate number range spiral of dimensions m x n
    strv    if n == 0:        yield ()    else:        yield tuple(range(start, m + start))        for row in rot_right(list(sp(n - 1, m, m + start))):            yield row def spiral(m):    return sp(m, m) for row in spiral(5):    print(''.join('%3i' % i for i in row))def spiral(n):    dat = [[None] * n for i in range(n)]    le = [[i + 1, i + 1] for i in reversed(range(n))]    le = sum(le, [])[1:]  
    dxdy = [[1, 0], [0, 1], [-1, 0], [0, -1]] * ((len(le) + 4) / 4)  
    x, y, val = -1, 0, -1    for steps, (dx, dy) in zip(le, dxdy):        x, y, val = x + dx, y + dy, val + 1        for j in range(steps):            dat[y][x] = val            if j != steps-1:                x, y, val = x + dx, y + dy, val + 1    return dat for row in spiral(5): 
    print ' '.join('%3s' % x for x in row)import itertools concat = itertools.chain.from_iterabledef partial_sums(items):    s = 0    for x in items:        s += x        yield s grade = lambda xs: sorted(range(len(xs)), key=xs.__getitem__)values = lambda n: itertools.cycle([1,n,-1,-n])counts = lambda n: concat([i,i-1] for i in range(n,0,-1))reshape = lambda n, xs: zip(*([iter(xs)] * n)) spiral = lambda n: reshape(n, grade(list(partial_sums(concat(                       [v]*c for c,v in zip(counts(n), values(n))))))) for row in spiral(5):    print(' '.join('%3s' % x for x in row))def spiral_matrix(n):    m = [[0] * n for i in range(n)]    dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]    x, y, c = 0, -1, 1    for i in range(n + n - 1):        for j in range((n + n - i) // 2):            x += dx[i % 4]            y += dy[i % 4]            m[x][y] = c            c += 1    return mfor i in spiral_matrix(5): print(*i)"
"names = sorted((set(globals().keys()) | set(__builtins__.__dict__.keys())) - set('_ names i'.split()))print( ''.join(' '.join(names[i:i+8]) for i in range(0, len(names), 8)) )"
"import retry: raw_inputexcept: raw_input = input 
try: bar = u'▁▂▃▄▅▆▇█'except: bar = '▁▂▃▄▅▆▇█'barcount = len(bar) - 1while True:    line = raw_input('Numbers please separated by space/commas: ')    numbers = [float(n) for n in re.split(r'[,]+', line.strip())]    mn, mx = min(numbers), max(numbers)    extent = mx - mn    sparkline = ''.join(bar[int( (n - mn) / extent * barcount)]                        for n in numbers)    print('min: %5f; max: %5f' % (mn, mx))    print(sparkline)"
"from collections import dequestack = deque()stack.append(value) 
value = stack.pop()not stack 
from collections import deque class Stack:    def __init__(self):        self._items = deque()    def append(self, item):        self._items.append(item)    def pop(self):        return self._items.pop()    def __nonzero__(self):        return bool(self._items)class Stack:    def __init__(self):        self._first = None    def __nonzero__(self):        return self._first is not None     def append(self, value):        self._first = (value, self._first)    def pop(self):        if self._first is None:            raise IndexError, strv        value, self._first = self._first        return valuewhile not stack.empty():while stack:"
"import copy guyprefers = { 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'], 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'], 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'], 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'], 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'], 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'], 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'], 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'], 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'], 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}galprefers = { 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'], 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'], 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'], 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'], 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'], 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'], 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'], 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'], 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'], 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']} guys = sorted(guyprefers.keys())gals = sorted(galprefers.keys())  def check(engaged):    inverseengaged = dict((v,k) for k,v in engaged.items())    for she, he in engaged.items():        shelikes = galprefers[she]        shelikesbetter = shelikes[:shelikes.index(he)]        helikes = guyprefers[he]        helikesbetter = helikes[:helikes.index(she)]        for guy in shelikesbetter:            guysgirl = inverseengaged[guy]            guylikes = guyprefers[guy]            if guylikes.index(guysgirl) > guylikes.index(she):                print(strv                      strv                      % (she, guy, he, guysgirl))                return False        for gal in helikesbetter:            girlsguy = engaged[gal]            gallikes = galprefers[gal]            if gallikes.index(girlsguy) > gallikes.index(he):                print(strv                      strv                      % (he, gal, she, girlsguy))                return False    return True def matchmaker():    guysfree = guys[:]    engaged  = {}    guyprefers2 = copy.deepcopy(guyprefers)    galprefers2 = copy.deepcopy(galprefers)    while guysfree:        guy = guysfree.pop(0)        guyslist = guyprefers2[guy]        gal = guyslist.pop(0)        fiance = engaged.get(gal)        if not fiance:            
            engaged[gal] = guy            print(strv % (guy, gal))        else:            
            galslist = galprefers2[gal]            if galslist.index(fiance) > galslist.index(guy):                
                engaged[gal] = guy                print(strv % (gal, fiance, guy))                if guyprefers2[fiance]:                    
                    guysfree.append(fiance)            else:                
                if guyslist:                    
                    guysfree.append(guy)    return engaged  print('Engagements:')engaged = matchmaker() print('Couples:')print('  ' + ',  '.join('%s is engaged to %s' % couple                          for couple in sorted(engaged.items())))print()print('Engagement stability check PASSED'      if check(engaged) else 'Engagement stability check FAILED') print('Swapping two fiances to introduce an error')engaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]for gal in gals[:2]:    print('  %s is now engaged to %s' % (gal, engaged[gal]))print()print('Engagement stability check PASSED'      if check(engaged) else 'Engagement stability check FAILED')"
">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]>>> def stoogesort(L, i=0, j=None):	if j is None:		j = len(L) - 1	if L[j] < L[i]:		L[i], L[j] = L[j], L[i]	if j - i > 1:		t = (j - i + 1) // 3		stoogesort(L, i  , j-t)		stoogesort(L, i+t, j  )		stoogesort(L, i  , j-t)	return L >>> stoogesort(data)[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]>>> def stoogesort(L, i, j):	if L[j] < L[i]:		L[i], L[j] = L[j], L[i]	if j - i > 1:		t = (j - i + 1) // 3		stoogesort(L, i  , j-t)		stoogesort(L, i+t, j  )		stoogesort(L, i  , j-t)	return L >>> def stooge(L): return stoogesort(L, 0, len(L) - 1) >>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]>>> stooge(data)[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]"
"from time import sleepfrom threading import Timer def sleepsort(values):    sleepsort.result = []    def add1(x):        sleepsort.result.append(x)    mx = values[0]    for v in values:        if mx < v: mx = v        Timer(v, add1, [v]).start()    sleep(mx+1)    return sleepsort.result if __name__ == '__main__':    x = [3,2,4,7,3,6,9,1]    if sleepsort(x) == sorted(x):        print('sleep sort worked for:',x)    else:        print('sleep sort FAILED for:',x)"
"from itertools import groupby def soundex(word):   codes = (strv,strv, strv, strv, strv, strv)   soundDict = dict((ch, str(ix+1)) for ix,cod in enumerate(codes) for ch in cod)   cmap2 = lambda kar: soundDict.get(kar, '9')   sdx =  ''.join(cmap2(kar) for kar in word.lower())   sdx2 = word[0].upper() + ''.join(k for k,g in list(groupby(sdx))[1:] if k!='9')   sdx3 = sdx2[0:4].ljust(4,'0')   return sdx3 >>>print soundex(strv)S532>>>print soundex(strv)E251>>>print soundex(strv)C532>>>print soundex(strv)E251"
"def merge_list(a, b):	out = []	while len(a) and len(b):		if a[0] < b[0]:			out.append(a.pop(0))		else:			out.append(b.pop(0))	out += a	out += b	return out def strand(a):	i, s = 0, [a.pop(0)]	while i < len(a):		if a[i] > s[-1]:			s.append(a.pop(i))		else:			i += 1	return s def strand_sort(a):	out = strand(a)	while len(a):		out = merge_list(out, strand(a))	return out print strand_sort([1, 6, 3, 2, 1, 7, 5, 3])"
"  def shell(seq):    inc = len(seq) // 2    while inc:        for i, el in enumerate(seq):            while i >= inc and seq[i - inc] > el:                seq[i] = seq[i - inc]                i -= inc            seq[i] = el        inc = 1 if inc == 2 else int(inc * 5.0 / 11) data = [22, 7, 2, -5, 8, 4]shell(data)print data 
"
"from itertools import permutations in_order = lambda s: all(x <= s[i+1] for i,x in enumerate(s[:-1]))perm_sort = lambda s: (p for p in permutations(s) if in_order(p)).next()"
"from functools import total_orderingfrom bisect import bisect_leftfrom heapq import merge @total_orderingclass Pile(list):    def __lt__(self, other): return self[-1] < other[-1]    def __eq__(self, other): return self[-1] == other[-1] def patience_sort(n):    piles = []    
    for x in n:        new_pile = Pile([x])        i = bisect_left(piles, new_pile)        if i != len(piles):            piles[i].append(x)        else:            piles.append(new_pile)     
    n[:] = merge(*[reversed(pile) for pile in piles]) if __name__ == strv:    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]    patience_sort(a)    print a"
"#python2.6 <from math import log def getDigit(num, base, digit_num):    
    return (num // base ** digit_num) % base   def makeBlanks(size):    
    return [ [] for i in range(size) ]   def split(a_list, base, digit_num):    buckets = makeBlanks(base)    for num in a_list:        
        buckets[getDigit(num, base, digit_num)].append(num)      return buckets 
def merge(a_list):    new_list = []    for sublist in a_list:       new_list.extend(sublist)    return new_list def maxAbs(a_list):    
    return max(abs(num) for num in a_list) def split_by_sign(a_list):    
    
    buckets = [[], []]    for num in a_list:        if num < 0:            buckets[0].append(num)        else:            buckets[1].append(num)    return buckets def radixSort(a_list, base):    
    passes = int(round(log(maxAbs(a_list), base)) + 1)     new_list = list(a_list)    for digit_num in range(passes):        new_list = merge(split(new_list, base, digit_num))    return merge(split_by_sign(new_list)) "
"def selection_sort(lst):    for i, e in enumerate(lst):        mn = min(range(i,len(lst)), key=lst.__getitem__)        lst[i], lst[mn] = lst[mn], e    return lst"
"tutor = False def pancakesort(data):    if len(data) <= 1:        return data    if tutor: print()    for size in range(len(data), 1, -1):        maxindex = max(range(size), key=data.__getitem__)        if maxindex+1 != size:            
            if maxindex != 0:                
                if tutor: print('With: %r doflip  %i'                                % ( ' '.join(str(x) for x in data), maxindex+1 ))                data[:maxindex+1] = reversed(data[:maxindex+1])            
            if tutor: print('With: %r  doflip %i'                                % ( ' '.join(str(x) for x in data), size ))            data[:size] = reversed(data[:size])    if tutor: print()if __name__ == '__main__':    import random     tutor = True    data = list('123456789')    while data == sorted(data):        random.shuffle(data)    print('Original List: %r' % ' '.join(data))    pancakesort(data)    print('Pancake Sorted List: %r' % ' '.join(data))"
"from heapq import merge def merge_sort(m):    if len(m) <= 1:        return m     middle = len(m) // 2    left = m[:middle]    right = m[middle:]     left = merge_sort(left)    right = merge_sort(right)    return list(merge(left, right))def merge(left, right):    result = []    left_idx, right_idx = 0, 0    while left_idx < len(left) and right_idx < len(right):        
        if left[left_idx] <= right[right_idx]:            result.append(left[left_idx])            left_idx += 1        else:            result.append(right[right_idx])            right_idx += 1     if left_idx < len(left):        result.extend(left[left_idx:])    if right_idx < len(right):        result.extend(right[right_idx:])    return result"
"def quickSort(arr):    less = []    pivotList = []    more = []    if len(arr) <= 1:        return arr    else:        pivot = arr[0]        for i in arr:            if i < pivot:                less.append(i)            elif i > pivot:                more.append(i)            else:                pivotList.append(i)        less = quickSort(less)        more = quickSort(more)        return less + pivotList + more a = [4, 65, 2, -31, 0, 99, 83, 782, 1]a = quickSort(a)def qsort(L):    return (qsort([y for y in L[1:] if y <  L[0]]) +             L[:1] +             qsort([y for y in L[1:] if y >= L[0]])) if len(L) > 1 else Ldef qsort(list):    if not list:        return []    else:        pivot = list[0]        less = [x for x in list     if x <  pivot]        more = [x for x in list[1:] if x >= pivot]        return qsort(less) + [pivot] + qsort(more)from random import * def qSort(a):    if len(a) <= 1:        return a    else:        q = choice(a)        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])def quickSort(a):    if len(a) <= 1:        return a    else:        less = []        more = []        pivot = choice(a)        for i in a:            if i < pivot:                less.append(i)            if i > pivot:                more.append(i)        less = quickSort(less)        more = quickSort(more)        return less + [pivot] * a.count(pivot) + moredef qsort(array):    if len(array) < 2:        return array    head, *tail = array    less = qsort([i for i in tail if i < head])    more = qsort([i for i in tail if i >= head])    return less + [head] + moredef quicksort(array):    _quicksort(array, 0, len(array) - 1) def _quicksort(array, start, stop):    if stop - start > 0:        pivot, left, right = array[start], start, stop        while left <= right:            while array[left] < pivot:                left += 1            while array[right] > pivot:                right -= 1            if left <= right:                array[left], array[right] = array[right], array[left]                left += 1                right -= 1        _quicksort(array, start, right)        _quicksort(array, left, stop)def (qsort (pivot ... ns))  (+ (qsort+keep (fn(_) (_ < pivot)) ns)     list.pivot     (qsort+keep (fn(_) (_ > pivot)) ns)) def (qsort x) :case x=nil  nil"
">>> def gnomesort(a):	i,j,size = 1,2,len(a)	while i < size:		if a[i-1] <= a[i]:			i,j = j, j+1		else:			a[i-1],a[i] = a[i],a[i-1]			i -= 1			if i == 0:				i,j = j, j+1	return a >>> gnomesort([3,4,2,5,1,6])[1, 2, 3, 4, 5, 6]>>>"
"def heapsort(lst):  ''' Heapsort. Note: this function sorts in-place (it mutates the list). '''   
  for start in range((len(lst)-2)/2, -1, -1):    siftdown(lst, start, len(lst)-1)   for end in range(len(lst)-1, 0, -1):    lst[end], lst[0] = lst[0], lst[end]    siftdown(lst, 0, end - 1)  return lst def siftdown(lst, start, end):  root = start  while True:    child = root * 2 + 1    if child > end: break    if child + 1 <= end and lst[child] < lst[child + 1]:      child += 1    if lst[root] < lst[child]:      lst[root], lst[child] = lst[child], lst[root]      root = child    else:      break"
"def cycleSort(vector):    strv    writes = 0     
    for cycleStart, item in enumerate(vector):         
        pos = cycleStart        for item2 in vector[cycleStart + 1:]:            if item2 < item:                pos += 1         
        if pos == cycleStart:            continue         
        while item == vector[pos]:            pos += 1        vector[pos], item = item, vector[pos]        writes += 1         
        while pos != cycleStart:             
            pos = cycleStart            for item2 in vector[cycleStart + 1:]:                if item2 < item:                    pos += 1             
            while item == vector[pos]:                pos += 1            vector[pos], item = item, vector[pos]            writes += 1     return writes  if __name__ == '__main__':    x = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]    xcopy = x[::]    writes = cycleSort(xcopy)    if xcopy != sorted(x):        print('Wrong order!')    else:        print('%rIs correctly sorted using cycleSort to'              '%rUsing %i writes.' % (x, xcopy, writes))"
">>> from collections import defaultdict>>> def countingSort(array, mn, mx):	count = defaultdict(int)	for i in array:		count[i] += 1	result = []	for j in range(mn,mx+1):		result += [j]* count[j]	return result >>> data = [9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4]>>> mini,maxi = 1,10>>> countingSort(data, mini, maxi) == sorted(data)Truedef countingSort(a, min, max):    cnt = [0] * (max - min + 1)    for x in a:        cnt[x - min] += 1     return [x for x, n in enumerate(cnt, start=min)              for i in xrange(n)]"
"def cocktailSort(A):    up = range(len(A)-1)    while True:        for indices in (up, reversed(up)):            swapped = False            for i in indices:                if A[i] > A[i+1]:                      A[i], A[i+1] =  A[i+1], A[i]                    swapped = True            if not swapped:                returntest1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]cocktailSort(test1)print test1#>>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] test2=list('big fjords vex quick waltz nymph')cocktailSort(test2)print ''.join(test2)#>>>      abcdefghiijklmnopqrstuvwxyzdef cocktail(a):    for i in range(len(a)//2):        swap = False        for j in range(1+i, len(a)-i):            if a[j] < a[j-1]:                a[j], a[j-1] = a[j-1], a[j]                swap = True        if not swap:            break        swap = False        for j in range(len(a)-i-1, i, -1):            if a[j] < a[j-1]:                a[j], a[j-1] = a[j-1], a[j]                swap = True        if not swap:            break"
">>> def combsort(input):    gap = len(input)    swaps = True    while gap > 1 or swaps:        gap = max(1, int(gap / 1.25))  
        swaps = False        for i in range(len(input) - gap):            j = i+gap            if input[i] > input[j]:                input[i], input[j] = input[j], input[i]                swaps = True  >>> y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]>>> combsort(y)>>> assert y == sorted(y)>>> y[0, 4, 5, 8, 14, 18, 20, 31, 33, 44, 62, 70, 73, 75, 76, 78, 81, 82, 84, 88]>>> "
" #python3#tests: expect no output.#doctest with  python3 -m doctest thisfile.py#additional tests:  python3 thisfile.py def circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':    '''
        >>> L = [3, 2, 8, 28, 2,]
        >>> circle_sort(L)
        3
        >>> print(L)
        [2, 2, 3, 8, 28]
        >>> L = [3, 2, 8, 28,]
        >>> circle_sort(L)
        1
        >>> print(L)
        [2, 3, 8, 28]
    '''    n = R-L    if n < 2:        return 0    swaps = 0    m = n//2    for i in range(m):        if A[R-(i+1)] < A[L+i]:            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)            swaps += 1    if (n & 1) and (A[L+m] < A[L+m-1]):        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)        swaps += 1    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R) def circle_sort(L:list)->'sort A in place, returning the number of swaps':    swaps = 0    s = 1    while s:        s = circle_sort_backend(L, 0, len(L))        swaps += s    return swaps 
if __name__ == '__main__':    from random import shuffle    for i in range(309):        L = list(range(i))        M = L[:]        shuffle(L)        N = L[:]        circle_sort(L)        if L != M:            print(len(L))            print(N)            print(L) "
"def insertion_sort(l):    for i in xrange(1, len(l)):        j = i-1         key = l[i]        while (l[j] > key) and (j >= 0):           l[j+1] = l[j]           j -= 1        l[j+1] = keydef insertion_sort_bin(seq):    for i in range(1, len(seq)):        key = seq[i]        
        
        
        low, up = 0, i        while up > low:            middle = (low + up) // 2            if seq[middle] < key:                low = middle + 1                          else:                up = middle        
        seq[:] = seq[:low] + [key] + seq[low:i] + seq[i + 1:]import bisectdef insertion_sort_bin(seq):    for i in range(1, len(seq)):        bisect.insort(seq, seq.pop(i), 0, i)"
"def bubble_sort(seq):    strvInefficiently sort the mutable sequence (list) in place.
       seq MUST BE A MUTABLE SEQUENCE.
 
       As with list.sort() and random.shuffle this does NOT return 
    strv    changed = True    while changed:        changed = False        for i in xrange(len(seq) - 1):            if seq[i] > seq[i+1]:                seq[i], seq[i+1] = seq[i+1], seq[i]                changed = True    return seq if __name__ == strv:   strv    from random import shuffle    testset = range(100)   testcase = testset[:] 
   shuffle(testcase)   assert testcase != testset  
   bubble_sort(testcase)   assert testcase == testset  
"
"try:  from itertools import zip_longestexcept:  try:    from itertools import izip_longest as zip_longest  except:    zip_longest = lambda *args: map(None, *args) def beadsort(l):  return map(len, columns(columns([[1] * e for e in l]))) def columns(l):  return [filter(None, x) for x in zip_longest(*l)] 
print(beadsort([5,3,1,7,4,1,1]))"
"strings = strv.split() def mykey(x):    return -len(x), x.upper() print sorted(strings, key=mykey)['strings', 'sample', 'sorted', 'here', 'Some', 'are', 'be', 'to']def mycmp(s1, s2):    return cmp(len(s2), len(s1)) or cmp(s1.upper(), s2.upper()) print sorted(strings, cmp=mycmp)"
">>> def sort_disjoint_sublist(data, indices):	indices = sorted(indices)	values  = sorted(data[i] for i in indices)	for index, value in zip(indices, values):		data[index] = value  >>> d = [7, 6, 5, 4, 3, 2, 1, 0]>>> i = set([6, 1, 7])>>> sort_disjoint_sublist(d, i)>>> d[7, 0, 5, 4, 3, 2, 1, 6]>>> 
>>> def sort_disjoint_sublist(data, indices):	for index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value  >>> "
"import random def bogosort(l):    while not in_order(l):        random.shuffle(l)    return l def in_order(l):    if not l:        return True    last = l[0]    for x in l[1:]:        if x < last:            return False        last = x    return Truedef in_order(l):    return all( l[i] <= l[i+1] for i in xrange(0,len(l)-1))import randomdef bogosort(lst):   random.shuffle(lst)  
   while lst != sorted(lst):       random.shuffle(lst)   return lstimport operatorimport randomfrom itertools import dropwhile, imap, islice, izip, repeat, starmap def shuffled(x):    x = x[:]    random.shuffle(x)    return x bogosort = lambda l: next(dropwhile(    lambda l: not all(starmap(operator.le, izip(l, islice(l, 1, None)))),    imap(shuffled, repeat(l))))"
"people = [('joe', 120), ('foo', 31), ('bar', 51)]sorted(people)[('bar', 51), ('foo', 31), ('joe', 120)]from operator import itemgetterpeople = [(120, 'joe'), (31, 'foo'), (51, 'bar')]people.sort(key=itemgetter(1))[(51, 'bar'), (31, 'foo'), (120, 'joe')]"
" data = [    '1.3.6.1.4.1.11.2.17.19.3.4.0.10',    '1.3.6.1.4.1.11.2.17.5.2.0.79',    '1.3.6.1.4.1.11.2.17.19.3.4.0.4',    '1.3.6.1.4.1.11150.3.4.0.1',    '1.3.6.1.4.1.11.2.17.19.3.4.0.1',    '1.3.6.1.4.1.11150.3.4.0'] for s in sorted(data, key=lambda x: list(map(int, x.split('.')))):    print(s) "
"from __future__ import print_functionfrom itertools import permutationsfrom enum import Enum A, B, C, D, E, F, G, H = Enum('Peg', 'A, B, C, D, E, F, G, H') connections = ((A, C), (A, D), (A, E),               (B, D), (B, E), (B, F),               (G, C), (G, D), (G, E),               (H, D), (H, E), (H, F),               (C, D), (D, E), (E, F))  def ok(conn, perm):    strv    this, that = (c.value - 1 for c in conn)    return abs(perm[this] - perm[that]) != 1  def solve():    return [perm for perm in permutations(range(1, 9))            if all(ok(conn, perm) for conn in connections)]  if __name__ == '__main__':    solutions = solve()    print(strv, ', '.join(str(i) for i in solutions[0]))def pp(solution):    strv    boardformat = rstrv
         A   B
        /|/|
       / | X | 
      /  |/   
     C - D - E - F
       |/|  /
       | X | /
        / /
         G   Hstrv    for letter, number in zip(strv, solution):        boardformat = boardformat.replace(letter, str(number))    print(boardformat)  if __name__ == '__main__':    for i, s in enumerate(solutions, 1):        print(""Solution"", i, end='')        pp(s)"
"nums = [2,4,3,1,2]nums.sort()nums = sorted([2,4,3,1,2])"
"board = []given = []start = None def setup(s):    global board, given, start    lines = s.splitlines()    ncols = len(lines[0].split())    nrows = len(lines)    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]     for r, row in enumerate(lines):        for c, cell in enumerate(row.split()):            if cell == strv :                board[r + 1][c + 1] = 0                continue            elif cell == strv:                continue 
            else:                val = int(cell)                board[r + 1][c + 1] = val                given.append(val)                if val == 1:                    start = (r + 1, c + 1)    given.sort() def solve(r, c, n, next=0):    if n > given[-1]:        return True    if board[r][c] and board[r][c] != n:        return False    if board[r][c] == 0 and given[next] == n:        return False     back = 0    if board[r][c] == n:        next += 1        back = n     board[r][c] = n    for i in xrange(-1, 2):        for j in xrange(-1, 2):            if solve(r + i, c + j, n + 1, next):                return True    board[r][c] = back    return False def print_board():    d = {-1: strv, 0: strv}    bmax = max(max(r) for r in board)    form = strv + str(len(str(bmax)) + 1) + strv    for r in board[1:-1]:        print strv.join(form % d.get(c, str(c)) for c in r[1:-1]) hi = strv
__ 33 35 __ __  .  .  .
__ __ 24 22 __  .  .  .
__ __ __ 21 __ __  .  .
__ 26 __ 13 40 11  .  .
27 __ __ __  9 __  1  .
 .  . __ __ 18 __ __  .
 .  .  .  . __  7 __ __
 .  .  .  .  .  .  5 __strv setup(hi)print_board()solve(start[0], start[1], 1)printprint_board()"
"from array import arrayfrom collections import dequeimport psyco data = []nrows = 0px = py = 0sdata = strvddata = strv def init(board):    global data, nrows, sdata, ddata, px, py    data = filter(None, board.splitlines())    nrows = max(len(r) for r in data)     maps = {' ':' ', '.': '.', '@':' ', '#':'#', '$':' '}    mapd = {' ':' ', '.': ' ', '@':'@', '#':' ', '$':'*'}     for r, row in enumerate(data):        for c, ch in enumerate(row):            sdata += maps[ch]            ddata += mapd[ch]            if ch == '@':                px = c                py = r def push(x, y, dx, dy, data):    if sdata[(y+2*dy) * nrows + x+2*dx] == '#' or \       data[(y+2*dy) * nrows + x+2*dx] != ' ':        return None     data2 = array(strv, data)    data2[y * nrows + x] = ' '    data2[(y+dy) * nrows + x+dx] = '@'    data2[(y+2*dy) * nrows + x+2*dx] = '*'    return data2.tostring() def is_solved(data):    for i in xrange(len(data)):        if (sdata[i] == '.') != (data[i] == '*'):            return False    return True def solve():    open = deque([(ddata, strv, px, py)])    visited = set([ddata])    dirs = ((0, -1, 'u', 'U'), ( 1, 0, 'r', 'R'),            (0,  1, 'd', 'D'), (-1, 0, 'l', 'L'))     lnrows = nrows    while open:        cur, csol, x, y = open.popleft()         for di in dirs:            temp = cur            dx, dy = di[0], di[1]             if temp[(y+dy) * lnrows + x+dx] == '*':                temp = push(x, y, dx, dy, temp)                if temp and temp not in visited:                    if is_solved(temp):                        return csol + di[3]                    open.append((temp, csol + di[3], x+dx, y+dy))                    visited.add(temp)            else:                if sdata[(y+dy) * lnrows + x+dx] == '#' or \                   temp[(y+dy) * lnrows + x+dx] != ' ':                    continue                 data2 = array(strv, temp)                data2[y * lnrows + x] = ' '                data2[(y+dy) * lnrows + x+dx] = '@'                temp = data2.tostring()                 if temp not in visited:                    if is_solved(temp):                        return csol + di[2]                    open.append((temp, csol + di[2], x+dx, y+dy))                    visited.add(temp)     return strv  level = strv
#######




#. #  #
#. $$ #
#.$$  #
#.#  @#
#######strv psyco.full()init(level)print level, """", solve()"
"import socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.connect((strv, 256))sock.sendall(strv) sock.close()"
from SOAPpy import WSDL proxy = WSDL.Proxy(strv)result = proxy.soapFunc(strv)result = proxy.anotherSoapFunc(34234)
"for node in lst:    print node.valueclass LinkedList(object):  strvUSELESS academic/classroom example of a linked list implemented in Python.
     Don't ever consider using something this crude!  Use the built-in list() type!
  strv  def __init__(self, value, next):    self.value = value;    self.next = next  def __iter__(self):    node = self    while node != None:      yield node.value      node = node.next; lst = LinkedList(strv,  next=  LinkedList(value=strv,next=    LinkedList(value=strv,   next=      LinkedList(value=strv, next=        LinkedList(value=strv, next=          LinkedList(value=strv, next=None)))))); for value in lst:  print value,;print"
"import time seconds = float(raw_input())print strvtime.sleep(seconds) 
print strv"
"def chain_insert(lst, at, item):    while lst is not None:        if lst[0] == at:            lst[1] = [item, lst[1]]            return        else:            lst = lst[1]    raise ValueError(str(at) + strv) chain = ['A', ['B', None]]chain_insert(chain, 'A', 'C')print chain['A', ['C', ['B', None]]]"
"import ctypes def click():    ctypes.windll.user32.mouse_event(0x2, 0,0,0,0)    
    ctypes.windll.user32.mouse_event(0x4, 0,0,0,0)    
 click()import pyautogui pyautogui.moveTo(100, 200)      
pyautogui.moveTo(None, 500)     
pyautogui.moveTo(600, None)     
pyautogui.moveTo(100, 200, 2)   
 pyautogui.moveRel(0, 50)        
pyautogui.moveRel(-30, 0)       
 pyautogui.click()                          
pyautogui.click(clicks=2)pyautogui.click(clicks=2, interval=0.25)   
 pyautogui.click(10, 5)                     
pyautogui.click(200, 250, button='right')  
 pyautogui.scroll(10)   
pyautogui.scroll(10, x=100, y=100)  
    "
">>> import pyautogui>>> pyautogui.typewrite('Hello world!')                 
>>> pyautogui.typewrite('Hello world!', interval=0.25)  
>>> pyautogui.press('enter')  
>>> pyautogui.press('f1')     
>>> pyautogui.press('left')   
>>> pyautogui.keyDown('shift')  
>>> pyautogui.press('left')     
>>> pyautogui.keyUp('shift')    
>>> pyautogui.hotkey('ctrl', 'shift', 'esc')"
"class LinkedList(object):     strvUSELESS academic/classroom example of a linked list implemented in Python.
        Don't ever consider using something this crude!  Use the built-in list() type!
     strv	class Node(object):		def __init__(self, item):			self.value  = item			self.next = None	def __init__(self, item=None):		if item is not None:			self.head = Node(item); self.tail = self.head		else:			self.head = None; self.tail = None	def append(self, item):		if not self.head:			self.head = Node(item)			self.tail = self.head		elif self.tail:			self.tail.next = Node(item)			self.tail = self.tail.next		else:			self.tail = Node(item)	def __iter__(self):		cursor = self.head		while cursor:			yield cursor.value			cursor = cursor.next"
">>> class Borg(object):	__state = {}	def __init__(self):		self.__dict__ = self.__state	
  >>> b1 = Borg()>>> b2 = Borg()>>> b1 is b2False>>> b1.datum = range(5)>>> b1.datum[0, 1, 2, 3, 4]>>> b2.datum[0, 1, 2, 3, 4]>>> b1.datum is b2.datumTrue>>> 
 import abc class Singleton(object):    strv
    Singleton class implementation
    strv    __metaclass__ = abc.ABCMeta     state = 1 #class attribute to be used as the singleton's attribute     @abc.abstractmethod    def __init__(self):        pass #this prevents instantiation!     @classmethod    def printSelf(cls):        print cls.state #prints out the value of the singleton's state #demonstrationif __name__ == strv:    try:        a = Singleton() #instantiation will fail!    except TypeError as err:        print err    Singleton.printSelf()    print Singleton.state    Singleton.state = 2    Singleton.printSelf()    print Singleton.state "
"#!/usr/bin/python3 '''
Simple database for: http://rosettacode.org/wiki/Simple_database
 
''' import argparsefrom argparse import Namespaceimport datetimeimport shlex  def parse_args():    'Set up, parse, and return arguments'     parser = argparse.ArgumentParser(epilog=globals()['__doc__'])     parser.add_argument('command', choices='add pl plc pa'.split(),                        help='''
add: Add a new entry
pl:  Print the latest entry
plc: Print the latest entry for each category/tag
pa:  Print all entries sorted by a date''')    parser.add_argument('-d', '--description',                        help='A description of the item. (e.g., title, name)')    parser.add_argument('-t', '--tag',                        help=('''A category or tag (genre, topic, relationship '''                              '''such as “friend” or “family”)'''))    parser.add_argument('-f', '--field', nargs=2, action='append',                         help='Other optional fields with value (can be repeated)')     return parser def do_add(args, dbname):    'Add a new entry'    if args.description is None:        args.description = ''    if args.tag is None:        args.tag = ''    del args.command    print('Writing record to %s' % dbname)    with open(dbname, 'a') as db:        db.write('%r' % args) def do_pl(args, dbname):    'Print the latest entry'    print('Getting last record from %s' % dbname)    with open(dbname, 'r') as db:        for line in db: pass    record = eval(line)    del record._date    print(str(record)) def do_plc(args, dbname):    'Print the latest entry for each category/tag'    print('Getting latest record for each tag from %s' % dbname)    with open(dbname, 'r') as db:        records = [eval(line) for line in db]    tags = set(record.tag for record in records)    records.reverse()    for record in records:        if record.tag in tags:            del record._date            print(str(record))            tags.discard(record.tag)            if not tags: break def do_pa(args, dbname):    'Print all entries sorted by a date'    print('Getting all records by date from %s' % dbname)    with open(dbname, 'r') as db:        records = [eval(line) for line in db]    for record in records:        del record._date        print(str(record)) def test():    import time    parser = parse_args()    for cmdline in [                    strv,                    strv,                    strv,                    strv,                    strv,                    ]:        args = parser.parse_args(shlex.split(cmdline))        now = datetime.datetime.utcnow()        args._date = now.isoformat()        do_command[args.command](args, dbname)        time.sleep(0.5)   do_command = dict(add=do_add, pl=do_pl, plc=do_plc, pa=do_pa)dbname = '_simple_db_db.py'  if __name__ == '__main__':    if 0:        test()    else:        parser = parse_args()        args = parser.parse_args()        now = datetime.datetime.utcnow()        args._date = now.isoformat()        do_command[args.command](args, dbname)"
"#!/usr/bin/env python##########################################################################################

from numpy import *import turtle ###########################################################################################	Functions defining the drawing actions
#	----------------------------------------------def Left(turn, point, fwd, angle, turt):	turt.left(angle)	return [turn, point, fwd, angle, turt]def Right(turn, point, fwd, angle, turt):	turt.right(angle)	return [turn, point, fwd, angle, turt]def Forward(turn, point, fwd, angle, turt):	turt.forward(fwd)	return [turn, point, fwd, angle, turt] ###########################################################################################		The drawing function#		--------------------#

#-----------------------------------------------------------------------------------------def DrawSierpinskiTriangle(level, ss=400):	
	turn = 0		
	angle=60.0 		
 	
	turtle.hideturtle()	turtle.screensize(ss,ss)	turtle.penup()	turtle.degrees() 	
	fwd0         = float(ss)	point=array([-fwd0/2.0, -fwd0/2.0]) 	
	
	#	1.) Start at a point	#	2.) Draw a straight line - the horizontal line (H)	#	3.) Bend twice by 60 degrees to the left (--)	#	4.) Draw a straight line - the slanted line (X)	#	5.) Bend twice by 60 degrees to the left (--)	#	6.) Draw a straight line - another slanted line (X)	
	#	7.) For the next level replace each horizontal line using	#		X->XX	#		H -> H--X++H++X--H	#			The lengths will be halved.  	decode    = {'-':Left, '+':Right, 'X':Forward, 'H':Forward}	axiom     = 'H--X--X' 	
	turtle.goto(point[0], point[1])	turtle.pendown()	turtle.hideturtle()	turt=turtle.getpen()	startposition=turt.clone() 	
	fwd       = fwd0/(2.0**level)	path      = axiom	for i in range(0,level):		path=path.replace('X','XX')		path=path.replace('H','H--X++H++X--H') 	
	for i in path:		[turn, point, fwd, angle, turt]=decode[i](turn, point, fwd, angle, turt)########################################################################################## DrawSierpinskiTriangle(5) "
"from turtle import *import mathspeed(0)      
hideturtle()  
 part_ratio = 2 * math.cos(math.radians(72))side_ratio = 1 / (part_ratio + 2) hide_turtles = True   
path_color = strv  
fill_color = strv  
 
def pentagon(t, s):  t.color(path_color, fill_color)  t.pendown()  t.right(36)  t.begin_fill()  for i in range(5):    t.forward(s)    t.right(72)  t.end_fill() 
def sierpinski(i, t, s):  t.setheading(0)  new_size = s * side_ratio   if i > 1:    i -= 1     
    for j in range(4):      t.right(36)      short = s * side_ratio / part_ratio      dist = [short, s, s, short][j]       
      spawn = Turtle()      if hide_turtles:spawn.hideturtle()      spawn.penup()      spawn.setposition(t.position())      spawn.setheading(t.heading())      spawn.forward(dist)       
      sierpinski(i, spawn, new_size)     
    sierpinski(i, t, new_size)   else:    
    pentagon(t, s)    
    del t def main():  t = Turtle()  t.hideturtle()  t.penup()  screen = t.getscreen()  y = screen.window_height()  t.goto(0, y/2-20)   i = 5       
  size = 300  
   
  size *= part_ratio   
  sierpinski(i, t, size) main()"
"from Tkinter import Tk, Label, Button def update_label():    global n    n += 1    l[strv] = strv % n w = Tk()n = 0l = Label(w, text=strv)l.pack()Button(w, text=strv, command=update_label).pack()w.mainloop()#!/usr/bin/env pythonfrom Tkinter import Button, Frame, Label, Pack class ClickCounter(Frame):    def click(self):        self.count += 1        self.label['text'] = 'Number of clicks: %d' % self.count     def createWidgets(self):        self.label = Label(self, text='here have been no clicks yet')        self.label.pack()        self.button = Button(self, text='click me', command=self.click)        self.button.pack()     def __init__(self, master=None):        Frame.__init__(self, master)        Pack.config(self)        self.createWidgets()        self.count = 0 if __name__==strv:    ClickCounter().mainloop()import sysfrom qt import * def update_label():    global i    i += 1    lbl.setText(strv % i) i = 0app = QApplication(sys.argv)win = QWidget()win.resize(200, 100)lbl = QLabel(strv, win)lbl.setGeometry(0, 15, 200, 25)btn = QPushButton(strv, win)btn.setGeometry(50, 50, 100, 25)btn.connect(btn, SIGNAL(strv), update_label)win.show()app.connect(app, SIGNAL(strv), app, SLOT(strv))app.exec_loop()import wx class MyApp(wx.App):  def click(self, event):    self.count += 1    self.label.SetLabel(strv % self.count)   def OnInit(self):    frame = wx.Frame(None, wx.ID_ANY, strv)    self.count = 0    self.button = wx.Button(frame, wx.ID_ANY, strv)    self.label = wx.StaticText(frame, wx.ID_ANY, strv)    self.Bind(wx.EVT_BUTTON, self.click, self.button)     self.sizer = wx.BoxSizer(wx.VERTICAL)    self.sizer.Add(self.button, True, wx.EXPAND)    self.sizer.Add(self.label, True, wx.EXPAND)    frame.SetSizer(self.sizer)    frame.SetAutoLayout(True)    self.sizer.Fit(frame)     frame.Show(True)     self.SetTopWindow(frame)    return True app = MyApp(0)app.MainLoop()"
"def sierpinski(n):    d = [strv]    for i in xrange(n):        sp = strv * (2 ** i)        d = [sp+x+sp for x in d] + [x+strv+x for x in d]    return d print """".join(sierpinski(4))import functools def sierpinski(n):     def aggregate(TRIANGLE, I):        SPACE = strv * (2 ** I)        return [SPACE+X+SPACE for X in TRIANGLE] + [X+strv+X for X in TRIANGLE]     return functools.reduce(aggregate, range(n), [strv]) print("""".join(sierpinski(4)))x = 1while True:	print(bin(x)[2:].replace('0', ' '))	x ^= x<<1"
>>> import time>>> time.asctime(time.gmtime(0))'Thu Jan  1 00:00:00 1970'>>>
"def eratosthenes2(n):    multiples = set()    for i in range(2, n+1):        if i not in multiples:            yield i            multiples.update(range(i*i, n+1, i)) print(list(eratosthenes2(100)))def primes_upto(limit):    is_prime = [False] * 2 + [True] * (limit - 1)     for n in range(int(limit**0.5 + 1.5)): 
        if is_prime[n]:            for i in range(n*n, limit+1, n):                is_prime[i] = False    return [i for i, prime in enumerate(is_prime) if prime]def iprimes_upto(limit):    is_prime = [False] * 2 + [True] * (limit - 1)    for n in xrange(int(limit**0.5 + 1.5)): 
        if is_prime[n]:            for i in range(n * n, limit + 1, n): 
                is_prime[i] = False    for i in xrange(limit + 1):        if is_prime[i]: yield i>>> list(iprimes_upto(15))[2, 3, 5, 7, 11, 13]def primes2(limit):    if limit < 2: return []    if limit < 3: return [2]    lmtbf = (limit - 3) // 2    buf = [True] * (lmtbf + 1)    for i in range((int(limit ** 0.5) - 3) // 2 + 1):        if buf[i]:            p = i + i + 3            s = p * (i + 1) + i            buf[s::p] = [False] * ((lmtbf - s) // p + 1)    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]def iprimes2(limit):    yield 2    if limit < 3: return    lmtbf = (limit - 3) // 2    buf = [True] * (lmtbf + 1)    for i in range((int(limit ** 0.5) - 3) // 2 + 1):        if buf[i]:            p = i + i + 3            s = p * (i + 1) + i            buf[s::p] = [False] * ((lmtbf - s) // p + 1)    for i in range(lmtbf + 1):        if buf[i]: yield (i + i + 3)def primes235(limit):    yield 2; yield 3; yield 5    if limit < 7: return    modPrms = [7,11,13,17,19,23,29,31]    gaps = [4,2,4,2,4,6,2,6,4,2,4,2,4,6,2,6] 
    ndxs = [0,0,0,0,1,1,2,2,2,2,3,3,4,4,4,4,5,5,5,5,5,5,6,6,7,7,7,7,7,7]    lmtbf = (limit + 23) // 30 * 8 - 1 
    lmtsqrt = (int(limit ** 0.5) - 7)    lmtsqrt = lmtsqrt // 30 * 8 + ndxs[lmtsqrt % 30] 
    buf = [True] * (lmtbf + 1)    for i in range(lmtsqrt + 1):        if buf[i]:            ci = i & 7; p = 30 * (i >> 3) + modPrms[ci]            s = p * p - 7; p8 = p << 3            for j in range(8):                c = s // 30 * 8 + ndxs[s % 30]                buf[c::p8] = [False] * ((lmtbf - c) // p8 + 1)                s += p * gaps[ci]; ci += 1    for i in range(lmtbf - 6 + (ndxs[(limit - 7) % 30])): 
        if buf[i]: yield (30 * (i >> 3) + modPrms[i & 7])import numpydef primes_upto2(limit):    is_prime = numpy.ones(limit + 1, dtype=numpy.bool)    for n in xrange(2, int(limit**0.5 + 1.5)):         if is_prime[n]:            is_prime[n*n::n] = 0    return numpy.nonzero(is_prime)[0][2:]from numpy import array, bool_, multiply, nonzero, ones, put, resize#def makepattern(smallprimes):    pattern = ones(multiply.reduce(smallprimes), dtype=bool_)    pattern[0] = 0    for p in smallprimes:        pattern[p::p] = 0    return pattern#def primes_upto3(limit, smallprimes=(2,3,5,7,11)):        sp = array(smallprimes)    if limit <= sp.max(): return sp[sp <= limit]    #    isprime = resize(makepattern(sp), limit + 1)     isprime[:2] = 0; put(isprime, sp, 1)     #    for n in range(sp.max() + 2, int(limit**0.5 + 1.5), 2):         if isprime[n]:            isprime[n*n::n] = 0     return nonzero(isprime)[0]>>> primes_upto3(10**6, smallprimes=(2,3)) 
array([     2,      3,      5, ..., 999961, 999979, 999983])>>> primes_upto3(10**7, smallprimes=(2,3))            
array([      2,       3,       5, ..., 9999971, 9999973, 9999991])>>> primes_upto3(15)array([ 2,  3,  5,  7, 11, 13])>>> primes_upto3(10**7, smallprimes=primes_upto3(15)) 
array([      2,       3,       5, ..., 9999971, 9999973, 9999991])>>> primes_upto2(10**7)                               
array([      2,       3,       5, ..., 9999971, 9999973, 9999991])>>> primes_upto3(10**7)                               
array([      2,       3,       5, ..., 9999971, 9999973, 9999991])import heapq 
def sieve():    
    
    nonprimes = []     i = 2    while True:        if nonprimes and i == nonprimes[0][0]: 
            while nonprimes[0][0] == i:                
                
                
                x = nonprimes[0]                x[0] += x[1]                heapq.heapreplace(nonprimes, x)         else: 
            
            
            
            
            heapq.heappush(nonprimes, [i*i, i])            yield i         i += 1def primes():    yield 2; yield 3; yield 5; yield 7;    bps = (p for p in primes())             
    p = next(bps) and next(bps)             
    q = p * p                               
    sieve = {}                              
    n = 9                                   
    while True:        if n not in sieve:                  
            if n < q:                       
                yield n                     
            else:                p2 = p + p                  
                sieve[q + p2] = p2          
                p = next(bps); q = p * p    
        else:            s = sieve.pop(n); nxt = n + s   
            while nxt in sieve: nxt += s    
            sieve[nxt] = s                  
        n += 2                              
 import itertoolsdef primes_up_to(limit):    return list(itertools.takewhile(lambda p: p <= limit, primes()))def primes():    for p in [2,3,5,7]: yield p                 
    gaps1 = [ 2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8 ]    gaps = gaps1 + [ 6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10 ] 
    def wheel_prime_pairs():        yield (11,0); bps = wheel_prime_pairs() 
        p, pi = next(bps); q = p * p            
        sieve = {}; n = 13; ni = 1              
        while True:            if n not in sieve:                  
                if n < q: yield (n, ni)         
                else:                    npi = pi + 1                
                    if npi > 47: npi = 0                    sieve[q + p * gaps[pi]] = (p, npi) 
                    p, pi = next(bps); q = p * p  
            else:                s, si = sieve.pop(n)                nxt = n + s * gaps[si]          
                si = si + 1                     
                if si > 47: si = 0                while nxt in sieve:             
                    nxt += s * gaps[si]                    si = si + 1                 
                    if si > 47: si = 0                sieve[nxt] = (s, si)            
            nni = ni + 1                        
            if nni > 47: nni = 0            n += gaps[ni]; ni = nni             
    for p, pi in wheel_prime_pairs(): yield p   
def primes():    whlPrms = [2,3,5,7,11,13,17]                
    for p in whlPrms: yield p    def makeGaps():        buf = [True] * (3 * 5 * 7 * 11 * 13 * 17 + 1) 
        for p in whlPrms:            if p < 3:                continue              
            strt = (p * p - 19) >> 1            
            while strt < 0: strt += p            buf[strt::p] = [False] * ((len(buf) - strt - 1) // p + 1) 
        whlPsns = [i + i for i,v in enumerate(buf) if v]        return [whlPsns[i + 1] - whlPsns[i] for i in range(len(whlPsns) - 1)]    gaps = makeGaps()                           
    def wheel_prime_pairs():        yield (19,0); bps = wheel_prime_pairs() 
        p, pi = next(bps); q = p * p            
        sieve = {}; n = 23; ni = 1              
        while True:            if n not in sieve:                  
                if n < q: yield (n, ni)         
                else:                    npi = pi + 1                
                    if npi > 92159: npi = 0                    sieve[q + p * gaps[pi]] = (p, npi) 
                    p, pi = next(bps); q = p * p  
            else:                s, si = sieve.pop(n)                nxt = n + s * gaps[si]          
                si = si + 1                     
                if si > 92159: si = 0                while nxt in sieve:             
                    nxt += s * gaps[si]                    si = si + 1                 
                    if si > 92159: si = 0                sieve[nxt] = (s, si)            
            nni = ni + 1                        
            if nni > 92159: nni = 0            n += gaps[ni]; ni = nni             
    for p, pi in wheel_prime_pairs(): yield p   
 "
">>> def a(answer):	print(strv % (answer, answer))	return answer >>> def b(answer):	print(strv % (answer, answer))	return answer >>> for i in (False, True):	for j in (False, True):		print (""Calculating: x = a(i) and b(j)"")		x = a(i) and b(j)		print (strv)		y = a(i) or  b(j)   Calculating: x = a(i) and b(j)  
Calculating: y = a(i) or  b(j)  
  
 Calculating: x = a(i) and b(j)  
Calculating: y = a(i) or  b(j)  
  
 Calculating: x = a(i) and b(j)  
  
Calculating: y = a(i) or  b(j)  
 Calculating: x = a(i) and b(j)  
  
Calculating: y = a(i) or  b(j)  
>>> for i in (False, True):	for j in (False, True):		print (""Calculating: x = a(i) and b(j) using x = b(j) if a(i) else False"")		x = b(j) if a(i) else False		print (strv)		y = b(j) if not a(i) else True   Calculating: x = a(i) and b(j) using x = b(j) if a(i) else False  
Calculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True  
  
 Calculating: x = a(i) and b(j) using x = b(j) if a(i) else False  
Calculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True  
  
 Calculating: x = a(i) and b(j) using x = b(j) if a(i) else False  
  
Calculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True  
 Calculating: x = a(i) and b(j) using x = b(j) if a(i) else False  
  
Calculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True  
"
"def in_carpet(x, y):    while True:        if x == 0 or y == 0:            return True        elif x % 3 == 1 and y % 3 == 1:            return False         x /= 3        y /= 3 def carpet(n):    for i in xrange(3 ** n):        for j in xrange(3 ** n):            if in_carpet(i, j):                print '*',            else:                print ' ',        printdef sierpinski_carpet(n):  carpet = [strv]  for i in xrange(n):    carpet = [x + x + x for x in carpet] + \             [x + x.replace(strv,strv) + x for x in carpet] + \             [x + x + x for x in carpet]  return """".join(carpet) print sierpinski_carpet(3)"
>>> import hashlib>>> hashlib.sha256( strv.encode() ).hexdigest()'764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf'>>> 
"from random import randint def dice5():    return randint(1, 5) def dice7():    r = dice5() + dice5() * 5 - 6    return (r % 7) + 1 if r < 21 else dice7()"
"import hashlibh = hashlib.sha1()h.update(bytes(strv, encoding=strv))h.hexdigest()
"
"class Setr():    def __init__(self, lo, hi, includelo=True, includehi=False):        self.eqn = strv % (lo,                                      '=' if includelo else '',                                      '=' if includehi else '',                                      hi)     def __contains__(self, X):        return eval(self.eqn, locals())     
    def __or__(self, b):        ans = Setr(0,0)        ans.eqn = strv % (self.eqn, b.eqn)        return ans     
    def __and__(self, b):        ans = Setr(0,0)        ans.eqn = strv % (self.eqn, b.eqn)        return ans     
    def __sub__(self, b):        ans = Setr(0,0)        ans.eqn = strv % (self.eqn, b.eqn)        return ans     def __repr__(self):        return strv % self.eqn  sets = [    Setr(0,1, 0,1) | Setr(0,2, 1,0),    Setr(0,2, 1,0) & Setr(1,2, 0,1),    Setr(0,3, 1,0) - Setr(0,1, 0,0),    Setr(0,3, 1,0) - Setr(0,1, 1,1),]settexts = '(0, 1] ∪ [0, 2);[0, 2) ∩ (1, 2];[0, 3) − (0, 1);[0, 3) − [0, 1]'.split(';') for s,t in zip(sets, settexts):    print(strv % (t,                             ', '.join(strv                                     % ('in' if v in s else 'ex', v)                                     for v in range(3)),                             s.eqn))"
"def consolidate(sets):    setlist = [s for s in sets if s]    for i, s1 in enumerate(setlist):        if s1:            for s2 in setlist[i+1:]:                intersection = s1.intersection(s2)                if intersection:                    s2.update(s1)                    s1.clear()                    s1 = s2    return [s for s in setlist if s]def conso(s):	if len(s) < 2: return s 	r, b = [s[0]], conso(s[1:])	for x in b:		if r[0].intersection(x): r[0].update(x)		else: r.append(x)	return rdef _test(consolidate=consolidate):     def freze(list_of_sets):        'return a set of frozensets from the list of sets to allow comparison'        return set(frozenset(s) for s in list_of_sets)     
    A,B,C,D,E,F,G,H,I,J,K = 'A,B,C,D,E,F,G,H,I,J,K'.split(',')    
    assert (freze(consolidate([{A,B}, {C,D}])) == freze([{'A', 'B'}, {'C', 'D'}]))    assert (freze(consolidate([{A,B}, {B,D}])) == freze([{'A', 'B', 'D'}]))    assert (freze(consolidate([{A,B}, {C,D}, {D,B}])) == freze([{'A', 'C', 'B', 'D'}]))    assert (freze(consolidate([{H,I,K}, {A,B}, {C,D}, {D,B}, {F,G,H}])) ==             freze([{'A', 'C', 'B', 'D'}, {'G', 'F', 'I', 'H', 'K'}]))    assert (freze(consolidate([{A,H}, {H,I,K}, {A,B}, {C,D}, {D,B}, {F,G,H}])) ==             freze([{'A', 'C', 'B', 'D', 'G', 'F', 'I', 'H', 'K'}]))    assert (freze(consolidate([{H,I,K}, {A,B}, {C,D}, {D,B}, {F,G,H}, {A,H}])) ==             freze([{'A', 'C', 'B', 'D', 'G', 'F', 'I', 'H', 'K'}]))    
    from copy import deepcopy    import itertools    sets = [{H,I,K}, {A,B}, {C,D}, {D,B}, {F,G,H}, {A,H}]    answer = consolidate(deepcopy(sets))    for perm in itertools.permutations(sets):            assert consolidate(deepcopy(perm)) == answer     assert (answer == [{'A', 'C', 'B', 'D', 'G', 'F', 'I', 'H', 'K'}])    assert (len(list(itertools.permutations(sets))) == 720)     print('_test(%s) complete' % consolidate.__name__) if __name__ == '__main__':    _test(consolidate)    _test(conso)"
"#!/usr/bin/python from itertools import product, combinationsfrom random import sample ## Major constantsfeatures = [ 'green purple red'.split(),             'one two three'.split(),             'oval diamond squiggle'.split(),             'open striped solid'.split() ] deck = list(product(list(range(3)), repeat=4)) dealt = 9 ## Functionsdef printcard(card):    print(' '.join('%8s' % f[i] for f,i in zip(features, card))) def getdeal(dealt=dealt):    deal = sample(deck, dealt)    return deal def getsets(deal):    good_feature_count = set([1, 3])    sets = [ comb for comb in combinations(deal, 3)             if all( [(len(set(feature)) in good_feature_count)                     for feature in zip(*comb)]                   ) ]    return sets def printit(deal, sets):    print('Dealt %i cards:' % len(deal))    for card in deal: printcard(card)    print('Found %i sets:' % len(sets))    for s in sets:        for card in s: printcard(card)        print('') if __name__ == '__main__':    while True:        deal = getdeal()        sets = getsets(deal)        if len(sets) == dealt / 2:           break    printit(deal, sets)  import random, pprintfrom itertools import product, combinations N_DRAW = 9N_GOAL = N_DRAW // 2 deck = list(product(strv.split(),                    strv.split(),                    strv.split(),                    strv.split())) sets = []while len(sets) != N_GOAL:    draw = random.sample(deck, N_DRAW)    sets = [cs for cs in combinations(draw, 3)            if all(len(set(t)) in [1, 3] for t in zip(*cs))] print strv % len(draw)pprint.pprint(draw)print ""Containing %d sets:"" % len(sets)pprint.pprint(sets)"
" def prime(a):    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1))) def primes_below(n):    return [i for i in range(n) if prime(i)] "
">>> from math import sqrt>>> 
>>> def nonsqr(n): return n + int(round(sqrt(n))) >>> 
>>> [nonsqr(i) for i in xrange(1,23)][2, 3, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27]>>> 
>>> for i in xrange(1,1000000):	j = sqrt(nonsqr(i))	assert j != int(j), strv % i  >>>"
"import smtplib def sendemail(from_addr, to_addr_list, cc_addr_list,              subject, message,              login, password,              smtpserver='smtp.gmail.com:587'):    header  = 'From: %s' % from_addr    header += 'To: %s' % ','.join(to_addr_list)    header += 'Cc: %s' % ','.join(cc_addr_list)    header += 'Subject: %s' % subject    message = header + message     server = smtplib.SMTP(smtpserver)    server.starttls()    server.login(login,password)    problems = server.sendmail(from_addr, to_addr_list, message)    server.quit()    return problemssendemail(from_addr    = ',           to_addr_list = ['],          cc_addr_list = ['],           subject      = 'Howdy',           message      = 'Howdy from a python function',           login        = 'pythonuser',           password     = 'XXXXX')import win32com.client def sendmail(to, title, body):    olMailItem = 0    ol = win32com.client.Dispatch(strv)    msg = ol.CreateItem(olMailItem)    msg.To = to    msg.Subject = title    msg.Body = body    msg.Send()    ol.Quit() sendmail("""", strv, strv)"
"class Example(object):     def foo(self, x):             return 42 + x name = strvgetattr(Example(), name)(5)      
"
" Plataanstraat 5           split as (Plataanstraat, 5)Straat 12                 split as (Straat, 12)Straat 12 II              split as (Straat, 12 II)Dr. J. Straat   12        split as (Dr. J. Straat  , 12)Dr. J. Straat 12 a        split as (Dr. J. Straat, 12 a)Dr. J. Straat 12-14       split as (Dr. J. Straat, 12-14)Laan 1940 – 1945 37       split as (Laan 1940 – 1945, 37)Plein 1940 2              split as (Plein 1940, 2)1213-laan 11              split as (1213-laan, 11)16 april 1944 Pad 1       split as (16 april 1944 Pad, 1)1e Kruisweg 36            split as (1e Kruisweg, 36)Laan 1940-’45 66          split as (Laan 1940-’45, 66)Laan ’40-’45              split as (Laan ’40-’45,)Langeloërduinen 3 46      split as (Langeloërduinen, 3 46)Marienwaerdt 2e Dreef 2   split as (Marienwaerdt 2e Dreef, 2)Provincialeweg N205 1     split as (Provincialeweg N205, 1)Rivium 2e Straat 59.      split as (Rivium 2e Straat, 59.)Nieuwe gracht 20rd        split as (Nieuwe gracht, 20rd)Nieuwe gracht 20rd 2      split as (Nieuwe gracht, 20rd 2)Nieuwe gracht 20zw /2     split as (Nieuwe gracht, 20zw /2)Nieuwe gracht 20zw/3      split as (Nieuwe gracht, 20zw/3)Nieuwe gracht 20 zw/4     split as (Nieuwe gracht, 20 zw/4)Bahnhofstr. 4             split as (Bahnhofstr., 4)Wertstr. 10               split as (Wertstr., 10)Lindenhof 1               split as (Lindenhof, 1)Nordesch 20               split as (Nordesch, 20)Weilstr. 6                split as (Weilstr., 6)Harthauer Weg 2           split as (Harthauer Weg, 2)Mainaustr. 49             split as (Mainaustr., 49)August-Horch-Str. 3       split as (August-Horch-Str., 3)Marktplatz 31             split as (Marktplatz, 31)Schmidener Weg 3          split as (Schmidener Weg, 3)Karl-Weysser-Str. 6       split as (Karl-Weysser-Str., 6)''')"
"import pyprimes def primorial_prime(_pmax=500):    isprime = pyprimes.isprime    n, primo = 0, 1    for prime in pyprimes.nprimes(_pmax):        n, primo = n+1, primo * prime        if isprime(primo-1) or isprime(primo+1):            yield n if __name__ == '__main__':    
    pyprimes.warn_probably = False      for i, n in zip(range(20), primorial_prime()):        print('Primorial prime %2i at primorial index: %3i' % (i+1, n))"
">>> s1, s2 = {1, 2, 3, 4}, {3, 4, 5, 6}>>> s1 | s2 
{1, 2, 3, 4, 5, 6}>>> s1 & s2 
{3, 4}>>> s1 - s2 
{1, 2}>>> s1 < s1 
False>>> {3, 1} < s1 
True>>> s1 <= s1 
True>>> {3, 1} <= s1 
True>>> {3, 2, 4, 1} == s1 
True>>> s1 == s2 
False>>> 2 in s1 
True>>> 10 not in s1 
True>>> {1, 2, 3, 4, 5} > s1 
True>>> {1, 2, 3, 4} > s1 
False>>> {1, 2, 3, 4} >= s1 
True>>> s1 ^ s2 
{1, 2, 5, 6}>>> len(s1) 
4>>> s1.add(99) 
>>> s1{99, 1, 2, 3, 4}>>> s1.discard(99) 
>>> s1{1, 2, 3, 4}>>> s1 |= s2 
>>> s1{1, 2, 3, 4, 5, 6}>>> s1 -= s2 
>>> s1{1, 2}>>> s1 ^= s2 
>>> s1{1, 2, 3, 4, 5, 6}>>> "
"from prime_decomposition import decompose def semiprime(n):    d = decompose(n)    try:        return next(d) * next(d) == n    except:        return False>>> semiprime(1679)True>>> [n for n in range(1,101) if semiprime(n)][4, 6, 9, 10, 14, 15, 21, 22, 25, 26, 33, 34, 35, 38, 39, 46, 49, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95]>>> "
">>> with open('unixdict.txt') as f:	wordset = set(f.read().strip().split()) >>> revlist = (''.join(word[::-1]) for word in wordset)>>> pairs   = set((wrd, rev) for wrd, rev in zip(wordset, revlist)                   if wrd < rev and rev in wordset)>>> len(pairs)158>>> sorted(pairs, key=lambda p: (len(p[0]), p))[-5:][('damon', 'nomad'), ('lager', 'regal'), ('leper', 'repel'), ('lever', 'revel'), ('kramer', 'remark')]>>> import osimport random
dictionary = {word.rstrip(os.linesep) for word in open('unixdict.txt')} 
results = []for word in dictionary:    
    reversed_word = word[::-1]    if reversed_word in dictionary and word > reversed_word:        results.append((word, reversed_word)) print(len(results))for words in random.sample(results, 5):    print(' '.join(words))"
"from itertools import groupby, permutations def A036058(number):    return ''.join( str(len(list(g))) + k                    for k,g in groupby(sorted(str(number), reverse=True)) ) def A036058_length(numberstring='0', printit=False):    iterations, last_three, queue_index = 1, ([None] * 3), 0     def A036058(number):        
        return ''.join( str(len(list(g))) + k                        for k,g in groupby(number) )     while True:        if printit:            print(strv % (iterations, numberstring))        numberstring = ''.join(sorted(numberstring, reverse=True))        if numberstring in last_three:            break        assert iterations < 1000000        last_three[queue_index], numberstring = numberstring, A036058(numberstring)        iterations += 1        queue_index +=1        queue_index %=3    return iterations def max_A036058_length( start_range=range(11) ):    already_done = set()    max_len = (-1, [])    for n in start_range:        sn = str(n)        sns = tuple(sorted(sn, reverse=True))        if sns not in already_done:            already_done.add(sns)            size = A036058_length(sns)            if size > max_len[0]:                max_len = (size, [n])            elif size == max_len[0]:                max_len[1].append(n)    return max_len lenmax, starts = max_A036058_length( range(1000000) ) 
allstarts = []for n in starts:    allstarts += [int(''.join(x))                  for x in set(k                               for k in permutations(str(n), 4)                               if k[0] != '0')]allstarts = [x for x in sorted(allstarts) if x < 1000000] print ( '''
The longest length, followed by the number(s) with the longest sequence length
for starting sequence numbers below 1000000 are:
  Iterations = %i and sequence-starts = %s.''' % (lenmax, allstarts)   ) print ( '''
Note that only the first of any sequences with the same digits is printed below.
(The others will differ only in their first term)''' ) for n in starts:    print()    A036058_length(str(n), printit=True)"
">>> def isSelfDescribing(n):	s = str(n)	return all(s.count(str(i)) == int(ch) for i, ch in enumerate(s)) >>> [x for x in range(4000000) if isSelfDescribing(x)][1210, 2020, 21200, 3211000]>>> [(x, isSelfDescribing(x)) for x in (1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000)][(1210, True), (2020, True), (21200, True), (3211000, True), (42101000, True), (521001000, True), (6210001000, True)]def impl(d, c, m):    if m < 0: return    if d == c[:len(d)]: print d    for i in range(c[len(d)],m+1):        dd = d+[i]        if i<len(dd) and c[i]==dd[i]: continue        impl(dd,c[:i]+[c[i]+1]+c[i+1:],m-i) def self(n): impl([], [0]*(n+1), n) self(10)"
">>> import tempfile>>> invisible = tempfile.TemporaryFile()>>> invisible.name'<fdopen>'>>> visible = tempfile.NamedTemporaryFile()>>> visible.name'/tmp/tmpZNfc_s'>>> visible.close()>>> invisible.close()fd, path = tempfile.mkstemp()try:    
finally:    os.close(fd)"
"cities = [    { strv: strv,                strv: 21.0  },    { strv: strv,                strv: 15.2  },    { strv: strv, strv: 11.3  },    { strv: strv, strv:  7.55 },    { strv: strv,            strv:  5.85 },    { strv: strv,    strv:  4.98 },    { strv: strv,        strv:  4.7  },    { strv: strv,           strv:  4.58 },    { strv: strv,              strv:  4.4  },    { strv: strv,           strv:  3.98 }] def first(query):    return next(query, None) print(    first(index for index, city in enumerate(cities)        if city['name'] == strv),    first(city['name'] for city in cities if city['population'] < 5),    first(city['population'] for city in cities if city['name'][0] == 'A'),    sep='')"
"def char2value(c):  assert c not in 'AEIOU', strv  return int(c, 36) sedolweight = [1,3,1,7,3,9] def checksum(sedol):    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,                  sedol, sedolweight)               )    return str((10 - (tmp % 10)) % 10) for sedol in '''
    710889
    B0YBKJ
    406566
    B0YBLH
    228276
    B0YBKL
    557910
    B0YBKR
    585284
    B0YBKT
    '''.split():    print sedol + checksum(sedol)"
>>> x=strv>>> def outerfunc():    x = strv     def scoped_local():        x = strv        return strv + x    print(scoped_local())     def scoped_nonlocal():        nonlocal x        return strv + x    print(scoped_nonlocal())     def scoped_global():        global x        return strv + x    print(scoped_global())     def scoped_notdefinedlocally():        return strv + x    print(scoped_notdefinedlocally())  >>> outerfunc()scoped_local scope gives x = scope localscoped_nonlocal scope gives x = From scope at outerfuncscoped_global scope gives x = From global scopescoped_notdefinedlocally scope gives x = From global scope>>>
"haystack=[strv,strv,strv,strv,strv,strv,strv,strv,strv] for needle in (strv,strv):  try:    print haystack.index(needle), needle  except ValueError, value_error:    print needle,strv>>> haystack=[strv,strv,strv,strv,strv,strv,strv,strv,strv]>>> haystack.index('Bush')4>>> haystack.index('Washington')Traceback (most recent call last):  File strv, line 1, in <module>    haystack.index('Washington')ValueError: list.index(x): x not in list>>>>>> def hi_index(needle, haystack):	return len(haystack)-1 - haystack[::-1].index(needle) >>> 
>>> for n in haystack:	hi = hi_index(n, haystack)	assert haystack[hi] == n, strv	assert n not in haystack[hi+1:], strv	if haystack.count(n) == 1:		assert hi == haystack.index(n), strv >>>def (pos x (seq | (head ... tail)) n)  default n :to 0  if seq    if (head = x)      n      (pos x tail n+1)"
" >>> from random import randrange>>> def sattoloCycle(items):	for i in range(len(items) - 1, 0, -1):		j = randrange(i)  
		items[j], items[i] = items[i], items[j]  >>> 
>>> for _ in range(10):	lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]	sattoloCycle(lst)	print(lst)  [5, 8, 1, 2, 6, 4, 3, 9, 10, 7][5, 9, 8, 10, 4, 3, 6, 2, 1, 7][10, 5, 8, 3, 9, 1, 4, 2, 6, 7][10, 5, 2, 6, 9, 7, 8, 3, 1, 4][7, 4, 8, 5, 10, 3, 2, 9, 1, 6][2, 3, 10, 9, 4, 5, 8, 1, 7, 6][5, 7, 4, 6, 2, 9, 3, 10, 8, 1][3, 10, 7, 2, 9, 5, 8, 4, 1, 6][2, 6, 5, 3, 9, 8, 10, 7, 1, 4][3, 6, 2, 5, 10, 4, 1, 9, 7, 8]>>> "
"try:    from itertools import zip_longest as izip_longest 
except:    from itertools import izip_longest                
 def fringe(tree):    strvYield tree members L-to-R depth first,
    as if stored in a binary treestrv    for node1 in tree:        if isinstance(node1, tuple):            for node2 in fringe(node1):                yield node2        else:            yield node1 def same_fringe(tree1, tree2):    return all(node1 == node2 for node1, node2 in               izip_longest(fringe(tree1), fringe(tree2))) if __name__ == '__main__':    a = 1, 2, 3, 4, 5, 6, 7, 8    b = 1, (( 2, 3 ), (4, (5, ((6, 7), 8))))    c = (((1, 2), 3), 4), 5, 6, 7, 8     x = 1, 2, 3, 4, 5, 6, 7, 8, 9    y = 0, 2, 3, 4, 5, 6, 7, 8    z = 1, 2, (4, 3), 5, 6, 7, 8     assert same_fringe(a, a)    assert same_fringe(a, b)    assert same_fringe(a, c)     assert not same_fringe(a, x)    assert not same_fringe(a, y)    assert not same_fringe(a, z)"
">>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])0.9999999999999999>>> from math import fsum>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])1.0"
"def monkey_coconuts(sailors=5):    strv        nuts = sailors    while True:        n0, wakes = nuts, []        for sailor in range(sailors + 1):            portion, remainder = divmod(n0, sailors)            wakes.append((n0, portion, remainder))            if portion <= 0 or remainder != (1 if sailor != sailors else 0):                nuts += 1                break            n0 = n0 - portion - remainder        else:            break    return nuts, wakes if __name__ == strv:    for sailors in [5, 6]:        nuts, wake_stats = monkey_coconuts(sailors)        print(""For %i sailors the initial nut count is %i"" % (sailors, nuts))        print(""On each waking, the nut count, portion taken, and monkeys share are: "",               ',  '.join(repr(ws) for ws in wake_stats))def wake_and_split(n0, sailors, depth=None):    if depth is None:        depth = sailors    portion, remainder = divmod(n0, sailors)    if portion <= 0 or remainder != (1 if depth else 0):        return None    else:        return n0 if not depth else wake_and_split(n0 - portion - remainder, sailors, depth - 1)  def monkey_coconuts(sailors=5):    strv        nuts = sailors    while True:        if wake_and_split(n0=nuts, sailors=sailors) is None:            nuts += 1        else:            break    return nuts if __name__ == strv:    for sailors in [5, 6]:        nuts = monkey_coconuts(sailors)        print(strv % (sailors, nuts)) 
def dioph(a, b, c):	aa,bb,x,y = a, b, 0, 1 	while True:		q,a,b = a//b, b, a%b		x,y = y - q*x, x		if abs(a) == 1: break 	if y*aa % bb != 1: y = -y	x,y = y*c, (c - aa*y*c)//bb	#assert(x*aa + y*bb == c)	return x,y 

def calcnuts(rems, min_share = 0):	n, r = len(rems) - 1, 0	c = (n - 1)**n	for x in rems: r,c = r + x*c, c//(n-1)*n 	a, b = (n-1)**n, n**(n+1)	x, y = dioph(a, -b, r)	k = (min_share - y + a - 1)//a	return x + k*b, y + k*a def distribute(nuts, monkey_nuts):	n = len(monkey_nuts) - 1	print(""%d sailors, %d nuts:""%(n, nuts))	for r in monkey_nuts[:-1]:		p = (nuts - r)//n		print(""Nuts %d, hide %d, monkey gets %d"" % (nuts, p, r))		nuts = p*(n - 1) 	r = monkey_nuts[-1]	p = (nuts - r)//n	print(""Finally:Nuts %d, each share %d, monkey gets %d"" % (nuts, p, r)) for sailors in range(2, 10):	monkey_loot = [1]*sailors + [0]	distribute(calcnuts(monkey_loot, 1)[0], monkey_loot) 
#for i in range(1, 5): print(10**i, calcnuts([1]*10**i + [0])[0])"
">>> def eval_with_x(code, a, b):	return eval(code, {'x':b}) - eval(code, {'x':a}) >>> eval_with_x('2 ** x', 3, 5)24>>> def eval_with_args(code, **kwordargs):	return eval(code, kwordargs) >>> code = '2 ** x'>>> eval_with_args(code, x=5) - eval_with_args(code, x=3)24>>> code = '3 * x + y'>>> eval_with_args(code, x=5, y=2) - eval_with_args(code, x=3, y=1)7"
"import re dbg = False term_regex = r'''(?mx)
    *(?:
        (?P<brackl>)|
        (?P<brackr>)|
        (?P<num>?++|?+)|
        (?P<sq>strv)|
        (?P<s>[^(^)]+)
       )''' def parse_sexp(sexp):    stack = []    out = []    if dbg: print(strv % tuple(strv.split()))    for termtypes in re.finditer(term_regex, sexp):        term, value = [(t,v) for t,v in termtypes.groupdict().items() if v][0]        if dbg: print(strv % (term, value, out, stack))        if   term == 'brackl':            stack.append(out)            out = []        elif term == 'brackr':            assert stack, strv            tmpout, out = out, stack.pop(-1)            out.append(tmpout)        elif term == 'num':            v = float(value)            if v.is_integer(): v = int(v)            out.append(v)        elif term == 'sq':            out.append(value[1:-1])        elif term == 's':            out.append(value)        else:            raise NotImplementedError(strv % (term, value))    assert not stack, strv    return out[0] def print_sexp(exp):    out = ''    if type(exp) == type([]):        out += '(' + ' '.join(print_sexp(x) for x in exp) + ')'    elif type(exp) == type('') and re.search(r'[()]', exp):        out += 'strv' % repr(exp)[1:-1].replace('""', '')    else:        out += '%s' % exp    return out  if __name__ == '__main__':    sexp = ''' ( ( data strv 123 4.5)
         (data (123 (4.5) strv)))'''     print('Input S-expression: %r' % (sexp, ))    parsed = parse_sexp(sexp)    print(""Parsed to Python:"", parsed)     print(""Then back to: '%s'"" % print_sexp(parsed))>>> from pprint import pprint as pp>>> x = [[(t,v) for t,v in  termtypes.groupdict().items() if v][0] for termtypes in re.finditer(term_regex, sexp)]>>> pp(x)[('brackl', '('), ('brackl', '('), ('s', 'data'), ('sq', 'strv'), ('num', '123'), ('num', '4.5'), ('brackr', ')'), ('brackl', '('), ('s', 'data'), ('brackl', '('), ('num', '123'), ('brackl', '('), ('num', '4.5'), ('brackr', ')'), ('sq', 'strv'), ('sq', 'strv'), ('brackr', ')'), ('brackr', ')'), ('brackr', ')')]>>> "
"def RK4(f):    return lambda t, y, dt: (            lambda dy1: (            lambda dy2: (            lambda dy3: (            lambda dy4: (dy1 + 2*dy2 + 2*dy3 + dy4)/6            )( dt * f( t + dt  , y + dy3   ) )	    )( dt * f( t + dt/2, y + dy2/2 ) )	    )( dt * f( t + dt/2, y + dy1/2 ) )	    )( dt * f( t       , y         ) ) def theory(t): return (t**2 + 4)**2 /16 from math import sqrtdy = RK4(lambda t, y: t*sqrt(y)) t, y, dt = 0., 1., .1while t <= 10:    if abs(round(t) - t) < 1e-5:	print(""y(%2.1f)= %4.6f  error: %4.6g"" % ( t, y, abs(y - theory(t))))    t, y = t + dt, y + dy( t, y, dt )  from math import sqrt def rk4(f, x0, y0, x1, n):    vx = [0] * (n + 1)    vy = [0] * (n + 1)    h = (x1 - x0) / float(n)    vx[0] = x = x0    vy[0] = y = y0    for i in range(1, n + 1):        k1 = h * f(x, y)        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)        k4 = h * f(x + h, y + k3)        vx[i] = x = x0 + i * h        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6    return vx, vy def f(x, y):    return x * sqrt(y) vx, vy = rk4(f, 0, 1, 10, 100)for x, y in list(zip(vx, vy))[::10]:    print(strv % (x, y, y - (4 + x * x)**2 / 16))  0.0    1.00000  +0.0000e+00 1.0    1.56250  -1.4572e-07 2.0    4.00000  -9.1948e-07 3.0   10.56250  -2.9096e-06 4.0   24.99999  -6.2349e-06 5.0   52.56249  -1.0820e-05 6.0   99.99998  -1.6595e-05 7.0  175.56248  -2.3518e-05 8.0  288.99997  -3.1565e-05 9.0  451.56246  -4.0723e-0510.0  675.99995  -5.0983e-05"
"def encode(input_string):    count = 1    prev = ''    lst = []    for character in input_string:        if character != prev:            if prev:                entry = (prev,count)                lst.append(entry)                #print lst            count = 1            prev = character        else:            count += 1    else:        entry = (character,count)        lst.append(entry)    return lst  def decode(lst):    q = strv    for character, count in lst:        q += character * count    return q #Method callencode(strv)decode([('a', 5), ('h', 6), ('m', 7), ('u', 1), ('i', 7), ('a', 6)])from itertools import groupbydef encode(input_string):    return [(len(list(g)), k) for k,g in groupby(input_string)] def decode(lst):    return ''.join(c * n for n,c in lst) encode(strv)decode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])from re import sub def encode(text):    '''
    Doctest:
        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')
        '12W1B12W3B24W1B14W'    
    '''    return sub(r'(.)*', lambda m: str(len(m.group(0))) + m.group(1),               text) def decode(text):    '''
    Doctest:
        >>> decode('12W1B12W3B24W1B14W')
        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'
    '''    return sub(r'(+)()', lambda m: m.group(2) * int(m.group(1)),               text) textin = strvassert decode(encode(textin)) == textin"
"from tkinter import *import randomimport time letter = [strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,          strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,' ']number = [strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,          strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,          strv,strv,strv,'31'] n = 2537e = 13d = 937def decrypt(F,d):    
    if d == 0:        return 1    if d == 1:        return F    w,r = divmod(d,2)    if r == 1:        return decrypt(F*F%n,w)*F%n    else:        return decrypt(F*F%n,w) def correct():    
    
    for i in range(len(D)):        if len(str(P[i]))%2 !=0:            y = str(0)+str(P[i])            P.remove(str(P[i]))            P.insert(i,y) def cipher(b,e):    
    if e == 0:        return 1    if e == 1:        return b    w,r = divmod(e,2)    if r == 1:        return cipher(b*b%n,w)*b%n    else:        return cipher(b*b%n,w) def group(j,h,z):    
    for i in range(int(j)):        y = 0        for n in range(h):            y += int(numP[(h*i)+n])*(10**(z-2*n))        X.append(int(y))   class App:    
    def __init__(self, master):         frame = Frame(master)        frame.grid()         #create a button with the quit command, and tell it where to go        quitbutton = Button(frame, text = strv, fg =strv,                                            command = root.quit, width = 10)        quitbutton.grid(row = 0, column =3)         #create an entry box, tell it where it goes, and how large it is        entry = Entry(frame, width = 100)        entry.grid(row = 0, column = 0)         #set initial content of the entry box        self.contents = StringVar()        self.contents.set(strv)        entry[strv] = self.contents         
        decrypt = Button(frame,text = strv, fg = strv,                         command = self.Decrypt)        decrypt.grid(row = 2, column = 1)         #create a label to display the number of ciphertext blocks in an encoded message        label = Label(frame, text = strv)        label.grid(row = 1, column = 1)         #creates a button which initializes the encryption of plaintext        encrypt = Button(frame, text=strv, fg = strv,                         command = self.Encrypt)        encrypt.grid(row =0, column =1)         #create an entry box for the value of strv        nbox = Entry(frame, width = 100)        nbox.grid(row = 3, column = 0)         self.n = StringVar()        self.n.set(n)        nbox[strv] = self.n        nbox.bind('<Key-Return>', self.set_n)           #key binding, when you press strv is changed to the value now in the box         nlabel = Label(frame, text = strv)        nlabel.grid(row = 3, column = 1)         #create an entry box for the value of strv        ebox = Entry(frame, width = 100)        ebox.grid(row = 4, column = 0)         self.e = StringVar()        self.e.set(e)        ebox[strv] = self.e        ebox.bind('<Key-Return>', self.set_e)         elabel = Label(frame, text = strv)        elabel.grid(row = 4, column = 1)         #create an entry box for the value of strv        dbox = Entry(frame, width = 100)        dbox.grid(row =5, column = 0)         self.d = StringVar()        self.d.set(d)        dbox[strv] = self.d        dbox.bind('<Key-Return>', self.set_d)         dlabel = Label(frame, text = strv)        dlabel.grid(row = 5, column =1)         blocks = Label(frame, width = 100)        blocks.grid(row = 1, column =0)         self.block = StringVar()        self.block.set(strv)        blocks[strv] = self.block         output = Entry(frame, width = 100)         output.grid(row = 2, column = 0)         self.answer = StringVar()        self.answer.set(strv)        output[strv] = self.answer     
    def set_n(self,event):        global n        n = int(self.n.get())        print(strv, n)     def set_e(self, event):        global e        e = int(self.e.get())        print(strv,e)     def set_d(self,event):        global d        d = int(self.d.get())        print(strv, d)     def Decrypt(self):        #decrypts an encoded message        global m,P,D,x,h,p,Text,y,w,PText        P = []        D = str(self.answer.get())              #Pulls the ciphertext out of the ciphertext box         D = D.lstrip('[')                       #removes the bracket strv from the left side of the string        D = D.rstrip(']')           D = D.split(',')                        #splits the string into a list of strings, separating at each comma.         for i in range(len(D)):                 #decrypts each block in the list of strings strv            x = decrypt(int(D[i]),d)                       P.append(str(x))        correct()                               #ensures each block is not missing a 0 at the start        h = len(P[0])        p = []        for i in range(len(D)):                 #further separates the list P into individual characters, i.e. strv            for n in range(int(h/2)):                                p.append(str(P[i][(2*n):((2*n)+2)]))  
         Text = []                                       for i in range(len(p)):                 
            for j in range(len(letter)):                if str(p[i]) == number[j]:                    Text.append(letter[j])        PText = str()        for i in range(len(Text)):              #places all text characters in one string            PText = PText + str(Text[i])        self.contents.set(str(PText))           #places the decrypted plaintext in the plaintext box      def Encrypt(self):        #encrypts a plaintext message using the current key        global plaintext,numP,q,j,z,X,C        plaintext = self.contents.get()              #pulls the plaintext out of the entry box for use        plaintext = plaintext.lower()                #places all plaintext in lower case        numP = []        for i in range(len(plaintext)):              
            for j in range(len(letter)):                if plaintext[i] == letter[j]:                    numP.append(number[j])        h = (len(str(n))//2)-1                       
        q = len(numP)%h        for i in range(h-q):            numP.append(number[random.randint(0,25)])   
        j = len(numP) / h        X = []        z = 0        for m in range(h-1):            z+=2        group(j,h,z)                                 
        k = len(X)        C = []        for i in range(k):                           
            b = X[i]            r = cipher(b,e)            C.append(r)        self.answer.set(C)        self.block.set(len(C))                      #places the ciphertext into the ciphertext box  root = Tk() app = App(root) root.mainloop()root.destroy()import randomimport time def decrypt(F,d):    if d == 0:        return 1    if d == 1:        return F    w,r = divmod(d,2)    if r == 1:        return decrypt(F*F%n,w)*F%n    else:        return decrypt(F*F%n,w) def correct():    for i in range(len(C)):        if len(str(P[i]))%2 !=0:            y = str(0)+str(P[i])            P.remove(str(P[i]))            P.insert(i,y) def cipher(b,e):    if e == 0:        return 1    if e == 1:        return b    w,r = divmod(e,2)    if r == 1:        return cipher(b*b%n,w)*b%n    else:        return cipher(b*b%n,w) def group(j,h,z):    for i in range(int(j)):        y = 0        for n in range(h):            y += int(numP[(h*i)+n])*(10**(z-2*n))        X.append(int(y)) def gcd(a, b):        while b != 0:            (a, b) = (b, a%b)        return a   letter = [strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,          strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv]number = [strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,          strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,          strv,strv,strv,strv]  print( '' )def Decrypt():    #decrypts an encoded message    global m,P,C,x,h,p,Text,y,w    P = []    C = str(input(strv))    C = C.lstrip('[')    C = C.rstrip(']')       C = C.split(',')    for i in range(len(C)):        x = decrypt(int(C[i]),d)        P.append(str(x))    correct()    #print(P)    h = len(P[0])    p = []    for i in range(len(C)):        for n in range(int(h/2)):            p.append(str(P[i][(2*n):((2*n)+2)]))     Text = []    for i in range(len(p)):        for j in range(len(letter)):            if str(p[i]) == number[j]:                Text.append(letter[j])    PText = str()    for i in range(len(Text)):        PText = PText + str(Text[i])    print(strv, PText) def Encrypt():    #encrypts a plaintext message using the current key    global plaintext,numP,q,j,z,X,C    plaintext =(input(strv))    plaintext = plaintext.lower()    numP = []    for i in range(len(plaintext)):        for j in range(len(letter)):            if plaintext[i] == letter[j]:                numP.append(number[j])    h = (len(str(n))//2)-1    q = len(numP)%h    for i in range(h-q):        numP.append(number[random.randint(0,25)])    j = len(numP) / h    #print(numP)    X = []    z = 0    for m in range(h-1):        z+=2    group(j,h,z)    k = len(X)    C = []    for i in range(k):        b = X[i]        r = cipher(b,e)        C.append(r)    print(strv,C)    print(strv,len(C)) def setup():    global n,e,d    while True:        try:            n = int(input(strv))            if n > 2:                break        except ValueError:            print('please enter a number')    while 1!=2 :        try:            e = int(input(strv))            if e >= 2:                break        except ValueError:            print('please enter a number')    while True:        try:            d = int(input(strv))            if d >= 0:                break        except ValueError:            print('please enter a number') #setup()n = 2537e = 13d = 937 print(strv)print(strv)print(strv)print(strv)print( '' )print( '' ) mm = str()while mm != 'quit':    mm = input(strv)    if mm.lower() == 'encrypt':        Encrypt()    elif mm.lower() == 'decrypt':        Decrypt()    elif mm.lower() == 'n':        try:            print('current n = ',n)            n = int(input(strv))        except ValueError:            print('That is not a valid entry')    elif mm.lower() == 'help':        print(strv)        print(strv)        print(strv)        print(strv)        print( '' )        print( '' )    elif mm.lower() == 'e':        try:            print('current e = ',e)            e = int(input(strv))        except ValueError:            print('That is not a valid entry')    elif mm.lower() == 'd':        try:            print('current d = ',d)            d = int(input(strv))        except ValueError:            print('That is not a valid entry')    else:        if mm != 'quit':            ii= random.randint(0,6)            statements = [strv,strv,strv,strv,strv,strv,strv]            print(statements[ii])>>>To redefine n,e, or d, type 'n','e',... etc.To encrypt a message with the current key, type 'Encrypt'To decrypt a message with the current key, type 'Decrypt'Type quit to exit    Enter Command...ENCRYPTEnter Plaintext :drink MORE OvaltineCiphertext: [140, 2222, 1864, 1616, 821, 384, 2038, 2116, 2222, 205, 384, 2116, 45, 1, 2497, 793, 1864, 1616, 205, 41]Number of Ciphertext blocks: 20Enter Command...decryptEnter ciphertext blocks:[140, 2222, 1864, 1616, 821, 384, 2038, 2116, 2222, 205, 384, 2116, 45, 1, 2497, 793, 1864, 1616, 205, 41]Plaintext is: drink more ovaltineuEnter Command...quit>>> "
">>> exec '''
x = sum([1,2,3,4])
print x
'''10>>> exec('''
x = sum([1,2,3,4])
print(x)
''')10"
">>> u'foo'.encode('rot13')'sbb'>>> 'sbb'.decode('rot13')u'foo'>>> import codecs>>> codecs.encode(strv, strv)'Gur dhvpx oebja sbk whzcf bire gur ynml qbt'>>> codecs.decode(_, strv)'The quick brown fox jumps over the lazy dog'#!/usr/bin/env pythonimport stringdef rot13(s):   strv each letter by the
      letter that's 13 steps from it (wrapping from z to a)
   strv   return s.translate(       string.maketrans(           string.ascii_uppercase + string.ascii_lowercase,           string.ascii_uppercase[13:] + string.ascii_uppercase[:13] +           string.ascii_lowercase[13:] + string.ascii_lowercase[:13]           )       )if __name__ == strv:   strvPeform line-by-line rot-13 encoding on any files listed on our
      command line or act as a standard UNIX filter (if no arguments
      specified).
   strv   import fileinput   for line in fileinput.input():      print rot13(line),  
#!/usr/bin/env pythonimport stringdef rot13(s):   strv each letter by the
      letter that's 13 steps from it (wrapping from z to a)
   strv   return s.translate(       str.maketrans(           string.ascii_uppercase + string.ascii_lowercase,           string.ascii_uppercase[13:] + string.ascii_uppercase[:13] +           string.ascii_lowercase[13:] + string.ascii_lowercase[:13]           )       )if __name__ == strv:   strvPeform line-by-line rot-13 encoding on any files listed on our
      command line or act as a standard UNIX filter (if no arguments
      specified).
   strv   import fileinput   for line in fileinput.input():      print(rot13(line), end=strv)#!/usr/bin/env pythonfrom __future__ import print_functionimport stringlets = string.ascii_lowercasekey = {x:y for (x,y) in zip(lets[13:]+lets[:14], lets)}key.update({x.upper():key[x].upper() for x in key.keys()})encode = lambda x: ''.join((key.get(c,c) for c in x))if __name__ == '__main__':   strvPeform line-by-line rot-13 encoding on any files listed on our
      command line or act as a standard UNIX filter (if no arguments
      specified).
   strv   import fileinput   for line in fileinput.input():      print(encode(line), end=strv)def (rot13 s)  (as string      (map rot13           (as list s))) Alphabet <- strvdef (rot13 c) :case (and string?.c len.c=1)  if (strv <= c <= strv)       let idx (pos c Alphabet)         Alphabet (idx+13 % 26)     (strv <= c <= strv)       (downcase.c -> rot13 -> upcase)     :else       c(rot13 strv)=> strv"
"
 import sysimport re langs = ['ada', 'cpp-qt', 'pascal', 'lscript', 'z80', 'visualprolog','html4strict', 'cil', 'objc', 'asm', 'progress', 'teraterm', 'hq9plus','genero', 'tsql', 'email', 'pic16', 'tcl', 'apt_sources', 'io', 'apache','vhdl', 'avisynth', 'winbatch', 'vbnet', 'ini', 'scilab', 'ocaml-brief','sas', 'actionscript3', 'qbasic', 'perl', 'bnf', 'cobol', 'powershell','php', 'kixtart', 'visualfoxpro', 'mirc', 'make', 'javascript', 'cpp','sdlbasic', 'cadlisp', 'php-brief', 'rails', 'verilog', 'xml', 'csharp','actionscript', 'nsis', 'bash', 'typoscript', 'freebasic', 'dot','applescript', 'haskell', 'dos', 'oracle8', 'cfdg', 'glsl', 'lotusscript','mpasm', 'latex', 'sql', 'klonec', 'ruby', 'ocaml', 'smarty', 'python','oracle11', 'caddcl', 'robots', 'groovy', 'smalltalk', 'diff', 'fortran','cfm', 'lua', 'modula3', 'vb', 'autoit', 'java', 'text', 'scala','lotusformulas', 'pixelbender', 'reg', '_div', 'whitespace', 'providex','asp', 'css', 'lolcode', 'lisp', 'inno', 'mysql', 'plsql', 'matlab','oobas', 'vim', 'delphi', 'xorg_conf', 'gml', 'prolog', 'bf', 'per','scheme', 'mxml', 'd', 'basic4gl', 'm68k', 'gnuplot', 'idl', 'abap','intercal', 'c_mac', 'thinbasic', 'java5', 'xpp', 'boo', 'klonecpp','blitzbasic', 'eiffel', 'povray', 'c', 'gettext'] slang = '/lang'code='code' text = sys.stdin.read() for i in langs:    text = text.replace(strv % i,strv % i)    text = text.replace(strv % i, strv % slang) text = re.sub(strv%(code,code), r""<lang ><%s>"" % slang, text) sys.stdout.write(text) "
"import requestsimport re LANGUAGES_URL = strvCATEG_ENTRIES_URL = strv languages_source = requests.get(LANGUAGES_URL).textcateg_entries_source = requests.get(CATEG_ENTRIES_URL).text raw_languages = re.findall('title=strv>', languages_source)
languages = [lang for lang in raw_languages    if lang not in ('Languages', 'Static Category Cache', 'Encyclopedia')] categ_entries = re.findall(    '<li><a[^>]+>([^<]+)</a>[^(]*[(](d+) member[s]*[)]</li>',    categ_entries_source) lang_entries = [(categ, int(entries))    for categ, entries in categ_entries if categ in languages]sorted_lang_entries = sorted(lang_entries, key=lambda x: -x[1]) for i, (lang, entries) in enumerate(sorted_lang_entries):    print(strv.format(i+1, entries, lang))import urllib, re key1 = lambda x: int(x[1]) get1 = urllib.urlopen(strv).read()get2 = urllib.urlopen(strv).read() langs = re.findall(""title:Category:(.+?)"",get1)qtdmbr = re.findall(""title=Category:(.+?)>.+?</a> (+) members"",get2) result = [(x,int(y)) for x,y in qtdmbr if x in langs] for n, i in enumerate(sorted(result,key=key1,reverse=True)):    print strv % (n+1, i[1], i[0])"
"import xml.dom.minidomimport urllib, sys def findrc(category):    name = strv % urllib.quote(category)    cmcontinue, titles = '', []    while True:        u = urllib.urlopen(name + cmcontinue)        xmldata = u.read()        u.close()        x = xml.dom.minidom.parseString(xmldata)        titles += [i.getAttribute(strv) for i in x.getElementsByTagName(strv)]        cmcontinue = filter( None,                             (urllib.quote(i.getAttribute(strv))                              for i in x.getElementsByTagName(strv)) )        if cmcontinue:            cmcontinue = '&cmcontinue=' + cmcontinue[0]        else:            break    return titles alltasks = findrc(strv)lang = findrc(sys.argv[1]) for i in [i for i in alltasks if i not in lang]:    print i"
"import cmathclass Complex(complex):   def __repr__(self):      rp = '%7.5f'%self.real if not self.pureImag() else ''      ip = '%7.5fj'%self.imag if not self.pureReal() else ''      conj = '' if (self.pureImag() or self.pureReal() or self.imag<0.0) else '+'      return '0.0' if (self.pureImag() and self.pureReal()) else rp+conj+ip   def pureImag(self):      return abs( self.real) < 0.000005   def pureReal(self):      return abs( self.imag) < 0.000005 def croots(n):   if n<=0:      return None   return (Complex(cmath.rect(1, 2*k*cmath.pi/n)) for k in range(n))   
 for nr in range(2,11):   print nr, list(croots(nr))"
"import urllib, xml.dom.minidom x = urllib.urlopen(strv) tasks = []for i in xml.dom.minidom.parseString(x.read()).getElementsByTagName(strv):    t = i.getAttribute('title').replace(strv, strv)    y = urllib.urlopen(strv % t.encode('utf-8'))    tasks.append( y.read().lower().count(strv) )    print t.replace(strv, strv) + strv % tasks[-1] print ""Total: %d examples."" % sum(tasks)"
"f = lambda x: x * x * x - 3 * x * x + 2 * x step = 0.001 
start = -1stop = 3 sign = f(start) > 0 x = startwhile x <= stop:    value = f(x)     if value == 0:        
        print strv, x    elif (value > 0) != sign:        
        print strv, x     
    sign = value > 0     x += step"
"#!/usr/bin/env python3 import mathimport cmathimport numpy def quad_discriminating_roots(a,b,c, entier = 1e-5):    strvFor reference, the naive algorithm which shows complete loss of
    precision on the quadratic in question.  (This function also returns a
    characterization of the roots.)strv    discriminant = b*b - 4*a*c    a,b,c,d =complex(a), complex(b), complex(c), complex(discriminant)    root1 = (-b + cmath.sqrt(d))/2./a    root2 = (-b - cmath.sqrt(d))/2./a    if abs(discriminant) < entier:        return strv, abs(root1), abs(root1)    if discriminant > 0:        return strv, root1.real, root2.real    return strv, root1, root2 def middlebrook(a, b, c):    try:        q = math.sqrt(a*c)/b        f = .5+ math.sqrt(1-4*q*q)/2    except ValueError:        q = cmath.sqrt(a*c)/b        f = .5+ cmath.sqrt(1-4*q*q)/2    return (-b/a)*f, -c/(b*f) def whatevery(a, b, c):    try:        d = math.sqrt(b*b-4*a*c)    except ValueError:        d = cmath.sqrt(b*b-4*a*c)    if b > 0:        return div(2*c, (-b-d)), div((-b-d), 2*a)    else:        return div((-b+d), 2*a), div(2*c, (-b+d)) def div(n, d):    strv    try:        return n/d    except ZeroDivisionError:        if n:            return n*float('inf')        return float('nan') testcases = [    (3, 4, 4/3),    
    (3, 2, -1),     
    (3, 2, 1),      
    (1, -1e9, 1),   
    (1, -1e100, 1),    (1, -1e200, 1),    (1, -1e300, 1),] print('Naive:')for c in testcases:    print(strv.format(*quad_discriminating_roots(*c))) print('Middlebrook:')for c in testcases:    print((strv*2).format(*middlebrook(*c))) print('What Every...')for c in testcases:    print((strv*2).format(*whatevery(*c))) print('Numpy:')for c in testcases:    print((strv*2).format(*numpy.roots(c)))"
"#!/usr/bin/env python
 import remale2female=ustrvmaleS femaleS, maleness femaleness,
him her, himself herself, his her, his hers, he she,
Mr Mrs, Mister Missus, Ms Mr, Master Miss, Master Mistress,
uncleS auntS, nephewS nieceS, sonS daughterS, grandsonS granddaughterS,
brotherS sisterS, man woman, men women, boyS girlS, paternal maternal,
grandfatherS grandmotherS, GodfatherS GodmotherS, GodsonS GoddaughterS,
fiancéS fiancéeS, husband wife, husbands wives, fatherS motherS, 
bachelorS spinsterS, bridegroomS brideS, widowerS widowS,
KnightS DameS, Sir DameS, KingS QueenS, DukeS DuchessES, PrinceS PrincessES,
Lord Lady, Lords Ladies, MarquessES MarchionessES, EarlS CountessES, ViscountS ViscountessES,
ladS lassES, sir madam, gentleman lady, gentlemen ladies, BaronS BaronessES,
stallionS mareS, ramS eweS, coltS fillieS, billy nanny, billies nannies, bullS cowS,
godS goddessES, heroS heroineS, shirtS blouseS, undies nickers, sweat glow,
jackarooS jillarooS, gigoloS hookerS, landlord landlady, landlords landladies, 
manservantS maidservantS, actorS actressES, CountS CountessES, EmperorS EmpressES, 
giantS giantessES, heirS heiressES, hostS hostessES, lionS lionessES, managerS manageressES,
murdererS murderessES, priestS priestessES, poetS poetessES, shepherdS shepherdessES,
stewardS stewardessES, tigerS tigressES, waiterS waitressES,
cockS henS, dogS bitchES, drakeS henS, dogS vixenS,
tomS tibS, boarS sowS, buckS roeS, peacockS peahenS, 
gander goose, ganders geese, friarS nunS, monkS nunS, Adam Eve,
Aaron Erin, Adrian Adriana, Aidrian Aidriana, Alan Alaina, Albert Alberta,
Alex Alexa, Alex Alexis, Alexander Alaxandra, Alexander Alexandra,
Alexander Alexis, Alexandra Alexander, Alexei Alexis, Alfred Alfreda,
Andrew Andrea, Andrew Andrea, Angel Angelica, Anthony Antonia,
Antoine Antoinette, Ariel Arielle, Ashleigh Ashley, 
Barry Barrie, Benedict Benita, Benjamin Benjamine, Bert Bertha, 
Brandon Brandi, Brendan Brenda, Briana Brian, Brian Rianne, 
Caela Caesi, Caeleb Caeli, Carl Carla, Carl Carly, Carolus Caroline,
Charles Caroline, Charles Charlotte, Christian Christa, Christian Christiana,
Christian Christina, Christopher Christina, Christopher Christine,
Clarence Claire, Claude Claudia, Clement Clementine, Cory Cora,
Daniel Daniella, Daniel Danielle, David Davena, David Davida,
David Davina, Dean Deanna, Devin Devina,
Edward Edwina, Edwin Edwina, Emil Emilie, Emil Emily, Eric Erica, Erick Erica,
Erick Ericka, Ernest Ernestine, Ethan Etha, Ethan Ethel, Eugene Eugenie,
Fabian Fabia, Francesco Francesca, Frances Francesca, Francis Frances,
Francis Francine, Frederick Fredrica, Fred Freda, Fredrick Frederica,
Gabriel Gabriella, Gabriel Gabrielle, Gene Jean, George Georgia, george georgina,
George Georgina, Gerald Geraldine, Giovanni Giovanna, Glen Glenn,
Harry Harriet, Harry Harriette, Heather Heath, Henry Henrietta, Horace Horatia,
Ian Iana, Ilija Ilinka, Ivo Ivy, Ivan Ivy,
Jack Jackelyn, Jack Jackie, Jack Jaclyn, Jack Jacqueline, Jacob Jacobine,
James Jamesina, James Jamie, Jaun Jaunita, Jayda Jayden, Jesse Jessica, 
Jesse Jessie, Joe Johanna, Joel Joelle, John Jean, John Joan, 
John Johanna, Joleen Joseph, Jon Joane, Joseph Josephine, Joseph Josphine, 
Julian Julia, Julian Juliana, Julian Julianna, Justin Justine,
Karl Karly, Kendrick Kendra, Ken Kendra, Kian Kiana, Kyle Kylie,
Laurence Laura, Laurence Lauren, Laurence Laurencia, Leigh Leigha,
Leon Leona, Louis Louise, Lucas Lucia, Lucian Lucy, Luke Lucia, Lyle Lyla,
Maria Mario, Mario Maricela, Mark Marcia, Marshall Marsha, Martin martina,
Martin Martina, Martin Martine, Max Maxine, Michael Michaela, Michael Micheala,
Michael Michelle, Mitchell Michelle, Nadir Nadira, Nicholas Nicole, Nicholas Nicki,
Nicholas Nicole, Nicky Nikki, Nicolas Nicole, Nigel Nigella, Noel Noelle,
Oen Ioena, Oliver Olivia,
Patrick Patricia, Paul Paula, Phillip Phillipa, Phillip Pippa,
Quintin Quintina,
Reginald Regina, Richard Richardine, Robert Roberta, Robert Robyn, Ronald Rhonda,
Ryan Rhian, Ryan Ryanne,
Samantha Samuel, Samuel Samantha, Samuel Sammantha, Samuel Samuela,
Sean Sian, Sean Siana, Shaun Shauna, Sheldon Shelby, Sonny Sunny,
Stephan Stephanie, Stephen Stephanie, Steven Stephanie,
Terry Carol, Terry Carrol, Theodore Theadora, Theodore Theodora,
Theodore Theordora, Thomas Thomasina, Tristan Tricia, Tristen Tricia,
Ulric Ulrika, Valentin Valentina, Victor Victoria,
William Wilhelmina, William Willa, William Willamina,
Xavier Xaviera, Yarden Yardena, Zahi Zahira, Zion Zionastrv re_nl=re.compile(r"",[ ]*"")m2f=[ tok.split(strv) for tok in re_nl.split(male2female) ] switch={}words=[]  re_plural=re.compile(strv)re_ES=re.compile(strv) def gen_pluralize(m,f):
  yield re_plural.sub(strv,m),re_plural.sub(strv,f)  yield re_ES.sub(strv,m),re_ES.sub(strv,f)  yield re_plural.sub(strv,m),re_plural.sub(strv,f) def gen_capitalize_pluralize(m,f):  for m,f in gen_pluralize(m,f):    yield m.capitalize(), f.capitalize()    yield m,f def gen_switch_role_capitalize_pluralize(m,f):  for m,f in gen_capitalize_pluralize(m,f):    yield m,f    yield f,m for m,f in m2f:  for xy,xx in gen_switch_role_capitalize_pluralize(m,f):    if xy not in switch:       switch[xy]=xx      words.append(xy) words=strv.join(words) re_word=re.compile(ur""(""+words+ur"")"") text=u'''When a new-hatched savage running wild about his native
woodlands in a grass clout, followed by the nibbling goats, as if
he were a green sapling; even then, in Queequeg's ambitious soul,
lurked a strong desire to see something more of Christendom than
a specimen whaler or two. His father was a High Chief, a King;
his uncle a High Priest; and on the maternal side he boasted aunts
who were the wives of unconquerable warriors. There was excellent
blood in his veins-royal stuff; though sadly vitiated, I fear,
by the cannibal propensity he nourished in his untutored youth.'''  def rev_gender(text):  text=re_word.split(text)  return strv.join([ word+switch[gen] for word,gen in zip(text[::2],text[1::2])])+text[-1] print rev_gender(text)"
"Python 3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:57:17) [MSC v.1600 64 bit (AMD64)] on win32Type strv, strv or strv for more information.>>> import hashlib>>> h = hashlib.new('ripemd160')>>> h.update(bstrv)>>> h.hexdigest()'b3be159860842cebaa7174c8fff0aa9e50a5199f'>>> "
"roman =        strv; 
adjust_roman = strv;arabic =       (1000000, 500000, 100000, 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1);adjust_arabic = (100000, 100000,  10000, 10000,  1000, 1000,  100, 100,  10, 10,  1, 1, 0); def arabic_to_roman(dclxvi):  org = dclxvi; 
  out = strv;  for scale,arabic_scale  in enumerate(arabic):     if org == 0: break    multiples = org / arabic_scale;    org -= arabic_scale * multiples;    out += roman[scale] * multiples;    if org >= -adjust_arabic[scale] + arabic_scale:       org -= -adjust_arabic[scale] + arabic_scale;      out +=  adjust_roman[scale] +  roman[scale]  return out if __name__ == strv:   test = (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,40,50,60,69,70,     80,90,99,100,200,300,400,500,600,666,700,800,900,1000,1009,1444,1666,1945,1997,1999,     2000,2008,2500,3000,4000,4999,5000,6666,10000,50000,100000,500000,1000000);  for val in test:     print '%d - %s'%(val, arabic_to_roman(val))romanDgts= 'ivxlcdmVXLCDM_' def ToRoman(num):   namoR = ''   if num >=4000000:      print 'Too Big -'      return '-----'   for rdix in range(0, len(romanDgts), 2):      if num==0: break      num,r = divmod(num,10)      v,r = divmod(r, 5)      if r==4:         namoR += romanDgts[rdix+1+v] + romanDgts[rdix]      else:         namoR += r*romanDgts[rdix] + (romanDgts[rdix+1] if(v==1) else '')   return namoR[-1::-1]anums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]rnums = strv.split() def to_roman(x):    ret = []    for a,r in zip(anums, rnums):        n,x = divmod(x,a)        ret.append(r*n)    return ''.join(ret) if __name__ == strv:    test = (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,40,            50,60,69,70,80,90,99,100,200,300,400,500,600,666,700,800,900,            1000,1009,1444,1666,1945,1997,1999,2000,2008,2010,2011,2500,            3000,3999)     for val in test:        print '%d - %s'%(val, to_roman(val)) rnl = [ { '4' : 'MMMM', '3' : 'MMM', '2' : 'MM', '1' : 'M', '0' : '' }, { '9' : 'CM', '8' : 'DCCC', '7' : 'DCC',          '6' : 'DC', '5' : 'D', '4' : 'CD', '3' : 'CCC', '2' : 'CC', '1' : 'C', '0' : '' }, { '9' : 'XC',          '8' : 'LXXX', '7' : 'LXX', '6' : 'LX', '5' : 'L', '4' : 'XL', '3' : 'XXX', '2' : 'XX', '1' : 'X',          '0' : '' }, { '9' : 'IX', '8' : 'VIII', '7' : 'VII', '6' : 'VI', '5' : 'V', '4' : 'IV', '3' : 'III',          '2' : 'II', '1' : 'I', '0' : '' }]
def number2romannumeral(n):    return ''.join([rnl[x][y] for x, y in zip(range(4), str(n).zfill(4)) if n < 5000 and n > -1])
def number2romannumeral(n):    return reduce(lambda x, y: x + y, map(lambda x, y: rnl[x][y], range(4), str(n).zfill(4))) if -1 < n < 5000 else None"
"from random import choice rules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}previous = ['rock', 'paper', 'scissors'] while True:    human = input('choose your weapon: ')    computer = rules[choice(previous)]  
     if human in ('quit', 'exit'): break     elif human in rules:        previous.append(human)        print('the computer played', computer, end='; ')         if rules[computer] == human:  
            print('yay you win!')        elif rules[human] == computer:  
            print('the computer beat you... :(')        else: print(strv)     else: print(strv)from random import randint hands = ['rock', 'scissors', 'paper']; judge = ['its a tie!', 'the computer beat you... :(', 'yay you win!']while True:    try:        YOU = hands.index(input('Choose your weapon: ')) 
    except ValueError:        break    NPC = randint(0, 2)    print('The computer played ' + hands[NPC] + '; ' + judge[YOU-NPC])"
" text = '''
---------- Ice and Fire ------------
 
fire, in end will world the say Some
ice. in say Some
desire of tasted I've what From
fire. favor who those with hold I
 
... elided paragraph last ...
 
Frost Robert -----------------------''' for line in text.split(''): print(' '.join(line.split()[::-1]))"
"_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1))) def decode( roman ):    result = 0    for r, r1 in zip(roman, roman[1:]):        rd, rd1 = _rdecode[r], _rdecode[r1]        result += -rd if rd < rd1 else rd    return result + _rdecode[roman[-1]] if __name__ == '__main__':    for r in 'MCMXC MMVIII MDCLXVI'.split():        print( r, decode(r) )roman_values = (('I',1), ('IV',4), ('V',5), ('IX',9),('X',10),('XL',40),('L',50),('XC',90),('C',100),                    ('CD', 400), ('D', 500), ('CM', 900), ('M',1000)) def roman_value(roman):    total=0    for symbol,value in reversed(roman_values):        while roman.startswith(symbol):            total += value            roman = roman[len(symbol):]    return total if __name__=='__main__':    for value in strv, strv, strv:        print('%s = %i' % (value, roman_value(value))) numerals = { 'M' : 1000, 'D' : 500, 'C' : 100, 'L' : 50, 'X' : 10, 'V' : 5, 'I' : 1 }def romannumeral2number(s):        return reduce(lambda x, y: -x + y if x < y else x + y, map(lambda x: numerals.get(x, 0), s.upper()))"
"class Example(object):    def foo(self):        print(strv)    def bar(self):        print(strv)    def __getattr__(self, name):        def method(*args):            print(strv + name)            if args:                print(strv + str(args))        return method example = Example() example.foo()        
example.bar()        
example.grill()      
example.ding(strv) 
                     
"
"def addsub(x, y):  return x + y, x - ysum, difference = addsub(33, 12)print strv % sumprint strv % difference"
"raw_input()[::-1]string[::-1]''.join(reversed(string))'''
  Reverse a Unicode string with proper handling of combining characters
''' import unicodedata def ureverse(ustring):    '''
    Reverse a string including unicode combining characters
 
    Example:
        >>> ucode = ''.join( chr(int(n, 16))
                             for n in ['61', '73', '20dd', '64', '66', '305'] )
        >>> ucoderev = ureverse(ucode)
        >>> ['%x' % ord(char) for char in ucoderev]
        ['66', '305', '64', '73', '20dd', '61']
        >>> 
    '''    groupedchars = []    uchar = list(ustring)    while uchar:        if 'COMBINING' in unicodedata.name(uchar[0], ''):            groupedchars[-1] += uchar.pop(0)        else:            groupedchars.append(uchar.pop(0))    
    groupedchars = groupedchars[::-1]     return ''.join(groupedchars) if __name__ == '__main__':    ucode = ''.join( chr(int(n, 16))                     for n in ['61', '73', '20dd', '64', '66', '305'] )    ucoderev = ureverse(ucode)    print (ucode)    print (ucoderev)"
"DIFF_THRESHOLD = 1e-40 class Fixed:    FREE = 0    A = 1    B = 2 class Node:    __slots__ = [strv, strv]    def __init__(self, v=0.0, f=Fixed.FREE):        self.voltage = v        self.fixed = f def set_boundary(m):    m[1][1] = Node( 1.0, Fixed.A)    m[6][7] = Node(-1.0, Fixed.B) def calc_difference(m, d):    h = len(m)    w = len(m[0])    total = 0.0     for i in xrange(h):        for j in xrange(w):            v = 0.0            n = 0            if i != 0:  v += m[i-1][j].voltage; n += 1            if j != 0:  v += m[i][j-1].voltage; n += 1            if i < h-1: v += m[i+1][j].voltage; n += 1            if j < w-1: v += m[i][j+1].voltage; n += 1            v = m[i][j].voltage - v / n             d[i][j].voltage = v            if m[i][j].fixed == Fixed.FREE:                total += v ** 2    return total def iter(m):    h = len(m)    w = len(m[0])    difference = [[Node() for j in xrange(w)] for i in xrange(h)]     while True:        set_boundary(m) 
        if calc_difference(m, difference) < DIFF_THRESHOLD:            break        for i, di in enumerate(difference):            for j, dij in enumerate(di):                m[i][j].voltage -= dij.voltage     cur = [0.0] * 3    for i, di in enumerate(difference):        for j, dij in enumerate(di):            cur[m[i][j].fixed] += (dij.voltage *                (bool(i) + bool(j) + (i < h-1) + (j < w-1)))     return (cur[Fixed.A] - cur[Fixed.B]) / 2.0 def main():    w = h = 10    mesh = [[Node() for j in xrange(w)] for i in xrange(h)]    print strv % (2 / iter(mesh)) main()import sys, copyfrom fractions import Fraction def gauss(a, b):    n, p = len(a), len(a[0])    for i in range(n):        t = abs(a[i][i])        k = i        for j in range(i + 1, n):            if abs(a[j][i]) > t:                t = abs(a[j][i])                k = j        if k != i:            for j in range(i, n):                a[i][j], a[k][j] = a[k][j], a[i][j]            b[i], b[k] = b[k], b[i]        t = 1/a[i][i]        for j in range(i + 1, n):            a[i][j] *= t        b[i] *= t        for j in range(i + 1, n):            t = a[j][i]            for k in range(i + 1, n):                a[j][k] -= t*a[i][k]            b[j] -= t * b[i]    for i in range(n - 1, -1, -1):        for j in range(i):            b[j] -= a[j][i]*b[i]    return b def resistor_grid(p, q, ai, aj, bi, bj):    n = p*q    I = Fraction(1, 1)    v = [0*I]*n    a = [copy.copy(v) for i in range(n)]    for i in range(p):        for j in range(q):            k = i*q + j            if i == ai and j == aj:                a[k][k] = I            else:                c = 0                if i + 1 < p:                    c += 1                    a[k][k + q] = -1                if i >= 1:                    c += 1                    a[k][k - q] = -1                if j + 1 < q:                    c += 1                    a[k][k + 1] = -1                if j >= 1:                    c += 1                    a[k][k - 1] = -1                a[k][k] = c*I    b = [0*I]*n    k = bi*q + bj    b[k] = 1    return gauss(a, b)[k] def main(arg):    r = resistor_grid(int(arg[0]), int(arg[1]), int(arg[2]), int(arg[3]), int(arg[4]), int(arg[5]))    print(r)    print(float(r)) main(sys.argv[1:]) 



"
"#!/usr/bin/pythondef repeat(f,n):  for i in range(n):    f(); def procedure():  print(strv); repeat(procedure,3); #prints strv (without quotes) three times, separated by newlines."
"strv * 5  
5 * strv  
"
"def is_repeated(text):    'check if the first part of the string is repeated throughout the string'    for x in range(len(text)//2, 0, -1):        if text.startswith(text[x:]): return x    return 0 matchstr = strv
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1
strvfor line in matchstr.split():    ln = is_repeated(line)    print('%r has a repetition length of %i i.e. %s'            % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))>>> def reps(text):    return [text[:x] for x in range(1, 1 + len(text) // 2)            if text.startswith(text[x:])] >>> matchstr = strv
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1
strv>>> print(''.join('%r has reps %r' % (line, reps(line)) for line in matchstr.split()))'1001110011' has reps ['10011']'1110111011' has reps ['1110']'0010010010' has reps ['001']'1010101010' has reps ['10', '1010']'1111111111' has reps ['1', '11', '111', '1111', '11111']'0100101101' has reps []'0100100' has reps ['010']'101' has reps []'11' has reps ['1']'00' has reps ['0']'1' has reps []>>> import re matchstr = strv
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1strv def _checker(matchobj):    g0, (g1, g2, g3, g4) = matchobj.group(0), matchobj.groups()    if not g4 and g1 and g1.startswith(g3):        return '%r repeats %r' % (g0, g1)    return '%r is not a rep-string' % (g0,) def checkit(txt):    print(re.sub(r'(.+)(+)(.*)|(.*)', _checker, txt)) checkit(matchstr)"
"import os os.rename(strv, strv)os.rename(strv, strv) os.rename(os.sep + strv, os.sep + strv)os.rename(os.sep + strv, os.sep + strv)import shutil shutil.move(strv, strv)shutil.move(strv, strv) shutil.move(strv, strv)shutil.move(strv, strv)"
"class Parent(object):    __priv = 'private'     def __init__(self, name):        self.name = name     def __repr__(self):        return '%s(%s)' % (type(self).__name__, self.name)     def doNothing(self):        pass import re class Child(Parent):    
    __rePrivate = re.compile('^_(Child|Parent)__')    
    __reBleh = re.compile('bleh$')    @property    def reBleh(self):        return self.__reBleh     def __init__(self, name, *args):        super(Child, self).__init__(name)        self.args = args     def __dir__(self):        myDir = filter(            
            lambda p: not self.__rePrivate.match(p),            list(set( \                sum([dir(base) for base in type(self).__bases__], []) \                + type(self).__dict__.keys() \                + self.__dict__.keys() \            )))        return myDir + map(            
            lambda p: p + '_bleh',            filter(                
                lambda p: (p[:2] != '__' or p[-2:] != '__') and not callable(getattr(self, p)),                myDir))     def __getattr__(self, name):        if name[-5:] == '_bleh':            
            return str(getattr(self, name[:-5])) + ' bleh'        if hasattr(super(Child, chld), '__getattr__'):            return super(Child, self).__getattr__(name)        raise AttributeError(strv % (type(self).__name__, name))     def __setattr__(self, name, value):        if name[-5:] == '_bleh':            
            if not (hasattr(self, name[:-5]) and callable(getattr(self, name[:-5]))):                setattr(self, name[:-5], self.reBleh.sub('', value))        elif hasattr(super(Child, self), '__setattr__'):            super(Child, self).__setattr__(name, value)        elif hasattr(self, '__dict__'):            self.__dict__[name] = value     def __repr__(self):        return '%s(%s, %s)' % (type(self).__name__, self.name, str(self.args).strip('[]()'))     def doStuff(self):        return (1+1.0/1e6) ** 1e6 par = Parent('par')par.parent = Truedir(par)#['_Parent__priv', '__class__', ..., 'doNothing', 'name', 'parent']inspect.getmembers(par)#[('_Parent__priv', 'private'), ('__class__', <class '__main__.Parent'>), ..., ('doNothing', <bound method Parent.doNothing of <__main__.Parent object at 0x100777650>>), ('name', 'par'), ('parent', True)] chld = Child('chld', 0, 'I', 'two')chld.own = strvdir(chld)#['__class__', ..., 'args', 'args_bleh', 'doNothing', 'doStuff', 'name', 'name_bleh', 'own', 'own_bleh', 'reBleh', 'reBleh_bleh']inspect.getmembers(chld)#[('__class__', <class '__main__.Child'>), ..., ('args', (0, 'I', 'two')), ('args_bleh', strv), ('reBleh', <_sre.SRE_Pattern object at 0x10067bd20>), ('reBleh_bleh', '<_sre.SRE_Pattern object at 0x10067bd20> bleh')] "
"#!/usr/bin/env python import fileinput, sys fname, start, count = sys.argv[1:4]start, count = int(start), int(count) for line in fileinput.input(fname, inplace=1, backup='.orig'):    if start <= fileinput.lineno() < start + count:        pass    else:        print line[:-1]fileinput.close()"
"import osos.__file__
 "
"import inspect 
class Super(object):  def __init__(self, name):    self.name = name   def __str__(self):    return strv % (self.name,)   def doSup(self):    return 'did super stuff'   @classmethod  def cls(cls):    return 'cls method (in sup)'   @classmethod  def supCls(cls):    return 'Super method'   @staticmethod  def supStatic():    return 'static method' class Other(object):  def otherMethod(self):    return 'other method' class Sub(Other, Super):  def __init__(self, name, *args):    super(Sub, self).__init__(name);    self.rest = args;    self.methods = {}   def __dir__(self):    return list(set( \        sum([dir(base) for base in type(self).__bases__], []) \        + type(self).__dict__.keys() \        + self.__dict__.keys() \        + self.methods.keys() \      ))   def __getattr__(self, name):    if name in self.methods:      if callable(self.methods[name]) and self.methods[name].__code__.co_argcount > 0:        if self.methods[name].__code__.co_varnames[0] == 'self':          return self.methods[name].__get__(self, type(self))        if self.methods[name].__code__.co_varnames[0] == 'cls':          return self.methods[name].__get__(type(self), type)      return self.methods[name]    raise AttributeError(strv % (type(self).__name__, name))   def __str__(self):    return strv % self.name   def doSub():    return 'did sub stuff'   @classmethod  def cls(cls):    return 'cls method (in Sub)'   @classmethod  def subCls(cls):    return 'Sub method'   @staticmethod  def subStatic():    return 'Sub method' sup = Super('sup')sub = Sub('sub', 0, 'I', 'two')sub.methods['incr'] = lambda x: x+1sub.methods['strs'] = lambda self, x: str(self) * x 
[method for method in dir(sub) if callable(getattr(sub, method))]
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == sub]#['__dir__', '__getattr__', '__init__', '__str__', 'doSub', 'doSup', 'otherMethod', 'strs']
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == type(sub)]#['__subclasshook__', 'cls', 'subCls', 'supCls']
[method for method in dir(sub) if callable(getattr(sub, method)) and type(getattr(sub, method)) == type(lambda:nil)]#['incr', 'subStatic', 'supStatic'] 
inspect.getmembers(sub, predicate=inspect.ismethod)
map(lambda t: t[0], inspect.getmembers(sub, predicate=inspect.ismethod))#['__dir__', '__getattr__', '__init__', '__str__', 'cls', 'doSub', 'doSup', 'otherMethod', 'strs', 'subCls', 'supCls']"
"import re string = strv if re.search('string$', string):    print(strv) string = re.sub(strv, strv, string)print(string)"
"items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']unique = list(set(items))items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']unique = []helperset = set()for x in items:    if x not in helperset:        unique.append(x)        helperset.add(x)import itertoolsitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']unique = [k for k,g in itertools.groupby(sorted(items))]items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']unique = []for x in items:    if x not in unique:        unique.append(x) from collections import OrderedDict as od print(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys())) def (dedup l)  let exists (table)    collect+each x l      unless exists.x        yield x      exists.x <- 1"
"import pyaudio chunk = 1024FORMAT = pyaudio.paInt16CHANNELS = 1RATE = 44100 p = pyaudio.PyAudio() stream = p.open(format = FORMAT,                channels = CHANNELS,                rate = RATE,                input = True,                frames_per_buffer = chunk) data = stream.read(chunk)print [ord(i) for i in data]"
"def ToReducedRowEchelonForm( M):    if not M: return    lead = 0    rowCount = len(M)    columnCount = len(M[0])    for r in range(rowCount):        if lead >= columnCount:            return        i = r        while M[i][lead] == 0:            i += 1            if i == rowCount:                i = r                lead += 1                if columnCount == lead:                    return        M[i],M[r] = M[r],M[i]        lv = M[r][lead]        M[r] = [ mrx / float(lv) for mrx in M[r]]        for i in range(rowCount):            if i != r:                lv = M[i][lead]                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]        lead += 1  mtx = [   [ 1, 2, -1, -4],   [ 2, 3, -1, -11],   [-2, 0, -3, 22],] ToReducedRowEchelonForm( mtx ) for rw in mtx:  print ', '.join( (str(rv) for rv in rw) )"
"with open('xxx.txt') as f:    for i, line in enumerate(f):        if i == 6:            break    else:        print('Not 7 lines in file')        line = Nonefrom itertools import islice with open('xxx.txt') as f:    try:        line = next(islice(f, 6, 7))    except StopIteration:        print('Not 7 lines in file') print open('xxx.txt').readlines()[:7][-1] "
"open(filename).read()open(filename, encoding='utf-8').read() with open(filename) as f:    data = f.read() "
" def get_next_character(f):  
  c = f.read(1)  while c:    while True:      try:        yield c.decode('utf-8')      except UnicodeDecodeError:        
        
        c += f.read(1)      else:        
        c = f.read(1)        break 
with open(strv,strv) as f:    for c in get_next_character(f):        print(c) def get_next_character(f):    strv    c = f.read(1)    while c:         yield c        c = f.read(1) 
with open(strv, encoding=strv) as f:    for c in get_next_character(f):        print(c, sep=strv, end=strv)"
"import math math.e          
math.pi         
math.sqrt(x)    
math.log(x)     
math.log10(x)   
math.exp(x)     
abs(x)          
math.floor(x)   
math.ceil(x)    
x ** y          
pow(x, y[, n])  
 

"
with open(strv) as f:    for line in f:        process(line)import fileinputfor line in fileinput.input():    process(line) 
"def readconf(fn):    ret = {}    with file(fn) as fp:        for line in fp:            
            line = line.strip()            if not line or line.startswith('#'): continue             boolval = True            
            if line.startswith(';'):                
                line = line.lstrip(';')                
                if len(line.split()) != 1: continue                boolval = False             bits = line.split(None, 1)            if len(bits) == 1:                
                k = bits[0]                v = boolval            else:                
                k, v = bits            ret[k.lower()] = v    return ret  if __name__ == '__main__':    import sys    conf = readconf(sys.argv[1])    for k, v in sorted(conf.items()):        print k, '=', v"
"from collections import namedtuplefrom pprint import pprint as ppimport sys Pt = namedtuple('Pt', 'x, y')               
Edge = namedtuple('Edge', 'a, b')           
Poly = namedtuple('Poly', 'name, edges')    
 _eps = 0.00001_huge = sys.float_info.max_tiny = sys.float_info.min def rayintersectseg(p, edge):    ''' takes a point p=Pt() and an edge of two endpoints a,b=Pt() of a line segment returns boolean
    '''    a,b = edge    if a.y > b.y:        a,b = b,a    if p.y == a.y or p.y == b.y:        p = Pt(p.x, p.y + _eps)     intersect = False     if (p.y > b.y or p.y < a.y) or (        p.x > max(a.x, b.x)):        return False     if p.x < min(a.x, b.x):        intersect = True    else:        if abs(a.x - b.x) > _tiny:            m_red = (b.y - a.y) / float(b.x - a.x)        else:            m_red = _huge        if abs(a.x - p.x) > _tiny:            m_blue = (p.y - a.y) / float(p.x - a.x)        else:            m_blue = _huge        intersect = m_blue >= m_red    return intersect def _odd(x): return x%2 == 1 def ispointinside(p, poly):    ln = len(poly)    return _odd(sum(rayintersectseg(p, edge)                    for edge in poly.edges )) def polypp(poly):    print (""  Polygon(name='%s', edges=("" % poly.name)    print ('   ', ',    '.join(str(e) for e in poly.edges) + '    ))') if __name__ == '__main__':    polys = [      Poly(name='square', edges=(        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0))        )),      Poly(name='square_hole', edges=(        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0)),        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=7.5, y=2.5)),        Edge(a=Pt(x=7.5, y=2.5), b=Pt(x=7.5, y=7.5)),        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=2.5, y=7.5)),        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=2.5, y=2.5))        )),      Poly(name='strange', edges=(        Edge(a=Pt(x=0, y=0), b=Pt(x=2.5, y=2.5)),        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=0, y=10)),        Edge(a=Pt(x=0, y=10), b=Pt(x=2.5, y=7.5)),        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=7.5, y=7.5)),        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=10, y=10)),        Edge(a=Pt(x=10, y=10), b=Pt(x=10, y=0)),        Edge(a=Pt(x=10, y=0), b=Pt(x=2.5, y=2.5))        )),      Poly(name='exagon', edges=(        Edge(a=Pt(x=3, y=0), b=Pt(x=7, y=0)),        Edge(a=Pt(x=7, y=0), b=Pt(x=10, y=5)),        Edge(a=Pt(x=10, y=5), b=Pt(x=7, y=10)),        Edge(a=Pt(x=7, y=10), b=Pt(x=3, y=10)),        Edge(a=Pt(x=3, y=10), b=Pt(x=0, y=5)),        Edge(a=Pt(x=0, y=5), b=Pt(x=3, y=0))        )),      ]    testpoints = (Pt(x=5, y=5), Pt(x=5, y=8),                  Pt(x=-10, y=5), Pt(x=0, y=5),                  Pt(x=10, y=5), Pt(x=8, y=5),                  Pt(x=10, y=10))     print ("" TESTING WHETHER POINTS ARE WITHIN POLYGONS"")    for poly in polys:        polypp(poly)        print ('   ', ''.join(strv % (p, ispointinside(p, poly))                               for p in testpoints[:3]))        print ('   ', ''.join(strv % (p, ispointinside(p, poly))                               for p in testpoints[3:6]))        print ('   ', ''.join(strv % (p, ispointinside(p, poly))                               for p in testpoints[6:]))def _convert_fortran_shapes():    point = Pt    pts = (point(0,0), point(10,0), point(10,10), point(0,10),            point(2.5,2.5), point(7.5,2.5), point(7.5,7.5), point(2.5,7.5),            point(0,5), point(10,5),            point(3,0), point(7,0), point(7,10), point(3,10))    p = (point(5,5), point(5, 8), point(-10, 5), point(0,5), point(10,5),         point(8,5), point(10,10) )     def create_polygon(pts,vertexindex):        return [tuple(Edge(pts[vertexindex[i]-1], pts[vertexindex[i+1]-1])                       for i in range(0, len(vertexindex), 2) )]    polys=[]    polys += create_polygon(pts, ( 1,2, 2,3, 3,4, 4,1 ) )    polys += create_polygon(pts, ( 1,2, 2,3, 3,4, 4,1, 5,6, 6,7, 7,8, 8,5 ) )    polys += create_polygon(pts, ( 1,5, 5,4, 4,8, 8,7, 7,3, 3,2, 2,5 ) )    polys += create_polygon(pts, ( 11,12, 12,10, 10,13, 13,14, 14,9, 9,11 ) )     names = ( strv, strv, strv, strv )    polys = [Poly(name, edges)             for name, edges in zip(names, polys)]    print 'polys = ['    for p in polys:        print strv % p.name        print '   ', ',    '.join(str(e) for e in p.edges) + '    )),'    print '  ]' _convert_fortran_shapes()"
"import subprocessimport time class Tlogger(object):    def __init__(self):        self.counts = 0        self.tottime = 0.0        self.laststart = 0.0        self.lastreport = time.time()     def logstart(self):        self.laststart = time.time()     def logend(self):        self.counts +=1        self.tottime += (time.time()-self.laststart)        if (time.time()-self.lastreport)>5.0:   
           self.report()     def report(self):        if ( self.counts > 4*self.tottime):            print strv% (self.counts/self.tottime);        else:            print strv%(self.tottime/self.counts);        self.lastreport = time.time()  def taskTimer( n, subproc_args ):    logger = Tlogger()     for x in range(n):        logger.logstart()        p = subprocess.Popen(subproc_args)        p.wait()        logger.logend()    logger.report()  import timeitimport sys def main( ):     
    s = strv    timer = timeit.Timer(s)    rzlts = timer.repeat(5, 5000)    for t in rzlts:        print strv,t     
    print strv,sys.argv[1]    print strv,sys.argv[2:]    print strv    for k in range(3):       taskTimer( int(sys.argv[1]), sys.argv[2:]) main()"
"def mc_rank(iterable, start=1):    strv    lastresult, fifo = None, []    for n, item in enumerate(iterable, start-1):        if item[0] == lastresult:            fifo += [item]        else:            while fifo:                yield n, fifo.pop(0)            lastresult, fifo = item[0], fifo + [item]    while fifo:        yield n+1, fifo.pop(0)  def sc_rank(iterable, start=1):    strv    lastresult, lastrank = None, None    for n, item in enumerate(iterable, start):        if item[0] == lastresult:            yield lastrank, item        else:            yield n, item            lastresult, lastrank = item[0], n  def d_rank(iterable, start=1):    strv    lastresult, lastrank = None, start - 1,    for item in iterable:        if item[0] == lastresult:            yield lastrank, item        else:            lastresult, lastrank = item[0], lastrank + 1            yield lastrank, item  def o_rank(iterable, start=1):    strv    yield from enumerate(iterable, start)  def f_rank(iterable, start=1):    strv    last, fifo = None, []    for n, item in enumerate(iterable, start):        if item[0] != last:            if fifo:                mean = sum(f[0] for f in fifo) / len(fifo)                while fifo:                    yield mean, fifo.pop(0)[1]        last = item[0]        fifo.append((n, item))    if fifo:        mean = sum(f[0] for f in fifo) / len(fifo)        while fifo:            yield mean, fifo.pop(0)[1]  if __name__ == '__main__':    scores = [(44, 'Solomon'),              (42, 'Jason'),              (42, 'Errol'),              (41, 'Garry'),              (41, 'Bernard'),              (41, 'Barry'),              (39, 'Stephen')]     print('Scores to be ranked (best first):')    for s in scores:        print('        %2i %s' % (s ))    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:        print('%s:' % ranker.__doc__)        for rank, score in ranker(scores):            print('  %3g, %r' % (rank, score))"
">>> import random>>> values = [random.gauss(1, .5) for i in range(1000)]>>> >>> def quick_check(numbers):    count = len(numbers)    mean = sum(numbers) / count    sdeviation = (sum((i - mean)**2 for i in numbers) / count)**0.5    return mean, sdeviation >>> quick_check(values)(1.0140373306786599, 0.49943411329234066)>>> >>> values = [ random.normalvariate(1, 0.5) for i in range(1000)]>>> quick_check(values)(0.990099111944864, 0.5029847005836282)>>> "
"range17 = range(17)a = [['0'] * 17 for i in range17]idx = [0] * 4  def find_group(mark, min_n, max_n, depth=1):    if (depth == 4):        prefix = strv if (mark == '1') else strv        print(strv.format(prefix))        for i in range(4):            print(idx[i])        return True     for i in range(min_n, max_n):        n = 0        while (n < depth):            if (a[idx[n]][i] != mark):                break            n += 1         if (n == depth):            idx[n] = i            if (find_group(mark, 1, max_n, depth + 1)):                return True     return False  if __name__ == '__main__':    for i in range17:        a[i][i] = '-'    for k in range(4):        for i in range17:            j = (i + pow(2, k)) % 17            a[i][j] = a[j][i] = '1'     
    
     for row in a:        print(' '.join(row))     for i in range17:        idx[0] = i        if (find_group('1', i + 1, 17) or find_group('0', i + 1, 17)):            print(strv)            exit()     print(strv)"
"from __future__ import print_functionfrom shapely.geometry import LineString if __name__==strv:	line = LineString([(0,0),(1,0.1),(2,-0.1),(3,5),(4,6),(5,7),(6,8.1),(7,9),(8,9),(9,9)])	print (line.simplify(1.0, preserve_topology=False))"
"import randomrand = random.SystemRandom()rand.randint(1,10)"
"def rangeexpand(txt):    lst = []    for r in txt.split(','):        if '-' in r[1:]:            r0, r1 = r[1:].split('-', 1)            lst += range(int(r[0] + r0), int(r1) + 1)        else:            lst.append(int(r))    return lst print(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))import re def rangeexpand(txt):    lst = []    for rng in txt.split(','):        start,end = re.match('^(-?+)(?:-(-?+))?$', rng).groups()        if end:            lst.extend(xrange(int(start),int(end)+1))        else:            lst.append(int(start))    return lstfrom functools import reducefrom operator import add def rangeexpand(s):    return reduce(add,            map(lambda x: list(range(*map(int, x.split('-')))) if '-' in x else [int(x)], s.split(','))) "
"def range_extract(lst):    'Yield 2-tuple ranges or 1-tuple single elements from list of increasing ints'    lenlst = len(lst)    i = 0    while i< lenlst:        low = lst[i]        while i <lenlst-1 and lst[i]+1 == lst[i+1]: i +=1        hi = lst[i]        if   hi - low >= 2:            yield (low, hi)        elif hi - low == 1:            yield (low,)            yield (hi,)        else:            yield (low,)        i += 1 def printr(ranges):    print( ','.join( (('%i-%i' % r) if len(r) == 2 else '%i' % r)                     for r in ranges ) ) if __name__ == '__main__':    for lst in [[-8, -7, -6, -3, -2, -1, 0, 1, 3, 4, 5, 7,                 8, 9, 10, 11, 14, 15, 17, 18, 19, 20],                [0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22,                 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39]]:        #print(list(range_extract(lst)))        printr(range_extract(lst))"
"import random def partition(vector, left, right, pivotIndex):    pivotValue = vector[pivotIndex]    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  
    storeIndex = left    for i in range(left, right):        if vector[i] < pivotValue:            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]            storeIndex += 1    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  
    return storeIndex def _select(vector, left, right, k):    strv    while True:        pivotIndex = random.randint(left, right)     
        pivotNewIndex = partition(vector, left, right, pivotIndex)        pivotDist = pivotNewIndex - left        if pivotDist == k:            return vector[pivotNewIndex]        elif k < pivotDist:            right = pivotNewIndex - 1        else:            k -= pivotDist + 1            left = pivotNewIndex + 1 def select(vector, k, left=None, right=None):    strv
    Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1].
    left, right default to (0, len(vector) - 1) if omitted
    strv    if left is None:        left = 0    lv1 = len(vector) - 1    if right is None:        right = lv1    assert vector and k >= 0, strv    assert 0 <= left <= lv1, strv    assert left <= right <= lv1, strv    return _select(vector, left, right, k) if __name__ == '__main__':    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]    print([select(v, i) for i in range(10)])"
"x = 'x = %rprint(x %% x)'print(x % x)x = 'x = {!r};print(x.format(x))';print(x.format(x))import sys; sys.stdout.write(open(sys.argv[0]).read())import sys,inspect;sys.stdout.write(inspect.getsource(inspect.currentframe())) print(__file__[:-3])  x = strvx = {0}{1}{0}
print x.format(chr(34)*3,x)strvprint x.format(chr(34)*3,x)  a = 'YSA9ICcnCmIgPSBhLmRlY29kZSgnYmFzZTY0JykKcHJpbnQgYls6NV0rYStiWzU6XQ=='b = a.decode('base64')print b[:5]+a+b[5:]  data = (	'ZGF0YSA9ICgKCSc=',	'JywKCSc=',	'JwopCnByZWZpeCwgc2VwYXJhdG9yLCBzdWZmaXggPSAoZC5kZWNvZGUoJ2Jhc2U2NCcpIGZvciBkIGluIGRhdGEpCnByaW50IHByZWZpeCArIGRhdGFbMF0gKyBzZXBhcmF0b3IgKyBkYXRhWzFdICsgc2VwYXJhdG9yICsgZGF0YVsyXSArIHN1ZmZpeA==')prefix, separator, suffix = (d.decode('base64') for d in data)print prefix + data[0] + separator + data[1] + separator + data[2] + suffix  def applyToOwnSourceCode(functionBody):	print strv	print functionBody	print strv + repr(functionBody) + strvapplyToOwnSourceCode('print strvprint functionBodyprint strv') "
"import Queuemy_queue = Queue.Queue()my_queue.put(strv)my_queue.put(strv)my_queue.put(strv)print my_queue.get()  
print my_queue.get()  
print my_queue.get()  
"
"   class FIFO(object):       def __init__(self, *args):           self.contents = list(args)       def __call__(self):           return self.pop()       def __len__(self):           return len(self.contents)       def pop(self):           return self.contents.pop(0)       def push(self, item):           self.contents.append(item)       def extend(self,*itemlist):           self.contents += itemlist       def empty(self):           return bool(self.contents)       def __iter__(self):           return self       def next(self):           if self.empty():               raise StopIteration           return self.pop() if __name__ == strv:    
    f = FIFO()    f.push(3)    f.push(2)    f.push(1)    while not f.empty():        print f.pop(),    
    
    f = FIFO(3,2,1)    while not f.empty():        print f(),    
    
    
    f = FIFO(3,2,1)    while f:        print f(),    
    f = FIFO(3,2,1)    for i in f:        print i,class FIFO:  ## NOT a new-style class, must not derive from strv   def __init__(self,*args):       self.contents = list(args)   def __call__(self):       return self.pop()   def empty(self):       return bool(self.contents)   def pop(self):       return self.contents.pop(0)   def __getattr__(self, attr):       return getattr(self.contents,attr)   def next(self):       if not self:           raise StopIteration       return self.pop()from collections import dequefifo = deque()fifo. appendleft(value) 
value = fifo.pop()not fifo 
fifo.pop() 
def (queue seq)  (tag queue (list seq lastcons.seq len.seq)) def (enq x q)  do1 x    let (l last len) rep.q      rep.q.2 <- (len + 1)      if no.l        rep.q.1 <- (rep.q.0 <- list.x)        rep.q.1 <- (cdr.last <- list.x) def (deq q)  let (l last len) rep.q    ret ans car.l      unless zero?.len        rep.q.2 <- (len - 1)      rep.q.0 <- cdr.l def (len q) :case (isa queue q)  rep.q.2"
"#!/usr/bin/env python3 import numpy as np def qr(A):    m, n = A.shape    Q = np.eye(m)    for i in range(n - (m == n)):        H = np.eye(m)        H[i:, i:] = make_householder(A[i:, i])        Q = np.dot(Q, H)        A = np.dot(H, A)    return Q, A def make_householder(a):    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))    v[0] = 1    H = np.eye(a.shape[0])    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])    return H 
a = np.array(((    (12, -51,   4),    ( 6, 167, -68),    (-4,  24, -41),))) q, r = qr(a)print('q:', q.round(6))print('r:', r.round(6)) 
def polyfit(x, y, n):    return lsqr(x[:, None]**np.arange(n + 1), y.T) def lsqr(a, b):    q, r = qr(a)    _, n = r.shape    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n]) x = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))y = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321)) print('polyfit:', polyfit(x, y, 2))"
"from collections import namedtupleimport math class Q(namedtuple('Quaternion', 'real, i, j, k')):    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)'      __slots__ = ()      def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):        'Defaults all parts of quaternion to zero'        return super().__new__(_cls, float(real), float(i), float(j), float(k))     def conjugate(self):        return Q(self.real, -self.i, -self.j, -self.k)     def _norm2(self):        return sum( x*x for x in self)     def norm(self):        return math.sqrt(self._norm2())     def reciprocal(self):        n2 = self._norm2()        return Q(*(x / n2 for x in self.conjugate()))      def __str__(self):        'Shorter form of Quaternion as string'        return 'Q(%g, %g, %g, %g)' % self     def __neg__(self):        return Q(-self.real, -self.i, -self.j, -self.k)     def __add__(self, other):        if type(other) == Q:            return Q( *(s+o for s,o in zip(self, other)) )        try:            f = float(other)        except:            return NotImplemented        return Q(self.real + f, self.i, self.j, self.k)     def __radd__(self, other):        return Q.__add__(self, other)     def __mul__(self, other):        if type(other) == Q:            a1,b1,c1,d1 = self            a2,b2,c2,d2 = other            return Q(                 a1*a2 - b1*b2 - c1*c2 - d1*d2,                 a1*b2 + b1*a2 + c1*d2 - d1*c2,                 a1*c2 - b1*d2 + c1*a2 + d1*b2,                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )        try:            f = float(other)        except:            return NotImplemented        return Q(self.real * f, self.i * f, self.j * f, self.k * f)     def __rmul__(self, other):        return Q.__mul__(self, other)     def __truediv__(self, other):        if type(other) == Q:            return self.__mul__(other.reciprocal())        try:            f = float(other)        except:            return NotImplemented        return Q(self.real / f, self.i / f, self.j / f, self.k / f)     def __rtruediv__(self, other):        return other * self.reciprocal()     __div__, __rdiv__ = __truediv__, __rtruediv__ Quaternion = Q        q  = Q(1, 2, 3, 4)q1 = Q(2, 3, 4, 5)q2 = Q(3, 4, 5, 6)r  = 7>>> qQuaternion(real=1.0, i=2.0, j=3.0, k=4.0)>>> q1Quaternion(real=2.0, i=3.0, j=4.0, k=5.0)>>> q2Quaternion(real=3.0, i=4.0, j=5.0, k=6.0)>>> r7>>> q.norm()5.477225575051661>>> q1.norm()7.3484692283495345>>> q2.norm()9.273618495495704>>> -qQuaternion(real=-1.0, i=-2.0, j=-3.0, k=-4.0)>>> q.conjugate()Quaternion(real=1.0, i=-2.0, j=-3.0, k=-4.0)>>> r + qQuaternion(real=8.0, i=2.0, j=3.0, k=4.0)>>> q + rQuaternion(real=8.0, i=2.0, j=3.0, k=4.0)>>> q1 + q2Quaternion(real=5.0, i=7.0, j=9.0, k=11.0)>>> q2 + q1Quaternion(real=5.0, i=7.0, j=9.0, k=11.0)>>> q * rQuaternion(real=7.0, i=14.0, j=21.0, k=28.0)>>> r * qQuaternion(real=7.0, i=14.0, j=21.0, k=28.0)>>> q1 * q2Quaternion(real=-56.0, i=16.0, j=24.0, k=26.0)>>> q2 * q1Quaternion(real=-56.0, i=18.0, j=20.0, k=28.0)>>> assert q1 * q2 != q2 * q1>>> >>> i, j, k = Q(0,1,0,0), Q(0,0,1,0), Q(0,0,0,1)>>> i*iQuaternion(real=-1.0, i=0.0, j=0.0, k=0.0)>>> j*jQuaternion(real=-1.0, i=0.0, j=0.0, k=0.0)>>> k*kQuaternion(real=-1.0, i=0.0, j=0.0, k=0.0)>>> i*j*kQuaternion(real=-1.0, i=0.0, j=0.0, k=0.0)>>> q1 / q2Quaternion(real=0.7906976744186047, i=0.023255813953488358, j=-2.7755575615628914e-17, k=0.046511627906976744)>>> q1 / q2 * q2Quaternion(real=2.0000000000000004, i=3.0000000000000004, j=4.000000000000001, k=5.000000000000001)>>> q2 * q1 / q2Quaternion(real=2.0, i=3.465116279069768, j=3.906976744186047, k=4.767441860465116)>>> q1.reciprocal() * q1Quaternion(real=0.9999999999999999, i=0.0, j=0.0, k=0.0)>>> q1 * q1.reciprocal()Quaternion(real=0.9999999999999999, i=0.0, j=0.0, k=0.0)>>> "
"from fractions import gcd  def pt1(maxperimeter=100):    '''


    '''    trips = []    for a in range(1, maxperimeter):        aa = a*a        for b in range(a, maxperimeter-a+1):            bb = b*b            for c in range(b, maxperimeter-b-a+1):                cc = c*c                if a+b+c > maxperimeter or cc > aa + bb: break                if aa + bb == cc:                    trips.append((a,b,c, gcd(a, b) == 1))    return trips def pytrip(trip=(3,4,5),perim=100, prim=1):    a0, b0, c0 = a, b, c = sorted(trip)    t, firstprim = set(), prim>0    while a + b + c <= perim:        t.add((a, b, c, firstprim>0))        a, b, c, firstprim = a+a0, b+b0, c+c0, False    #    t2 = set()    for a, b, c, firstprim in t:        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7        if  a5 - b5 + c7 <= perim:            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)        if  a5 + b5 + c7 <= perim:            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)        if -a5 + b5 + c7 <= perim:            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)    return t | t2 def pt2(maxperimeter=100):    '''




    '''    trips = pytrip((3,4,5), maxperimeter, 1)    return trips def printit(maxperimeter=100, pt=pt1):    trips = pt(maxperimeter)    print(strv          % (maxperimeter,             len(trips),             len([prim for a,b,c,prim in trips if prim]))) for algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):    print(algo.__doc__)    for maxperimeter in range(mn, mx+1, mn):        printit(maxperimeter, algo) from sys import setrecursionlimitsetrecursionlimit(2000) 
 def triples(lim, a = 3, b = 4, c = 5):    l = a + b + c    if l > lim: return (0, 0)    return reduce(lambda x, y: (x[0] + y[0], x[1] + y[1]), [        (1, lim / l),        triples(lim,  a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c),        triples(lim,  a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c),        triples(lim, -a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c) ]) for peri in [10 ** e for e in range(1, 8)]:    print peri, triples(peri)"
">>> def proper_divs2(n):...     return {x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x}... >>> [proper_divs2(n) for n in range(1, 11)][set(), {1}, {1}, {1, 2}, {1}, {1, 2, 3}, {1}, {1, 2, 4}, {1, 3}, {1, 2, 5}]>>> >>> n, length = max(((n, len(proper_divs2(n))) for n in range(1, 20001)), key=lambda pd: pd[1])>>> n15120>>> length79>>> from math import sqrtfrom functools import lru_cache, reducefrom collections import Counterfrom itertools import product  MUL = int.__mul__  def prime_factors(n):    'Map prime factors to their multiplicity for n'    d = _divs(n)    d = [] if d == [n] else (d[:-1] if d[-1] == d else d)    pf = Counter(d)    return dict(pf) @lru_cache(maxsize=None)def _divs(n):    'Memoized recursive function returning prime factors of n as a list'    for i in range(2, int(sqrt(n)+1)):        d, m  = divmod(n, i)        if not m:            return [i] + _divs(d)    return [n]  def proper_divs(n):    '''Return the set of proper divisors of n.'''    pf = prime_factors(n)    pfactors, occurrences = pf.keys(), pf.values()    multiplicities = product(*(range(oc + 1) for oc in occurrences))    divs = {reduce(MUL, (pf**m for pf, m in zip(pfactors, multis)), 1)            for multis in multiplicities}    try:        divs.remove(n)    except KeyError:        pass    return divs or ({1} if n != 1 else set())  if __name__ == '__main__':    rangemax = 20000     print([proper_divs(n) for n in range(1, 11)])    print(*max(((n, len(proper_divs(n))) for n in range(1, 20001)), key=lambda pd: pd[1]))"
import sysif problem:    sys.exit(1)import osif problem:    os.abort()
" from collections import namedtupleimport math Circle = namedtuple('Circle', 'x, y, r') def solveApollonius(c1, c2, c3, s1, s2, s3):    '''
    >>> solveApollonius((0, 0, 1), (4, 0, 1), (2, 4, 2), 1,1,1)
    Circle(x=2.0, y=2.1, r=3.9)
    >>> solveApollonius((0, 0, 1), (4, 0, 1), (2, 4, 2), -1,-1,-1)
    Circle(x=2.0, y=0.8333333333333333, r=1.1666666666666667) 
    '''    x1, y1, r1 = c1    x2, y2, r2 = c2    x3, y3, r3 = c3     v11 = 2*x2 - 2*x1    v12 = 2*y2 - 2*y1    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2    v14 = 2*s2*r2 - 2*s1*r1     v21 = 2*x3 - 2*x2    v22 = 2*y3 - 2*y2    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3    v24 = 2*s3*r3 - 2*s2*r2     w12 = v12/v11    w13 = v13/v11    w14 = v14/v11     w22 = v22/v21-w12    w23 = v23/v21-w13    w24 = v24/v21-w14     P = -w23/w22    Q = w24/w22    M = -w12*P-w13    N = w14 - w12*Q     a = N*N + Q*Q - 1    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1     
    D = b*b-4*a*c    rs = (-b-math.sqrt(D))/(2*a)     xs = M+N*rs    ys = P+Q*rs     return Circle(xs, ys, rs) if __name__ == '__main__':    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)    print(solveApollonius(c1, c2, c3, 1, 1, 1))    #Expects strv (green circle in image)    print(solveApollonius(c1, c2, c3, -1, -1, -1)) #Expects strv (red circle in image)"
#!/usr/bin/env python import sys def main():    program = sys.argv[0]    print(strv % program) if __name__ == strv:    main()#!/usr/bin/env python import inspect def main():    program = inspect.getfile(inspect.currentframe())    print(strv % program) if __name__ == strv:    main()
"from __future__ import print_functionfrom itertools import takewhile maxsum = 99 def get_primes(max):    if max < 2:        return []    lprimes = [2]    for x in range(3, max + 1, 2):        for p in lprimes:            if x % p == 0:                break        else:            lprimes.append(x)    return lprimes descendants = [[] for _ in range(maxsum + 1)]ancestors = [[] for _ in range(maxsum + 1)] primes = get_primes(maxsum) for p in primes:    descendants[p].append(p)    for s in range(1, len(descendants) - p):        descendants[s + p] += [p * pr for pr in descendants[s]] for p in primes + [4]:    descendants[p].pop() total = 0for s in range(1, maxsum + 1):    descendants[s].sort()    for d in takewhile(lambda x: x <= maxsum, descendants[s]):        ancestors[d] = ancestors[s] + [s]    print([s], strv, len(ancestors[s]))    print(strv, ancestors[s] if len(ancestors[s]) else strv)    print(strv, len(descendants[s]) if len(descendants[s]) else strv)    if len(descendants[s]):        print(descendants[s])    print()    total += len(descendants[s]) print(strv, total)"
"import random, bisect def probchoice(items, probs):  '''
  Splits the interval 0.0-1.0 in proportion to probs
  then finds where each random.random() choice lies
  '''   prob_accumulator = 0  accumulator = []  for p in probs:    prob_accumulator += p    accumulator.append(prob_accumulator)   while True:    r = random.random()    yield items[bisect.bisect(accumulator, r)] def probchoice2(items, probs, bincount=10000):  '''
  Puts items in bins in proportion to probs
  then uses random.choice() to select items.
 
  Larger bincount for more memory use but
  higher accuracy (on avarage).
  '''   bins = []  for item,prob in zip(items, probs):    bins += [item]*int(bincount*prob)  while True:    yield random.choice(bins)  def tester(func=probchoice, items='good bad ugly'.split(),                    probs=[0.5, 0.3, 0.2],                    trials = 100000                    ):  def problist2string(probs):    '''
    Turns a list of probabilities into a string
    Also rounds FP values
    '''    return strv.join('%8.6f' % (p,) for p in probs)   from collections import defaultdict   counter = defaultdict(int)  it = func(items, probs)  for dummy in xrange(trials):    counter[it.next()] += 1  print ""#### %s##"" % func.func_name.upper()    print strv, trials  print strv, ' '.join(items)  print strv, problist2string(probs)  print strv, problist2string(    counter[x]/float(trials) for x in items) if __name__ == '__main__':  items = 'aleph beth gimel daleth he waw zayin heth'.split()  probs = [1/(float(n)+5) for n in range(len(items))]  probs[-1] = 1-sum(probs[:-1])  tester(probchoice, items, probs, 1000000)  tester(probchoice2, items, probs, 1000000)"
"from pyprimes import nprimesfrom functools import reduce  primelist = list(nprimes(1000001))    
 def primorial(n):    return reduce(int.__mul__, primelist[:n], 1) if __name__ == '__main__':    print('First ten primorals:', [primorial(n) for n in range(10)])    for e in range(7):        n = 10**e        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))"
"from __future__ import print_function import sysfrom itertools import islice, cycle, count try:    from itertools import compressexcept ImportError:    def compress(data, selectors):        strv        return (d for d, s in zip(data, selectors) if s)  def is_prime(n):    return list(zip((True, False), decompose(n)))[-1][0] class IsPrimeCached(dict):    def __missing__(self, n):        r = is_prime(n)        self[n] = r        return r is_prime_cached = IsPrimeCached() def croft():    strvYield prime integers using the Croft Spiral sieve.
 
    This is a variant of wheel factorisation modulo 30.
    strv    
    
    
    
    
    
    
    
    for p in (2, 3, 5):        yield p    roots = {9: 3, 25: 5}  
    primeroots = frozenset((1, 7, 11, 13, 17, 19, 23, 29))    selectors = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)    for q in compress(            
            islice(count(7), 0, None, 2),            
            cycle(selectors)            ):        
        
        if q in roots:            p = roots[q]            del roots[q]            x = q + 2*p            while x in roots or (x % 30) not in primeroots:                x += 2*p            roots[x] = p        else:            roots[q*q] = q            yield qprimes = croft def decompose(n):    for p in primes():        if p*p > n: break        while n % p == 0:            yield p            n //=p    if n > 1:        yield n  if __name__ == '__main__':    
     import time     for m in primes():        p = 2 ** m - 1        print( strv.format(m, p) )        start = time.time()        for factor in decompose(p):            print(factor, end=' ')            sys.stdout.flush()         print( strv.format( time.time()-start ) )        if m >= 59:            breakfrom math import floor, sqrttry:     longexcept NameError:     long = int def fac(n):    step = lambda x: 1 + (x<<2) - ((x>>1)<<1)    maxq = long(floor(sqrt(n)))    d = 1    q = n % 2 == 0 and 2 or 3     while q <= maxq and n % q != 0:        q = step(d)        d += 1    return q <= maxq and [q] + fac(n//q) or [n] if __name__ == '__main__':    import time    start = time.time()    tocalc =  2**59-1    print(strv % (tocalc, fac(tocalc)))    print(strv % (time.time() - start))"
"def prime(a):    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))def prime2(a):    if a == 2: return True    if a < 2 or a % 2 == 0: return False    return not any(a % x == 0 for x in xrange(3, int(a**0.5) + 1, 2))def prime3(a):    if a < 2: return False    if a == 2 or a == 3: return True 
    if a % 2 == 0 or a % 3 == 0: return False 
     maxDivisor = a**0.5    d, i = 5, 2    while d <= maxDivisor:        if a % d == 0: return False        d += i         i = 6 - i 
     return True>>> import re>>> def isprime(n):    return not re.match(r'^1?$|^(11+?)+$', '1' * n) >>> 
>>> [i for i in range(40) if isprime(i)][2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]"
">>> import queue>>> pq = queue.PriorityQueue()>>> for item in ((3, strv), (4, strv), (5, strv), (1, strv), (2, strv)):  pq.put(item)  >>> while not pq.empty():  print(pq.get_nowait())  (1, 'Solve RC tasks')(2, 'Tax return')(3, 'Clear drains')(4, 'Feed cat')(5, 'Make tea')>>> >>> import queue>>> help(queue.PriorityQueue)Help on class PriorityQueue in module queue: class PriorityQueue(Queue) |  Variant of Queue that retrieves open entries in priority order (lowest first). |   |  Entries are typically tuples of the form:  (priority number, data). |   |  Method resolution order: |      PriorityQueue |      Queue |      builtins.object |   |  Methods inherited from Queue: |   |  __init__(self, maxsize=0) |   |  empty(self) |      Return True if the queue is empty, False otherwise (not reliable!). |       |      This method is likely to be removed at some point.  Use qsize() == 0 |      as a direct substitute, but be aware that either approach risks a race |      condition where a queue can grow before the result of empty() or |      qsize() can be used. |       |      To create code that needs to wait for all queued tasks to be |      completed, the preferred technique is to use the join() method. |   |  full(self) |      Return True if the queue is full, False otherwise (not reliable!). |       |      This method is likely to be removed at some point.  Use qsize() >= n |      as a direct substitute, but be aware that either approach risks a race |      condition where a queue can shrink before the result of full() or |      qsize() can be used. |   |  get(self, block=True, timeout=None) |      Remove and return an item from the queue. |       |      If optional args 'block' is true and 'timeout' is None (the default), |      block if necessary until an item is available. If 'timeout' is |      a positive number, it blocks at most 'timeout' seconds and raises |      the Empty exception if no item was available within that time. |      Otherwise ('block' is false), return an item if one is immediately |      available, else raise the Empty exception ('timeout' is ignored |      in that case). |   |  get_nowait(self) |      Remove and return an item from the queue without blocking. |       |      Only get an item if one is immediately available. Otherwise |      raise the Empty exception. |   |  join(self) |      Blocks until all items in the Queue have been gotten and processed. |       |      The count of unfinished tasks goes up whenever an item is added to the |      queue. The count goes down whenever a consumer thread calls task_done() |      to indicate the item was retrieved and all work on it is complete. |       |      When the count of unfinished tasks drops to zero, join() unblocks. |   |  put(self, item, block=True, timeout=None) |      Put an item into the queue. |       |      If optional args 'block' is true and 'timeout' is None (the default), |      block if necessary until a free slot is available. If 'timeout' is |      a positive number, it blocks at most 'timeout' seconds and raises |      the Full exception if no free slot was available within that time. |      Otherwise ('block' is false), put an item on the queue if a free slot |      is immediately available, else raise the Full exception ('timeout' |      is ignored in that case). |   |  put_nowait(self, item) |      Put an item into the queue without blocking. |       |      Only enqueue the item if a free slot is immediately available. |      Otherwise raise the Full exception. |   |  qsize(self) |      Return the approximate size of the queue (not reliable!). |   |  task_done(self) |      Indicate that a formerly enqueued task is complete. |       |      Used by Queue consumer threads.  For each get() used to fetch a task, |      a subsequent call to task_done() tells the queue that the processing |      on the task is complete. |       |      If a join() is currently blocking, it will resume when all items |      have been processed (meaning that a task_done() call was received |      for every item that had been put() into the queue). |       |      Raises a ValueError if called more times than there were items |      placed in the queue. |   |  ---------------------------------------------------------------------- |  Data descriptors inherited from Queue: |   |  __dict__ |      dictionary for instance variables (if defined) |   |  __weakref__ |      list of weak references to the object (if defined) >>> >>> from heapq import heappush, heappop, heapify>>> items = [(3, strv), (4, strv), (5, strv), (1, strv), (2, strv)]>>> heapify(items)>>> while items:  print(heappop(items))  (1, 'Solve RC tasks')(2, 'Tax return')(3, 'Clear drains')(4, 'Feed cat')(5, 'Make tea')>>> >>> help('heapq')Help on module heapq: NAME    heapq - Heap queue algorithm (a.k.a. priority queue). DESCRIPTION    Heaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for    all k, counting elements from 0.  For the sake of comparison,    non-existing elements are considered to be infinite.  The interesting    property of a heap is that a[0] is always its smallest element.     Usage:     heap = []            
    heappush(heap, item) 
    item = heappop(heap) 
    item = heap[0]       
    heapify(x)           
    item = heapreplace(heap, item) 
                                   
     Our API differs from textbook heap algorithms as follows:     - We use 0-based indexing.  This makes the relationship between the      index for a node and the indexes for its children slightly less      obvious, but is more suitable since Python uses 0-based indexing.     - Our heappop() method returns the smallest item, not the largest.     These two make it possible to view the heap as a regular Python list    without surprises: heap[0] is the smallest item, and heap.sort()    maintains the heap invariant! FUNCTIONS    heapify(...)        Transform list into a heap, in-place, in O(len(heap)) time.     heappop(...)        Pop the smallest item off the heap, maintaining the heap invariant.     heappush(...)        Push item onto heap, maintaining the heap invariant.     heappushpop(...)        Push item on the heap, then pop and return the smallest item        from the heap. The combined action runs more efficiently than        heappush() followed by a separate call to heappop().     heapreplace(...)        Pop and return the current smallest value, and add the new item.         This is more efficient than heappop() followed by heappush(), and can be        more appropriate when using a fixed-size heap.  Note that the value        returned may be larger than item!  That constrains reasonable uses of        this routine unless written as part of a conditional replacement:             if item > heap[0]:                item = heapreplace(heap, item)     merge(*iterables)        Merge multiple sorted inputs into a single sorted output.         Similar to sorted(itertools.chain(*iterables)) but returns a generator,        does not pull the data into memory all at once, and assumes that each of        the input streams is already sorted (smallest to largest).         >>> list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))        [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]     nlargest(n, iterable, key=None)        Find the n largest elements in a dataset.         Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]     nsmallest(n, iterable, key=None)        Find the n smallest elements in a dataset.         Equivalent to:  sorted(iterable, key=key)[:n] DATA    __about__ = 'Heap queues[explanation by François Pinard]H... t...
    __all__ = ['heappush', 'heappop', 'heapify', 'heapreplace', 'merge', '... FILE    c:\python32\lib\heapq.py  >>> "
"Python 3.2 (r32:88445, Feb 20 2011, 21:30:00) [MSC v.1500 64 bit (AMD64)] on win32Type strv, strv or strv for more information.>>> import __future__>>> __future__.all_feature_names['nested_scopes', 'generators', 'division', 'absolute_import', 'with_statement', 'print_function', 'unicode_literals', 'barry_as_FLUFL']>>> Python 2.7.2 (default, Jun 12 2011, 14:24:46) [MSC v.1500 64 bit (AMD64)] on win32Type strv, strv or strv for more information.>>> import __future__>>> __future__.all_feature_names['nested_scopes', 'generators', 'division', 'absolute_import', 'with_statement', 'print_function', 'unicode_literals']>>> "
"
 def extended_synthetic_division(dividend, divisor):    '''Fast polynomial division by using Extended Synthetic Division. Also works with non-monic polynomials.'''    
     out = list(dividend) 
    normalizer = divisor[0]    for i in xrange(len(dividend)-(len(divisor)-1)):        out[i] /= normalizer 
                                 
        coef = out[i]        if coef != 0: 
            for j in xrange(1, len(divisor)): 
                                              
                out[i + j] += -divisor[j] * coef     
    
    
    separator = -(len(divisor)-1)    return out[:separator], out[separator:] 
 if __name__ == '__main__':    print strv    N = [1, -12, 0, -42]    D = [1, -3]    print strv % (N,D),    print strv % extended_synthetic_division(N, D) "
">>> def popcount(n): return bin(n).count(strv)... >>> [popcount(3**i) for i in range(30)][1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]>>> evil, odious, i = [], [], 0>>> while len(evil) < 30 or len(odious) < 30:...     p = popcount(i)...     if p % 2: odious.append(i)...     else: evil.append(i)...     i += 1... >>> evil[:30][0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]>>> odious[:30][1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]>>> "
">>> import bisect>>> _cin  = [.06, .11, .16, .21, .26, .31, .36, .41, .46, .51, .56, .61, .66, .71, .76, .81, .86, .91, .96, 1.01]>>> _cout = [.10, .18, .26, .32, .38, .44, .50, .54, .58, .62, .66, .70, .74, .78, .82, .86, .90, .94, .98, 1.00]>>> def pricerounder(pricein):	return _cout[ bisect.bisect_right(_cin, pricein) ]>>> import bisect>>> _cin  = [ 6, 11, 16, 21, 26, 31, 36, 41, 46, 51, 56, 61, 66, 71, 76, 81, 86, 91, 96, 101]>>> _cout = [10, 18, 26, 32, 38, 44, 50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 100]>>> def centsrounder(centsin):	return _cout[ bisect.bisect_right(_cin, centsin) ]def bisect_right(a, x, lo=0, hi=None):    strvReturn the index where to insert item x in list a, assuming a is sorted.
 
    The return value i is such that all e in a[:i] have e <= x, and all e in
    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will
    insert just after the rightmost x already there.
 
    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    strv     if lo < 0:        raise ValueError('lo must be non-negative')    if hi is None:        hi = len(a)    while lo < hi:        mid = (lo+hi)//2        if x < a[mid]: hi = mid        else: lo = mid+1    return lo"
"def list_powerset(lst):    
    result = [[]]    for x in lst:        
        
        
        
        
        
        result.extend([subset + [x] for subset in result])    return result 
def list_powerset2(lst):    return reduce(lambda result, x: result + [subset + [x] for subset in result],                  lst, [[]]) def powerset(s):    return frozenset(map(frozenset, list_powerset(list(s))))def powersetlist(s):    r = [[]]    for e in s:        print strv % (r,e)        r += [x+[e] for x in r]    return r s= [0,1,2,3]    print ""powersetlist(%r) =  %r"" % (s, powersetlist(s))def powersequence(val):    ''' Generate a 'powerset' for sequence types that are indexable by integers.
        Uses a binary count to enumerate the members and returns a list
 
        Examples:
            >>> powersequence('STR')   # String
            ['', 'S', 'T', 'ST', 'R', 'SR', 'TR', 'STR']
            >>> powersequence([0,1,2]) # List
            [[], [0], [1], [0, 1], [2], [0, 2], [1, 2], [0, 1, 2]]
            >>> powersequence((3,4,5)) # Tuple
            [(), (3,), (4,), (3, 4), (5,), (3, 5), (4, 5), (3, 4, 5)]
            >>> 
    '''    vtype = type(val); vlen = len(val); vrange = range(vlen)    return [ reduce( lambda x,y: x+y, (val[i:i+1] for i in vrange if 2**i & n), vtype())             for n in range(2**vlen) ] def powerset(s):    ''' Generate the powerset of s
 
        Example:
            >>> powerset(set([6,7,8]))
            set([frozenset([7]), frozenset([8, 6, 7]), frozenset([6]), frozenset([6, 7]), frozenset([]), frozenset([8]), frozenset([8, 7]), frozenset([8, 6])])
    '''    return set( frozenset(x) for x in powersequence(list(s)) ) def p(l):    if not l: return [[]]    return p(l[1:]) + [[l[0]] + x for x in p(l[1:])] >>> from pprint import pprint as pp>>> from itertools import chain, combinations>>> >>> def powerset(iterable):    strv    s = list(iterable)    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) >>> pp(set(powerset({1,2,3,4}))){(), (1,), (1, 2), (1, 2, 3), (1, 2, 3, 4), (1, 2, 4), (1, 3), (1, 3, 4), (1, 4), (2,), (2, 3), (2, 3, 4), (2, 4), (3,), (3, 4), (4,)}>>> "
"import copy class T:   def classname(self):       return self.__class__.__name__    def __init__(self):      self.myValue = strv    def speak(self):      print self.classname(), 'Hello', self.myValue    def clone(self):      return copy.copy(self) class S1(T):   def speak(self):      print self.classname(),strv, self.myValue class S2(T):   def speak(self):      print self.classname(),strv, self.myValue  print strva = S1()a.myValue = 'Green'a.speak() b = S2()b.myValue = 'Blue'b.speak() u = T()u.myValue = 'Purple'u.speak() print strvu = a.clone()u.speak()a.speak()print strvu.myValue = strvu.speak()a.speak() print strvu = bu.speak()b.speak()print strvu.myValue = strvu.speak()b.speak()import cPickle as pickle source = {'a': [1, 2.0, 3, 4+6j],         'b': ('string', u'Unicode string'),         'c': None} target = pickle.loads(pickle.dumps(source))target = source.__class__()  
if hasattr(source, 'items') and callable(source.items):    for key,value in source.items:        target[key] = valueelif hasattr(source, '__len__'):    target = source[:]else:  
    target = source"
"
 from itertools import izipfrom math import fabs def degree(poly):    while poly and poly[-1] == 0:        poly.pop()   
    return len(poly)-1 def poly_div(N, D):    dD = degree(D)    dN = degree(N)    if dD < 0: raise ZeroDivisionError    if dN >= dD:        q = [0] * dN        while dN >= dD:            d = [0]*(dN - dD) + D            mult = q[dN - dD] = N[-1] / float(d[-1])            d = [coeff*mult for coeff in d]            N = [fabs ( coeffN - coeffd ) for coeffN, coeffd in izip(N, d)]            dN = degree(N)        r = N    else:        q = [0]        r = N    return q, r if __name__ == '__main__':    print strv    N = [-42, 0, -12, 1]    D = [-3, 1, 0, 0]    print strv % (N,D),    print strv % poly_div(N, D)"
"class Point(object):    def __init__(self, x=0.0, y=0.0):        self.x = x        self.y = y    def __repr__(self):        return '<Point 0x%x x: %f y: %f>' % (id(self), self.x, self.y) class Circle(object):    def __init__(self, center=None, radius=1.0):        self.center = center or Point()        self.radius = radius    def __repr__(self):        return '<Circle 0x%x x: %f y: %f radius: %f>' % (            id(self), self.center.x, self.center.y, self.radius)class Point(object):    def __init__(self, x=0.0, y=0.0):        self.x = x        self.y = y    def __repr__(self):        return '<Point 0x%x x: %f y: %f>' % (id(self), self.x, self.y) class Circle(Point):    def __init__(self, x=0.0, y=0.0, radius=1.0):        Point.__init__(self, x, y)        self.radius = radius    def __repr__(self):        return '<Circle 0x%x x: %f y: %f radius: %f>' % (            id(self), self.x, self.y, self.radius)>>> from collections import namedtuple>>> class Point(namedtuple('Point', 'x y')):	def __new__( _cls, x=0, y=0 ):		return super().__new__(_cls, x, y)  >>> class Circle(namedtuple('Circle', 'x y r')):	def __new__( _cls, x=0, y=0, r=0 ):		return super().__new__(_cls, x, y, r)  >>> Point(), Point(x=1), Point(y=2), Point(3, 4)(Point(x=0, y=0), Point(x=1, y=0), Point(x=0, y=2), Point(x=3, y=4))>>> Circle(), Circle(r=2), Circle(1, 2, 3)(Circle(x=0, y=0, r=0), Circle(x=0, y=0, r=2), Circle(x=1, y=2, r=3))>>> p = Point(1.25, 3.87)>>> pPoint(x=1.25, y=3.87)>>> p.x = 10.81Traceback (most recent call last):  File strv, line 1, in <module>    p.x = 10.81AttributeError: can't set attribute
>>> >>> Point = namedtuple('Point', 'x y')>>> Circle = namedtuple('Circle', 'x y r')>>> Point(3, 4)Point(x=3, y=4)>>> Circle(x=1, y=2, r=3)Circle(x=1, y=2, r=3)>>> "
":- initialization(main).  faces([a,k,q,j,10,9,8,7,6,5,4,3,2]). face(F) :- faces(Fs), member(F,Fs).suit(S) :- member(S, ['♥','♦','♣','♠']).  best_hand(Cards,H) :-    straight_flush(Cards,C) -> H = straight-flush(C)  ; many_kind(Cards,F,4)    -> H = four-of-a-kind(F)  ; full_house(Cards,F1,F2) -> H = full-house(F1,F2)  ; flush(Cards,S)          -> H = flush(S)  ; straight(Cards,F)       -> H = straight(F)  ; many_kind(Cards,F,3)    -> H = three-of-a-kind(F)  ; two_pair(Cards,F1,F2)   -> H = two-pair(F1,F2)  ; many_kind(Cards,F,2)    -> H = one-pair(F)  ; many_kind(Cards,F,1)    -> H = high-card(F)  ;                            H = invalid  . straight_flush(Cards, c(F,S)) :- straight(Cards,F), flush(Cards,S). full_house(Cards,F1,F2) :-    many_kind(Cards,F1,3), many_kind(Cards,F2,2), F1 \= F2. flush(Cards,S) :- maplist(has_suit(S), Cards).has_suit(S, c(_,S)). straight(Cards,F) :-    select(c(F,_), Cards, Cs), pred_face(F,F1), straight(Cs,F1).straight([],_).pred_face(F,F1) :- F = 2 -> F1 = a ; faces(Fs), append(_, [F,F1|_], Fs). two_pair(Cards,F1,F2) :-    many_kind(Cards,F1,2), many_kind(Cards,F2,2), F1 \= F2. many_kind(Cards,F,N) :-    face(F), findall(_, member(c(F,_), Cards), Xs), length(Xs,N).  % utils/parserparse_line(Cards)  --> strv, parse_line(Cards).parse_line([C|Cs]) --> parse_card(C), parse_line(Cs).parse_line([])     --> []. parse_card(c(F,S)) --> parse_face(F), parse_suit(S). parse_suit(S,In,Out) :- suit(S), atom_codes(S,Xs), append(Xs,Out,In).parse_face(F,In,Out) :- face(F), face_codes(F,Xs), append(Xs,Out,In). face_codes(F,Xs) :- number(F) -> number_codes(F,Xs) ; atom_codes(F,Xs).  % teststest(strv).test(strv).test(strv).test(strv).test(strv).test(strv).test(strv).test(strv).test(strv). run_tests :-    test(Line), phrase(parse_line(Cards), Line), best_hand(Cards,H)  , write(Cards), write(''), write(H), nl  .main :- findall(_, run_tests, _), halt.from collections import namedtuple class Card(namedtuple('Card', 'face, suit')):    def __repr__(self):        return ''.join(self)  suit = '♥ ♦ ♣ ♠'.split()
faces   = '2 3 4 5 6 7 8 9 10 j q k a'lowaces = 'a 2 3 4 5 6 7 8 9 10 j q k'
face   = faces.split()lowace = lowaces.split()  def straightflush(hand):    f,fs = ( (lowace, lowaces) if any(card.face == '2' for card in hand)             else (face, faces) )    ordered = sorted(hand, key=lambda card: (f.index(card.face), card.suit))    first, rest = ordered[0], ordered[1:]    if ( all(card.suit == first.suit for card in rest) and         ' '.join(card.face for card in ordered) in fs ):        return 'straight-flush', ordered[-1].face    return False def fourofakind(hand):    allfaces = [f for f,s in hand]    allftypes = set(allfaces)    if len(allftypes) != 2:        return False    for f in allftypes:        if allfaces.count(f) == 4:            allftypes.remove(f)            return 'four-of-a-kind', [f, allftypes.pop()]    else:        return False def fullhouse(hand):    allfaces = [f for f,s in hand]    allftypes = set(allfaces)    if len(allftypes) != 2:        return False    for f in allftypes:        if allfaces.count(f) == 3:            allftypes.remove(f)            return 'full-house', [f, allftypes.pop()]    else:        return False def flush(hand):    allstypes = {s for f, s in hand}    if len(allstypes) == 1:        allfaces = [f for f,s in hand]        return 'flush', sorted(allfaces,                               key=lambda f: face.index(f),                               reverse=True)    return False def straight(hand):    f,fs = ( (lowace, lowaces) if any(card.face == '2' for card in hand)             else (face, faces) )    ordered = sorted(hand, key=lambda card: (f.index(card.face), card.suit))    first, rest = ordered[0], ordered[1:]    if ' '.join(card.face for card in ordered) in fs:        return 'straight', ordered[-1].face    return False def threeofakind(hand):    allfaces = [f for f,s in hand]    allftypes = set(allfaces)    if len(allftypes) <= 2:        return False    for f in allftypes:        if allfaces.count(f) == 3:            allftypes.remove(f)            return ('three-of-a-kind', [f] +                     sorted(allftypes,                            key=lambda f: face.index(f),                            reverse=True))    else:        return False def twopair(hand):    allfaces = [f for f,s in hand]    allftypes = set(allfaces)    pairs = [f for f in allftypes if allfaces.count(f) == 2]    if len(pairs) != 2:        return False    p0, p1 = pairs    other = [(allftypes - set(pairs)).pop()]    return 'two-pair', pairs + other if face.index(p0) > face.index(p1) else pairs[::-1] + other def onepair(hand):    allfaces = [f for f,s in hand]    allftypes = set(allfaces)    pairs = [f for f in allftypes if allfaces.count(f) == 2]    if len(pairs) != 1:        return False    allftypes.remove(pairs[0])    return 'one-pair', pairs + sorted(allftypes,                                      key=lambda f: face.index(f),                                      reverse=True) def highcard(hand):    allfaces = [f for f,s in hand]    return 'high-card', sorted(allfaces,                               key=lambda f: face.index(f),                               reverse=True) handrankorder =  (straightflush, fourofakind, fullhouse,                  flush, straight, threeofakind,                  twopair, onepair, highcard) def rank(cards):    hand = handy(cards)    for ranker in handrankorder:        rank = ranker(hand)        if rank:            break    assert rank, strv % cards    return rank def handy(cards='2♥ 2♦ 2♣ k♣ q♦'):    hand = []    for card in cards.split():        f, s = card[:-1], card[-1]        assert f in face, strv % f        assert s in suit, strv % s        hand.append(Card(f, s))    assert len(hand) == 5, strv % len(hand)    assert len(set(hand)) == 5, strv % cards    return hand  if __name__ == '__main__':    hands = [strv,     strv,     strv,     strv,     strv,     strv,     strv] + [     strv,     strv,     ]    print(strv % (strv, strv, strv))    for cards in hands:        r = rank(cards)        print(strv % (cards, r[0], r[1]))"
" 
 a = strv 
 b = [] 
 class Foo(object):     pass c = Foo() 
 class Bar(object):     def __init__(self, initializer = None)         
         if initializer is not None:            self.value = initializer d = Bar(10) print d.value 
 if a is b: pass 
 if id(a) == id(b): pass 
 def a(fmt, *args):     if fmt is None:         fmt = strv      print fmt % (args) 
 b.append(a) 
 del(a) 
 b[0](strv)  
              
"
">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]>>> coeffs = numpy.polyfit(x,y,deg=2)>>> coeffsarray([ 3.,  2.,  1.])>>> yf = numpy.polyval(numpy.poly1d(coeffs), x)>>> yfarray([   1.,    6.,   17.,   34.,   57.,   86.,  121.,  162.,  209., 262.,  321.])>>> '%.1g' % max(y-yf)'1e-013'>>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]>>> p = numpy.poly1d(numpy.polyfit(x, y, deg=2), variable='N')>>> print p       21.085 N + 10.36 N - 0.6164"
">>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0] >>> import pylab>>> pylab.plot(x, y, 'bo')>>> pylab.savefig('qsort-range-10-9.png')  from visual import *from visual.graph import * plot1 = gdisplay( title='VPython Plot-Demo',                   xtitle='x',                  ytitle='y    (click and drag mouse to see coordinates)',                  foreground=color.black,                  background=color.white,                   x=0, y=0,                  width=400, height=400,                  xmin=0, xmax=10,                   ymin=0, ymax=200 ) f1 = gdots(color=color.red)                 
 f1.plot(pos= (0,   2.7), color=color.blue ) 
f1.plot(pos=[(1,   2.8),                    
             (2,  31.4),             (3,  38.1),              (4,  58.0),             (5,  76.2),             (6, 100.5),             (7, 130.0),             (8, 149.3),             (9, 180.0) ]        )label(display=plot1.display, text=strv,      pos=(6,100.5), xoffset=30,yoffset=-20 ) "
"import random class Card(object):    suits = (strv,strv,strv,strv)    pips = (strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv)     def __init__(self, pip,suit):        self.pip=pip        self.suit=suit     def __str__(self):        return strv%(self.pip,self.suit) class Deck(object):    def __init__(self):        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]     def __str__(self):        return strv%strv.join( (str(card) for card in self.deck))     def shuffle(self):        random.shuffle(self.deck)     def deal(self):        self.shuffle()  
        return self.deck.pop(0)from pokerhand import Card, suit, facefrom itertools import productfrom random import randrange class Deck():    def __init__(self):        self.__deck = [Card(f, s) for f,s in product(face, suit)]     def __repr__(self):        return 'Deck of ' + ' '.join(repr(card) for card in self.__deck)     def shuffle(self):        pass     def deal(self):        return self.__deck.pop(randrange(len(self.__deck))) if __name__ == '__main__':    deck = Deck()    print('40 cards from a deck:')    for i in range(5):        for j in range(8):            print(deck.deal(), end=' ')        print()    print('The remaining cards are a', deck)"
"from string import ascii_uppercasefrom itertools import productfrom re import findall def uniq(seq):    seen = {}    return [seen.setdefault(x, x) for x in seq if x not in seen] def partition(seq, n):    return [seq[i : i + n] for i in xrange(0, len(seq), n)]  strvdef playfair(key, from_ = 'J', to = None):    if to is None:        to = 'I' if from_ == 'J' else ''     def canonicalize(s):        return filter(str.isupper, s.upper()).replace(from_, to)     
    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)     
    enc = {}     
    for row in m:        for i, j in product(xrange(5), repeat=2):            if i != j:                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]     
    for c in zip(*m):        for i, j in product(xrange(5), repeat=2):            if i != j:                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]     
    for i1, j1, i2, j2 in product(xrange(5), repeat=4):        if i1 != i2 and j1 != j2:            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]     
    dec = dict((v, k) for k, v in enc.iteritems())     def sub_enc(txt):        lst = findall(r""(.)(?:(?!)(.))?"", canonicalize(txt))        return strv.join(enc[a + (b if b else 'X')] for a, b in lst)     def sub_dec(encoded):        return strv.join(dec[p] for p in partition(canonicalize(encoded), 2))     return sub_enc, sub_dec  (encode, decode) = playfair(strv)orig = strvprint strv, origenc = encode(orig)print strv, encprint strv, decode(enc)"
import timefrom pygame import mixer mixer.init(frequency=16000) #set frequency for wav files1 = mixer.Sound('test.wav')s2 = mixer.Sound('test2.wav') #individuals1.play(-1)         #loops indefinitelytime.sleep(0.5) #simultaneouslys2.play()          #play once time.sleep(2)s2.play(2)         #optional parameter loops three times time.sleep(10) #set volume downs1.set_volume(0.1)time.sleep(5) #set volume ups1.set_volume(1)time.sleep(5) s1.stop()s2.stop()mixer.quit()import timefrom pygame import mixerfrom pygame.mixer import music mixer.init()music.load('test.mp3') music.play()time.sleep(10) music.stop()mixer.quit()
"import mathimport colorsysfrom PIL import Image def plasma (w, h):	out = Image.new(strv, (w, h))	pix = out.load()	for x in range (w):		for y in range(h):			hue = 4.0 + math.sin(x / 19.0) + math.sin(y / 9.0) \				+ math.sin((x + y) / 25.0) + math.sin(math.sqrt(x**2.0 + y**2.0) / 8.0)			hsv = colorsys.hsv_to_rgb(hue/8.0, 1, 1)			pix[x, y] = tuple([int(round(c * 255.0)) for c in hsv])	return out if __name__==strv:	im = plasma(400, 400)	im.show()"
"#!/usr/bin/python3 '''
See: http://en.wikipedia.org/wiki/Pig_(dice)
 
This program scores, throws the dice, and plays for an N player game of Pig.
 
''' from random import randintfrom collections import namedtupleimport randomfrom pprint import pprint as ppfrom collections import Counter  playercount = 2maxscore = 100maxgames = 100000  Game = namedtuple('Game', 'players, maxscore, rounds')Round = namedtuple('Round', 'who, start, scores, safe')  class Player():    def __init__(self, player_index):        self.player_index = player_index     def __repr__(self):        return '%s(%i)' % (self.__class__.__name__, self.player_index)     def __call__(self, safescore, scores, game):        'Returns boolean True to roll again'        pass class RandPlay(Player):    def __call__(self, safe, scores, game):        'Returns random boolean choice of whether to roll again'        return bool(random.randint(0, 1)) class RollTo20(Player):    def __call__(self, safe, scores, game):        'Roll again if this rounds score < 20'        return (((sum(scores) + safe[self.player_index]) < maxscore)    
                and(sum(scores) < 20))                                  
 class Desparat(Player):    def __call__(self, safe, scores, game):        'Roll again if this rounds score < 20 or someone is within 20 of winning'        return (((sum(scores) + safe[self.player_index]) < maxscore)    
                and( (sum(scores) < 20)                                 
                     or max(safe) >= (maxscore - 20)))                  
  def game__str__(self):    'Pretty printer for Game class'    return (""Game(players=%r, maxscore=%i,  rounds=[    %s  ])""            % (self.players, self.maxscore,               ',    '.join(repr(round) for round in self.rounds)))Game.__str__ = game__str__  def winningorder(players, safescores):    'Return (players in winning order, their scores)'    return tuple(zip(*sorted(zip(players, safescores),                            key=lambda x: x[1], reverse=True))) def playpig(game):    '''
    Plays the game of pig returning the players in winning order
    and their scores whilst updating argument game with the details of play.
    '''    players, maxscore, rounds = game    playercount = len(players)    safescore = [0] * playercount   
    player = 0                      
    scores=[]                       
     while max(safescore) < maxscore:        startscore = safescore[player]        rolling = players[player](safescore, scores, game)        if rolling:            rolled = randint(1, 6)            scores.append(rolled)            if rolled == 1:                
                round = Round(who=players[player],                              start=startscore,                              scores=scores,                              safe=safescore[player])                rounds.append(round)                scores, player = [], (player + 1) % playercount        else:            
            safescore[player] += sum(scores)            round = Round(who=players[player],                          start=startscore,                          scores=scores,                          safe=safescore[player])            rounds.append(round)            if safescore[player] >= maxscore:                break            scores, player = [], (player + 1) % playercount     
    return winningorder(players, safescore) if __name__ == '__main__':    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),                maxscore=20,                rounds=[])    print('ONE GAME')    print('Winning order: %r; Respective scores: %r' % playpig(game))    print(game)    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),                maxscore=maxscore,                rounds=[])    algos = (RollTo20, RandPlay, Desparat)    print('MULTIPLE STATISTICS using %r  for %i GAMES'          % (', '.join(p.__name__ for p in algos), maxgames,))    winners = Counter(repr(playpig(game._replace(players=tuple(random.choice(algos)(i)                                                               for i in range(playercount)),                                                 rounds=[]))[0])                      for i in range(maxgames))    print('  Players(position) winning on left; occurrences on right:    %s'          % ',    '.join(str(w) for w in winners.most_common()))"
"#!/usr/bin/python3 '''
See: http://en.wikipedia.org/wiki/Pig_(dice)
 
This program scores and throws the dice for a two player game of Pig
 
''' from random import randint playercount = 2maxscore = 100safescore = [0] * playercountplayer = 0score=0 while max(safescore) < maxscore:    rolling = input(strv                    % (player, safescore[player], score)).strip().lower() in {'yes', 'y', ''}    if rolling:        rolled = randint(1, 6)        print('  Rolled %i' % rolled)        if rolled == 1:            print('  Bust! you lose %i but still keep your previous %i'                  % (score, safescore[player]))            score, player = 0, (player + 1) % playercount        else:            score += rolled    else:        safescore[player] += score        if safescore[player] >= maxscore:            break        print('  Sticking with %i' % safescore[player])        score, player = 0, (player + 1) % playercount print('Player %i wins with a score of %i' %(player, safescore[player]))"
" #Python task for Pinstripe/Display #Tested for Python2.7 by Benjamin Curutchet #Import PIL librariesfrom PIL import Imagefrom PIL import ImageColorfrom PIL import ImageDraw #Create the picture (size parameter 1660x1005 like the example)x_size = 1650y_size = 1000im = Image.new('RGB',(x_size, y_size)) #Create a full black picturedraw = ImageDraw.Draw(im) #RGB code for the White ColorWhite  = (255,255,255)  #First loop in order to create four distinct linesy_delimiter_list = []for y_delimiter in range(1,y_size,y_size/4):	y_delimiter_list.append(y_delimiter)  #Four different loops in order to draw columns in white depending on the#number of the line for x in range(1,x_size,2):	for y in range(1,y_delimiter_list[1],1):		draw.point((x,y),White) for x in range(1,x_size-1,4):	for y in range(y_delimiter_list[1],y_delimiter_list[2],1):		draw.point((x,y),White)		draw.point((x+1,y),White) for x in range(1,x_size-2,6):	for y in range(y_delimiter_list[2],y_delimiter_list[3],1):		draw.point((x,y),White)		draw.point((x+1,y),White)		draw.point((x+2,y),White) for x in range(1,x_size-3,8):	for y in range(y_delimiter_list[3],y_size,1):		draw.point((x,y),White)		draw.point((x+1,y),White)		draw.point((x+2,y),White)		draw.point((x+3,y),White)   #Save the picture under a name as a jpg file.print strv		im.save('PictureResult.jpg')  "
">>> phrase = strv>>> phrase[::-1]					  
'lasrever esarhp edoc attesor'>>> ' '.join(word[::-1] for word in phrase.split())	  
'attesor edoc esarhp lasrever'>>> ' '.join(word for word in phrase.split()[::-1])	  
'reversal phrase code rosetta'>>> "
"def calcPi():    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3    while True:        if 4*q+r-t < n*t:            yield n            nr = 10*(r-n*t)            n  = ((10*(3*q+r))//t)-10*n            q  *= 10            r  = nr        else:            nr = (2*q+r)*l            nn = (q*(7*k)+2+(r*l))//(t*l)            q  *= k            t  *= l            l  += 2            k += 1            n  = nn            r  = nr import syspi_digits = calcPi()i = 0for d in pi_digits:    sys.stdout.write(str(d))    i += 1    if i == 40: print(strv); i = 0"
">>> import random>>> random.choice(['foo', 'bar', 'baz'])'baz'"
"from itertools import permutationsimport math  def derangements(n):    'All deranged permutations of the integers 0..n-1 inclusive'    return ( perm for perm in permutations(range(n))             if all(indx != p for indx, p in enumerate(perm)) ) def subfact(n):    if n == 2 or n == 0:        return 1    elif n == 1:        return 0    elif  1 <= n <=18:        return round(math.factorial(n) / math.e)    elif n.imag == 0 and n.real == int(n.real) and n > 0:        return (n-1) * ( subfact(n - 1) + subfact(n - 2) )    else:        raise ValueError() def _iterlen(iter):    'length of an iterator without taking much memory'    l = 0    for x in iter:        l += 1    return l if __name__ == '__main__':    n = 4    print(strv % (tuple(range(n)),))    for d in derangements(n):        print(strv % (d,))     print(""Table of n vs counted vs calculated derangements"")    for n in range(10):        print(strv %              (n, _iterlen(derangements(n)), subfact(n)))     n = 20    print(""!%i = %i"" % (n, subfact(n)))"
"from itertools import product 
for x in product('ACRK', repeat=5):    w = ''.join(x)    print w    if w.lower() == 'crack': break"
">>> def popcount(n): return bin(n).count(strv) >>> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}>>> p, i = [], 0>>> while len(p) < 25:        if popcount(i) in primes: p.append(i)        i += 1  >>> p[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33, 34, 35, 36]>>> p, i = [], 888888877>>> while i <= 888888888:        if popcount(i) in primes: p.append(i)        i += 1  >>> p[888888877, 888888878, 888888880, 888888883, 888888885, 888888886]>>> "
"from math import factorial as factfrom random import randrangefrom textwrap import wrap def identity_perm(n):     return list(range(n)) def unranker1(n, r, pi):    while n > 0:        n1, (rdivn, rmodn) = n-1, divmod(r, n)        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]        n = n1        r = rdivn    return pi def init_pi1(n, pi):     pi1 = [-1] * n    for i in range(n):         pi1[pi[i]] = i    return pi1 def ranker1(n, pi, pi1):    if n == 1:         return 0    n1 = n-1    s = pi[n1]    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]    pi1[s], pi1[n1] = pi1[n1], pi1[s]    return s + n * ranker1(n1, pi, pi1) def unranker2(n, r, pi):    while n > 0:        n1 = n-1        s, rmodf = divmod(r, fact(n1))        pi[n1], pi[s] = pi[s], pi[n1]        n = n1        r = rmodf    return pi def ranker2(n, pi, pi1):    if n == 1:         return 0    n1 = n-1    s = pi[n1]    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]    pi1[s], pi1[n1] = pi1[n1], pi1[s]    return s * fact(n1) + ranker2(n1, pi, pi1) def get_random_ranks(permsize, samplesize):        perms = fact(permsize)    ranks = set()    while len(ranks) < samplesize:        ranks |= set( randrange(perms)                       for r in range(samplesize - len(ranks)) )    return ranks     def test1(comment, unranker, ranker):        n, samplesize, n2 = 3, 4, 12    print(comment)    perms = []    for r in range(fact(n)):        pi = identity_perm(n)        perm = unranker(n, r, pi)        perms.append((r, perm))    for r, pi in perms:        pi1 = init_pi1(n, pi)        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))    print('  %i random individual samples of %i items:' % (samplesize, n2))    for r in get_random_ranks(n2, samplesize):        pi = identity_perm(n2)        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))    print('') def test2(comment, unranker):        samplesize, n2 = 4, 144    print(comment)    print('  %i random individual samples of %i items:' % (samplesize, n2))    for r in get_random_ranks(n2, samplesize):        pi = identity_perm(n2)        print('    ' + '      '.join(wrap(repr(unranker(n2, r, pi)))))    print('') if __name__ == '__main__':    test1('First ordering:', unranker1, ranker1)    test1('Second ordering:', unranker2, ranker2)    test2('First ordering, large number of perms:', unranker1)def ranker1(n, pi, pi1):    if n == 1:         return 0    n1 = n-1    s = pi[n1]    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]    pi1[s], pi1[n1] = pi1[n1], pi1[s]    return s + n * ranker1(n1, pi, pi1) def ranker2(n, pi, pi1):    result = 0    for i in range(n-1, 0, -1):        s = pi[i]        pi[i], pi[pi1[i]] = pi[pi1[i]], pi[i]        pi1[s], pi1[i] = pi1[i], pi1[s]        result += s * fact(i)    return result"
"from itertools import combinations as comb def statistic(ab, a):    sumab, suma = sum(ab), sum(a)    return ( suma / len(a) -             (sumab -suma) / (len(ab) - len(a)) ) def permutationTest(a, b):    ab = a + b    Tobs = statistic(ab, a)    under = 0    for count, perm in enumerate(comb(ab, len(a)), 1):        if statistic(ab, perm) <= Tobs:            under += 1    return under * 100. / count treatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]controlGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]under = permutationTest(treatmentGroup, controlGroup)print(strv % (under, 100. - under))from itertools import combinations as comb def permutationTest(a, b):    ab = a + b    Tobs = sum(a)    under = 0    for count, perm in enumerate(comb(ab, len(a)), 1):        if sum(perm) <= Tobs:            under += 1    return under * 100. / count treatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]controlGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]under = permutationTest(treatmentGroup, controlGroup)print(strv % (under, 100. - under))"
"def perlin_noise(x, y, z):    X = int(x) & 255                  
    Y = int(y) & 255                  
    Z = int(z) & 255    x -= int(x)                                
    y -= int(y)                                
    z -= int(z)    u = fade(x)                                
    v = fade(y)                                
    w = fade(z)    A = p[X  ]+Y; AA = p[A]+Z; AB = p[A+1]+Z      
    B = p[X+1]+Y; BA = p[B]+Z; BB = p[B+1]+Z      
     return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  
                                   grad(p[BA  ], x-1, y  , z   )), 
                           lerp(u, grad(p[AB  ], x  , y-1, z   ),  
                                   grad(p[BB  ], x-1, y-1, z   ))),
                   lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  
                                   grad(p[BA+1], x-1, y  , z-1 )), 
                           lerp(u, grad(p[AB+1], x  , y-1, z-1 ),                                   grad(p[BB+1], x-1, y-1, z-1 )))) def fade(t):     return t ** 3 * (t * (t * 6 - 15) + 10) def lerp(t, a, b):    return a + t * (b - a) def grad(hash, x, y, z):    h = hash & 15                      
    u = x if h<8 else y                
    v = y if h<4 else (x if h in (12, 14) else z)    return (u if (h&1) == 0 else -u) + (v if (h&2) == 0 else -v) p = [None] * 512permutation = [151,160,137,91,90,15,   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]for i in range(256):    p[256+i] = p[i] = permutation[i] if __name__ == '__main__':    print(strv % perlin_noise(3.14, 42, 7))"
" import doctestimport random  def flatten(lst):    strv
    >>> flatten([[3,2],[1,2]])
    [3, 2, 1, 2]
    strv    return [i for sublst in lst for i in sublst] def magic_shuffle(deck):    strv
    >>> magic_shuffle([1,2,3,4])
    [1, 3, 2, 4]
    strv    half = len(deck) // 2     return flatten(zip(deck[:half], deck[half:])) def after_how_many_is_equal(shuffle_type,start,end):    strv
    >>> after_how_many_is_equal(magic_shuffle,[1,2,3,4],[1,2,3,4])
    2
    strv     start = shuffle_type(start)    counter = 1    while start != end:        start = shuffle_type(start)        counter += 1    return counter def main():    doctest.testmod()     print(strv)    for length in (8, 24, 52, 100, 1020, 1024, 10000):        deck = list(range(length))        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)        print(strv.format(length,shuffles_needed))  if __name__ == strv:    main()  def mul_ord2(n):	
	
	if n == 2: return 1 	n,t,o = n-1,2,1	while t != 1:		t,o = (t*2)%n,o+1	return o def shuffles(n):	a,c = list(range(n)), 0	b = a 	while True:		
		
		a = a[0:n:2] + a[1:n:2]		c += 1		if b == a: break	return c for n in range(2, 10000, 2):	#print(n, mul_ord2(n))	print(n, shuffles(n))"
"from operator import itemgetter DEBUG = False 
 def spermutations(n):    strv    sign = 1    p = [[i, 0 if i == 0 else -1] 
         for i in range(n)]     if DEBUG: print ' #', p    yield tuple(pp[0] for pp in p), sign     while any(pp[1] for pp in p): 
        i1, (n1, d1) = max(((i, pp) for i, pp in enumerate(p) if pp[1]),                           key=itemgetter(1))        sign *= -1        if d1 == -1:            
            i2 = i1 - 1            p[i1], p[i2] = p[i2], p[i1]            
            
            
            if i2 == 0 or p[i2 - 1][0] > n1:                
                p[i2][1] = 0        elif d1 == 1:            
            i2 = i1 + 1            p[i1], p[i2] = p[i2], p[i1]            
            
            
            if i2 == n - 1 or p[i2 + 1][0] > n1:                
                p[i2][1] = 0        if DEBUG: print ' #', p        yield tuple(pp[0] for pp in p), sign         for i3, pp in enumerate(p):            n3, d3 = pp            if n3 > n1:                pp[1] = 1 if i3 < i2 else -1                if DEBUG: print ' # Set Moving'  if __name__ == '__main__':    from itertools import permutations     for n in (3, 4):        print 'Permutations and sign of %i items' % n        sp = set()        for i in spermutations(n):            sp.add(i[0])            print('Perm: %r Sign: %2i' % i)            #if DEBUG: raw_input('?')        
        p = set(permutations(range(n)))        assert sp == p, 'Two methods of generating permutations do not agree'def s_permutations(seq):    def s_perm(seq):        if not seq:            return [[]]        else:            new_items = []            for i, item in enumerate(s_perm(seq[:-1])):                if i % 2:                    
                    new_items += [item[:i] + seq[-1:] + item[i:]                                  for i in range(len(item) + 1)]                else:                    
                    new_items += [item[:i] + seq[-1:] + item[i:]                                  for i in range(len(item), -1, -1)]            return new_items     return [(tuple(item), -1 if i % 2 else 1)            for i, item in enumerate(s_perm(seq))]def s_permutations(seq):    items = [[]]    for j in seq:        new_items = []        for i, item in enumerate(items):            if i % 2:                
                new_items += [item[:i] + [j] + item[i:]                              for i in range(len(item) + 1)]            else:                
                new_items += [item[:i] + [j] + item[i:]                              for i in range(len(item), -1, -1)]        items = new_items     return [(tuple(item), -1 if i % 2 else 1)            for i, item in enumerate(items)]"
"def perf(n):    sum = 0    for i in xrange(1, n):        if n % i == 0:            sum += i    return sum == nperf = lambda n: n == sum(i for i in xrange(1, n) if n % i == 0)"
"from random import randomimport stringfrom pprint import pprint as pp M, N, t = 15, 15, 100 cell2char = ' #' + string.ascii_lettersNOT_VISITED = 1     
 class PercolatedException(Exception): pass def newgrid(p):    return [[int(random() < p) for m in range(M)] for n in range(N)] 
 def pgrid(cell, percolated=None):    for n in range(N):        print( '%i)  ' % (n % 10)                + ' '.join(cell2char[cell[n][m]] for m in range(M)))    if percolated:         where = percolated.args[0][0]        print('!)  ' + '  ' * where + cell2char[cell[n][where]]) def check_from_top(cell):    n, walk_index = 0, 1    try:        for m in range(M):            if cell[n][m] == NOT_VISITED:                walk_index += 1                walk_maze(m, n, cell, walk_index)    except PercolatedException as ex:        return ex    return None  def walk_maze(m, n, cell, indx):    
    cell[n][m] = indx    
    if n < N - 1 and cell[n+1][m] == NOT_VISITED:        walk_maze(m, n+1, cell, indx)    
    elif n == N - 1:        raise PercolatedException((m, indx))    
    if m and cell[n][m - 1] == NOT_VISITED:        walk_maze(m-1, n, cell, indx)    
    if m < M - 1 and cell[n][m + 1] == NOT_VISITED:        walk_maze(m+1, n, cell, indx)    
    if n and cell[n-1][m] == NOT_VISITED:        walk_maze(m, n-1, cell, indx) if __name__ == '__main__':    sample_printed = False    pcount = {}    for p10 in range(11):        p = p10 / 10.0        pcount[p] = 0        for tries in range(t):            cell = newgrid(p)            percolated = check_from_top(cell)            if percolated:                pcount[p] += 1                if not sample_printed:                    print('Sample percolating %i x %i, p = %5.2f grid' % (M, N, p))                    pgrid(cell, percolated)                    sample_printed = True    print(' p: Fraction of %i tries that percolate through' % t )     pp({p:c/float(t) for p, c in pcount.items()})"
"import itertoolsfor values in itertools.permutations([1,2,3]):    print (values)def perm1(n):    a = list(range(n))    def sub(i):        if i == n - 1:            yield tuple(a)        else:            for k in range(i, n):                a[i], a[k] = a[k], a[i]                yield from sub(i + 1)                a[i], a[k] = a[k], a[i]    yield from sub(0) def perm2(n):    a = list(range(n))    def sub(i):        if i == n - 1:            yield tuple(a)        else:            for k in range(i, n):                a[i], a[k] = a[k], a[i]                yield from sub(i + 1)            x = a[i]            for k in range(i + 1, n):                a[k - 1] = a[k]            a[n - 1] = x    yield from sub(0)for u in perm1(3): print(u)(0, 1, 2)(0, 2, 1)(1, 0, 2)(1, 2, 0)(2, 1, 0)(2, 0, 1) for u in perm2(3): print(u)(0, 1, 2)(0, 2, 1)(1, 0, 2)(1, 2, 0)(2, 0, 1)(2, 1, 0)def nextperm(a):    n = len(a)    i = n - 1    while i > 0 and a[i - 1] > a[i]:        i -= 1    j = i    k = n - 1    while j < k:        a[j], a[k] = a[k], a[j]        j += 1        k -= 1    if i == 0:        return False    else:        j = i        while a[j] < a[i - 1]:            j += 1        a[i - 1], a[j] = a[j], a[i - 1]        return True def perm3(n):    if type(n) is int:        if n < 1:            return []        a = list(range(n))    else:        a = sorted(n)    u = [tuple(a)]    while nextperm(a):        u.append(tuple(a))    return u for p in perm3(3): print(p)(0, 1, 2)(0, 2, 1)(1, 0, 2)(1, 2, 0)(2, 0, 1)(2, 1, 0)"
"from __future__ import divisionfrom random import randomfrom math import fsum n, p, t = 100, 0.5, 500 def newv(n, p):     return [int(random() < p) for i in range(n)] def runs(v):     return sum((a & ~b) for a, b in zip(v, v[1:] + [0])) def mean_run_density(n, p):    return runs(newv(n, p)) / n for p10 in range(1, 10, 2):    p = p10 / 10    limit = p * (1 - p)    print('')    for n2 in range(10, 16, 2):        n = 2**n2        sim = fsum(mean_run_density(n, p) for i in range(t)) / t        print('t=%3i p=%4.2f n=%5i p(1-p)=%5.3f sim=%5.3f delta=%3.1f%%'              % (t, p, n, limit, sim, abs(sim - limit) / limit * 100 if limit else sim * 100))"
"from __future__ import divisionfrom random import randomimport stringfrom math import fsum n_range, p, t = (2**n2 for n2 in range(4, 14, 2)), 0.5, 5N = M = 15 NOT_CLUSTERED = 1   
cell2char = ' #' + string.ascii_letters def newgrid(n, p):    return [[int(random() < p) for x in range(n)] for y in range(n)] def pgrid(cell):    for n in range(N):        print( '%i)  ' % (n % 10)                + ' '.join(cell2char[cell[n][m]] for m in range(M)))  def cluster_density(n, p):    cc = clustercount(newgrid(n, p))    return cc / n / n def clustercount(cell):    walk_index = 1    for n in range(N):        for m in range(M):            if cell[n][m] == NOT_CLUSTERED:                walk_index += 1                walk_maze(m, n, cell, walk_index)    return walk_index - 1  def walk_maze(m, n, cell, indx):    
    cell[n][m] = indx    
    if n < N - 1 and cell[n+1][m] == NOT_CLUSTERED:        walk_maze(m, n+1, cell, indx)    
    if m < M - 1 and cell[n][m + 1] == NOT_CLUSTERED:        walk_maze(m+1, n, cell, indx)    
    if m and cell[n][m - 1] == NOT_CLUSTERED:        walk_maze(m-1, n, cell, indx)    
    if n and cell[n-1][m] == NOT_CLUSTERED:        walk_maze(m, n-1, cell, indx)  if __name__ == '__main__':    cell = newgrid(n=N, p=0.5)    print('Found %i clusters in this %i by %i grid'           % (clustercount(cell), N, N))    pgrid(cell)    print('')     for n in n_range:        N = M = n        sim = fsum(cluster_density(n, p) for i in range(t)) / t        print('t=%3i p=%4.2f n=%5i sim=%7.5f'              % (t, p, n, sim))"
"from collections import namedtuplefrom random import randomfrom pprint import pprint as pp Grid = namedtuple('Grid', 'cell, hwall, vwall') M, N, t = 10, 10, 100 class PercolatedException(Exception): pass HVF = [(' .', ' _'), (':', '|'), (' ', '#')]  
 def newgrid(p):    hwall = [[int(random() < p) for m in range(M)]              for n in range(N+1)]    vwall = [[(1 if m in (0, M) else int(random() < p)) for m in range(M+1)]              for n in range(N)]    cell = [[0 for m in range(M)]              for n in range(N)]    return Grid(cell, hwall, vwall) def pgrid(grid, percolated=None):    cell, hwall, vwall = grid    h, v, f = HVF    for n in range(N):        print('    ' + ''.join(h[hwall[n][m]] for m in range(M)))        print('%i)  ' % (n % 10) + ''.join(v[vwall[n][m]] + f[cell[n][m] if m < M else 0]                                          for m in range(M+1))[:-1])    n = N    print('    ' + ''.join(h[hwall[n][m]] for m in range(M)))    if percolated:         where = percolated.args[0][0]        print('!)  ' + '  ' * where + ' ' + f[1]) def pour_on_top(grid):    cell, hwall, vwall = grid    n = 0    try:        for m in range(M):            if not hwall[n][m]:                flood_fill(m, n, cell, hwall, vwall)    except PercolatedException as ex:        return ex    return None  def flood_fill(m, n, cell, hwall, vwall):    
    cell[n][m] = 1    
    if n < N - 1 and not hwall[n + 1][m] and not cell[n+1][m]:        flood_fill(m, n+1, cell, hwall, vwall)    
    elif n == N - 1 and not hwall[n + 1][m]:        raise PercolatedException((m, n+1))    
    if m and not vwall[n][m] and not cell[n][m - 1]:        flood_fill(m-1, n, cell, hwall, vwall)    
    if m < M - 1 and not vwall[n][m + 1] and not cell[n][m + 1]:        flood_fill(m+1, n, cell, hwall, vwall)    
    if n and not hwall[n][m] and not cell[n-1][m]:        flood_fill(m, n-1, cell, hwall, vwall) if __name__ == '__main__':    sample_printed = False    pcount = {}    for p10 in range(11):        p = (10 - p10) / 10.0    
        pcount[p] = 0        for tries in range(t):            grid = newgrid(p)            percolated = pour_on_top(grid)            if percolated:                pcount[p] += 1                if not sample_printed:                    print('Sample percolating %i x %i grid' % (M, N))                    pgrid(grid, percolated)                    sample_printed = True    print(' p: Fraction of %i tries that percolate through' % t )     pp({p:c/float(t) for p, c in pcount.items()})"
"from itertools import izipimport Image i1 = Image.open(strv)i2 = Image.open(strv)assert i1.mode == i2.mode, strvassert i1.size == i2.size, strv pairs = izip(i1.getdata(), i2.getdata())if len(i1.getbands()) == 1:    
    dif = sum(abs(p1-p2) for p1,p2 in pairs)else:    dif = sum(abs(c1-c2) for p1,p2 in pairs for c1,c2 in zip(p1,p2)) ncomponents = i1.size[0] * i1.size[1] * 3print strv, (dif / 255.0 * 100) / ncomponents"
"from __future__ import print_functionimport randomfrom time import sleep first = random.choice([True, False]) you = ''if first:    me = ''.join(random.sample('HT'*3, 3))    print('I choose first and will win on first seeing {} in the list of tosses'.format(me))    while len(you) != 3 or any(ch not in 'HT' for ch in you) or you == me:        you = input('What sequence of three Heads/Tails will you win with: ')else:    while len(you) != 3 or any(ch not in 'HT' for ch in you):        you = input('After you: What sequence of three Heads/Tails will you win with: ')    me = ('H' if you[1] == 'T' else 'T') + you[:2]    print('I win on first seeing {} in the list of tosses'.format(me)) print('Rolling:  ', end='')rolled = ''while True:    rolled += random.choice('HT')    print(rolled[-1], end='')    if rolled.endswith(you):        print('  You win!')        break    if rolled.endswith(me):        print('  I win!')        break    sleep(1)    
"
"import turtle turtle.bgcolor(strv)t = turtle.Turtle()t.color(strv, strv)t.begin_fill()for i in range(0, 5):    t.forward(200)    t.right(144)t.end_fill()"
"import random lowercase = 'abcdefghijklmnopqrstuvwxyz' 
uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 
digits = '0123456789'                    
punctuation = '!""#$%&()*+,-./:;<=>?@[]^_{|}~' 
 allowed = lowercase + uppercase + digits + punctuation visually_similar = 'Il1O05S2Z'  def new_password(length:int, readable=True) -> str:    if length < 4:        print(strv.format(length),            strv)        return ''    choice = random.SystemRandom().choice    while True:        password_chars = [            choice(lowercase),            choice(uppercase),            choice(digits),            choice(punctuation)            ] + random.sample(allowed, length-4)        if (not readable or                 all(c not in visually_similar for c in password_chars)):            random.SystemRandom().shuffle(password_chars)            return ''.join(password_chars)  def password_generator(length, qty=1, readable=True):    for i in range(qty):        print(new_password(length, readable)) "
"from fractions import Fraction def muller_seq(n:int) -> float:    seq = [Fraction(0), Fraction(2), Fraction(-4)]    for i in range(3, n+1):        next_value = (111 - 1130/seq[i-1]            + 3000/(seq[i-1]*seq[i-2]))        seq.append(next_value)    return float(seq[n]) for n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:    print(strv.format(n, muller_seq(n)))from decimal import Decimal, getcontext def bank(years:int) -> float:    strv
    Warning: still will diverge and return incorrect results after 250 years
    the higher the precision, the more years will cover
    strv    getcontext().prec = 500    
    e = Decimal('2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921817413596629043572900334295260595630738132328627943490763233829880753195251019011573834187930702154089149934884167509244761460668082264800168477411853742345442437107539077744992069551702761838606261331384583000752044933826560297606737113200709328709127443747047230696977209310141692836819025515108657463772111252389784425056953696770785449969967946864454905987931636889230098793127736178215424999229576351')    decimal_balance = e - 1    for year in range(1, years+1):        decimal_balance = decimal_balance * year - 1    return(float(decimal_balance)) print(strv, bank(25))for year in range(200, 256, 5):    print(year, '->', bank(year)) from fractions import Fraction def rump(generic_a, generic_b) -> float:    a = Fraction('{}'.format(generic_a))    b = Fraction('{}'.format(generic_b))    fractional_result = Fraction('333.75') * b**6 \        + a**2 * ( 11 * a**2 * b**2 - b**6 - 121 * b**4 - 2 ) \        + Fraction('5.5') * b**8 + a / (2 * b)    return(float(fractional_result))  print(strv, rump(77617.0, 33096.0)) "
"




#[ X ] [ 11] [ Y ] [ 4 ] [ Z ]
 def combine( snl, snr ): 	cl = {}	if isinstance(snl, int):		cl['1'] = snl	elif isinstance(snl, string):		cl[snl] = 1	else:		cl.update( snl) 	if isinstance(snr, int):		n = cl.get('1', 0)		cl['1'] = n + snr	elif isinstance(snr, string):		n = cl.get(snr, 0)		cl[snr] = n + 1	else:		for k,v in snr.items():			n = cl.get(k, 0)			cl[k] = n+v	return cl  def constrain(nsum, vn ):	nn = {}	nn.update(vn)	n = nn.get('1', 0)	nn['1'] = n - nsum	return nn def makeMatrix( constraints ):	vmap = set()	for c in constraints:		vmap.update( c.keys())	vmap.remove('1')	nvars = len(vmap)	vmap = sorted(vmap)		
	mtx = []	for c in constraints:		row = []		for vv in vmap:			row.append(float(c.get(vv, 0)))		row.append(-float(c.get('1',0)))		mtx.append(row) 	if len(constraints) == nvars:		print 'System appears solvable'	elif len(constraints) < nvars:		print 'System is not solvable - needs more constraints.'	return mtx, vmap  def SolvePyramid( vl, cnstr ): 	vl.reverse()	constraints = [cnstr]	lvls = len(vl)	for lvln in range(1,lvls):		lvd = vl[lvln]		for k in range(lvls - lvln):			sn = lvd[k]			ll = vl[lvln-1]			vn = combine(ll[k], ll[k+1])			if sn is None:				lvd[k] = vn			else:				constraints.append(constrain( sn, vn )) 	print 'Constraint Equations:'	for cstr in constraints:		fset = ('%d*%s'%(v,k) for k,v in cstr.items() )		print ' + '.join(fset), ' = 0' 	mtx,vmap = makeMatrix(constraints) 	MtxSolve(mtx) 	d = len(vmap)	for j in range(d):		print vmap[j],'=', mtx[j][d]  def MtxSolve(mtx):	
 	mDim = len(mtx)			
	for j in range(mDim):		rw0= mtx[j]		f = 1.0/rw0[j]		for k in range(j, mDim+1):			rw0[k] *= f 		for l in range(1+j,mDim):			rwl = mtx[l]			f = -rwl[j]			for k in range(j, mDim+1):				rwl[k] += f * rw0[k] 	
	for j1 in range(1,mDim):		j = mDim - j1		rw0= mtx[j]		for l in range(0, j):			rwl = mtx[l]			f = -rwl[j]			rwl[j]    += f * rw0[j]			rwl[mDim] += f * rw0[mDim] 	return mtx  p = [ [151], [None,None], [40,None,None], [None,None,None,None], ['X', 11, 'Y', 4, 'Z'] ]addlConstraint = { 'X':1, 'Y':-1, 'Z':1, '1':0 }SolvePyramid( p, addlConstraint)from csp import Problem p = Problem()pvars = strv.split()
p.addvars(pvars, xrange(152))p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)p.addrule(strv)for sol in p.xsolutions():    print [sol[k] for k in strv]"
"from functools import partial def fs(f, s): return [f(value) for value in s] def f1(value): return value * 2 def f2(value): return value ** 2 fsf1 = partial(fs, f1)fsf2 = partial(fs, f2) s = [0, 1, 2, 3]assert fs(f1, s) == fsf1(s) 
assert fs(f2, s) == fsf2(s) 
 s = [2, 4, 6, 8]assert fs(f1, s) == fsf1(s) 
assert fs(f2, s) == fsf2(s) 
def partial(f, g):	def fg(*x): return f(g, *x)	return fg def fs(f, *x): return [ f(a) for a in x]def f1(a): return a * 2def f2(a): return a * a fsf1 = partial(fs, f1)fsf2 = partial(fs, f2) print fsf1(1, 2, 3, 4)print fsf2(1, 2, 3, 4)"
"from pprint import pprint as pp def pascal_upp(n):    s = [[0] * n for _ in range(n)]    s[0] = [1] * n    for i in range(1, n):        for j in range(i, n):            s[i][j] = s[i-1][j-1] + s[i][j-1]    return s def pascal_low(n):    
    return [list(x) for x in zip(*pascal_upp(n))] def pascal_sym(n):    s = [[1] * n for _ in range(n)]    for i in range(1, n):        for j in range(1, n):            s[i][j] = s[i-1][j] + s[i][j-1]    return s  if __name__ == strv:    n = 5    print(""Upper:"")    pp(pascal_upp(n))    print(""Lower:"")    pp(pascal_low(n))    print(""Symmetric:"")    pp(pascal_sym(n))def binomialCoeff(n, k):    result = 1    for i in range(1, k+1):        result = result * (n-i+1) // i    return result def pascal_upp(n):    return [[binomialCoeff(j, i) for j in range(n)] for i in range(n)] def pascal_low(n):    return [[binomialCoeff(i, j) for j in range(n)] for i in range(n)] def pascal_sym(n):    return [[binomialCoeff(i+j, i) for j in range(n)] for i in range(n)]"
"def pascal(n):   strvPrints out n rows of Pascal's triangle.
   It returns False for failure and True for success.strv   row = [1]   k = [0]   for x in range(max(n,0)):      print row      row=[l+r for l,r in zip(row+k,k+row)]   return n>=1def scan(op, seq, it):  a = []  result = it  a.append(it)  for x in seq:    result = op(result, x)    a.append(result)  return a def pascal(n):    def nextrow(row, x):        return [l+r for l,r in zip(row+[0,],[0,]+row)]     return scan(nextrow, range(n-1), [1,]) for row in pascal(4):    print(row)"
" from optparse import OptionParser[...]parser = OptionParser()parser.add_option(strv, strv, dest=strv,                  help=strv, metavar=strv)parser.add_option(strv, strv,                  action=strv, dest=strv, default=True,                  help=strv) (options, args) = parser.parse_args() example: <yourscript> --file=outfile -q "
"def op_pow(stack):    b = stack.pop(); a = stack.pop()    stack.append( a ** b )def op_mul(stack):    b = stack.pop(); a = stack.pop()    stack.append( a * b )def op_div(stack):    b = stack.pop(); a = stack.pop()    stack.append( a / b )def op_add(stack):    b = stack.pop(); a = stack.pop()    stack.append( a + b )def op_sub(stack):    b = stack.pop(); a = stack.pop()    stack.append( a - b )def op_num(stack, num):    stack.append( num ) ops = { '^': op_pow, '*': op_mul, '/': op_div, '+': op_add, '-': op_sub, } def get_input(inp = None):    'Inputs an expression and returns list of tokens'     if inp is None:        inp = input('expression: ')    tokens = inp.strip().split()    return tokens def rpn_calc(tokens):    stack = []    table = ['TOKEN,ACTION,STACK'.split(',')]    for token in tokens:        if token in ops:            action = 'Apply op to top of stack'            ops[token](stack)            table.append( (token, action, ' '.join(str(s) for s in stack)) )        else:            action = 'Push num onto top of stack'            op_num(stack, eval(token))            table.append( (token, action, ' '.join(str(s) for s in stack)) )    return table if __name__ == '__main__':    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'    print( 'For RPN expression: %r' % rpn )    rp = rpn_calc(get_input(rpn))    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]    row = rp[0]    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))    for row in rp[1:]:        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))     print(' The final output value is: %r' % rp[-1][2])a=[]b={'+': lambda x,y: y+x, '-': lambda x,y: y-x, '*': lambda x,y: y*x,'/': lambda x,y:y/x,'^': lambda x,y:y**x}for c in '3 4 2 * 1 5 - 2 3 ^ ^ / +'.split():    if c in b: a.append(b[c](a.pop(),a.pop()))    else: a.append(float(c))    print c, a"
"from math import log as lnfrom math import sqrt, log, exp, sin, cos, tan, pi, efrom ast import literal_eval strv
>>> # EXAMPLE USAGE
>>> result = rpn_to_infix('3 4 2 * 1 -5 - ln 2 3 ** ** / +', VERBOSE=True)
TOKEN  STACK
3      ['3']
4      ['3', '4']
2      ['3', '4', '2']
*      ['3', Node('2','*','4')]
1      ['3', Node('2','*','4'), '1']
-5     ['3', Node('2','*','4'), '1', '-5']
-      ['3', Node('2','*','4'), Node('-5','-','1')]
ln     ['3', Node('2','*','4'), Node(Node('-5','-','1'),'ln',None)]
2      ['3', Node('2','*','4'), Node(Node('-5','-','1'),'ln',None), '2']
3      ['3', Node('2','*','4'), Node(Node('-5','-','1'),'ln',None), '2', '3']
**     ['3', Node('2','*','4'), Node(Node('-5','-','1'),'ln',None), Node('3','**','2')]
**     ['3', Node('2','*','4'), Node(Node('3','**','2'),'**',Node(Node('-5','-','1'),'ln',None))]
/      ['3', Node(Node(Node('3','**','2'),'**',Node(Node('-5','-','1'),'ln',None)),'/',Node('2','*','4'))]
+      [Node(Node(Node(Node('3','**','2'),'**',Node(Node('-5','-','1'),'ln',None)),'/',Node('2','*','4')),'+','3')]
>>> result
strv prec_dict =  {'abs':5, 'sqrt':5, 'exp':5,  'log':5,  'ln':5,              'sin':5, 'cos':5,  'tan':5,              '**':4, '*':3, '/':3, '+':2, '-':2}assoc_dict = {'abs':0, 'sqrt':0, 'exp':0,  'log':0,  'ln':0,              'sin':0, 'cos':0,  'tan':0,              '**':1, '*':0, '/':0, '+':0, '-':0}arity_dict = {'abs':1, 'sqrt':1, 'exp':1,  'log':1,  'ln':1,              'sin':1, 'cos':1,  'tan':1,              '**':2, '*':2, '/':2, '+':2, '-':2} class Node:    def __init__(self,x,op,y=None):        self.precedence = prec_dict[op]        self.assocright = assoc_dict[op]        self.arity = arity_dict[op]        self.op = op         if not self.assocright and self > x and \           isinstance(x, Node) and self.arity == 2:                self.x = x.x                self.y = Node(x.y, x.op, y)        else:            self.x,self.y = x,y     def __str__(self):        strv
        Building an infix string that evaluates correctly is easy.
        Building an infix string that looks pretty and evaluates
        correctly requires more effort.
        strv         
        if self.y == None:            return '%s(%s)'%(self.op,str(self.x))         
        str_y = str(self.y)        if  self.y < self or \            (self.y == self and self.assocright) or \            (str_y[0] is '-' and self.assocright):             str_y = '(%s)'%str_y         
        str_x = str(self.x)        str_op = self.op        if self.op is '+' and not isinstance(self.x, Node) and str_x[0] is '-':            str_x = str_x[1:]            str_op = '-'        elif self.op is '-' and not isinstance(self.x, Node) and str_x[0] is '-':            str_x = str_x[1:]            str_op = '+'        elif self.x < self or \             (self.x == self and not self.assocright and \              getattr(self.x, 'op', 1) != getattr(self, 'op', 2)):             str_x = '(%s)'%str_x         return ' '.join([str_y, str_op, str_x])     def __repr__(self):        strv
        >>> repr(Node('3','+','4')) == repr(eval(repr(Node('3','+','4'))))
        True
        strv        return 'Node(%s,%s,%s)'%(repr(self.x), repr(self.op), repr(self.y))     def __lt__(self, other):        if isinstance(other, Node):            return self.precedence < other.precedence        return self.precedence < prec_dict.get(other,9)     def __gt__(self, other):        if isinstance(other, Node):            return self.precedence > other.precedence        return self.precedence > prec_dict.get(other,9)   def rpn_to_infix(s, VERBOSE=False):    strv
    converts rpn notation to infix notation for string s
 
        strv
 
    >>> rpn_to_infix('5 4 +')
    '5 + 4'
    >>> rpn_to_infix('5 -4 +')
    '5 - 4'
    >>> rpn_to_infix('5 -4 -')
    '5 + 4'
    >>> rpn_to_infix('5 -4.2 +')
    '5 - 4.2'
    >>> rpn_to_infix('-4 2 **')
    '(-4) ** 2'
    >>> rpn_to_infix('x y +')
    'x + y'
    >>> rpn_to_infix('x -y +')
    'x - y'
    >>> rpn_to_infix('5 4 3 2 ** ** **')
    '5 ** 4 ** 3 ** 2'
    >>> rpn_to_infix('5 6 ** 7 **')
    '(5 ** 6) ** 7'
    >>> rpn_to_infix('1 2 3 + -')
    '1 - (2 + 3)'
    >>> rpn_to_infix('4 3 2 + +')
    '4 + 3 + 2'
    >>> rpn_to_infix('5 4 3 2 + + +')
    '5 + 4 + 3 + 2'
    >>> rpn_to_infix('5 4 3 2 * * *')
    '5 * 4 * 3 * 2'
    >>> rpn_to_infix('5 4 3 2 + - +')
    '5 + (4 - (3 + 2))'
    >>> rpn_to_infix('3 4 5 * -')
    '3 - 4 * 5'
    >>> rpn_to_infix('3 4 5 - *')
    '(3 - 4) * 5'
    >>> rpn_to_infix('4 2 * 1 5 - +')
    '4 * 2 + (1 - 5)'
    >>> rpn_to_infix('4 2 * 1 5 - 2 ** /')
    '4 * 2 / (1 - 5) ** 2'
    >>> rpn_to_infix('3 4 2 * 1 5 - 2 3 ** ** / +')
    '3 + 4 * 2 / (1 - 5) ** 2 ** 3'
    >>> rpn_to_infix('1 2 + 3 4 + ** 5 6 + **')
    '((1 + 2) ** (3 + 4)) ** (5 + 6)'
    >>> rpn_to_infix('x sin')
    'sin(x)'
    >>> rpn_to_infix('5 4 3 2 + sqrt - +')
    '5 + (4 - sqrt(3 + 2))'
    >>> rpn_to_infix('5 4 3 2 + sqrt ln - +')
    '5 + (4 - ln(sqrt(3 + 2)))'
    >>> rpn_to_infix('5 sin 4 cos *')
    'sin(5) * cos(4)'
    >>> rpn_to_infix('5 4 cos * sin')
    'sin(5 * cos(4))'
    >>> rpn_to_infix('3 4 2 * 1 -5 - ln 2 3 ** ** / +')
    '3 + 4 * 2 / ln(1 + 5) ** 2 ** 3'
    strv    if VERBOSE : print('TOKEN  STACK')     stack=[]    for token in s.replace('^','**').split():        if token in prec_dict:            if arity_dict[token] == 1:                stack.append(Node(stack.pop(),token))            elif arity_dict[token] == 2:                stack.append(Node(stack.pop(),token,stack.pop()))        else:            stack.append(token)         
        if VERBOSE : print(token+' '*(7-len(token))+repr(stack))      return str(stack[0]) def rpn_eval(s):    strv
    computes the value of an rpn string
 
    >>> rpn_eval('5 4 +') == eval(rpn_to_infix('5 4 +'))
    True
    >>> rpn_eval('-4 2 **') == eval(rpn_to_infix('-4 2 **'))
    True
    >>> round(rpn_eval('3 4 2 * 1 -5 - ln 2 3 ** ** / +'),7) == 
        round(eval(rpn_to_infix('3 4 2 * 1 -5 - ln 2 3 ** ** / +')),7)
    True
    >>> round(rpn_eval('5 4 3 2 + sqrt ln - +'),7) == 
        round(eval(rpn_to_infix('5 4 3 2 + sqrt ln - +')),7)
    True
    strv     stack=[]    for token in s.replace('^','**').split():        if token in prec_dict:            if arity_dict[token] == 1:                stack.append(literal_eval('%s(%s)'%(token,stack.pop())))            elif arity_dict[token] == 2:                x,y=stack.pop(),stack.pop()                stack.append(literal_eval('(%s) %s %s'%(y,token,x)))        else:            stack.append(token)     return stack[0] strTest = strvstrResult = rpn_to_infix(strTest)print (strv,strTest)print (strv,strResult) "
"import sqlite3 db = sqlite3.connect(':memory:') 
db.execute('create temp table players (name, score, active, jerseyNum)')db.execute('insert into players values (strv,99)')db.execute('insert into players values (strv,100)') 
 
db.execute('update players set name=?, score=?, active=? where jerseyNum=?', ('Smith, Steve', 42, True, 99)) 
db.execute('update players set name=:name, score=:score, active=:active where jerseyNum=:num',    {'num': 100,     'name': 'John Doe',     'active': False,     'score': -1}) 
for row in db.execute('select * from players'):   print(row)"
"from ipaddress import ip_addressfrom urllib.parse import urlparse tests = [    strv,    strv,    strv,    strv,    strv,    strv,    strv ] def parse_ip_port(netloc):    try:        ip = ip_address(netloc)        port = None    except ValueError:        parsed = urlparse('//{}'.format(netloc))        ip = ip_address(parsed.hostname)        port = parsed.port    return ip, port for address in tests:    ip, port = parse_ip_port(address)    hex_ip = {4:'{:08X}', 6:'{:032X}'}[ip.version].format(int(ip))    print(strv.format(        str(ip), hex_ip, ip.version, port ))import stringfrom pyparsing import * 
 tests=strv#
127.0.0.1                       # The strv IPv4 address
127.0.0.1:80                    # The strv IPv4 address, with a specified port (80)
::1                             # The strv IPv6 address
[::1]:80                        # The strv IPv6 address, with a specified port (80)
2605:2700:0:3::4713:93e3        # Rosetta Code's primary server's public IPv6 address
[2605:2700:0:3::4713:93e3]:80   # Rosetta Code's primary server's public IPv6 address, +port (80)
2001:db8:85a3:0:0:8a2e:370:7334 # doc, IPv6 for 555-1234
2001:db8:85a3::8a2e:370:7334    # doc
[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443 # doc +port
192.168.0.1                     # private
::ffff:192.168.0.1              # private transitional
::ffff:71.19.147.227            # Rosetta Code's transitional
[::ffff:71.19.147.227]:80       # Rosetta Code's transitional +port
::                              # unspecified
256.0.0.0                       # invalid, octet > 255 (currently not detected)
g::1                            # invalid
0000                                    Bad address
0000:0000                               Bad address
0000:0000:0000:0000:0000:0000:0000:0000 Good address
0000:0000:0000::0000:0000               Good Address
0000::0000::0000:0000                   Bad address
ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff Good address
ffff:ffff:ffff:fffg:ffff:ffff:ffff:ffff Bad address
fff:ffff:ffff:ffff:ffff:ffff:ffff:ffff  Good address
fff:ffff:0:ffff:ffff:ffff:ffff:ffff     Good address
strv def print_args(args):  print strv, args def join(args):  args[0]=strv.join(args)  del args[1:] def replace(val):  def lambda_replace(args):    args[0]=val    del args[1:]  return lambda_replace def atoi(args): args[0]=string.atoi(args[0])def itohex2(args): args[0]=strv%args[0] def hextoi(args): args[0]=string.atoi(args[0], 16)def itohex4(args): args[0]=strv%args[0] def assert_in_range(lwb, upb):  def range_check(args):    return 
    if args[0] < lwb:      raise ValueError,strv%(args[0], lwb)    if args[0] > upb:      raise ValueError,strv%(args[0], upb)  return range_check dot = Literal(strv).suppress()(strv); colon = Literal(strv).suppress()(strv)octet = Word(nums).setParseAction(atoi,assert_in_range(0,255),itohex2)(strv); port = Word(nums).setParseAction(atoi,assert_in_range(0,256*256-1))(strv)ipv4 = (octet + (dot+octet)*3)(strv)ipv4.setParseAction(join) #,hextoi) ipv4_port = ipv4+colon.suppress()+port a2f = strvhex = oneOf(strv.join(nums+a2f)); hexet = (hex*(0,4))(strv)hexet.setParseAction(join, hextoi, itohex4) max=8; stop=max+1 xXXXX_etc = [None, hexet]; xXXXX_etc.extend([hexet + (colon+hexet)*n for n in range(1,max)])x0000_etc = [ Literal(strv).setParseAction(replace(strv*num_x0000s)) for num_x0000s in range(stop) ] ipv6=xXXXX_etc[-1]+x0000_etc[0] | xXXXX_etc[-1] 
for num_prefix in range(max-1, -1, -1):  for num_x0000s in range(0,stop-num_prefix):    x0000 = x0000_etc[num_x0000s]    num_suffix=max-num_prefix-num_x0000s    if num_prefix:      if num_suffix: pat = xXXXX_etc[num_prefix]+x0000+xXXXX_etc[num_suffix]      else:          pat = xXXXX_etc[num_prefix]+x0000    elif num_suffix: pat =                       x0000+xXXXX_etc[num_suffix]    else: pat=x0000    ipv6 = ipv6 | pat ipv6.setParseAction(join) 
ipv6_port = Literal(strv).suppress() + ipv6 + Literal(strv).suppress()+colon+port ipv6_transitional = (Literal(strv).setParseAction(replace(strv*20+strv))+ipv4).setParseAction(join)ipv6_transitional_port = Literal(strv).suppress() + ipv6_transitional + Literal(strv).suppress()+colon+port ip_fmt = (           (ipv4_port|ipv4)(strv) |           (ipv6_transitional_port|ipv6_transitional|ipv6_port|ipv6)(strv)         ) + LineEnd() class IPAddr(object):  def __init__(self, string):    self.service = dict(zip((strv,strv), ip_fmt.parseString(string)[:]))  def __getitem__(self, key): return self.service[key]  def __contains__(self, key): return key in self.service  def __repr__(self): return `self.service` 
  address=property(lambda self: self.service[strv])  port=property(lambda self: self.service[strv])  is_service=property(lambda self: strv in self.service)  version=property(lambda self: {False:4, True:6}[len(self.address)>8]) for test in tests.splitlines():  if not test.startswith(strv):    ip_str, desc = test.split(None,1)    print ip_str,strv,    try:      ip=IPAddr(ip_str)      print ip, strv,ip.version,strv,    except (ParseException,ValueError), details: print strv,details,    print strv,desc"
"import multiprocessingfrom hashlib import sha256  def HashFromSerial(serial):    divisor = 456976    letters = []    for i in range(5):        letter, serial = divmod(serial, divisor)        letters.append( 97 + int(letter) )        divisor /= 26    return (letters, sha256(bytes(letters)).digest())  def main():    h1 = bytes().fromhex(strv)    h2 = bytes().fromhex(strv)    h3 = bytes().fromhex(strv)    numpasswords = int(26 ** 5)    chunksize = int(numpasswords / multiprocessing.cpu_count())    with multiprocessing.Pool() as p:        for (letters, digest) in p.imap_unordered(HashFromSerial, range(numpasswords), chunksize):            if digest == h1 or digest == h2 or digest == h3:                password = strv.join(chr(x) for x in letters)                print(password + strv + digest.hex())  if __name__ == strv:    main()"
"from collections import namedtuplefrom pprint import pprint as pp OpInfo = namedtuple('OpInfo', 'prec assoc')L, R = 'Left Right'.split() ops = { '^': OpInfo(prec=4, assoc=R), '*': OpInfo(prec=3, assoc=L), '/': OpInfo(prec=3, assoc=L), '+': OpInfo(prec=2, assoc=L), '-': OpInfo(prec=2, assoc=L), '(': OpInfo(prec=9, assoc=L), ')': OpInfo(prec=0, assoc=L), } NUM, LPAREN, RPAREN = 'NUMBER ( )'.split()  def get_input(inp = None):    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'     if inp is None:        inp = input('expression: ')    tokens = inp.strip().split()    tokenvals = []    for token in tokens:        if token in ops:            tokenvals.append((token, ops[token]))        #elif token in (LPAREN, RPAREN):        
        else:                tokenvals.append((NUM, token))    return tokenvals def shunting(tokenvals):    outq, stack = [], []    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]    for token, val in tokenvals:        note = action = ''        if token is NUM:            action = 'Add number to output'            outq.append(val)            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )        elif token in ops:            t1, (p1, a1) = token, val            v = t1            note = 'Pop ops from stack to output'             while stack:                t2, (p2, a2) = stack[-1]                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):                    if t1 != RPAREN:                        if t2 != LPAREN:                            stack.pop()                            action = '(Pop op)'                            outq.append(t2)                        else:                                break                    else:                                if t2 != LPAREN:                            stack.pop()                            action = '(Pop op)'                            outq.append(t2)                        else:                                stack.pop()                            action = '(Pop & discard strv)'                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )                            break                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )                    v = note = ''                else:                    note = ''                    break                note = ''             note = ''             if t1 != RPAREN:                stack.append((token, val))                action = 'Push op token to stack'            else:                action = 'Discard strv'            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )    note = 'Drain stack to output'    while stack:        v = ''        t2, (p2, a2) = stack[-1]        action = '(Pop op)'        stack.pop()        outq.append(t2)        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )        v = note = ''    return table if __name__ == '__main__':    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'    print( 'For infix expression: %r' % infix )    rp = shunting(get_input(infix))    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]    row = rp[0]    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))    for row in rp[1:]:        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))     print(' The final output RPN is: %r' % rp[-1][2])"
"from concurrent import futuresfrom math import floor, sqrt NUMBERS = [    112272537195293,    112582718962171,    112272537095293,    115280098190773,    115797840077099,    1099726829285419]
 def lowest_factor(n, _start=3):    if n % 2 == 0:        return 2    search_max = int(floor(sqrt(n))) + 1    for i in range(_start, search_max, 2):        if n % i == 0:            return i    return n def prime_factors(n, lowest):    pf = []    while n > 1:        pf.append(lowest)        n //= lowest        lowest = lowest_factor(n, max(lowest, 3))    return pf def prime_factors_of_number_with_lowest_prime_factor(NUMBERS):    with futures.ProcessPoolExecutor() as executor:        low_factor, number = max( (l, f) for l, f in zip(executor.map(lowest_factor, NUMBERS), NUMBERS) )        all_factors = prime_factors(number, low_factor)        return number, all_factors  def main():    print('For these numbers:')    print('  '.join(str(p) for p in NUMBERS))    number, all_factors = prime_factors_of_number_with_lowest_prime_factor(NUMBERS)    print('    The one with the largest minimum prime factor is {}:'.format(number))    print('      All its prime factors in order are: {}'.format(all_factors)) if __name__ == '__main__':    main()import multiprocessing 
from math import floor, sqrt numbers = [    112272537195293,    112582718962171,    112272537095293,    115280098190773,    115797840077099,    1099726829285419]
 def lowest_factor(n, _start=3):    if n % 2 == 0:        return 2    search_max = int(floor(sqrt(n))) + 1    for i in range(_start, search_max, 2):        if n % i == 0:            return i    return n def prime_factors(n, lowest):    pf = []    while n > 1:        pf.append(lowest)        n //= lowest        lowest = lowest_factor(n, max(lowest, 3))    return pf
 def prime_factors_of_number_with_lowest_prime_factor(numbers):    pool = multiprocessing.Pool(processes=5)    factors = pool.map(lowest_factor,numbers)     low_factor,number = max((l,f) for l,f in zip(factors,numbers))    all_factors = prime_factors(number,low_factor)    return number,all_factors if __name__ == '__main__':    print('For these numbers:')    print('  '.join(str(p) for p in numbers))    number, all_factors = prime_factors_of_number_with_lowest_prime_factor(numbers)    print('    The one with the largest minimum prime factor is {}:'.format(number))    print('      All its prime factors in order are: {}'.format(all_factors)) "
"try:    import psyco    psyco.full()except ImportError:    pass MAX_N = 300BRANCH = 4 ra = [0] * MAX_Nunrooted = [0] * MAX_N def tree(br, n, l, sum = 1, cnt = 1):    global ra, unrooted, MAX_N, BRANCH    for b in xrange(br + 1, BRANCH + 1):        sum += n        if sum >= MAX_N:            return         
        if l * 2 >= sum and b >= BRANCH:            return         if b == br + 1:            c = ra[n] * cnt        else:            c = c * (ra[n] + (b - br - 1)) / (b - br)         if l * 2 < sum:            unrooted[sum] += c         if b < BRANCH:            ra[sum] += c;            for m in range(1, n):                tree(b, m, l, sum, c) def bicenter(s):    global ra, unrooted    if not (s & 1):        aux = ra[s / 2]        unrooted[s] += aux * (aux + 1) / 2  def main():    global ra, unrooted, MAX_N    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1     for n in xrange(1, MAX_N):        tree(0, n, n)        bicenter(n)        print strv % (n, unrooted[n]) main()from itertools import count, chain, tee, islice, cyclefrom fractions import Fractionfrom sys import setrecursionlimitsetrecursionlimit(5000) def frac(a,b): return a//b if a%b == 0 else Fraction(a,b) 
class Poly:    def __init__(self, gen = None):        self.gen, self.source = (None, gen) if type(gen) is Poly \            else (gen, None)     def __iter__(self):        
        
        return Poly(self)     def getsource(self):        if self.gen == None:            s = self.source            s.getsource()            s.gen, self.gen = tee(s.gen, 2)     def next(self):        self.getsource()        return next(self.gen)     __next__ = next     
    def __lshift__(self, a): self.gen = a     
    def __neg__(self): return Poly(-x for x in self)     def __sub__(a, b): return a + (-b)     def __rsub__(a, n):        a = Poly(a)        def gen():            yield(n - next(a))            for x in a: yield(-x)        return Poly(gen())     def __add__(a, b):        if type(b) is Poly:            return Poly(x + y for (x,y) in zip(a,b))         a = Poly(a)        def gen():            yield(next(a) + b)            for x in a: yield(x)         return Poly(gen())     def __radd__(a,b):        return a + b     def __mul__(a,b):        if not type(b) is Poly:            return Poly(x*b for x in a)         def gen():            s = Poly(cycle([0]))            for y in b:                s += y*a                yield(next(s))         return Poly(gen())     def __rmul__(a,b): return a*b     def __truediv__(a,b):        if not type(b) is Poly:            return Poly(frac(x, b) for x in a)         a, b = Poly(a), Poly(b)        def gen():            r, bb = a,next(b)            while True:                aa = next(r)                q = frac(aa, bb)                yield(q)                r -= q*b         return Poly(gen())     def repl(self, n):        def gen():            for x in self:                yield(x)                for i in range(n-1): yield(0)        return Poly(gen())     def __pow__(self, n):        return Poly(self) if n == 1 else self * self**(n-1) def S2(a,b): return (a*a + b)/2def S4(a,b,c,d): return a**4/24 + a**2*b/4 + a*c/3 + b**2/8 + d/4 x1 = Poly()x2 = x1.repl(2)x3 = x1.repl(3)x4 = x1.repl(4)x1 << chain([1], (x1**3 + 3*x1*x2 + 2*x3)/6) a598 = x1a678 = Poly(chain([0], S4(x1, x2, x3, x4)))a599 = S2(x1 - 1, x2 - 1)a602 = a678 - a599 + x2 for n,x in zip(count(0), islice(a602, 500)): print(n,x)"
"import string, sysif sys.version_info[0] < 3:    input = raw_input def ispangram(sentence, alphabet=string.ascii_lowercase):    alphaset = set(alphabet)    return alphaset <= set(sentence.lower()) print ( ispangram(input('Sentence: ')) )"
"from __future__ import print_function def order_disjoint_list_items(data, items):    #Modifies data list in-place    itemindices = []    for item in set(items):        itemcount = items.count(item)        #assert data.count(item) >= itemcount, 'More of %r than in data' % item        lastindex = [-1]        for i in range(itemcount):            lastindex.append(data.index(item, lastindex[-1] + 1))        itemindices += lastindex[1:]    itemindices.sort()    for index, item in zip(itemindices, items):        data[index] = item if __name__ == '__main__':    tostring = ' '.join    for data, items in [ (str.split('the cat sat on the mat'), str.split('mat cat')),                         (str.split('the cat sat on the mat'), str.split('cat mat')),                         (list('ABCABCABC'), list('CACA')),                         (list('ABCABDABE'), list('EADA')),                         (list('AB'), list('B')),                         (list('AB'), list('BA')),                         (list('ABBA'), list('BA')),                         (list(''), list('')),                         (list('A'), list('A')),                         (list('AB'), list('')),                         (list('ABBA'), list('AB')),                         (list('ABAB'), list('AB')),                         (list('ABAB'), list('BABA')),                         (list('ABCCBA'), list('ACAC')),                         (list('ABCCBA'), list('CACA')),                       ]:        print('Data M: %-24r Order N: %-9r' % (tostring(data), tostring(items)), end=' ')        order_disjoint_list_items(data, items)        print(strv % tostring(data))"
"from itertools import combinations def partitions(*args):    def p(s, *args):        if not args: return [[]]        res = []        for c in combinations(s, args[0]):            s0 = [x for x in s if x not in c]            for r in p(s0, *args[1:]):                res.append([c] + r)        return res    s = range(sum(args))    return p(s, *args) print partitions(2, 0, 2)from itertools import combinations as comb def partitions(*args):    def minus(s1, s2): return [x for x in s1 if x not in s2]    def p(s, *args):        if not args: return [[]]        return [[c] + r for c in comb(s, args[0]) for r in p(minus(s, c), *args[1:])]    return p(range(1, sum(args) + 1), *args) print partitions(2, 0, 2)"
">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]Falsedef (a < b) :case (or list?.a list?.b)  if not.b       nil     not.a       b     (car.a = car.b)       (cdr.a < cdr.b)     :else       (car.a < car.b)"
"def is_palindrome(s):  return s == s[::-1]def is_palindrome_r(s):  if len(s) <= 1:    return True  elif s[0] != s[-1]:    return False  else:    return is_palindrome_r(s[1:-1])def is_palindrome_r2(s):  return not s or s[0] == s[-1] and is_palindrome_r2(s[1:-1])def test(f, good, bad):  assert all(f(x) for x in good)  assert not any(f(x) for x in bad)  print '%s passed all %d tests' % (f.__name__, len(good)+len(bad)) pals = ('', 'a', 'aa', 'aba', 'abba')notpals = ('aA', 'abA', 'abxBa', 'abxxBa')for ispal in is_palindrome, is_palindrome_r, is_palindrome_r2:  test(ispal, pals, notpals)def p_loop():  import re, string  re1=strv       
  re2=strv       
  pal=raw_input(strv)  pd = pal.replace(' ','')  for c in string.punctuation:     pd = pd.replace(c,strv)  if pal == strv :    return -1  c=len(pd)   
  loops = (c+1)/2   for x in range(loops):    re1 = re1 + ""()""    if (c%2 == 1 and x == 0):       continue     p = loops - x    re2 = re2 + """" + str(p)  regex= re1+re2+strv   
  #print(regex)  # To test regex before re.search  m = re.search(r'^'+regex,pd,re.IGNORECASE)  if (m):     print(""   ""+'""'+pal+'""')     print(""   is a Palindrome"")     return 1  else:     print(strv)     return 0"
"import urllib.request url = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'words = urllib.request.urlopen(url).read().decode(strv).split()ordered = [word for word in words if word==''.join(sorted(word))]maxlen = len(max(ordered, key=len))maxorderedwords = [word for word in ordered if len(word) == maxlen]print(' '.join(maxorderedwords))import urllib.request mx, url = 0, 'http://www.puzzlers.org/pub/wordlists/unixdict.txt' for word in urllib.request.urlopen(url).read().decode(strv).split():    lenword = len(word)    if lenword >= mx and word==''.join(sorted(word)):        if lenword > mx:            words, mx = [], lenword        words.append(word)print(' '.join(words))from itertools import groupbyo = (w for w in map(str.strip, open(strv)) if sorted(w)==list(w))print list(next(groupby(sorted(o, key=len, reverse=True), key=len))[1])"
"#!/usr/bin/env python
 def ownCalcPass (password, nonce) :    m_1 = 0xFFFFFFFFL    m_8 = 0xFFFFFFF8L    m_16 = 0xFFFFFFF0L    m_128 = 0xFFFFFF80L    m_16777216 = 0XFF000000L    flag = True    num1 = 0L    num2 = 0L    password = long(password)     for c in nonce :        num1 = num1 & m_1        num2 = num2 & m_1        if c == '1':            length = not flag            if not length :                num2 = password            num1 = num2 & m_128            num1 = num1 >> 7            num2 = num2 << 25            num1 = num1 + num2            flag = False        elif c == '2':            length = not flag            if not length :                num2 = password            num1 = num2 & m_16            num1 = num1 >> 4            num2 = num2 << 28            num1 = num1 + num2            flag = False        elif c == '3':            length = not flag            if not length :                num2 = password            num1 = num2 & m_8            num1 = num1 >> 3            num2 = num2 << 29            num1 = num1 + num2            flag = False        elif c == '4':            length = not flag             if not length:                num2 = password            num1 = num2 << 1            num2 = num2 >> 31            num1 = num1 + num2            flag = False        elif c == '5':            length = not flag            if not length:                num2 = password            num1 = num2 << 5            num2 = num2 >> 27            num1 = num1 + num2            flag = False        elif c == '6':            length = not flag            if not length:                num2 = password            num1 = num2 << 12            num2 = num2 >> 20            num1 = num1 + num2            flag = False        elif c == '7':            length = not flag            if not length:                num2 = password            num1 = num2 & 0xFF00L            num1 = num1 + (( num2 & 0xFFL ) << 24 )            num1 = num1 + (( num2 & 0xFF0000L ) >> 16 )            num2 = ( num2 & m_16777216 ) >> 8            num1 = num1 + num2            flag = False        elif c == '8':            length = not flag            if not length:                num2 = password            num1 = num2 & 0xFFFFL            num1 = num1 << 16            num1 = num1 + ( num2 >> 24 )            num2 = num2 & 0xFF0000L            num2 = num2 >> 8            num1 = num1 + num2            flag = False        elif c == '9':            length = not flag            if not length:                num2 = password            num1 = ~num2            flag = False        else :            num1 = num2        num2 = num1    return num1 & m_1 def ownTestCalcPass (passwd, nonce, expected) :        res = ownCalcPass(passwd, nonce)        m = passwd+' '+nonce+' '+str(res)+' '+str(expected)        if res == long(expected) :                print 'PASS '+m        else :                 print 'FAIL '+m if __name__ == '__main__':    import sys     ownTestCalcPass('12345','603356072','25280520')    ownTestCalcPass('12345','410501656','119537670') "
">>> def printtable(data):    for row in data:        print ' '.join('%-5s' % ('strv' % cell) for cell in row)  >>> import operator>>> def sorttable(table, ordering=None, column=0, reverse=False):    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse) >>> data = [[strv, strv, strv], [strv, strv, strv], [strv, strv, strv]]>>> printtable(data)strv   strv   strv  strv    strv   strv  strv strv strv>>> printtable( sorttable(data) )strv    strv   strv  strv   strv   strv  strv strv strv>>> printtable( sorttable(data, column=2) )strv strv strvstrv   strv   strv  strv    strv   strv  >>> printtable( sorttable(data, column=1) )strv   strv   strv  strv    strv   strv  strv strv strv>>> printtable( sorttable(data, column=1, reverse=True) )strv strv strvstrv    strv   strv  strv   strv   strv  >>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )strv strv strvstrv   strv   strv  strv    strv   strv  >>>"
"#!/usr/bin/env python#-*- coding: utf-8 -*- from OpenGL.GL import *from OpenGL.GLUT import * def paint():    glClearColor(0.3,0.3,0.3,0.0)    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)     glShadeModel(GL_SMOOTH)     glLoadIdentity()    glTranslatef(-15.0, -15.0, 0.0)     glBegin(GL_TRIANGLES)    glColor3f(1.0, 0.0, 0.0)    glVertex2f(0.0, 0.0)    glColor3f(0.0, 1.0, 0.0)    glVertex2f(30.0, 0.0)    glColor3f(0.0, 0.0, 1.0)    glVertex2f(0.0, 30.0)    glEnd()     glFlush() def reshape(width, height):    glViewport(0, 0, width, height)    glMatrixMode(GL_PROJECTION)    glLoadIdentity()    glOrtho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)    glMatrixMode(GL_MODELVIEW) if __name__ == '__main__':    glutInit(1, 1)    glutInitWindowSize(640, 480)    glutCreateWindow(strv)     glutDisplayFunc(paint)    glutReshapeFunc(reshape)     glutMainLoop()"
"#!/usr/bin/env python
import win32com.clientfrom win32com.server.util import wrap, unwrapfrom win32com.server.dispatcher import DefaultDebugDispatcherfrom ctypes import *import commandsimport pythoncomimport winerrorfrom win32com.server.exception import Exception clsid = strviid = pythoncom.MakeIID(clsid)appid = strv class VeryPermissive:    def __init__(self):        self.data = []        self.handle = 0        self.dobjects = {}            def __del__(self):        pythoncom.RevokeActiveObject(self.handle)    def _dynamic_(self, name, lcid, wFlags, args):        if wFlags & pythoncom.DISPATCH_METHOD:            return getattr(self,name)(*args)        if wFlags & pythoncom.DISPATCH_PROPERTYGET:            try:                
                ret = self.__dict__[name]                if type(ret)==type(()):                    ret = list(ret)                return ret            except KeyError: 
                raise Exception(scode=winerror.DISP_E_MEMBERNOTFOUND)        if wFlags & (pythoncom.DISPATCH_PROPERTYPUT | pythoncom.DISPATCH_PROPERTYPUTREF):            setattr(self, name, args[0])            return        raise Exception(scode=winerror.E_INVALIDARG, desc=strv)    def write(self, x):        print x        return 0import win32com.server.util, win32com.server.policychild = VeryPermissive()ob = win32com.server.util.wrap(child, usePolicy=win32com.server.policy.DynamicPolicy)try:    handle = pythoncom.RegisterActiveObject(ob, iid, 0)except pythoncom.com_error, details:    print strv, details    handle = None    child.handle = handle   ahk = win32com.client.Dispatch(strv)ahk.aRegisterIDs(clsid, appid)


import win32com.clientclient = win32com.client.Dispatch(strv)client.write(strv)"
"from random import randrangetry:    range = xrangeexcept: pass def one_of_n(lines): 
    choice = None    for i, line in enumerate(lines):        if randrange(i+1) == 0:            choice = line    return choice def one_of_n_test(n=10, trials=1000000):    bins = [0] * n    if n:        for i in range(trials):            bins[one_of_n(range(n))] += 1    return bins print(one_of_n_test())"
"from sys import argv unit2mult = {strv: 0.7112, strv: 0.01,     strv:   0.0254,             strv:    0.3048, strv:  1000.0,   strv:  0.00254,             strv:  1.0,    strv:      7467.6,   strv:    0.1778,             strv: 2.1336, strv:     0.000254, strv: 0.04445,             strv: 1066.8} if __name__ == '__main__':    assert len(argv) == 3, 'ERROR. Need two arguments - number then units'    try:        value = float(argv[1])    except:        print('ERROR. First argument must be a (float) number')        raise    unit = argv[2]    assert unit in unit2mult, ( 'ERROR. Only know the following units: '                                 + ' '.join(unit2mult.keys()) )     print(strv % (value, unit))    for unt, mlt in sorted(unit2mult.items()):        print('  %10s: %g' % (unt, value * unit2mult[unit] / mlt))"
"import random printdead, printlive = '_#'maxgenerations = 10cellcount = 20offendvalue = '0' universe = ''.join(random.choice('01') for i in range(cellcount)) neighbours2newstate = { '000': '0', '001': '0', '010': '0', '011': '1', '100': '0', '101': '1', '110': '1', '111': '0', } for i in range(maxgenerations):    print strv % ( i,          universe.replace('0', printdead).replace('1', printlive) )    universe = offendvalue + universe + offendvalue    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))import random nquads = 5maxgenerations = 10fmt = '%%0%ix'%nquadsnbits = 4*nquadsa = random.getrandbits(nbits)  << 1#a = int('01110110101010100100', 2) << 1endmask = (2<<nbits)-2;endvals = 0<<(nbits+1) | 0tr = ('____', '___#', '__#_', '__##', '_#__', '_#_#', '_##_', '_###',      '#___', '#__#', '#_#_', '#_##', '##__', '##_#', '###_', '####' )for i in range(maxgenerations):   print strv % (i,(''.join(tr[int(t,16)] for t in (fmt%(a>>1)))))   a |= endvals   a = ((a&((a<<1) | (a>>1))) ^ ((a<<1)&(a>>1))) & endmask>>> gen = [ch == '#' for ch in '_###_##_#_#_#_#__#__']>>> for n in range(10):	print(''.join('#' if cell else '_' for cell in gen))	gen = [0] + gen + [0]	gen = [sum(gen[m:m+3]) == 2 for m in range(len(gen)-2)]  _###_##_#_#_#_#__#___#_#####_#_#_#________##___##_#_#_________##___###_#__________##___#_##___________##____###___________##____#_#___________##_____#____________##__________________##________________>>> def (gens n l)  prn l  repeat n    zap! gen l    prn l def (gen l)  with (a nil  b nil  c l.0)    collect nil  
      each x cdr.l        shift! a b c x        yield (next a b c)      yield (next b c nil) def (next a b c)  
  if (and a c)  not.b     (or a c)  bdef (uca l)  
  (tag uca (list l len.l)) def (len l) :case (isa uca l)  
  rep.l.1 defcoerce uca list  
  (fn(_) rep._.0) def (pr l) :case (isa uca l)  
  each x l  
    pr (if x strv strv) 
defcall uca (l i)  if (0 <= i < len.l)    rep.l.0.i def (gens n l)  prn l  repeat n    zap! gen l    prn l def (gen l)  uca+collect+for i 0 (i < len.l) ++i    yield (next  (l i-1)  l.i  (l i+1)) 
def (next a b c)  if (and a c) not.b     (or a c)  b"
"import zlib, base64 b64 = b'''
eNrtVE1rwzAMvedXaKdeRn7ENrb21rHCzmrs1m49K9gOJv9+cko/HBcGg0LHcpOfnq2np0QL
2FuKgBbICDAoeoiKwEc0hqIUgLAxfV0tQJCdhQM7qh68kheswKeBt5ROYetTemYMCC3rii//
WMS3WkhXVyuFAaLT261JuBWwu4iDbvYp1tYzHVS68VEIObwFgaDB0KizuFs38aSdqKv3TgcJ
uPYdn2B1opwIpeKE53qPftxRd88Y6uoVbdPzWxznrQ3ZUi3DudQ/bcELbevqM32iCIrj3IIh
W6plOJf6L6xaajZjzqW/qAsKIvITBGs9Nm3glboZzkVP5l6Y+0bHLnedD0CttIyrpEU5Kv7N
Mz3XkPBc/TSN3yxGiqMiipHRekycK0ZwMhM8jerGC9zuZaoTho3kMKSfJjLaF8v8wLzmXMqM
zJvGew/jnZPzclA08yAkikegDTTUMfzwDXBcwoE='''print(zlib.decompress(base64.b64decode(b64)).decode(strv, strv))animals = [        (strv, strv),        (strv, strv),        (strv, strv),        (strv, strv),        (strv, strv),        (strv, strv),        (strv, strv),        (strv, strv)] for i, (animal, lyric) in enumerate(animals):    print ""There was an old lady who swallowed a {}.{}"".format(animal, lyric)     if animal == strv: break     for (predator, _), (prey, _) in zip(animals[i:0:-1], animals[i-1::-1]):        print ""She swallowed the {} to catch the {}"".format(predator, prey)     if animal != strv: print animals[0][1]  
    print  
"
"import re _vowels = 'AEIOU' def replace_at(text, position, fromlist, tolist):    for f, t in zip(fromlist, tolist):        if text[position:].startswith(f):            return ''.join([text[:position],                            t,                            text[position+len(f):]])    return text def replace_end(text, fromlist, tolist):    for f, t in zip(fromlist, tolist):        if text.endswith(f):            return text[:-len(f)] + t    return text def nysiis(name):    name = re.sub(r'', '', name).upper()    name = replace_at(name, 0, ['MAC', 'KN', 'K', 'PH', 'PF', 'SCH'],                               ['MCC', 'N',  'C', 'FF', 'FF', 'SSS'])    name = replace_end(name, ['EE', 'IE', 'DT', 'RT', 'RD', 'NT', 'ND'],                             ['Y',  'Y',  'D',  'D',  'D',  'D',  'D'])    key, key1 = name[0], ''    i = 1    while i < len(name):        #print(i, name, key1, key)        n_1, n = name[i-1], name[i]        n1_ = name[i+1] if i+1 < len(name) else ''        name = replace_at(name, i, ['EV'] + list(_vowels), ['AF'] + ['A']*5)        name = replace_at(name, i, 'QZM', 'GSN')        name = replace_at(name, i, ['KN', 'K'], ['N', 'C'])        name = replace_at(name, i, ['SCH', 'PH'], ['SSS', 'FF'])        if n == 'H' and (n_1 not in _vowels or n1_ not in _vowels):            name = ''.join([name[:i], n_1, name[i+1:]])        if n == 'W' and n_1 in _vowels:            name = ''.join([name[:i], 'A', name[i+1:]])        if key and key[-1] != name[i]:            key += name[i]        i += 1    key = replace_end(key, ['S', 'AY', 'A'], ['', 'Y', ''])    return key1 + key if __name__ == '__main__':    names = ['Bishop', 'Carlson', 'Carr', 'Chapman', 'Franklin',             'Greene', 'Harper', 'Jacobs', 'Larson', 'Lawrence',             'Lawson', 'Louis, XVI', 'Lynch', 'Mackenzie', 'Matthews',             'McCormack', 'McDaniel', 'McDonald', 'Mclaughlin', 'Morrison',             strv, strv, 'Richards', 'Silva', 'Watkins',             'Wheeler', 'Willis', 'brown, sr', 'browne, III', 'browne, IV',             'knight', 'mitchell', strv]    for name in names:        print('%15s: %s' % (name, nysiis(name)))"
"



 import pickle class Entity:	def __init__(self):		self.name = strv	def printName(self):		print self.name class Person(Entity): #OldMan inherits from Entity	def __init__(self): #override constructor		self.name = strv  instance1 = Person()instance1.printName() instance2 = Entity()instance2.printName() target = file(strv, strv) 
 
pickle.dump((instance1, instance2), target) 
target.close() 
print strv 
target = file(strv) 
i1, i2 = pickle.load(target)print strv i1.printName()i2.printName()"
"from sys import stdin, stdout def char_in(): return stdin.read(1)def char_out(c): stdout.write(c) def odd(prev = lambda: None):	a = char_in()	if not a.isalpha():		prev()		char_out(a)		return a != '.' 	
	def clos():		char_out(a)		prev() 	return odd(clos) def even():	while True:		c = char_in()		char_out(c)		if not c.isalpha(): return c != '.' e = Falsewhile odd() if e else even():	e = not efrom sys import stdin, stdout def char_in(): return stdin.read(1)def char_out(c): stdout.write(c) def odd():	a = char_in()	if a.isalpha():		r = odd()		char_out(a)		return r 	
	def clos():		char_out(a)		return a != '.' 	return clos def even():	while True:		c = char_in()		char_out(c)		if not c.isalpha(): return c != '.' e = Falsewhile odd()() if e else even():	e = not efrom sys import stdin, stdout def fwd(c):    if c.isalpha():        return [stdout.write(c), (yield from fwd((yield f)))][1]    else:        return c def rev(c):    if c.isalpha():        return [(yield from rev((yield r))), stdout.write(c)][0]    else:        return c def fw():    while True:        stdout.write((yield from fwd((yield r)))) def re():    while True:        stdout.write((yield from rev((yield f)))) f = fw()r = re()next(f)next(r) coro = fwhile True:    c = stdin.read(1)    if not c:        break    coro = coro.send(c)"
"from numpy import * ##################################################################
def Legendre(n,x):	x=array(x)	if (n==0):		return x*0+1.0	elif (n==1):		return x	else:		return ((2.0*n-1.0)*x*Legendre(n-1,x)-(n-1)*Legendre(n-2,x))/n ##################################################################
def DLegendre(n,x):	x=array(x)	if (n==0):		return x*0	elif (n==1):		return x*0+1.0	else:		return (n/(x**2-1.0))*(x*Legendre(n,x)-Legendre(n-1,x))##################################################################
def LegendreRoots(polyorder,tolerance=1e-20):	if polyorder<2:		err=1 
	else:		roots=[]		
		for i in range(1,int(polyorder)/2 +1):			x=cos(pi*(i-0.25)/(polyorder+0.5))			error=10*tolerance		        iters=0		        while (error>tolerance) and (iters<1000):		                dx=-Legendre(polyorder,x)/DLegendre(polyorder,x)		                x=x+dx		                iters=iters+1		                error=abs(dx)			roots.append(x)		
		roots=array(roots)		if polyorder%2==0:			roots=concatenate( (-1.0*roots, roots[::-1]) )		else:			roots=concatenate( (-1.0*roots, [0.0], roots[::-1]) )		err=0 
	return [roots, err]##################################################################
def GaussLegendreWeights(polyorder):	W=[]	[xis,err]=LegendreRoots(polyorder)	if err==0:		W=2.0/( (1.0-xis**2)*(DLegendre(polyorder,xis)**2) )		err=0	else:		err=1 
	return [W, xis, err]##################################################################



#def GaussLegendreQuadrature(func, polyorder, a, b):	[Ws,xs, err]= GaussLegendreWeights(polyorder)	if err==0:		ans=(b-a)*0.5*sum( Ws*func( (b-a)*0.5*xs+ (b+a)*0.5 ) )	else: 		
		err=1		ans=None	return [ans,err]##################################################################
def func(x):	return exp(x)##################################################################
 order=5[Ws,xs,err]=GaussLegendreWeights(order)if err==0:	print strv, order	print strv, xs	print strv, Wselse:	print strv 
[ans,err]=GaussLegendreQuadrature(func , order, -3,3)if err==0:	print strv, anselse:	print strv"
"'''
number reversal game
    Given a jumbled list of the numbers 1 to 9
    Show the list.
    Ask the player how many digits from the left to reverse.
    Reverse those digits then ask again.
    until all the digits end up in ascending order.
 
''' import random print(__doc__)data, trials = list('123456789'), 0while data == sorted(data):    random.shuffle(data)while data != sorted(data):    trials += 1    flip = int(input('#%2i: LIST: %r Flip how many?: ' % (trials, ' '.join(data))))    data[:flip] = reversed(data[:flip]) print('You took %2i attempts to put the digits in order!' % trials)"
"from collections import namedtupleimport math class I(namedtuple('Imprecise', 'value, delta')):    'Imprecise type: I(value=0.0, delta=0.0)'      __slots__ = ()      def __new__(_cls, value=0.0, delta=0.0):        'Defaults to 0.0 ± delta'        return super().__new__(_cls, float(value), abs(float(delta)))     def reciprocal(self):        return I(1. / self.value, self.delta / (self.value**2))      def __str__(self):        'Shorter form of Imprecise as string'        return 'I(%g, %g)' % self     def __neg__(self):        return I(-self.value, self.delta)     def __add__(self, other):        if type(other) == I:            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )        try:            c = float(other)        except:            return NotImplemented        return I(self.value + c, self.delta)     def __sub__(self, other):        return self + (-other)     def __radd__(self, other):        return I.__add__(self, other)     def __mul__(self, other):        if type(other) == I:            #if id(self) == id(other):                
            a1,b1 = self            a2,b2 = other            f = a1 * a2            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )        try:            c = float(other)        except:            return NotImplemented        return I(self.value * c, self.delta * c)     def __pow__(self, other):        if type(other) == I:            return NotImplemented        try:            c = float(other)        except:            return NotImplemented        f = self.value ** c        return I(f, f * c * (self.delta / self.value))     def __rmul__(self, other):        return I.__mul__(self, other)     def __truediv__(self, other):        if type(other) == I:            return self.__mul__(other.reciprocal())        try:            c = float(other)        except:            return NotImplemented        return I(self.value / c, self.delta / c)     def __rtruediv__(self, other):        return other * self.reciprocal()     __div__, __rdiv__ = __truediv__, __rtruediv__ Imprecise = I def distance(p1, p2):    x1, y1 = p1    x2, y2 = p2    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5 x1 = I(100, 1.1)x2 = I(200, 2.2)y1 = I( 50, 1.2)y2 = I(100, 2.3) p1, p2 = (x1, y1), (x2, y2)print(""Distance between points  p1: %s  and p2: %s  = %r"" % (      p1, p2, distance(p1, p2)))"
"from fractions import Fraction def left_rect(f,x,h):  return f(x) def mid_rect(f,x,h):  return f(x + h/2) def right_rect(f,x,h):  return f(x+h) def trapezium(f,x,h):  return (f(x) + f(x+h))/2.0 def simpson(f,x,h):  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0 def cube(x):  return x*x*x def reciprocal(x):  return 1/x def identity(x):  return x def integrate( f, a, b, steps, meth):   h = (b-a)/steps   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))   return ival   
for a, b, steps, func in ((0., 1., 100, cube), (1., 100., 1000, reciprocal)):    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps) = %r' %              (func.__name__, rule.__name__, a, b, steps,               integrate( func, a, b, steps, rule)))    a, b = Fraction.from_float(a), Fraction.from_float(b)    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps and fractions) = %r' %              (func.__name__, rule.__name__, a, b, steps,               float(integrate( func, a, b, steps, rule)))) 
for a, b, steps, func in ((0., 5000., 5000000, identity),                          (0., 6000., 6000000, identity)):    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps) = %r' %              (func.__name__, rule.__name__, a, b, steps,               integrate( func, a, b, steps, rule)))    a, b = Fraction.from_float(a), Fraction.from_float(b)    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps and fractions) = %r' %              (func.__name__, rule.__name__, a, b, steps,               float(integrate( func, a, b, steps, rule))))for a, b, steps, func in ((0., 1., 100, cube), (1., 100., 1000, reciprocal)):    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps) = %r' %              (func.__name__, rule.__name__, a, b, steps,               integrate( func, a, b, steps, rule)))    a, b = Fraction.from_float(a), Fraction.from_float(b)    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps and fractions) = %r' %              (func.__name__, rule.__name__, a, b, steps,               float(integrate( func, a, b, steps, rule)))) 
for a, b, steps, func in ((1., 5000., 5000000, identity),                          (1., 6000., 6000000, identity)):    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps) = %r' %              (func.__name__, rule.__name__, a, b, steps,               integrate( func, a, b, steps, rule)))    a, b = Fraction.from_float(a), Fraction.from_float(b)    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):        print('%s integrated using %s  from %r to %r (%i steps and fractions) = %r' %              (func.__name__, rule.__name__, a, b, steps,               float(integrate( func, a, b, steps, rule))))def faster_simpson(f, a, b, steps):   h = (b-a)/float(steps)   a1 = a+h/2   s1 = sum( f(a1+i*h) for i in range(0,steps))   s2 = sum( f(a+i*h) for i in range(1,steps))   return (h/6.0)*(f(a)+f(b)+4.0*s1+2.0*s2)"
x = Noneif x is None:  print strvelse:  print strv
"from decimal import Decimal, getcontext def nthroot (n, A, precision):    getcontext().prec = precision     n = Decimal(n)    x_0 = A / n #step 1: make a while guess.    x_1 = 1     #need it to exist before step 2    while True:        #step 2:        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))        if x_0 == x_1:            return x_1print nthroot(5, 34, 10)print nthroot(10,42, 20)print nthroot(2, 5, 400)"
"def nonoblocks(blocks, cells):    if not blocks or blocks[0] == 0:        yield [(0, 0)]    else:        assert sum(blocks) + len(blocks)-1 <= cells, \            'Those blocks will not fit in those cells'        blength, brest = blocks[0], blocks[1:]      
        minspace4rest = sum(1+b for b in brest)     
        
        for bpos in range(0, cells - minspace4rest - blength + 1):            if not brest:                
                yield [(bpos, blength)]            else:                
                
                
                offset = bpos + blength +1                nonoargs = (brest, cells - offset)  
                
                for subpos in nonoblocks(*nonoargs):                    
                    rest = [(offset + bp, bl) for bp, bl in subpos]                    
                    vec = [(bpos, blength)] + rest                    yield vec def pblock(vec, cells):    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'    vector = ['_'] * cells    for ch, (bp, bl) in enumerate(vec, ord('A')):        for i in range(bp, bp + bl):            vector[i] = chr(ch) if vector[i] == '_' else'?'    return '|' + '|'.join(vector) + '|'  if __name__ == '__main__':    for blocks, cells in (            ([2, 1], 5),            ([], 5),            ([8], 10),            ([2, 3, 2, 3], 15),           
           
           
            ([2, 3], 5),            ):        print('Configuration:    %s # %i cells and %r blocks' % (pblock([], cells), cells, blocks))                print('  Possibilities:')        for i, vector in enumerate(nonoblocks(blocks, cells)):            print('   ', pblock(vector, cells))        print('  A total of %i Possible configurations.' % (i+1))"
">>> for n in range(34):	print strv.format(n, n, n, n)	#The following would give the same output, and, 	#due to the outer brackets, works with Python 3.0 too	#print ( strv.format(n=n) )        0   0  0  0      1   1  1  1     10   2  2  2     11   3  3  3    100   4  4  4    101   5  5  5    110   6  6  6    111   7  7  7   1000  10  8  8   1001  11  9  9   1010  12 10  A   1011  13 11  B   1100  14 12  C   1101  15 13  D   1110  16 14  E   1111  17 15  F  10000  20 16 10  10001  21 17 11  10010  22 18 12  10011  23 19 13  10100  24 20 14  10101  25 21 15  10110  26 22 16  10111  27 23 17  11000  30 24 18  11001  31 25 19  11010  32 26 1A  11011  33 27 1B  11100  34 28 1C  11101  35 29 1D  11110  36 30 1E  11111  37 31 1F 100000  40 32 20 100001  41 33 21>>>for n in range(34):	print strv % (n, n, n)n = 33#Python 3.x:print(bin(n), oct(n), n, hex(n)) 

 #Python 2.x:#print oct(n), n, hex(n)
"
"from itertools import izip def gen_row(w, s):    strv    def gen_seg(o, sp):        if not o:            return [[2] * sp]        return [[2] * x + o[0] + tail                for x in xrange(1, sp - len(o) + 2)                for tail in gen_seg(o[1:], sp - x)]     return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]  def deduce(hr, vr):    strv    def allowable(row):        return reduce(lambda a, b: [x | y for x, y in izip(a, b)], row)     def fits(a, b):        return all(x & y for x, y in izip(a, b))     def fix_col(n):        strvSee if any value in a given column is fixed;
        if so, mark its corresponding row for future fixup.strv        c = [x[n] for x in can_do]        cols[n] = [x for x in cols[n] if fits(x, c)]        for i, x in enumerate(allowable(cols[n])):            if x != can_do[i][n]:                mod_rows.add(i)                can_do[i][n] &= x     def fix_row(n):        strv        c = can_do[n]        rows[n] = [x for x in rows[n] if fits(x, c)]        for i, x in enumerate(allowable(rows[n])):            if x != can_do[n][i]:                mod_cols.add(i)                can_do[n][i] &= x     def show_gram(m):        
        
        for x in m:            print strv.join(strv[i] for i in x)        print     w, h = len(vr), len(hr)    rows = [gen_row(w, x) for x in hr]    cols = [gen_row(h, x) for x in vr]    can_do = map(allowable, rows)     
    mod_rows, mod_cols = set(), set(xrange(w))     while mod_cols:        for i in mod_cols:            fix_col(i)        mod_cols = set()        for i in mod_rows:            fix_row(i)        mod_rows = set()     if all(can_do[i][j] in (1, 2) for j in xrange(w) for i in xrange(h)):        print strv 
    else:        print strv     
    
    
    out = [0] * h     def try_all(n = 0):        if n >= h:            for j in xrange(w):                if [x[j] for x in out] not in cols[j]:                    return 0            show_gram(out)            return 1        sol = 0        for x in rows[n]:            out[n] = x            sol += try_all(n + 1)        return sol     n = try_all()    if not n:        print strv    elif n == 1:        print strv    else:        print n, strv    print  def solve(p, show_runs=True):    s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]         for l in p.splitlines()]    if show_runs:        print strv, s[0]        print strv, s[1]    deduce(s[0], s[1])  def main():    
    fn = strv    for p in (x for x in open(fn).read().split("""") if x):        solve(p)     print strv    solve(""B B A AB B A A"")     print strv    solve(""B A AA A A"") main()"
">>> text = '100'>>> for base in range(2,21):    print (strv            % (text, base, int(text, base)))  String '100' in base 2 is  4 in base 10String '100' in base 3 is  9 in base 10String '100' in base 4 is  16 in base 10String '100' in base 5 is  25 in base 10String '100' in base 6 is  36 in base 10String '100' in base 7 is  49 in base 10String '100' in base 8 is  64 in base 10String '100' in base 9 is  81 in base 10String '100' in base 10 is  100 in base 10String '100' in base 11 is  121 in base 10String '100' in base 12 is  144 in base 10String '100' in base 13 is  169 in base 10String '100' in base 14 is  196 in base 10String '100' in base 15 is  225 in base 10String '100' in base 16 is  256 in base 10String '100' in base 17 is  289 in base 10String '100' in base 18 is  324 in base 10String '100' in base 19 is  361 in base 10String '100' in base 20 is  400 in base 10"
"def ncsub(seq, s=0):    if seq:        x = seq[:1]        xs = seq[1:]        p2 = s % 2        p1 = not p2        return [x + ys for ys in ncsub(xs, s + p1)] + ncsub(xs, s + p2)    else:        return [[]] if s >= 3 else []from sys import argvimport psyco def C(n, k):    result = 1    for d in xrange(1, k+1):        result *= n        n -= 1        result /= d    return result 
nsubs = lambda n: sum(C(n, k) for k in xrange(3, n+1)) def ncsub(seq):    n = len(seq)    result = [None] * nsubs(n)    pos = 0     for i in xrange(1, 2 ** n):        S  = []        nc = False        for j in xrange(n + 1):            k = i >> j            if k == 0:                if nc:                    result[pos] = S                    pos += 1                break            elif k % 2:                S.append(seq[j])            elif S:                nc = True    return result from sys import argvimport psycopsyco.full()n = 10 if len(argv) < 2 else int(argv[1])print len( ncsub(range(1, n)) )"
"TENS = [None, None, strv, strv, strv,        strv, strv, strv, strv, strv]SMALL = [strv, strv, strv, strv, strv, strv,         strv, strv, strv, strv, strv, strv,         strv, strv, strv, strv,         strv, strv, strv, strv]HUGE = [None, None] + [h + strv                        for h in (strv, strv, strv, strv, strv, strv,                                   strv, strv, strv, strv)] def nonzero(c, n, connect=''):    return strv if n == 0 else connect + c + spell_integer(n) def last_and(num):    if ',' in num:        pre, last = num.rsplit(',', 1)        if ' and ' not in last:            last = ' and' + last        num = ''.join([pre, ',', last])    return num def big(e, n):    if e == 0:        return spell_integer(n)    elif e == 1:        return spell_integer(n) + strv    else:        return spell_integer(n) + strv + HUGE[e] def base1000_rev(n):    
    
    while n != 0:        n, r = divmod(n, 1000)        yield r def spell_integer(n):    if n < 0:        return strv + spell_integer(-n)    elif n < 20:        return SMALL[n]    elif n < 100:        a, b = divmod(n, 10)        return TENS[a] + nonzero(strv, b)    elif n < 1000:        a, b = divmod(n, 100)        return SMALL[a] + strv + nonzero(strv, b, ' and')    else:        num = strv.join([big(e, x) for e, x in                         enumerate(base1000_rev(n)) if x][::-1])        return last_and(num) if __name__ == '__main__':    
    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):        print('%+4i -> %s' % (n, spell_integer(n)))    print('')       n = 201021002001    while n:        print('%-12i -> %s' % (n, spell_integer(n)))        n //= -10    print('%-12i -> %s' % (n, spell_integer(n)))    print('')"
"i = int('1a',16)  
digits = strvdef baseN(num,b):   return (((num == 0) and  strv )            or ( baseN(num // b, b).lstrip(strv)                 + digits[num % b])) 
def baseN(num,b):  if num == 0: return strv  result = strv  while num != 0:    num, d = divmod(num, b)    result += digits[d]  return result[::-1] 
 k = 26s = baseN(k,16) 
"
"#!/bin/pythonfrom __future__ import print_function def EncodeNegBase(n, b): #Converts from decimal	if n == 0:		return strv	out = []	while n != 0:		n, rem = divmod(n, b)		if rem < 0:			n += 1			rem -= b		out.append(rem)	return strv.join(map(str, out[::-1])) def DecodeNegBase(nstr, b): #Converts to decimal	if nstr == strv:		return 0 	total = 0	for i, ch in enumerate(nstr[::-1]):		total += int(ch) * b**i	return total if __name__==strv: 	print (strv)	result = EncodeNegBase(10, -2)	print (result)	if DecodeNegBase(result, -2) == 10: print (strv)	else: print (strv) 	print (strv)	result = EncodeNegBase(146, -3)	print (result)	if DecodeNegBase(result, -3) == 146: print (strv)	else: print (strv) 	print (strv)	result = EncodeNegBase(15, -10)	print (result)	if DecodeNegBase(result, -10) == 15: print (strv)	else: print (strv)"
"def makeList(separator):    counter = 1     def makeItem(item):        nonlocal counter        result = str(counter) + separator + item + """"        counter += 1        return result     return makeItem(strv) + makeItem(strv) + makeItem(strv) print(makeList(strv))"
"import time, calendar, sched, winsound duration = 750      
freq = 1280         
bellchar = ""2407""watches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',') def gap(n=1):    time.sleep(n * duration / 1000)off = gap def on(n=1):    winsound.Beep(freq, n * duration) def bong():    on(); off(0.5) def bongs(m):    for i in range(m):        print(bellchar, end=' ')        bong()        if i % 2:            print('  ', end='')            off(0.5)    print('') scheds =  sched.scheduler(time.time, time.sleep) def ships_bell(now=None):    def adjust_to_half_hour(atime):        atime[4] = (atime[4] // 30) * 30        atime[5] = 0        return atime     debug = now is not None    rightnow = time.gmtime()    if not debug:        now = adjust_to_half_hour( list(rightnow) )    then = now[::]    then[4] += 30    hr, mn = now[3:5]    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)    b += 1    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')    if debug:        print(strv % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')    else:        print(strv % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')    bongs(b)    if not debug:        scheds.enterabs(calendar.timegm(then), 0, ships_bell)        #print(time.struct_time(then))        scheds.run() def dbg_tester():    for h in range(24):        for m in (0, 30):            if (h,m) == (24,30): break            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )  if __name__ == '__main__':    ships_bell()"
"#!/path/to/python
 import sysprint strv.join(sys.argv[1:])"
 import syswith open(sys.argv[0]) as quine:    code = raw_input(strv)    if code == quine.read():        print(strv)    else:        print(strv)  _='_=%r;print (_%%_==input())';print (_%_==input()) 
"from __future__ import print_functionfrom itertools import count, islice def narcissists():    for digits in count(0):        digitpowers = [i**digits for i in range(10)]        for n in range(int(10**(digits-1)), 10**digits):            div, digitpsum = n, 0            while div:                div, mod = divmod(div, 10)                digitpsum += digitpowers[mod]            if n == digitpsum:                yield n for i, n in enumerate(islice(narcissists(), 25), 1):    print(n, end=' ')    if i % 5 == 0: print() print()try:    import psyco    psyco.full()except:    pass class Narcissistics:    def __init__(self, max_len):        self.max_len = max_len        self.power = [0] * 10        self.dsum = [0] * (max_len + 1)        self.count = [0] * 10        self.len = 0        self.ord0 = ord('0')     def check_perm(self, out = [0] * 10):        for i in xrange(10):            out[i] = 0         s = str(self.dsum[0])        for d in s:            c = ord(d) - self.ord0            out[c] += 1            if out[c] > self.count[c]:                return         if len(s) == self.len:            print self.dsum[0],     def narc2(self, pos, d):        if not pos:            self.check_perm()            return         while True:            self.dsum[pos - 1] = self.dsum[pos] + self.power[d]            self.count[d] += 1            self.narc2(pos - 1, d)            self.count[d] -= 1            if d == 0:                break            d -= 1     def show(self, n):        self.len = n        for i in xrange(len(self.power)):            self.power[i] = i ** n        self.dsum[n] = 0        print strv % n,        self.narc2(n, 9)        print def main():    narc = Narcissistics(14)    for i in xrange(1, narc.max_len + 1):        narc.show(i) main()"
"from spell_integer import spell_integer, SMALL, TENS, HUGE def int_from_words(num):    words = num.replace(',','').replace(' and ', ' ').replace('-', ' ').split()    if words[0] == 'minus':        negmult = -1        words.pop(0)    else:        negmult = 1    small, total = 0, 0    for word in words:        if word in SMALL:            small += SMALL.index(word)        elif word in TENS:            small += TENS.index(word) * 10        elif word == 'hundred':            small *= 100        elif word == 'thousand':            total += small * 1000            small = 0        elif word in HUGE:            total += small * 1000 ** HUGE.index(word)            small = 0        else:            raise ValueError(strv % (word, num))    return negmult * (total + small)  if __name__ == '__main__':    
    for n in range(-10000, 10000, 17):        assert n == int_from_words(spell_integer(n))     for n in range(20):        assert 13**n == int_from_words(spell_integer(13**n))     print('#### These tests show <==> for a successful round trip, otherwise <??>##')     for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):        txt = spell_integer(n)        num = int_from_words(txt)        print('%+4i <%s> %s' % (n, '==' if n == num else '??', txt))    print('')       n = 201021002001    while n:        txt = spell_integer(n)        num = int_from_words(txt)        print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))        n //= -10    txt = spell_integer(n)    num = int_from_words(txt)    print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))    print('')"
"def subtract(x, y):    return x - y subtract(5, 3)         
subtract(y = 3, x = 5) 
>>> from __future__ import print_function>>> >>> def show_args(defparam1, defparam2 = 'default value', *posparam, **keyparam):  strv  print (strv)  print (strv, defparam1)  print (strv, defparam2)   print (strv)  if posparam:    n = 0    for p in posparam:      print (strv, n, strv, p)      n += 1  else:    print (strv)   print (strv)  if keyparam:    for k,v in sorted(keyparam.items()):      print (strv, k, strv, v)  else:    print (strv)  >>> show_args('POSITIONAL', 'ARGUMENTS')  Default Parameters:    defparam1 value is: POSITIONAL    defparam2 value is: ARGUMENTS  Positional Arguments:    <None>  Keyword Arguments (by sorted key name):    <None>>>> show_args(defparam2='ARGUMENT', defparam1='KEYWORD')  Default Parameters:    defparam1 value is: KEYWORD    defparam2 value is: ARGUMENT  Positional Arguments:    <None>  Keyword Arguments (by sorted key name):    <None>>>> show_args( *('SEQUENCE', 'ARGUMENTS') )  Default Parameters:    defparam1 value is: SEQUENCE    defparam2 value is: ARGUMENTS  Positional Arguments:    <None>  Keyword Arguments (by sorted key name):    <None>>>> show_args( **{'defparam2':'ARGUMENTS', 'defparam1':'MAPPING'} )  Default Parameters:    defparam1 value is: MAPPING    defparam2 value is: ARGUMENTS  Positional Arguments:    <None>  Keyword Arguments (by sorted key name):    <None>>>> show_args('ONLY DEFINE defparam1 ARGUMENT')  Default Parameters:    defparam1 value is: ONLY DEFINE defparam1 ARGUMENT    defparam2 value is: default value  Positional Arguments:    <None>  Keyword Arguments (by sorted key name):    <None>>>> show_args('POSITIONAL', 'ARGUMENTS',               'EXTRA', 'POSITIONAL', 'ARGUMENTS')  Default Parameters:    defparam1 value is: POSITIONAL    defparam2 value is: ARGUMENTS  Positional Arguments:    positional argument: 0 is: EXTRA    positional argument: 1 is: POSITIONAL    positional argument: 2 is: ARGUMENTS  Keyword Arguments (by sorted key name):    <None>>>> show_args('POSITIONAL', 'ARGUMENTS',               kwa1='EXTRA', kwa2='KEYWORD', kwa3='ARGUMENTS')  Default Parameters:    defparam1 value is: POSITIONAL    defparam2 value is: ARGUMENTS  Positional Arguments:    <None>  Keyword Arguments (by sorted key name):    keyword argument: kwa1 is: EXTRA    keyword argument: kwa2 is: KEYWORD    keyword argument: kwa3 is: ARGUMENTS>>> show_args('POSITIONAL',               'ARGUMENTS', 'EXTRA', 'POSITIONAL', 'ARGUMENTS',               kwa1='EXTRA', kwa2='KEYWORD', kwa3='ARGUMENTS')  Default Parameters:    defparam1 value is: POSITIONAL    defparam2 value is: ARGUMENTS  Positional Arguments:    positional argument: 0 is: EXTRA    positional argument: 1 is: POSITIONAL    positional argument: 2 is: ARGUMENTS  Keyword Arguments (by sorted key name):    keyword argument: kwa1 is: EXTRA    keyword argument: kwa2 is: KEYWORD    keyword argument: kwa3 is: ARGUMENTS>>> 
>>> show_args('POSITIONAL', 'ARGUMENTS',               kwa1='EXTRA', kwa2='KEYWORD', kwa3='ARGUMENTS',               'EXTRA', 'POSITIONAL', 'ARGUMENTS')SyntaxError: non-keyword arg after keyword arg>>>"
"_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th'] def nth(n):    return strv % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th') if __name__ == '__main__':    for j in range(0,1001, 250):        print(' '.join(nth(i) for i in list(range(j, j+25))))#!/usr/bin/env python3 def ord(n):    try:        s = ['st', 'nd', 'rd'][(n-1)%10]        if (n-10)%100//10:            return str(n)+s    except IndexError:        pass    return str(n)+'th' if __name__ == '__main__':    print(*(ord(n) for n in range(26)))    print(*(ord(n) for n in range(250,266)))    print(*(ord(n) for n in range(1000,1026)))"
">>> import winsound>>> for note in [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]:	winsound.Beep(int(note+.5), 500)	>>> "
"

  from itertools import groupbyfrom unicodedata import decomposition, namefrom pprint import pprint as pp commonleaders = ['the'] 
replacements = {u'ß': 'ss',  
                u'ſ': 's',                u'ʒ': 's',                } hexdigits = set('0123456789abcdef')decdigits = set('0123456789')   
 def splitchar(c):    ' De-ligature. De-accent a char'    de = decomposition(c)    if de:        
        de = [d for d in de.split()                  if all(c.lower()                         in hexdigits for c in d)]        n = name(c, c).upper()        
        if len(de)> 1 and 'PRECEDE' in n:            
            de[1], de[0] = de[0], de[1]        tmp = [ unichr(int(k, 16)) for k in de]        base, others = tmp[0], tmp[1:]        if 'LIGATURE' in n:            
            base += others.pop(0)    else:        base = c    return base  def sortkeygen(s):    '''Generate 'natural' sort key for s
 
    Doctests:
        >>> sortkeygen('  some extra    spaces  ')
        [u'some extra spaces']
        >>> sortkeygen('CasE InseNsItIve')
        [u'case insensitive']
        >>> sortkeygen('The Wind in the Willows')
        [u'wind in the willows']
        >>> sortkeygen(u'62 ligature')
        [u'ij ligature']
        >>> sortkeygen(u'3575 upper/lower case Y with acute accent')
        [u'yy upper/lower case y with acute accent']
        >>> sortkeygen('foo9.txt')
        [u'foo', 9, u'.txt']
        >>> sortkeygen('x9y99')
        [u'x', 9, u'y', 99]
    '''    
    s = unicode(s).strip()    
    s = ' '.join(s.split())    
    s = s.lower()    
    words = s.split()    if len(words) > 1 and words[0] in commonleaders:        s = ' '.join( words[1:])    
    s = ''.join(splitchar(c) for c in s)    
    s = ''.join( replacements.get(ch, ch) for ch in s )    
    s = [ int(strv.join(g)) if isinteger else strv.join(g)          for isinteger,g in groupby(s, lambda x: x in decdigits)]     return s def naturalsort(items):    ''' Naturally sort a series of strings
 
    Doctests:
        >>> naturalsort(['The Wind in the Willows','The 40th step more',
                         'The 39 steps', 'Wanda'])
        ['The 39 steps', 'The 40th step more', 'Wanda', 'The Wind in the Willows']
 
    '''    return sorted(items, key=sortkeygen) if __name__ == '__main__':    import string     ns = naturalsort     print '
    txt = ['%signore leading spaces: 2%+i' % (' '*i, i-2) for i in range(4)]    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    txt = ['ignore m.a.s%s spaces: 2%+i' % (' '*i, i-2) for i in range(4)]    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    txt = ['Equiv.%sspaces: 3%+i' % (ch, i-3)           for i,ch in enumerate(reversed(string.whitespace))]    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    s = 'CASE INDEPENENT'    txt = [s[:i].lower() + s[i:] + ': 3%+i' % (i-3) for i in range(1,5)]    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    txt = ['foo100bar99baz0.txt', 'foo100bar10baz0.txt',           'foo1000bar99baz10.txt', 'foo1000bar99baz9.txt']    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    txt = ['The Wind in the Willows','The 40th step more',                         'The 39 steps', 'Wanda']    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    txt = ['Equiv. %s accents: 2%+i' % (ch, i-2)           for i,ch in enumerate(u'fdddyY')]    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    txt = [u'62 ligatured ij', 'no ligature',]    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; pp(sorted(txt))    print 'Naturally sorted:'; pp(ns(txt))     print '
    s = u'ʒſßs' 
    txt = ['Start with an %s: 2%+i' % (ch, i-2)           for i,ch in enumerate(s)]    print 'Text strings:'; pp(txt)    print 'Normally sorted :'; print ''.join(sorted(txt))    print 'Naturally sorted:'; print ''.join(ns(txt))"
"from itertools import permutations n = 8cols = range(n)for vec in permutations(cols):    if n == len(set(vec[i]+i for i in cols)) \         == len(set(vec[i]-i for i in cols)):        print ( vec )def board(vec):    print ("""".join('.' * i + 'Q' + '.' * (n-i-1) for i in vec) + ""==="")
BOARD_SIZE = 8 def under_attack(col, queens):    return col in queens or \           any(abs(col - x) == len(queens)-i for i,x in enumerate(queens)) def solve(n):    solutions = [[]]    for row in range(n):        solutions = [solution+[i+1]                       for solution in solutions                       for i in range(BOARD_SIZE)                       if not under_attack(i+1, solution)]    return solutions for answer in solve(BOARD_SIZE): print(list(enumerate(answer, start=1)))BOARD_SIZE = 8 def under_attack(col, queens):    return col in queens or \           any(abs(col - x) == len(queens)-i for i,x in enumerate(queens)) def solve(n):    solutions = [[]]    for row in range(n):        solutions = (solution+[i+1]                       for solution in solutions 
                                                 
                       for i in range(BOARD_SIZE)                       if not under_attack(i+1, solution))    return solutions answers = solve(BOARD_SIZE)first_answer = next(answers)print(list(enumerate(first_answer, start=1)))def queens(n):    a = list(range(n))    up = [True]*(2*n - 1)    down = [True]*(2*n - 1)    def sub(i):        if i == n:            yield tuple(a)        else:            for k in range(i, n):                j = a[k]                p = i + j                q = i - j + n - 1                if up[p] and down[q]:                    up[p] = down[q] = False                    a[i], a[k] = a[k], a[i]                    yield from sub(i + 1)                    up[p] = down[q] = True                    a[i], a[k] = a[k], a[i]    yield from sub(0) #Count solutions for n=8:sum(1 for p in queens(8))92def queens_lex(n):    a = list(range(n))    up = [True]*(2*n - 1)    down = [True]*(2*n - 1)    def sub(i):        if i == n:            yield tuple(a)        else:            for k in range(i, n):                a[i], a[k] = a[k], a[i]                j = a[i]                p = i + j                q = i - j + n - 1                if up[p] and down[q]:                    up[p] = down[q] = False                    yield from sub(i + 1)                    up[p] = down[q] = True            x = a[i]            for k in range(i + 1, n):                a[k - 1] = a[k]            a[n - 1] = x    yield from sub(0) next(queens(31))(0, 2, 4, 1, 3, 8, 10, 12, 14, 6, 17, 21, 26, 28, 25, 27, 24, 30, 7, 5, 29, 15, 13, 11, 9, 18, 22, 19, 23, 16, 20) next(queens_lex(31))(0, 2, 4, 1, 3, 8, 10, 12, 14, 5, 17, 22, 25, 27, 30, 24, 26, 29, 6, 16, 28, 13, 9, 7, 19, 11, 15, 18, 21, 23, 20) #Compare to A065188#1, 3, 5, 2, 4, 9, 11, 13, 15, 6, 8, 19, 7, 22, 10, 25, 27, 29, 31, 12, 14, 35, 37, ..."
"import threadingfrom time import sleep 

res = 2sema = threading.Semaphore(res) class res_thread(threading.Thread):	def run(self):		global res		n = self.getName()		for i in range(1, 4):			
			
			
			sema.acquire()			res = res - 1			print n, strv, res			sleep(2)                         
			res = res + 1			print n, strv, res			sema.release() 
for i in range(1, 5):	t = res_thread()	t.start()"
"import Image, ImageDraw image = Image.new(strv, (256, 256))drawingTool = ImageDraw.Draw(image) for x in range(256):    for y in range(256):        drawingTool.point((x, y), (0, x^y, 0)) del drawingToolimage.save(strv, strv)"
"def gcd(a, b):    while b != 0:        a, b = b, a % b    return a def lcm(a, b):    return (a*b) / gcd(a, b) def isPrime(p):    return (p > 1) and all(f == p for f,e in factored(p)) primeList = [2,3,5,7]def primes():    for p in primeList:        yield p    while 1:        p += 2        while not isPrime(p):            p += 2        primeList.append(p)        yield p def factored( a):    for p in primes():        j = 0        while a%p == 0:            a /= p            j += 1        if j > 0:            yield (p,j)        if a < p*p: break    if a > 1:        yield (a,1)  def multOrdr1(a,(p,e) ):    m = p**e    t = (p-1)*(p**(e-1)) 
    qs = [1,]    for f in factored(t):        qs = [ q * f[0]**j for j in range(1+f[1]) for q in qs ]    qs.sort()     for q in qs:        if pow( a, q, m )==1: break    return q  def multOrder(a,m):    assert gcd(a,m) == 1    mofs = (multOrdr1(a,r) for r in factored(m))    return reduce(lcm, mofs, 1)  if __name__ == strv:    print multOrder(37, 1000)        
    b = 10**20-1    print multOrder(2, b) 
    print multOrder(17,b) 
    b = 100001    print multOrder(54,b)    print pow( 54, multOrder(54,b),b)    if any( (1==pow(54,r, b)) for r in range(1,multOrder(54,b))):        print 'Exists a power r < 9090 where pow(54,r,b)==1'    else:        print 'Everything checks.'"
def F(n): return 1 if n == 0 else n - M(F(n-1))def M(n): return 0 if n == 0 else n - F(M(n-1)) print ([ F(n) for n in range(20) ])print ([ M(n) for n in range(20) ])
">>> import re>>> def ms2(txt=strv, sep=[strv, strv, strv]):	if not txt or not sep:		return []	ans = m = []	for m in re.finditer('(.*?)(?:' + '|'.join('('+re.escape(s)+')' for s in sep) + ')', txt):		ans += [m.group(1), (m.lastindex-2, m.start(m.lastindex))]	if m and txt[m.end(m.lastindex):]:		ans += [txt[m.end(m.lastindex):]]	return ans >>> ms2()['a', (1, 1), '', (0, 3), 'b', (2, 6), '', (1, 7), 'c']>>> ms2(txt=strv, sep=[strv, strv, strv])['a', (1, 1), '', (0, 3), '', (0, 4), 'b', (0, 6), '', (1, 7), 'c']def multisplit(text, sep):    lastmatch = i = 0    matches = []    while i < len(text):        for j, s in enumerate(sep):            if text[i:].startswith(s):                if i > lastmatch:                    matches.append(text[lastmatch:i])                matches.append((j, i))  
                lastmatch = i + len(s)                i += len(s)                break        else:            i += 1    if i > lastmatch:        matches.append(text[lastmatch:i])    return matches >>> multisplit('a!===b=!=c', ['==', '!=', '='])['a', (1, 1), (0, 3), 'b', (2, 6), (1, 7), 'c']>>> multisplit('a!===b=!=c', ['!=', '==', '='])['a', (0, 1), (1, 3), 'b', (2, 6), (0, 7), 'c'] def min_pos(List):	return List.index(min(List)) def find_all(S, Sub, Start = 0, End = -1, IsOverlapped = 0):	Res = []	if End == -1:		End = len(S)	if IsOverlapped:		DeltaPos = 1	else:		DeltaPos = len(Sub)	Pos = Start	while True:		Pos = S.find(Sub, Pos, End)		if Pos == -1:			break		Res.append(Pos)		Pos += DeltaPos	return Res def multisplit(S, SepList):	SepPosListList = []	SLen = len(S)	SepNumList = []	ListCount = 0	for i, Sep in enumerate(SepList):		SepPosList = find_all(S, Sep, 0, SLen, IsOverlapped = 1)		if SepPosList != []:			SepNumList.append(i)			SepPosListList.append(SepPosList)			ListCount += 1	if ListCount == 0:		return [S]	MinPosList = []	for i in range(ListCount):		MinPosList.append(SepPosListList[i][0])	SepEnd = 0	MinPosPos = min_pos(MinPosList)	Res = []	while True:		Res.append( S[SepEnd : MinPosList[MinPosPos]] )		Res.append([SepNumList[MinPosPos], MinPosList[MinPosPos]])		SepEnd = MinPosList[MinPosPos] + len(SepList[SepNumList[MinPosPos]])		while True:			MinPosPos = min_pos(MinPosList)			if MinPosList[MinPosPos] < SepEnd:				del SepPosListList[MinPosPos][0]				if len(SepPosListList[MinPosPos]) == 0:					del SepPosListList[MinPosPos]					del MinPosList[MinPosPos]					del SepNumList[MinPosPos]					ListCount -= 1					if ListCount == 0:						break				else:					MinPosList[MinPosPos] = SepPosListList[MinPosPos][0]			else:				break		if ListCount == 0:			break	Res.append(S[SepEnd:])	return Res  S = strvmultisplit(S, [strv, strv, strv]) 
multisplit(S, [strv, strv, strv]) 
"
"[Foo()] * n 
[Foo() for i in range(n)]"
"#!/bin/bashstrv strv strv print strv#!/bin/shstrv '''
if [ -L $0 ]; then
...
exec strv
exit 127
''' __doc__ = strv print strv"
"import numpy as np height = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63,    1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83]weight = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,    61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46] X = np.mat(height**np.arange(3)[:, None])y = np.mat(weight) print(y * X.T * (X*X.T).I)import numpy as np height = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63,    1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83]weight = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,    61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46] X = np.array(height)[:, None]**range(3)y = weight print(np.linalg.lstsq(X, y)[0])"
">>> from functools import reduce>>> from operator import mul>>> def mfac(n, m): return reduce(mul, range(n, 0, -m)) >>> for m in range(1, 11): print(strv % (m, [mfac(n, m) for n in range(1, 11)]))  1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800] 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840] 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280] 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120] 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50] 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40] 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30] 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20] 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]>>> >>> def mfac2(n, m): return n if n <= (m + 1) else n * mfac2(n - m, m) >>> for m in range(1, 6): print(strv % (m, [mfac2(n, m) for n in range(1, 11)]))  1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800] 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840] 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280] 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120] 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]>>> "
">>> from pprint import pprint as pp   
>>> from itertools import product>>> >>> def dict_as_mdarray(dimensions=(2, 3), init=0.0):...     return {indices: init for indices in product(*(range(i) for i in dimensions))}... >>> >>> mdarray = dict_as_mdarray((2, 3, 4, 5))>>> pp(mdarray){(0, 0, 0, 0): 0.0, (0, 0, 0, 1): 0.0, (0, 0, 0, 2): 0.0, (0, 0, 0, 3): 0.0, (0, 0, 0, 4): 0.0, (0, 0, 1, 0): 0.0,... (1, 2, 3, 0): 0.0, (1, 2, 3, 1): 0.0, (1, 2, 3, 2): 0.0, (1, 2, 3, 3): 0.0, (1, 2, 3, 4): 0.0}>>> mdarray[(0, 1, 2, 3)]0.0>>> mdarray[(0, 1, 2, 3)] = 6.78>>> mdarray[(0, 1, 2, 3)]6.78>>> mdarray[(0, 1, 2, 3)] = 5.4321>>> mdarray[(0, 1, 2, 3)]5.4321>>> pp(mdarray){(0, 0, 0, 0): 0.0, (0, 0, 0, 1): 0.0, (0, 0, 0, 2): 0.0,... (0, 1, 2, 2): 0.0, (0, 1, 2, 3): 5.4321, (0, 1, 2, 4): 0.0,... (1, 2, 3, 3): 0.0, (1, 2, 3, 4): 0.0}>>> import numpy as npa = np.array([[1, 2], [3, 4]], order=strv)b = np.array([[1, 2], [3, 4]], order=strv)np.reshape(a, (4,))             
np.reshape(b, (4,))             
np.reshape(b, (4,), order=strv)  
>>> from numpy import *>>> >>> mdarray = zeros((2, 3, 4, 5), dtype=int8, order='F') >>> mdarrayarray([[[[0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0]],         [[0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0]],         [[0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0]]],         [[[0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0]],         [[0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0]],         [[0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0],         [0, 0, 0, 0, 0]]]], dtype=int8)>>> mdarray[0, 1, 2, 3]0>>> mdarray[0, 1, 2, 3] = 123>>> mdarray[0, 1, 2, 3]123>>> mdarray[0, 1, 2, 3] = 666>>> mdarray[0, 1, 2, 3]-102>>> mdarray[0, 1, 2, 3] = 255>>> mdarray[0, 1, 2, 3]-1>>> mdarray[0, 1, 2, 3] = -128>>> mdarray[0, 1, 2, 3]-128>>> mdarrayarray([[[[   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0]],         [[   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0, -128,    0],         [   0,    0,    0,    0,    0]],         [[   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0]]],         [[[   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0]],         [[   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0]],         [[   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0],         [   0,    0,    0,    0,    0]]]], dtype=int8)>>> "
">>> size = 12>>> width = len(str(size**2))>>> for row in range(-1,size+1):	if row==0:		print(strv*width + strv+strv*((width+1)*size-1))	else:		print(strv.join(strv % ((width,) + ((strv,strv)      if row==-1 and col==0					              else (row,strv) if row>0   and col==0					              else (col,strv)  if row==-1					              else (strv,strv)   if row>col					              else (row*col,strv)))			       for col in range(size+1)))    x│  1   2   3   4   5   6   7   8   9  10  11  12 ───┼───────────────────────────────────────────────  1│  1   2   3   4   5   6   7   8   9  10  11  12   2│      4   6   8  10  12  14  16  18  20  22  24   3│          9  12  15  18  21  24  27  30  33  36   4│             16  20  24  28  32  36  40  44  48   5│                 25  30  35  40  45  50  55  60   6│                     36  42  48  54  60  66  72   7│                         49  56  63  70  77  84   8│                             64  72  80  88  96   9│                                 81  90  99 108  10│                                    100 110 120  11│                                        121 132  12│                                            144 >>> "
"import collectionsdef MostFreqKHashing(inputString, K):    occuDict = collections.defaultdict(int)    for c in inputString:        occuDict[c] += 1    occuList = sorted(occuDict.items(), key = lambda x: x[1], reverse = True)    outputStr = ''.join(c + str(cnt) for c, cnt in occuList[:K])    return outputStr  #If number of occurrence of the character is not more than 9def MostFreqKSimilarity(inputStr1, inputStr2):    similarity = 0    for i in range(0, len(inputStr1), 2):        c = inputStr1[i]        cnt1 = int(inputStr1[i + 1])        for j in range(0, len(inputStr2), 2):            if inputStr2[j] == c:                cnt2 = int(inputStr2[j + 1])                similarity += cnt1 + cnt2                break    return similarity def MostFreqKSDF(inputStr1, inputStr2, K, maxDistance):    return maxDistance - MostFreqKSimilarity(MostFreqKHashing(inputStr1,K), MostFreqKHashing(inputStr2,K))import collectionsdef MostFreqKHashing(inputString, K):    occuDict = collections.defaultdict(int)    for c in inputString:        occuDict[c] += 1    occuList = sorted(occuDict.items(), key = lambda x: x[1], reverse = True)    outputDict = collections.OrderedDict(occuList[:K])    #Return OrdredDict instead of string for faster lookup.    return outputDict  def MostFreqKSimilarity(inputStr1, inputStr2):    similarity = 0    for c, cnt1 in inputStr1.items():        #Reduce the time complexity of lookup operation to about O(1).        if c in inputStr2:             cnt2 = inputStr2[c]            similarity += cnt1 + cnt2    return similarity def MostFreqKSDF(inputStr1, inputStr2, K, maxDistance):    return maxDistance - MostFreqKSimilarity(MostFreqKHashing(inputStr1,K), MostFreqKHashing(inputStr2,K))str1 = strvstr2 = strvK = 2maxDistance = 100dict1 = MostFreqKHashing(str1, 2)print(strv%dict1)print(''.join(c + str(cnt) for c, cnt in dict1.items()))dict2 = MostFreqKHashing(str2, 2)print(strv%dict2)print(''.join(c + str(cnt) for c, cnt in dict2.items()))print(MostFreqKSDF(str1, str2, K, maxDistance))"
" import Tkinter as tk def showxy(event):    xm, ym = event.x, event.y    str1 = strv % (xm, ym)    
    root.title(str1)    
    x,y, delta = 100, 100, 10    frame.config(bg='red'                 if abs(xm - x) < delta and abs(ym - y) < delta                 else 'yellow') root = tk.Tk()frame = tk.Frame(root, bg= 'yellow', width=300, height=200)frame.bind(strv, showxy)frame.pack() root.mainloop()  #simple way of ,get cursor xy datafrom Tkinter import *win=Tk()win.geometry(strv)def xy(event):    xm, ym = event.x, event.y    xy_data = strv % (xm, ym)    lab=Label(win,text=xy_data)    lab.grid(row=0,column=0) win.bind(strv,xy)mainloop() "
"from __future__ import print_functionfrom string import ascii_lowercase SYMBOLTABLE = list(ascii_lowercase) def move2front_encode(strng, symboltable):    sequence, pad = [], symboltable[::]    for char in strng:        indx = pad.index(char)        sequence.append(indx)        pad = [pad.pop(indx)] + pad    return sequence def move2front_decode(sequence, symboltable):    chars, pad = [], symboltable[::]    for indx in sequence:        char = pad[indx]        chars.append(char)        pad = [pad.pop(indx)] + pad    return ''.join(chars) if __name__ == '__main__':    for s in ['broood', 'bananaaa', 'hiphophiphop']:        encode = move2front_encode(s, SYMBOLTABLE)        print('%14r encodes to %r' % (s, encode), end=', ')        decode = move2front_decode(encode, SYMBOLTABLE)        print('which decodes back to %r' % decode)        assert s == decode, 'Whoops!'def m2f_e(s, st):    return [[st.index(ch), st.insert(0, st.pop(st.index(ch)))][0] for ch in s] def m2f_d(sq, st):    return ''.join([st[i], st.insert(0, st.pop(i))][0] for i in sq) ST = list('abcdefghijklmnopqrstuvwxyz')for s in ['broood', 'bananaaa', 'hiphophiphop']:    encode = m2f_e(s, ST[::])    print('%14r encodes to %r' % (s, encode), end=', ')    decode = m2f_d(encode, ST[::])    print('decodes back to %r' % decode)    assert s == decode, 'Whoops!'"
"#!/usr/bin/env python 
 def meaning_of_life():  return 42 if __name__ == strv:  print(strv % meaning_of_life())#!/usr/bin/env python 
 from life import meaning_of_life print(strv % meaning_of_life())print(strv)"
">>> import random, math>>> throws = 1000>>> 4.0 * sum(math.hypot(*[random.random()*2-1	                 for q in [0,1]]) < 1              for p in xrange(throws)) / float(throws)3.1520000000000001>>> throws = 1000000>>> 4.0 * sum(math.hypot(*[random.random()*2-1	                 for q in [0,1]]) < 1              for p in xrange(throws)) / float(throws)3.1396359999999999>>> throws = 100000000>>> 4.0 * sum(math.hypot(*[random.random()*2-1	                 for q in [0,1]]) < 1              for p in xrange(throws)) / float(throws)3.1415666400000002 from random import randomfrom math import hypottry:    import psyco    psyco.full()except:    pass def pi(nthrows):    inside = 0    for i in xrange(nthrows):        if hypot(random(), random()) < 1:            inside += 1    return 4.0 * inside / nthrows for n in [10**4, 10**6, 10**7, 10**8]:    print strv % (n, pi(n))  import numpy as np n = input('Number of samples: ')print np.sum(np.random.rand(n)**2+np.random.rand(n)**2<1)/float(n)*4 "
">>> def extended_gcd(aa, bb):    lastremainder, remainder = abs(aa), abs(bb)    x, lastx, y, lasty = 0, 1, 1, 0    while remainder:        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)        x, lastx = lastx - quotient*x, x        y, lasty = lasty - quotient*y, y    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1) >>> def modinv(a, m):	g, x, y = extended_gcd(a, m)	if g != 1:		raise ValueError	return x % m >>> modinv(42, 2017)1969>>> "
"a = 2988348162058574136915891421498819466320163312926952423791023078876139b = 2351399303373464486466122544523690094744975233415544072992656881240319m = 10 ** 40print(pow(a, b, m))"
"import time, winsound #, sys char2morse = {                    strv: strv,      """": strv,     strv: strv,    strv: strv,            strv: strv,      strv: strv,     strv: strv,      strv: strv,           strv: strv,     strv: strv,     strv: strv,           strv: strv,      strv: strv,      strv: strv,      strv: strv,           strv: strv,      strv: strv,      strv: strv,      strv: strv,           strv: strv,      strv: strv,           strv: strv,     strv: strv,     strv: strv,      strv: strv,           strv: strv,           strv: strv,         strv: strv,       strv: strv,       strv: strv,           strv: strv,          strv: strv,       strv: strv,        strv: strv,           strv: strv,         strv: strv,       strv: strv,        strv: strv,           strv: strv,         strv: strv,         strv: strv,        strv: strv,           strv: strv,       strv: strv,        strv: strv,        strv: strv,           strv: strv,        strv: strv,       strv: strv,        strv: strv,           strv: strv,       strv: strv,           strv: strv,      strv: strv,     strv: strv, } e = 50      
f = 1280    
chargap = 1 
wordgap = 7 
 def gap(n=1):    time.sleep(n * e / 1000)off = gap def on(n=1):    winsound.Beep(f, n * e) def dit():    on(); off() def dah():    on(3); off() def bloop(n=3):    winsound.Beep(f//2, n * e) def windowsmorse(text):    for word in text.strip().upper().split():        for char in word:            for element in char2morse.get(char, '?'):                if element == '-':                    dah()                elif element == '.':                    dit()                else:                    bloop()            gap(chargap)        gap(wordgap) 
#with open(sys.argv[0], 'r') as thisfile:
 while True:    windowsmorse(input('A string to change into morse: ')) "
"import operatorimport functools @functools.total_orderingclass Mod:    __slots__ = ['val','mod']     def __init__(self, val, mod):        if not isinstance(val, int):            raise ValueError('Value must be integer')        if not isinstance(mod, int) or mod<=0:            raise ValueError('Modulo must be positive integer')        self.val = val % mod        self.mod = mod     def __repr__(self):        return 'Mod({}, {})'.format(self.val, self.mod)     def __int__(self):        return self.val     def __eq__(self, other):        if isinstance(other, Mod):            if self.mod == other.mod:                return self.val==other.val            else:                return NotImplemented        elif isinstance(other, int):            return self.val == other        else:            return NotImplemented     def __lt__(self, other):        if isinstance(other, Mod):            if self.mod == other.mod:                return self.val<other.val            else:                return NotImplemented        elif isinstance(other, int):            return self.val < other        else:            return NotImplemented     def _check_operand(self, other):        if not isinstance(other, (int, Mod)):            raise TypeError('Only integer and Mod operands are supported')        if isinstance(other, Mod) and self.mod != other.mod:            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))     def __pow__(self, other):        self._check_operand(other)        
        return Mod(pow(self.val, int(other), self.mod), self.mod)     def __neg__(self):        return Mod(self.mod - self.val, self.mod)     def __pos__(self):        return self 
     def __abs__(self):        return self 
 

def _make_op(opname):    op_fun = getattr(operator, opname)  
    def op(self, other):        self._check_operand(other)        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)    return op def _make_reflected_op(opname):    op_fun = getattr(operator, opname)    def op(self, other):        self._check_operand(other)        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)    return op 
for opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:    setattr(Mod, opname, _make_op(opname))    setattr(Mod, reflected_opname, _make_reflected_op(opname)) def f(x):    return x**100+x+1 print(f(Mod(10,13)))
"
"'''
I could understand the explanation of the Monty Hall problem
but needed some more evidence
 
References:
  http://www.bbc.co.uk/dna/h2g2/A1054306
  http://en.wikipedia.org/wiki/Monty_Hall_problem especially:
  http://en.wikipedia.org/wiki/Monty_Hall_problem#Increasing_the_number_of_doors
'''from random import randrange doors, iterations = 3,100000  
 def monty_hall(choice, switch=False, doorCount=doors):  
  door = [False]*doorCount  
  door[randrange(doorCount)] = True   chosen = door[choice]   unpicked = door  del unpicked[choice]   
  
  
  alternative = True in unpicked   if switch:    return alternative  else:    return chosen print ""Monty Hall problem simulation:""print doors, strv, iterations, ""iterations."" print strv,print sum(monty_hall(randrange(3), switch=False)          for x in range(iterations)),print strv, iterations, strvprint strv,print sum(monty_hall(randrange(3), switch=True)          for x in range(iterations)),print strv, iterations, ""times.""import random #1 represents a car #0 represent a goat stay = 0  #amount won if stay in the same positionswitch = 0 
 for i in range(1000):    lst = [1,0,0]           
    random.shuffle(lst)     
     ran = random.randrange(3) 
     user = lst[ran] #storing the random guess      del(lst[ran]) 
     huh = 0    for i in lst: 
        if i ==0:            del(lst[huh]) 
            break        huh+=1     if user ==1: 
        stay+=1     if lst[0] == 1: 
        switch+=1 print(strv,stay)print(strv,switch)#Done by Sam Witton 09/04/2014"
" '''
Minesweeper game.
 
    There is an n by m grid that has a random number of between 20% to 60%
    of randomly hidden mines that need to be found. 
 
    Positions in the grid are modified by entering their coordinates
    where the first coordinate is horizontal in the grid and the second
    vertical. The top left of the grid is position 1,1; the bottom right is
    at n,m.
 
    * The total number of mines to be found is shown at the beginning of the
    game.
    * Each mine occupies a single grid point, and its position is initially
    unknown to the player
    * The grid is shown as a rectangle of characters between moves.
    * You are initially shown all grids as obscured, by a single dot '.'
    * You may mark what you think is the position of a mine which will show
    as a '?'
    * You can mark what you think is free space by entering its coordinates.
    :*  If the point is free space then it is cleared, as are any adjacent
    points that are also free space- this is repeated recursively for
    subsequent adjacent free points unless that point is marked as a mine
    or is a mine.
    ::*   Points marked as a mine show as a '?'.
    ::*   Other free points show as an integer count of the number of adjacent
    true mines in its immediate neighbourhood, or as a single space ' ' if the
    free point is not adjacent to any true mines.
    * Of course you loose if you try to clear space that starts on a mine.
    * You win when you have correctly identified all mines.
 
 
    When prompted you may:
        Toggle where you think a mine is at position x, y:
          m <x> <y>
        Clear the grid starting at position x, y (and print the result):
          c <x> <y>
        Print the grid so far:
          p
        Resign
          r
    Resigning will first show the grid with an 'N' for unfound true mines, a
    'Y' for found true mines and a '?' for where you marked clear space as a
    mine 
 
'''  gridsize  = (6, 4)minerange = (0.2, 0.6)  try:    raw_inputexcept:    raw_input = input import randomfrom itertools import productfrom pprint import pprint as pp  def gridandmines(gridsize=gridsize, minerange=minerange):    xgrid, ygrid = gridsize    minmines, maxmines = minerange    minecount = xgrid * ygrid        minecount = random.randint(int(minecount*minmines), int(minecount*maxmines))    grid = set(product(range(xgrid), range(ygrid)))    mines = set(random.sample(grid, minecount))    show = {xy:'.' for xy in grid}    return grid, mines, show def printgrid(show, gridsize=gridsize):    xgrid, ygrid = gridsize    grid = ''.join(''.join(show[(x,y)] for x in range(xgrid))                     for y in range(ygrid))    print( grid ) def resign(showgrid, mines, markedmines):    for m in mines:        showgrid[m] = 'Y' if m in markedmines else 'N' def clear(x,y, showgrid, grid, mines, markedmines):    if showgrid[(x, y)] == '.':        xychar = str(sum(1                         for xx in (x-1, x, x+1)                         for yy in (y-1, y, y+1)                         if (xx, yy) in mines ))        if xychar == '0': xychar = '.'        showgrid[(x,y)] = xychar        for xx in (x-1, x, x+1):            for yy in (y-1, y, y+1):                xxyy = (xx, yy)                if ( xxyy != (x, y)                     and xxyy in grid                     and xxyy not in mines | markedmines ):                    clear(xx, yy, showgrid, grid, mines, markedmines) if __name__ == '__main__':    grid, mines, showgrid = gridandmines()    markedmines = set([])    print( __doc__ )    print( 'There are %i true mines of fixed position in the grid' % len(mines) )    printgrid(showgrid)    while markedmines != mines:        inp = raw_input('m x y/c x y/p/r: ').strip().split()        if inp:            if inp[0] == 'm':                x, y = [int(i)-1 for i in inp[1:3]]                if (x,y) in markedmines:                    markedmines.remove((x,y))                    showgrid[(x,y)] = '.'                else:                    markedmines.add((x,y))                    showgrid[(x,y)] = '?'            elif inp[0] == 'p':                printgrid(showgrid)            elif inp[0] == 'c':                x, y = [int(i)-1 for i in inp[1:3]]                if (x,y) in mines | markedmines:                    print( 'KLABOOM!! You hit a mine.' )                    resign(showgrid, mines, markedmines)                    printgrid(showgrid)                    break                clear(x,y, showgrid, grid, mines, markedmines)                printgrid(showgrid)            elif inp[0] == 'r':                print( 'Resigning!' )                resign(showgrid, mines, markedmines)                printgrid(showgrid)                break     print( 'You got %i and missed %i of the %i mines'           % (len(mines.intersection(markedmines)),              len(markedmines.difference(mines)),              len(mines)) )"
" #lang Pythonimport time def main(bpm = 72, bpb = 4):    sleep = 60.0 / bpm    counter = 0    while True:        counter += 1        if counter % bpb:            print 'tick'        else:            print 'TICK'        time.sleep(sleep)   main()  "
"import timeimport threading 
sem = threading.Semaphore(4) workers = []running = 1  def worker():    me = threading.currentThread()    while 1:        sem.acquire()        try:            if not running:                break            print '%s acquired semaphore' % me.getName()            time.sleep(2.0)        finally:            sem.release()        time.sleep(0.01) 
 
for i in range(10):    t = threading.Thread(name=str(i), target=worker)    workers.append(t)    t.start() 
try:    while 1:        time.sleep(0.1)except KeyboardInterrupt:    running = 0    for t in workers:        t.join()"
" from macropy.core.macros import *from macropy.core.quotes import macros, q, ast, u macros = Macros() @macros.exprdef expand(tree, **kw):    addition = 10    return q[lambda x: x * ast[tree] + u[addition]]  func = expand[1 + 2]print func(5) "
">>> def middle_three_digits(i):	s = str(abs(i))	length = len(s)	assert length >= 3 and length % 2 == 1, strv	mid = length // 2	return s[mid-1:mid+2] >>> passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]>>> failing = [1, 2, -1, -10, 2002, -2002, 0]>>> for x in passing + failing:	try:		answer = middle_three_digits(x)	except AssertionError as error:		answer = error	print(strv % (x, answer))  middle_three_digits(123) returned: '123'middle_three_digits(12345) returned: '234'middle_three_digits(1234567) returned: '345'middle_three_digits(987654321) returned: '654'middle_three_digits(10001) returned: '000'middle_three_digits(-10001) returned: '000'middle_three_digits(-123) returned: '123'middle_three_digits(-100) returned: '100'middle_three_digits(100) returned: '100'middle_three_digits(-12345) returned: '234'middle_three_digits(1) returned: AssertionError('Need odd and >= 3 digits',)middle_three_digits(2) returned: AssertionError('Need odd and >= 3 digits',)middle_three_digits(-1) returned: AssertionError('Need odd and >= 3 digits',)middle_three_digits(-10) returned: AssertionError('Need odd and >= 3 digits',)middle_three_digits(2002) returned: AssertionError('Need odd and >= 3 digits',)middle_three_digits(-2002) returned: AssertionError('Need odd and >= 3 digits',)middle_three_digits(0) returned: AssertionError('Need odd and >= 3 digits',)>>> "
"import random _mrpt_num_trials = 5 
 def is_probable_prime(n):    strv
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
 
    >>> is_probable_prime(1)
    Traceback (most recent call last):
        ...
    AssertionError
    >>> is_probable_prime(2)
    True
    >>> is_probable_prime(3)
    True
    >>> is_probable_prime(4)
    False
    >>> is_probable_prime(5)
    True
    >>> is_probable_prime(123456789)
    False
 
    >>> primes_under_1000 = [i for i in range(2, 1000) if is_probable_prime(i)]
    >>> len(primes_under_1000)
    168
    >>> primes_under_1000[-10:]
    [937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
 
    >>> is_probable_prime(6438080068035544392301298549614926991513861075340134
3291807343952413826484237063006136971539473913409092293733259038472039
7133335969549256322620979036686633213903952966175107096769180017646161
851573147596390153)
    True
 
    >>> is_probable_prime(7438080068035544392301298549614926991513861075340134
3291807343952413826484237063006136971539473913409092293733259038472039
7133335969549256322620979036686633213903952966175107096769180017646161
851573147596390153)
    False
    strv    assert n >= 2    
    if n == 2:        return True    
    if n % 2 == 0:        return False    
    
    s = 0    d = n-1    while True:        quotient, remainder = divmod(d, 2)        if remainder == 1:            break        s += 1        d = quotient    assert(2**s * d == n-1)     
    def try_composite(a):        if pow(a, d, n) == 1:            return False        for i in range(s):            if pow(a, 2**i * d, n) == n-1:                return False        return True 
     for i in range(_mrpt_num_trials):        a = random.randrange(2, n)        if try_composite(a):            return False     return True 
def _try_composite(a, d, n, s):    if pow(a, d, n) == 1:        return False    for i in range(s):        if pow(a, 2**i * d, n) == n-1:            return False    return True 
 def is_prime(n, _precision_for_huge_n=16):    if n in _known_primes or n in (0, 1):        return True    if any((n % p) == 0 for p in _known_primes):        return False    d, s = n - 1, 0    while not d % 2:        d, s = d >> 1, s + 1    
    if n < 1373653:         return not any(_try_composite(a, d, n, s) for a in (2, 3))    if n < 25326001:         return not any(_try_composite(a, d, n, s) for a in (2, 3, 5))    if n < 118670087467:         if n == 3215031751:             return False        return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7))    if n < 2152302898747:         return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11))    if n < 3474749660383:         return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11, 13))    if n < 341550071728321:         return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11, 13, 17))    
    return not any(_try_composite(a, d, n, s)                    for a in _known_primes[:_precision_for_huge_n]) _known_primes = [2, 3]_known_primes += [x for x in range(5, 1000, 2) if is_prime(x)]"
"from ctypes import Structure, c_int rs232_9pin  = strv.split()rs232_25pin = ( strv                strv                strv ).split() class RS232_9pin(Structure):    _fields_ = [(__, c_int, 1) for __ in rs232_9pin]  class RS232_25pin(Structure):    _fields_ = [(__, c_int, 1) for __ in rs232_25pin]"
"def _menu(items):    for indexitem in enumerate(items):        print (strv % indexitem) def _ok(reply, itemcount):    try:        n = int(reply)        return 0 <= n < itemcount    except:        return False def selector(items, prompt):    'Prompt to select an item from the items'    if not items: return ''    reply = -1    itemcount = len(items)    while not _ok(reply, itemcount):        _menu(items)        
        reply = raw_input(prompt).strip()    return items[int(reply)] if __name__ == '__main__':    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']    item = selector(items, 'Which is from the three pigs: ')    print (strv + item)"
"import Image, ImageFilterim = Image.open('image.ppm') median = im.filter(ImageFilter.MedianFilter(3))median.save('image2.ppm')"
">>> from array import array>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello 2641'),	('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]>>> for typecode, initializer in argslist:	a = array(typecode, initializer)	print a	del a  array('l')array('c', 'hello world')array('u', u'hello 2641')array('l', [1, 2, 3, 4, 5])array('d', [1.0, 2.0, 3.1400000000000001])>>>"
"import hashlibprint hashlib.new(strv,raw_input().encode('utf-16le')).hexdigest().upper()"
">>> import hashlib>>> 
>>> tests = (  (bstrv, 'd41d8cd98f00b204e9800998ecf8427e'),  (bstrv, '0cc175b9c0f1b6a831c399e269772661'),  (bstrv, '900150983cd24fb0d6963f7d28e17f72'),  (bstrv, 'f96b697d7cb7938d525a2f31aaf161d0'),  (bstrv, 'c3fcd3d76192e4007dfb496cca67e13b'),  (bstrv, 'd174ab98d277d9f5a5611c2c9f419d9f'),  (bstrv, '57edf4a22be3c955ac49da2e2107b67a') )>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden >>> >>> import hashlib>>> print hashlib.md5(strv).hexdigest()e38ca1d920c4b8b8d3946b2c72f01680>>> import md5>>> print md5.md5(strv).hexdigest()e38ca1d920c4b8b8d3946b2c72f01680"
"import math rotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,                  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,                  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,                  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21] constants = [int(abs(math.sin(i+1)) * 2**32) & 0xFFFFFFFF for i in range(64)] init_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476] functions = 16*[lambda b, c, d: (b & c) | (~b & d)] + \            16*[lambda b, c, d: (d & b) | (~d & c)] + \            16*[lambda b, c, d: b ^ c ^ d] + \            16*[lambda b, c, d: c ^ (b | ~d)] index_functions = 16*[lambda i: i] + \                  16*[lambda i: (5*i + 1)%16] + \                  16*[lambda i: (3*i + 5)%16] + \                  16*[lambda i: (7*i)%16] def left_rotate(x, amount):    x &= 0xFFFFFFFF    return ((x<<amount) | (x>>(32-amount))) & 0xFFFFFFFF def md5(message):     message = bytearray(message) #copy our input into a mutable buffer    orig_len_in_bits = (8 * len(message)) & 0xffffffffffffffff    message.append(0x80)    while len(message)%64 != 56:        message.append(0)    message += orig_len_in_bits.to_bytes(8, byteorder='little')     hash_pieces = init_values[:]     for chunk_ofst in range(0, len(message), 64):        a, b, c, d = hash_pieces        chunk = message[chunk_ofst:chunk_ofst+64]        for i in range(64):            f = functions[i](b, c, d)            g = index_functions[i](i)            to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder='little')            new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) & 0xFFFFFFFF            a, b, c, d = d, new_b, b, c        for i, val in enumerate([a, b, c, d]):            hash_pieces[i] += val            hash_pieces[i] &= 0xFFFFFFFF     return sum(x<<(32*i) for i, x in enumerate(hash_pieces)) def md5_to_hex(digest):    raw = digest.to_bytes(16, byteorder='little')    return '{:032x}'.format(int.from_bytes(raw, byteorder='big')) if __name__=='__main__':    demo = [bstrv, bstrv, bstrv, bstrv, bstrv,            bstrv,            bstrv]    for message in demo:        print(md5_to_hex(md5(message)),' <= ""',message.decode('ascii'),'""', sep='') "
" 
 def Dijkstra(Graph, source):    '''
        +   +---+---+
        | 0   1   2 |
        +---+   +   +
        | 3   4 | 5  
        +---+---+---+
 
        >>> graph = (        # or ones on the diagonal
        ...     (0,1,0,0,0,0,),
        ...     (1,0,1,0,1,0,),
        ...     (0,1,0,0,0,1,),
        ...     (0,0,0,0,1,0,),
        ...     (0,1,0,1,0,0,),
        ...     (0,0,1,0,0,0,),
        ... )
        ...
        >>> Dijkstra(graph, 0)
        ([0, 1, 2, 3, 2, 3], [1e+140, 0, 1, 4, 1, 2])
        >>> display_solution([1e+140, 0, 1, 4, 1, 2])
        5<2<1<0
    '''    
    infinity = float('infinity')    n = len(graph)    dist = [infinity]*n   
    previous = [infinity]*n 
    dist[source] = 0        
    Q = list(range(n)) 
    while Q:           
        u = min(Q, key=lambda n:dist[n])                 
        Q.remove(u)        if dist[u] == infinity:            break 
        for v in range(n):               
            if Graph[u][v] and (v in Q): 
                alt = dist[u] + Graph[u][v]                if alt < dist[v]:       
                    dist[v] = alt                    previous[v] = u    return dist,previous def display_solution(predecessor):    cell = len(predecessor)-1    while cell:        print(cell,end='<')        cell = predecessor[cell]    print(0) "
"def solve(tri):    while len(tri) > 1:        t0 = tri.pop()        t1 = tri.pop()        tri.append([max(t0[i], t0[i+1]) + t for i,t in enumerate(t1)])    return tri[0][0]  data = strv                55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93strv print solve([map(int, row.split()) for row in data.splitlines()])from itertools import imap f = lambda x, y, z: x + max(y, z)g = lambda xs, ys: list(imap(f, ys, xs, xs[1:]))data = [map(int, row.split()) for row in open(strv)][::-1]print reduce(g, data)[0]"
"from random import shuffle, randrange def make_maze(w = 16, h = 8):    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]    ver = [[strv] * w + ['|'] for _ in range(h)] + [[]]    hor = [[strv] * w + ['+'] for _ in range(h + 1)]     def walk(x, y):        vis[y][x] = 1         d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]        shuffle(d)        for (xx, yy) in d:            if vis[yy][xx]: continue            if xx == x: hor[max(y, yy)][x] = strv            if yy == y: ver[y][max(x, xx)] = strv            walk(xx, yy)     walk(randrange(w), randrange(h))     s = strv    for (a, b) in zip(hor, ver):        s += ''.join(a + [''] + b + [''])    return s if __name__ == '__main__':    print(make_maze())"
">>> from operator import mul>>> def matrixMul(m1, m2):  return map(    lambda row:      map(        lambda *column:          sum(map(mul, row, column)),        *m2),    m1) >>> def identity(size):	size = range(size)	return [[(i==j)*1 for i in size] for j in size] >>> def matrixExp(m, pow):	assert pow>=0 and int(pow)==pow, strv	accumulator = identity(len(m))	for i in range(pow):		accumulator = matrixMul(accumulator, m)	return accumulator >>> def printtable(data):	for row in data:		print ' '.join('%-5s' % ('%s' % cell) for cell in row)  >>> m = [[3,2], [2,1]]>>> for i in range(5):	print '%i:' % i	printtable( matrixExp(m, i) )   0:1     0    0     1     1:3     2    2     1     2:13    8    8     5     3:55    34   34    21    4:233   144  144   89   >>> printtable( matrixExp(m, 10) )1346269 832040832040 514229>>>"
"from itertools import permutationsfrom operator import mulfrom math import fsumfrom spermutations import spermutations def prod(lst):    return reduce(mul, lst, 1) def perm(a):    n = len(a)    r = range(n)    s = permutations(r)    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s) def det(a):    n = len(a)    r = range(n)    s = spermutations(n)    return fsum(sign * prod(a[i][sigma[i]] for i in r)                for sigma, sign in s) if __name__ == '__main__':    from pprint import pprint as pp     for a in (             [             [1, 2],              [3, 4]],              [             [1, 2, 3, 4],             [4, 5, 6, 7],             [7, 8, 9, 10],             [10, 11, 12, 13]],                     [             [ 0,  1,  2,  3,  4],             [ 5,  6,  7,  8,  9],             [10, 11, 12, 13, 14],             [15, 16, 17, 18, 19],             [20, 21, 22, 23, 24]],        ):        print('')        pp(a)        print('Perm: %s Det: %s' % (perm(a), det(a)))"
"a=((1,  1,  1,   1), 
     (2,  4,  8,  16),     (3,  9, 27,  81),     (4, 16, 64, 256)) b=((  4  , -3  ,  4/3.,  -1/4. ), 
     (-13/3., 19/4., -7/3.,  11/24.),     (  3/2., -2.  ,  7/6.,  -1/4. ),     ( -1/6.,  1/4., -1/6.,   1/24.))   def MatrixMul( mtx_a, mtx_b):    tpos_b = zip( *mtx_b)    rtn = [[ sum( ea*eb for ea,eb in zip(a,b)) for b in tpos_b] for a in mtx_a]    return rtn  v = MatrixMul( a, b ) print 'v = ('for r in v:    print '[',     for val in r:        print '%8.2f '%val,     print ']'print ')'  u = MatrixMul(b,a) print 'u = 'for r in u:    print '[',     for val in r:        print '%8.2f '%val,     print ']'print ')'from operator import mul def matrixMul(m1, m2):  return map(    lambda row:      map(        lambda *column:          sum(map(mul, row, column)),        *m2),    m1)def mm(A, B):    return [[sum(x * B[i][col] for i,x in enumerate(row)) for col in range(len(B[0]))] for row in A] import numpy as npnp.dot(a,b)#or if a is an arraya.dot(b)"
" import ostargetfile = strvos.rename(os.path.realpath(targetfile), os.path.realpath(targetfile)+strv)f = open(os.path.realpath(targetfile), strv)f.write(strv)f.close() "
">>> def maprange( a, b, s):	(a1, a2), (b1, b2) = a, b	return  b1 + ((s - a1) * (b2 - b1) / (a2 - a1)) >>> for s in range(11):	print(strv % (s, maprange( (0, 10), (-1, 0), s)))   0 maps to -1 1 maps to -0.9 2 maps to -0.8 3 maps to -0.7 4 maps to -0.6 5 maps to -0.5 6 maps to -0.4 7 maps to -0.3 8 maps to -0.2 9 maps to -0.110 maps to 0>>> from fractions import Fraction>>> for s in range(11):	print(strv % (s, maprange( (0, 10), (-1, 0), Fraction(s))))   0 maps to -1 1 maps to -9/10 2 maps to -4/5 3 maps to -7/10 4 maps to -3/5 5 maps to -1/2 6 maps to -2/5 7 maps to -3/10 8 maps to -1/5 9 maps to -1/1010 maps to 0>>> "
" from errno import EEXISTfrom os import mkdir, curdirfrom os.path import split, exists def mkdirp(path, mode=0777):    head, tail = split(path)    if not tail:        head, tail = split(head)    if head and tail and not exists(head):        try:            mkdirp(head, mode)        except OSError as e:            
            if e.errno != EEXIST:                raise        if tail == curdir:  
            return    try:        mkdir(path, mode)    except OSError as e:        
        if e.errno != EEXIST:            raise  def mkdirp(path):    try:        os.makedirs(path)    except OSError as exc: 
        if exc.errno == errno.EEXIST and os.path.isdir(path):            pass        else: raise  def mkdirp(path):    os.makedirs(path, exist_ok=True) "
" k8 = [	14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] k7 = [	15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]k6 = [	10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]k5 = [	 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]k4 = [	 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]k3 = [	12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]k2 = [	 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]k1 = [	13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ] k87 = [0] * 256k65 = [0] * 256k43 = [0] * 256k21 = [0] * 256 def kboxinit():	for i in range(256):		k87[i] = k8[i >> 4] << 4 | k7[i & 15]		k65[i] = k6[i >> 4] << 4 | k5[i & 15]		k43[i] = k4[i >> 4] << 4 | k3[i & 15]		k21[i] = k2[i >> 4] << 4 | k1[i & 15] def f(x):	x = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |	      k43[x>> 8 & 255] <<  8 | k21[x & 255] )	return x<<11 | x>>(32-11)"
"#!/usr/bin/env pythonimport syssys.setrecursionlimit(1025) def a(in_k, x1, x2, x3, x4, x5):    k = [in_k]    def b():        k[0] -= 1        return a(k[0], b, x1, x2, x3, x4)    return x4() + x5() if k[0] <= 0 else b() x = lambda i: lambda: iprint(a(10, x(1), x(-1), x(-1), x(1), x(0)))  #!/usr/bin/env pythonimport syssys.setrecursionlimit(1025) def a(k, x1, x2, x3, x4, x5):    def b():        b.k -= 1        return a(b.k, b, x1, x2, x3, x4)    b.k = k    return x4() + x5() if b.k <= 0 else b() x = lambda i: lambda: iprint(a(10, x(1), x(-1), x(-1), x(1), x(0)))  #!/usr/bin/env pythonimport syssys.setrecursionlimit(1025) def A(k, x1, x2, x3, x4, x5):    def B():        nonlocal k        k -= 1        return A(k, B, x1, x2, x3, x4)    return x4() + x5() if k <= 0 else B() print(A(10, lambda: 1, lambda: -1, lambda: -1, lambda: 1, lambda: 0))"
"m=((1,  1,  1,   1),   (2,  4,  8,  16),   (3,  9, 27,  81),   (4, 16, 64, 256),   (5, 25,125, 625))print(zip(*m))

"
"function mandelbrot(a)    z = 0    for i=1:50        z = z^2 + a    end    return zend for y=1.0:-0.05:-1.0    for x=-2.0:0.0315:0.5        abs(mandelbrot(complex(x, y))) < 2 ? print(strv) : print(strv)    end    println()endusing Images @inline function hsv2rgb(h, s, v)    const c = v * s    const x = c * (1 - abs(((h/60) % 2) - 1))    const m = v - c     const r,g,b =        if h < 60            (c, x, 0)        elseif h < 120            (x, c, 0)        elseif h < 180            (0, c, x)        elseif h < 240            (0, x, c)        elseif h < 300            (x, 0, c)        else            (c, 0, x)        end     (r + m), (b + m), (g + m)end function mandelbrot()     const w, h = 1000, 1000     const zoom  = 0.5    const moveX = 0    const moveY = 0     const img = Array(RGB{Float64}, h, w)    const maxIter = 30     for x in 1:w        for y in 1:h            i = maxIter            const c = Complex(                (2*x - w) / (w * zoom) + moveX,                (2*y - h) / (h * zoom) + moveY            )            z = c            while abs(z) < 2 && (i -= 1) > 0                z = z^2 + c            end            const r,g,b = hsv2rgb(i / maxIter * 360, 1, i / maxIter)            img[y,x] = RGB{Float64}(r, g, b)        end    end     save(strv, img)end mandelbrot()
try:    from functools import reduceexcept:    pass  def mandelbrot(a):    return reduce(lambda z, _: z * z + a, range(50), 0) def step(start, step, iterations):    return (start + (i * step) for i in range(iterations)) rows = ((strv if abs(mandelbrot(complex(x, y))) < 2 else strv        for x in step(-2.0, .0315, 80))        for y in step(1, -.05, 41)) print("""".join(strv.join(row) for row in rows))  import math def mandelbrot(z , c , n=40):    if abs(z) > 1000:        return float(strv)    elif n > 0:        return mandelbrot(z ** 2 + c, c, n - 1)     else:        return z ** 2 + c print("""".join([strv.join([strv if not math.isnan(mandelbrot(0, x + 1j * y).real) else strv                 for x in [a * 0.02 for a in range(-80, 30)]])                  for y in [a * 0.05 for a in range(-20, 20)]])     ) from pylab import *from numpy import NaN def m(a):	z = 0	for n in range(1, 100):		z = z**2 + a		if abs(z) > 2:			return n	return NaN X = arange(-2, .5, .002)Y = arange(-1,  1, .002)Z = zeros((len(Y), len(X))) for iy, y in enumerate(Y):	print (iy, strv, len(Y))	for ix, x in enumerate(X):		Z[iy,ix] = m(x + 1j * y) imshow(Z, cmap = plt.cm.prism, interpolation = 'none', extent = (X.min(), X.max(), Y.min(), Y.max()))xlabel(strv)ylabel(strv)savefig(strv)show()"
">>> def magic(n):    for row in range(1, n + 1):        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in                       (n * ((row + col - 1 + n // 2) % n) +                       ((row + 2 * col - 2) % n) + 1                       for col in range(1, n + 1))))    print('All sum to magic number %i' % ((n * n + 1) * n // 2))  >>> for n in (5, 3, 7):	print('Order %i=======' % n)	magic(n)   Order 5=======17 24  1  8 1523  5  7 14 16 4  6 13 20 2210 12 19 21  311 18 25  2  9 All sum to magic number 65 Order 3=======8 1 63 5 74 9 2 All sum to magic number 15 Order 7=======30 39 48  1 10 19 2838 47  7  9 18 27 2946  6  8 17 26 35 37 5 14 16 25 34 36 4513 15 24 33 42 44  421 23 32 41 43  3 1222 31 40 49  2 11 20 All sum to magic number 175>>> "
"import ctypesimport osfrom ctypes import c_ubyte, c_int code = bytes([0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3]) code_size = len(code)
if (os.name == 'posix'):    import mmap    executable_map = mmap.mmap(-1, code_size, mmap.MAP_PRIVATE | mmap.MAP_ANON, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)    
    executable_map.write(code)    
    
    func_address = ctypes.addressof(c_ubyte.from_buffer(executable_map))elif (os.name == 'nt'):    
    code_buffer = ctypes.create_string_buffer(code)    PAGE_EXECUTE_READWRITE = 0x40  
    MEM_COMMIT = 0x1000    executable_buffer_address = ctypes.windll.kernel32.VirtualAlloc(0, code_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)    if (executable_buffer_address == 0):        print('Warning: Failed to enable code execution, call will likely cause a protection fault.')        func_address = ctypes.addressof(code_buffer)    else:        ctypes.memmove(executable_buffer_address, code_buffer, code_size)        func_address = executable_buffer_addresselse:    
    code_buffer = ctypes.create_string_buffer(code)    func_address = ctypes.addressof(code_buffer) prototype = ctypes.CFUNCTYPE(c_int, c_ubyte, c_ubyte) 
func = prototype(func_address)                        
res = func(7,12)print(res) "
"import requests for addr in ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21',        'D4:F4:6F:C9:EF:8D', '23:45:67']:    vendor = requests.get('http://api.macvendors.com/' + addr).text    print(addr, vendor)"
"import re 
#try: input = raw_input#except: pass template = '''<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.''' def madlibs(template):    print('The story template is:' + template)    fields = sorted(set( re.findall('<[^>]+>', template) ))    values = input('Input a comma-separated list of words to replace the following items'                   '  %s: ' % ','.join(fields)).split(',')    story = template    for f,v in zip(fields, values):        story = story.replace(f, v)    print('The story becomes:' + story) madlibs(template)"
"def compress(uncompressed):    strv     
    dict_size = 256    dictionary = dict((chr(i), i) for i in xrange(dict_size))    
     w = strv    result = []    for c in uncompressed:        wc = w + c        if wc in dictionary:            w = wc        else:            result.append(dictionary[w])            
            dictionary[wc] = dict_size            dict_size += 1            w = c     
    if w:        result.append(dictionary[w])    return result  def decompress(compressed):    strv    from cStringIO import StringIO     
    dict_size = 256    dictionary = dict((chr(i), chr(i)) for i in xrange(dict_size))    
     
    
    result = StringIO()    w = compressed.pop(0)    result.write(w)    for k in compressed:        if k in dictionary:            entry = dictionary[k]        elif k == dict_size:            entry = w + w[0]        else:            raise ValueError('Bad compressed k: %s' % k)        result.write(entry)         
        dictionary[dict_size] = w + entry[0]        dict_size += 1         w = entry    return result.getvalue()  
compressed = compress('TOBEORNOTTOBEORTOBEORNOT')print (compressed)decompressed = decompress(compressed)print (decompressed)"
"from __future__ import print_function def lgen(even=False, nmax=1000000):    start = 2 if even else 1    n, lst = 1, list(range(start, nmax + 1, 2))    lenlst = len(lst)    yield lst[0]    while n < lenlst and lst[n] < lenlst:        yield lst[n]        n, lst = n + 1, [j for i,j in enumerate(lst, 1) if i % lst[n]]        lenlst = len(lst)    
    for i in lst[n:]:        yield ifrom itertools import isliceimport sys, re class ArgumentError(Exception):    passdef arghandler(argstring):    match_obj = re.match( rstrv(?mx)
    (?:
      (?P<SINGLE>
         (?: ^ (?P<SINGLEL> + ) (?:  |  ,  lucky ) * $ )
        |(?: ^ (?P<SINGLEE> + ) (?:  |  ,  evenLucky ) * $ )
      )
     |(?P<KTH>
         (?: ^ (?P<KTHL> +  + ) (?:  |  lucky ) * $ )
        |(?: ^ (?P<KTHE> +  + ) (?:  |  evenLucky ) * $ )
      )
     |(?P<RANGE>
         (?: ^ (?P<RANGEL> +  -+ ) (?:  |  lucky ) * $ )
        |(?: ^ (?P<RANGEE> +  -+ ) (?:  |  evenLucky ) * $ )
      )
    )strv, argstring)     if match_obj:        
        SINGLEL = match_obj.group('SINGLEL')        SINGLEE = match_obj.group('SINGLEE')        KTHL = match_obj.group('KTHL')        KTHE = match_obj.group('KTHE')        RANGEL = match_obj.group('RANGEL')        RANGEE = match_obj.group('RANGEE')        if SINGLEL:             j = int(SINGLEL)            assert 0 < j < 10001, strv            print(strv % j, end=' ')            print( list(islice(lgen(), j-1, j))[0] )        elif SINGLEE:             j = int(SINGLEE)            assert 0 < j < 10001, strv            print(strv % j, end=' ')            print( list(islice(lgen(even=True), j-1, j))[0] )        elif KTHL:             j, k = [int(num) for num in KTHL.split()]            assert 0 < j < 10001, strv            assert 0 < k < 10001 and k > j, strv            print(strv % (j, k), end=' ')            for n, luck in enumerate(lgen(), 1):                if n > k: break                if n >=j: print(luck, end = ', ')            print('')        elif KTHE:             j, k = [int(num) for num in KTHE.split()]            assert 0 < j < 10001, strv            assert 0 < k < 10001 and k > j, strv            print(strv % (j, k), end=' ')            for n, luck in enumerate(lgen(even=True), 1):                if n > k: break                if n >=j: print(luck, end = ', ')            print('')        elif RANGEL:             j, k = [int(num) for num in RANGEL.split()]            assert 0 < j < 10001, strv            assert 0 < -k < 10001 and -k > j, strv            k = -k            print(strv % (j, k), end=' ')            for n in lgen():                if n > k: break                if n >=j: print(n, end = ', ')            print('')        elif RANGEE:             j, k = [int(num) for num in RANGEE.split()]            assert 0 < j < 10001, strv            assert 0 < -k < 10001 and -k > j, strv            k = -k            print(strv % (j, k), end=' ')            for n in lgen(even=True):                if n > k: break                if n >=j: print(n, end = ', ')            print('')    else:        raise ArgumentError('''
 
  Error Parsing Arguments!
 
  Expected Arguments of the form (where j and k are integers):
 
      j                #  Jth       lucky number
      j  ,      lucky  #  Jth       lucky number
      j  ,  evenLucky  #  Jth  even lucky number
                       #
      j  k             #  Jth  through  Kth (inclusive)       lucky numbers
      j  k      lucky  #  Jth  through  Kth (inclusive)       lucky numbers
      j  k  evenLucky  #  Jth  through  Kth (inclusive)  even lucky numbers
                       #
      j -k             #  all       lucky numbers in the range  j --? |k|
      j -k      lucky  #  all       lucky numbers in the range  j --? |k|
      j -k  evenLucky  #  all  even lucky numbers in the range  j --? |k|
        ''') if __name__ == '__main__':    arghandler(' '.join(sys.argv[1:]))"
" from sys import stdoutfrom math import sqrt, log def is_prime ( p ):  if p == 2: return True 
  elif p <= 1 or p % 2 == 0: return False  else:    for i in range(3, int(sqrt(p))+1, 2 ):       if p % i == 0: return False    return True def is_mersenne_prime ( p ):  if p == 2:    return True  else:    m_p = ( 1 << p ) - 1    s = 4    for i in range(3, p+1):       s = (s ** 2 - 2) % m_p    return s == 0 precision = 20000   
long_bits_width = precision * log(10, 2)upb_prime = int( long_bits_width - 1 ) / 2    
upb_count = 45      
 print (strv%upb_prime) count=0for p in range(2, int(upb_prime+1)):   if is_prime(p) and is_mersenne_prime(p):    print(strv%p),    stdout.flush()    count += 1  if count >= upb_count: breakprint  def isqrt(n):    if n < 0:        raise ValueError    elif n < 2:        return n    else:        a = 1 << ((1 + n.bit_length()) >> 1)        while True:            b = (a + n // a) >> 1            if b >= a:                return a            a = b def isprime(n):    if n < 5:        return n == 2 or n == 3    elif n%2 == 0:        return False    else:        r = isqrt(n)        k = 3        while k <= r:            if n%k == 0:                return False            k += 2        return True def lucas_lehmer_fast(n):    if n == 2:        return True    elif not isprime(n):        return False    else:        m = 2**n - 1        s = 4        for i in range(2, n):            sqr = s*s            s = (sqr & m) + (sqr >> n)            if s >= m:                s -= m            s -= 2        return s == 0 
 from math import logfrom sys import stdout precision = 20000   
long_bits_width = precision * log(10, 2)upb_prime = int( long_bits_width - 1 ) / 2    

upb_count = 15      
 print (strv%upb_prime) count=0
for p in range(2, int(upb_prime+1)):   if lucas_lehmer_fast(p):    print(strv%p),    stdout.flush()    count += 1  if count >= upb_count: breakprint import gmpy2 as mp def lucas_lehmer(n):    if n == 2:        return True    if not mp.is_prime(n):        return False    two = mp.mpz(2)    m = two**n - 1    s = two*two    for i in range(2, n):        sqr = s*s        s = (sqr & m) + (sqr >> n)        if s >= m:            s -= m        s -= two    return mp.is_zero(s)"
">>> def luhn(n):	r = [int(ch) for ch in str(n)][::-1]	return (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0 >>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):	print(n, luhn(n))"
"def ludic(nmax=100000):    yield 1    lst = list(range(2, nmax + 1))    while lst:        yield lst[0]        del lst[::lst[0]] ludics = [l for l in ludic()] print('First 25 ludic primes:')print(ludics[:25])print(""There are %i ludic numbers <= 1000""      % sum(1 for l in ludics if l <= 1000)) print(""2000'th..2005'th ludic primes:"")print(ludics[2000-1: 2005]) n = 250triplets = [(x, x+2, x+6)            for x in ludics            if x+6 < n and x+2 in ludics and x+6 in ludics]print('There are %i triplets less than %i:  %r'      % (len(triplets), n, triplets))def ludic(nmax=64):    yield 1    taken = []    while True:        lst, nmax = list(range(2, nmax + 1)), nmax * 2        for t in taken:            del lst[::t]        while lst:            t = lst[0]            taken.append(t)            yield t            del lst[::t]"
"from __future__ import print_function def add_reverse(num, max_iter=1000):    i, nums = 0, {num}    while True:        i, num = i+1, num + reverse_int(num)        nums.add(num)        if reverse_int(num) == num or i >= max_iter:            break    return nums _cache(maxsize=2**20)def reverse_int(num):    return int(str(num)[::-1]) def split_roots_from_relateds(roots_and_relateds):    roots = roots_and_relateds[::]    i = 1    while i < len(roots):        this = roots[i]        if any(this.intersection(prev) for prev in roots[:i]):            del roots[i]        else:            i += 1    root = [min(each_set) for each_set in roots]    related = [min(each_set) for each_set in roots_and_relateds]    related = [n for n in related if n not in root]    return root, related def find_lychrel(maxn, max_reversions):    'Lychrel number generator'    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]    roots_and_relateds = [s for s in series if len(s) > max_reversions]    return split_roots_from_relateds(roots_and_relateds)  if __name__ == '__main__':    maxn, reversion_limit = 10000, 500    print(strv          % (maxn, reversion_limit))    lychrel, l_related = find_lychrel(maxn, reversion_limit)    print('  Number of Lychrel numbers:', len(lychrel))    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))    print('  Number of Lychrel related:', len(l_related))    #print('    Lychrel related:', ', '.join(str(n) for n in l_related))    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]    print('  Number of Lychrel palindromes:', len(pals))    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))from __future__ import print_function def rev(n): return int(str(n)[::-1]) def lychel(n, cache = {}):    if n in cache: return cache[n]     n0, r = n, rev(n)    res, seen = (True, n), []    for i in range(1000):        n += r        r = rev(n)        if n == r:            res = (False, 0)            break        if n in cache:            res = cache[n]            break        seen.append(n)     for x in seen: cache[x] = res    return res seeds, related, palin = [], [], [] for i in range(1, 1000000):    tf, s = lychel(i)    if not tf: continue    (seeds if i == s else related).append(i)    if i == rev(i): palin.append(i) print(strv%len(seeds), seeds)print(strv % len(related))print(strv % len(palin), palin)"
"from pprint import pprint def matrixMul(A, B):    TB = zip(*B)    return [[sum(ea*eb for ea,eb in zip(a,b)) for b in TB] for a in A] def pivotize(m):    strv    n = len(m)    ID = [[float(i == j) for i in xrange(n)] for j in xrange(n)]    for j in xrange(n):        row = max(xrange(j, n), key=lambda i: abs(m[i][j]))        if j != row:            ID[j], ID[row] = ID[row], ID[j]    return ID def lu(A):    strv    n = len(A)    L = [[0.0] * n for i in xrange(n)]    U = [[0.0] * n for i in xrange(n)]    P = pivotize(A)    A2 = matrixMul(P, A)    for j in xrange(n):        L[j][j] = 1.0        for i in xrange(j+1):            s1 = sum(U[k][j] * L[i][k] for k in xrange(i))            U[i][j] = A2[i][j] - s1        for i in xrange(j, n):            s2 = sum(U[k][j] * L[i][k] for k in xrange(j))            L[i][j] = (A2[i][j] - s2) / U[j][j]    return (L, U, P) a = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]for part in lu(a):    pprint(part, width=19)    printprintb = [[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]]for part in lu(b):    pprint(part)    print"
"from random import randint def do_scan(mat):    for row in mat:        for item in row:            print item,            if item == 20:                print                return        print    print mat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]do_scan(mat)from random import randint class Found20(Exception):    pass mat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)] try:    for row in mat:        for item in row:            print item,            if item == 20:                raise Found20        printexcept Found20:    printfrom random import randint mat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)] found20 = Falsefor row in mat:    for item in row:        print item,        if item == 20:            found20 = True            break    print    if found20:        break"
n = 1024while n > 0:    print n    n //= 2
"print ( ', '.join(str(i+1) for i in range(10)) )>>> from sys import stdout>>> write = stdout.write>>> n, i = 10, 1>>> while True:    write(i)    i += 1    if i > n:        break    write(', ')  1, 2, 3, 4, 5, 6, 7, 8, 9, 10>>>"
while 1:   print strv
"for i in collection:   print ilines = words = characters = 0f = open('somefile','r')for eachline in f:    lines += 1    for eachword in eachline.split():        words += 1        for eachchar in eachword:            characters += 1 print lines, words, charactersd = {3: strv, 1: strv, 4: strv, 2: strv}for k in sorted(d):    print(strv % (k, d[k])) d = {strv: strv, strv: strv, strv: strv, strv: strv}for k in sorted(d):    print(strv % (k, d[k]))d = {strv: 42, 3.14159: strv, 23: strv, strv: 0, 13: strv}for k in sorted(d):    print(strv % (k, d[k]))"
"for i in xrange(2, 9, 2):    print strv % i,print strvfor i in range(2, 9, 2):    print(strv % i, end=strv)print(strv)"
"for i in xrange(10, -1, -1):    print i[i for i in xrange(10, -1, -1)]import pprintpprint.pprint([i for i in xrange(10, -1, -1)]) "
val = 0while True:   val +=1   print val   if val % 6 == 0: breakval = 1print valwhile val % 6 != 0:   val += 1   print val
"for i in xrange(1,11):    if i % 5 == 0:        print i        continue    print i, strv,"
"for i in 1..5:  for i in 1..i:    stdout.write(strv)  echo(strv)import sysfor i in xrange(5):    for j in xrange(i+1):        sys.stdout.write(strv)    printfor i in range(1,6):    print '*' * i"
from random import randrange while True:    a = randrange(20)    print(a)    if a == 10:        break    b = randrange(20)    print(b)
">>> print ( ''.join(''.join(x) for x in zip('abc', 'ABC', '123')) )aA1bB2cC3>>>>>> print ( ''.join(map(lambda *x: ''.join(x), 'abc', 'ABC', '123')) )aA1bB2cC3>>>from itertools import imap def join3(a,b,c):   print a+b+c imap(join3,'abc','ABC','123')>>> from itertools import zip_longest>>> print ( ''.join(''.join(x) for x in zip_longest('abc', 'ABCD', '12345', fillvalue='#')) )aA1bB2cC3#D4##5>>>"
"def lookandsay(number):    result = strv     repeat = number[0]    number = number[1:]+strv    times = 1     for actual in number:        if actual != repeat:            result += str(times)+repeat            times = 1            repeat = actual        else:            times += 1     return result num = strv for i in range(10):    print num    num = lookandsay(num)>>> from itertools import groupby>>> def lookandsay(number):	return ''.join( str(len(list(g))) + k		        for k,g in groupby(number) ) >>> numberstring='1'>>> for i in range(10):	print numberstring	numberstring = lookandsay(numberstring)>>> from itertools import groupby, islice>>> >>> def lookandsay(number='1'):	while True:		yield number		number = ''.join( str(len(list(g))) + k		                  for k,g in groupby(number) )  >>> print(''.join(islice(lookandsay(), 10)))1112112111112213122111311222111132132113113121113122113211311123113112211import re def lookandsay(str):    return re.sub(r'(.)*', lambda m: str(len(m.group(0))) + m.group(1), str) num = strvfor i in range(10):    print num    num = lookandsay(num)"
"def longest_increasing_subsequence(X):    strv    N = len(X)    P = [0] * N    M = [0] * (N+1)    L = 0    for i in range(N):       lo = 1       hi = L       while lo <= hi:           mid = (lo+hi)//2           if (X[M[mid]] < X[i]):               lo = mid+1           else:               hi = mid-1        newL = lo       P[i] = M[newL-1]       M[newL] = i        if (newL > L):           L = newL     S = []    k = M[L]    for i in range(L-1, -1, -1):        S.append(X[k])        k = P[k]    return S[::-1] if __name__ == '__main__':    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))def longest_increasing_subsequence(d):    'Return one of the L.I.S. of list d'    l = []    for i in range(len(d)):        l.append(max([l[j] for j in range(i) if l[j][-1] < d[i]] or [[]], key=len)                   + [d[i]])    return max(l, key=len) if __name__ == '__main__':    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))from collections import namedtuplefrom functools import total_orderingfrom bisect import bisect_left @total_orderingclass Node(namedtuple('Node_', 'val back')):    def __iter__(self):        while self is not None:            yield self.val            self = self.back    def __lt__(self, other):        return self.val < other.val    def __eq__(self, other):        return self.val == other.val def lis(d):    strv    if not d:        return []    pileTops = []    for di in d:        j = bisect_left(pileTops, Node(di, None))        new_node = Node(di, pileTops[j-1] if j > 0 else None)        if j == len(pileTops):            pileTops.append(new_node)        else:            pileTops[j] = new_node     return list(pileTops[-1])[::-1] if __name__ == '__main__':    for d in [[3,2,6,4,5,1],              [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:        print('a L.I.S. of %s is %s' % (d, lis(d)))"
" import res1 = strvs2 = strvlongest = strvi = 0for x in s1:    if re.search(x, s2):      s = x      while re.search(s, s2):        if len(s)>len(longest):            longest = s        if i+len(s) == len(s1):            break        s = s1[i:i+len(s)+1]    i += 1print longest"
"import fileinput 




def longer(a, b):    while a and b:        a, b = a[1:], b[1:]    return a longest, lines = '', ''for x in fileinput.input():    if longer(x, longest):        lines, longest = x, x    elif not longer(longest, x):        lines += x print(lines, end='')"
"import os.path def lcp(*s):    return os.path.commonprefix(s) assert lcp(strv,strv,strv) == strvassert lcp(strv,strv) == strvassert lcp(strv,strv) == strvassert lcp(strv) == strvassert lcp(strv) == strvassert lcp(strv,strv) == strvassert lcp(strv,strv) == strvfrom itertools import takewhile def lcp(*s):    return ''.join(ch[0] for ch in takewhile(lambda x: min(x) == max(x),					     zip(*s))) assert lcp(strv,strv,strv) == strvassert lcp(strv,strv) == strvassert lcp(strv,strv) == strvassert lcp(strv) == strvassert lcp(strv) == strvassert lcp(strv,strv) == strvassert lcp(strv,strv) == strvfrom itertools import takewhile def lcp(*s):    return ''.join(a for a,b in takewhile(lambda x: x[0] == x[1],					  zip(min(s), max(s))))"
"def lcs(xstr, ystr):    strv
    >>> lcs('thisisatest', 'testing123testing')
    'tsitest'
    strv    if not xstr or not ystr:        return strv    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]    if x == y:        return x + lcs(xs, ys)    else:        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)if __name__==strv:    import doctest; doctest.testmod()def lcs(a, b):    lengths = [[0 for j in range(len(b)+1)] for i in range(len(a)+1)]    
    for i, x in enumerate(a):        for j, y in enumerate(b):            if x == y:                lengths[i+1][j+1] = lengths[i][j] + 1            else:                lengths[i+1][j+1] = max(lengths[i+1][j], lengths[i][j+1])    
    result = strv    x, y = len(a), len(b)    while x != 0 and y != 0:        if lengths[x][y] == lengths[x-1][y]:            x -= 1        elif lengths[x][y] == lengths[x][y-1]:            y -= 1        else:            assert a[x-1] == b[y-1]            result = a[x-1] + result            x -= 1            y -= 1    return result"
"'c' == strv 
'text' == strv' "" 'strv'20' == ' 'u'unicode string'u'05d0' 
r'20' == 'x20'''' single triple quote '''strv"
"def logic(a, b):        print 'a and b:', a and b        print 'a or b:' , a or b        print 'not a:'  , not a"
" 2.3    
.3     
.3e4   
.3e+34 
.3e-34 
2.  
 "
"def bags(n,cache={}):	if not n: return [(0, strv)] 	upto = sum([bags(x) for x in range(n-1, 0, -1)], [])	return [(c+1, '('+s+')') for c,s in bagchain((0, strv), n-1, upto)] def bagchain(x, n, bb, start=0):	if not n: return [x] 	out = []	for i in range(start, len(bb)):		c,s = bb[i]		if c <= n: out += bagchain((x[0] + c, x[1] + s), n-c, bb, i)	return out 
def replace_brackets(s):	depth,out = 0,[]	for c in s:		if c == '(':			out.append(strv[depth%3])			depth += 1		else:			depth -= 1			out.append(strv[depth%3])	return strv.join(out) for x in bags(5): print(replace_brackets(x[1]))treeid = {(): 0} '''
Successor of a tree.  The predecessor p of a tree t is:
 
  1. if the smallest subtree of t is a single node, then p is t minus that node
  2. otherwise, p is t with its smalles subtree strv replaced by m's predecessor
 
Here strv means the tree is generated earlier, as recorded by treeid. Obviously,
predecessor to a tree is unique.  Since every degree n tree has a
unique degree (n-1) predecessor, inverting the process leads to the successors
to tree t:
 
  1. append a single node tree to t's root, or
  2. replace t's smallest subtree by its successors
 
We need to keep the trees so generated canonical, so when replacing a subtree,
the replacement must not be larger than the next smallest subtree.
 
Note that trees can be compared by other means, as long as trees with fewer nodes
are considered smaller, and trees with the same number of nodes have a fixed order.
'''def succ(x):    yield(((),) + x)    if not x: return     if len(x) == 1:        for i in succ(x[0]): yield((i,))        return     head,rest = x[0],tuple(x[1:])    top = treeid[rest[0]]     for i in [i for i in succ(head) if treeid[i] <= top]:        yield((i,) + rest) def trees(n):    if n == 1:        yield()        return     global treeid    for x in trees(n-1):        for a in succ(x):            if not a in treeid: treeid[a] = len(treeid)            yield(a) def tostr(x): return strv + strv.join(map(tostr, x)) + strv for x in trees(5): print(tostr(x))"
">>> 
>>> 0b1011010111 == 0o1327 == 727 == 0x2d7True>>>>>> 
>>> 0b1011010111 == 0o1327 == 01327 == 727 == 0x2d7True>>>>>> 
>>> 01327 == 727 == 0x2d7True>>>"
"from __future__ import print_functionfrom time import sleep  last_idle = last_total = 0while True:    with open('/proc/stat') as f:        fields = [float(column) for column in f.readline().strip().split()[1:]]    idle, total = fields[3], sum(fields)    idle_delta, total_delta = idle - last_idle, total - last_total    last_idle, last_total = idle, total    utilisation = 100.0 * (1.0 - idle_delta / total_delta)    print('%5.1f%%' % utilisation, end='')    sleep(5)"
"#!/usr/bin/env pythonprint 2**64*2**64#!/usr/bin/env python def add_with_carry(result, addend, addendpos):    while True:        while len(result) < addendpos + 1:            result.append(0)        addend_result = str(int(addend) + int(result[addendpos]))        addend_digits = list(addend_result)        result[addendpos] = addend_digits.pop()         if not addend_digits:            break        addend = addend_digits.pop()        addendpos += 1 def longhand_multiplication(multiplicand, multiplier):    result = []    for multiplicand_offset, multiplicand_digit in enumerate(reversed(multiplicand)):        for multiplier_offset, multiplier_digit in enumerate(reversed(multiplier), start=multiplicand_offset):            multiplication_result = str(int(multiplicand_digit) * int(multiplier_digit))             for addend_offset, result_digit_addend in enumerate(reversed(multiplication_result), start=multiplier_offset):                add_with_carry(result, result_digit_addend, addend_offset)     result.reverse()     return ''.join(result) if __name__ == strv:    sixtyfour = strv     onetwentyeight = longhand_multiplication(sixtyfour, sixtyfour)    print(onetwentyeight)#!/usr/bin/env python def digits(x):    return [int(c) for c in str(x)] def mult_table(xs, ys):    return [[x * y for x in xs] for y in ys] def polymul(xs, ys):    return map(lambda *vs: sum(filter(None, vs)),               *[[0] * i + zs for i, zs in enumerate(mult_table(xs, ys))]) def longmult(x, y):    result = 0    for v in polymul(digits(x), digits(y)):        result = result * 10 + v    return result if __name__ == strv:    print longmult(2**64, 2**64)"
def bsd_rand(seed):   def rand():      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff      return rand.seed   rand.seed = seed   return rand def msvcrt_rand(seed):   def rand():      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff      return rand.seed >> 16   rand.seed = seed   return randdef bsd_rand(seed):   def rand():      nonlocal seed      seed = (1103515245*seed + 12345) & 0x7fffffff      return seed   return rand def msvcrt_rand(seed):   def rand():      nonlocal seed      seed = (214013*seed + 2531011) & 0x7fffffff      return seed >> 16   return rand
"[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]((x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2)"
"from itertools import islice def lfact():    yield 0    fact, summ, n = 1, 0, 1     while 1:        fact, summ, n = fact*n, summ + fact, n + 1        yield summ print('first 11:  %r' % [lf for i, lf in zip(range(11), lfact())])print('20 through 110 (inclusive) by tens:')for lf in islice(lfact(), 20, 111, 10):    print(lf)print('Digits in 1,000 through 10,000 (inclusive) by thousands:  %r'       % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )"
"import collections, sys def filecharcount(openfile):    return sorted(collections.Counter(c for l in openfile for c in l).items()) f = open(sys.argv[1])print(filecharcount(f))import stringif hasattr(string, 'ascii_lowercase'):    letters = string.ascii_lowercase       
else:    letters = string.lowercase             
offset = ord('a') def countletters(file_handle):    strvTraverse a file and compute the number of occurences of each letter
    return results as a simple 26 element list of integers.strv    results = [0] * len(letters)    for line in file_handle:        for char in line:            char = char.lower()            if char in letters:                results[ord(char) - offset] += 1                
    return results if __name__ == strv:    sourcedata = open(sys.argv[1])    lettercounts = countletters(sourcedata)    for i in xrange(len(lettercounts)):        print strv % (chr(i + ord('a')), lettercounts[i]),...from collections import defaultdictdef countletters(file_handle):    strvCount occurences of letters and return a dictionary of them
    strv    results = defaultdict(int)    for line in file_handle:        for char in line:            if char.lower() in letters:                c = char.lower()                results[c] += 1    return resultslettercounts = countletters(sourcedata)for letter,count in lettercounts.iteritems():    print strv % (letter, count),"
"def minimumEditDistance(s1,s2):    if len(s1) > len(s2):        s1,s2 = s2,s1    distances = range(len(s1) + 1)    for index2,char2 in enumerate(s2):        newDistances = [index2+1]        for index1,char1 in enumerate(s1):            if char1 == char2:                newDistances.append(distances[index1])            else:                newDistances.append(1 + min((distances[index1],                                             distances[index1+1],                                             newDistances[-1])))        distances = newDistances    return distances[-1] print(minimumEditDistance(strv,strv))print(minimumEditDistance(strv,strv)) def levenshteinDistance(str1, str2):    m = len(str1)    n = len(str2)    lensum = float(m + n)    d = []               for i in range(m+1):        d.append([i])            del d[0][0]        for j in range(n+1):        d[0].append(j)           for j in range(1,n+1):        for i in range(1,m+1):            if str1[i-1] == str2[j-1]:                d[i].insert(j,d[i-1][j-1])                       else:                minimum = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]+2)                         d[i].insert(j, minimum)    ldist = d[-1][-1]    ratio = (lensum - ldist)/lensum    return {'distance':ldist, 'ratio':ratio} print(levenshteinDistance(strv,strv))   print(levenshteinDistance(strv,strv))  >>> from functools import lru_cache>>> @lru_cache(maxsize=4095)def ld(s, t):	if not s: return len(t)	if not t: return len(s)	if s[0] == t[0]: return ld(s[1:], t[1:])	l1 = ld(s, t[1:])	l2 = ld(s[1:], t)	l3 = ld(s[1:], t[1:])	return 1 + min(l1, l2, l3) >>> print( ld(strv,strv),ld(strv,strv) )3 8"
">>> import fractions>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0 >>> lcm(12, 18)36>>> lcm(-6, 14)42>>> assert lcm(0, 2) == lcm(2, 0) == 0>>> from prime_decomposition import decomposetry:    reduceexcept NameError:    from functools import reduce def lcm(a, b):    mul = int.__mul__    if a and b:        da = list(decompose(abs(a)))        db = list(decompose(abs(b)))        merge= da        for d in da:            if d in db: db.remove(d)        merge += db        return reduce(mul, merge, 1)    return 0 if __name__ == '__main__':    print( lcm(12, 18) )    
    print( lcm(-6, 14) )    
    assert lcm(0, 2) == lcm(2, 0) == 0>>> def lcm(*values):	values = set([abs(int(v)) for v in values])	if values and 0 not in values:		n = n0 = max(values)		values.remove(n)		while any( n % m for m in values ):			n += n0		return n	return 0 >>> lcm(-6, 14)42>>> lcm(2, 0)0>>> lcm(12, 18)36>>> lcm(12, 18, 22)396>>> >>> def lcm(p,q):	p, q = abs(p), abs(q)	m = p * q	if not m: return 0	while True:		p %= q		if not p: return m // q		q %= p		if not q: return m // p  >>> lcm(-6, 14)42>>> lcm(12, 18)36>>> lcm(2, 0)0>>> "
"import calendar def last_fridays(year):    for month in range(1, 13):        last_friday = max(week[calendar.FRIDAY]            for week in calendar.monthcalendar(year, month))        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))import calendarc=calendar.Calendar()fridays={}year=raw_input(strv)for item in c.yeardatescalendar(int(year)):    for i1 in item:        for i2 in i1:            for i3 in i2:                if strv in i3.ctime() and year in i3.ctime():                    month,day=str(i3).rsplit(strv,1)                    fridays[month]=day for item in sorted((month+strv+day for month,day in fridays.items()),                   key=lambda x:int(x.split(strv)[1])):    print itemimport calendarc=calendar.Calendar()fridays={}year=raw_input(strv)add=list.__add__for day in reduce(add,reduce(add,reduce(add,c.yeardatescalendar(int(year))))):     if strv in day.ctime() and year in day.ctime():        month,day=str(day).rsplit(strv,1)        fridays[month]=day for item in sorted((month+strv+day for month,day in fridays.items()),                   key=lambda x:int(x.split(strv)[1])):    print itemimport calendarfrom itertools import chainf=chain.from_iterablec=calendar.Calendar()fridays={}year=raw_input(strv)add=list.__add__ for day in f(f(f(c.yeardatescalendar(int(year))))):     if strv in day.ctime() and year in day.ctime():        month,day=str(day).rsplit(strv,1)        fridays[month]=day for item in sorted((month+strv+day for month,day in fridays.items()),                   key=lambda x:int(x.split(strv)[1])):    print item"
"try:    cmp     
    def maxnum(x):        return ''.join(sorted((str(n) for n in x),                              cmp=lambda x,y:cmp(y+x, x+y)))except NameError:    
    from functools import cmp_to_key    def cmp(x, y):        return -1 if x<y else ( 0 if x==y else 1)    def maxnum(x):        return ''.join(sorted((str(n) for n in x),                              key=cmp_to_key(lambda x,y:cmp(y+x, x+y)))) for numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60):    print('Numbers: %r  Largest integer: %15s' % (numbers, maxnum(numbers)))def maxnum(x):    maxlen = len(str(max(x)))    return ''.join(sorted((str(v) for v in x), reverse=True,                          key=lambda i: i*(maxlen * 2 // len(i)))) for numbers in [(212, 21221), (1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:    print('Numbers: %r  Largest integer: %15s' % (numbers, maxnum(numbers)))from fractions import Fractionfrom math import log10 def maxnum(x):    return ''.join(str(n) for n in sorted(x, reverse=True,                          key=lambda i: Fraction(i, 10**(int(log10(i))+1)-1))) for numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:    print('Numbers: %r  Largest integer: %15s' % (numbers, maxnum(numbers)))from itertools import permutationsdef maxnum(x):    return max(int(''.join(n) for n in permutations(str(i) for i in x))) for numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:    print('Numbers: %r  Largest integer: %15s' % (numbers, maxnum(numbers)))"
"from collections import defaultdict def order_words(words):    byfirst = defaultdict(set)    for word in words:        byfirst[word[0]].add( word )    #byfirst = dict(byfirst)    return byfirst def linkfirst(byfirst, sofar):    '''
    For all words matching last char of last word in sofar as FIRST char and not in sofar,
    return longest chain as sofar + chain
    '''     assert sofar    chmatch = sofar[-1][-1]    options = byfirst[chmatch] - set(sofar)    #print('  linkfirst options: %r %r' % (chmatch, options))    if not options:        return sofar    else:        alternatives = ( linkfirst(byfirst, list(sofar) + [word])                         for word in options )        mx = max( alternatives, key=len )        #input('linkfirst: %r' % mx)        return mx def llfl(words):     byfirst = order_words(words)    return max( (linkfirst(byfirst, [word]) for word in words), key=len ) if __name__ == '__main__':    pokemon = '''audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask'''    pokemon = pokemon.strip().lower().split()    pokemon = sorted(set(pokemon))        l = llfl(pokemon)    for i in range(0, len(l), 8): print(' '.join(l[i:i+8]))    print(len(l))import psyco nsolutions = 0 def search(sequences, ord_minc, curr_word, current_path,           current_path_len, longest_path):    global nsolutions     current_path[current_path_len] = curr_word    current_path_len += 1     if current_path_len == len(longest_path):        nsolutions += 1    elif current_path_len > len(longest_path):        nsolutions = 1        longest_path[:] = current_path[:current_path_len]     
    last_char_index = ord(curr_word[-1]) - ord_minc    if last_char_index >= 0 and last_char_index < len(sequences):        for pair in sequences[last_char_index]:            if not pair[1]:                pair[1] = True                search(sequences, ord_minc, pair[0], current_path,                       current_path_len, longest_path)                pair[1] = False  def find_longest_chain(words):    ord_minc = ord(min(word[0] for word in words))    ord_maxc = ord(max(word[0] for word in words))    sequences = [[] for _ in xrange(ord_maxc - ord_minc + 1)]    for word in words:        sequences[ord(word[0]) - ord_minc].append([word, False])     current_path = [None] * len(words)    longest_path = []     
    for seq in sequences:        for pair in seq:            pair[1] = True            search(sequences, ord_minc, pair[0],                   current_path, 0, longest_path)            pair[1] = False     return longest_path  def main():    global nsolutions     pokemon = strvaudino bagon baltoy banette bidoof braviary
bronzor carracosta charmeleon cresselia croagunk darmanitan deino
emboar emolga exeggcute gabite girafarig gulpin haxorus heatmor
heatran ivysaur jellicent jumpluff kangaskhan kricketune landorus
ledyba loudred lumineon lunatone machamp magnezone mamoswine nosepass
petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede
scrafty seaking sealeo silcoon simisear snivy snorlax spoink starly
tirtouga trapinch treecko tyrogue vigoroth vulpix wailord wartortle
whismur wingull yamaskstrv.lower().split()     
    pokemon = sorted(set(pokemon))     sol = find_longest_chain(pokemon)    print strv, len(sol)    print strv, nsolutions    print strv    for i in xrange(0, len(sol), 7):        print strv, strv.join(sol[i : i+7]) psyco.full()main()"
"import calendarcalendar.isleap(year)def is_leap_year(year):    if year % 100 == 0:        return year % 400 == 0    return year % 4 == 0import datetime def is_leap_year(year):    try:        datetime.date(year, 2, 29)    except ValueError:        return False    return True"
"from __future__ import print_function 
def path(n, p = {1:0}, lvl=[[1]]):	if not n: return []	while n not in p:		q = []		for x,y in ((x, x+y) for x in lvl[0] for y in path(x) if not x+y in p):			p[y] = x			q.append(y)		lvl[0] = q 	return path(p[n]) + [n] def tree_pow(x, n):    r, p = {0:1, 1:x}, 0    for i in path(n):        r[i] = r[i-p] * r[p]        p = i    return r[n] def show_pow(x, n):    fmt = ""%d: %s"" + [strv, strv][x==int(x)] + """"    print(fmt % (n, repr(path(n)), x, n, tree_pow(x, n))) for x in range(18): show_pow(2, x)show_pow(3, 191)show_pow(1.1, 81)"
"width = 75height = 52nsteps = 12000 class Dir: up, right, down, left = range(4)class Turn: left, right = False, Trueclass Color: white, black = '.', '#'M = [[Color.white] * width for _ in range(height)] x = width // 2y = height // 2dir = Dir.up i = 0while i < nsteps and 0 <= x < width and 0 <= y < height:    turn = Turn.left if M[y][x] == Color.black else Turn.right    M[y][x] = Color.white if M[y][x] == Color.black else Color.black     dir = (4 + dir + (1 if turn else -1)) % 4    dir = [Dir.up, Dir.right, Dir.down, Dir.left][dir]    if   dir == Dir.up:    y -= 1    elif dir == Dir.right: x -= 1    elif dir == Dir.down:  y += 1    elif dir == Dir.left:  x += 1    else: assert False    i += 1 print ("""".join(strv.join(row) for row in M))"
"from random import randrange def s_of_n_creator(n):    sample, i = [], 0    def s_of_n(item):        nonlocal i         i += 1        if i <= n:            
            sample.append(item)        elif randrange(i) < n:            
            sample[randrange(n)] = item        return sample    return s_of_n if __name__ == '__main__':    bin = [0]* 10    items = range(10)    print(strv)    s_of_n = s_of_n_creator(3)    for item in items:        sample = s_of_n(item)        print(strv % (item, sample))    #    for trial in range(100000):        s_of_n = s_of_n_creator(3)        for item in items:            sample = s_of_n(item)        for s in sample:            bin[s] += 1    print(""Test item frequencies for 100000 runs: "",          '  '.join(strv % x for x in enumerate(bin)))class S_of_n_creator():    def __init__(self, n):        self.n = n        self.i = 0        self.sample = []     def __call__(self, item):        self.i += 1        n, i, sample = self.n, self.i, self.sample        if i <= n:            
            sample.append(item)        elif randrange(i) < n:            
            sample[randrange(n)] = item        return samples_of_n = S_of_n_creator(3)"
"import copy boardsize=6_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1))   def chess2index(chess, boardsize=boardsize):    'Convert Algebraic chess notation to internal index format'    chess = chess.strip().lower()    x = ord(chess[0]) - ord('a')    y = boardsize - int(chess[1:])    return (x, y) def boardstring(board, boardsize=boardsize):    r = range(boardsize)    lines = ''    for y in r:        lines += '' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '                                 for x in r)    return lines def knightmoves(board, P, boardsize=boardsize):    Px, Py = P    kmoves = set((Px+x, Py+y) for x,y in _kmoves)    kmoves = set( (x,y)                  for x,y in kmoves                  if 0 <= x < boardsize                     and 0 <= y < boardsize                     and not board[(x,y)] )    return kmoves def accessibility(board, P, boardsize=boardsize):    access = []    brd = copy.deepcopy(board)    for pos in knightmoves(board, P, boardsize=boardsize):        brd[pos] = -1        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )        brd[pos] = 0    return access def knights_tour(start, boardsize=boardsize, _debug=False):    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}    move = 1    P = chess2index(start, boardsize)    board[P] = move    move += 1    if _debug:        print(boardstring(board, boardsize=boardsize))    while move <= len(board):        P = min(accessibility(board, P, boardsize))[1]        board[P] = move        move += 1        if _debug:            print(boardstring(board, boardsize=boardsize))            input('%2i next: ' % move)    return board if __name__ == '__main__':    while 1:        boardsize = int(input('boardsize: '))        if boardsize < 5:            continue        start = input('Start position: ')        board = knights_tour(start, boardsize)        print(boardstring(board, boardsize=boardsize))"
"from random import randrange def knuth_shuffle(x):    for i in range(len(x)-1, 0, -1):        j = randrange(i + 1)        x[i], x[j] = x[j], x[i] x = list(range(10))knuth_shuffle(x)print(strv, x)"
#!/usr/bin/env pythonimport curses def print_message():    stdscr.addstr('This is the message.') stdscr = curses.initscr()curses.noecho()curses.cbreak()stdscr.keypad(1) stdscr.addstr('CTRL+P for message or q to quit.')while True:    c = stdscr.getch()    if c == 16: print_message()    elif c == ord('q'): break curses.nocbreak()stdscr.keypad(0)curses.echo()curses.endwin() 
"
items = [(strv,    3.8, 36.0),         (strv,    5.4, 43.0),         (strv,     3.6, 90.0),         (strv, 2.4, 45.0),         (strv,  4.0, 30.0),         (strv,   2.5, 56.0),         (strv,    3.7, 67.0),         (strv,  3.0, 95.0),         (strv, 5.9, 98.0)] MAXWT = 15.0 sorted_items = sorted(((value/amount, amount, name)                       for name, amount, value in items),                      reverse = True)wt = val = 0bagged = []for unit_value, amount, name in sorted_items:    portion = min(MAXWT - wt, amount)    wt     += portion    addval  = portion * unit_value    val    += addval    bagged += [(name, portion, addval)]    if wt >= MAXWT:        break print(strv)print("""".join(strv % item for item in bagged))print(""TOTAL WEIGHT: %5.2fTOTAL VALUE: %5.2f"" % (wt, val))"
"#!/usr/bin/env python import __future__import sysif sys.version_info.major < 3:    import thread as _threadelse:    import _threadimport time  try:    from msvcrt import getch  
except ImportError:    def getch():   
        import tty, termios        fd = sys.stdin.fileno()        old_settings = termios.tcgetattr(fd)        try:            tty.setraw(sys.stdin.fileno())            ch = sys.stdin.read(1)        finally:            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)        return ch char = None def keypress():    global char    char = getch() _thread.start_new_thread(keypress, ()) while True:    if char is not None:        print(strv + char.decode('utf-8'))        break    print(strv)    time.sleep(5)"
"def flush_input():    try:        import msvcrt        while msvcrt.kbhit():            msvcrt.getch()    except ImportError:        import sys, termios        termios.tcflush(sys.stdin, termios.TCIOFLUSH) "
"#!/usr/bin/env python try:    from msvcrt import getchexcept ImportError:    def getch():        import sys, tty, termios        fd = sys.stdin.fileno()        old_settings = termios.tcgetattr(fd)        try:            tty.setraw(sys.stdin.fileno())            ch = sys.stdin.read(1)        finally:            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)        return ch print strvwhile True:    char = getch()    if char.lower() in (strv, strv):        print char        break#!/usr/bin/env python
from curses import wrapper##def main(stdscr):  
  #y = ord(strv)  #n = ord(strv)  while True:    
    #window.nodelay(yes)    
    
    #kb_Inpt = stdscr.getch()    
    kb_Inpt = stdscr.getkey()    #if kb_Inpt == (y or n):    if kb_Inpt.lower() == ('y' or 'n'):      break      return None  #  return None##*** unit test ***#if __name__ == strv:  #  wrapper(main)"
"epsilon = 1.0while 1.0 + epsilon != 1.0:    epsilon = epsilon / 2.0>>> from decimal import *>>> >>> getcontext().prec = 6>>> >>> def kahansum(input):    summ = c = 0    for num in input:        y = num - c        t = summ + y        c = (t - summ) - y        summ = t    return summ >>> a, b, c = [Decimal(n) for n in '10000.0 3.14159 2.71828'.split()]>>> a, b, c(Decimal('10000.0'), Decimal('3.14159'), Decimal('2.71828'))>>> >>> (a + b) + cDecimal('10005.8')>>> kahansum([a, b, c])Decimal('10005.9')>>> >>> >>> sum([a, b, c])Decimal('10005.8')>>> 
>>> >>> 
>>> getcontext()Context(prec=6, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[InvalidOperation, DivisionByZero, Overflow])>>> >>> >>> ## Lets try the simple summation with more precision for comparison>>> getcontext().prec = 20>>> (a + b) + cDecimal('10005.85987')>>> >>> eps = 1.0>>> while 1.0 + eps != 1.0:	eps = eps / 2.0  >>> eps1.1102230246251565e-16>>> (1.0 + eps) - eps0.9999999999999999>>> kahansum([1, eps, -eps])1.0>>> >>> >>> 
>>> import sys>>> sys.float_infosys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)>>> >>> from decimal import localcontext, Decimal>>> >>> with localcontext() as ctx:	one, ten = Decimal('1.0'), Decimal('10')	eps = one	while one + eps != one:		eps = eps / ten	print('eps is:', eps)	print('Simple sum is:', (one + eps) - eps)	print('Kahan sum is:', kahansum([one, eps, -eps]))  eps is: 1E-28Simple sum is: 0.9999999999999999999999999999Kahan sum is: 1.000000000000000000000000000>>> "
"from itertools import groupbyfrom collections import namedtuplefrom pprint import pprint as pp def anyvalidcomb(items,  val=0, wt=0):    ' All combinations below the maxwt '    if not items:        yield [], val, wt    else:        this, *items = items            
        for n in range(this.number+1):            v = val + n*this.value            w = wt  + n*this.weight            if w > maxwt:                break            for c in anyvalidcomb(items, v, w):                yield [this]*n + c[COMB], c[VAL], c[WT] maxwt = 400COMB, VAL, WT = range(3)Item  = namedtuple('Items', 'name weight value number')items = [ Item(*x) for x in          (            (strv, 9, 150, 1),            (strv, 13, 35, 1),            (strv, 153, 200, 3),            (strv, 50, 60, 2),            (strv, 15, 60, 2),            (strv, 68, 45, 3),            (strv, 27, 60, 3),            (strv, 39, 40, 3),            (strv, 23, 30, 1),            (strv, 52, 10, 3),            (strv, 11, 70, 1),            (strv, 32, 30, 1),            (strv, 24, 15, 2),            (strv, 48, 10, 2),            (strv, 73, 40, 1),            (strv, 42, 70, 1),            (strv, 43, 75, 1),            (strv, 22, 80, 1),            (strv, 7, 20, 1),            (strv, 18, 12, 2),            (strv, 4, 50, 1),            (strv, 30, 10, 2),           ) ]   bagged = max( anyvalidcomb(items), key=lambda c: (c[VAL], -c[WT])) 
print(""Bagged the following %i items  "" % len(bagged[COMB]) +      '  '.join('%i off: %s' % (len(list(grp)), item.name)                  for item,grp in groupby(sorted(bagged[COMB]))))print(strv % bagged[1:])from itertools import groupby try:    xrangeexcept:    xrange = range maxwt = 400 groupeditems = (            (strv, 9, 150, 1),            (strv, 13, 35, 1),            (strv, 153, 200, 3),            (strv, 50, 60, 2),            (strv, 15, 60, 2),            (strv, 68, 45, 3),            (strv, 27, 60, 3),            (strv, 39, 40, 3),            (strv, 23, 30, 1),            (strv, 52, 10, 3),            (strv, 11, 70, 1),            (strv, 32, 30, 1),            (strv, 24, 15, 2),            (strv, 48, 10, 2),            (strv, 73, 40, 1),            (strv, 42, 70, 1),            (strv, 43, 75, 1),            (strv, 22, 80, 1),            (strv, 7, 20, 1),            (strv, 18, 12, 2),            (strv, 4, 50, 1),            (strv, 30, 10, 2),           )items = sum( ([(item, wt, val)]*n for item, wt, val,n in groupeditems), []) def knapsack01_dp(items, limit):    table = [[0 for w in range(limit + 1)] for j in xrange(len(items) + 1)]     for j in xrange(1, len(items) + 1):        item, wt, val = items[j-1]        for w in xrange(1, limit + 1):            if wt > w:                table[j][w] = table[j-1][w]            else:                table[j][w] = max(table[j-1][w],                                  table[j-1][w-wt] + val)     result = []    w = limit    for j in range(len(items), 0, -1):        was_added = table[j][w] != table[j-1][w]         if was_added:            item, wt, val = items[j-1]            result.append(items[j-1])            w -= wt     return result  bagged = knapsack01_dp(items, maxwt)print(""Bagged the following %i items  "" % len(bagged) +      '  '.join('%i off: %s' % (len(list(grp)), item[0])                  for item,grp in groupby(sorted(bagged))))print(strv % (    sum(item[2] for item in bagged), sum(item[1] for item in bagged)))items = (	(strv,		9,	150,	1),	(strv,	13,	35,	1),	(strv,	153,	200,	3),	(strv,	50,	60,	2),	(strv,	15,	60,	2),	(strv,		68,	45,	3),	(strv,	27,	60,	3),	(strv,	39,	40,	3),	(strv,	23,	30,	1),	(strv,	52,	10,	3),	(strv,11,	70,	1),	(strv,	32,	30,	1),	(strv,	24,	15,	2),	(strv,	48,	10,	2),	(strv,	73,	40,	1),	(strv,	42,	70,	1),	(strv,	43,	75,	1),	(strv,	22,	80,	1),	(strv,	7,	20,	1),	(strv,	18,	12,	2),	(strv,	4,	50,	1),	(strv,	30,	10,	2),) #cache: could just use memoize module, but explicit caching is clearerdef choose_item(weight, idx, cache):    if idx < 0: return 0, []     k = (weight, idx)    if k in cache: return cache[k]     name, w, v, qty = items[idx]    best_v, best_list = 0, []     for i in range(0, qty + 1):        wlim = weight - i * w        if wlim < 0: break         val, taken = choose_item(wlim, idx - 1, cache)        if val + i * v > best_v:            best_v = val + i * v            best_list = taken[:]            best_list.append(i)     cache[k] = [best_v, best_list]    return best_v, best_list  v, lst = choose_item(400, len(items) - 1, {})w = 0for i, cnt in enumerate(lst):    if cnt > 0:        print cnt, items[i][0]        w = w + items[i][1] * cnt print strv, w, strv, v"
"from itertools import combinations def anycomb(items):    ' return combinations of any length from the items '    return ( comb             for r in range(1, len(items)+1)             for comb in combinations(items, r)             ) def totalvalue(comb):    ' Totalise a particular combination of items'    totwt = totval = 0    for item, wt, val in comb:        totwt  += wt        totval += val    return (totval, -totwt) if totwt <= 400 else (0, 0) items = (    (strv, 9, 150), (strv, 13, 35), (strv, 153, 200), (strv, 50, 160),    (strv, 15, 60), (strv, 68, 45), (strv, 27, 60), (strv, 39, 40),    (strv, 23, 30), (strv, 52, 10), (strv, 11, 70), (strv, 32, 30),    (strv, 24, 15), (strv, 48, 10), (strv, 73, 40),    (strv, 42, 70), (strv, 43, 75),    (strv, 22, 80), (strv, 7, 20), (strv, 18, 12),    (strv, 4, 50), (strv, 30, 10),    )bagged = max( anycomb(items), key=totalvalue) 
print(""Bagged the following items  "" +      '  '.join(sorted(item for item,_,_ in bagged)))val, wt = totalvalue(bagged)print(strv % (val, -wt))try:    xrangeexcept:    xrange = range def totalvalue(comb):    ' Totalise a particular combination of items'    totwt = totval = 0    for item, wt, val in comb:        totwt  += wt        totval += val    return (totval, -totwt) if totwt <= 400 else (0, 0) items = (    (strv, 9, 150), (strv, 13, 35), (strv, 153, 200), (strv, 50, 160),    (strv, 15, 60), (strv, 68, 45), (strv, 27, 60), (strv, 39, 40),    (strv, 23, 30), (strv, 52, 10), (strv, 11, 70), (strv, 32, 30),    (strv, 24, 15), (strv, 48, 10), (strv, 73, 40),    (strv, 42, 70), (strv, 43, 75),    (strv, 22, 80), (strv, 7, 20), (strv, 18, 12),    (strv, 4, 50), (strv, 30, 10),    ) def knapsack01_dp(items, limit):    table = [[0 for w in range(limit + 1)] for j in xrange(len(items) + 1)]     for j in xrange(1, len(items) + 1):        item, wt, val = items[j-1]        for w in xrange(1, limit + 1):            if wt > w:                table[j][w] = table[j-1][w]            else:                table[j][w] = max(table[j-1][w],                                  table[j-1][w-wt] + val)     result = []    w = limit    for j in range(len(items), 0, -1):        was_added = table[j][w] != table[j-1][w]         if was_added:            item, wt, val = items[j-1]            result.append(items[j-1])            w -= wt     return result  bagged = knapsack01_dp(items, 400)print(""Bagged the following items  "" +      '  '.join(sorted(item for item,_,_ in bagged)))val, wt = totalvalue(bagged)print(strv % (val, -wt))def total_value(items, max_weight):    return  sum([x[2] for x in items]) if sum([x[1] for x in items]) < max_weight else 0 cache = {}def solve(items, max_weight):    if not items:        return ()    if (items,max_weight) not in cache:        head = items[0]        tail = items[1:]        include = (head,) + solve(tail, max_weight - head[1])        dont_include = solve(tail, max_weight)        if total_value(include, max_weight) > total_value(dont_include, max_weight):            answer = include        else:            answer = dont_include        cache[(items,max_weight)] = answer    return cache[(items,max_weight)] items = (    (strv, 9, 150), (strv, 13, 35), (strv, 153, 200), (strv, 50, 160),    (strv, 15, 60), (strv, 68, 45), (strv, 27, 60), (strv, 39, 40),    (strv, 23, 30), (strv, 52, 10), (strv, 11, 70), (strv, 32, 30),    (strv, 24, 15), (strv, 48, 10), (strv, 73, 40),    (strv, 42, 70), (strv, 43, 75),    (strv, 22, 80), (strv, 7, 20), (strv, 18, 12),    (strv, 4, 50), (strv, 30, 10),    )max_weight = 400 solution = solve(items, max_weight)print strvfor x in solution:    print x[0]print strv, total_value(solution, max_weight)print strv, sum([x[1] for x in solution])"
"from random import seed, randomfrom time import clockfrom operator import itemgetterfrom collections import namedtuplefrom math import sqrtfrom copy import deepcopy  def sqd(p1, p2):    return sum((c1 - c2) ** 2 for c1, c2 in zip(p1, p2))  class KdNode(object):    __slots__ = (strv, strv, strv, strv)     def __init__(self, dom_elt, split, left, right):        self.dom_elt = dom_elt        self.split = split        self.left = left        self.right = right  class Orthotope(object):    __slots__ = (strv, strv)     def __init__(self, mi, ma):        self.min, self.max = mi, ma  class KdTree(object):    __slots__ = (strv, strv)     def __init__(self, pts, bounds):        def nk2(split, exset):            if not exset:                return None            exset.sort(key=itemgetter(split))            m = len(exset) // 2            d = exset[m]            while m + 1 < len(exset) and exset[m + 1][split] == d[split]:                m += 1             s2 = (split + 1) % len(d)  
            return KdNode(d, split, nk2(s2, exset[:m]),                                    nk2(s2, exset[m + 1:]))        self.n = nk2(0, pts)        self.bounds = bounds T3 = namedtuple(strv, strv)  def find_nearest(k, t, p):    def nn(kd, target, hr, max_dist_sqd):        if kd is None:            return T3([0.0] * k, float(strv), 0)         nodes_visited = 1        s = kd.split        pivot = kd.dom_elt        left_hr = deepcopy(hr)        right_hr = deepcopy(hr)        left_hr.max[s] = pivot[s]        right_hr.min[s] = pivot[s]         if target[s] <= pivot[s]:            nearer_kd, nearer_hr = kd.left, left_hr            further_kd, further_hr = kd.right, right_hr        else:            nearer_kd, nearer_hr = kd.right, right_hr            further_kd, further_hr = kd.left, left_hr         n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd)        nearest = n1.nearest        dist_sqd = n1.dist_sqd        nodes_visited += n1.nodes_visited         if dist_sqd < max_dist_sqd:            max_dist_sqd = dist_sqd        d = (pivot[s] - target[s]) ** 2        if d > max_dist_sqd:            return T3(nearest, dist_sqd, nodes_visited)        d = sqd(pivot, target)        if d < dist_sqd:            nearest = pivot            dist_sqd = d            max_dist_sqd = dist_sqd         n2 = nn(further_kd, target, further_hr, max_dist_sqd)        nodes_visited += n2.nodes_visited        if n2.dist_sqd < dist_sqd:            nearest = n2.nearest            dist_sqd = n2.dist_sqd         return T3(nearest, dist_sqd, nodes_visited)     return nn(t.n, p, t.bounds, float(strv))  def show_nearest(k, heading, kd, p):    print(heading + strv)    print(strv, p)    n = find_nearest(k, kd, p)    print(strv, n.nearest)    print(strv, sqrt(n.dist_sqd))    print(strv, n.nodes_visited, """")  def random_point(k):    return [random() for _ in range(k)]  def random_points(k, n):    return [random_point(k) for _ in range(n)] if __name__ == strv:    seed(1)    P = lambda *coords: list(coords)    kd1 = KdTree([P(2, 3), P(5, 4), P(9, 6), P(4, 7), P(8, 1), P(7, 2)],                  Orthotope(P(0, 0), P(10, 10)))    show_nearest(2, strv, kd1, P(9, 2))     N = 400000    t0 = clock()    kd2 = KdTree(random_points(3, N), Orthotope(P(0, 0, 0), P(1, 1, 1)))    t1 = clock()    text = lambda *parts: strv.join(map(str, parts))    show_nearest(2, text(strv, N,                         strv,                         t1-t0, strv),                 kd2, random_point(3))"
" 
from goto import goto, labellabel .startfor i in range(1, 4):    print i    if i == 2:        try:            output = message        except NameError:            print strv            message = strv            goto .startprint output, """" "
"from math import pi, sin, cosfrom collections import namedtuplefrom random import random, choicefrom copy import copy try:    import psyco    psyco.full()except ImportError:    pass  FLOAT_MAX = 1e100  class Point:    __slots__ = [strv, strv, strv]    def __init__(self, x=0.0, y=0.0, group=0):        self.x, self.y, self.group = x, y, group  def generate_points(npoints, radius):    points = [Point() for _ in xrange(npoints)]     
    for p in points:        r = random() * radius        ang = random() * 2 * pi        p.x = r * cos(ang)        p.y = r * sin(ang)     return points  def nearest_cluster_center(point, cluster_centers):    strv    def sqr_distance_2D(a, b):        return (a.x - b.x) ** 2  +  (a.y - b.y) ** 2     min_index = point.group    min_dist = FLOAT_MAX     for i, cc in enumerate(cluster_centers):        d = sqr_distance_2D(cc, point)        if min_dist > d:            min_dist = d            min_index = i     return (min_index, min_dist)  def kpp(points, cluster_centers):    cluster_centers[0] = copy(choice(points))    d = [0.0 for _ in xrange(len(points))]     for i in xrange(1, len(cluster_centers)):        sum = 0        for j, p in enumerate(points):            d[j] = nearest_cluster_center(p, cluster_centers[:i])[1]            sum += d[j]         sum *= random()         for j, di in enumerate(d):            sum -= di            if sum > 0:                continue            cluster_centers[i] = copy(points[j])            break     for p in points:        p.group = nearest_cluster_center(p, cluster_centers)[0]  def lloyd(points, nclusters):    cluster_centers = [Point() for _ in xrange(nclusters)]     
    kpp(points, cluster_centers)     lenpts10 = len(points) >> 10     changed = 0    while True:        
        for cc in cluster_centers:            cc.x = 0            cc.y = 0            cc.group = 0         for p in points:            cluster_centers[p.group].group += 1            cluster_centers[p.group].x += p.x            cluster_centers[p.group].y += p.y         for cc in cluster_centers:            cc.x /= cc.group            cc.y /= cc.group         
        changed = 0        for p in points:            min_i = nearest_cluster_center(p, cluster_centers)[0]            if min_i != p.group:                changed += 1                p.group = min_i         
        if changed <= lenpts10:            break     for i, cc in enumerate(cluster_centers):        cc.group = i     return cluster_centers  def print_eps(points, cluster_centers, W=400, H=400):    Color = namedtuple(strv, strv);     colors = []    for i in xrange(len(cluster_centers)):        colors.append(Color((3 * (i + 1) % 11) / 11.0,                            (7 * i % 11) / 11.0,                            (9 * i % 11) / 11.0))     max_x = max_y = -FLOAT_MAX    min_x = min_y = FLOAT_MAX     for p in points:        if max_x < p.x: max_x = p.x        if min_x > p.x: min_x = p.x        if max_y < p.y: max_y = p.y        if min_y > p.y: min_y = p.y     scale = min(W / (max_x - min_x),                H / (max_y - min_y))    cx = (max_x + min_x) / 2    cy = (max_y + min_y) / 2     print ""%%!PS-Adobe-3.0%%%%BoundingBox: -5 -5 %d %d"" % (W + 10, H + 10)     print (""/l {rlineto} def /m {rmoveto} def"" +           ""/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def"" +           strv +           strv +           strv)     for i, cc in enumerate(cluster_centers):        print (strv %               (colors[i].r, colors[i].g, colors[i].b))         for p in points:            if p.group != i:                continue            print (strv % ((p.x - cx) * scale + W / 2,                                    (p.y - cy) * scale + H / 2))         print (""0 setgray %g %g s"" % ((cc.x - cx) * scale + W / 2,                                        (cc.y - cy) * scale + H / 2))     print ""%%%%EOF""  def main():    npoints = 30000    k = 7 
     points = generate_points(npoints, 10)    cluster_centers = lloyd(points, k)    print_eps(points, cluster_centers)  main()"
">>> def k(n):	n2 = str(n**2)	for i in range(len(n2)):		a, b = int(n2[:i] or 0), int(n2[i:])		if b and a + b == n:			return n			#return (n, (n2[:i], n2[i:]))  >>> [x for x in range(1,10000) if k(x)][1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4879, 4950, 5050, 5292, 7272, 7777, 9999]>>> len([x for x in range(1,1000000) if k(x)])54>>> def encode(n, base):    result = strv    while n:        n, d = divmod(n, base)        if d < 10:            result += str(d)        else:            result += chr(d - 10 + ord(strv))    return result[::-1]def Kaprekar(n, base):    if n == '1':        return True    sq = encode((int(n, base)**2), base)    for i in range(1,len(sq)):        if (int(sq[:i], base) + int(sq[i:], base) == int(n, base)) and (int(sq[:i], base) > 0) and (int(sq[i:], base)>0):            return True    return Falsedef Find(m, n, base):    return [encode(i, base) for i in range(m,n+1) if Kaprekar(encode(i, base), base)] m = int(raw_input('Where to start?'))n = int(raw_input('Where to stop?'))base = int(raw_input('Enter base:'))KNumbers = Find(m, n, base)for i in KNumbers:    print iprint 'The number of Kaprekar Numbers found are',print len(KNumbers)raw_input() Base = 10N = 6Paddy_cnt = 1for n in range(N):  for V in CastOut(Base,Start=Base**n,End=Base**(n+1)):    for B in range(n+1,n*2+2):      x,y = divmod(V*V,Base**B)      if V == x+y and 0<y:        print('{1}: {0}'.format(V, Paddy_cnt))        Paddy_cnt += 1        break  Base = 16N = 4Paddy_cnt = 1for V in CastOut(Base,Start=1,End=Base**N):  for B in range(1,N*2-1):    x,y = divmod(V*V,Base**B)    if V == x+y and 0<y:      print('{1}: {0:x}'.format(V, Paddy_cnt))      Paddy_cnt += 1      break "
"import sysimport pygame pygame.init() 
clk = pygame.time.Clock() 
if pygame.joystick.get_count() == 0:    raise IOError(strv)joy = pygame.joystick.Joystick(0)joy.init() 
size = width, height = 600, 600screen = pygame.display.set_mode(size)pygame.display.set_caption(strv) 
frameRect = pygame.Rect((45, 45), (510, 510)) 
crosshair = pygame.surface.Surface((10, 10))crosshair.fill(pygame.Color(strv))pygame.draw.circle(crosshair, pygame.Color(strv), (5,5), 5, 0)crosshair.set_colorkey(pygame.Color(strv), pygame.RLEACCEL)crosshair = crosshair.convert() 
writer = pygame.font.Font(pygame.font.get_default_font(), 15)buttons = {}for b in range(joy.get_numbuttons()):    buttons[b] = [        writer.render(            hex(b)[2:].upper(),            1,            pygame.Color(strv),            pygame.Color(strv)        ).convert(),        
        
        ((15*b)+45, 560)    ] while True:    
    pygame.event.pump()    for events in pygame.event.get():        if events.type == pygame.QUIT:            pygame.quit()            sys.exit()     
    screen.fill(pygame.Color(strv))     
    x = joy.get_axis(0)    y = joy.get_axis(1)     
    
    screen.blit(crosshair, ((x*250)+300-5, (y*250)+300-5))    pygame.draw.rect(screen, pygame.Color(strv), frameRect, 1)     
    for b in range(joy.get_numbuttons()):        if joy.get_button(b):            screen.blit(buttons[b][0], buttons[b][1])     
    pygame.display.flip()    clk.tick(40) 
"
"from PIL import Image if __name__ == strv:	w, h, zoom = 800,600,1	bitmap = Image.new(strv, (w, h), strv)	pix = bitmap.load() 	cX, cY = -0.7, 0.27015	moveX, moveY = 0.0, 0.0	maxIter = 255 	for x in range(w):		for y in range(h):			zx = 1.5*(x - w/2)/(0.5*zoom*w) + moveX			zy = 1.0*(y - h/2)/(0.5*zoom*h) + moveY			i = maxIter			while zx*zx + zy*zy < 4 and i > 1:				tmp = zx*zx - zy*zy + cX				zy,zx = 2.0*zx*zy + cY, tmp				i -= 1			
			pix[x,y] = (i << 21) + (i << 10) + i*8 	bitmap.show()"
">>> import json>>> data = json.loads('{ strv] }')>>> sample = { strv: [1,2], strv: strv }>>> json_string = json.dumps(sample)>>> json_string'{strv}'>>> sample{'blue': [1, 2], 'ocean': 'water'}>>> data{'foo': 1, 'bar': [10, 'apples']}>>> true = True; false = False; null = None>>> data = eval('{ strv] }')>>> data{'foo': 1, 'bar': [10, 'apples']}"
">>> def j(n, k):	p, i, seq = list(range(n)), 0, []	while p:		i = (i+k-1) % len(p)		seq.append(p.pop(i))	return 'Prisoner killing order: %s.Survivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1]) >>> print(j(5, 2))Prisoner killing order: 1, 3, 0, 4.Survivor: 2>>> print(j(41, 3))Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.Survivor: 30>>> >>>def josephus(n, k):        r = 0        for i in xrange(1, n+1):            r = (r+k)%i        return 'Survivor: %d' %r >>> print(josephus(5, 2))Survivor: 2>>> print(josephus(41, 3))Survivor: 30>>> def josephus(n, k):    a = list(range(1, n + 1))    a[n - 1] = 0    p = 0    v = []    while a[p] != p:        for i in range(k - 2):            p = a[p]        v.append(a[p])        a[p] = a[a[p]]        p = a[p]    v.append(p)    return v josephus(10, 2)[1, 3, 5, 7, 9, 2, 6, 0, 8, 4] josephus(41, 3)[-1]30"
"class Ref(object):    def __init__(self, value=None):        self.value = value def harmonic_sum(i, lo, hi, term):    
    temp = 0    i.value = lo    while i.value <= hi:  
        temp += term() 
        i.value += 1   
    return temp i = Ref() 

print harmonic_sum(i, 1, 100, lambda: 1.0/i.value)"
">>> step = lambda x: sum(int(d) ** 2 for d in str(x))>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))>>> [iterate(x) for x in xrange(1, 20)][1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]from math import ceil, log10, factorial def next_step(x):    result = 0    while x > 0:        result += (x % 10) ** 2        x /= 10    return result def check(number):    candidate = 0    for n in number:        candidate = candidate * 10 + n     while candidate != 89 and candidate != 1:        candidate = next_step(candidate)     if candidate == 89:        digits_count = [0] * 10        for d in number:            digits_count[d] += 1         result = factorial(len(number))        for c in digits_count:            result /= factorial(c)        return result     return 0 def main():    limit = 100000000    cache_size = int(ceil(log10(limit)))    assert 10 ** cache_size == limit     number = [0] * cache_size    result = 0    i = cache_size - 1     while True:        if i == 0 and number[i] == 9:            break        if i == cache_size - 1 and number[i] < 9:            number[i] += 1            result += check(number)        elif number[i] == 9:            i -= 1        else:            number[i] += 1            for j in xrange(i + 1, cache_size):                number[j] = number[i]            i = cache_size - 1            result += check(number)     print result main()>>> from functools import lru_cache>>> @lru_cache(maxsize=1024)def ids(n):	if n in {1, 89}: return n	else: return ids(sum(int(d) ** 2 for d in str(n)))  >>> ids(15)89>>> [ids(x) for x in range(1, 21)][1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1, 89]>>> sum(ids(x) == 89 for x in range(1, 100000000))85744333>>> >>> from functools import lru_cache>>> @lru_cache(maxsize=1024)def _ids(nt):	if nt in {('1',), ('8', '9')}: return nt	else: return _ids(tuple(sorted(str(sum(int(d) ** 2 for d in nt)))))  >>> def ids(n):	return int(''.join(_ids(tuple(sorted(str(n)))))) >>> ids(1), ids(15)(1, 89)>>> [ids(x) for x in range(1, 21)][1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1, 89]>>> sum(ids(x) == 89 for x in range(1, 100000000))85744333>>> _ids.cache_info()CacheInfo(hits=99991418, misses=5867462, maxsize=1024, currsize=1024)>>> from __future__ import print_functionfrom itertools import count def check89(n):    while True:        n, t = 0, n        while t: n, t = n + (t%10)**2, t//10        if n <= 1: return False        if n ==89: return True a, sq, is89 = [1], [x**2 for x in range(1, 10)], [False]for n in range(1, 500):    b, a = a, a + [0]*81    is89 += map(check89, range(len(b), len(a)))     for i,v in enumerate(b):        for s in sq: a[i + s] += v     x = sum(a[i] for i in range(len(a)) if is89[i])    print(strv % n, x)"
">>> def jortSort(myarray):	return list(myarray) == sorted(myarray)>>> for data in [(1,2,4,3), (14,6,8), ['a', 'c'], ['s', 'u', 'x'], 'CVGH', 'PQRST']:	print('jortSort(%r) is %s' % (data, jortSort(data)))jortSort((1, 2, 4, 3)) is FalsejortSort((14, 6, 8)) is FalsejortSort(['a', 'c']) is TruejortSort(['s', 'u', 'x']) is TruejortSort('CVGH') is FalsejortSort('PQRST') is True>>> def jortSort(array):   
  originalArray = list(array)  array.sort()   
  for i in range(len(originalArray)):    if originalArray[i] != array[i]:      return False   return True"
x = truevalue if condition else falsevaluewith open(strv) as f:    something(f)
"
 import sys major, minor, bugfix = sys.version_info[:3] if major < 2:     sys.exit('Python 2 is required')   def defined(name): 
     return name in globals() or name in locals() or name in vars(__builtins__)  def defined2(name): 
     try:          eval(name)          return True     except NameError:          return False  if defined('bloop') and defined('abs') and callable(abs):     print abs(bloop)  if defined2('bloop') and defined2('abs') and callable(abs):     print abs(bloop)try:    print abs(bloop)except (NameError, TypeError):    print strvdef sum_of_global_int_vars():    variables = vars(__builtins__).copy()    variables.update(globals())    print sum(v for v in variables.itervalues() if type(v) == int) sum_of_global_int_vars()"
"from __future__ import division def jaro(s, t):    s_len = len(s)    t_len = len(t)     if s_len == 0 and t_len == 0:        return 1     match_distance = (max(s_len, t_len) // 2) - 1     s_matches = [False] * s_len    t_matches = [False] * t_len     matches = 0    transpositions = 0     for i in range(s_len):        start = max(0, i-match_distance)        end = min(i+match_distance+1, t_len)         for j in range(start, end):            if t_matches[j]:                continue            if s[i] != t[j]:                continue            s_matches[i] = True            t_matches[j] = True            matches += 1            break     if matches == 0:        return 0     k = 0    for i in range(s_len):        if not s_matches[i]:            continue        while not t_matches[k]:            k += 1        if s[i] != t[k]:            transpositions += 1        k += 1     return ((matches / s_len) +            (matches / t_len) +            ((matches - transpositions/2) / matches)) / 3 for s,t in [(   'MARTHA',      'MARHTA'),            (    'DIXON',    'DICKSONX'),            ('JELLYFISH',  'SMELLYFISH')]:    print(strv % (s, t, jaro(s, t)))"
i=1while i:    print(i)    i += 1from itertools import count for i in count():     print(i)
"def root(a,b):    if b<2:return b    a1=a-1    c=1    d=(a1*c+b//(c**a1))//a    e=(a1*d+b//(d**a1))//a    while c!=d and c!=e:        c,d,e=d,e,(a1*e+b//(e**a1))//a    return min(d,e)print(""First 2,001 digits of the square root of two:{}"".format(root(2,2*100**2000)))"
"'''
This implements: http://en.wikipedia.org/wiki/Inverted_index of 28/07/10
''' from pprint import pprint as ppfrom glob import globtry: reduceexcept: from functools import reducetry:    raw_inputexcept: raw_input = input  def parsetexts(fileglob='InvertedIndex/T*.txt'):    texts, words = {}, set()    for txtfile in glob(fileglob):        with open(txtfile, 'r') as f:            txt = f.read().split()            words |= set(txt)            texts[txtfile.split('')[-1]] = txt    return texts, words def termsearch(terms): 
    return reduce(set.intersection,                  (invindex[term] for term in terms),                  set(texts.keys())) texts, words = parsetexts()print('Texts')pp(texts)print('Words')pp(sorted(words)) invindex = {word:set(txt                        for txt, wrds in texts.items() if word in wrds)            for word in words}print('Inverted Index')pp({k:sorted(v) for k,v in invindex.items()}) terms = [strv, strv, strv]print('Term Search for: ' + repr(terms))pp(sorted(termsearch(terms)))from collections import Counter  def termsearch(terms): 
    if not set(terms).issubset(words):        return set()    return reduce(set.intersection,                  (set(x[0] for x in txtindx)                   for term, txtindx in finvindex.items()                   if term in terms),                  set(texts.keys()) ) def phrasesearch(phrase):    wordsinphrase = phrase.strip().strip('""').split()    if not set(wordsinphrase).issubset(words):        return set()    #firstword, *otherwords = wordsinphrase # Only Python 3    firstword, otherwords = wordsinphrase[0], wordsinphrase[1:]    found = []    for txt in termsearch(wordsinphrase):        
        for firstindx in (indx for t,indx in finvindex[firstword]                          if t == txt):            
            if all( (txt, firstindx+1 + otherindx) in finvindex[otherword]                    for otherindx, otherword in enumerate(otherwords) ):                found.append(txt)    return found  finvindex = {word:set((txt, wrdindx)                      for txt, wrds in texts.items()                      for wrdindx in (i for i,w in enumerate(wrds) if word==w)                      if word in wrds)             for word in words}print('Full Inverted Index')pp({k:sorted(v) for k,v in finvindex.items()}) print('Term Search on full inverted index for: ' + repr(terms))pp(sorted(termsearch(terms))) phrase = 'strv'print('Phrase Search for: ' + phrase)print(phrasesearch(phrase)) 
phrase = 'strv'print('Phrase Search for: ' + phrase)ans = phrasesearch(phrase)print(ans)ans = Counter(ans)print('  The phrase is found most commonly in text: ' + repr(ans.most_common(1)[0][0]))"
"pythonPython 2.6.1 (r261:67517, Dec  4 2008, 16:51:00) [MSC v.1500 32 bit (Intel)] onwin32Type strv, strv, strv or strv for more information.>>> def f(string1, string2, separator):	return separator.join([string1, '', string2]) >>> f('Rosetta', 'Code', ':')'Rosetta::Code'>>>"
"def do_stuff(a, b):	return a + b t = input()for x in range(0, t):	a, b = raw_input().strip().split()	print do_stuff(int(a), int(b))>>> try: raw_inputexcept NameError: raw_input = input >>> for i in range(int(raw_input())):	print(sum(int(numberstring)		  for numberstring		  in raw_input().strip().split()))  51 2310 2030-3 52100 21025 510>>> >>> for i in range(int(raw_input('lines: '))):	print(sum(int(numberstring)                   for numberstring in raw_input('two numbers: ').strip().split()))  lines: 5two numbers: 1 23two numbers: 10 2030two numbers: -3 52two numbers: 100 2102two numbers: 5 510>>> "
try: input = raw_inputexcept: pass def do_stuff(words):	print(words) linecount = int(input())for x in range(linecount):	line = input()	do_stuff(line)
"Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32Type strv, strv or strv for more information.>>> for calc in '''   -(-2147483647-1)
   2000000000 + 2000000000
   -2147483647 - 2147483647
   46341 * 46341
   (-2147483647-1) / -1'''.split(''):	ans = eval(calc)	print('Expression: %r evaluates to %s of type %s'	      % (calc.strip(), ans, type(ans)))  Expression: '-(-2147483647-1)' evaluates to 2147483648 of type <type 'long'>Expression: '2000000000 + 2000000000' evaluates to 4000000000 of type <type 'long'>Expression: '-2147483647 - 2147483647' evaluates to -4294967294 of type <type 'long'>Expression: '46341 * 46341' evaluates to 2147488281 of type <type 'long'>Expression: '(-2147483647-1) / -1' evaluates to 2147483648 of type <type 'long'>>>> Python 3.4.1 (v3.4.1:c0e311e010fc, May 18 2014, 10:38:22) [MSC v.1600 32 bit (Intel)] on win32Type strv, strv or strv for more information.>>> for calc in '''   -(-2147483647-1)
   2000000000 + 2000000000
   -2147483647 - 2147483647
   46341 * 46341
   (-2147483647-1) / -1'''.split(''):	ans = eval(calc)	print('Expression: %r evaluates to %s of type %s'	      % (calc.strip(), ans, type(ans)))  Expression: '-(-2147483647-1)' evaluates to 2147483648 of type <class 'int'>Expression: '2000000000 + 2000000000' evaluates to 4000000000 of type <class 'int'>Expression: '-2147483647 - 2147483647' evaluates to -4294967294 of type <class 'int'>Expression: '46341 * 46341' evaluates to 2147488281 of type <class 'int'>Expression: '(-2147483647-1) / -1' evaluates to 2147483648.0 of type <class 'float'>>>> "
"#!/usr/bin/env pythona = input('Enter value of a: ')b = input('Enter value of b: ') if a < b:    print 'a is less than b'elif a > b:    print 'a is greater than b'elif a == b:    print 'a is equal to b'#!/usr/bin/env pythonimport systry:   a = input('Enter value of a: ')   b = input('Enter value of b: ')except (ValueError, EnvironmentError), err:   print sys.stderr, strv, err   sys.exit(1) dispatch = {    -1: 'is less than',     0: 'is equal to',     1: 'is greater than'     } print a, dispatch[cmp(a,b)], b"
"while(True):      x = input(strv)      print(x)my_file = open(filename, 'r')try:    for line in my_file:        pass 
finally:    my_file.close()from __future__ import with_statement with open(filename, 'r') as f:    for line in f:        pass 
line = my_file.readline() 
lines = my_file.readlines() 
import fileinputfor line in fileinput.input():    pass 
"
"class Camera:  pass #functions go here...class MobilePhone:  pass #functions go here...class CameraPhone(Camera, MobilePhone):  pass #functions go here..."
"class Animal:  pass #functions go here... class Dog(Animal):  pass #functions go here... class Cat(Animal):  pass #functions go here... class Lab(Dog):  pass #functions go here... class Collie(Dog):  pass #functions go here...import time class Animal(object):    def __init__(self, birth=None, alive=True):        self.birth = birth if birth else time.time()        self.alive = alive    def age(self):        return time.time() - self.birth    def kill(self):        self.alive = False class Dog(Animal):    def __init__(self, bones_collected=0, **kwargs):        self.bone_collected = bones_collected        super(Dog, self).__init__(**kwargs) class Cat(Animal):    max_lives = 9    def __init__(self, lives=max_lives, **kwargs):        self.lives = lives        super(Cat, self).__init__(**kwargs)    def kill(self):        if self.lives>0:            self.lives -= 1            if self.lives == 0:                super(Cat, self).kill()        else:            raise ValueError        return self class Labrador(Dog):    def __init__(self, guide_dog=False, **kwargs):        self.guide_dog=False        super(Labrador, self).__init__(**kwargs) class Collie(Dog):    def __init__(self, sheep_dog=False, **kwargs):        self.sheep_dog=False        super(Collie, self).__init__(**kwargs) lassie = Collie()felix = Cat()felix.kill().kill().kill()mr_winkle = Dog()buddy = Labrador()buddy.kill()print strv,felix.lives, strv,strv%(strv if buddy.alive else strv)"
"def rank(x): return int('a'.join(map(str, [1] + x)), 11) def unrank(n):	s = ''	while n: s,n = strv[n%11] + s, n//11	return map(int, s.split('a'))[1:] l = [1, 2, 3, 10, 100, 987654321]print ln = rank(l)print nl = unrank(n)print ldef unrank(n):        return map(len, bin(n)[3:].split(strv)) if n else [] def rank(x):        return int('1' + '0'.join('1'*a for a in x), 2) if x else 0 for x in range(11):        print x, unrank(x), rank(unrank(x)) printx = [1, 2, 3, 5, 8];print x, rank(x), unrank(rank(x)) "
">>> float('infinity')inf>>> 1.0 / 0.0Traceback (most recent call last):  File strv, line 1, in <module>ZeroDivisionError: float division"
"from fractions import Fractionfrom decimal import Decimal, getcontextgetcontext().prec = 60from itertools import product casting_functions = [int, float, complex,   
                     Fraction, Decimal,     
                     hex, oct, bin,         
                     bool,                  
                     iter,                  
                     list, tuple, range,    
                     str, bytes,            
                     bytearray,             
                     set, frozenset,        
                     dict,                  
                    ] examples_of_types = [0, 42,                      0.0 -0.0, 12.34, 56.0,                      (0+0j), (1+2j), (1+0j), (78.9+0j), (0+1.2j),                     Fraction(0, 1), Fraction(22, 7), Fraction(4, 2),                      Decimal('0'),                     Decimal('3.14159265358979323846264338327950288419716939937510'),                     Decimal('1'), Decimal('1.5'),                     True, False,                     iter(()), iter([1, 2, 3]), iter({'A', 'B', 'C'}),                      iter([[1, 2], [3, 4]]), iter((('a', 1), (2, 'b'))),                     [], [1, 2], [[1, 2], [3, 4]],                     (), (1, 'two', (3+0j)), (('a', 1), (2, 'b')),                     range(0), range(3),                     strv, strv, strv, strv,                     bstrv, bstrv, bstrv,                     bytearray(bstrv), bytearray(bstrv), bytearray(bstrv),                     set(), {1, 'two', (3+0j), (4, 5, 6)},                     frozenset(), frozenset({1, 'two', (3+0j), (4, 5, 6)}),                     {}, {1: 'one', 'two': (2+3j), ('RC', 3): None}                     ]if __name__ == '__main__':    print('Common Python types/type casting functions:')    print('  ' + '  '.join(f.__name__ for f in casting_functions))    print('Examples of those types:')    print('  ' + '  '.join('%-26s %r' % (type(e), e) for e in examples_of_types))    print('Casts of the examples:')    for f, e in product(casting_functions, examples_of_types):        try:            ans = f(e)        except BaseException:            ans = 'EXCEPTION RAISED!'        print('%-60s -> %r' % ('%s(%r)' % (f.__name__, e), ans))"
next = str(int('123') + 1)
"classes = (str.isupper, str.islower, str.isalnum, str.isalpha, str.isdecimal,           str.isdigit, str.isidentifier, str.isnumeric, str.isprintable,           str.isspace, str.istitle) for stringclass in classes:    chars = ''.join(chr(i) for i in range(0x10FFFF+1) if stringclass(chr(i)))    print('String class %s has %i characters the first of which are:  %r'          % (stringclass.__name__, len(chars), chars[:100]))"
"import timeimport randomimport Tkinterimport Image, ImageTk 
 class App(object):    def __init__(self, size, root):        self.root = root        self.root.title(strv)         self.img = Image.new(strv, size)        self.label = Tkinter.Label(root)        self.label.pack()         self.time = 0.0        self.frames = 0        self.size = size        self.loop()     def loop(self):        self.ta = time.time()        
        rnd = random.random        white = (255, 255, 255)        black = (0, 0, 0)        npixels = self.size[0] * self.size[1]        data = [white if rnd() > 0.5 else black for i in xrange(npixels)]        self.img.putdata(data)        self.pimg = ImageTk.PhotoImage(self.img)        self.label[strv] = self.pimg        self.tb = time.time()         self.time += (self.tb - self.ta)        self.frames += 1         if self.frames == 30:            try:                self.fps = self.frames / self.time            except:                self.fps = strv            print (strv %                  (self.frames, self.time, self.fps))            self.time = 0            self.frames = 0         self.root.after(1, self.loop) def main():    root = Tkinter.Tk()    app = App((320, 240), root)    root.mainloop() main()"
import mymodulemymodule.variable
"#!/bin/pythonfrom PIL import Image, ImageFilter if __name__==strv:	im = Image.open(strv) 	kernelValues = [-2,-1,0,-1,1,1,0,1,2] #emboss	kernel = ImageFilter.Kernel((3,3), kernelValues) 	im2 = im.filter(kernel) 	im2.show()#!/bin/pythonimport numpy as npfrom scipy.ndimage.filters import convolvefrom scipy.misc import imread, imshow if __name__==strv:	im = imread(strv, mode=strv)	im = np.array(im, dtype=float) #Convert to float to prevent clipping colors 	kernel = np.array([[[0,-2,0],[0,-1,0],[0,0,0]],						[[0,-1,0],[0,1,0],[0,1,0]],						[[0,0,0],[0,1,0],[0,2,0]]])#emboss 	im2 = convolve(im, kernel)	im3 = np.array(np.clip(im2, 0, 255), dtype=np.uint8) #Apply color clipping 	imshow(im3)"
"def identity(size):    matrix = [[0]*size for i in range(size)]    #matrix = [[0] * size] * size    #Has a flaw. See http://stackoverflow.com/questions/240178/unexpected-feature-in-a-python-list-of-lists     for i in range(size):        matrix[i][i] = 1     for rows in matrix:        for elements in rows:            print elements,        print strv>>> def identity(size):...     return {(x, y):int(x == y) for x in range(size) for y in range(size)}... >>> size = 4>>> matrix = identity(size)>>> print(''.join(' '.join(str(matrix[(x, y)]) for x in range(size)) for y in range(size)))1 0 0 00 1 0 00 0 1 00 0 0 1>>>  np.mat(np.eye(size)) "
"#
#def DrawBoard(board):  peg = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]  for n in xrange(1,16):    peg[n] = '.'    if n in board:      peg[n] = strv % n  print strv % peg[1]  print strv % (peg[2],peg[3])  print strv % (peg[4],peg[5],peg[6])  print strv % (peg[7],peg[8],peg[9],peg[10])  print strv % (peg[11],peg[12],peg[13],peg[14],peg[15])# 
def RemovePeg(board,n):  board.remove(n) 
def AddPeg(board,n):  board.append(n) 
def IsPeg(board,n):  return n in board 

JumpMoves = { 1: [ (2,4),(3,6) ],  
              2: [ (4,7),(5,9)  ],              3: [ (5,8),(6,10) ],              4: [ (2,1),(5,6),(7,11),(8,13) ],              5: [ (8,12),(9,14) ],              6: [ (3,1),(5,4),(9,13),(10,15) ],              7: [ (4,2),(8,9)  ],              8: [ (5,3),(9,10) ],              9: [ (5,2),(8,7)  ],             10: [ (9,8) ],             11: [ (12,13) ],             12: [ (8,5),(13,14) ],             13: [ (8,4),(9,6),(12,11),(14,15) ],             14: [ (9,5),(13,12)  ],             15: [ (10,6),(14,13) ]            } Solution = []#
#def Solve(board):  #DrawBoard(board)  if len(board) == 1:    return board 
  
  for peg in xrange(1,16): 
    if IsPeg(board,peg):      movelist = JumpMoves[peg]      for over,land in movelist:        if IsPeg(board,over) and not IsPeg(board,land):          saveboard = board[:] 
          RemovePeg(board,peg)          RemovePeg(board,over)          AddPeg(board,land) 
           Solution.append((peg,over,land))           board = Solve(board)          if len(board) == 1:            return board        ## undo move and back track when stuck!          board = saveboard[:] 
          del Solution[-1] 
  return board #
#def InitSolve(empty):  board = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]  RemovePeg(board,empty_start)  Solve(board) #empty_start = 1InitSolve(empty_start) board = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]RemovePeg(board,empty_start)for peg,over,land in Solution:  RemovePeg(board,peg)  RemovePeg(board,over)  AddPeg(board,land) 
  DrawBoard(board)  print ""Peg %X jumped over %X to land on %X"" % (peg,over,land)"
"import httplib connection = httplib.HTTPSConnection('www.example.com',cert_file='myCert.PEM')connection.request('GET','/index.html')response = connection.getresponse()data = response.read() "
"import re _country2length = dict(    AL=28, AD=24, AT=20, AZ=28, BE=16, BH=22, BA=20, BR=29,    BG=22, CR=21, HR=21, CY=28, CZ=24, DK=18, DO=28, EE=20,    FO=18, FI=18, FR=27, GE=22, DE=22, GI=23, GR=27, GL=18,    GT=28, HU=28, IS=26, IE=22, IL=23, IT=27, KZ=20, KW=30,    LV=21, LB=28, LI=21, LT=20, LU=20, MK=19, MT=31, MR=27,    MU=30, MC=27, MD=24, ME=22, NL=18, NO=15, PK=24, PS=29,    PL=28, PT=25, RO=24, SM=27, SA=24, RS=22, SK=24, SI=19,    ES=24, SE=24, CH=21, TN=24, TR=26, AE=23, GB=22, VG=24 ) def valid_iban(iban):    
    iban = iban.replace(' ','').replace('','')    if not re.match(r'^[A-Z]+$', iban):         return False    
    if len(iban) != _country2length[iban[:2]]:        return False    
    iban = iban[4:] + iban[:4]    digits = int(''.join(str(int(ch, 36)) for ch in iban)) #BASE 36: 0..9,A..Z -> 0..35    return digits % 97 == 1 if __name__ == '__main__':    for account in [strv, strv]:        print('%s validation is: %s' % (account, valid_iban(account)))"
"#!/usr/bin/python
 from mechanize import Browser USER_AGENT = strv br = Browser()br.addheaders = [(strv, USER_AGENT)] 



 br.open(strv) br.select_form(strv)br['email'] = """"br['pass'] = strvbr['persistent'] = [strv] response = br.submit()print response.read()"
"import urllib.requestimport re PLAUSIBILITY_RATIO = 2 def plausibility_check(comment, x, y):    print('  Checking plausibility of: %s' % comment)    if x > PLAUSIBILITY_RATIO * y:        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'              % (x, y, x / y))    else:        if x > y:            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'                  % (x, y, x / y))        else:            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'                  % (x, y, x / y))    return x > PLAUSIBILITY_RATIO * y def simple_stats(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):    words = urllib.request.urlopen(url).read().decode().lower().split()    cie = len({word for word in words if 'cie' in word})    cei = len({word for word in words if 'cei' in word})    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})    return cei, cie, not_c_ie, not_c_ei def print_result(cei, cie, not_c_ie, not_c_ei):    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)         & plausibility_check('E before I when preceded by C', cei, cie) ):        print('OVERALL IT IS PLAUSIBLE!')    else:        print('OVERALL IT IS IMPLAUSIBLE!')    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO) print('Checking plausibility of strv:')print_result(*simple_stats())def stretch_stats(url='http://ucrel.lancs.ac.uk/bncfreq/lists/1_2_all_freq.txt'):    freq = [line.strip().lower().split()            for line in urllib.request.urlopen(url)            if len(line.strip().split()) == 3]    wordfreq = [(word.decode(), int(frq))                for word, pos, frq in freq[1:]                if (b'ie' in word) or (b'ei' in word)]    cie = sum(frq for word, frq in wordfreq if 'cie' in word)    cei = sum(frq for word, frq in wordfreq if 'cei' in word)    not_c_ie = sum(frq for word, frq in wordfreq if re.search(r'(^ie|[^c]ie)', word))    not_c_ei = sum(frq for word, frq in wordfreq if re.search(r'(^ei|[^c]ei)', word))    return cei, cie, not_c_ie, not_c_ei print('Checking plausibility of strv')print('And taking account of word frequencies in British English:')print_result(*stretch_stats())"
"from heapq import heappush, heappop, heapifyfrom collections import defaultdict def encode(symb2freq):    strv    heap = [[wt, [sym, strv]] for sym, wt in symb2freq.items()]    heapify(heap)    while len(heap) > 1:        lo = heappop(heap)        hi = heappop(heap)        for pair in lo[1:]:            pair[1] = '0' + pair[1]        for pair in hi[1:]:            pair[1] = '1' + pair[1]        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p)) txt = strvsymb2freq = defaultdict(int)for ch in txt:    symb2freq[ch] += 1

huff = encode(symb2freq)print ""SymbolWeightHuffman Code""for p in huff:    print ""%s%s%s"" % (p[0], symb2freq[p[0]], p[1])"
 from urllib.request import urlopenprint(urlopen('https://sourceforge.net/').read())  from urllib2 import urlopenprint urlopen('https://sourceforge.net/').read() 
" import urllib.requestprint(urllib.request.urlopen(strv).read())  from http.client import HTTPConnectionconn = HTTPConnection(strv)
conn.request(strv, strv)  
result = conn.getresponse()r1 = result.read() 
  import urllibprint urllib.urlopen(strv).read()  import urllib2print urllib2.urlopen(strv).read() "
import sockethost = socket.gethostname()
" from math import hypot, pi, cos, sinfrom PIL import Image  def hough(im, ntx=460, mry=360):    strv    pim = im.load()    nimx, mimy = im.size    mry = int(mry/2)*2          #Make sure that this is even    him = Image.new(strv, (ntx, mry), 255)    phim = him.load()     rmax = hypot(nimx, mimy)    dr = rmax / (mry/2)    dth = pi / ntx     for jx in xrange(nimx):        for iy in xrange(mimy):            col = pim[jx, iy]            if col == 255: continue            for jtx in xrange(ntx):                th = dth * jtx                r = jx*cos(th) + iy*sin(th)                iry = mry/2 + int(r/dr+0.5)                phim[jtx, iry] -= 1    return him  def test():    strv    im = Image.open(strv).convert(strv)    him = hough(im)    him.save(strv)  if __name__ == strv: test()  "
">>> import platform, sys, socket>>> platform.architecture()('64bit', 'ELF')>>> platform.machine()'x86_64'>>> platform.node()'yourhostname'>>> platform.system()'Linux'>>> sys.byteorderlittle>>> socket.gethostname()'yourhostname'>>>"
">>> def horner(coeffs, x):	acc = 0	for c in reversed(coeffs):		acc = acc * x + c	return acc >>> horner( (-19, 7, -4, 6), 3)128>>> try: from functools import reduceexcept: pass >>> def horner(coeffs, x):	return reduce(lambda acc, c: acc * x + c, reversed(coeffs), 0) >>> horner( (-19, 7, -4, 6), 3)128>>> import numpy>>> numpy.polynomial.polynomial.polyval(3, (-19, 7, -4, 6))128.0"
"from dateutil.easter import *import datetime, calendar class Holiday(object):    def __init__(self, date, offset=0):        self.holiday = date + datetime.timedelta(days=offset)     def __str__(self):        dayofweek = calendar.day_name[self.holiday.weekday()][0:3]        month = calendar.month_name[self.holiday.month][0:3]        return '{0} {1:2d} {2}'.format(dayofweek, self.holiday.day, month) def get_holiday_values(year):    holidays = {'year': year}    easterDate = easter(year)    holidays['easter'] = Holiday(easterDate)     holidays['ascension'] = Holiday(easterDate, 39)    holidays['pentecost'] = Holiday(easterDate, 49)    holidays['trinity'] = Holiday(easterDate, 56)    holidays['corpus'] = Holiday(easterDate, 60)    return holidays def print_holidays(holidays):    print '{year:4d} Easter: {easter}, Ascension: {ascension}, Pentecost: {pentecost}, Trinity: {trinity}, Corpus: {corpus}'.format(**holidays) if __name__ == strv:    print strv    for year in range(400, 2200, 100):        print_holidays(get_holiday_values(year))     print ''    print strv    for year in range(2010, 2021):        print_holidays(get_holiday_values(year))  "
"from __future__ import print_functionimport mathtry: raw_inputexcept: raw_input = input lat = float(raw_input(strv))lng = float(raw_input(strv))ref = float(raw_input(strv))print() slat = math.sin(math.radians(lat))print(strv % slat)print(strv % (lng-ref))print()print(strv) for h in range(-6, 7):  hra = 15 * h  hra -= lng - ref  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))  print(strv % (h, hra, hla))"
"from __future__ import division def maxandmallows(nmaxpower2):    nmax = 2**nmaxpower2    mx = (0.5, 2)    mxpow2 = []    mallows = None     
    
    hc = [None, 1, 1]     for n in range(2, nmax + 1):        ratio = hc[n] / n        if ratio > mx[0]:            mx = (ratio, n)        if ratio >= 0.55:            mallows = n        if ratio == 0.5:            print(strv %		  (n//2, n, mx[0], mx[1]))            mxpow2.append(mx[0])            mx = (ratio, n)        hc.append(hc[hc[n]] + hc[-hc[n]])     return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None if __name__ == '__main__':    hc, mallows = maxandmallows(20)    if mallows:        print(""You too might have won $1000 with the mallows number of %i"" % mallows) "
"def ffr(n):    if n < 1 or type(n) != int: raise ValueError(strv)    try:        return ffr.r[n]    except IndexError:        r, s = ffr.r, ffs.s        ffr_n_1 = ffr(n-1)        lastr = r[-1]        
        s += list(range(s[-1] + 1, lastr))        if s[-1] < lastr: s += [lastr + 1]        
        len_s = len(s)        ffs_n_1 = s[n-1] if len_s > n else (n - len_s) + s[-1]        ans = ffr_n_1 + ffs_n_1        r.append(ans)        return ansffr.r = [None, 1] def ffs(n):    if n < 1 or type(n) != int: raise ValueError(strv)    try:        return ffs.s[n]    except IndexError:        r, s = ffr.r, ffs.s        for i in range(len(r), n+2):            ffr(i)            if len(s) > n:                return s[n]        raise Exception(strv)ffs.s = [None, 2] if __name__ == '__main__':    first10 = [ffr(i) for i in range(1,11)]    assert first10 == [1, 3, 7, 12, 18, 26, 35, 45, 56, 69], strv    print(strv, first10)    #    bin = [None] + [0]*1000    for i in range(40, 0, -1):        bin[ffr(i)] += 1    for i in range(960, 0, -1):        bin[ffs(i)] += 1    if all(b == 1 for b in bin[1:1000]):        print(strv)    else:        print(strv)cR = [1]cS = [2] def extend_RS():	x = cR[len(cR) - 1] + cS[len(cR) - 1]	cR.append(x)	cS += range(cS[-1] + 1, x)	cS.append(x + 1) def ff_R(n):	assert(n > 0)	while n > len(cR): extend_RS()	return cR[n - 1] def ff_S(n):	assert(n > 0)	while n > len(cS): extend_RS()	return cS[n - 1] 
print([ ff_R(i) for i in range(1, 11) ]) s = {}for i in range(1, 1001): s[i] = 0for i in range(1, 41):  del s[ff_R(i)]for i in range(1, 961): del s[ff_S(i)] 
print(strv)from itertools import islice def R():	n = 1	yield n	for s in S():		n += s		yield n; def S():	yield 2	yield 4	u = 5	for r in R():		if r <= u: continue;		for x in range(u, r): yield x		u = r + 1 def lst(s, n): return list(islice(s(), n)) print strv, lst(R, 10)print strv, lst(S, 10)print sorted(lst(R, 40) + lst(S, 960)) == list(range(1,1001)) 

"
"def q(n):    if n < 1 or type(n) != int: raise ValueError(strv)    try:        return q.seq[n]    except IndexError:        ans = q(n - q(n - 1)) + q(n - q(n - 2))        q.seq.append(ans)        return ansq.seq = [None, 1, 1] if __name__ == '__main__':    first10 = [q(i) for i in range(1,11)]    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], strv    print(strv, ', '.join(str(i) for i in first10))    assert q(1000) == 502, strv    print(strv, q(1000))from sys import getrecursionlimit def q1(n):    if n < 1 or type(n) != int: raise ValueError(strv)    try:        return q.seq[n]    except IndexError:        len_q, rlimit = len(q.seq), getrecursionlimit()        if (n - len_q) > (rlimit // 5):            for i in range(len_q, n, rlimit // 5):                q(i)        ans = q(n - q(n - 1)) + q(n - q(n - 2))        q.seq.append(ans)        return ans if __name__ == '__main__':    tmp = q1(100000)    print(strv %          sum(k1 < k0 for k0, k1 in zip(q.seq[1:], q.seq[2:])))def q(n):    l = len(q.seq)    while l <= n:        q.seq.append(q.seq[l - q.seq[l - 1]] + q.seq[l - q.seq[l - 2]])	l += 1    return q.seq[n]q.seq = [None, 1, 1] print(strv, [q(i) for i in range(1, 11)])print(strv, q(1000))q(100000)print(strv %      sum([q.seq[i] > q.seq[i + 1] for i in range(1, 100000)]))"
"import sys HIST = {} def trace(frame, event, arg):    for name,val in frame.f_locals.items():        if name not in HIST:            HIST[name] = []        else:            if HIST[name][-1] is val:                continue        HIST[name].append(val)    return trace def undo(name):    HIST[name].pop(-1)    return HIST[name][-1] def main():    a = 10    a = 20     for i in range(5):        c = i     print strv, c, strv,    c = undo('c')    c = undo('c')    c = undo('c')    print c    print 'HIST:', HIST sys.settrace(trace)main()"
"from decimal import Decimalimport math def h(n):    'Simple, reduced precision calculation'    return math.factorial(n) / (2 * math.log(2) ** (n + 1)) def h2(n):    'Extended precision Hickerson function'    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1)) for n in range(18):    x = h2(n)    norm = str(x.normalize())    almostinteger = (' Nearly integer'                      if 'E' not in norm and ('.0' in norm or '.9' in norm)                      else ' NOT nearly integer!')    print('n:%2i h:%s%s' % (n, norm, almostinteger))"
"print(strv
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
strv)"
"from wsgiref.simple_server import make_server def app(environ, start_response):    start_response('200 OK', [('Content-Type','text/html')])    yield bstrv server = make_server('127.0.0.1', 8080, app)server.serve_forever()with server_socket socket :port 4000  accepting client :from socket    making stdout outfile+fd.client      prn strv      prn strv      prn strv      prn strv"
"from __future__ import division, print_functionfrom math import sqrtfrom fractions import gcdfrom itertools import product  def hero(a, b, c):    s = (a + b + c) / 2    a2 = s*(s-a)*(s-b)*(s-c)    return sqrt(a2) if a2 > 0 else 0  def is_heronian(a, b, c):    a = hero(a, b, c)    return a > 0 and a.is_integer()  def gcd3(x, y, z):     return gcd(gcd(x, y), z)  if __name__ == '__main__':    maxside = 200    h = [(a, b, c) for a,b,c in product(range(1, maxside + 1), repeat=3)          if a <= b <= c and a + b > c and gcd3(a, b, c) == 1 and is_heronian(a, b, c)]    h.sort(key = lambda x: (hero(*x), sum(x), x[::-1]))   
    print('Primitive Heronian triangles with sides up to %i:' % maxside, len(h))    print('First ten when ordered by increasing area, then perimeter,then maximum sides:')    print(''.join('  %14r perim: %3i area: %i'                     % (sides, sum(sides), hero(*sides)) for sides in h[:10]))    print('All with area 210 subject to the previous ordering:')    print(''.join('  %14r perim: %3i area: %i'                     % (sides, sum(sides), hero(*sides)) for sides in h                    if hero(*sides) == 210))"
def first(function):    return function() def second():    return strv result = first(second)  result = first(lambda: strv)
"import syssys.stdout.write(strv)print(strv, end=strv)"
"import sys print >> sys.stderr, strvimport sys print(strv, file=sys.stderr)import sys sys.stderr.write(""Goodbye, World!"")"
"echo(strv)print strvimport syssys.stdout.write(""Hello world!"")print(strv)import __hello__import __phello__import __phello__.spam"
print strv
"lp = open(strv)lp.write(""Hello World!"")lp.close()lp = open(strv,strv)lp.write(""Hello World!"")lp.close()"
"import tkMessageBox result = tkMessageBox.showinfo(strv, strv)from tkinter import messagebox result = messagebox.showinfo(strv, strv)import PyQt4.QtGuiapp = PyQt4.QtGui.QApplication([])pb = PyQt4.QtGui.QPushButton('Hello World')pb.connect(pb,PyQt4.QtCore.SIGNAL(strv),pb.close)pb.show()exit(app.exec_())import pygtkpygtk.require('2.0')import gtk window = gtk.Window()window.set_title('Goodbye, World')window.connect('delete-event', gtk.main_quit)window.show_all()gtk.main() 
from visual import * scene.title = strvscene.background = color.gray(0.2) scene.width  = 600scene.height = 400scene.range  = 4#scene.autocenter = True S = sphere(pos=(0,0,0), radius=1, material=materials.earth)rot=0.005 txPos=(0, 1.2, 0) from visual.text import *
T1 = text(pos=txPos, string='HELLO', color=color.red, depth=0.3, justify='center') import vis
T2 = vis.text(pos=txPos, text=strv, color=color.green, depth=-0.3, align='center')T2.visible=False Lbl_w = label(pos=(0,0,0), text='World', color=color.cyan,              xoffset=80, yoffset=-40)     
 L1 = label(pos=(0,-1.5,0), text='Drag with right mousebutton to rotate view',   box=0)L2 = label(pos=(0,-1.9,0), text='Drag up+down with middle mousebutton to zoom', box=0)L3 = label(pos=(0,-2.3,0), text='Left-click to change', color=color.orange,     box=0) print strv     
  cCount = 0def change():    global rot, cCount    cCount=cCount+1    print strv, cCount    rot=-rot    if T1.visible:        T1.visible=False        T2.visible=True    else:        T1.visible=True        T2.visible=False scene.bind( 'click', change ) while True:  rate(100)  S.rotate( angle=rot, axis=(0,1,0) )  import wx app = wx.App(False)frame = wx.Frame(None, wx.ID_ANY, strv)frame.Show(True)app.MainLoop()"
"from math import radians, sin, cos, sqrt, asin def haversine(lat1, lon1, lat2, lon2):   R = 6372.8 
   dLat = radians(lat2 - lat1)  dLon = radians(lon2 - lon1)  lat1 = radians(lat1)  lat2 = radians(lat2)   a = sin(dLat/2)**2 + cos(lat1)*cos(lat2)*sin(dLon/2)**2  c = 2*asin(sqrt(a))   return R * c >>> haversine(36.12, -86.67, 33.94, -118.40)2887.2599506071106>>> "
"keys = ['a', 'b', 'c']values = [1, 2, 3]hash = {key: value for key, value in zip(keys, values)}keys = ['a', 'b', 'c']values = [1, 2, 3]hash = dict(zip(keys, values)) 
from itertools import iziphash = dict(izip(keys, values))keys = ['a', 'b', 'c']values = [1, 2, 3]hash = {}for k,v in zip(keys, values):    hash[k] = v>>> class Hashable(object):	def __hash__(self):		return id(self) ^ 0xBEEF  >>> my_inst = Hashable()>>> my_int = 1>>> my_complex = 0 + 1j>>> my_float = 1.2>>> my_string = strv>>> my_bool = True>>> my_unicode = u'Ham'>>> my_list = ['a', 7]>>> my_tuple = ( 0.0, 1.4 )>>> my_set = set(my_list)>>> def my_func():	pass >>> class my_class(object):	pass >>> keys = [my_inst, my_tuple, my_int, my_complex, my_float, my_string,	my_bool, my_unicode, frozenset(my_set), tuple(my_list),	my_func, my_class]>>> values = range(12)>>> d = dict(zip(keys, values))>>> for key, value in d.items(): print key, strv, value 1 : 61j : 3Ham : 7Spam : 5(0.0, 1.3999999999999999) : 1frozenset(['a', 7]) : 81.2 : 4('a', 7) : 9<function my_func at 0x0128E7B0> : 10<class '__main__.my_class'> : 11<__main__.Hashable object at 0x012AFC50> : 0>>> 
>>> 
"
"from collections import defaultdict def hashJoin(table1, index1, table2, index2):    h = defaultdict(list)    
    for s in table1:        h[s[index1]].append(s)    
    return [(s, r) for r in table2 for s in h[r[index2]]] table1 = [(27, strv),          (18, strv),          (28, strv),          (18, strv),          (28, strv)]table2 = [(strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv)] for row in hashJoin(table1, 1, table2, 0):    print(row)"
"import time def counter():    n = 0    t1 = time.time()    while True:        try:            time.sleep(0.5)            n += 1            print n        except KeyboardInterrupt, e:            print 'Program has run for %5.3f seconds.' % (time.time() - t1)            break counter()import time def intrptWIN():   procDone = False   n = 0    while not procDone:      try:         time.sleep(0.5)         n += 1         print n      except KeyboardInterrupt, e:         procDone = True t1 = time.time()intrptWIN()tdelt = time.time() - t1print 'Program has run for %5.3f seconds.' % tdeltimport signal, time, threadingdone = Falsen = 0 def counter():   global n, timer   n += 1   print n   timer = threading.Timer(0.5, counter)   timer.start() def sigIntHandler(signum, frame):   global done   timer.cancel()   done = True def intrptUNIX():   global timer   signal.signal(signal.SIGINT, sigIntHandler)    timer = threading.Timer(0.5, counter)   timer.start()   while not done:      signal.pause() t1 = time.time()intrptUNIX()tdelt = time.time() - t1print 'Program has run for %5.3f seconds.' % tdeltimport time, signal class WeAreDoneException(Exception):    pass def sigIntHandler(signum, frame):    signal.signal(signal.SIGINT, signal.SIG_DFL) 
    raise WeAreDoneException t1 = time.time() try:    signal.signal(signal.SIGINT, sigIntHandler)    n = 0    while True:        time.sleep(0.5)        n += 1        print nexcept WeAreDoneException:    pass tdelt = time.time() - t1print 'Program has run for %5.3f seconds.' % tdelt"
">>> import itertools>>> def harshad():	for n in itertools.count(1):		if n % sum(int(ch) for ch in str(n)) == 0:			yield n  >>> list(itertools.islice(harshad(), 0, 20))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]>>> for n in harshad():	if n > 1000:		print(n)		break  1002>>> >>> from itertools import count, islice>>> harshad = (n for n in count(1) if n % sum(int(ch) for ch in str(n)) == 0)>>> list(islice(harshad, 0, 20))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]>>> next(x for x in harshad if x > 1000)1002>>> "
">>> def happy(n):    past = set()			    while n != 1:        n = sum(int(i)**2 for i in str(n))        if n in past:            return False        past.add(n)    return True >>> [x for x in xrange(500) if happy(x)][:8][1, 7, 10, 13, 19, 23, 28, 31]"
" import random, tkMessageBoxfrom Tkinter import *window = Tk()window.geometry(strv)options = { strv:5, strv:5}s=StringVar()s.set(1)def increase():    s.set(int(s.get())+1)def rand():    if tkMessageBox.askyesno(strv, strv):        s.set(random.randrange(0,5000))def update(e):    if not e.char.isdigit():        tkMessageBox.showerror('Error', 'Invalid input !')         return strve = Entry(text=s)e.grid(column=0, row=0, **options)e.bind('<Key>', update)b1 = Button(text=strv, command=increase, **options )b1.grid(column=1, row=0, **options)b2 = Button(text=strv, command=rand, **options)b2.grid(column=2, row=0, **options)mainloop()import randomfrom Tkinter import *import tkMessageBox  class Application(Frame):    def __init__(self, master):        Frame.__init__(self, master)        self.counter = 0        self.contents = StringVar()        self.contents.set(str(self.counter))        self.pack(expand=True, fill='both', padx=10, pady=15)        self.create_widgets()     def increment(self, *args):        self.counter += 1        self.update_entry()     def random(self):        if tkMessageBox.askyesno(strv, strv):            self.counter = random.randint(0, 5000)            self.update_entry()     def entry_updated(self, event, *args):        if not event.char:            return 'break'        if not event.char.isdigit():            tkMessageBox.showerror('Error', 'Invalid input !')            return 'break'        self.counter = int('%s%s' % (self.contents.get(), event.char))     def update_entry(self):        self.contents.set(str(self.counter))        self.entry['textvariable'] = self.contents     def create_widgets(self):        options = {'expand': True, 'fill': 'x', 'side': 'left', 'padx': 5}        self.entry = Entry(self)        self.entry.bind('<Key>', self.entry_updated)        self.entry.pack(**options)        self.update_entry()        self.increment_button = Button(self, text='Increment', command=self.increment)        self.increment_button.pack(**options)        self.random_button = Button(self, text='Random', command=self.random)        self.random_button.pack(**options)  if __name__ == '__main__':    root = Tk()    try:        app = Application(master=root)        app.master.title(strv)        app.mainloop()    except KeyboardInterrupt:        root.destroy()"
"inclusive_range = mn, mx = (1, 10) print('''
Think of a number between %i and %i and wait for me to guess it.
On every guess of mine you should state whether the guess was
too high, too low, or equal to your number by typing h, l, or =
''' % inclusive_range) i = 0while True:    i += 1    guess = (mn+mx)//2    txt = input(strv                % (i, guess)).strip().lower()[0]    if txt not in 'hl=':        print(strv % txt)        continue    if txt == 'h':        mx = guess-1    if txt == 'l':        mn = guess+1    if txt == '=':        print(strv)        break    if (mn > mx) or (mn < inclusive_range[0]) or (mx > inclusive_range[1]):        print(strv)        break print(""Thanks for keeping score."")import bisecttry: input = raw_inputexcept: pass class GuessNumberFakeList(object):    def __getitem__(self, i):        s = input(strv % i)        return 0 if s.lower().startswith('y') else -1 LOWER, UPPER = 0, 100 if __name__ == strv:    print(strvInstructions:
Think of integer number from %d (inclusive) to %d (exclusive) and
I will guess it. After each guess, I will ask you if it is less than
or equal to some number, and you will respond with strv.
strv % (LOWER, UPPER))    result = bisect.bisect_left(GuessNumberFakeList(), 0, LOWER, UPPER)    print(strv % result)"
"def hailstone(n):    seq = [n]    while n>1:        n = 3*n + 1 if n & 1 else n//2        seq.append(n)    return seq if __name__ == '__main__':    h = hailstone(27)    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]    print(strv %          max((len(hailstone(i)), i) for i in range(1,100000)))"
"#!/usr/bin/env python#four gray scaled stripes 8:16:32:64 in Python 2.7.1 from livewires import * horiz=640; vert=480; pruh=vert/4; dpp=255.0begin_graphics(width=horiz,height=vert,title=strv,background=Colour.black) def ty_pruhy(each):	hiy=each[0]*pruh; loy=hiy-pruh	krok=horiz/each[1]; piecol=255.0/(each[1]-1)	for x in xrange(0,each[1]):		barva=Colour(piecol*x/dpp,piecol*x/dpp,piecol*x/dpp ); set_colour(barva)		if each[2]:			box(x*krok,hiy,x*krok+krok,loy,filled=1)		else:			box(horiz-x*krok,hiy,horiz-((x+1)*krok),loy,filled=1) 
source=[[4,8,True],[3,16,False],[2,32,True],[1,64,False]]for each in source:	ty_pruhy(each) while keys_pressed() != [' ']: 
	pass "
"import randomtarget, guess = random.randint(1, 10), 0while target != guess:    guess = int(input(strv))print(strv)"
"from itertools import islice def hamming2():    '''
    This version is based on a snippet from:
        http://dobbscodetalk.com/index.php?option=com_content&task=view&id=913&Itemid=85
 
        When expressed in some imaginary pseudo-C with automatic
        unlimited storage allocation and BIGNUM arithmetics, it can be
        expressed as:
            hamming = h where
              array h;
              n=0; h[0]=1; i=0; j=0; k=0;
              x2=2*h[ i ]; x3=3*h[j]; x5=5*h[k];
              repeat:
                h[++n] = min(x2,x3,x5);
                if (x2==h[n]) { x2=2*h[++i]; }
                if (x3==h[n]) { x3=3*h[++j]; }
                if (x5==h[n]) { x5=5*h[++k]; } 
    '''    h = 1    _h=[h]    
    multipliers  = (2, 3, 5)    multindeces  = [0 for i in multipliers] 
    multvalues   = [x * _h[i] for x,i in zip(multipliers, multindeces)]    yield h    while True:        h = min(multvalues)        _h.append(h)        for (n,(v,x,i)) in enumerate(zip(multvalues, multipliers, multindeces)):            if v == h:                i += 1                multindeces[n] = i                multvalues[n]  = x * _h[i]        
        mini = min(multindeces)        if mini >= 1000:            del _h[:mini]            multindeces = [i - mini for i in multindeces]        #        yield himport psyco def hamming(limit):    h = [1] * limit    x2, x3, x5 = 2, 3, 5    i = j = k = 0     for n in xrange(1, limit):        h[n] = min(x2, x3, x5)        if x2 == h[n]:            i += 1            x2 = 2 * h[i]        if x3 == h[n]:            j += 1            x3 = 3 * h[j]        if x5 == h[n]:            k += 1            x5 = 5 * h[k]     return h[-1] psyco.bind(hamming)print [hamming(i) for i in xrange(1, 21)]print hamming(1691)print hamming(1000000)from itertools import tee, chain, groupby, islicefrom heapq import merge def raymonds_hamming():    
    
    
     def deferred_output():        for i in output:            yield i     result, p2, p3, p5 = tee(deferred_output(), 4)    m2 = (2*x for x in p2)                          
    m3 = (3*x for x in p3)                          
    m5 = (5*x for x in p5)                          
    merged = merge(m2, m3, m5)    combined = chain([1], merged)                   
    output = (k for k,g in groupby(combined))       
     return result print list(islice(raymonds_hamming(), 20))print islice(raymonds_hamming(), 1689, 1690).next()print islice(raymonds_hamming(), 999999, 1000000).next()from heapq import mergefrom itertools import tee def hamming_numbers():    last = 1    yield last     a,b,c = tee(hamming_numbers(), 3)     for n in merge((2*i for i in a), (3*i for i in b), (5*i for i in c)):        if n != last:            yield n            last = nfrom itertools import islice, chain, tee def merge(r, s):    
    rr = r.next()    ss = s.next()    while True:        if rr < ss:            yield rr            rr = r.next()        else:            yield ss            ss = s.next() def p(n):    def gen():        x = n        while True:            yield x            x *= n    return gen() def pp(n, s):    def gen():        for x in (merge(s, chain([n], (n * y for y in fb)))):            yield x    r, fb = tee(gen())    return r def hamming(a, b = None):    if not b:        b = a + 1    seq = (chain([1], pp(5, pp(3, p(2)))))    return list(islice(seq, a - 1, b - 1)) print hamming(1, 21)print hamming(1691)[0]print hamming(1000000)[0]"
"max(values)>>> floatstrings = ['1', ' 2.3', '4.5e-1', '0.01e4', '-1.2']>>> max(floatstrings, key = float)'0.01e4'>>>>>> max(float(x) for x in floatstrings)100.0>>>>>> mylist = [47, 11, 42, 102, 13]>>> reduce(lambda a,b: a if (a > b) else b, mylist)102def (best f seq)  if seq    ret winner car.seq      each elem cdr.seq        if (f elem winner)          winner <- elem def (max ... args)  (best (>) args)"
"import random inclusive_range = (1, 100) print(""Guess my target number that is between %i and %i (inclusive).""      % inclusive_range)target = random.randint(*inclusive_range)answer, i = None, 0while answer != target:    i += 1    txt = input(strv % i)    try:        answer = int(txt)    except ValueError:        print(strv % txt)        continue    if answer < inclusive_range[0] or answer > inclusive_range[1]:        print(strv)        continue    if answer == target:        print(strv)        break    if answer < target: print(strv)    if answer > target: print(strv) print(""Thanks for playing."")"
"def maxsubseq(seq):  return max((seq[begin:end] for begin in xrange(len(seq)+1)                             for end in xrange(begin, len(seq)+1)),             key=sum)def maxsum(sequence):    strv    maxsofar, maxendinghere = 0, 0    for x in sequence:        
        maxendinghere = max(maxendinghere + x, 0)        maxsofar = max(maxsofar, maxendinghere)    return maxsofardef maxsumseq(sequence):    start, end, sum_start = -1, -1, -1    maxsum_, sum_ = 0, 0    for i, x in enumerate(sequence):        sum_ += x        if maxsum_ < sum_: 
            maxsum_ = sum_            start, end = sum_start, i        elif sum_ < 0: 
            sum_ = 0            sum_start = i    assert maxsum_ == maxsum(sequence)     assert maxsum_ == sum(sequence[start + 1:end + 1])    return sequence[start + 1:end + 1]def maxsumit(iterable):    maxseq = seq = []    start, end, sum_start = -1, -1, -1    maxsum_, sum_ = 0, 0    for i, x in enumerate(iterable):        seq.append(x); sum_ += x        if maxsum_ < sum_:             maxseq = seq; maxsum_ = sum_            start, end = sum_start, i        elif sum_ < 0:            seq = []; sum_ = 0            sum_start = i    assert maxsum_ == sum(maxseq[:end - start])    return maxseq[:end - start]f = maxsumitassert f([]) == []assert f([-1]) == []assert f([0])  == []assert f([1])       == [1]assert f([1, 0])    == [1]assert f([0, 1])    == [0, 1]   assert f([0, 1, 0]) == [0, 1]   assert f([2])         == [2]assert f([2, -1])     == [2]assert f([-1, 2])     == [2]assert f([-1, 2, -1]) == [2]assert f([2, -1, 3])         == [2, -1, 3]assert f([2, -1, 3, -1])     == [2, -1, 3] assert f([-1, 2, -1, 3])     == [2, -1, 3]assert f([-1, 2, -1, 3, -1]) == [2, -1, 3]assert f([-1, 1, 2, -5, -6]) == [1,2]"
"
import ioppmfileout = io.StringIO('') def togreyscale(self):    for h in range(self.height):        for w in range(self.width):            r, g, b = self.get(w, h)            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)            self.set(w, h, Colour(l, l, l)) Bitmap.togreyscale = togreyscale      
bitmap = Bitmap(4, 4, white)bitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))bitmap.set(3, 3, Colour(0, 127, 31))print('Colour:')
bitmap.writeppmp3(ppmfileout)print(ppmfileout.getvalue())print('Grey:')bitmap.togreyscale()ppmfileout = io.StringIO('')bitmap.writeppmp3(ppmfileout)print(ppmfileout.getvalue())  '''
The print statement above produces the following output :
 
Colour:
P3


4 4
255
   255 255 255   255 255 255   255 255 255     0 127  31
   255 255 255   255 255 255   255 255 255   255 255 255
   255 255 255   127   0  63   255 255 255   255 255 255
   255 255 255   127   0  63   255 255 255   255 255 255
 
Grey:
P3


4 4
254
   254 254 254   254 254 254   254 254 254    93  93  93
   254 254 254   254 254 254   254 254 254   254 254 254
   254 254 254    31  31  31   254 254 254   254 254 254
   254 254 254    31  31  31   254 254 254   254 254 254
 
'''"
"from fractions import gcddef gcd_iter(u, v):    while v:        u, v = v, u % v    return abs(u)def gcd(u, v):    return gcd(v, u % v) if v else abs(u)def gcd_bin(u, v):    u, v = abs(u), abs(v) 
    if u < v:        u, v = v, u 
    if v == 0:        return u     
    k = 1    while u & 1 == 0 and v & 1 == 0: 
        u >>= 1; v >>= 1        k <<= 1     t = -v if u & 1 else u    while t:        while t & 1 == 0:            t >>= 1        if t > 0:            u = t        else:            v = -t        t = u - v    return u * k"
">>> import subprocess>>> returned_text = subprocess.check_output(strv, shell=True, universal_newlines=True)>>> type(returned_text)<class 'str'>>>> print(returned_text) Volume in drive C is Windows Volume Serial Number is 44X7-73CE  Directory of C:\Python33 04/07/2013  06:40    <DIR>          .04/07/2013  06:40    <DIR>          ..27/05/2013  07:10    <DIR>          DLLs27/05/2013  07:10    <DIR>          Doc27/05/2013  07:10    <DIR>          include27/05/2013  07:10    <DIR>          Lib27/05/2013  07:10    <DIR>          libs16/05/2013  00:15            33,326 LICENSE.txt15/05/2013  22:49           214,554 NEWS.txt16/05/2013  00:03            26,624 python.exe16/05/2013  00:03            27,136 pythonw.exe15/05/2013  22:49             6,701 README.txt27/05/2013  07:10    <DIR>          tcl27/05/2013  07:10    <DIR>          Tools16/05/2013  00:02            43,008 w9xpopen.exe               6 File(s)        351,349 bytes               9 Dir(s)  46,326,947,840 bytes free >>> 
"
">>> def int2bin(n):	'From positive integer to list of binary bits, msb at index 0'	if n:		bits = []		while n:			n,remainder = divmod(n, 2)			bits.insert(0, remainder)		return bits	else: return [0]  >>> def bin2int(bits):	'From binary bits, msb at index 0 to integer'	i = 0	for bit in bits:		i = i * 2 + bit	return i>>> def bin2gray(bits):	return bits[:1] + [i ^ ishift for i, ishift in zip(bits[:-1], bits[1:])] >>> def gray2bin(bits):	b = [bits[0]]	for nextb in bits[1:]: b.append(b[-1] ^ nextb)	return b>>> for i in range(16):	print('int:%2i -> bin:%12r -> gray:%12r -> bin:%12r -> int:%2i' %	      ( i,	        int2bin(i),	        bin2gray(int2bin(i)),	        gray2bin(bin2gray(int2bin(i))),	        bin2int(gray2bin(bin2gray(int2bin(i))))	      ))  int: 0 -> bin:         [0] -> gray:         [0] -> bin:         [0] -> int: 0int: 1 -> bin:         [1] -> gray:         [1] -> bin:         [1] -> int: 1int: 2 -> bin:      [1, 0] -> gray:      [1, 1] -> bin:      [1, 0] -> int: 2int: 3 -> bin:      [1, 1] -> gray:      [1, 0] -> bin:      [1, 1] -> int: 3int: 4 -> bin:   [1, 0, 0] -> gray:   [1, 1, 0] -> bin:   [1, 0, 0] -> int: 4int: 5 -> bin:   [1, 0, 1] -> gray:   [1, 1, 1] -> bin:   [1, 0, 1] -> int: 5int: 6 -> bin:   [1, 1, 0] -> gray:   [1, 0, 1] -> bin:   [1, 1, 0] -> int: 6int: 7 -> bin:   [1, 1, 1] -> gray:   [1, 0, 0] -> bin:   [1, 1, 1] -> int: 7int: 8 -> bin:[1, 0, 0, 0] -> gray:[1, 1, 0, 0] -> bin:[1, 0, 0, 0] -> int: 8int: 9 -> bin:[1, 0, 0, 1] -> gray:[1, 1, 0, 1] -> bin:[1, 0, 0, 1] -> int: 9int:10 -> bin:[1, 0, 1, 0] -> gray:[1, 1, 1, 1] -> bin:[1, 0, 1, 0] -> int:10int:11 -> bin:[1, 0, 1, 1] -> gray:[1, 1, 1, 0] -> bin:[1, 0, 1, 1] -> int:11int:12 -> bin:[1, 1, 0, 0] -> gray:[1, 0, 1, 0] -> bin:[1, 1, 0, 0] -> int:12int:13 -> bin:[1, 1, 0, 1] -> gray:[1, 0, 1, 1] -> bin:[1, 1, 0, 1] -> int:13int:14 -> bin:[1, 1, 1, 0] -> gray:[1, 0, 0, 1] -> bin:[1, 1, 1, 0] -> int:14int:15 -> bin:[1, 1, 1, 1] -> gray:[1, 0, 0, 0] -> bin:[1, 1, 1, 1] -> int:15>>> "
"import fileinput for line in fileinput.input(inplace=True):    print(line.replace('Goodbye London!', 'Hello New York!'), end='') "
">>> from itertools import permutations>>> pieces = 'KQRrBbNN'>>> starts = {''.join(p).upper() for p in permutations(pieces)                     if p.index('B') % 2 != p.index('b') % 2 		
                     and ( p.index('r') < p.index('K') < p.index('R')	
                           or p.index('R') < p.index('K') < p.index('r') ) }>>> len(starts)960>>> starts.pop()'QNBRNKRB'>>> >>> import re>>> pieces = 'KQRRBBNN'>>> bish = re.compile(r'B(|..|....|......)B').search>>> king = re.compile(r'R.*K.*R').search>>> starts3 = {p for p in (''.join(q) for q in permutations(pieces))            if bish(p) and king(p)}>>> len(starts3)960>>> starts3.pop()'QRNKBNRB'>>> from random import choice def random960():    start = ['R', 'K', 'R']         
    #    for piece in ['Q', 'N', 'N']:        start.insert(choice(range(len(start)+1)), piece)    #    bishpos = choice(range(len(start)+1))    start.insert(bishpos, 'B')    start.insert(choice(range(bishpos + 1, len(start) + 1, 2)), 'B')    return start    return ''.join(start).upper() print(random960())from random import choice def generate960():    start = ('R', 'K', 'R')         
     
    starts = {start}    for piece in ['Q', 'N', 'N']:        starts2 = set()        for s in starts:            for pos in range(len(s)+1):                s2 = list(s)                s2.insert(pos, piece)                starts2.add(tuple(s2))        starts = starts2     
    starts2 = set()    for s in starts:        for bishpos in range(len(s)+1):            s2 = list(s)            s2.insert(bishpos, 'B')            for bishpos2 in range(bishpos+1, len(s)+2, 2):                s3 = s2[::]                s3.insert(bishpos2, 'B')                starts2.add(tuple(s3))     return  list(starts2) gen = generate960()print(''.join(choice(gen)))"
"
from string import ascii_lowercase 
lower = [chr(i) for i in range(ord('a'), ord('z') + 1)]"
"def genfizzbuzz(factorwords, numbers):    factorwords.sort(key=lambda p: p[0])    lines = []    for num in numbers:        words = ''.join(wrd for fact, wrd in factorwords if (num % fact) == 0)        lines.append(words if words else str(num))    return ''.join(lines) if __name__ == '__main__':    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))from collections import defaultdict n = 100mods = {    3: strv,    5: strv,} def fizzbuzz(n=n, mods=mods):    factors = defaultdict(list)    for mod in mods:        factors[mod].append(mod)     for i in range(1,n+1):        res = ''        for mod in sorted(factors[i]):            factors[i+mod].append(mod)            res += mods[mod]        del factors[i]        yield res or str(i) if __name__ == '__main__':    n = int(input())    mods = { int(k): v for k,v in (input().split(maxsplit=1) for _ in range(3)) }    for line in fizzbuzz(n, mods):        print(line) from collections import defaultdict n = 100mods = [    (3, 'Fizz'),    (5, 'Buzz'),] def fizzbuzz(n=n, mods=mods):    res = defaultdict(str)     for num, name in mods:        for i in range(num, n+1, num):            res[i] += name     return ''.join(res[i] or str(i) for i in range(1, n+1))  if __name__ == '__main__':    n = int(input())     mods = []    while len(mods) != 3:   
        try:            line = input()        except EOFError:            break        idx = line.find(' ')                        
        num, name = int(line[:idx]), line[idx+1:]   
        mods.append((num, name))    
     print(fizzbuzz(n, mods)) "
"a, b = b, adef swap(a, b):    return b, a"
"from itertools import islice, count def powers(m):    for n in count():        yield n ** m def filtered(s1, s2):    v, f = next(s1), next(s2)    while True:        if v > f:            f = next(s2)            continue        elif v < f:            yield v        v = next(s1) squares, cubes = powers(2), powers(3)f = filtered(squares, cubes)print(list(islice(f, 20, 30)))"
"from itertools import zip_longest  fc2 = '''
cleaning,,
    house1,40,
        bedrooms,,.25
        bathrooms,,
            bathroom1,,.5
            bathroom2,,
            outside_lavatory,,1
        attic,,.75
        kitchen,,.1
        living_rooms,,
            lounge,,
            dining_room,,
            conservatory,,
            playroom,,1
        basement,,
        garage,,
        garden,,.8
    house2,60,
        upstairs,,
            bedrooms,,
                suite_1,,
                suite_2,,
                bedroom_3,,
                bedroom_4,,
            bathroom,,
            toilet,,
            attics,,.6
        groundfloor,,
            kitchen,,
            living_rooms,,
                lounge,,
                dining_room,,
                conservatory,,
                playroom,,
            wet_room_&_toilet,,
            garage,,
            garden,,.9
            hot_tub_suite,,1
        basement,,
            cellars,,1
            wine_cellar,,1
            cinema,,.75
 
''' NAME, WT, COV = 0, 1, 2 def right_type(txt):    try:        return float(txt)    except ValueError:        return txt def commas_to_list(the_list, lines, start_indent=0):    '''
    Output format is a nest of lists and tuples
    lists are for coverage leaves without children items in the list are name, weight, coverage
    tuples are 2-tuples for nodes with children. The first element is a list representing the
    name, weight, coverage of the node (some to be calculated); the second element is a list of
    child elements which may be 2-tuples or lists as above.
 
    the_list is modified in-place
    lines must be a generator of successive lines of input like fc2
    '''    for n, line in lines:        indent = 0        while line.startswith(' ' * (4 * indent)):            indent += 1        indent -= 1        fields = [right_type(f) for f in line.strip().split(',')]        if indent == start_indent:            the_list.append(fields)        elif indent > start_indent:            lst = [fields]            sub = commas_to_list(lst, lines, indent)            the_list[-1] = (the_list[-1], lst)            if sub not in (None, ['']) :                the_list.append(sub)        else:            return fields if fields else None    return None  def pptreefields(lst, indent=0, widths=['%-32s', '%-8g', '%-10g']):    '''
    Pretty prints the format described from function commas_to_list as a table with 
    names in the first column suitably indented and all columns having a fixed 
    minimum column width.
    '''    lhs = ' ' * (4 * indent)    for item in lst:        if type(item) != tuple:            name, *rest = item            print(widths[0] % (lhs + name), end='|')            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):                if type(item) == str:                    width = width[:-1] + 's'                print(width % item, end='|')            print()        else:            item, children = item            name, *rest = item            print(widths[0] % (lhs + name), end='|')            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):                if type(item) == str:                    width = width[:-1] + 's'                print(width % item, end='|')            print()            pptreefields(children, indent+1)  def default_field(node_list):    node_list[WT] = node_list[WT] if node_list[WT] else 1.0    node_list[COV] = node_list[COV] if node_list[COV] else 0.0 def depth_first(tree, visitor=default_field):    for item in tree:        if type(item) == tuple:            item, children = item            depth_first(children, visitor)        visitor(item)  def covercalc(tree):    '''
    Depth first weighted average of coverage
    '''    sum_covwt, sum_wt = 0, 0    for item in tree:        if type(item) == tuple:            item, children = item            item[COV] = covercalc(children)        sum_wt  += item[WT]        sum_covwt += item[COV] * item[WT]    cov = sum_covwt / sum_wt    return cov if __name__ == '__main__':            lstc = []    commas_to_list(lstc, ((n, ln) for n, ln in enumerate(fc2.split(''))))    #pp(lstc, width=1, indent=4, compact=1)     #print('\n\nEXPANDED DEFAULTS\n')    depth_first(lstc)    #pptreefields(['NAME_HIERARCHY WEIGHT COVERAGE'.split()] + lstc)     print('TOP COVERAGE = %f' % covercalc(lstc))    depth_first(lstc)    pptreefields(['NAME_HIERARCHY WEIGHT COVERAGE'.split()] + lstc)
 SPACES = 4class Node:    path2node = {}     def add_node(self, pathname, wt, cov):        path2node = self.path2node        path, name = pathname.strip().rsplit('/', 1)        node = Node(name, wt, cov)        path2node[pathname] = node        path2node[path].child.append(node) 
     def __init__(self, name=strv, wt=1, cov=0.0, child=None):        if child is None:            child = []        self.name, self.wt, self.cov, self.child = name, wt, cov, child        self.delta = None        self.sum_wt = wt        if name == strv:             
            self.path2node[name] = self      def __repr__(self, indent=0):        name, wt, cov, delta, child = (self.name, self.wt, self.cov,                                        self.delta, self.child)        lhs = ' ' * (SPACES * indent) + strv % name        txt = '%-40s wt=%2g, cov=%-8.5g, delta=%-10s, child=[' \              % (lhs, wt, cov, ('n/a' if delta is None else '%-10.7f' % delta))        if not child:            txt += (']),')        else:            txt += ('')            for c in child:                txt += c.__repr__(indent + 1)            txt += (' ' * (SPACES * indent) + ""]),"")        return txt     def covercalc(self):        '''
        Depth first weighted average of coverage
        '''        child = self.child        if not child:            return self.cov        sum_covwt, sum_wt = 0, 0        for node in child:            nwt = node.wt            ncov = node.covercalc()            sum_wt += nwt            sum_covwt += ncov * nwt        cov = sum_covwt / sum_wt        self.sum_wt = sum_wt        self.cov = cov        return cov     def deltacalc(self, power=1.0):        '''
        Top down distribution of weighted residuals
        '''        sum_wt = self.sum_wt        self.delta = delta = (1 - self.cov) * power        for node in self.child:            node.deltacalc(power * node.wt / sum_wt)        return delta  def isclose(a, b, rel_tol=1e-9, abs_tol=1e-9):    return abs(a-b) <= max( rel_tol * max(abs(a), abs(b)), abs_tol )  if __name__ == '__main__':     top = Node()    
    add_node = top.add_node     add_node('/cleaning', 1, 0)    add_node('/cleaning/house1', 40, 0)    add_node('/cleaning/house1/bedrooms', 1, 0.25)    add_node('/cleaning/house1/bathrooms', 1, 0)    add_node('/cleaning/house1/bathrooms/bathroom1', 1, 0.5)    add_node('/cleaning/house1/bathrooms/bathroom2', 1, 0)    add_node('/cleaning/house1/bathrooms/outside_lavatory', 1, 1)    add_node('/cleaning/house1/attic', 1, 0.75)    add_node('/cleaning/house1/kitchen', 1, 0.1)    add_node('/cleaning/house1/living_rooms', 1, 0)    add_node('/cleaning/house1/living_rooms/lounge', 1, 0)    add_node('/cleaning/house1/living_rooms/dining_room', 1, 0)    add_node('/cleaning/house1/living_rooms/conservatory', 1, 0)    add_node('/cleaning/house1/living_rooms/playroom', 1, 1)    add_node('/cleaning/house1/basement', 1, 0)    add_node('/cleaning/house1/garage', 1, 0)    add_node('/cleaning/house1/garden', 1, 0.8)    add_node('/cleaning/house2', 60, 0)    add_node('/cleaning/house2/upstairs', 1, 0)    add_node('/cleaning/house2/upstairs/bedrooms', 1, 0)    add_node('/cleaning/house2/upstairs/bedrooms/suite_1', 1, 0)    add_node('/cleaning/house2/upstairs/bedrooms/suite_2', 1, 0)    add_node('/cleaning/house2/upstairs/bedrooms/bedroom_3', 1, 0)    add_node('/cleaning/house2/upstairs/bedrooms/bedroom_4', 1, 0)    add_node('/cleaning/house2/upstairs/bathroom', 1, 0)    add_node('/cleaning/house2/upstairs/toilet', 1, 0)    add_node('/cleaning/house2/upstairs/attics', 1, 0.6)    add_node('/cleaning/house2/groundfloor', 1, 0)    add_node('/cleaning/house2/groundfloor/kitchen', 1, 0)    add_node('/cleaning/house2/groundfloor/living_rooms', 1, 0)    add_node('/cleaning/house2/groundfloor/living_rooms/lounge', 1, 0)    add_node('/cleaning/house2/groundfloor/living_rooms/dining_room', 1, 0)    add_node('/cleaning/house2/groundfloor/living_rooms/conservatory', 1, 0)    add_node('/cleaning/house2/groundfloor/living_rooms/playroom', 1, 0)    add_node('/cleaning/house2/groundfloor/wet_room_&_toilet', 1, 0)    add_node('/cleaning/house2/groundfloor/garage', 1, 0)    add_node('/cleaning/house2/groundfloor/garden', 1, 0.9)    add_node('/cleaning/house2/groundfloor/hot_tub_suite', 1, 1)    add_node('/cleaning/house2/basement', 1, 0)    add_node('/cleaning/house2/basement/cellars', 1, 1)    add_node('/cleaning/house2/basement/wine_cellar', 1, 1)    add_node('/cleaning/house2/basement/cinema', 1, 0.75)     top = top.child[0]  
    cover = top.covercalc()    delta = top.deltacalc()    print('TOP COVERAGE = %g' % cover)    print(top)    assert isclose((delta + cover), 1.0), strv \                                          strv % (delta, cover) "
"

 import copyfrom fractions import Fraction def gauss(a, b):    a = copy.deepcopy(a)    b = copy.deepcopy(b)    n = len(a)    p = len(b[0])    det = 1    for i in range(n - 1):        k = i        for j in range(i + 1, n):            if abs(a[j][i]) > abs(a[k][i]):                k = j        if k != i:            a[i], a[k] = a[k], a[i]            b[i], b[k] = b[k], b[i]            det = -det         for j in range(i + 1, n):            t = a[j][i]/a[i][i]            for k in range(i + 1, n):                a[j][k] -= t*a[i][k]            for k in range(p):                b[j][k] -= t*b[i][k]     for i in range(n - 1, -1, -1):        for j in range(i + 1, n):            t = a[i][j]            for k in range(p):                b[i][k] -= t*b[j][k]        t = 1/a[i][i]        det *= a[i][i]        for j in range(p):            b[i][j] *= t    return det, b def zeromat(p, q):    return [[0]*q for i in range(p)] def matmul(a, b):    n, p = len(a), len(a[0])    p1, q = len(b), len(b[0])    if p != p1:        raise ValueError(strv)    c = zeromat(n, q)    for i in range(n):        for j in range(q):                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))    return c  def mapmat(f, a):    return [list(map(f, v)) for v in a] def ratmat(a):    return mapmat(Fraction, a) 
 a = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]det, c = gauss(a, b) det-360.0 c[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]] 
matmul(a, c)[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]] 
 det, c = gauss(ratmat(a), ratmat(b)) detFraction(-360, 1) c[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]] matmul(a, c)[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]"
"import ast class CallCountingVisitor(ast.NodeVisitor):     def __init__(self):        self.calls = {}     def visit_Call(self, node):        if isinstance(node.func, ast.Name):            fun_name = node.func.id            call_count = self.calls.get(fun_name, 0)            self.calls[fun_name] = call_count + 1        self.generic_visit(node) filename = input('Enter a filename to parse: ')with open(filename, encoding='utf-8') as f:    contents = f.read()root = ast.parse(contents, filename=filename) #NOTE: this will throw a SyntaxError if the file isn't valid Python codevisitor = CallCountingVisitor()visitor.visit(root)top10 = sorted(visitor.calls.items(), key=lambda x: x[1], reverse=True)[:10]for name, count in top10:    print(name,'called',count,'times') "
"_a =    ( 1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108,         -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675,         -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511,         -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824,         -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776,          0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049,          0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562,          0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812,          0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119,          0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002       )def gamma (x):    y  = float(x) - 1.0;   sm = _a[-1];   for an in _a[-2::-1]:      sm = sm * y + an;   return 1.0 / sm;  if __name__ == '__main__':    for i in range(1,11):        print strv % gamma(i/3.0) "
" from ftplib import FTPftp = FTP('kernel.org')ftp.login()ftp.cwd('/pub/linux/kernel')ftp.set_pasv(True) 
print ftp.retrlines('LIST')print ftp.retrbinary('RETR README', open('README', 'wb').write)ftp.quit() "
"from itertools import imap, imap, groupby, chain, imapfrom operator import itemgetterfrom sys import argvfrom array import array def concat_map(func, it):    return list(chain.from_iterable(imap(func, it))) def minima(poly):    strv    return (min(pt[0] for pt in poly), min(pt[1] for pt in poly)) def translate_to_origin(poly):    (minx, miny) = minima(poly)    return [(x - minx, y - miny) for (x, y) in poly] rotate90   = lambda (x, y): ( y, -x)rotate180  = lambda (x, y): (-x, -y)rotate270  = lambda (x, y): (-y,  x)reflect    = lambda (x, y): (-x,  y) def rotations_and_reflections(poly):    strv    return (poly,            map(rotate90, poly),            map(rotate180, poly),            map(rotate270, poly),            map(reflect, poly),            [reflect(rotate90(pt)) for pt in poly],            [reflect(rotate180(pt)) for pt in poly],            [reflect(rotate270(pt)) for pt in poly]) def canonical(poly):    return min(sorted(translate_to_origin(pl)) for pl in rotations_and_reflections(poly)) def unique(lst):    lst.sort()    return map(next, imap(itemgetter(1), groupby(lst))) 
contiguous = lambda (x, y): [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)] def new_points(poly):    strv    return unique([pt for pt in concat_map(contiguous, poly) if pt not in poly]) def new_polys(poly):    return unique([canonical(poly + [pt]) for pt in new_points(poly)]) monomino = [(0, 0)]monominoes = [monomino] def rank(n):    strv    assert n >= 0    if n == 0: return []    if n == 1: return monominoes    return unique(concat_map(new_polys, rank(n - 1))) def text_representation(poly):    strv    min_pt = minima(poly)    max_pt = (max(p[0] for p in poly), max(p[1] for p in poly))    table = [array('c', ' ') * (max_pt[1] - min_pt[1] + 1)             for _ in xrange(max_pt[0] - min_pt[0] + 1)]    for pt in poly:        table[pt[0] - min_pt[0]][pt[1] - min_pt[1]] = '#'    return """".join(row.tostring() for row in table) def main():    print [len(rank(n)) for n in xrange(1, 11)]     n = int(argv[1]) if (len(argv) == 2) else 5    print ""All free polyominoes of rank %d:"" % n     for poly in rank(n):        print text_representation(poly), """" main()"
def reverse_domain(domain):    strv    return '.'.join(reversed(domain.split('.')))
"compose = lambda f, g: lambda x: f( g(x) )>>> compose = lambda f, g: lambda x: f( g(x) )>>> from math import sin, asin>>> sin_asin = compose(sin, asin)>>> sin_asin(0.5)0.5>>>"
"from fractions import Fraction def fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]     n = Fraction(n)    while True:        yield n.numerator        for f in flist:            if (n * f).denominator == 1:                break        else:            break        n *= f if __name__ == '__main__':    n, m = 2, 15    print('First %i members of fractran(%i):  ' % (m, n) +          ', '.join(str(f) for f,i in zip(fractran(n), range(m)))) from fractran import fractran def fractran_primes():    for i, fr in enumerate(fractran(2), 1):        binstr = bin(fr)[2:]        if binstr.count('1') == 1:            prime = binstr.count('0')            if prime > 1:   
                yield prime, i if __name__ == '__main__':    for (prime, i), j in zip(fractran_primes(), range(15)):        print(strv % (prime, i))"
"def multiply(a, b):    return a * bmultiply = lambda a, b: a * bclass Multiply:    def __init__(self):        pass    def __call__(self, a, b):        return a * b multiply = Multiply()print multiply(2, 4)    
def (multiply a b)  a*b(multiply 3 4)=> 12(multiply 3 :a 4)  
=> 12def (multiply a b|by)  (* a b)multiply 3 :by 4=> 12"
"import pygame, math pygame.init()window = pygame.display.set_mode((600, 600))pygame.display.set_caption(strv)screen = pygame.display.get_surface() def drawTree(x1, y1, angle, depth):    if depth:        x2 = x1 + int(math.cos(math.radians(angle)) * depth * 10.0)        y2 = y1 + int(math.sin(math.radians(angle)) * depth * 10.0)        pygame.draw.line(screen, (255,255,255), (x1, y1), (x2, y2), 2)        drawTree(x2, y2, angle - 20, depth - 1)        drawTree(x2, y2, angle + 20, depth - 1) def input(event):    if event.type == pygame.QUIT:        exit(0) drawTree(300, 550, -90, 9)pygame.display.flip()while True:    input(pygame.event.wait())"
"#!/usr/bin/env python strv     http://rosettacode.org/wiki/Four_bit_adder
        Demonstrate theoretical four bit adder simulation
        using And, Or & Invert primitives
 
        2011-05-10  jc
strv from myhdl import always_comb, ConcatSignal, delay, intbv, Signal, \                  Simulation, toVerilog, toVHDL from random import randrange   strv   define set of primitives
      ------------------------   strvdef inverter(z, a):   
   strv   @always_comb   
   def logic():      z.next = not a   return logic   
 def and2(z, a, b):   strv   @always_comb    def logic():      z.next = a and b   return logic def or2(z, a, b):   strv      @always_comb     def logic():      z.next = a or b   return logic  strv   build components using defined primitive set
      --------------------------------------------   strvdef xor2 (z, a, b):   strv      
   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]   
   inv0 = inverter(nota,  a)   inv1 = inverter(notb,  b)   and2a = and2(annotb,  a, notb)   and2b = and2(bnnota,  b, nota)   or2a = or2(z,  annotb, bnnota)   return inv0, inv1, and2a, and2b, or2a def halfAdder(carry, summ,  in_a, in_b):   strv    and2a = and2(carry,  in_a, in_b)   xor2a  =  xor2(summ,   in_a, in_b)   return and2a, xor2a def fullAdder(fa_c1, fa_s,  fa_c0, fa_a, fa_b):   strv   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]   halfAdder01 = halfAdder(ha1_c1, ha1_s, fa_c0, fa_a)   halfAdder02 = halfAdder(ha2_c1, fa_s, ha1_s, fa_b)   or2a = or2(fa_c1, ha1_c1, ha2_c1)   return halfAdder01, halfAdder02, or2a def Adder4b_ST(co,sum4, ina,inb):   ''' assemble 4 full adders '''    c = [Signal(bool()) for i in range(0,4)]   sl = [Signal(bool()) for i in range(4)]  
   halfAdder_0 = halfAdder(c[1],sl[0],      ina(0),inb(0))   fullAdder_1 = fullAdder(c[2],sl[1], c[1],ina(1),inb(1))    fullAdder_2 = fullAdder(c[3],sl[2], c[2],ina(2),inb(2))    fullAdder_3 = fullAdder(co,  sl[3], c[3],ina(3),inb(3))    
   sc = ConcatSignal(*reversed(sl))  
   @always_comb   def list2intbv():      sum4.next = sc  
    return halfAdder_0, fullAdder_1, fullAdder_2, fullAdder_3, list2intbv  strv   define signals and code for testing
      -----------------------------------   strvt_co, t_s, t_a, t_b, dbug = [Signal(bool(0)) for i in range(5)]ina4, inb4, sum4 = [Signal(intbv(0)[4:])  for i in range(3)] def test():   print ""      b   a   |  c1    s        -------------------""   for i in range(15):      ina4.next, inb4.next = randrange(2**4), randrange(2**4)      yield delay(5)      print strv \             % (ina4,inb4, t_co,sum4)      assert t_co * 16 + sum4 == ina4 + inb4    print  strv   instantiate components and run test
      -----------------------------------   strvAdder4b_01 = Adder4b_ST(t_co,sum4, ina4,inb4)test_1 = test() def main():   sim = Simulation(Adder4b_01, test_1)   sim.run()       toVHDL(Adder4b_ST, t_co,sum4, ina4,inb4)   toVerilog(Adder4b_ST, t_co,sum4, ina4,inb4) if __name__ == '__main__':   main() #!/usr/bin/env python from myhdl import * def Half_adder(a, b, s, c):     @always_comb    def logic():        s.next = a ^ b        c.next = a & b     return logic  def Full_Adder(a, b, cin, s, c_out):    s_ha1, c_ha1, c_ha2 = [Signal(bool()) for i in range(3)]    ha1 = Half_adder(a=cin, b=a, s=s_ha1, c=c_ha1)    ha2 = Half_adder(a=s_ha1, b=b, s=s, c=c_ha2)     @always_comb    def logic():        c_out.next = c_ha1 | c_ha2     return ha1, ha2, logic  def Multibit_Adder(a, b, s):    N = len(s)-1    
    al = [a(i) for i in range(N)]    bl = [b(i) for i in range(N)]    
    cl = [Signal(bool()) for i in range(N+1)]    sl = [Signal(bool()) for i in range(N+1)]    
    cl[0] = 0    sl[N] = cl[N]    
    sc = ConcatSignal(*reversed(sl))     
    @always_comb    def assign():        s.next = sc     
    add = [None] * N    for i in range(N):        add[i] = Full_Adder(a=al[i], b=bl[i], s=sl[i], cin=cl[i], c_out=cl[i+1])     return add, assign  
N=4a = Signal(intbv(0)[N:])b = Signal(intbv(0)[N:])s = Signal(intbv(0)[N+1:]) 
toVerilog(Multibit_Adder, a, b, s)toVHDL(Multibit_Adder, a, b, s)     
from random import randrangedef tb():    dut = Multibit_Adder(a, b, s)     @instance    def check():        yield delay(10)        for i in range(100):            p, q = randrange(2**N), randrange(2**N)            a.next = p            b.next = q            yield delay(10)            assert s == p + q     return dut, check 
def test_Adder():    sim = Simulation(tb())    sim.run() def xor(a, b): return (a and not b) or (b and not a) def ha(a, b): return xor(a, b), a and b     
 def fa(a, b, ci):    s0, c0 = ha(ci, a)    s1, c1 = ha(s0, b)    return s1, c0 or c1     
 def fa4(a, b):    width = 4    ci = [None] * width    co = [None] * width    s  = [None] * width    for i in range(width):        s[i], co[i] = fa(a[i], b[i], co[i-1] if i else 0)    return s, co[-1] def int2bus(n, width=4):    return [int(c) for c in strv.format(n, width)[::-1]] def bus2int(b):    return sum(1 << i for i, bit in enumerate(b) if bit) def test_fa4():    width = 4    tot = [None] * (width + 1)    for a in range(2**width):        for b in range(2**width):            tot[:width], tot[width] = fa4(int2bus(a), int2bus(b))            assert a + b == bus2int(tot), strv % (a, b, tot)  if __name__ == '__main__':   test_fa4()"
"from math import pi, expr = exp(pi)-piprint rprint strv%(r,r,r,r,r,r)print strv%(-r,-r,-r)print strv%(r,r,r)print strv%(r,r,r)print strv%(-r,-r,-r)print strv%(r,r,r)print strv%(r,r,r)from math import pi, expr = exp(pi)-piprint(r)print(strv.format(r))print(strv.format(-r))print(strv.format(r))print(strv.format(r))print(strv.format(-r))print(strv.format(r))print(strv.format(r))"
"''' 
For a discussion on pipe() and head() see
  http://paddy3118.blogspot.com/2009/05/pipe-fitting-with-python-generators.html
''' from itertools import islicefrom fractions import Fractionfrom functools import reducetry:    from itertools import izip as zip 
except:    pass def head(n):    ''' return a generator that passes through at most n items
    '''    return lambda seq: islice(seq, n) def pipe(gen, *cmds):    ''' pipe(a,b,c,d, ...) -> yield from ...d(c(b(a)))
    '''    return reduce(lambda gen, cmd: cmd(gen), cmds, gen) def sinepower():    n = 0    fac = 1    sign = +1    zero = 0    yield zero    while True:        n +=1        fac *= n        yield Fraction(1, fac*sign)        sign = -sign        n +=1        fac *= n        yield zerodef cosinepower():    n = 0    fac = 1    sign = +1    yield Fraction(1,fac)    zero = 0    while True:        n +=1        fac *= n        yield zero        sign = -sign        n +=1        fac *= n        yield Fraction(1, fac*sign)def pluspower(*powergenerators):    for elements in zip(*powergenerators):        yield sum(elements)def minuspower(*powergenerators):    for elements in zip(*powergenerators):        yield elements[0] - sum(elements[1:])def mulpower(fgen,ggen):    'From: http://en.wikipedia.org/wiki/Power_series#Multiplication_and_division'    a,b = [],[]    for f,g in zip(fgen, ggen):        a.append(f)        b.append(g)        yield sum(f*g for f,g in zip(a, reversed(b)))def constpower(n):    yield n    while True:        yield 0def diffpower(gen):    'differentiatiate power series'    next(gen)    for n, an in enumerate(gen, start=1):        yield an*ndef intgpower(k=0):    'integrate power series with constant k'    def _intgpower(gen):        yield k        for n, an in enumerate(gen, start=1):            yield an * Fraction(1,n)    return _intgpower  print(strv)c = list(pipe(cosinepower(), head(10)))print(c)print(strv)s = list(pipe(sinepower(), head(10)))print(s)
integc = list(pipe(cosinepower(),intgpower(0), head(10)))
integs1 = list(minuspower(pipe(constpower(1), head(10)),                          pipe(sinepower(),intgpower(0), head(10)))) assert s == integc, strvassert c == integs1, strvfrom itertools import islice, teefrom fractions import Fractiontry:    from itertools import izip as zip 
except:    pass def pluspower(*powergenerators):    for elements in zip(*powergenerators):        yield sum(elements)def minuspower(*powergenerators):    for elements in zip(*powergenerators):        yield elements[0] - sum(elements[1:])def mulpower(fgen,ggen):    'From: http://en.wikipedia.org/wiki/Power_series#Multiplication_and_division'    a,b = [],[]    for f,g in zip(fgen, ggen):        a.append(f)        b.append(g)        yield sum(f*g for f,g in zip(a, reversed(b)))def constpower(n):    yield n    while True:        yield 0def diffpower(gen):    'differentiatiate power series'    next(gen)    for n, an in enumerate(gen, start=1):        yield an*ndef intgpower(gen):    'integrate power series with bounds from 0 to x'    yield 0    for n, an in enumerate(gen, start=1):        yield an * Fraction(1,n)  def sine_cosine_series():    def deferred_sin():        for i in sinx_temp:            yield i    def deferred_cos():        for i in cosx_temp:            yield i     sinx_result, sinx_copy1 = tee(deferred_sin(), 2)    cosx_result, cosx_copy1 = tee(deferred_cos(), 2)     sinx_temp = intgpower(cosx_copy1)    cosx_temp = minuspower(constpower(1), intgpower(sinx_copy1))     return sinx_result, cosx_result sinx, cosx = sine_cosine_series() print(strv)print(list(islice(sinx, 10)))print(strv)print(list(islice(cosx, 10)))from itertools import count, chain, tee, islice, cyclefrom fractions import Fraction 
class Poly:    def __init__(self, gen = None):        self.gen, self.source = (None, gen) if type(gen) is Poly \            else (gen, None)     def __iter__(self):        
        
        return Poly(self)     def getsource(self):        if self.gen == None:            s = self.source            s.getsource()            (a,b) = tee(s.gen, 2)            s.gen = a            self.gen = b     def next(self):        self.getsource()        return next(self.gen)     __next__ = next     
    def __lshift__(self, a): self.gen = a     
    def __neg__(self): return Poly(-x for x in self)     def __sub__(a, b): return a + (-b)     def __rsub__(a, n):        a = Poly(a)        def gen():            yield(n - next(a))            for x in a: yield(-x)        return Poly(gen())     def __add__(a, b):        if type(b) is Poly:            return Poly(x + y for (x,y) in zip(a,b))         a = Poly(a)        def gen():            yield(next(a) + b)            for x in a: yield(x)        return Poly(gen())     def __radd__(a,b):        return a + b     def __mul__(a,b):        if not type(b) is Poly:            return Poly(x*b for x in a)         def gen():            s = Poly(cycle([0]))            for y in b:                s += y*a                yield(next(s))         return Poly(gen())     def __rmul__(a,b): return a*b     def __truediv__(a,b):        if not type(b) is Poly:            return Poly(Fraction(x, b) for x in a)         a, b = Poly(a), Poly(b)        def gen():            r, bb = a,next(b)            while True:                aa = next(r)                q = Fraction(aa, bb)                yield(q)                r -= q*b         return Poly(gen()) 
def inte(a):    def gen():        yield(0)        for (x,n) in zip(a, count(1)):            yield(Fraction(x,n))    return Poly(gen()) def diff(a):    def gen():        for (x, n) in zip(a, count(0)):            if n: yield(x*n)    return Poly(gen())  
sinx, cosx, tanx, expx = Poly(), Poly(), Poly(), Poly() sinx << inte(cosx)cosx << 1 - inte(sinx)tanx << sinx / cosx        
expx << 1 + inte(expx) for n,x in zip((strv, strv, strv, strv), (sinx, cosx, tanx, expx)):    print(n, ', '.join(map(str, list(islice(x, 10)))))"
">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]>>> 
>>> difn = lambda s, n: difn(dif(s), n-1) if n else s >>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]>>> difn(s, 0)[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]>>> difn(s, 1)[-43, 11, -29, -7, 10, 23, -50, 50, 18]>>> difn(s, 2)[54, -40, 22, 17, 13, -73, 100, -32] >>> from pprint import pprint>>> pprint( [difn(s, i) for i in xrange(10)] )[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73], [-43, 11, -29, -7, 10, 23, -50, 50, 18], [54, -40, 22, 17, 13, -73, 100, -32], [-94, 62, -5, -4, -86, 173, -132], [156, -67, 1, -82, 259, -305], [-223, 68, -83, 341, -564], [291, -151, 424, -905], [-442, 575, -1329], [1017, -1904], [-2921]]"
"import os pid = os.fork()if pid > 0: 
else: 
"
"'''
Forest-Fire Cellular automation
 See: http://en.wikipedia.org/wiki/Forest-fire_model
''' L = 15
initial_trees = 0.55p = 0.01f = 0.001 try:    raw_inputexcept:    raw_input = input import random  tree, burning, space = 'TB.'hood = ((-1,-1), (-1,0), (-1,1),        (0,-1),          (0, 1),        (1,-1),  (1,0),  (1,1)) def initialise():    grid = {(x,y): (tree if random.random()<= initial_trees else space)            for x in range(L)            for y in range(L) }    return grid def gprint(grid):    txt = ''.join(''.join(grid[(x,y)] for x in range(L))                    for y in range(L))    print(txt) def quickprint(grid):    t = b = 0    ll = L * L    for x in range(L):        for y in range(L):            if grid[(x,y)] in (tree, burning):                t += 1                if grid[(x,y)] == burning:                    b += 1    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'          + ' (%6.3f%%, %6.3f%%)')          % (ll, t, b, 100. * t / ll, 100. * b / ll))  def gnew(grid):    newgrid = {}    for x in range(L):        for y in range(L):            if grid[(x,y)] == burning:                newgrid[(x,y)] = space            elif grid[(x,y)] == space:                newgrid[(x,y)] = tree if random.random()<= p else space            elif grid[(x,y)] == tree:                newgrid[(x,y)] = (burning                                   if any(grid.get((x+dx,y+dy),space) == burning                                            for dx,dy in hood)                                        or random.random()<= f                                    else tree)    return newgrid if __name__ == '__main__':    grid = initialise()    iter = 0    while True:        quickprint(grid)        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()        if inp:            if inp[0] == 'p':                gprint(grid)            elif inp.isdigit():                for i in range(int(inp)):                    iter +=1                    grid = gnew(grid)                    quickprint(grid)            elif inp[0] == 'q':                break        grid = gnew(grid)        iter +=1"
">>> def floyd(rowcount=5):	rows = [[1]]	while len(rows) < rowcount:		n = rows[-1][-1] + 1		rows.append(list(range(n, n + len(rows[-1]) + 1)))	return rows >>> floyd()[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):	colspace = [len(str(n)) for n in rows[-1]]	for row in rows:		print( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))  >>> pfloyd()12 34 5 67 8 9 10>>> pfloyd(floyd(5)) 1 2  3 4  5  6 7  8  9 1011 12 13 14 15>>> pfloyd(floyd(14)) 1 2  3 4  5  6 7  8  9 1011 12 13 14 1516 17 18 19 20 2122 23 24 25 26 27 2829 30 31 32 33 34 35 3637 38 39 40 41 42 43 44  4546 47 48 49 50 51 52 53  54  5556 57 58 59 60 61 62 63  64  65  6667 68 69 70 71 72 73 74  75  76  77  7879 80 81 82 83 84 85 86  87  88  89  90  9192 93 94 95 96 97 98 99 100 101 102 103 104 105>>> def floyd(rowcount=5):    return [list(range(i*(i-1)//2+1, i*(i+1)//2+1))            for i in range(1, rowcount+1)]"
"strv
Given a %i by %i sqare array of zeroes or ones in an initial
configuration, and a target configuration of zeroes and ones
The task is to transform one to the other in as few moves as 
possible by inverting whole numbered rows or whole lettered 
columns at once.
In an inversion any 1 becomes 0 and any 0 becomes 1 for that
whole row or column.
 
strv from random import randrangefrom copy import deepcopyfrom string import ascii_lowercase  try:    
    input = raw_inputexcept:    pass N = 3   
 board  = [[0]* N for i in range(N)] def setbits(board, count=1):    for i in range(count):        board[randrange(N)][randrange(N)] ^= 1 def shuffle(board, count=1):    for i in range(count):        if randrange(0, 2):            fliprow(randrange(N))        else:            flipcol(randrange(N))  def pr(board, comment=''):    print(str(comment))    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))    print('  ' + '  '.join(' '.join(['%2s' % j] + [str(i) for i in line])                             for j, line in enumerate(board, 1))) def init(board):    setbits(board, count=randrange(N)+1)    target = deepcopy(board)    while board == target:        shuffle(board, count=2 * N)    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0],                                                     ascii_lowercase[N-1])    return target, prompt def fliprow(i):    board[i-1][:] = [x ^ 1 for x in board[i-1] ] def flipcol(i):    for row in board:        row[i] ^= 1 if __name__ == '__main__':    print(__doc__ % (N, N))    target, prompt = init(board)    pr(target, 'Target configuration is:')    print('')    turns = 0    while board != target:        turns += 1        pr(board, '%i:' % turns)        ans = input(prompt).strip()        if (len(ans) == 1             and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):            flipcol(ascii_lowercase.index(ans))        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:            fliprow(int(ans))        elif ans == 'T':            pr(target, 'Target configuration is:')            turns -= 1        elif ans == 'X':            break        else:            print(strv                  ""(X to exit or T to show target)"" % ans[:9])            turns -= 1    else:        print('Well done!Bye.')"
"
for i in range(n):    if (n%2) == 0:        continue    if (n%i) == 0:        result = i        breakelse:    result = None    print strvclass MyException(Exception): passclass MyVirtual(object):    def __init__(self):        raise NotImplementedErrortry:    temp = 0/0
except:   
    print strv
try:    temp = 0/0
except ZeroDivisionError:    print strv
try:    temp = 0/0except:    print strv

finally:    print strv


try:    try:        pass    except (MyException1, MyOtherException):        pass    except SomeOtherException:finally:    do_some_cleanup() 
try:    temp = 1/1 
except ZeroDivisionError: 
    print strv
else:    print strv

i = 0while 1: 
    try:       temp2 = 0/i 
       temp = math.sqrt(i)        break 
    except ValueError: #        print strv        break 
    except ZeroDivisionError:        print strv        i-=1 
        
        
        continue 
                 




 class StupidError(Exception): pass 
try:    raise StupidError(strv) 
except StupidError, details: 
    print 'Something stupid occurred:', details 
  

    i = 101    for i in range(4): 
        print strv        if i % 2 == 0:            continue 
        print strv    else:        print strv     
    
    
    
    
    
    
    
 if(__name__ == strv):    main()class Quitting(Exception): passmax = 10 with open(strv) as myfile:    exit_counter = 0    for line in myfile:        exit_counter += 1        if exit_counter > max:            raise Quitting         print line,"
"IDLE 2.6.1      >>> 
>>> x,xi, y,yi = 2.0,0.5, 4.0,0.25>>> 
>>> z  = x + y>>> zi = 1.0 / (x + y)>>> 
>>> multiplier = lambda n1, n2: (lambda m: n1 * n2 * m)>>> 
>>> numlist = [x, y, z]>>> numlisti = [xi, yi, zi]>>> 
>>> [multiplier(inversen, n)(.5) for n, inversen in zip(numlist, numlisti)][0.5, 0.5, 0.5]>>>>>> 
>>> from math import sin, cos, acos, asin>>> 
>>> cube = lambda x: x * x * x>>> croot = lambda x: x ** (1/3.0)>>> 
>>> 
>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )>>> 
>>> funclist = [sin, cos, cube]>>> funclisti = [asin, acos, croot]>>> 
>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)][0.5, 0.4999999999999999, 0.5]>>>"
">>> def flatten(lst):	return sum( ([x] if not isinstance(x, list) else flatten(x)		     for x in lst), [] ) >>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]>>> flatten(lst)[1, 2, 3, 4, 5, 6, 7, 8]>>> def flat(lst):    i=0    while i<len(lst):        while True:            try:                lst[i:i+1] = lst[i]            except (TypeError, IndexError):                break        i += 1 >>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]>>> flat(lst)>>> lst[1, 2, 3, 4, 5, 6, 7, 8]>>> def flatten(lst):     for x in lst:         if isinstance(x, list):             for x in flatten(x):                 yield x         else:             yield x  >>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]>>> print list(flatten(lst)) [1, 2, 3, 4, 5, 6, 7, 8]def (flatten seq acc)  if no.seq       acc     ~list?.seq       (cons seq acc)     :else       (flatten car.seq (flatten cdr.seq acc))"
">>> 
>>> from math import sin, cos, acos, asin>>> 
>>> cube = lambda x: x * x * x>>> croot = lambda x: x ** (1/3.0)>>> 
>>> 
>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )>>> 
>>> funclist = [sin, cos, cube]>>> funclisti = [asin, acos, croot]>>> 
>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)][0.5, 0.4999999999999999, 0.5]>>>"
"for i in xrange(1, 101):    if i % 15 == 0:        print strv    elif i % 3 == 0:        print strv    elif i % 5 == 0:        print strv    else:        print ifor i in range(1,101): print(strv*(i%3==0) + strv*(i%5==0) or i)for i in range(100):print(i%3//2*'Fizz'+i%5//4*'Buzz'or i+1)from itertools import cycle, izip, count, islice fizzes = cycle([strv] * 2 + [strv])buzzes = cycle([strv] * 4 + [strv])both = (f + b for f, b in izip(fizzes, buzzes)) 

fizzbuzz = (word or n for word, n in izip(both, count(1))) 
for i in islice(fizzbuzz, 100):    print i"
"from __future__ import print_functionfrom shapely.geometry import LineString if __name__==strv:	line1 = LineString([(4.0,0.0), (6.0,10.0)])	line2 = LineString([(0.0,3.0), (10.0,7.0)])	print (line1.intersection(line2))"
"#!/bin/pythonfrom __future__ import print_functionimport numpy as np def LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint, epsilon=1e-6): 	ndotu = planeNormal.dot(rayDirection)	if abs(ndotu) < epsilon:		raise RuntimeError(strv) 	w = rayPoint - planePoint	si = -planeNormal.dot(w) / ndotu	Psi = w + si * rayDirection + planePoint	return Psi  if __name__==strv:	#Define plane	planeNormal = np.array([0, 0, 1])	planePoint = np.array([0, 0, 5]) #Any point on the plane 	#Define ray	rayDirection = np.array([0, -1, -1])	rayPoint = np.array([0, 0, 10]) #Any point along the ray 	Psi = LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint)	print (strv, Psi)"
"from datetime import timedelta, date DAY     = timedelta(days=1)START, STOP = date(1900, 1, 1), date(2101, 1, 1)WEEKEND = {6, 5, 4}     
FMT     = '%Y %m(%B)' def fiveweekendspermonth(start=START, stop=STOP):    'Compute months with five weekends between dates'     when = start    lastmonth = weekenddays = 0    fiveweekends = []    while when < stop:        year, mon, _mday, _h, _m, _s, wday, _yday, _isdst = when.timetuple()        if mon != lastmonth:            if weekenddays >= 15:                fiveweekends.append(when - DAY)            weekenddays = 0            lastmonth = mon        if wday in WEEKEND:            weekenddays += 1        when += DAY    return fiveweekends dates = fiveweekendspermonth()indent = '  'print('There are %s months of which the first and last five are:' % len(dates))print(indent +(''+indent).join(d.strftime(FMT) for d in dates[:5]))print(indent +'...')print(indent +(''+indent).join(d.strftime(FMT) for d in dates[-5:])) print('There are %i years in the range that do not have months with five weekends'      % len(set(range(START.year, STOP.year)) - {d.year for d in dates}))LONGMONTHS = (1, 3, 5, 7, 8, 10, 12) 
def fiveweekendspermonth2(start=START, stop=STOP):    return [date(yr, month, 31)            for yr in range(START.year, STOP.year)            for month in LONGMONTHS            if date(yr, month, 31).timetuple()[6] == 6 
            ] dates2 = fiveweekendspermonth2()assert dates2 == dates"
"environments = [{'cnt':0, 'seq':i+1} for i in range(12)] code = '''
print('% 4d' % seq, end='')
if seq != 1:
    cnt += 1
    seq = 3 * seq + 1 if seq & 1 else seq // 2
''' while any(env['seq'] > 1 for env in environments):    for env in environments:        exec(code, globals(), env)    print() print('Counts')for env in environments:    print('% 4d' % env['cnt'], end='')print()"
"from itertools import islice digits = strv def baseN(num,b):  if num == 0: return strv  result = strv  while num != 0:    num, d = divmod(num, b)    result += digits[d]  return result[::-1] 
 def pal2(num):    if num == 0 or num == 1: return True    based = bin(num)[2:]    return based == based[::-1] def pal_23():    yield 0    yield 1    n = 1    while True:        n += 1        b = baseN(n, 3)        revb = b[::-1]        #if len(b) > 12: break        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):            t = int(trial, 3)            if pal2(t):                yield t for pal23 in islice(pal_23(), 6):    print(pal23, baseN(pal23, 3), baseN(pal23, 2))"
"import random def is_probable_prime(n,k):    #this uses the miller-rabin primality test found from rosetta code    if n==0 or n==1:        return False    if n==2:        return True    if n % 2 == 0:        return False    s = 0    d = n-1     while True:        quotient, remainder = divmod(d, 2)        if remainder == 1:            break        s += 1        d = quotient     def try_composite(a):        if pow(a, d, n) == 1:            return False        for i in range(s):            if pow(a, 2**i * d, n) == n-1:                return False        return True 
     for i in range(k):        a = random.randrange(2, n)        if try_composite(a):            return False     return True 
  def largest_left_truncatable_prime(base):        radix = 0    candidates = [0]    while True:        new_candidates=[]        multiplier = base**radix        for i in range(1,base):            new_candidates += [x+i*multiplier for x in candidates if is_probable_prime(x+i*multiplier,30)]        if len(new_candidates)==0:            return max(candidates)        candidates = new_candidates        radix += 1 for b in range(3,24):    print(""%d:%d"" % (b,largest_left_truncatable_prime(b))) "
" import sysimport calendar year = 2013if len(sys.argv) > 1:    try:        year = int(sys.argv[-1])    except ValueError:        pass for month in range(1, 13):    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday)) "
"from itertools import permutations given = '''ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA
           CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB'''.split() allPerms = [''.join(x) for x in permutations(given[0])] missing = list(set(allPerms) - set(given)) 
 def missing_permutation(arr):  strv   
  
  if len(arr) == 0: raise Exception(strv)  if len(arr) == 1:      return [arr[0][1] + arr[0][0]]   
  
  
  
  
  missing_permutation = ''  for pos in range(len(arr[0])):      s = set()      for permutation in arr:          c = permutation[pos]          if c in s:            s.remove(c)          else:            s.add(c)      missing_permutation += list(s)[0]  return missing_permutation given = '''ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA
           CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB'''.split() print missing_permutation(given) >>> from collections import Counter>>> given = '''ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA
           CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB'''.split()>>> ''.join(Counter(x).most_common()[-1][0] for x in zip(*given))'DBAC'>>> >>> from pprint import pprint as pp>>> pp(list(zip(*given)), width=120)[('A', 'C', 'A', 'D', 'B', 'A', 'A', 'C', 'D', 'B', 'C', 'C', 'C', 'A', 'A', 'B', 'D', 'B', 'B', 'B', 'C', 'D', 'D'), ('B', 'A', 'C', 'A', 'C', 'C', 'D', 'D', 'A', 'C', 'A', 'D', 'B', 'B', 'D', 'D', 'C', 'A', 'A', 'D', 'B', 'B', 'C'), ('C', 'B', 'D', 'C', 'D', 'B', 'C', 'A', 'B', 'A', 'D', 'B', 'A', 'D', 'B', 'C', 'B', 'C', 'D', 'A', 'D', 'C', 'A'), ('D', 'D', 'B', 'B', 'A', 'D', 'B', 'B', 'C', 'D', 'B', 'A', 'D', 'C', 'C', 'A', 'A', 'D', 'C', 'C', 'A', 'A', 'B')]>>> pp([Counter(x).most_common() for x in zip(*given)])[[('C', 6), ('B', 6), ('A', 6), ('D', 5)], [('D', 6), ('C', 6), ('A', 6), ('B', 5)], [('D', 6), ('C', 6), ('B', 6), ('A', 5)], [('D', 6), ('B', 6), ('A', 6), ('C', 5)]]>>> pp([Counter(x).most_common()[-1] for x in zip(*given)])[('D', 5), ('B', 5), ('A', 5), ('C', 5)]>>> pp([Counter(x).most_common()[-1][0] for x in zip(*given)])['D', 'B', 'A', 'C']>>> ''.join([Counter(x).most_common()[-1][0] for x in zip(*given)])'DBAC'>>> "
"import sysprint(sys.getrecursionlimit())import syssys.setrecursionlimit(12345)def recurse(counter):  print(counter)  counter += 1  recurse(counter)File strv, line 2, in recurseRecursionError: maximum recursion depth exceeded while calling a Python object996"
"from __future__ import print_functionimport osimport hashlibimport datetime def FindDuplicateFiles(pth, minSize = 0, hashName = strv):	knownFiles = {} 	#Analyse files	for root, dirs, files in os.walk(pth):		for fina in files:			fullFina = os.path.join(root, fina)			isSymLink = os.path.islink(fullFina)			if isSymLink:				continue 
			si = os.path.getsize(fullFina)			if si < minSize:				continue			if si not in knownFiles:				knownFiles[si] = {}			h = hashlib.new(hashName)			h.update(open(fullFina, strv).read())			hashed = h.digest()			if hashed in knownFiles[si]:				fileRec = knownFiles[si][hashed]				fileRec.append(fullFina)			else:				knownFiles[si][hashed] = [fullFina] 	#Print result	sizeList = list(knownFiles.keys())	sizeList.sort(reverse=True)	for si in sizeList:		filesAtThisSize = knownFiles[si]		for hashVal in filesAtThisSize:			if len(filesAtThisSize[hashVal]) < 2:				continue			fullFinaLi = filesAtThisSize[hashVal]			print (strv)			for fullFina in fullFinaLi:				st = os.stat(fullFina)				isHardLink = st.st_nlink > 1 				infoStr = []				if isHardLink:					infoStr.append(strv)				fmtModTime = datetime.datetime.utcfromtimestamp(st.st_mtime).strftime('%Y-%m-%dT%H:%M:%SZ')				print (fmtModTime, si, os.path.relpath(fullFina, pth), strv.join(infoStr)) if __name__==strv: 	FindDuplicateFiles('/home/tim/Dropbox', 1024*1024) "
"def msb(x):    return x.bit_length() - 1 def lsb(x):    return msb(x & -x) for i in range(6):    x = 42 ** i    print(strv % (x, msb(x), lsb(x))) for i in range(6):    x = 1302 ** i    print(strv % (x, msb(x), lsb(x)))"
"import sys, osfrom collections import Counter def dodir(path):    global h     for name in os.listdir(path):        p = os.path.join(path, name)         if os.path.islink(p):            pass        elif os.path.isfile(p):            h[os.stat(p).st_size] += 1        elif os.path.isdir(p):            dodir(p)        else:            pass def main(arg):    global h    h = Counter()    for dir in arg:        dodir(dir)     s = n = 0    for k, v in sorted(h.items()):        print(strv % (k, v))        n += v        s += k * v    print(strv % (s, n)) main(sys.argv[1:])"
"values = range(10)evens = [x for x in values if not x & 1]ievens = (x for x in values if not x & 1) 

evens = filter(lambda x: not x & 1, values)values = range(10)evens = values[::2]values = range(10)values[::2] = [11,13,15,17,19]print values11, 1, 13, 3, 15, 5, 17, 7, 19, 9"
import os size = os.path.getsize('input.txt')size = os.path.getsize('/input.txt')
"import os #Get modification time:modtime = os.path.getmtime('filename') #Set the access and modification times:os.utime('path', (actime, mtime)) #Set just the modification time:os.utime('path', (os.path.getatime('path'), mtime)) #Set the access and modification times to the current time:os.utime('path', None)"
">>> import os>>> os.path.commonprefix(['/home/user1/tmp/coverage/test',                           '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])'/home/user1/tmp/cove'>>> def commonprefix(args, sep='/'):	return os.path.commonprefix(args).rpartition(sep)[0] >>> commonprefix(['/home/user1/tmp/coverage/test',                   '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])'/home/user1/tmp'>>> paths = ['/home/user1/tmp/coverage/test', '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members']>>> os.path.dirname(os.path.commonprefix(paths))'/home/user1/tmp'>>> from itertools import takewhile>>> def allnamesequal(name):	return all(n==name[0] for n in name[1:]) >>> def commonprefix(paths, sep='/'):	bydirectorylevels = zip(*[p.split(sep) for p in paths])	return sep.join(x[0] for x in takewhile(allnamesequal, bydirectorylevels)) >>> commonprefix(['/home/user1/tmp/coverage/test',                   '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])'/home/user1/tmp'>>> 
>>> commonprefix(['/home/user1/tmp', '/home/user1/tmp/coverage/test',                  '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])'/home/user1/tmp'>>> "
" def isExt(fileName, extensions):  return True in map(fileName.lower().endswith, (strv + e.lower() for e in extensions)) "
"from functools import wrapsfrom turtle import * def memoize(obj):    cache = obj.cache = {}    @wraps(obj)    def memoizer(*args, **kwargs):        key = str(args) + str(kwargs)        if key not in cache:            cache[key] = obj(*args, **kwargs)        return cache[key]    return memoizer @memoizedef fibonacci_word(n):    assert n > 0    if n == 1:        return strv    if n == 2:        return strv    return fibonacci_word(n - 1) + fibonacci_word(n - 2) def draw_fractal(word, step):    for i, c in enumerate(word, 1):        forward(step)        if c == strv:            if i % 2 == 0:                left(90)            else:                right(90) def main():    n = 25 
    step = 1 
    width = 1050 
    height = 1050 
    w = fibonacci_word(n)     setup(width=width, height=height)    speed(0)    setheading(90)    left(90)    penup()    forward(500)    right(90)    backward(500)    pendown()    tracer(10000)    hideturtle()     draw_fractal(w, step)     
    getscreen().getcanvas().postscript(file=strv)    exitonclick() if __name__ == '__main__':    main()"
">>> import math>>> from collections import Counter>>> >>> def entropy(s):...     p, lns = Counter(s), float(len(s))...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())... >>> >>> def fibword(nmax=37):...     fwords = ['1', '0']...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))...     def pr(n, fwords):...         while len(fwords) < n:...             fwords += [''.join(fwords[-2:][::-1])]...         v = fwords[n-1]...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))...     for n in range(1, nmax+1): pr(n, fwords)... >>> fibword()N       Length Entropy    Fibword  1          1         -0 1  2          1         -0 0  3          2          1 01  4          3  0.9182958 010  5          5  0.9709506 01001  6          8   0.954434 01001010  7         13  0.9612366 0100101001001  8         21  0.9587119 <too long>  9         34  0.9596869 <too long> 10         55   0.959316 <too long> 11         89  0.9594579 <too long> 12        144  0.9594038 <too long> 13        233  0.9594244 <too long> 14        377  0.9594165 <too long> 15        610  0.9594196 <too long> 16        987  0.9594184 <too long> 17       1597  0.9594188 <too long> 18       2584  0.9594187 <too long> 19       4181  0.9594187 <too long> 20       6765  0.9594187 <too long> 21      10946  0.9594187 <too long> 22      17711  0.9594187 <too long> 23      28657  0.9594187 <too long> 24      46368  0.9594187 <too long> 25      75025  0.9594187 <too long> 26     121393  0.9594187 <too long> 27     196418  0.9594187 <too long> 28     317811  0.9594187 <too long> 29     514229  0.9594187 <too long> 30     832040  0.9594187 <too long> 31    1346269  0.9594187 <too long> 32    2178309  0.9594187 <too long> 33    3524578  0.9594187 <too long> 34    5702887  0.9594187 <too long> 35    9227465  0.9594187 <too long> 36   14930352  0.9594187 <too long> 37   24157817  0.9594187 <too long>>>> "
"import shutilshutil.copyfile('input.txt', 'output.txt')infile = open('input.txt', 'r')outfile = open('output.txt', 'w')for line in infile:   outfile.write(line)outfile.close()infile.close()import systry:    infile = open('input.txt', 'r')except IOError:    print >> sys.stderr, strv    sys.exit(1)try:    outfile = open('output.txt', 'w')except IOError:    print >> sys.stderr, strv    sys.exit(1)try:  
    try: 
        for line in infile:            outfile.write(line)    except IOError, e:        print >> sys.stderr, strvfinally:    infile.close()    outfile.close()import systry:    with open('input.txt') as infile:        with open('output.txt', 'w') as outfile:            for line in infile:                outfile.write(line)except IOError:    print >> sys.stderr, strv    sys.exit(1)"
"from fractions import Fraction def nextu(a):    n = len(a)    a.append(1)    for i in range(n - 1, 0, -1):        a[i] = i * a[i] + a[i - 1]    return a def nextv(a):    n = len(a) - 1    b = [(1 - n) * x for x in a]    b.append(1)    for i in range(n):        b[i + 1] += a[i]    return b def sumpol(n):    u = [0, 1]    v = [[1], [1, 1]]    yield [Fraction(0), Fraction(1)]    for i in range(1, n):        v.append(nextv(v[-1]))        t = [0] * (i + 2)        p = 1        for j, r in enumerate(u):            r = Fraction(r, j + 1)            for k, s in enumerate(v[j + 1]):                t[k] += r * s        yield t        u = nextu(u) def polstr(a):    s = strv    q = False    n = len(a) - 1    for i, x in enumerate(reversed(a)):        i = n - i        if i < 2:            m = strv if i == 1 else strv        else:            m = strv % i        c = str(abs(x))        if i > 0:            if c == strv:                c = strv            else:                m = strv + m        if x != 0:            if q:                t = strv if x > 0 else strv                s += strv % (t, c, m)            else:                t = strv if x > 0 else strv                s = strv % (t, c, m)                q = True    if q:        return s    else:        return strv for i, p in enumerate(sumpol(10)):    print(i, strv, polstr(p))"
"import io FASTA='''
>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED''' infile = io.StringIO(FASTA) def fasta_parse(infile):    key = ''    for line in infile:        if line.startswith('>'):            if key:                yield key, val            key, val = line[1:].rstrip().split()[0], ''        elif key:            val += line.rstrip()    if key:        yield key, val print(''.join('%s: %s' % keyval for keyval in fasta_parse(infile)))"
"from cmath import exp, pi def fft(x):    N = len(x)    if N <= 1: return x    even = fft(x[0::2])    odd =  fft(x[1::2])    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]    return [even[k] + T[k] for k in range(N//2)] + \           [even[k] - T[k] for k in range(N//2)] print( ' '.join(strv % abs(f)                 for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )>>> from numpy.fft import fft>>> from numpy import array>>> a = array([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])>>> print( ' '.join(strv % abs(f) for f in fft(a)) )4.000 2.613 0.000 1.082 0.000 1.082 0.000 2.613"
">>> def fiblike(start):	addnum = len(start)	memo = start[:]	def fibber(n):		try:			return memo[n]		except IndexError:			ans = sum(fibber(i) for i in range(n-addnum, n))			memo.append(ans)			return ans	return fibber >>> fibo = fiblike([1,1])>>> [fibo(i) for i in range(10)][1, 1, 2, 3, 5, 8, 13, 21, 34, 55]>>> lucas = fiblike([2,1])>>> [lucas(i) for i in range(10)][2, 1, 3, 4, 7, 11, 18, 29, 47, 76]>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :	fibber = fiblike([1] + [2**i for i in range(n-1)])	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))  n= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...n= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...n= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...n= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...n= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...n= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...n= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...n= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...n=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...>>> >>> class Fiblike():	def __init__(self, start):		self.addnum = len(start)		self.memo = start[:]	def __call__(self, n):		try:			return self.memo[n]		except IndexError:			ans = sum(self(i) for i in range(n-self.addnum, n))			self.memo.append(ans)			return ans  >>> fibo = Fiblike([1,1])>>> [fibo(i) for i in range(10)][1, 1, 2, 3, 5, 8, 13, 21, 34, 55]>>> lucas = Fiblike([2,1])>>> [lucas(i) for i in range(10)][2, 1, 3, 4, 7, 11, 18, 29, 47, 76]>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :	fibber = Fiblike([1] + [2**i for i in range(n-1)])	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))  n= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...n= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...n= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...n= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...n= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...n= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...n= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...n= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...n=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...>>> from itertools import islice, cycle def fiblike(tail):    for x in tail:        yield x    for i in cycle(xrange(len(tail))):        tail[i] = x = sum(tail)        yield x fibo = fiblike([1, 1])print list(islice(fibo, 10))lucas = fiblike([2, 1])print list(islice(lucas, 10)) suffixes = strvfor n, name in zip(xrange(2, 11), suffixes.split()):    fib = fiblike([1] + [2 ** i for i in xrange(n - 1)])    items = list(islice(fib, 15))    print strv % (n, name, items)"
"def is_prime(number):    return True 
 def m_factor(p):    max_k = 16384 / p 
    for k in xrange(max_k):        q = 2*p*k + 1        if not is_prime(q):            continue        elif q % 8 != 1 and q % 8 != 7:            continue        elif pow(2, p, q) == 1:            return q    return None if __name__ == '__main__':    exponent = int(raw_input(strv))    if not is_prime(exponent):        print strv % exponent    else:        factor = m_factor(exponent)        if not factor:            print strv % exponent        else:            print strv % (exponent, factor)"
"def fib(n,x=[0,1]):   for i in range(abs(n)-1): x=[x[1],sum(x)]   return x[1]*pow(-1,abs(n)-1) if n<0 else x[1] if n else 0 for i in range(-30,31): print fib(i),from math import * def analytic_fibonacci(n):  sqrt_5 = sqrt(5);  p = (1 + sqrt_5) / 2;  q = 1/p;  return int( (p**n + q**n) / sqrt_5 + 0.5 ) for i in range(1,31):  print analytic_fibonacci(i),def fibIter(n):    if n < 2:        return n    fibPrev = 1    fib = 1    for num in xrange(2, n):        fibPrev, fib = fib, fib + fibPrev    return fibdef fibRec(n):    if n < 2:        return n    else:        return fibRec(n-1) + fibRec(n-2)def fibMemo():    pad = {0:0, 1:1}    def func(n):        if n not in pad:            pad[n] = func(n-1) + func(n-2)        return pad[n]    return func fm = fibMemo()for i in range(1,31):    print fm(i),def fibFastRec(n):    def fib(prvprv, prv, c):        if c < 1:             return prvprv        else:             return fib(prv, prvprv + prv, c - 1)     return fib(0, 1, n)def fibGen(n):    a, b = 0, 1    while n>0:        yield a        a, b, n = b, a+b, n-1 >>> [i for i in fibGen(11)] [0,1,1,2,3,5,8,13,21,34,55]  def prevPowTwo(n):    'Gets the power of two that is less than or equal to the given input'    if ((n & -n) == n):        return n    else:        n -= 1        n |= n >> 1        n |= n >> 2        n |= n >> 4        n |= n >> 8        n |= n >> 16        n += 1        return (n/2) def crazyFib(n):    'Crazy fast fibonacci number calculation'    powTwo = prevPowTwo(n)     q = r = i = 1    s = 0     while(i < powTwo):        i *= 2        q, r, s = q*q + r*r, r * (q + s), (r*r + s*s)     while(i < n):        i += 1        q, r, s = q+r, q, r     return q def fib(n, c={0:1, 1:1}):    if n not in c:        x = n // 2        c[n] = fib(x-1) * fib(n-x-1) + fib(x) * fib(n - x)    return c[n] fib(10000000)  
def fib():    strv    yield 1  
    lhs, rhs = fib(), fib()    yield next(lhs) 
    while True:        yield next(lhs)+next(rhs) f=fib()print [next(f) for _ in range(9)]from itertools import islice def fib():    yield 0    yield 1    a, b = fib(), fib()    next(b)    while True:        yield next(a)+next(b) print(tuple(islice(fib(), 10)))fib=function(n,x=c(0,1)) {   if (abs(n)>1) for (i in seq(abs(n)-1)) x=c(x[2],sum(x))   if (n<0) return(x[2]*(-1)^(abs(n)-1)) else if (n) return(x[2]) else return(0)}   sapply(seq(-31,31),fib)def (fib n)  if (n < 2)    n    (+ (fib n-1) (fib n-2))def (fib n)  (+ (fib n-1) (fib n-2)) def (fib n) :case (n < 2)  ndef (fib n saved)  
  default saved :to (table 0 0 1 1)  
  default saved.n :to    (+ (fib n-1 saved) (fib n-2 saved))  saved.n"
"import redef extractExt(url):  m = re.search(r'[A-Za-z0-9]+$', url)  return m.group(0) if m else strv "
"from fractions import Fraction  class Fr(Fraction):    def __repr__(self):        return '(%s/%s)' % (self.numerator, self.denominator)  def farey(n, length=False):    if not length:        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})    else:        #return 1         +    len({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1)) if __name__ == '__main__':    print('Farey sequence for order 1 through 11 (inclusive):')    for n in range(1, 12):         print(farey(n))    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')    print([farey(i, length=True) for i in range(100, 1001, 100)])"
" #! /usr/bin/python3 '''
    $ # example session in bash
    $ python3 external_sort.py 
    expect 123456789
    memory size 1 passed
    memory size 2 passed
    memory size 3 passed
    memory size 4 passed
    memory size 5 passed
    memory size 6 passed
    memory size 7 passed
    memory size 8 passed
    memory size 9 passed
    memory size 10 passed
    memory size 11 passed
''' import io def sort_large_file(n: int, source: open, sink: open, file_opener = open)->None:     '''
        approach:
            break the source into files of size n
            sort each of these files
            merge these onto the sink
    '''     
    mergers = []    while True:        text = list(source.read(n))        if not len(text):            break;        text.sort()        merge_me = file_opener()        merge_me.write(''.join(text))        mergers.append(merge_me)        merge_me.seek(0)     
    stack_tops = [f.read(1) for f in mergers]    while stack_tops:        c = min(stack_tops)        sink.write(c)        i = stack_tops.index(c)        t = mergers[i].read(1)        if t:            stack_tops[i] = t        else:            del stack_tops[i]            mergers[i].close()            del mergers[i]  
 def main():    '''
        test case
        sort 6,7,8,9,2,5,3,4,1 with several memory sizes
    '''     
    input_file_too_large_for_memory = io.StringIO('678925341')     
    t = list(input_file_too_large_for_memory.read())    t.sort()    expect = ''.join(t)    print('expect', expect)     
    for memory_size in range(1,12):        input_file_too_large_for_memory.seek(0)        output_file_too_large_for_memory = io.StringIO()        sort_large_file(memory_size, input_file_too_large_for_memory, output_file_too_large_for_memory, io.StringIO)        output_file_too_large_for_memory.seek(0)        assert(output_file_too_large_for_memory.read() == expect)        print('memory size {} passed'.format(memory_size)) if __name__ == '__main__':   example = main   example() "
">>> def factors(n):      return [i for i in range(1, n + 1) if not n%i]>>> def factors(n):      return [i for i in range(1, n//2 + 1) if not n%i] + [n] >>> factors(45)[1, 3, 5, 9, 15, 45]>>> from math import sqrt>>> def factor(n):      factors = set()      for x in range(1, int(sqrt(n)) + 1):        if n % x == 0:          factors.add(x)          factors.add(n//x)      return sorted(factors) >>> for i in (45, 53, 64): print( strv % (i, factor(i)) ) 45: factors: [1, 3, 5, 9, 15, 45]53: factors: [1, 53]64: factors: [1, 2, 4, 8, 16, 32, 64]from itertools import chain, cycle, accumulate 
 def factors(n):    def prime_powers(n):        
        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):            if c*c > n: break            if n%c: continue            d,p = (), c            while not n%c:                n,p,d = n//c, p*c, d + (p,)            yield(d)        if n > 1: yield((n,))     r = [1]    for e in prime_powers(n):        r += [a*b for a in r for b in e]    return r"
">>> 
>>> inf = 1e234 * 1e234>>> _inf = 1e234 * -1e234>>> _zero = 1 / _inf>>> nan = inf + _inf>>> inf, _inf, _zero, nan(inf, -inf, -0.0, nan)>>> 
>>> for value in (inf, _inf, _zero, nan): print (value) inf-inf-0.0nan>>> 
>>> float('nan')nan>>> float('inf')inf>>> float('-inf')-inf>>> -0.-0.0>>> 
>>> nan == nanFalse>>> nan is nanTrue>>> 0. == -0.True>>> 0. is -0.False>>> inf + _infnan>>> 0.0 * nannan>>> nan * 0.0nan>>> 0.0 * infnan>>> inf * 0.0nan>>> 
>>> 1 / -0.0 Traceback (most recent call last):  File strv, line 1, in <module>    1 / -0.0ZeroDivisionError: float division by zero>>> 
"
"#!/usr/bin/env python3 HW = r'''
/++++!/===========?++.>+.+++++++..+++
++| /+>+++++++>/ /++++++++++<<.++>./
$+++/ | ++++++++>++++.>.+++.-----
      =-<<<<+>+++/ /=.>.+>.--------.-/''' def snusp(store, code):    ds = bytearray(store)  
    dp = 0                 
    cs = code.splitlines() 
    ipr, ipc = 0, 0        
    for r, row in enumerate(cs):        try:            ipc = row.index('$')            ipr = r            break        except ValueError:            pass    rt, dn, lt, up = range(4)    id = rt  
    def step():        nonlocal ipr, ipc        if id&1:            ipr += 1 - (id&2)        else:            ipc += 1 - (id&2)    while ipr >= 0 and ipr < len(cs) and ipc >= 0 and ipc < len(cs[ipr]):        op = cs[ipr][ipc]        if op == '>':            dp += 1        elif op == '<':            dp -= 1        elif op == '+':            ds[dp] += 1        elif op == '-':            ds[dp] -= 1        elif op == '.':            print(chr(ds[dp]), end='')        elif op == ',':            ds[dp] = input()        elif op == '/':            id = ~id        elif op == '':            id ^= 1        elif op == '!':            step()        elif op == '?':            if not ds[dp]:                step()        step() if __name__ == '__main__':    snusp(5, HW)"
"islice(count(7), 0, None, 2)from __future__ import print_functionfrom prime_decomposition import primesfrom itertools import islice  def p_range(lower_inclusive, upper_exclusive):    'Primes in the range'    for p in primes():        if p >= upper_exclusive: break        if p >= lower_inclusive: yield p if __name__ == '__main__':    print('The first twenty primes:  ', list(islice(primes(),20)))    print('The primes between 100 and 150:  ', list(p_range(100, 150)))    print('The ''number'' of primes between 7,700 and 8,000:  ', len(list(p_range(7700, 8000))))    print('The 10,000th prime:  ', next(islice(primes(),10000-1, 10000)))def wsieve():       
    wh11 = [ 2,4,2,4,6,2,6,4,2,4,6,6, 2,6,4,2,6,4,6,8,4,2,4,2,             4,8,6,4,6,2,4,6,2,6,6,4, 2,4,6,2,6,4,2,4,2,10,2,10]    cs = accumulate( chain( [11], cycle( wh11)))    yield( next( cs))  
    ps = wsieve()      
    p = next(ps)       
    psq = p*p          
    D = dict( zip( accumulate( chain( [0], wh11)), count(0)))   
    mults = {}    for c in cs:        if c in mults:            wheel = mults.pop(c)          elif c < psq:                          yield c ; continue           else:          
            x = [p*d for d in wh11]            i = D[ (p-11) % 210]            wheel = accumulate( chain( [psq+x[i]], cycle( x[i+1:] + x[:i+1])))            p = next(ps) ; psq = p*p         for m in wheel:             if not m in mults:                 break        mults[m] = wheel def primes(): 	yield from (2, 3, 5, 7)	yield from wsieve()  print( list( islice( primes(), 0, 20)))print( list( takewhile( lambda x: x<150,                    dropwhile( lambda x: x<100, primes()))))print( len( list( takewhile( lambda x: x<8000,                    dropwhile( lambda x: x<7700, primes())))))print( list( islice( primes(), 10000-1, 10000))[0])"
"import mathmath.factorial(n)def factorial(n):    result = 1    for i in range(1, n+1):        result *= i    return resultfrom operator import mulfrom functools import reduce def factorial(n):    return reduce(mul, range(1,n+1), 1)def factorial(n):    z=1    if n>1:        z=n*factorial(n-1)    return zfrom cmath import * 
g = 7p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,     771.32342877765313, -176.61502916214059, 12.507343278686905,     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7] def gamma(z):  z = complex(z)  
  if z.real < 0.5:    return pi / (sin(pi*z)*gamma(1-z))  else:    z -= 1    x = p[0]    for i in range(1, g+2):      x += p[i]/(z+i)    t = z + g + 0.5    return sqrt(2*pi) * t**(z+0.5) * exp(-t) * x def factorial(n):  return gamma(n+1) print strv,factorial(-0.5)**2for i in range(10):  print strv%(i,factorial(i))def (fact n)  if (n = 0)    1    (n * (fact n-1))def (fact n)  (n * (fact n-1)) def (fact 0)  1def (fact n)  ret result 1    for i 1 (i <= n) ++i      result <- result*i
def (nums n)  collect+for i 1 (i <= n) ++i    yield i def (fact n)  (reduce (*) nums.n 1)"
"MULTIPLY = lambda x, y: x*y class num(float):    
    
    def __pow__(self, b):        return reduce(MULTIPLY, [self]*b, 1) 
print num(2).__pow__(3)print num(2) ** 3 
print num(2.3).__pow__(8)print num(2.3) ** 8"
"def hailstone(n):    seq = [n]    while n>1:        n = 3*n + 1 if n & 1 else n//2        seq.append(n)    return seq if __name__ == '__main__':    h = hailstone(27)    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]    print(strv %          max((len(hailstone(i)), i) for i in range(1,100000)))from collections import Counter def function_length_frequency(func, hrange):    return Counter(len(func(n)) for n in hrange).most_common() if __name__ == '__main__':    from executable_hailstone_library import hailstone     upto = 100000    hlen, freq = function_length_frequency(hailstone, range(1, upto))[0]    print(""The length of hailstone sequence that is most common for""          strv          % (upto, hlen, freq))"
"import re def extractreplacements(grammar):    return [ (matchobj.group('pat'), matchobj.group('repl'), bool(matchobj.group('term')))                for matchobj in re.finditer(syntaxre, grammar)                if matchobj.group('rule')] def replace(text, replacements):    while True:        for pat, repl, term in replacements:            if pat in text:                text = text.replace(pat, repl, 1)                if term:                    return text                break        else:            return text syntaxre = rstrv(?mx)
^(?: 
  (?: (?P<comment>  .* ) ) |
  (?: (?P<blank>   *  ) (?:  | $ )  ) |
  (?: (?P<rule>    (?P<pat> .+? ) + -> + (?P<term> )? (?P<repl> .+) ) )
)$
strv grammar1 = strv




A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule
strv grammar2 = '''


A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
''' grammar3 = '''


A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
''' grammar4 = '''
### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.


_+1 -> _1+
1+1 -> 11+




1! -> !1
,! -> !+
_! -> _


1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _


 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +


_1 -> 1
1+_ -> 1
_+_ -> 
''' grammar5 = '''


#


A0 -> 1B


0A1 -> C01
1A1 -> C11


0B0 -> A01
1B0 -> A11


B1 -> 1B


0C0 -> B01
1C0 -> B11


0C1 -> H01
1C1 -> H11
''' text1 = strv text2 = strv text3 = '_1111*11111_' text4 = '000000A000000'  if __name__ == '__main__':    assert replace(text1, extractreplacements(grammar1)) \           == 'I bought a bag of apples from my brother.'    assert replace(text1, extractreplacements(grammar2)) \           == 'I bought a bag of apples from T shop.'    
    assert replace(text2, extractreplacements(grammar3)) \           == 'I bought a bag of apples with my money from T shop.'    assert replace(text3, extractreplacements(grammar4)) \           == '11111111111111111111'    assert replace(text4, extractreplacements(grammar5)) \           == '00011H1111000'"
"class U0(Exception): passclass U1(Exception): pass def foo():    for i in range(2):        try:            bar(i)        except U0:            print(strv) def bar(i):    baz(i) 
 def baz(i):    raise U1 if i else U0 foo()"
"import exceptionsclass SillyError(exceptions.Exception):    def __init__(self,args=None):         self.args=argsclass MyInvalidArgument(ValueError):   passdef spam():    raise SillyError 
def spam():    raise SillyError, 'egg' 
def spam():    raise SillyError('egg')try:   foo()except SillyError, se:   print se.args   bar()else:   
   quux()finally:   baz()try:   foo()except SillyError as se:   print(se.args)   bar()else:   
   quux()finally:   baz()"
">>> def is_odd(i): return bool(i & 1) >>> def is_even(i): return not is_odd(i) >>> [(j, is_odd(j)) for j in range(10)][(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]>>> [(j, is_even(j)) for j in range(10)][(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]>>> >> def is_even(i):        return (i % 2) == 0 >>> is_even(1)False>>> is_even(2)True>>>"
"def eulers_sum_of_powers():    max_n = 250    pow_5 = [n**5 for n in range(max_n)]    pow5_to_n = {n**5: n for n in range(max_n)}    for x0 in range(1, max_n):        for x1 in range(1, x0):            for x2 in range(1, x1):                for x3 in range(1, x2):                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))                    if pow_5_sum in pow5_to_n:                        y = pow5_to_n[pow_5_sum]                        return (x0, x1, x2, x3, y) print(strv % eulers_sum_of_powers())from itertools import combinations def eulers_sum_of_powers():    max_n = 250    pow_5 = [n**5 for n in range(max_n)]    pow5_to_n = {n**5: n for n in range(max_n)}    for x0, x1, x2, x3 in combinations(range(1, max_n), 4):        pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))        if pow_5_sum in pow5_to_n:            y = pow5_to_n[pow_5_sum]            return (x0, x1, x2, x3, y) print(strv % eulers_sum_of_powers())MAX = 250p5, sum2 = {}, {} for i in range(1, MAX):	p5[i**5] = i	for j in range(i, MAX):		sum2[i**5 + j**5] = (i, j) sk = sorted(sum2.keys())for p in sorted(p5.keys()):	for s in sk:		if p <= s: break		if p - s in sum2:			print(p5[p], sum2[s] + sum2[p-s])			exit()"
"def binomialCoeff(n, k):    result = 1    for i in range(1, k+1):        result = result * (n-i+1) / i    return result if __name__ == strv:    print(binomialCoeff(5, 3))from operator import muldef comb(n,r):    ''' calculate nCr - the binomial coefficient
    >>> comb(3,2)
    3
    >>> comb(9,4)
    126
    >>> comb(9,6)
    84
    >>> comb(20,14)
    38760
    '''     if r > n-r:  
        r = n-r    return int( reduce( mul, range((n-r+1), n+1), 1) /      reduce( mul, range(1,r+1), 1) )"
"import osexit_code = os.system('ls')       
output    = os.popen('ls').read() 
import subprocess
exit_code = subprocess.check_call(['ls', '-l'])   
assert exit_code == 0output    = subprocess.check_output(['ls', '-l']) 
from subprocess import PIPE, Popen, STDOUTp = Popen('ls', stdout=PIPE, stderr=STDOUT)print p.communicate()[0]import commandsstat, out = commands.getstatusoutput('ls')if not stat:    print out"
">>> 5**3**21953125>>> (5**3)**215625>>> 5**(3**2)1953125>>> 
>>> try: from functools import reduce 
except: pass >>> reduce(pow, (5, 3, 2))15625>>> "
"from string import lettersfrom random import choice, random target  = list(strv)charset = letters + ' 'parent  = [choice(charset) for _ in range(len(target))]minmutaterate  = .09C = range(100) perfectfitness = float(len(target)) def fitness(trial):    'Sum of matching chars by position'    return sum(t==h for t,h in zip(trial, target)) def mutaterate():    'Less mutation the closer the fit of the parent'    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate)) def mutate(parent, rate):    return [(ch if random() <= rate else choice(charset)) for ch in parent] def que():    '(from the favourite saying of Manuel in Fawlty Towers)'    print (strv %           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent))) def mate(a, b):    place = 0    if choice(xrange(10)) < 7:        place = choice(xrange(len(target)))    else:        return a, b     return a, b, a[:place] + b[place:], b[:place] + a[place:] iterations = 0center = len(C)/2while parent != target:    rate = mutaterate()    iterations += 1    if iterations % 100 == 0: que()    copies = [ mutate(parent, rate) for _ in C ]  + [parent]    parent1 = max(copies[:center], key=fitness)    parent2 = max(copies[center:], key=fitness)    parent = max(mate(parent1, parent2), key=fitness)que()from random import choice, random target  = list(strv)alphabet = strvp = 0.05 
c = 100  
 def neg_fitness(trial):    return sum(t != h for t,h in zip(trial, target)) def mutate(parent):    return [(choice(alphabet) if random() < p else ch) for ch in parent] parent = [choice(alphabet) for _ in xrange(len(target))]i = 0print strv % i, strv.join(parent)while parent != target:    copies = (mutate(parent) for _ in xrange(c))    parent = min(copies, key=neg_fitness)    print strv % i, strv.join(parent)    i += 1"
"def euler(f,y0,a,b,h):	t,y = a,y0	while t <= b:		print strv % (t,y)		t += h		y += h * f(t,y) def newtoncooling(time, temp):	return -0.07 * (temp - 20) euler(newtoncooling,100,0,100,10) "
import osos.environ['HOME']
">>> from enum import Enum>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')>>> Contact.__members__mappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))>>> >>> 
>>> class Contact2(Enum):	FIRST_NAME = 1	LAST_NAME = 2	PHONE = 3  >>> Contact2.__members__mappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))>>> FIRST_NAME, LAST_NAME, PHONE = range(3)vars().update((key,val) for val,key in enumerate((strv,strv,strv)))"
"def eqindex2Pass(data):    strv    suml, sumr, ddelayed = 0, sum(data), 0    for i, d in enumerate(data):        suml += ddelayed        sumr -= d        ddelayed = d        if suml == sumr:            yield idef eqindexMultiPass(data):    strv    for i in range(len(data)):        suml, sumr = sum(data[:i]), sum(data[i+1:])        if suml == sumr:            yield idef eqindexMultiPass(s):    return [i for i in xrange(len(s)) if sum(s[:i]) == sum(s[i+1:])] print eqindexMultiPass([-7, 1, 5, 2, -4, 3, 0])from collections import defaultdict def eqindex1Pass(data):    strv    l, h = 0, defaultdict(list)    for i, c in enumerate(data):        l += c        h[l * 2 - c].append(i)    return h[l]f = (eqindex2Pass, eqindexMultiPass, eqindex1Pass)d = ([-7, 1, 5, 2, -4, 3, 0],     [2, 4, 6],     [2, 9, 2],     [1, -1, 1, -1, 1, -1, 1]) for data in d:    print(strv % data)    for func in f:        print(strv % (func.__name__, list(func(data))))"
"tutor = True def halve(x):    return x // 2 def double(x):    return x * 2 def even(x):    return not x % 2 def ethiopian(multiplier, multiplicand):    if tutor:        print(strv %              (multiplier, multiplicand))    result = 0    while multiplier >= 1:        if even(multiplier):            if tutor:                print(strv %                      (multiplier, multiplicand))        else:            if tutor:                print(strv %                      (multiplier, multiplicand))            result += multiplicand        multiplier   = halve(multiplier)        multiplicand = double(multiplicand)    if tutor:        print()    return resulthalve  = lambda x: x // 2double = lambda x: x*2even   = lambda x: not x % 2 def ethiopian(multiplier, multiplicand):    result = 0     while multiplier >= 1:        if not even(multiplier):            result += multiplicand        multiplier   = halve(multiplier)        multiplicand = double(multiplicand)     return resulttutor = True from itertools import izip, takewhile def iterate(function, arg):    while 1:        yield arg        arg = function(arg) def halve(x): return x // 2def double(x): return x * 2def even(x): return x % 2 == 0 def show_heading(multiplier, multiplicand):    print strv % (multiplier, multiplicand),    print strv    print TABLE_FORMAT = strv def show_table(table):    for p, q in table:        print TABLE_FORMAT % (p, q, strv,                              p, q if not even(p) else strv * len(str(q))) def show_result(result):    print TABLE_FORMAT % ('', '', '', '', strv * (len(str(result)) + 1))    print TABLE_FORMAT % ('', '', '', '', result) def ethiopian(multiplier, multiplicand):    def column1(x): return takewhile(lambda v: v >= 1, iterate(halve, x))    def column2(x): return iterate(double, x)    def rows(x, y): return izip(column1(x), column2(y))    table = rows(multiplier, multiplicand)    if tutor:         table = list(table)        show_heading(multiplier, multiplicand)        show_table(table)    result = sum(q for p, q in table if not even(p))    if tutor:         show_result(result)    return result"
"import mathfrom collections import Counter def entropy(s):    p, lns = Counter(s), float(len(s))    return -sum( count/lns * math.log(count/lns, 2) for count in p.values()) with open('c:/E.py') as f:    b=f.read() print(entropy(b))"
">>> s = strv>>> s[0] = strv Traceback (most recent call last):  File strv, line 1, in <module>    s[0] = strvTypeError: 'str' object does not support item assignment>>> class Immut(object):	def __setattr__(self, *args):		raise TypeError(			strv)         __delattr__ = __setattr__         def __repr__(self):		return str(self.value)         def __init__(self, value):                
		super(Immut, self).__setattr__(strv, value) >>> im = Immut(123)>>> im123>>> im.value = 124 Traceback (most recent call last):  File strv, line 1, in <module>    del a.value  File strv, line 4, in __setattr__    strv)TypeError: 'Immut' object does not support item assignment>>>"
s = ''if not s:    print('String s is empty.')if s:    print('String s is not empty.')
"from __future__ import divisionimport math def hist(source):    hist = {}; l = 0;    for e in source:        l += 1        if e not in hist:            hist[e] = 0        hist[e] += 1    return (l,hist) def entropy(hist,l):    elist = []    for v in hist.values():        c = v / l        elist.append(-c * math.log(c ,2))    return sum(elist) def printHist(h):    flip = lambda (k,v) : (v,k)    h = sorted(h.iteritems(), key = flip)    print 'SymhifiInf'    for (k,v) in h:        print '%s%f%f%f'%(k,v,v/l,-math.log(v/l, 2))   source = strv(l,h) = hist(source);print '.[Results].'print 'Length',lprint 'Entropy:', entropy(h, l)printHist(h)>>> import math>>> from collections import Counter>>> >>> def entropy(s):...     p, lns = Counter(s), float(len(s))...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())... >>> entropy(strv)1.8464393446710154>>> def Entropy(text):    import math    log2=lambda x:math.log(x)/math.log(2)    exr={}    infoc=0    for each in text:        try:            exr[each]+=1        except:            exr[each]=1    textlen=len(text)    for k,v in exr.items():        freq  =  1.0*v/textlen        infoc+=freq*log2(freq)    infoc*=-1    return infoc while True:    print Entropy(raw_input('>>>'))"
import os;if os.listdir(raw_input(strv)):    print strvelse:    print strv 
"#!/usr/bin/env python3 class Point:    b = 7    def __init__(self, x=float('inf'), y=float('inf')):        self.x = x        self.y = y     def copy(self):        return Point(self.x, self.y)     def is_zero(self):        return self.x > 1e20 or self.x < -1e20     def neg(self):        return Point(self.x, -self.y)     def dbl(self):        if self.is_zero():            return self.copy()        try:            L = (3 * self.x * self.x) / (2 * self.y)        except ZeroDivisionError:            return Point()        x = L * L - 2 * self.x        return Point(x, L * (self.x - x) - self.y)     def add(self, q):        if self.x == q.x and self.y == q.y:            return self.dbl()        if self.is_zero():            return q.copy()        if q.is_zero():            return self.copy()        try:            L = (q.y - self.y) / (q.x - self.x)        except ZeroDivisionError:            return Point()        x = L * L - self.x - q.x        return Point(x, L * (self.x - x) - self.y)     def mul(self, n):        p = self.copy()        r = Point()        i = 1        while i <= n:            if i&n:                r = r.add(p)            p = p.dbl()            i <<= 1        return r     def __str__(self):        return strv.format(self.x, self.y) def show(s, p):    print(s, strv if p.is_zero() else p) def from_y(y):    n = y * y - Point.b    x = n**(1./3) if n>=0 else -((-n)**(1./3))    return Point(x, y) 
a = from_y(1)b = from_y(2)show(strv, a)show(strv, b)c = a.add(b)show(strv, c)d = c.neg()show(strv, d)show(strv, c.add(d))show(strv, a.add(b.add(d)))show(strv, a.mul(12345))"
"from __future__ import print_functionfrom prime_decomposition import primes, is_primefrom heapq import *from itertools import islice def emirp():    largest = set()    emirps = []    heapify(emirps)    for pr in primes():        while emirps and pr > emirps[0]:            yield heappop(emirps)        if pr in largest:            yield pr        else:            rp = int(str(pr)[::-1])            if rp > pr and is_prime(rp):                heappush(emirps, pr)                largest.add(rp) print('First 20:  ', list(islice(emirp(), 20)))print('Between 7700 and 8000:  [', end='')for pr in emirp():    if pr >= 8000: break    if pr >= 7700: print(pr, end=', ')print(']')print('10000th:  ', list(islice(emirp(), 10000-1, 10000)))"
"from elementary_cellular_automaton import eca, eca_wrap def rule30bytes(lencells=100):    cells = '1' + '0' * (lencells - 1)    gen = eca(cells, 30)    while True:        yield int(''.join(next(gen)[0] for i in range(8)), 2) if __name__ == '__main__':    print([b for i,b in zip(range(10), rule30bytes())])def rule30bytes(lencells=100):    cells = '1' + '0' * (lencells - 1)    gen = eca_wrap(cells, 30)    while True:        yield int(''.join(next(gen)[0] for i in range(8)), 2))"
"def _notcell(c):    return '0' if c == '1' else '1' def eca_infinite(cells, rule):    lencells = len(cells)    rulebits = '{0:08b}'.format(rule)    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}    c = cells    while True:        yield c        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    
         c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))        #yield c[1:-1] if __name__ == '__main__':    lines = 25    for rule in (90, 30):        print('Rule: %i' % rule)        for i, c in zip(range(lines), eca_infinite('1', rule)):            print('%2i: %s%s' % (i, ' '*(lines - i), c.replace('0', '.').replace('1', '#')))"
"#!/bin/pythonfrom __future__ import print_function class Node(object):	def __init__(self):		self.edges = {} 
		self.link = None 
		self.len = 0 
 class Eertree(object):	def __init__(self):		self.nodes = []		
		self.rto = Node() #odd length root node, or node -1		self.rte = Node() #even length root node, or node 0 		
		self.rto.link = self.rte.link = self.rto;		self.rto.len = -1		self.rte.len = 0		self.S = [0] 
		self.maxSufT = self.rte 
 	def get_max_suffix_pal(self, startNode, a):		
		
		
		u = startNode		i = len(self.S)		k = u.len		while id(u) != id(self.rto) and self.S[i - k - 1] != a:			assert id(u) != id(u.link) #Prevent infinte loop			u = u.link			k = u.len 		return u 	def add(self, a): 		
		
		
		
		Q = self.get_max_suffix_pal(self.maxSufT, a) 		
		createANewNode = not a in Q.edges 		if createANewNode:			
			P = Node()			self.nodes.append(P)			P.len = Q.len + 2			if P.len == 1:				
				P.link = self.rte			else:				
				
				
				P.link = self.get_max_suffix_pal(Q.link, a).edges[a] 			
			Q.edges[a] = P 		#P becomes the new maxSufT		self.maxSufT = Q.edges[a] 		#Store accumulated input string		self.S.append(a) 		return createANewNode 	def get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):		#Each node represents a palindrome, which can be reconstructed		#by the path from the root node to each non-root node. 		#Traverse all edges, since they represent other palindromes		for lnkName in nd.edges:			nd2 = nd.edges[lnkName] #The lnkName is the character used for this edge			self.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result) 		#Reconstruct based on charsToHere characters.		if id(nd) != id(self.rto) and id(nd) != id(self.rte): #Don't print for root nodes			tmp = strv.join(charsToHere)			if id(nodesToHere[0]) == id(self.rte): #Even string				assembled = tmp[::-1] + tmp			else: #Odd string				assembled = tmp[::-1] + tmp[1:]			result.append(assembled) if __name__==strv:	st = strv	print (strv, st)	eertree = Eertree()	for ch in st:		eertree.add(ch) 	print (strv, len(eertree.nodes)) 	#Traverse tree to find sub-palindromes	result = []	eertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) #Odd length words	eertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) #Even length words	print (strv, result)"
"def eca(cells, rule):    lencells = len(cells)    c = strv + cells + strv    
    rulebits = '{0:08b}'.format(rule)    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}    yield c[1:-1]    while True:        c = ''.join(['0',                     ''.join(neighbours2next[c[i-1:i+2]]                             for i in range(1,lencells+1)),                     '0'])        yield c[1:-1] if __name__ == '__main__':    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)    zipped = [range(lines)] + [eca(start, rule) for rule in rules]    print('   Rules: %r' % (rules,))    for data in zip(*zipped):        i = data[0]        cells = data[1:]        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))def eca_wrap(cells, rule):    lencells = len(cells)    rulebits = '{0:08b}'.format(rule)    neighbours2next = {tuple('{0:03b}'.format(n)):rulebits[::-1][n] for n in range(8)}    c = cells    while True:        yield c        c = ''.join(neighbours2next[(c[i-1], c[i], c[(i+1) % lencells])] for i in range(lencells)) if __name__ == '__main__':    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)    zipped = [range(lines)] + [eca_wrap(start, rule) for rule in rules]    print('   Rules: %r' % (rules,))    for data in zip(*zipped):        i = data[0]        cells = data[1:]        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#'))) def _notcell(c):    return '0' if c == '1' else '1' def eca_infinite(cells, rule):    lencells = len(cells)    rulebits = '{0:08b}'.format(rule)    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}    c = cells    while True:        yield c        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    
         c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))        #yield c[1:-1] if __name__ == '__main__':    lines, start, rules = 20, '1', (90, 30, 122)    zipped = [range(lines)] + [eca_infinite(start, rule) for rule in rules]    print('   Rules: %r' % (rules,))    for data in zip(*zipped):        i = data[0]        cells = ['%s%s%s' % (' '*(lines - i), c, ' '*(lines - i)) for c in data[1:]]        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))"
"from fractions import Fractionfrom math import ceil class Fr(Fraction):    def __repr__(self):        return '%s/%s' % (self.numerator, self.denominator) def ef(fr):    ans = []    if fr >= 1:        if fr.denominator == 1:            return [[int(fr)], Fr(0, 1)]        intfr = int(fr)        ans, fr = [[intfr]], fr - intfr    x, y = fr.numerator, fr.denominator    while x != 1:        ans.append(Fr(1, ceil(1/fr)))        fr = Fr(-y % x, y* ceil(1/fr))        x, y = fr.numerator, fr.denominator    ans.append(fr)    return ans if __name__ == '__main__':    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:        print('%r ─► %s' % (fr, ' '.join(str(x) for x in ef(fr))))    lenmax = denommax = (0, None)     for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):        e = ef(fr)        #assert sum((f[0] if type(f) is list else f) for f in e) == fr, 'Whoops!'        elen, edenom = len(e), e[-1].denominator        if elen > lenmax[0]:            lenmax = (elen, fr, e)        if edenom > denommax[0]:            denommax = (edenom, fr, e)    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))    dstr = str(denommax[0])    print('Denominator max is %r with %i digits %s...%s' %          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))"
"import SocketServer HOST = strvPORT = 12321 

 class EchoServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):    
    pass class EchoRequestHandler(SocketServer.StreamRequestHandler):    strv
    Handles one connection to the client.
    strv    def handle(self):        print strv % self.client_address[0]        while True:            line = self.rfile.readline()            if not line: break            print strv % (self.client_address[0], line.rstrip())            self.wfile.write(line)        print strv % self.client_address[0]  
server = EchoServer((HOST, PORT), EchoRequestHandler) 

print strv % server.server_addressserver.serve_forever()"
">>> import random>>> from operator import add, sub, mul, floordiv>>> from pprint import pprint as pp>>> >>> def ewise(matrix1, matrix2, op):	return [[op(e1,e2) for e1,e2 in zip(row1, row2)] for row1,row2 in zip(matrix1, matrix2)] >>> m,n = 3,4 	
>>> a0 = [[random.randint(1,9) for y in range(n)] for x in range(m)]>>> a1 = [[random.randint(1,9) for y in range(n)] for x in range(m)]>>> pp(a0); pp(a1)[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]][[4, 5, 1, 6], [6, 8, 3, 4], [2, 2, 6, 3]]>>> pp(ewise(a0, a1, add))[[11, 13, 8, 10], [10, 17, 7, 5], [4, 5, 12, 7]]>>> pp(ewise(a0, a1, sub))[[3, 3, 6, -2], [-2, 1, 1, -3], [0, 1, 0, 1]]>>> pp(ewise(a0, a1, mul))[[28, 40, 7, 24], [24, 72, 12, 4], [4, 6, 36, 12]]>>> pp(ewise(a0, a1, floordiv))[[1, 1, 7, 0], [0, 1, 1, 0], [1, 1, 1, 1]]>>> pp(ewise(a0, a1, pow))[[2401, 32768, 7, 4096], [4096, 43046721, 64, 1], [4, 9, 46656, 64]]>>> pp(ewise(a0, a1, lambda x, y:2*x - y))[[10, 11, 13, 2], [2, 10, 5, -2], [2, 4, 6, 5]]>>> >>> def s_ewise(scalar1, matrix1, op):	return [[op(scalar1, e1) for e1 in row1] for row1 in matrix1] >>> scalar = 10>>> a0[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]>>> for op in ( add, sub, mul, floordiv, pow, lambda x, y:2*x - y ):	print(strv % op.__name__, s_ewise(scalar, a0, op))         add : [[17, 18, 17, 14], [14, 19, 14, 11], [12, 13, 16, 14]]       sub : [[3, 2, 3, 6], [6, 1, 6, 9], [8, 7, 4, 6]]       mul : [[70, 80, 70, 40], [40, 90, 40, 10], [20, 30, 60, 40]]  floordiv : [[1, 1, 1, 2], [2, 1, 2, 10], [5, 3, 1, 2]]       pow : [[10000000, 100000000, 10000000, 10000], [10000, 1000000000, 10000, 10], [100, 1000, 1000000, 10000]]  <lambda> : [[13, 12, 13, 16], [16, 11, 16, 19], [18, 17, 14, 16]]>>> "
>>> name = raw_input(strv)Enter a variable name: X>>> globals()[name] = 42>>> X42>>> name = input(strv)Enter a variable name: X>>> globals()[name] = 42>>> X42
"from visual import *scene.title = strv scene.range = 2scene.autocenter = True print strvprint strv deg45 = math.radians(45.0)  
 cube = box()    
cube.rotate( angle=deg45, axis=(1,0,0) )cube.rotate( angle=deg45, axis=(0,0,1) ) while True:                 
    rate(50)    cube.rotate( angle=0.005, axis=(0,1,0) ) "
"import random colours_in_order = 'Red White Blue'.split() def dutch_flag_sort(items, order=colours_in_order):    'return sort of items using the given order'    reverse_index = dict((x,i) for i,x in enumerate(order))    return sorted(items, key=lambda x: reverse_index[x]) def dutch_flag_check(items, order=colours_in_order):    'Return True if each item of items is in the given order'    reverse_index = dict((x,i) for i,x in enumerate(order))    order_of_items = [reverse_index[item] for item in items]    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:])) def random_balls(mx=5):    'Select from 1 to mx balls of each colour, randomly'    balls = sum([[colour] * random.randint(1, mx)                 for colour in colours_in_order], [])    random.shuffle(balls)    return balls def main():    
    while True:        balls = random_balls()        if not dutch_flag_check(balls):            break    print(strv, balls)    sorted_balls = dutch_flag_sort(balls)    print(strv, sorted_balls)    assert dutch_flag_check(sorted_balls), 'Whoops. Not sorted!' if __name__ == '__main__':    main()from itertools import chaindef dutch_flag_sort2(items, order=colours_in_order):    'return summed filter of items using the given order'    return list(chain.from_iterable(filter(lambda c: c==colour, items)                                    for colour in order))def dutch_flag_sort2(items, order=colours_in_order):    'return summed filter of items using the given order'    return [c for colour in order for c in items if c==colour]def dutch_flag_sort3(items, order=colours_in_order):    'counts each colour to construct flag'    return sum([[colour] * items.count(colour) for colour in order], [])import random colours_in_order = 'Red White Blue'.split() def dutch_flag_sort(items):    '''
    In-place sort of list items using the given order.
    Python idiom is to return None when argument is modified in-place
 
    O(n)? Algorithm from Go language implementation of
    http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Flag/'''     lo, mid, hi = 0, 0, len(items)-1    while mid <= hi:        colour = items[mid]        if colour == 'Red':            items[lo], items[mid] = items[mid], items[lo]            lo += 1            mid += 1        elif colour == 'White':            mid += 1        else:            items[mid], items[hi] = items[hi], items[mid]            hi -= 1 def dutch_flag_check(items, order=colours_in_order):    'Return True if each item of items is in the given order'    order_of_items = [order.index(item) for item in items]    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:])) def random_balls(mx=5):    'Select from 1 to mx balls of each colour, randomly'    balls = sum(([[colour] * random.randint(1, mx)                 for colour in colours_in_order]), [])    random.shuffle(balls)    return balls def main():    
    while 1:        balls = random_balls()        if not dutch_flag_check(balls):            break    print(strv, balls)    dutch_flag_sort(balls)    print(strv, balls)    assert dutch_flag_check(balls), 'Whoops. Not sorted!' if __name__ == '__main__':    main()"
"def _pr(t, x, y, z):    txt = ''.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()                    for m in reversed(range(3+y+z)))    return txt def cuboid(x,y,z):    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']    for i,ch in enumerate(xrow):        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch    if _debug: print(_pr(t, x, y, z))    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']    for j,ch in enumerate(ycol):        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']    if _debug: print(_pr(t, x, y, z))    for k,ch in enumerate(zdepth):        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch     return _pr(t, x, y, z)  _debug = Falseif __name__ == '__main__':    for dim in ((2,3,4), (3,4,2), (4,2,3)):        print(strv % (dim,), cuboid(*dim), sep='')from visual import *mybox = box(pos=(0,0,0), length=4, height=2, width=3, axis=(-0.1,-0.1,0.1) ) scene.title = strv from __future__ import print_function, divisionfrom visual import *import itertools title = strvscene.title = titleprint( ""%s"" % title ) msg = strv
Drag with right mousebutton to rotate view.
Drag up+down with middle mousebutton to zoom.
Left mouseclick to show info.
 
Press x,X, y,Y, z,Z to rotate the box in single steps.
Press b, c,o,m to change background, color, opacity, material.
Press r,R to rotate, d,a for demo, automatic,  space to stop.
Press h to show this help,  ESC or q to quit.
strv #...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+... ## Rotate one step per keypress: def rotX(obj, a) :    obj.rotate( angle=a, axis=(1,0,0) )def rotY(obj, a) :    obj.rotate( angle=a, axis=(0,1,0) )def rotZ(obj, a) :    obj.rotate( angle=a, axis=(0,0,1) ) ## Selection of background-colors: bg_list = [color.gray(0.2), color.gray(0.4), color.gray(0.7), color.gray(0.9)]bg = itertools.cycle(bg_list)def backgr() :    b = next(bg)    print(strv,b)    scene.background = b ## Selection of colors: col_list = [color.white, color.red,  color.orange, color.yellow,              color.green, color.blue, color.cyan,   color.magenta,             color.black]col = itertools.cycle(col_list)#c = col.next()#c = next(col)def paint(obj) :    c = next(col)    print(strv,c)    obj.color = c ## Selection of opacity / transparancy : opa_list = [1.0, 0.7, 0.5, 0.2]opa = itertools.cycle(opa_list)def solid(obj) :    o = next(opa)    print(strv,o)    obj.opacity = o ## Selection of materials: mName_list = [strv,              strv,              strv,              strv,              strv,              strv,              strv,              strv,              strv,              strv ]mat_list  = [ None,              materials.wood,              materials.rough,              materials.bricks,              materials.glass,              materials.earth,              materials.plastic,              materials.ice,              materials.diffuse,              materials.marble ]mName = itertools.cycle(mName_list)mat   = itertools.cycle(mat_list)def surface(obj) :    mM = next(mat)    mN = next(mName)    print(strv, mN)    obj.material = mM    obj.mat      = mN ## Selection for rotation-angle & axis : rotAng_list = [ 0.0, 0.005, 0.0, -0.005 ]rotDir_list = [ (1,0,0), (0,1,0), (0,0,1) ] rotAng = itertools.cycle(rotAng_list)rotDir = itertools.cycle(rotDir_list) rotAn = next(rotAng)     
rotAx = next(rotDir)     
 def rotAngle() :    global rotAn    rotAn = next(rotAng)    print(strv,rotAn) def rotAxis() :    global rotAx    rotAx = next(rotDir)    print(strv,rotAx) ## List of keypresses for demo: #demoC_list = [ strv ]demoCmd_list = strv+strv+strvdemoCmd = itertools.cycle(demoCmd_list)def demoStep() :    k = next(demoCmd)    print(strv,k)    cmd(k) #...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+... def objCount():    n=0    for obj in scene.objects:        n=n+1    return n def objInfo(obj) :    print( ""Object:"", obj )    print( strv,  obj.pos,   strv, obj.size )    print( strv, obj.axis,  strv,   obj.up )    print( strv, obj.color, obj.opacity )    print( strv,  obj.mat,   obj.material ) def sceneInfo(sc) :    print( ""Scene:"",  sc )    print( strv,   sc.width, strv, sc.height )    print( strv,   sc.range, strv, sc.scale )    print( strv,  sc.center )    
    print( strv, sc.forward, strv, sc.fov )    print( strv,    sc.mouse.camera, strv, sc.mouse.ray )    print( strv, sc.ambient )    print( strv,   sc.lights  )    
    print( strv, objCount(), scene.objects ) #...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+... scene.width  = 600scene.height = 400scene.range  = 4#scene.autocenter = True#scene.background = color.gray(0.2)scene.background = next(bg) autoDemo = -1 print( msg )  ## Create cuboid (aka strv) : 

##c  = box(pos =( 0.0, 0.0, 0.0 ),##         size=( 4, 2, 3 ),            # L,H,W##         axis=( 1.0, 0.0, 0.0 ),##         up  =( 0.0, 1.0, 0.0 ),##         color   = color.orange,##         opacity = 1.0,##         material= materials.marble##         )c  = box(pos =( 0.0, 0.0, 0.0 ),         size=( 4, 2, 3 ),            
         axis=( 1.0, 0.0, 0.0 ),         up  =( 0.0, 1.0, 0.0 )         )print(strv, c)paint(c)     
solid(c)     
surface(c)   
 rotX(c,0.4)         
rotY(c,0.6) #sceneInfo(scene)#objInfo(c)print(""Press 'a' to start auto-running demo."") #...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+...  ## Processing of input: cCount = 0def click():    global cCount    cCount=cCount+1    sceneInfo(scene)    objInfo(c)scene.bind( 'click', click ) def keyInput():    key = scene.kb.getkey()    print( 'Key: strv' % key )     if ( (key == 'esc') or (key == 'q') ) :        print( strv )        exit(0)    else :        cmd(key)scene.bind('keydown', keyInput) def cmd(key):    global autoDemo    if (key == 'h') :  print( msg )    if (key == '?') :  print( msg )    if (key == 's') :  sceneInfo(scene)    if (key == 'i') :  objInfo(c)     if (key == 'x') :  rotX(c, 0.1)    if (key == 'X') :  rotX(c,-0.1)    if (key == 'y') :  rotY(c, 0.1)    if (key == 'Y') :  rotY(c,-0.1)    if (key == 'z') :  rotZ(c, 0.1)    if (key == 'Z') :  rotZ(c,-0.1)     if (key == 'c') :  paint(c)    if (key == 'o') :  solid(c)    if (key == 'm') :  surface(c)     if (key == 'b') :  backgr()    if (key == 'r') :  rotAngle()    if (key == 'R') :  rotAxis()    if (key == 'd') :  demoStep()    if (key == 'a') :  autoDemo = -autoDemo    if (key == 'A') :  autoDemo = -autoDemo    if (key == ' ') :  stop() def stop() :    global autoDemo, rotAn    autoDemo = -1    while rotAn <> 0 :      rotAngle()     print(strv) r=100t=0while True:                 
    rate(50)    t = t+1    if rotAn != 0 :        c.rotate( angle=rotAn, axis=rotAx )     if t>=r :        t=0        if autoDemo>0 :            demoStep() "
"class List:    def __init__(self, data, next=None, prev=None):        self.data = data        self.next = next        self.prev = prev     def append(self, data):        if self.next == None:            self.next = List(data, None, self)            return self.next        else:            return self.next.append(data) 
tail = head = List(10)for i in [ 20, 30, 40 ]:    tail = tail.append(i) 
node = headwhile node != None:    print(node.data)    node = node.next 
node = tailwhile node != None:    print(node.data)    node = node.prevl = [ 10, 20, 30, 40 ]for i in l:    print(i)for i in reversed(l):    
    print(i)"
"import time def chunks(l, n=5):    return [l[i:i+n] for i in range(0, len(l), n)] def binary(n, digits=8):    n=int(n)    return '{0:0{1}b}'.format(n, digits) def secs(n):    n=int(n)    h='x' * n    return strv.join(chunks(h)) def bin_bit(h):    h=h.replace(strv,strv)    h=h.replace(strv,strv)    return strv.join(list(h))  x=str(time.ctime()).split()y=x[3].split(strv) s=y[-1]y=map(binary,y[:-1]) print bin_bit(y[0])printprint bin_bit(y[1])printprint secs(s)"
"def insert(anchor, new):    new.next = anchor.next    new.prev = anchor    anchor.next.prev = new    anchor.next = new"
"import math shades = ('.',':','!','*','o','e','&','#','%','@') def normalize(v):	len = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)	return (v[0]/len, v[1]/len, v[2]/len) def dot(x,y):	d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]	return -d if d < 0 else 0 def draw_sphere(r, k, ambient, light):	for i in range(int(math.floor(-r)),int(math.ceil(r)+1)):		x = i + 0.5		line = '' 		for j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):			y = j/2 + 0.5			if x*x + y*y <= r*r:				vec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))				b = dot(light,vec)**k + ambient				intensity = int((1-b)*(len(shades)-1))				line += shades[intensity] if 0 <= intensity < len(shades) else shades[0]			else:				line += ' ' 		print(line) light = normalize((30,30,-50))draw_sphere(20,4,0.1, light)draw_sphere(10,2,0.4, light) import pygamefrom pygame.locals import *import timeimport sysimport randomimport math  class Tricubic:    def __init__(self,pts):        self.coefficients = []        for plane in pts:            planecoeffs = []            for line in plane:                p = (line[3]-line[2])-(line[0]-line[1])                q = (line[0]-line[1])-p                r = line[2]-line[0]                s = line[1]                planecoeffs.append([p,q,r,s])            self.coefficients.append(planecoeff)    def Eval(at):        return Misc.Cubic([CoeffBicubic(coeffs[0],d),CoeffBicubic(coeffs[1],d),CoeffBicubic(coeffs[2],d),CoeffBicubic(coeffs[3],d)],d.z)    def CoeffCubic(coeffs,d):        return (coeffs[0]*(d.x**3))+(coeffs[1]*(d.x**2))+(coeffs[2]*d.x)+coeffs[3]    def CoeffBicubic(coeffs,d):        return Misc.Cubic([CoeffCubic(coeffs[0],d),CoeffCubic(coeffs[1],d),CoeffCubic(coeffs[2],d),CoeffCubic(coeffs[3],d)],d.y)class Misc:    def LinePara(line,t):        return Vector3.Add(line[0],Vector3.Scale(Vector3.Subtract(line[1],line[0]),t))    def LUR(at,above):        look = at.Unit()        right = Vector3.Cross(look,above).Unit()        up = Vector3.Scale(Vector3.Cross(look,right),-1)        return [look,up,right]    def LinePlane(line,triangle,cp=True):        try:            u = Vector3.Subtract(triangle.points[1].point,triangle.points[0])            v = Vector3.Subtract(triangle.points[2],triangle.points[0])            n = Vector3.Cross(u,v)            r = (Vector3.Dot(n,Vector3.Subtract(triangle.points[0],line.start))/Vector3.Dot(n,line.direction))            if stp:                point = Vector3.Add(Vector3.Scale(line.direction,r),line.start)                w = Vector3.Subtract(point,triangle.points[0])                udv = Vector3.Dot(u,v)                wdv = Vector3.Dot(w,v)                vdv = Vector3.Dot(v,v)                wdu = Vector3.Dot(w,u)                udu = Vector3.Dot(u,u)                denominator = (udv**2)-(udu*vdv)                s = ((udv*wdv)-(vdv*wdu))/denominator                t = ((udv*wdu)-(udu*wdv))/denominator                return [r,Vector2(s,t),point]                print('hooray')            else:                return [r]        except:            return None    def Cubic(pts,d):        p = (pts[3]-pts[2])-(pts[0]-pts[1])        q = (pts[0]-pts[1])-p        r = pts[2]-pts[0]        s = pts[1]        return (p*(d**3))+(q*(d**2))+(r*d)+s    def Bicubic(pts,d):        return Misc.Cubic([Misc.Cubic(pts[0],d.x),Misc.Cubic(pts[1],d.x),Misc.Cubic(pts[2],d.x),Misc.Cubic(pts[3],d.x)],d.y)    def Tricubic(pts,d):        return Misc.Cubic([Misc.Bicubic(pts[0],d),Misc.Bicubic(pts[1],d),Misc.Bicubic(pts[2],d),Misc.Bicubic(pts[3],d)],d.z)    def Quadcubic(pts,d):        return Misc.Cubic([Misc.Tricubic(pts[0],d),Misc.Tricubic(pts[1],d),Misc.Tricubic(pts[2],d),Misc.Tricubic(pts[3],d)],d.w)    def Linear(pts,d):        return (pts[2]*d)+(pts[1]*(1-d))    def Bilinear(pts,d):        return Misc.Linear([0,Misc.Linear(pts[1],d.x),Misc.Linear(pts[2],d.x)],d.y)    def Trilinear(pts,d):        return Misc.Linear([0,Misc.Bilinear(pts[1],d),Misc.Bilinear(pts[2],d)],d.z)    def LP2(line,triangle,cp=True):        try:            bla = triangle.points[1]            bla = triangle.points[0]            u = Vector3.Subtract(triangle.points[1].point,triangle.points[0].point)            v = Vector3.Subtract(triangle.points[2].point,triangle.points[0].point)            n = Vector3.Cross(u,v)            d = Vector3.Subtract(line[1],line[0])            r = (Vector3.Dot(n,Vector3.Subtract(triangle.points[0].point,line[0]))/Vector3.Dot(n,d))            if cp:                point = Vector3.Add(Vector3.Scale(d,r),line[0])                w = Vector3.Subtract(point,triangle.points[0].point)                udv = Vector3.Dot(u,v)                wdv = Vector3.Dot(w,v)                vdv = Vector3.Dot(v,v)                wdu = Vector3.Dot(w,u)                udu = Vector3.Dot(u,u)                denominator = (udv**2)-(udu*vdv)                s = ((udv*wdv)-(vdv*wdu))/denominator                t = ((udv*wdu)-(udu*wdv))/denominator                return (r,Vector2(s,t),point)            else:                return (r)        except:            return None    def Phong(normal,viewer,light,material,term):        
        
        n = normal.Unit()        v = viewer.Unit()        l = light[0].Unit()        ldn = Vector3.Dot(l,n)        #print(ldn)        val = 0        if ldn > 0:            val += material[1][term]*ldn*light[1][term]            rdv = Vector3.Dot(Vector3.Subtract(Vector3.Scale(n,2*ldn),l),v)            if rdv > 0:                val += (material[2][term]*(rdv**material[3])*light[2][term])        #print(val)        return val    def Lighting(ambient,normal,viewer,lights,material,term):        
        
        val = material[0][term]*ambient[term]        for light in lights:            val += Misc.Phong(normal,viewer,light,material,term)        return val    def Lighting2(start,direction,ambient,intersect,triangle,lights):        coord = intersect[1]        val = Color.Add(Color.Multiply(ambient,Color.Multiply(triangle.material.color['ambient'],triangle.Map('ambient',coord))),                        Color.Multiply(triangle.material.color['glow'],triangle.Map('glow',coord)))        for light in lights:            for n in range(3):                val[n] += Misc.Phong(triangle.InterpolatedNormal(coord),                                     Vector3.Scale(direction,-1),                                     (light.To(intersect[2]),light.Diffuse(intersect[2]),light.Specular(intersect[2])),                                     (Color(),                                      Color.Multiply(triangle.material.color['diffuse'],triangle.Map('diffuse',coord)),                                      Color.Multiply(triangle.material.color['specular'],triangle.Map('specular',coord)),                                      triangle.material.shiny),n)        return val    def Ray(start,direction,scene,color=True,sector=None):        intersect = None        intersected = None        col = None        for triangle in scene.triangles:            possible = True            if sector != None:                possible = False                for point in triangle.points:                    if not(point.sector.x < sector.x):                        possible = True                if possible:                    possible = False                    for point in triangle.points:                        if not(point.sector.x > sector.x):                            possible = True                if possible:                    possible = False                    for point in triangle.points:                        if not(point.sector.y < sector.y):                            possible = True                if possible:                    possible = False                    for point in triangle.points:                        if not(point.sector.y > sector.y):                            possible = True            possible = True            if possible:                tmp = Misc.LP2([start,Vector3.Add(start,direction)],triangle,color)                write = False                if type(tmp) == type(5.1):                    tmp = None                if (tmp != None):                    if (intersect == None):                        if (tmp[0] > 0) and (tmp[1].x >= 0) and (tmp[1].y >= 0) and (tmp[1].x+tmp[1].y <= 1):                            write = True                    elif (tmp[0] > 0) and (tmp[0] < intersect[0]) and (tmp[1].x >= 0) and (tmp[1].y >= 0) and (tmp[1].x+tmp[1].y <= 1):                        write = True                if write:                    intersect = tmp                    intersected = triangle        if color and (intersect != None):            applicable = []            for light in scene.lights:                block = Misc.Ray(intersect[2],light.To(intersect[2]),scene,False)                if block == None:                    applicable.append(light)                elif light.location != None:                    if Vector3.Subtract(light.location,intersect[2]).Magnitude() < block[0]:                        applicable.append(light)            col = Misc.Lighting2(start,direction,scene.ambient,intersect,intersected,applicable)            return (intersect,col)        else:            return intersectclass DirLight:    def __init__(self,direction,diffuse,specular):        self.location = None        self.direction = direction.Unit()        self.diffuse = diffuse        self.specular = specular    def To(self,frm):        return Vector3.Scale(self.direction,-1)    def Diffuse(self,to):        return self.diffuse    def Specular(self,to):        return self.specularclass Material:    def __init__(self):        self.color = {'ambient':Color(1,1,1),                      'diffuse':Color(1,1,1),                      'specular':Color(1,1,1),                      'glow':Color(1,1,1)}        self.maps = {'ambient':Map(),                     'diffuse':Map(),                     'specular':Map(),                     'glow':Map(),                     'bump':Map()}        self.shiny = 10class Map:    def __init__(self,surface=None):        self.surface = surface        if self.surface != None:            self.width = self.surface.get_width()            self.height = self.surface.get_height()    def __getitem__(self,index):        if self.surface == None:            return Color(1,1,1)        else:            try:                return Color.From255(self.surface.get_at((int(index.x*(self.width-1)),int(index.y*(self.height-1)))))            except:                return Color(0,0,1)class Color:    def __init__(self,r=0,g=0,b=0):        self.r = r        self.g = g        self.b = b    def __getitem__(self,index):        if index == 0:            return self.r        elif index == 1:            return self.g        elif index == 2:            return self.b    def __setitem__(self,index,value):        if index == 0:            self.r = value        elif index == 1:            self.g = value        elif index == 2:            self.b = value    def Multiply(A,B):        return Color(A.r*B.r,A.g*B.g,A.b*B.b)    def Add(A,B):        return Color(A.r+B.r,A.g+B.g,A.b+B.b)    def From255(A):        return Color(A.r/255,A.g/255,A.b/255)class Vertex:    def __init__(self,point,normal,maps):        self.bpoint = point        self.bnormal = normal        self.maps = maps        for name in ['ambient','diffuse','specular','glow','bump']:            try:                bla = self.maps[name]            except:                self.maps[name] = Vector2()        self.sector = None    def Transform(self,points,norms):        self.point = Matrix2.Multiply(self.bpoint.Horizontal(),points).Vectorize()        self.normal = Matrix2.Multiply(self.bnormal.Horizontal(),norms).Vectorize()class Triangle:    def __init__(self,vertices,material=Material()):        self.points = vertices        self.material = material    def Map(self,name,coord):        pts = []        for n in range(3):            pts.append(self.points[n].maps[name])        loc = Vector2.Add(pts[0],                          Vector2.Add(Vector2.Scale(Vector2.Subtract(pts[1],pts[0]),coord.x),                                      Vector2.Scale(Vector2.Subtract(pts[2],pts[0]),coord.y)))        #print(loc.x,loc.y)        return self.material.maps[name][loc]    def InterpolatedNormal(self,coord):        return Vector3.Add(Vector3.Scale(self.points[0].normal,1-coord.x-coord.y),                           Vector3.Add(Vector3.Scale(self.points[1].normal,coord.x),Vector3.Scale(self.points[2].normal,coord.y))).Unit()class Line:    def __init__(self,A,B=None,direction=None):        self.start = A        if B != None:            self.direction = Vector3.Subtract(B,A).Unit()        elif direction != None:            self.direction = direction        else:            raise RuntimeError('Neither B nor direction are specified')class Scene:    def __init__(self):        self.triangles = []        self.vertices = []        self.lights = []        self.exterior = []        self.ambient = 0class Matrix2:    def __init__(self,data=[[]]):        self.FromData(data)    def __getitem__(self,index):        return self.data[index[1]][index[0]]    def __setitem__(self,index,value):        self.data[index[1]][index[0]]=value    def Dimension(self):        self.rows = len(self.data)        self.cols = len(self.data[0])    def FromData(self,data):        self.data = data        length=len(data[0])        for row in data:            if len(row)!=length:                self.data=None                raise RuntimeError('Data rows are not of uniform length.')        self.Dimension()    def Multiply(A,B):        if A.cols!=B.rows:            raise RuntimeError('Column count of Matrix2 A does not match row count of Matrix2 B.')        matrix = Matrix2.Empty(B.cols,A.rows)        x=0        while x<matrix.cols:            y=0            while y<matrix.rows:                val=0                n=0                while n<A.cols:                    val+=A[(n,y)]*B[(x,n)]                    n+=1                matrix[(x,y)]=val                y+=1            x+=1        return matrix    def Scalar(A,n):        pass    def Empty(rows,cols):        data = []        row = [0]*rows        n = 0        while n < cols:            data.append(row[:])            n+=1        matrix=Matrix2(data)        matrix.Dimension()        return matrix    def Identity(cols):        matrix = Matrix2.Empty(cols,cols)        n = 0        while n < cols:            matrix[(n,n)]=1            n += 1        return matrix    def Vectorize(self):        if self.cols==1:            if self.rows!=4:                raise RuntimeError('Only 1 by 4 or 4 by 1 Matrix2s can be cast to Vector3s.')            vertical=True        elif self.rows==1:            if self.cols!=4:                raise RuntimeError('Only 1 by 4 or 4 by 1 Matrix2s can be cast to Vector3s.')            vertical = False        else:            raise RuntimeError('Only 1 by 4 or 4 by 1 Matrix2s can be cast to Vector3s.')        vector=[0]*4        n=0        while n<4:            if vertical:                vector[n]=self[(0,n)]            else:                vector[n]=self[(n,0)]            n+=1        return Vector3(vector[0],vector[1],vector[2],vector[3])    def Print(self,decimals,spaces):        length=0        for row in self.data:            for val in row:                string=str(round(val,decimals))                if length<len(string):                    length=len(string)        text=''        for row in self.data:            temp=''            for value in row:                val=str(round(float(value),decimals))                pads=length-len(val)                pad=int(pads/2)                temp+=(' '*pad)+val+(' '*(pads-pad))+(' '*spaces)            text+=(' '*spaces)+temp[0:len(temp)-1]+(' '*spaces)+''        return(text[0:len(text)-1])    def RotX(angle):        return Matrix2([            [1,0,0,0],            [0,math.cos(angle),0-math.sin(angle),0],            [0,math.sin(angle),math.cos(angle),0],            [0,0,0,1]])    def RotY(angle):        return Matrix2([            [math.cos(angle),0,0-math.sin(angle),0],            [0,1,0,0],            [math.sin(angle),0,math.cos(angle),0],            [0,0,0,1]])    def RotZ(angle):        return Matrix2([            [math.cos(angle),0-math.sin(angle),0,0],            [math.sin(angle),math.cos(angle),0,0],            [0,0,1,0],            [0,0,0,1]])    def Translate(vector):        return Matrix2([            [1,0,0,0],            [0,1,0,0],            [0,0,1,0],            [vector.x,vector.y,vector.z,1]])    def Scale(vector):        return Matrix2([            [vector.x,0,0,0],            [0,vector.y,0,0],            [0,0,vector.z,0],            [0,0,0,1]])    def Clone(self):        data = []        for row in self.data:            data.append(row[:])        return Matrix2(data)    def Inverse(self):        adjoint = self.Adjoint()        det = self.Determinant()        if det == 0:            raise RuntimeError('Cannot find the inverse of a matrix with a determinant of 0')        inverse = Matrix2.Empty(self.rows,self.cols)        x = 0        while x < self.cols:            y = 0            while y < self.rows:                inverse[(x,y)] = adjoint[(x,y)]/det                y += 1            x += 1        return inverse    def Transpose(self):        transpose = Matrix2.Empty(self.cols,self.rows)        x = 0        while x < self.cols:            y = 0            while y < self.rows:                transpose[(y,x)] = self[(x,y)]                y += 1            x += 1        return transpose    def Adjoint(self):        return self.Cofactors().Transpose()    def Determinant(self):        if self.rows != self.cols:            raise RuntimeError('Cannot find the determinant of a non-square matrix')        if self.rows == 1:            return self[(0,0)]        cofactors = self.Cofactors()        determinant = 0        n = 0        while n < self.cols:            determinant += self[(n,0)]*cofactors[(n,0)]            n += 1        return determinant    def Minors(self):        if self.rows != self.cols:            raise RuntimeError('Cannot find the minors of a non-square matrix')        if self.rows == 1:            raise RuntimeError('Cannot find the minors of a 1 by 1 matrix')        minors = Matrix2.Empty(self.rows,self.cols)        lines = range(self.rows)        x = 0        while x < self.cols:            y = 0            while y < self.cols:                tiny = Matrix2.Empty(self.rows-1,self.cols-1)                ox = 0                nx = 0                while ox < self.cols:                    oy = 0                    ny = 0                    while oy < self.cols:                        if not((ox == x) or (oy == y)):                            tiny[(nx,ny)] = self[(ox,oy)]                        if oy != y:                            ny += 1                        oy += 1                    if ox != x:                        nx += 1                    ox += 1                minors[(x,y)] = tiny.Determinant()                y += 1            x += 1        return minors    def Cofactors(self):        minors = self.Minors()        cofactors = Matrix2.Empty(self.rows,self.cols)        x = 0        while x < self.cols:            y = 0            while y < self.rows:                if int((x+y)/2) == ((x+y)/2):                    cofactors[(x,y)] = minors[(x,y)]                else:                    cofactors[(x,y)] = -1*minors[(x,y)]                y += 1            x += 1        return cofactors    def Perspective(e):        return Matrix2([            [1,0,0,0],            [0,1,0,0],            [0,0,1,1/e[2]],            [-e[0],-e[1],0,0]])    def Add(A,B):        if A.rows != B.rows:            RuntimeError('The row counts of Matrix A and Matrix B are not identical.')        if A.cols != B.cols:            RuntimeError('The column counts of Matrix A and Matrix B are not identical.')        matrix = Matrix.Empty(A.rows,A.cols)        for x in range(A.cols):            for y in range(A.rows):                matrix[(x,y)] = A[(x,y)]+B[(x,y)]        return matrix    def Subtract(A,B):        if A.rows != B.rows:            RuntimeError('The row counts of Matrix A and Matrix B are not identical.')        if A.cols != B.cols:            RuntimeError('The column counts of Matrix A and Matrix B are not identical.')        matrix = Matrix.Empty(A.rows,A.cols)        for x in range(A.cols):            for y in range(A.rows):                matrix[(x,y)] = A[(x,y)]+B[(x,y)]        return matrix    def DivHomogeneous(self):        if (self.cols,self.rows) == (1,4):            for y in range(3):                self[(0,y)] = self[(0,y)]/self[(0,3)]            self[(0,3)] = 1        if (self.cols,self.rows) == (4,1):            for x in range(3):                self[(x,0)] = self[(x,0)]/self[(3,0)]            self[(3,0)] = 1        else:            raise RuntimeError('1 by 4 or 4 by 1 Matrix2 expected')    def Object(pos,look,up,right):        return Matrix2([            [right.x,right.y,right.z,0],            [up.x,up.y,up.z,0],            [look.x,look.y,look.z,0],            [pos.x,pos.y,pos.z,1]])    def Camera(eye,look,up,right):        return Matrix2([            [right.x,up.x,look.x,0],            [right.y,up.y,look.y,0],            [right.z,up.z,look.z,0],            [-Vector3.Dot(eye,right),             -Vector3.Dot(eye,up),             -Vector3.Dot(eye,look),1]])    def YPR(rot):        return Matrix2.Multiply(            Matrix2.Multiply(Matrix2.RotZ(rot.z),                             Matrix2.RotX(rot.x)),            Matrix2.RotY(rot.y))class Vector2:    def __init__(self,data=0,y=0):        if (type(data) == type(5)) or (type(data) == type(5.1)):            self.x = data            self.y = y        else:            self.x = data[0]            self.y = data[1]    def __getitem__(self,index):        if index == 0:            return self.x        elif index == 1:            return self.y    def __setitem__(self,index,value):        if index == 0:            self.x = value        elif index == 1:            self.y = 1    def Add(A,B):        return Vector2(A.x+B.x,A.y+B.y)    def Subtract(A,B):        return Vector2(A.x-B.x,A.y-B.y)    def Scale(A,n):        return Vector2(A.x*n,A.y*n)    def Magnitude(self):        return ((self.x**2)+(self.y**2))**.5    def Unit(self):        return Vector2.Scale(self,1/self.Magnitude())    def Clone(self):        return Vector2(self.x,self.y)class Vector3:    def __init__(self,data=0,y=0,z=0,w=1):        if (type(data) == type(5)) or (type(data) == type(5.1)):            self.x = data/w            self.y = y/w            self.z = z/w        else:            try:                temp = data[3]            except:                temp = 1            self.x = data[0]/temp            self.y = data[1]/temp            self.z = data[2]/temp    def __getitem__(self,index):        if index == 0:            return self.x        elif index == 1:            return self.y        elif index == 2:            return self.z    def __setitem__(self,index,value):        if index == 0:            self.x = value        elif index == 1:            self.y = value        elif index == 2:            self.z = value    def Vertical(self):        return Matrix2([[self.x],[self.y],[self.z],[1]])    def Horizontal(self):        return Matrix2([[self.x,self.y,self.z,1]])    def Dot(A,B):        return (A.x*B.x)+(A.y*B.y)+(A.z*B.z)    def Cross(A,B):        return Vector3([            (A.y*B.z)-(A.z*B.y),            (A.z*B.x)-(A.x*B.z),            (A.x*B.y)-(A.y*B.x)])    def Add(A,B):        return Vector3(A.x+B.x,A.y+B.y,A.z+B.z)    def Subtract(A,B):        return Vector3(A.x-B.x,A.y-B.y,A.z-B.z)    def Scale(A,n):        return Vector3(A.x*n,A.y*n,A.z*n)    def Magnitude(self):        return ((self.x**2)+(self.y**2)+(self.z**2))**.5    def Print(self,decimals,spaces):        return self.Horizontal().Print(decimals,spaces)    def Same(A,B):        same = False        if A.x == B.x:            if A.y == B.y:                if A.z == B.z:                    same = True        return same    def Unit(self):        return Vector3.Scale(self,1/self.Magnitude())    def Clone(self):        return Vector3(self.x,self.y,self.z)class Vector4:    def __init__(self,data=0,y=0,z=0,w=0):        if (type(data) == type(5)) or (type(data) == type(5.1)):            self.x = data            self.y = y            self.z = z            self.w = w        else:            self.x = data[0]            self.y = data[0]            self.z = data[0]            self.w = data[0] points = [Vector3([-1,-1,0]),Vector3([1,-1,0]),Vector3([0,1,0])]width = 255height = widthscreen = pygame.display.set_mode((width,height),0,32)scl = 2pos =  Vector3([0,0,5])view = Vector3([0,0,1])frames = 0 def Transform(point,mat):   return Matrix2.Multiply(point.Horizontal(),mat).Vectorize() def RV():   return Vector3([random.random(),random.random(),random.random()]) green = pygame.Color(0,255,0)def XY(bla):   return (((width*bla[0])+width)/2,((height*bla[1])+width)/2) screen.fill(pygame.Color(0,0,0))size = 255 world = Matrix2.Identity(4)inv = world.Inverse()invt = world.Inverse().Transpose()center = Vector3(0,0,2)  def Texture(size):   texture = []   for pa in range(size):      plane = []      for pb in range(size):         line = []         for pc in range(size):            line.append(random.random())         plane.append(line)      texture.append(plane)   return texture lights = [(Vector3(-10,6,-9),[.7,.7*.9,.7*.8],[.7,.7*.9,.9*.8])]lights = [(Vector3(-10,6,-9),[.8,.8,.8],[.7,.7,.7])] depth = 3groups = []for n in range(1):     textures = []   for n in range(depth):      textures.append(Texture(4**(n+1)))   groups.append(textures) def Select(texture,at):   sel = []   for pa in range(4):      aplane = texture[pa+math.floor(at.z)]      bplane = []      for pb in range(4):         aline = aplane[pb+math.floor(at.y)]         bline = []         for pc in range(4):            bline.append(aline[pc+math.floor(at.x)])         bplane.append(bline)      sel.append(bplane)   return (sel,Vector3(at.x%1,at.y%1,at.z%1))def Round(val):   return val-(val-math.floor(val)) theta = math.tan(70*math.pi/360)for x in range(width):   for event in pygame.event.get():      if event.type == QUIT:         pygame.quit()         sys.exit()      if event.type == KEYDOWN:         pass   for y in range(height):      l = Vector3(theta*2*((x/width)-.5),theta*2*((y/width)-.5),1).Unit()      ldc = Vector3.Dot(l,center)       d = ldc-(((ldc**2)-Vector3.Dot(center,center)+1)**.5)      if type(d) != type((-1)**.5):         intersection = Vector3.Scale(l,d)         normal = Vector3.Subtract(intersection,center).Unit()         point = Transform(normal,world)          s = Vector3.Scale(Vector3.Add(point,Vector3(1,1,1)),.5)         val = 0         for i in range(depth):            sel = Select(groups[0][i],Vector3.Scale(s,4**i))            val += Misc.Tricubic(sel[0],sel[1])*((1/2)**i)/4          val = (25*val)%1         vals = [0,Misc.Linear([0,.3,1],val),1]          coloring = []         for i in range(3):            #light = Misc.Lighting([1,1,1],normal,Vector3.Scale(intersection,-1),lights,([0,.03*val,.03],[0,.7*val,.7],[.3,.3,.3],7),i)            light = Misc.Lighting([.1,.1,.1],normal,Vector3.Scale(intersection,-1),lights,(vals,vals,[1,1,1],10),i)            if light > 1:               light = 1            elif light < 0:               light = 0            coloring.append(round(255*light))         screen.set_at((x,height-y),pygame.Color(coloring[0],coloring[1],coloring[2]))   pygame.display.update()pygame.image.save(screen,strv)while True:   for event in pygame.event.get():      if event.type == QUIT:         pygame.quit()         sys.exit()      if event.type == KEYDOWN:         pass from visual import *scene.title = strvsphere()    
 from __future__ import print_function, divisionfrom visual import * title = strvscene.title = titleprint( ""%s"" % title ) print( 'Drag with right mousebutton to rotate view'  )print( 'Drag up+down with middle mousebutton to zoom') scene.autocenter = True 
S1 = sphere(pos=(0.0, 0.0, 0.0), radius=1.0, color=color.blue)#S2 = sphere(pos=(2.0, 0.0, 0.0), radius=1.0, material=materials.earth)#S3 = sphere(pos=(0.0, 2.0, 0.0), radius=1.0, material=materials.BlueMarble)#S4 = sphere(pos=(0.0, 0.0, 2.0), radius=1.0,
 while True:                 
    rate(100)    pass                    
 "
"from turtle import * def dragon(step, length):    dcr(step, length) def dcr(step, length):    step -= 1    length /= 1.41421    if step > 0:        right(45)        dcr(step, length)        left(90)        dcl(step, length)        right(45)    else:        right(45)        forward(length)        left(90)        forward(length)        right(45) def dcl(step, length):    step -= 1    length /= 1.41421     if step > 0:        left(45)        dcr(step, length)        right(90)        dcl(step, length)        left(45)    else:        left(45)        forward(length)        right(90)        forward(length)        left(45)from turtle import right, left, forward, speed, exitonclick, hideturtle def dragon(level=4, size=200, zig=right, zag=left):    if level <= 0:        forward(size)        return     size /= 1.41421    zig(45)    dragon(level-1, size, right, left)    zag(90)    dragon(level-1, size, left, right)    zig(45) speed(0)hideturtle()dragon(6)exitonclick() 
from turtle import right, left, forward, speed, exitonclick, hideturtle def dragon(level=4, size=200, direction=45):    if level:        right(direction)        dragon(level-1, size/1.41421356237, 45)        left(direction * 2)        dragon(level-1, size/1.41421356237, -45)        right(direction)    else:        forward(size) speed(0)hideturtle()dragon(6)exitonclick() 
"
"class Node(object):     def __init__(self, data = None, prev = None, next = None):         self.prev = prev         self.next = next         self.data = data     def __str__(self):         return str(self.data)     def __repr__(self):         return repr(self.data)     def iter_forward(self):         c = self         while c != None:             yield c             c = c.next     def iter_backward(self):         c = self         while c != None:             yield c             c = c.prev"
"class Doc(object):   strv
   This is a class docstring. Traditionally triple-quoted strings are used because
   they can span multiple lines and you can include quotation marks without escaping.
   strv   def method(self, num):      strv      pass>>> def somefunction():	strv  >>> help(somefunction)Help on function somefunction in module __main__: somefunction()    takes no args and returns None after doing not a lot >>>"
"def dotp(a,b):    assert len(a) == len(b), 'Vector sizes must match'    return sum(aterm * bterm for aterm,bterm in zip(a, b)) if __name__ == '__main__':    a, b = [1, 3, -5], [4, -2, -1]    assert dotp(a,b) == 3def (dot_product x y)  (sum+map (*) x y)"
">>> import socket>>> ips = set(i[4][0] for i in socket.getaddrinfo('www.kame.net', 80))>>> for ip in ips: print ip...2001:200:dff:fff1:216:3eff:feb1:44d7203.178.141.194"
" def linear(x):    return ' + '.join(['{}e({})'.format('-' if v == -1 else '' if v == 1 else str(v) + '*', i + 1)        for i, v in enumerate(x) if v] or ['0']).replace(' + -', ' - ') list(map(lambda x: print(linear(x)), [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0],        [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, 3], [-1]])) "
"#!/usr/bin/env python
 import SimpleXMLRPCServer class MyHandlerInstance:    def echo(self, data):        '''Method for returning data got from client'''        return 'Server responded: %s' % data     def div(self, num1, num2):        '''Method for divide 2 numbers'''        return num1/num2 def foo_function():    '''A function (not an instance method)'''    return True HOST = strvPORT = 8000 server = SimpleXMLRPCServer.SimpleXMLRPCServer((HOST, PORT)) 
server.register_introspection_functions() 
server.register_instance(MyHandlerInstance()) 
server.register_function(foo_function) try:    
    server.serve_forever()except KeyboardInterrupt:    print 'Exiting...'    server.server_close()#!/usr/bin/env python
 import xmlrpclib HOST = strvPORT = 8000 rpc = xmlrpclib.ServerProxy(strv % (HOST, PORT)) 
print 'Server supports these functions:',print ' '.join(rpc.system.listMethods()) 
rpc.echo(strv) 
print 'Server says: 8 / 4 is: %d' % rpc.div(8, 4) 
if rpc.foo_function():    print 'Server says: foo_function returned True'#!/usr/bin/python
 import BaseHTTPServer HOST = strvPORT = 8000 

class MyHTTPHandler(BaseHTTPServer.BaseHTTPRequestHandler):    def do_GET(self):        
        self.send_response(200)        
        self.send_header(strv, strv)        self.end_headers()         
        self.wfile.write(strv)        self.wfile.write(strv % self.path)        self.wfile.write(strv) if __name__ == '__main__':    server = BaseHTTPServer.HTTPServer((HOST, PORT), MyHTTPHandler)    try:        server.serve_forever()    except KeyboardInterrupt:        print 'Exiting...'        server.server_close()#!/usr/bin/python
 import httplib HOST = strvPORT = 8000 conn = httplib.HTTPConnection(HOST, PORT)conn.request(strv, strv) response = conn.getresponse()print 'Server Status: %d' % response.status print 'Server Message: %s' % response.read()#!/usr/bin/python
 import SocketServerimport pickle HOST = strvPORT = 8000 class RPCServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):    
    
    
     daemon_threads = True class RPCHandler(SocketServer.StreamRequestHandler):    def handle(self):        in_channel = pickle.Unpickler(self.rfile)        out_channel = pickle.Pickler(self.wfile, protocol=2)        while True:            try:                name, args, kwargs = in_channel.load()                print 'got %s %s %s' % (name, args, kwargs)            except EOFError:                
                
                
                break            try:                method = getattr(self.server.object_to_proxy, name)                result = method(*args, **kwargs)            except Exception, e:                out_channel.dump(('Error',e))            else:                out_channel.dump(('OK',result)) class MyHandlerInstance(object):    def echo(self, data):        '''Method for returning data got from client'''        return 'Server responded: %s' % data     def div(self, dividend, divisor):        '''Method to divide 2 numbers'''        return dividend/divisor     def is_computer_on(self):        return True if __name__ == '__main__':    rpcserver = RPCServer((HOST, PORT), RPCHandler)    rpcserver.object_to_proxy = MyHandlerInstance()    try:        rpcserver.serve_forever()    except KeyboardInterrupt:        print 'Exiting...'        rpcserver.server_close() #!/usr/bin/python
 import socketimport pickle HOST = strvPORT = 8000 class RPCClient(object):    def __init__(self, host, port):        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.socket.connect((host, port))        self.rfile = self.socket.makefile('rb')        self.wfile = self.socket.makefile('wb')        self.in_channel = pickle.Unpickler(self.rfile)        self.out_channel = pickle.Pickler(self.wfile, protocol=2)     def _close(self):        self.socket.close()        self.rfile.close()        self.wfile.close()     
    
    
    def __getattr__(self, name):        def proxy(*args, **kwargs):            self.out_channel.dump((name, args, kwargs))            self.wfile.flush() 
            status, result = self.in_channel.load()            if status == 'OK':                return result            else:                raise result         return proxy if __name__ == '__main__':    
    rpcclient = RPCClient(HOST, PORT)     print 'Testing the echo() method:'    print rpcclient.echo('Hello world!')    print    print 'Calculating 42/2 on the remote machine:'    print rpcclient.div(42, 2)    print    print 'is_computer_on on the remote machine returns:'    print rpcclient.is_computer_on()    print    print 'Testing keyword args:'    print '42/2 is:', rpcclient.div(divisor=2, dividend=42)    rpcclient._close()    del rpcclient#!/usr/bin/python
 import Pyro.coreimport Pyro.naming 
class StringInstance(Pyro.core.ObjBase):    def makeUpper(self, data):        return data.upper() class MathInstance(Pyro.core.ObjBase):    def div(self, num1, num2):        return num1/num2 if __name__ == '__main__':    server = Pyro.core.Daemon()    name_server = Pyro.naming.NameServerLocator().getNS()    server.useNameServer(name_server)    server.connect(StringInstance(), 'string')    server.connect(MathInstance(), 'math')    try:        server.requestLoop()    except KeyboardInterrupt:        print 'Exiting...'        server.shutdown()#!/usr/bin/python
 import Pyro.core DATA = strvNUM1 = 10NUM2 = 5 string = Pyro.core.getProxyForURI(strv)math = Pyro.core.getProxyForURI(strv) print 'We sent: %s' % DATAprint 'Server responded: %s' % string.makeUpper(DATA) print 'We sent two numbers to divide: %d and %d' % (NUM1, NUM2)print 'Server responded the result: %s' % math.div(NUM1, NUM2)#!/usr/bin/python
 import spread PORT = '4803' 
conn = spread.connect(PORT)
conn.join('test') print 'Waiting for messages... If you want to stop this script, please stop spread daemon'while True:    recv = conn.receive()    if hasattr(recv, 'sender') and hasattr(recv, 'message'):        print 'Sender: %s' % recv.sender        print 'Message: %s' % recv.message#!/usr/bin/python
 import spread PORT = '4803' conn = spread.connect(PORT)conn.join('test') conn.multicast(spread.RELIABLE_MESS, 'test', 'hello, this is message sent from python')conn.disconnect()"
"import threadingimport randomimport time 
#





 class Philosopher(threading.Thread):     running = True     def __init__(self, xname, forkOnLeft, forkOnRight):        threading.Thread.__init__(self)        self.name = xname        self.forkOnLeft = forkOnLeft        self.forkOnRight = forkOnRight     def run(self):        while(self.running):            
            time.sleep( random.uniform(3,13))            print '%s is hungry.' % self.name            self.dine()     def dine(self):        fork1, fork2 = self.forkOnLeft, self.forkOnRight         while self.running:            fork1.acquire(True)            locked = fork2.acquire(False)            if locked: break            fork1.release()            print '%s swaps forks' % self.name            fork1, fork2 = fork2, fork1        else:            return         self.dining()        fork2.release()        fork1.release()     def dining(self):			        print '%s starts eating '% self.name        time.sleep(random.uniform(1,10))        print '%s finishes eating and leaves to think.' % self.name def DiningPhilosophers():    forks = [threading.Lock() for n in range(5)]    philosopherNames = ('Aristotle','Kant','Buddha','Marx', 'Russel')     philosophers= [Philosopher(philosopherNames[i], forks[i%5], forks[(i+1)%5]) \            for i in range(5)]     random.seed(507129)    Philosopher.running = True    for p in philosophers: p.start()    time.sleep(100)    Philosopher.running = False    print (strv) DiningPhilosophers()"
"try:    from functools import reduceexcept:    pass def mdroot(n):    'Multiplicative digital root'    mdr = [n]    while mdr[-1] > 9:        mdr.append(reduce(int.__mul__, (int(dig) for dig in str(mdr[-1])), 1))    return len(mdr) - 1, mdr[-1] if __name__ == '__main__':    print('Number: (MP, MDR)======  =========')    for n in (123321, 7739, 893, 899998):        print('%6i: %r' % (n, mdroot(n)))     table, n = {i: [] for i in range(10)}, 0    while min(len(row) for row in table.values()) < 5:        mpersistence, mdr = mdroot(n)        table[mdr].append(n)        n += 1    print('MP: [n0..n4]==  ========')    for mp, val in sorted(table.items()):        print('%2i: %r' % (mp, val[:5]))def mdroot(n):    count, mdr = 0, n     while mdr > 9:        m, digitsMul = mdr, 1        while m:            m, md = divmod(m, 10)            digitsMul *= md        mdr = digitsMul        count += 1    return count, mdr"
"from collections import namedtuple, dequefrom pprint import pprint as pp  inf = float('inf')Edge = namedtuple('Edge', 'start, end, cost') class Graph():    def __init__(self, edges):        self.edges = edges2 = [Edge(*edge) for edge in edges]        self.vertices = set(sum(([e.start, e.end] for e in edges2), []))     def dijkstra(self, source, dest):        assert source in self.vertices        dist = {vertex: inf for vertex in self.vertices}        previous = {vertex: None for vertex in self.vertices}        dist[source] = 0        q = self.vertices.copy()        neighbours = {vertex: set() for vertex in self.vertices}        for start, end, cost in self.edges:            neighbours[start].add((end, cost))        #pp(neighbours)         while q:            u = min(q, key=lambda vertex: dist[vertex])            q.remove(u)            if dist[u] == inf or u == dest:                break            for v, cost in neighbours[u]:                alt = dist[u] + cost                if alt < dist[v]:                                  
                    dist[v] = alt                    previous[v] = u        #pp(previous)        s, u = deque(), dest        while previous[u]:            s.appendleft(u)            u = previous[u]        s.appendleft(u)        return s  graph = Graph([(strv, strv, 7),  (strv, strv, 9),  (strv, strv, 14), (strv, strv, 10),               (strv, strv, 15), (strv, strv, 11), (strv, strv, 2),  (strv, strv, 6),               (strv, strv, 9)])pp(graph.dijkstra(strv, strv))"
"import datetime, calendar DISCORDIAN_SEASONS = [strv, strv, strv, strv, strv] def ddate(year, month, day):    today = datetime.date(year, month, day)    is_leap_year = calendar.isleap(year)    if is_leap_year and month == 2 and day == 29:        return strv + (year + 1166)     day_of_year = today.timetuple().tm_yday - 1     if is_leap_year and day_of_year >= 60:        day_of_year -= 1 
     season, dday = divmod(day_of_year, 73)    return strv % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166) "
"from itertools import product def gen_dict(n_faces, n_dice):    counts = [0] * ((n_faces + 1) * n_dice)    for t in product(range(1, n_faces + 1), repeat=n_dice):        counts[sum(t)] += 1    return counts, n_faces ** n_dice def beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):    c1, p1 = gen_dict(n_sides1, n_dice1)    c2, p2 = gen_dict(n_sides2, n_dice2)    p12 = float(p1 * p2)     return sum(p[1] * q[1] / p12               for p, q in product(enumerate(c1), enumerate(c2))               if p[0] > q[0]) print beating_probability(4, 9, 6, 6)print beating_probability(10, 5, 7, 6)from __future__ import print_function, division def combos(sides, n):    if not n: return [1]    ret = [0] * (max(sides)*n + 1)    for i,v in enumerate(combos(sides, n - 1)):        if not v: continue        for s in sides: ret[i + s] += v    return ret def winning(sides1, n1, sides2, n2):    p1, p2 = combos(sides1, n1), combos(sides2, n2)    win,loss,tie = 0,0,0 
    for i,x1 in enumerate(p1):        
        win += x1*sum(p2[:i])        tie += x1*sum(p2[i:i+1])        loss+= x1*sum(p2[i+1:])    s = sum(p1)*sum(p2)    return win/s, tie/s, loss/s print(winning(range(1,5), 9, range(1,7), 6))print(winning(range(1,11), 5, range(1,8), 6)) 
 

from __future__ import division, print_functionfrom itertools import accumulate 
 def combos(sides, n):    ret = [1] + [0]*(n + 1)*sides 
    for p in range(1, n + 1):        rolling_sum = 0        for i in range(p*sides, p - 1, -1):            rolling_sum += ret[i - sides] - ret[i]            ret[i] = rolling_sum        ret[p - 1] = 0    return ret def winning(d1, n1, d2, n2):    c1, c2 = combos(d1, n1), combos(d2, n2)    ac = list(accumulate(c2 + [0]*(len(c1) - len(c2))))     return sum(v*a for  v,a in zip(c1[1:], ac)) / (ac[-1]*sum(c1))  print(winning(4, 9, 6, 6))print(winning(5, 10, 6, 7)) #print(winning(6, 700, 8, 540))"
"def digital_root (n):    ap = 0    n = abs(int(n))    while n >= 10:        n = sum(int(digit) for digit in str(n))        ap += 1    return ap, n if __name__ == '__main__':    for n in [627615, 39390, 588225, 393900588225, 55]:        persistance, root = digital_root(n)        print(strv               % (n, persistance, root))"
"from __future__ import print_functionimport numpy as np def CheckTriWinding(tri, allowReversed):	trisq = np.ones((3,3))	trisq[:,0:2] = np.array(tri)	detTri = np.linalg.det(trisq)	if detTri < 0.0:		if allowReversed:			a = trisq[2,:].copy()			trisq[2,:] = trisq[1,:]			trisq[1,:] = a		else: raise ValueError(strv)	return trisq def TriTri2D(t1, t2, eps = 0.0, allowReversed = False, onBoundary = True):	#Trangles must be expressed anti-clockwise	t1s = CheckTriWinding(t1, allowReversed)	t2s = CheckTriWinding(t2, allowReversed) 	if onBoundary:		#Points on the boundary are considered as colliding		chkEdge = lambda x: np.linalg.det(x) < eps	else:		#Points on the boundary are not considered as colliding		chkEdge = lambda x: np.linalg.det(x) <= eps 	#For edge E of trangle 1,	for i in range(3):		edge = np.roll(t1s, i, axis=0)[:2,:] 		#Check all points of trangle 2 lay on the external side of the edge E. If		#they do, the triangles do not collide.		if (chkEdge(np.vstack((edge, t2s[0]))) and			chkEdge(np.vstack((edge, t2s[1]))) and  			chkEdge(np.vstack((edge, t2s[2])))):			return False 	#For edge E of trangle 2,	for i in range(3):		edge = np.roll(t2s, i, axis=0)[:2,:] 		#Check all points of trangle 1 lay on the external side of the edge E. If		#they do, the triangles do not collide.		if (chkEdge(np.vstack((edge, t1s[0]))) and			chkEdge(np.vstack((edge, t1s[1]))) and  			chkEdge(np.vstack((edge, t1s[2])))):			return False 	#The triangles collide	return True if __name__==strv:	t1 = [[0,0],[5,0],[0,5]]	t2 = [[0,0],[5,0],[0,6]]	print (TriTri2D(t1, t2), True) 	t1 = [[0,0],[0,5],[5,0]]	t2 = [[0,0],[0,6],[5,0]]	print (TriTri2D(t1, t2, allowReversed = True), True) 	t1 = [[0,0],[5,0],[0,5]]	t2 = [[-10,0],[-5,0],[-1,6]]	print (TriTri2D(t1, t2), False) 	t1 = [[0,0],[5,0],[2.5,5]]	t2 = [[0,4],[2.5,-1],[5,4]]	print (TriTri2D(t1, t2), True) 	t1 = [[0,0],[1,1],[0,2]]	t2 = [[2,1],[3,0],[3,2]]	print (TriTri2D(t1, t2), False) 	t1 = [[0,0],[1,1],[0,2]]	t2 = [[2,1],[3,-2],[3,4]]	print (TriTri2D(t1, t2), False) 	#Barely touching	t1 = [[0,0],[1,0],[0,1]]	t2 = [[1,0],[2,0],[1,1]]	print (TriTri2D(t1, t2, onBoundary = True), True) 	#Barely touching	t1 = [[0,0],[1,0],[0,1]]	t2 = [[1,0],[2,0],[1,1]]	print (TriTri2D(t1, t2, onBoundary = False), False)from __future__ import print_functionfrom shapely.geometry import Polygon def PolyOverlaps(poly1, poly2):	poly1s = Polygon(poly1)	poly2s = Polygon(poly2)	return poly1s.intersects(poly2s) if __name__==strv:	t1 = [[0,0],[5,0],[0,5]]	t2 = [[0,0],[5,0],[0,6]]	print (PolyOverlaps(t1, t2), True) 	t1 = [[0,0],[0,5],[5,0]]	t2 = [[0,0],[0,6],[5,0]]	print (PolyOverlaps(t1, t2), True) 	t1 = [[0,0],[5,0],[0,5]]	t2 = [[-10,0],[-5,0],[-1,6]]	print (PolyOverlaps(t1, t2), False) 	t1 = [[0,0],[5,0],[2.5,5]]	t2 = [[0,4],[2.5,-1],[5,4]]	print (PolyOverlaps(t1, t2), True) 	t1 = [[0,0],[1,1],[0,2]]	t2 = [[2,1],[3,0],[3,2]]	print (PolyOverlaps(t1, t2), False) 	t1 = [[0,0],[1,1],[0,2]]	t2 = [[2,1],[3,-2],[3,4]]	print (PolyOverlaps(t1, t2), False) 	#Barely touching	t1 = [[0,0],[1,0],[0,1]]	t2 = [[1,0],[2,0],[1,1]]	print (PolyOverlaps(t1, t2), strv)"
"import __main__, os def isOnlyInstance():    
    
    return os.system(strv +                     __main__.__file__[0] + strv + __main__.__file__[1:] +                     strv) != 0"
"import refrom itertools import product problem_re = re.compile(rstrv(?msx)(?:
 


(?P<namelist> [a-zA-Z]+ (?: , + [a-zA-Z]+)* (?: ,? + and) + [a-zA-Z]+ )
 


| (?:  .* house + that + contains + only +
  (?P<floorcount> two|three|four|five|six|seven|eight|nine|ten ) + floors * )
 


|(?: (?P<not_live>   [a-zA-Z]+ + does + not + live + on + the +
  (?: top|bottom|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth) + floor *  ))
 


|(?P<not_either>  [a-zA-Z]+ + does + not + live + on + either
  (?: + (?: or +)? the +       
    (?: top|bottom|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth))+ + floor *  )
 


|(?P<hi_lower>   [a-zA-Z]+ + lives + on + a  (?: higher|lower)
   + floor + than (?: + does)  +  [a-zA-Z]+ *  )
 


|(?P<adjacency>   [a-zA-Z]+ + does (?:+ not)? + live + on + a +
   floor + adjacent + to +  [a-zA-Z]+ (?: 's )? *  )
 


|(?P<question> Where + does + everyone + live * )
 
)
strv) names, lennames = None, Nonefloors = Noneconstraint_expr = 'len(set(alloc)) == lennames' 
 def do_namelist(txt):    strv    global names, lennames    names = txt.replace(' and ', ' ').split(', ')    lennames = len(names) def do_floorcount(txt):    strv    global floors    floors = '||two|three|four|five|six|seven|eight|nine|ten'.split('|').index(txt) def do_not_live(txt):    strv    global constraint_expr    t = txt.strip().split()    who, floor = t[0], t[-2]    w, f = (names.index(who),            ('|first|second|third|fourth|fifth|sixth|' +             'seventh|eighth|ninth|tenth|top|bottom|').split('|').index(floor)            )    if f == 11: f = floors    if f == 12: f = 1    constraint_expr += ' and alloc[%i] != %i' % (w, f) def do_not_either(txt):    strv    global constraint_expr    t = txt.replace(' or ', ' ').replace(' the ', ' ').strip().split()    who, floor = t[0], t[6:-1]    w, fl = (names.index(who),             [('|first|second|third|fourth|fifth|sixth|' +               'seventh|eighth|ninth|tenth|top|bottom|').split('|').index(f)              for f in floor]             )    for f in fl:        if f == 11: f = floors        if f == 12: f = 1        constraint_expr += ' and alloc[%i] != %i' % (w, f)  def do_hi_lower(txt):    strv    global constraint_expr    t = txt.replace('.', '').strip().split()    name_indices = [names.index(who) for who in (t[0], t[-1])]    if 'lower' in t:        name_indices = name_indices[::-1]    constraint_expr += ' and alloc[%i] > alloc[%i]' % tuple(name_indices) def do_adjacency(txt):    ''' E.g. strv'''    global constraint_expr    t = txt.replace('.', '').replace(strv, '').strip().split()    name_indices = [names.index(who) for who in (t[0], t[-1])]    constraint_expr += ' and abs(alloc[%i] - alloc[%i]) > 1' % tuple(name_indices) def do_question(txt):    global constraint_expr, names, lennames     exec_txt = '''
for alloc in product(range(1,floors+1), repeat=len(names)):
    if %s:
        break
else:
    alloc = None
''' % constraint_expr    exec(exec_txt, globals(), locals())    a = locals()['alloc']    if a:        output= ['Floors are numbered from 1 to %i inclusive.' % floors]        for a2n in zip(a, names):            output += ['  Floor %i is occupied by %s' % a2n]        output.sort(reverse=True)        print(''.join(output))    else:        print('No solution found.')    print() handler = {    'namelist': do_namelist,    'floorcount': do_floorcount,    'not_live': do_not_live,    'not_either': do_not_either,    'hi_lower': do_hi_lower,    'adjacency': do_adjacency,    'question': do_question,    }def parse_and_solve(problem):    p = re.sub(r'+', ' ', problem).strip()    for x in problem_re.finditer(p):        groupname, txt = [(k,v) for k,v in x.groupdict().items() if v][0]        #print (strv % (groupname, txt))        handler[groupname](txt)if __name__ == '__main__':      parse_and_solve(strv
        Baker, Cooper, Fletcher, Miller, and Smith
        live on different floors of an apartment house that contains
        only five floors. Baker does not live on the top floor. Cooper
        does not live on the bottom floor. Fletcher does not live on
        either the top or the bottom floor. Miller lives on a higher
        floor than does Cooper. Smith does not live on a floor
        adjacent to Fletcher's. Fletcher does not live on a floor
        adjacent to Cooper's. Where does everyone live?strv)     print('# Add another person with more constraints and more floors:')    parse_and_solve(strv
        Baker, Cooper, Fletcher, Miller, Guinan, and Smith
        live on different floors of an apartment house that contains
        only seven floors. Guinan does not live on either the top or the third or the fourth floor.
        Baker does not live on the top floor. Cooper
        does not live on the bottom floor. Fletcher does not live on
        either the top or the bottom floor. Miller lives on a higher
        floor than does Cooper. Smith does not live on a floor
        adjacent to Fletcher's. Fletcher does not live on a floor
        adjacent to Cooper's. Where does everyone live?strv)from amb import Amb if __name__ == '__main__':    amb = Amb()     maxfloors = 5    floors = range(1, maxfloors+1)    
    Baker, Cooper, Fletcher, Miller, Smith = (amb(floors) for i in range(5))    for _dummy in amb( lambda Baker, Cooper, Fletcher, Miller, Smith: (                         len(set([Baker, Cooper, Fletcher, Miller, Smith])) == 5  
                         and Baker != maxfloors                         and Cooper != 1                         and Fletcher not in (maxfloors, 1)                         and Miller > Cooper                         and (Smith - Fletcher) not in (1, -1)  
                         and (Fletcher - Cooper) not in (1, -1) 
                         ) ):         print 'Floors are numbered from 1 to %i inclusive.' % maxfloors        print ''.join(sorted('  Floor %i is occupied by %s'                                   % (globals()[name], name)                               for name in 'Baker, Cooper, Fletcher, Miller, Smith'.split(', ')))        break    else:        print 'No solution found.'    print      print '# Add another person with more constraints and more floors:'    
     amb = Amb()     maxfloors = 7    floors = range(1, maxfloors+1)    
    Baker, Cooper, Fletcher, Miller, Guinan, Smith = (amb(floors) for i in range(6))    for _dummy in amb( lambda Baker, Cooper, Fletcher, Miller, Guinan, Smith: (                         len(set([Baker, Cooper, Fletcher, Miller, Guinan, Smith])) == 6  
                         and Guinan not in (maxfloors, 3, 4)                         and Baker != maxfloors                         and Cooper != 1                         and Fletcher not in (maxfloors, 1)                         and Miller > Cooper                         and (Smith - Fletcher) not in (1, -1)  
                         and (Fletcher - Cooper) not in (1, -1) 
                         ) ):         print 'Floors are numbered from 1 to %i inclusive.' % maxfloors        print ''.join(sorted('  Floor %i is occupied by %s'                                   % (globals()[name], name)                               for name in 'Baker, Cooper, Fletcher, Miller, Guinan, Smith'.split(', ')))        break    else:        print 'No solution found.'    print from itertools import permutations class Names:    Baker, Cooper, Fletcher, Miller, Smith = range(5)    seq = [Baker, Cooper, Fletcher, Miller, Smith]    strings = strv.split() predicates = [    lambda s: s[Names.Baker] != len(s)-1,    lambda s: s[Names.Cooper] != 0,    lambda s: s[Names.Fletcher] != 0 and s[Names.Fletcher] != len(s)-1,    lambda s: s[Names.Miller] > s[Names.Cooper],    lambda s: abs(s[Names.Smith] - s[Names.Fletcher]) != 1,    lambda s: abs(s[Names.Cooper] - s[Names.Fletcher]) != 1]; for sol in permutations(Names.seq):    if all(p(sol) for p in predicates):        print strv.join(Names.strings[s] for s in sol)"
"def div_check(x, y):  try:    x / y  except ZeroDivisionError:    return True  else:    return False"
"import math  dxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193,        0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201,        0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799,        0.087] dys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188,        -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,        0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038,        -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445,        -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044,        0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,        -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901,        0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032] def funnel(dxs, rule):    x, rxs = 0, []    for dx in dxs:        rxs.append(x + dx)        x = rule(x, dx)    return rxs def mean(xs): return sum(xs) / len(xs) def stddev(xs):    m = mean(xs)    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs)) def experiment(label, rule):    rxs, rys = funnel(dxs, rule), funnel(dys, rule)    print label    print 'Mean x, y    : %.4f, %.4f' % (mean(rxs), mean(rys))    print 'Std dev x, y : %.4f, %.4f' % (stddev(rxs), stddev(rys))    print  experiment('Rule 1:', lambda z, dz: 0)experiment('Rule 2:', lambda z, dz: -dz)experiment('Rule 3:', lambda z, dz: -(z+dz))experiment('Rule 4:', lambda z, dz: z+dz)from random import gaussfrom math import sqrtfrom pprint import pprint as pp NMAX=50 def statscreator():    sum_ = sum2 = n = 0    def stats(x):        nonlocal sum_, sum2, n         sum_ += x        sum2 += x*x        n    += 1.0        return sum_/n, sqrt(sum2/n - sum_*sum_/n/n)    return stats def drop(target, sigma=1.0):    'Drop ball at target'    return gauss(target, sigma) def deming(rule, nmax=NMAX):    ''' Simulate Demings funnel in 1D. '''     stats = statscreator()    target = 0    for i in range(nmax):        value = drop(target)        mean, sdev = stats(value)        target = rule(target, value)        if i == nmax - 1:            return mean, sdev def d1(target, value):    ''' Keep Funnel over target. '''     return target  def d2(target, value):    ''' The new target starts at the center, 0,0 then is adjusted to
    be the previous target _minus_ the offset of the new drop from the
    previous target. '''     return -value   
 def d3(target, value):    ''' The new target starts at the center, 0,0 then is adjusted to
    be the previous target _minus_ the offset of the new drop from the
    center, 0.0. '''     return target - value def d4(target, value):    ''' (Dumb). The new target is where it last dropped. '''     return value  def printit(rule, trials=5):    print('Deming simulation. %i trials using rule %s: %s'          % (trials, rule.__name__.upper(), rule.__doc__))    for i in range(trials):        print('    Mean: %7.3f, Sdev: %7.3f' % deming(rule))  if __name__ == '__main__':    rcomments = [ (d1, 'Should have smallest deviations ~1.0, and be centered on 0.0'),                  (d2, 'Should be centred on 0.0 with larger deviations than D1'),                  (d3, 'Should be centred on 0.0 with larger deviations than D1'),                  (d4, 'Center wanders all over the place, with deviations to match!'),                ]    for rule, comment in rcomments:        printit(rule)        print('  %s' % comment)"
"import os
os.remove(strv)os.rmdir(strv)
os.remove(strv)os.rmdir(strv)import shutilshutil.rmtree(strv)"
"class Delegator:   def __init__(self):      self.delegate = None   def operation(self):       if hasattr(self.delegate, 'thing') and callable(self.delegate.thing):          return self.delegate.thing()       return 'default implementation' class Delegate:   def thing(self):      return 'delegate implementation' if __name__ == '__main__':    
   a = Delegator()   assert a.operation() == 'default implementation'    
   a.delegate = 'A delegate may be any object'   assert a.operation() == 'default implementation'    
   a.delegate = Delegate()   assert a.operation() == 'delegate implementation'"
import copydeepcopy_of_obj = copy.deepcopy(obj)
"def is_numeric(s):    try:        float(s)        return True    except (ValueError, TypeError):        return False is_numeric('123.0')'123'.isdigit()def is_numeric(literal):    strv    castings = [int, float, complex,        lambda s: int(s,2),  #binary        lambda s: int(s,8),  #octal        lambda s: int(s,16)] #hex    for cast in castings:        try:            cast(literal)            return True        except ValueError:            pass    return Falsedef numeric(literal):    strv    castings = [int, float, complex,        lambda s: int(s,2),  #binary        lambda s: int(s,8),  #octal        lambda s: int(s,16)] #hex    for cast in castings:        try:            return cast(literal)        except ValueError:            pass    return None  tests = [    '0', '0.', '00', '123', '0123', '+123', '-123', '-123.', '-123e-4', '-.8E-04',    '0.123', '(5)', '-123+4.5j', '0b0101', ' +0B101 ', '0o123', '-0xABC', '0x1a1',    '12.5%', '1/2', '½', '3¼', 'π', 'Ⅻ', '1,000,000', '1 000', '- 001.20e+02',     'NaN', 'inf', '-Infinity'] for s in tests:    print(strv % (        '""'+s+'""', numeric(s), type(numeric(s)), is_numeric(s), s.isnumeric() ))"
" '''
Create a Decision table then use it
''' def dt_creator():    print(""CREATING THE DECISION TABLE"")    conditions = input(strv)    conditions = [c.strip() for c in conditions.split(',')]    print( (""That was %s conditions:  "" % len(conditions))           + '  '.join(strv % x for x in enumerate(conditions, 1)) )    print(""Input an action, a semicolon, then a list of tuples of rules that trigger it. End with a blank line"")    action2rules, action = [], ' '    while action:        action = input(strv % (len(action2rules) + 1)).strip()        if action:            name, _, rules = [x.strip() for x in action.partition(';')]            rules = eval(rules)            assert all(len(rule) == len(conditions) for rule in rules), \                   strv             action2rules.append((name, rules))    actions = [x[0] for x in action2rules]    
    rule2actions = dict((y,[]) for y in set(sum((x[1] for x in action2rules), [])))    for action, rules in action2rules:        for r in rules:            rule2actions[r].append( action )    return conditions, rule2actions def dt_user(dt, default=['Pray!']):    conditions, rule2actions = dt    print(""USING THE DECISION TABLE"")    rule = tuple(int('y' == input(strv % c)) for c in conditions)    print(""Try this:  "" + '  '.join(rule2actions.get(rule, default))) if __name__ == '__main__':    dt = dt_creator()    dt_user(dt)    dt_user(dt)    dt_user(dt)"
">>> class num(int):    def __init__(self, b):        if 1 <= b <= 10:            return int.__init__(self+0)        else:            raise ValueError,strv % b  >>> x = num(3)>>> x = num(11) Traceback (most recent call last):  File strv, line 1, in <module>    x = num(11)  File strv, line 6, in __init__    raise ValueError,strv % bValueError: Value 11 should be >=0 and <= 10>>> x3>>> type(x)<class '__main__.num'>>>>"
"def ToReducedRowEchelonForm( M ):    if not M: return    lead = 0    rowCount = len(M)    columnCount = len(M[0])    for r in range(rowCount):        if lead >= columnCount:            return        i = r        while M[i][lead] == 0:            i += 1            if i == rowCount:                i = r                lead += 1                if columnCount == lead:                    return        M[i],M[r] = M[r],M[i]        lv = M[r][lead]        M[r] = [ mrx / lv for mrx in M[r]]        for i in range(rowCount):            if i != r:                lv = M[i][lead]                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]        lead += 1 def pmtx(mtx):    print (''.join(''.join(' %4s' % col for col in row) for row in mtx)) def convolve(f, h):    g = [0] * (len(f) + len(h) - 1)    for hindex, hval in enumerate(h):        for findex, fval in enumerate(f):            g[hindex + findex] += fval * hval    return g def deconvolve(g, f):    lenh = len(g) - len(f) + 1    mtx = [[0 for x in range(lenh+1)] for y in g]    for hindex in range(lenh):        for findex, fval in enumerate(f):            gindex = hindex + findex            mtx[gindex][hindex] = fval    for gindex, gval in enumerate(g):                mtx[gindex][lenh] = gval    ToReducedRowEchelonForm( mtx )    return [mtx[i][lenh] for i in range(lenh)]  
 if __name__ == '__main__':    h = [-8,-9,-3,-1,-6,7]    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]    assert convolve(f,h) == g    assert deconvolve(g, f) == h"
"import sys, math, collections Sphere = collections.namedtuple(strv, strv)V3 = collections.namedtuple(strv, strv) def normalize((x, y, z)):    len = math.sqrt(x**2 + y**2 + z**2)    return V3(x / len, y / len, z / len) def dot(v1, v2):    d = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z    return -d if d < 0 else 0.0 def hit_sphere(sph, x0, y0):    x = x0 - sph.cx    y = y0 - sph.cy    zsq = sph.r ** 2 - (x ** 2 + y ** 2)    if zsq < 0:        return (False, 0, 0)    szsq = math.sqrt(zsq)    return (True, sph.cz - szsq, sph.cz + szsq) def draw_sphere(k, ambient, light):    shades = strv    pos = Sphere(20.0, 20.0, 0.0, 20.0)    neg = Sphere(1.0, 1.0, -6.0, 20.0)     for i in xrange(int(math.floor(pos.cy - pos.r)),                    int(math.ceil(pos.cy + pos.r) + 1)):        y = i + 0.5        for j in xrange(int(math.floor(pos.cx - 2 * pos.r)),                        int(math.ceil(pos.cx + 2 * pos.r) + 1)):            x = (j - pos.cx) / 2.0 + 0.5 + pos.cx             (h, zb1, zb2) = hit_sphere(pos, x, y)            if not h:                hit_result = 0            else:                (h, zs1, zs2) = hit_sphere(neg, x, y)                if not h:                    hit_result = 1                elif zs1 > zb1:                    hit_result = 1                elif zs2 > zb2:                    hit_result = 0                elif zs2 > zb1:                    hit_result = 2                else:                    hit_result = 1             if hit_result == 0:                sys.stdout.write(' ')                continue            elif hit_result == 1:                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)            elif hit_result == 2:                vec = V3(neg.cx-x, neg.cy-y, neg.cz-zs2)            vec = normalize(vec)             b = dot(light, vec) ** k + ambient            intensity = int((1 - b) * len(shades))            intensity = min(len(shades), max(0, intensity))            sys.stdout.write(shades[intensity])        print light = normalize(V3(-50, 30, 50))draw_sphere(2, 0.5, light)"
"hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))bin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16)) def float_dec2bin(d):    neg = False    if d < 0:        d = -d        neg = True    hx = float(d).hex()    p = hx.index('p')    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]            + bin(int(hx[p+2:]))[2:]) def float_bin2dec(bn):    neg = False    if bn[0] == '-':        bn = bn[1:]        neg = True    dp = bn.index('.')    extra0 = '0' * (4 - (dp % 4))    bn2 = extra0 + bn    dp = bn2.index('.')    p = bn2.index('p')    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])                 for i in range(0, dp+1, 4))    bn3 = bn2[dp+1:p]    extra0 = '0' * (4 - (len(bn3) % 4))    bn4 = bn3 + extra0    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))                  for i in range(0, len(bn4), 4))    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]          + str(int('0b' + bn2[p+2:], 2)))    return float.fromhex(hx)"
"import datetimetoday = datetime.date.today()
print today.isoformat()
print today.strftime('%Y-%m-%d')"
"from sys import argv def randomGenerator(seed=1):    max_int32 = (1 << 31) - 1    seed = seed & max_int32     while True:        seed = (seed * 214013 + 2531011) & max_int32        yield seed >> 16 def deal(seed):    nc = 52    cards = range(nc - 1, -1, -1)    rnd = randomGenerator(seed)    for i, r in zip(range(nc), rnd):        j = (nc - 1) - r % (nc - i)        cards[i], cards[j] = cards[j], cards[i]    return cards def show(cards):    l = [strv[c / 4] + strv[c % 4] for c in cards]    for i in range(0, len(cards), 8):        print strv, strv.join(l[i : i+8]) if __name__ == '__main__':    seed = int(argv[1]) if len(argv) == 2 else 11982    print strv, seed    deck = deal(seed)    show(deck)"
"import itertools def brent(f, x0):    
    power = lam = 1    tortoise = x0    hare = f(x0)  
    while tortoise != hare:        if power == lam:  
            tortoise = hare            power *= 2            lam = 0        hare = f(hare)        lam += 1     
    mu = 0    tortoise = hare = x0    for i in range(lam):    
        hare = f(hare)    
     
    while tortoise != hare:        tortoise = f(tortoise)        hare = f(hare)        mu += 1     return lam, mu def iterate(f, x0):    while True:        yield x0        x0 = f(x0) if __name__ == '__main__':    f = lambda x: (x * x + 1) % 255    x0 = 3    lam, mu = brent(f, x0)    print(strv % lam)    print(strv % mu)    print(strv % list(itertools.islice(iterate(f, x0), mu, mu+lam)))import itertools def brent_length(f, x0):    
    hare = x0    power = 1    while True:        tortoise = hare        for i in range(1, power+1):            hare = f(hare)            if tortoise == hare:                return i        power *= 2 def brent(f, x0):    lam = brent_length(f, x0)     
    mu = 0    hare = x0    for i in range(lam):    
        hare = f(hare)    
     
    tortoise = x0    while tortoise != hare:        tortoise = f(tortoise)        hare = f(hare)        mu += 1     return lam, mu def iterate(f, x0):    while True:        yield x0        x0 = f(x0) if __name__ == '__main__':    f = lambda x: (x * x + 1) % 255    x0 = 3    lam, mu = brent(f, x0)    print(strv % lam)    print(strv % mu)    print(strv % list(itertools.islice(iterate(f, x0), mu, mu+lam)))"
"import datetime def mt():	datime1=strv	formatting = strv	datime2 = datime1[:-3]  
	tdelta = datetime.timedelta(hours=12)		
	s3 = datetime.datetime.strptime(datime2, formatting)	datime2 = s3+tdelta	print datime2.strftime(strv) + datime1[-3:] mt()"
"from calendar import weekday, SUNDAY [year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]"
"from decimal import Decimal as Dfrom collections import namedtuple Item = namedtuple('Item', 'price, quant') items = dict( hamburger=Item(D('5.50'), D('4000000000000000')),              milkshake=Item(D('2.86'), D('2')) )tax_rate = D('0.0765') fmt = strvprint(fmt % tuple('Item Price Quantity Extension'.upper().split())) total_before_tax = 0for item, (price, quant) in sorted(items.items()):    ext = price * quant    print(fmt % (item, price, quant, ext))    total_before_tax += extprint(fmt % ('', '', '', '--------------------'))print(fmt % ('', '', 'subtotal', total_before_tax)) tax = (tax_rate * total_before_tax).quantize(D('0.00'))print(fmt % ('', '', 'Tax', tax)) total = total_before_tax + taxprint(fmt % ('', '', '', '--------------------'))print(fmt % ('', '', 'Total', total))"
 def addN(n):     def adder(x):         return x + n     return adder >>> add2 = addN(2) >>> add2 <function adder at 0x009F1E30> >>> add2(7) 9
"def cut_it(h, w):    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))    if h & 1: h, w = w, h    if h & 1: return 0    if w == 1: return 1    count = 0     next = [w + 1, -w - 1, -1, 1]    blen = (h + 1) * (w + 1) - 1    grid = [False] * (blen + 1)     def walk(y, x, count):        if not y or y == h or not x or x == w:            return count + 1         t = y * (w + 1) + x        grid[t] = grid[blen - t] = True         if not grid[t + next[0]]:            count = walk(y + dirs[0][0], x + dirs[0][1], count)        if not grid[t + next[1]]:            count = walk(y + dirs[1][0], x + dirs[1][1], count)        if not grid[t + next[2]]:            count = walk(y + dirs[2][0], x + dirs[2][1], count)        if not grid[t + next[3]]:            count = walk(y + dirs[3][0], x + dirs[3][1], count)         grid[t] = grid[blen - t] = False        return count     t = h // 2 * (w + 1) + w // 2    if w & 1:        grid[t] = grid[t + 1] = True        count = walk(h // 2, w // 2 - 1, count)        res = count        count = 0        count = walk(h // 2 - 1, w // 2, count)        return res + count * 2    else:        grid[t] = True        count = walk(h // 2, w // 2 - 1, count)        if h == w:            return count * 2        count = walk(h // 2 - 1, w // 2, count)        return count def main():    for w in xrange(1, 10):        for h in xrange(1, w + 1):            if not((w * h) & 1):                print strv % (w, h, cut_it(w, h)) main()try:    import psycoexcept ImportError:    passelse:    psyco.full() w, h = 0, 0count = 0vis = [] def cwalk(y, x, d):    global vis, count, w, h    if not y or y == h or not x or x == w:        count += 1        return     vis[y][x] = vis[h - y][w - x] = 1     if x and not vis[y][x - 1]:        cwalk(y, x - 1, d | 1)    if (d & 1) and x < w and not vis[y][x+1]:        cwalk(y, x + 1, d|1)    if y and not vis[y - 1][x]:        cwalk(y - 1, x, d | 2)    if (d & 2) and y < h and not vis[y + 1][x]:        cwalk(y + 1, x, d | 2)     vis[y][x] = vis[h - y][w - x] = 0 def count_only(x, y):    global vis, count, w, h    count = 0    w = x    h = y     if (h * w) & 1:        return count    if h & 1:        w, h = h, w     vis = [[0] * (w + 1) for _ in xrange(h + 1)]    vis[h // 2][w // 2] = 1     if w & 1:        vis[h // 2][w // 2 + 1] = 1     res = 0    if w > 1:        cwalk(h // 2, w // 2 - 1, 1)        res = 2 * count - 1        count = 0        if w != h:            cwalk(h // 2 + 1, w // 2, 3 if (w & 1) else 2)         res += 2 * count - (not (w & 1))    else:        res = 1     if w == h:        res = 2 * res + 2    return res def main():    for y in xrange(1, 10):        for x in xrange(1, y + 1):            if not (x & 1) or not (y & 1):                print strv % (y, x, count_only(x, y)) main()"
" from collections import UserDictimport copy class Dict(UserDict):    '''
    >>> d = Dict(a=1, b=2)
    >>> d
    Dict({'a': 1, 'b': 2})
    >>> d['a'] = 55; d['b'] = 66
    >>> d
    Dict({'a': 55, 'b': 66})
    >>> d.clear()
    >>> d
    Dict({'a': 1, 'b': 2})
    >>> d['a'] = 55; d['b'] = 66
    >>> d['a']
    55
    >>> del d['a']
    >>> d
    Dict({'a': 1, 'b': 66})
    '''    def __init__(self, dict=None, **kwargs):        self.__init = True        super().__init__(dict, **kwargs)        self.default = copy.deepcopy(self.data)        self.__init = False     def __delitem__(self, key):        if key in self.default:            self.data[key] = self.default[key]        else:            raise NotImplementedError     def __setitem__(self, key, item):        if self.__init:            super().__setitem__(key, item)        elif key in self.data:            self.data[key] = item        else:            raise KeyError     def __repr__(self):        return strv % (type(self).__name__, super().__repr__())     def fromkeys(cls, iterable, value=None):        if self.__init:            super().fromkeys(cls, iterable, value)        else:            for key in iterable:                if key in self.data:                    self.data[key] = value                else:                    raise KeyError     def clear(self):        self.data.update(copy.deepcopy(self.default))     def pop(self, key, default=None):        raise NotImplementedError     def popitem(self):        raise NotImplementedError     def update(self, E, **F):        if self.__init:            super().update(E, **F)        else:            haskeys = False            try:                keys = E.keys()                haskeys = Ture            except AttributeError:                pass            if haskeys:                for key in keys:                    self[key] = E[key]            else:                for key, val in E:                    self[key] = val            for key in F:                self[key] = F[key]     def setdefault(self, key, default=None):        if key not in self.data:            raise KeyError        else:            return super().setdefault(key, default)"
">>> from math import sqrt>>> def sd(x):    sd.sum  += x    sd.sum2 += x*x    sd.n    += 1.0    sum, sum2, n = sd.sum, sd.sum2, sd.n    return sqrt(sum2/n - sum*sum/n/n) >>> sd.sum = sd.sum2 = sd.n = 0>>> for value in (2,4,4,4,5,5,7,9):    print (value, sd(value))  (2, 0.0)(4, 1.0)(4, 0.94280904158206258)(4, 0.8660254037844386)(5, 0.97979589711327075)(5, 1.0)(7, 1.3997084244475311)(9, 2.0)>>>>>> class SD(object): 
	def __init__(self):		self.sum, self.sum2, self.n = (0,0,0)	def sd(self, x):		self.sum  += x		self.sum2 += x*x		self.n    += 1.0		sum, sum2, n = self.sum, self.sum2, self.n		return sqrt(sum2/n - sum*sum/n/n) >>> sd_inst = SD()>>> for value in (2,4,4,4,5,5,7,9):	print (value, sd_inst.sd(value))>>> from math import sqrt>>> def sdcreator():	sum = sum2 = n = 0	def sd(x):		nonlocal sum, sum2, n 		sum  += x		sum2 += x*x		n    += 1.0		return sqrt(sum2/n - sum*sum/n/n)	return sd >>> sd = sdcreator()>>> for value in (2,4,4,4,5,5,7,9):	print (value, sd(value))  2 0.04 1.04 0.9428090415824 0.8660254037845 0.9797958971135 1.07 1.399708424459 2.0>>> from math import sqrt>>> def sdcreator():	sum = sum2 = n = 0	while True:		x = yield sqrt(sum2/n - sum*sum/n/n) if n else None 		sum  += x		sum2 += x*x		n    += 1.0 >>> sd = sdcreator()>>> sd.send(None)>>> for value in (2,4,4,4,5,5,7,9):	print (value, sd.send(value))  2 0.04 1.04 0.9428090415824 0.8660254037845 0.9797958971135 1.07 1.399708424459 2.0>>> myMean = lambda MyList : reduce(lambda x, y: x + y, MyList) / float(len(MyList))>>> myStd = lambda MyList : (reduce(lambda x,y : x + y , map(lambda x: (x-myMean(MyList))**2 , MyList)) / float(len(MyList)))**.5 >>> print myStd([2,4,4,4,5,5,7,9])2.0 "
">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!')... >>> "
"import fileinput changerow, changecolumn, changevalue = 2, 4, 'strv' with fileinput.input('csv_data_manipulation.csv', inplace=True) as f:    for line in f:        if fileinput.filelineno() == changerow:            fields = line.rstrip().split(',')            fields[changecolumn-1] = changevalue            line = ','.join(fields) + ''        print(line, end='')"
"csvtxt = '''
Character,Speech
The multitude,The messiah! Show us the messiah!
Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
The multitude,Who are you?
Brians mother,I'm his mother; that's who!
The multitude,Behold his mother! Behold his mother!
''' from cgi import escape def _row2tr(row, attr=None):    cols = escape(row).split(',')    return ('<TR>'            + ''.join('<TD>%s</TD>' % data for data in cols)            + '</TR>') def csv2html(txt):    htmltxt = '<TABLE summary=strv>'    for rownum, row in enumerate(txt.split('')):        htmlrow = _row2tr(row)        htmlrow = '  <TBODY>%s</TBODY>' % htmlrow        htmltxt += htmlrow    htmltxt += '</TABLE>'    return htmltxt htmltxt = csv2html(csvtxt)print(htmltxt)def _row2trextra(row, attr=None):    cols = escape(row).split(',')    attr_tr = attr.get('TR', '')    attr_td = attr.get('TD', '')    return (('<TR%s>' % attr_tr)            + ''.join('<TD%s>%s</TD>' % (attr_td, data) for data in cols)            + '</TR>') def csv2htmlextra(txt, header=True, attr=None):    ' attr is a dictionary mapping tags to attributes to add to that tag'     attr_table = attr.get('TABLE', '')    attr_thead = attr.get('THEAD', '')    attr_tbody = attr.get('TBODY', '')    htmltxt = '<TABLE%s>' % attr_table    for rownum, row in enumerate(txt.split('')):        htmlrow = _row2trextra(row, attr)        rowclass = ('THEAD%s' % attr_thead) if (header and rownum == 0) else ('TBODY%s' % attr_tbody)        htmlrow = '  <%s>%s</%s>' % (rowclass, htmlrow, rowclass[:5])        htmltxt += htmlrow    htmltxt += '</TABLE>'    return htmltxt htmltxt = csv2htmlextra(csvtxt, True,                        dict(TABLE=' border=strv',                             THEAD=' bgcolor=strv',                             TBODY=' bgcolor=strv'                              )                        )print(htmltxt)"
" import random def rand9999():    return random.randint(1000, 9999) def tag(attr='', **kwargs):    for tag, txt in kwargs.items():        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals()) if __name__ == '__main__':    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + ''    rows = ''.join(tag(tr=''.join(tag(' style=strv', td=i)                                    + ''.join(tag(td=rand9999())                                              for j in range(3))))                     for i in range(1, 6))    table = tag(table='' + header + rows + '')    print(table)"
" 
from numpy import linalg A=[[2,-1,5,1],[3,2,2,-6],[1,3,3,-1],[5,-2,-3,3]]B=[-3,-32,-47,49]C=[[2,-1,5,1],[3,2,2,-6],[1,3,3,-1],[5,-2,-3,3]]X=[]for i in range(0,len(B)):    for j in range(0,len(B)):        C[j][i]=B[j]        if i>0:            C[j][i-1]=A[j][i-1]    X.append(round(linalg.det(C)/linalg.det(A),1)) print('w=%s'%X[0],'x=%s'%X[1],'y=%s'%X[2],'z=%s'%X[3]) "
"width = int(raw_input(strv))height = int(raw_input(strv))myarray = [[0] * width for i in xrange(height)]myarray[0][0] = 3.5print myarray[0][0]myarray = {(w,h): 0 for w in range(width) for h in range(height)}
myarray[(0,0)] = 3.5print myarray[(0,0)]"
">>> s = 'The quick brown fox jumps over the lazy dog'>>> import zlib>>> hex(zlib.crc32(s))'0x414fa339' >>> import binascii>>> hex(binascii.crc32(s))'0x414fa339'def create_table():    a = []    for i in range(256):        k = i        for j in range(8):            if k & 1:                k ^= 0x1db710640            k >>= 1        a.append(k)    return a def crc_update(buf, crc):    crc ^= 0xffffffff    for k in buf:        crc = (crc >> 8) ^ crc_table[(crc & 0xff) ^ k]    return crc ^ 0xffffffff crc_table = create_table()print(hex(crc_update(bstrv, 0)))"
"import osfor directory in ['/', './']:  open(directory + 'output.txt', 'w').close()  
  os.mkdir(directory + 'docs')                 
from __future__ import with_statementimport osdef create(directory):    with open(os.path.join(directory, strv), strv):        pass    os.mkdir(os.path.join(directory, strv)) create(strv) 
create(strv) 
"
import sysfor n in xrange(sys.maxint):    print oct(n)
>>> strv.count(strv)3>>> strv.count(strv)2
"def changes(amount, coins):    ways = [0] * (amount + 1)    ways[0] = 1    for coin in coins:        for j in xrange(coin, amount + 1):            ways[j] += ways[j - coin]    return ways[amount] print changes(100, [1, 5, 10, 25])print changes(100000, [1, 5, 10, 25, 50, 100])try:    import psyco    psyco.full()except ImportError:    pass def count_changes(amount_cents, coins):    n = len(coins)    
    cycle = max([c+1 for c in coins if c <= amount_cents]) * n    table = [0] * cycle    for i in xrange(n):        table[i] = 1     pos = n    for s in xrange(1, amount_cents + 1):        for i in xrange(n):            if i == 0 and pos >= cycle:                pos = 0            if coins[i] <= s:                q = pos - coins[i] * n                table[pos]= table[q] if (q >= 0) else table[q + cycle]            if i:                table[pos] += table[pos - 1]            pos += 1    return table[pos - 1] def main():    us_coins = [100, 50, 25, 10, 5, 1]    eu_coins = [200, 100, 50, 20, 10, 5, 2, 1]     for coins in (us_coins, eu_coins):        print count_changes(     100, coins[2:])        print count_changes(  100000, coins)        print count_changes( 1000000, coins)        print count_changes(10000000, coins), """" main()"
"from functools import lru_cache primes = [2, 3, 5, 7, 11, 13, 17]    
 @lru_cache(maxsize=2000)def pfactor(n):    if n == 1:        return [1]    n2 = n // 2 + 1    for p in primes:        if p <= n2:            d, m = divmod(n, p)            if m == 0:                if d > 1:                    return [p] + pfactor(d)                else:                    return [p]        else:            if n > primes[-1]:                primes.append(n)            return [n] if __name__ == '__main__':    mx = 5000    for n in range(1, mx + 1):        factors = pfactor(n)        if n <= 10 or n >= mx - 20:            print( '%4i %5s %s' % (n,                                   '' if factors != [n] or n == 1 else 'prime',                                   'x'.join(str(i) for i in factors)) )        if n == 11:            print('...')     print('Number of primes gathered up to', n, 'is', len(primes))    print(pfactor.cache_info())"
"from __future__ import print_functionfrom shapely.geometry import MultiPoint if __name__==strv:	pts = MultiPoint([(16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2), (12,10)])	print (pts.convex_hull)"
>>> src = strv>>> a = src>>> b = src[:]>>> import copy>>> c = copy.copy(src)>>> d = copy.deepcopy(src)>>> src is a is b is c is dTrue>>> a = 'hello'>>> b = ''.join(a)>>> a == bTrue>>> b is a  ### Might be True ... depends on strv implementation details!False
">>> from fractions import Fraction>>> for d in (0.9054054, 0.518518, 0.75): print(d, Fraction.from_float(d).limit_denominator(100)) 0.9054054 67/740.518518 14/270.75 3/4>>> for d in '0.9054054 0.518518 0.75'.split(): print(d, Fraction(d)) 0.9054054 4527027/50000000.518518 259259/5000000.75 3/4>>> "
"class NG:  def __init__(self, a1, a, b1, b):    self.a1, self.a, self.b1, self.b = a1, a, b1, b   def ingress(self, n):    self.a, self.a1 = self.a1, self.a + self.a1 * n    self.b, self.b1 = self.b1, self.b + self.b1 * n   @property  def needterm(self):    return (self.b == 0 or self.b1 == 0) or not self.a//self.b == self.a1//self.b1   @property  def egress(self):    n = self.a // self.b    self.a,  self.b  = self.b,  self.a  - self.b  * n    self.a1, self.b1 = self.b1, self.a1 - self.b1 * n    return n   @property  def egress_done(self):    if self.needterm: self.a, self.b = self.a1, self.b1    return self.egress   @property  def done(self):    return self.b == 0 and self.b1 == 0data = [[strv,      [2,1,0,2], [13,11]],        [strv,        [2,1,0,2], [22, 7]],        [strv, [1,0,0,4], [22, 7]]] for string, ng, r in data:  print( strv % string, end='' )  op = NG(*ng)  for n in r2cf(*r):    if not op.needterm: print( strv % op.egress, end='' )    op.ingress(n)  while True:    print( strv % op.egress_done, end='' )    if op.done: break  print()"
"def r2cf(n1,n2):  while n2:    n1, (t1, n2) = n2, divmod(n1, n2)    yield t1 print(list(r2cf(1,2)))    
print(list(r2cf(3,1)))    
print(list(r2cf(23,8)))    
print(list(r2cf(13,11)))    
print(list(r2cf(22,7)))    
print(list(r2cf(14142,10000)))    
print(list(r2cf(141421,100000)))    
print(list(r2cf(1414214,1000000)))    
print(list(r2cf(14142136,10000000)))    
def real2cf(x):    while True:        t1, f = divmod(x, 1)        yield int(t1)        if not f:            break        x = 1/f from fractions import Fractionfrom itertools import islice print(list(real2cf(Fraction(13, 11))))    
print(list(islice(real2cf(2 ** 0.5), 20)))    
"
">>> def duration(seconds):	t= []	for dm in (60, 60, 24, 7):		seconds, m = divmod(seconds, dm)		t.append(m)	t.append(seconds)	return ', '.join('%d %s' % (num, unit)			 for num, unit in zip(t[::-1], 'wk d hr min sec'.split())			 if num) >>> for seconds in [7259, 86400, 6000000]:	print(strv % (seconds, duration(seconds)))     7259 sec = 2 hr, 59 sec  86400 sec = 1 d6000000 sec = 9 wk, 6 d, 10 hr, 40 min>>> >>> def duration(seconds, _maxweeks=99999999999):    return ', '.join('%d %s' % (num, unit)		     for num, unit in zip([(seconds // d) % m					   for d, m in ((604800, _maxweeks),                                                         (86400, 7), (3600, 24),                                                         (60, 60), (1, 60))],					  ['wk', 'd', 'hr', 'min', 'sec'])		     if num) >>> for seconds in [7259, 86400, 6000000]:	print(strv % (seconds, duration(seconds)))     7259 sec = 2 hr, 59 sec  86400 sec = 1 d6000000 sec = 9 wk, 6 d, 10 hr, 40 min>>> "
"import randomfrom collections import defaultdict printdead, printlive = '-#'maxgenerations = 3cellcount = 3,3celltable = defaultdict(int, { (1, 2): 1, (1, 3): 1, (0, 3): 1, } ) 
 #### Start States##
u = universe = defaultdict(int)u[(1,0)], u[(1,1)], u[(1,2)] = 1,1,1 ## toad#u = universe = defaultdict(int)#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1#u[(6,6)], u[(6,7)], u[(6,8)] = 1,1,1 ## glider#u = universe = defaultdict(int)#maxgenerations = 16#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1#u[(6,5)] = 1#u[(7,6)] = 1 ## random start#universe = defaultdict(int, 




 for i in range(maxgenerations):    print ""Generation %3i:"" % ( i, )    for row in range(cellcount[1]):        print strv, ''.join(str(universe[(row,col)])                            for col in range(cellcount[0])).replace(                                '0', printdead).replace('1', printlive)    nextgeneration = defaultdict(int)    for row in range(cellcount[1]):        for col in range(cellcount[0]):            nextgeneration[(row,col)] = celltable[                ( universe[(row,col)],                  -universe[(row,col)] + sum(universe[(r,c)]                                             for r in range(row-1,row+2)                                             for c in range(col-1, col+2) )                ) ]    universe = nextgenerationfrom collections import Counter def life(world, N):    strv    for g in range(N+1):        display(world, g)        counts = Counter(n for c in world for n in offset(neighboring_cells, c))        world = {c for c in counts                 if counts[c] == 3 or (counts[c] == 2 and c in world)} neighboring_cells = [(-1, -1), (-1, 0), (-1, 1),                      ( 0, -1),          ( 0, 1),                      ( 1, -1), ( 1, 0), ( 1, 1)] def offset(cells, delta):    strv    (dx, dy) = delta    return {(x+dx, y+dy) for (x, y) in cells} def display(world, g):    strv    print '          GENERATION {}:'.format(g)    Xs, Ys = zip(*world)    Xrange = range(min(Xs), max(Xs)+1)    for y in range(min(Ys), max(Ys)+1):        print ''.join('#' if (x, y) in world else '.'                      for x in Xrange) blinker = {(1, 0), (1, 1), (1, 2)}block   = {(0, 0), (1, 1), (0, 1), (1, 0)}toad    = {(1, 2), (0, 1), (0, 0), (0, 2), (1, 3), (1, 1)}glider  = {(0, 1), (1, 0), (0, 0), (0, 2), (2, 1)}world   = (block | offset(blinker, (5, 2)) | offset(glider, (15, 5)) | offset(toad, (25, 5))           | {(18, 2), (19, 2), (20, 2), (21, 2)} | offset(block, (35, 7)))  life(world, 5)"
"def conjugate_transpose(m):    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m)) def mmul( ma, mb):    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma) def mi(size):    'Complex Identity matrix'    sz = range(size)    m = [[0 + 0j for i in sz] for j in sz]    for i in range(size):        m[i][i] = 1 + 0j    return tuple(tuple(row) for row in m) def __allsame(vector):    first, rest = vector[0], vector[1:]    return all(i == first for i in rest) def __allnearsame(vector, eps=1e-14):    first, rest = vector[0], vector[1:]    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps               for i in rest) def isequal(matrices, eps=1e-14):    'Check any number of matrices for equality within eps'    x = [len(m) for m in matrices]    if not __allsame(x): return False    y = [len(m[0]) for m in matrices]    if not __allsame(y): return False    for s in range(x[0]):        for t in range(y[0]):            if not __allnearsame([m[s][t] for m in matrices], eps): return False    return True  def ishermitian(m, ct):    return isequal([m, ct]) def isnormal(m, ct):    return isequal([mmul(m, ct), mmul(ct, m)]) def isunitary(m, ct):    mct, ctm = mmul(m, ct), mmul(ct, m)    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])    ident = mi(mctx)    return isequal([mct, ctm, ident]) def printm(comment, m):    print(comment)    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]    width = max(max(len(f) for f in row) for row in fields)    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)    print(''.join(lines)) if __name__ == '__main__':    for matrix in [            ((( 3.000+0.000j), (+2.000+1.000j)),             (( 2.000-1.000j), (+1.000+0.000j))),             ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)),             (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)),             (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),             ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)),             (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)),             (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:        printm('Matrix:', matrix)        ct = conjugate_transpose(matrix)        printm('Its conjugate transpose:', ct)        print('Hermitian? %s.' % ishermitian(matrix, ct))        print('Normal?    %s.' % isnormal(matrix, ct))        print('Unitary?   %s.' % isunitary(matrix, ct))"
">>> from collections import defaultdict>>> from random import choice>>> world = defaultdict(int)>>> possiblepoints = [(x,y) for x in range(-15,16)		  for y in range(-15,16)		  if 10 <= abs(x+y*1j) <= 15]>>> for i in range(100): world[choice(possiblepoints)] += 1 >>> for x in range(-15,16):	print(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '			  for y in range(-15,16)))                1     1                     1 1                        11 1     1  1     1           111  1     1211                 1   2    1 1    11             1  11         21              1   1            11  1       1  2                1 1       1  2                             1 1                      1     1 1                            2                      11     1                         1                           1         1                          1                          1                              2                                 1       1                  1 1          1                2   1      1   3            11  2          11   1    1      1   2                 1   1    2                 1  1                            1      1     1                  2 2   1                             1               >>> for i in range(1000): world[choice(possiblepoints)] += 1 >>> for x in range(-15,16):	print(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '			  for y in range(-15,16)))                 2                         41341421333                  5133333131253 1              5231514 14214721 24           326 21222143234122322         54235153132123344125 22       32331432         2422 33       5453135           4144344     132595               323123    4 6353               432224   5 4323                 3 5313  23214                   41433  42454                   33342  332 4                   34314  142 1                   35 53 124211                   53131  22221                   152 4  22213                   34562  654 4                   4 212  24354                   52232  544222                 283323   411123               453325    251321               124332     2124134           2443226      2 113315         64324334       2412452 324 32121132363          4222434324635 5433             3113333123432112633              2131181233  424                  47414232164                         4               "
"from fractions import Fractionimport itertoolstry: zip = itertools.izipexcept: pass 
def CF(a, b, t):  terms = list(itertools.islice(zip(a, b), t))  z = Fraction(1,1)  for a, b in reversed(terms):    z = a + b / z  return z 
def pRes(x, d):  q, x = divmod(x, 1)  res = str(q)  res += strv  for i in range(d):    x *= 10    q, x = divmod(x, 1)    res += str(q)  return res 
def sqrt2_a():  yield 1  for x in itertools.repeat(2):    yield x def sqrt2_b():  for x in itertools.repeat(1):    yield x cf = CF(sqrt2_a(), sqrt2_b(), 950)print(pRes(cf, 200))#1.41421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147  
def Napier_a():  yield 2  for x in itertools.count(1):    yield x def Napier_b():  yield 1  for x in itertools.count(1):    yield x cf = CF(Napier_a(), Napier_b(), 950)print(pRes(cf, 200))#2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901 
def Pi_a():  yield 3  for x in itertools.repeat(6):    yield x def Pi_b():  for x in itertools.count(1,2):    yield x*x cf = CF(Pi_a(), Pi_b(), 950)print(pRes(cf, 10))#3.1415926532from decimal import Decimal, getcontext def calc(fun, n):    temp = Decimal(strv)     for ni in xrange(n+1, 0, -1):        (a, b) = fun(ni)        temp = Decimal(b) / (a + temp)     return fun(0)[0] + temp def fsqrt2(n):    return (2 if n > 0 else 1, 1) def fnapier(n):    return (n if n > 0 else 2, (n - 1) if n > 1 else 1) def fpi(n):    return (6 if n > 0 else 3, (2 * n - 1) ** 2) getcontext().prec = 50print calc(fsqrt2, 200)print calc(fnapier, 200)print calc(fpi, 200)"
"Python 3.2 (r32:88445, Feb 20 2011, 21:30:00) [MSC v.1500 64 bit (AMD64)] on win 32Type strv, strv, strv or strv for more information.>>> from concurrent import futures>>> with futures.ProcessPoolExecutor() as executor:...   _ = list(executor.map(print, 'Enjoy Rosetta Code'.split()))...EnjoyRosettaCode>>>import threadingimport random def echo(text):    print(text) threading.Timer(random.random(), echo, (strv,)).start()threading.Timer(random.random(), echo, (strv,)).start()threading.Timer(random.random(), echo, (strv,)).start()import threadingimport random def echo(text):    print(text) for text in [strv, strv, strv]:    threading.Timer(random.random(), echo, (text,)).start()import random, sys, timeimport threading lock = threading.Lock() def echo(s):    time.sleep(1e-2*random.random())    
    with lock:        sys.stdout.write(s)        sys.stdout.write('') for line in 'Enjoy Rosetta Code'.split():    threading.Thread(target=echo, args=(line,)).start()from __future__ import print_functionfrom multiprocessing import Pool def main():    p = Pool()    p.map(print, 'Enjoy Rosetta Code'.split()) if __name__==strv:    main()import randomfrom twisted.internet    import reactor, task, deferfrom twisted.python.util import println delay = lambda: 1e-4*random.random()d = defer.DeferredList([task.deferLater(reactor, delay(), println, line)                        for line in 'Enjoy Rosetta Code'.split()])d.addBoth(lambda _: reactor.stop())reactor.run()from __future__ import print_functionimport randomimport gevent delay = lambda: 1e-4*random.random()gevent.joinall([gevent.spawn_later(delay(), print, line)               for line in 'Enjoy Rosetta Code'.split()])"
"X, Y = 0, 1p = (3, 4)p = [3, 4] print p[X]class Point:    def __init__(self, x=0, y=0):        self.x = x        self.y = y p = Point()print p.xclass MyObject(object): passpoint = MyObject()point.x, point.y = 0, 1

pseudo_object = {'x': 1, 'y': 2}>>> from collections import namedtuple>>> help(namedtuple)Help on function namedtuple in module collections: namedtuple(typename, field_names, verbose=False)    Returns a new subclass of tuple with named fields.     >>> Point = namedtuple('Point', 'x y')    >>> Point.__doc__                   
    'Point(x, y)'    >>> p = Point(11, y=22)             
    >>> p[0] + p[1]                     
    33    >>> x, y = p                        
    >>> x, y    (11, 22)    >>> p.x + p.y                       
    33    >>> d = p._asdict()                 
    >>> d['x']    11    >>> Point(**d)                      
    Point(x=11, y=22)    >>> p._replace(x=100)               
    Point(x=100, y=22) >>>"
"def run_vm(data_size)    int stack[data_size + 1000]    set stack[0..data_size - 1] to 0    int pc = 0    while True:        op = code[pc]        pc += 1         if op == FETCH:            stack.append(stack[bytes_to_int(code[pc:pc+word_size])[0]]);            pc += word_size        elif op == STORE:            stack[bytes_to_int(code[pc:pc+word_size])[0]] = stack.pop();            pc += word_size        elif op == PUSH:            stack.append(bytes_to_int(code[pc:pc+word_size])[0]);            pc += word_size        elif op == ADD:   stack[-2] += stack[-1]; stack.pop()        elif op == SUB:   stack[-2] -= stack[-1]; stack.pop()        elif op == MUL:   stack[-2] *= stack[-1]; stack.pop()        elif op == DIV:   stack[-2] /= stack[-1]; stack.pop()        elif op == MOD:   stack[-2] %= stack[-1]; stack.pop()        elif op == LT:    stack[-2] = stack[-2] <  stack[-1]; stack.pop()        elif op == GT:    stack[-2] = stack[-2] >  stack[-1]; stack.pop()        elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()        elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()        elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()        elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()        elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()        elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()        elif op == NEG:   stack[-1] = -stack[-1]        elif op == NOT:   stack[-1] = not stack[-1]        elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]        elif op == JZ:    if stack.pop() then pc += word_size else pc += bytes_to_int(code[pc:pc+word_size])[0]        elif op == PRTC:  print stack[-1] as a character; stack.pop()        elif op == PRTS:  print the constant string referred to by stack[-1]; stack.pop()        elif op == PRTI:  print stack[-1] as an integer; stack.pop()        elif op == HALT:  breakfrom __future__ import print_functionimport sys, struct FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND, OR, NEG, NOT, \JMP, JZ, PRTC, PRTS, PRTI, HALT = range(24) code_map = {    strv: FETCH,    strv: STORE,    strv:  PUSH,    strv:   ADD,    strv:   SUB,    strv:   MUL,    strv:   DIV,    strv:   MOD,    strv:    LT,    strv:    GT,    strv:    LE,    strv:    GE,    strv:    EQ,    strv:    NE,    strv:   AND,    strv:    OR,    strv:   NOT,    strv:   NEG,    strv:   JMP,    strv:    JZ,    strv:  PRTC,    strv:  PRTS,    strv:  PRTI,    strv:  HALT} input_file  = Nonecode        = bytearray()string_pool = []word_size   = 4 #*** show error and exitdef error(msg):    print(strv % (msg))    exit(1) def int_to_bytes(val):    return struct.pack(strv, val) def bytes_to_int(bstr):    return struct.unpack(strv, bstr) #***def emit_byte(x):    code.append(x) #***def emit_word(x):    s = int_to_bytes(x)    for x in s:        code.append(x) #***def run_vm(data_size):    stack = [0 for i in range(data_size + 1)]    pc = 0    while True:        op = code[pc]        pc += 1         if op == FETCH:            stack.append(stack[bytes_to_int(code[pc:pc+word_size])[0]]);            pc += word_size        elif op == STORE:            stack[bytes_to_int(code[pc:pc+word_size])[0]] = stack.pop();            pc += word_size        elif op == PUSH:            stack.append(bytes_to_int(code[pc:pc+word_size])[0]);            pc += word_size        elif op == ADD:   stack[-2] += stack[-1]; stack.pop()        elif op == SUB:   stack[-2] -= stack[-1]; stack.pop()        elif op == MUL:   stack[-2] *= stack[-1]; stack.pop()        
        elif op == DIV:   stack[-2] = int(float(stack[-2]) / stack[-1]); stack.pop()        elif op == MOD:   stack[-2] = int(float(stack[-2]) % stack[-1]); stack.pop()        elif op == LT:    stack[-2] = stack[-2] <  stack[-1]; stack.pop()        elif op == GT:    stack[-2] = stack[-2] >  stack[-1]; stack.pop()        elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()        elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()        elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()        elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()        elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()        elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()        elif op == NEG:   stack[-1] = -stack[-1]        elif op == NOT:   stack[-1] = not stack[-1]        elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]        elif op == JZ:            if stack.pop():                pc += word_size            else:                pc += bytes_to_int(code[pc:pc+word_size])[0]        elif op == PRTC:  print(strv % (stack[-1]), end=''); stack.pop()        elif op == PRTS:  print(strv % (string_pool[stack[-1]]), end=''); stack.pop()        elif op == PRTI:  print(strv % (stack[-1]), end=''); stack.pop()        elif op == HALT:  break def str_trans(srce):    dest = strv    i = 0    while i < len(srce):        if srce[i] == '' and i + 1 < len(srce):            if srce[i + 1] == 'n':                dest += ''                i += 2            elif srce[i + 1] == '':                dest += ''                i += 2        else:            dest += srce[i]            i += 1     return dest #***def load_code():    global string_pool     line = input_file.readline()    if len(line) == 0:        error(strv)     line_list = line.split()    data_size = int(line_list[1])    n_strings = int(line_list[3])     for i in range(n_strings):        string_pool.append(str_trans(input_file.readline().strip('""')))     while True:        line = input_file.readline()        if len(line) == 0:            break        line_list = line.split()        offset = int(line_list[0])        instr  = line_list[1]        opcode = code_map.get(instr)        if opcode == None:            error(strv % (instr, offset))        emit_byte(opcode)        if opcode in [JMP, JZ]:            p = int(line_list[3])            emit_word(p - (offset + 1))        elif opcode == PUSH:            value = int(line_list[2])            emit_word(value)        elif opcode in [FETCH, STORE]:            value = int(line_list[2].strip('[]'))            emit_word(value)     return data_size #*** main driverinput_file = sys.stdinif len(sys.argv) > 1:    try:        input_file = open(sys.argv[1], strv, 4096)    except IOError as e:        error(0, 0, strv % sys.argv[1]) data_size = load_code()run_vm(data_size)"
"if x == 0:    foo()elif x == 1:    bar()elif x == 2:    baz()else:    boz()true_value if condition else false_value>>> secret='foo'>>> print 'got it' if secret=='foo' else 'try again''got it'>>> secret = 'foo'>>> result = 'got it' if secret=='foo' else 'try again'>>> print result'got it'dispatcher = dict()dispatcher[0]=foo  
                   
dispatcher[1]=bardispatcher[2]=baz  
 
results = dispatcher.get(x, boz)()  

if x in dispatcher:    results=dispatcher[x]()
dispatcher = {    0: foo,    1: bar,    2: baz,}
results = dispatcher.get(x, boz)()

results = {    0: foo,    1: bar,    2: baz,}.get(x, boz)()"
"def expr(p)    if tok is strv        x = paren_expr()    elif tok in [strv, strv, strv]        gettok()        y = expr(precedence of operator)        if operator was strv            x = y        else            x = make_node(operator, y)    elif tok is an Identifier        x = make_leaf(Identifier, variable name)        gettok()    elif tok is an Integer constant        x = make_leaf(Integer, integer value)        gettok()    else        error()     while tok is a binary operator and precedence of tok >= p        save_tok = tok        gettok()        q = precedence of save_tok        if save_tok is not right associative            q += 1        x = make_node(Operator save_tok represents, x, expr(q))     return x def paren_expr()    expect(strv)    x = expr(0)    expect(strv)    return x def stmt()    t = NULL    if accept(strv)        e = paren_expr()        s = stmt()        t = make_node(If, e, make_node(If, s, accept(strv) ? stmt() : NULL))    elif accept(strv)        t = make_node(Prtc, paren_expr())        expect(strv)    elif accept(strv)        expect(strv)        repeat            if tok is a string                e = make_node(Prts, make_leaf(String, the string))                gettok()            else                e = make_node(Prti, expr(0))             t = make_node(Sequence, t, e)        until not accept(strv)        expect(strv)        expect(strv)    elif tok is strv        gettok()    elif tok is an Identifier        v = make_leaf(Identifier, variable name)        gettok()        expect(strv)        t = make_node(Assign, v, expr(0))        expect(strv)    elif accept(strv)        e = paren_expr()        t = make_node(While, e, stmt()    elif accept(strv)        while tok not equal strv and tok not equal end-of-file            t = make_node(Sequence, t, stmt())        expect(strv)    elif tok is end-of-file        pass    else        error()    return t def parse()    t = NULL    gettok()    repeat        t = make_node(Sequence, t, stmt())    until tok is end-of-file    return tdef prt_ast(t)    if t == NULL        print("";"")    else        print(t.node_type)        if t.node_type in [Identifier, Integer, String]     
            print the value of the Ident, Integer or String, """"        else            print("""")            prt_ast(t.left)            prt_ast(t.right)def load_ast()    line = readline()    
    line_list = tokenize the line, respecting double quotes     text = line_list[0] 
     if text == strv   
        return NULL     node_type = text 
     
    
    
    if len(line_list) > 1        return make_leaf(node_type, line_list[1])     left = load_ast()    right = load_ast()    return make_node(node_type, left, right)from __future__ import print_functionimport sys, shlex, operator tk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \tk_Geq, tk_Eql, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,      \tk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \tk_Integer, tk_String = range(31) nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25) 
Tokens = [    [strv             , False, False, False, -1, -1        ],    [strv               , False, True,  False, 13, nd_Mul    ],    [strv               , False, True,  False, 13, nd_Div    ],    [strv               , False, True,  False, 13, nd_Mod    ],    [strv               , False, True,  False, 12, nd_Add    ],    [strv               , False, True,  False, 12, nd_Sub    ],    [strv               , False, False, True,  14, nd_Negate ],    [strv               , False, False, True,  14, nd_Not    ],    [strv               , False, True,  False, 10, nd_Lss    ],    [strv              , False, True,  False, 10, nd_Leq    ],    [strv               , False, True,  False, 10, nd_Gtr    ],    [strv              , False, True,  False, 10, nd_Geq    ],    [strv              , False, True,  False,  9, nd_Eql    ],    [strv              , False, True,  False,  9, nd_Neq    ],    [strv               , False, False, False, -1, nd_Assign ],    [strv              , False, True,  False,  5, nd_And    ],    [strv              , False, True,  False,  4, nd_Or     ],    [strv              , False, False, False, -1, nd_If     ],    [strv            , False, False, False, -1, -1        ],    [strv           , False, False, False, -1, nd_While  ],    [strv           , False, False, False, -1, -1        ],    [strv            , False, False, False, -1, -1        ],    [strv               , False, False, False, -1, -1        ],    [strv               , False, False, False, -1, -1        ],    [strv               , False, False, False, -1, -1        ],    [strv               , False, False, False, -1, -1        ],    [strv               , False, False, False, -1, -1        ],    [strv               , False, False, False, -1, -1        ],    [strv           , False, False, False, -1, nd_Ident  ],    [strv , False, False, False, -1, nd_Integer],    [strv  , False, False, False, -1, nd_String ]    ] all_syms = {strv   : tk_EOI,     strv    : tk_Mul,            strv      : tk_Div,     strv         : tk_Mod,            strv         : tk_Add,     strv    : tk_Sub,            strv      : tk_Negate,  strv         : tk_Not,            strv        : tk_Lss,     strv   : tk_Leq,            strv     : tk_Gtr,     strv: tk_Geq,            strv       : tk_Eql,     strv    : tk_Neq,            strv      : tk_Assign,  strv         : tk_And,            strv          : tk_Or,      strv     : tk_If,            strv   : tk_Else,    strv  : tk_While,            strv  : tk_Print,   strv   : tk_Putc,            strv      : tk_Lparen,  strv     : tk_Rparen,            strv      : tk_Lbrace,  strv     : tk_Rbrace,            strv      : tk_Semi,    strv          : tk_Comma,            strv     : tk_Ident,   strv        : tk_Integer,            strv         : tk_String} Display_nodes = [strv, strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv, strv,    strv, strv] TK_NAME         = 0TK_RIGHT_ASSOC  = 1TK_IS_BINARY    = 2TK_IS_UNARY     = 3TK_PRECEDENCE   = 4TK_NODE         = 5 input_file = Noneerr_line   = Noneerr_col    = Nonetok        = Nonetok_text   = None #*** show error and exitdef error(msg):    print(strv % (int(err_line), int(err_col), msg))    exit(1) #***def gettok():    global err_line, err_col, tok, tok_text, tok_other    line = input_file.readline()    if len(line) == 0:        error(strv)     line_list = shlex.split(line, False, False)    
    
     err_line = line_list[0]    err_col  = line_list[1]    tok_text = line_list[2]     tok = all_syms.get(tok_text)    if tok == None:        error(strv % (tok_text))     tok_other = None    if tok in [tk_Integer, tk_Ident, tk_String]:        tok_other = line_list[3] class Node:    def __init__(self, node_type, left = None, right = None, value = None):        self.node_type  = node_type        self.left  = left        self.right = right        self.value = value #***def make_node(oper, left, right = None):    return Node(oper, left, right) #***def make_leaf(oper, n):    return Node(oper, value = n) #***def expect(msg, s):    if tok == s:        gettok()        return    error(strv % (msg, Tokens[s][TK_NAME], Tokens[tok][TK_NAME])) #***def expr(p):    x = None     if tok == tk_Lparen:        x = paren_expr()    elif tok in [tk_Sub, tk_Add]:        op = (tk_Negate if tok == tk_Sub else tk_Add)        gettok()        node = expr(Tokens[tk_Negate][TK_PRECEDENCE])        x = (make_node(nd_Negate, node) if op == tk_Negate else node)    elif tok == tk_Not:        gettok()        x = make_node(nd_Not, expr(Tokens[tk_Not][TK_PRECEDENCE]))    elif tok == tk_Ident:        x = make_leaf(nd_Ident, tok_other)        gettok()    elif tok == tk_Integer:        x = make_leaf(nd_Integer, tok_other)        gettok()    else:        error(strv % (Tokens[tok][TK_NAME]))     while Tokens[tok][TK_IS_BINARY] and Tokens[tok][TK_PRECEDENCE] >= p:        op = tok        gettok()        q = Tokens[op][TK_PRECEDENCE]        if not Tokens[op][TK_RIGHT_ASSOC]:            q += 1         node = expr(q)        x = make_node(Tokens[op][TK_NODE], x, node)     return x #***def paren_expr():    expect(strv, tk_Lparen)    node = expr(0)    expect(strv, tk_Rparen)    return node #***def stmt():    t = None     if tok == tk_If:        gettok()        e = paren_expr()        s = stmt()        s2 = None        if tok == tk_Else:            gettok()            s2 = stmt()        t = make_node(nd_If, e, make_node(nd_If, s, s2))    elif tok == tk_Putc:        gettok()        e = paren_expr()        t = make_node(nd_Prtc, e)        expect(strv, tk_Semi)    elif tok == tk_Print:        gettok()        expect(strv, tk_Lparen)        while True:            if tok == tk_String:                e = make_node(nd_Prts, make_leaf(nd_String, tok_other))                gettok()            else:                e = make_node(nd_Prti, expr(0))             t = make_node(nd_Sequence, t, e)            if tok != tk_Comma:                break            gettok()        expect(strv, tk_Rparen)        expect(strv, tk_Semi)    elif tok == tk_Semi:        gettok()    elif tok == tk_Ident:        v = make_leaf(nd_Ident, tok_other)        gettok()        expect(strv, tk_Assign)        e = expr(0)        t = make_node(nd_Assign, v, e)        expect(strv, tk_Semi)    elif tok == tk_While:        gettok()        e = paren_expr()        s = stmt()        t = make_node(nd_While, e, s)    elif tok == tk_Lbrace:        gettok()        while tok != tk_Rbrace and tok != tk_EOI:            t = make_node(nd_Sequence, t, stmt())        expect(strv, tk_Rbrace)    elif tok == tk_EOI:        pass    else:        error(strv % (Tokens[tok][TK_NAME]))     return t #***def parse():    t = None    gettok()    while True:        t = make_node(nd_Sequence, t, stmt())        if tok == tk_EOI or t == None:            break    return t def prt_ast(t):    if t == None:        print(strv)    else:        print(strv % (Display_nodes[t.node_type]), end='')        if t.node_type in [nd_Ident, nd_Integer]:            print(strv % (t.value))        elif t.node_type == nd_String:            print(strv %(t.value))        else:            print(strv)            prt_ast(t.left)            prt_ast(t.right) #*** main driverinput_file = sys.stdinif len(sys.argv) > 1:    try:        input_file = open(sys.argv[1], strv, 4096)    except IOError as e:        error(0, 0, strv % sys.argv[1])t = parse()prt_ast(t)"
" def load_ast()    line = readline()    
    line_list = tokenize the line, respecting double quotes     text = line_list[0] 
     if text == strv        return None     node_type = text 
     
    
    
    if len(line_list) > 1        return make_leaf(node_type, line_list[1])     left = load_ast()    right = load_ast()    return make_node(node_type, left, right) from __future__ import print_functionimport sys, struct, shlex, operator nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25) all_syms = {    strv  : nd_Ident,    strv      : nd_String,    strv     : nd_Integer,  strv    : nd_Sequence,    strv          : nd_If,       strv        : nd_Prtc,    strv        : nd_Prts,     strv        : nd_Prti,    strv       : nd_While,    strv      : nd_Assign,    strv      : nd_Negate,   strv         : nd_Not,    strv    : nd_Mul,      strv      : nd_Div,    strv         : nd_Mod,      strv         : nd_Add,    strv    : nd_Sub,      strv        : nd_Lss,    strv   : nd_Leq,      strv     : nd_Gtr,    strv: nd_Geq,      strv       : nd_Eql,    strv    : nd_Neq,      strv         : nd_And,    strv          : nd_Or} FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND, OR, NEG, NOT, \JMP, JZ, PRTC, PRTS, PRTI, HALT = range(24) operators = {nd_Lss: LT, nd_Gtr: GT, nd_Leq: LE, nd_Geq: GE, nd_Eql: EQ, nd_Neq: NE,    nd_And: AND, nd_Or: OR, nd_Sub: SUB, nd_Add: ADD, nd_Div: DIV, nd_Mul: MUL, nd_Mod: MOD} unary_operators = {nd_Negate: NEG, nd_Not: NOT} input_file  = Nonecode        = bytearray()string_pool = {}globals     = {}string_n    = 0globals_n   = 0word_size   = 4 #*** show error and exitdef error(msg):    print(strv % (msg))    exit(1) def int_to_bytes(val):    return struct.pack(strv, val) def bytes_to_int(bstr):    return struct.unpack(strv, bstr) class Node:    def __init__(self, node_type, left = None, right = None, value = None):        self.node_type  = node_type        self.left  = left        self.right = right        self.value = value #***def make_node(oper, left, right = None):    return Node(oper, left, right) #***def make_leaf(oper, n):    return Node(oper, value = n) #***def emit_byte(x):    code.append(x) #***def emit_word(x):    s = int_to_bytes(x)    for x in s:        code.append(x) def emit_word_at(at, n):    code[at:at+word_size] = int_to_bytes(n) def hole():    t = len(code)    emit_word(0)    return t #***def fetch_var_offset(name):    global globals_n     n = globals.get(name, None)    if n == None:        globals[name] = globals_n        n = globals_n        globals_n += 1    return n #***def fetch_string_offset(the_string):    global string_n     n = string_pool.get(the_string, None)    if n == None:        string_pool[the_string] = string_n        n = string_n        string_n += 1    return n #***def code_gen(x):    if x == None: return    elif x.node_type == nd_Ident:        emit_byte(FETCH)        n = fetch_var_offset(x.value)        emit_word(n)    elif x.node_type == nd_Integer:        emit_byte(PUSH)        emit_word(x.value)    elif x.node_type == nd_String:        emit_byte(PUSH)        n = fetch_string_offset(x.value)        emit_word(n)    elif x.node_type == nd_Assign:        n = fetch_var_offset(x.left.value)        code_gen(x.right)        emit_byte(STORE)        emit_word(n)    elif x.node_type == nd_If:        code_gen(x.left)              
        emit_byte(JZ)                 
        p1 = hole()                   
        code_gen(x.right.left)        
        if (x.right.right != None):            emit_byte(JMP)            
            p2 = hole()        emit_word_at(p1, len(code) - p1)        if (x.right.right != None):            code_gen(x.right.right)   
            emit_word_at(p2, len(code) - p2)    elif x.node_type == nd_While:        p1 = len(code)        code_gen(x.left)        emit_byte(JZ)        p2 = hole()        code_gen(x.right)        emit_byte(JMP)                       
        emit_word(p1 - len(code))        emit_word_at(p2, len(code) - p2)    elif x.node_type == nd_Sequence:        code_gen(x.left)        code_gen(x.right)    elif x.node_type == nd_Prtc:        code_gen(x.left)        emit_byte(PRTC)    elif x.node_type == nd_Prti:        code_gen(x.left)        emit_byte(PRTI)    elif x.node_type == nd_Prts:        code_gen(x.left)        emit_byte(PRTS)    elif x.node_type in operators:        code_gen(x.left)        code_gen(x.right)        emit_byte(operators[x.node_type])    elif x.node_type in unary_operators:        code_gen(x.left)        emit_byte(unary_operators[x.node_type])    else:        error(strv % (x.node_type)) #***def code_finish():    emit_byte(HALT) #***def list_code():    print(strv % (len(globals), len(string_pool)))     for k in sorted(string_pool, key=string_pool.get):        print(k)     pc = 0    while pc < len(code):        print(strv % (pc), end='')        op = code[pc]        pc += 1        if op == FETCH:            x = bytes_to_int(code[pc:pc+word_size])[0]            print(strv % (x));            pc += word_size        elif op == STORE:            x = bytes_to_int(code[pc:pc+word_size])[0]            print(strv % (x));            pc += word_size        elif op == PUSH:            x = bytes_to_int(code[pc:pc+word_size])[0]            print(strv % (x));            pc += word_size        elif op == ADD:   print(strv)        elif op == SUB:   print(strv)        elif op == MUL:   print(strv)        elif op == DIV:   print(strv)        elif op == MOD:   print(strv)        elif op == LT:    print(strv)        elif op == GT:    print(strv)        elif op == LE:    print(strv)        elif op == GE:    print(strv)        elif op == EQ:    print(strv)        elif op == NE:    print(strv)        elif op == AND:   print(strv)        elif op == OR:    print(strv)        elif op == NEG:   print(strv)        elif op == NOT:   print(strv)        elif op == JMP:            x = bytes_to_int(code[pc:pc+word_size])[0]            print(strv % (x, pc + x));            pc += word_size        elif op == JZ:            x = bytes_to_int(code[pc:pc+word_size])[0]            print(strv % (x, pc + x));            pc += word_size        elif op == PRTC:  print(strv)        elif op == PRTI:  print(strv)        elif op == PRTS:  print(strv)        elif op == HALT:  print(strv)        else: error(strv, (op)); def load_ast():    line = input_file.readline()    line_list = shlex.split(line, False, False)     text = line_list[0]    if text == strv:        return None    node_type = all_syms[text]     if len(line_list) > 1:        value = line_list[1]        if value.isdigit():            value = int(value)        return make_leaf(node_type, value)     left = load_ast()    right = load_ast()    return make_node(node_type, left, right) #*** main driverinput_file = sys.stdinif len(sys.argv) > 1:    try:        input_file = open(sys.argv[1], strv, 4096)    except IOError as e:        error(strv % sys.argv[1]) n = load_ast()code_gen(n)code_finish()list_code()"
"from __future__ import print_functionimport sys 
 tk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \tk_Geq, tk_Eq, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,       \tk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \tk_Integer, tk_String = range(31) all_syms = [strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv,    strv, strv] 
symbols = { '{': tk_Lbrace, '}': tk_Rbrace, '(': tk_Lparen, ')': tk_Rparen, '+': tk_Add, '-': tk_Sub,    '*': tk_Mul, '%': tk_Mod, ';': tk_Semi, ',': tk_Comma } key_words = {'if': tk_If, 'else': tk_Else, 'print': tk_Print, 'putc': tk_Putc, 'while': tk_While} the_ch = strv    
the_col = 0the_line = 1input_file = None #*** show error and exitdef error(line, col, msg):    print(line, col, msg)    exit(1) #*** get the next character from the inputdef next_ch():    global the_ch, the_col, the_line     the_ch = input_file.read(1)    the_col += 1    if the_ch == '':        the_line += 1        the_col = 0    return the_ch #*** 'x' - character constantsdef char_lit(err_line, err_col):    n = ord(next_ch())              
    if the_ch == '':        error(err_line, err_col, strv)    elif the_ch == '':        next_ch()        if the_ch == 'n':            n = 10        elif the_ch == '':            n = ord('')        else:            error(err_line, err_col, ""unknown escape sequence %c"" % (the_ch))    if next_ch() != '':        error(err_line, err_col, strv)    next_ch()    return tk_Integer, err_line, err_col, n #*** process divide or commentsdef div_or_cmt(err_line, err_col):    if next_ch() != '*':        return tk_Div, err_line, err_col     
    next_ch()    while True:        if the_ch == '*':            if next_ch() == '/':                next_ch()                return gettok()        elif len(the_ch) == 0:            error(err_line, err_col, strv)        else:            next_ch() #*** strvdef string_lit(start, err_line, err_col):    text = strv     while next_ch() != start:        if len(the_ch) == 0:            error(err_line, err_col, strv)        if the_ch == '':            error(err_line, err_col, strv)        text += the_ch     next_ch()    return tk_String, err_line, err_col, text #*** handle identifiers and integersdef ident_or_int(err_line, err_col):    is_number = True    text = strv     while the_ch.isalnum() or the_ch == '_':        text += the_ch        if not the_ch.isdigit():            is_number = False        next_ch()     if len(text) == 0:        error(err_line, err_col, strv % (ord(the_ch), the_ch))     if text[0].isdigit():        if not is_number:            error(err_line, err_col, strv % (text))        n = int(text)        return tk_Integer, err_line, err_col, n     if text in key_words:        return key_words[text], err_line, err_col     return tk_Ident, err_line, err_col, text #*** look ahead for '>=', etc.def follow(expect, ifyes, ifno, err_line, err_col):    if next_ch() == expect:        next_ch()        return ifyes, err_line, err_col     if ifno == tk_EOI:        error(err_line, err_col, strv % (ord(the_ch), the_ch))     return ifno, err_line, err_col #*** return the next token typedef gettok():    while the_ch.isspace():        next_ch()     err_line = the_line    err_col  = the_col     if len(the_ch) == 0:    return tk_EOI, err_line, err_col    elif the_ch == '/':     return div_or_cmt(err_line, err_col)    elif the_ch == '':    return char_lit(err_line, err_col)    elif the_ch == '<':     return follow('=', tk_Leq, tk_Lss,    err_line, err_col)    elif the_ch == '>':     return follow('=', tk_Geq, tk_Gtr,    err_line, err_col)    elif the_ch == '=':     return follow('=', tk_Eq,  tk_Assign, err_line, err_col)    elif the_ch == '!':     return follow('=', tk_Neq, tk_Not,    err_line, err_col)    elif the_ch == '&':     return follow('&', tk_And, tk_EOI,    err_line, err_col)    elif the_ch == '|':     return follow('|', tk_Or,  tk_EOI,    err_line, err_col)    elif the_ch == '""':     return string_lit(the_ch, err_line, err_col)    elif the_ch in symbols:        sym = symbols[the_ch]        next_ch()        return sym, err_line, err_col    else: return ident_or_int(err_line, err_col) #*** main driverinput_file = sys.stdinif len(sys.argv) > 1:    try:        input_file = open(sys.argv[1], strv, 4096)    except IOError as e:        error(0, 0, strv % sys.argv[1]) while True:    t = gettok()    tok  = t[0]    line = t[1]    col  = t[2]     print(strv % (line, col, all_syms[tok]), end='')     if tok == tk_Integer:  print(strv % (t[3]))    elif tok == tk_Ident:  print(strv %   (t[3]))    elif tok == tk_String: print('  strv' % (t[3]))    else:                  print(strv)     if tok == tk_EOI:        break"
"def load_ast()    line = readline()    
    line_list = tokenize the line, respecting double quotes     text = line_list[0] 
     if text == strv   
        return NULL     node_type = text 
     
    
    
    if len(line_list) > 1        return make_leaf(node_type, line_list[1])     left = load_ast()    right = load_ast()    return make_node(node_type, left, right)interp(x)    if x == NULL return NULL    elif x.node_type == Integer return x.value converted to an integer    elif x.node_type == Ident   return the current value of variable x.value    elif x.node_type == String  return x.value    elif x.node_type == Assign                    globals[x.left.value] = interp(x.right)                    return NULL    elif x.node_type is a binary operator return interp(x.left) operator interp(x.right)    elif x.node_type is a unary operator, return return operator interp(x.left)    elif x.node_type ==  If                    if (interp(x.left)) then interp(x.right.left)                    else interp(x.right.right)                    return NULL    elif x.node_type == While                    while (interp(x.left)) do interp(x.right)                    return NULL    elif x.node_type == Prtc                    print interp(x.left) as a character, no newline                    return NULL    elif x.node_type == Prti                    print interp(x.left) as an integer, no newline                    return NULL    elif x.node_type == Prts                    print interp(x.left) as a string, respecting newlines ("""")                    return NULL    elif x.node_type == Sequence                    interp(x.left)                    interp(x.right)                    return NULL    else        error(strv)from __future__ import print_functionimport sys, shlex, operator nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25) all_syms = {    strv  : nd_Ident,    strv      : nd_String,    strv     : nd_Integer,  strv    : nd_Sequence,    strv          : nd_If,       strv        : nd_Prtc,    strv        : nd_Prts,     strv        : nd_Prti,    strv       : nd_While,    strv      : nd_Assign,    strv      : nd_Negate,   strv         : nd_Not,    strv    : nd_Mul,      strv      : nd_Div,    strv         : nd_Mod,      strv         : nd_Add,    strv    : nd_Sub,      strv        : nd_Lss,    strv   : nd_Leq,      strv     : nd_Gtr,    strv: nd_Geq,      strv       : nd_Eql,    strv    : nd_Neq,      strv         : nd_And,    strv          : nd_Or} input_file  = Noneglobals     = {} #*** show error and exitdef error(msg):    print(strv % (msg))    exit(1) class Node:    def __init__(self, node_type, left = None, right = None, value = None):        self.node_type  = node_type        self.left  = left        self.right = right        self.value = value #***def make_node(oper, left, right = None):    return Node(oper, left, right) #***def make_leaf(oper, n):    return Node(oper, value = n) #***def fetch_var(var_name):    n = globals.get(var_name, None)    if n == None:        globals[var_name] = n = 0    return n #***def interp(x):    global globals     if x == None: return None    elif x.node_type == nd_Integer: return int(x.value)    elif x.node_type == nd_Ident:   return fetch_var(x.value)    elif x.node_type == nd_String:  return x.value     elif x.node_type == nd_Assign:                    globals[x.left.value] = interp(x.right)                    return None    elif x.node_type == nd_Add:     return interp(x.left) +   interp(x.right)    elif x.node_type == nd_Sub:     return interp(x.left) -   interp(x.right)    elif x.node_type == nd_Mul:     return interp(x.left) *   interp(x.right)    
    
    elif x.node_type == nd_Div:     return int(float(interp(x.left)) / interp(x.right))    elif x.node_type == nd_Mod:     return int(float(interp(x.left)) % interp(x.right))    elif x.node_type == nd_Lss:     return interp(x.left) <   interp(x.right)    elif x.node_type == nd_Gtr:     return interp(x.left) >   interp(x.right)    elif x.node_type == nd_Leq:     return interp(x.left) <=  interp(x.right)    elif x.node_type == nd_Geq:     return interp(x.left) >=  interp(x.right)    elif x.node_type == nd_Eql:     return interp(x.left) ==  interp(x.right)    elif x.node_type == nd_Neq:     return interp(x.left) !=  interp(x.right)    elif x.node_type == nd_And:     return interp(x.left) and interp(x.right)    elif x.node_type == nd_Or:      return interp(x.left) or  interp(x.right)    elif x.node_type == nd_Negate:  return -interp(x.left)    elif x.node_type == nd_Not:     return not interp(x.left)     elif x.node_type ==  nd_If:                    if (interp(x.left)):                        interp(x.right.left)                    else:                        interp(x.right.right)                    return None     elif x.node_type == nd_While:                    while (interp(x.left)):                        interp(x.right)                    return None     elif x.node_type == nd_Prtc:                    print(strv % (interp(x.left)), end='')                    return None     elif x.node_type == nd_Prti:                    print(strv % (interp(x.left)), end='')                    return None     elif x.node_type == nd_Prts:                    print(interp(x.left), end='')                    return None     elif x.node_type == nd_Sequence:                    interp(x.left)                    interp(x.right)                    return None    else:        error(strv % (x.node_type)) def str_trans(srce):    dest = strv    i = 0    srce = srce[1:-1]    while i < len(srce):        if srce[i] == '' and i + 1 < len(srce):            if srce[i + 1] == 'n':                dest += ''                i += 2            elif srce[i + 1] == '':                dest += ''                i += 2        else:            dest += srce[i]            i += 1     return dest def load_ast():    line = input_file.readline()    line_list = shlex.split(line, False, False)     text = line_list[0]     value = None    if len(line_list) > 1:        value = line_list[1]        if value.isdigit():            value = int(value)     if text == strv:        return None    node_type = all_syms[text]    if value != None:        if node_type == nd_String:            value = str_trans(value)         return make_leaf(node_type, value)    left = load_ast()    right = load_ast()    return make_node(node_type, left, right) #*** main driverinput_file = sys.stdinif len(sys.argv) > 1:    try:        input_file = open(sys.argv[1], strv, 4096)    except IOError as e:        error(0, 0, strv % sys.argv[1]) n = load_ast()interp(n)"
"all(a == nexta for a, nexta in zip(strings, strings[1:]) 
all(a < nexta for a, nexta in zip(strings, strings[1:]) 
"
"def builtinsort(x):    x.sort() def partition(seq, pivot):   low, middle, up = [], [], []   for x in seq:       if x < pivot:           low.append(x)       elif x == pivot:           middle.append(x)       else:           up.append(x)   return low, middle, upimport randomdef qsortranpart(seq):   size = len(seq)   if size < 2: return seq   low, middle, up = partition(seq, random.choice(seq))   return qsortranpart(low) + middle + qsortranpart(up)def ones(n):    return [1]*n def reversedrange(n):    return reversed(range(n)) def shuffledrange(n):    x = range(n)    random.shuffle(x)    return xdef write_timings(npoints=10, maxN=10**4, sort_functions=(builtinsort,insertion_sort, qsort),                   sequence_creators = (ones, range, shuffledrange)):       Ns = range(2, maxN, maxN//npoints)   for sort in sort_functions:       for make_seq in sequence_creators:           Ts = [usec(sort, (make_seq(n),)) for n in Ns]           writedat('%s-%s-%d-%d.xy' % (sort.__name__,  make_seq.__name__, len(Ns), max(Ns)), Ns, Ts)import operatorimport numpy, pylabdef plotdd(dictplotdict):   strv   symbols = ('o', '^', 'v', '<', '>', 's', '+', 'x', 'D', 'd',              '1', '2', '3', '4', 'h', 'H', 'p', '|', '_')   colors = list('bgrcmyk') 
   for npoints, plotdict in dictplotdict.iteritems():       for ttle, lst in plotdict.iteritems():                       pylab.hold(False)                                           for i, (label, polynom, x, y) in enumerate(sorted(lst,key=operator.itemgetter(0))):               pylab.plot(x, y, colors[i % len(colors)] + symbols[i % len(symbols)], label='%s %s' % (polynom, label))               pylab.hold(True)               y = numpy.polyval(polynom, x)               pylab.plot(x, y, colors[i % len(colors)], label= '_nolegend_')                           pylab.legend(loc='upper left')           pylab.xlabel(polynom.variable)           pylab.ylabel('log2( time in microseconds )')                           pylab.title(ttle, verticalalignment='bottom')           figname = '_%(npoints)03d%(ttle)s' % vars()           pylab.savefig(figname+'.png')           pylab.savefig(figname+'.pdf')           print fignameimport collections, itertools, glob, reimport numpydef plot_timings():   makedict = lambda: collections.defaultdict(lambda: collections.defaultdict(list))   df = makedict()   ds = makedict()   
   for filename in glob.glob('*.xy'):       m = re.match(r'([^-]+)-([^-]+)-(+)-(+)xy', filename)       print filename       assert m, filename       funcname, seqname, npoints, maxN = m.groups()       npoints, maxN = int(npoints), int(maxN)               a = numpy.fromiter(itertools.imap(float, open(filename).read().split()), dtype='f')       Ns = a[::2]  
       Ts = a[1::2] 
       assert len(Ns) == len(Ts) == npoints       assert max(Ns) <= maxN       #       logsafe = numpy.logical_and(Ns>0, Ts>0)       Ts = numpy.log2(Ts[logsafe])       Ns = numpy.log2(Ns[logsafe])       coeffs = numpy.polyfit(Ns, Ts, deg=1)       poly = numpy.poly1d(coeffs, variable='log2(N)')       #       df[npoints][funcname].append((seqname, poly, Ns, Ts))       ds[npoints][seqname].append((funcname, poly, Ns, Ts))   
   plotdd(df)   plotdd(ds) 
sort_functions = [    builtinsort,         
    insertion_sort,      
    insertion_sort_lowb, 
                         
    qsort,               
    qsortranlc,          
                         
    qsortranpart,        
    qsortranpartis,      
    ]                    
if __name__==strv:   import sys   sys.setrecursionlimit(10000)   write_timings(npoints=100, maxN=1024, 
                 sort_functions=sort_functions,                 sequence_creators = (ones, range, shuffledrange))   plot_timings()"
">>> def strcat(sequence):    return '{%s}' % ', '.join(sequence)[::-1].replace(',', 'dna ', 1)[::-1] >>> for seq in ([], [strv], [strv, strv], [strv, strv, strv, strv]):    print('Input: %-24r -> Output: %r' % (seq, strcat(seq)))  Input: []                       -> Output: '{}'Input: ['ABC']                  -> Output: '{ABC}'Input: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'Input: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'>>> def commaQuibble(s):    return '{%s}' % ' and '.join(s).replace(' and ', ', ', len(s) - 2) for seq in ([], [strv], [strv, strv], [strv, strv, strv, strv]):	print('Input: %-24r -> Output: %r' % (seq, commaQuibble(seq)))>>> def quibble(s):    return ('{' +                (', '.join(s[:-1]) + ' and ' if len(s) > 1 else '') +	        (s[-1] if s else '') +	    '}') >>> for seq in ([], [strv], [strv, strv], [strv, strv, strv, strv]):	print('Input: %-24r -> Output: %r' % (seq, quibble(seq)))  Input: []                       -> Output: '{}'Input: ['ABC']                  -> Output: '{ABC}'Input: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'Input: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'>>> "
import sysprogram_name = sys.argv[0]arguments = sys.argv[1:]count = len(arguments)
"
 var x = 0 ## Documentation comments start with double hash characters. var y = 0 ## Comments are a proper part of the syntax and are indentation sensitive.          ## If the next line only consists of a comment piece, it must be aligned          ## either to the preceding one (documentation generator would merge these lines)## or to the code block (starting a new comment piece).   
 var z = 0 ## Alternatively you can end the preceding comment piece with a backslash \  ## to reset alignment to any column you like.  ## See also http://nim-code.org/tut1.html#comments
foo = 5 
strvUn-assigned strings in triple-quotes might be used 
   as multi-line comments
strv '''
   strv quote marks; and they can contain mixtures
   of other quote marks without any need to scapethem using any special characters.  They also may span multiple
   lines without special escape characters.
'''#!/usr/bin/env python
strv class Foo:     '''Some documentation for the Foo class'''     def __init__(self):        strv def bar():    strv if __name__ == strv:    print (__doc__)    print (Foo.__doc__)    print (Foo.__init__.__doc__)    print (bar.__doc__)"
"from __future__ import print_function from scipy.misc import factorial as factfrom scipy.misc import comb def perm(N, k, exact=0):    return comb(N, k, exact) * fact(k, exact) exact=Trueprint('Sample Perms 1..12')for N in range(1, 13):    k = max(N-2, 1)    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '') print('Sample Combs 10..60')for N in range(10, 61, 10):    k = N-2    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '') exact=Falseprint('Sample Perms 5..1500 Using FP approximations')for N in [5, 15, 150, 1500, 15000]:    k = N-2    print('%iP%i =' % (N, k), perm(N, k, exact)) print('Sample Combs 100..1000 Using FP approximations')for N in range(100, 1001, 100):    k = N-2    print('%iC%i =' % (N, k), comb(N, k, exact)) "
">>> from itertools import combinations>>> list(combinations(range(5),3))[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]def comb(m, lst):    if m == 0: return [[]]    return [[x] + suffix for i, x in enumerate(lst)            for suffix in comb(m - 1, lst[i + 1:])]>>> comb(3, range(5))[[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]def comb(m, s):    if m == 0: return [[]]    if s == []: return []    return [s[:1] + a for a in comb(m-1, s[1:])] + comb(m, s[1:]) print comb(3, range(5))"
">>> from itertools import combinations_with_replacement>>> n, k = 'iced jam plain'.split(), 2>>> list(combinations_with_replacement(n,k))[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]>>> 
>>> len(list(combinations_with_replacement(range(10), 3)))220>>> "
from PIL import Image if __name__==strv:	im = Image.open(strv)	im2 = im.quantize(16)	im2.show()
"def get_pixel_colour(i_x, i_y):	import win32gui	i_desktop_window_id = win32gui.GetDesktopWindow()	i_desktop_window_dc = win32gui.GetWindowDC(i_desktop_window_id)	long_colour = win32gui.GetPixel(i_desktop_window_dc, i_x, i_y)	i_colour = int(long_colour)	return (i_colour & 0xff), ((i_colour >> 8) & 0xff), ((i_colour >> 16) & 0xff) print get_pixel_colour(0, 0)def get_pixel_colour(i_x, i_y):	import PIL.ImageGrab	return PIL.ImageGrab.grab().load()[i_x, i_y] print get_pixel_colour(0, 0)def get_pixel_colour(i_x, i_y):	import PIL.Image 
	import PIL.ImageStat 
	import Xlib.display 
	o_x_root = Xlib.display.Display().screen().root	o_x_image = o_x_root.get_image(i_x, i_y, 1, 1, Xlib.X.ZPixmap, 0xffffffff)	o_pil_image_rgb = PIL.Image.fromstring(strv, (1, 1), o_x_image.data, strv, strv)	lf_colour = PIL.ImageStat.Stat(o_pil_image_rgb).mean	return tuple(map(int, lf_colour)) print get_pixel_colour(0, 0)def get_pixel_colour(i_x, i_y):	import gtk 
	o_gdk_pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, False, 8, 1, 1)	o_gdk_pixbuf.get_from_drawable(gtk.gdk.get_default_root_window(), gtk.gdk.colormap_get_system(), i_x, i_y, 0, 0, 1, 1)	return tuple(o_gdk_pixbuf.get_pixels_array().tolist()[0][0]) print get_pixel_colour(0, 0)def get_pixel_colour(i_x, i_y):	import PyQt4.QtGui 
	app = PyQt4.QtGui.QApplication([])	long_qdesktop_id = PyQt4.QtGui.QApplication.desktop().winId()	long_colour = PyQt4.QtGui.QPixmap.grabWindow(long_qdesktop_id, i_x, i_y, 1, 1).toImage().pixel(0, 0)	i_colour = int(long_colour)	return ((i_colour >> 16) & 0xff), ((i_colour >> 8) & 0xff), (i_colour & 0xff) print get_pixel_colour(0, 0)"
" #!/usr/bin/env python#vertical coloured stripes in window in Python 2.7.1 from livewires import * horiz=640; vert=480begin_graphics(width=horiz,height=vert,title=strv,background=Colour.black)NameColors=[strv,strv,strv,strv,strv,strv,strv,strv]stepik=horiz/len(NameColors) for index,each in enumerate(NameColors):	ExcStrng=strv+each+strv	exec ExcStrng	box(index*stepik,0,(index+1)*stepik,vert,filled=1) while keys_pressed() != ['x']: 
	pass end_graphics() "
"collection = [0, '1']                 
x = collection[0]                     
collection.append(2)                  
collection.insert(0, '-1')            
y = collection[0]                     
collection.extend([2,'3'])            
collection += [2,'3']                 
collection[2:6]                       
len(collection)                       
collection = (0, 1)                   
collection[:]                         
collection[-4:-1]                     
collection[::2]                       
collection=strv              
x = collection[::-1]                  
collection[::2] == strv[::2] 
collection.__getitem__(slice(0,len(collection),2))  
collection = {0: strv, 1: strv}    
collection['zero'] = 2                
collection = set([0, '1'])            
"
"funcs = []for i in range(10):    funcs.append(lambda: i * i)print funcs[3]() 
funcs = []for i in range(10):    funcs.append(lambda i=i: i * i)print funcs[3]() 
funcs = [lambda i=i: i * i for i in range(10)]print funcs[3]() 
funcs = []for i in range(10):    funcs.append((lambda i: lambda: i * i)(i))print funcs[3]() 
funcs = [(lambda i: lambda: i)(i * i) for i in range(10)]print funcs[3]() 
funcs = map(lambda i: lambda: i * i, range(10))print funcs[3]() 
funcs=[eval(strv%i**2)for i in range(10)]print funcs[3]() 
"
" 
 from __future__ import print_functionfrom datetime import datetime pinyin = {  '甲': 'jiă',  '乙': 'yĭ',  '丙': 'bĭng',  '丁': 'dīng',  '戊': 'wù',  '己': 'jĭ',  '庚': 'gēng',  '辛': 'xīn',  '壬': 'rén',  '癸': 'gŭi',   '子': 'zĭ',  '丑': 'chŏu',  '寅': 'yín',  '卯': 'măo',  '辰': 'chén',  '巳': 'sì',  '午': 'wŭ',  '未': 'wèi',  '申': 'shēn',  '酉': 'yŏu',  '戌': 'xū',  '亥': 'hài'} animals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake',           'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']elements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water'] celestial = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸']terrestrial = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥']aspects = ['yang', 'yin']  def calculate(year):    BASE = 4    year = int(year)    cycle_year = year - BASE    stem_number = cycle_year % 10    stem_han = celestial[stem_number]    stem_pinyin = pinyin[stem_han]    element_number = stem_number // 2    element = elements[element_number]    branch_number = cycle_year % 12    branch_han = terrestrial[branch_number]    branch_pinyin = pinyin[branch_han]    animal = animals[branch_number]    aspect_number = cycle_year % 2    aspect = aspects[aspect_number]    index = cycle_year % 60 + 1    print(strv          .format(year, stem_han, branch_han,                  stem_pinyin, branch_pinyin, element, animal, aspect, index))  current_year = datetime.now().yearyears = [1935, 1938, 1968, 1972, 1976, current_year]for year in years:    calculate(year)  "
"strv
  Compute nearest pair of points using two algorithms
 
  First algorithm is 'brute force' comparison of every possible pair.
  Second, 'divide and conquer', is based on:
    www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt 
strv from random import randint, randrangefrom operator import itemgetter, attrgetter infinity = float('inf') 
 def bruteForceClosestPair(point):    numPoints = len(point)    if numPoints < 2:        return infinity, (None, None)    return min( ((abs(point[i] - point[j]), (point[i], point[j]))                 for i in range(numPoints-1)                 for j in range(i+1,numPoints)),                key=itemgetter(0)) def closestPair(point):    xP = sorted(point, key= attrgetter('real'))    yP = sorted(point, key= attrgetter('imag'))    return _closestPair(xP, yP) def _closestPair(xP, yP):    numPoints = len(xP)    if numPoints <= 3:        return bruteForceClosestPair(xP)    Pl = xP[:numPoints/2]    Pr = xP[numPoints/2:]    Yl, Yr = [], []    xDivider = Pl[-1].real    for p in yP:        if p.real <= xDivider:            Yl.append(p)        else:            Yr.append(p)    dl, pairl = _closestPair(Pl, Yl)    dr, pairr = _closestPair(Pr, Yr)    dm, pairm = (dl, pairl) if dl < dr else (dr, pairr)    
    closeY = [p for p in yP  if abs(p.real - xDivider) < dm]    numCloseY = len(closeY)    if numCloseY > 1:        
        closestY = min( ((abs(closeY[i] - closeY[j]), (closeY[i], closeY[j]))                         for i in range(numCloseY-1)                         for j in range(i+1,min(i+8, numCloseY))),                        key=itemgetter(0))        return (dm, pairm) if dm <= closestY[0] else closestY    else:        return dm, pairm def times():    ''' Time the different functions
    '''    import timeit     functions = [bruteForceClosestPair, closestPair]    for f in functions:        print 'Time for', f.__name__, timeit.Timer(            '%s(pointList)' % f.__name__,            'from closestpair import %s, pointList' % f.__name__).timeit(number=1)   pointList = [randint(0,1000)+1j*randint(0,1000) for i in range(2000)] if __name__ == '__main__':    pointList = [(5+9j), (9+3j), (2+0j), (8+4j), (7+4j), (9+10j), (1+9j), (8+2j), 10j, (9+6j)]    print pointList    print '  bruteForceClosestPair:', bruteForceClosestPair(pointList)    print '            closestPair:', closestPair(pointList)    for i in range(10):        pointList = [randrange(11)+1j*randrange(11) for i in range(10)]        print '', pointList        print ' bruteForceClosestPair:', bruteForceClosestPair(pointList)        print '           closestPair:', closestPair(pointList)    print ''    times()    times()    times()"
"from collections import namedtuplefrom math import sqrt Pt = namedtuple('Pt', 'x, y')Circle = Cir = namedtuple('Circle', 'x, y, r') def circles_from_p1p2r(p1, p2, r):    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'    if r == 0.0:        raise ValueError('radius of zero')    (x1, y1), (x2, y2) = p1, p2    if p1 == p2:        raise ValueError('coincident points gives infinite number of Circles')    
    dx, dy = x2 - x1, y2 - y1    
    q = sqrt(dx**2 + dy**2)    if q > 2.0*r:        raise ValueError('separation of points > diameter')    
    x3, y3 = (x1+x2)/2, (y1+y2)/2    
    d = sqrt(r**2-(q/2)**2)    
    c1 = Cir(x = x3 - d*dy/q,             y = y3 + d*dx/q,             r = abs(r))    
    c2 = Cir(x = x3 + d*dy/q,             y = y3 - d*dx/q,             r = abs(r))    return c1, c2 if __name__ == '__main__':    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:        print('Through points:  %r,  %r  and radius %fYou can construct the following circles:'              % (p1, p2, r))        try:            print('  %r  %r' % circles_from_p1p2r(p1, p2, r))        except ValueError as v:            print('  ERROR: %s' % (v.args[0],))"
"class MyClass:    name2 = 2 
     def __init__(self):        strv
        Constructor  (Technically an initializer rather than a true strv)
        strv        self.name1 = 0 
     def someMethod(self):        strv
        Method
        strv        self.name1 = 1        MyClass.name2 = 3  myclass = MyClass() 
 class MyOtherClass:    count = 0  
    def __init__(self, name, gender=strv, age=None):        strv
        One initializer required, others are optional (with different defaults)
        strv        MyOtherClass.count += 1        self.name = name        self.gender = gender        if age is not None:            self.age = age    def __del__(self):        MyOtherClass.count -= 1 person1 = MyOtherClass(strv)print person1.name, person1.gender  
print person1.age                   
person2 = MyOtherClass(strv, strv, 23)print person2.name, person2.gender, person2.age  
class MyClass(object):    ..."
"
def chinese_remainder(n, a):    sum = 0    prod = reduce(lambda a, b: a*b, n)     for n_i, a_i in zip(n, a):        p = prod / n_i        sum += a_i * mul_inv(p, n_i) * p    return sum % prod  def mul_inv(a, b):    b0 = b    x0, x1 = 0, 1    if b == 1: return 1    while a > 1:        q = a / b        a, b = b, a%b        x0, x1 = x1 - q * x0, x0    if x1 < 0: x1 += b0    return x1 if __name__ == '__main__':    n = [3, 5, 7]    a = [2, 3, 2]    print chinese_remainder(n, a)"
import os os.path.isfile(strv)os.path.isfile(strv)os.path.isdir(strv)os.path.isdir(strv)
from sys import stdinif stdin.isatty():    print(strv)else:    print(strv)
from sys import stdoutif stdout.isatty():    print 'The output device is a teletype. Or something like a teletype.'else:    print 'The output device isnt like a teletype.'
"import refrom fractions import Fractionfrom pprint import pprint as pp  equationtext = '''
  pi/4 = arctan(1/2) + arctan(1/3) 
  pi/4 = 2*arctan(1/3) + arctan(1/7)
  pi/4 = 4*arctan(1/5) - arctan(1/239)
  pi/4 = 5*arctan(1/7) + 2*arctan(3/79)
  pi/4 = 5*arctan(29/278) + 7*arctan(3/79)
  pi/4 = arctan(1/2) + arctan(1/5) + arctan(1/8) 
  pi/4 = 4*arctan(1/5) - arctan(1/70) + arctan(1/99) 
  pi/4 = 5*arctan(1/7) + 4*arctan(1/53) + 2*arctan(1/4443)
  pi/4 = 6*arctan(1/8) + 2*arctan(1/57) + arctan(1/239)
  pi/4 = 8*arctan(1/10) - arctan(1/239) - 4*arctan(1/515)
  pi/4 = 12*arctan(1/18) + 8*arctan(1/57) - 5*arctan(1/239)
  pi/4 = 16*arctan(1/21) + 3*arctan(1/239) + 4*arctan(3/1042)
  pi/4 = 22*arctan(1/28) + 2*arctan(1/443) - 5*arctan(1/1393) - 10*arctan(1/11018)
  pi/4 = 22*arctan(1/38) + 17*arctan(7/601) + 10*arctan(7/8149)
  pi/4 = 44*arctan(1/57) + 7*arctan(1/239) - 12*arctan(1/682) + 24*arctan(1/12943)
  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12943)
  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12944)
''' def parse_eqn(equationtext=equationtext):    eqn_re = re.compile(rstrv(?mx)
    (?P<lhs> ^ * pi/4 * = *)?             # LHS of equation
    (?:                                         # RHS
        * (?P<sign> [+-])? * 
        (?: (?P<mult> +) * )? 
        * arctan (?P<numer> +) / (?P<denom> +)
    )strv)     found = eqn_re.findall(equationtext)    machins, part = [], []    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):        if lhs and part:            machins.append(part)            part = []        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),                       Fraction(int(numer), (int(denom) if denom else 1)) ) )    machins.append(part)    return machins  def tans(xs):    xslen = len(xs)    if xslen == 1:        return tanEval(*xs[0])    aa, bb = xs[:xslen//2], xs[xslen//2:]    a, b = tans(aa), tans(bb)    return (a + b) / (1 - a * b) def tanEval(coef, f):    if coef == 1:        return f    if coef < 0:        return -tanEval(-coef, f)    ca = coef // 2    cb = coef - ca    a, b = tanEval(ca, f), tanEval(cb, f)    return (a + b) / (1 - a * b)  if __name__ == '__main__':    machins = parse_eqn()    #pp(machins, width=160)    for machin, eqn in zip(machins, equationtext.split('')):        ans = tans(machin)        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))"
"from __future__ import print_function from pprint import pprintfrom math import sqrt  def cholesky(A):    L = [[0.0] * len(A) for _ in xrange(len(A))]    for i in xrange(len(A)):        for j in xrange(i+1):            s = sum(L[i][k] * L[j][k] for k in xrange(j))            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \                      (1.0 / L[j][j] * (A[i][j] - s))    return L if __name__ == strv:    m1 = [[25, 15, -5],          [15, 18,  0],          [-5,  0, 11]]    pprint(cholesky(m1))    print()     m2 = [[18, 22,  54,  42],          [22, 70,  86,  62],          [54, 86, 174, 134],          [42, 62, 134, 106]]    pprint(cholesky(m2), width=120)def cholesky(A):    L = [[0.0] * len(A) for _ in range(len(A))]    for i, (Ai, Li) in enumerate(zip(A, L)):        for j, Lj in enumerate(L[:i+1]):            s = sum(Li[k] * Lj[k] for k in range(j))            Li[j] = sqrt(Ai[i] - s) if (i == j) else \                      (1.0 / Lj[j] * (Ai[j] - s))    return L"
">>> from operator import add>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]>>> help(reduce)Help on built-in function reduce in module __builtin__: reduce(...)    reduce(function, sequence[, initial]) -> value     Apply a function of two arguments cumulatively to the items of a sequence,    from left to right, so as to reduce the sequence to a single value.    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items    of the sequence in the calculation, and serves as a default when the    sequence is empty. >>> reduce(add, listoflists, [])['the', 'cat', 'sat', 'on', 'the', 'mat']>>> from functools import reducefrom operator import add, mul nums = range(1,11) summation = reduce(add, nums) product = reduce(mul, nums) concatenation = reduce(lambda a, b: str(a) + str(b), nums) print(summation, product, concatenation)"
"#!/usr/bin/env python import socketimport threadimport time HOST = strvPORT = 4004 def accept(conn):    strv
    Call the inner func in a thread so as not to block. Wait for a 
    name to be entered from the given connection. Once a name is 
    entered, set the connection to non-blocking and add the user to 
    the users dict.
    strv    def threaded():        while True:            conn.send(strv)            try:                name = conn.recv(1024).strip()            except socket.error:                continue            if name in users:                conn.send(""Name entered is already in use."")            elif name:                conn.setblocking(False)                users[name] = conn                broadcast(name, strv % name)                break    thread.start_new_thread(threaded, ()) def broadcast(name, message):    strv
    Send a message to all users from the given name.
    strv    print message    for to_name, conn in users.items():        if to_name != name:            try:                conn.send(message + """")            except socket.error:                pass 
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)server.setblocking(False)server.bind((HOST, PORT))server.listen(1)print strv % (strv % server.getsockname()) 
users = {}while True:    try:        
        while True:            try:                conn, addr = server.accept()            except socket.error:                break            accept(conn)        
        for name, conn in users.items():            try:                message = conn.recv(1024)            except socket.error:                continue            if not message:                
                del users[name]                broadcast(name, strv % name)            else:                broadcast(name, strv % (name, message.strip()))        time.sleep(.1)    except (SystemExit, KeyboardInterrupt):        break"
"print ord('a') 
print chr(97)  
print ord(u'π')   
print unichr(960) 
print(ord('a')) 
print(ord('π')) 
print(chr(97))  
print(chr(960)) 
"
">>> n = 15>>> t = [0] * (n + 2)>>> t[1] = 1>>> for i in range(1, n + 1):	for j in range(i, 1, -1): t[j] += t[j - 1]	t[i + 1] = t[i]	for j in range(i + 1, 1, -1): t[j] += t[j - 1]	print(t[i+1] - t[i], end=' ')  1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440 9694845 >>> def catalan_number(n):    nm = dm = 1    for k in range(2, n+1):      nm, dm = ( nm*(n+k), dm*k )    return nm/dm print [catalan_number(n) for n in range(1, 16)] [1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845]"
"
#
#def CastOut(Base=10, Start=1, End=999999):  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]  x,y = divmod(Start, Base-1)  while True:    for n in ran:      k = (Base-1)*x + n      if k < Start:        continue      if k > End:        return      yield k    x += 1 for V in CastOut(Base=16,Start=1,End=255):  print(V, end=' ')"
">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)The three dogs are named  Benjamin ,  Samba , and  Bernie>>> "
"#!/bin/pythonimport numpy as npfrom scipy.ndimage.filters import convolve, gaussian_filterfrom scipy.misc import imread, imshow def CannyEdgeDetector(im, blur = 1, highThreshold = 91, lowThreshold = 31):	im = np.array(im, dtype=float) #Convert to float to prevent clipping values 	#Gaussian blur to reduce noise	im2 = gaussian_filter(im, blur) 	#Use sobel filters to get horizontal and vertical gradients	im3h = convolve(im2,[[-1,0,1],[-2,0,2],[-1,0,1]]) 	im3v = convolve(im2,[[1,2,1],[0,0,0],[-1,-2,-1]]) 	#Get gradient and direction	grad = np.power(np.power(im3h, 2.0) + np.power(im3v, 2.0), 0.5)	theta = np.arctan2(im3v, im3h)	thetaQ = (np.round(theta * (5.0 / np.pi)) + 5) % 5 #Quantize direction 	#Non-maximum suppression	gradSup = grad.copy()	for r in range(im.shape[0]):		for c in range(im.shape[1]):			#Suppress pixels at the image edge			if r == 0 or r == im.shape[0]-1 or c == 0 or c == im.shape[1] - 1:				gradSup[r, c] = 0				continue			tq = thetaQ[r, c] % 4 			if tq == 0: #0 is E-W (horizontal)				if grad[r, c] <= grad[r, c-1] or grad[r, c] <= grad[r, c+1]:					gradSup[r, c] = 0			if tq == 1: #1 is NE-SW				if grad[r, c] <= grad[r-1, c+1] or grad[r, c] <= grad[r+1, c-1]:					gradSup[r, c] = 0			if tq == 2: #2 is N-S (vertical)				if grad[r, c] <= grad[r-1, c] or grad[r, c] <= grad[r+1, c]:					gradSup[r, c] = 0			if tq == 3: #3 is NW-SE				if grad[r, c] <= grad[r-1, c-1] or grad[r, c] <= grad[r+1, c+1]:					gradSup[r, c] = 0 	#Double threshold	strongEdges = (gradSup > highThreshold) 	#Strong has value 2, weak has value 1	thresholdedEdges = np.array(strongEdges, dtype=np.uint8) + (gradSup > lowThreshold) 	#Tracing edges with hysteresis		#Find weak edge pixels near strong edge pixels	finalEdges = strongEdges.copy()	currentPixels = []	for r in range(1, im.shape[0]-1):		for c in range(1, im.shape[1]-1):				if thresholdedEdges[r, c] != 1:				continue #Not a weak pixel 			#Get 3x3 patch				localPatch = thresholdedEdges[r-1:r+2,c-1:c+2]			patchMax = localPatch.max()			if patchMax == 2:				currentPixels.append((r, c))				finalEdges[r, c] = 1 	#Extend strong edges based on current pixels	while len(currentPixels) > 0:		newPix = []		for r, c in currentPixels:			for dr in range(-1, 2):				for dc in range(-1, 2):					if dr == 0 and dc == 0: continue					r2 = r+dr					c2 = c+dc					if thresholdedEdges[r2, c2] == 1 and finalEdges[r2, c2] == 0:						#Copy this weak pixel to final result						newPix.append((r2, c2))						finalEdges[r2, c2] = 1		currentPixels = newPix 	return finalEdges if __name__==strv:	im = imread(strv, mode=strv) #Open image, convert to greyscale	finalEdges = CannyEdgeDetector(im)	imshow(finalEdges)"
"class MyClass(object):	@classmethod	def myClassMethod(self, x):		pass	@staticmethod	def myStaticMethod(x):		pass	def myMethod(self, x):		return 42 + x myInstance = MyClass() 
myInstance.myMethod(someParameter)
MyClass.myMethod(myInstance, someParameter)  
MyClass.myClassMethod(someParameter)MyClass.myStaticMethod(someParameter)
myInstance.myClassMethod(someParameter)myInstance.myStaticMethod(someParameter)"
"from math import factorialimport functools def memoize(func):    cache = {}    def memoized(key):        
        if key not in cache:            cache[key] = func(key)        return cache[key]    return functools.update_wrapper(memoized, func)  @memoizedef fact(n):    return factorial(n) def cat_direct(n):    return fact(2*n) // fact(n + 1) // fact(n) @memoize    def catR1(n):    return ( 1 if n == 0             else sum( catR1(i) * catR1(n - 1 - i)                       for i in range(n) ) ) @memoize    def catR2(n):    return ( 1 if n == 0             else ( ( 4 * n - 2 ) * catR2( n - 1) ) // ( n + 1 ) )  if __name__ == '__main__':    def pr(results):        fmt = '%-10s %-10s %-10s'        print ((fmt % tuple(c.__name__ for c in defs)).upper())        print (fmt % (('='*10,)*3))        for r in zip(*results):            print (fmt % r)      defs = (cat_direct, catR1, catR2)    results = [ tuple(c(i) for i in range(15)) for c in defs ]    pr(results)"
"class Isprime():    '''
    Extensible sieve of Eratosthenes
 
    >>> isprime.check(11)
    True
    >>> isprime.multiples
    {2, 4, 6, 8, 9, 10}
    >>> isprime.primes
    [2, 3, 5, 7, 11]
    >>> isprime(13)
    True
    >>> isprime.multiples
    {2, 4, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 18, 20, 21, 22}
    >>> isprime.primes
    [2, 3, 5, 7, 11, 13, 17, 19]
    >>> isprime.nmax
    22
    >>> 
    '''    multiples = {2}    primes = [2]    nmax = 2     def __init__(self, nmax):        if nmax > self.nmax:            self.check(nmax)     def check(self, n):        if type(n) == float:            if not n.is_integer(): return False            n = int(n)        multiples = self.multiples        if n <= self.nmax:            return n not in multiples        else:            
            primes, nmax = self.primes, self.nmax            newmax = max(nmax*2, n)            for p in primes:                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))            for i in range(nmax+1, newmax+1):                if i not in multiples:                    primes.append(i)                    multiples.update(range(i*2, newmax+1, i))            self.nmax = newmax            return n not in multiples     __call__ = check  def carmichael(p1):    ans = []    if isprime(p1):        for h3 in range(2, p1):            g = h3 + p1            for d in range(1, g):                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:                    p2 = 1 + ((p1 - 1)* g // d)                    if isprime(p2):                        p3 = 1 + (p1 * p2 // h3)                        if isprime(p3):                            if (p2 * p3) % (p1 - 1) == 1:                                #print('%i X %i X %i' % (p1, p2, p3))                                ans += [tuple(sorted((p1, p2, p3)))]    return ans isprime = Isprime(2) ans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))print(','.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))"
 import ctypes user32_dll = ctypes.cdll.LoadLibrary('User32.dll')print user32_dll.GetDoubleClickTime() 
"import ctypeslibc = ctypes.CDLL(strv)libc.strcmp(strv, strv)     
libc.strcmp(strv, strv) 
"
"def no_args():    pass
no_args() def fixed_args(x, y):    print('x=%r, y=%r' % (x, y))
fixed_args(1, 2)        
 ## Can also called them using the parameter names, in either order:fixed_args(y=2, x=1) ## Can also strv fixed_args() to a sequence:myargs=(1,2) 
fixed_args(*myargs) def opt_args(x=1):    print(x)
opt_args()              
opt_args(3.141)         
 def var_args(*v):    print(v)
var_args(1, 2, 3)       
var_args(1, (2,3))      
var_args()              
 ## Named argumentsfixed_args(y=2, x=1)    
 ## As a statementif 1:    no_args() ## First-class within an expressionassert no_args() is None def return_something():    return 1x = return_something() def is_builtin(x):	print(x.__name__ in dir(__builtins__))
is_builtin(pow)         
is_builtin(is_builtin)  
 
 def takes_anything(*args, **kwargs):    for each in args:        print(each)    for key, value in sorted(kwargs.items()):        print(strv % (key, value))    
    wrapped_fn(*args, **kwargs)    
    
 ## A subroutine is merely a function that has no explicit## return statement and will return None. ## Python uses strv.## See, for example, http://www.python-course.eu/passing_arguments.php ## For partial function application see:##   http://rosettacode.org/wiki/Partial_function_application#Python"
" import subprocesspx = subprocess.Popen(['python', '-c', 'import calendar; calendar.prcal(1969)'],                      stdout=subprocess.PIPE)cal = px.communicate()[0]print cal.upper() "
">>> class MyClassName:	__private = 123	non_private = __private * 2  >>> mine = MyClassName()>>> mine.non_private246>>> mine.__privateTraceback (most recent call last):  File strv, line 1, in <module>    mine.__privateAttributeError: 'MyClassName' object has no attribute '__private'>>> mine._MyClassName__private123>>> "
"from itertools import permutationsfrom random import shuffle try:    raw_inputexcept:    raw_input = inputtry:    from itertools import izipexcept:    izip = zip digits = '123456789'size = 4 def parse_score(score):    score = score.strip().split(',')    return tuple(int(s.strip()) for s in score) def scorecalc(guess, chosen):    bulls = cows = 0    for g,c in izip(guess, chosen):        if g == c:            bulls += 1        elif g in chosen:            cows += 1    return bulls, cows choices = list(permutations(digits, size))shuffle(choices)answers = []scores  = [] print (""Playing Bulls & Cows with %i unique digits"" % size) while True:    ans = choices[0]    answers.append(ans)    #print (strv % len(choices))    score = raw_input(strv                      % (len(answers), size, ''.join(ans)))    score = parse_score(score)    scores.append(score)    #print(strv % score)    found =  score == (size, 0)    if found:        print (strv)        break    choices = [c for c in choices if scorecalc(c, ans) == score]    if not choices:        print (strv)        print ('  ' +               '  '.join(strv % (''.join(an),sc)                           for an,sc in izip(answers, scores)))        break"
"def getitem(s, depth=0):    out = [strv]    while s:        c = s[0]        if depth and (c == ',' or c == '}'):            return out,s        if c == '{':            x = getgroup(s[1:], depth+1)            if x:                out,s = [a+b for a in out for b in x[0]], x[1]                continue        if c == '' and len(s) > 1:            s, c = s[1:], c + s[1]         out, s = [a+c for a in out], s[1:]     return out,s def getgroup(s, depth):    out, comma = [], False    while s:        g,s = getitem(s, depth)        if not s: break        out += g         if s[0] == '}':            if comma: return out, s[1:]            return ['{' + a + '}' for a in out], s[1:]         if s[0] == ',':            comma,s = True, s[1:]     return None 
for s in '''~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ , again }}more }cowbell!
{}} some }{,{{ edge, edge} }{ cases, {here} '''.split(''):    print """".join([s] + getitem(s)[0]) + """""
"def caesar(s, k, decode = False):	if decode: k = 26 - k	return strv.join([chr((ord(i) - 65 + k) % 26 + 65)				for i in s.upper()				if ord(i) >= 65 and ord(i) <= 90 ]) msg = strvprint msgenc = caesar(msg, 11)print encprint caesar(enc, 11, decode = True)import stringdef caesar(s, k, decode = False):   if decode: k = 26 - k   return s.translate(       string.maketrans(           string.ascii_uppercase + string.ascii_lowercase,           string.ascii_uppercase[k:] + string.ascii_uppercase[:k] +           string.ascii_lowercase[k:] + string.ascii_lowercase[:k]           )       )msg = strvprint msgenc = caesar(msg, 11)print encprint caesar(enc, 11, decode = True)import stringdef caesar(s, k = 13, decode = False, *, memo={}):  if decode: k = 26 - k  k = k % 26  table = memo.get(k)  if table is None:    table = memo[k] = str.maketrans(                        string.ascii_uppercase + string.ascii_lowercase,                        string.ascii_uppercase[k:] + string.ascii_uppercase[:k] +                        string.ascii_lowercase[k:] + string.ascii_lowercase[:k])  return s.translate(table) from string import ascii_uppercase as abc def caesar(s, k, decode = False):    trans = dict(zip(abc, abc[(k,26-k)[decode]:] + abc[:(k,26-k)[decode]]))    return ''.join(trans[L] for L in s.upper() if L in abc) msg = strvprint(caesar(msg, 11))print(caesar(caesar(msg, 11), 11, True)) "
">>> TrueTrue>>> not TrueFalse>>> 
>>> False + 00>>> True + 01>>> False + 0j0j>>> True * 3.1413.141>>> 
>>> not 0True>>> not not 0False>>> not 1234False>>> bool(0.0)False>>> bool(0j)False>>> bool(1+2j)True>>> 
>>> bool([])False>>> bool([None])True>>> 'I contain something' if (None,) else 'I am empty''I contain something'>>> bool({})False>>> bool(strv)False>>> bool(strv)True"
">>> import calendar>>> help(calendar.prcal)Help on method pryear in module calendar: pryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance    Print a years calendar. >>> calendar.prcal(1969)                                  1969       January                   February                   MarchMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su       1  2  3  4  5                      1  2                      1  2 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  913 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 1620 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 2327 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30                                                    31        April                      May                       JuneMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su    1  2  3  4  5  6                1  2  3  4                         1 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  814 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 1521 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 2228 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29                                                    30         July                     August                  SeptemberMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 1414 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 2121 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 2828 29 30 31               25 26 27 28 29 30 31      29 30       October                   November                  DecemberMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su       1  2  3  4  5                      1  2       1  2  3  4  5  6  7 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 1413 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 2120 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 2827 28 29 30 31            24 25 26 27 28 29 30      29 30 31"
"import pygame, sys, osfrom pygame.locals import *from random import randintpygame.init() MAXSPEED = 15SIZE = 3COLOR = (45, 90, 45)WINDOWSIZE = 400TIMETICK = 1MAXPART = 50 freeParticles = pygame.sprite.Group()tree = pygame.sprite.Group() window = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))pygame.display.set_caption(strv) screen = pygame.display.get_surface()  class Particle(pygame.sprite.Sprite):    def __init__(self, vector, location, surface):        pygame.sprite.Sprite.__init__(self)        self.vector = vector        self.surface = surface        self.accelerate(vector)        self.add(freeParticles)        self.rect = pygame.Rect(location[0], location[1], SIZE, SIZE)        self.surface.fill(COLOR, self.rect)     def onEdge(self):        if self.rect.left <= 0:            self.vector = (abs(self.vector[0]), self.vector[1])        elif self.rect.top <= 0:            self.vector = (self.vector[0], abs(self.vector[1]))        elif self.rect.right >= WINDOWSIZE:            self.vector = (-abs(self.vector[0]), self.vector[1])        elif self.rect.bottom >= WINDOWSIZE:            self.vector = (self.vector[0], -abs(self.vector[1]))     def update(self):        if freeParticles in self.groups():            self.surface.fill((0,0,0), self.rect)            self.remove(freeParticles)            if pygame.sprite.spritecollideany(self, freeParticles):                self.accelerate((randint(-MAXSPEED, MAXSPEED),                                  randint(-MAXSPEED, MAXSPEED)))                self.add(freeParticles)            elif pygame.sprite.spritecollideany(self, tree):                self.stop()            else:                self.add(freeParticles)             self.onEdge()             if (self.vector == (0,0)) and tree not in self.groups():                self.accelerate((randint(-MAXSPEED, MAXSPEED),                                  randint(-MAXSPEED, MAXSPEED)))            self.rect.move_ip(self.vector[0], self.vector[1])        self.surface.fill(COLOR, self.rect)     def stop(self):        self.vector = (0,0)        self.remove(freeParticles)        self.add(tree)     def accelerate(self, vector):        self.vector = vector NEW = USEREVENT + 1TICK = USEREVENT + 2 pygame.time.set_timer(NEW, 50)pygame.time.set_timer(TICK, TIMETICK)  def input(events):    for event in events:        if event.type == QUIT:            sys.exit(0)        elif event.type == NEW and (len(freeParticles) < MAXPART):            Particle((randint(-MAXSPEED,MAXSPEED),                      randint(-MAXSPEED,MAXSPEED)),                     (randint(0, WINDOWSIZE), randint(0, WINDOWSIZE)),                      screen)        elif event.type == TICK:            freeParticles.update()  half = WINDOWSIZE/2tenth = WINDOWSIZE/10 root = Particle((0,0),                (randint(half-tenth, half+tenth),                  randint(half-tenth, half+tenth)), screen)root.stop() while True:    input(pygame.event.get())    pygame.display.flip()"
"class BitWriter(object):    def __init__(self, f):        self.accumulator = 0        self.bcount = 0        self.out = f     def __del__(self):        try:            self.flush()        except ValueError:   
            pass     def _writebit(self, bit):        if self.bcount == 8:            self.flush()        if bit > 0:            self.accumulator |= 1 << 7-self.bcount        self.bcount += 1     def writebits(self, bits, n):        while n > 0:            self._writebit(bits & 1 << n-1)            n -= 1     def flush(self):        self.out.write(bytearray([self.accumulator]))        self.accumulator = 0        self.bcount = 0  class BitReader(object):    def __init__(self, f):        self.input = f        self.accumulator = 0        self.bcount = 0        self.read = 0     def _readbit(self):        if not self.bcount:            a = self.input.read(1)            if a:                self.accumulator = ord(a)            self.bcount = 8            self.read = len(a)        rv = (self.accumulator & (1 << self.bcount-1)) >> self.bcount-1        self.bcount -= 1        return rv     def readbits(self, n):        v = 0        while n > 0:            v = (v << 1) | self._readbit()            n -= 1        return v if __name__ == '__main__':    import os    import sys    
    module_name = os.path.splitext(os.path.basename(__file__))[0]    bitio = __import__(module_name)     with open('bitio_test.dat', 'wb') as outfile:        writer = bitio.BitWriter(outfile)        chars = '12345abcde'        for ch in chars:            writer.writebits(ord(ch), 7)     with open('bitio_test.dat', 'rb') as infile:        reader = bitio.BitReader(infile)        chars = []        while True:            x = reader.readbits(7)            if reader.read == 0:                break            chars.append(chr(x))        print(''.join(chars))import sysimport bitio o = bitio.BitWriter(sys.stdout)c = sys.stdin.read(1)while len(c) > 0:    o.writebits(ord(c), 7)    c = sys.stdin.read(1)import sysimport bitio r = bitio.BitReader(sys.stdin)while True:    x = r.readbits(7)    if not r.read:  
        break    sys.stdout.write(chr(x))"
"def bitwise(a, b):        print 'a and b:', a & b        print 'a or b:', a | b        print 'a xor b:', a ^ b        print 'not a:', ~a        print 'a << b:', a << b 
        print 'a >> b:', a >> b 

x = x << n & 0xff
x = x << n & 0xffff
x = x << n & 0xffffffff
x = x << n & 0xffffffffffffffffdef bitstr(n, width=None):   strvreturn the binary representation of n as a string and
      optionally zero-fill (pad) it to a given length
   strv   result = list()   while n:      result.append(str(n%2))      n = int(n/2)   if (width is not None) and len(result) < width:      result.extend(['0'] * (width - len(result)))   result.reverse()   return ''.join(result) def mask(n):   strvReturn a bitmask of length n (suitable for masking against an
      int to coerce the size to a given length)
   strv   if n >= 0:       return 2**n - 1   else:       return 0 def rol(n, rotations=1, width=8):    strvReturn a given number of bitwise left rotations of an integer n,
       for a given bit field width.
    strv    rotations %= width    if rotations < 1:        return n    n &= mask(width) ## Should it be an error to truncate here?    return ((n << rotations) & mask(width)) | (n >> (width - rotations)) def ror(n, rotations=1, width=8):    strvReturn a given number of bitwise right rotations of an integer n,
       for a given bit field width.
    strv    rotations %= width    if rotations < 1:        return n    n &= mask(width)    return (n >> rotations) | ((n << (width - rotations)) & mask(width))"
"
 
import io ppmtxt = '''P3


4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
'''  def tokenize(f):    for line in f:        if line[0] != '#':            for t in line.split():                yield t def ppmp3tobitmap(f):    t = tokenize(f)    nexttoken = lambda : next(t)    assert 'P3' == nexttoken(), 'Wrong filetype'    width, height, maxval = (int(nexttoken()) for i in range(3))    bitmap = Bitmap(width, height, Colour(0, 0, 0))    for h in range(height-1, -1, -1):        for w in range(0, width):            bitmap.set(w, h, Colour( *(int(nexttoken()) for i in range(3))))     return bitmap print('Original Colour PPM file')print(ppmtxt)ppmfile = io.StringIO(ppmtxt)bitmap = ppmp3tobitmap(ppmfile)print('Grey PPM:')bitmap.togreyscale()ppmfileout = io.StringIO('')bitmap.writeppmp3(ppmfileout)print(ppmfileout.getvalue())  '''
The print statements above produce the following output:
 
Original Colour PPM file
P3


4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
 
Grey PPM:
P3


4 4
11
    0  0  0    0  0  0    0  0  0    4  4  4
    0  0  0   11 11 11    0  0  0    0  0  0
    0  0  0    0  0  0   11 11 11    0  0  0
    4  4  4    0  0  0    0  0  0    0  0  0
 
'''"
" 
import ioppmfileout = io.StringIO('') def writeppmp3(self, f):    self.writeppm(f, ppmformat='P3') def writeppm(self, f, ppmformat='P6'):    assert ppmformat in ['P3', 'P6'], 'Format wrong'    magic = ppmformat + ''    comment = '# generated from Bitmap.writeppm'    maxval = max(max(max(bit) for bit in row) for row in self.map)    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'    if ppmformat == 'P6':        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))        maxval = 255    else:        fwrite = f.write        numsize=len(str(maxval))    fwrite(magic)    fwrite(comment)    fwrite('%i %i%i' % (self.width, self.height, maxval))    for h in range(self.height-1, -1, -1):        for w in range(self.width):            r, g, b = self.get(w, h)            if ppmformat == 'P3':                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))            else:                fwrite('%c%c%c' % (r, g, b))        if ppmformat == 'P3':            fwrite('') Bitmap.writeppmp3 = writeppmp3Bitmap.writeppm = writeppm 
bitmap = Bitmap(4, 4, black)bitmap.fillrect(1, 0, 1, 2, white)bitmap.set(3, 3, Colour(127, 0, 63))
bitmap.writeppmp3(ppmfileout)
print(ppmfileout.getvalue()) '''
The print statement above produces the following output :
 
P3


4 4
255
     0   0   0     0   0   0     0   0   0   127   0  63
     0   0   0     0   0   0     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
 
''' 
ppmfileout = open('tmp.ppm', 'wb')bitmap.writeppm(ppmfileout)ppmfileout.close() "
"def circle(self, x0, y0, radius, colour=black):    f = 1 - radius    ddf_x = 1    ddf_y = -2 * radius    x = 0    y = radius    self.set(x0, y0 + radius, colour)    self.set(x0, y0 - radius, colour)    self.set(x0 + radius, y0, colour)    self.set(x0 - radius, y0, colour)     while x < y:        if f >= 0:             y -= 1            ddf_y += 2            f += ddf_y        x += 1        ddf_x += 2        f += ddf_x            self.set(x0 + x, y0 + y, colour)        self.set(x0 - x, y0 + y, colour)        self.set(x0 + x, y0 - y, colour)        self.set(x0 - x, y0 - y, colour)        self.set(x0 + y, y0 + x, colour)        self.set(x0 - y, y0 + x, colour)        self.set(x0 + y, y0 - x, colour)        self.set(x0 - y, y0 - x, colour)Bitmap.circle = circle bitmap = Bitmap(25,25)bitmap.circle(x0=12, y0=12, radius=12)bitmap.chardisplay() '''
The origin, 0,0; is the lower left, with x increasing to the right,
and Y increasing upwards.
 
The program above produces the following display :
 
+-------------------------+
|         @@@@@@@         |
|       @@       @@       |
|     @@           @@     |
|    @               @    |
|   @                 @   |
|  @                   @  |
|  @                   @  |
| @                     @ |
| @                     @ |
|@                       @|
|@                       @|
|@                       @|
|@                       @|
|@                       @|
|@                       @|
|@                       @|
| @                     @ |
| @                     @ |
|  @                   @  |
|  @                   @  |
|   @                 @   |
|    @               @    |
|     @@           @@     |
|       @@       @@       |
|         @@@@@@@         |
+-------------------------+
''' "
"def cubicbezier(self, x0, y0, x1, y1, x2, y2, x3, y3, n=20):    pts = []    for i in range(n+1):        t = i / n        a = (1. - t)**3        b = 3. * t * (1. - t)**2        c = 3.0 * t**2 * (1.0 - t)        d = t**3         x = int(a * x0 + b * x1 + c * x2 + d * x3)        y = int(a * y0 + b * y1 + c * y2 + d * y3)        pts.append( (x, y) )    for i in range(n):        self.line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1])Bitmap.cubicbezier = cubicbezier bitmap = Bitmap(17,17)bitmap.cubicbezier(16,1, 1,4, 3,16, 15,11)bitmap.chardisplay()  '''
The origin, 0,0; is the lower left, with x increasing to the right,
and Y increasing upwards.
 
The chardisplay above produces the following output :
+-----------------+
|                 |
|                 |
|                 |
|                 |
|         @@@@    |
|      @@@    @@@ |
|     @           |
|     @           |
|     @           |
|     @           |
|      @          |
|      @          |
|       @         |
|        @        |
|         @@@@    |
|             @@@@|
|                 |
+-----------------+
'''"
"majors   = 'north east south west'.split()majors   *= 2 
quarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')quarter2 = [p.replace('NE','EN') for p in quarter1] def degrees2compasspoint(d):    d = (d % 360) + 360/64    majorindex, minor = divmod(d, 90.)    majorindex = int(majorindex)    minorindex  = int( (minor*4) // 45 )    p1, p2 = majors[majorindex: majorindex+2]    if p1 in {'north', 'south'}:        q = quarter1    else:        q = quarter2    return q[minorindex].replace('N', p1).replace('E', p2).capitalize() if __name__ == '__main__':    for i in range(33):        d = i * 11.25        m = i % 3        if   m == 1: d += 5.62        elif m == 2: d -= 5.62        n = i % 32 + 1        print( '%2i %-18s %7.2f°' % (n, degrees2compasspoint(d), d) )"
"#!/usr/bin/env python3 import binasciiimport functoolsimport hashlib digits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz' def b58(n):    return b58(n//58) + digits58[n%58:n%58+1] if n else b'' def public_point_to_address(x, y):    c = b'04' + binascii.unhexlify(x) + binascii.unhexlify(y)    r = hashlib.new('ripemd160')    r.update(hashlib.sha256(c).digest())    c = b'00' + r.digest()    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4])) if __name__ == '__main__':    print(public_point_to_address(        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))"
" import Imagedef FloodFill( fileName, initNode, targetColor, replaceColor ):   img = Image.open( fileName )   pix = img.load()   xsize, ysize = img.size   Q = []   if pix[ initNode[0], initNode[1] ] != targetColor:      return img   Q.append( initNode )   while Q != []:      node = Q.pop(0)      if pix[ node[0], node[1] ] == targetColor:         W = list( node )         if node[0] + 1 < xsize:            E = list( [ node[0] + 1, node[1] ] )         else:            E = list( node )      
      while pix[ W[0], W[1] ] == targetColor:         pix[ W[0], W[1] ] = replaceColor         if W[1] + 1 < ysize:            if pix[ W[0], W[1] + 1 ] == targetColor:               Q.append( [ W[0], W[1] + 1 ] )         if W[1] - 1 >= 0:            if pix[ W[0], W[1] - 1 ] == targetColor:               Q.append( [ W[0], W[1] - 1 ] )         if W[0] - 1 >= 0:            W[0] = W[0] - 1         else:            break      
      while pix[ E[0], E[1] ] == targetColor:         pix[ E[0], E[1] ] = replaceColor         if E[1] + 1 < ysize:            if pix[ E[0], E[1] + 1 ] == targetColor:               Q.append( [ E[0], E[1] + 1 ] )         if E[1] - 1 >= 0:            if pix[ E[0], E[1] - 1 ] == targetColor:               Q.append( [ E[0], E[1] -1 ] )         if E[0] + 1 < xsize:            E[0] = E[0] + 1         else:            break      return img  



img = FloodFill( strv, [55,55], (0,0,0,255), (255,255,255,255) )#The resulting image is saved as Filled.pngimg.save( strv ) "
"def line(self, x0, y0, x1, y1):    strv    dx = abs(x1 - x0)    dy = abs(y1 - y0)    x, y = x0, y0    sx = -1 if x0 > x1 else 1    sy = -1 if y0 > y1 else 1    if dx > dy:        err = dx / 2.0        while x != x1:            self.set(x, y)            err -= dy            if err < 0:                y += sy                err += dx            x += sx    else:        err = dy / 2.0        while y != y1:            self.set(x, y)            err -= dx            if err < 0:                x += sx                err += dy            y += sy            self.set(x, y)Bitmap.line = line bitmap = Bitmap(17,17)for points in ((1,8,8,16),(8,16,16,8),(16,8,8,1),(8,1,1,8)):    bitmap.line(*points)bitmap.chardisplay() '''
The origin, 0,0; is the lower left, with x increasing to the right,
and Y increasing upwards.
 
The chardisplay above produces the following output :
+-----------------+
|        @        |
|       @ @       |
|      @   @      |
|     @     @     |
|    @       @    |
|    @        @   |
|   @          @  |
|  @            @ |
| @              @|
|  @            @ |
|   @          @  |
|    @       @@   |
|     @     @     |
|      @   @      |
|       @ @       |
|        @        |
|                 |
+-----------------+
''' from fractions import Fraction def line(self, x0, y0, x1, y1):    rev = reversed    if abs(y1 - y0) <= abs(x1 - x0):        x0, y0, x1, y1 = y0, x0, y1, x1        rev = lambda x: x    if x1 < x0:        x0, y0, x1, y1 = x1, y1, x0, y0    leny = abs(y1 - y0)    for i in range(leny + 1):        self.set(*rev((round(Fraction(i, leny) * (x1 - x0)) + x0, (1 if y1 > y0 else -1) * i + y0))) Bitmap.line = line 
 "
"from hashlib import sha256 digits58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz' def decode_base58(bc, length):    n = 0    for char in bc:        n = n * 58 + digits58.index(char)    return n.to_bytes(length, 'big')def check_bc(bc):    bcbytes = decode_base58(bc, 25)    return bcbytes[-4:] == sha256(sha256(bcbytes[:-4]).digest()).digest()[:4] print(check_bc('1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i'))print(check_bc(strv))>>> n = 2491969579123783355964723219455906992268673266682165637887>>> length = 25>>> list( reversed(range(length)) )[24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]>>> assert n.to_bytes(length, 'big') == bytes( (n >> i*8) & 0xff for i in reversed(range(length)))>>> "
" from random import randint def equal_birthdays(sharers=2, groupsize=23, rep=100000):    'Note: 4 sharing common birthday may have 2 dates shared between two people each'     g = range(groupsize)    sh = sharers - 1    eq = sum((groupsize - len(set(randint(1,365) for i in g)) >= sh)             for j in range(rep))    return (eq * 100.) / rep def equal_birthdays(sharers=2, groupsize=23, rep=100000):    'Note: 4 sharing common birthday must all share same common day'     g = range(groupsize)    sh = sharers - 1    eq = 0    for j in range(rep):        group = [randint(1,365) for i in g]        if (groupsize - len(set(group)) >= sh and            any( group.count(member) >= sharers for member in set(group))):            eq += 1    return (eq * 100.) / rep group_est = [2]for sharers in (2, 3, 4, 5):    groupsize = group_est[-1]+1    while equal_birthdays(sharers, groupsize, 100) < 50.:        
        groupsize += 1    for groupsize in range(int(groupsize - (groupsize - group_est[-1])/4.), groupsize + 999):        
        eq = equal_birthdays(sharers, groupsize, 250)        if eq > 50.:            break    for groupsize in range(groupsize - 1, groupsize +999):        
        eq = equal_birthdays(sharers, groupsize, 50000)        if eq > 50.:            break    group_est.append(groupsize)    print(strv % (sharers, groupsize, eq))from collections import defaultdictdays = 365 def find_half(c):     
    
    def inc_people(din, over):        
        
         dout,over = defaultdict(int), over * days        for k,s in din.items():            for i,v in enumerate(k):                if v + 1 >= c:                    over += s                else:                    dout[tuple(sorted(k[0:i] + (v + 1,) + k[i+1:]))] += s            dout[(1,) + k] += s * (days - len(k))        return dout, over     d, combos, good, n = {():1}, 1, 0, 0     
    
    while True:        n += 1        combos *= days 
        d,good = inc_people(d, good)         #!!! print d.items()        if good * 2 >= combos:            return n, good, combos 


for x in range(2, 5):    n, good, combos = find_half(x)    print strv% (x, n, good, combos) 

def fact(n, cache={0:1}):    if not n in cache:        cache[n] = n * fact(n - 1)    return cache[n] 
def perm(n, k, cache={}):    if not (n,k) in cache:        cache[(n,k)] = fact(n) / fact(n - k)    return cache[(n,k)] def choose(n, k, cache={}):    if not (n,k) in cache:        cache[(n,k)] = perm(n, k) / fact(k)    return cache[(n, k)] 

def combos(d, p, m, cache={}):    if not p: return 1    if not m: return 0    if p <= m: return d**p        
     k = (d, p, m)    if not k in cache:        result = 0        for x in range(0, p//m + 1):            c = combos(d - x, p - x * m, m - 1)            
            if c: result += c * choose(d, x) * perm(p, x * m) / fact(m)**x        cache[k] = result     return cache[k] def find_half(m):    n = 0    while True:        n += 1        total = 365 ** n        c = total - combos(365, n, m - 1)        if c * 2 >= total:            print strv % (n, m, c, total)            return for x in range(2, 6): find_half(x)"
"#!/bin/pythonimport numpy as npfrom scipy.misc import imread, imshowfrom scipy import ndimage def GetBilinearPixel(imArr, posX, posY):	out = [] 	#Get integer and fractional parts of numbers	modXi = int(posX)	modYi = int(posY)	modXf = posX - modXi	modYf = posY - modYi	modXiPlusOneLim = min(modXi+1,imArr.shape[1]-1)	modYiPlusOneLim = min(modYi+1,imArr.shape[0]-1) 	#Get pixels in four corners	for chan in range(imArr.shape[2]):		bl = imArr[modYi, modXi, chan]		br = imArr[modYi, modXiPlusOneLim, chan]		tl = imArr[modYiPlusOneLim, modXi, chan]		tr = imArr[modYiPlusOneLim, modXiPlusOneLim, chan] 		#Calculate interpolation		b = modXf * br + (1. - modXf) * bl		t = modXf * tr + (1. - modXf) * tl		pxf = modYf * t + (1. - modYf) * b		out.append(int(pxf+0.5)) 	return out if __name__==strv: 	im = imread(strv, mode=strv)	enlargedShape = list(map(int, [im.shape[0]*1.6, im.shape[1]*1.6, im.shape[2]]))	enlargedImg = np.empty(enlargedShape, dtype=np.uint8)	rowScale = float(im.shape[0]) / float(enlargedImg.shape[0])	colScale = float(im.shape[1]) / float(enlargedImg.shape[1]) 	for r in range(enlargedImg.shape[0]):		for c in range(enlargedImg.shape[1]):			orir = r * rowScale #Find position in original image			oric = c * colScale			enlargedImg[r, c] = GetBilinearPixel(im, oric, orir) 	imshow(enlargedImg) "
"s1 = ""A 'string' literal ""s2 = 'You may use any of  or "" as delimiter's3 = strvThis text 
   goes over several lines
       up to the closing triple quotestrvs = strvt = strvu = s + t   
assert strv == 'Hello'assert '' == '09'assert strv < strvassert strv >= strvif x=='': print strvif not x: print strvtxt = strvtxt += '07'
txt = strvassert txt[4] == strvassert txt[0:4] == strvassert txt[:4] == strv 
assert txt[5:9] == strvassert txt[5:] == strv 
txt = strvassert txt[-1] == strvassert txt[-4:] == strvv1 = strvv2 = v1.replace(strv, strv)print v2 
v1 = strv v2 = strvmsg = v1 + strv + v2items = [strv, strv, strv, strv, strv]joined = strv.join(items)print joined

line = strvfields = line.split(',')print fields

s1 = b""A 'byte string' literal ""s2 = b'You may use any of  or "" as delimiter's3 = bstrvThis text 
   goes over several lines
       up to the closing triple quotestrvx = b'abc'x[0] 
x = b'abc'list(x) 
bytes([97, 98, 99]) 
"
">>> for i in range(16): print('{0:b}'.format(i)) 01101110010111011110001001101010111100110111101111>>> for i in range(16): print(bin(i)) 0b00b10b100b110b1000b1010b1100b1110b10000b10010b10100b10110b11000b11010b11100b1111>>> oct2bin = {'0': '000', '1': '001', '2': '010', '3': '011', '4': '100', '5': '101', '6': '110', '7': '111'}>>> bin = lambda n: ''.join(oct2bin[octdigit] for octdigit in '%o' % n).lstrip('0') or '0'>>> for i in range(16): print(bin(i)) 01101110010111011110001001101010111100110111101111"
"import random def count(w1,wnew):    return sum(c1==c2 for c1,c2 in zip(w1, wnew)) def best_shuffle(w):    wnew = list(w)    n = len(w)    rangelists = (list(range(n)), list(range(n)))    for r in rangelists:        random.shuffle(r)    rangei, rangej = rangelists    for i in rangei:        for j in rangej:            if i != j and wnew[j] != wnew[i] and w[i] != wnew[j] and w[j] != wnew[i]:                wnew[j], wnew[i] = wnew[i], wnew[j]                break    wnew = ''.join(wnew)    return wnew, count(w, wnew)  if __name__ == '__main__':    test_words = ('tree abracadabra seesaw elk grrrrrr up a '                   + 'antidisestablishmentarianism hounddogs').split()    test_words += ['aardvarks are ant eaters', 'immediately', 'abba']    for w in test_words:        wnew, c = best_shuffle(w)        print(strv % (w, wnew, c))#!/usr/bin/env python def best_shuffle(s):    
    from collections import defaultdict    count = defaultdict(int)    for c in s:        count[c] += 1     
    r = []    for x in s:        
        best = None        rankb = -2        for c, rankc in count.items():            
            
            
            if c == x: rankc = -1            if rankc > rankb:                best = c                rankb = rankc         
        r.append(best)        count[best] -= 1        if count[best] >= 0: del count[best]     
    
    i = len(s) - 1    if r[i] == s[i]:        for j in range(i):            if r[i] != s[j] and r[j] != s[i]:                r[i], r[j] = r[j], r[i]                break     
    
    
    r = ''.join(r)     score = sum(x == y for x, y in zip(r, s))     return (r, score) for s in strv, strv, strv, strv, strv, strv:    shuffled, score = best_shuffle(s)    print(strv % (s, shuffled, score))"
"def binary_search(l, value):    low = 0    high = len(l)-1    while low <= high:         mid = (low+high)//2        if l[mid] > value: high = mid-1        elif l[mid] < value: low = mid+1        else: return mid    return -1def binary_search(l, value, low = 0, high = -1):    if not l: return -1    if(high == -1): high = len(l)-1    if low >= high:        if l[low] == value: return low        else: return -1    mid = (low+high)//2    if l[mid] > value: return binary_search(l, value, low, mid-1)    elif l[mid] < value: return binary_search(l, value, mid+1, high)    else: return midindex = bisect.bisect_left(list, item) 
index = bisect.bisect_right(list, item) 
index = bisect.bisect(list, item) 
 
bisect.insort_left(list, item)bisect.insort_right(list, item)bisect.insort(list, item)from bisect import bisect_left def binary_search(a, x, lo=0, hi=None):   
    hi = hi if hi is not None else len(a) 
    pos = bisect_left(a,x,lo,hi)          
    return (pos if pos != hi and a[pos] == x else -1) 
def binary_search(l, value):    low = 0    high = len(l)-1    while low + 1 < high:        mid = (low+high)//2        if l[mid] > value:            high = mid        elif l[mid] < value:            low = mid        else:            return mid    return high if abs(l[high] - value) < abs(l[low] - value) else low"
"from fractions import Fraction as Fr def bernoulli(n):    A = [0] * (n+1)    for m in range(n+1):        A[m] = Fr(1, m+1)        for j in range(m, 0, -1):          A[j-1] = j*(A[j-1] - A[j])    return A[0] 
 bn = [(i, bernoulli(i)) for i in range(61)]bn = [(i, b) for i,b in bn if b]width = max(len(str(b.numerator)) for i,b in bn)for i,b in bn:    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))def bernoulli2():    A, m = [], 0    while True:        A.append(Fr(1, m+1))        for j in range(m, 0, -1):          A[j-1] = j*(A[j-1] - A[j])        yield A[0] 
        m += 1 bn2 = [ix for ix in zip(range(61), bernoulli2())]bn2 = [(i, b) for i,b in bn2 if b]width = max(len(str(b.numerator)) for i,b in bn2)for i,b in bn2:    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))"
import urllibimport base64 data = urllib.urlopen('http://rosettacode.org/favicon.ico').read()print base64.b64encode(data)
"from __future__ import divisionfrom itertools import islice, countfrom collections import Counterfrom math import log10from random import randint expected = [log10(1+1/d) for d in range(1,10)] def fib():    a,b = 1,1    while True:        yield a        a,b = b,a+b 
def power_of_threes():    return (3**k for k in count(0)) def heads(s):    for a in s: yield int(str(a)[0]) def show_dist(title, s):    c = Counter(s)    size = sum(c.values())    res = [c[d]/size for d in range(1,10)]     print(""%s Benfords deviation"" % title)    for r, e in zip(res, expected):        print(strv % (r*100., e*100., abs(r - e)*100.)) def rand1000():    while True: yield randint(1,9999) if __name__ == '__main__':    show_dist(strv, islice(heads(fib()), 1000))    show_dist(strv, islice(heads(power_of_threes()), 1000))     
    show_dist(strv, islice(heads(rand1000()), 10000))"
"  import randomfrom PIL import Image  class BarnsleyFern(object):    def __init__(self, img_width, img_height, paint_color=(0, 150, 0),                 bg_color=(255, 255, 255)):        self.img_width, self.img_height = img_width, img_height        self.paint_color = paint_color        self.x, self.y = 0, 0        self.age = 0         self.fern = Image.new('RGB', (img_width, img_height), bg_color)        self.pix = self.fern.load()        self.pix[self.scale(0, 0)] = paint_color     def scale(self, x, y):        h = (x + 2.182)*(self.img_width - 1)/4.8378        k = (9.9983 - y)*(self.img_height - 1)/9.9983        return h, k     def transform(self, x, y):        rand = random.uniform(0, 100)        if rand < 1:            return 0, 0.16*y        elif 1 <= rand < 86:            return 0.85*x + 0.04*y, -0.04*x + 0.85*y + 1.6        elif 86 <= rand < 93:            return 0.2*x - 0.26*y, 0.23*x + 0.22*y + 1.6        else:            return -0.15*x + 0.28*y, 0.26*x + 0.24*y + 0.44     def iterate(self, iterations):        for _ in range(iterations):            self.x, self.y = self.transform(self.x, self.y)            self.pix[self.scale(self.x, self.y)] = self.paint_color        self.age += iterations fern = BarnsleyFern(500, 500)fern.iterate(1000000)fern.fern.show()  "
"class BalancedTernary:    
     str2dig = {'+': 1, '-': -1, '0': 0} 
    dig2str = {1: '+', -1: '-', 0: '0'} 
    table = ((0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)) 
     def __init__(self, inp):        if isinstance(inp, str):            self.digits = [BalancedTernary.str2dig[c] for c in reversed(inp)]        elif isinstance(inp, int):            self.digits = self._int2ternary(inp)        elif isinstance(inp, BalancedTernary):            self.digits = list(inp.digits)        elif isinstance(inp, list):            if all(d in (0, 1, -1) for d in inp):                self.digits = list(inp)            else:                raise ValueError(strv)        else:            raise TypeError(strv)     @staticmethod    def _int2ternary(n):        if n == 0: return []        if (n % 3) == 0: return [0] + BalancedTernary._int2ternary(n // 3)        if (n % 3) == 1: return [1] + BalancedTernary._int2ternary(n // 3)        if (n % 3) == 2: return [-1] + BalancedTernary._int2ternary((n + 1) // 3)     def to_int(self):        return reduce(lambda y,x: x + 3 * y, reversed(self.digits), 0)     def __repr__(self):        if not self.digits: return strv        return strv.join(BalancedTernary.dig2str[d] for d in reversed(self.digits))     @staticmethod    def _neg(digs):        return [-d for d in digs]     def __neg__(self):        return BalancedTernary(BalancedTernary._neg(self.digits))     @staticmethod    def _add(a, b, c=0):        if not (a and b):            if c == 0:                return a or b            else:                return BalancedTernary._add([c], a or b)        else:            (d, c) = BalancedTernary.table[3 + (a[0] if a else 0) + (b[0] if b else 0) + c]            res = BalancedTernary._add(a[1:], b[1:], c)            
            if res or d != 0:                return [d] + res            else:                return res     def __add__(self, b):        return BalancedTernary(BalancedTernary._add(self.digits, b.digits))     def __sub__(self, b):        return self + (-b)     @staticmethod    def _mul(a, b):        if not (a and b):            return []        else:            if   a[0] == -1: x = BalancedTernary._neg(b)            elif a[0] ==  0: x = []            elif a[0] ==  1: x = b            else: assert False            y = [0] + BalancedTernary._mul(a[1:], b)            return BalancedTernary._add(x, y)     def __mul__(self, b):        return BalancedTernary(BalancedTernary._mul(self.digits, b.digits))  def main():    a = BalancedTernary(strv)    print strv, a.to_int(), a     b = BalancedTernary(-436)    print strv, b.to_int(), b     c = BalancedTernary(strv)    print strv, c.to_int(), c     r = a * (b - c)    print strv, r.to_int(), r main()"
"import string sometext = strvAll children, except one, grow up. They soon know that they will grow
up, and the way Wendy knew was this. One day when she was two years old
she was playing in a garden, and she plucked another flower and ran with
it to her mother. I suppose she must have looked rather delightful, for
Mrs. Darling put her hand to her heart and cried, ""Oh, why can't you
remain like this for ever!"" This was all that passed between them on
the subject, but henceforth Wendy knew that she must grow up. You always
know after you are two. Two is the beginning of the end.
 
Of course they lived at 14 [their house number on their street], and
until Wendy came her mother was the chief one. She was a lovely lady,
with a romantic mind and such a sweet mocking mouth. Her romantic
mind was like the tiny boxes, one within the other, that come from the
puzzling East, however many you discover there is always one more; and
her sweet mocking mouth had one kiss on it that Wendy could never get,
though there it was, perfectly conspicuous in the right-hand corner.strv.lower() lc2bin = {ch: '{:05b}'.format(i)           for i, ch in enumerate(string.ascii_lowercase + ' .')}bin2lc = {val: key for key, val in lc2bin.items()} phrase = 'Rosetta code Bacon cipher example secret phrase to encode in the capitalisation of peter pan'.lower() def to_5binary(msg):    return ( ch == '1' for ch in ''.join(lc2bin.get(ch, '') for ch in msg.lower())) def encrypt(message, text):    bin5 = to_5binary(message)    textlist = list(text.lower())    out = []    for capitalise in bin5:        while textlist:            ch = textlist.pop(0)            if ch.isalpha():                if capitalise:                    ch = ch.upper()                out.append(ch)                break            else:                out.append(ch)        else:            raise Exception('ERROR: Ran out of characters in sometext')    return ''.join(out) + '...'  def  decrypt(bacontext):    binary = []    bin5 = []    out = []    for ch in bacontext:        if ch.isalpha():            binary.append('1' if ch.isupper() else '0')            if len(binary) == 5:                bin5 = ''.join(binary)                out.append(bin2lc[bin5])                binary = []    return ''.join(out)  print('PLAINTEXT = %s' % phrase)encrypted = encrypt(phrase, sometext)print('ENCRYPTED = %s' % encrypted)decrypted = decrypt(encrypted)print('DECRYPTED = %s' % decrypted)assert phrase == decrypted, 'Round-tripping error'"
" 

 n=0 
 

 while n**2 % 1000000 != 269696:     
    # %    -> 'modulo' or remainer after division    # !=   -> not equal to     n += 1 
 print(n) 
 "
">>> def gen(N):...     txt = ['[', ']'] * N...     random.shuffle( txt )...     return ''.join(txt)... >>> def balanced(txt):...     braced = 0...     for ch in txt:...         if ch == '[': braced += 1...         if ch == ']':...             braced -= 1...             if braced < 0: return False...     return braced == 0... >>> for txt in (gen(N) for N in range(10)):...     print (strv % (txt, '' if balanced(txt) else ' not'))... ''                     is balanced'[]'                   is balanced'[][]'                 is balanced'][[[]]'               is not balanced'[]][[][]'             is not balanced'[][[][]]]['           is not balanced'][]][][[]][['         is not balanced'[[]]]]][]][[[['       is not balanced'[[[[]][]]][[][]]'     is balanced'][[][[]]][]]][[[[]'   is not balanced"
">>> from math import sqrt>>> def qmean(num):	return sqrt(sum(n*n for n in num)/len(num)) >>> qmean(range(1,11))6.2048368229954285"
">>> from collections import defaultdict>>> def modes(values):	count = defaultdict(int)	for v in values:		count[v] +=1	best = max(count.values())	return [k for k,v in count.items() if v == best] >>> modes([1,3,6,6,6,6,7,7,12,12,17])[6]>>> modes((1,1,2,4,4))[1, 4]>>> from collections import Counter>>> def modes(values):	count = Counter(values)	best = max(count.values())	return [k for k,v in count.items() if v == best] >>> modes([1,3,6,6,6,6,7,7,12,12,17])[6]>>> modes((1,1,2,4,4))[1, 4]def onemode(values):    return max(set(values), key=values.count)"
"from operator import mulfrom functools import reduce def amean(num):	return sum(num)/len(num) def gmean(num):	return reduce(mul, num, 1)**(1/len(num)) def hmean(num):	return len(num)/sum(1/n for n in num) numbers = range(1,11) 
a, g, h = amean(numbers), gmean(numbers), hmean(numbers)print(a, g, h)assert( a >= g >= h ) "
"from cmath import rect, phasefrom math import radians, degrees  def mean_angle(deg):    return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg))) def mean_time(times):    t = (time.split(':') for time in times)    seconds = ((float(s) + int(m) * 60 + int(h) * 3600)                for h, m, s in t)    day = 24 * 60 * 60    to_angles = [s * 360. / day for s in seconds]    mean_as_angle = mean_angle(to_angles)    mean_seconds = mean_as_angle * day / 360.    if mean_seconds < 0:        mean_seconds += day    h, m = divmod(mean_seconds, 3600)    m, s = divmod(m, 60)    return '%02i:%02i:%02i' % (h, m, s)  if __name__ == '__main__':    print( mean_time([strv, strv, strv, strv]) )"
">>> from cmath import rect, phase>>> from math import radians, degrees>>> def mean_angle(deg):...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))... >>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')...     The mean angle of [350, 10] is: -0.0 degreesThe mean angle of [90, 180, 270, 360] is: -90.0 degreesThe mean angle of [10, 20, 30] is: 20.0 degrees>>> "
"def median(aray):    srtd = sorted(aray)    alen = len(srtd)    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2]) a = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)print a, median(a)a = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)print a, median(a)"
"from __future__ import division 
from math import factorialfrom random import randrange MAX_N = 20TIMES = 1000000 def analytical(n):	return sum(factorial(n) / pow(n, i) / factorial(n -i) for i in range(1, n+1)) def test(n, times):    count = 0    for i in range(times):        x, bits = 1, 0        while not (bits & x):            count += 1            bits |= x            x = 1 << randrange(n)    return count / times if __name__ == '__main__':    print("" navgexp.diff-------------------------------"")    for n in range(1, MAX_N+1):        avg = test(n, TIMES)        theory = analytical(n)        diff = (avg / theory - 1) * 100        print(strv % (n, avg, theory, diff))"
import timeimport os seconds = input(strv)sound = input(strv) time.sleep(float(seconds))os.startfile(sound + strv)
"from math import fsumdef average(x):    return fsum(x)/float(len(x)) if x else 0print (average([0,0,3,1,4,1,5,9,0,0]))print (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))2.32.3def average(x):    return sum(x)/float(len(x)) if x else 0print (average([0,0,3,1,4,1,5,9,0,0]))print (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))2.31e-21def avg(data):    if len(data)==0:        return 0    else:        return sum(data)/float(len(data))print avg([0,0,3,1,4,1,5,9,0,0])2.3def (mean l)  sum.l / len.l"
"from __future__ import with_statement 
import threadingimport randomimport time terminate = threading.Event() class Buckets:    def __init__(self, nbuckets):        self.nbuckets = nbuckets        self.values = [random.randrange(10) for i in range(nbuckets)]        self.lock = threading.Lock()     def __getitem__(self, i):        return self.values[i]     def transfer(self, src, dst, amount):        with self.lock:            amount = min(amount, self.values[src])            self.values[src] -= amount            self.values[dst] += amount     def snapshot(self):        
        with self.lock:            return self.values[:] def randomize(buckets):    nbuckets = buckets.nbuckets    while not terminate.isSet():        src = random.randrange(nbuckets)        dst = random.randrange(nbuckets)        if dst!=src:            amount = random.randrange(20)            buckets.transfer(src, dst, amount) def equalize(buckets):    nbuckets = buckets.nbuckets    while not terminate.isSet():        src = random.randrange(nbuckets)        dst = random.randrange(nbuckets)        if dst!=src:            amount = (buckets[src] - buckets[dst]) // 2            if amount>=0: buckets.transfer(src, dst, amount)            else: buckets.transfer(dst, src, -amount) def print_state(buckets):    snapshot = buckets.snapshot()    for value in snapshot:        print '%2d' % value,    print '=', sum(snapshot) 
buckets = Buckets(15) 
t1 = threading.Thread(target=randomize, args=[buckets])t1.start() 
t2 = threading.Thread(target=equalize, args=[buckets])t2.start() 
try:    while True:        print_state(buckets)        time.sleep(1)except KeyboardInterrupt: 
    terminate.set() 
t1.join()t2.join()"
"hash = dict()  
hash = dict(red=strv, green=strv, blue=strv)hash = { 'key1':1, 'key2':2, }value = hash[key]
d = {}d['spam'] = 1d['eggs'] = 2   
d1 = {'spam': 1, 'eggs': 2}d2 = dict(spam=1, eggs=2) 
d1 = dict([('spam', 1), ('eggs', 2)])d2 = dict(zip(['spam', 'eggs'], [1, 2])) 
for key in d:  print key, d[key] 
for key, value in d.iteritems():  print key, valuemyDict = { '1': 'a string', 1: 'an integer', 1.0: 'a floating point number', (1,): 'a tuple' }"
"myDict = { strv: 13,	   strv: 31,	   strv    : 71 } 
for key, value in myDict.items():    print (strv % (key, value)) 
for key in myDict:    print (strv % key)
for key in myDict.keys():    print (strv % key) 
for value in myDict.values():    print (strv % value)"
"a = 5#...input or change a hereassert a == 42 
assert a == 42, strv 
       
       
"
">>> print(len(['apple', 'orange']))2>>> "
"array = [] array.append(1)array.append(3) array[0] = 2 print array[0]myArray = [0] * sizemyArray = [[0]* width] * height] 
myArray = [[0 for x in range(width)] for y in range(height)]myArray = list()for x in range(height):   myArray.append([0] * width) 
item = array[index] 
array.pop()  
array.pop(0) 
 
item = array[-1] 
  try:    
    print array[len(array)]except IndexError as e:    
    print e "
"arr1 = [1, 2, 3]arr2 = [4, 5, 6]arr3 = [7, 8, 9]arr4 = arr1 + arr2assert arr4 == [1, 2, 3, 4, 5, 6]arr4.extend(arr3)assert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]arr5 = [4, 5, 6]arr6 = [7, 8, 9]arr6 += arr5assert arr6 == [7, 8, 9, 4, 5, 6]"
"x = int(raw_input(strv))y = int(raw_input(strv)) print strv % (x + y)print strv % (x - y)print strv % (x * y)print strv % (x / y)     
                                   
print strv % (x % y)    
print strv % divmod(x, y)print strv % x**y ## Only used to keep the display up when the program endsraw_input( )def getnum(prompt):    while True: 
        try:            n = int(raw_input(prompt))        except ValueError:            print strv\            continue        break    return n x = getnum(strv)y = getnum(strv)...def arithmetic(x, y):    for op in strv.split():        expr = strv % vars()        print(""%s=> %s"" % (expr, eval(expr)))  arithmetic(12, 8)arithmetic(input(strv), input(strv))a <- (read)b <- (read)prn strv a+bprn strv a-bprn strv a*bprn strv a/bprn strv (int a/b)prn strv a%bprn strv a^b"
"from fractions import Fraction for candidate in range(2, 2**19):  sum = Fraction(1, candidate)  for factor in range(2, int(candidate**0.5)+1):    if candidate % factor == 0:      sum += Fraction(1, factor) + Fraction(1, candidate // factor)  if sum.denominator == 1:    print(strv %           (candidate, int(sum), strv if sum == 1 else strv))def lcm(a, b):    return a // gcd(a,b) * b def gcd(u, v):    return gcd(v, u%v) if v else abs(u) class Fraction:    def __init__(self, numerator, denominator):        common = gcd(numerator, denominator)        self.numerator = numerator//common        self.denominator = denominator//common    def __add__(self, frac):        common = lcm(self.denominator, frac.denominator)        n = common // self.denominator * self.numerator + common // frac.denominator * frac.numerator        return Fraction(n, common)    def __sub__(self, frac):        return self.__add__(-frac)    def __neg__(self):        return Fraction(-self.numerator, self.denominator)    def __abs__(self):        return Fraction(abs(self.numerator), abs(self.denominator))    def __mul__(self, frac):        return Fraction(self.numerator * frac.numerator, self.denominator * frac.denominator)    def __div__(self, frac):        return self.__mul__(frac.reciprocal())    def reciprocal(self):        return Fraction(self.denominator, self.numerator)    def __cmp__(self, n):        return int(float(self) - float(n))    def __float__(self):        return float(self.numerator / self.denominator)    def __int__(self):        return (self.numerator // self.denominator)"
"from math import sqrt def agm(a0, g0, tolerance=1e-10):    strv
    Calculating the arithmetic-geometric mean of two numbers a0, g0.
 
    tolerance     the tolerance for the converged 
                  value of the arithmetic-geometric mean
                  (default value = 1e-10)
    strv    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)    while abs(an - gn) > tolerance:        an, gn = (an + gn) / 2.0, sqrt(an * gn)    return an print agm(1, 1 / sqrt(2))from decimal import Decimal, getcontext def agm(a, g, tolerance=Decimal(strv)):    while True:        a, g = (a + g) / 2, (a * g).sqrt()        if abs(a - g) < tolerance:            return a getcontext().prec = 70print agm(Decimal(1), 1 / Decimal(2).sqrt())"
"from decimal import * D = Decimalgetcontext().prec = 100a = n = D(1)g, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)for i in range(18):    x = [(a + g) * half, (a * g).sqrt()]    var = x[0] - a    z -= var * var * n    n += n    a, g = x    print(a * a / z)"
>>> z1 = 1.5 + 3j>>> z2 = 1.5 + 1.5j>>> z1 + z2(3+4.5j)>>> z1 - z21.5j>>> z1 * z2(-2.25+6.75j)>>> z1 / z2(1.5+0.5j)>>> - z1(-1.5-3j)>>> z1.conjugate()(1.5-3j)>>> abs(z1)3.3541019662496847>>> z1 ** z2(-1.1024829553277784-0.38306415117199333j)>>> z1.real1.5>>> z1.imag3.0>>> 
"from collections import Counter def cumulative_freq(freq):    cf = {}    total = 0    for b in range(256):        if b in freq:            cf[b] = total            total += freq[b]    return cf def arithmethic_coding(bytes, radix):     
    freq = Counter(bytes)     
    cf = cumulative_freq(freq)     
    base = len(bytes)     
    lower = 0     
    pf = 1     
    
    for b in bytes:        lower = lower*base + cf[b]*pf        pf *= freq[b]     
    upper = lower+pf     pow = 0    while True:        pf //= radix        if pf==0: break        pow += 1     enc = (upper-1) // radix**pow    return enc, pow, freq def arithmethic_decoding(enc, radix, pow, freq):     
    enc *= radix**pow;     
    base = sum(freq.values())     
    cf = cumulative_freq(freq)     
    dict = {}    for k,v in cf.items():        dict[v] = k     
    lchar = None    for i in range(base):        if i in dict:            lchar = dict[i]        elif lchar is not None:            dict[i] = lchar     
    decoded = bytearray()    for i in range(base-1, -1, -1):        pow = base**i        div = enc//pow         c  = dict[div]        fv = freq[c]        cv = cf[c]         rem = (enc - pow*cv) // fv         enc = rem        decoded.append(c)     
    return bytes(decoded) radix = 10      
 for str in b'DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT'.split():    enc, pow, freq = arithmethic_coding(str, radix)    dec = arithmethic_decoding(enc, radix, pow, freq)     print(strv % (str, enc, radix, pow))     if str != dec:    	raise Exception(""However that is incorrect!"")"
"import operator class AstNode(object):   def __init__( self, opr, left, right ):      self.opr = opr      self.l = left      self.r = right    def eval(self):      return self.opr(self.l.eval(), self.r.eval()) class LeafNode(object):   def __init__( self, valStrg ):      self.v = int(valStrg)    def eval(self):      return self.v class Yaccer(object):   def __init__(self):      self.operstak = []      self.nodestak =[]      self.__dict__.update(self.state1)    def v1( self, valStrg ):      
      self.nodestak.append( LeafNode(valStrg))      self.__dict__.update(self.state2)      #print 'push', valStrg    def o2( self, operchar ):      
      def openParen(a,b):         return 0		
       opDict= { '+': ( operator.add, 2, 2 ),         '-': (operator.sub, 2, 2 ),         '*': (operator.mul, 3, 3 ),         '/': (operator.div, 3, 3 ),         '^': ( pow,         4, 5 ),  
         '(': ( openParen,   0, 8 )         }      operPrecidence = opDict[operchar][2]      self.redeuce(operPrecidence)       self.operstak.append(opDict[operchar])      self.__dict__.update(self.state1)      
    def syntaxErr(self, char ):      
      print 'parse error - near operator strv' %char    def pc2( self,operchar ):      
      
      self.redeuce( 1 )      if len(self.operstak)>0:         self.operstak.pop()		
      else:         print 'Error - no open parenthesis matches close parens.'      self.__dict__.update(self.state2)    def end(self):      self.redeuce(0)      return self.nodestak.pop()    def redeuce(self, precidence):      while len(self.operstak)>0:         tailOper = self.operstak[-1]         if tailOper[1] < precidence: break          tailOper = self.operstak.pop()         vrgt = self.nodestak.pop()         vlft= self.nodestak.pop()         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))         
    state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }  def Lex( exprssn, p ):   bgn = None   cp = -1   for c in exprssn:      cp += 1      if c in '+-/*^()':         
         if bgn is not None:            p.v(p, exprssn[bgn:cp])            bgn = None         if c=='(': p.po(p, c)         elif c==')':p.pc(p, c)         else: p.o(p, c)      elif c in ' ':         if bgn is not None:            p.v(p, exprssn[bgn:cp])            bgn = None      elif c in '0123456789':         if bgn is None:            bgn = cp      else:         print 'Invalid character in expression'         if bgn is not None:            p.v(p, exprssn[bgn:cp])            bgn = None    if bgn is not None:      p.v(p, exprssn[bgn:cp+1])      bgn = None   return p.end()  expr = raw_input(strv)astTree = Lex( expr, Yaccer())print expr, '=',astTree.eval()>>> import ast>>> >>> expr=strv>>> node = ast.parse(expr, mode='eval')>>> print(ast.dump(node).replace(',', ','))Expression(body=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Num(n=3), op=Sub(), right=Num(n=1))), op=Add(), right=BinOp(left=Num(n=2), op=Mult(), right=Num(n=5))))>>> code_object = compile(node, filename='<string>', mode='eval')>>> eval(code_object)14>>> 
>>> node.body.right.right.n5>>> node.body.right.right.n = 6>>> code_object = compile(node, filename='<string>', mode='eval')>>> eval(code_object)16"
"from turtle import *from math import *color(strv)down()for i in range(200):    t = i / 20 * pi    x = (1 + 5 * t) * cos(t)    y = (1 + 5 * t) * sin(t)    goto(x, y)up()done()"
"#!/bin/pythonfrom __future__ import print_functionfrom scipy import signalimport matplotlib.pyplot as plt if __name__==strv:	sig = [-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,		-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,		0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,		0.0259303398477,0.490105989562,0.549391221511,0.9047198589] 	#Create an order 3 lowpass butterworth filter	#Generated using b, a = signal.butter(3, 0.5)	a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]	b = [0.16666667, 0.5, 0.5, 0.16666667] 	#Apply the filter to signal	filt = signal.lfilter(b, a, sig)	print (filt) 	plt.plot(sig, 'b')	plt.plot(filt, 'r--')	plt.show()"
">>> y = str( 5**4**3**2 )>>> print (strv % (y[:20], y[-20:], len(y)))5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits"
"#############################
#############################
passwd_list=[  dict(account='jsmith', password='x', UID=1001, GID=1000, 
       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),                  directory='/home/jsmith', shell='/bin/bash'),  dict(account='jdoe', password='x', UID=1002, GID=1000,       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),       directory='/home/jdoe', shell='/bin/bash')] passwd_fields=strv.split()GECOS_fields=strv.split() def passwd_text_repr(passwd_rec):
  passwd_rec[strv]=strv.join([ passwd_rec[strv][field] for field in GECOS_fields])  for field in passwd_rec: 
    if not isinstance(passwd_rec[field], str):      passwd_rec[field]=`passwd_rec[field]`  return strv.join([ passwd_rec[field] for field in passwd_fields ]) passwd_text=open(strv,strv)for passwd_rec in passwd_list:  print >> passwd_text,passwd_text_repr(passwd_rec)passwd_text.close() #################################
#################################passwd_text=open(strv,strv)new_rec=dict(account='xyz', password='x', UID=1003, GID=1000,             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',                        homephone='(234)555-0033', email='xyz@rosettacode.org'),             directory='/home/xyz', shell='/bin/bash')print >> passwd_text,  passwd_text_repr(new_rec)passwd_text.close() ##############################################
##############################################passwd_list=list(open(strv,strv))if strv in passwd_list[-1]:  print strv,passwd_list[-1][:-1]"
"def square(n):    return n * n numbers = [1, 3, 5, 7] squares1 = [square(n) for n in numbers]     
 squares2a = map(square, numbers)            
 squares2b = map(lambda x: x*x, numbers)     
 squares3 = [n * n for n in numbers]         
                                            
 isquares1 = (n * n for n in numbers)        
 import itertoolsisquares2 = itertools.imap(square, numbers) 
print strv.join(str(n * n) for n in range(10))print strv.join(map(str, map(square, range(10))))0 1 4 9 16 25 36 49 64 81"
">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))>>> [ Y(fib)(i) for i in range(-2, 10) ][None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]>>>from functools import partial>>> Y = lambda f: (lambda x: x(x))(lambda y: partial(f, lambda *args: y(y)(*args)))>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))>>> [ Y(fib)(i) for i in range(-2, 10) ][None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]>>> from functools import partial>>> Y = lambda f: partial(f, f)>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(f, n-1) + f(f, n-2)))>>> [ Y(fib)(i) for i in range(-2, 10) ][None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> from inspect import currentframe>>> from types import FunctionType>>> def myself (*args, **kw):...    caller_frame = currentframe(1)...    code = caller_frame.f_code...    return FunctionType(code, caller_frame.f_globals)(*args, **kw)...>>> print strv,>>> print (lambda n:1 if n<=1 else n*myself(n-1)) ( 5 ) "
"from __future__ import print_function def getDifference(b1, b2):	r = (b2 - b1) % 360.0	
	
	if r >= 180.0:		r -= 360.0	return r if __name__ == strv:	print (strv)	print (getDifference(20.0, 45.0))	print (getDifference(-45.0, 45.0))	print (getDifference(-85.0, 90.0))	print (getDifference(-95.0, 90.0))	print (getDifference(-45.0, 125.0))	print (getDifference(-45.0, 145.0))	print (getDifference(-45.0, 125.0))	print (getDifference(-45.0, 145.0))	print (getDifference(29.4803, -88.6381))	print (getDifference(-78.3251, -159.036)) 	print (strv)	print (getDifference(-70099.74233810938, 29840.67437876723))	print (getDifference(-165313.6666297357, 33693.9894517456))	print (getDifference(1174.8380510598456, -154146.66490124757))	print (getDifference(60175.77306795546, 42213.07192354373))"
"import pygame, sysfrom pygame.locals import *pygame.init() YSIZE = 40XSIZE = 150 TEXT = strvFONTSIZE = 32 LEFT = FalseRIGHT = True DIR = RIGHT TIMETICK = 180TICK = USEREVENT + 2 TEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE) pygame.time.set_timer(TICK, TIMETICK) window = pygame.display.set_mode((XSIZE, YSIZE))pygame.display.set_caption(strv) font = pygame.font.SysFont(None, FONTSIZE)screen = pygame.display.get_surface() def rotate():    index = DIR and -1 or 1    global TEXT    TEXT = TEXT[index:]+TEXT[:index] def click(position):    if TEXTBOX.collidepoint(position):        global DIR        DIR = not DIR def draw():    surface = font.render(TEXT, True, (255,255,255), (0,0,0))    global TEXTBOX    TEXTBOX = screen.blit(surface, TEXTBOX) def input(event):    if event.type == QUIT:        sys.exit(0)    elif event.type == MOUSEBUTTONDOWN:        click(event.pos)    elif event.type == TICK:        draw()        rotate() while True:    input(pygame.event.wait())    pygame.display.flip()import Tkinter as tki def scroll_text(s, how_many):    return s[how_many:] + s[:how_many] direction = 1tk = tki.Tk()var = tki.Variable(tk) def mouse_handler(point):    global direction    direction *= -1 def timer_handler():    var.set(scroll_text(var.get(),direction))    tk.after(125, timer_handler) var.set('Hello, World! ')tki.Label(tk, textvariable=var).pack()tk.bind(strv, mouse_handler)tk.after(125, timer_handler)tk.title('Python Animation')tki.mainloop() "
"import pygame, sysfrom pygame.locals import *from math import sin, cos, radians pygame.init() WINDOWSIZE = 250TIMETICK = 100BOBSIZE = 15 window = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))pygame.display.set_caption(strv) screen = pygame.display.get_surface()screen.fill((255,255,255)) PIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)SWINGLENGTH = PIVOT[1]*4 class BobMass(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.theta = 45        self.dtheta = 0        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),                                1,1)        self.draw()     def recomputeAngle(self):        scaling = 3000.0/(SWINGLENGTH**2)         firstDDtheta = -sin(radians(self.theta))*scaling        midDtheta = self.dtheta + firstDDtheta        midtheta = self.theta + (self.dtheta + midDtheta)/2.0         midDDtheta = -sin(radians(midtheta))*scaling        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2        midtheta = self.theta + (self.dtheta + midDtheta)/2         midDDtheta = -sin(radians(midtheta)) * scaling        lastDtheta = midDtheta + midDDtheta        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0         lastDDtheta = -sin(radians(lasttheta)) * scaling        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0         self.dtheta = lastDtheta        self.theta = lasttheta        self.rect = pygame.Rect(PIVOT[0]-                                SWINGLENGTH*sin(radians(self.theta)),                                 PIVOT[1]+                                SWINGLENGTH*cos(radians(self.theta)),1,1)      def draw(self):        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))     def update(self):        self.recomputeAngle()        screen.fill((255,255,255))        self.draw() bob = BobMass() TICK = USEREVENT + 2pygame.time.set_timer(TICK, TIMETICK) def input(events):    for event in events:        if event.type == QUIT:            sys.exit(0)        elif event.type == TICK:            bob.update() while True:    input(pygame.event.get())    pygame.display.flip()"
"import urllib.requestfrom collections import defaultdictfrom itertools import combinations def getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):    return list(set(urllib.request.urlopen(url).read().decode().split())) def find_anagrams(words):    anagram = defaultdict(list) 
    for word in words:        anagram[tuple(sorted(word))].append( word )    return dict((key, words) for key, words in anagram.items()                if len(words) > 1) def is_deranged(words):    'returns pairs of words that have no character in the same position'    return [ (word1, word2)             for word1,word2 in combinations(words, 2)             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ] def largest_deranged_ana(anagrams):    ordered_anagrams = sorted(anagrams.items(),                              key=lambda x:(-len(x[0]), x[0]))    for _, words in ordered_anagrams:        deranged_pairs = is_deranged(words)        if deranged_pairs:            return deranged_pairs    return [] if __name__ == '__main__':    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')    print(strv, len(words))     anagrams = find_anagrams(words)    print(strv, len(anagrams),"""")     print(strv)    print('  ' + '  '.join(', '.join(pairs)                             for pairs in largest_deranged_ana(anagrams)))from itertools import izip, ifilterfrom collections import defaultdict def find_deranged(words):    return [(w1, w2) for i, w1 in enumerate(words)                     for w2 in words[i + 1:]                     if all(a != b for a,b in izip(w1, w2))] def main():    wclasses = [[] for _ in xrange(30)]    for word in open(strv).read().split():        wclasses[-len(word)].append(word)     print strv    for words in ifilter(None, wclasses):        anags = defaultdict(list)        for w in words:            anags[strv.join(sorted(w))].append(w)        anas = (find_deranged(a) for a in anags.itervalues() if len(a)>1)        pairs = filter(None, anas)        if pairs:            print strv % (pairs[0][0])            break main()"
"import itertools as _itertools class Amb(object):    def __init__(self):        self._names2values   = {}       
        self._func           = None     
        self._valueiterator  = None     
        self._funcargnames   = None     
     def __call__(self, arg=None):        if hasattr(arg, '__code__'):                            ##            ## Called with a constraint function.             ##            globls = arg.__globals__ if hasattr(arg, '__globals__') else arg.func_globals            
            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]            for name in argv:                if name not in self._names2values:                    assert name in globls, \                           strv % name                    self._names2values[name] = globls[name]            
            valuesets = [self._names2values[name] for name in argv]            self._valueiterator = _itertools.product(*valuesets)            self._func = arg            self._funcargnames = argv            return self        elif arg is not None:            ##            ## Assume called with an iterable set of values            ##            arg = frozenset(arg)            return arg        else:            ##            ## blank call tries to return next solution            ##            return self._nextinsearch()     def _nextinsearch(self):        arg = self._func        globls = arg.__globals__        argv = self._funcargnames        found = False        for values in self._valueiterator:            if arg(*values):                
                found = True                for n, v in zip(argv, values):                    globls[n] = v                break        if not found: raise StopIteration        return values     def __iter__(self):        return self     def __next__(self):        return self()    next = __next__ 
 if __name__ == '__main__':    if True:        amb = Amb()         print(""Small Pythagorean triples problem:"")        x = amb(range(1,11))        y = amb(range(1,11))        z = amb(range(1,11))         for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):            print ('%s %s %s' % (x, y, z))      if True:        amb = Amb()         print(""Rosetta Code Amb problem:"")        w1 = amb([strv, strv, strv])        w2 = amb([strv, strv, strv])        w3 = amb([strv, strv, strv])        w4 = amb([strv, strv])         for _dummy in amb( lambda w1, w2, w3, w4: \                             w1[-1] == w2[0] and \                             w2[-1] == w3[0] and \                             w3[-1] == w4[0] ):            print ('%s %s %s %s' % (w1, w2, w3, w4))     if True:        amb = Amb()         print(""Amb problem from ""            strv)        x = amb([1, 2, 3])        y = amb([4, 5, 6])         for _dummy in amb( lambda x, y: x * y != 8 ):            print ('%s %s' % (x, y))"
">>> import urllib.request>>> from collections import defaultdict>>> words = urllib.request.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt').read().split()>>> anagram = defaultdict(list) 
>>> for word in words:	anagram[tuple(sorted(word))].append( word )  >>> count = max(len(ana) for ana in anagram.values())>>> for ana in anagram.values():	if len(ana) >= count:		print ([x.decode() for x in ana])>>> import urllib>>> from collections import defaultdict>>> words = urllib.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt').read().split()>>> len(words)25104>>> anagram = defaultdict(list) 
>>> for word in words:	anagram[tuple(sorted(word))].append( word )  >>> count = max(len(ana) for ana in anagram.itervalues())>>> for ana in anagram.itervalues():	if len(ana) >= count:		print ana  ['angel', 'angle', 'galen', 'glean', 'lange']['alger', 'glare', 'lager', 'large', 'regal']['caret', 'carte', 'cater', 'crate', 'trace']['evil', 'levi', 'live', 'veil', 'vile']['elan', 'lane', 'lean', 'lena', 'neal']['abel', 'able', 'bale', 'bela', 'elba']>>> count5>>>>>> import urllib, itertools>>> words = urllib.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt').read().split()>>> len(words)25104>>> anagrams = [list(g) for k,g in itertools.groupby(sorted(words, key=sorted), key=sorted)]  >>> count = max(len(ana) for ana in anagrams)>>> for ana in anagrams:	if len(ana) >= count:		print ana  ['abel', 'able', 'bale', 'bela', 'elba']['caret', 'carte', 'cater', 'crate', 'trace']['angel', 'angle', 'galen', 'glean', 'lange']['alger', 'glare', 'lager', 'large', 'regal']['elan', 'lane', 'lean', 'lena', 'neal']['evil', 'levi', 'live', 'veil', 'vile']>>> count5>>>"
"from proper_divisors import proper_divs def amicable(rangemax=20000):    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}    for num, divsum in n2divsum.items():        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:            yield num, divsum if __name__ == '__main__':    for num, divsum in amicable():        print('Amicable pair: %i and %i With proper divisors:    %r    %r'              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))"
"from prime_decomposition import decomposefrom itertools import islice, counttry:     from functools import reduceexcept:     pass  def almostprime(n, k=2):    d = decompose(n)    try:        terms = [next(d) for i in range(k)]        return reduce(int.__mul__, terms, 1) == n    except:        return False if __name__ == '__main__':    for k in range(1,6):        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))"
"from proper_divisors import proper_divsfrom functools import lru_cache  @lru_cache()def pdsum(n):     return sum(proper_divs(n))  def aliquot(n, maxlen=16, maxterm=2**47):    if n == 0:        return 'terminating', [0]    s, slen, new = [n], 1, n    while slen <= maxlen and new < maxterm:        new = pdsum(s[-1])        if new in s:            if s[0] == new:                if slen == 1:                    return 'perfect', s                elif slen == 2:                    return 'amicable', s                else:                    return 'sociable of length %i' % slen, s            elif s[-1] == new:                return 'aspiring', s            else:                return 'cyclic back to %i' % new, s        elif new == 0:            return 'terminating', s + [0]        else:            s.append(new)            slen += 1    else:        return 'non-terminating', s if __name__ == '__main__':    for n in range(1, 11):         print('%s: %r' % aliquot(n))    print()    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]:         print('%s: %r' % aliquot(n))"
"foo = object()  
address = id(foo)"
"def expand_x_1(n): 
    c =1    for i in range(n/2+1):        c = c*(n-i)/(i+1)        yield c def aks(p):    if p==2:        return True     for i in expand_x_1(p):        if i % p:
            return False    return Truedef expand_x_1(p):    ex = [1]    for i in range(p):        ex.append(ex[-1] * -(p-i) / (i+1))    return ex[::-1] def aks_test(p):    if p < 2: return False    ex = expand_x_1(p)    ex[0] += 1    return not any(mult % p for mult in ex[0:-1])  print('# p: (x-1)^p for small p')for p in range(12):    print('%3i: %s' % (p, ' '.join('%+i%s' % (e, ('x^%i' % n) if n else '')                                   for n,e in enumerate(expand_x_1(p))))) print('
)print([p for p in range(101) if aks_test(p)])print('''
{| class=strv
|+ Polynomial Expansions and AKS prime test
|-
! <math>p</math>
! <math>(x-1)^p</math>
|-''')for p in range(12):    print('! <math>%i</math>| <math>%s</math>| %r|-'          % (p,             ' '.join('%s%s' % (('%+i' % e) if (e != 1 or not p or (p and not n) ) else '+',                                (('x^{%i}' % n) if n > 1 else 'x') if n else '')                      for n,e in enumerate(expand_x_1(p))),             aks_test(p)))print('|}')"
"class empty(object):    passe = empty()   e.foo = 1   setattr(e, name, value)class empty(object):    def __init__(this):        this.foo = strv def patch_empty(obj):    def fn(self=obj):        print self.foo    obj.print_output = fn e = empty()patch_empty(e)e.print_output()
"
"import ldap l = ldap.initialize(strv)try:    l.protocol_version = ldap.VERSION3    l.set_option(ldap.OPT_REFERRALS, 0)     bind = l.simple_bind_s("""", strv)     base = strv    criteria = strv    attributes = ['displayName', 'company']    result = l.search_s(base, ldap.SCOPE_SUBTREE, criteria, attributes)     results = [entry for dn, entry in result if isinstance(entry, dict)]    print resultsfinally:    l.unbind() "
"from time import time, sleepfrom threading import Thread class Integrator(Thread):    'continuously integrate a function `K`, at each `interval` seconds'    def __init__(self, K=lambda t:0, interval=1e-4):        Thread.__init__(self)        self.interval  = interval        self.K   = K        self.S   = 0.0        self.__run = True        self.start()     def run(self):        strv        interval = self.interval        start = time()        t0, k0 = 0, self.K(0)        while self.__run:            sleep(interval)            t1 = time() - start            k1 = self.K(t1)            self.S += (k1 + k0)*(t1 - t0)/2.0            t0, k0 = t1, k1     def join(self):        self.__run = False        Thread.join(self) if __name__ == strv:    from math import sin, pi     ai = Integrator(lambda t: sin(pi*t))    sleep(2)    print ai.S    ai.K = lambda t: 0    sleep(0.5)    print ai.S"
"from StringIO import StringIO textinfile = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.''' j2justifier = dict(L=str.ljust, R=str.rjust, C=str.center) def aligner(infile, justification = 'L'):  ''' 
  Justify columns of textual tabular input where the row separator is the newline
  and the field separator is a 'dollar' character.
  justification can be L, R, or C; (Left, Right, or Centered).
 
  Return the justified output as a string
  '''  assert justification in j2justifier, strv  justifier = j2justifier[justification]   fieldsbyrow= [line.strip().split('$') for line in infile]  
  maxfields = max(len(row) for row in fieldsbyrow)  fieldsbyrow = [fields + ['']*(maxfields - len(fields))                    for fields in fieldsbyrow]  
  fieldsbycolumn = zip(*fieldsbyrow)  
  colwidths = [max(len(field) for field in column)               for column in fieldsbycolumn]  
  fieldsbycolumn = [ [justifier(field, width) for field in column]                     for width, column in zip(colwidths, fieldsbycolumn) ]  
  fieldsbyrow = zip(*fieldsbycolumn)   return """".join( strv.join(row) for row in fieldsbyrow)  for align in 'Left Right Center'.split():  infile = StringIO(textinfile)  print ""# %s Column-aligned output:"" % align  print aligner(infile, align[0])txt = strvGiven$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.strv parts = [line.rstrip(strv).split(strv) for line in txt.splitlines()] max_widths = {}for line in parts:    for i, word in enumerate(line):        max_widths[i] = max(max_widths.get(i, 0), len(word)) for i, justify in enumerate([str.ljust, str.center, str.rjust]):    print [strv, strv, strv][i], "" column-aligned output:""    for line in parts:        for j, word in enumerate(line):            print justify(word, max_widths[j]),        print    print strv * 52'''
cat <<'EOF' > align_columns.dat
Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.
EOF
''' for align in '<^>':  rows = [ line.strip().split('$') for line in open('align_columns.dat') ]  fmts = [ '{:%s%d}' % (align, max( len(row[i]) if i < len(row) else 0 for row in rows ))           for i in range(max(map(len, rows))) ]  for row in rows:    print(' '.join(fmts).format(*(row + [''] * len(fmts))))  print('')"
"import ldap l = ldap.initialize(strv)try:    l.protocol_version = ldap.VERSION3    l.set_option(ldap.OPT_REFERRALS, 0)     bind = l.simple_bind_s("""", strv)finally:    l.unbind() "
>>> def accumulator(sum):  def f(n):    f.sum += n    return f.sum  f.sum = sum  return f >>> x = accumulator(1)>>> x(5)6>>> x(2.3)8.3000000000000007>>> x = accumulator(1)>>> x(5)6>>> x(2.3)8.3000000000000007>>> x2 = accumulator(3)>>> x2(5)8>>> x2(3.3)11.300000000000001>>> x(0)8.3000000000000007>>> x2(0)11.300000000000001def accumulator(sum):  def f(n):    nonlocal sum    sum += n    return sum  return f x = accumulator(1)x(5)print(accumulator(3))print(x(2.3))def accumulator(sum):  while True:    sum += yield sum x = accumulator(1)x.send(None)x.send(5)print(accumulator(3))print(x.send(2.3))def (accumulator n)  (fn() ++n)
">>> from proper_divisors import proper_divs>>> from collections import Counter>>> >>> rangemax = 20000>>> >>> def pdsum(n):...     return sum(proper_divs(n))... >>> def classify(n, p):...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'... >>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))>>> classes.most_common()[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]>>> "
"def ack1(M, N):   return (N + 1) if M == 0 else (      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))def ack2(M, N):    if M == 0:        return N + 1    elif N == 0:        return ack2(M - 1, 1)    else:        return ack2(M - 1, ack2(M, N - 1))>>> import sys>>> sys.setrecursionlimit(3000)>>> ack1(0,0)1>>> ack1(3,4)125>>> ack2(0,0)1>>> ack2(3,4)125def ack2(M, N):   return (N + 1)   if M == 0 else (          (N + 2)   if M == 1 else (          (2*N + 3) if M == 2 else (          (8*(2**N - 1) + 5) if M == 3 else (          ack2(M-1, 1) if N == 0 else ack2(M-1, ack2(M, N-1))))))"
"from __future__ import print_functionimport matplotlib.pyplot as plt class AStarGraph(object):	#Define a class board like grid with two barriers 	def __init__(self):		self.barriers = []		self.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)]) 	def heuristic(self, start, goal):		#Use Chebyshev distance heuristic if we can move one square either		#adjacent or diagonal		D = 1		D2 = 1		dx = abs(start[0] - goal[0])		dy = abs(start[1] - goal[1])		return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy) 	def get_vertex_neighbours(self, pos):		n = []		#Moves allow link a chess king		for dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:			x2 = pos[0] + dx			y2 = pos[1] + dy			if x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:				continue			n.append((x2, y2))		return n 	def move_cost(self, a, b):		for barrier in self.barriers:			if b in barrier:				return 100 #Extremely high cost to enter barrier squares		return 1 #Normal movement cost def AStarSearch(start, end, graph): 	G = {} #Actual movement cost to each position from the start position	F = {} #Estimated movement cost of start to end going via this position 	#Initialize starting values	G[start] = 0 	F[start] = graph.heuristic(start, end) 	closedVertices = set()	openVertices = set([start])	cameFrom = {} 	while len(openVertices) > 0:		#Get the vertex in the open list with the lowest F score		current = None		currentFscore = None		for pos in openVertices:			if current is None or F[pos] < currentFscore:				currentFscore = F[pos]				current = pos 		#Check if we have reached the goal		if current == end:			#Retrace our route backward			path = [current]			while current in cameFrom:				current = cameFrom[current]				path.append(current)			path.reverse()			return path, F[end] #Done! 		#Mark the current vertex as closed		openVertices.remove(current)		closedVertices.add(current) 		#Update scores for vertices near the current position		for neighbour in graph.get_vertex_neighbours(current):			if neighbour in closedVertices: 				continue #We have already processed this node exhaustively			candidateG = G[current] + graph.move_cost(current, neighbour) 			if neighbour not in openVertices:				openVertices.add(neighbour) #Discovered a new vertex			elif candidateG >= G[neighbour]:				continue #This G score is worse than previously found 			#Adopt this G score			cameFrom[neighbour] = current			G[neighbour] = candidateG			H = graph.heuristic(neighbour, end)			F[neighbour] = G[neighbour] + H 	raise RuntimeError(strv) if __name__==strv:	graph = AStarGraph()	result, cost = AStarSearch((0,0), (7,7), graph)	print (strv, result)	print (strv, cost)	plt.plot([v[0] for v in result], [v[1] for v in result])	for barrier in graph.barriers:		plt.plot([v[0] for v in barrier], [v[1] for v in barrier])	plt.xlim(-1,8)	plt.ylim(-1,8)	plt.show()"
"class BaseQueue(object):    strvAbstract/Virtual Class 
    strv    def __init__(self):        self.contents = list()        raise NotImplementedError    def Enqueue(self, item):        raise NotImplementedError    def Dequeue(self):        raise NotImplementedError    def Print_Contents(self):        for i in self.contents:            print i,from abc import ABCMeta, abstractmethod class BaseQueue():    strvAbstract Class 
    strv    __metaclass__ = ABCMeta     def __init__(self):        self.contents = list()     @abstractmethod    def Enqueue(self, item):        pass     @abstractmethod    def Dequeue(self):        pass     def Print_Contents(self):        for i in self.contents:            print i,"
"def sing(b, end):    print(b or 'No more','bottle'+('s' if b-1 else ''), end) for i in range(99, 0, -1):    sing(i, 'of beer on the wall,')    sing(i, 'of beer,')    print('Take one down, pass it around,')    sing(i-1, 'of beer on the wall.')verse = '''
%i bottles of beer on the wall
%i bottles of beer
Take one down, pass it around
%i bottles of beer on the wall
''' for bottles in range(99,0,-1):    print verse % (bottles, bottles, bottles-1) verse = '''
{some} bottles of beer on the wall
{some} bottles of beer
Take one down, pass it around
{less} bottles of beer on the wall
''' for bottles in range(99,0,-1):    print verse.format(some=bottles, less=bottles-1) a, b, c, s = strv, "" on the wall"", ""Take one down, pass it around"", strprint """".join(s(x)+a+b+s(x)+a+""""+c+s(x-1)+a+b for x in xrange(99, 0, -1))a = lambda n: ""%u bottle%s of beer on the wall"" % (n, strv[n==1:])print """".join(a(x)+a(x)[:-13]+""Take one down, pass it around""+a(x-1) for x in xrange(99, 0, -1))#!/usr/bin/env python3strv
{0} {2} of beer on the wall
{0} {2} of beer
Take one down, pass it around
{1} {3} of beer on the wall
strvprint("""".join(    __doc__.format(        i, i - 1,        strv if i == 1 else strv,        strv if i - 1 == 1 else strv    ) for i in range(99, 0, -1)), end=strv)ones = ('', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine')prefixes = ('thir', 'four', 'fif', 'six', 'seven', 'eigh', 'nine')tens = ['', '', 'twenty' ]teens = ['ten', 'eleven', 'twelve']for prefix in prefixes:    tens.append(prefix + 'ty')    teens.append(prefix +'teen')tens[4] = 'forty' def number(num):     strv    ten, one = divmod(num, 10)    if ten == 0 and one == 0:        return 'no'    elif ten == 0:        return ones[one]    elif ten == 1:        return teens[one]    elif one == 0:        return tens[ten]    else:        return strv % (tens[ten], ones[one]) def bottles(beer):    strv    return strv % (             number(beer).capitalize(), 's' if beer > 1 else ''    ) onthewall = 'on the wall'takeonedown = 'Take one down, pass it around'for beer in range(99, 0, -1):     print bottles(beer), onthewall    print bottles(beer)    print takeonedown    print bottles(beer-1), onthewall    printfor n in xrange(99, 0, -1):    ##  The formatting performs a conditional check on the variable.    ##  If it formats the first open for False, and the second for True    print n, 'bottle%s of beer on the the wall.' % ('s', '')[n == 1]    print n, 'bottle%s of beer.' % ('s', '')[n == 1]    print 'Take one down, pass it around.'    print n - 1, 'bottle%s of beer on the wall.' % ('s', '')[n - 1 == 1]"
"try: raw_inputexcept: raw_input = input print(sum(map(int, raw_input().split())))import sys for line in sys.stdin:    print(sum(map(int, line.split())))"
"    >>> can_make_word(strv)    True    >>> can_make_word(strv)    True    >>> can_make_word(strv)    False    >>> can_make_word(strv)    True    >>> can_make_word(strv)    False    >>> can_make_word(strv)    True    >>> can_make_word(strv)    True '''
Note that this code is broken, e.g., it won't work when 
blocks = [(strv, where the answer
should be True, but the code returns False.
'''blocks = [(strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv),          (strv, strv)]  def can_make_word(word, block_collection=blocks):    strv
    Return True if `word` can be made from the blocks in `block_collection`.
 
    >>> can_make_word(strv)
    False
    >>> can_make_word(strv)
    True
    >>> can_make_word(strv)
    True
    >>> can_make_word(strv)
    False
    >>> can_make_word(strv)
    True
    >>> can_make_word(strv)
    False
    >>> can_make_word(strv)
    True
    >>> can_make_word(strv)
    True
    strv    if not word:        return False     blocks_remaining = block_collection[:]    for char in word.upper():        for block in blocks_remaining:            if char in block:                blocks_remaining.remove(block)                break        else:            return False    return True  if __name__ == strv:    import doctest    doctest.testmod()    print(strv.join(strv % (w, can_make_word(w)) for w in                    [strv, strv, strv, strv, strv,                      strv, strv, strv])) BLOCKS = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split() def _abc(word, blocks):    for i, ch in enumerate(word):        for blk in (b for b in blocks if ch in b):            whatsleft = word[i + 1:]            blksleft = blocks[:]            blksleft.remove(blk)            if not whatsleft:                 return True, blksleft            if not blksleft:                 return False, blksleft            ans, blksleft = _abc(whatsleft, blksleft)            if ans:                return ans, blksleft        else:            break    return False, blocks def abc(word, blocks=BLOCKS):    return _abc(word.upper(), blocks)[0] if __name__ == '__main__':    for word in [''] + 'A BARK BoOK TrEAT COmMoN SQUAD conFUsE'.split():        print('Can we spell %9r? %r' % (word, abc(word)))def mkword(w, b):    if not w: return []     c,w = w[0],w[1:]    for i in range(len(b)):        if c in b[i]:            m = mkword(w, b[0:i] + b[i+1:])            if m != None: return [b[i]] + m def abc(w, blk):    return mkword(w.upper(), [a.upper() for a in blk]) blocks = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split() for w in strv.split(', '):    print '' + w + '' + ' ->', abc(w, blocks)"
"cache = [[1]]def cumu(n):    for l in range(len(cache), n+1):        r = [0]        for x in range(1, l+1):            r.append(r[-1] + cache[l-x][min(x, l-x)])        cache.append(r)    return cache[n] def row(n):    r = cumu(n)    return [r[i+1] - r[i] for i in range(n)] print strvfor x in range(1, 11): print strv%x, row(x)  print ""sums:""for x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]def partitions(N):    diffs,k,s = [],1,1    while k * (3*k-1) < 2*N:        diffs.extend([(2*k - 1, s), (k, s)])	k,s = k+1,-s     out = [1] + [0]*N    for p in range(0, N+1):        x = out[p]	for (o,s) in diffs:           p += o           if p > N: break           out[p] += x*s     return out p = partitions(12345)for x in [23,123,1234,12345]: print x, p[x]def partitions(n):    partitions.p.append(0)     for k in xrange(1, n + 1):        d = n - k * (3 * k - 1) // 2        if d < 0:            break         if k & 1:            partitions.p[n] += partitions.p[d]        else:            partitions.p[n] -= partitions.p[d]         d -= k        if d < 0:            break         if k & 1:            partitions.p[n] += partitions.p[d]        else:            partitions.p[n] -= partitions.p[d]     return partitions.p[-1] partitions.p = [1] def main():    ns = set([23, 123, 1234, 12345])    max_ns = max(ns)     for i in xrange(1, max_ns + 1):        if i > max_ns:            break        p = partitions(i)        if i in ns:            print strv % (i, p) main()"
" import itertools def all_equal(a,b,c,d,e,f,g):    return a+b == b+c+d and a+b == d+e+f and a+b == f+g def foursquares(lo,hi,unique,show):    solutions = 0    if unique:        uorn = strv        citer = itertools.combinations(range(lo,hi+1),7)    else:        uorn = strv        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)     for c in citer:            for p in set(itertools.permutations(c)):                if all_equal(*p):                    solutions += 1                    if show:                        print str(p)[1:-1]     print str(solutions)+strv+uorn+strv+str(lo)+strv+str(hi)    print  def foursquares(lo,hi,unique,show):     def acd_iter():        strv
        Iterates through all the possible valid values of 
        a, c, and d.
 
        a = c + d
        strv        for c in range(lo,hi+1):            for d in range(lo,hi+1):                if (not unique) or (c <> d):                    a = c + d                    if a >= lo and a <= hi:                        if (not unique) or (c <> 0 and d <> 0):                            yield (a,c,d)     def ge_iter():        strv
        Iterates through all the possible valid values of 
        g and e.
 
        g = d + e
        strv        for e in range(lo,hi+1):            if (not unique) or (e not in (a,c,d)):                g = d + e                if g >= lo and g <= hi:                    if (not unique) or (g not in (a,c,d,e)):                        yield (g,e)     def bf_iter():        strv
        Iterates through all the possible valid values of 
        b and f.
 
        b = e + f - c
        strv        for f in range(lo,hi+1):            if (not unique) or (f not in (a,c,d,g,e)):                b = e + f - c                if b >= lo and b <= hi:                    if (not unique) or (b not in (a,c,d,g,e,f)):                        yield (b,f)     solutions = 0                        acd_itr = acd_iter()                  for acd in acd_itr:        a,c,d = acd        ge_itr = ge_iter()        for ge in ge_itr:            g,e = ge            bf_itr = bf_iter()            for bf in bf_itr:                b,f = bf                solutions += 1                if show:                    print str((a,b,c,d,e,f,g))[1:-1]    if unique:        uorn = strv    else:        uorn = strv     print str(solutions)+strv+uorn+strv+str(lo)+strv+str(hi)    print  "
"'''
 The 24 Game Player
 
 Given any four digits in the range 1 to 9, which may have repetitions,
 Using just the +, -, *, and / operators; and the possible use of
 brackets, (), show how to make an answer of 24.
 
 An answer of strv  will quit the game.
 An answer of strv  will generate a new set of four digits.
 An answer of strv will ask you for a new set of four digits.
 An answer of strv  will compute an expression for the current digits.
 
 Otherwise you are repeatedly asked for an expression until it evaluates to 24
 
 Note: you cannot form multiple digit numbers from the supplied digits,
 so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.
 
''' from   __future__ import division, print_functionfrom   itertools  import permutations, combinations, product, \                         chainfrom   pprint     import pprint as ppfrom   fractions  import Fraction as Fimport random, ast, reimport sys if sys.version_info[0] < 3:    input = raw_input    from itertools import izip_longest as zip_longestelse:    from itertools import zip_longest  def choose4():    'four random digits >0 as characters'    return [str(random.randint(1,9)) for i in range(4)] def ask4():    'get four random digits >0 from the player'    digits = ''    while len(digits) != 4 or not all(d in '123456789' for d in digits):        digits = input('Enter the digits to solve for: ')        digits = ''.join(digits.strip().split())    return list(digits) def welcome(digits):    print (__doc__)    print (strv + ' '.join(digits)) def check(answer, digits):    allowed = set('() +-*/'+''.join(digits))    ok = all(ch in allowed for ch in answer) and \         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \         and not re.search('', answer)    if ok:        try:            ast.parse(answer)        except:            ok = False    return ok def solve(digits):    strv
    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():
            solve(list(digits))
 
 
    Solution found: 2 + 3 * 6 + 4
    '2 + 3 * 6 + 4'
    Solution found: ( 4 + 7 - 8 ) * 8
    '( 4 + 7 - 8 ) * 8'
    No solution found for: 1 1 1 1
    '!'
    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6
    '1 + 2 + 3 * ( 4 + 5 ) - 6'
    Solution found: ( 1 + 2 ) * ( 1 + 7 )
    '( 1 + 2 ) * ( 1 + 7 )'
    Solution found: 8 / ( 3 - 8 / 3 )
    '8 / ( 3 - 8 / 3 )'
    >>> strv    digilen = len(digits)    
    exprlen = 2 * digilen - 1    
    digiperm = sorted(set(permutations(digits)))    
    opcomb   = list(product('+-*/', repeat=digilen-1))    
    brackets = ( [()] + [(x,y)                         for x in range(0, exprlen, 2)                         for y in range(x+4, exprlen+2, 2)                         if (x,y) != (0,exprlen+1)]                 + [(0, 3+1, 4+2, 7+3)] ) 
    for d in digiperm:        for ops in opcomb:            if '/' in ops:                d2 = [('F(%s)' % i) for i in d] 
            else:                d2 = d            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))            for b in brackets:                exp = ex[::]                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):                    exp.insert(insertpoint, bracket)                txt = ''.join(exp)                try:                    num = eval(txt)                except ZeroDivisionError:                    continue                if num == 24:                    if '/' in ops:                        exp = [ (term if not term.startswith('F(') else term[2])                               for term in exp ]                    ans = ' '.join(exp).rstrip()                    print (strv,ans)                    return ans    print (strv, ' '.join(digits))                return '!' def main():        digits = choose4()    welcome(digits)    trial = 0    answer = ''    chk = ans = False    while not (chk and ans == 24):        trial +=1        answer = input(strv % trial)        chk = check(answer, digits)        if answer == '?':            solve(digits)            answer = '!'        if answer.lower() == 'q':            break        if answer == '!':            digits = choose4()            trial = 0            print (""New digits:"", ' '.join(digits))            continue        if answer == '!!':            digits = ask4()            trial = 0            print (""New digits:"", ' '.join(digits))            continue        if not chk:            print (strv % answer)        else:            if '/' in answer:                
                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)                                  for char in answer )            ans = eval(answer)            print (strv, ans)            if ans == 24:                print (strv)    print (strv)    main()"
" #!/usr/bin/env python3 import cursesfrom random import randrange, choice 
from collections import defaultdict letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']actions_dict = dict(zip(letter_codes, actions * 2)) def get_user_action(keyboard):    	char = strv	while char not in actions_dict:    		char = keyboard.getch()	return actions_dict[char] def transpose(field):	return [list(row) for row in zip(*field)] def invert(field):	return [row[::-1] for row in field] class GameField(object):	def __init__(self, height=4, width=4, win=2048):		self.height = height		self.width = width		self.win_value = 2048		self.score = 0		self.highscore = 0		self.reset() 	def reset(self):		if self.score > self.highscore:			self.highscore = self.score		self.score = 0		self.field = [[0 for i in range(self.width)] for j in range(self.height)]		self.spawn()		self.spawn() 	def move(self, direction):		def move_row_left(row):			def tighten(row): 
				new_row = [i for i in row if i != 0]				new_row += [0 for i in range(len(row) - len(new_row))]				return new_row 			def merge(row):				pair = False				new_row = []				for i in range(len(row)):					if pair:						new_row.append(2 * row[i])						self.score += 2 * row[i]						pair = False					else:						if i + 1 < len(row) and row[i] == row[i + 1]:							pair = True							new_row.append(0)						else:							new_row.append(row[i])				assert len(new_row) == len(row)				return new_row			return tighten(merge(tighten(row))) 		moves = {}		moves['Left']  = lambda field:								\				[move_row_left(row) for row in field]		moves['Right'] = lambda field:								\				invert(moves['Left'](invert(field)))		moves['Up']    = lambda field:								\				transpose(moves['Left'](transpose(field)))		moves['Down']  = lambda field:								\				transpose(moves['Right'](transpose(field))) 		if direction in moves:			if self.move_is_possible(direction):				self.field = moves[direction](self.field)				self.spawn()				return True			else:				return False 	def is_win(self):		return any(any(i >= self.win_value for i in row) for row in self.field) 	def is_gameover(self):		return not any(self.move_is_possible(move) for move in actions) 	def draw(self, screen):		help_string1 = '(W)Up (S)Down (A)Left (D)Right'		help_string2 = '     (R)Restart (Q)Exit'		gameover_string = '           GAME OVER'		win_string = '          YOU WIN!'		def cast(string):			screen.addstr(string + '') 		def draw_hor_separator():			top = '┌' + ('┬──────' * self.width + '┐')[1:]			mid = '├' + ('┼──────' * self.width + '┤')[1:]			bot = '└' + ('┴──────' * self.width + '┘')[1:]			separator = defaultdict(lambda: mid)			separator[0], separator[self.height] = top, bot			if not hasattr(draw_hor_separator, strv):				draw_hor_separator.counter = 0			cast(separator[draw_hor_separator.counter])			draw_hor_separator.counter += 1 		def draw_row(row):			cast(''.join('│{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '│') 		screen.clear()		cast('SCORE: ' + str(self.score))		if 0 != self.highscore:			cast('HGHSCORE: ' + str(self.highscore))		for row in self.field:			draw_hor_separator()			draw_row(row)		draw_hor_separator()		if self.is_win():			cast(win_string)		else:			if self.is_gameover():				cast(gameover_string)			else:				cast(help_string1)		cast(help_string2) 	def spawn(self):		new_element = 4 if randrange(100) > 89 else 2		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])		self.field[i][j] = new_element 	def move_is_possible(self, direction):		def row_is_left_movable(row): 			def change(i): 
				if row[i] == 0 and row[i + 1] != 0: 
					return True				if row[i] != 0 and row[i + 1] == row[i]: 
					return True				return False			return any(change(i) for i in range(len(row) - 1)) 		check = {}		check['Left']  = lambda field:								\				any(row_is_left_movable(row) for row in field) 		check['Right'] = lambda field:								\				 check['Left'](invert(field)) 		check['Up']    = lambda field:								\				check['Left'](transpose(field)) 		check['Down']  = lambda field:								\				check['Right'](transpose(field)) 		if direction in check:			return check[direction](self.field)		else:			return False def main(stdscr):	curses.use_default_colors()	game_field = GameField(win=32)	state_actions = {} 
	def init():		game_field.reset()		return 'Game' 	state_actions['Init'] = init 	def not_game(state):		game_field.draw(stdscr)		action = get_user_action(stdscr)		responses = defaultdict(lambda: state)		responses['Restart'], responses['Exit'] = 'Init', 'Exit'		return responses[action] 	state_actions['Win'] = lambda: not_game('Win')	state_actions['Gameover'] = lambda: not_game('Gameover') 	def game():		game_field.draw(stdscr)		action = get_user_action(stdscr)		if action == 'Restart':			return 'Init'		if action == 'Exit':			return 'Exit'		if game_field.move(action): 
			if game_field.is_win():				return 'Win'			if game_field.is_gameover():				return 'Gameover'		return 'Game' 	state_actions['Game'] = game 	state = 'Init'	while state != 'Exit':		state = state_actions[state]() curses.wrapper(main) "
" ''' Structural Game for 15 - Puzzle with different difficulty levels'''from random import randint  class Puzzle:    def __init__(self):        self.items = {}        self.position = None     def main_frame(self):        d = self.items        print('+-----+-----+-----+-----+')        print('|%s|%s|%s|%s|' % (d[1], d[2], d[3], d[4]))        print('+-----+-----+-----+-----+')        print('|%s|%s|%s|%s|' % (d[5], d[6], d[7], d[8]))        print('+-----+-----+-----+-----+')        print('|%s|%s|%s|%s|' % (d[9], d[10], d[11], d[12]))        print('+-----+-----+-----+-----+')        print('|%s|%s|%s|%s|' % (d[13], d[14], d[15], d[16]))        print('+-----+-----+-----+-----+')     def format(self, ch):        ch = ch.strip()        if len(ch) == 1:            return '  ' + ch + '  '        elif len(ch) == 2:            return '  ' + ch + ' '        elif len(ch) == 0:            return '     '     def change(self, to):        fro = self.position        for a, b in self.items.items():            if b == self.format(str(to)):                to = a                break        self.items[fro], self.items[to] = self.items[to], self.items[fro]        self.position = to     def build_board(self, difficulty):        for i in range(1, 17):            self.items[i] = self.format(str(i))        tmp = 0        for a, b in self.items.items():            if b == '  16 ':                self.items[a] = '     '                tmp = a                break        self.position = tmp        if difficulty == 0:            diff = 10        elif difficulty == 1:            diff = 50        else:            diff = 100        for _ in range(diff):            lst = self.valid_moves()            lst1 = []            for j in lst:                lst1.append(int(j.strip()))            self.change(lst1[randint(0, len(lst1)-1)])     def valid_moves(self):        pos = self.position        if pos in [6, 7, 10, 11]:            return self.items[pos - 4], self.items[pos - 1],\                   self.items[pos + 1], self.items[pos + 4]        elif pos in [5, 9]:            return self.items[pos - 4], self.items[pos + 4],\                   self.items[pos + 1]        elif pos in [8, 12]:            return self.items[pos - 4], self.items[pos + 4],\                   self.items[pos - 1]        elif pos in [2, 3]:            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]        elif pos in [14, 15]:            return self.items[pos - 1], self.items[pos + 1],\                  self.items[pos - 4]        elif pos == 1:            return self.items[pos + 1], self.items[pos + 4]        elif pos == 4:            return self.items[pos - 1], self.items[pos + 4]        elif pos == 13:            return self.items[pos + 1], self.items[pos - 4]        elif pos == 16:            return self.items[pos - 1], self.items[pos - 4]     def game_over(self):        flag = False        for a, b in self.items.items():            if b == '     ':                pass            else:                if a == int(b.strip()):                    flag = True                else:                    flag = False        return flag  g = Puzzle()g.build_board(int(input('Enter the difficulty : 0 1 22 '                        '=> highest 0=> lowest')))g.main_frame()print('Enter 0 to exit')while True:    print('Hello user:To change the position just enter the no. near it')    lst = g.valid_moves()    lst1 = []    for i in lst:        lst1.append(int(i.strip()))        print(i.strip(), '', end='')    print()    x = int(input())    if x == 0:        break    elif x not in lst1:        print('Wrong move')    else:        g.change(x)    g.main_frame()    if g.game_over():        print('You WON')        break "
" doors = [False] * 100for i in range(100):   for j in range(i, 100, i+1):       doors[j] = not doors[j]   print(strv % (i+1), 'open' if doors[i] else 'close') for i in xrange(1, 101):    root = i ** 0.5    print strv % i, 'open' if root == int(root) else 'close'print ''.join(['Door %s is %s' % (i, ('closed', 'open')[(i**0.5).is_integer()]) for i in xrange(1, 101)])print ''.join('Door %s is %s' % (i, 'closed' if i**0.5 % 1 else 'open') for i in range(1, 101)) for i in range(1, 101):    if i**0.5 % 1:        state='open'    else:        state='close'    print(strv.format(i, state)) for i in range(1,11): print(strv % i**2)def (doors n)  let door (table)    for step 1 (step <= n) ++step      for j 0 (j < n) (j <- j+step)        zap! not door.j     for j 0 (j < n) ++j      when door.j        pr j        pr strv"
"import random, rechars = [strv,strv,strv,strv,strv,strv]  while True:    charsandints, ints = [], []    for x in range(4):        ints.append(str(random.randrange(1,10)))    charsandints = chars + ints    print strv, ints    guess = raw_input(strv)    if guess.lower() == strv:        break    elif guess.lower() == strv:        pass    else:        flag = True        for a in guess:            if a not in charsandints or guess.count(a) > charsandints.count(a):                flag = False        if re.search("""", guess):            print strv            break        if flag:            print strv, eval(guess)            if eval(guess) == 24:                print strv                break            else:                print strv                break        else:            print strv, charsandints            breakprint strv'''
 The 24 Game
 
 Given any four digits in the range 1 to 9, which may have repetitions,
 Using just the +, -, *, and / operators; and the possible use of
 brackets, (), show how to make an answer of 24.
 
 An answer of strv will quit the game.
 An answer of strv will generate a new set of four digits.
 Otherwise you are repeatedly asked for an expression until it evaluates to 24
 
 Note: you cannot form multiple digit numbers from the supplied digits,
 so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.
 
''' from __future__ import division, print_functionimport random, ast, reimport sys if sys.version_info[0] < 3: input = raw_input def choose4():    'four random digits >0 as characters'    return [str(random.randint(1,9)) for i in range(4)] def welcome(digits):    print (__doc__)    print (strv + ' '.join(digits)) def check(answer, digits):    allowed = set('() +-*/'+''.join(digits))    ok = all(ch in allowed for ch in answer) and \         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \         and not re.search('', answer)    if ok:        try:            ast.parse(answer)        except:            ok = False    return ok def main():        digits = choose4()    welcome(digits)    trial = 0    answer = ''    chk = ans = False    while not (chk and ans == 24):        trial +=1        answer = input(strv % trial)        chk = check(answer, digits)        if answer.lower() == 'q':            break        if answer == '!':            digits = choose4()            print (strv, ' '.join(digits))            continue        if not chk:            print (strv % answer)        else:            ans = eval(answer)            print (strv, ans)            if ans == 24:                print (strv)    print (strv)    if __name__ == '__main__': main() "
