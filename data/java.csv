keywords
"import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.commons.net.ftp.FTP;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;
 
public class FTPconn {
 
    public static void main([] args) throws  {
         server = strv;
        int port = 21;
         user = strv;
         pass = """";
 
         output = null;
 
        FTPClient ftpClient = new FTPClient();
        try {
            ftpClient.connect(server, port);
 
            serverReply(ftpClient);
 
            int replyCode = ftpClient.getReplyCode();
            if (!FTPReply.isPositiveCompletion(replyCode)) {
                .out.println(strv + replyCode);
                return;
            }
 
            serverReply(ftpClient);
 
            if (!ftpClient.login(user, pass)) {
                .out.println(strv);
                return;
            }
 
             dir = strv;
            if (!ftpClient.changeWorkingDirectory(dir)) {
                .out.println(strv);
                return;
            }
 
            ftpClient.enterLocalPassiveMode();
 
            for (FTPFile file : ftpClient.listFiles())
                .out.println(file);
 
             filename = strv;
            output = new (filename);
 
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            if (!ftpClient.retrieveFile(filename, output)) {
                .out.println(strv);
                return;
            }
 
            serverReply(ftpClient);
 
            ftpClient.logout();
 
        } finally {
            if (output != null)
                output.close();
        }
    }
 
    private static void serverReply(FTPClient ftpClient) {
        for ( reply : ftpClient.getReplyStrings()) {
            .out.println(reply);
        }
    }
}"
"import java.io.File;
 
public interface Test {
 
    public static void main([] args) {
        try {
             f = new (strv);
            if (f.mkdirs())
                .out.println(strv);
        } catch ( e) {
            e.printStackTrace();
        }
    }
}"
"import java.math.*;
 
public class Hickerson {
 
    final static  LN2 = strv;
 
    public static void main([] args) {
        for (int n = 1; n <= 17; n++)
            .out.printf(strv, n, almostInteger(n));
    }
 
    static boolean almostInteger(int n) {
         a = new (LN2);
        a = a.pow(n + 1).multiply(.valueOf(2));
 
        long f = n;
        while (--n > 1)
            f *= n;
 
         b = new (f);
        b = b.divide(a, MathContext.DECIMAL128);
 
         c = b.movePointRight(1).toBigInteger().mod(.TEN);
 
        return c.toString().matches(strv);
    }
}"
"import java.awt.Point;
import java.util.*;
 
public class ZhangSuen {
 
    final static [] image = {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv};
 
    final static int[][] nbrs = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1},
        {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}};
 
    final static int[][][] nbrGroups = {{{0, 2, 4}, {2, 4, 6}}, {{0, 2, 6},
        {0, 4, 6}}};
 
    static List<Point> toWhite = new ArrayList<>();
    static char[][] grid;
 
    public static void main([] args) {
        grid = new char[image.length][];
        for (int r = 0; r < image.length; r++)
            grid[r] = image[r].toCharArray();
 
        thinImage();
    }
 
    static void thinImage() {
        boolean firstStep = false;
        boolean hasChanged;
 
        do {
            hasChanged = false;
            firstStep = !firstStep;
 
            for (int r = 1; r < grid.length - 1; r++) {
                for (int c = 1; c < grid[0].length - 1; c++) {
 
                    if (grid[r][c] != '#')
                        continue;
 
                    int nn = numNeighbors(r, c);
                    if (nn < 2 || nn > 6)
                        continue;
 
                    if (numTransitions(r, c) != 1)
                        continue;
 
                    if (!atLeastOneIsWhite(r, c, firstStep ? 0 : 1))
                        continue;
 
                    toWhite.add(new (c, r));
                    hasChanged = true;
                }
            }
 
            for ( p : toWhite)
                grid[p.y][p.x] = ' ';
            toWhite.clear();
 
        } while (firstStep || hasChanged);
 
        printResult();
    }
 
    static int numNeighbors(int r, int c) {
        int count = 0;
        for (int i = 0; i < nbrs.length - 1; i++)
            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == '#')
                count++;
        return count;
    }
 
    static int numTransitions(int r, int c) {
        int count = 0;
        for (int i = 0; i < nbrs.length - 1; i++)
            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == ' ') {
                if (grid[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == '#')
                    count++;
            }
        return count;
    }
 
    static boolean atLeastOneIsWhite(int r, int c, int step) {
        int count = 0;
        int[][] group = nbrGroups[step];
        for (int i = 0; i < 2; i++)
            for (int j = 0; j < group[i].length; j++) {
                int[] nbr = nbrs[group[i][j]];
                if (grid[r + nbr[1]][c + nbr[0]] == ' ') {
                    count++;
                    break;
                }
            }
        return count > 1;
    }
 
    static void printResult() {
        for (char[] row : grid)
            .out.println(row);
    }
}"
"public static int[][] Zig_Zag(final int size)
{
 int[][] data = new int[size][size];
 int i = 1;
 int j = 1;
 for (int element = 0; element < size * size; element++)
 {
  data[i - 1][j - 1] = element;
  if ((i + j) % 2 == 0)
  {
   

   if (j < size)
    j++;
   else
    i+= 2;
   if (i > 1)
    i--;
  }
  else
  {
   

   if (i < size)
    i++;
   else
    j+= 2;
   if (j > 1)
    j--;
  }
 }
 return data;
}"
".out.println(.pow(0, 0));"
"import java.util.*;
 
class Zeckendorf
{
  public static  getZeckendorf(int n)
  {
    if (n == 0)
      return strv;
    List<Integer> fibNumbers = new ArrayList<Integer>();
    fibNumbers.add(1);
    int nextFib = 2;
    while (nextFib <= n)
    {
      fibNumbers.add(nextFib);
      nextFib += fibNumbers.get(fibNumbers.size() - 2);
    }
    StringBuilder sb = new StringBuilder();
    for (int i = fibNumbers.size() - 1; i >= 0; i--)
    {
      int fibNumber = fibNumbers.get(i);
      sb.append((fibNumber <= n) ? strv : strv);
      if (fibNumber <= n)
        n -= fibNumber;
    }
    return sb.toString();
  }
 
  public static void main([] args)
  {
    for (int i = 0; i <= 20; i++)
      .out.println(strv + i + strv + getZeckendorf(i));
  }
}import java.util.ArrayList;
import java.util.List;
 
public class Zeckendorf {
 
    private List<Integer> getFibList(final int maxNum, final int n1, final int n2, final List<Integer> fibs){
        if(n2 > maxNum) return fibs;
 
        fibs.add(n2);
 
        return getFibList(maxNum, n2, n1 + n2, fibs);
    }
 
    public  getZeckendorf(final int num) {
        if (num <= 0) return strv;
 
        final List<Integer> fibs = getFibList(num, 1, 2, new ArrayList<Integer>(){{ add(1); }});
 
        return getZeckString(strv, num, fibs.size() - 1, fibs);
    }
 
    private  getZeckString(final  zeck, final int num, final int index, final List<Integer> fibs){
        final int curFib = fibs.get(index);
        final boolean placeZeck = num >= curFib;
 
        final  outString = placeZeck ? zeck + strv : zeck + strv;
        final int outNum = placeZeck ? num - curFib : num;
 
        if(index == 0) return outString;
 
        return  getZeckString(outString, outNum, index - 1, fibs);
    }
 
    public static void main(final [] args) {
        final Zeckendorf zeckendorf = new Zeckendorf();
 
        for(int i =0; i <= 20; i++){
            .out.println(strv+ i +""):"" + zeckendorf.getZeckendorf(i));
        }
    }
}"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
class YahooSearch {
    private  query;
    

    private int page = 1;
    

    private static final Pattern pattern = Pattern.compile(
        ""<a class=yschttl spt href=[^*]+?**([^]+?)>(.+?)</a></h3>.*?<div class=(?:sm-abs|abstr)>(.+?)</div>"");
 
    public YahooSearch( query) {
        this.query = query;
    }
 
    public List<YahooResult> search() throws , URISyntaxException,  {
        

        

        StringBuilder searchUrl = new StringBuilder(strv);
        searchUrl.append(strv).append(.encode(query, strv));
        if (page > 1) {searchUrl.append(strv).append((page - 1) * 10 + 1);}
        

         url = new (searchUrl.toString());
        List<YahooResult> result = new ArrayList<YahooResult>();
        StringBuilder sb = new StringBuilder();
        

         in = null;
        try {
            in = new (new (url.openStream()));
            

             line = in.readLine();
            while (line != null) {
                sb.append(line);
                line = in.readLine();
            }
        }
        catch ( ioe) {
            ioe.printStackTrace();
        }
        finally {
            try {in.close();} catch ( ignoreMe) {}
        }
         searchResult = sb.toString();
        

        Matcher matcher = pattern.matcher(searchResult);
        while (matcher.find()) {
            

             resultUrl = .decode(matcher.group(1), strv);
             resultTitle = matcher.group(2).replaceAll(strv, strv).replaceAll(strv, strv);
             resultContent = matcher.group(3).replaceAll(strv, strv).replaceAll(strv, strv);
            

            result.add(new YahooResult(resultUrl, resultTitle, resultContent));
        }
        return result;
    }
 
    public List<YahooResult> search(int page) throws , URISyntaxException,  {
        

        this.page = page;
        return search();
    }
 
    public List<YahooResult> nextPage() throws , URISyntaxException,  {
        

        page++;
        return search();
    }
 
    public List<YahooResult> previousPage() throws , URISyntaxException,  {
        

        if (page > 1) {
            page--;
            return search();
        } else return new ArrayList<YahooResult>();
    }
}
 
class YahooResult {
    private  url;
    private  title;
    private  content;
 
    public  getUrl() {
        return url;
    }
 
    public void setUrl( url) {
        this.url = url;
    }
 
    public void setUrl( url) throws  {
        this.url = new (url);
    }
 
    public  getTitle() {
        return title;
    }
 
    public void setTitle( title) {
        this.title = title;
    }
 
    public  getContent() {
        return content;
    }
 
    public void setContent( content) {
        this.content = content;
    }
 
    public YahooResult( url,  title,  content) {
        setUrl(url);
        setTitle(title);
        setContent(content);
    }
 
    public YahooResult( url,  title,  content) throws  {
        setUrl(url);
        setTitle(title);
        setContent(content);
    }
 
    @Override
    public  toString() {
        StringBuilder sb = new StringBuilder();
        if (title != null) {
            sb.append(strv).append(title);
        }
        if (url != null) {
            sb.append(strv).append(url);
        }
        return sb.charAt(0) == ',' ? sb.substring(1) : sb.toString();
    }
}
 
public class TestYahooSearch {
    public static void main([] args) throws , URISyntaxException,  {
        

        YahooSearch search = new YahooSearch(strv);
        

        List<YahooResult> results = search.search();
        

        for (YahooResult result : results) {
            .out.println(result.toString());
        }
    }
}"
"package org.rosettacode.yinandyang;
 
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
 
public class YinYangGenerator
{
    private final int size;
 
    public YinYangGenerator(final int size)
    {
        this.size = size;
    }
 
    /**     *  Draw a yin yang symbol on the given graphics context.     */
    public void drawYinYang(final  graphics)
    {
        

        final  colorSave = graphics.getColor();
 
        graphics.setColor(.WHITE);
        

        graphics.fillOval(0, 0, size-1, size-1);
 
        graphics.setColor(.BLACK);
        

        graphics.fillArc(0, 0, size-1, size-1, 270, 180);
        graphics.fillOval(size/4, size/2, size/2, size/2);
 
        graphics.setColor(.WHITE);
        graphics.fillOval(size/4, 0, size/2, size/2);
        graphics.fillOval(7*size/16, 11*size/16, size/8, size/8);
 
        graphics.setColor(.BLACK);
        graphics.fillOval(7*size/16, 3*size/16, size/8, size/8);
        

        graphics.drawOval(0, 0, size-1, size-1);
 
        

        graphics.setColor(colorSave);
    }
 
    /**     *  Create an image containing a yin yang symbol.     */
    public  createImage(final  bg)
    {
        

        final  image = new (size, size, .TYPE_INT_RGB);
        

        

        

        final  graphics = image.getGraphics();
        

        graphics.setColor(bg);
        graphics.fillRect(0,0,size,size);
        drawYinYang(graphics);
        return image;
    }
 
    public static void main(final  args[])
    {
        final int size = .parseInt(args[0]);
        final YinYangGenerator generator = new YinYangGenerator(size);
 
        final  frame = new (strv);
        frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
        final  yinYang = generator.createImage(frame.getBackground());
        

        frame.add(new (new (yinYang)));
        frame.pack();
        frame.setVisible(true);
    }
}import java.util.Collection;
import java.util.Map;
import java.util.Optional;
import java.util.function.BooleanSupplier;
import java.util.function.Supplier;
import java.util.stream.IntStream;
import java.util.stream.Stream;
 
import static java.util..singletonMap;
 
public interface YinYang {
  public static boolean circle(
    int x,
    int y,
    int c,
    int r
  ) {
    return
      (r * r) >=
        ((x = x / 2) * x)
         + ((y = y - c) * y)
    ;
  }
 
  public static  pixel(int x, int y, int r) {
    return Stream.<Map<BooleanSupplier, Supplier<String>>>of(
      singletonMap(
        () -> circle(x, y, -r / 2, r / 6),
        () -> strv
      ),
      singletonMap(
        () -> circle(x, y, r / 2, r / 6),
        () -> strv
      ),
      singletonMap(
        () -> circle(x, y, -r / 2, r / 2),
        () -> strv
      ),
      singletonMap(
        () -> circle(x, y, r / 2, r / 2),
        () -> strv
      ),
      singletonMap(
        () -> circle(x, y, 0, r),
        () -> x < 0 ? strv : strv
      )
    )
      .sequential()
      .map(::entrySet)
      .flatMap(::stream)
      .filter(e -> e.getKey().getAsBoolean())
      .map(::getValue)
      .map(Supplier::get)
      .findAny()
      .orElse(strv)
    ;
  }
 
  public static void yinYang(int r) {
    IntStream.rangeClosed(-r, r)
      .mapToObj(
        y ->
          IntStream.rangeClosed(
            0 - r - r,
            r + r
          )
            .mapToObj(x -> pixel(x, y, r))
            .reduce(strv, ::concat)
      )
      .forEach(.out::println)
    ;
  }
 
  public static void main(... arguments) {
    Optional.of(arguments)
      .filter(a -> a.length == 1)
      .map(a -> a[0])
      .map(::parseInt)
      .ifPresent(YinYang::yinYang)
    ;
  }
}
 "
" 
package zebra;
 
public class LineOfPuzzle implements {
 
    private  order;
    private  nation; 
    private  color; 
    private  animal;
    private  drink;
    private  cigarette;
 
    private LineOfPuzzle rightNeighbor;
    private LineOfPuzzle leftNeighbor;
    private PuzzleSet<LineOfPuzzle> undefNeighbors;
 
    public LineOfPuzzle ( order,  nation,  color, 
                          animal,  drink,  cigarette){
 
        this.animal=animal;
        this.cigarette=cigarette;
        this.color=color;
        this.drink=drink;
        this.nation=nation;
        this.order=order;                
    }
 
    public  getOrder() {
        return order;
    }
 
    public void setOrder( order) {
        this.order = order;
    }
 
    public  getNation() {
        return nation;
    }
 
    public void setNation( nation) {
        this.nation = nation;
    }
 
    public  getColor() {
        return color;
    }
 
    public void setColor( color) {
        this.color = color;
    }
 
    public  getAnimal() {
        return animal;
    }
 
    public void setAnimal( animal) {
        this.animal = animal;
    }
 
    public  getDrink() {
        return drink;
    }
 
    public void setDrink( drink) {
        this.drink = drink;
    }
 
    public  getCigarette() {
        return cigarette;
    }
 
    public void setCigarette( cigarette) {
        this.cigarette = cigarette;
    }
 
    /**     * Overrides object equal method     * @param obj     * @return     */
    @Override
    public boolean equals( obj) {
        if (obj instanceof LineOfPuzzle){
            LineOfPuzzle searchLine = (LineOfPuzzle)obj;
            return  this.getWholeLine().equalsIgnoreCase(searchLine.getWholeLine());
        }
        else
            return false;
    }
 
    public int getFactsCount(){
        int facts = 0;
        facts+=this.getOrder()!=null?1:0;
        facts+=this.getNation()!=null?1:0;
        facts+=this.getColor()!=null?1:0;
        facts+=this.getAnimal()!=null?1:0;
        facts+=this.getCigarette()!=null?1:0;
        facts+=this.getDrink()!=null?1:0;
        return facts;
    }
 
    public int getCommonFactsCount(LineOfPuzzle lineOfFacts){
        int ordrCmp = (this.order!=null && lineOfFacts.getOrder()!= null &&
                       this.order.intValue()== lineOfFacts.getOrder().intValue())?1:0;        
 
        int natnCmp = (this.nation!=null && lineOfFacts.getNation()!= null && 
                       this.nation.equalsIgnoreCase(lineOfFacts.getNation()))?1:0;
 
        int colrCmp = (this.color!=null && lineOfFacts.getColor()!= null && 
                       this.color.equalsIgnoreCase(lineOfFacts.getColor()))?1:0;
 
        int petsCmp = (this.animal!=null && (lineOfFacts.getAnimal()!= null && 
                       this.animal.equalsIgnoreCase(lineOfFacts.getAnimal())))?1:0;
 
        int cigrCmp = (this.cigarette!=null && lineOfFacts.getCigarette()!= null && 
                       this.cigarette.equalsIgnoreCase(lineOfFacts.getCigarette()))?1:0;
 
        int drnkCmp = (this.drink!=null && lineOfFacts.getDrink()!= null && 
                       this.drink.equalsIgnoreCase(lineOfFacts.getDrink()))?1:0;
 
        int result = (ordrCmp + natnCmp + colrCmp + petsCmp + cigrCmp + drnkCmp);
 
        return result;
    } 
 
    public void addUndefindedNeighbor(LineOfPuzzle newNeighbor){        
        if (this.undefNeighbors==null) 
            this.undefNeighbors = new PuzzleSet<>();
 
        this.undefNeighbors.add(newNeighbor);
    }
 
    public boolean hasUndefNeighbors(){
        return (this.undefNeighbors!=null);
    } 
 
    public PuzzleSet<LineOfPuzzle> getUndefNeighbors(){
        return this.undefNeighbors;
    }
 
    public void setLeftNeighbor(LineOfPuzzle leftNeighbor){
        this.leftNeighbor = leftNeighbor;
        this.leftNeighbor.setOrder(this.order - 1);        
    }
 
    public void setRightNeighbor(LineOfPuzzle rightNeighbor){
        this.rightNeighbor=rightNeighbor;                    
        this.rightNeighbor.setOrder(this.order + 1);        
    }
 
    public boolean hasLeftNeighbor(){
        return (leftNeighbor!=null);
    }
 
    public LineOfPuzzle getLeftNeighbor(){
        return this.leftNeighbor;
    }
 
    public boolean hasNeighbor(int direction){
        if (direction < 0) 
            return (leftNeighbor!=null);
        else
            return (rightNeighbor!=null);
    }
 
    public boolean hasRightNeighbor(){
        return (rightNeighbor!=null);
    } 
 
    public LineOfPuzzle getRightNeighbor(){
        return this.rightNeighbor;
    }
 
    public LineOfPuzzle getNeighbor(int direction){
        if (direction < 0) 
            return this.leftNeighbor;
        else
            return this.rightNeighbor;
    }
 
    public  getWholeLine() {
         sLine = this.order + strv + 
                       this.nation + strv +
                       this.color + strv + 
                       this.animal + strv +                       
                       this.drink + strv +
                       this.cigarette;
            return sLine;
    }    
 
    @Override
    public int hashCode() {
        int sLine = (this.order + strv +
                     this.nation + strv +
                     this.color + strv + 
                     this.animal + strv +
                     this.drink + strv +
                     this.cigarette
                ).hashCode();
        return sLine;
    }    
 
    public void merge(LineOfPuzzle mergedLine){        
        if (this.order == null) this.order = mergedLine.order;    
        if (this.nation == null) this.nation = mergedLine.nation;    
        if (this.color == null) this.color = mergedLine.color;    
        if (this.animal == null) this.animal = mergedLine.animal;    
        if (this.drink == null) this.drink = mergedLine.drink;    
        if (this.cigarette == null) this.cigarette = mergedLine.cigarette;            
    }
 
 
    public LineOfPuzzle clone() {
        try {
            return (LineOfPuzzle) super.clone();
        } catch ( e) {        
            e.printStackTrace();
            throw new ();
        }
    }
}
  
package zebra;
 
import java.util.Iterator;
import java.util.LinkedHashSet;
 
public class PuzzleSet<T extends LineOfPuzzle> extends LinkedHashSet{     
    private T t;
 
    private int countOfOne=0;
    private int countOfTwo=0;
    private int countOfThree=0;
    private int countOfFour=0;
    private int countOfFive=0;
 
    PuzzleSet() {
        super();        
    }
 
    public void set(T t) { this.t = t; }    
 
    public T get(int index) { 
        return ((T)this.toArray()[index]); 
    }   
 
    public PuzzleSet<T> getSimilarLines(T searchLine) { 
        PuzzleSet<T> puzzleSubSet = new PuzzleSet<>();
        for (Iterator<T> it = this.iterator(); it.hasNext();) {
            T lineOfPuzzle = it.next();
 
            if(lineOfPuzzle.getCommonFactsCount(searchLine) == searchLine.getFactsCount())
                puzzleSubSet.add(lineOfPuzzle);            
        }
        if (puzzleSubSet.isEmpty()) 
            return null;
 
        return puzzleSubSet; 
    }   
 
    public boolean contains(T searchLine) {
        for (Iterator<T> it = this.iterator(); it.hasNext();) {
            T puzzleLine = it.next();
 
            if(puzzleLine.getCommonFactsCount(searchLine) == searchLine.getFactsCount())
                return true;
        }
        return false;
    }
 
    public boolean accepts(T searchLine) {
        int passed=0;
        int notpassed=0;
 
        for (Iterator<T> it = this.iterator(); it.hasNext();) {
            T puzzleSetLine = it.next();
 
            int lineFactsCnt = puzzleSetLine.getFactsCount();
            int comnFactsCnt = puzzleSetLine.getCommonFactsCount(searchLine);
 
            if( lineFactsCnt != comnFactsCnt && lineFactsCnt !=0 && comnFactsCnt !=0){
                notpassed++;        
            }
 
            if( lineFactsCnt == comnFactsCnt)
                passed++;
        }
        return (passed >= 0 && notpassed == 0);        
    }
 
    public void riseLineCountFlags(int lineOrderId){         
         switch (lineOrderId){
             case 1: countOfOne++; break;
             case 2: countOfTwo++; break;
             case 3: countOfThree++; break;
             case 4: countOfFour++; break;                 
             case 5: countOfFive++; break;
             default:;
         }
     }
 
    public void clearLineCountFlags(){         
        countOfOne=0;
        countOfTwo=0;
        countOfThree=0;
        countOfFour=0;                 
        countOfFive=0;
     }
 
    public int getLineCountByOrderId(int lineOrderId){
         switch (lineOrderId){
             case 1: return countOfOne;
             case 2: return countOfTwo;
             case 3: return countOfThree;
             case 4: return countOfFour;                 
             case 5: return countOfFive;
             default:return -1;
         }
    }
}
  
package zebra;
 
import java.util.ArrayList;
import java.util.Iterator;
 
public class Puzzle {
    private static final ArrayList<Integer> orders = new ArrayList<>(5);
    private static final ArrayList<String> nations = new ArrayList<>(5);
    private static final ArrayList<String> animals = new ArrayList<>(5);
    private static final ArrayList<String> drinks = new ArrayList<>(5);
    private static final ArrayList<String> cigarettes = new ArrayList<>(5);
    private static final ArrayList<String> colors = new ArrayList<>(5);
    private static PuzzleSet<LineOfPuzzle> puzzleTable; 
    static
    {
        

        orders.add(1);
        orders.add(2);
        orders.add(3);
        orders.add(4);
        orders.add(5);
        

        nations.add(strv);
        nations.add(strv);
        nations.add(strv);
        nations.add(strv);
        nations.add(strv);
        //Animals
        animals.add(strv);
        animals.add(strv);
        animals.add(strv);
        animals.add(strv);
        animals.add(strv);
        //Drinks
        drinks.add(strv);
        drinks.add(strv);
        drinks.add(strv);
        drinks.add(strv);
        drinks.add(strv);        
        //Smokes
        cigarettes.add(strv);
        cigarettes.add(strv);
        cigarettes.add(strv);
        cigarettes.add(strv);
        cigarettes.add(strv);        
        //Colors
        colors.add(strv);
        colors.add(strv);
        colors.add(strv);
        colors.add(strv);
        colors.add(strv);       
    }    
 
    public static void main ([] args){        
        boolean validLine=true;
        puzzleTable = new PuzzleSet<>();
 
        //Rules
        LineOfPuzzle rule2 = new LineOfPuzzle(null, strv, strv, null, null, null);
        LineOfPuzzle rule3 = new LineOfPuzzle(null, strv, null, strv, null, null);
        LineOfPuzzle rule4 = new LineOfPuzzle(null, strv, null, null, strv, null);
        LineOfPuzzle rule6 = new LineOfPuzzle(null, null, strv, null, strv, null);
        LineOfPuzzle rule7 = new LineOfPuzzle(null, null, null, strv, null, strv);
        LineOfPuzzle rule8 = new LineOfPuzzle(null, null, strv, null, null, strv);
        LineOfPuzzle rule9 = new LineOfPuzzle(3, null, null, null, strv, null);
        LineOfPuzzle rule10 = new LineOfPuzzle(1, strv, null, null, null, null);
        LineOfPuzzle rule13 = new LineOfPuzzle(null, null, null, null, strv, strv);
        LineOfPuzzle rule14 = new LineOfPuzzle(null, strv, null, null, null, strv);
        LineOfPuzzle rule15 = new LineOfPuzzle(2, null, strv, null, null, null);
 
        PuzzleSet<LineOfPuzzle> ruleSet = new PuzzleSet<>();
        ruleSet.add(rule2);
        ruleSet.add(rule3);
        ruleSet.add(rule4);
        ruleSet.add(rule6);
        ruleSet.add(rule7);
        ruleSet.add(rule8);
        ruleSet.add(rule9);
        ruleSet.add(rule10);
        ruleSet.add(rule13);
        ruleSet.add(rule14);
        ruleSet.add(rule15);
 
        //Creating all possible combination of a puzzle line. 
        //The maximum number of lines is 5^^6 (15625).
        //Each combination line is checked against a set of knowing facts, thus
        //only a small number of line result at the end.
        for ( orderId : Puzzle.orders) {            
            for ( nation : Puzzle.nations) {                
                for ( color : Puzzle.colors) {                    
                    for ( animal : Puzzle.animals) {                        
                        for ( drink : Puzzle.drinks) {                            
                            for ( cigarette : Puzzle.cigarettes) {
                                LineOfPuzzle pzlLine = new LineOfPuzzle(orderId, 
                                                                     nation, 
                                                                     color,
                                                                     animal,
                                                                     drink,
                                                                     cigarette);
                                

                                if (ruleSet.accepts(pzlLine)){                                      
                                        

                                        if (cigarette.equalsIgnoreCase(strv) 
                                                && (animal.equalsIgnoreCase(strv) 
                                                || drink.equalsIgnoreCase(strv)))
                                            validLine = false;
 
                                        if (cigarette.equalsIgnoreCase(strv) 
                                                && animal.equalsIgnoreCase(strv))
                                            validLine = false;
 
                                        if (validLine){
                                            puzzleTable.add(pzlLine);
 
                                            //set neighbors constraints
                                            if (color.equalsIgnoreCase(strv)){
                                                pzlLine.setRightNeighbor(new LineOfPuzzle(null, null, strv, null, null, null));
                                            }                                        
                                            if (color.equalsIgnoreCase(strv)){
                                                pzlLine.setLeftNeighbor(new LineOfPuzzle(null, null, strv, null, null, null));
                                            }
                                            //
                                            if (animal.equalsIgnoreCase(strv) 
                                                    && !cigarette.equalsIgnoreCase(strv) ){
                                                pzlLine.addUndefindedNeighbor(new LineOfPuzzle(null, null, null, null, null, strv));
                                            }                                                                  
                                            if (cigarette.equalsIgnoreCase(strv) 
                                                    && !animal.equalsIgnoreCase(strv)){
                                                pzlLine.addUndefindedNeighbor(new LineOfPuzzle(null, null, null, strv, null, null));
                                            }
                                            //
                                            if (drink.equalsIgnoreCase(strv) 
                                                    && !animal.equalsIgnoreCase(strv) 
                                                    && !cigarette.equalsIgnoreCase(strv)){
                                                pzlLine.addUndefindedNeighbor(new LineOfPuzzle(null, null, null, null, null, strv));
                                            }
 
                                            if (cigarette.equalsIgnoreCase(strv) 
                                                    && !drink.equalsIgnoreCase(strv)){
                                                pzlLine.addUndefindedNeighbor(new LineOfPuzzle(null, null, null, null, strv, null));
                                            }                                        
                                            //
                                            if (animal.equalsIgnoreCase(strv) 
                                                    && !cigarette.equalsIgnoreCase(strv)){
                                                pzlLine.addUndefindedNeighbor(new LineOfPuzzle(null, null, null, null, null, strv));
                                            }
                                            if (cigarette.equalsIgnoreCase(strv) 
                                                    && !animal.equalsIgnoreCase(strv)){
                                                pzlLine.addUndefindedNeighbor(new LineOfPuzzle(null, null, null, strv, null, null));
                                            }                                               
                                        }
                                        validLine = true;
                                }
                            } //cigarette end
                        } //drinks end
                    } //animal end
                } //color end                    
            } //nations end
        } //order end
 
        .out.println(strv+ 
                                                puzzleTable.size() + strv);      
 
        for (Iterator<LineOfPuzzle> it = puzzleTable.iterator(); it.hasNext();){
            validLine=true;
 
            LineOfPuzzle lineOfPuzzle = it.next();
 
            if (lineOfPuzzle.hasLeftNeighbor()){
                LineOfPuzzle neighbor = lineOfPuzzle.getLeftNeighbor();                
                if (neighbor.getOrder()<1 || neighbor.getOrder()>5){
                    validLine=false;
                    it.remove();
 
                }
            }
            if (validLine && lineOfPuzzle.hasRightNeighbor()){
                LineOfPuzzle neighbor = lineOfPuzzle.getRightNeighbor();                
                if (neighbor.getOrder()<1 || neighbor.getOrder()>5){
                    it.remove();
                }                
            }                        
        }
 
        .out.println(strv + 
                                                puzzleTable.size() + strv);        
 
        //Setting left and right neighbors
        for (Iterator<LineOfPuzzle> it = puzzleTable.iterator(); it.hasNext();) {
            LineOfPuzzle puzzleLine = it.next();
 
            if (puzzleLine.hasUndefNeighbors()){
                for (Iterator<LineOfPuzzle> it1 = puzzleLine.getUndefNeighbors().iterator(); it1.hasNext();) {
                    LineOfPuzzle leftNeighbor = it1.next();
                    LineOfPuzzle rightNeighbor = leftNeighbor.clone();
 
                    //make it left neighbor
                    leftNeighbor.setOrder(puzzleLine.getOrder()-1);
                    if (puzzleTable.contains(leftNeighbor)){
                        if (puzzleLine.hasLeftNeighbor())
                            puzzleLine.getLeftNeighbor().merge(leftNeighbor);
                        else
                            puzzleLine.setLeftNeighbor(leftNeighbor);
                    }
                    rightNeighbor.setOrder(puzzleLine.getOrder()+1);
                    if (puzzleTable.contains(rightNeighbor)){
                        if (puzzleLine.hasRightNeighbor())
                            puzzleLine.getRightNeighbor().merge(rightNeighbor);
                        else
                            puzzleLine.setRightNeighbor(rightNeighbor);
                    }                    
                }
            }
        }
 
        int iteration=1;
        int lastSize=0;
 
        //Recursively validate against neighbor rules
        while (puzzleTable.size()>5 && lastSize != puzzleTable.size()) {
            lastSize = puzzleTable.size();
            puzzleTable.clearLineCountFlags();
 
            recursiveSearch(null, puzzleTable, -1);
 
            ruleSet.clear();
            

            

            for (int i = 1; i < 6; i++) {
                if (puzzleTable.getLineCountByOrderId(i)==1)
                   ruleSet.addAll(puzzleTable.getSimilarLines(new LineOfPuzzle(i, null, null, null, null, null)));
            }
 
            for (Iterator<LineOfPuzzle> it = puzzleTable.iterator(); it.hasNext();) {
                LineOfPuzzle puzzleLine = it.next();
 
                if (!ruleSet.accepts(puzzleLine))
                    it.remove();           
            }
            //
            .out.println(strv + iteration + strv
                                                + puzzleTable.size() + strv);
            iteration+=1;            
        }        
 
        

        .out.println(strv);  
        if (puzzleTable.size()==5){
            for (Iterator<LineOfPuzzle> it = puzzleTable.iterator(); it.hasNext();) {
            LineOfPuzzle puzzleLine = it.next();
                .out.println(puzzleLine.getWholeLine());             
            }
        }else
            .out.println(strv);                
    }
 
    

    

    

    private static boolean recursiveSearch(LineOfPuzzle pzzlNodeLine,
                                           PuzzleSet puzzleSet, int direction){
        boolean validLeaf = false;
        boolean hasNeighbor = false;
        PuzzleSet<LineOfPuzzle> puzzleSubSet = null;
 
        for (Iterator<LineOfPuzzle> it = puzzleSet.iterator(); it.hasNext();) {
            LineOfPuzzle pzzlLeafLine = it.next();            
            validLeaf = false;
 
            hasNeighbor = pzzlLeafLine.hasNeighbor(direction);
 
            if (hasNeighbor){                                
                puzzleSubSet = puzzleTable.getSimilarLines(pzzlLeafLine.getNeighbor(direction));
                if (puzzleSubSet != null){
                    if (pzzlNodeLine !=null)
                        validLeaf = puzzleSubSet.contains(pzzlNodeLine);
                    else
                        validLeaf = recursiveSearch(pzzlLeafLine, puzzleSubSet, -1*direction);
                }
                else
                    validLeaf = false;
            }
 
            if (!validLeaf && pzzlLeafLine.hasNeighbor(-1*direction)){
                hasNeighbor = true;
                if (hasNeighbor){
                    puzzleSubSet = puzzleTable.getSimilarLines(pzzlLeafLine.getNeighbor(-1*direction));
                    if (puzzleSubSet != null){
                        if (pzzlNodeLine !=null)
                            validLeaf = puzzleSubSet.contains(pzzlNodeLine);                        
                        else
                            validLeaf = recursiveSearch(pzzlLeafLine, puzzleSubSet, direction);
                    }
                    else
                        validLeaf = false;
                }
            }
 
            if (pzzlNodeLine != null && validLeaf)
                return validLeaf;
 
            if (pzzlNodeLine == null && hasNeighbor && !validLeaf){
                it.remove();
            }
 
            if (pzzlNodeLine == null){
                if (hasNeighbor && validLeaf){
                     puzzleSet.riseLineCountFlags(pzzlLeafLine.getOrder());
                }
                if (!hasNeighbor){
                    puzzleSet.riseLineCountFlags(pzzlLeafLine.getOrder());
                }
            }         
        }                
        return validLeaf;
    }
}
 "
" 
import java.io.StringWriter;
 
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
 
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
 
public class RDOMSerialization {
 
  private  domDoc;
 
  public RDOMSerialization() {
    return;
  }
 
  protected void buildDOMDocument() {
 
    DocumentBuilderFactory factory;
    DocumentBuilder builder;
    DOMImplementation impl;
     elmt1;
     elmt2;
 
    try {
      factory = DocumentBuilderFactory.newInstance();
      builder = factory.newDocumentBuilder();
      impl = builder.getDOMImplementation();
      domDoc = impl.createDocument(null, null, null);
      elmt1 = domDoc.createElement(strv);
      elmt2 = domDoc.createElement(strv);
      elmt2.setTextContent(strv);
 
      domDoc.appendChild(elmt1);
      elmt1.appendChild(elmt2);
    }
    catch (ParserConfigurationException ex) {
      ex.printStackTrace();
    }
 
    return;
  }
 
  protected void serializeXML() {
 
    DOMSource domSrc;
    Transformer txformer;
     sw;
    StreamResult sr;
 
    try {
      domSrc = new DOMSource(domDoc);
 
      txformer = TransformerFactory.newInstance().newTransformer();
      txformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, strv);
      txformer.setOutputProperty(OutputKeys.METHOD, strv);
      txformer.setOutputProperty(OutputKeys.ENCODING, strv);
      txformer.setOutputProperty(OutputKeys.INDENT, strv);
      txformer.setOutputProperty(OutputKeys.STANDALONE, strv);
      txformer.setOutputProperty(strv, strv);
 
      sw = new ();
      sr = new StreamResult(sw);
 
      txformer.transform(domSrc, sr);
 
      .out.println(sw.toString());
    }
    catch (TransformerConfigurationException ex) {
      ex.printStackTrace();
    }
    catch (TransformerFactoryConfigurationError ex) {
      ex.printStackTrace();
    }
    catch (TransformerException ex) {
      ex.printStackTrace();
    }
 
    return;
  }
 
  public static void serializationDriver([] args) {
 
    RDOMSerialization lcl = new RDOMSerialization();
    lcl.buildDOMDocument();
    lcl.serializeXML();
 
    return;
  }
 
  public static void main([] args) {
    serializationDriver(args);
    return;
  }
}
 "
"import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;
 
import java.net.MalformedURLException;
import java.net.URL;
 
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import javax.xml.ws.Holder;
 
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
 
public class XmlValidation {
	public static void main(... args) throws  {
		 schemaLocation = new (strv);
		 documentLocation = new (strv);
		if (validate(schemaLocation, documentLocation)) {
			.out.println(strv);
		} else {
			.out.println(strv);
		}
	}
 
	

	public static boolean minimalValidate( schemaLocation,  documentLocation) {
		SchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);
		try {
			Validator validator = factory.newSchema(schemaLocation).newValidator();
			validator.validate(new StreamSource(documentLocation.toString()));
			return true;
		} catch ( e) {
			return false;
		}
	}
 
	

	public static boolean validate( schemaLocation,  documentLocation) {
		SchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);
		final Holder<Boolean> valid = new Holder<>(true);
		try {
			Validator validator = factory.newSchema(schemaLocation).newValidator();
			

			validator.setErrorHandler(new ErrorHandler(){
				@Override
				public void warning(SAXParseException exception) {
					.out.println(strv + exception.getMessage());
				}
 
				@Override
				public void error(SAXParseException exception) {
					.out.println(strv + exception.getMessage());
					valid.value = false;
				}
 
				@Override
				public void fatalError(SAXParseException exception) throws SAXException {
					.out.println(strv + exception.getMessage());
					throw exception;
				}});
			validator.validate(new StreamSource(documentLocation.toString()));
			return valid.value;
		} catch (SAXException e) {
			

			return false;
		} catch ( e) {
			

			.err.println(e);
			return false;
		}
	}
}"
"import java.io.StringReader;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
 
public class XMLParser {
	final static  xmlStr = 
			  ""<inventory title=OmniCorp Store #45x10^3>""
			+ ""  <section name=health>""
			+ ""    <item upc=123456789 stock=12>""
			+ strv
			+ strv
			+ strv
			+ strv
			+ ""    <item upc=445322344 stock=18>""
			+ strv
			+ strv
			+ strv
			+ strv
			+ strv
			+ ""  <section name=food>""
			+ ""    <item upc=485672034 stock=653>""
			+ strv
			+ strv
			+ strv
			+ strv
			+ ""    <item upc=132957764 stock=44>""
			+ strv
			+ strv
			+ strv
			+ strv
			+ strv 
			+ strv;
 
	public static void main([] args) {
		try {
			 doc = DocumentBuilderFactory.newInstance()
					.newDocumentBuilder()
					.parse(new InputSource(new (xmlStr)));
			XPath xpath = XPathFactory.newInstance().newXPath();
			

			.out.println(((Node) xpath.evaluate(
					strv, doc, XPathConstants.NODE))
					.getAttributes().getNamedItem(strv));
			

			NodeList nodes = (NodeList) xpath.evaluate(
					strv, doc,
					XPathConstants.NODESET);
			for (int i = 0; i < nodes.getLength(); i++)
				.out.println(nodes.item(i).getTextContent());
		} catch ( e) {
			.out.println(strv);
		}
	}
}"
"import java.io.*;
 
public class Test {
 
    public static void main([] args) throws  {
        try ( bw = new (new (strv))) {
            bw.write(strv);
        }
    }
}"
"import java.io.StringWriter;
 
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
 
import org.w3c.dom.Document;
import org.w3c.dom.Element;
 
public class XmlCreation {
 
  private static final [] names = {strv, strv, strv};
  private static final [] remarks = {strv,
    ""Burns: When chapman billies leave the street ..."",
      strv};
 
  public static void main([] args) {
    try {
      

      final  doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
 
      

      final  root = doc.createElement(strv);
      doc.appendChild(root);
 
      

      for(int i = 0; i < names.length; i++) {
        final  character = doc.createElement(strv);
        root.appendChild(character);
        character.setAttribute(strv, names[i]);
        character.appendChild(doc.createTextNode(remarks[i]));
      }
 
      

      

      final Source source = new DOMSource(doc);
 
      

      final  buffer = new ();
 
      

      final Result result = new StreamResult(buffer);
 
      

      final Transformer transformer = TransformerFactory.newInstance().newTransformer();
      transformer.setOutputProperty(strv, strv);
      transformer.transform(source, result);
 
      

      

      .out.println(buffer.toString());
    } catch ( e) {
      e.printStackTrace();
    }
  }
 
}import java.io.StringWriter;
 
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
 
public class XmlCreationStax {
 
  private static final [] names = {strv, strv, strv};
  private static final [] remarks = {strv,
    ""Burns: When chapman billies leave the street ..."",
      strv};
 
  public static void main([] args) {
    try {
      final  buffer = new ();
 
      final XMLStreamWriter out = XMLOutputFactory.newInstance()
          .createXMLStreamWriter(buffer);
 
      out.writeStartDocument(strv, strv);
      out.writeStartElement(strv);
 
      for(int i = 0; i < names.length; i++) {
        out.writeStartElement(strv);
        out.writeAttribute(strv, names[i]);
        out.writeCharacters(remarks[i]);
        out.writeEndElement();
      }
 
      out.writeEndElement();
      out.writeEndDocument();
 
      .out.println(buffer);
    } catch ( e) {
      e.printStackTrace();
    }
  }
}"
"import java.awt.*;
import static java.lang..*;
import javax.swing.*;
 
public class XiaolinWu extends  {
 
    public XiaolinWu() {
         dim = new (640, 640);
        setPreferredSize(dim);
        setBackground(.white);
    }
 
    void plot( g, double x, double y, double c) {
        g.setColor(new (0f, 0f, 0f, (float)c));
        g.fillOval((int) x, (int) y, 2, 2);
    }
 
    int ipart(double x) {
        return (int) x;
    }
 
    double fpart(double x) {
        return x - floor(x);
    }
 
    double rfpart(double x) {
        return 1.0 - fpart(x);
    }
 
    void drawLine( g, double x0, double y0, double x1, double y1) {
 
        boolean steep = abs(y1 - y0) > abs(x1 - x0);
        if (steep)
            drawLine(g, y0, x0, y1, x1);
 
        if (x0 > x1)
            drawLine(g, x1, y1, x0, y0);
 
        double dx = x1 - x0;
        double dy = y1 - y0;
        double gradient = dy / dx;
 
        

        double xend = round(x0);
        double yend = y0 + gradient * (xend - x0);
        double xgap = rfpart(x0 + 0.5);
        double xpxl1 = xend; 

        double ypxl1 = ipart(yend);
 
        if (steep) {
            plot(g, ypxl1, xpxl1, rfpart(yend) * xgap);
            plot(g, ypxl1 + 1, xpxl1, fpart(yend) * xgap);
        } else {
            plot(g, xpxl1, ypxl1, rfpart(yend) * xgap);
            plot(g, xpxl1, ypxl1 + 1, fpart(yend) * xgap);
        }
 
        

        double intery = yend + gradient;
 
        

        xend = round(x1);
        yend = y1 + gradient * (xend - x1);
        xgap = fpart(x1 + 0.5);
        double xpxl2 = xend; 

        double ypxl2 = ipart(yend);
 
        if (steep) {
            plot(g, ypxl2, xpxl2, rfpart(yend) * xgap);
            plot(g, ypxl2 + 1, xpxl2, fpart(yend) * xgap);
        } else {
            plot(g, xpxl2, ypxl2, rfpart(yend) * xgap);
            plot(g, xpxl2, ypxl2 + 1, fpart(yend) * xgap);
        }
 
        

        for (double x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
            if (steep) {
                plot(g, ipart(intery), x, rfpart(intery));
                plot(g, ipart(intery) + 1, x, fpart(intery));
            } else {
                plot(g, x, ipart(intery), rfpart(intery));
                plot(g, x, ipart(intery) + 1, fpart(intery));
            }
            intery = intery + gradient;
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
 
        drawLine(g, 550, 170, 50, 435);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new XiaolinWu(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.io.IOException;
import java.io.StringReader;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;
 
public class StudentHandler extends DefaultHandler {
  public static void main([] args)throws {
     xml = ""<Students>""+
    ""<Student Name=April Gender=F DateOfBirth=1989-01-02 />""+
    ""<Student Name=Bob Gender=M  DateOfBirth=1990-03-04 />""+
    ""<Student Name=Chad Gender=M  DateOfBirth=1991-05-06 />""+
    ""<Student Name=Dave Gender=M  DateOfBirth=1992-07-08>""+
    ""  <Pet Type=dog Name=Rover />""+
    ""</Student>""+
    ""<Student DateOfBirth=1993-09-10 Gender=F Name=&#x00C9;mily />""+
    strv;
    StudentHandler handler = new StudentHandler();
    handler.parse(new InputSource(new (xml)));
  }
 
  public void parse(InputSource src) throws SAXException,  {
		XMLReader parser = XMLReaderFactory.createXMLReader();
    parser.setContentHandler(this);
    parser.parse(src);
  }
 
  @Override
  public void characters(char[] ch, int start, int length) throws SAXException {
    //if there were text as part of the elements, we would deal with it here
    //by adding it to a StringBuffer, but we don't have to for this task
    super.characters(ch, start, length);
  }
 
  @Override
  public void endElement( uri,  localName,  qName) throws SAXException {
    //this is where we would get the info from the StringBuffer if we had to,
    //but all we need is attributes
    super.endElement(uri, localName, qName);
  }
 
  @Override
  public void startElement( uri,  localName,  qName,  attributes) throws SAXException {
    if(qName.equals(strv)){
      .out.println(attributes.getValue(strv));
    }
  }
}"
"public class F5{
    char[]z={' ',' ','_','/',};
    long[][]f={
        {87381,87381,87381,87381,87381,87381,87381,},
        {349525,375733,742837,742837,375733,349525,349525,},
        {742741,768853,742837,742837,768853,349525,349525,},
        {349525,375733,742741,742741,375733,349525,349525,},
        {349621,375733,742837,742837,375733,349525,349525,},
        {349525,375637,768949,742741,375733,349525,349525,},
        {351157,374101,768949,374101,374101,349525,349525,},
        {349525,375733,742837,742837,375733,349621,351157,},
        {742741,768853,742837,742837,742837,349525,349525,},
        {181,85,181,181,181,85,85,},
        {1461,1365,1461,1461,1461,1461,2901,},
        {742741,744277,767317,744277,742837,349525,349525,},
        {181,181,181,181,181,85,85,},
        {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},
        {349525,768853,742837,742837,742837,349525,349525,},
        {349525,375637,742837,742837,375637,349525,349525,},
        {349525,768853,742837,742837,768853,742741,742741,},
        {349525,375733,742837,742837,375733,349621,349621,},
        {349525,744373,767317,742741,742741,349525,349525,},
        {349525,375733,767317,351157,768853,349525,349525,},
        {374101,768949,374101,374101,351157,349525,349525,},
        {349525,742837,742837,742837,375733,349525,349525,},
        {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},
        {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},
        {349525,742837,375637,742837,742837,349525,349525,},
        {349525,742837,742837,742837,375733,349621,375637,},
        {349525,768949,351061,374101,768949,349525,349525,},
        {375637,742837,768949,742837,742837,349525,349525,},
        {768853,742837,768853,742837,768853,349525,349525,},
        {375733,742741,742741,742741,375733,349525,349525,},
        {192213,185709,185709,185709,192213,87381,87381,},
        {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},
        {768949,742741,768853,742741,742741,349525,349525,},
        {375733,742741,744373,742837,375733,349525,349525,},
        {742837,742837,768949,742837,742837,349525,349525,},
        {48053,23381,23381,23381,48053,21845,21845,},
        {349621,349621,349621,742837,375637,349525,349525,},
        {742837,744277,767317,744277,742837,349525,349525,},
        {742741,742741,742741,742741,768949,349525,349525,},
        {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},
        {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},
        {375637,742837,742837,742837,375637,349525,349525,},
        {768853,742837,768853,742741,742741,349525,349525,},
        {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},
        {768853,742837,768853,742837,742837,349525,349525,},
        {375733,742741,375637,349621,768853,349525,349525,},
        {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},
        {742837,742837,742837,742837,375637,349525,349525,},
        {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},
        {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},
        {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},
        {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},
        {12303285,5593941,5616981,5985621,12303285,5592405,5592405,},};
    public static void main([]a){
        new F5(a.length>0?a[0]:strv);}
    private F5( s){
        StringBuilder[]o=new StringBuilder[7];
        for(int i=0;i<7;i++)o[i]=new StringBuilder();
        for(int i=0,l=s.length();i<l;i++){
            int c=s.charAt(i);
            if(65<=c&&c<=90)c-=39;
            else if(97<=c&&c<=122)c-=97;
            else c=-1;
            long[]d=f[++c];
            for(int j=0;j<7;j++){
                StringBuilder b=new StringBuilder();
                long v=d[j];
                while(v>0){
                    b.append(z[(int)(v&3)]);
                    v>>=2;}
                o[j].append(b.reverse().toString());}}
        for(int i=0;i<7;i++){
            for(int j=0;j<7-i;j++)
                .out.print(' ');
            .out.println(o[i]);}}}
 "
"import java.io.*;
import static java.lang..format;
import java.util.*;
 
public class WordSearch {
    static class Grid {
        int numAttempts;
        char[][] cells = new char[nRows][nCols];
        List<String> solutions = new ArrayList<>();
    }
 
    final static int[][] dirs = {{1, 0}, {0, 1}, {1, 1}, {1, -1}, {-1, 0},
    {0, -1}, {-1, -1}, {-1, 1}};
 
    final static int nRows = 10;
    final static int nCols = 10;
    final static int gridSize = nRows * nCols;
    final static int minWords = 25;
 
    final static  rand = new ();
 
    public static void main([] args) {
        printResult(createWordSearch(readWords(strv)));
    }
 
    static List<String> readWords( filename) {
        int maxLen = .max(nRows, nCols);
 
        List<String> words = new ArrayList<>();
        try (Scanner sc = new Scanner(new (filename))) {
            while (sc.hasNext()) {
                 s = sc.next().trim().toLowerCase();
                if (s.matches(strv + maxLen + strv))
                    words.add(s);
            }
        } catch ( e) {
            .out.println(e);
        }
        return words;
    }
 
    static Grid createWordSearch(List<String> words) {
        Grid grid = null;
        int numAttempts = 0;
 
        outer:
        while (++numAttempts < 100) {
            .shuffle(words);
 
            grid = new Grid();
            int messageLen = placeMessage(grid, strv);
            int target = gridSize - messageLen;
 
            int cellsFilled = 0;
            for ( word : words) {
                cellsFilled += tryPlaceWord(grid, word);
                if (cellsFilled == target) {
                    if (grid.solutions.size() >= minWords) {
                        grid.numAttempts = numAttempts;
                        break outer;
                    } else break; 

                }
            }
        }
 
        return grid;
    }
 
    static int placeMessage(Grid grid,  msg) {
        msg = msg.toUpperCase().replaceAll(strv, strv);
 
        int messageLen = msg.length();
        if (messageLen > 0 && messageLen < gridSize) {
            int gapSize = gridSize / messageLen;
 
            for (int i = 0; i < messageLen; i++) {
                int pos = i * gapSize + rand.nextInt(gapSize);
                grid.cells[pos / nCols][pos % nCols] = msg.charAt(i);
            }
            return messageLen;
        }
        return 0;
    }
 
    static int tryPlaceWord(Grid grid,  word) {
        int randDir = rand.nextInt(dirs.length);
        int randPos = rand.nextInt(gridSize);
 
        for (int dir = 0; dir < dirs.length; dir++) {
            dir = (dir + randDir) % dirs.length;
 
            for (int pos = 0; pos < gridSize; pos++) {
                pos = (pos + randPos) % gridSize;
 
                int lettersPlaced = tryLocation(grid, word, dir, pos);
                if (lettersPlaced > 0)
                    return lettersPlaced;
            }
        }
        return 0;
    }
 
    static int tryLocation(Grid grid,  word, int dir, int pos) {
 
        int r = pos / nCols;
        int c = pos % nCols;
        int len = word.length();
 
        

        if ((dirs[dir][0] == 1 && (len + c) > nCols)
                || (dirs[dir][0] == -1 && (len - 1) > c)
                || (dirs[dir][1] == 1 && (len + r) > nRows)
                || (dirs[dir][1] == -1 && (len - 1) > r))
            return 0;
 
        int rr, cc, i, overlaps = 0;
 
        

        for (i = 0, rr = r, cc = c; i < len; i++) {
            if (grid.cells[rr][cc] != 0 && grid.cells[rr][cc] != word.charAt(i))
                return 0;
            cc += dirs[dir][0];
            rr += dirs[dir][1];
        }
 
        

        for (i = 0, rr = r, cc = c; i < len; i++) {
            if (grid.cells[rr][cc] == word.charAt(i))
                overlaps++;
            else
                grid.cells[rr][cc] = word.charAt(i);
 
            if (i < len - 1) {
                cc += dirs[dir][0];
                rr += dirs[dir][1];
            }
        }
 
        int lettersPlaced = len - overlaps;
        if (lettersPlaced > 0) {
            grid.solutions.add(format(strv, word, c, r, cc, rr));
        }
 
        return lettersPlaced;
    }
 
    static void printResult(Grid grid) {
        if (grid == null || grid.numAttempts == 0) {
            .out.println(strv);
            return;
        }
        int size = grid.solutions.size();
 
        .out.println(strv + grid.numAttempts);
        .out.println(strv + size);
 
        .out.println(""     0  1  2  3  4  5  6  7  8  9"");
        .out.print(strv);
        for (int r = 0; r < nRows; r++) {
            .out.printf(strv, r);
            for (int c = 0; c < nCols; c++)
                .out.printf(strv, grid.cells[r][c]);
        }
 
        .out.println("""");
 
        for (int i = 0; i < size - 1; i += 2) {
            .out.printf(strv, grid.solutions.get(i),
                    grid.solutions.get(i + 1));
        }
        if (size % 2 == 1)
            .out.println(grid.solutions.get(size - 1));
    }
}"
"import java.awt.BorderLayout;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.lang.reflect.InvocationTargetException;
import javax.swing.AbstractAction;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
 
public class WindowController extends  {
   

   public static void main( final [] args ) {
      .invokeLater (
         new () {
            public void run() {
               new WindowController();
            }
         }
      );
   }
 
   private  list;
 
   

   private class ControlButton extends  {
      private ControlButton( final  name ) {
         super(
            new ( name ) {
               public void actionPerformed( final  e ) {
                  try {
                     WindowController.class.getMethod( strv + name )
                        .invoke ( WindowController.this );
                  } catch ( final  x ) { 

                     x.printStackTrace();        

                  }
               }
            }
         );
      }
   }
 
   

   public WindowController() {
      super( strv );
 
      final  main = new ();
      final  controls = new ();
 
      setLocationByPlatform( true );
      setResizable( false );
      setDefaultCloseOperation( .EXIT_ON_CLOSE );
      setLayout( new ( 3, 3 ) );
      getRootPane().setBorder( new ( 3, 3, 3, 3 ) );
      add( new ( strv ), .NORTH );
      main.add( list = new () );
      add( main, .CENTER );
      controls.setLayout( new ( 0, 1, 3, 3 ) );
      controls.add( new ControlButton( strv      ) );
      controls.add( new ControlButton( strv     ) );
      controls.add( new ControlButton( strv     ) );
      controls.add( new ControlButton( strv    ) );
      controls.add( new ControlButton( strv ) );
      controls.add( new ControlButton( strv ) );
      controls.add( new ControlButton( strv     ) );
      controls.add( new ControlButton( strv   ) );
      add( controls, .EAST );
      pack();
      setVisible( true );
   }
 
   

   private static class ControlledWindow extends  {
      private int num;
 
      public ControlledWindow( final int num ) {
         super( .toString( num ) );
         this.num = num;
         setLocationByPlatform( true );
         getRootPane().setBorder( new ( 3, 3, 3, 3 ) );
         setDefaultCloseOperation( .DISPOSE_ON_CLOSE );
         add( new ( strv + num + strv ) );
         pack();
         setVisible( true );
      }
 
      public  toString() {
         return strv + num;
      }
   }
 
   

   

 
   public void doAdd() {
      list.addItem( new ControlledWindow( list.getItemCount () + 1 ) );
      pack();
   }
 
   public void doHide() {
      ( (  ) list.getSelectedItem() ).setVisible( false );
   }
 
   public void doShow() {
      ( (  ) list.getSelectedItem() ).setVisible( true );
   }
 
   public void doClose() {
      ( (  ) list.getSelectedItem() ).dispose();
   }
 
   public void doMinimise() {
      ( (  ) list.getSelectedItem() ).setState( .ICONIFIED );
   }
 
   public void doMaximise() {
      ( (  ) list.getSelectedItem() ).setExtendedState( .MAXIMIZED_BOTH );
   }
 
   public void doMove() {
      ( (  ) list.getSelectedItem() ).setLocation
      (
         .parseInt( .showInputDialog( strv ) ),
         .parseInt( .showInputDialog( strv ) )
      );
   }
 
   public void doResize() {
      final  window = (  ) list.getSelectedItem();
 
      window.setBounds
      (
         window.getX(),
         window.getY(),
         .parseInt( .showInputDialog( strv ) ),
         .parseInt( .showInputDialog( strv ) )
      );
   }
}
 "
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
 
 
public class WebTime{
	public static void main([] args){
		try{
			 address = new (
					strv);
			 conn = address.openConnection();
			 in = new (
					new (conn.getInputStream()));
			 line;
			while(!(line = in.readLine()).contains(strv));
			.out.println(line.substring(4));
		}catch( e){
			.err.println(strv);
			e.printStackTrace();
		}
	}
}"
"import javax.swing.JFrame;
import javax.swing.SwingUtilities;
 
public class WindowExample {
 
  public static void main([] args) {
     runnable = new () {
      public void run() {
	createAndShow();
      }
    };
    .invokeLater(runnable);
  }
 
  static void createAndShow() {
     frame = new (strv);
    frame.setSize(640,480);
    frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
    frame.setVisible(true);
  }
}import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
 
public class WindowExample extends  {
    public void paint( g) {
         g2 = () g;
 
        g2.setStroke(new (2.0f));
        g2.drawString(strv, 20, 20);
        g2.setPaint(.blue);
        g2.draw(new .(40, 40, 20, 20));
    }
 
    public static void main( s[]) {
         f = new (strv);
        f.addWindowListener(new () {
            public void windowClosing( e) {.exit(0);}
        });
         applet = new ShapesDemo2D();
        f.getContentPane().add(strv, applet);
        f.pack();
        f.setSize(new (150, 150));
        f.setVisible(true);
    }
}"
"import javax.swing.JFrame;
 
public class Main {
     public static void main([] args) throws  {
          w = new (strv);
         w.setDefaultCloseOperation(.EXIT_ON_CLOSE);
         w.setSize(800,600);
         w.setVisible(true);
     }
}"
"import java.io.File;
 
public class MainEntry {
    public static void main([] args) {
        walkin(new (strv)); //Replace this with a suitable directory
    }
 
    /**     * Recursive function to descend into the directory tree and find all the files      * that end with strv     * @param dir A file object defining the top directory     **/
    public static void walkin( dir) {
         pattern = strv;
 
         listFile[] = dir.listFiles();
        if (listFile != null) {
            for (int i=0; i<listFile.length; i++) {
                if (listFile[i].isDirectory()) {
                    walkin(listFile[i]);
                } else {
                    if (listFile[i].getName().endsWith(pattern)) {
                        .out.println(listFile[i].getPath());
                    }
                }
            }
        }
    }
}import java.io.IOException;
import java.nio.file.*;
 
public class WalkTree {
	public static void main([] args) throws  {
		Path start = FileSystems.getDefault().getPath(strv);
		Files.walk(start)
		     .filter( path -> path.toFile().isFile())
		     .filter( path -> path.toString().endsWith(strv))
		     .forEach( .out::println );
	}
}
 "
" dir = new (strv);
 
[] contents = dir.list();
for ( file : contents)
    if (file.endsWith(strv))
        .out.println(file);"
" 
package rosettacode;
 
import java.util.StringTokenizer;
 
public class WordWrap 
{
	int defaultLineWidth=80;
	int defaultSpaceWidth=1;
	void minNumLinesWrap( text)
	{
		minNumLinesWrap(text,defaultLineWidth);
	}
	void minNumLinesWrap( text,int LineWidth)
	{
		 st=new (text);
		int SpaceLeft=LineWidth;
		int SpaceWidth=defaultSpaceWidth;
		while(st.hasMoreTokens())
		{
			 word=st.nextToken();
			if((word.length()+SpaceWidth)>SpaceLeft)
			{
				.out.print(""""+word+strv);
				SpaceLeft=LineWidth-word.length();
			}
			else
			{
				.out.print(word+strv);
				SpaceLeft-=(word.length()+SpaceWidth);
			}
		}
	}
	public static void main([] args)
	{
		WordWrap now=new WordWrap();
		 wodehouse=strv;
		.out.println(strv);
		now.minNumLinesWrap(wodehouse);
		.out.println(""LINEWIDTH=120"");
		now.minNumLinesWrap(wodehouse,120);
	}
 
}
 
 "
"import java.util.Arrays;
import static java.util..stream;
import java.util.concurrent.*;
 
public class VogelsApproximationMethod {
 
    final static int[] demand = {30, 20, 70, 30, 60};
    final static int[] supply = {50, 60, 50, 50};
    final static int[][] costs = {{16, 16, 13, 22, 17}, {14, 14, 13, 19, 15},
    {19, 19, 20, 23, 50}, {50, 12, 50, 15, 11}};
 
    final static int nRows = supply.length;
    final static int nCols = demand.length;
 
    static boolean[] rowDone = new boolean[nRows];
    static boolean[] colDone = new boolean[nCols];
    static int[][] result = new int[nRows][nCols];
 
    static ExecutorService es = Executors.newFixedThreadPool(2);
 
    public static void main([] args) throws  {
        int supplyLeft = stream(supply).sum();
        int totalCost = 0;
 
        while (supplyLeft > 0) {
            int[] cell = nextCell();
            int r = cell[0];
            int c = cell[1];
 
            int quantity = .min(demand[c], supply[r]);
            demand[c] -= quantity;
            if (demand[c] == 0)
                colDone[c] = true;
 
            supply[r] -= quantity;
            if (supply[r] == 0)
                rowDone[r] = true;
 
            result[r][c] = quantity;
            supplyLeft -= quantity;
 
            totalCost += quantity * costs[r][c];
        }
 
        stream(result).forEach(a -> .out.println(.toString(a)));
        .out.println(strv + totalCost);
 
        es.shutdown();
    }
 
    static int[] nextCell() throws  {
        Future<int[]> f1 = es.submit(() -> maxPenalty(nRows, nCols, true));
        Future<int[]> f2 = es.submit(() -> maxPenalty(nCols, nRows, false));
 
        int[] res1 = f1.get();
        int[] res2 = f2.get();
 
        if (res1[3] == res2[3])
            return res1[2] < res2[2] ? res1 : res2;
 
        return (res1[3] > res2[3]) ? res2 : res1;
    }
 
    static int[] diff(int j, int len, boolean isRow) {
        int min1 = .MAX_VALUE, min2 = .MAX_VALUE;
        int minP = -1;
        for (int i = 0; i < len; i++) {
            if (isRow ? colDone[i] : rowDone[i])
                continue;
            int c = isRow ? costs[j][i] : costs[i][j];
            if (c < min1) {
                min2 = min1;
                min1 = c;
                minP = i;
            } else if (c < min2)
                min2 = c;
        }
        return new int[]{min2 - min1, min1, minP};
    }
 
    static int[] maxPenalty(int len1, int len2, boolean isRow) {
        int md = .MIN_VALUE;
        int pc = -1, pm = -1, mc = -1;
        for (int i = 0; i < len1; i++) {
            if (isRow ? rowDone[i] : colDone[i])
                continue;
            int[] res = diff(i, len2, isRow);
            if (res[0] > md) {
                md = res[0];  

                pm = i;       

                mc = res[1];  

                pc = res[2];  

            }
        }
        return isRow ? new int[]{pm, pc, mc, md} : new int[]{pc, pm, mc, md};
    }
}"
"import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Random;
 
import javax.imageio.ImageIO;
import javax.swing.JFrame;
 
public class Voronoi extends  {
	static double p = 3;
	static  I;
	static int px[], py[], color[], cells = 100, size = 1000;
 
	public Voronoi() {
		super(strv);
		setBounds(0, 0, size, size);
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		int n = 0;
		 rand = new ();
		I = new (size, size, .TYPE_INT_RGB);
		px = new int[cells];
		py = new int[cells];
		color = new int[cells];
		for (int i = 0; i < cells; i++) {
			px[i] = rand.nextInt(size);
			py[i] = rand.nextInt(size);
			color[i] = rand.nextInt(16777215);
 
		}
		for (int x = 0; x < size; x++) {
			for (int y = 0; y < size; y++) {
				n = 0;
				for (byte i = 0; i < cells; i++) {
					if (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {
						n = i;
 
					}
				}
				I.setRGB(x, y, color[n]);
 
			}
		}
 
		 g = I.createGraphics();
		g.setColor(.BLACK);
		for (int i = 0; i < cells; i++) {
			g.fill(new  .(px[i] - 2.5, py[i] - 2.5, 5, 5));
		}
 
		try {
			ImageIO.write(I, strv, new (strv));
		} catch ( e) {
 
		}
 
	}
 
	public void paint( g) {
		g.drawImage(I, 0, 0, this);
	}
 
	static double distance(int x1, int x2, int y1, int y2) {
		double d;
	    d = .sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); 

	

	

	  	return d;
	}
 
	public static void main([] args) {
		new Voronoi().setVisible(true);
	}
}
 "
"public class VisualizeTree {
    public static void main([] args) {
        BinarySearchTree tree = new BinarySearchTree();
 
        tree.insert(100);
        for (int i = 0; i < 20; i++)
            tree.insert((int) (.random() * 200));
        tree.display();
    }
}
 
class BinarySearchTree {
    private Node root;
 
    private class Node {
        private int key;
        private Node left, right;
 
        Node(int k) {
            key = k;
        }
    }
 
    public boolean insert(int key) {
        if (root == null)
            root = new Node(key);
        else {
            Node n = root;
            Node parent;
            while (true) {
                if (n.key == key)
                    return false;
 
                parent = n;
 
                boolean goLeft = key < n.key;
                n = goLeft ? n.left : n.right;
 
                if (n == null) {
                    if (goLeft) {
                        parent.left = new Node(key);
                    } else {
                        parent.right = new Node(key);
                    }
                    break;
                }
            }
        }
        return true;
    }
 
    public void display() {
        final int height = 5, width = 64;
 
        int len = width * height * 2 + 2;
        StringBuilder sb = new StringBuilder(len);
        for (int i = 1; i <= len; i++)
            sb.append(i < len - 2 && i % width == 0 ? """" : ' ');
 
        displayR(sb, width / 2, 1, width / 4, width, root, strv);
        .out.println(sb);
    }
 
    private void displayR(StringBuilder sb, int c, int r, int d, int w, Node n,
             edge) {
        if (n != null) {
            displayR(sb, c - d, r + 2, d / 2, w, n.left, strv);
 
             s = .valueOf(n.key);
            int idx1 = r * w + c - (s.length() + 1) / 2;
            int idx2 = idx1 + s.length();
            int idx3 = idx1 - w;
            if (idx2 < sb.length())
                sb.replace(idx1, idx2, s).replace(idx3, idx3 + 2, edge);
 
            displayR(sb, c + d, r + 2, d / 2, w, n.right, "" "");
        }
    }
}"
"import static java.lang..pow;
import java.util.Arrays;
import static java.util..stream;
import org.apache.commons.math3.special.Gamma;
 
public class Test {
 
    static double x2Dist(double[] data) {
        double avg = stream(data).sum() / data.length;
        double sqs = stream(data).reduce(0, (a, b) -> a + pow((b - avg), 2));
        return sqs / avg;
    }
 
    static double x2Prob(double dof, double distance) {
        return Gamma.regularizedGammaQ(dof / 2, distance / 2);
    }
 
    static boolean x2IsUniform(double[] data, double significance) {
        return x2Prob(data.length - 1.0, x2Dist(data)) > significance;
    }
 
    public static void main([] a) {
        double[][] dataSets = {{199809, 200665, 199607, 200270, 199649},
        {522573, 244456, 139979, 71531, 21461}};
 
        .out.printf(strv,
                strv, strv, strv, strv, strv);
 
        for (double[] ds : dataSets) {
            int dof = ds.length - 1;
            double dist = x2Dist(ds);
            double prob = x2Prob(dof, dist);
            .out.printf(strv,
                    dof, dist, prob, x2IsUniform(ds, 0.05) ? strv : strv,
                    .toString(ds));
        }
    }
}"
"import static java.lang..abs;
import java.util.*;
import java.util.function.IntSupplier;
 
public class Test {
 
    static void distCheck(IntSupplier f, int nRepeats, double delta) {
        Map<, Integer> counts = new HashMap<>();
 
        for (int i = 0; i < nRepeats; i++)
            counts.compute(f.getAsInt(), (k, v) -> v == null ? 1 : v + 1);
 
        double target = nRepeats / (double) counts.size();
        int deltaCount = (int) (delta / 100.0 * target);
 
        counts.forEach((k, v) -> {
            if (abs(target - v) >= deltaCount)
                .out.printf(strv
                        + strv, k, v);
        });
 
        counts.keySet().stream().sorted().forEach(k
                -> .out.printf(strv, k, counts.get(k)));
    }
 
    public static void main([] a) {
        distCheck(() -> (int) (.random() * 5) + 1, 1_000_000, 1);
    }
}"
"public class VigenereCipher {
    public static void main([] args) {
         key = strv;
         ori = strv;
         enc = encrypt(ori, key);
        .out.println(enc);
        .out.println(decrypt(enc, key));
    }
 
    static  encrypt( text, final  key) {
         res = strv;
        text = text.toUpperCase();
        for (int i = 0, j = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (c < 'A' || c > 'Z') continue;
            res += (char)((c + key.charAt(j) - 2 * 'A') % 26 + 'A');
            j = ++j % key.length();
        }
        return res;
    }
 
    static  decrypt( text, final  key) {
         res = strv;
        text = text.toUpperCase();
        for (int i = 0, j = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (c < 'A' || c > 'Z') continue;
            res += (char)((c - key.charAt(j) + 26) % 26 + 'A');
            j = ++j % key.length();
        }
        return res;
    }
}"
"import java.util.Locale;
 
public class Test {
 
    public static void main([] args) {
        .out.println(new Vec2(5, 7).add(new Vec2(2, 3)));
        .out.println(new Vec2(5, 7).sub(new Vec2(2, 3)));
        .out.println(new Vec2(5, 7).mult(11));
        .out.println(new Vec2(5, 7).div(2));
    }
}
 
class Vec2 {
    final double x, y;
 
    Vec2(double x, double y) {
        this.x = x;
        this.y = y;
    }
 
    Vec2 add(Vec2 v) {
        return new Vec2(x + v.x, y + v.y);
    }
 
    Vec2 sub(Vec2 v) {
        return new Vec2(x - v.x, y - v.y);
    }
 
    Vec2 div(double val) {
        return new Vec2(x / val, y / val);
    }
 
    Vec2 mult(double val) {
        return new Vec2(x * val, y * val);
    }
 
    @Override
    public  toString() {
        return .format(.US, strv, x, y);
    }
}"
"import java.util.Formatter;
import java.io.UnsupportedEncodingException;
 
public class UTF8EncodeDecode {
    public static byte[] utf8encode(int codepoint) throws  {
        return new (new int[]{codepoint}, 0, 1).getBytes(strv);
    }
    public static int utf8decode(byte[] bytes) throws  {
        return new (bytes, strv).codePointAt(0);
    }
    public static final void main([] args) throws  {
        .out.printf(""%-7s %-43s %7s%s%7s"", strv, strv, strv, strv, strv);
        for (int codepoint : new int[]{0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E}) {
            byte[] encoded = utf8encode(codepoint);
            Formatter formatter = new Formatter();
            for (byte b : encoded) {
                formatter.format(strv, b);
            }
             encodedHex = formatter.toString();
            int decoded = utf8decode(encoded);
            .out.printf(""%-7c %-43s U+%04X%-12sU+%04X"", codepoint, .getName(codepoint), codepoint, encodedHex, decoded);
        }
    }
    public static final void main([] args) throws  {
        .out.printf(""%-7s %-43s %7s%s%s"", strv, strv, strv, strv, strv);
        for (int codepoint : new int[]{0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E}) {
            byte[] encoded = utf8encode(codepoint);
            Formatter formatter = new Formatter();
            for (byte b : encoded) {
                formatter.format(strv, b);
            }
             encodedHex = formatter.toString();
            int decoded = utf8decode(encoded);
            .out.printf(""%-7c %-43s U+%04X%-12s%c"", codepoint, .getName(codepoint), codepoint, encodedHex, decoded);
        }
    }
}"
"public class VLQCode
{
  public static byte[] encode(long n)
  {
    int numRelevantBits = 64 - .numberOfLeadingZeros(n);
    int numBytes = (numRelevantBits + 6) / 7;
    if (numBytes == 0)
      numBytes = 1;
    byte[] output = new byte[numBytes];
    for (int i = numBytes - 1; i >= 0; i--)
    {
      int curByte = (int)(n & 0x7F);
      if (i != (numBytes - 1))
        curByte |= 0x80;
      output[i] = (byte)curByte;
      n >>>= 7;
    }
    return output;
  }
 
  public static long decode(byte[] b)
  {
    long n = 0;
    for (int i = 0; i < b.length; i++)
    {
      int curByte = b[i] & 0xFF;
      n = (n << 7) | (curByte & 0x7F);
      if ((curByte & 0x80) == 0)
        break;
    }
    return n;
  }
 
  public static  byteArrayToString(byte[] b)
  {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < b.length; i++)
    {
      if (i > 0)
        sb.append(strv);
       s = .toHexString(b[i] & 0xFF);
      if (s.length() < 2)
        s = strv + s;
      sb.append(s);
    }
    return sb.toString();
  }
 
  public static void main([] args)
  {
    long[] testNumbers = { 2097152, 2097151, 1, 127, 128, 589723405834L };
    for (long n : testNumbers)
    {
      byte[] encoded = encode(n);
      long decoded = decode(encoded);
      .out.println(strv + n + strv + byteArrayToString(encoded) + strv + decoded + strv + ((n == decoded) ? strv : strv));
    }
  }
}
 "
"int a;
double b;
AClassNameHere c;int a, b, c;int a = 5;
double b;
int c = 5, d = 6, e, f;
 x = strv;
 y = x;
b = 3.14;final  x = strv;
final  y;
final double[] nums = new double[15];
y = strv;
x = strv; //not legal
nums[5] = 2.5; //legal
nums = new double[10]; //not legal
final  now = new java.util.();
now.setTime(1234567890); //legal
now = new (1234567890); //not legal"
"public class VanDerCorput{
	public static double vdc(int n){
		double vdc = 0;
		int denom = 1;
		while(n != 0){
			vdc += n % 2.0 / (denom *= 2);
			n /= 2;
		}
		return vdc;
	}
 
	public static void main([] args){
		for(int i = 0; i <= 10; i++){
			.out.println(vdc(i));
		}
	}
}"
"public class VampireNumber {
 
    public static void main( args[]) {
 
        

        

        long countVamps = 0, start = 10, tens = 10;
        outer:
        for (int numDigits = 2; numDigits <= 18; numDigits += 2) {
            long end = start * 10;
            for (long i = start; i < end; i++) {
                if (countFangs(i, tens) > 0) {
                    if (++countVamps >= 26)
                        break outer;
                }
            }
            start *= 100;
            tens *= 10;
        }
        .out.println();
 
        long[] bigs = {16758243290880L, 24959017348650L,
            14593825548650L};
 
        for (long b : bigs)
            countFangs(b, 10000000L);
    }
 
    private static int countFangs(long n, long tens) {
        int countFangs = 0;
 
        

        long lo = .max(tens / 10, (n + tens - 2) / (tens - 1));
        long hi = .min(n / lo, (long) .sqrt(n));
 
        long nTally = tallyDigits(n);
 
        for (long a = lo; a <= hi; a++) {
            long b = n / a;
 
            if (a * b != n)
                continue;
 
            

            if (n % 9 != (a + b) % 9)
                continue;
 
            if (a % 10 == 0 && b % 10 == 0)
                continue;
 
            if (nTally == tallyDigits(a) + tallyDigits(b)) {
                if (countFangs == 0)
                    .out.printf(""%d : "", n);
                .out.printf(strv, a, b);
                countFangs++;
            }
        }
        return countFangs;
    }
 
    

    private static long tallyDigits(long n) {
        long total = 0;
        while (n > 0) {
            total += 1L << ((n % 10) * 6);
            n /= 10;
        }
        return total;
    }
}"
"package src;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.net.URI;
 
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
 
 
 
public class EventGetter {
 
 
	 city = strv;
	 topic = strv;
 
	public  getEvent( path_code, key) throws {
		 responseString = strv;
 
		URI request = new URIBuilder()			//We build the request URI
			.setScheme(strv)
			.setHost(strv)
			.setPath(path_code)
			//List of parameters :
			.setParameter(strv, topic)
			.setParameter(strv, city)
			//End of params
			.setParameter(strv, key)
			.build();
 
		HttpGet get = new HttpGet(request);			//Assign the URI to the get request
		.out.println(strv+get.toString());
 
		CloseableHttpClient client = HttpClients.createDefault();
		CloseableHttpResponse response = client.execute(get);
		responseString = EntityUtils.toString(response.getEntity());
 
		return responseString;
	}
 
	public  getApiKey( key_path){
		 key = strv;
 
		try{
			 reader = new (new (key_path));	//Read the file where the API Key is
			key = reader.readLine().toString();									//Store key
			reader.close();
		}
		catch( e){.out.println(e.toString());}
 
		return key;																//Return the key value.
	}
 
}/* * In this class, You can see the diferent  * ways of asking for events. * */
 
 
package src;
 
import java.util.Iterator;
 
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.json.simple.parser.JSONParser;
 
public class Main {
	public static void main([] args) {
 
		 key_path = strv; 							//Path to API Key (api_key.txt)
		 key = strv;
		 path_code = strv;								//PathCode for get-events
																			//More PathCodes : http://www.meetup.com/meetup_api/docs/
		 events = strv;
 
		EventGetter eventGetter = new EventGetter();
		key = eventGetter.getApiKey(key_path);
 
		/*		 * 1-PARAMETER EXAMPLE :		 */ 
		eventGetter.topic = strv;										//Set the parameter strv
 
		try {
			events = eventGetter.getEvent(path_code, key);					//Store the event response into a String
		} catch ( e) {e.printStackTrace();}
		DecodeJSON(events);													//Print JSON-parsed events info						
 
		/*		 * 2-PARAMETER EXAMPLE :		 */
		eventGetter.topic = strv;											//Set parameters
		eventGetter.city = strv;										
		try{
			events = eventGetter.getEvent(path_code, key);
		}catch( e){e.printStackTrace();}
		//System.out.println(events);											//Print the events list (JSON)
 
 
		/*		 * MULTIPLE-TOPICS EXAMPLE :		 * Separate topics by commas		 */
		eventGetter.topic = strv;								//multiple topic separated by commas										
		eventGetter.city = strv;
		try{
			events = eventGetter.getEvent(path_code, key);
		}catch( e){e.printStackTrace();}
 
	}
 
	public static void DecodeJSON( events){
 
		try{
			JSONParser parser = new JSONParser();
			JSONObject obj = (JSONObject) parser.parse(events);
			JSONArray results = (JSONArray) obj.get(strv);
			.out.println(strv);
 
			 i = results.iterator(); 
			while(i.hasNext()){
				JSONObject event = (JSONObject) i.next();
				.out.println(strv+event.get(strv));
 
				if(event.containsKey(strv)){
					JSONObject venue = (JSONObject) event.get(strv);
					.out.println(strv+venue.get(strv));
					.out.println(strv+venue.get(strv));
				}
 
 
				.out.println(strv+event.get(strv));
				.out.println(strv+event.get(strv));
				i.next();
			}
 
		}
		catch( e){e.printStackTrace();}
	}
 
}"
"public class ISIN {
 
    public static void main([] args) {
        [] isins = {
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
        };
        for ( isin : isins)
            .out.printf(""%s is %s%n"", isin, ISINtest(isin) ? strv : strv);
    }
 
    static boolean ISINtest( isin) {
        isin = isin.trim().toUpperCase();
 
        if (!isin.matches(""^[A-Z]{2}[A-Z0-9]{9}d$""))
            return false;
 
        StringBuilder sb = new StringBuilder();
        for (char c : isin.substring(0, 12).toCharArray())
            sb.append(.digit(c, 36));
 
        return Luhn.luhnTest(sb.toString());
    }
}"
"import javax.swing.*;
 
public class GetInputSwing {
    public static void main([] args) throws  {
        int number = .parseInt(
                .showInputDialog (strv));
         string = .showInputDialog (strv);
    }
}"
"import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
 
public class Main
{
    public static void main([] args) throws 
    {
         normal = strv;
         encoded = .encode(normal, strv);
        .out.println(encoded);
    }
}"
" 
import java.util.Scanner;
 
public class GetInput {
    public static void main([] args) throws  {
        Scanner s = new Scanner(.in);
        .out.print(strv);
         str = s.nextLine();
        .out.print(strv);
        int i = .parseInt(s.next());
    }
}import java.util.Scanner;
 
public class GetInput {
    public static void main([] args) {
        Scanner stdin = new Scanner(.in);
         string = stdin.nextLine();
        int number = stdin.nextInt();
    }
}"
"import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
 
public class Main
{
    public static void main([] args) throws 
    {
         encoded = strv;
         normal = .decode(encoded, strv);
        .out.println(normal);
    }
}"
" 
package rosetta;
 
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
 
public class UnixLS {
 
	public static void main([] args) throws  {
		UnixLS ls = new UnixLS();
		ls.list(.out);
	}
 
	private void list( out) throws  {
		try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(strv))) {
			stream.forEach((path) -> out.println(path.getFileName()));
		}
	}
}
 
 "
"int Δ = 1;
double π = 3.141592;
 你好 = strv;
Δ++;
.out.println(Δ);"
" string = null;        

.out.println(string);           //prints strv to std out
.out.println(string.length());  
int i = null;      

if (i == null) {   

    i = 1;
} i = null;  

if (i == null) {
    i = 1;
}"
"import java.io.*;
import java.util.*;
import java.util.regex.*;
 
public class UpdateConfig {
 
    public static void main([] args) {
        if (args[0] == null) {
            .out.println(strv);
 
        } else if (readConfig(args[0])) {
            enableOption(strv);
            disableOption(strv);
            setOption(strv, strv);
            addOption(strv, strv);
            store();
        }
    }
 
    private enum EntryType {
        EMPTY, ENABLED, DISABLED, COMMENT
    }
 
    private static class Entry {
        EntryType type;
         name, value;
 
        Entry(EntryType t,  n,  v) {
            type = t;
            name = n;
            value = v;
        }
    }
 
    private static Map<, Entry> entries = new LinkedHashMap<>();
    private static  path;
 
    private static boolean readConfig( p) {
        path = p;
 
         f = new (path);
        if (!f.exists() || f.isDirectory())
            return false;
 
         regexString = ""^(;*)s*([A-Za-z0-9]+)s*([A-Za-z0-9]*)"";
        Pattern regex = Pattern.compile(regexString);
 
        try (Scanner sc = new Scanner(new (f))){
            int emptyLines = 0;
             line;
            while (sc.hasNext()) {
                line = sc.nextLine().trim();
 
                if (line.isEmpty()) {
                    addOption(strv + emptyLines++, null, EntryType.EMPTY);
 
                } else if (line.charAt(0) == '#') {
                    entries.put(line, new Entry(EntryType.COMMENT, line, null));
 
                } else {
                    line = line.replaceAll(""[^a-zA-Z0-9x20;]"", strv);
                    Matcher m = regex.matcher(line);
 
                    if (m.find() && !m.group(2).isEmpty()) {
 
                        EntryType t = EntryType.ENABLED;
                        if (!m.group(1).isEmpty())
                            t = EntryType.DISABLED;
 
                        addOption(m.group(2), m.group(3), t);
                    }
                }
            }
        } catch ( e) {
            .out.println(e);
        }
        return true;
    }
 
    private static void addOption( name,  value) {
        addOption(name, value, EntryType.ENABLED);
    }
 
    private static void addOption( name,  value, EntryType t) {
        name = name.toUpperCase();
        entries.put(name, new Entry(t, name, value));
    }
 
    private static void enableOption( name) {
        Entry e = entries.get(name.toUpperCase());
        if (e != null)
            e.type = EntryType.ENABLED;
    }
 
    private static void disableOption( name) {
        Entry e = entries.get(name.toUpperCase());
        if (e != null)
            e.type = EntryType.DISABLED;
    }
 
    private static void setOption( name,  value) {
        Entry e = entries.get(name.toUpperCase());
        if (e != null)
            e.value = value;
    }
 
    private static void store() {
        try ( pw = new (path)) {
            for (Entry e : entries.values()) {
                switch (e.type) {
                    case EMPTY:
                        pw.println();
                        break;
                    case ENABLED:
                        pw.format(strv, e.name, e.value);
                        break;
                    case DISABLED:
                        pw.format(strv, e.name, e.value);
                        break;
                    case COMMENT:
                        pw.println(e.name);
                        break;
                    default:
                        break;
                }
            }
            if (pw.checkError()) {
                throw new (strv);
            }
        } catch ( e) {
            .out.println(e);
        }
    }
}"
"import java.util.Arrays;
 
public class TwoSum {
 
    public static void main([] args) {
        long sum = 21;
        int[] arr = {0, 2, 11, 19, 90};
 
        .out.println(.toString(twoSum(arr, sum)));
    }
 
    public static int[] twoSum(int[] a, long target) {
        int i = 0, j = a.length - 1;
        while (i < j) {
            long sum = a[i] + a[j];
            if (sum == target)
                return new int[]{i, j};
            if (sum < target) i++;
            else j--;
        }
        return null;
    }
}"
"public class Bias {
    public static boolean biased(int n) {
        return .random() < 1.0 / n;
    }
 
    public static boolean unbiased(int n) {
        boolean a, b;
        do {
            a = biased(n);
            b = biased(n);
        } while (a == b);
        return a;
    }
 
    public static void main([] args) {
        final int M = 50000;
        for (int n = 3; n < 7; n++) {
            int c1 = 0, c2 = 0;
            for (int i = 0; i < M; i++) {
                c1 += biased(n) ? 1 : 0;
                c2 += unbiased(n) ? 1 : 0;
            }
            .out.format(""%d: %2.2f%%  %2.2f%%"",
                              n, 100.0*c1/M, 100.0*c2/M);
        }
    }
}"
"import java.awt.*;
import javax.swing.*;
 
public class LargeUlamSpiral extends  {
 
    public LargeUlamSpiral() {
        setPreferredSize(new (605, 605));
        setBackground(.white);
    }
 
    private boolean isPrime(int n) {
        if (n <= 2 || n % 2 == 0)
            return n == 2;
        for (int i = 3; i * i <= n; i += 2)
            if (n % i == 0)
                return false;
        return true;
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        g.setColor(getForeground());
 
        double angle = 0.0;
        int x = 300, y = 300, dx = 1, dy = 0;
 
        for (int i = 1, step = 1, turn = 1; i < 40_000; i++) {
 
            if (isPrime(i))
                g.fillRect(x, y, 2, 2);
 
            x += dx * 3;
            y += dy * 3;
 
            if (i == turn) {
 
                angle += 90.0;
 
                if ((dx == 0 && dy == -1) || (dx == 0 && dy == 1))
                    step++;
 
                turn += step;
 
                dx = (int) .cos(.toRadians(angle));
                dy = (int) .sin(.toRadians(-angle));
            }
        }
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new LargeUlamSpiral(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}import java.awt.*;
import javax.swing.*;
 
public class UlamSpiral extends  {
 
     primeFont = new (strv, .BOLD, 20);
     compositeFont = new (strv, .PLAIN, 16);
 
    public UlamSpiral() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
    }
 
    private boolean isPrime(int n) {
        if (n <= 2 || n % 2 == 0)
            return n == 2;
        for (int i = 3; i * i <= n; i += 2)
            if (n % i == 0)
                return false;
        return true;
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        g.setStroke(new (2));
 
        double angle = 0.0;
        int x = 280, y = 330, dx = 1, dy = 0;
 
        g.setColor(getForeground());
        g.drawLine(x, y - 5, x + 50, y - 5);
 
        for (int i = 1, step = 1, turn = 1; i < 100; i++) {
 
            g.setColor(getBackground());
            g.fillRect(x - 5, y - 20, 30, 30);
            g.setColor(getForeground());
            g.setFont(isPrime(i) ? primeFont : compositeFont);
            g.drawString(.valueOf(i), x + (i < 10 ? 4 : 0), y);
 
            x += dx * 50;
            y += dy * 50;
 
            if (i == turn) {
                angle += 90.0;
 
                if ((dx == 0 && dy == -1) || (dx == 0 && dy == 1))
                    step++;
 
                turn += step;
 
                dx = (int) .cos(.toRadians(angle));
                dy = (int) .sin(.toRadians(-angle));
 
                g.translate(9, -5);
                g.drawLine(x, y, x + dx * step * 50, y + dy * step * 50);
                g.translate(-9, 5);
            }
        }
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new UlamSpiral(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
 
public class TruncFile {
	public static void main([] args) throws {
		if(args.length < 2){
			.out.println(strv);
			return;
		}
		//turn on strv so it doesn't clear the file
		FileChannel outChan = new (args[0], true).getChannel();
		long newSize = .parseLong(args[1]);
		outChan.truncate(newSize);
		outChan.close();
	}
}"
"import java.util.BitSet;
 
public class Main {
 
	public static void main([] args){
 
		final int MAX = 1000000;
 
		//Sieve of Eratosthenes (using BitSet only for odd numbers)
		 primeList = new (MAX>>1); 
		primeList.set(0,primeList.size(),true); 
 
		int sqroot = (int) .sqrt(MAX); 
		primeList.clear(0); 
		for(int num = 3; num <= sqroot; num+=2) 
		{ 
			if( primeList.get(num >> 1) ) 
			{ 
				int inc = num << 1;
				for(int factor = num * num; factor < MAX; factor += inc) 
				{ 
					//if( ((factor) & 1) == 1) 
					//{ 
					primeList.clear(factor >> 1); 
					//} 
				} 
			} 
		}
		//Sieve ends...
 
		//Find Largest Truncatable Prime. (so we start from 1000000 - 1
		int rightTrunc = -1, leftTrunc = -1;
		for(int prime = (MAX - 1) | 1; prime >= 3; prime -= 2)
		{
			if(primeList.get(prime>>1))
			{
				//Already found Right Truncatable Prime?
				if(rightTrunc == -1)
				{
					int right = prime;
					while(right > 0 && right % 2 != 0 && primeList.get(right >> 1)) right /= 10;
					if(right == 0) rightTrunc = prime;
				}
 
				//Already found Left Truncatable Prime?
				if(leftTrunc == -1 )
				{
					//Left Truncation
					 left = .toString(prime);
					if(!left.contains(strv))
					{
						while( left.length() > 0 ){
							int iLeft = .parseInt(left);
							if(!primeList.get( iLeft >> 1)) break;
							left = left.substring(1);
						}
						if(left.length() == 0) leftTrunc = prime;
					}
				}
				if(leftTrunc != -1 && rightTrunc != -1) //Found both? then Stop loop
				{
					break;
				}
			}
		}
		.out.println(strv + leftTrunc);
		.out.println(strv + rightTrunc);
	}
}
 "
"import java.io.File;
import java.util.*;
import static java.util..stream;
import static java.util.stream.Collectors.toCollection;
 
public class TransportationProblem {
 
    private static int[] demand;
    private static int[] supply;
    private static double[][] costs;
    private static Shipment[][] matrix;
 
    private static class Shipment {
        final double costPerUnit;
        final int r, c;
        double quantity;
 
        public Shipment(double q, double cpu, int r, int c) {
            quantity = q;
            costPerUnit = cpu;
            this.r = r;
            this.c = c;
        }
    }
 
    static void init( filename) throws  {
 
        try (Scanner sc = new Scanner(new (filename))) {
            int numSources = sc.nextInt();
            int numDestinations = sc.nextInt();
 
            List<Integer> src = new ArrayList<>();
            List<Integer> dst = new ArrayList<>();
 
            for (int i = 0; i < numSources; i++)
                src.add(sc.nextInt());
 
            for (int i = 0; i < numDestinations; i++)
                dst.add(sc.nextInt());
 
            

            int totalSrc = src.stream().mapToInt(i -> i).sum();
            int totalDst = dst.stream().mapToInt(i -> i).sum();
            if (totalSrc > totalDst)
                dst.add(totalSrc - totalDst);
            else if (totalDst > totalSrc)
                src.add(totalDst - totalSrc);
 
            supply = src.stream().mapToInt(i -> i).toArray();
            demand = dst.stream().mapToInt(i -> i).toArray();
 
            costs = new double[supply.length][demand.length];
            matrix = new Shipment[supply.length][demand.length];
 
            for (int i = 0; i < numSources; i++)
                for (int j = 0; j < numDestinations; j++)
                    costs[i][j] = sc.nextDouble();
        }
    }
 
    static void northWestCornerRule() {
 
        for (int r = 0, northwest = 0; r < supply.length; r++)
            for (int c = northwest; c < demand.length; c++) {
 
                int quantity = .min(supply[r], demand[c]);
                if (quantity > 0) {
                    matrix[r][c] = new Shipment(quantity, costs[r][c], r, c);
 
                    supply[r] -= quantity;
                    demand[c] -= quantity;
 
                    if (supply[r] == 0) {
                        northwest = c;
                        break;
                    }
                }
            }
    }
 
    static void steppingStone() {
        double maxReduction = 0;
        Shipment[] move = null;
        Shipment leaving = null;
 
        fixDegenerateCase();
 
        for (int r = 0; r < supply.length; r++) {
            for (int c = 0; c < demand.length; c++) {
 
                if (matrix[r][c] != null)
                    continue;
 
                Shipment trial = new Shipment(0, costs[r][c], r, c);
                Shipment[] path = getClosedPath(trial);
 
                double reduction = 0;
                double lowestQuantity = .MAX_VALUE;
                Shipment leavingCandidate = null;
 
                boolean plus = true;
                for (Shipment s : path) {
                    if (plus) {
                        reduction += s.costPerUnit;
                    } else {
                        reduction -= s.costPerUnit;
                        if (s.quantity < lowestQuantity) {
                            leavingCandidate = s;
                            lowestQuantity = s.quantity;
                        }
                    }
                    plus = !plus;
                }
                if (reduction < maxReduction) {
                    move = path;
                    leaving = leavingCandidate;
                    maxReduction = reduction;
                }
            }
        }
 
        if (move != null) {
            double q = leaving.quantity;
            boolean plus = true;
            for (Shipment s : move) {
                s.quantity += plus ? q : -q;
                matrix[s.r][s.c] = s.quantity == 0 ? null : s;
                plus = !plus;
            }
            steppingStone();
        }
    }
 
    static LinkedList<Shipment> matrixToList() {
        return stream(matrix)
                .flatMap(row -> stream(row))
                .filter(s -> s != null)
                .collect(toCollection(::new));
    }
 
    static Shipment[] getClosedPath(Shipment s) {
        LinkedList<Shipment> path = matrixToList();
        path.addFirst(s);
 
        

        

        while (path.removeIf(e -> {
            Shipment[] nbrs = getNeighbors(e, path);
            return nbrs[0] == null || nbrs[1] == null;
        }));
 
        

        Shipment[] stones = path.toArray(new Shipment[path.size()]);
        Shipment prev = s;
        for (int i = 0; i < stones.length; i++) {
            stones[i] = prev;
            prev = getNeighbors(prev, path)[i % 2];
        }
        return stones;
    }
 
    static Shipment[] getNeighbors(Shipment s, LinkedList<Shipment> lst) {
        Shipment[] nbrs = new Shipment[2];
        for (Shipment o : lst) {
            if (o != s) {
                if (o.r == s.r && nbrs[0] == null)
                    nbrs[0] = o;
                else if (o.c == s.c && nbrs[1] == null)
                    nbrs[1] = o;
                if (nbrs[0] != null && nbrs[1] != null)
                    break;
            }
        }
        return nbrs;
    }
 
    static void fixDegenerateCase() {
        final double eps = .MIN_VALUE;
 
        if (supply.length + demand.length - 1 != matrixToList().size()) {
 
            for (int r = 0; r < supply.length; r++)
                for (int c = 0; c < demand.length; c++) {
                    if (matrix[r][c] == null) {
                        Shipment dummy = new Shipment(eps, costs[r][c], r, c);
                        if (getClosedPath(dummy).length == 0) {
                            matrix[r][c] = dummy;
                            return;
                        }
                    }
                }
        }
    }
 
    static void printResult( filename) {
        .out.printf(strv, filename);
        double totalCosts = 0;
 
        for (int r = 0; r < supply.length; r++) {
            for (int c = 0; c < demand.length; c++) {
 
                Shipment s = matrix[r][c];
                if (s != null && s.r == r && s.c == c) {
                    .out.printf(strv, (int) s.quantity);
                    totalCosts += (s.quantity * s.costPerUnit);
                } else
                    .out.printf(strv);
            }
            .out.println();
        }
        .out.printf(strv, totalCosts);
    }
 
    public static void main([] args) throws  {
 
        for ( filename : new []{strv, strv,
            strv}) {
            init(filename);
            northWestCornerRule();
            steppingStone();
            printResult(filename);
        }
    }
}"
"/** * Alexander Alvonellos  */
import java.util.*;
import java.io.*; 
 
public class TPKA {
	public static void main(... args) {
		double[] input = new double[11];
		double userInput = 0.0;
		Scanner in = new Scanner(.in);
		for(int i = 0; i < 11; i++) {
			.out.print(strv);
			 s = in.nextLine();
			try {
				userInput = .parseDouble(s);
			} catch ( e) { 
				.out.println(strv);
				.exit(1);
			}
			input[i] = userInput;
		}
		for(int j = 10; j >= 0; j--) {
			double x = input[j]; double y = f(x);
			if( y < 400.0) {
				.out.printf(""f( %.2f ) = %.2f"", x, y);
			} else {
				.out.printf(""f( %.2f ) = %s"", x, strv);
			}
		}
	}
 
	private static double f(double x) {
		return .pow(.abs(x), 0.5) + (5*(.pow(x, 3)));
	}
}
 "
" 
public class LogicPuzzle
{
    boolean S[] = new boolean[13];
    int Count = 0;
 
    public boolean check2 ()
    {
        int count = 0;
        for (int k = 7; k <= 12; k++)
            if (S[k]) count++;
        return S[2] == (count == 3);
    }
 
    public boolean check3 ()
    {
        int count = 0;
        for (int k = 2; k <= 12; k += 2)
            if (S[k]) count++;
        return S[3] == (count == 2);
    }
 
    public boolean check4 ()
    {
        return S[4] == ( !S[5] || S[6] && S[7]);
    }
 
    public boolean check5 ()
    {
        return S[5] == ( !S[2] && !S[3] && !S[4]);
    }
 
    public boolean check6 ()
    {
        int count = 0;
        for (int k = 1; k <= 11; k += 2)
            if (S[k]) count++;
        return S[6] == (count == 4);
    }
 
    public boolean check7 ()
    {
        return S[7] == ((S[2] || S[3]) && !(S[2] && S[3]));
    }
 
    public boolean check8 ()
    {
        return S[8] == ( !S[7] || S[5] && S[6]);
    }
 
    public boolean check9 ()
    {
        int count = 0;
        for (int k = 1; k <= 6; k++)
            if (S[k]) count++;
        return S[9] == (count == 3);
    }
 
    public boolean check10 ()
    {
        return S[10] == (S[11] && S[12]);
    }
 
    public boolean check11 ()
    {
        int count = 0;
        for (int k = 7; k <= 9; k++)
            if (S[k]) count++;
        return S[11] == (count == 1);
    }
 
    public boolean check12 ()
    {
        int count = 0;
        for (int k = 1; k <= 11; k++)
            if (S[k]) count++;
        return S[12] == (count == 4);
    }
 
    public void check ()
    {
        if (check2() && check3() && check4() && check5() && check6()
            && check7() && check8() && check9() && check10() && check11()
            && check12())
        {
            for (int k = 1; k <= 12; k++)
                if (S[k]) .out.print(k + strv);
            .out.println();
            Count++;
        }
    }
 
    public void recurseAll (int k)
    {
        if (k == 13)
            check();
        else
        {
            S[k] = false;
            recurseAll(k + 1);
            S[k] = true;
            recurseAll(k + 1);
        }
    }
 
    public static void main ( args[])
    {
        LogicPuzzle P = new LogicPuzzle();
        P.S[1] = true;
        P.recurseAll(2);
        .out.println();
        .out.println(P.Count + strv);
    }
}
 "
"public class Trig {
        public static void main([] args) {
                //Pi / 4 is 45 degrees. All answers should be the same.
                double radians = .PI / 4;
                double degrees = 45.0;
                //sine
                .out.println(.sin(radians) + strv + .sin(.toRadians(degrees)));
                //cosine
                .out.println(.cos(radians) + strv + .cos(.toRadians(degrees)));
                //tangent
                .out.println(.tan(radians) + strv + .tan(.toRadians(degrees)));
                //arcsine
                double arcsin = .asin(.sin(radians));
                .out.println(arcsin + strv + .toDegrees(arcsin));
                //arccosine
                double arccos = .acos(.cos(radians));
                .out.println(arccos + strv + .toDegrees(arccos));
                //arctangent
                double arctan = .atan(.tan(radians));
                .out.println(arctan + strv + .toDegrees(arctan));
        }
}"
"public class Topswops {
    static final int maxBest = 32;
    static int[] best;
 
    static private void trySwaps(int[] deck, int f, int d, int n) {
        if (d > best[n])
            best[n] = d;
 
        for (int i = n - 1; i >= 0; i--) {
            if (deck[i] == -1 || deck[i] == i)
                break;
            if (d + best[i] <= best[n])
                return;
        }
 
        int[] deck2 = deck.clone();
        for (int i = 1; i < n; i++) {
            final int k = 1 << i;
            if (deck2[i] == -1) {
                if ((f & k) != 0)
                    continue;
            } else if (deck2[i] != i)
                continue;
 
            deck2[0] = i;
            for (int j = i - 1; j >= 0; j--)
                deck2[i - j] = deck[j]; 

            trySwaps(deck2, f | k, d + 1, n);
        }
    }
 
    static int topswops(int n) {
        assert(n > 0 && n < maxBest);
        best[n] = 0;
        int[] deck0 = new int[n + 1];
        for (int i = 1; i < n; i++)
            deck0[i] = -1;
        trySwaps(deck0, 1, 0, n);
        return best[n];
    }
 
    public static void main([] args) {
        best = new int[maxBest];
        for (int i = 1; i < 11; i++)
            .out.println(i + strv + topswops(i));
    }
}"
" 
public class CirclesTotalArea {
 
    /* Solution by      * Rectangles are given as 4-element arrays [tx, ty, w, h].     * Circles are given as 3-element arrays [cx, cy, r].     */
 
    private static double distSq(double x1, double y1, double x2, double y2) {
        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    }
 
    private static boolean rectangleFullyInsideCircle(double[] rect, double[] circ) {
        double r2 = circ[2] * circ[2];
        

        return distSq(rect[0], rect[1], circ[0], circ[1]) <= r2 &&
          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) <= r2 &&
          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) <= r2 &&
          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) <= r2;
    }
 
    private static boolean rectangleSurelyOutsideCircle(double[] rect, double[] circ) {
        

        if(rect[0] <= circ[0] && circ[0] <= rect[0] + rect[2] &&
          rect[1] - rect[3] <= circ[1] && circ[1] <= rect[1]) { return false; }
        

        double r2 = circ[2] + .max(rect[2], rect[3]);
        r2 = r2 * r2;
        return distSq(rect[0], rect[1], circ[0], circ[1]) >= r2 &&
          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) >= r2 &&
          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) >= r2 &&
          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) >= r2;
    }
 
    private static boolean[] surelyOutside;
 
    private static double totalArea(double[] rect, double[][] circs, int d) {    
        

        int surelyOutsideCount = 0;
        for(int i = 0; i < circs.length; i++) {
            if(rectangleFullyInsideCircle(rect, circs[i])) { return rect[2] * rect[3]; }
            if(rectangleSurelyOutsideCircle(rect, circs[i])) {
                surelyOutside[i] = true;
                surelyOutsideCount++;
            }
            else { surelyOutside[i] = false; }
        }
        

        if(surelyOutsideCount == circs.length) { return 0; }
        

        if(d < 1) { 
            return rect[2] * rect[3] / 3;  

        }
        

        if(surelyOutsideCount > 0) {
            double[][] newCircs = new double[circs.length - surelyOutsideCount][3];
            int loc = 0;
            for(int i = 0; i < circs.length; i++) {
                if(!surelyOutside[i]) { newCircs[loc++] = circs[i]; }
            }
            circs = newCircs;
        }
        

        double w = rect[2] / 2; 

        double h = rect[3] / 2; 

        double[][] pieces = {
            { rect[0], rect[1], w, h }, 

            { rect[0] + w, rect[1], w, h }, 

            { rect[0], rect[1] - h, w, h }, 

            { rect[0] + w, rect[1] - h, w, h } 

        };
        double total = 0;
        for(double[] piece: pieces) { total += totalArea(piece, circs, d - 1); }
        return total;
    }
 
    public static double totalArea(double[][] circs, int d) {
        double maxx = .NEGATIVE_INFINITY;
        double minx = .POSITIVE_INFINITY;
        double maxy = .NEGATIVE_INFINITY;
        double miny = .POSITIVE_INFINITY;
        

        for(double[] circ: circs) {
            if(circ[0] + circ[2] > maxx) { maxx = circ[0] + circ[2]; }
            if(circ[0] - circ[2] < minx) { minx = circ[0] - circ[2]; }
            if(circ[1] + circ[2] > maxy) { maxy = circ[1] + circ[2]; }
            if(circ[1] - circ[2] < miny) { miny = circ[1] - circ[2]; }
        }
        double[] rect = { minx, maxy, maxx - minx, maxy - miny };
        surelyOutside = new boolean[circs.length];
        return totalArea(rect, circs, d);
    }
 
    public static void main([] args) {
        double[][] circs = {
            { 1.6417233788, 1.6121789534, 0.0848270516 },
            {-1.4944608174, 1.2077959613, 1.1039549836 },
            { 0.6110294452, -0.6907087527, 0.9089162485 },
            { 0.3844862411, 0.2923344616, 0.2375743054 },
            {-0.2495892950, -0.3832854473, 1.0845181219 },
            {1.7813504266, 1.6178237031, 0.8162655711 },
            {-0.1985249206, -0.8343333301, 0.0538864941 },
            {-1.7011985145, -0.1263820964, 0.4776976918 },
            {-0.4319462812, 1.4104420482, 0.7886291537 },
            {0.2178372997, -0.9499557344, 0.0357871187 },
            {-0.6294854565, -1.3078893852, 0.7653357688 },
            {1.7952608455, 0.6281269104, 0.2727652452 },
            {1.4168575317, 1.0683357171, 1.1016025378 },
            {1.4637371396, 0.9463877418, 1.1846214562 },
            {-0.5263668798, 1.7315156631, 1.4428514068 },
            {-1.2197352481, 0.9144146579, 1.0727263474 },
            {-0.1389358881, 0.1092805780, 0.7350208828 },
            {1.5293954595, 0.0030278255, 1.2472867347 },
            {-0.5258728625, 1.3782633069, 1.3495508831 },
            {-0.1403562064, 0.2437382535, 1.3804956588 },
            {0.8055826339, -0.0482092025, 0.3327165165 },
            {-0.6311979224, 0.7184578971, 0.2491045282 },
            {1.4685857879, -0.8347049536, 1.3670667538 },
            {-0.6855727502, 1.6465021616, 1.0593087096 },
            {0.0152957411, 0.0638919221, 0.9771215985 }
        };
        double ans = totalArea(circs, 24);
        .out.println(strv + ans);
        .out.println(strv + .abs(21.56503660 - ans));
    }
}"
"import java.util.*;
import static java.util..asList;
import static java.util.stream.Collectors.toList;
 
public class TopologicalSort2 {
 
    public static void main([] args) {
         s = strv
                + strv;
 
        Graph g = new Graph(s, new int[][]{
            {0, 10}, {0, 2}, {0, 3},
            {1, 10}, {1, 3}, {1, 4},
            {2, 17}, {2, 5}, {2, 9},
            {3, 6}, {3, 7}, {3, 8}, {3, 9},
            {10, 11}, {10, 12}, {10, 13},
            {11, 14}, {11, 15},
            {13, 16}, {13, 17},});
 
        .out.println(strv + g.toplevels());
        [] files = {strv, strv, strv};
        for ( f : files)
            .out.printf(strv, f, g.compileOrder(f));
    }
}
 
class Graph {
    List<String> vertices;
    boolean[][] adjacency;
    int numVertices;
 
    public Graph( s, int[][] edges) {
        vertices = asList(s.split(strv));
        numVertices = vertices.size();
        adjacency = new boolean[numVertices][numVertices];
 
        for (int[] edge : edges)
            adjacency[edge[0]][edge[1]] = true;
    }
 
    List<String> toplevels() {
        List<String> result = new ArrayList<>();
        

        outer:
        for (int c = 0; c < numVertices; c++) {
            for (int r = 0; r < numVertices; r++) {
                if (adjacency[r][c])
                    continue outer;
            }
            result.add(vertices.get(c));
        }
        return result;
    }
 
    List<String> compileOrder( item) {
        LinkedList<String> result = new LinkedList<>();
        LinkedList<Integer> queue = new LinkedList<>();
 
        queue.add(vertices.indexOf(item));
 
        while (!queue.isEmpty()) {
            int r = queue.poll();
            for (int c = 0; c < numVertices; c++) {
                if (adjacency[r][c] && !queue.contains(c)) {
                    queue.add(c);
                }
            }
            result.addFirst(vertices.get(r));
        }
        return result.stream().distinct().collect(toList());
    }
}"
"public void move(int n, int from, int to, int via) {
  if (n == 1) {
    .out.println(strv + from + strv + to);
  } else {
    move(n - 1, from, via, to);
    move(1, from, to, via);
    move(n - 1, via, to, from);
  }
}"
"import java.util.*;
 
public class TokenizeStringWithEscaping {
 
    public static void main([] args) {
         sample = strv;
        char separator = '|';
        char escape = '^';
 
        .out.println(sample);
        try {
            .out.println(tokenizeString(sample, separator, escape));
        } catch ( e) {
            .out.println(e);
        }
    }
 
    public static List<String> tokenizeString( s, char sep, char escape)
            throws  {
        List<String> tokens = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
 
        boolean inEscape = false;
        for (char c : s.toCharArray()) {
            if (inEscape) {
                inEscape = false;
            } else if (c == escape) {
                inEscape = true;
                continue;
            } else if (c == sep) {
                tokens.add(sb.toString());
                sb.setLength(0);
                continue;
            }
            sb.append(c);
        }
        if (inEscape)
            throw new (strv);
 
        tokens.add(sb.toString());
 
        return tokens;
    }
}"
"import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
 
public class TimeIt {
	public static void main([] args) {
		final ThreadMXBean threadMX = ManagementFactory.getThreadMXBean();
		assert threadMX.isCurrentThreadCpuTimeSupported();
		threadMX.setThreadCpuTimeEnabled(true);
 
		long start, end;
		start = threadMX.getCurrentThreadCpuTime();
		countTo(100000000);
		end = threadMX.getCurrentThreadCpuTime();
		.out.println(strv+(end-start)/1000000+strv);
		start = threadMX.getCurrentThreadCpuTime();
		countTo(1000000000L);
		end = threadMX.getCurrentThreadCpuTime();
		.out.println(strv+(end-start)/1000000+strv);
 
	}
 
	public static void countTo(long x){
		.out.println(strv);
		for(long i=0;i<x;i++);
		.out.println(strv);
	}
}	public static void main([] args){
		long start, end;
		start = .currentTimeMillis();
		countTo(100000000);
		end = .currentTimeMillis();
		.out.println(strv+(end-start)+strv);
		start = .currentTimeMillis();
		countTo(1000000000L);
		end = .currentTimeMillis();
		.out.println(strv+(end-start)+strv);
 
	}"
"public class ThueMorse {
 
    public static void main([] args) {
        sequence(6);
    }
 
    public static void sequence(int steps) {
        StringBuilder sb1 = new StringBuilder(strv);
        StringBuilder sb2 = new StringBuilder(strv);
        for (int i = 0; i < steps; i++) {
             tmp = sb1.toString();
            sb1.append(sb2);
            sb2.append(tmp);
        }
        .out.println(sb1);
    }
}"
"import java.io.File;
import java.util.*;
 
public class TopRankPerGroup {
 
    private static class Employee {
        final  name;
        final  id;
        final  department;
        final int salary;
 
        Employee([] rec) {
            name = rec[0];
            id = rec[1];
            salary = .parseInt(rec[2]);
            department = rec[3];
        }
 
        @Override
        public  toString() {
            return .format(strv, id, name, salary, department);
        }
    }
 
    public static void main([] args) throws  {
        int N = args.length > 0 ? .parseInt(args[0]) : 3;
 
        Map<, List<Employee>> records = new TreeMap<>();
        try (Scanner sc = new Scanner(new (strv))) {
            while (sc.hasNextLine()) {
                [] rec = sc.nextLine().trim().split(strv);
 
                List<Employee> lst = records.get(rec[3]);
                if (lst == null) {
                    lst = new ArrayList<>();
                    records.put(rec[3], lst);
                }
                lst.add(new Employee(rec));
            }
        }
 
        records.forEach((key, val) -> {
            .out.printf(strv, key);
            val.stream()
                .sorted((a, b) -> .compare(b.salary, a.salary))
                .limit(N).forEach(.out::println);
        });
    }
}"
"import java.util.*;
 
public class TopologicalSort {
 
    public static void main([] args) {
         s = strv
                + strv;
 
        Graph g = new Graph(s, new int[][]{
            {2, 0}, {2, 14}, {2, 13}, {2, 4}, {2, 3}, {2, 12}, {2, 1},
            {3, 1}, {3, 10}, {3, 11},
            {4, 1}, {4, 10},
            {5, 0}, {5, 14}, {5, 10}, {5, 4}, {5, 3}, {5, 1}, {5, 11},
            {6, 1}, {6, 3}, {6, 10}, {6, 11},
            {7, 1}, {7, 10},
            {8, 1}, {8, 10},
            {9, 1}, {9, 10},
            {10, 1},
            {11, 1}, {11, 10},
            {12, 0}, {12, 1},
            {13, 1}
        });
 
        .out.println(strv);
        .out.println(g.topoSort());
    }
}
 
class Graph {
    [] vertices;
    boolean[][] adjacency;
    int numVertices;
 
    public Graph( s, int[][] edges) {
        vertices = s.split(strv);
        numVertices = vertices.length;
        adjacency = new boolean[numVertices][numVertices];
 
        for (int[] edge : edges)
            adjacency[edge[0]][edge[1]] = true;
    }
 
    List<String> topoSort() {
        List<String> result = new ArrayList<>();
        List<Integer> todo = new LinkedList<>();
 
        for (int i = 0; i < numVertices; i++)
            todo.add(i);
 
        try {
            outer:
            while (!todo.isEmpty()) {
                for ( r : todo) {
                    if (!hasDependency(r, todo)) {
                        todo.remove(r);
                        result.add(vertices[r]);
                         

                        continue outer;
                    }
                }
                throw new (strv);
            }
        } catch ( e) {
            .out.println(e);
            return null;
        }
        return result;
    }
 
    boolean hasDependency( r, List<Integer> todo) {
        for ( c : todo) {
            if (adjacency[r][c])
                return true;
        }
        return false;
    }
}"
"import static java.lang..*;
 
public class Test {
    final static int N = 32;
    final static int N2 = (N * (N - 1) / 2);
    final static double STEP = 0.05;
 
    static double[] xval = new double[N];
    static double[] t_sin = new double[N];
    static double[] t_cos = new double[N];
    static double[] t_tan = new double[N];
 
    static double[] r_sin = new double[N2];
    static double[] r_cos = new double[N2];
    static double[] r_tan = new double[N2];
 
    static double rho(double[] x, double[] y, double[] r, int i, int n) {
        if (n < 0)
            return 0;
 
        if (n == 0)
            return y[i];
 
        int idx = (N - 1 - n) * (N - n) / 2 + i;
        if (r[idx] != r[idx])
            r[idx] = (x[i] - x[i + n])
                    / (rho(x, y, r, i, n - 1) - rho(x, y, r, i + 1, n - 1))
                    + rho(x, y, r, i + 1, n - 2);
 
        return r[idx];
    }
 
    static double thiele(double[] x, double[] y, double[] r, double xin, int n) {
        if (n > N - 1)
            return 1;
        return rho(x, y, r, 0, n) - rho(x, y, r, 0, n - 2)
                + (xin - x[n]) / thiele(x, y, r, xin, n + 1);
    }
 
    public static void main([] args) {
        for (int i = 0; i < N; i++) {
            xval[i] = i * STEP;
            t_sin[i] = sin(xval[i]);
            t_cos[i] = cos(xval[i]);
            t_tan[i] = t_sin[i] / t_cos[i];
        }
 
        for (int i = 0; i < N2; i++)
            r_sin[i] = r_cos[i] = r_tan[i] = .NaN;
 
        .out.printf(strv, 6 * thiele(t_sin, xval, r_sin, 0.5, 0));
        .out.printf(strv, 3 * thiele(t_cos, xval, r_cos, 0.5, 0));
        .out.printf(strv, 4 * thiele(t_tan, xval, r_tan, 1.0, 0));
    }
}"
" 
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Vector;
 
public class RTextonyms {
 
  private static final Map<, Character> mapping;
  private int total, elements, textonyms, max_found;
  private  filename, mappingResult;
  private Vector<String> max_strings;
  private Map<, Vector<String>> values;
 
  static {
    mapping = new HashMap<, Character>();
    mapping.put('A', '2'); mapping.put('B', '2'); mapping.put('C', '2');
    mapping.put('D', '3'); mapping.put('E', '3'); mapping.put('F', '3');
    mapping.put('G', '4'); mapping.put('H', '4'); mapping.put('I', '4');
    mapping.put('J', '5'); mapping.put('K', '5'); mapping.put('L', '5');
    mapping.put('M', '6'); mapping.put('N', '6'); mapping.put('O', '6');
    mapping.put('P', '7'); mapping.put('Q', '7'); mapping.put('R', '7'); mapping.put('S', '7');
    mapping.put('T', '8'); mapping.put('U', '8'); mapping.put('V', '8');
    mapping.put('W', '9'); mapping.put('X', '9'); mapping.put('Y', '9'); mapping.put('Z', '9');
  }
 
  public RTextonyms( filename) {
 
    this.filename = filename;
    this.total = this.elements = this.textonyms = this.max_found = 0;
    this.values = new HashMap<, Vector<String>>();
    this.max_strings = new Vector<String>();
 
    return;
  }
 
  public void add( line) {
 
     mapping = strv;
    total++;
    if (!get_mapping(line)) {
      return;
    }
    mapping = mappingResult;
 
    if (values.get(mapping) == null) {
      values.put(mapping, new Vector<String>());
    }
 
    int num_strings;
    num_strings = values.get(mapping).size();
    textonyms += num_strings == 1 ? 1 : 0;
    elements++;
 
    if (num_strings > max_found) {
      max_strings.clear();
      max_strings.add(mapping);
      max_found = num_strings;
    }
    else if (num_strings == max_found) {
      max_strings.add(mapping);
    }
 
    values.get(mapping).add(line);
 
    return;
  }
 
  public void results() {
 
    .out.printf(strv, total, filename);
    .out.printf(strv, elements,
        filename);
    .out.printf(strv, values.size());
    .out.printf(strv, textonyms);
    .out.printf(strv, max_found + 1);
    for ( key : max_strings) {
      .out.printf(strv, key, values.get(key).toString());
    }
    .out.println();
 
    return;
  }
 
  public void match( key) {
 
    Vector<String> match;
    match = values.get(key);
    if (match == null) {
      .out.printf(strv, key);
    }
    else {
      .out.printf(strv, key, match.toString());
    }
 
    return;
  }
 
  private boolean get_mapping( line) {
 
    mappingResult = line;
    StringBuilder mappingBuilder = new StringBuilder();
    for (char cc : line.toCharArray()) {
      if (.isAlphabetic(cc)) {
        mappingBuilder.append(mapping.get(.toUpperCase(cc)));
      }
      else if (.isDigit(cc)) {
        mappingBuilder.append(cc);
      }
      else {
        return false;
      }
    }
    mappingResult = mappingBuilder.toString();
 
    return true;
  }
 
  public static void main([] args) {
 
     filename;
    if (args.length > 0) {
      filename = args[0];
    }
    else {
      filename = strv;
    }
    RTextonyms tc;
    tc = new RTextonyms(filename);
    Path fp = Paths.get(filename);
    try (Scanner fs = new Scanner(fp, StandardCharsets.UTF_8.name())) {
      while (fs.hasNextLine()) {
        tc.add(fs.nextLine());
      }
    }
    catch ( ex) {
      ex.printStackTrace();
    }
 
    List<String> numbers = .asList(
        strv, strv, strv, strv,
        strv
        );
 
    tc.results();
    for ( number : numbers) {
      if (number.equals(strv)) {
        .out.println();
      }
      else {
        tc.match(number);
      }
    }
 
    return;
  }
}
 "
"import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.Random;
 
 
public class IsaacRandom extends  {
 
	private static final long serialVersionUID = 1L;
 
	private final int[] randResult = new int[256];    

	private int valuesUsed;                           

 
	

	private final int[] mm = new int[256];
	private int aa, bb, cc;
 
	public IsaacRandom() {
		super(0);
		init(null);
	}
 
	public IsaacRandom(int[] seed) {
		super(0);
		setSeed(seed);
	}
 
	public IsaacRandom( seed) {
		super(0);
		setSeed(seed);
	}
 
	private void generateMoreResults() {
		cc++;
		bb += cc;
 
		for (int i=0; i<256; i++) {
			int x = mm[i];
			switch (i&3) {
			case 0:
				aa = aa^(aa<<13);
				break;
			case 1:
				aa = aa^(aa>>>6);
				break;
			case 2:
				aa = aa^(aa<<2);
				break;
			case 3:
				aa = aa^(aa>>>16);
				break;
			}
			aa = mm[i^128] + aa;
			int y = mm[i] = mm[(x>>>2) & 0xFF] + aa + bb;
			randResult[i] = bb = mm[(y>>>10) & 0xFF] + x;
		}
 
		valuesUsed = 0;
	}
 
	private static void mix(int[] s) {
		   s[0]^=s[1]<<11;  s[3]+=s[0]; s[1]+=s[2];
		   s[1]^=s[2]>>>2;  s[4]+=s[1]; s[2]+=s[3];
		   s[2]^=s[3]<<8;   s[5]+=s[2]; s[3]+=s[4];
		   s[3]^=s[4]>>>16; s[6]+=s[3]; s[4]+=s[5];
		   s[4]^=s[5]<<10;  s[7]+=s[4]; s[5]+=s[6];
		   s[5]^=s[6]>>>4;  s[0]+=s[5]; s[6]+=s[7];
		   s[6]^=s[7]<<8;   s[1]+=s[6]; s[7]+=s[0];
		   s[7]^=s[0]>>>9;  s[2]+=s[7]; s[0]+=s[1];
	}
 
	private void init(int[] seed) {
		if (seed != null && seed.length != 256) {
			seed = .copyOf(seed, 256);
		}
		aa = bb = cc = 0;
		int[] initState = new int[8];
		.fill(initState, 0x9e3779b9);	

 
		for (int i=0; i<4; i++) {
			mix(initState);
		}
 
		for (int i=0; i<256; i+=8) {
			if (seed != null) {
				for (int j=0; j<8; j++) {
					initState[j] += seed[i+j];
				}
			}
			mix(initState);
			for (int j=0; j<8; j++) {
				mm[i+j] = initState[j];
			}
		}
 
		if (seed != null) {
			for (int i=0; i<256; i+=8) {
				for (int j=0; j<8; j++) {
					initState[j] += mm[i+j];
				}
 
				mix(initState);
 
				for (int j=0; j<8; j++) {
					mm[i+j] = initState[j];
				}
			}
		}
 
		valuesUsed = 256;	

	}
 
	@Override
	protected int next(int bits) {
		if (valuesUsed == 256) {
			generateMoreResults();
			assert(valuesUsed == 0);
		}
		int value = randResult[valuesUsed];
		valuesUsed++;
		return value >>> (32-bits);
	}
 
	@Override
	public synchronized void setSeed(long seed) {
		super.setSeed(0);
		if (mm == null) {
			

			

			

			return;
		}
		int[] arraySeed = new int[256];
		arraySeed[0] = (int) (seed & 0xFFFFFFFF);
		arraySeed[1] = (int) (seed >>> 32);
		init(arraySeed);
	}
 
	public synchronized void setSeed(int[] seed) {
		super.setSeed(0);
		init(seed);
	}
 
	public synchronized void setSeed( seed) {
		super.setSeed(0);
		char[] charSeed = seed.toCharArray();
		int[] intSeed = new int[charSeed.length];
		for (int i=0; i<charSeed.length; i++) {
			intSeed[i] = charSeed[i];
		}
		init(intSeed);
	}
 
	public int randomChar() {
		long unsignedNext = nextInt() & 0xFFFFFFFFL;	

		return (int) (unsignedNext % 95 + 32);		    

	}
 
	public enum CipherMode { ENCIPHER, DECIPHER, NONE };
 
	public byte[] vernamCipher(byte[] input) {
		byte[] result = new byte[input.length];
		for (int i=0; i<input.length; i++) {
			result[i] = (byte) (randomChar() ^ input[i]);
		}
		return result;
	}
 
	private static byte caesarShift(CipherMode mode, byte ch, int shift, byte modulo, byte start) {
		if (mode == CipherMode.DECIPHER) {
			shift = -shift;
		}
		int n = (ch-start) + shift;
		n %= modulo;
		if (n<0) {
			n += modulo;
		}
		return (byte) (start + n);
	}
 
	public byte[] caesarCipher(CipherMode mode, byte[] input, byte modulo, byte start) {
		byte[] result = new byte[input.length];
		for (int i=0; i<input.length; i++) {
			result[i] = caesarShift(mode, input[i], randomChar(), modulo, start);
		}
		return result;
	}
 
	private static  toHexString(byte[] input) {
		

		StringBuilder sb = new StringBuilder(input.length*2);
		for (byte b : input) {
			sb.append(.format(strv, b));
		}
		return sb.toString();
	}
 
	public static void main([] args) {
		final byte MOD = 95;
		final byte START = 32;
 
		 secret = strv;
		 key = strv;
 
		IsaacRandom random = new IsaacRandom(key);
		byte[] vernamResult;
		byte[] caesarResult;
		 vernamDecrypted;
		 caesarDecrypted;
		try {
			vernamResult = random.vernamCipher(secret.getBytes(strv));
			caesarResult = random.caesarCipher(CipherMode.ENCIPHER, secret.getBytes(strv), MOD, START);
			random.setSeed(key);
			vernamDecrypted = new (random.vernamCipher(vernamResult), strv);
			caesarDecrypted = new (random.caesarCipher(CipherMode.DECIPHER, caesarResult, MOD, START), strv);
		} catch ( e) {
			throw new (strv);
		}
		.out.printf(""Message: %s"", secret);
		.out.printf(""Key    : %s"", key);
		.out.printf(""XOR    : %s"", toHexString(vernamResult));
		.out.printf(""XOR dcr: %s"", vernamDecrypted);
		.out.printf(""MOD    : %s"", toHexString(caesarResult));
		.out.printf(""MOD dcr: %s"", caesarDecrypted);
	}
}"
" 
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Hashtable;
 
public class TicTacToe
{
	public static void main([] args)
	{
		TicTacToe now=new TicTacToe();
		now.startMatch();
	}
 
	private int[][] marks;
	private int[][] wins;
	private int[] weights;
	private char[][] grid;
	private final int knotcount=3;
	private final int crosscount=4;
	private final int totalcount=5;
	private final int playerid=0;
	private final int compid=1;
	private final int truceid=2;
	private final int playingid=3;
	private  movesPlayer;
	private byte override;
	private char[][] overridegrid={{'o','o','o'},{'o','o','o'},{'o','o','o'}};
	private char[][] numpad={{'7','8','9'},{'4','5','6'},{'1','2','3'}};
	private Hashtable<,Integer> crossbank;
	private Hashtable<,Integer> knotbank;
 
	public void startMatch()
	{
		 br=new (new (.in));
		.out.print(strv);
		char choice='y';
		try
		{
			choice=br.readLine().charAt(0);
		}
		catch( e)
		{
			.out.println(e.getMessage());
		}
		if(choice=='n'||choice=='N')
		{
			return;
		}
 
		.out.println(""Use a standard numpad as an entry grid, as so: "");
		display(numpad);
		.out.println(strv);
		int playerscore=0;
		int compscore=0;
		do
		{
			int result=startGame();
			if(result==playerid)
				playerscore++;
			else if(result==compid)
				compscore++;
			.out.println(strv+playerscore+strv+compscore);
			.out.print(strv);
			try
			{
				choice=br.readLine().charAt(0);
			}
			catch( e)
			{
				.out.println(e.getMessage());
			}
 
		}while(choice!='n'||choice=='N');
 
		.out.println(strv);
	}
	private void put(int cell,int player)
	{
		int i=-1,j=-1;;
		switch(cell)
		{
		case 1:i=2;j=0;break;
		case 2:i=2;j=1;break;
		case 3:i=2;j=2;break;
		case 4:i=1;j=0;break;
		case 5:i=1;j=1;break;
		case 6:i=1;j=2;break;
		case 7:i=0;j=0;break;
		case 8:i=0;j=1;break;
		case 9:i=0;j=2;break;
		default:display(overridegrid);return;
		}
		char mark='x';
		if(player==0)
			mark='o';
		grid[i][j]=mark;
		display(grid);
	}
	private int startGame()
	{
		init();
		display(grid);
		int status=playingid;
		while(status==playingid)
		{
			put(playerMove(),0);
			if(override==1)
			{
				.out.println(strv);
				return playerid;
			}
			status=checkForWin();
			if(status!=playingid)
				break;
			try{.sleep(1000);}catch( e){.out.print(e.getMessage());}
			put(compMove(),1);
			status=checkForWin();
		}
		return status;
	}
	private void init()
	{
		movesPlayer=strv;
		override=0;
		marks=new int[8][6];
		wins=new int[][]	//new int[8][3];
		{	
				{7,8,9},
				{4,5,6},
				{1,2,3},
				{7,4,1},
				{8,5,2},
				{9,6,3},
				{7,5,3},
				{9,5,1}
		};
		weights=new int[]{3,2,3,2,4,2,3,2,3};
		grid=new char[][]{{' ',' ',' '},{' ',' ',' '},{' ',' ',' '}};
		crossbank=new Hashtable<,Integer>();
		knotbank=new Hashtable<,Integer>();
	}
	private void mark(int m,int player)
	{
		for(int i=0;i<wins.length;i++)
			for(int j=0;j<wins[i].length;j++)
				if(wins[i][j]==m)
				{
					marks[i][j]=1;
					if(player==playerid)
						marks[i][knotcount]++;
					else
						marks[i][crosscount]++;
					marks[i][totalcount]++;
				}
	}
	private void fixWeights()
	{
		for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
				if(marks[i][j]==1)
					if(weights[wins[i][j]-1]!=.MIN_VALUE)
						weights[wins[i][j]-1]=.MIN_VALUE;
 
		for(int i=0;i<8;i++)
		{
			if(marks[i][totalcount]!=2)
				continue;
			if(marks[i][crosscount]==2)
			{
				int p=i,q=-1;
				if(marks[i][0]==0)
					q=0;
				else if(marks[i][1]==0)
					q=1;
				else if(marks[i][2]==0)
					q=2;
 
				if(weights[wins[p][q]-1]!=.MIN_VALUE)
				{
					weights[wins[p][q]-1]=6;
				}
			}
			if(marks[i][knotcount]==2)
			{
				int p=i,q=-1;
				if(marks[i][0]==0)
					q=0;
				else if(marks[i][1]==0)
					q=1;
				else if(marks[i][2]==0)
					q=2;
 
				if(weights[wins[p][q]-1]!=.MIN_VALUE)
				{
					weights[wins[p][q]-1]=5;
				}
			}
		}
	}
	private int compMove()
	{
		int cell=move();
		.out.println(strv+cell);
		//weights[cell-1]=Integer.MIN_VALUE;
		return cell;
	}
	private int move()
	{
		int max=.MIN_VALUE;
		int cell=0;
		for(int i=0;i<weights.length;i++)
			if(weights[i]>max)
			{
				max=weights[i];
				cell=i+1;
			}
 
		//This section ensures the computer never loses
		//Remove it for a fair match
		//Dirty kluge
		if(movesPlayer.equals(strv)||movesPlayer.equals(strv))
			cell=9;
		else if(movesPlayer.equals(strv)||movesPlayer.equals(strv))
			cell=3;
		else if (movesPlayer.equals(strv)||movesPlayer.equals(strv))
			cell=7;
		else if(movesPlayer.equals(strv)||movesPlayer.equals(strv))
			cell=4*((int)(.random()*2)+1);
		else if(movesPlayer.equals(strv)||movesPlayer.equals(strv))
			cell=4+2*(int)(.pow(-1, (int)(.random()*2)));
 
		mark(cell,1);
		fixWeights();
		crossbank.put(cell, 0);
		return cell;
	}
	private int playerMove()
	{
		.out.print(strv);
		 br=new (new (.in));
		int cell=0;
		int okay=0;
		while(okay==0)
		{
			try
			{
				cell=.parseInt(br.readLine());
			}
			catch( e)
			{
				.out.println(e.getMessage());
			}
			if(cell==7494)
			{
				override=1;
				return -1;
			}
			if((cell<1||cell>9)||weights[cell-1]==.MIN_VALUE)
				.out.print(strv);
			else
				okay=1;
		}
		playerMoved(cell);
		.out.println();
		return cell;
	}
	private void playerMoved(int cell)
	{
		movesPlayer+=cell;
		mark(cell,0);
		fixWeights();
		knotbank.put(cell, 0);
	}
	private int checkForWin()
	{
		int crossflag=0,knotflag=0;
		for(int i=0;i<wins.length;i++)
		{
			if(crossbank.containsKey(wins[i][0]))
				if(crossbank.containsKey(wins[i][1]))
					if(crossbank.containsKey(wins[i][2]))
					{
						crossflag=1;
						break;
					}
			if(knotbank.containsKey(wins[i][0]))
				if(knotbank.containsKey(wins[i][1]))
					if(knotbank.containsKey(wins[i][2]))
					{
						knotflag=1;
						break;
					}
		}
		if(knotflag==1)
		{
			display(grid);
			.out.println(strv);
			return playerid;
		}
		else if(crossflag==1)
		{
			display(grid);
			.out.println(strv);
			return compid;
		}
 
		for(int i=0;i<weights.length;i++)
			if(weights[i]!=.MIN_VALUE)
				return playingid;
		.out.println(strv);
 
		return truceid;
	}
	private void display(char[][] grid)
	{
		for(int i=0;i<3;i++)
		{
			.out.println(""-------"");
			.out.print(strv);
			for(int j=0;j<3;j++)
				.out.print(grid[i][j]+strv);
		}
		.out.println(""-------"");
	}
}
 import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.logging.Logger;
/** * TicTacToe Application* @author Steve Robinson* @version 1.0*/
class TicTacToeFrame extends 
{
  [][] buttons= new [3][3];
  statusBar;
 GamePanel panel;
  turn;
 GameListener listener=new GameListener();
  count;
 public TicTacToeFrame()
 {
setLayout(new ());
  panel=new GamePanel();
  add(panel,.CENTER);
  statusBar=new (strv);
  statusBar.setEditable(false);
  add(statusBar,.SOUTH);
  setTitle(strv);
  setVisible(true);
  setDefaultCloseOperation(.EXIT_ON_CLOSE);
  setBounds(400,400,300,300);
 }
 class GamePanel extends 
 {
  public GamePanel()
  {
   setLayout(new (3,3));
   turn =1;
   count=0;
   for(int i=0;i<3;i++)
    for(int j=0;j<3;j++)   {
     buttons[i][j]=new ();
     buttons[i][j].putClientProperty(strv, new []{i,j});
     buttons[i][j].putClientProperty(strv, null);
     buttons[i][j].addActionListener(listener);
     add(buttons[i][j]);
    }
  }
 }
 class GameListener implements 
 {
  public void actionPerformed( e)
  {
   count++;
    b=()e.getSource();
   []index=([]) b.getClientProperty(strv);
   //System.out.println(turn); //turn                  //   //System.out.println(strv);         //
   b.putClientProperty(strv, turn);
    ico=new (turn.toString()+strv);
   b.setIcon(ico);
   b.setEnabled(false);
   boolean result=checkVictoryCondition(index);
   if(result)
   {
    .showMessageDialog(null, strv+turn.toString()+strv);
    initComponents();
   }
   else
   {
    if(turn==1)
    {
     turn=2;
     statusBar.setText(strv);
    }
    else
    {
     turn=1;
     statusBar.setText(strv);
    }
   }
   if(count==9)
   {
    .showMessageDialog(null, strv);
    initComponents();
   }
  }
   getOwner( b)
  {
   return ()b.getClientProperty(strv);
  }
  //PrintButtonMap for Diagnostics
  void printbuttonMap( [][]bMap)
  {
   for(int i=0;i    for(int j=0;j     .out.print(bMap[i][j]+strv);
    .out.println(strv);
   }
  }
  boolean checkVictoryCondition( [] index)
  {
   /*Integer[][]buttonMap=new Integer[][] {      { getOwner(buttons[0][0]),getOwner(buttons[0][1]),getOwner(buttons[0][2])},      { getOwner(buttons[1][0]),getOwner(buttons[1][1]),getOwner(buttons[1][2])},      { getOwner(buttons[2][0]),getOwner(buttons[2][1]),getOwner(buttons[2][2])}   };   printbuttonMap(buttonMap); */
    a=index[0];
                 b=index[1];
   int i;
   //check row
   for(i=0;i<3;i++)  {
    if(getOwner(buttons[a][i])!=getOwner(buttons[a][b]))
     break;
   }
   if(i==3)
    return true;
   //check column
   for(i=0;i<3;i++)  {
    if(getOwner(buttons[i][b])!=getOwner(buttons[a][b]))
     break;
   }
   if(i==3)
    return true;
   //check diagonal
   if((a==2&&b==2)||(a==0&&b==0)||(a==1&&b==1)||(a==0&&b==2)||(a==2&&b==0))
   {
    //left diagonal
    for(i=0;i     if(getOwner(buttons[i][i])!=getOwner(buttons[a][b]))
      break;
    if(i==3)
     return true;
    //right diagonal
    if((getOwner(buttons[0][2])==getOwner(buttons[a][b]))&&(getOwner(buttons[1][1])==getOwner(buttons[a][b]))&&(getOwner(buttons[2][0])==getOwner(buttons[a][b])))
     return true;
    }
   return false;
  }
 }
 void initComponents()
 {
  for(int i=0;i<3;i++)  
   for(int j=0;j<3;j++)  {
    buttons[i][j].putClientProperty(strv, new []{i,j});
    buttons[i][j].putClientProperty(strv,null);
    buttons[i][j].setIcon(null);
    buttons[i][j].setEnabled(true);
    turn=1;
    count=0;
    statusBar.setText(strv);
   }
 }
}
class TicTacToe {
 public static void main([] args) {
  .invokeLater(new (){
   public void run()
   {
    TicTacToeFrame frame=new TicTacToeFrame();
   }
  });
 }
}
  
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
 
 
//Make sure the name of the class is the same as the .java file name.
//If you change the class name you should change the class object name in runGUI method
public class ticTacToeCallum implements  {
 
  static  frame;          
  static  contentPane;    
  static  lblEnterFirstPlayerName, lblEnterSecondPlayerName, lblFirstPlayerScore, lblSecondPlayerScore;    
  static  btnButton1, btnButton2, btnButton3, btnButton4, btnButton5, btnButton6, btnButton7, btnButton8, btnButton9, btnClearBoard, btnClearAll, btnCloseGame;     
  static  txtEnterFirstPlayerName, txtEnterSecondPlayerName;  
  static  imgicon = new (strv);
 
   buttonFont = new (strv, .PLAIN, 20);
 
 
  //to adjust the frame size change the values in pixels
  static int width = 600;
  static int length = 400;
  static int firstPlayerScore = 0;
  static int secondPlayerScore = 0;
  static int playerTurn = 1;
  static int roundComplete = 0;
  static int button1 = 1, button2 = 1, button3 = 1, button4 = 1, button5 = 1, button6 = 1, button7 = 1, button8 = 1, button9 = 1; 

 
 
  public ticTacToeCallum(){
 
    frame = new (strv);
    frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
 
    contentPane = new ();
    contentPane.setLayout(new (6, 3, 10, 10));
    contentPane.setBorder(.createEmptyBorder(20, 20, 20, 20));
 
    btnButton1 = new (strv);
    btnButton1.setFont(buttonFont);
    btnButton1.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton1.setIcon(imgicon);
    btnButton1.setActionCommand(strv);    
    btnButton1.addActionListener(this);  
    contentPane.add(btnButton1);
 
    btnButton2 = new (strv);
    btnButton2.setFont(buttonFont);
    btnButton2.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton2.setIcon(imgicon);
    btnButton2.setActionCommand(strv);    
    btnButton2.addActionListener(this);      
    contentPane.add(btnButton2);
 
    btnButton3 = new (strv); 
    btnButton3.setFont(buttonFont);
    btnButton3.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton3.setIcon(imgicon);
    btnButton3.setActionCommand(strv);    
    btnButton3.addActionListener(this);      
    contentPane.add(btnButton3);
 
    btnButton4 = new (strv);
    btnButton4.setFont(buttonFont);
    btnButton4.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton4.setIcon(imgicon);
    btnButton4.setActionCommand(strv);    
    btnButton4.addActionListener(this);      
    contentPane.add(btnButton4);
 
    btnButton5 = new (strv); 
    btnButton5.setFont(buttonFont);
    btnButton5.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton5.setIcon(imgicon);
    btnButton5.setActionCommand(strv);    
    btnButton5.addActionListener(this);      
    contentPane.add(btnButton5);
 
    btnButton6 = new (strv); 
    btnButton6.setFont(buttonFont);
    btnButton6.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton6.setIcon(imgicon);
    btnButton6.setActionCommand(strv);    
    btnButton6.addActionListener(this);      
    contentPane.add(btnButton6);
 
    btnButton7 = new (strv); 
    btnButton7.setFont(buttonFont);
    btnButton7.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton7.setIcon(imgicon);
    btnButton7.setActionCommand(strv);    
    btnButton7.addActionListener(this);      
    contentPane.add(btnButton7);
 
    btnButton8 = new (strv); 
    btnButton8.setFont(buttonFont);
    btnButton8.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton8.setIcon(imgicon);
    btnButton8.setActionCommand(strv);    
    btnButton8.addActionListener(this);      
    contentPane.add(btnButton8);
 
    btnButton9 = new (strv);
    btnButton9.setFont(buttonFont);
    btnButton9.setAlignmentX(.CENTER_ALIGNMENT);
    btnButton9.setIcon(imgicon);
    btnButton9.setActionCommand(strv);    
    btnButton9.addActionListener(this);      
    contentPane.add(btnButton9);
 
    lblEnterFirstPlayerName = new (strv);
    contentPane.add(lblEnterFirstPlayerName);
 
    txtEnterFirstPlayerName = new (strv);
    contentPane.add(txtEnterFirstPlayerName);
 
    lblFirstPlayerScore = new (strv + firstPlayerScore);
    contentPane.add(lblFirstPlayerScore);
 
    lblEnterSecondPlayerName = new (strv);
    contentPane.add(lblEnterSecondPlayerName);
 
    txtEnterSecondPlayerName = new (strv);
    contentPane.add(txtEnterSecondPlayerName);
 
    lblSecondPlayerScore = new (strv + secondPlayerScore);
    contentPane.add(lblSecondPlayerScore);
 
    btnClearBoard = new (strv);  
    btnClearBoard.setAlignmentX(.CENTER_ALIGNMENT);
    btnClearBoard.setIcon(imgicon);
    btnClearBoard.setActionCommand(strv);    
    btnClearBoard.addActionListener(this);      
    contentPane.add(btnClearBoard);
 
    btnClearAll = new (strv);  
    btnClearAll.setAlignmentX(.CENTER_ALIGNMENT);
    btnClearAll.setIcon(imgicon);
    btnClearAll.setActionCommand(strv);    
    btnClearAll.addActionListener(this);      
    contentPane.add(btnClearAll);
 
    btnCloseGame = new (strv); 
    btnCloseGame.setAlignmentX(.CENTER_ALIGNMENT);
    btnCloseGame.setIcon(imgicon);
    btnCloseGame.setActionCommand(strv);    
    btnCloseGame.addActionListener(this);      
    contentPane.add(btnCloseGame);
 
    frame.setContentPane(contentPane);
    frame.pack();
    frame.setSize(width,length);
    frame.setVisible(true);
 
  }
 
  public void actionPerformed( event) {
     eventName = event.getActionCommand();
     if (eventName.equals(strv)) {
    	 if (button1 == 1){
    		 if (playerTurn == 1){
    			 btnButton1.setForeground(.RED);
    			 btnButton1.setText(strv);
   	  			 playerTurn = 2;
    			 button1 = 0;
    		 } else if (playerTurn == 2) {
    			 btnButton1.setForeground(.GREEN);
    			 btnButton1.setText(strv);
    			 playerTurn = 1;
    			 button1 = 0;
    		 }
    	 }
      } else if (eventName.equals (strv)) {
    	  if (button2 == 1){	
    	  	if (playerTurn == 1){
    	  		btnButton2.setForeground(.RED);
    	  		btnButton2.setText(strv);
  	  			playerTurn = 2;
    	  		button2 = 0;
    	  	} else if (playerTurn == 2) {
    	  		btnButton2.setForeground(.GREEN);
    	  		btnButton2.setText(strv);
    	  		playerTurn = 1;
    	  		button2 = 0;
    	  	}
    	  }	
      }	else if (eventName.equals (strv)) {
    	  if (button3 == 1){	
      	  	if (playerTurn == 1){
      	  		btnButton3.setForeground(.RED);
      	  		btnButton3.setText(strv);
  	  			playerTurn = 2;
      	  		button3 = 0;
      	  	} else if (playerTurn == 2) {
      	  		btnButton3.setForeground(.GREEN);
      	  		btnButton3.setText(strv);
      	  		playerTurn = 1;
      	  		button3 = 0;
      	  	}
      	  }
      }	else if (eventName.equals (strv)) {
    	  if (button4 == 1){	
      	  	if (playerTurn == 1){
      	  		btnButton4.setForeground(.RED);
      	  		btnButton4.setText(strv);
  	  			playerTurn = 2;
      	  		button4 = 0;
      	  	} else if (playerTurn == 2) {
      	  		btnButton4.setForeground(.GREEN);
      	  		btnButton4.setText(strv);
      	  		playerTurn = 1;
      	  		button4 = 0;
      	  	}
      	  }
      }	else if (eventName.equals (strv)) {
    	  if (button5 == 1){	
      	  	if (playerTurn == 1){
      	  		btnButton5.setForeground(.RED);
  	  			btnButton5.setText(strv);
  	  			playerTurn = 2;
  	  			button5 = 0;
      	  	} else if (playerTurn == 2) {
      	  		btnButton5.setForeground(.GREEN);
  	  			btnButton5.setText(strv);
  	  			playerTurn = 1;
  	  			button5 = 0;
      	  	}
      	  }
      } else if (eventName.equals (strv)) {
    	  if (button6 == 1){	
      	  	if (playerTurn == 1){
      	  		btnButton6.setForeground(.RED);
  	  			btnButton6.setText(strv);
  	  			playerTurn = 2;
  	  			button6 = 0;
      	  	} else if (playerTurn == 2) {
      	  		btnButton6.setForeground(.GREEN);
  	  			btnButton6.setText(strv);
  	  			playerTurn = 1;
  	  			button6 = 0;
      	  	}
      	  }
      } else if (eventName.equals (strv)) {
    	  if (button7 == 1){	
      	  	if (playerTurn == 1){
      	  		btnButton7.setForeground(.RED);
  	  			btnButton7.setText(strv);
  	  			playerTurn = 2;
  	  			button7 = 0;
      	  	} else if (playerTurn == 2) {
      	  		btnButton7.setForeground(.GREEN);
  	  			btnButton7.setText(strv);
  	  			playerTurn = 1;
  	  			button7 = 0;
      	  	}
      	  }
      } else if (eventName.equals (strv)) {
    	  if (button8 == 1){	
      	  	if (playerTurn == 1){
      	  		btnButton8.setForeground(.RED);
  	  			btnButton8.setText(strv);
  	  			playerTurn = 2;
  	  			button8 = 0;
      	  	} else if (playerTurn == 2) {
      	  		btnButton8.setForeground(.GREEN);
  	  			btnButton8.setText(strv);
  	  			playerTurn = 1;
  	  			button8 = 0;
      	  	}
      	  }
      } else if (eventName.equals (strv)) {
    	  if (button9 == 1){	
      	  	if (playerTurn == 1){
      	  		btnButton9.setForeground(.RED);
  	  			btnButton9.setText(strv);
  	  			playerTurn = 2;
  	  			button9 = 0;
      	  	} else if (playerTurn == 2) {
      	  		btnButton9.setForeground(.GREEN);
  	  			btnButton9.setText(strv);
  	  			playerTurn = 1;
  	  			button9 = 0;
      	  	}
      	  }
      } else if (eventName.equals (strv)) {
 
    	  btnButton1.setText(strv);
          btnButton2.setText(strv);
          btnButton3.setText(strv);
          btnButton4.setText(strv);
          btnButton5.setText(strv);
          btnButton6.setText(strv);
          btnButton7.setText(strv);
          btnButton8.setText(strv);
          btnButton9.setText(strv);
 
          button1 = 1;
          button2 = 1;
          button3 = 1;
          button4 = 1;
          button5 = 1;
          button6 = 1;
          button7 = 1;
          button8 = 1;
          button9 = 1;
 
          playerTurn = 1;
 
          roundComplete = 0;
 
      } else if (eventName.equals (strv)) {
 
    	  btnButton1.setText(strv);
          btnButton2.setText(strv);
          btnButton3.setText(strv);
          btnButton4.setText(strv);
          btnButton5.setText(strv);
          btnButton6.setText(strv);
          btnButton7.setText(strv);
          btnButton8.setText(strv);
          btnButton9.setText(strv);
 
          firstPlayerScore = 0;
          lblFirstPlayerScore.setText(strv + firstPlayerScore);
          secondPlayerScore = 0;
          lblSecondPlayerScore.setText(strv + secondPlayerScore);
 
          txtEnterFirstPlayerName.setText(strv);
          txtEnterSecondPlayerName.setText(strv);
 
          button1 = 1;
          button2 = 1;
          button3 = 1;
          button4 = 1;
          button5 = 1;
          button6 = 1;
          button7 = 1;
          button8 = 1;
          button9 = 1;
 
          playerTurn = 1;
 
          roundComplete = 0;
 
      } else if (eventName.equals (strv)) {
    	  .exit(0);
      }  
     score();
    }
 
 
  public static void score(){
	  if (roundComplete == 0){
	  if (btnButton1.getText().equals(btnButton2.getText())  && btnButton1.getText().equals(btnButton3.getText())){
	    	if (btnButton1.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton1.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	    if (btnButton1.getText().equals(btnButton4.getText())  && btnButton1.getText().equals(btnButton7.getText())){
	    	if (btnButton1.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton1.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	    if (btnButton1.getText().equals(btnButton5.getText())  && btnButton1.getText().equals(btnButton9.getText())){
	    	if (btnButton1.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton1.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	    if (btnButton7.getText().equals(btnButton8.getText())  && btnButton7.getText().equals(btnButton9.getText())){
	    	if (btnButton7.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton7.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	    if (btnButton7.getText().equals(btnButton5.getText())  && btnButton7.getText().equals(btnButton3.getText())){
	    	if (btnButton7.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton7.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	    if (btnButton3.getText().equals(btnButton6.getText())  && btnButton3.getText().equals(btnButton9.getText())){
	    	if (btnButton3.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton3.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	    if (btnButton4.getText().equals(btnButton5.getText())  && btnButton4.getText().equals(btnButton6.getText())){
	    	if (btnButton4.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton4.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	    if (btnButton2.getText().equals(btnButton5.getText())  && btnButton2.getText().equals(btnButton8.getText())){
	    	if (btnButton2.getText().equals(strv)){
	    		firstPlayerScore += 1;
	    		lblFirstPlayerScore.setText(strv + firstPlayerScore);
	    		roundComplete = 1;
	    	} else if (btnButton2.getText().equals(strv)){
	    		secondPlayerScore += 1;
	    		lblSecondPlayerScore.setText(strv + secondPlayerScore);
	    		roundComplete = 1;
	    	}
	    }
	  }
	    if (roundComplete == 1){
	    	button1 = 0;
	    	button2 = 0;
	    	button3 = 0;
	    	button4 = 0;
	    	button5 = 0;
	    	button6 = 0;
	    	button7 = 0;
	    	button8 = 0;
	    	button9 = 0;
	    }
  }
 
  /**   * Create and show the GUI.   */
  private static void runGUI() {
    ticTacToeCallum        greeting     = new ticTacToeCallum();
  }
 
 
 
  //Do not change this method
  public static void main([] args) {
    /* Methods that create and show a GUI should be run from an event-dispatching thread */
    javax.swing..invokeLater(new () {
      public void run() {
        runGUI();
      }
    });
  }
}
 "
"public class TwelveDaysOfChristmas {
 
    final static [] gifts = {
        strv, strv,
        strv, strv,
        strv, strv,
        strv, strv,
        strv, strv,
        strv, strv,
        strv, strv
    };
 
    final static [] days = {
        strv, strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv
    };
 
    public static void main([] args) {
        for (int i = 0; i < days.length; i++) {
            .out.printf(strv, days[i]);
            .out.println(strv);
            for (int j = i; j >= 0; j--)
                .out.println(gifts[i == 11 && j < 2 ? j + 12 : j]);
        }
    }
}"
"import java.io.File;
import java.util.*;
import static java.lang..out;
 
public class TextProcessing1 {
 
    public static void main([] args) throws  {
        .setDefault(new (strv, strv));
        Metrics metrics = new Metrics();
 
        int dataGap = 0;
         gapBeginDate = null;
        try (Scanner lines = new Scanner(new (strv))) {
            while (lines.hasNextLine()) {
 
                double lineTotal = 0.0;
                int linePairs = 0;
                int lineInvalid = 0;
                 lineDate;
 
                try (Scanner line = new Scanner(lines.nextLine())) {
 
                    lineDate = line.next();
 
                    while (line.hasNext()) {
                        final double value = line.nextDouble();
                        if (line.nextInt() <= 0) {
                            if (dataGap == 0)
                                gapBeginDate = lineDate;
                            dataGap++;
                            lineInvalid++;
                            continue;
                        }
                        lineTotal += value;
                        linePairs++;
 
                        metrics.addDataGap(dataGap, gapBeginDate, lineDate);
                        dataGap = 0;
                    }
                }
                metrics.addLine(lineTotal, linePairs);
                metrics.lineResult(lineDate, lineInvalid, linePairs, lineTotal);
            }
            metrics.report();
        }
    }
 
    private static class Metrics {
        private List<[]> gapDates;
        private int maxDataGap = -1;
        private double total;
        private int pairs;
        private int lineResultCount;
 
        void addLine(double tot, double prs) {
            total += tot;
            pairs += prs;
        }
 
        void addDataGap(int gap,  begin,  end) {
            if (gap > 0 && gap >= maxDataGap) {
                if (gap > maxDataGap) {
                    maxDataGap = gap;
                    gapDates = new ArrayList<>();
                }
                gapDates.add(new []{begin, end});
            }
        }
 
        void lineResult( date, int invalid, int prs, double tot) {
            if (lineResultCount >= 3)
                return;
            out.printf(strv,
                    date, invalid, prs, tot, (prs > 0) ? tot / prs : 0.0);
            lineResultCount++;
        }
 
        void report() {
            out.printf(strv, total);
            out.printf(strv, pairs);
            out.printf(strv, total / pairs);
            out.printf(strv,
                    maxDataGap);
            for ([] dates : gapDates)
                out.printf(strv, dates[0], dates[1]);
 
        }
    }
}"
"public class Bell{
    public static void main([] args){
        java.awt..getDefaultToolkit().beep();
 
        //or
 
        .out.println((char)7);
    }
}"
"import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
 
public class Main
{
    public static void main([] args) throws 
    {
         writer = new (.out, true, strv);
        writer.println(strv);
        writer.println(strv);
    }
}"
"public class Clear
{
    public static void main ([] args)
    {
        .out.print(""33[2J"");
    }
}public class Clear
{
    public static void main ([] args)
    {
        .out.print(""3343"");
    }
}"
"public class TemperatureConversion {
    public static void main( args[]) {
        if (args.length == 1) {
            try {
                double kelvin = .parseDouble(args[0]);
                if (kelvin >= 0) {
                    .out.printf(""K  %2.2f"", kelvin);
                    .out.printf(""C  %2.2f"", kelvinToCelsius(kelvin));
                    .out.printf(""F  %2.2f"", kelvinToFahrenheit(kelvin));
                    .out.printf(""R  %2.2f"", kelvinToRankine(kelvin));
                } else {
                    .out.printf(strv, kelvin);
                }
            } catch ( e) {
                .out.println(e);
            }
        }
    }
 
    public static double kelvinToCelsius(double k) {
        return k + 273.15;
    }
 
    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }
 
    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}"
"import java.io.*;
import java.nio.channels.*;
import java.util.Date;
 
public class TakeNotes {
    public static void main([] args) throws  {
        if (args.length > 0) {
             ps = new (new (strv, true));
            ps.println(new ());
            ps.print("""" + args[0]);
            for (int i = 1; i < args.length; i++)
                ps.print(strv + args[i]);
            ps.println();
            ps.close();
        } else {
            FileChannel fc = new (strv).getChannel();
            fc.transferTo(0, fc.size(), Channels.newChannel(.out));
            fc.close();
        }
    }
}"
"import java.util.PriorityQueue;
import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
 
class CubeSum implements Comparable<CubeSum> {
	public long x, y, value;
 
	public CubeSum(long x, long y) {
		this.x = x;
		this.y = y;
		this.value = x*x*x + y*y*y;
	}
 
	public  toString() {
		return .format(strv, x, y);
	}
 
	public int compareTo(CubeSum that) {
		return value < that.value ? -1 : value > that.value ? 1 : 0;
	}
}
 
class SumIterator implements Iterator<CubeSum> {
	PriorityQueue<CubeSum> pq = new PriorityQueue<CubeSum>();
	long n = 0;
 
	public boolean hasNext() { return true; }
	public CubeSum next() {
		while (pq.size() == 0 || pq.peek().value >= n*n*n)
			pq.add(new CubeSum(++n, 1));
 
		CubeSum s = pq.remove();
		if (s.x > s.y + 1) pq.add(new CubeSum(s.x, s.y+1));
 
		return s;
	}
}
 
class TaxiIterator implements Iterator<List<CubeSum>> {
	Iterator<CubeSum> sumIterator = new SumIterator();
	CubeSum last = sumIterator.next();
 
	public boolean hasNext() { return true; }
	public List<CubeSum> next() {
		CubeSum s;
		List<CubeSum> train = new ArrayList<CubeSum>();
 
		while ((s = sumIterator.next()).value != last.value)
			last = s;
 
		train.add(last);
 
		do { train.add(s); } while ((s = sumIterator.next()).value == last.value);
		last = s;
 
		return train;
	}
}
 
public class Taxi {
	public static final void main([] args) {
		Iterator<List<CubeSum>> taxi = new TaxiIterator();
 
		for (int i = 1; i <= 2006; i++) {
			List<CubeSum> t = taxi.next();
			if (i > 25 && i < 2000) continue;
 
			.out.printf(strv, i, t.get(0).value);
			for (CubeSum s: t)
				.out.print(strv + s);
			.out.println();
		}
	}
}"
"public class SystemTime{
    public static void main([] args){
        .out.format(strv, .currentTimeMillis());
    }
}import java.util.Date;
 
public class SystemTime{
   public static void main([] args){
       now = new ();
      .out.println(now); 

 
      .out.println(now.getTime()); 

      //System.currentTimeMillis() returns the same value
   }
}"
"import java.io.BufferedReader;
import java.io.FileReader;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
 
class SynchronousConcurrency
{
  public static void main([] args) throws 
  {
    final AtomicLong lineCount = new AtomicLong(0);
    final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();
    final  EOF = new ();
 
    final  writerThread = new (new () {
        public void run()
        {
          long linesWrote = 0;
          while (true)
          {
            try
            {
               line = queue.take();
              

              if (line == EOF)
                break;
              .out.println(line);
              linesWrote++;
            }
            catch ( ie)
            {  }
          }
          lineCount.set(linesWrote);
        }
      }
    );
    writerThread.start();
 
    

     br = new (new (strv));
     line;
    while ((line = br.readLine()) != null)
      queue.put(line);
    br.close();
    queue.put(EOF);
    writerThread.join();
    

    .out.println(strv + lineCount.get());
    return;
  }
}
 "
"Set<String> setA = new Set<String>{'John', 'Bob', 'Mary', 'Serena'};
Set<String> setB = new Set<String>{'Jim', 'Mary', 'John', 'Bob'};
 


Set<String> notInSetA = setB.clone();
notInSetA.removeAll(setA);
 
Set<String> notInSetB = setA.clone();
notInSetB.removeAll(setB);
 
Set<String> symmetricDifference = new Set<String>();
symmetricDifference.addAll(notInSetA);
symmetricDifference.addAll(notInSetB);
 


Set<String> union = setA.clone();
union.addAll(setB);
 
Set<String> intersection = setA.clone();
intersection.retainAll(setB);
 
Set<String> symmetricDifference2 = union.clone();
symmetricDifference2.removeAll(intersection);
 
.debug('Not in set A: ' + notInSetA);
.debug('Not in set B: ' + notInSetB);
.debug('Symmetric Difference: ' + symmetricDifference);
.debug('Symmetric Difference 2: ' + symmetricDifference2);import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
 
public class SymmetricDifference {
    public static void main([] args) {
        Set<String> setA = new HashSet<String>(.asList(strv, strv, strv, strv, strv));
        Set<String> setB = new HashSet<String>(.asList(strv, strv, strv, strv, strv));
 
        

        .out.println(strv + setA);
        .out.println(strv + setB);
 
        

        

        Set<String> notInSetA = new HashSet<String>(setB);
        notInSetA.removeAll(setA);
        Set<String> notInSetB = new HashSet<String>(setA);
        notInSetB.removeAll(setB);
 
        

        Set<String> symmetricDifference = new HashSet<String>(notInSetA);
        symmetricDifference.addAll(notInSetB);
 
        

        

        Set<String> union = new HashSet<String>(setA);
        union.addAll(setB);
 
        

        Set<String> intersection = new HashSet<String>(setA);
        intersection.retainAll(setB);
 
        

        Set<String> symmetricDifference2 = new HashSet<String>(union);
        symmetricDifference2.removeAll(intersection);
 
        

        .out.println(strv + notInSetA);
        .out.println(strv + notInSetB);
        .out.println(strv + symmetricDifference);
        .out.println(strv + symmetricDifference2);
    }
}"
"import static java.util.stream.IntStream.rangeClosed;
 
public class Test {
    final static int nMax = 12;
 
    static char[] superperm;
    static int pos;
    static int[] count = new int[nMax];
 
    static int factSum(int n) {
        return rangeClosed(1, n)
                .map(m -> rangeClosed(1, m).reduce(1, (a, b) -> a * b)).sum();
    }
 
    static boolean r(int n) {
        if (n == 0)
            return false;
 
        char c = superperm[pos - n];
        if (--count[n] == 0) {
            count[n] = n;
            if (!r(n - 1))
                return false;
        }
        superperm[pos++] = c;
        return true;
    }
 
    static void superPerm(int n) {
         chars = strv;
 
        pos = n;
        superperm = new char[factSum(n)];
 
        for (int i = 0; i < n + 1; i++)
            count[i] = i;
        for (int i = 1; i < n + 1; i++)
            superperm[i - 1] = chars.charAt(i);
 
        while (r(n)) {
        }
    }
 
    public static void main([] args) {
        for (int n = 0; n < nMax; n++) {
            superPerm(n);
            .out.printf(strv, n, superperm.length);
            .out.println();
        }
    }
}"
"import java.awt.*;
import java.awt.geom.Path2D;
import static java.lang..pow;
import java.util.Hashtable;
import javax.swing.*;
import javax.swing.event.*;
 
public class SuperEllipse extends  implements  {
    private double exp = 2.5;
 
    public SuperEllipse() {
        setPreferredSize(new (650, 650));
        setBackground(.white);
        setFont(new (strv, .PLAIN, 18));
    }
 
    void drawGrid( g) {
        g.setStroke(new (2));
        g.setColor(new (0xEEEEEE));
 
        int w = getWidth();
        int h = getHeight();
        int spacing = 25;
 
        for (int i = 0; i < w / spacing; i++) {
            g.drawLine(0, i * spacing, w, i * spacing);
            g.drawLine(i * spacing, 0, i * spacing, w);
        }
        g.drawLine(0, h - 1, w, h - 1);
 
        g.setColor(new (0xAAAAAA));
        g.drawLine(0, w / 2, w, w / 2);
        g.drawLine(w / 2, 0, w / 2, w);
    }
 
    void drawLegend( g) {
        g.setColor(.black);
        g.setFont(getFont());
        g.drawString(strv + .valueOf(exp), getWidth() - 150, 45);
        g.drawString(strv, getWidth() - 150, 75);
    }
 
    void drawEllipse( g) {
 
        final int a = 200; 

        double[] points = new double[a + 1];
 
        Path2D p = new Path2D.();
        p.moveTo(a, 0);
 
        

        for (int x = a; x >= 0; x--) {
            points[x] = pow(pow(a, exp) - pow(x, exp), 1 / exp); 

            p.lineTo(x, -points[x]);
        }
 
        

        for (int x = 0; x <= a; x++)
            p.lineTo(x, points[x]);
 
        for (int x = a; x >= 0; x--)
            p.lineTo(-x, points[x]);
 
        for (int x = 0; x <= a; x++)
            p.lineTo(-x, -points[x]);
 
        g.translate(getWidth() / 2, getHeight() / 2);
        g.setStroke(new (2));
 
        g.setColor(new (0x25B0C4DE, true));
        g.fill(p);
 
        g.setColor(new (0xB0C4DE)); 

        g.draw(p);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
        g.setRenderingHint(.KEY_TEXT_ANTIALIASING,
                .VALUE_TEXT_ANTIALIAS_ON);
 
        drawGrid(g);
        drawLegend(g);
        drawEllipse(g);
    }
 
    @Override
    public void stateChanged( e) {
         source = () e.getSource();
        exp = source.getValue() / 2.0;
        repaint();
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            SuperEllipse panel = new SuperEllipse();
            f.add(panel, .CENTER);
 
             exponent = new (.HORIZONTAL, 1, 9, 5);
            exponent.addChangeListener(panel);
            exponent.setMajorTickSpacing(1);
            exponent.setPaintLabels(true);
            exponent.setBackground(.white);
            exponent.setBorder(.createEmptyBorder(20, 20, 20, 20));
 
            Hashtable<, JLabel> labelTable = new Hashtable<>();
            for (int i = 1; i < 10; i++)
                labelTable.put(i, new (.valueOf(i * 0.5)));
            exponent.setLabelTable(labelTable);
 
            f.add(exponent, .SOUTH);
 
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"public class Sum{
    public static double f(double x){
       return 1/(x*x);
    }
 
    public static void main([] args){
       double start = 1;
       double end = 1000;
       double sum = 0;
 
       for(double x = start;x <= end;x++) sum += f(x);
 
       .out.println(strv + start + strv + end +strv + sum);
    }
}"
"class SumMultiples {
	public static long getSum(long n) {
		long sum = 0;
		for (int i = 3; i < n; i++) {
			if (i % 3 == 0 || i % 5 == 0) sum += i;
		}
		return sum;
	}
	public static void main([] args) {
		.out.println(getSum(1000));
	}
}"
"import java.math.BigInteger;
public class SumDigits {
    public static int sumDigits(long num) {
	return sumDigits(num, 10);
    }
    public static int sumDigits(long num, int base) {
	 s = .toString(num, base);
	int result = 0;
	for (int i = 0; i < s.length(); i++)
	    result += .digit(s.charAt(i), base);
	return result;
    }
    public static int sumDigits( num) {
	return sumDigits(num, 10);
    }
    public static int sumDigits( num, int base) {
	 s = num.toString(base);
	int result = 0;
	for (int i = 0; i < s.length(); i++)
	    result += .digit(s.charAt(i), base);
	return result;
    }
 
    public static void main([] args) {
	.out.println(sumDigits(1));
	.out.println(sumDigits(12345));
	.out.println(sumDigits(123045));
	.out.println(sumDigits(0xfe, 16));
	.out.println(sumDigits(0xf0e, 16));
	.out.println(sumDigits(new (strv)));
    }
}"
"package org.rosettacode;
 
import java.util.ArrayList;
import java.util.List;
 
 
/** * This program applies the logic in the Sum and Product Puzzle for the value  * provided by systematically applying each requirement to all number pairs in  * range. Note that the requirements: (x, y different), (x < y), and  * (x, y > MIN_VALUE) are baked into the loops in run(), sumAddends(), and  * productFactors(), so do not need a separate test. Also note that to test a * solution to this logic puzzle, it is suggested to test the condition with * maxSum = 1685 to ensure that both the original solution (4, 13) and the * additional solution (4, 61), and only these solutions, are found. Note * also that at 1684 only the original solution should be found! */
public class SumAndProductPuzzle {
    private final long beginning;
    private final int maxSum;
    private static final int MIN_VALUE = 2;
    private List<int[]> firstConditionExcludes = new ArrayList<>();
    private List<int[]> secondConditionExcludes = new ArrayList<>();
 
    public static void main(... args){
 
        if (args.length == 0){
            new SumAndProductPuzzle(100).run();
            new SumAndProductPuzzle(1684).run();
            new SumAndProductPuzzle(1685).run();
        } else {
            for ( arg : args){
                try{
                    new SumAndProductPuzzle(.valueOf(arg)).run();
                } catch ( e){
                    .out.println(strv +
                            strv + arg + strv +
                            strv +
                            strv);
                }
            }
        }
    }
 
    public SumAndProductPuzzle(int maxSum){
        this.beginning = .currentTimeMillis();
        this.maxSum = maxSum;
        .out.println(strv + .valueOf(maxSum) + 
                strv + .valueOf(beginning) + strv);
    }
 
    public void run(){
        for (int x = MIN_VALUE; x < maxSum - MIN_VALUE; x++){
            for (int y = x + 1; y < maxSum - MIN_VALUE; y++){
 
                if (isSumNoGreaterThanMax(x,y) &&
                    isSKnowsPCannotKnow(x,y) &&
                    isPKnowsNow(x,y) &&
                    isSKnowsNow(x,y)
                    ){
                    .out.println(strv + .valueOf(x) + strv + .valueOf(y) + 
                            strv + .valueOf(.currentTimeMillis() - beginning) + strv);
                }
            }
        }
        .out.println(strv + .valueOf(maxSum) + 
                strv + .valueOf(.currentTimeMillis() - beginning) + strv);
    }
 
    public boolean isSumNoGreaterThanMax(int x, int y){
        return x + y <= maxSum;
    }
 
    public boolean isSKnowsPCannotKnow(int x, int y){
 
        if (firstConditionExcludes.contains(new int[] {x, y})){
            return false;
        }
 
        for (int[] addends : sumAddends(x, y)){
            if ( !(productFactors(addends[0], addends[1]).size() > 1) ) {
                firstConditionExcludes.add(new int[] {x, y});
                return false;
            }
        }
        return true;
    }
 
    public boolean isPKnowsNow(int x, int y){
 
        if (secondConditionExcludes.contains(new int[] {x, y})){
            return false;
        }
 
        int countSolutions = 0;
        for (int[] factors : productFactors(x, y)){
            if (isSKnowsPCannotKnow(factors[0], factors[1])){
                countSolutions++;
            }
        }
 
        if (countSolutions == 1){
            return true;
        } else {
            secondConditionExcludes.add(new int[] {x, y});
            return false;
        }
    }
 
    public boolean isSKnowsNow(int x, int y){
 
        int countSolutions = 0;
        for (int[] addends : sumAddends(x, y)){
            if (isPKnowsNow(addends[0], addends[1])){
                countSolutions++;
            }
        }
        return countSolutions == 1;
    }
 
    public List<int[]> sumAddends(int x, int y){
 
        List<int[]> list = new ArrayList<>();
        int sum = x + y;
 
        for (int addend = MIN_VALUE; addend < sum - addend; addend++){
            if (isSumNoGreaterThanMax(addend, sum - addend)){
                list.add(new int[]{addend, sum - addend});
            }
        }
        return list;
    }
 
    public List<int[]> productFactors(int x, int y){
 
        List<int[]> list = new ArrayList<>();
        int product = x * y;
 
        for (int factor = MIN_VALUE; factor < product / factor; factor++){
            if (product % factor == 0){
                if (isSumNoGreaterThanMax(factor, product / factor)){
                    list.add(new int[]{factor, product / factor});
                }
            }
        }
        return list;
    }
}"
"import java.util.function.IntSupplier;
import static java.util.stream.IntStream.generate;
 
public class SubtractiveGenerator implements IntSupplier {
    static final int MOD = 1_000_000_000;
    private int[] state = new int[55];
    private int si, sj;
 
    public SubtractiveGenerator(int p1) {
        subrandSeed(p1);
    }
 
    void subrandSeed(int p1) {
        int p2 = 1;
 
        state[0] = p1 % MOD;
        for (int i = 1, j = 21; i < 55; i++, j += 21) {
            if (j >= 55)
                j -= 55;
            state[j] = p2;
            if ((p2 = p1 - p2) < 0)
                p2 += MOD;
            p1 = state[j];
        }
 
        si = 0;
        sj = 24;
        for (int i = 0; i < 165; i++)
            getAsInt();
    }
 
    @Override
    public int getAsInt() {
        if (si == sj)
            subrandSeed(0);
 
        if (si-- == 0)
            si = 54;
        if (sj-- == 0)
            sj = 54;
 
        int x = state[si] - state[sj];
        if (x < 0)
            x += MOD;
 
        return state[si] = x;
    }
 
    public static void main([] args) {
        generate(new SubtractiveGenerator(292_929)).limit(10)
                .forEach(.out::println);
    }
}"
" 
 strOrig = 'brooms';
 str1 = strOrig.substring(1, strOrig.length());
system.debug(str1);
 str2 = strOrig.substring(0, strOrig.length()-1);
system.debug(str2);
 str3 = strOrig.substring(1, strOrig.length()-1);
system.debug(str3);
 


 strOrig = 'brooms';
 str1 = strOrig.replaceAll( '^.', '' );
system.debug(str1);
 str2 = strOrig.replaceAll( '.$', '' ) ;
system.debug(str2);
 str3 = strOrig.replaceAll( '^.|.$', '' );
system.debug(str3);
 public class RM_chars {
  public static void main( [] args ){
    .out.println( strv.substring( 1 ) );
    .out.println( strv.substring( 0, 4 ) );
    .out.println( strv.substring( 1, 5 ) );
      

      

 
    .out.println( strv.replaceAll( strv, strv ) );
    .out.println( strv.replaceAll( strv, strv ) );
    .out.println( strv.replaceAll( strv, strv ) );
      

  }
}"
"public class SubstitutionCipher {
 
    final static  key = ""]kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXsv*N""
            + ""[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,QcC1yxJ"";
 
    static  text = strv
            + strv
            + strv
            + strv
            + strv
            + strv
            + strv
            + strv;
 
    public static void main([] args) {
         enc = encode(text);
        .out.println(strv + enc);
        .out.println(""Decoded: "" + decode(enc));
    }
 
    static  encode( s) {
        StringBuilder sb = new StringBuilder(s.length());
 
        for (char c : s.toCharArray())
            sb.append(key.charAt((int) c - 32));
 
        return sb.toString();
    }
 
    static  decode( s) {
        StringBuilder sb = new StringBuilder(s.length());
 
        for (char c : s.toCharArray())
            sb.append((char) (key.indexOf((int) c) + 32));
 
        return sb.toString();
    }
}"
"import java.util.Scanner;
 
public class Subleq {
 
    public static void main([] args) {
        int[] mem = {15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0,
            -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0};
 
        Scanner input = new Scanner(.in);
        int instructionPointer = 0;
 
        do {
            int a = mem[instructionPointer];
            int b = mem[instructionPointer + 1];
 
            if (a == -1) {
                mem[b] = input.nextInt();
 
            } else if (b == -1) {
                .out.printf(strv, (char) mem[a]);
 
            } else {
 
                mem[b] -= mem[a];
                if (mem[b] < 1) {
                    instructionPointer = mem[instructionPointer + 2];
                    continue;
                }
            }
 
            instructionPointer += 3;
 
        } while (instructionPointer >= 0);
    }
}"
" x = strv;
.out.println(x.substring(n, n + m));
.out.println(x.substring(n));
.out.println(x.substring(0, x.length() - 1));
int index1 = x.indexOf('i');
.out.println(x.substring(index1, index1 + m));
int index2 = x.indexOf(strv);
.out.println(x.substring(index2, index2 + m));
//indexOf methods also have an optional strv argument which will
//make indexOf ignore characters before that index"
"public class Sudoku
{
    private int mBoard[][];
    private int mBoardSize;
    private int mBoxSize;
    private boolean mRowSubset[][];
    private boolean mColSubset[][];
    private boolean mBoxSubset[][];
 
    public Sudoku(int board[][]) {
        mBoard = board;
        mBoardSize = mBoard.length;
        mBoxSize = (int).sqrt(mBoardSize);
    }
 
    public void initSubsets() {
        mRowSubset = new boolean[mBoardSize][mBoardSize];
        mColSubset = new boolean[mBoardSize][mBoardSize];
        mBoxSubset = new boolean[mBoardSize][mBoardSize];
        for(int i = 0; i < mBoard.length; i++) {
            for(int j = 0; j < mBoard.length; j++) {
                int value = mBoard[i][j];
                if(value != 0) {
                    setSubsetValue(i, j, value, true);
                }
            }
        }
    }
 
    private void setSubsetValue(int i, int j, int value, boolean present) {
        mRowSubset[i][value - 1] = present;
        mColSubset[j][value - 1] = present;
        mBoxSubset[computeBoxNo(i, j)][value - 1] = present;
    }
 
    public boolean solve() {
        return solve(0, 0);
    }
 
    public boolean solve(int i, int j) {
        if(i == mBoardSize) {
            i = 0;
            if(++j == mBoardSize) {
                return true;
            }
        }
        if(mBoard[i][j] != 0) {
            return solve(i + 1, j);
        }
        for(int value = 1; value <= mBoardSize; value++) {
            if(isValid(i, j, value)) {
                mBoard[i][j] = value;
                setSubsetValue(i, j, value, true);
                if(solve(i + 1, j)) {
                    return true;
                }
                setSubsetValue(i, j, value, false);
            }
        }
 
        mBoard[i][j] = 0;
        return false;
    }
 
    private boolean isValid(int i, int j, int val) {
        val--;
        boolean isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val];
        return !isPresent;
    }
 
    private int computeBoxNo(int i, int j) {
        int boxRow = i / mBoxSize;
        int boxCol = j / mBoxSize;
        return boxRow * mBoxSize + boxCol;
    }
 
    public void print() {
        for(int i = 0; i < mBoardSize; i++) {
            if(i % mBoxSize == 0) {
                .out.println(strv);
            }
            for(int j = 0; j < mBoardSize; j++) {
                if(j % mBoxSize == 0) {
                    .out.print(strv);
                }
                .out.print(mBoard[i][j] != 0 ? (() (.valueOf(mBoard[i][j]))) : strv);
                .out.print(' ');
            }
 
            .out.println(strv);
        }
 
        .out.println(strv);
    }
}"
" 
public class Trims{
   public static  ltrim( s){
      int i = 0;
      while (i < s.length() && .isWhitespace(s.charAt(i))){
         i++;
      }
      return s.substring(i);
   }
 
   public static  rtrim( s){
      int i = s.length() - 1;
      while (i > 0 && .isWhitespace(s.charAt(i))){
         i--;
      }
      return s.substring(0, i + 1);
   }
 
   public static void main([] args){
       s = ""    String with spaces        "";
      .out.println(ltrim(s));
      .out.println(rtrim(s));
      .out.println(s.trim()); //trims both ends
   }
}"
"import java.util.function.IntPredicate;
 
public class StripControlCodes {
 
    public static void main([] args) {
         s = ""0000 abc00E9def007F"";
        .out.println(stripChars(s, c -> c > '001F' && c != '007F'));
        .out.println(stripChars(s, c -> c > '001F' && c < '007F'));
    }
 
    static  stripChars( s, IntPredicate include) {
        return s.codePoints().filter(include::test).collect(StringBuilder::new,
                StringBuilder::appendCodePoint, StringBuilder::append).toString();
    }
}"
"import java.io.*;
 
public class StripLineComments{
    public static void main( [] args ){
	if( args.length < 1 ){
	    .out.println(strv);
	}
	else{
	     inputFile = args[0];
	     input = strv;
	    try{
		 reader = new ( new ( inputFile ) );
		 line = strv;
		while((line = reader.readLine()) != null){
		    .out.println( line.split(strv)[0] );
		}
	    }
	    catch(  e ){
		e.printStackTrace();
	    }
	}
    }
}"
"import java.io.*;
 
public class StripBlockComments{
    public static  readFile( filename) {
	 reader = new (new (filename));
	try {
	    StringBuilder fileContents = new StringBuilder();
	    char[] buffer = new char[4096];
	    while (reader.read(buffer, 0, 4096) > 0) {
		fileContents.append(buffer);
	    }
	    return fileContents.toString();
	} finally {
	    reader.close();
	}
    }
 
    public static  stripComments( beginToken,  endToken,
				        input) {
	StringBuilder output = new StringBuilder();
	while (true) {
	    int begin = input.indexOf(beginToken);
	    int end = input.indexOf(endToken, begin+beginToken.length());
	    if (begin == -1 || end == -1) {
		output.append(input);
		return output.toString();
	    }
	    output.append(input.substring(0, begin));
	    input = input.substring(end + endToken.length());
	}
    }
 
    public static void main([] args) {
	if (args.length < 3) {
	    .out.println(strv);
	    .exit(1);
	}
 
	 begin = args[0];
	 end = args[1];
	 input = args[2];
 
	try {
	    .out.println(stripComments(begin, end, readFile(input)));
	} catch ( e) {
	    e.printStackTrace();
	    .exit(1);
	}
    }
}"
"class StripChars {
    public static  stripChars( inString,  toStrip) {
        return inString.replaceAll(strv + toStrip + strv, strv);
    }
 
    public static void main([] args) {
         sentence = strv;
         chars = strv;
        .out.println(strv + sentence);
        .out.println(strv + chars);
        .out.println(strv + stripChars(sentence, chars));
    }
}"
"public class Prepend {
 
    public static void main([] args) {
         s = strv;
        .out.println(strv + s);
    }
}"
"strv.startsWith(strv) //returns true
strv.endsWith(strv) //returns false
strv.contains(strv) //returns false
strv.contains(strv) //returns true
int loc = strv.indexOf(strv) //returns -1
loc = strv.indexOf(strv) //returns 0
loc = strv.indexOf(strv,loc+1) //returns 2"
"import java.text.BreakIterator;
 
public class Grapheme {
  public static void main([] args) {
    printLength(strv);
    printLength(strv);
    printLength(strv);
  }
 
  public static void printLength( s) {
     it = .getCharacterInstance();
    it.setText(s);
    int count = 0;
    while (it.next() != .DONE) {
      count++;
    }
    .out.println(strv + count+ strv + s);
  }
}"
" original = strv;
 little = strv;
 replaced = original.replace(strv, little); //does not change the original String
.out.println(replaced);
//Alternative:
.out.printf(strv, little);
//Alternative:
 formatted = .format(strv, little);
.out.println(formatted);"
"public class Compare
{
	/**	 * Test in the developer console:	 * Compare.compare('Hello', 'Hello');	 * Compare.compare('5', '5.0');	 * Compare.compare('java', 'Java');	 * Compare.compare('ĴÃVÁ', 'ĴÃVÁ');	*/
 
    public static void compare ( A,  B)
    {
        if (A.equals(B))
            .debug(A + ' and  ' + B + ' are lexically equal.');
        else
            .debug(A + ' and  ' + B + ' are not lexically equal.');
 
        if (A.equalsIgnoreCase(B))
            .debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');
        else
            .debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');
 
        if (A.compareTo(B) < 0)
            .debug(A + ' is lexically before ' + B);
        else if (A.compareTo(B) > 0)
            .debug(A + ' is lexically after ' + B);
 
        if (A.compareTo(B) >= 0)
            .debug(A + ' is not lexically before ' + B);
        if (A.compareTo(B) <= 0)
            .debug(A + ' is not lexically after ' + B);
 
        .debug('The lexical relationship is: ' + A.compareTo(B));
    }
}public class Compare
{
    public static void main ([] args)
    {
        compare(strv, strv);
        compare(strv, strv);
        compare(strv, strv);
        compare(strv, strv);
        compare(strv, strv);
    }
    public static void compare ( A,  B)
    {
        if (A.equals(B))
            .out.printf(strv, A, B);
        else
            .out.printf(strv, A, B);
        .out.println();
 
        if (A.equalsIgnoreCase(B))
            .out.printf(strv, A, B);
        else
            .out.printf(strv, A, B);
        .out.println();
 
        if (A.compareTo(B) < 0)
            .out.printf(""'%s' is lexically before '%s'."", A, B);
        else if (A.compareTo(B) > 0)
            .out.printf(""'%s' is lexically after '%s'."", A, B);
 
        if (A.compareTo(B) >= 0)
            .out.printf(""'%s' is not lexically before '%s'."", A, B);
        if (A.compareTo(B) <= 0)
            .out.printf(""'%s' is not lexically after '%s'."", A, B);
 
        .out.printf(""The lexical relationship is: %d"", A.compareTo(B));
        .out.printf(""The case-insensitive lexical relationship is: %d"", A.compareToIgnoreCase(B));
    }
}"
" sa = strv;
sa += strv;
.out.println(sa);
 
StringBuilder ba = new StringBuilder();
ba.append(strv);
ba.append(strv);
.out.println(ba.toString());"
" str = strv;
.out.println(str.toUpperCase());
.out.println(str.toLowerCase());
//Also works with non-English characters with no modification
.out.println(strv.toUpperCase());
.out.println(strv.toLowerCase()); //does not transalate strv"
"import java.util.Map;
import java.util.regex.*;
 
public class StraddlingCheckerboard {
 
    final static [] keyvals = {strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv};
 
    final static Map<, String> val2key = new HashMap<>();
    final static Map<, String> key2val = new HashMap<>();
 
    public static void main([] args) {
        for ( keyval : keyvals) {
            [] kv = keyval.split(strv);
            val2key.put(kv[0], kv[1]);
            key2val.put(kv[1], kv[0]);
        }
         enc = encode(strv
                + strv);
        .out.println(enc);
        .out.println(decode(enc));
    }
 
    static  encode( s) {
        StringBuilder sb = new StringBuilder();
        for ( c : s.toUpperCase().split(strv)) {
            c = val2key.get(c);
            if (c != null)
                sb.append(c);
        }
        return sb.toString();
    }
 
    static  decode( s) {
        Matcher m = Pattern.compile(strv).matcher(s);
        StringBuilder sb = new StringBuilder();
        while (m.find()) {
             v = key2val.get(m.group(1));
            if (v != null)
                sb.append(v);
        }
        return sb.toString();
    }
}"
"import java.awt.*;
import javax.swing.*;
 
public class SternBrocot extends  {
 
    public SternBrocot() {
        setPreferredSize(new (800, 500));
        setFont(new (strv, .PLAIN, 18));
        setBackground(.white);
    }
 
    private void drawTree(int n1, int d1, int n2, int d2,
            int x, int y, int gap, int lvl,  g) {
 
        if (lvl == 0)
            return;
 
        

        int numer = n1 + n2;
        int denom = d1 + d2;
 
        if (lvl > 1) {
            g.drawLine(x + 5, y + 4, x - gap + 5, y + 124);
            g.drawLine(x + 5, y + 4, x + gap + 5, y + 124);
        }
 
        g.setColor(getBackground());
        g.fillRect(x - 10, y - 15, 35, 40);
 
        g.setColor(getForeground());
        g.drawString(.valueOf(numer), x, y);
        g.drawString(strv, x, y + 2);
        g.drawString(.valueOf(denom), x, y + 22);
 
        drawTree(n1, d1, numer, denom, x - gap, y + 120, gap / 2, lvl - 1, g);
        drawTree(numer, denom, n2, d2, x + gap, y + 120, gap / 2, lvl - 1, g);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        int w = getWidth();
 
        drawTree(0, 1, 1, 0, w / 2, 50, w / 4, 4, g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new SternBrocot(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import static java.lang..*;
import static java.util..stream;
import java.util.Locale;
import java.util.function.DoubleSupplier;
import static java.util.stream.Collectors.joining;
import java.util.stream.DoubleStream;
import static java.util.stream.IntStream.range;
 
public class Test implements DoubleSupplier {
 
    private double mu, sigma;
    private double[] state = new double[2];
    private int index = state.length;
 
    Test(double m, double s) {
        mu = m;
        sigma = s;
    }
 
    static double[] meanStdDev(double[] numbers) {
        if (numbers.length == 0)
            return new double[]{0.0, 0.0};
 
        double sx = 0.0, sxx = 0.0;
        long n = 0;
        for (double x : numbers) {
            sx += x;
            sxx += pow(x, 2);
            n++;
        }
 
        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};
    }
 
    static  replicate(int n,  s) {
        return range(0, n + 1).mapToObj(i -> s).collect(joining());
    }
 
    static void showHistogram01(double[] numbers) {
        final int maxWidth = 50;
        long[] bins = new long[10];
 
        for (double x : numbers)
            bins[(int) (x * bins.length)]++;
 
        double maxFreq = stream(bins).max().getAsLong();
 
        for (int i = 0; i < bins.length; i++)
            .out.printf(strv, i / (double) bins.length,
                    replicate((int) (bins[i] / maxFreq * maxWidth), strv));
        .out.println();
    }
 
    @Override
    public double getAsDouble() {
        index++;
        if (index >= state.length) {
            double r = sqrt(-2 * log(random())) * sigma;
            double x = 2 * PI * random();
            state = new double[]{mu + r * sin(x), mu + r * cos(x)};
            index = 0;
        }
        return state[index];
 
    }
 
    public static void main([] args) {
        .setDefault(.US);
        double[] data = DoubleStream.generate(new Test(0.0, 0.5)).limit(100_000)
                .toArray();
 
        double[] res = meanStdDev(data);
        .out.printf(strv, res[0], res[1]);
 
        showHistogram01(stream(data).map(a -> max(0.0, min(0.9999, a / 3 + 0.5)))
                .toArray());
    }
}"
"import java.util.*;
import java.util.stream.*;
 
public class StateNamePuzzle {
 
    static [] states = {strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv,
        strv, strv, strv, strv, strv,};
 
    public static void main([] args) {
        solve(.asList(states));
    }
 
    static void solve(List<String> input) {
        Map<, String> orig = input.stream().collect(Collectors.toMap(
                s -> s.replaceAll(""s"", strv).toLowerCase(), s -> s, (s, a) -> s));
 
        input = new ArrayList<>(orig.keySet());
 
        Map<, List<[]>> map = new HashMap<>();
        for (int i = 0; i < input.size() - 1; i++) {
             pair0 = input.get(i);
            for (int j = i + 1; j < input.size(); j++) {
 
                [] pair = {pair0, input.get(j)};
                 s = pair0 + pair[1];
                 key = .toString(s.chars().sorted().toArray());
 
                List<[]> val = map.getOrDefault(key, new ArrayList<>());
                val.add(pair);
                map.put(key, val);
            }
        }
 
        map.forEach((key, list) -> {
            for (int i = 0; i < list.size() - 1; i++) {
                [] a = list.get(i);
                for (int j = i + 1; j < list.size(); j++) {
                    [] b = list.get(j);
 
                    if (Stream.of(a[0], a[1], b[0], b[1]).distinct().count() < 4)
                        continue;
 
                    .out.printf(strv, orig.get(a[0]),
                            orig.get(a[1]), orig.get(b[0]), orig.get(b[1]));
                }
            }
        });
    }
}"
"import static java.lang..pow;
import static java.util..stream;
import static java.util.stream.Collectors.joining;
import static java.util.stream.IntStream.range;
 
public class Test {
    static double[] meanStdDev(double[] numbers) {
        if (numbers.length == 0)
            return new double[]{0.0, 0.0};
 
        double sx = 0.0, sxx = 0.0;
        long n = 0;
        for (double x : numbers) {
            sx += x;
            sxx += pow(x, 2);
            n++;
        }
        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};
    }
 
    static  replicate(int n,  s) {
        return range(0, n + 1).mapToObj(i -> s).collect(joining());
    }
 
    static void showHistogram01(double[] numbers) {
        final int maxWidth = 50;
        long[] bins = new long[10];
 
        for (double x : numbers)
            bins[(int) (x * bins.length)]++;
 
        double maxFreq = stream(bins).max().getAsLong();
 
        for (int i = 0; i < bins.length; i++)
            .out.printf(strv, i / (double) bins.length,
                    replicate((int) (bins[i] / maxFreq * maxWidth), strv));
        .out.println();
    }
 
    public static void main([] a) {
        .setDefault(.US);
        for (int p = 1; p < 7; p++) {
            double[] n = range(0, (int) pow(10, p))
                    .mapToDouble(i -> .random()).toArray();
 
            .out.println((int)pow(10, p) + strv);
            double[] res = meanStdDev(n);
            .out.printf(strv, res[0], res[1]);
            showHistogram01(n);
        }
    }
}"
"public void stepUp() {
  while (!step()) stepUp();
}public void stepUp(){
  for (int i = 0; i < 1; step() ? ++i : --i);
}"
"import java.util.Stack;
 
public class StackTest {
    public static void main( final [] args ) {
        final Stack<String> stack = new Stack<String>();
 
        .out.println( strv + stack.empty() );
 
        stack.push( strv );
        .out.println( strv + stack.empty() );
        .out.println( strv + stack.pop() );
 
        stack.push( strv );
        stack.push( strv );
        .out.println( strv + stack.pop() );
 
        

        stack.pop();
        stack.pop();
    }
}public class {
    private Node first = null;
    public boolean isEmpty(){
        return first == null;
    }
    public  Pop(){
        if(isEmpty()) 
            throw new (strv);
        else{
             temp = first.value;
            first = first.next;
            return temp;
        }
    }
    public void Push( o){
        first = new Node(o, first);
    }
    class Node{
        public Node next;
        public  value;
        public Node( value){
            this(value, null); 
        }
        public Node( value, Node next){
            this.next = next;
            this.value = value;
        }
    }
}"
"import java.io.UnsupportedEncodingException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.math.BigInteger;
 
 
class UserManager {
    private  dbConnection;
 
    public UserManager() {
    }
 
    private  md5( aString) throws ,  {
         md;
         hex;
         hexString;
        byte[] bytesOfMessage;
        byte[] theDigest;
 
        hexString = new ();
        bytesOfMessage = aString.getBytes(strv);
        md = .getInstance(strv);
        theDigest = md.digest(bytesOfMessage);
 
        for (int i = 0; i < theDigest.length; i++) {
            hex = .toHexString(0xff & theDigest[i]);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
 
        return hexString.toString();
    }
 
    public void connectDB( host, int port,  db,  user,  password)
      throws ,  {
 
        Class.forName(strv);
 
        this.dbConnection =  .getConnection(strv
                                + host
                                + strv
                                + port
                                + strv
                                + db, user, password);
    }
 
    public boolean createUser( user,  password) {
         random;
         insert;
         salt;
 
        random = new ();
        salt =  new (130, random).toString(16);
 
        insert = strv
            + strv
            + strv;
 
        try ( pstmt = this.dbConnection.prepareStatement(insert)) {
            pstmt.setString(1, user);
            pstmt.setString(2, salt);
            pstmt.setString(3, this.md5(salt + password));
            pstmt.executeUpdate();
 
            return true;
        } catch( |  |  ex) {
            return false;
        }
    }
 
    public boolean authenticateUser( user,  password) {
         pass_md5;
         pass_salt;
         select;
         res;
 
        select = strv;
        res = null;
 
        try( pstmt = this.dbConnection.prepareStatement(select)) {
            pstmt.setString(1, user);
            res = pstmt.executeQuery();
 
            res.next(); 

 
            pass_salt = res.getString(1);
            pass_md5 = res.getString(2);
 
            if (pass_md5.equals(this.md5(pass_salt + password))) {
                return true;
            } else {
                return false;
            }
 
        } catch( |  |  ex) {
            return false;
        } finally {
            try {
                if (res instanceof  && !res.isClosed()) {
                    res.close();
                }
            } catch( ex) {
            }
        }
    }
 
    public void closeConnection() {
        try {
            this.dbConnection.close();
        } catch( |  ex) {
        }
    }
 
    public static void main([] args) {
        UserManager um;
 
        um = new UserManager();
        try {
            um.connectDB(strv, 3306, strv, strv, strv);
 
            if (um.createUser(strv, strv)) {
                .out.println(strv);
            }
 
            if (um.authenticateUser(strv, strv)) {
                .out.println(strv);
            }
        } catch( |  ex) {
            ex.printStackTrace();
        } finally {
            um.closeConnection();
        }
    }
}"
"package org.rosettacode;
 
import java.util.ArrayList;
import java.util.List;
 
 
/** * This class provides a main method that will, for each arg provided, * transform a String into a list of sub-strings, where each contiguous * series of characters is made into a String, then the next, and so on, * and then it will output them all separated by a comma and a space. */
public class SplitStringByCharacterChange {
 
    public static void main(... args){
        for ( string : args){
 
            List<String> resultStrings = splitStringByCharacter(string);
             output = formatList(resultStrings);
            .out.println(output);
        }
    }
 
    /**     * @param string String - String to split     * @return List<\String> - substrings of contiguous characters     */
    public static List<String> splitStringByCharacter( string){
 
        List<String> resultStrings = new ArrayList<>();
        StringBuilder currentString = new StringBuilder();
 
        for (int pointer = 0; pointer < string.length(); pointer++){
 
            currentString.append(string.charAt(pointer));
 
            if (pointer == string.length() - 1 
                    || currentString.charAt(0) != string.charAt(pointer + 1)) {
                resultStrings.add(currentString.toString());
                currentString = new StringBuilder();
            }
        }
 
        return resultStrings;
    }
 
    /**     * @param list List<\String> - list of strings to format as a comma+space-delimited string     * @return String     */
    public static  formatList(List<String> list){
 
        StringBuilder output = new StringBuilder();
 
        for (int pointer = 0; pointer < list.size(); pointer++){
            output.append(list.get(pointer));
 
            if (pointer != list.size() - 1){
                output.append(strv);
            }
        }
 
        return output.toString();
    }
}"
" 
public class Sparkline 
{
	 bars=strv;
	public static void main([] args)
	{
		Sparkline now=new Sparkline();
		float[] arr={1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1};
		now.display1D(arr);
		.out.println(now.getSparkline(arr));
		float[] arr1={1.5f, 0.5f, 3.5f, 2.5f, 5.5f, 4.5f, 7.5f, 6.5f};
		now.display1D(arr1);
		.out.println(now.getSparkline(arr1));
	}
	public void display1D(float[] arr)
	{
		for(int i=0;i<arr.length;i++)
			.out.print(arr[i]+strv);
		.out.println();
	}
	public  getSparkline(float[] arr)
	{
		float min=.MAX_VALUE;
		float max=.MIN_VALUE;
		for(int i=0;i<arr.length;i++)
		{
			if(arr[i]<min)
				min=arr[i];
			if(arr[i]>max)
				max=arr[i];
		}
		float range=max-min;
		int num=bars.length()-1;
		 line=strv;
		for(int i=0;i<arr.length;i++)
		{
 
			line+=bars.charAt((int).ceil(((arr[i]-min)/range*num)));
		}
		return line;
	}
}
 "
"& | ^ ~ //bitwise AND, OR, XOR, and NOT
>> << //bitwise arithmetic shift
>>> //bitwise logical shift
+ - * / = % //+ can be used for String concatenation)x = x + 2 is the same as x += 2
++ -- //increment and decrement--before a variable for pre (++x), after for post(x++)
== < > != <= >= //comparison! //NOT
&& || //short-circuit AND, OR
^ & | //long-circuit XOR, AND, OR{ } //scope
( ) //for functions
; //statement terminator
[ ] //array index
"" //string literal' //character literal? : //ternary operator
 unicode escape sequence see below)/* */ //comment enclosures  (can be escaped by  unicode escape sequence see below)\b     //Backspace
\n     //Line Feed
\r     //Carriage Return
\f     //Form Feed
\t     //Tab
\0     //Null) Note. This is actually a OCTAL escape but handy nonetheless
\'     //Single Quote     //Double Quote     //BackslashDD   //Octal Escape Sequence, D is a number between 0 and 7; can only express characters from 0 to 255 (i.e.  to 77)\uHHHH //Unicode Escape Sequence, H is any hexadecimal digit between 0 and 9 and between A and F
""hello 0022 is this a string?""/* * c:\unix\home\ */"
"public static void main([] args){
    .out.println(soundex(strv));
    .out.println(soundex(strv));
    .out.println(soundex(strv));
    .out.println(soundex(strv));
  }
 
private static  getCode(char c){
  switch(c){
    case 'B': case 'F': case 'P': case 'V':
      return strv;
    case 'C': case 'G': case 'J': case 'K':
    case 'Q': case 'S': case 'X': case 'Z':
      return strv;
    case 'D': case 'T':
      return strv;
    case 'L':
      return strv;
    case 'M': case 'N':
      return strv;
    case 'R':
      return strv;
    default:
      return strv;
  }
}
 
public static  soundex( s){
   code, previous, soundex;
  code = s.toUpperCase().charAt(0) + strv;
  previous = strv;
  for(int i = 1;i < s.length();i++){
     current = getCode(s.toUpperCase().charAt(i));
    if(current.length() > 0 && !current.equals(previous)){
      code = code + current;
    }
    previous = current;
  }
  soundex = (code + strv).substring(0, 4);
  return soundex;
}"
"import java.util.Arrays;
 
public class Stooge {
    public static void main([] args) {
        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};
        stoogeSort(nums);
        .out.println(.toString(nums));
    }
 
    public static void stoogeSort(int[] L) {
        stoogeSort(L, 0, L.length - 1);
    }
 
    public static void stoogeSort(int[] L, int i, int j) {
        if (L[j] < L[i]) {
            int tmp = L[i];
            L[i] = L[j];
            L[j] = tmp;
        }
        if (j - i > 1) {
            int t = (j - i + 1) / 3;
            stoogeSort(L, i, j - t);
            stoogeSort(L, i + t, j);
            stoogeSort(L, i, j - t);
        }
    }
}"
"public static void sort(int[] nums){
	for(int currentPlace = 0;currentPlace<nums.length-1;currentPlace++){
		int smallest = .MAX_VALUE;
		int smallestAt = currentPlace+1;
		for(int check = currentPlace; check<nums.length;check++){
			if(nums[check]<smallest){
				smallestAt = check;
				smallest = nums[check];
			}
		}
		int temp = nums[currentPlace];
		nums[currentPlace] = nums[smallestAt];
		nums[smallestAt] = temp;
	}
}"
"public static int[] sort(int[] old) {
    

    for (int shift = .SIZE - 1; shift > -1; shift--) {
        

        int[] tmp = new int[old.length];
        

        int j = 0;
 
        

        for (int i = 0; i < old.length; i++) {
            

            boolean move = old[i] << shift >= 0;
 
            

            if (shift == 0 ? !move : move) {
                tmp[j] = old[i];
                j++;
            } else {
                

                old[i - j] = old[i];
            }
        }
 
        

        for (int i = j; i < tmp.length; i++) {
            tmp[i] = old[i - j];
        }
 
        

        old = tmp;
    }
 
    return old;
} 
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
 
public class RSortingRadixsort00 {
 
  public RSortingRadixsort00() {
 
    return;
  }
 
  public static int[] lsdRadixSort(int[] tlist) {
 
    List<Integer> intermediates;
    int[] limits = getLimits(tlist);
    tlist = rescale(tlist, limits[1]);
 
    for (int px = 1; px <= limits[2]; ++px) {
      @SuppressWarnings(strv)
      Queue<Integer> bukits[] = new Queue[10];
      for (int ix = 0; ix < tlist.length; ++ix) {
        int cval = tlist[ix];
        int digit = (int) (cval / .pow(10, px - 1) % 10);
        if (bukits[digit] == null) {
          bukits[digit] = new LinkedList<>();
        }
        bukits[digit].add(cval);
      }
 
      intermediates = new ArrayList<>();
      for (int bi = 0; bi < 10; ++bi) {
        if (bukits[bi] != null) {
          while (bukits[bi].size() > 0) {
            int nextd;
            nextd = bukits[bi].poll();
            intermediates.add(nextd);
          }
        }
      }
 
      for (int iw = 0; iw < intermediates.size(); ++iw) {
        tlist[iw] = intermediates.get(iw);
      }
    }
 
    tlist = rescale(tlist, -limits[1]);
 
    return tlist;
  }
 
  private static int[] rescale(int[] arry, int delta) {
 
    for (int ix = 0; ix < arry.length; ++ix) {
      arry[ix] -= delta;
    }
 
    return arry;
  }
 
  private static int[] getLimits(int[] tlist) {
 
    int[] lims = new int[3];
 
    for (int i_ = 0; i_ < tlist.length; ++i_) {
      lims[0] = .max(lims[0], tlist[i_]);
      lims[1] = .min(lims[1], tlist[i_]);
    }
    lims[2] = (int) .ceil(.log10(lims[0] - lims[1]));
 
    return lims;
  }
 
  private static void runSample([] args) {
 
    int[][] lists = {
      new int[] { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, },
      new int[] { -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, -0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, },
      new int[] { 2, 24, 45, 0, 66, 75, 170, -802, -90, 1066, 666, },
      new int[] { 170, 45, 75, 90, 2, 24, 802, 66, },
      new int[] { -170, -45, -75, -90, -2, -24, -802, -66, },
    };
 
    long etime;
    lsdRadixSort(.copyOf(lists[0], lists[0].length)); 

 
    for (int[] tlist : lists) {
      .out.println(array2list(tlist));
      etime = .nanoTime();
      tlist = lsdRadixSort(tlist);
      etime = .nanoTime() - etime;
      .out.println(array2list(tlist));
      .out.printf(strv, ((double) etime / 1_000_000_000.0));
      .out.println();
    }
 
    return;
  }
 
  private static List<Integer> array2list(int[] arry) {
 
    List<Integer> target = new ArrayList<>(arry.length);
 
    for ( iv : arry) {
      target.add(iv);
    }
 
    return target;
  }
 
  public static void main([] args) {
 
    runSample(args);
 
    return;
  }
}
 "
"public static void shell(int[] a) {
	int increment = a.length / 2;
	while (increment > 0) {
		for (int i = increment; i < a.length; i++) {
			int j = i;
			int temp = a[i];
			while (j >= increment && a[j - increment] > temp) {
				a[j] = a[j - increment];
				j = j - increment;
			}
			a[j] = temp;
		}
		if (increment == 2) {
			increment = 1;
		} else {
			increment *= (5.0 / 11);
		}
	}
}"
"import java.util.*;
 
public class PatienceSort {
    public static <E extends Comparable<? super E>> void sort (E[] n) {
        List<Pile<E>> piles = new ArrayList<Pile<E>>();
        

        for (E x : n) {
            Pile<E> newPile = new Pile<E>();
            newPile.push(x);
            int i = .binarySearch(piles, newPile);
            if (i < 0) i = ~i;
            if (i != piles.size())
                piles.get(i).push(x);
            else
                piles.add(newPile);
        }
 
        

        PriorityQueue<Pile<E>> heap = new PriorityQueue<Pile<E>>(piles);
        for (int c = 0; c < n.length; c++) {
            Pile<E> smallPile = heap.poll();
            n[c] = smallPile.pop();
            if (!smallPile.isEmpty())
                heap.offer(smallPile);
        }
        assert(heap.isEmpty());
    }
 
    private static class Pile<E extends Comparable<? super E>> extends Stack<E> implements Comparable<Pile<E>> {
        public int compareTo(Pile<E> y) { return peek().compareTo(y.peek()); }
    }
 
    public static void main([] args) {
	[] a = {4, 65, 2, -31, 0, 99, 83, 782, 1};
	sort(a);
	.out.println(.toString(a));
    }
}"
" 
public class PancakeSort
{
   int[] heap;
 
   public  toString() {
       info = strv;
      for (int x: heap)
         info += x + strv;
      return info;
   }
 
   public void flip(int n) {
      for (int i = 0; i < (n+1) / 2; ++i) {
         int tmp = heap[i];
         heap[i] = heap[n-i];
         heap[n-i] = tmp;
      }      
      .out.println(strv + n + strv + toString());
   }
 
   public int[] minmax(int n) {
      int xm, xM;
      xm = xM = heap[0];
      int posm = 0, posM = 0;
 
      for (int i = 1; i < n; ++i) {
         if (heap[i] < xm) {
            xm = heap[i];
            posm = i;
         }
         else if (heap[i] > xM) {
            xM = heap[i];
            posM = i;
         }
      }
      return new int[] {posm, posM};
   }
 
   public void sort(int n, int dir) {
      if (n == 0) return;
 
      int[] mM = minmax(n);
      int bestXPos = mM[dir];
      int altXPos = mM[1-dir];
      boolean flipped = false;
 
      if (bestXPos == n-1) {
         --n;
      }
      else if (bestXPos == 0) {
         flip(n-1);
         --n;
      }
      else if (altXPos == n-1) {
         dir = 1-dir;
         --n;
         flipped = true;
      }
      else {
         flip(bestXPos);
      }
      sort(n, dir);
 
      if (flipped) {
         flip(n);
      }
   }
 
   PancakeSort(int[] numbers) {
      heap = numbers;
      sort(numbers.length, 1);
   } 
 
   public static void main([] args) {
      int[] numbers = new int[args.length];
      for (int i = 0; i < args.length; ++i)
         numbers[i] = .valueOf(args[i]);
 
      PancakeSort pancakes = new PancakeSort(numbers);
      .out.println(pancakes);
   }
}"
"public static void heapSort(int[] a){
	int count = a.length;
 
	//first place a in max-heap order
	heapify(a, count);
 
	int end = count - 1;
	while(end > 0){
		//swap the root(maximum value) of the heap with the
		//last element of the heap
		int tmp = a[end];
		a[end] = a[0];
		a[0] = tmp;
		//put the heap back in max-heap order
		siftDown(a, 0, end - 1);
		//decrement the size of the heap so that the previous
		//max value will stay in its proper place
		end--;
	}
}
 
public static void heapify(int[] a, int count){
	//start is assigned the index in a of the last parent node
	int start = (count - 2) / 2; //binary heap
 
	while(start >= 0){
		//sift down the node at index start to the proper place
		//such that all nodes below the start index are in heap
		//order
		siftDown(a, start, count - 1);
		start--;
	}
	//after sifting down the root all nodes/elements are in heap order
}
 
public static void siftDown(int[] a, int start, int end){
	//end represents the limit of how far down the heap to sift
	int root = start;
 
	while((root * 2 + 1) <= end){      //While the root has at least one child
		int child = root * 2 + 1;           //root*2+1 points to the left child
		//if the child has a sibling and the child's value is less than its sibling's...
		if(child + 1 <= end && a[child] < a[child + 1])
			child = child + 1;           //... then point to the right child instead
		if(a[root] < a[child]){     //out of max-heap order
			int tmp = a[root];
			a[root] = a[child];
			a[child] = tmp;
			root = child;                //repeat to continue sifting down the child now
		}else
			return;
	}
}"
"import java.util.Arrays;
 
public class CycleSort {
 
    public static void main([] args) {
        int[] arr = {5, 0, 1, 2, 2, 3, 5, 1, 1, 0, 5, 6, 9, 8, 0, 1};
 
        .out.println(.toString(arr));
 
        int writes = cycleSort(arr);
        .out.println(.toString(arr));
        .out.println(strv + writes);
    }
 
    static int cycleSort(int[] a) {
        int writes = 0;
 
        for (int cycleStart = 0; cycleStart < a.length - 1; cycleStart++) {
            int val = a[cycleStart];
 
            

            

            int pos = cycleStart;
            for (int i = cycleStart + 1; i < a.length; i++)
                if (a[i] < val)
                    pos++;
 
            

            if (pos == cycleStart)
                continue;
 
            

            while (val == a[pos])
                pos++;
 
            

            int tmp = a[pos];
            a[pos] = val;
            val = tmp;
            writes++;
 
            

            

            while (pos != cycleStart) {
                pos = cycleStart;
                for (int i = cycleStart + 1; i < a.length; i++)
                    if (a[i] < val)
                        pos++;
 
                while (val == a[pos])
                    pos++;
 
                tmp = a[pos];
                a[pos] = val;
                val = tmp;
                writes++;
            }
        }
        return writes;
    }
}"
"public static void gnomeSort(int[] a)
{
  int i=1;
  int j=2;
 
  while(i < a.length) {
    if ( a[i-1] <= a[i] ) {
      i = j; j++;
    } else {
      int tmp = a[i-1];
      a[i-1] = a[i];
      a[i--] = tmp;
      i = (i==0) ? j++ : i;
    }
  }
}"
"public static void cocktailSort( int[] A ){
	boolean swapped;
	do {
		swapped = false;
		for (int i =0; i<=  A.length  - 2;i++) {
			if (A[ i ] > A[ i + 1 ]) {
				//test whether the two elements are in the wrong order
				int temp = A[i];
				A[i] = A[i+1];
				A[i+1]=temp;
				swapped = true;
			}
		}
		if (!swapped) {
			//we can exit the outer loop here if no swaps occurred.
			break;
		}
		swapped = false;
		for (int i= A.length - 2;i>=0;i--) {
			if (A[ i ] > A[ i + 1 ]) {
				int temp = A[i];
				A[i] = A[i+1];
				A[i+1]=temp;
				swapped = true;
			}
		}
		//if no elements have been swapped, then the list is sorted
	} while (swapped);
}"
"import java.util.Arrays;
 
public class CircleSort {
 
    public static void main([] args) {
        circleSort(new int[]{2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1});
    }
 
    public static void circleSort(int[] arr) {
        if (arr.length > 0)
            do {
                .out.println(.toString(arr));
            } while (circleSortR(arr, 0, arr.length - 1, 0) != 0);
    }
 
    private static int circleSortR(int[] arr, int lo, int hi, int numSwaps) {
        if (lo == hi)
            return numSwaps;
 
        int high = hi;
        int low = lo;
        int mid = (hi - lo) / 2;
 
        while (lo < hi) {
            if (arr[lo] > arr[hi]) {
                swap(arr, lo, hi);
                numSwaps++;
            }
            lo++;
            hi--;
        }
 
        if (lo == hi && arr[lo] > arr[hi + 1]) {
            swap(arr, lo, hi + 1);
            numSwaps++;
        }
 
        numSwaps = circleSortR(arr, low, low + mid, numSwaps);
        numSwaps = circleSortR(arr, low + mid + 1, high, numSwaps);
 
        return numSwaps;
    }
 
    private static void swap(int[] arr, int idx1, int idx2) {
        int tmp = arr[idx1];
        arr[idx1] = arr[idx2];
        arr[idx2] = tmp;
    }
}"
"public static <E extends Comparable<? super E>> void sort(E[] input) {
    int gap = input.length;
    boolean swapped = true;
    while (gap > 1 || swapped) {
        if (gap > 1) {
            gap = (int) (gap / 1.3);
        }
        swapped = false;
        for (int i = 0; i + gap < input.length; i++) {
            if (input[i].compareTo(input[i + gap]) > 0) {
                E t = input[i];
                input[i] = input[i + gap];
                input[i + gap] = t;
                swapped = true;
            }
        }
    }
}"
" 
 
public class BeadSort 
{
	public static void main([] args)
	{
		BeadSort now=new BeadSort();
		int[] arr=new int[(int)(.random()*11)+5];
		for(int i=0;i<arr.length;i++)
			arr[i]=(int)(.random()*10);
		.out.print(strv);
		now.display1D(arr);
 
		int[] sort=now.beadSort(arr);
		.out.print(strv);
		now.display1D(sort);
	}
	int[] beadSort(int[] arr)
	{
		int max=0;
		for(int i=0;i<arr.length;i++)
			if(arr[i]>max)
				max=arr[i];
 
		//Set up abacus
		char[][] grid=new char[arr.length][max];
		int[] levelcount=new int[max];
		for(int i=0;i<max;i++)
		{
			levelcount[i]=0;
			for(int j=0;j<arr.length;j++)
				grid[j][i]='_';
		}
		/*		display1D(arr);		display1D(levelcount);		display2D(grid);		*/
 
		//Drop the beads
		for(int i=0;i<arr.length;i++)
		{
			int num=arr[i];
			for(int j=0;num>0;j++)
			{
				grid[levelcount[j]++][j]='*';
				num--;
			}
		}
		.out.println();
		display2D(grid);
		//Count the beads
		int[] sorted=new int[arr.length];
		for(int i=0;i<arr.length;i++)
		{
			int putt=0;
			for(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)
				putt++;
			sorted[i]=putt;
		}
 
		return sorted;
	}
	void display1D(int[] arr)
	{
		for(int i=0;i<arr.length;i++)
			.out.print(arr[i]+strv);
		.out.println();
	}
	void display1D(char[] arr)
	{
		for(int i=0;i<arr.length;i++)
			.out.print(arr[i]+strv);
		.out.println();
	}
	void display2D(char[][] arr)
	{
		for(int i=0;i<arr.length;i++)
			display1D(arr[i]);
		.out.println();
	}
}
 "
" 
 
public class BogoSort 
{
	public static void main([] args)
	{
		//Enter array to be sorted here
		int[] arr={4,5,6,0,7,8,9,1,2,3};
 
		BogoSort now=new BogoSort();
		.out.print(strv);
		now.display1D(arr);
 
		now.bogo(arr);
 
		.out.print(strv);
		now.display1D(arr);
	}
	void bogo(int[] arr)
	{
		//Keep a track of the number of shuffles
		int shuffle=1;
		for(;!isSorted(arr);shuffle++)
			shuffle(arr);
		//Boast
		.out.println(strv+shuffle+strv);
	}
	void shuffle(int[] arr)
	{
		//Standard Fisher-Yates shuffle algorithm
		int i=arr.length-1;
		while(i>0)
			swap(arr,i--,(int)(.random()*i));
	}
	void swap(int[] arr,int i,int j)
	{
		int temp=arr[i];
		arr[i]=arr[j];
		arr[j]=temp;
	}
	boolean isSorted(int[] arr)
	{
 
		for(int i=1;i<arr.length;i++)
			if(arr[i]<arr[i-1])
				return false;
		return true;
	}
	void display1D(int[] arr)
	{
		for(int i=0;i<arr.length;i++)
			.out.print(arr[i]+strv);
		.out.println();
	}
 
}
 "
"public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {
    boolean changed = false;
    do {
        changed = false;
        for (int a = 0; a < comparable.length - 1; a++) {
            if (comparable[a].compareTo(comparable[a + 1]) > 0) {
                E tmp = comparable[a];
                comparable[a] = comparable[a + 1];
                comparable[a + 1] = tmp;
                changed = true;
            }
        }
    } while (changed);
}if (comparable[a].compareTo(comparable[b]) < 0){
   //same swap code as before
}"
"import java.util.Arrays;
import java.util.Comparator;
 
public class RJSortStability {
 
  public static void main([] args) {
    [] cityList = { strv, strv, strv, strv, };
 
    [] cn = cityList.clone();
    .out.println(""Before sort:"");
    for ( city : cn) {
      .out.println(city);
    }
 
    

    .sort(cn, new Comparator<String>() {
      public int compare( lft,  rgt) {
        return lft.substring(4).compareTo(rgt.substring(4));
      }
    });
 
    .out.println(""After sort on city:"");
    for ( city : cn) {
      .out.println(city);
    }
 
    cn = cityList.clone();
    .out.println(""Before sort:"");
    for ( city : cn) {
      .out.println(city);
    }
 
    

    .sort(cn, new Comparator<String>() {
      public int compare( lft,  rgt) {
        return lft.substring(0, 2).compareTo(rgt.substring(0, 2));
      }
    });
 
    .out.println(""After sort on country:"");
    for ( city : cn) {
      .out.println(city);
    }
 
    .out.println();
  }
}"
"import java.util.Arrays;
 
public class example {
    public static void main([] args)
    {
        int[] nums = {2,4,3,1,2};
        .sort(nums);
    }
}"
"import static java.lang..abs;
import java.util.*;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;
 
public class NoConnection {
 
    

    static int[][] links = {
        {2, 3, 4}, 

        {3, 4, 5}, 

        {2, 4},    

        {5},       

        {2, 3, 4}, 

        {3, 4, 5}, 

    };
 
    static int[] pegs = new int[8];
 
    public static void main([] args) {
 
        List<Integer> vals = range(1, 9).mapToObj(i -> i).collect(toList());
        do {
            .shuffle(vals);
            for (int i = 0; i < pegs.length; i++)
                pegs[i] = vals.get(i);
 
        } while (!solved());
 
        printResult();
    }
 
    static boolean solved() {
        for (int i = 0; i < links.length; i++)
            for (int peg : links[i])
                if (abs(pegs[i] - peg) == 1)
                    return false;
        return true;
    }
 
    static void printResult() {
        .out.printf(strv, pegs[0], pegs[1]);
        .out.printf(strv, pegs[2], pegs[3], pegs[4], pegs[5]);
        .out.printf(strv, pegs[6], pegs[7]);
    }
}"
"import java.util.*;
 
public class Numbrix {
 
    final static [] board = {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv};
 
    final static int[][] moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
 
    static int[][] grid;
    static int[] clues;
    static int totalToFill;
 
    public static void main([] args) {
        int nRows = board.length + 2;
        int nCols = board[0].split(strv).length + 2;
        int startRow = 0, startCol = 0;
 
        grid = new int[nRows][nCols];
        totalToFill = (nRows - 2) * (nCols - 2);
        List<Integer> lst = new ArrayList<>();
 
        for (int r = 0; r < nRows; r++) {
            .fill(grid[r], -1);
 
            if (r >= 1 && r < nRows - 1) {
 
                [] row = board[r - 1].split(strv);
 
                for (int c = 1; c < nCols - 1; c++) {
                    int val = .parseInt(row[c - 1]);
                    if (val > 0)
                        lst.add(val);
                    if (val == 1) {
                        startRow = r;
                        startCol = c;
                    }
                    grid[r][c] = val;
                }
            }
        }
 
        clues = lst.stream().sorted().mapToInt(i -> i).toArray();
 
        if (solve(startRow, startCol, 1, 0))
            printResult();
    }
 
    static boolean solve(int r, int c, int count, int nextClue) {
        if (count > totalToFill)
            return true;
 
        if (grid[r][c] != 0 && grid[r][c] != count)
            return false;
 
        if (grid[r][c] == 0 && nextClue < clues.length)
            if (clues[nextClue] == count)
                return false;
 
        int back = grid[r][c];
        if (back == count)
            nextClue++;
 
        grid[r][c] = count;
        for (int[] move : moves)
            if (solve(r + move[1], c + move[0], count + 1, nextClue))
                return true;
 
        grid[r][c] = back;
        return false;
    }
 
    static void printResult() {
        for (int[] row : grid) {
            for (int i : row) {
                if (i == -1)
                    continue;
                .out.printf(strv, i);
            }
            .out.println();
        }
    }
}"
"import java.util.Arrays;
import java.util.Comparator;
 
public class SortComp {
    public static class Pair {
        public  name;
        public  value;
        public Pair( n,  v) {
            name = n;
            value = v;
        }
    }
 
    public static void main([] args) {
        Pair[] pairs = {new Pair(strv, strv), new Pair(strv, strv),
            new Pair(strv, strv), new Pair(strv, strv),
            new Pair(strv, strv), new Pair(strv, strv),
            new Pair(strv, strv), new Pair(strv, strv),
            new Pair(strv, strv), new Pair(strv, strv)};
 
        sortByName(pairs);
        for (Pair p : pairs) {
            .out.println(p.name + strv + p.value);
        }
    }
 
    public static void sortByName(Pair[] pairs) {
        .sort(pairs, new Comparator<Pair>() {
            public int compare(Pair p1, Pair p2) {
                return p1.name.compareTo(p2.name);
            }
        });
    }
}    public static void sortByName(Pair[] pairs) {
        .sort(pairs, (p1, p2) -> p1.name.compareTo(p2.name));
    }    public static void sortByName(Pair[] pairs) {
        .sort(pairs, .comparing(p -> p.name));
    }"
"import java.util.*;
 
public class Hopido {
 
    final static [] board = {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv};
 
    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},
    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};
    static int[][] grid;
    static int totalToFill;
 
    public static void main([] args) {
        int nRows = board.length + 6;
        int nCols = board[0].length() + 6;
 
        grid = new int[nRows][nCols];
 
        for (int r = 0; r < nRows; r++) {
            .fill(grid[r], -1);
            for (int c = 3; c < nCols - 3; c++)
                if (r >= 3 && r < nRows - 3) {
                    if (board[r - 3].charAt(c - 3) == '0') {
                        grid[r][c] = 0;
                        totalToFill++;
                    }
                }
        }
 
        int pos = -1, r, c;
        do {
            do {
                pos++;
                r = pos / nCols;
                c = pos % nCols;
            } while (grid[r][c] == -1);
 
            grid[r][c] = 1;
            if (solve(r, c, 2))
                break;
            grid[r][c] = 0;
 
        } while (pos < nRows * nCols);
 
        printResult();
    }
 
    static boolean solve(int r, int c, int count) {
        if (count > totalToFill)
            return true;
 
        List<int[]> nbrs = neighbors(r, c);
 
        if (nbrs.isEmpty() && count != totalToFill)
            return false;
 
        .sort(nbrs, (a, b) -> a[2] - b[2]);
 
        for (int[] nb : nbrs) {
            r = nb[0];
            c = nb[1];
            grid[r][c] = count;
            if (solve(r, c, count + 1))
                return true;
            grid[r][c] = 0;
        }
 
        return false;
    }
 
    static List<int[]> neighbors(int r, int c) {
        List<int[]> nbrs = new ArrayList<>();
 
        for (int[] m : moves) {
            int x = m[0];
            int y = m[1];
            if (grid[r + y][c + x] == 0) {
                int num = countNeighbors(r + y, c + x) - 1;
                nbrs.add(new int[]{r + y, c + x, num});
            }
        }
        return nbrs;
    }
 
    static int countNeighbors(int r, int c) {
        int num = 0;
        for (int[] m : moves)
            if (grid[r + m[1]][c + m[0]] == 0)
                num++;
        return num;
    }
 
    static void printResult() {
        for (int[] row : grid) {
            for (int i : row) {
                if (i == -1)
                    .out.printf(strv, ' ');
                else
                    .out.printf(strv, i);
            }
            .out.println();
        }
    }
}"
"import java.util.*;
 
public class HolyKnightsTour {
 
    final static [] board = {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv};
 
    private final static int base = 12;
    private final static int[][] moves = {{1, -2}, {2, -1}, {2, 1}, {1, 2},
    {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};
    private static int[][] grid;
    private static int total = 2;
 
    public static void main([] args) {
        int row = 0, col = 0;
 
        grid = new int[base][base];
 
        for (int r = 0; r < base; r++) {
            .fill(grid[r], -1);
            for (int c = 2; c < base - 2; c++) {
                if (r >= 2 && r < base - 2) {
                    if (board[r - 2].charAt(c - 2) == 'x') {
                        grid[r][c] = 0;
                        total++;
                    }
                    if (board[r - 2].charAt(c - 2) == '1') {
                        row = r;
                        col = c;
                    }
                }
            }
        }
 
        grid[row][col] = 1;
 
        if (solve(row, col, 2))
            printResult();
    }
 
    private static boolean solve(int r, int c, int count) {
        if (count == total)
            return true;
 
        List<int[]> nbrs = neighbors(r, c);
 
        if (nbrs.isEmpty() && count != total)
            return false;
 
        .sort(nbrs, (a, b) -> a[2] - b[2]);
 
        for (int[] nb : nbrs) {
            r = nb[0];
            c = nb[1];
            grid[r][c] = count;
            if (solve(r, c, count + 1))
                return true;
            grid[r][c] = 0;
        }
 
        return false;
    }
 
    private static List<int[]> neighbors(int r, int c) {
        List<int[]> nbrs = new ArrayList<>();
 
        for (int[] m : moves) {
            int x = m[0];
            int y = m[1];
            if (grid[r + y][c + x] == 0) {
                int num = countNeighbors(r + y, c + x) - 1;
                nbrs.add(new int[]{r + y, c + x, num});
            }
        }
        return nbrs;
    }
 
    private static int countNeighbors(int r, int c) {
        int num = 0;
        for (int[] m : moves)
            if (grid[r + m[1]][c + m[0]] == 0)
                num++;
        return num;
    }
 
    private static void printResult() {
        for (int[] row : grid) {
            for (int i : row) {
                if (i == -1)
                    .out.printf(strv, ' ');
                else
                    .out.printf(strv, i);
            }
            .out.println();
        }
    }
}"
"import java.io.IOException;
import java.net.*;
public class SocketSend {
  public static void main( args[]) throws  {
    sendData(strv, strv);
  }
 
  public static void sendData( host,  msg) throws  {
     sock = new ( host, 256 );
    sock.getOutputStream().write(msg.getBytes());
    sock.getOutputStream().flush();
    sock.close();
  }
}"
"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
 
public class Hidato {
 
    private static int[][] board;
    private static int[] given, start;
 
    public static void main([] args) {
        [] input = {strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv};
 
        setup(input);
        printBoard();
        .out.println(""Found:"");
        solve(start[0], start[1], 1, 0);
        printBoard();
    }
 
    private static void setup([] input) {
        /* This task is not about input validation, so           we're going to trust the input to be valid */
 
        [][] puzzle = new [input.length][];
        for (int i = 0; i < input.length; i++)
            puzzle[i] = input[i].split(strv);
 
        int nCols = puzzle[0].length;
        int nRows = puzzle.length;
 
        List<Integer> list = new ArrayList<>(nRows * nCols);
 
        board = new int[nRows + 2][nCols + 2];
        for (int[] row : board)
            for (int c = 0; c < nCols + 2; c++)
                row[c] = -1;
 
        for (int r = 0; r < nRows; r++) {
            [] row = puzzle[r];
            for (int c = 0; c < nCols; c++) {
                 cell = row[c];
                switch (cell) {
                    case strv:
                        board[r + 1][c + 1] = 0;
                        break;
                    case strv:
                        break;
                    default:
                        int val = .parseInt(cell);
                        board[r + 1][c + 1] = val;
                        list.add(val);
                        if (val == 1)
                            start = new int[]{r + 1, c + 1};
                }
            }
        }
        .sort(list);
        given = new int[list.size()];
        for (int i = 0; i < given.length; i++)
            given[i] = list.get(i);
    }
 
    private static boolean solve(int r, int c, int n, int next) {
        if (n > given[given.length - 1])
            return true;
 
        if (board[r][c] != 0 && board[r][c] != n)
            return false;
 
        if (board[r][c] == 0 && given[next] == n)
            return false;
 
        int back = board[r][c];
        if (back == n)
            next++;
 
        board[r][c] = n;
        for (int i = -1; i < 2; i++)
            for (int j = -1; j < 2; j++)
                if (solve(r + i, c + j, n + 1, next))
                    return true;
 
        board[r][c] = back;
        return false;
    }
 
    private static void printBoard() {
        for (int[] row : board) {
            for (int c : row) {
                if (c == -1)
                    .out.print(strv);
                else
                    .out.printf(c > 0 ? strv : strv, c);
            }
            .out.println();
        }
    }
}"
"import java.util.*;
 
public class SmithNumbers {
 
    public static void main([] args) {
        for (int n = 1; n < 10_000; n++) {
            List<Integer> factors = primeFactors(n);
            if (factors.size() > 1) {
                int sum = sumDigits(n);
                for (int f : factors)
                    sum -= sumDigits(f);
                if (sum == 0)
                    .out.println(n);
            }
        }
    }
 
    static List<Integer> primeFactors(int n) {
        List<Integer> result = new ArrayList<>();
 
        for (int i = 2; n % i == 0; n /= i)
            result.add(i);
 
        for (int i = 3; i * i <= n; i += 2) {
            while (n % i == 0) {
                result.add(i);
                n /= i;
            }
        }
 
        if (n != 1)
            result.add(n);
 
        return result;
    }
 
    static int sumDigits(int n) {
        int sum = 0;
        while (n > 0) {
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
}"
"import java.util.*;
 
public class Sokoban {
     destBoard, currBoard;
    int playerX, playerY, nCols;
 
    Sokoban([] board) {
        nCols = board[0].length();
        StringBuilder destBuf = new StringBuilder();
        StringBuilder currBuf = new StringBuilder();
 
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < nCols; c++) {
 
                char ch = board[r].charAt(c);
 
                destBuf.append(ch != '$' && ch != '@' ? ch : ' ');
                currBuf.append(ch != '.' ? ch : ' ');
 
                if (ch == '@') {
                    this.playerX = c;
                    this.playerY = r;
                }
            }
        }
        destBoard = destBuf.toString();
        currBoard = currBuf.toString();
    }
 
     move(int x, int y, int dx, int dy,  trialBoard) {
 
        int newPlayerPos = (y + dy) * nCols + x + dx;
 
        if (trialBoard.charAt(newPlayerPos) != ' ')
            return null;
 
        char[] trial = trialBoard.toCharArray();
        trial[y * nCols + x] = ' ';
        trial[newPlayerPos] = '@';
 
        return new (trial);
    }
 
     push(int x, int y, int dx, int dy,  trialBoard) {
 
        int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;
 
        if (trialBoard.charAt(newBoxPos) != ' ')
            return null;
 
        char[] trial = trialBoard.toCharArray();
        trial[y * nCols + x] = ' ';
        trial[(y + dy) * nCols + x + dx] = '@';
        trial[newBoxPos] = '$';
 
        return new (trial);
    }
 
    boolean isSolved( trialBoard) {
        for (int i = 0; i < trialBoard.length(); i++)
            if ((destBoard.charAt(i) == '.')
                    != (trialBoard.charAt(i) == '$'))
                return false;
        return true;
    }
 
     solve() {
        class Board {
             cur, sol;
            int x, y;
 
            Board( s1,  s2, int px, int py) {
                cur = s1;
                sol = s2;
                x = px;
                y = py;
            }
        }
        char[][] dirLabels = {{'u', 'U'}, {'r', 'R'}, {'d', 'D'}, {'l', 'L'}};
        int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};
 
        Set<String> history = new HashSet<>();
        LinkedList<Board> open = new LinkedList<>();
 
        history.add(currBoard);
        open.add(new Board(currBoard, strv, playerX, playerY));
 
        while (!open.isEmpty()) {
            Board item = open.poll();
             cur = item.cur;
             sol = item.sol;
            int x = item.x;
            int y = item.y;
 
            for (int i = 0; i < dirs.length; i++) {
                 trial = cur;
                int dx = dirs[i][0];
                int dy = dirs[i][1];
 
                

                if (trial.charAt((y + dy) * nCols + x + dx) == '$') {
 
                    

                    if ((trial = push(x, y, dx, dy, trial)) != null) {
 
                        

                        if (!history.contains(trial)) {
 
                             newSol = sol + dirLabels[i][1];
 
                            if (isSolved(trial))
                                return newSol;
 
                            open.add(new Board(trial, newSol, x + dx, y + dy));
                            history.add(trial);
                        }
                    }
 
                

                } else if ((trial = move(x, y, dx, dy, trial)) != null) {
 
                    if (!history.contains(trial)) {
                         newSol = sol + dirLabels[i][0];
                        open.add(new Board(trial, newSol, x + dx, y + dy));
                        history.add(trial);
                    }
                }
            }
        }
        return strv;
    }
 
    public static void main([] a) {
         level = strv
                + strv;
        .out.println(new Sokoban(level.split(strv)).solve());
    }
}"
"LinkedList<Type> list = new LinkedList<Type>();
 
for(Type i: list){
  //each element will be in variable strv
  .out.println(i);
}"
"class Link
{
    Link next;
    int data;
}class Link
{
    Link next;
    int data;
    Link(int a_data, Link a_next) { next = a_next; data = a_data; }
} Link small_primes = new Link(2, new Link(3, new Link(5, new Link(7, null))));class Link<T>
{
  Link<T> next;
  T data;
  Link(T a_data, Link<T> a_next) { next = a_next; data = a_data; }
}"
"void insertNode(Node<T> anchor_node, Node<T> new_node)
{
    new_node.next = anchor_node.next;
    anchor_node.next = new_node;
}"
" p = component.getLocation();
 robot = new ();
robot.mouseMove(p.getX(), p.getY()); //you may want to move a few pixels closer to the center by adding to these values
robot.mousePress(.BUTTON1_MASK); //BUTTON1_MASK is the left button,
                                       //BUTTON2_MASK is the middle button, BUTTON3_MASK is the right button
robot.mouseRelease(.BUTTON1_MASK);button.doClick(); //optionally, give an integer argument for the number of milliseconds to hold the button down"
"class Singleton
{
    private static Singleton myInstance;
    public static Singleton getInstance()
    {
        if (myInstance == null)
        {
            synchronized(Singleton.class)
            {
                if (myInstance == null)
                {
                    myInstance = new Singleton();
                }
            }
        }
 
        return myInstance;
    }
 
    protected Singleton()
    {
        

    }
 
    

}public class Singleton {
    private Singleton() {
        

    }
 
    private static class LazyHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
 
    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}class Singleton
{
    private static Singleton myInstance;
    public static Singleton getInstance()
    {
        if (myInstance == null)
        {
            myInstance = new Singleton();
        }
 
        return myInstance;
    }
 
    protected Singleton()
    {
        

    }
 
    

}"
"import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
public class Clicks extends  implements {
	private long clicks = 0;
	private  label;
	private  clicker;
	private  text;
 
	public Clicks(){
		text = strv;
		label = new (text);
		clicker = new (strv);
		clicker.addActionListener(this);//listen to the button
		setLayout(new ());//handles placement of components
		add(label,.CENTER);//add the label to the biggest section
		add(clicker,.SOUTH);//put the button underneath it
		setSize(300,200);//stretch out the window
		setDefaultCloseOperation(.EXIT_ON_CLOSE);//stop the program on strv
		setVisible(true);//show it
	}
	public static void main([] args){
		new Clicks();//call the constructor where all the magic happens
	}
	public void actionPerformed( arg0) {
		if(arg0.getSource() == clicker){//if they clicked the button
			text = strv + (++clicks) + strv;
			label.setText(text);//change the text
		}
 
	}
}"
"import javax.swing.*;
import java.awt.*;
 
/*** SierpinskyTriangle.java* Draws a SierpinskyTriangle in a JFrame* The order of complexity is given from command line, but* defaults to 3** @author Istarnion*/ 
 
class SierpinskyTriangle {
 
	public static void main([] args) {
		int i = 3;		

		if(args.length >= 1) {
			try {
				i = .parseInt(args[0]);
			}
			catch( e) {
				.out.println(""Usage: 'java SierpinskyTriangle [level]'Now setting level to ""+i);
			}
		}
		final int level = i;
 
		 frame = new (strv);
		frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
 
		 panel = new () {
			@Override
			public void paintComponent( g) {
				g.setColor(.BLACK);
				drawSierpinskyTriangle(level, 20, 20, 360, ()g);
			}
		};
 
		panel.setPreferredSize(new (400, 400));
 
		frame.add(panel);
		frame.pack();
		frame.setResizable(false);
		frame.setLocationRelativeTo(null);
		frame.setVisible(true);
	}
 
	private static void drawSierpinskyTriangle(int level, int x, int y, int size,  g) {
		if(level <= 0) return;
 
		g.drawLine(x, y, x+size, y);
		g.drawLine(x, y, x, y+size);
		g.drawLine(x+size, y, x, y+size);
 
		drawSierpinskyTriangle(level-1, x, y, size/2, g);
		drawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);
		drawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);
	}
}import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.geom.Path2D;
import javax.swing.*;
 
public class SierpinskiTriangle extends  {
    private final int dim = 512;
    private final int margin = 20;
 
    private int limit = dim;
 
    public SierpinskiTriangle() {
        setPreferredSize(new (dim + 2 * margin, dim + 2 * margin));
        setBackground(.white);
        setForeground(.green.darker());
 
        new (2000, ( e) -> {
            limit /= 2;
            if (limit <= 2)
                limit = dim;
            repaint();
        }).start();
    }
 
    void drawTriangle( g, int x, int y, int size) {
        if (size <= limit) {
            Path2D p = new Path2D.();
            p.moveTo(x, y);
            p.lineTo(x + size / 2, y + size);
            p.lineTo(x - size / 2, y + size);
            g.fill(p);
        } else {
            size /= 2;
            drawTriangle(g, x, y, size);
            drawTriangle(g, x + size / 2, y + size, size);
            drawTriangle(g, x - size / 2, y + size, size);
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
        g.translate(margin, margin);
        drawTriangle(g, dim / 2, 0, dim);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new SierpinskiTriangle(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.io.*;
import java.text.*;
import java.util.*;
 
public class SimpleDatabase {
 
    final static  filename = strv;
 
    public static void main([] args) {
        if (args.length < 1 || args.length > 3) {
            printUsage();
            return;
        }
 
        switch (args[0].toLowerCase()) {
            case strv:
                addItem(args);
                break;
            case strv:
                printLatest(args);
                break;
            case strv:
                printAll();
                break;
            default:
                printUsage();
                break;
        }
    }
 
    private static class Item implements Comparable<Item>{
        final  name;
        final  date;
        final  category;
 
        Item( n,  d,  c) {
            name = n;
            date = d;
            category = c;
        }
 
        @Override
        public int compareTo(Item item){
            return date.compareTo(item.date);
        }
 
        @Override
        public  toString() {
            return .format(strv, name, date, category);
        }
    }
 
    private static void addItem([] input) {
        if (input.length < 2) {
            printUsage();
            return;
        }
        List<Item> db = load();
         sdf = new (strv);
         date = sdf.format(new ());
         cat = (input.length == 3) ? input[2] : strv;
        db.add(new Item(input[1], date, cat));
        store(db);
    }
 
    private static void printLatest([] a) {
        List<Item> db = load();
        if (db.isEmpty()) {
            .out.println(strv);
            return;
        }
        .sort(db);
        if (a.length == 2) {
            for (Item item : db)
                if (item.category.equals(a[1]))
                    .out.println(item);
        } else {
            .out.println(db.get(0));
        }
    }
 
    private static void printAll() {
        List<Item> db = load();
        if (db.isEmpty()) {
            .out.println(strv);
            return;
        }
        .sort(db);
        for (Item item : db)
            .out.println(item);
    }
 
    private static List<Item> load() {
        List<Item> db = new ArrayList<>();
        try (Scanner sc = new Scanner(new (filename))) {
            while (sc.hasNext()) {
                [] item = sc.nextLine().split(strv);
                db.add(new Item(item[0], item[1], item[2]));
            }
        } catch ( e) {
            .out.println(e);
        }
        return db;
    }
 
    private static void store(List<Item> db) {
        try ( fw = new (filename)) {
            for (Item item : db)
                fw.write(item.toString());
        } catch ( e) {
            .out.println(e);
        }
    }
 
    private static void printUsage() {
         .out.println(strv);
         .out.println(strv);
         .out.println(strv);
         .out.println(strv
                 + strv);
         .out.println(strv);
         .out.println(""  For instance: add some item name ""
                 + ""some category name"");
    }
}"
"public static void triangle(int n){
        n= 1 << n;
        StringBuilder line= new StringBuilder(); //use a strv
        char t= 0;
        char u= 0; 

        for(int i= 0;i <= 2 * n;++i)
                line.append(strv); //start empty
        line.setCharAt(n, '*'); //with the top point of the triangle
        for(int i= 0;i < n;++i){
                .out.println(line);
                u= '*';
                for(int j= n - i;j < n + i + 1;++j){
                        t= (line.charAt(j - 1) == line.charAt(j + 1) ? ' ' : '*');
                        line.setCharAt(j - 1, u);
                        u= t;
                }
                line.setCharAt(n + i, t);
                line.setCharAt(n + i + 1, '*');
        }
}import java.util.*;
 
public class Sierpinski
{
    public static List<String> sierpinski(int n)
    {
        List<String> down = .asList(strv);
         space = strv;
        for (int i = 0; i < n; i++) {
            List<String> newDown = new ArrayList<String>();
            for ( x : down)
                newDown.add(space + x + space);
            for ( x : down)
                newDown.add(x + strv + x);
 
            down = newDown;
            space += space;
        }
        return down;
    }
 
    public static void main([] args)
    {
        for ( x : sierpinski(4))
            .out.println(x);
    }
}"
"import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.geom.Path2D;
import static java.lang..*;
import java.util.Random;
import javax.swing.*;
 
public class SierpinskiPentagon extends  {
    

    final double degrees072 = toRadians(72);
 
    /* After scaling we'll have 2 sides plus a gap occupying the length       of a side before scaling. The gap is the base of an isosceles triangle       with a base angle of 72 degrees. */
    final double scaleFactor = 1 / (2 + cos(degrees072) * 2);
 
    final int margin = 20;
    int limit = 0;
     r = new ();
 
    public SierpinskiPentagon() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
 
        new (3000, ( e) -> {
            limit++;
            if (limit >= 5)
                limit = 0;
            repaint();
        }).start();
    }
 
    void drawPentagon( g, double x, double y, double side, int depth) {
        double angle = 3 * degrees072; 

 
        if (depth == 0) {
 
            Path2D p = new Path2D.();
            p.moveTo(x, y);
 
            

            for (int i = 0; i < 5; i++) {
                x = x + cos(angle) * side;
                y = y - sin(angle) * side;
                p.lineTo(x, y);
                angle += degrees072;
            }
 
            g.setColor(RandomHue.next());
            g.fill(p);
 
        } else {
 
            side *= scaleFactor;
 
            /* Starting at the top of the highest pentagon, calculate               the top vertices of the other pentagons by taking the               length of the scaled side plus the length of the gap. */
            double distance = side + side * cos(degrees072) * 2;
 
            /* The top positions form a virtual pentagon of their own,               so simply move from one to the other by changing direction. */
            for (int i = 0; i < 5; i++) {
                x = x + cos(angle) * distance;
                y = y - sin(angle) * distance;
                drawPentagon(g, x, y, side, depth - 1);
                angle += degrees072;
            }
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        int w = getWidth();
        double radius = w / 2 - 2 * margin;
        double side = radius * sin(PI / 5) * 2;
 
        drawPentagon(g, w / 2, 3 * margin, side, limit);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(true);
            f.add(new SierpinskiPentagon(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}
 
class RandomHue {
    /* Try to avoid random color values clumping together */
    final static double goldenRatioConjugate = (sqrt(5) - 1) / 2;
    private static double hue = .random();
 
    static  next() {
        hue = (hue + goldenRatioConjugate) % 1;
        return .getHSBColor((float) hue, 1, 1);
    }
}"
"import java.text.DateFormat;
import java.util.Date;
import java.util.TimeZone;
 
public class DateTest{
    public static void main([] args) {
         date = new (0);
         format = .getDateTimeInstance();
        format.setTimeZone(.getTimeZone(strv));
        .out.println(format.format(date));
    }
}"
"public static boolean inCarpet(long x, long y) {
    while (x!=0 && y!=0) {
        if (x % 3 == 1 && y % 3 == 1)
            return false;
        x /= 3;
        y /= 3;
    }
    return true;
}
 
public static void carpet(final int n) {
    final double power = .pow(3,n);
    for(long i = 0; i < power; i++) {
        for(long j = 0; j < power; j++) {
            .out.print(inCarpet(i, j) ? strv : strv);
        }
        .out.println();
    }
}import java.awt.*;
import java.awt.event.ActionEvent;
import javax.swing.*;
 
public class SierpinskiCarpet extends  {
    private final int dim = 513;
    private final int margin = 20;
 
    private int limit = dim;
 
    public SierpinskiCarpet() {
        setPreferredSize(new (dim + 2 * margin, dim + 2 * margin));
        setBackground(.white);
        setForeground(.orange);
 
        new (2000, ( e) -> {
            limit /= 3;
            if (limit <= 3)
                limit = dim;
            repaint();
        }).start();
    }
 
    void drawCarpet( g, int x, int y, int size) {
        if (size < limit)
            return;
        size /= 3;
        for (int i = 0; i < 9; i++) {
            if (i == 4) {
                g.fillRect(x + size, y + size, size, size);
            } else {
                drawCarpet(g, x + (i % 3) * size, y + (i / 3) * size, size);
            }
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
        g.translate(margin, margin);
        drawCarpet(g, 0, 0, dim);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new SierpinskiCarpet(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"int maxx,maxy;
int max;
boolean[] sieve;
 
void plot(int pos, boolean active) {
  set(pos%maxx,pos/maxx, active?#000000:#ffffff);
}
 
void setup() {
  size(1000, 1000, P2D);
  frameRate(2);
  maxx=width;
  maxy=height;
  max=width*height;
  sieve=new boolean[max+1];
 
  sieve[1]=false;
  plot(0,false);
  plot(1,false);
  for(int i=2;i<=max;i++) {
    sieve[i]=true;
    plot(i,true);
  }
}
 
int i=2;
 
void draw() {
  if(!sieve[i]) {
    while(i*i<max && !sieve[i]) {
      i++;
    }
  }
  if(sieve[i]) {
    print(i+strv);
    for(int j=i*i;j<=max;j+=i) {
      if(sieve[j]) {
        sieve[j]=false;
        plot(j,false);
      }
    }
  }
  if(i*i<max) {
    i++;
  } else {
    noLoop();
    println(strv);
  }
}"
"public class ShortCirc {
    public static void main([] args){
        .out.println(strv + (a(false) && b(false)) + """");
        .out.println(strv + (a(false) || b(false)) + """");
 
        .out.println(strv + (a(false) && b(true)) + """");
        .out.println(strv + (a(false) || b(true)) + """");
 
        .out.println(strv + (a(true) && b(false)) + """");
        .out.println(strv + (a(true) || b(false)) + """");
 
        .out.println(strv + (a(true) && b(true)) + """");
        .out.println(strv + (a(true) || b(true)) + """");
    }
 
    public static boolean a(boolean a){
        .out.println(strv);
        return a;
    }
 
    public static boolean b(boolean b){
        .out.println(strv);
        return b;
    }
}"
"import java.util.Random;
public class SevenSidedDice 
{
	private static final  rnd = new ();
	public static void main([] args)
	{
		SevenSidedDice now=new SevenSidedDice();
		.out.println(strv+now.seven());
	}
	int seven()
	{
		int v=21;
		while(v>20)
			v=five()+five()*5-6;
		return 1+v%7;
	}
	int five()
	{
		return 1+rnd.nextInt(5);
	}
}"
"import java.util.*;
 
public class SetPuzzle {
 
    enum  {
 
        GREEN(0), PURPLE(1), RED(2);
 
        private (int v) {
            val = v;
        }
        public final int val;
    }
 
    enum  {
 
        ONE(0), TWO(1), THREE(2);
 
        private (int v) {
            val = v;
        }
        public final int val;
    }
 
    enum Symbol {
 
        OVAL(0), DIAMOND(1), SQUIGGLE(2);
 
        private Symbol(int v) {
            val = v;
        }
        public final int val;
    }
 
    enum Fill {
 
        OPEN(0), STRIPED(1), SOLID(2);
 
        private Fill(int v) {
            val = v;
        }
        public final int val;
    }
 
    private static class Card implements Comparable<Card> {
 
         c;
         n;
        Symbol s;
        Fill f;
 
        @Override
        public  toString() {
            return .format(strv, c, n, s, f);
        }
 
        @Override
        public int compareTo(Card o) {
            return (c.val - o.c.val) * 10 + (n.val - o.n.val);
        }
    }
    private static Card[] deck;
 
    public static void main([] args) {
        deck = new Card[81];
        [] colors = .values();
        [] numbers = .values();
        Symbol[] symbols = Symbol.values();
        Fill[] fillmodes = Fill.values();
        for (int i = 0; i < deck.length; i++) {
            deck[i] = new Card();
            deck[i].c = colors[i / 27];
            deck[i].n = numbers[(i / 9) % 3];
            deck[i].s = symbols[(i / 3) % 3];
            deck[i].f = fillmodes[i % 3];
        }
        findSets(12);
    }
 
    private static void findSets(int numCards) {
        int target = numCards / 2;
        Card[] cards;
        Card[][] sets = new Card[target][3];
        int cnt;
        do {
            .shuffle(.asList(deck));
            cards = .copyOfRange(deck, 0, numCards);
            cnt = 0;
 
            outer:
            for (int i = 0; i < cards.length - 2; i++) {
                for (int j = i + 1; j < cards.length - 1; j++) {
                    for (int k = j + 1; k < cards.length; k++) {
                        if (validSet(cards[i], cards[j], cards[k])) {
                            if (cnt < target)
                                sets[cnt] = new Card[]{cards[i], cards[j], cards[k]};
                            if (++cnt > target) {
                                break outer;
                            }
                        }
                    }
                }
            }
        } while (cnt != target);
 
        .sort(cards);
 
        .out.printf(""GIVEN %d CARDS:"", numCards);
        for (Card c : cards) {
            .out.println(c);
        }
        .out.println();
 
        .out.println(strv + target + "" SETS:"");
        for (Card[] set : sets) {
            for (Card c : set) {
                .out.println(c);
            }
            .out.println();
        }
    }
 
    private static boolean validSet(Card c1, Card c2, Card c3) {
        int tot = 0;
        tot += (c1.c.val + c2.c.val + c3.c.val) % 3;
        tot += (c1.n.val + c2.n.val + c3.n.val) % 3;
        tot += (c1.s.val + c2.s.val + c3.s.val) % 3;
        tot += (c1.f.val + c2.f.val + c3.f.val) % 3;
        return tot == 0;
    }
}"
"import java.util.*;
 
public class SetConsolidation {
 
    public static void main([] args) {
        List<Set<Character>> h1 = hashSetList(strv, strv);
        .out.println(consolidate(h1));
 
        List<Set<Character>> h2 = hashSetList(strv, strv);
        .out.println(consolidateR(h2));
 
        List<Set<Character>> h3 = hashSetList(strv, strv, strv);
        .out.println(consolidate(h3));
 
        List<Set<Character>> h4 = hashSetList(strv, strv, strv, strv, strv);
        .out.println(consolidateR(h4));
    }
 
    

    private static <E> List<Set<E>>
                consolidate(Collection<? extends Set<E>> sets) {
	List<Set<E>> r = new ArrayList<>();
	for (Set<E> s : sets) {
	    List<Set<E>> new_r = new ArrayList<>();
	    new_r.add(s);
	    for (Set<E> x : r) {
		if (!.disjoint(s, x)) {
		    s.addAll(x);
		} else {
		    new_r.add(x);
		}
	    }
	    r = new_r;
	}
	return r;
    }
 
    

    private static <E> List<Set<E>> consolidateR(List<Set<E>> sets) {
        if (sets.size() < 2)
            return sets;
        List<Set<E>> r = new ArrayList<>();
        r.add(sets.get(0));
        for (Set<E> x : consolidateR(sets.subList(1, sets.size()))) {
            if (!.disjoint(r.get(0), x)) {
                r.get(0).addAll(x);
            } else {
                r.add(x);
            }
        }
        return r;
    }
 
    private static List<Set<Character>> hashSetList(... set) {
        List<Set<Character>> r = new ArrayList<>();
        for (int i = 0; i < set.length; i++) {
            r.add(new HashSet<Character>());
            for (int j = 0; j < set[i].length(); j++)
                r.get(i).add(set[i].charAt(j));
        }
        return r;
    }
}"
"import java.math.BigInteger;
 
public class PrimorialPrimes {
 
    final static int sieveLimit = 1550_000;
    static boolean[] notPrime = sieve(sieveLimit);
 
    public static void main([] args) {
 
        int count = 0;
        for (int i = 1; i < 1000_000 && count < 20; i++) {
             b = primorial(i);
            if (b.add(.ONE).isProbablePrime(1)
                    || b.subtract(.ONE).isProbablePrime(1)) {
                .out.printf(strv, i);
                count++;
            }
        }
    }
 
    static  primorial(int n) {
        if (n == 0)
            return .ONE;
 
         result = .ONE;
        for (int i = 0; i < sieveLimit && n > 0; i++) {
            if (notPrime[i])
                continue;
            result = result.multiply(.valueOf(i));
            n--;
        }
        return result;
    }
 
    public static boolean[] sieve(int limit) {
        boolean[] composite = new boolean[limit];
        composite[0] = composite[1] = true;
 
        int max = (int) .sqrt(limit);
        for (int n = 2; n <= max; n++) {
            if (!composite[n]) {
                for (int k = n * n; k < limit; k += n) {
                    composite[k] = true;
                }
            }
        }
        return composite;
    }
}"
"import java.util.stream.IntStream;
 
public class Test {
 
    static IntStream getPrimes(int start, int end) {
        return IntStream.rangeClosed(start, end).filter(n -> isPrime(n));
    }
 
    public static boolean isPrime(long x) {
        if (x < 3 || x % 2 == 0)
            return x == 2;
 
        long max = (long) .sqrt(x);
        for (long n = 3; n <= max; n += 2) {
            if (x % n == 0) {
                return false;
            }
        }
        return true;
    }
 
    public static void main([] args) {
        getPrimes(0, 100).forEach(p -> .out.printf(strv, p));
    }
}"
"import java.lang.reflect.Method;
 
class Example {
  public int foo(int x) {
    return 42 + x;
  }
}
 
public class Main {
  public static void main([] args) throws  {
     example = new Example();
     name = strv;
    Class<?> clazz = example.getClass();
     meth = clazz.getMethod(name, int.class);
     result = meth.invoke(example, 5); 

    .out.println(result);        

  }
}"
"public class SeqNonSquares {
    public static int nonsqr(int n) {
        return n + (int).round(.sqrt(n));
    }
 
    public static void main([] args) {
        

        for (int i = 1; i < 23; i++)
            .out.print(nonsqr(i) + strv);
        .out.println();
 
        

        for (int i = 1; i < 1000000; i++) {
            double j = .sqrt(nonsqr(i));
            assert j != .floor(j);
        }
    }
}"
"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;
 
public class SelfReferentialSequence {
 
    static Map<, Integer> cache = new ConcurrentHashMap<>(10_000);
 
    public static void main([] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);
 
        .out.println(strv);
        res.seeds.forEach(e -> .out.println(.toString(e)));
 
        .out.println(""Sequence:"");
        summarize(res.seeds.get(0)[0], true);
    }
 
    static int[] summarize(int seed, boolean display) {
         n = .valueOf(seed);
 
         k = .toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};
 
        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();
 
        int[] freq = new int[10];
 
        while (!seen.contains(n)) {
            seen.add(n);
 
            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;
 
            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                .out.println(n);
            n = sb.toString();
        }
 
        cache.put(k, seen.size());
 
        return new int[]{seed, seen.size()};
    }
 
    static class Seeds {
        int largest = .MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();
 
        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }
 
        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}"
"import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.File;
import java.io.IOException;
import java.util.Scanner;
 
class CopysJ {
 
  public static void main([] args) {
     ddname_IN  = strv;
     ddname_OUT = strv;
    if (args.length >= 1) { ddname_IN  = args[0].length() > 0 ? args[0] : ddname_IN; }
    if (args.length >= 2) { ddname_OUT = args[1].length() > 0 ? args[1] : ddname_OUT; }
 
     dd_IN = new (ddname_IN);
     dd_OUT = new (ddname_OUT);
 
    try (
      Scanner scanner_IN = new Scanner(dd_IN);
       writer_OUT = new (new (dd_OUT))
      ) {
       a;
       b;
       c;
       d;
       c1;
       x = strv;
       data_IN;
       data_OUT;
      int ib;
 
      while (scanner_IN.hasNextLine()) {
        data_IN = scanner_IN.nextLine();
        ib = 0;
        a = data_IN.substring(ib, ib += 5);
        b = data_IN.substring(ib, ib += 5);
        c = data_IN.substring(ib, ib += 4);
        c1=.toHexString(new ((c.getBytes())[0]).intValue());
        if (c1.length()<2) { c1=strv + c1; }
        data_OUT = a + c1 + x;
        writer_OUT.write(data_OUT);
        writer_OUT.newLine();
        .out.println(data_IN);
        .out.println(data_OUT);
        .out.println();
      }
    }
    catch ( ex) {
      ex.printStackTrace();
    }
    return;
  }
}"
"public class SelfDescribingNumbers{
    public static boolean isSelfDescribing(int a){
         s = .toString(a);
        for(int i = 0; i < s.length(); i++){
             s0 = s.charAt(i) + strv;
            int b = .parseInt(s0); 

            int count = 0;
            for(int j = 0; j < s.length(); j++){
                int temp = .parseInt(s.charAt(j) + strv);
                if(temp == i){
                    count++;
                }
                if (count > b) return false;
            }
            if(count != b) return false;
        }
        return true;
    }
 
    public static void main([] args){
        for(int i = 0; i < 100000000; i++){
            if(isSelfDescribing(i)){
                .out.println(i);
             }
        }
    }
}"
"import java.util.Scanner;
 
public class SEDOL{
	public static void main([] args){
		Scanner sc = new Scanner(.in);
		while(sc.hasNext()){
			 sedol = sc.next();
			.out.println(sedol + getSedolCheckDigit(sedol));
		}
	}
 
	private static final int[] mult = {1, 3, 1, 7, 3, 9};
 
	public static int getSedolCheckDigit( str){
	    if(!validateSedol(str)){
	    	.err.println(strv);
	    	return -1;
	    }
	    str = str.toUpperCase();
	    int total = 0;
	    for(int i = 0;i < 6; i++){
	        char s = str.charAt(i);
	        total += .digit(s, 36) * mult[i];
	    }
	    return (10 - (total % 10)) % 10;
	}
 
	public static boolean validateSedol( str){
		return (str.length() == 6) && !str.toUpperCase().matches(strv);
	}
}"
"import java.io.File;
import java.io.IOException;
 
public class CreateTempFile {
    public static void main([] args)  {
        try {
            //create a temp file
             temp = .createTempFile(strv, strv);
            .out.println(strv + temp.getAbsolutePath());
        }
        catch( e) {
            e.printStackTrace();
    	}
    }
}"
"public //any class may access this member directly
 
protected //only this class, subclasses of this class,
//and classes in the same package may access this member directly
 
private //only this class may access this member directly
 
static //for use with other modifiers
//limits this member to one reference for the entire JVM
 
//adding no modifier (sometimes called strv) allows access to the member by classes in the same package
 












 
//method parameters are available inside the entire method
 
//Other declarations follow lexical scoping,
//being in the scope of the innermost set of braces ({}) to them.
//You may also create local scopes by surrounding blocks of code with braces.
 
public void function(int x){
   //can use x here
   int y;
   //can use x and y here
   {
      int z;
      //can use x, y, and z here
   }
   //can use x and y here, but NOT z
}"
"private static final  rng = new ();
 
void sattoloCycle([] items) {
    for (int i = items.length; i-- > 1;) {
        int j = rng.nextInt(i);
         tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }
}"
"import java.util.*;
 
class SameFringe
{
  public interface Node<T extends Comparable<? super T>>
  {
    Node<T> getLeft();
    Node<T> getRight();
    boolean isLeaf();
    T getData();
  }
 
  public static class SimpleNode<T extends Comparable<? super T>> implements Node<T>
  {
    private final T data;
    public SimpleNode<T> left;
    public SimpleNode<T> right;
 
    public SimpleNode(T data)
    {  this(data, null, null);  }
 
    public SimpleNode(T data, SimpleNode<T> left, SimpleNode<T> right)
    {
      this.data = data;
      this.left = left;
      this.right = right;
    }
 
    public Node<T> getLeft()
    {  return left;  }
 
    public Node<T> getRight()
    {  return right;  }
 
    public boolean isLeaf()
    {  return ((left == null) && (right == null));  }
 
    public T getData()
    {  return data;  }
 
    public SimpleNode<T> addToTree(T data)
    {
      int cmp = data.compareTo(this.data);
      if (cmp == 0)
        throw new (strv);
      if (cmp < 0)
      {
        if (left == null)
          return (left = new SimpleNode<T>(data));
        return left.addToTree(data);
      }
      if (right == null)
        return (right = new SimpleNode<T>(data));
      return right.addToTree(data);
    }
  }
 
  public static <T extends Comparable<? super T>> boolean areLeavesSame(Node<T> node1, Node<T> node2)
  {
    Stack<Node<T>> stack1 = new Stack<Node<T>>();
    Stack<Node<T>> stack2 = new Stack<Node<T>>();
    stack1.push(node1);
    stack2.push(node2);
    

    while (((node1 = advanceToLeaf(stack1)) != null) & ((node2 = advanceToLeaf(stack2)) != null))
      if (!node1.getData().equals(node2.getData()))
        return false;
    

    return (node1 == null) && (node2 == null);
  }
 
  private static <T extends Comparable<? super T>> Node<T> advanceToLeaf(Stack<Node<T>> stack)
  {
    while (!stack.isEmpty())
    {
      Node<T> node = stack.pop();
      if (node.isLeaf())
        return node;
      Node<T> rightNode = node.getRight();
      if (rightNode != null)
        stack.push(rightNode);
      Node<T> leftNode = node.getLeft();
      if (leftNode != null)
        stack.push(leftNode);
    }
    return null;
  }
 
  public static void main([] args)
  {
    SimpleNode<Integer> headNode1 = new SimpleNode<Integer>(35, new SimpleNode<Integer>(25, new SimpleNode<Integer>(15, new SimpleNode<Integer>(10), new SimpleNode<Integer>(20)), new SimpleNode<Integer>(30)), new SimpleNode<Integer>(45, new SimpleNode<Integer>(40), new SimpleNode<Integer>(50)));
    SimpleNode<Integer> headNode2 = new SimpleNode<Integer>(24, new SimpleNode<Integer>(14, new SimpleNode<Integer>(10), new SimpleNode<Integer>(16, null, new SimpleNode<Integer>(20))), new SimpleNode<Integer>(34, new SimpleNode<Integer>(30), new SimpleNode<Integer>(42, new SimpleNode<Integer>(40), new SimpleNode<Integer>(56, new SimpleNode<Integer>(50), null))));
    SimpleNode<Integer> headNode3 = new SimpleNode<Integer>(24, new SimpleNode<Integer>(14, new SimpleNode<Integer>(10), new SimpleNode<Integer>(16, null, new SimpleNode<Integer>(20))), new SimpleNode<Integer>(34, new SimpleNode<Integer>(30), new SimpleNode<Integer>(42, new SimpleNode<Integer>(40), new SimpleNode<Integer>(50, null, new SimpleNode<Integer>(56)))));
    .out.print(strv);
    simpleWalk(headNode1);
    .out.println();
    .out.print(strv);
    simpleWalk(headNode2);
    .out.println();
    .out.print(strv);
    simpleWalk(headNode3);
    .out.println();
    .out.println(strv + areLeavesSame(headNode1, headNode2));
    .out.println(strv + areLeavesSame(headNode2, headNode3));
  }
 
  public static void simpleWalk(Node<Integer> node)
  {
    if (node.isLeaf())
      .out.print(node.getData() + strv);
    else
    {
      Node<Integer> left = node.getLeft();
      if (left != null)
        simpleWalk(left);
      Node<Integer> right = node.getRight();
      if (right != null)
        simpleWalk(right);
    }
  }
}"
"import java.util.List;
import java.util.Arrays;
 
List<String> haystack = .asList(strv,strv,strv,strv,strv,strv,strv,strv,strv);
 
for ( needle : new []{strv,strv}) {
    int index = haystack.indexOf(needle);
    if (index < 0)
        .out.println(needle + strv);
    else
        .out.println(index + strv + needle);
}import java.util.Arrays;
 
[] haystack = { strv,strv,strv,strv,strv,strv,strv,strv,strv};
 
for ( needle : new []{strv,strv}) {
    int index = .binarySearch(haystack, needle);
    if (index < 0)
        .out.println(needle + strv);
    else
        .out.println(index + strv + needle);
}"
"public class Test {
 
    static boolean valid(int n, int nuts) {
        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)
            if (nuts % n != 1)
                return false;
        return nuts != 0 && (nuts % n == 0);
    }
 
    public static void main([] args) {
        int x = 0;
        for (int n = 2; n < 10; n++) {
            while (!valid(n, x))
                x++;
            .out.printf(strv, n, x);
        }
    }
}"
"package jfkbits;
 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.util.Iterator;
 
public class LispTokenizer implements Iterator<Token>
{
    

     m_tokenizer;
     m_ioexn;
 
    /** Constructs a tokenizer that scans input from the given string.     * @param src A string containing S-expressions.     */
    public LispTokenizer( src)
    {
        this(new (src));
    }
 
    /** Constructs a tokenizer that scans input from the given Reader.     * @param r Reader for the character input source     */
    public LispTokenizer( r)
    {
        if(r == null)
            r = new (strv);
         buffrdr = new (r);
        m_tokenizer = new (buffrdr);
        m_tokenizer.resetSyntax(); 

 
        m_tokenizer.whitespaceChars(0, ' ');
        m_tokenizer.wordChars(' '+1,255);
        m_tokenizer.ordinaryChar('(');
        m_tokenizer.ordinaryChar(')');
        m_tokenizer.ordinaryChar('');
        m_tokenizer.commentChar(';');
        m_tokenizer.quoteChar('""');
    }
 
    public Token peekToken()
    {	
        if(m_ioexn != null)
            return null;
        try
        {
            m_tokenizer.nextToken();
        }
        catch( e)
        {
            m_ioexn = e;
            return null;
        }
        if(m_tokenizer.ttype == .TT_EOF)
            return null;
        Token token = new Token(m_tokenizer);
        m_tokenizer.pushBack();
        return token;
    }
 
    public boolean hasNext()
    {
        if(m_ioexn != null)
            return false;
        try
        {
            m_tokenizer.nextToken();
        }
        catch( e)
        {
            m_ioexn = e;
            return false;
        }
        if(m_tokenizer.ttype == .TT_EOF)
            return false;
        m_tokenizer.pushBack();
        return true;
    }
 
    /** Return the most recently caught IOException, if any,     *      * @return     */
    public  getIOException()
    {
        return m_ioexn;
    }
 
    public Token next()
    {
        try
        {
            m_tokenizer.nextToken();
        }
        catch( e)
        {
            m_ioexn = e;
            return null;
        }
 
        Token token = new Token(m_tokenizer);
        return token;
    }
 
    public void remove()
    {
    }
}package jfkbits;
import java.io.StreamTokenizer;
 
public class Token
{
    public static final int SYMBOL = .TT_WORD;
    public int type;
    public  text;
    public int line;
 
    public Token( tzr)
    {
        this.type = tzr.ttype;
        this.text = tzr.sval;
        this.line = tzr.lineno();
    }
 
    public  toString()
    {
        switch(this.type)
        {
            case SYMBOL:
            case '""':
                return this.text;
            default:
                return .valueOf((char)this.type);
        }
    }
}package jfkbits;
 
import jfkbits.LispParser.Expr;
 
public class Atom implements Expr
{
     name;
    public  toString()
    {
        return name;
    }
    public Atom( text)
    {
        name = text;
    }
 
}package jfkbits;
 
public class StringAtom extends Atom
{
    public  toString()
    {
        

         escaped = name.replace("""", """").replace("""", ""n"").replace("""", ""r"").replace("""", """");
        return """"+escaped+"""";
    }
 
    public StringAtom( text)
    {
        super(text);
    }
    public  getValue()
    {
        return name;
    }
}
 package jfkbits;
 
import java.util.AbstractCollection;
import java.util.Arrays;
import java.util.Iterator;
import java.util.ArrayList;
 
import jfkbits.LispParser.Expr;
 
public class ExprList extends ArrayList<Expr> implements Expr
{
    ExprList parent = null;
    int indent =1;
 
    public int getIndent()
    {
        if (parent != null)
        {
            return parent.getIndent()+indent;
        }
        else return 0;
    }
 
    public void setIndent(int indent)
    {
        this.indent = indent;
    }
 
 
 
    public void setParent(ExprList parent)
    {
        this.parent = parent;
    }
 
    public  toString()
    {
         indent = strv;
        if (parent != null && parent.get(0) != this)
        {
            indent = """";
            char[] chars = new char[getIndent()];
            .fill(chars, ' ');
            indent += new (chars);		
        }
 
         output = indent+strv;
        for(Iterator<Expr> it=this.iterator(); it.hasNext(); ) 
        {
            Expr expr = it.next();
            output += expr.toString();
            if (it.hasNext())
                output += strv;
        }
        output += strv;
        return output;
    }
 
    @Override
    public synchronized boolean add(Expr e)
    {
        if (e instanceof ExprList)
        {
            ((ExprList) e).setParent(this);
            if (size() != 0 && get(0) instanceof Atom)
                ((ExprList) e).setIndent(2);
        }
        return super.add(e);
    }
 
}package jfkbits;
 
 
public class LispParser
{
    LispTokenizer tokenizer;
 
    public LispParser(LispTokenizer input)
    {
        tokenizer=input;
    }
 
    public class  extends 
    {
 
    }
 
    public interface Expr
    {
        

    }
 
    public Expr parseExpr() throws 
    {
        Token token = tokenizer.next();
        switch(token.type)
        {
            case '(': return parseExprList(token);
            case '""': return new StringAtom(token.text);
            default: return new Atom(token.text);
        }
    }
 
 
    protected ExprList parseExprList(Token openParen) throws 
    {
        ExprList acc = new ExprList();
        while(tokenizer.peekToken().type != ')')
        {
            Expr element = parseExpr();
            acc.add(element);
        }
        Token closeParen = tokenizer.next();
        return acc;
    }
 
}
 import jfkbits.ExprList;
import jfkbits.LispParser;
import jfkbits.LispParser.ParseException;
import jfkbits.LispTokenizer;
 
public class LispParserDemo
{
    public static void main( args[])
    {
 
        LispTokenizer tzr = new LispTokenizer(
            ""((data quoted data 123 4.5) (data (!@# (4.5) (more data))))"");
        LispParser parser = new LispParser(tzr);
 
        try
        {
            Expr result = parser.parseExpr();
            .out.println(result);
        }
        catch ( e1)
        {
            

            e1.printStackTrace();
        }
    }	
}"
"import static java.lang..*;
import java.util.function.BiFunction;
 
public class RungeKutta {
 
    static void runge(BiFunction<, , Double> yp_func, double[] t,
            double[] y, double dt) {
 
        for (int n = 0; n < t.length - 1; n++) {
            double dy1 = dt * yp_func.apply(t[n], y[n]);
            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);
            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);
            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);
            t[n + 1] = t[n] + dt;
            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;
        }
    }
 
    static double calc_err(double t, double calc) {
        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;
        return abs(actual - calc);
    }
 
    public static void main([] args) {
        double dt = 0.10;
        double[] t_arr = new double[101];
        double[] y_arr = new double[101];
        y_arr[0] = 1.0;
 
        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);
 
        for (int i = 0; i < t_arr.length; i++)
            if (i % 10 == 0)
                .out.printf(strv,
                        t_arr[i], y_arr[i],
                        calc_err(t_arr[i], y_arr[i]));
    }
}"
"import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RunLengthEncoding {
 
    public static  encode( source) {
         dest = new ();
        for (int i = 0; i < source.length(); i++) {
            int runLength = 1;
            while (i+1 < source.length() && source.charAt(i) == source.charAt(i+1)) {
                runLength++;
                i++;
            }
            dest.append(runLength);
            dest.append(source.charAt(i));
        }
        return dest.toString();
    }
 
    public static  decode( source) {
         dest = new ();
        Pattern pattern = Pattern.compile(strv);
        Matcher matcher = pattern.matcher(source);
        while (matcher.find()) {
            int number = .parseInt(matcher.group());
            matcher.find();
            while (number-- != 0) {
                dest.append(matcher.group());
            }
        }
        return dest.toString();
    }
 
    public static void main([] args) {
         example = strv;
        .out.println(encode(example));
        .out.println(decode(strv));
    }
}import static org.junit.Assert.assertEquals;
 
import org.junit.Test;
 
public class RunLengthEncodingTest {
	private RLE = new RunLengthEncoding();
 
	@Test
	public void encodingTest() {
		assertEquals(strv, RLE.encode(strv));
		assertEquals(strv, RLE.encode(strv));
		assertEquals(strv,
				RLE.encode(strv));
		assertEquals(strv,
				RLE.encode(strv));
		assertEquals(strv,
				RLE.encode(strv));
		assertEquals(strv, RLE.encode(strv));
 
	}
 
	@Test
	public void decodingTest() {
		assertEquals(strv, RLE.decode(strv));
		assertEquals(strv, RLE.decode(strv));
		assertEquals(strv,
				RLE.decode(strv));
		assertEquals(strv, RLE.decode(strv));
		assertEquals(strv, RLE.decode(strv));
 
	}
}"
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
 
public class FixCodeTags 
{
	public static void main([] args)
	{
		 sourcefile=args[0];
		 convertedfile=args[1];
		convert(sourcefile,convertedfile);
	}
		static [] languages = {strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv};
	static void convert( sourcefile, convertedfile)
	{
		try
		{
			 br=new (new (sourcefile));
			//String buffer to store contents of the file
			 sb=new (strv);
			 line;
			while((line=br.readLine())!=null)
			{
				for(int i=0;i<languages.length;i++)
				{
					 lang=languages[i];
					line=line.replaceAll(strv+lang+strv, strv+lang+strv);
					line=line.replaceAll(strv+lang+strv, strv+lang+strv);
					line=line.replaceAll(strv+lang+strv, strv+lang+strv);
					line=line.replaceAll(strv, strv+strv);
				}
				sb.append(line);
			}
			br.close();
 
			 fw=new (new (convertedfile));
			//Write entire string buffer into the file
			fw.write(sb.toString());
			fw.close();
		}
		catch ( e)
		{
			.out.println(strv+e.getMessage());
		}
	}
}
 "
"import java.io.*;
 
public class Rot13 {
    public static void main([] args) {
         in;
        if (args.length >= 1) {
            for ( file : args) {
                try {
                    in = new (new (file));
                     line;
                    while ((line = in.readLine()) != null) {
                        .out.println(convert(line));
                    }
                } catch ( e) {
                    e.printStackTrace();
                }
            }
        } else {
            try {
                in = new (new (.in));
                 line;
                while ((line = in.readLine()) != null) {
                    .out.println(convert(line));
                }
            } catch ( e) {
                e.printStackTrace();
            }
        }
    }
 
    public static  convert( msg) {
        StringBuilder retVal = new StringBuilder();
        for (char a : msg.toCharArray()) {
            if (a >= 'A' && a <= 'Z') {
                a += 13;
                if (a > 'Z') {
                    a -= 26;
                }
            } else if (a >= 'a' && a <= 'z') {
                a += 13;
                if (a > 'z') {
                    a -= 26;
                }
            }
            retVal.append(a);
        }
        return retVal.toString();
    }
}"
"import java.util.Locale;
 
public class Test {
 
    public static void main([] a) {
        for (int n = 2; n < 6; n++)
            unity(n);
    }
 
    public static void unity(int n) {
        .out.printf(strv, n);
 
        //all the way around the circle at even intervals
        for (double angle = 0; angle < 2 * .PI; angle += (2 * .PI) / n) {
 
            double real = .cos(angle); //real axis is the x axis
 
            if (.abs(real) < 1.0E-3)
                real = 0.0; //get rid of annoying sci notation
 
            double imag = .sin(angle); //imaginary axis is the y axis
 
            if (.abs(imag) < 1.0E-3)
                imag = 0.0;
 
            .out.printf(.US, strv, real, imag);
        }
    }
}"
"import  java.net.URL;
import  java.net.URLConnection;
import  java.io.*;
import  java.util.*;
 
public class GetRCLanguages
{
    

    

    private static class LanguageComparator implements Comparator<String>
    {
        public int compare(  a,  b )
        {
            

            int result = ( b.charAt( 0 ) - a.charAt( 0 ) );
            if( result == 0 )
            {
                

                result = a.compareTo( b );
            } 

        return result;
        } 

    } 

 
    

    private static  after(  text, int marker )
    {
         result = strv;
        int    pos    = text.indexOf( marker );
        if( pos >= 0 )
        {
            

            result = text.substring( pos + 1 );
        } 

    return result;
    } 

 
    

    

    public static void parseContent(  path
                                   , [] gcmcontinue
                                   , ArrayList<String> languageList
                                   )
    {
        try
        {
 
                        url = new ( path );
              rc  = url.openConnection();
            

            rc.setRequestProperty( strv, strv );
             bfr = new ( new ( rc.getInputStream() ) );
 
            gcmcontinue[0]      = strv;
             languageName = strv;
             line         = bfr.readLine();
            while( line != null )
            {
                line = line.trim();
                if     ( line.startsWith( strv ) )
                {
                    

                    languageName = after( line, ':' ).trim();
                }
                else if( line.startsWith( strv ) )
                {
                    

                     pageCount = after( line, '>' ).trim();
                    if( pageCount.compareTo( strv ) != 0 )
                    {
                        

                        languageList.add( ( (char) .parseInt( pageCount ) ) + languageName );
                        languageName = strv;
                    } 

                }
                else if( line.startsWith( strv ) )
                {
                    

                    gcmcontinue[0] = after( line, '>' ).trim();
                } 

                line = bfr.readLine();
            } 

            bfr.close();
        }
        catch(  e )
        {
            e.printStackTrace();
        } 

    } 

 
    public static void main( [] args )
    {
        

        ArrayList<String> languageList = new ArrayList<String>( 1000 );
        []          gcmcontinue  = new [1];
        gcmcontinue[0]                 = strv;
        do
        {
             path = ( strv
                          + strv
                          + strv
                          + strv
                          + ( gcmcontinue[0].compareTo( strv ) == 0 ? strv : ( strv + gcmcontinue[0] ) )
                          + strv
                          + strv
                          );
            parseContent( path, gcmcontinue, languageList );
        }
        while( gcmcontinue[0].compareTo( strv ) != 0 );
        

        [] languages = languageList.toArray(new []{});
        .sort( languages, new LanguageComparator() );
        

        int    lastTie    = -1;
        int    lastCount  = -1;
        for( int lPos = 0; lPos < languages.length; lPos ++ )
        {
            int    count = (int) ( languages[ lPos ].charAt( 0 ) );
            .out.format( ""%4d: %4d: %s""
                             , 1 + ( count == lastCount ? lastTie : lPos )
                             , count
                             , languages[ lPos ].substring( 1 )
                             );
            if( count != lastCount )
            {
                lastTie   = lPos;
                lastCount = count;
            } 

        } 

    } 

} 
"
"public class QuadraticRoots {
    private static class Complex {
        double re, im;
 
        public Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }
 
        @Override
        public boolean equals( obj) {
            if (obj == this) {return true;}
            if (!(obj instanceof Complex)) {return false;}
            Complex other = (Complex) obj;
            return (re == other.re) && (im == other.im);
        }
 
        @Override
        public  toString() {
            if (im == 0.0) {return .format(strv, re);}
            if (re == 0.0) {return .format(strv, im);}
            return .format(strv, re,
                (im < 0.0 ? '-' : '+'), .abs(im));
        }
    }
 
    private static Complex[] quadraticRoots(double a, double b, double c) {
        Complex[] roots = new Complex[2];
        double d = b * b - 4.0 * a * c;  

        double aa = a + a;
 
        if (d < 0.0) {
            double re = -b / aa;
            double im = .sqrt(-d) / aa;
            roots[0] = new Complex(re, im);
            roots[1] = new Complex(re, -im);
        } else if (b < 0.0) {
            

            

            double re = (-b + .sqrt(d)) / aa;
            roots[0] = new Complex(re, 0.0);
            roots[1] = new Complex(c / (a * re), 0.0);
        } else {
            

            double re = (-b - .sqrt(d)) / aa;
            roots[1] = new Complex(re, 0.0);
            roots[0] = new Complex(c / (a * re), 0.0);
        }
        return roots;
    }
 
    public static void main([] args) {
        double[][] equations = {
            {1.0, 22.0, -1323.0},   

            {6.0, -23.0, 20.0},     

            {1.0, -1.0e9, 1.0},     

            {1.0, 2.0, 1.0},        

            {1.0, 0.0, 1.0},        

            {1.0, 1.0, 1.0}         

        };
        for (int i = 0; i < equations.length; i++) {
            Complex[] roots = quadraticRoots(
                equations[i][0], equations[i][1], equations[i][2]);
            .out.format(strv,
                equations[i][0], equations[i][1], equations[i][2]);
            if (roots[0].equals(roots[1])) {
                .out.format(strv, roots[0]);
            } else {
                .out.format(strv, roots[0]);
                .out.format(strv, roots[1]);
            }
        }
    }
}"
"public class Roots {
    public interface Function {
	public double f(double x);
    }
 
    private static int sign(double x) {
	return (x < 0.0) ? -1 : (x > 0.0) ? 1 : 0;
    }
 
    public static void printRoots(Function f, double lowerBound,
				  double upperBound, double step) {
	double x = lowerBound, ox = x;
	double y = f.f(x), oy = y;
	int s = sign(y), os = s;
 
	for (; x <= upperBound ; x += step) {
	    s = sign(y = f.f(x));
	    if (s == 0) {
		.out.println(x);
	    } else if (s != os) {
		double dx = x - ox;
		double dy = y - oy;
		double cx = x - dx * (y / dy);
		.out.println(strv + cx);
	    }
	    ox = x; oy = y; os = s;
	}
    }
 
    public static void main([] args) {
	Function poly = new Function () {
	    public double f(double x) {
		return x*x*x - 3*x*x + 2*x;
	    }
	};
	printRoots(poly, -1.0, 4, 0.002);
    }
}"
"import java.awt.*;
import static java.awt..*;
import java.awt.event.*;
import static java.lang..abs;
import static java.lang..format;
import java.util.Random;
import javax.swing.*;
 
public class Robots extends  {
    enum Grid {
        Player(strv), (strv), Scrap(strv), Mark(strv);
 
        Grid( s) {
            symbol = s;
        }
        final  symbol;
    }
 
    final static int[][] dirs = {{-1, 1}, {0, 1}, {1, 1}, {-1, 0}, {1, 0},
    {-1, -1}, {0, -1}, {1, -1}};
 
    final static  rand = new ();
 
    final int nRows;
    final int nCols;
 
    Grid[][] grid;
    int playerRow, playerCol, score, hiScore, level;
    boolean gameOver = true;
     dash;
 
    public Robots() {
        setPreferredSize(new (800, 650));
        setBackground(.white);
        setForeground(.lightGray);
        setFont(new (strv, .PLAIN, 18));
        setFocusable(true);
 
        nRows = 38;
        nCols = 50;
 
        dash = new (2.0f, CAP_BUTT, JOIN_MITER, 10.0f,
                new float[]{5.0f}, 0.0f);
 
        addMouseListener(new () {
            @Override
            public void mousePressed( e) {
                if (gameOver) {
                    startNewGame();
                    repaint();
                }
            }
        });
 
        addKeyListener(new () {
            @Override
            public void keyPressed( e) {
                int keyCode = e.getKeyCode();
 
                if (keyCode == .VK_NUMPAD5) {
                    teleport();
 
                } else {
                    int k = keyCode - .VK_NUMPAD1;
                    if (k >= 0 && k < 9) {
                        move(k > 4 ? --k : k);
                    }
                }
                repaint();
            }
        });
    }
 
    void startNewGame() {
        level = 1;
        if (score > hiScore)
            hiScore = score;
        score = 0;
        initGrid();
        gameOver = false;
    }
 
    void initGrid() {
        grid = new Grid[nRows][nCols];
 
        teleport();
 
        int numRobots = 7 * level;
        for (int i = 0; i < numRobots;) {
            int r = rand.nextInt(nRows);
            int c = rand.nextInt(nCols);
            if (grid[r][c] == null) {
                grid[r][c] = Grid.;
                i++;
            }
        }
    }
 
    boolean movePlayer(int r, int c) {
        if (grid[r][c] != null) {
            gameOver = true;
        } else {
            grid[playerRow][playerCol] = null;
            playerRow = r;
            playerCol = c;
            grid[r][c] = Grid.Player;
        }
        return !gameOver;
    }
 
    void move(int d) {
        int c = playerCol + dirs[d][0];
        int r = playerRow + dirs[d][1];
 
        if (!withinBounds(r, c))
            return;
 
        if (!movePlayer(r, c))
            return;
 
        for (int rr = 0; rr < nRows; rr++)
            for (int cc = 0; cc < nCols; cc++) {
                if (grid[rr][cc] == Grid.) {
 
                    

                    int nc = (c == cc ? 0 : (c - cc) / abs(c - cc)) + cc;
                    int nr = (r == rr ? 0 : (r - rr) / abs(r - rr)) + rr;
 
                    if (!withinBounds(nr, nc))
                        continue;
 
                    grid[rr][cc] = null;
 
                    if (grid[nr][nc] == Grid.Player) {
                        gameOver = true;
                        return; /* EARLY RETURN */
 
                    } else if (grid[nr][nc] != null) {
                        score++;
                        if (grid[nr][nc] != Grid.Scrap)
                            score++;
                        grid[nr][nc] = Grid.Scrap;
 
                    } else {
                        

                        grid[nr][nc] = Grid.Mark;
                    }
                }
            }
 
        int robotsLeft = 0;
        for (int rr = 0; rr < nRows; rr++)
            for (int cc = 0; cc < nCols; cc++) {
                if (grid[rr][cc] == Grid.Mark)
                    grid[rr][cc] = Grid.;
                if (grid[rr][cc] == Grid.)
                    robotsLeft++;
            }
 
        if (robotsLeft == 0) {
            level++;
            initGrid();
        }
    }
 
    void teleport() {
        movePlayer(rand.nextInt(nRows), rand.nextInt(nCols));
    }
 
    void drawBorder( g) {
        g.setStroke(dash);
        g.setColor(getForeground());
        g.drawRect(22, 20, getWidth() - 41, getHeight() - 72);
    }
 
    void drawGrid( g) {
        for (int r = 0; r < nRows; r++)
            for (int c = 0; c < nCols; c++) {
                if (grid[r][c] != null)
                    g.drawString(grid[r][c].symbol, 24 + c * 15, 36 + r * 15);
            }
    }
 
    void drawStartScreen( g) {
        g.setColor(.gray);
        g.setFont(new (strv, .BOLD, 48));
        g.drawString(strv, 315, 280);
 
        g.setFont(getFont());
        g.drawString(strv, 270, 350);
        g.drawString(strv, 300, 380);
        g.drawString(strv, 328, 410);
    }
 
    void drawScore( g) {
        g.setColor(.gray);
        g.setFont(getFont());
         s = format(strv, hiScore, score);
        g.drawString(s, 30, getHeight() - 17);
    }
 
    boolean withinBounds(int r, int c) {
        return c >= 0 && c < nCols && r >= 0 && r < nRows;
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawBorder(g);
        drawScore(g);
        if (gameOver) {
            drawStartScreen(g);
        } else {
            drawGrid(g);
        }
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new Robots(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"/* Parse Roman Numerals    Nigel Galloway March 16th., 2012*/
grammar ParseRN ;
 
options {
	language = Java;
}
@members {
int rnValue;
int ONE;
}
 
parseRN:	({rnValue = 0;} rn NEWLINE {.out.println($rn.text + strv + rnValue);})*
	;
 
rn	:	(Thousand {rnValue += 1000;})* hundreds? tens? units?;
 
hundreds:	{ONE = 0;} (h9 | h5) {if (ONE > 3) .out.println (strv);};
h9	:	Hundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);
h5	:	FiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;
 
tens	:	{ONE = 0;} (t9 | t5) {if (ONE > 3) .out.println (strv);};
t9	:	Ten {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);
t5	:	Fifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;
 
units	:	{ONE = 0;} (u9 | u5) {if (ONE > 3) .out.println (strv);};
u9	:	One {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);
u5	:	Five {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;
 
One	:	'I';
Five	:	'V';
Ten	:	'X';
Fifty	:	'L';
Hundred:	'C';
FiveHund:	'D';
Thousand:	'M' ;
NEWLINE:	''? '' ;"
"import org.bouncycastle.crypto.digests.RIPEMD160Digest;
import org.bouncycastle.util.encoders.Hex;
 
public class RosettaRIPEMD160
{
    public static void main ([] argv) throws 
    {
        byte[] r = strv.getBytes(strv);
        RIPEMD160Digest d = new RIPEMD160Digest();
        d.update (r, 0, r.length);
        byte[] o = new byte[d.getDigestSize()];
        d.doFinal (o, 0);
        Hex.encode (o, .out);
        .out.println();
    }
}"
"public class ReverseWords {
 
    static final [] lines = {
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv,
        strv};
 
    public static void main([] args) {
        for ( line : lines) {
            [] words = line.split(""s"");
            for (int i = words.length - 1; i >= 0; i--)
                .out.printf(strv, words[i]);
            .out.println();
        }
    }
}package string;
 
import static java.util..stream;
 
public interface ReverseWords {
  public static final [] LINES = {
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv,
    strv
  };
 
  public static [] reverseWords([] lines) {
    return stream(lines)
      .parallel()
      .map(l -> l.split(""s""))
      .map(ws -> stream(ws)
        .parallel()
        .map(w -> strv + w)
        .reduce(
          strv,
          (w1, w2) -> w2 + w1
        )
      )
      .toArray([]::new)
    ;
  }
 
  public static void main(... arguments) {
    stream(reverseWords(LINES))
      .forEach(.out::println)
    ;
  }
}"
"public class ReallyLameTranslationOfJ {
 
    public static void main([] args) {
         s = strv;
        .out.println(cheapTrick(s));
        .out.println(cheapTrick(cheapTrick(s)));
    }
 
    static  cheapTrick( s) {
        if (s.contains(strv))
            return s.replaceAll(strv, strv);
        else if(s.contains(strv))
            return s.replaceAll(strv, strv);
        return s;
    }
}"
"import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
 


public class RReturnMultipleVals {
  public static final  K_lipsum = strv;
  public static final    K_1024   = 1024L;
  public static final  L        = strv;
  public static final  R        = strv;
 
  

  public static void main([] args) throws {
     nv_;
     sv_;
    switch (args.length) {
      case 0:
        nv_ = K_1024;
        sv_ = K_lipsum;
        break;
      case 1:
        nv_ = .parseLong(args[0]);
        sv_ = K_lipsum;
        break;
      case 2:
        nv_ = .parseLong(args[0]);
        sv_ = args[1];
        break;
      default:
        nv_ = .parseLong(args[0]);
        sv_ = args[1];
        for (int ix = 2; ix < args.length; ++ix) {
          sv_ = sv_ + strv + args[ix];
        }
        break;
    }
 
    RReturnMultipleVals lcl = new RReturnMultipleVals();
 
    Pair<, String> rvp = lcl.getPairFromPair(nv_, sv_); 

    .out.println(strv);
    .out.printf(strv, rvp.getLeftVal(), rvp.getRightVal());
 
    List<Object> rvl = lcl.getPairFromList(nv_, sv_); 

    .out.println(""Results extracted from a Java Colections List object:"");
    .out.printf(strv, rvl.get(0), rvl.get(1));
 
    Map<, Object> rvm = lcl.getPairFromMap(nv_, sv_); 

    .out.println(""Results extracted from a Java Colections Map object:"");
    .out.printf(strv, rvm.get(L), rvm.get(R));
  }
  

  

  

  public <T, U> Pair<T, U> getPairFromPair(T vl_, U vr_) {
    return new Pair<T, U>(vl_, vr_);
  }
  

  

  

  public List<Object> getPairFromList( nv_,  sv_) {
    List<Object> rset = new ArrayList<Object>();
    rset.add(nv_);
    rset.add(sv_);
    return rset;
  }
  

  

  

  public Map<, Object> getPairFromMap( nv_,  sv_) {
    Map<, Object> rset = new HashMap<, Object>();
    rset.put(L, nv_);
    rset.put(R, sv_);
    return rset;
  }
 
  

  private static class Pair<L, R> {
    private L leftVal;
    private R rightVal;
 
    public Pair(L nv_, R sv_) {
      setLeftVal(nv_);
      setRightVal(sv_);
    }
    public void setLeftVal(L nv_) {
      leftVal = nv_;
    }
    public L getLeftVal() {
      return leftVal;
    }
    public void setRightVal(R sv_) {
      rightVal = sv_;
    }
    public R getRightVal() {
      return rightVal;
    }
  }
}public class Values {
	private final [] objects;
	public Values( ... objects) {
		this.objects = objects;
	}
	public <T> T get(int i) {
		return (T) objects[i];
	}
	public [] get() {
		return objects;
	}
 
	

	public static void main([] args) {
		Values v = getValues();
		int i = v.get(0);
		.out.println(i);
		printValues(i, v.get(1));
		printValues(v.get());
	}
	private static Values getValues() {
		return new Values(1, 3.8, strv);
	}
	private static void printValues(int i, double d) {
		.out.println(i + strv + d);
	}
	private static void printValues( ... objects) {
		for (int i=0; i<objects.length; i+=1) .out.print((i==0 ? strv: strv) + objects[i]);
		.out.println();
	}
}"
"import java.util.function.Consumer;
import java.util.stream.IntStream;
 
public class Repeat {
 
    public static void main([] args) {
        repeat(3, (x) -> .out.println(strv + x));
    }
 
    static void repeat (int n, Consumer<Integer> fun) {
        IntStream.range(0, n).forEach(i -> fun.accept(i + 1));
    }
}"
" 
 str = 'Hello World!';
str = str.reverse();
system.debug(str);
 public static  reverseString( s) {
    return new (s).reverse().toString();
}"
"public class RepString {
 
    static final [] input = {strv, strv, strv,
        strv, strv, strv, strv, strv, strv,
        strv, strv, strv};
 
    public static void main([] args) {
        for ( s : input)
            .out.printf(strv, s, repString(s));
    }
 
    static  repString( s) {
        int len = s.length();
        outer:
        for (int part = len / 2; part > 0; part--) {
            int tail = len % part;
            if (tail > 0 && !s.substring(0, tail).equals(s.substring(len - tail)))
                continue;
            for (int j = 0; j < len / part - 1; j++) {
                int a = j * part;
                int b = (j + 1) * part;
                int c = (j + 2) * part;
                if (!s.substring(a, b).equals(s.substring(b, c)))
                    continue outer;
            }
            return s.substring(0, part);
        }
        return strv;
    }
}"
"import java.io.File;
public class FileRenameTest {
   public static boolean renameFile( oldname,  newname) {
       

        file = new (oldname);
 
       

        file2 = new (newname);
 
       

       boolean success = file.renameTo(file2);
       return success;
   }
   public static void test( type,  oldname,  newname) {
       .out.println(strv + type + strv + oldname +
           ( renameFile(oldname, newname) ? strv : strv)
           + newname + strv
       );
   }
   public static void main( args[]) {
        test(strv, strv, strv);
        test(strv, .separator + strv, .separator + strv);
        test(strv, strv, strv);
        test(strv, .separator + strv + .separator, .separator + strv + .separator);
   }
}"
" 
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
 
public class RemoveLines
{
	public static void main([] args)
	{
		//Enter name of the file here
		 filename=strv;
		//Enter starting line here
		int startline=1;
		//Enter number of lines here.
		int numlines=2;
 
		RemoveLines now=new RemoveLines();
		now.delete(filename,startline,numlines);
	}
	void delete( filename, int startline, int numlines)
	{
		try
		{
			 br=new (new (filename));
 
			//String buffer to store contents of the file
			 sb=new (strv);
 
			//Keep track of the line number
			int linenumber=1;
			 line;
 
			while((line=br.readLine())!=null)
			{
				//Store each valid line in the string buffer
				if(linenumber<startline||linenumber>=startline+numlines)
					sb.append(line+"""");
				linenumber++;
			}
			if(startline+numlines>linenumber)
				.out.println(strv);
			br.close();
 
			 fw=new (new (filename));
			//Write entire string buffer into the file
			fw.write(sb.toString());
			fw.close();
		}
		catch ( e)
		{
			.out.println(strv+e.getMessage());
		}
	}
}
 
 "
"import java.lang.reflect.Method;
 
public class ListMethods {
    public int examplePublicInstanceMethod(char c, double d) {
        return 42;
    }
 
    private boolean examplePrivateInstanceMethod( s) {
        return true;
    }
 
    public static void main([] args) {
        Class clazz = ListMethods.class;
 
        .out.println(strv);
        for ( m : clazz.getMethods()) {
            .out.println(m);
        }
        .out.println();
        .out.println(strv);
        for ( m : clazz.getDeclaredMethods()) {
            .out.println(m);
        }
    }
}"
"import java.lang.reflect.Field;
 
public class ListFields {
    public int examplePublicField = 42;
    private boolean examplePrivateField = true;
 
    public static void main([] args) throws  {
        ListFields obj = new ListFields();
        Class clazz = obj.getClass();
 
        .out.println(strv);
        for ( f : clazz.getFields()) {
            .out.printf(""%s%s"", f, f.get(obj));
        }
        .out.println();
        .out.println(strv);
        for ( f : clazz.getDeclaredFields()) {
            .out.printf(""%s%s"", f, f.get(obj));
        }
    }
}"
"import java.util.*;
 
class Test {
 
    public static void main([] args) {
 
        [] data = {1, 1, 2, 2, 3, 3, 3, strv, strv, strv, strv, strv, strv};
        .stream(data).distinct().forEach((o) -> .out.printf(strv, o));
    }
}"
" str = strv;
if (str.matches(strv)) { 

  .out.println(strv);
}import java.util.regex.*;
Pattern p = Pattern.compile(strv);
Matcher m = p.matcher(str);
while (m.find()) {
  

} orig = strv;
 result = orig.replaceAll(strv, strv);

"
"import java.util.*;
import java.lang.Math;
import org.apache.commons.math.fraction.Fraction;
import org.apache.commons.math.fraction.FractionConversionException;
 
/* Matrix class * Handles elementary Matrix operations: *	Interchange *	Multiply and Add *	Scale *	Reduced Row Echelon Form */
class Matrix {
	LinkedList<LinkedList<Fraction>> matrix;
	int numRows;
	int numCols;	
 
	static class Coordinate {
		int row;
		int col;
 
		Coordinate(int r, int c) {
			row = r;
			col = c;
		}
 
		public  toString() {
			return strv + row + strv + col + strv;
		}
	}
 
	Matrix(double [][] m) {
		numRows = m.length;	
		numCols = m[0].length;
 
		matrix = new LinkedList<LinkedList<Fraction>>();
 
		for (int i = 0; i < numRows; i++) {
			matrix.add(new LinkedList<Fraction>());
			for (int j = 0; j < numCols; j++) {
				try {
					matrix.get(i).add(new Fraction(m[i][j]));
				} catch (FractionConversionException e) {
					.err.println(strv);
				}
			}
		}
	}
 
	public void Interchange(Coordinate a, Coordinate b) {
		LinkedList<Fraction> temp = matrix.get(a.row);
		matrix.set(a.row, matrix.get(b.row));		
		matrix.set(b.row, temp);
 
		int t = a.row;
		a.row = b.row;
		b.row = t;
	} 
 
	public void Scale(Coordinate x, Fraction d) {
		LinkedList<Fraction> row = matrix.get(x.row);
		for (int i = 0; i < numCols; i++) {
			row.set(i, row.get(i).multiply(d));
		}
	}
 
	public void MultiplyAndAdd(Coordinate to, Coordinate from, Fraction scalar) {
		LinkedList<Fraction> row = matrix.get(to.row);
		LinkedList<Fraction> rowMultiplied = matrix.get(from.row);
 
		for (int i = 0; i < numCols; i++) {
			row.set(i, row.get(i).add((rowMultiplied.get(i).multiply(scalar))));
		}
	}
 
	public void RREF() {
		Coordinate pivot = new Coordinate(0,0);
 
		int submatrix = 0;
		for (int x = 0; x < numCols; x++) {
			pivot = new Coordinate(pivot.row, x);
			//Step 1
				//Begin with the leftmost nonzero column. This is a pivot column. The pivot position is at the top.
				for (int i = x; i < numCols; i++) {
					if (isColumnZeroes(pivot) == false) {
						break;	
					} else {
						pivot.col = i;
					}
				}
			//Step 2
				//Select a nonzero entry in the pivot column with the highest absolute value as a pivot. 
				pivot = findPivot(pivot);
 
				if (getCoordinate(pivot).doubleValue() == 0.0) {
					pivot.row++;
					continue;
				}
 
				//If necessary, interchange rows to move this entry into the pivot position.
				//move this row to the top of the submatrix
				if (pivot.row != submatrix) {
					Interchange(new Coordinate(submatrix, pivot.col), pivot);
				}
 
				//Force pivot to be 1
				if (getCoordinate(pivot).doubleValue() != 1) {
					/*					System.out.println(getCoordinate(pivot));					System.out.println(pivot);					System.out.println(matrix);					*/
					Fraction scalar = getCoordinate(pivot).reciprocal();
					Scale(pivot, scalar);
				}
			//Step 3
				//Use row replacement operations to create zeroes in all positions below the pivot.
				//belowPivot = belowPivot + (Pivot * -belowPivot)
				for (int i = pivot.row; i < numRows; i++) {
					if (i == pivot.row) {
						continue;
					}
					Coordinate belowPivot = new Coordinate(i, pivot.col);
					Fraction complement = (getCoordinate(belowPivot).negate().divide(getCoordinate(pivot)));
					MultiplyAndAdd(belowPivot, pivot, complement);
				}
			//Step 5
				//Beginning with the rightmost pivot and working upward and to the left, create zeroes above each pivot.
				//If a pivot is not 1, make it 1 by a scaling operation.
					//Use row replacement operations to create zeroes in all positions above the pivot
				for (int i = pivot.row; i >= 0; i--) {
					if (i == pivot.row) {
						if (getCoordinate(pivot).doubleValue() != 1.0) {
							Scale(pivot, getCoordinate(pivot).reciprocal());	
						}
						continue;
					}
					if (i == pivot.row) {
						continue;
					}
 
					Coordinate abovePivot = new Coordinate(i, pivot.col);
					Fraction complement = (getCoordinate(abovePivot).negate().divide(getCoordinate(pivot)));
					MultiplyAndAdd(abovePivot, pivot, complement);
				}
			//Step 4
				//Ignore the row containing the pivot position and cover all rows, if any, above it.
				//Apply steps 1-3 to the remaining submatrix. Repeat until there are no more nonzero entries.
				if ((pivot.row + 1) >= numRows || isRowZeroes(new Coordinate(pivot.row+1, pivot.col))) {
					break;
				}
 
				submatrix++;
				pivot.row++;
		}
	}
 
	public boolean isColumnZeroes(Coordinate a) {
		for (int i = 0; i < numRows; i++) {
			if (matrix.get(i).get(a.col).doubleValue() != 0.0) {
				return false;
			}
		}
 
		return true;
	}
 
	public boolean isRowZeroes(Coordinate a) {
		for (int i = 0; i < numCols; i++) {
			if (matrix.get(a.row).get(i).doubleValue() != 0.0) {
				return false;
			}
		}
 
		return true;
	}
 
	public Coordinate findPivot(Coordinate a) {
		int first_row = a.row;
		Coordinate pivot = new Coordinate(a.row, a.col);
		Coordinate current = new Coordinate(a.row, a.col);	
 
		for (int i = a.row; i < (numRows - first_row); i++) {
			current.row = i;
			if (getCoordinate(current).doubleValue() == 1.0) {
				Interchange(current, a);
			}
		}
 
		current.row = a.row;
		for (int i = current.row; i < (numRows - first_row); i++) {
			current.row = i;
			if (getCoordinate(current).doubleValue() != 0) {
				pivot.row = i;
				break;
			}
		}
 
 
		return pivot;	
	}	
 
	public Fraction getCoordinate(Coordinate a) {
		return matrix.get(a.row).get(a.col);
	}
 
	public  toString() {
		return matrix.toString().replace(strv, ""]"");
	}
 
	public static void main ([] args) {
        	double[][] matrix_1 = {
			{1, 2, -1, -4},
			{2, 3, -1, -11},
			{-2, 0, -3, 22}
		};
 
		Matrix x = new Matrix(matrix_1);
		.out.println(""before"" + x.toString() + """");
		x.RREF();
		.out.println(""after"" + x.toString() + """");
 
		double matrix_2 [][] = {
			{2, 0, -1, 0, 0},
			{1, 0, 0, -1, 0},
			{3, 0, 0, -2, -1},
			{0, 1, 0, 0, -2},
			{0, 1, -1, 0, 0}
		};
 
		Matrix y = new Matrix(matrix_2);
		.out.println(""before"" + y.toString() + """");
		y.RREF();
		.out.println(""after"" + y.toString() + """");
 
		double matrix_3 [][] = {
			{1, 2, 3, 4, 3, 1},
			{2, 4, 6, 2, 6, 2},
			{3, 6, 18, 9, 9, -6},
			{4, 8, 12, 10, 12, 4},
			{5, 10, 24, 11, 15, -4}
		};
 
		Matrix z = new Matrix(matrix_3);
		.out.println(""before"" + z.toString() + """");
		z.RREF();
		.out.println(""after"" + z.toString() + """");
 
		double matrix_4 [][] = {
			{0, 1},
			{1, 2},
			{0,5}
		};
 
		Matrix a = new Matrix(matrix_4);
		.out.println(""before"" + a.toString() + """");
		a.RREF();
		.out.println(""after"" + a.toString() + """");
	}	
}"
".E; //e
.PI; //pi
.sqrt(x); //square root--cube root also available (cbrt)
.log(x); //natural logarithm--log base 10 also available (log10)
.exp(x); //exponential
.abs(x); //absolute value
.floor(x); //floor
.ceil(x); //ceiling
.pow(x,y); //power"
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
 
public class ReadFile {
    public static void main([] args) throws {
         fileContents = readEntireFile(strv);
    }
 
    private static  readEntireFile( filename) throws  {
         in = new (filename);
        StringBuilder contents = new StringBuilder();
        char[] buffer = new char[4096];
        int read = 0;
        do {
            contents.append(buffer, 0, read);
            read = in.read(buffer);
        } while (read >= 0);
        in.close();
        return contents.toString();
    }
} 
import java.nio.channels.FileChannel.MapMode;
import java.nio.MappedByteBuffer;
import java.io.RandomAccessFile;
import java.io.IOException;
import java.io.File;
 
public class MMapReadFile {
	public static void main([] args) throws  {
		MappedByteBuffer buff = getBufferFor(new (args[0]));
                 results = new (buff.asCharBuffer());
	}
 
	public static MappedByteBuffer getBufferFor( f) throws  {  
		 file = new (f, strv);
 
		MappedByteBuffer buffer = file.getChannel().map(MapMode.READ_ONLY, 0, f.length());
		file.close();
		return buffer;
	}
} content = new Scanner(new (strv), strv).useDelimiter(""A"").next();"
"package linenbr7;
 
import java.io.*;
 
public class LineNbr7 {
 
    public static void main([] args) throws  {
         f = new (args[0]);
        if (!f.isFile() || !f.canRead())
            throw new (strv + args[0]);
 
         br = new (new (f));
        try ( lnr = new (br)) {
             line = null;
            int lnum = 0;
            while ((line = lnr.readLine()) != null
                    && (lnum = lnr.getLineNumber()) < 7) {
            }
 
            switch (lnum) {
                case 0:
                    .out.println(strv);
                    break;
                case 7:
                    boolean empty = strv.equals(line);
                    .out.println(strv + (empty ? strv : line));
                    break;
                default:
                    .out.println(strv + lnum + strv);
            }
        }
    }
}"
"import java.io.BufferedReader;
import java.io.FileReader;
 
/** * Reads a file line by line, processing each line. * * @author  $Author$ * @version $Revision$ */
public class ReadFileByLines {
    private static void processLine(int lineNo,  line) {
        

    }
 
    public static void main([] args) {
        for ( filename : args) {
             br = null;
             fr = null;
            try {
                fr = new (filename);
                br = new (fr);
                 line;
                int lineNo = 0;
                while ((line = br.readLine()) != null) {
                    processLine(++lineNo, line);
                }
            }
            catch ( x) {
                x.printStackTrace();
            }
            finally {
                if (fr != null) {
                    try {br.close();} catch ( ignoreMe) {}
                    try {fr.close();} catch ( ignoreMe) {}
                }
            }
        }
    }
}"
"import java.io.*;
 
public class RUTF8CharacterReader {
  private  slurped;
  private  encoding;
  private  fName;
  private  fFile;
  

  public  slurpChars( fileName) {
    StringBuilder slrp = new StringBuilder();
    fName = fileName;
    fFile = new (fName);
    try ( fr = new (fFile)) {
      encoding = (() fr).getEncoding();
      forever: for (;;) {
        int ic;
        if ((ic = fr.read()) < 0) { break forever; }
        char cc = (char) ic;
        slrp.append(cc);
      }
    }
    catch ( ex) {
      ex.printStackTrace();
    }
    catch ( ex) {
      ex.printStackTrace();
    }
    slurped = slrp.length() > 0 ? slrp.toString() : null;
    return slurped;
  }
  

  public void encodingDetails() {
     FMT_000 = ""file_encoding=%s file_name=%s%n"";
     FMT_001 = ""unicode_string_length=%d code_point_count=%d string=%s%n"";
     FMT_002 = ""codepoint_index=%03d character_count=%d unicode_id=U+%05X hex=%#08x dec=%07d oct=%07o string=%s utf-16=%s utf-8=%s character_name=%s%n"";
     str = slurped;
    .out.printf(FMT_000, encoding, fFile.getAbsoluteFile());
    .out.printf(FMT_001, str.length(), .codePointCount(str, 0, str.length()), str);
    for (int ix = 0; ix < str.length(); ++ix) {
      int cp = .codePointAt(str, ix);
      int cc = .charCount(cp);
       cpName = .getName(cp);
       x_utf16;
       x_utf8;
      x_utf16 = strv;
      x_utf8 = strv;
      try {
        x_utf16 = codePointToUTF16(cp);
        x_utf8 = codePointToUTF8(cp);
      }
      catch ( ex) {
        ex.printStackTrace();
      }
      .out.printf(FMT_002, ix, cc, cp, cp, ((long) cp & 0x00000000ffffffff), cp, new (.toChars(cp)), x_utf16, x_utf8, cpName);
      if (cc > 1) {
        int[] surrogates = { (int) .highSurrogate(cp), (int) .lowSurrogate(cp), };
        int ixx = ix++;
        for (int sp : surrogates) {
           spName = .getName(sp);
          x_utf16 = strv;
          x_utf8 = strv;
          try {
            x_utf16 = codePointToUTF16(sp);
            x_utf8 = codePointToUTF8(sp);
          }
          catch ( ex) {
            ex.printStackTrace();
          }
          int sc = .charCount(sp);
          .out.printf(FMT_002, ixx++, sc, sp, sp, ((long) sp & 0x00000000ffffffff), sp, new (.toChars(sp)), x_utf16, x_utf8, spName);
        }
      }
    }
    return;
  }
  

  public static  codePointToUTF8(int cp) throws  {
     scp = new (.toChars(cp));
    boolean comma = false;
    StringBuilder xparts = new StringBuilder();
    byte[] b_utf8 = scp.getBytes(strv);
    for (int xx = 0; xx < b_utf8.length; ++xx) {
      if (comma) { xparts.append(','); }
      xparts.append(.format(strv, b_utf8[xx]));
      comma = true;
    }
    return xparts.toString();
  }
  

  public static  codePointToUTF16(int cp) throws  {
     scp = new (.toChars(cp));
    StringBuilder xparts = new StringBuilder();
    byte[] b_utf16 = scp.getBytes(strv);
    boolean comma = false;
    for (int xx = 0; xx < b_utf16.length; xx += 2) {
      if (comma) { xparts.append(','); }
      xparts.append(.format(strv, b_utf16[xx], b_utf16[xx + 1]));
      comma = true;
    }
    return xparts.toString();
  }
  

  public static void main([] args) {
     inFile;
    if (args.length > 0 && args[0].length() > 0) { inFile = args[0]; }
    else { inFile = strv; }
    RUTF8CharacterReader lcl = new RUTF8CharacterReader();
    lcl.slurpChars(inFile);
    lcl.encodingDetails();
    return;
  }
}
 "
"import static java.lang..*;
 
public class RayCasting {
 
    static boolean intersects(int[] A, int[] B, double[] P) {
        if (A[1] > B[1])
            return intersects(B, A, P);
 
        if (P[1] == A[1] || P[1] == B[1])
            P[1] += 0.0001;
 
        if (P[1] > B[1] || P[1] < A[1] || P[0] > max(A[0], B[0]))
            return false;
 
        if (P[0] < min(A[0], B[0]))
            return true;
 
        double red = (P[1] - A[1]) / (double) (P[0] - A[0]);
        double blue = (B[1] - A[1]) / (double) (B[0] - A[0]);
        return red >= blue;
    }
 
    static boolean contains(int[][] shape, double[] pnt) {
        boolean inside = false;
        int len = shape.length;
        for (int i = 0; i < len; i++) {
            if (intersects(shape[i], shape[(i + 1) % len], pnt))
                inside = !inside;
        }
        return inside;
    }
 
    public static void main([] a) {
        double[][] testPoints = {{10, 10}, {10, 16}, {-20, 10}, {0, 10},
        {20, 10}, {16, 10}, {20, 20}};
 
        for (int[][] shape : shapes) {
            for (double[] pnt : testPoints)
                .out.printf(strv, contains(shape, pnt));
            .out.println();
        }
    }
 
    final static int[][] square = {{0, 0}, {20, 0}, {20, 20}, {0, 20}};
 
    final static int[][] squareHole = {{0, 0}, {20, 0}, {20, 20}, {0, 20},
    {5, 5}, {15, 5}, {15, 15}, {5, 15}};
 
    final static int[][] strange = {{0, 0}, {5, 5}, {0, 20}, {5, 15}, {15, 15},
    {20, 20}, {20, 0}};
 
    final static int[][] hexagon = {{6, 0}, {14, 0}, {20, 10}, {14, 20},
    {6, 20}, {0, 10}};
 
    final static int[][][] shapes = {square, squareHole, strange, hexagon};
}"
"import java.util.function.Consumer;
 
public class RateCounter {
 
    public static void main([] args) {
        for (double d : benchmark(10, x -> .out.print(strv), 10))
            .out.println(d);
    }
 
    static double[] benchmark(int n, Consumer<Integer> f, int arg) {
        double[] timings = new double[n];
        for (int i = 0; i < n; i++) {
            long time = .nanoTime();
            f.accept(arg);
            timings[i] = .nanoTime() - time;
        }
        return timings;
    }
}import java.util.function.IntConsumer;
import java.util.stream.DoubleStream;
 
import static java.lang..nanoTime;
import static java.util.stream.DoubleStream.generate;
 
import static java.lang..out;
 
public interface RateCounter {
  public static void main(final ... arguments) {
    benchmark(
      10,
      x -> out.print(strv),
      10
    )
      .forEach(out::println)
    ;
  }
 
  public static DoubleStream benchmark(
    final int n,
    final IntConsumer consumer,
    final int argument
  ) {
    return generate(() -> {
      final long time = nanoTime();
      consumer.accept(argument);
      return nanoTime() - time;
    })
      .limit(n)
    ;
  }
}"
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class ConfigReader {
    private static final Pattern             LINE_PATTERN = Pattern.compile( strv );
    private static final Map<, Object> DEFAULTS     = new HashMap<, Object>() {{
        put( strv, false );
        put( strv, false );
    }};
 
    public static void main( final [] args ) {
        .out.println( parseFile( args[ 0 ] ) );
    }
 
    public static Map<, Object> parseFile( final  fileName ) {
        final Map<, Object> result = new HashMap<, Object>( DEFAULTS );
        /*v*/       reader = null;
 
        try {
            reader = new ( new ( fileName ) );
            for (  line; null != ( line = reader.readLine() );  ) {
                parseLine( line, result );
            }
        } catch ( final  x ) {
            throw new ( strv + x, x );
        } finally {
            if ( null != reader ) try {
                reader.close();
            } catch ( final  x2 ) {
                .err.println( strv + fileName + strv + x2 );
            }
        }
 
        return result;
    }
 
    private static void parseLine( final  line, final Map<, Object> map ) {
        if ( strv.equals( line.trim() ) || line.startsWith( strv ) || line.startsWith( strv ) )
            return;
 
        final Matcher matcher = LINE_PATTERN.matcher( line );
 
        if ( ! matcher.matches() ) {
            .err.println( strv + line );
            return;
        }
 
        final  key   = matcher.group( 1 ).trim().toLowerCase();
        final  value = matcher.group( 2 ).trim();
 
        if ( strv.equals( value ) ) {
            map.put( key, true );
        } else if ( -1 == value.indexOf( ',' ) ) {
            map.put( key, value );
        } else {
            final [] values = value.split( strv );
 
            for ( int i = 0; i < values.length; i++ ) {
                values[ i ] = values[ i ].trim();
            }
            map.put( key, .asList( values ) );
        }
    }
}"
"import java.util.*;
 
public class RankingMethods {
 
    final static [] input = {strv, strv, strv,
        strv, strv, strv, strv};
 
    public static void main([] args) {
        int len = input.length;
 
        Map<, int[]> map = new TreeMap<>((a, b) -> b.compareTo(a));
        for (int i = 0; i < len; i++) {
             key = input[i].split(""s+"")[0];
            int[] arr;
            if ((arr = map.get(key)) == null)
                arr = new int[]{i, 0};
            arr[1]++;
            map.put(key, arr);
        }
        int[][] groups = map.values().toArray(new int[map.size()][]);
 
        standardRanking(len, groups);
        modifiedRanking(len, groups);
        denseRanking(len, groups);
        ordinalRanking(len);
        fractionalRanking(len, groups);
    }
 
    private static void standardRanking(int len, int[][] groups) {
        .out.println(""Standard ranking"");
        for (int i = 0, rank = 0, group = 0; i < len; i++) {
            if (group < groups.length && i == groups[group][0]) {
                rank = i + 1;
                group++;
            }
            .out.printf(strv, rank, input[i]);
        }
    }
 
    private static void modifiedRanking(int len, int[][] groups) {
        .out.println(""Modified ranking"");
        for (int i = 0, rank = 0, group = 0; i < len; i++) {
            if (group < groups.length && i == groups[group][0])
                rank += groups[group++][1];
            .out.printf(strv, rank, input[i]);
        }
    }
 
    private static void denseRanking(int len, int[][] groups) {
        .out.println(""Dense ranking"");
        for (int i = 0, rank = 0; i < len; i++) {
            if (rank < groups.length && i == groups[rank][0])
                rank++;
            .out.printf(strv, rank, input[i]);
        }
    }
 
    private static void ordinalRanking(int len) {
        .out.println(""Ordinal ranking"");
        for (int i = 0; i < len; i++)
            .out.printf(strv, i + 1, input[i]);
    }
 
    private static void fractionalRanking(int len, int[][] groups) {
        .out.println(""Fractional ranking"");
        float rank = 0;
        for (int i = 0, tmp = 0, group = 0; i < len; i++) {
            if (group < groups.length && i == groups[group][0]) {
                tmp += groups[group++][1];
                rank = (i + 1 + tmp) / 2.0F;
            }
            .out.printf(strv, rank, input[i]);
        }
    }
}"
"public class RangeExtraction {
 
    public static void main([] args) {
        int[] arr = {0, 1, 2, 4, 6, 7, 8, 11, 12, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
            25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
            37, 38, 39};
 
        int len = arr.length;
        int idx = 0, idx2 = 0;
        while (idx < len) {
            while (++idx2 < len && arr[idx2] - arr[idx2 - 1] == 1);
            if (idx2 - idx > 2) {
                .out.printf(strv, arr[idx], arr[idx2 - 1]);
                idx = idx2;
            } else {
                for (; idx < idx2; idx++)
                    .out.printf(strv, arr[idx]);
            }
        }
    }
}"
"import java.util.*;
 
class RangeExpander implements Iterator<Integer>, Iterable<Integer> {
 
    private static final Pattern TOKEN_PATTERN = Pattern.compile(""([+-]?d+)-([+-]?d+)"");
 
    private final Iterator<String> tokensIterator;
 
    private boolean inRange;
    private int upperRangeEndpoint;
    private int nextRangeValue;
 
    public RangeExpander( range) {
        [] tokens = range.split(""s*,s*"");
        this.tokensIterator = .asList(tokens).iterator();
    }
 
    @Override
    public boolean hasNext() {
        return hasNextRangeValue() || this.tokensIterator.hasNext();
    }
 
    private boolean hasNextRangeValue() {
        return this.inRange && this.nextRangeValue <= this.upperRangeEndpoint;
    }
 
    @Override
    public  next() {
        if (!hasNext()) {
            throw new ();
        }
 
        if (hasNextRangeValue()) {
            return this.nextRangeValue++;
        }
 
         token = this.tokensIterator.next();
 
        Matcher matcher = TOKEN_PATTERN.matcher(token);
        if (matcher.find()) {
            this.inRange = true;
            this.upperRangeEndpoint = .valueOf(matcher.group(2));
            this.nextRangeValue = .valueOf(matcher.group(1));
            return this.nextRangeValue++;
        }
 
        this.inRange = false;
        return .valueOf(token);
    }
 
    @Override
    public Iterator<Integer> iterator() {
        return this;
    }
 
}
 
class RangeExpanderTest {
    public static void main([] args) {
        RangeExpander re = new RangeExpander(strv);
        for (int i : re) {
            .out.print(i + strv);
        }
    }
}"
"import java.security.SecureRandom;
 
public class RandomExample {
  public static void main([] args) {
     rng = new ();
 
    /* Prints a random signed 32-bit integer. */
    .out.println(rng.nextInt());
  }
}"
"package railwaycircuit;
 
import static java.util..stream;
import java.util.*;
import static java.util.stream.IntStream.range;
 
public class RailwayCircuit {
    final static int RIGHT = 1, LEFT = -1, STRAIGHT = 0;
 
    static  normalize(int[] tracks) {
        char[] a = new char[tracks.length];
        for (int i = 0; i < a.length; i++)
            a[i] = strv.charAt(tracks[i] + 1);
 
        /* Rotate the array and find the lexicographically lowest order        to allow the hashmap to weed out duplicate solutions. */
         norm = new (a);
        for (int i = 0, len = a.length; i < len; i++) {
 
             s = new (a);
            if (s.compareTo(norm) < 0)
                norm = s;
 
            char tmp = a[0];
            for (int j = 1; j < a.length; j++)
                a[j - 1] = a[j];
            a[len - 1] = tmp;
        }
        return norm;
    }
 
    static boolean fullCircleStraight(int[] tracks, int nStraight) {
        if (nStraight == 0)
            return true;
 
        

        if (stream(tracks).filter(i -> i == STRAIGHT).count() != nStraight)
            return false;
 
        

        int[] straight = new int[12];
        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {
            if (tracks[i] == STRAIGHT)
                straight[idx % 12]++;
            idx += tracks[i];
        }
 
        return !(range(0, 6).anyMatch(i -> straight[i] != straight[i + 6])
                && range(0, 8).anyMatch(i -> straight[i] != straight[i + 4]));
    }
 
    static boolean fullCircleRight(int[] tracks) {
 
        

        if (stream(tracks).map(i -> i * 30).sum() % 360 != 0)
            return false;
 
        

        int[] rTurns = new int[12];
        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {
            if (tracks[i] == RIGHT)
                rTurns[idx % 12]++;
            idx += tracks[i];
        }
 
        return !(range(0, 6).anyMatch(i -> rTurns[i] != rTurns[i + 6])
                && range(0, 8).anyMatch(i -> rTurns[i] != rTurns[i + 4]));
    }
 
    static void circuits(int nCurved, int nStraight) {
        Map<, int[]> solutions = new HashMap<>();
 
        PermutationsGen gen = getPermutationsGen(nCurved, nStraight);
        while (gen.hasNext()) {
 
            int[] tracks = gen.next();
 
            if (!fullCircleStraight(tracks, nStraight))
                continue;
 
            if (!fullCircleRight(tracks))
                continue;
 
            solutions.put(normalize(tracks), tracks.clone());
        }
        report(solutions, nCurved, nStraight);
    }
 
    static PermutationsGen getPermutationsGen(int nCurved, int nStraight) {
        assert (nCurved + nStraight - 12) % 4 == 0 : strv;
 
        int[] trackTypes = new int[]{RIGHT, LEFT};
 
        if (nStraight != 0) {
            if (nCurved == 12)
                trackTypes = new int[]{RIGHT, STRAIGHT};
            else
                trackTypes = new int[]{RIGHT, LEFT, STRAIGHT};
        }
 
        return new PermutationsGen(nCurved + nStraight, trackTypes);
    }
 
    static void report(Map<, int[]> sol, int numC, int numS) {
 
        int size = sol.size();
        .out.printf(strv, size, numC, numS);
 
        if (size < 10)
            sol.values().stream().forEach(tracks -> {
                stream(tracks).forEach(i -> .out.printf(strv, i));
                .out.println();
            });
    }
 
    public static void main([] args) {
        circuits(12, 0);
        circuits(16, 0);
        circuits(20, 0);
        circuits(24, 0);
        circuits(12, 4);
    }
}
 
class PermutationsGen {
    

    private int[] indices;
    private int[] choices;
    private int[] sequence;
    private int carry;
 
    PermutationsGen(int numPositions, int[] choices) {
        indices = new int[numPositions];
        sequence = new int[numPositions];
        this.choices = choices;
    }
 
    int[] next() {
        carry = 1;
        /* The generator skips the first index, so the result will always start        with a right turn (0) and we avoid clockwise/counter-clockwise        duplicate solutions. */
        for (int i = 1; i < indices.length && carry > 0; i++) {
            indices[i] += carry;
            carry = 0;
 
            if (indices[i] == choices.length) {
                carry = 1;
                indices[i] = 0;
            }
        }
 
        for (int i = 0; i < indices.length; i++)
            sequence[i] = choices[indices[i]];
 
        return sequence;
    }
 
    boolean hasNext() {
        return carry != 1;
    }
}"
"import java.util.Arrays;
import java.util.stream.IntStream;
 
public class RamseysTheorem {
 
    static char[][] createMatrix() {
         r = strv + .toBinaryString(53643);
        int len = r.length();
        return IntStream.range(0, len)
                .mapToObj(i -> r.substring(len - i) + r.substring(0, len - i))
                .map(::toCharArray)
                .toArray(char[][]::new);
    }
 
    /**     * Check that every clique of four has at least one pair connected and one     * pair unconnected. It requires a symmetric matrix.     */
    static  ramseyCheck(char[][] mat) {
        int len = mat.length;
        char[] connectivity = strv.toCharArray();
 
        for (int a = 0; a < len; a++) {
            for (int b = 0; b < len; b++) {
                if (a == b)
                    continue;
                connectivity[0] = mat[a][b];
                for (int c = 0; c < len; c++) {
                    if (a == c || b == c)
                        continue;
                    connectivity[1] = mat[a][c];
                    connectivity[2] = mat[b][c];
                    for (int d = 0; d < len; d++) {
                        if (a == d || b == d || c == d)
                            continue;
                        connectivity[3] = mat[a][d];
                        connectivity[4] = mat[b][d];
                        connectivity[5] = mat[c][d];
 
                        

                        

                         conn = new (connectivity);
                        if (conn.indexOf('0') == -1)
                            return .format(strv
                                    + strv, a, b, c, d);
                        else if (conn.indexOf('1') == -1)
                            return .format(strv
                                    + strv, a, b, c, d);
                    }
                }
            }
        }
        return strv;
    }
 
    public static void main([] a) {
        char[][] mat = createMatrix();
        for (char[] s : mat)
            .out.println(.toString(s));
        .out.println(ramseyCheck(mat));
    }
}"
"double[] list = new double[1000];
double mean = 1.0, std = 0.5;
 rng = new ();
for(int i = 0;i<list.length;i++) {
  list[i] = mean + std * rng.nextGaussian();
}"
"class S{public static void main([]a){ s=strv;char c=34;.out.println(s.substring(0,52)+c+s+c+s.substring(52));}}class S{public static void main([]a){ p=strv;.out.printf(p,34,p);}}"
"import java.util.Random;
 
public class QuickSelect {
 
	private static <E extends Comparable<? super E>> int partition(E[] arr, int left, int right, int pivot) {
		E pivotVal = arr[pivot];
		swap(arr, pivot, right);
		int storeIndex = left;
		for (int i = left; i < right; i++) {
			if (arr[i].compareTo(pivotVal) < 0) {
				swap(arr, i, storeIndex);
				storeIndex++;
			}
		}
		swap(arr, right, storeIndex);
		return storeIndex;
	}
 
	private static <E extends Comparable<? super E>> E select(E[] arr, int n) {
		int left = 0;
		int right = arr.length - 1;
		 rand = new ();
		while (right >= left) {
			int pivotIndex = partition(arr, left, right, rand.nextInt(right - left + 1) + left);
			if (pivotIndex == n) {
				return arr[pivotIndex];
			} else if (pivotIndex < n) {
				left = pivotIndex + 1;
			} else {
				right = pivotIndex - 1;
			}
		}
		return null;
	}
 
	private static void swap([] arr, int i1, int i2) {
		if (i1 != i2) {
			 temp = arr[i1];
			arr[i1] = arr[i2];
			arr[i2] = temp;
		}
	}
 
	public static void main([] args) {
		for (int i = 0; i < 10; i++) {
			[] input = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};
			.out.print(select(input, i));
			if (i < 9) .out.print(strv);
		}
		.out.println();
	}
 
}"
"import java.util.LinkedList;
import java.util.Queue;
...
Queue<Integer> queue = new LinkedList<Integer>();
.out.println(queue.isEmpty());      



queue.add(1);
queue.add(2);
queue.add(3);
.out.println(queue);                

.out.println(queue.remove());       

.out.println(queue);                

.out.println(queue.isEmpty());      
import java.util.LinkedList;
...
 queue = new ();
.out.println(queue.isEmpty());      

queue.add(new (1));
queue.add(new (2));
queue.add(new (3));
.out.println(queue);                

.out.println(queue.removeFirst());  

.out.println(queue);                

.out.println(queue.isEmpty());      
"
"public class Queue<E>{
    Node<E> head = null, tail = null;
 
    static class Node<E>{
        E value;
        Node<E> next;
 
        Node(E value, Node<E> next){
            this.value= value;
            this.next= next;
        }
 
    }
 
    public Queue(){
    }
 
    public void enqueue(E value){ //standard queue name for strv
        Node<E> newNode= new Node<E>(value, null);
        if(empty()){
            head= newNode;
        }else{
            tail.next = newNode;
        }
        tail= newNode;
    }
 
    public E dequeue() throws java.util.{//standard queue name for strv
        if(empty()){
            throw new java.util.(strv);
        }
        E retVal= head.value;
        head= head.next;
        return retVal;
    } 
 
    public boolean empty(){
        return head == null;
    }
}"
"import java.awt.*;
import java.awt.geom.Path2D;
import javax.swing.*;
 
public class PythagorasTree extends  {
    final int depthLimit = 7;
    float hue = 0.15f;
 
    public PythagorasTree() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
    }
 
    private void drawTree( g, float x1, float y1, float x2, float y2,
            int depth) {
 
        if (depth == depthLimit)
            return;
 
        float dx = x2 - x1;
        float dy = y1 - y2;
 
        float x3 = x2 - dy;
        float y3 = y2 - dx;
        float x4 = x1 - dy;
        float y4 = y1 - dx;
        float x5 = x4 + 0.5F * (dx - dy);
        float y5 = y4 - 0.5F * (dx + dy);
 
        Path2D square = new Path2D.();
        square.moveTo(x1, y1);
        square.lineTo(x2, y2);
        square.lineTo(x3, y3);
        square.lineTo(x4, y4);
        square.closePath();
 
        g.setColor(.getHSBColor(hue + depth * 0.02f, 1, 1));
        g.fill(square);
        g.setColor(.lightGray);
        g.draw(square);
 
        Path2D triangle = new Path2D.();
        triangle.moveTo(x3, y3);
        triangle.lineTo(x4, y4);
        triangle.lineTo(x5, y5);
        triangle.closePath();
 
        g.setColor(.getHSBColor(hue + depth * 0.035f, 1, 1));
        g.fill(triangle);
        g.setColor(.lightGray);
        g.draw(triangle);
 
        drawTree(g, x4, y4, x5, y5, depth + 1);
        drawTree(g, x5, y5, x3, y3, depth + 1);
    }
 
    @Override
    public void paintComponent( g) {
        super.paintComponent(g);
        drawTree(() g, 275, 500, 375, 500, 0);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new PythagorasTree(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}void tree(float x1, float y1, float x2, float y2, int depth) {
 
  if (depth <= 0) {
    return;
  }
 
  float dx = (x2 - x1);
  float dy = (y1 - y2);
 
  float x3 = (x2 - dy);
  float y3 = (y2 - dx);
  float x4 = (x1 - dy);
  float y4 = (y1 - dx);
  float x5 = (x4 + 0.5*(dx - dy));
  float y5 = (y4 - 0.5*(dx + dy));
 
  

  beginShape();
  fill(0.0, 255.0/depth, 0.0);
  vertex(x1, y1);
  vertex(x2, y2);
  vertex(x3, y3);
  vertex(x4, y4);
  vertex(x1, y1);
  endShape();
 
  

  beginShape();
  fill(0.0, 255.0/depth, 0.0);
  vertex(x3, y3);
  vertex(x4, y4);
  vertex(x5, y5);
  vertex(x3, y3);
  endShape();
 
  tree(x4, y4, x5, y5, depth-1);
  tree(x5, y5, x3, y3, depth-1);
}  
 
void setup() {
  size(1920, 1080);
  background(255);
  stroke(0, 255, 0);
  tree(width/2.3, height, width/1.8, height, 10);
}"
" 
import java.math.BigInteger;
import static java.math..ONE;
 
public class PythTrip{
 
    public static void main([] args){
        long tripCount = 0, primCount = 0;
 
        //change this to whatever perimeter limit you want;the RAM's the limit
         periLimit = .valueOf(100),
                peri2 = periLimit.divide(.valueOf(2)),
                peri3 = periLimit.divide(.valueOf(3));
 
        for( a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){
             aa = a.multiply(a);
 
            for( b = a.add(ONE);
                    b.compareTo(peri2) < 0; b = b.add(ONE)){
                 bb = b.multiply(b);
                 ab = a.add(b);
                 aabb = aa.add(bb);
 
                for( c = b.add(ONE);
                        c.compareTo(peri2) < 0; c = c.add(ONE)){
 
                    int compare = aabb.compareTo(c.multiply(c));
                    //if a+b+c > periLimit
                    if(ab.add(c).compareTo(periLimit) > 0){
                        break;
                    }
                    //if a^2 + b^2 != c^2
                    if(compare < 0){
                        break;
                    }else if (compare == 0){
                        tripCount++;
                        .out.print(a + strv + b + strv + c);
 
                        //does binary GCD under the hood
                        if(a.gcd(b).equals(ONE)){
                            .out.print(strv);
                            primCount++;
                        }
                        .out.println();
                    }
                }
            }
        }
        .out.println(strv + periLimit + strv
                + tripCount + strv + primCount + strv);
    }
}"
"if(problem){
   .exit(integerErrorCode); 
   //conventionally, error code 0 is the code for strv,
   

   //optionally: Runtime.getRuntime().exit(integerErrorCode);
}if(problem){
   .getRuntime().halt(integerErrorCode); 
   //conventionally, error code 0 is the code for strv,
   

}"
"public class Quaternion {
    private final double a, b, c, d;
 
    public Quaternion(double a, double b, double c, double d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
    public Quaternion(double r) {
        this(r, 0.0, 0.0, 0.0);
    }
 
    public double norm() {
        return .sqrt(a * a + b * b + c * c + d * d);
    }
 
    public Quaternion negative() {
        return new Quaternion(-a, -b, -c, -d);
    }
 
    public Quaternion conjugate() {
        return new Quaternion(a, -b, -c, -d);
    }
 
    public Quaternion add(double r) {
        return new Quaternion(a + r, b, c, d);
    }
    public static Quaternion add(Quaternion q, double r) {
        return q.add(r);
    }
    public static Quaternion add(double r, Quaternion q) {
        return q.add(r);
    }
    public Quaternion add(Quaternion q) {
        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);
    }
    public static Quaternion add(Quaternion q1, Quaternion q2) {
        return q1.add(q2);
    }
 
    public Quaternion times(double r) {
        return new Quaternion(a * r, b * r, c * r, d * r);
    }
    public static Quaternion times(Quaternion q, double r) {
        return q.times(r);
    }
    public static Quaternion times(double r, Quaternion q) {
        return q.times(r);
    }
    public Quaternion times(Quaternion q) {
        return new Quaternion(
            a * q.a - b * q.b - c * q.c - d * q.d,
            a * q.b + b * q.a + c * q.d - d * q.c,
            a * q.c - b * q.d + c * q.a + d * q.b,
            a * q.d + b * q.c - c * q.b + d * q.a
        );
    }
    public static Quaternion times(Quaternion q1, Quaternion q2) {
        return q1.times(q2);
    }
 
    @Override
    public boolean equals( obj) {
        if (!(obj instanceof Quaternion)) return false;
        final Quaternion other = (Quaternion) obj;
        if (.doubleToLongBits(this.a) != .doubleToLongBits(other.a)) return false;
        if (.doubleToLongBits(this.b) != .doubleToLongBits(other.b)) return false;
        if (.doubleToLongBits(this.c) != .doubleToLongBits(other.c)) return false;
        if (.doubleToLongBits(this.d) != .doubleToLongBits(other.d)) return false;
        return true;
    }
    @Override
    public  toString() {
        return .format(strv, a, b, c, d).replaceAll(""+ -"", strv);
    }
 
    public  toQuadruple() {
        return .format(strv, a, b, c, d);
    }
 
    public static void main([] args) {
        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);
        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);
        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);
        double r = 7.0;
        .out.format(strv, q);
        .out.format(strv, q1);
        .out.format(strv, q2);
        .out.format(strv, r);
        .out.format(""2016q2016     = %.2f%n"", q.norm());
        .out.format(strv, q.negative());
        .out.format(strv, q.conjugate());
        .out.format(strv, q.add(r));
        .out.format(strv, q1.add(q2));
        .out.format(""q 00d7 r   = %s%n"", q.times(r));
        Quaternion q1q2 = q1.times(q2);
        Quaternion q2q1 = q2.times(q1);
        .out.format(""q1 00d7 q2 = %s%n"", q1q2);
        .out.format(""q2 00d7 q1 = %s%n"", q2q1);
        .out.format(""q1 00d7 q2 %s q2 00d7 q1%n"", (q1q2.equals(q2q1) ? strv : ""2260""));
    }
}"
"public class ScriptName {
	public static void main([] args) {
		 program = .getProperty(strv).split(strv)[0];
		.out.println(strv + program);
	}
}public class ScriptName {
	public static void main([] args) {
		Class c = new (){}.getClass().getEnclosingClass();
		.out.println(strv + c.getName());
	}
}public class ScriptName {
	public static void main([] args) {
		Class c = .getSecurityManager().getClassContext()[0];
		.out.println(strv + c.getName());
	}
}public class ScriptName {
	public static void main([] args) {
		 program = .currentThread().getStackTrace()[1].getClassName();
		.out.println(strv + program);
	}
}"
"public class Prob{
	static long TRIALS= 1000000;
 
	private static class Expv{
		public  name;
		public int probcount;
		public double expect;
		public double mapping;
 
		public Expv( name, int probcount, double expect, double mapping){
			this.name= name;
			this.probcount= probcount;
			this.expect= expect;
			this.mapping= mapping;
		}
	}
 
	static Expv[] items=
			{new Expv(strv, 0, 0.0, 0.0), new Expv(strv, 0, 0.0, 0.0),
					new Expv(strv, 0, 0.0, 0.0),
					new Expv(strv, 0, 0.0, 0.0),
					new Expv(strv, 0, 0.0, 0.0), new Expv(strv, 0, 0.0, 0.0),
					new Expv(strv, 0, 0.0, 0.0),
					new Expv(strv, 0, 0.0, 0.0)};
 
	public static void main([] args){
		int i, j;
		double rnum, tsum= 0.0;
 
		for(i= 0, rnum= 5.0;i < 7;i++, rnum+= 1.0){
			items[i].expect= 1.0 / rnum;
			tsum+= items[i].expect;
		}
		items[7].expect= 1.0 - tsum;
 
		items[0].mapping= 1.0 / 5.0;
		for(i= 1;i < 7;i++){
			items[i].mapping= items[i - 1].mapping + 1.0 / ((double)i + 5.0);
		}
		items[7].mapping= 1.0;
 
 
		for(i= 0;i < TRIALS;i++){
			rnum= .random();
			for(j= 0;j < 8;j++){
				if(rnum < items[j].mapping){
					items[j].probcount++;
					break;
				}
			}
		}
 
		.out.printf(""Trials: %d"", TRIALS);
		.out.printf(strv);
		for(i= 0;i < 8;i++)
			.out.printf(strv, items[i].name);
		.out.printf(""Target prob.:   "");
		for(i= 0;i < 8;i++)
			.out.printf(strv, items[i].expect);
		.out.printf(""Attained prob.: "");
		for(i= 0;i < 8;i++)
			.out.printf(strv, (double)(items[i].probcount)
					/ (double)TRIALS);
		.out.printf("""");
 
	}
}"
"public class Circle
{
 public double[] center;
 public double radius;
 public Circle(double[] center, double radius)
 {
  this.center = center;
  this.radius = radius;
 }
 public  toString()
 {
  return .format(strv,center[0],center[1],
		       radius);
 }
}
 
public class ApolloniusSolver
{
/** Solves the Problem of Apollonius (finding a circle tangent to three other  * circles in the plane). The method uses approximately 68 heavy operations  * (multiplication, division, square-roots).   * @param c1 One of the circles in the problem  * @param c2 One of the circles in the problem  * @param c3 One of the circles in the problem  * @param s1 An indication if the solution should be externally or internally  *           tangent (+1/-1) to c1  * @param s2 An indication if the solution should be externally or internally  *           tangent (+1/-1) to c2  * @param s3 An indication if the solution should be externally or internally  *           tangent (+1/-1) to c3  * @return The circle that is tangent to c1, c2 and c3.   */
 public static Circle solveApollonius(Circle c1, Circle c2, Circle c3, int s1,
				      int s2, int s3)
 {
  float x1 = c1.center[0];
  float y1 = c1.center[1];
  float r1 = c1.radius;
  float x2 = c2.center[0];
  float y2 = c2.center[1];
  float r2 = c2.radius;
  float x3 = c3.center[0];
  float y3 = c3.center[1];
  float r3 = c3.radius;
 
  //Currently optimized for fewest multiplications. Should be optimized for
  //readability
  float v11 = 2*x2 - 2*x1;
  float v12 = 2*y2 - 2*y1;
  float v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2;
  float v14 = 2*s2*r2 - 2*s1*r1;
 
  float v21 = 2*x3 - 2*x2;
  float v22 = 2*y3 - 2*y2;
  float v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3;
  float v24 = 2*s3*r3 - 2*s2*r2;
 
  float w12 = v12/v11;
  float w13 = v13/v11;
  float w14 = v14/v11;
 
  float w22 = v22/v21-w12;
  float w23 = v23/v21-w13;
  float w24 = v24/v21-w14;
 
  float P = -w23/w22;
  float Q = w24/w22;
  float M = -w12*P-w13;
  float N = w14 - w12*Q;
 
  float a = N*N + Q*Q - 1;
  float b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1;
  float c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1;
 
  

  

  float D = b*b-4*a*c;
  float rs = (-b-.sqrt(D))/(2*a);
  float xs = M + N * rs;
  float ys = P + Q * rs;
  return new Circle(new double[]{xs,ys}, rs);
 }
 public static void main(final [] args)
 {
  Circle c1 = new Circle(new double[]{0,0}, 1);
  Circle c2 = new Circle(new double[]{4,0}, 1);
  Circle c3 = new Circle(new double[]{2,4}, 2);
  

  .out.println(solveApollonius(c1,c2,c3,1,1,1));
  

  .out.println(solveApollonius(c1,c2,c3,-1,-1,-1));
 }
}"
"import java.math.BigInteger;
 
public class PrimorialNumbers {
    final static int sieveLimit = 1300_000;
    static boolean[] notPrime = sieve(sieveLimit);
 
    public static void main([] args) {
        for (int i = 0; i < 10; i++)
            .out.printf(strv, i, primorial(i));
 
        for (int i = 1; i < 6; i++) {
            int len = primorial((int) .pow(10, i)).toString().length();
            .out.printf(strv, i, len);
        }
    }
 
    static  primorial(int n) {
        if (n == 0)
            return .ONE;
 
         result = .ONE;
        for (int i = 0; i < sieveLimit && n > 0; i++) {
            if (notPrime[i])
                continue;
            result = result.multiply(.valueOf(i));
            n--;
        }
        return result;
    }
 
    public static boolean[] sieve(int limit) {
        boolean[] composite = new boolean[limit];
        composite[0] = composite[1] = true;
 
        int max = (int) .sqrt(limit);
        for (int n = 2; n <= max; n++) {
            if (!composite[n]) {
                for (int k = n * n; k < limit; k += n) {
                    composite[k] = true;
                }
            }
        }
        return composite;
    }
}"
"import java.util.PriorityQueue;
 
class Task implements Comparable<Task> {
    final int priority;
    final  name;
 
    public Task(int p,  n) {
        priority = p;
        name = n;
    }
 
    public  toString() {
        return priority + strv + name;
    }
 
    public int compareTo(Task other) {
        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;
    }
 
    public static void main([] args) {
        PriorityQueue<Task> pq = new PriorityQueue<Task>();
        pq.add(new Task(3, strv));
        pq.add(new Task(4, strv));
        pq.add(new Task(5, strv));
        pq.add(new Task(1, strv));
        pq.add(new Task(2, strv));
 
        while (!pq.isEmpty())
            .out.println(pq.remove());
    }
}"
"public class PrimeConspiracy {
 
    public static void main([] args) {
        final int limit = 1000_000;
        final int sieveLimit = 15_500_000;
 
        int[][] buckets = new int[10][10];
        int prevDigit = 2;
        boolean[] notPrime = sieve(sieveLimit);
 
        for (int n = 3, primeCount = 1; primeCount < limit; n++) {
            if (notPrime[n])
                continue;
 
            int digit = n % 10;
            buckets[prevDigit][digit]++;
            prevDigit = digit;
            primeCount++;
        }
 
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (buckets[i][j] != 0) {
                    .out.printf(strv, i,
                            j, buckets[i][j] / (limit / 100.0));
                }
            }
        }
    }
 
    public static boolean[] sieve(int limit) {
        boolean[] composite = new boolean[limit];
        composite[0] = composite[1] = true;
 
        int max = (int) .sqrt(limit);
        for (int n = 2; n <= max; n++) {
            if (!composite[n]) {
                for (int k = n * n; k < limit; k += n) {
                    composite[k] = true;
                }
            }
        }
        return composite;
    }
}"
"public boolean prime( i);public static List<BigInteger> primeFactorBig( a){
    List<BigInteger> ans = new LinkedList<BigInteger>();
    //loop until we test the number itself or the number is 1
    for ( i = .valueOf(2); i.compareTo(a) <= 0 && !a.equals(.ONE);
         i = i.add(.ONE)){
        while (a.remainder(i).equals(.ZERO) && prime(i)) { //if we have a prime factor
            ans.add(i); //put it in the list
            a = a.divide(i); //factor it out of the number
        }
    }
    return ans;
}private static final  two = .valueOf(2);
 
public List<BigInteger> primeDecomp( a) {
    

    if (a.compareTo(two) < 0) {
        return null; 
    }
 
    //quickly handle even values
    List<BigInteger> result = new ArrayList<BigInteger>();
    while (a.and(.ONE).equals(.ZERO)) {
        a = a.shiftRight(1);
        result.add(two);
    }
 
    //left with odd values
    if (!a.equals(.ONE)) {
         b = .valueOf(3);
        while (b.compareTo(a) < 0) {
            if (b.isProbablePrime(10)) {
                [] dr = a.divideAndRemainder(b);
                if (dr[1].equals(.ZERO)) {
                    result.add(b);
                    a = dr[0];
                }
            }
            b = b.add(two);
        }
        result.add(b); //b will always be prime here...
    }
    return result;
} 
private static final  TWO = .valueOf(2);
private static final  THREE = .valueOf(3);
private static final  FIVE = .valueOf(5);
 
public static ArrayList<BigInteger> primeDecomp( n){
	if(n.compareTo(TWO) < 0) return null;
	ArrayList<BigInteger> factors = new ArrayList<BigInteger>();
 
	

	while(n.and(.ONE).equals(.ZERO)){
		n = n.shiftRight(1);
		factors.add(TWO);
	}
 
	

	while(n.mod(THREE).equals(.ZERO)){
		factors.add(THREE);
		n = n.divide(THREE);
	}
 
	

	while(n.mod(FIVE).equals(.ZERO)){
		factors.add(FIVE);
		n = n.divide(FIVE);
	}
 
	

	

	

	int[] pattern = {4,2,4,2,4,6,2,6};
	int pattern_index = 0;
	 current_test = .valueOf(7);
	while(!n.equals(.ONE)){
		while(n.mod(current_test).equals(.ZERO)){
			factors.add(current_test);
			n = n.divide(current_test);
		}
		current_test = current_test.add(.valueOf(pattern[pattern_index]));
		pattern_index = (pattern_index + 1) & 7;
	}
 
	return factors;
}
 public static List<BigInteger> primeFactorBig( a){
    List<BigInteger> ans = new LinkedList<BigInteger>();
 
    for( divisor = .valueOf(2);
    	a.compareTo(ONE) > 0; divisor = divisor.add(ONE))
		while(a.mod(divisor).equals(ZERO)){
			 ans.add(divisor);
			 a = a.divide(divisor);
		}
    return ans;
}"
"public static boolean prime(long a){
   if(a == 2){
      return true;
   }else if(a <= 1 || a % 2 == 0){
      return false;
   }
   long max = (long).sqrt(a);
   for(long n= 3; n <= max; n+= 2){
      if(a % n == 0){ return false; }
   }
   return true;
}public static boolean prime(int n) {
    return !new (new char[n]).matches("".?|(..+?)1+"");
}"
"import java.util.Random;
 
public class Main {
	private static float priceFraction(float f) {
		if (0.00f <= f && f < 0.06f) return 0.10f;
		else if (f < 0.11f) return 0.18f;
		else if (f < 0.16f) return 0.26f;
		else if (f < 0.21f) return 0.32f;
		else if (f < 0.26f) return 0.38f;
		else if (f < 0.31f) return 0.44f;
		else if (f < 0.36f) return 0.50f;
		else if (f < 0.41f) return 0.54f;
		else if (f < 0.46f) return 0.58f;
		else if (f < 0.51f) return 0.62f;
		else if (f < 0.56f) return 0.66f;
		else if (f < 0.61f) return 0.70f;
		else if (f < 0.66f) return 0.74f;
		else if (f < 0.71f) return 0.78f;
		else if (f < 0.76f) return 0.82f;
		else if (f < 0.81f) return 0.86f;
		else if (f < 0.86f) return 0.90f;
		else if (f < 0.91f) return 0.94f;
		else if (f < 0.96f) return 0.98f;
		else if (f < 1.01f) return 1.00f;
		else throw new ();
	}
 
	public static void main([] args) {
		 rnd = new ();
		for (int i = 0; i < 5; i++) {
			float f = rnd.nextFloat();
			.out.format(strv, f, priceFraction(f));
		}
	}
}"
"import java.util.Arrays;
 
public class Test {
 
    public static void main([] args) {
        int[] N = {1, -12, 0, -42};
        int[] D = {1, -3};
 
        .out.printf(strv,
                .toString(N),
                .toString(D),
                .deepToString(extendedSyntheticDivision(N, D)));
    }
 
    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {
        int[] out = dividend.clone();
        int normalizer = divisor[0];
 
        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {
            out[i] /= normalizer;
 
            int coef = out[i];
            if (coef != 0) {
                for (int j = 1; j < divisor.length; j++)
                    out[i + j] += -divisor[j] * coef;
            }
        }
 
        int separator = out.length - (divisor.length - 1);
 
        return new int[][]{
            .copyOfRange(out, 0, separator),
            .copyOfRange(out, separator, out.length)
        };
    }
}"
"import java.math.BigInteger;
 
public class PopCount {
    public static void main([] args) {
	{ 

	    .out.print(strv);
	    int n = 1;
	    for (int i = 0; i < 20; i++) {
		.out.printf(strv, .bitCount(n));
		n *= 3;
	    }
	    .out.println();
	}
	{ 

	    .out.print(strv);
	    long n = 1;
	    for (int i = 0; i < 30; i++) {
		.out.printf(strv, .bitCount(n));
		n *= 3;
	    }
	    .out.println();
	}
	{ 

	    .out.print(strv);
	     n = .ONE;
	     three = .valueOf(3);
	    for (int i = 0; i < 30; i++) {
		.out.printf(strv, n.bitCount());
		n = n.multiply(three);
	    }
	    .out.println();
	}
 
	int[] od = new int[30];
	int ne = 0, no = 0;
	.out.print(strv);
	for (int n = 0; ne+no < 60; n++) {
	    if ((.bitCount(n) & 1) == 0) {
		if (ne < 30) {
		    .out.printf(strv, n);
		    ne++;
		}
	    } else {
		if (no < 30) {
		    od[no++] = n;
		}
	    }
	}
	.out.println();
	.out.print(strv);
	for (int n : od) {
	    .out.printf(strv, n);
	}
	.out.println();
    }
}"
"import java.awt.*;
import java.awt.event.ActionEvent;
import javax.swing.*;
 
public class PolySpiral extends  {
    double inc = 0;
 
    public PolySpiral() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
 
        new (40, ( e) -> {
            inc = (inc + 0.05) % 360;
            repaint();
        }).start();
    }
 
    void drawSpiral( g, int len, double angleIncrement) {
 
        double x1 = getWidth() / 2;
        double y1 = getHeight() / 2;
        double angle = angleIncrement;
 
        for (int i = 0; i < 150; i++) {
 
            g.setColor(.getHSBColor(i / 150f, 1.0f, 1.0f));
 
            double x2 = x1 + .cos(angle) * len;
            double y2 = y1 - .sin(angle) * len;
            g.drawLine((int) x1, (int) y1, (int) x2, (int) y2);
            x1 = x2;
            y1 = y2;
 
            len += 3;
 
            angle = (angle + angleIncrement) % (.PI * 2);
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawSpiral(g, 5, .toRadians(inc));
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(true);
            f.add(new PolySpiral(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"class  {
   protected int x, y;
   public () { this(0); }
   public (int x) { this(x, 0); }
   public (int x, int y) { this.x = x; this.y = y; }
   public ( p) { this(p.x, p.y); }
   public int getX() { return this.x; }
   public int getY() { return this.y; }
   public void setX(int x) { this.x = x; }
   public void setY(int y) { this.y = y; }
   public void print() { .out.println(strv + this.x + strv + this.y); }
}
 
class Circle extends  {
   private int r;
   public Circle( p) { this(p, 0); }
   public Circle( p, int r) { super(p); this.r = r; }
   public Circle() { this(0); }
   public Circle(int x) { this(x, 0); }
   public Circle(int x, int y) { this(x, y, 0); }
   public Circle(int x, int y, int r) { super(x, y); this.r = r; }
   public Circle(Circle c) { this(c.x, c.y, c.r); }
   public int getR() { return this.r; }
   public void setR(int r) { this.r = r; }
   public void print() { .out.println(strv + this.x + strv + this.y + strv + this.r); }
}
 
public class test {
  public static void main( args[]) {
     p = new ();
     c = new Circle();
    p.print();
    c.print();     
  }
}"
"class T implements  {
    public  name() { return strv; }
    public T copy() {
        try {
            return (T)super.clone();
        } catch ( e) {
            return null;
        }
    }
}
 
class S extends T {
    public  name() { return strv; }
}
 
public class PolymorphicCopy {
    public static T copier(T x) { return x.copy(); }
    public static void main([] args) {
        T obj1 = new T();
        S obj2 = new S();
        .out.println(copier(obj1).name()); 

        .out.println(copier(obj2).name()); 

    }
}"
" public class Foo { public int x = 0; }
 
 void somefunction() {
     Foo a; 

     a = new Foo(); 

     Foo b = a; 

     a.x = 5; 

     .out.println(b.x); 

 }"
"import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
 
public class PokerHandAnalyzer {
 
    final static  faces = strv;
    final static  suits = strv;
    final static [] deck = buildDeck();
 
    public static void main([] args) {
        .out.println(""Regular hands:"");
        for ( input : new []{strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv}) {
            .out.println(analyzeHand(input.split(strv)));
        }
 
        .out.println(""Hands with wildcards:"");
        for ( input : new []{strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv,
            strv}) {
            .out.println(analyzeHandWithWildcards(input.split(strv)));
        }
    }
 
    private static Score analyzeHand(final [] hand) {
        if (hand.length != 5)
            return new Score(strv, -1, hand);
 
        if (new HashSet<>(.asList(hand)).size() != hand.length)
            return new Score(strv, -1, hand);
 
        int[] faceCount = new int[faces.length()];
        long straight = 0, flush = 0;
        for ( card : hand) {
 
            int face = faces.indexOf(card.charAt(0));
            if (face == -1)
                return new Score(strv, -1, hand);
            straight |= (1 << face);
 
            faceCount[face]++;
 
            if (suits.indexOf(card.charAt(1)) == -1)
                return new Score(strv, -1, hand);
            flush |= (1 << card.charAt(1));
        }
 
        

        while (straight % 2 == 0)
            straight >>= 1;
 
        

        boolean hasStraight = straight == 0b11111 || straight == 0b1111000000001;
 
        

        boolean hasFlush = (flush & (flush - 1)) == 0;
 
        if (hasStraight && hasFlush)
            return new Score(strv, 9, hand);
 
        int total = 0;
        for (int count : faceCount) {
            if (count == 4)
                return new Score(strv, 8, hand);
            if (count == 3)
                total += 3;
            else if (count == 2)
                total += 2;
        }
 
        if (total == 5)
            return new Score(strv, 7, hand);
 
        if (hasFlush)
            return new Score(strv, 6, hand);
 
        if (hasStraight)
            return new Score(strv, 5, hand);
 
        if (total == 3)
            return new Score(strv, 4, hand);
 
        if (total == 4)
            return new Score(strv, 3, hand);
 
        if (total == 2)
            return new Score(strv, 2, hand);
 
        return new Score(strv, 1, hand);
    }
 
    private static WildScore analyzeHandWithWildcards([] hand) {
        if (.frequency(.asList(hand), strv) > 2)
            throw new (strv);
 
        return new WildScore(analyzeHandWithWildcardsR(hand, null), hand.clone());
    }
 
    private static Score analyzeHandWithWildcardsR([] hand,
            Score best) {
 
        for (int i = 0; i < hand.length; i++) {
            if (hand[i].equals(strv)) {
                for ( card : deck) {
                    if (!.asList(hand).contains(card)) {
                        hand[i] = card;
                        best = analyzeHandWithWildcardsR(hand, best);
                    }
                }
                hand[i] = strv;
                break;
            }
        }
        Score result = analyzeHand(hand);
        if (best == null || result.weight > best.weight)
            best = result;
        return best;
    }
 
    private static [] buildDeck() {
        [] dck = new [suits.length() * faces.length()];
        int i = 0;
        for (char s : suits.toCharArray()) {
            for (char f : faces.toCharArray()) {
                dck[i] = strv + f + s;
                i++;
            }
        }
        return dck;
    }
 
    private static class Score {
        final int weight;
        final  name;
        final [] hand;
 
        Score( n, int w, [] h) {
            weight = w;
            name = n;
            hand = h != null ? h.clone() : h;
        }
 
        @Override
        public  toString() {
            return .toString(hand) + strv + name;
        }
    }
 
    private static class WildScore {
        final [] wild;
        final Score score;
 
        WildScore(Score s, [] w) {
            score = s;
            wild = w;
        }
 
        @Override
        public  toString() {
            return .format(strv, .toString(wild),
                    score.toString());
        }
    }
}"
"  import java.awt.*;
  import java.awt.event.*;
  import java.awt.geom.*;
  import javax.swing.JApplet;
  import javax.swing.JFrame;
  public class Plot2d extends  {
    double[] xi;
    double[] yi;
    public Plot2d(double[] x, double[] y) {
        this.xi = x;
        this.yi = y;
    }
    public static double max(double[] t) {
        double maximum = t[0];   
        for (int i = 1; i < t.length; i++) {
            if (t[i] > maximum) {
                maximum = t[i];  
            }
        }
        return maximum;
    }
    public static double min(double[] t) {
        double minimum = t[0];
        for (int i = 1; i < t.length; i++) {
            if (t[i] < minimum) {
                minimum = t[i];
            }
        }
        return minimum;
    }
    public void init() {
        setBackground(.white);
        setForeground(.white);
    }
    public void paint( g) {
         g2 = () g;
        g2.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
        g2.setPaint(.black);
        int x0 = 70;
        int y0 = 10;
        int xm = 670;
        int ym = 410;
        int xspan = xm - x0;
        int yspan = ym - y0;
        double xmax = max(xi);
        double xmin = min(xi);
        double ymax = max(yi);
        double ymin = min(yi);
        g2.draw(new (x0, ym, xm, ym));
        g2.draw(new (x0, ym, x0, y0));
        for (int j = 0; j < 5; j++) {
            int interv = 4;
            g2.drawString(strv + (j * (xmax - xmin) / interv + xmin), j * xspan / interv + x0 - 10, ym + 20);
            g2.drawString(strv + (j * (ymax - ymin) / interv + ymin), x0 - 20 - (int) (9 * .log10(ymax)),
 ym - j * yspan / interv + y0 - 5);
            g2.draw(new (j * xspan / interv + x0, ym, j * xspan / interv + x0, ym + 5));
            g2.draw(new (x0 - 5, j * yspan / interv + y0, x0, j * yspan / interv + y0));
        }
        for (int i = 0; i < xi.length; i++) {
            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));
            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));
            g2.drawString(strv, x0 + f - 3, h + 14);
        }
        for (int i = 0; i < xi.length - 1; i++) {
            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));
            int f2 = (int) ((xi[i + 1] - xmin) * xspan / (xmax - xmin));
            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));
            int h2 = (int) (((ymax - ymin) - (yi[i + 1] - ymin)) * yspan / (ymax - ymin));
            g2.draw(new (f + x0, h + y0, f2 + x0, h2 + y0));
        }
    }
    public static void main( args[]) {
         f = new (strv);
        f.addWindowListener(new () {
            public void windowClosing( e) {
                .exit(0);
            }
        });
        double[] r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        double[] t = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.09};
         applet = new Plot2d(r, t);
        f.getContentPane().add(strv, applet);
        applet.init();
        f.pack();
        f.setSize(new (720, 480));
        f.show();
    }
  }
 "
"import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import static java.awt.image..*;
import static java.lang..*;
import javax.swing.*;
 
public class PlasmaEffect extends  {
    float[][] plasma;
    float hueShift = 0;
     img;
 
    public PlasmaEffect() {
         dim = new (640, 640);
        setPreferredSize(dim);
        setBackground(.white);
 
        img = new (dim.width, dim.height, TYPE_INT_RGB);
        plasma = createPlasma(dim.height, dim.width);
 
        

        new (42, ( e) -> {
            hueShift = (hueShift + 0.02f) % 1;
            repaint();
        }).start();
    }
 
    float[][] createPlasma(int w, int h) {
        float[][] buffer = new float[h][w];
 
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++) {
 
                double value = sin(x / 16.0);
                value += sin(y / 8.0);
                value += sin((x + y) / 16.0);
                value += sin(sqrt(x * x + y * y) / 8.0);
                value += 4; 

                value /= 8; 

 
                

                assert (value >= 0.0 && value <= 1.0) : strv;
 
                buffer[y][x] = (float) value;
            }
        return buffer;
    }
 
    void drawPlasma( g) {
        int h = plasma.length;
        int w = plasma[0].length;
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++) {
                float hue = hueShift + plasma[y][x] % 1;
                img.setRGB(x, y, .HSBtoRGB(hue, 1, 1));
            }
        g.drawImage(img, 0, 0, null);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawPlasma(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new PlasmaEffect(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.awt.Point;
import java.util.Scanner;
 
public class PlayfairCipher {
    private static char[][] charTable;
    private static [] positions;
 
    public static void main([] args) {
        Scanner sc = new Scanner(.in);
 
         key = prompt(strv, sc, 6);
         txt = prompt(strv, sc, 1);
         jti = prompt(strv, sc, 1);
 
        boolean changeJtoI = jti.equalsIgnoreCase(strv);
 
        createTable(key, changeJtoI);
 
         enc = encode(prepareText(txt, changeJtoI));
 
        .out.printf(strv, enc);
        .out.printf(strv, decode(enc));
    }
 
    private static  prompt( promptText, Scanner sc, int minLen) {
         s;
        do {
            .out.print(promptText);
            s = sc.nextLine().trim();
        } while (s.length() < minLen);
        return s;
    }
 
    private static  prepareText( s, boolean changeJtoI) {
        s = s.toUpperCase().replaceAll(strv, strv);
        return changeJtoI ? s.replace(strv, strv) : s.replace(strv, strv);
    }
 
    private static void createTable( key, boolean changeJtoI) {
        charTable = new char[5][5];
        positions = new [26];
 
         s = prepareText(key + strv, changeJtoI);
 
        int len = s.length();
        for (int i = 0, k = 0; i < len; i++) {
            char c = s.charAt(i);
            if (positions[c - 'A'] == null) {
                charTable[k / 5][k % 5] = c;
                positions[c - 'A'] = new (k % 5, k / 5);
                k++;
            }
        }
    }
 
    private static  encode( s) {
        StringBuilder sb = new StringBuilder(s);
 
        for (int i = 0; i < sb.length(); i += 2) {
 
            if (i == sb.length() - 1)
                sb.append(sb.length() % 2 == 1 ? 'X' : strv);
 
            else if (sb.charAt(i) == sb.charAt(i + 1))
                sb.insert(i + 1, 'X');
        }
        return codec(sb, 1);
    }
 
    private static  decode( s) {
        return codec(new StringBuilder(s), 4);
    }
 
    private static  codec(StringBuilder text, int direction) {
        int len = text.length();
        for (int i = 0; i < len; i += 2) {
            char a = text.charAt(i);
            char b = text.charAt(i + 1);
 
            int row1 = positions[a - 'A'].y;
            int row2 = positions[b - 'A'].y;
            int col1 = positions[a - 'A'].x;
            int col2 = positions[b - 'A'].x;
 
            if (row1 == row2) {
                col1 = (col1 + direction) % 5;
                col2 = (col2 + direction) % 5;
 
            } else if (col1 == col2) {
                row1 = (row1 + direction) % 5;
                row2 = (row2 + direction) % 5;
 
            } else {
                int tmp = col1;
                col1 = col2;
                col2 = tmp;
            }
 
            text.setCharAt(i, charTable[row1][col1]);
            text.setCharAt(i + 1, charTable[row2][col2]);
        }
        return text.toString();
    }
}import java.util.Scanner;
 
public class PlayfairCipherEncryption
{
    private  KeyWord        = new ();
    private              = new ();
    private char   matrix_arr[][] = new char[5][5];
 
    public void setKey( k)
    {
         K_adjust = new ();
        boolean flag = false;
        K_adjust = K_adjust + k.charAt(0);
        for (int i = 1; i < k.length(); i++)
        {
            for (int j = 0; j < K_adjust.length(); j++)
            {
                if (k.charAt(i) == K_adjust.charAt(j))
                {
                    flag = true;
                }
            }
            if (flag == false)
                K_adjust = K_adjust + k.charAt(i);
            flag = false;
        }
        KeyWord = K_adjust;
    }
 
    public void KeyGen()
    {
        boolean flag = true;
        char current;
         = KeyWord;
        for (int i = 0; i < 26; i++)
        {
            current = (char) (i + 97);
            if (current == 'j')
                continue;
            for (int j = 0; j < KeyWord.length(); j++)
            {
                if (current == KeyWord.charAt(j))
                {
                    flag = false;
                    break;
                }
            }
            if (flag)
                 =  + current;
            flag = true;
        }
        .out.println();
        matrix();
    }
 
    private void matrix()
    {
        int counter = 0;
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 5; j++)
            {
                matrix_arr[i][j] = .charAt(counter);
                .out.print(matrix_arr[i][j] + strv);
                counter++;
            }
            .out.println();
        }
    }
 
    private  format( old_text)
    {
        int i = 0;
        int len = 0;
         text = new ();
        len = old_text.length();
        for (int tmp = 0; tmp < len; tmp++)
        {
            if (old_text.charAt(tmp) == 'j')
            {
                text = text + 'i';
            }
            else
                text = text + old_text.charAt(tmp);
        }
        len = text.length();
        for (i = 0; i < len; i = i + 2)
        {
            if (text.charAt(i + 1) == text.charAt(i))
            {
                text = text.substring(0, i + 1) + 'x' + text.substring(i + 1);
            }
        }
        return text;
    }
 
    private [] Divid2Pairs( new_string)
    {
         Original = format(new_string);
        int size = Original.length();
        if (size % 2 != 0)
        {
            size++;
            Original = Original + 'x';
        }
         x[] = new [size / 2];
        int counter = 0;
        for (int i = 0; i < size / 2; i++)
        {
            x[i] = Original.substring(counter, counter + 2);
            counter = counter + 2;
        }
        return x;
    }
 
    public int[] GetDiminsions(char letter)
    {
        int[] key = new int[2];
        if (letter == 'j')
            letter = 'i';
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 5; j++)
            {
                if (matrix_arr[i][j] == letter)
                {
                    key[0] = i;
                    key[1] = j;
                    break;
                }
            }
        }
        return key;
    }
 
    public  encryptMessage( Source)
    {
         src_arr[] = Divid2Pairs(Source);
         Code = new ();
        char one;
        char two;
        int part1[] = new int[2];
        int part2[] = new int[2];
        for (int i = 0; i < src_arr.length; i++)
        {
            one = src_arr[i].charAt(0);
            two = src_arr[i].charAt(1);
            part1 = GetDiminsions(one);
            part2 = GetDiminsions(two);
            if (part1[0] == part2[0])
            {
                if (part1[1] < 4)
                    part1[1]++;
                else
                    part1[1] = 0;
                if (part2[1] < 4)
                    part2[1]++;
                else
                    part2[1] = 0;
            }
            else if (part1[1] == part2[1])
            {
                if (part1[0] < 4)
                    part1[0]++;
                else
                    part1[0] = 0;
                if (part2[0] < 4)
                    part2[0]++;
                else
                    part2[0] = 0;
            }
            else
            {
                int temp = part1[1];
                part1[1] = part2[1];
                part2[1] = temp;
            }
            Code = Code + matrix_arr[part1[0]][part1[1]]
                    + matrix_arr[part2[0]][part2[1]];
        }
        return Code;
    }
 
    public static void main([] args)
    {
        PlayfairCipherEncryption x = new PlayfairCipherEncryption();
        Scanner sc = new Scanner(.in);
        .out.println(strv);
         keyword = sc.next();
        x.setKey(keyword);
        x.KeyGen();
        .out
                .println(strv);
         key_input = sc.next();
        if (key_input.length() % 2 == 0)
        {
            .out.println(strv + x.encryptMessage(key_input));
        }
        else
        {
            .out.println(strv);
        }
        sc.close();
    }
}"
"import java.awt.*;
import javax.swing.*;
 
public class PinstripeDisplay extends  {
 
    final int bands = 4;
 
    public PinstripeDisplay() {
        setPreferredSize(new (900, 600));
    }
 
    @Override
    public void paintComponent( g) {
        super.paintComponent(g);
        int h = getHeight();
        for (int b = 1; b <= bands; b++) {
            for (int x = 0, colIndex = 0; x < getWidth(); x += b, colIndex++) {
                g.setColor(colIndex % 2 == 0 ? .white : .black);
                g.fillRect(x, (b - 1) * (h / bands), x + b, b * (h / bands));
            }
        }
    }
 
    public static void main([] args) {
        .invokeLater(new () {
            @Override
            public void run() {
                 f = new ();
                f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
                f.setTitle(strv);
                f.add(new PinstripeDisplay(), .CENTER);
                f.pack();
                f.setLocationRelativeTo(null);
                f.setVisible(true);
            }
        });
    }
}"
"public enum Pip { Two, Three, Four, Five, Six, Seven, 
    Eight, Nine, Ten, Jack, Queen, King, Ace }public enum Suit { Diamonds, Spades, Hearts, Clubs }public class Card {
    private final Suit suit;
    private final Pip value;
 
    public Card(Suit s, Pip v) {
        suit = s;
        value = v;
    }
 
    public  toString() {
        return value + strv + suit;
    }
}import java.util.Collections;
import java.util.LinkedList;
 
public class Deck {
    private final LinkedList<Card> deck= new LinkedList<Card>();
 
    public Deck() {
        for (Suit s : Suit.values())
            for (Pip v : Pip.values())
                deck.add(new Card(s, v));
    }
 
    public Card deal() {
        return deck.poll();
    }
 
    public void shuffle() {
        .shuffle(deck); 

    }
 
    public  toString(){
        return deck.toString();
    }
}"
"import java.util.*;
 
public class PigDice {
 
    public static void main([] args) {
        final int maxScore = 100;
        final int playerCount = 2;
        final [] yesses = {strv, strv, strv};
 
        int[] safeScore = new int[2];
        int player = 0, score = 0;
 
        Scanner sc = new Scanner(.in);
         rnd = new ();
 
        while (true) {
            .out.printf(strv, player,
                    safeScore[player], score);
            if (safeScore[player] + score < maxScore
                    && .asList(yesses).contains(sc.nextLine())) {
                final int rolled = rnd.nextInt(6) + 1;
                .out.printf("" Rolled %d"", rolled);
                if (rolled == 1) {
                    .out.printf("" Bust! You lose %d but keep %d"",
                            score, safeScore[player]);
                } else {
                    score += rolled;
                    continue;
                }
            } else {
                safeScore[player] += score;
                if (safeScore[player] >= maxScore)
                    break;
                .out.printf("" Sticking with %d"", safeScore[player]);
            }
            score = 0;
            player = (player + 1) % playerCount;
        }
        .out.printf(""Player %d wins with a score of %d"",
                player, safeScore[player]);
    }
}"
"import java.util.Random;
...
int[] array = {1,2,3};
return array[new ().nextInt(array.length)]; 
"
"import java.util.Scanner;
 
public class Pigdice {
 
	public static void main([] args) {
		Scanner scan = new Scanner(.in);
		int players = 0;
 
		//Validate the input
		while(true) {
			//Get the number of players
			.out.println(strv);
			if(scan.hasNextInt()) {
 
				//Gotta be more than 0
				int nextInt = scan.nextInt();
				if(nextInt > 0) {
					players = nextInt;
					break;
				}
			}
			else {
				.out.println(""That wasn't an integer. Try again. "");
				scan.next();
			}
		}
		.out.println(strv + players + "" players. "");
 
		//Start the game
		play(players, scan);
 
		scan.close();
	}
 
	public static void play(int group, Scanner scan) {
		//Set the number of strategies available.
		final int STRATEGIES = 5;
 
		//Construct the dice- accepts an int as an arg for number of sides, but defaults to 6.
		Dice dice = new Dice();
 
		//Create an array of players and initialize them to defaults.
		Player[] players = new Player[group];
		for(int count = 0; count < group; count++) {
			players[count] = new Player(count);
			.out.println(strv + players[count].getNumber() + strv);
		}
 
		/*****Print strategy options here. Modify Player.java to add strategies. *****/
		.out.println(strv + (STRATEGIES - 1) + strv);
		.out.println(strv);
		.out.println(strv);
		.out.println(strv);
		.out.println(strv);
		.out.println(strv);
 
		//Get the strategy for each player
		for(Player player : players) {
			.out.println(""What strategy would you like player "" + player.getNumber() + strv);
 
			//Validate the strategy is a real strategy.
			while(true) {
				if(scan.hasNextInt()) {
					int nextInt = scan.nextInt();
					if (nextInt < Strategy.STRATEGIES.length) {
						player.setStrategy(Strategy.STRATEGIES[nextInt]);
						break;
					}
				}
				else {
					.out.println(strv);
					scan.next();
				}
			}
		}
 
		//Here is where the rules for the game are programmatically defined.
		int max = 0;
		while(max < 100) {
 
			//Begin the round
			for(Player player : players) {
				.out.println(strv + player.getNumber() + strv);
 
				//Set the points for the turn to 0
				player.setTurnPoints(0);
 
				//Determine whether the player chooses to roll or hold.
				player.setMax(max);
				while(true) {
					Move choice = player.choose();
					if(choice == Move.ROLL) {
						int roll = dice.roll();
						.out.println(strv + roll + strv);
						player.setTurnPoints(player.getTurnPoints() + roll);
 
						//Increment the player's built in iterator.
						player.incIter();
 
						//If the player rolls a 1, their turn is over and they gain 0 points this round.
						if(roll == 1) {
							player.setTurnPoints(0);
							break;
						}
					}
					//Check if the player held or not.
					else {
						.out.println(strv);
						break;
					}
				}
 
				//End the turn and add any accumulated points to the player's pool.
				player.addPoints(player.getTurnPoints());
				.out.println(strv + player.getNumber() + strv + player.getPoints() + "". "");
 
				//Reset the player's built in iterator.
				player.resetIter();
 
				//Update the max score if necessary.
				if(max < player.getPoints()) {
					max = player.getPoints();
				}
 
				//If someone won, stop the game and announce the winner.
				if(max >= 100) {
					.out.println(strv + player.getNumber() + strv + max + strv);
 
					//Announce the final scores.
					for(Player p : players) {
						.out.println(strv + p.getNumber() + strv + p.getPoints() + strv);
					}
					break;
				}
			}
		}
 
	}
 
}public class Player {
 
	private int points = 0;
	private int turnPoints = 0;
	private Strategy strategy = null;
	private int max = 0;
	private int number;
	private int iter = 0;
 
	public Player(int val) {
		number = val;
	}
 
	public int getPoints() {
		return points;
	}
	public int getTurnPoints() {
		return turnPoints;
	}
	public int getMax() {
		return max;
	}
	public int getNumber() {
		return number;
	}
	public int getIter() {
		return iter;
	}
	public void addPoints(int val) {
		points += val;
	}
	public void setTurnPoints(int val) {
		turnPoints = val;
	}
	public void setStrategy(Strategy strat) {
		strategy = strat;
	}
	public void setMax(int val) {
		max = val;
	}
	public void setNumber(int val) {
		number = val;
	}
	public void resetIter() {
		iter = 0;
	}
	public void incIter() {
		iter++;
	}
	public void aiIntro() {
		.out.println(strv + getNumber() + strv + getTurnPoints() + strv + getPoints() + strv);
		.out.println(strv + getMax() + strv);
	}
	public Move choose() {
		return strategy.choose(this);
	}
 
}public enum Move { ROLL, HOLD }import java.util.Scanner;
 
public interface Strategy {
 
	Move choose(Player player);
 
	static final Scanner str = new Scanner(.in);
	static final Dice die = new Dice(2);
	static final int ROOF = 75;
	static final int FLOOR = 20;
	static final int BASEMENT = 10;
 
	/*****MODIFY THIS AREA TO MODIFY THE STRATEGIES*****/
	//Determine whether to roll or hold based on the strategy for this player.
	public static final Strategy[] STRATEGIES = {
 
		//Strategy 0 is a user-defined strategy
		player -> {
			.out.println(strv + player.getTurnPoints() + strv + player.getPoints() + strv);
			.out.println(strv + player.getMax() + strv);
			.out.println(strv);
			while(true) {
				 input = null;
				if(str.hasNextLine()) {
					input = str.nextLine();
				}
				if(input.contains(strv)) {
					return Move.ROLL;
				}
				else if(input.contains(strv)) {
					return Move.HOLD;
				}
				else {
					.out.println(""  Enter an h or an r. "");
					.out.println(input);
				}
			}
		},
 
		//Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.
		player -> {
			player.aiIntro();
			if(player.getTurnPoints() < FLOOR || player.getMax() >= ROOF) {
				if(player.getTurnPoints() >= (100 - player.getPoints())) {
					return Move.HOLD;					
				}
				else {
					return Move.ROLL;
				}
			}
			else {
				return Move.HOLD;
			}
		},
 
		//Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold.
		player -> {
			player.aiIntro();
			if(player.getPoints() == 0 && player.getTurnPoints() >= (BASEMENT / 2)) {
				return Move.HOLD;
			}
			if(player.getIter() > 3) {
				int roll = die.roll();
 
				if(roll == 1) {
					return Move.HOLD;
				}
				else {
					return Move.ROLL;
				}
			}
			else {
				return Move.ROLL;
			}
		},
 
		//Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls.
		player -> {
			player.aiIntro();
			if(player.getIter() > 5) {
				int roll = die.roll();
 
				if(roll == 1) {
					return Move.HOLD;
				}
				else {
					return Move.ROLL;
				}
			}
			else if(player.getPoints() < BASEMENT && player.getTurnPoints() > BASEMENT) {
				return Move.HOLD;
			}
			else {
				return Move.ROLL;
			}
		},
 
		/*Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll.		Unless their total is zero, in which case they'll hold at 10 points. */
		player -> {
			player.aiIntro();
			if(player.getPoints() == 0 && player.getTurnPoints() >= (BASEMENT / 2)) {
				return Move.HOLD;
			}
			else if(player.getTurnPoints() < FLOOR || player.getMax() >= ROOF) {
				if(player.getTurnPoints() >= (100 - player.getPoints())) {
					return Move.HOLD;					
				}
				else {
					return Move.ROLL;
				}
			}
			else if(player.getTurnPoints() > FLOOR && player.getMax() <= ROOF) {
				int roll = die.roll();
 
				if(roll == 1) {
					return Move.HOLD;
				}
				else {
					return Move.ROLL;
				}
			}
			else {
				return Move.HOLD;
			}
		}
	};
 
}import java.util.Random;
 
public class Dice {
	 rand = new ();
	int sides;
	Dice(int numSides) {
		sides = numSides;
	}
	Dice() {
		sides = 6;
	}
	int roll() {
		return rand.nextInt(sides) + 1;
	}
}"
"import java.math.BigInteger ;
 
public class Pi {
  final  TWO = .valueOf(2) ;
  final  THREE = .valueOf(3) ;
  final  FOUR = .valueOf(4) ;
  final  SEVEN = .valueOf(7) ;
 
   q = .ONE ;
   r = .ZERO ;
   t = .ONE ;
   k = .ONE ;
   n = .valueOf(3) ;
   l = .valueOf(3) ;
 
  public void calcPiDigits(){
     nn, nr ;
    boolean first = true ;
    while(true){
        if(FOUR.multiply(q).add(r).subtract(t).compareTo(n.multiply(t)) == -1){
          .out.print(n) ;
          if(first){.out.print(strv) ; first = false ;}
          nr = .TEN.multiply(r.subtract(n.multiply(t))) ;
          n = .TEN.multiply(THREE.multiply(q).add(r)).divide(t).subtract(.TEN.multiply(n)) ;
          q = q.multiply(.TEN) ;
          r = nr ;
          .out.flush() ;
        }else{
          nr = TWO.multiply(q).add(r).multiply(l) ;
          nn = q.multiply((SEVEN.multiply(k))).add(TWO).add(r.multiply(l)).divide(t.multiply(l)) ;
          q = q.multiply(k) ;
          t = t.multiply(l) ;
          l = l.add(TWO) ;
          k = k.add(.ONE) ;
          n = nn ;
          r = nr ;
        }
    }
  }
 
  public static void main([] args) {
    Pi p = new Pi() ;
    p.calcPiDigits() ;
  }
}"
"public class Pernicious{
    //very simple isPrime since x will be <= Long.SIZE
    public static boolean isPrime(int x){
        if(x < 2) return false;
        for(int i = 2; i < x; i++){
            if(x % i == 0) return false;
        }
        return true;
    }
 
    public static int popCount(long x){
        return .bitCount(x);
    }
 
    public static void main([] args){
        for(long i = 1, n = 0; n < 25; i++){
            if(isPrime(popCount(i))){
                .out.print(i + strv);
                n++;
            }
        }
 
        .out.println();
 
        for(long i = 888888877; i <= 888888888; i++){
            if(isPrime(popCount(i))) .out.print(i + strv);
        }
    }
}"
"import java.math.BigInteger;
import java.util.*;
 
class RankPermutation
{
  public static  getRank(int[] permutation)
  {
    int n = permutation.length;
     usedDigits = new ();
     rank = .ZERO;
    for (int i = 0; i < n; i++)
    {
      rank = rank.multiply(.valueOf(n - i));
      int digit = 0;
      int v = -1;
      while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])
        digit++;
      usedDigits.set(v);
      rank = rank.add(.valueOf(digit));
    }
    return rank;
  }
 
  public static int[] getPermutation(int n,  rank)
  {
    int[] digits = new int[n];
    for (int digit = 2; digit <= n; digit++)
    {
       divisor = .valueOf(digit);
      digits[n - digit] = rank.mod(divisor).intValue();
      if (digit < n)
        rank = rank.divide(divisor);
    }
     usedDigits = new ();
    int[] permutation = new int[n];
    for (int i = 0; i < n; i++)
    {
      int v = usedDigits.nextClearBit(0);
      for (int j = 0; j < digits[i]; j++)
        v = usedDigits.nextClearBit(v + 1);
      permutation[i] = v;
      usedDigits.set(v);
    }
    return permutation;
  }
 
  public static void main([] args)
  {
    for (int i = 0; i < 6; i++)
    {
      int[] permutation = getPermutation(3, .valueOf(i));
      .out.println(.valueOf(i) + strv + .toString(permutation) + strv + getRank(permutation));
    }
     rnd = new ();
    for (int n : new int[] { 12, 144 })
    {
       factorial = .ONE;
      for (int i = 2; i <= n; i++)
        factorial = factorial.multiply(.valueOf(i));
      

      .out.println(strv + n);
      for (int i = 0; i < 5; i++)
      {
         rank = new ((factorial.bitLength() + 1) << 1, rnd);
        rank = rank.mod(factorial);
        int[] permutation = getPermutation(n, rank);
        .out.println(strv + rank + strv + .toString(permutation) + strv + getRank(permutation));
      }
    }
  }
 
}"
"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
 
public class Derangement {
 
    public static void main([] args) {
        .out.println(""derangements for n = 4"");
        for ( d  : ()(derangements(4, false)[0])) {
            .out.println(.toString((int[])d));
        }
 
        .out.println(""table of n vs counted vs calculated derangements"");
        for (int i = 0; i < 10; i++) {
            int d = (()derangements(i, true)[1]).intValue();
            .out.printf(""%d  %-7d %-7d"", i, d, subfact(i));
        }
 
        .out.printf (""!20 = %20d"", subfact(20L));
    }
 
    static [] derangements(int n, boolean countOnly) {
        int[] seq = iota(n);
        int[] ori = .copyOf(seq, n);
        long tot = fact(n);
 
        List<int[]> all = new ArrayList<int[]>();
        int cnt = n == 0 ? 1 : 0;
 
        while (--tot > 0) {
            int j = n - 2;
            while (seq[j] > seq[j + 1]) {
                j--;
            }
            int k = n - 1;
            while (seq[j] > seq[k]) {
                k--;
            }
            swap(seq, k, j);
 
            int r = n - 1;
            int s = j + 1;
            while (r > s) {
                swap(seq, s, r);
                r--;
                s++;
            }
 
            j = 0;
            while (j < n && seq[j] != ori[j]) {
                j++;
            }
            if (j == n) {
                if (countOnly) {
                    cnt++;
                } else {
                    all.add(.copyOf(seq, n));
                }
            }
        }
        return new []{all, cnt};
    }
 
    static long fact(long n) {
        long result = 1;
        for (long i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
 
    static long subfact(long n) {
        if (0 <= n && n <= 2) {
            return n != 1 ? 1 : 0;
        }
        return (n - 1) * (subfact(n - 1) + subfact(n - 2));
    }
 
    static void swap(int[] arr, int lhs, int rhs) {
        int tmp = arr[lhs];
        arr[lhs] = arr[rhs];
        arr[rhs] = tmp;
    }
 
    static int[] iota(int n) {
        if (n < 0) {
            throw new (strv);
        }
        int[] r = new int[n];
        for (int i = 0; i < n; i++) {
            r[i] = i;
        }
        return r;
    }
}"
"public class PermutationGenerator {
    private int[] array;
    private int firstNum;
    private boolean firstReady = false;
 
    public PermutationGenerator(int n, int firstNum_) {
        if (n < 1) {
            throw new (strv);
        }
        firstNum = firstNum_;
        array = new int[n];
        reset();
    }
 
    public void reset() {
        for (int i = 0; i < array.length; i++) {
            array[i] = i + firstNum;
        }
        firstReady = false;
    }
 
    public boolean hasMore() {
        boolean end = firstReady;
        for (int i = 1; i < array.length; i++) {
            end = end && array[i] < array[i-1];
        }
        return !end;
    }
 
    public int[] getNext() {
 
        if (!firstReady) {
            firstReady = true;
            return array;
        }
 
        int temp;
        int j = array.length - 2;
        int k = array.length - 1;
 
        

 
        for (;array[j] > array[j+1]; j--);
 
        

        

 
        for (;array[j] > array[k]; k--);
 
        

 
        temp = array[k];
        array[k] = array[j];
        array[j] = temp;
 
        

 
        int r = array.length - 1;
        int s = j + 1;
 
        while (r > s) {
            temp = array[s];
            array[s++] = array[r];
            array[r--] = temp;
        }
 
        return array;
    } 

 
    

    public static void main([] args) {
        PermutationGenerator pg = new PermutationGenerator(3, 1);
 
        while (pg.hasMore()) {
            int[] temp =  pg.getNext();
            for (int i = 0; i < temp.length; i++) {
                .out.print(temp[i] + strv);
            }
            .out.println();
        }
    }
 
} 
public class Permutations {
	public static void main([] args) {
		.out.println(Utils.Permutations(Utils.mRange(1, 3)));
	}
}"
"import java.util.function.Predicate;
 
public class PermutationsWithRepetitions {
 
    public static void main([] args) {
        char[] chars = {'a', 'b', 'c', 'd'};
        

        permute(chars, 3, i -> i[0] == 1 && i[1] == 1 && i[2] == 0);
    }
 
    static void permute(char[] a, int k, Predicate<int[]> decider) {
        int n = a.length;
        if (k < 1 || k > n)
            throw new (strv);
 
        int[] indexes = new int[n];
        int total = (int) .pow(n, k);
 
        while (total-- > 0) {
            for (int i = 0; i < n - (n - k); i++)
                .out.print(a[indexes[i]]);
            .out.println();
 
            if (decider.test(indexes))
                break;
 
            for (int i = 0; i < n; i++) {
                if (indexes[i] >= n - 1) {
                    indexes[i] = 0;
                } else {
                    indexes[i]++;
                    break;
                }
            }
        }
    }
}"
"import java.util.Arrays;
import java.util.stream.IntStream;
 
public class PerfectShuffle {
 
    public static void main([] args) {
        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};
        for (int size : sizes)
            .out.printf(strv, size, perfectShuffle(size));
    }
 
    static int perfectShuffle(int size) {
        if (size % 2 != 0)
            throw new (strv);
 
        int half = size / 2;
        int[] a = IntStream.range(0, size).toArray();
        int[] original = a.clone();
        int[] aa = new int[size];
 
        for (int count = 1; true; count++) {
            .arraycopy(a, 0, aa, 0, size);
 
            for (int i = 0; i < half; i++) {
                a[2 * i] = aa[i];
                a[2 * i + 1] = aa[i + half];
            }
 
            if (.equals(a, original))
                return count;
        }
    }
}"
"

 
public final class ImprovedNoise {
   static public double noise(double x, double y, double z) {
      int X = (int).floor(x) & 255,                  

          Y = (int).floor(y) & 255,                  

          Z = (int).floor(z) & 255;
      x -= .floor(x);                                

      y -= .floor(y);                                

      z -= .floor(z);
      double u = fade(x),                                

             v = fade(y),                                

             w = fade(z);
      int A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      

          B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      

 
      return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  

                                     grad(p[BA  ], x-1, y  , z   )), 

                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  

                                     grad(p[BB  ], x-1, y-1, z   ))),

                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  

                                     grad(p[BA+1], x-1, y  , z-1 )), 

                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),
                                     grad(p[BB+1], x-1, y-1, z-1 ))));
   }
   static double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }
   static double lerp(double t, double a, double b) { return a + t * (b - a); }
   static double grad(int hash, double x, double y, double z) {
      int h = hash & 15;                      

      double u = h<8 ? x : y,                 

             v = h<4 ? y : h==12||h==14 ? x : z;
      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
   }
   static final int p[] = new int[512], permutation[] = { 151,160,137,91,90,15,
   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
   };
   static { for (int i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i]; }
}"
"public static boolean perf(int n){
	int sum= 0;
	for(int i= 1;i < n;i++){
		if(n % i == 0){
			sum+= i;
		}
	}
	return sum == n;
}import java.math.BigInteger;
 
public static boolean perf( n){
	 sum= .ZERO;
	for( i= .ONE;
	i.compareTo(n) < 0;i=i.add(.ONE)){
		if(n.mod(i).equals(.ZERO)){
			sum= sum.add(i);
		}
	}
	return sum.equals(n);
}"
"import java.awt.*;
import java.awt.event.ActionEvent;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;
 
public class Perceptron extends  {
 
    class Trainer {
        double[] inputs;
        int answer;
 
        Trainer(double x, double y, int a) {
            inputs = new double[]{x, y, 1};
            answer = a;
        }
    }
 
    Trainer[] training = new Trainer[2000];
    double[] weights;
    double c = 0.00001;
    int count;
 
    public Perceptron(int n) {
         r = new ();
         dim = new (640, 360);
        setPreferredSize(dim);
        setBackground(.white);
 
        weights = new double[n];
        for (int i = 0; i < weights.length; i++) {
            weights[i] = r.nextDouble() * 2 - 1;
        }
 
        for (int i = 0; i < training.length; i++) {
            double x = r.nextDouble() * dim.width;
            double y = r.nextDouble() * dim.height;
 
            int answer = y < f(x) ? -1 : 1;
 
            training[i] = new Trainer(x, y, answer);
        }
 
        new (10, ( e) -> {
            repaint();
        }).start();
    }
 
    private double f(double x) {
        return x * 0.7 + 40;
    }
 
    int feedForward(double[] inputs) {
        assert inputs.length == weights.length : strv;
 
        double sum = 0;
        for (int i = 0; i < weights.length; i++) {
            sum += inputs[i] * weights[i];
        }
        return activate(sum);
    }
 
    int activate(double s) {
        return s > 0 ? 1 : -1;
    }
 
    void train(double[] inputs, int desired) {
        int guess = feedForward(inputs);
        double error = desired - guess;
        for (int i = 0; i < weights.length; i++) {
            weights[i] += c * error * inputs[i];
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        

        int x = getWidth();
        int y = (int) f(x);
        g.setStroke(new (2));
        g.setColor(.orange);
        g.drawLine(0, (int) f(0), x, y);
 
        train(training[count].inputs, training[count].answer);
        count = (count + 1) % training.length;
 
        g.setStroke(new (1));
        g.setColor(.black);
        for (int i = 0; i < count; i++) {
            int guess = feedForward(training[i].inputs);
 
            x = (int) training[i].inputs[0] - 4;
            y = (int) training[i].inputs[1] - 4;
 
            if (guess > 0)
                g.drawOval(x, y, 8, 8);
            else
                g.fillOval(x, y, 8, 8);
        }
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new Perceptron(3), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.util.*;
 
public class PentominoTiling {
 
    static final char[] symbols = strv.toCharArray();
 
    static final int nRows = 8;
    static final int nCols = 8;
    static final int target = 12;
    static final int blank = 12;
 
    static int[][] grid = new int[nRows][nCols];
    static boolean[] placed = new boolean[target];
 
    public static void main([] args) {
         rand = new ();
 
        for (int r = 0; r < nRows; r++)
            .fill(grid[r], -1);
 
        for (int i = 0; i < 4; i++)
            grid[rand.nextInt(nRows)][rand.nextInt(nCols)] = blank;
 
        if (solve(0, 0)) {
            printResult();
        } else {
            .out.println(strv);
        }
    }
 
    static void printResult() {
        for (int[] r : grid) {
            for (int i : r)
                .out.printf(strv, symbols[i]);
            .out.println();
        }
    }
 
    static boolean tryPlaceOrientation(int[] o, int r, int c, int shapeIndex) {
 
        for (int i = 0; i < o.length; i += 2) {
            int x = c + o[i + 1];
            int y = r + o[i];
            if (x < 0 || x >= nCols || y < 0 || y >= nRows || grid[y][x] != -1)
                return false;
        }
 
        grid[r][c] = shapeIndex;
        for (int i = 0; i < o.length; i += 2)
            grid[r + o[i]][c + o[i + 1]] = shapeIndex;
 
        return true;
    }
 
    static void removeOrientation(int[] o, int r, int c) {
        grid[r][c] = -1;
        for (int i = 0; i < o.length; i += 2)
            grid[r + o[i]][c + o[i + 1]] = -1;
    }
 
    static boolean solve(int pos, int numPlaced) {
        if (numPlaced == target)
            return true;
 
        int row = pos / nCols;
        int col = pos % nCols;
 
        if (grid[row][col] != -1)
            return solve(pos + 1, numPlaced);
 
        for (int i = 0; i < shapes.length; i++) {
 
            if (!placed[i]) {
 
                for (int[] orientation : shapes[i]) {
 
                    if (!tryPlaceOrientation(orientation, row, col, i))
                        continue;
 
                    placed[i] = true;
 
                    if (solve(pos + 1, numPlaced + 1))
                        return true;
 
                    removeOrientation(orientation, row, col);
                    placed[i] = false;
                }
            }
        }
        return false;
    }
 
    

    static final int[][] F = {{1, -1, 1, 0, 1, 1, 2, 1}, {0, 1, 1, -1, 1, 0, 2, 0},
    {1, 0, 1, 1, 1, 2, 2, 1}, {1, 0, 1, 1, 2, -1, 2, 0}, {1, -2, 1, -1, 1, 0, 2, -1},
    {0, 1, 1, 1, 1, 2, 2, 1}, {1, -1, 1, 0, 1, 1, 2, -1}, {1, -1, 1, 0, 2, 0, 2, 1}};
 
    static final int[][] I = {{0, 1, 0, 2, 0, 3, 0, 4}, {1, 0, 2, 0, 3, 0, 4, 0}};
 
    static final int[][] L = {{1, 0, 1, 1, 1, 2, 1, 3}, {1, 0, 2, 0, 3, -1, 3, 0},
    {0, 1, 0, 2, 0, 3, 1, 3}, {0, 1, 1, 0, 2, 0, 3, 0}, {0, 1, 1, 1, 2, 1, 3, 1},
    {0, 1, 0, 2, 0, 3, 1, 0}, {1, 0, 2, 0, 3, 0, 3, 1}, {1, -3, 1, -2, 1, -1, 1, 0}};
 
    static final int[][] N = {{0, 1, 1, -2, 1, -1, 1, 0}, {1, 0, 1, 1, 2, 1, 3, 1},
    {0, 1, 0, 2, 1, -1, 1, 0}, {1, 0, 2, 0, 2, 1, 3, 1}, {0, 1, 1, 1, 1, 2, 1, 3},
    {1, 0, 2, -1, 2, 0, 3, -1}, {0, 1, 0, 2, 1, 2, 1, 3}, {1, -1, 1, 0, 2, -1, 3, -1}};
 
    static final int[][] P = {{0, 1, 1, 0, 1, 1, 2, 1}, {0, 1, 0, 2, 1, 0, 1, 1},
    {1, 0, 1, 1, 2, 0, 2, 1}, {0, 1, 1, -1, 1, 0, 1, 1}, {0, 1, 1, 0, 1, 1, 1, 2},
    {1, -1, 1, 0, 2, -1, 2, 0}, {0, 1, 0, 2, 1, 1, 1, 2}, {0, 1, 1, 0, 1, 1, 2, 0}};
 
    static final int[][] T = {{0, 1, 0, 2, 1, 1, 2, 1}, {1, -2, 1, -1, 1, 0, 2, 0},
    {1, 0, 2, -1, 2, 0, 2, 1}, {1, 0, 1, 1, 1, 2, 2, 0}};
 
    static final int[][] U = {{0, 1, 0, 2, 1, 0, 1, 2}, {0, 1, 1, 1, 2, 0, 2, 1},
    {0, 2, 1, 0, 1, 1, 1, 2}, {0, 1, 1, 0, 2, 0, 2, 1}};
 
    static final int[][] V = {{1, 0, 2, 0, 2, 1, 2, 2}, {0, 1, 0, 2, 1, 0, 2, 0},
    {1, 0, 2, -2, 2, -1, 2, 0}, {0, 1, 0, 2, 1, 2, 2, 2}};
 
    static final int[][] W = {{1, 0, 1, 1, 2, 1, 2, 2}, {1, -1, 1, 0, 2, -2, 2, -1},
    {0, 1, 1, 1, 1, 2, 2, 2}, {0, 1, 1, -1, 1, 0, 2, -1}};
 
    static final int[][] X = {{1, -1, 1, 0, 1, 1, 2, 0}};
 
    static final int[][] Y = {{1, -2, 1, -1, 1, 0, 1, 1}, {1, -1, 1, 0, 2, 0, 3, 0},
    {0, 1, 0, 2, 0, 3, 1, 1}, {1, 0, 2, 0, 2, 1, 3, 0}, {0, 1, 0, 2, 0, 3, 1, 2},
    {1, 0, 1, 1, 2, 0, 3, 0}, {1, -1, 1, 0, 1, 1, 1, 2}, {1, 0, 2, -1, 2, 0, 3, 0}};
 
    static final int[][] Z = {{0, 1, 1, 0, 2, -1, 2, 0}, {1, 0, 1, 1, 1, 2, 2, 2},
    {0, 1, 1, 1, 2, 1, 2, 2}, {1, -2, 1, -1, 1, 0, 2, -2}};
 
    static final int[][][] shapes = {F, I, L, N, P, T, U, V, W, X, Y, Z};
}"
"import java.awt.*;
import java.util.List;
import java.awt.geom.Path2D;
import java.util.*;
import javax.swing.*;
import static java.lang..*;
import static java.util.stream.Collectors.toList;
 
public class PenroseTiling extends  {
    

    class Tile {
        double x, y, angle, size;
        Type type;
 
        Tile(Type t, double x, double y, double a, double s) {
            type = t;
            this.x = x;
            this.y = y;
            angle = a;
            size = s;
        }
 
        @Override
        public boolean equals( o) {
            if (o instanceof Tile) {
                Tile t = (Tile) o;
                return type == t.type && x == t.x && y == t.y && angle == t.angle;
            }
            return false;
        }
    }
 
    enum Type {
        Kite, Dart
    }
 
    static final double G = (1 + sqrt(5)) / 2; 

    static final double T = toRadians(36); 

 
    List<Tile> tiles = new ArrayList<>();
 
    public PenroseTiling() {
        int w = 700, h = 450;
        setPreferredSize(new (w, h));
        setBackground(.white);
 
        tiles = deflateTiles(setupPrototiles(w, h), 5);
    }
 
    List<Tile> setupPrototiles(int w, int h) {
        List<Tile> proto = new ArrayList<>();
 
        

        for (double a = PI / 2 + T; a < 3 * PI; a += 2 * T)
            proto.add(new Tile(Type.Kite, w / 2, h / 2, a, w / 2.5));
 
        return proto;
    }
 
    List<Tile> deflateTiles(List<Tile> tls, int generation) {
        if (generation <= 0)
            return tls;
 
        List<Tile> next = new ArrayList<>();
 
        for (Tile tile : tls) {
            double x = tile.x, y = tile.y, a = tile.angle, nx, ny;
            double size = tile.size / G;
 
            if (tile.type == Type.Dart) {
                next.add(new Tile(Type.Kite, x, y, a + 5 * T, size));
 
                for (int i = 0, sign = 1; i < 2; i++, sign *= -1) {
                    nx = x + cos(a - 4 * T * sign) * G * tile.size;
                    ny = y - sin(a - 4 * T * sign) * G * tile.size;
                    next.add(new Tile(Type.Dart, nx, ny, a - 4 * T * sign, size));
                }
 
            } else {
 
                for (int i = 0, sign = 1; i < 2; i++, sign *= -1) {
                    next.add(new Tile(Type.Dart, x, y, a - 4 * T * sign, size));
 
                    nx = x + cos(a - T * sign) * G * tile.size;
                    ny = y - sin(a - T * sign) * G * tile.size;
                    next.add(new Tile(Type.Kite, nx, ny, a + 3 * T * sign, size));
                }
            }
        }
        

        tls = next.stream().distinct().collect(toList());
 
        return deflateTiles(tls, generation - 1);
    }
 
    void drawTiles( g) {
        double[][] dist = {{G, G, G}, {-G, -1, -G}};
        for (Tile tile : tiles) {
            double angle = tile.angle - T;
            Path2D path = new Path2D.();
            path.moveTo(tile.x, tile.y);
 
            int ord = tile.type.ordinal();
            for (int i = 0; i < 3; i++) {
                double x = tile.x + dist[ord][i] * tile.size * cos(angle);
                double y = tile.y - dist[ord][i] * tile.size * sin(angle);
                path.lineTo(x, y);
                angle += T;
            }
            path.closePath();
            g.setColor(ord == 0 ? .orange : .yellow);
            g.fill(path);
            g.setColor(.darkGray);
            g.draw(path);
        }
    }
 
    @Override
    public void paintComponent( og) {
        super.paintComponent(og);
         g = () og;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
        drawTiles(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new PenroseTiling(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.awt.*;
import java.awt.geom.Path2D;
import javax.swing.*;
 
public class Pentagram extends  {
 
    final double degrees144 = .toRadians(144);
 
    public Pentagram() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
    }
 
    private void drawPentagram( g, int len, int x, int y,
             fill,  stroke) {
        double angle = 0;
 
        Path2D p = new Path2D.();
        p.moveTo(x, y);
 
        for (int i = 0; i < 5; i++) {
            int x2 = x + (int) (.cos(angle) * len);
            int y2 = y + (int) (.sin(-angle) * len);
            p.lineTo(x2, y2);
            x = x2;
            y = y2;
            angle -= degrees144;
        }
        p.closePath();
 
        g.setColor(fill);
        g.fill(p);
 
        g.setColor(stroke);
        g.draw(p);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
 
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        g.setStroke(new (5, .CAP_ROUND, 0));
 
        drawPentagram(g, 500, 70, 250, new (0x6495ED), .darkGray);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new Pentagram(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import java.io.IOException;
import java.net.URL;
 
public class ImgDiffPercent
{
  public static void main( args[])
  {
     img1 = null;
     img2 = null;
    try {
       url1 = new (strv);
       url2 = new (strv);
      img1 = ImageIO.read(url1);
      img2 = ImageIO.read(url2);
    } catch ( e) {
      e.printStackTrace();
    }
    int width1 = img1.getWidth(null);
    int width2 = img2.getWidth(null);
    int height1 = img1.getHeight(null);
    int height2 = img2.getHeight(null);
    if ((width1 != width2) || (height1 != height2)) {
      .err.println(strv);
      .exit(1);
    }
    long diff = 0;
    for (int y = 0; y < height1; y++) {
      for (int x = 0; x < width1; x++) {
        int rgb1 = img1.getRGB(x, y);
        int rgb2 = img2.getRGB(x, y);
        int r1 = (rgb1 >> 16) & 0xff;
        int g1 = (rgb1 >>  8) & 0xff;
        int b1 = (rgb1      ) & 0xff;
        int r2 = (rgb2 >> 16) & 0xff;
        int g2 = (rgb2 >>  8) & 0xff;
        int b2 = (rgb2      ) & 0xff;
        diff += .abs(r1 - r2);
        diff += .abs(g1 - g2);
        diff += .abs(b1 - b2);
      }
    }
    double n = width1 * height1 * 3;
    double p = diff / n / 255.0;
    .out.println(strv + (p * 100.0));
  }
}"
"import java.util.*;
 
public class PasswordGenerator {
    final static  rand = new ();
 
    public static void main([] args) {
        int num, len;
 
        try {
            if (args.length != 2)
                throw new ();
 
            len = .parseInt(args[0]);
            if (len < 4 || len > 16)
                throw new ();
 
            num = .parseInt(args[1]);
            if (num < 1 || num > 10)
                throw new ();
 
            for ( pw : generatePasswords(num, len))
                .out.println(pw);
 
        } catch ( e) {
             s = strv
                    + ""want to generate,and how many (min 1, max 10)"";
            .out.println(s);
        }
    }
 
    private static List<String> generatePasswords(int num, int len) {
        final  s = ""!#$%&'()*+,-./:;<=>?@[]^_{|}~"";
 
        List<String> result = new ArrayList<>();
 
        for (int i = 0; i < num; i++) {
            StringBuilder sb = new StringBuilder();
            sb.append(s.charAt(rand.nextInt(s.length())));
            sb.append((char) (rand.nextInt(10) + '0'));
            sb.append((char) (rand.nextInt(26) + 'a'));
            sb.append((char) (rand.nextInt(26) + 'A'));
 
            for (int j = 4; j < len; j++) {
                int r = rand.nextInt(93) + '!';
                if (r == 92 || r == 96) {
                    j--;
                } else {
                    sb.append((char) r);
                }
            }
            result.add(shuffle(sb));
        }
        return result;
    }
 
    public static  shuffle(StringBuilder sb) {
        int len = sb.length();
        for (int i = len - 1; i > 0; i--) {
            int r = rand.nextInt(i);
            char tmp = sb.charAt(i);
            sb.setCharAt(i, sb.charAt(r));
            sb.setCharAt(r, tmp);
        }
        return sb.toString();
    }
}"
"import java.util.*;
 
public class PenneysGame {
 
    public static void main([] args) {
         rand = new ();
 
         compChoice = strv, playerChoice;
        if (rand.nextBoolean()) {
 
            for (int i = 0; i < 3; i++)
                compChoice += strv.charAt(rand.nextInt(2));
            .out.printf(strv, compChoice);
 
            playerChoice = prompt(compChoice);
 
        } else {
 
            playerChoice = prompt(compChoice);
 
            compChoice = strv;
            if (playerChoice.charAt(1) == 'T')
                compChoice = strv;
            compChoice += playerChoice.substring(0, 2);
            .out.printf(strv, compChoice);
        }
 
         tossed = strv;
        while (true) {
            tossed += strv.charAt(rand.nextInt(2));
            .out.printf(strv , tossed);
            if (tossed.endsWith(playerChoice)) {
                .out.println(strv);
                break;
            }
            if (tossed.endsWith(compChoice)) {
                .out.println(strv);
                break;
            }
        }
    }
 
    private static  prompt( otherChoice) {
        Scanner sc = new Scanner(.in);
         s;
        do {
            .out.print(strv);
            s = sc.nextLine().trim().toUpperCase();
        } while (!s.matches(strv) || s.equals(otherChoice));
        return s;
    }
}"
"import static java.lang..out;
import java.util.List;
import java.util.function.Function;
import java.util.stream.*;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;
 
public class PascalMatrix {
    static int binomialCoef(int n, int k) {
        int result = 1;
        for (int i = 1; i <= k; i++)
            result = result * (n - i + 1) / i;
        return result;
    }
 
    static List<IntStream> pascal(int n, Function<, IntStream> f) {
        return range(0, n).mapToObj(i -> f.apply(i)).collect(toList());
    }
 
    static List<IntStream> pascalUpp(int n) {
        return pascal(n, i -> range(0, n).map(j -> binomialCoef(j, i)));
    }
 
    static List<IntStream> pascalLow(int n) {
        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i, j)));
    }
 
    static List<IntStream> pascalSym(int n) {
        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i + j, i)));
    }
 
    static void print( label, List<IntStream> result) {
        out.println("""" + label);
        for (IntStream row : result) {
            row.forEach(i -> out.printf(strv, i));
            .out.println();
        }
    }
 
    public static void main([] a) {
        print(strv, pascalUpp(5));
        print(strv, pascalLow(5));
        print(strv, pascalSym(5));
    }
}"
"import java.util.Arrays;
 
public class PartialApplication {
	interface IntegerFunction {
		int call(int arg);
	}
 
	

	static int[] fs(IntegerFunction f, int[] s) {
		int[] r = new int[s.length];
		for (int i = 0; i < s.length; i++)
			r[i] = f.call(s[i]);
		return r;		
	}
 
	interface SequenceFunction {
		int[] call(int[] arg);
	}
 
	

	

	static SequenceFunction fs(final IntegerFunction f) {
		return new SequenceFunction() {
			public int[] call(int[] s) {
				

				return fs(f, s);
			}
		};
	}
 
	static IntegerFunction f1 = new IntegerFunction() {
		public int call(int i) {
			return i * 2;
		}
	};
 
	static IntegerFunction f2 = new IntegerFunction() {
		public int call(int i) {
			return i * i;
		}
	};
 
	static SequenceFunction fsf1 = fs(f1); 

 
	static SequenceFunction fsf2 = fs(f2);
 
	public static void main([] args) {
		int[][] sequences = {
			{ 0, 1, 2, 3 },
			{ 2, 4, 6, 8 },
		};
 
		for (int[] array : sequences) {
			.out.printf(
			    ""array: %s"" +
			    ""  fsf1(array): %s"" +
			    ""  fsf2(array): %s"",
			    .toString(array),
			    .toString(fsf1.call(array)),
			    .toString(fsf2.call(array)));
		}
	}
}"
"import java.util.ArrayList;
...//class definition, etc.
public static void genPyrN(int rows){
	if(rows < 0) return;
	//save the last row here
	ArrayList<Integer> last = new ArrayList<Integer>();
	last.add(1);
	.out.println(last);
	for(int i= 1;i <= rows;++i){
		//work on the next row
		ArrayList<Integer> thisRow= new ArrayList<Integer>();
		thisRow.add(last.get(0)); //beginning
		for(int j= 1;j < i;++j){//loop the number of elements in this row
			//sum from the last row
			thisRow.add(last.get(j - 1) + last.get(j));
		}
		thisRow.add(last.get(0)); //end
		last= thisRow;//save this row
		.out.println(thisRow);
	}
}public class Pas{
	public static void main([] args){
		//usage
		pas(20);
	}
 
	public static void pas(int rows){
		for(int i = 0; i < rows; i++){
			for(int j = 0; j <= i; j++){
				.out.print(ncr(i, j) + strv);
			}
			.out.println();
		}
	}
 
	public static long ncr(int n, int r){
		return fact(n) / (fact(r) * fact(n - r));
	}
 
	public static long fact(int n){
		long ans = 1;
		for(int i = 2; i <= n; i++){
			ans *= i;
		}
		return ans;
	}
} 
public class Pascal {
	private static void printPascalLine (int n) {
		if (n < 1)
			return;
		int m = 1;
		.out.print(strv);
		for (int j=1; j<n; j++) {
			m = m * (n-j)/j;
			.out.print(m);
			.out.print(strv);
		}
		.out.println();
	}
 
	public static void printPascal (int nRows) {
		for(int i=1; i<=nRows; i++)
			printPascalLine(i);
	}
}
 "
"public class PostfixToInfix {
 
    public static void main([] args) {
        for ( e : new []{strv,
            strv}) {
            .out.printf(strv, e);
            .out.printf(strv, postfixToInfix(e));
            .out.println();
        }
    }
 
    static  postfixToInfix(final  postfix) {
 
        class Expression {
            final static  ops = strv;
 
             op, ex;
            int prec = 3;
 
            Expression( e) {
                ex = e;
            }
 
            Expression( e1,  e2,  o) {
                ex = .format(strv, e1, o, e2);
                op = o;
                prec = ops.indexOf(o) / 2;
            }
 
            @Override
            public  toString() {
                return ex;
            }
        }
 
        Stack<Expression> expr = new Stack<>();
 
        for ( token : postfix.split(""s+"")) {
            char c = token.charAt(0);
            int idx = Expression.ops.indexOf(c);
            if (idx != -1 && token.length() == 1) {
 
                Expression r = expr.pop();
                Expression l = expr.pop();
 
                int opPrec = idx / 2;
 
                if (l.prec < opPrec || (l.prec == opPrec && c == '^'))
                    l.ex = '(' + l.ex + ')';
 
                if (r.prec < opPrec || (r.prec == opPrec && c != '^'))
                    r.ex = '(' + r.ex + ')';
 
                expr.push(new Expression(l.ex, r.ex, token));
            } else {
                expr.push(new Expression(token));
            }
            .out.printf(strv, token, expr);
        }
        return expr.peek().ex;
    }
}"
"import java.util.Stack;
 
public class ShuntingYard {
 
    public static void main([] args) {
         infix = strv;
        .out.printf(strv, infix);
        .out.printf(strv, infixToPostfix(infix));
    }
 
    static  infixToPostfix( infix) {
        final  ops = strv;
        StringBuilder sb = new StringBuilder();
        Stack<Integer> s = new Stack<>();
 
        for ( token : infix.split(""s"")) {
            if (token.isEmpty())
                continue;
            char c = token.charAt(0);
            int idx = ops.indexOf(c);
 
            

            if (idx != -1) {
                if (s.isEmpty())
                    s.push(idx);
 
                else {
                    while (!s.isEmpty()) {
                        int prec2 = s.peek() / 2;
                        int prec1 = idx / 2;
                        if (prec2 > prec1 || (prec2 == prec1 && c != '^'))
                            sb.append(ops.charAt(s.pop())).append(' ');
                        else break;
                    }
                    s.push(idx);
                }
            } 
            else if (c == '(') {
                s.push(-2); 

            } 
            else if (c == ')') {
                

                while (s.peek() != -2)
                    sb.append(ops.charAt(s.pop())).append(' ');
                s.pop();
            }
            else {
                sb.append(token).append(' ');
            }
        }
        while (!s.isEmpty())
            sb.append(ops.charAt(s.pop())).append(' ');
        return sb.toString();
    }
}"
"import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.regex.Pattern;
 
import javax.xml.bind.DatatypeConverter;
 
/** * Parses ipv4 and ipv6 addresses. Emits each described IP address as a * hexadecimal integer representing the address, the address space, and the port * number specified, if any. */
public class IPParser {
	/*	 * Using regex to ensure that the address is a valid one. This allows for	 * separating by format and ensures that the operations done on a format	 * will be valid.	 */
	

	private final  ipv4segment =
			strv;
 
	

	private final  portsegment =
			strv
					+ strv;
	private final  ipv4address = strv + ipv4segment + "".){3,3}""
			+ ipv4segment;
	private final  ipv4addressWithPort = ipv4address + portsegment + strv;
	private final  ipv6segment = strv;
	private final  ipv6address = strv +
	

			strv + ipv6segment + strv + ipv6segment + strv +
	

			strv + ipv6segment + strv +
			

			strv + ipv6segment + strv + ipv6segment + strv +
			

			strv + ipv6segment + strv + ipv6segment + strv +
			

			strv + ipv6segment + strv + ipv6segment + strv +
			

			strv + ipv6segment + strv + ipv6segment + strv +
			

			strv + ipv6segment + strv + ipv6segment + strv +
			

			ipv6segment + strv + ipv6segment + strv +
			// ::2:3:4:5:6:7:8, ::2:3:4:5:6:7:8, ::8, ::
			strv + ipv6segment + strv +
			

			

			strv + ipv6segment + strv +
			// ::255.255.255.255, ::ffff:255.255.255.255,
			// ::ffff:0:255.255.255.255 (IPv4-mapped IPv6 addresses and
			

			strv + ipv4address + strv +
			

			

			strv + ipv6segment + strv + ipv4address + strv;
 
	private final  ipv6addressWithPort = ""["" + ipv6address + ""]""
			+ portsegment + strv;
 
	/**	 * Parses ipv4 and ipv6 addresses. Emits each described IP address as a	 * hexadecimal integer representing the address, the address space, and the	 * port number specified, if any.	 * 	 * @param address the address to analyze	 */
	public void parse( address) {
 
		

		 space = strv;

		 hex = strv;

		 port = strv;

 
		

		

		if (Pattern.matches(strv + ipv4address + strv, address)) {
			 a;
			space = strv;
			try {
				a = .getByName(address);
				hex = DatatypeConverter.printHexBinary(a.getAddress());
			}
			catch ( e) {
				e.printStackTrace();
				hex = strv;
			}
			port = strv;
		}
		else if (Pattern.matches(strv + ipv4addressWithPort + strv, address)) {
			[] parts = address.split(""."");
			port = parts[3].split(strv)[1];
			parts[3] = parts[3].split(strv)[0];
			 a;
			space = strv;
			try {
				address = parts[0] + parts[1] + parts[2] + parts[3];
				a = .getByName(address);
				hex = DatatypeConverter.printHexBinary(a.getAddress());
			}
			catch ( e) {
				e.printStackTrace();
				hex = strv;
			}
		}
		else if (Pattern.matches(strv + ipv6address + strv, address)) {
			 a;
			space = strv;
			try {
				a = Inet6Address.getByName(address);
				hex = DatatypeConverter.printHexBinary(a.getAddress());
			}
			catch ( e) {
				e.printStackTrace();
				hex = strv;
			}
			port = strv;
		}
		else if (Pattern.matches(strv + ipv6addressWithPort + strv, address)) {
			[] parts = address.split(strv);
			 a;
			space = strv;
			address =
					address.replace(strv, strv).replace(strv, strv)
							.replaceAll(portsegment + strv, strv);
			try {
				a = Inet6Address.getByName(address);
				hex = DatatypeConverter.printHexBinary(a.getAddress());
			}
			catch ( e) {
				e.printStackTrace();
				hex = strv;
			}
			port = parts[parts.length - 1];
		}
		else {
			

			hex = strv;
			space = strv;
			port = strv;
		}
 
		

		.out.println(strv + address + strv);
		.out.println(strv + space);
		.out.println(strv + hex);
		.out.println(strv + port);
		.out.println();
 
	}
 
	/**	 * Tests the parser using various addresses.	 * 	 * @param args arguments for the program	 */
	public static void main([] args) {
		IPParser parser = new IPParser();
 
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		

		parser.parse(strv);
 
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		parser.parse(strv);
		

		parser.parse(strv);
	}
}
 "
" 
grammar rpnC ;
//


//


//
@members {
Stack<Double> s = new Stack<Double>();
}
rpn	:	(WS* (num|op) (WS | WS* NEWLINE {.out.println(s.pop());}))*;
num	:	'-'? Digit+ ('.' Digit+)? {s.push(.parseDouble($num.text));};
Digit	:	'0'..'9';
op	:	'-' {double x = s.pop(); s.push(s.pop() - x);}
	|	'/' {double x = s.pop(); s.push(s.pop() / x);}
	|	'*' {s.push(s.pop() * s.pop());}
	|	'^' {double x = s.pop(); s.push(.pow(s.pop(), x));}
	|	'+' {s.push(s.pop() + s.pop());};
WS	:	(' ' | ''){skip()};
NEWLINE	:	''? '';
 "
"import java.sql.DriverManager;
import java.sql.Connection;
import java.sql.PreparedStatement;
 
public class DBDemo{
   private  protocol; //set this to some connection protocol like strv
   private  dbName;   //set this to the name of your database
   private  username;
   private  password;
 
    conn = .getConnection(protocol + dbName, username, password);
    query;
 
   public int setUpAndExecPS(){
      query = conn.prepareStatement(
            strv);
 
      query.setString(1, strv);//automatically sanitizes and adds quotes
      query.setInt(2, 42);
      query.setBoolean(3, true);
      query.setInt(4, 99);
      //there are similar methods for other SQL types in PerparedStatement
 
      return query.executeUpdate();//returns the number of rows changed
      //PreparedStatement.executeQuery() will return a java.sql.ResultSet,
      //execute() will simply return a boolean saying whether it succeeded or not
   }
}"
"public class Tree<T>{
	private T value;
	private Tree<T> left;
	private Tree<T> right;
 
	public void replaceAll(T value){
		this.value = value;
		if(left != null)
			left.replaceAll(value);
		if(right != null)
			right.replaceAll(value);
	}
}"
"import static java.lang..out;
 
import static java.util..stream;
import static java.util..comparing;
 
public interface ParallelCalculations {
  public static final long[] NUMBERS = {
    12757923,
    12878611,
    12878893,
    12757923,
    15808973,
    15780709,
    197622519
  };
 
  public static void main(... arguments) {
    stream(NUMBERS)
      .unordered()
      .parallel()
      .mapToObj(ParallelCalculations::minimalPrimeFactor)
      .max(comparing(a -> a[0]))
      .ifPresent(res -> out.printf(
        strv,
        res[1],
        res[0]
      ))
    ;
  }
 
  public static long[] minimalPrimeFactor(long n) {
    return iterate(2, i -> i + 1)
      .filter(i -> n >= i * i)
      .filter(i -> n % i == 0)
      .mapToObj(i -> new long[]{i, n})
      .findFirst()
      .orElseGet(() -> new long[]{n, n})
    ;
  }
}"
"import java.math.BigInteger;
import java.util.Arrays;
 
class Test {
    final static int nMax = 250;
    final static int nBranches = 4;
 
    static [] rooted = new [nMax + 1];
    static [] unrooted = new [nMax + 1];
    static [] c = new [nBranches];
 
    static void tree(int br, int n, int l, int inSum,  cnt) {
        int sum = inSum;
        for (int b = br + 1; b <= nBranches; b++) {
            sum += n;
 
            if (sum > nMax || (l * 2 >= sum && b >= nBranches))
                return;
 
             tmp = rooted[n];
            if (b == br + 1) {
                c[br] = tmp.multiply(cnt);
            } else {
                c[br] = c[br].multiply(tmp.add(.valueOf(b - br - 1)));
                c[br] = c[br].divide(.valueOf(b - br));
            }
 
            if (l * 2 < sum)
                unrooted[sum] = unrooted[sum].add(c[br]);
 
            if (b < nBranches)
                rooted[sum] = rooted[sum].add(c[br]);
 
            for (int m = n - 1; m > 0; m--)
                tree(b, m, l, sum, c[br]);
        }
    }
 
    static void bicenter(int s) {
        if ((s & 1) == 0) {
             tmp = rooted[s / 2];
            tmp = tmp.add(.ONE).multiply(rooted[s / 2]);
            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));
        }
    }
 
    public static void main([] args) {
        .fill(rooted, .ZERO);
        .fill(unrooted, .ZERO);
        rooted[0] = rooted[1] = .ONE;
        unrooted[0] = unrooted[1] = .ONE;
 
        for (int n = 1; n <= nMax; n++) {
            tree(0, n, n, 1, .ONE);
            bicenter(n);
            .out.printf(strv, n, unrooted[n]);
        }
    }
}"
"public static boolean pali( testMe){
	StringBuilder sb = new StringBuilder(testMe);
	return testMe.equals(sb.reverse().toString());
}public static boolean rPali( testMe){
	if(testMe.length()<=1){
		return true;
	}
	if(!(testMe.charAt(0)+strv).equals(testMe.charAt(testMe.length()-1)+strv)){
		return false;
	}
	return rPali(testMe.substring(1, testMe.length()-1));
}public static boolean rPali( testMe){
	int strLen = testMe.length();
	return rPaliHelp(testMe, strLen-1, strLen/2, 0);
}
 
public static boolean rPaliHelp( testMe, int strLen, int testLen, int index){
	if(index > testLen){
		return true;
	}
	if(testMe.charAt(index) != testMe.charAt(strLen-index)){
		return false;
	}
	return rPaliHelp(testMe, strLen, testLen, index + 1);
}
 public static boolean pali( testMe){
	return testMe.matches(""|(?:(.)(?<=(?=^.*?(12?)$).*))+(?<=(?=^2$).*)"");
}"
"import java.util.Arrays;
import java.util.BitSet;
import org.apache.commons.lang3.ArrayUtils;
 
public class OrderDisjointItems {
 
    public static void main([] args) {
        final [][] MNs = {{strv, strv},
        {strv, strv},
        {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv}};
 
        for ([] a : MNs) {
            [] r = orderDisjointItems(a[0].split(strv), a[1].split(strv));
            .out.printf(strv, a[0], a[1], .toString(r));
        }
    }
 
    

    static [] orderDisjointItems([] m, [] n) {
        for ( e : n) {
            int idx = ArrayUtils.indexOf(m, e);
            if (idx != -1)
                m[idx] = null;
        }
        for (int i = 0, j = 0; i < m.length; i++) {
            if (m[i] == null)
                m[i] = n[j++];
        }
        return m;
    }
 
    

    static [] orderDisjointItems2([] m, [] n) {
         bitSet = new (m.length);
        for ( e : n) {
            int idx = -1;
            do {
                idx = ArrayUtils.indexOf(m, e, idx + 1);
            } while (idx != -1 && bitSet.get(idx));
            if (idx != -1)
                bitSet.set(idx);
        }
        for (int i = 0, j = 0; i < m.length; i++) {
            if (bitSet.get(i))
                m[i] = n[j++];
        }
        return m;
    }
}"
"import java.util.*;
 
public class OptionalParams {
    

    static <T extends Comparable<? super T>> Comparator<T> naturalOrdering() {
        return .reverseOrder(.<T>reverseOrder());
    }
 
    public static <T extends Comparable<? super T>> void
                             sortTable(T[][] table) {
        sortTable(table, 0);
    }
    public static <T extends Comparable<? super T>> void
                             sortTable(T[][] table,
                                       int column) {
        sortTable(table, column, false);
    }
    public static <T extends Comparable<? super T>> void
                             sortTable(T[][] table,
                                       int column, boolean reverse) {
        sortTable(table, column, reverse, OptionalParams.<T>naturalOrdering());
    }
    public static <T> void sortTable(T[][] table,
                                     final int column,
                                     final boolean reverse,
                                     final Comparator<T> ordering) {
        Comparator<T[]> myCmp = new Comparator<T[]>() {
            public int compare(T[] x, T[] y) {
                return (reverse ? -1 : 1) *
                       ordering.compare(x[column], y[column]);
            }
        };
        .sort(table, myCmp);
    }
 
    public static void main([] args) {
        [][] data0 = {{strv, strv, strv},
                            {strv, strv, strv},
                            {strv, strv, strv}};
        .out.println(.deepToString(data0));
        

 
        

        [][] data = data0.clone();
        sortTable(data);
        .out.println(.deepToString(data));
        

 
        data = data0.clone();
        sortTable(data, 2);
        .out.println(.deepToString(data));
        

 
        data = data0.clone();
        sortTable(data, 1);
        .out.println(.deepToString(data));
        

 
        data = data0.clone();
        sortTable(data, 1, true);
        .out.println(.deepToString(data));
        

 
        data = data0.clone();
        sortTable(data, 0, false, new Comparator<String>() {
                public int compare( a,  b) {
                    return b.length() - a.length();
                }
            });
        .out.println(.deepToString(data));
        

    }
}"
"import org.lwjgl.LWJGLException;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import static org.lwjgl.opengl.GL11.*;
 
 
public class OpenGlExample {
 
	public void run() throws LWJGLException {
		Display.setDisplayMode(new DisplayMode(640, 480));
		Display.create();
 
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(-30, 30, -30, 30, -30, 30);
		glMatrixMode(GL_MODELVIEW);
 
		while(!Display.isCloseRequested()) {
			render();
 
			Display.update();
		}
 
		Display.destroy();
	}
 
	public void render() {
 
		glClearColor(0.3f, 0.3f, 0.3f, 0.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
		glShadeModel(GL_SMOOTH);
 
		glLoadIdentity();
		glTranslatef(-15.0f, -15.0f, 0.0f);
 
		glBegin(GL_TRIANGLES);
		glColor3f(1.0f, 0.0f, 0.0f);
		glVertex2f(0.0f, 0.0f);
		glColor3f(0.0f, 1.0f, 0.0f);
		glVertex2f(30f, 0.0f);
		glColor3f(0.0f, 0.0f, 1.0f);
		glVertex2f(0.0f, 30.0f);
		glEnd();
 
	}
 
	public static void main([] args) {
		OpenGlExample openGlExmpl = new OpenGlExample();
		try {
			openGlExmpl.run();
		} catch(LWJGLException e) {
			.err.println(e);
		}
	}
 
}
 
 "
"public class Life{
	public static void main([] args) throws {
		 start= strv;
		int numGens = 10;
		for(int i= 0; i < numGens; i++){
			.out.println(strv + i + strv + start);
			start= life(start);
		}
	}
 
	public static  life( lastGen){
		 newGen= strv;
		for(int i= 0; i < lastGen.length(); i++){
			int neighbors= 0;
			if (i == 0){//left edge
				neighbors= lastGen.charAt(1) == '#' ? 1 : 0;
			} else if (i == lastGen.length() - 1){//right edge
				neighbors= lastGen.charAt(i - 1) == '#' ? 1 : 0;
			} else{//middle
				neighbors= getNeighbors(lastGen.substring(i - 1, i + 2));
			}
 
			if (neighbors == 0){//dies or stays dead with no neighbors
				newGen+= strv;
			}
			if (neighbors == 1){//stays with one neighbor
				newGen+= lastGen.charAt(i);
			}
			if (neighbors == 2){//flips with two neighbors
				newGen+= lastGen.charAt(i) == '#' ? strv : strv;
			}
		}
		return newGen;
	}
 
	public static int getNeighbors( group){
		int ans= 0;
		if (group.charAt(0) == '#') ans++;
		if (group.charAt(2) == '#') ans++;
		return ans;
	}
}public class Life{
	private static char[] trans = strv.toCharArray();
 
	private static int v(StringBuilder cell, int i){
		return (cell.charAt(i) != '_') ? 1 : 0;
	}
 
	public static boolean evolve(StringBuilder cell){
		boolean diff = false;
		StringBuilder backup = new StringBuilder(cell.toString());
 
		for(int i = 1; i < cell.length() - 3; i++){
			/* use left, self, right as binary number bits for table index */
			backup.setCharAt(i, trans[v(cell, i - 1) * 4 + v(cell, i) * 2
			      					+ v(cell, i + 1)]);
			diff = diff || (backup.charAt(i) != cell.charAt(i));
		}
 
		cell.delete(0, cell.length());//clear the buffer
		cell.append(backup);//replace it with the new generation
		return diff;
	}
 
	public static void main([] args){
		StringBuilder  c = new StringBuilder(""_###_##_#_#_#_#__#__"");
 
		do{
			.out.printf(c.substring(1));
		}while(evolve(c));
	}
}"
"import java.util.Arrays;
import java.util.Random;
 
public class OneOfNLines {
 
	static  rand;
 
	public static int oneOfN(int n) {
		int choice = 0;
 
		for(int i = 1; i < n; i++) {
			if(rand.nextInt(i+1) == 0)
				choice = i;
		}
 
		return choice;
	}
 
	public static void main([] args) {
		int n = 10;
		int trials = 1000000;
		int[] bins = new int[n];
		rand = new ();
 
		for(int i = 0; i < trials; i++)
			bins[oneOfN(n)]++;
 
 
		.out.println(.toString(bins));
	}
}
 "
"public class OldRussianMeasures {
 
    final static [] keys = {strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv,
        strv, strv};
 
    final static double[] values = {0.000254, 0.00254, 0.01,0.0254,
        0.04445, 0.1778, 0.3048, 0.7112, 1.0, 2.1336, 1000.0,
        1066.8, 7467.6};
 
    public static void main([] a) {
        if (a.length == 2 && a[0].matches(""[+-]?d*(.d+)?"")) {
            double inputVal = lookup(a[1]);
            if (!.isNaN(inputVal)) {
                double magnitude = .parseDouble(a[0]);
                double meters = magnitude * inputVal;
                .out.printf(strv, a[0], a[1]);
                for ( k: keys)
                    .out.printf(strv, k, meters / lookup(k));
                return;
            }
        }
        .out.println(strv);
 
    }
 
    public static double lookup( key) {
        for (int i = 0; i < keys.length; i++)
            if (keys[i].equals(key))
                return values[i];
        return .NaN;
    }
}"
"public class OldLadySwallowedAFly {
 
    final static [] data = {
        strv
        + strv
        + strv
        + strv, strv, strv, strv, strv
        + strv, strv, strv
        + strv, strv, strv, strv
        + strv, strv, strv, strv, strv
        + strv, strv, strv, strv, strv, strv, strv, strv
        + strv, strv};
 
    static boolean oldLady( part, boolean s) {
        for (char c : part.toCharArray()) {
            if (s)
                s = oldLady(data[c - '_'], false);
            else if (c == '_')
                s = true;
            else
                .out.print(c == '/' ? '' : c);
        }
        return s;
    }
 
    public static void main([] args) {
        oldLady(data[0], false);
    }
}"
"public class OddWord {
    interface CharHandler {
	CharHandler handle(char c) throws ;
    }
    final CharHandler fwd = new CharHandler() {
	public CharHandler handle(char c) {
	    .out.print(c);
	    return (.isLetter(c) ? fwd : rev);
	}
    };
    class Reverser extends  implements CharHandler {
	Reverser() {
	    setDaemon(true);
	    start();
	}
	private  ch; 

	private char recur() throws  {
	    notify();
	    while (ch == null) wait();
	    char c = ch, ret = c;
	    ch = null;
	    if (.isLetter(c)) {
		ret = recur();
		.out.print(c);
	    }
	    return ret;
	}
	public synchronized void run() {
	    try {
		while (true) {
		    .out.print(recur());
		    notify();
		}
	    } catch ( e) {}
	}
	public synchronized CharHandler handle(char c) throws  {
	    while (ch != null) wait();
	    ch = c;
	    notify();
	    while (ch != null) wait();
	    return (.isLetter(c) ? rev : fwd);
	}
    }
    final CharHandler rev = new Reverser();
 
    public void loop() throws  {
	CharHandler handler = fwd;
	int c;
	while ((c = .in.read()) >= 0) {
	    handler = handler.handle((char) c);
	}
    }
 
    public static void main([] args) throws  {
	new OddWord().loop();
    }
}"
"import java.io.*;
 


class  implements  {
    

    

    static final long serialVersionUID = 3504465751164822571L;
     name = strv;
    public  toString() { return name; }
}
 
class Person extends  implements  {
    static final long serialVersionUID = -9170445713373959735L;
    Person() { name = strv; }
}
 
public class SerializationTest {
    public static void main([] args) {
        Person instance1 = new Person();
        .out.println(instance1);
 
         instance2 = new ();
        .out.println(instance2);
 
        

        try {
             out = new (new (strv)); 

 
            out.writeObject(instance1); 

            out.writeObject(instance2);
            out.close();
            .out.println(strv);
        } catch ( e) {
            .err.println(strv);
            e.printStackTrace();
            .exit(1);
        }
 
        

        try {
             in = new (new (strv)); 

 
             readObject1 = in.readObject(); 

             readObject2 = in.readObject(); 

            in.close();
            .out.println(strv);
 
            .out.println(readObject1);
            .out.println(readObject2);
        } catch ( e) {
            .err.println(strv);
            e.printStackTrace();
            .exit(1);
        } catch ( e) {
            .err.println(strv);
            e.printStackTrace();
            .exit(1);
        }
    }
}"
"import static java.util..*;
import static java.lang..out;
 
public class NYSIIS {
 
    final static [][] first = {{strv, strv}, {strv, strv}, {strv, strv},
    {strv, strv}, {strv, strv}, {strv, strv}};
 
    final static [][] last = {{strv, strv}, {strv, strv}, {strv, strv},
    {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv}};
 
    final static  Vowels = strv;
 
    public static void main([] args) {
        stream(args).parallel().map(n -> transcode(n)).forEach(out::println);
    }
 
    static  transcode( s) {
        int len = s.length();
        StringBuilder sb = new StringBuilder(len);
 
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (c >= 'a' && c <= 'z')
                sb.append((char) (c - 32));
            else if (c >= 'A' && c <= 'Z')
                sb.append(c);
        }
 
        replace(sb, 0, first);
        replace(sb, sb.length() - 2, last);
 
        len = sb.length();
        sb.append(strv);
        for (int i = 1; i < len; i++) {
            char prev = sb.charAt(i - 1);
            char curr = sb.charAt(i);
            char next = sb.charAt(i + 1);
 
            if (curr == 'E' && next == 'V')
                sb.replace(i, i + 2, strv);
 
            else if (isVowel(curr))
                sb.setCharAt(i, 'A');
 
            else if (curr == 'Q')
                sb.setCharAt(i, 'G');
 
            else if (curr == 'Z')
                sb.setCharAt(i, 'S');
 
            else if (curr == 'M')
                sb.setCharAt(i, 'N');
 
            else if (curr == 'K' && next == 'N')
                sb.setCharAt(i, 'N');
 
            else if (curr == 'K')
                sb.setCharAt(i, 'C');
 
            else if (sb.indexOf(strv, i) == i)
                sb.replace(i, i + 3, strv);
 
            else if (curr == 'P' && next == 'H')
                sb.replace(i, i + 2, strv);
 
            else if (curr == 'H' && (!isVowel(prev) || !isVowel(next)))
                sb.setCharAt(i, prev);
 
            else if (curr == 'W' && isVowel(prev))
                sb.setCharAt(i, prev);
 
            if (sb.charAt(i) == prev) {
                sb.deleteCharAt(i--);
                len--;
            }
        }
        sb.setLength(sb.length() - 1); 

 
        int lastPos = sb.length() - 1;
        if (lastPos > 1) {
 
            if (sb.lastIndexOf(strv) == lastPos - 1)
                sb.delete(lastPos - 1, lastPos + 1).append(strv);
 
            else if (sb.charAt(lastPos) == 'S')
                sb.setLength(lastPos);
 
            else if (sb.charAt(lastPos) == 'A')
                sb.setLength(lastPos);
        }
 
        if (sb.length() > 6)
            sb.insert(6, '[').append(']');
 
        return .format(strv, s, sb);
    }
 
    private static void replace(StringBuilder sb, int start, [][] maps) {
        if (start >= 0)
            for ([] map : maps) {
                if (sb.indexOf(map[0]) == start) {
                    sb.replace(start, start + map[0].length(), map[1]);
                    break;
                }
            }
    }
 
    private static boolean isVowel(char c) {
        return Vowels.indexOf(c) != -1;
    }
}"
"import static java.lang..*;
import java.util.function.Function;
 
public class Test {
    final static int N = 5;
 
    static double[] lroots = new double[N];
    static double[] weight = new double[N];
    static double[][] lcoef = new double[N + 1][N + 1];
 
    static void legeCoef() {
        lcoef[0][0] = lcoef[1][1] = 1;
 
        for (int n = 2; n <= N; n++) {
 
            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;
 
            for (int i = 1; i <= n; i++) {
                lcoef[n][i] = ((2 * n - 1) * lcoef[n - 1][i - 1]
                        - (n - 1) * lcoef[n - 2][i]) / n;
            }
        }
    }
 
    static double legeEval(int n, double x) {
        double s = lcoef[n][n];
        for (int i = n; i > 0; i--)
            s = s * x + lcoef[n][i - 1];
        return s;
    }
 
    static double legeDiff(int n, double x) {
        return n * (x * legeEval(n, x) - legeEval(n - 1, x)) / (x * x - 1);
    }
 
    static void legeRoots() {
        double x, x1;
        for (int i = 1; i <= N; i++) {
            x = cos(PI * (i - 0.25) / (N + 0.5));
            do {
                x1 = x;
                x -= legeEval(N, x) / legeDiff(N, x);
            } while (x != x1);
 
            lroots[i - 1] = x;
 
            x1 = legeDiff(N, x);
            weight[i - 1] = 2 / ((1 - x * x) * x1 * x1);
        }
    }
 
    static double legeInte(Function<, Double> f, double a, double b) {
        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;
        for (int i = 0; i < N; i++)
            sum += weight[i] * f.apply(c1 * lroots[i] + c2);
        return c1 * sum;
    }
 
    public static void main([] args) {
        legeCoef();
        legeRoots();
 
        .out.print(strv);
        for (int i = 0; i < N; i++)
            .out.printf(strv, lroots[i]);
 
        .out.print(""Weight:"");
        for (int i = 0; i < N; i++)
            .out.printf(strv, weight[i]);
 
        .out.printf(""%nintegrating Exp(x) over [-3, 3]:%n%10.8f,%n""
                + ""compared to actual%n%10.8f%n"",
                legeInte(x -> exp(x), -3, 3), exp(3) - exp(-3));
    }
}"
"public class Approx {
    private double value;
    private double error;
 
    public Approx(){this.value = this.error = 0;}
 
    public Approx(Approx b){
        this.value = b.value;
        this.error = b.error;
    }
 
    public Approx(double value, double error){
        this.value = value;
        this.error = error;
    }
 
    public Approx add(Approx b){
        value+= b.value;
        error = .sqrt(error * error + b.error * b.error);
        return this;
    }
 
    public Approx add(double b){
        value+= b;
        return this;
    }
 
    public Approx sub(Approx b){
        value-= b.value;
        error = .sqrt(error * error + b.error * b.error);
        return this;
    }
 
    public Approx sub(double b){
        value-= b;
        return this;
    }
 
    public Approx mult(Approx b){
        double oldVal = value;
        value*= b.value;
        error = .sqrt(value * value * (error*error) / (oldVal*oldVal) +
                                  (b.error*b.error) / (b.value*b.value));
        return this;
    }
 
    public Approx mult(double b){
        value*= b;
        error = .abs(b * error);
        return this;
    }
 
    public Approx div(Approx b){
        double oldVal = value;
        value/= b.value;
        error = .sqrt(value * value * (error*error) / (oldVal*oldVal) +
                                  (b.error*b.error) / (b.value*b.value));
        return this;
    }
 
    public Approx div(double b){
        value/= b;
        error = .abs(b * error);
        return this;
    }
 
    public Approx pow(double b){
        double oldVal = value;
        value = .pow(value, b);
        error = .abs(value * b * (error / oldVal));
        return this;
    }
 
    @Override
    public  toString(){return value+strv+error;}
 
    public static void main([] args){
        Approx x1 = new Approx(100, 1.1);
        Approx y1 = new Approx(50, 1.2);
        Approx x2 = new Approx(200, 2.2);
        Approx y2 = new Approx(100, 2.3);
 
        x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);
 
        .out.println(x1);
    }
}"
"

if (object == null) {
   .out.println(strv);
}"
"public class Int2Words {
    static [] small = {strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv};
    static [] tens = {strv, strv, strv, strv, strv, strv, strv,
        strv};
    static [] big = {strv, strv, strv, strv};
 
    public static void main([] args) {
        .out.println(int2Text(900000001));
        .out.println(int2Text(1234567890));
        .out.println(int2Text(-987654321));
        .out.println(int2Text(0));
    }
 
    public static  int2Text(long number) {
        long num = 0;
         outP = strv;
        int unit = 0;
        long tmpLng1 = 0;
 
        if (number == 0) {
            return strv;
        }
 
        num = .abs(number);
 
        for (;;) {
            tmpLng1 = num % 100;
            if (tmpLng1 >= 1 && tmpLng1 <= 19) {
                outP = small[(int) tmpLng1 - 1] + strv + outP;
            } else if (tmpLng1 >= 20 && tmpLng1 <= 99) {
                if (tmpLng1 % 10 == 0) {
                    outP = tens[(int) (tmpLng1 / 10) - 2] + strv + outP;
                } else {
                    outP = tens[(int) (tmpLng1 / 10) - 2] + strv
                            + small[(int) (tmpLng1 % 10) - 1] + strv + outP;
                }
            }
 
            tmpLng1 = (num % 1000) / 100;
            if (tmpLng1 != 0) {
                outP = small[(int) tmpLng1 - 1] + strv + outP;
            }
 
            num /= 1000;
            if (num == 0) {
                break;
            }
 
            tmpLng1 = num % 1000;
            if (tmpLng1 != 0) {
                outP = big[unit] + strv + outP;
            }
            unit++;
        }
 
        if (number < 0) {
            outP = strv + outP;
        }
 
        return outP.trim();
    }
}public class NumberToWordsConverter { 

 
	final private  static [] units = {strv,strv,strv,strv,strv,
		strv,strv,strv,strv,strv,strv,
		strv,strv,strv,strv,strv,
		strv,strv,strv,strv};
	final private static [] tens = {strv,strv,strv,strv,strv,strv,
		strv,strv,strv,strv};
 
	public static  convert( i) {
		//
		if( i < 20)  return units[i];
		if( i < 100) return tens[i/10] + ((i % 10 > 0)? strv + convert(i % 10):strv);
		if( i < 1000) return units[i/100] + strv + ((i % 100 > 0)?strv + convert(i % 100):strv);
		if( i < 1000000) return convert(i / 1000) + strv + ((i % 1000 > 0)? strv + convert(i % 1000):strv) ;
		return convert(i / 1000000) + strv + ((i % 1000000 > 0)? strv + convert(i % 1000000):strv) ;
	}
}"
"import java.util.*;
import static java.util..stream;
import static java.util.stream.Collectors.toList;
 
public class Nonoblock {
 
    public static void main([] args) {
        printBlock(strv, 5);
        printBlock(strv, 5);
        printBlock(strv, 10);
        printBlock(strv, 15);
        printBlock(strv, 5);
    }
 
    static void printBlock( data, int len) {
        int sumChars = data.chars().map(c -> .digit(c, 10)).sum();
        [] a = data.split(strv);
 
        .out.printf(strv, .toString(a), len);
        if (len - sumChars <= 0) {
            .out.println(strv);
            return;
        }
 
        List<String> prep = stream(a).filter(x -> !strv.equals(x))
                .map(x -> repeat(.digit(x.charAt(0), 10), strv))
                .collect(toList());
 
        for ( r : genSequence(prep, len - sumChars + 1))
            .out.println(r.substring(1));
    }
 
    

    static List<String> genSequence(List<String> ones, int numZeros) {
        if (ones.isEmpty())
            return .asList(repeat(numZeros, strv));
 
        List<String> result = new ArrayList<>();
        for (int x = 1; x < numZeros - ones.size() + 2; x++) {
            List<String> skipOne = ones.stream().skip(1).collect(toList());
            for ( tail : genSequence(skipOne, numZeros - x))
                result.add(repeat(x, strv) + ones.get(0) + tail);
        }
        return result;
    }
 
    static  repeat(int n,  s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++)
            sb.append(s);
        return sb.toString();
    }
}"
"public static double nthroot(int n, double A) {
	return nthroot(n, A, .001);
}
public static double nthroot(int n, double A, double p) {
	if(A < 0) {
		.err.println(strv);

		return -1;
	} else if(A == 0) {
		return 0;
	}
	double x_prev = A;
	double x = A / n;  

	while(.abs(x - x_prev) > p) {
		x_prev = x;
		x = ((n - 1.0) * x + A / .pow(x, n - 1.0)) / n;
	}
	return x;
}public static double nthroot(int n, double x) {
  assert (n > 1 && x > 0);
  int np = n - 1;
  double g1 = x;
  double g2 = iter(g1, np, n, x);
  while (g1 != g2) {
    g1 = iter(g1, np, n, x);
    g2 = iter(iter(g2, np, n, x), np, n, x);
  }
  return g1;
}
 
private static double iter(double g, int np, int n, double x) {
  return (np * g + x / .pow(g, np)) / n;
}"
"import java.util.*;
import static java.util..*;
import static java.util.stream.Collectors.toList;
 
public class NonogramSolver {
 
    static [] p1 = {strv, strv};
 
    static [] p2 = {strv, strv
        + strv};
 
    static [] p3 = {strv
        + strv,
        strv
        + strv};
 
    static [] p4 = {strv
        + strv, strv
        + strv};
 
    public static void main([] args) {
        for ([] puzzleData : new [][]{p1, p2, p3, p4})
            newPuzzle(puzzleData);
    }
 
    static void newPuzzle([] data) {
        [] rowData = data[0].split(""s"");
        [] colData = data[1].split(""s"");
 
        List<List<BitSet>> cols, rows;
        rows = getCandidates(rowData, colData.length);
        cols = getCandidates(colData, rowData.length);
 
        int numChanged;
        do {
            numChanged = reduceMutual(cols, rows);
            if (numChanged == -1) {
                .out.println(strv);
                return;
            }
        } while (numChanged > 0);
 
        for (List<BitSet> row : rows) {
            for (int i = 0; i < cols.size(); i++)
                .out.print(row.get(0).get(i) ? strv : strv);
            .out.println();
        }
        .out.println();
    }
 
    

    static List<List<BitSet>> getCandidates([] data, int len) {
        List<List<BitSet>> result = new ArrayList<>();
 
        for ( s : data) {
            List<BitSet> lst = new LinkedList<>();
 
            int sumChars = s.chars().map(c -> c - 'A' + 1).sum();
            List<String> prep = stream(s.split(strv))
                    .map(x -> repeat(x.charAt(0) - 'A' + 1, strv)).collect(toList());
 
            for ( r : genSequence(prep, len - sumChars + 1)) {
                char[] bits = r.substring(1).toCharArray();
                 bitset = new (bits.length);
                for (int i = 0; i < bits.length; i++)
                    bitset.set(i, bits[i] == '1');
                lst.add(bitset);
            }
            result.add(lst);
        }
        return result;
    }
 
    

    static List<String> genSequence(List<String> ones, int numZeros) {
        if (ones.isEmpty())
            return asList(repeat(numZeros, strv));
 
        List<String> result = new ArrayList<>();
        for (int x = 1; x < numZeros - ones.size() + 2; x++) {
            List<String> skipOne = ones.stream().skip(1).collect(toList());
            for ( tail : genSequence(skipOne, numZeros - x))
                result.add(repeat(x, strv) + ones.get(0) + tail);
        }
        return result;
    }
 
    static  repeat(int n,  s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++)
            sb.append(s);
        return sb.toString();
    }
 
    /* If all the candidates for a row have a value in common for a certain cell,    then it's the only possible outcome, and all the candidates from the    corresponding column need to have that value for that cell too. The ones    that don't, are removed. The same for all columns. It goes back and forth,    until no more candidates can be removed or a list is empty (failure). */
 
    static int reduceMutual(List<List<BitSet>> cols, List<List<BitSet>> rows) {
        int countRemoved1 = reduce(cols, rows);
        if (countRemoved1 == -1)
            return -1;
 
        int countRemoved2 = reduce(rows, cols);
        if (countRemoved2 == -1)
            return -1;
 
        return countRemoved1 + countRemoved2;
    }
 
    static int reduce(List<List<BitSet>> a, List<List<BitSet>> b) {
        int countRemoved = 0;
 
        for (int i = 0; i < a.size(); i++) {
 
             commonOn = new ();
            commonOn.set(0, b.size());
             commonOff = new ();
 
            

            for ( candidate : a.get(i)) {
                commonOn.and(candidate);
                commonOff.or(candidate);
            }
 
            

            for (int j = 0; j < b.size(); j++) {
                final int fi = i, fj = j;
 
                if (b.get(j).removeIf(cnd -> (commonOn.get(fj) && !cnd.get(fi))
                        || (!commonOff.get(fj) && cnd.get(fi))))
                    countRemoved++;
 
                if (b.get(j).isEmpty())
                    return -1;
            }
        }
        return countRemoved;
    }
}"
"int number = .parseInt(stringNum, base);.decode(strv); 

.decode(strv);     

.decode(strv);    
"
"public static long backToTen( num, int oldBase){
   return .parseLong(num, oldBase); //takes both uppercase and lowercase letters
}
 
public static  tenToBase(long num, int newBase){
   return .toString(num, newBase);//add .toUpperCase() for capital letters
}public static  backToTenBig( num, int oldBase){
   return new (num, oldBase); //takes both uppercase and lowercase letters
}
 
public static  tenBigToBase( num, int newBase){
   return num.toString(newBase);//add .toUpperCase() for capital letters
}"
"import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.TimeZone;
 
public class NauticalBell extends  {
 
    public static void main([] args) {
        NauticalBell bells = new NauticalBell();
        bells.setDaemon(true);
        bells.start();
        try {
            bells.join();
        } catch ( e) {
            .out.println(e);
        }
    }
 
    @Override
    public void run() {
         sdf = new (strv);
        sdf.setTimeZone(.getTimeZone(strv));
 
        int numBells = 0;
        long time = .currentTimeMillis();
        long next = time - (time % (24 * 60 * 60 * 1000)); 

 
        while (next < time) {
            next += 30 * 60 * 1000; 

            numBells = 1 + (numBells % 8);
        }
 
        while (true) {
            long wait = 100L;
            time = .currentTimeMillis();
            if (time - next >= 0) {
                 bells = numBells == 1 ? strv : strv;
                 timeString = sdf.format(time);
                .out.printf(""%s : %d %s"", timeString, numBells, bells);
                next += 30 * 60 * 1000;
                wait = next - time;
                numBells = 1 + (numBells % 8);
            }
            try {
                .sleep(wait);
            } catch ( e) {
                return;
            }
        }
    }
}"
"import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
 
public class NestedFunctionsDemo {
 
    static  makeList( separator) {
        AtomicInteger counter = new AtomicInteger(1);
 
        Function<, String> makeItem = item -> counter.getAndIncrement() + separator + item + """";
 
        return makeItem.apply(strv) + makeItem.apply(strv) + makeItem.apply(strv);
    }
 
    public static void main([] args) {
        .out.println(makeList(strv));
    }
}"
"public class NonContinuousSubsequences {
 
    public static void main( args[]) {
        seqR(strv, strv, 0, 0);
    }
 
    private static void seqR( s,  c, int i, int added) {
        if (i == s.length()) {
            if (c.trim().length() > added)
                .out.println(c);
        } else {
            seqR(s, c + s.charAt(i), i + 1, added + 1);
            seqR(s, c + ' ', i + 1, added);
        }
    }
}"
"processNutritionFacts(new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build());"
"public class Nth {
	public static  ordinalAbbrev(int n){
		 ans = strv; //most of the time it should be strv
		if(n % 100 / 10 == 1) return ans; //teens are all strv
		switch(n % 10){
			case 1: ans = strv; break;
			case 2: ans = strv; break;
			case 3: ans = strv; break;
		}
		return ans;
	}
 
	public static void main([] args){
		for(int i = 0; i <= 25;i++){
			.out.print(i + ordinalAbbrev(i) + strv);
		}
		.out.println();
		for(int i = 250; i <= 265;i++){
			.out.print(i + ordinalAbbrev(i) + strv);
		}
		.out.println();
		for(int i = 1000; i <= 1025;i++){
			.out.print(i + ordinalAbbrev(i) + strv);
		}
	}
}package nth;
 
import java.util.stream.IntStream;
import java.util.stream.Stream;
 
public interface Nth {
  public static  suffix(int n){
    if(n % 100 / 10 == 1){
      return strv; //teens are all strv
    }
    switch(n % 10){
      case 1: return strv;
      case 2: return strv;
      case 3: return strv;
      default: return strv; //most of the time it should be strv
    }
  }
 
  public static void print(int start, int end) {
    IntStream.rangeClosed(start, end)
      .parallel()
      .mapToObj(i -> i + suffix(i) + strv)
      .reduce(::concat)
      .ifPresent(.out::println)
    ;
  }
 
  public static void print(int[] startAndEnd) {
    print(startAndEnd[0], startAndEnd[1]);
  }
 
  public static int[] startAndEnd(int start, int end) {
    return new int[] {
      start,
      end
    };
  }
 
  public static void main(... arguments){
    Stream.of(
      startAndEnd(0, 25),
      startAndEnd(250, 265),
      startAndEnd(1000, 1025)
    )
      .forEach(Nth::print)
    ;
  }
}"
"public class Main {
    static  mutex = new ();
    static int i = 0;
 
    public void addAndPrint()
    {
        .out.print(strv + i + strv);
        i++;
        .out.println(strv + i);
    }
 
    public void subAndPrint()
    {
        .out.print(strv + i + strv);
        i--;
        .out.println(strv + i);
    }
 
 
    public static void main([] args){
        final Main m = new Main();
        new () {
            public void run()
            {
                while (true) { synchronized(m.mutex) { m.addAndPrint(); } }
            }
        }.start();
        new () {
            public void run()
            {
                while (true) { synchronized(m.mutex) { m.subAndPrint(); } }
            }
        }.start();
    }
}"
" 
public class Main {
    public static void main([] args) {
        for(int i = 0 ; i <= 5000 ; i++ ){
            int val = .valueOf(i).chars().map(x -> (int) .pow( x-48 ,x-48)).sum();
            if( i == val){
                .out.println( i + strv);
            }
        }
    }
}
 
 "
"public class NQueens {
 
  private static int[] b = new int[8];
  private static int s = 0;
 
  static boolean unsafe(int y) {
    int x = b[y];
    for (int i = 1; i <= y; i++) {
      int t = b[y - i];
      if (t == x ||
          t == x - i ||
          t == x + i) {
        return true;
      }
    }
 
    return false;
  }
 
  public static void putboard() {
    .out.println(""Solution "" + (++s));
    for (int y = 0; y < 8; y++) {
      for (int x = 0; x < 8; x++) {
        .out.print((b[y] == x) ? strv : strv);
      }
      .out.println(strv);
    }
  }
 
  public static void main([] args) {
    int y = 0;
    b[0] = -1;
    while (y >= 0) {
      do {
        b[y]++;
      } while ((b[y] < 8) && unsafe(y));
      if (b[y] < 8) {
        if (y < 7) {
          b[++y] = -1;
        } else {
          putboard();
        }
      } else {
        y--;
      }
    }
  }
}"
"import java.awt.Color;
import java.awt.Graphics;
 
import javax.swing.JFrame;
import javax.swing.JPanel;
 
public class XorPattern extends {
    private  xorPanel;
 
    public XorPattern(){
        xorPanel = new (){
            @Override
            public void paint( g) {
                for(int y = 0; y < getHeight();y++){
                    for(int x = 0; x < getWidth();x++){
                        g.setColor(new (0, (x ^ y) % 256, 0));
                        g.drawLine(x, y, x, y);
                    }
                }
            }
        };
        add(xorPanel);
        setSize(300, 300);
        setDefaultCloseOperation(.EXIT_ON_CLOSE);
        setVisible(true);
    }
 
    public static void main([] args){
        new XorPattern();
    }
}"
"import java.util.*;
 
public class MultiSplit {
 
    public static void main([] args) {
        .out.println(strv);
        .out.println(.toString(strv.split(strv)));
 
        .out.println(""Manual split:"");
        for ( s : multiSplit(strv, new []{strv, strv, strv}))
            .out.printf(""%s "", s);
    }
 
    static List<String> multiSplit( txt, [] separators) {
        List<String> result = new ArrayList<>();
        int txtLen = txt.length(), from = 0;
 
        for (int to = 0; to < txtLen; to++) {
            for ( sep : separators) {
                int sepLen = sep.length();
                if (txt.regionMatches(to, sep, 0, sepLen)) {
                    result.add(txt.substring(from, to));
                    from = to + sepLen;
                    to = from - 1; 

                    break;
                }
            }
        }
        if (from < txtLen)
            result.add(txt.substring(from));
        return result;
    }
}"
"Foo[] foos = new Foo[n]; 

for (int i = 0; i < foos.length; i++)
    foos[i] = new Foo();
 


Foo[] foos_WRONG = new Foo[n];
.fill(foos, new Foo());  
"
"public class MultiFact {
	private static long multiFact(long n, int deg){
		long ans = 1;
		for(long i = n; i > 0; i -= deg){
			ans *= i;
		}
		return ans;
	}
 
	public static void main([] args){
		for(int deg = 1; deg <= 5; deg++){
			.out.print(strv + deg + strv);
			for(long n = 1; n <= 10; n++){
				.out.print(strv + multiFact(n, deg));
			}
			.out.println();
		}
	}
}"
"public class MultiplicationTable {
    public static void main([] args) {
        for (int i = 1; i <= 12; i++)
            .out.print("""" + i);
 
        .out.println();
        for (int i = 0; i < 100; i++)
            .out.print(strv);
        .out.println();
        for (int i = 1; i <= 12; i++) {
            .out.print(i + strv);
            for(int j = 1; j <= 12; j++) {
                .out.print("""");
                if (j >= i)
                    .out.print("""" + i * j);
            }
            .out.println();
        }
    }
}"
"import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
 
 
public class SDF {
 
    /** Counting the number of occurrences of each character     * @param character array     * @return hashmap : Key = char, Value = num of occurrence     */
    public static HashMap<, Integer> countElementOcurrences(char[] array) {
 
        HashMap<, Integer> countMap = new HashMap<, Integer>();
 
        for (char element : array) {
             count = countMap.get(element);
            count = (count == null) ? 1 : count + 1;
            countMap.put(element, count);
        }
 
        return countMap;
    }
 
    /**     * Sorts the counted numbers of characters (keys, values) by java Collection List     * @param HashMap (with key as character, value as number of occurrences)     * @return sorted HashMap     */
    private static <K, V extends Comparable<? super V>>
            HashMap<K, V> descendingSortByValues(HashMap<K, V> map) { 
	List<.Entry<K, V>> list = new ArrayList<.Entry<K, V>>(map.entrySet());
	

	.sort(list, new Comparator<.Entry<K, V>>() {
		public int compare(.Entry<K, V> o1, .Entry<K, V> o2) {
		    return o2.getValue().compareTo(o1.getValue());
		}
	    });
 
	

	

	HashMap<K, V> sortedHashMap = new LinkedHashMap<K, V>();
	for (.Entry<K, V> entry : list) {
	    sortedHashMap.put(entry.getKey(), entry.getValue());
	} 
	return sortedHashMap;
    }
    /**     * get most frequent k characters     * @param array of characters     * @param limit of k     * @return hashed String      */
    public static  mostOcurrencesElement(char[] array, int k) {
        HashMap<, Integer> countMap = countElementOcurrences(array);
        .out.println(countMap);
        Map<, Integer> map = descendingSortByValues(countMap); 
        .out.println(map);
        int i = 0;
         output = strv;
        for (.Entry<, Integer> pairs : map.entrySet()) {
	    if (i++ >= k)
		break;
            output += strv + pairs.getKey() + pairs.getValue();
        }
        return output;
    }
    /**     * Calculates the similarity between two input strings     * @param input string 1     * @param input string 2     * @param maximum possible limit value      * @return distance as integer     */
    public static int getDiff( str1,  str2, int limit) {
        int similarity = 0;
	int k = 0;
	for (int i = 0; i < str1.length() ; i = k) {
	    k ++;
	    if (.isLetter(str1.charAt(i))) {
		int pos = str2.indexOf(str1.charAt(i));
 
		if (pos >= 0) {	
		     digitStr1 = strv;
		    while ( k < str1.length() && !.isLetter(str1.charAt(k))) {
			digitStr1 += str1.charAt(k);
			k++;
		    }
 
		    int k2 = pos+1;
		     digitStr2 = strv;
		    while (k2 < str2.length() && !.isLetter(str2.charAt(k2)) ) {
			digitStr2 += str2.charAt(k2);
			k2++;
		    }
 
		    similarity += .parseInt(digitStr2)
			+ .parseInt(digitStr1);
 
		} 
	    }
	}
	return .abs(limit - similarity);
    }
    /**     * Wrapper function      * @param input string 1     * @param input string 2     * @param maximum possible limit value      * @return distance as integer     */
    public static int SDFfunc( str1,  str2, int limit) {
        return getDiff(mostOcurrencesElement(str1.toCharArray(), 2), mostOcurrencesElement(str2.toCharArray(), 2), limit);
    }
 
    public static void main([] args) {
         input1 = strv;
         input2 = strv;
        .out.println(SDF.SDFfunc(input1,input2,100));
 
    }
 
}"
"import java.util.*;
 
public class MorseCode {
 
    final static [][] code = {
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {"""", strv}, {strv, strv}, {strv, strv}}; 

 
    final static Map<, String> map = new HashMap<>();
 
    static {
        for ([] pair : code)
            map.put(pair[0].charAt(0), pair[1].trim());
    }
 
    public static void main([] args) {
        printMorse(strv);
        printMorse(strv);
        printMorse(strv);
    }
 
    static void printMorse( input) {
        .out.printf(strv, input);
 
        input = input.trim().replaceAll(strv, strv).toUpperCase();
        for (char c : input.toCharArray()) {
             s = map.get(c);
            if (s != null)
                .out.printf(strv, s);
        }
        .out.println("""");
    }
}"
"public class MC {
	public static void main([] args) {
		.out.println(getPi(10000));
		.out.println(getPi(100000));
		.out.println(getPi(1000000));
		.out.println(getPi(10000000));
		.out.println(getPi(100000000));
 
	}
	public static double getPi(int numThrows){
		int inCircle= 0;
		for(int i= 0;i < numThrows;i++){
			//a square with a side of length 2 centered at 0 has 
			//x and y range of -1 to 1
			double randX= (.random() * 2) - 1;//range -1 to 1
			double randY= (.random() * 2) - 1;//range -1 to 1
			//distance from (0,0) = sqrt((x-0)^2+(y-0)^2)
			double dist= .sqrt(randX * randX + randY * randY);
			//^ or in Java 1.5+: double dist= Math.hypot(randX, randY);
			if(dist < 1){//circle with diameter of 2 has radius of 1
				inCircle++;
			}
		}
		return 4.0 * inCircle / numThrows;
	}
}package montecarlo;
 
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
 
import static java.lang..random;
import static java.lang..hypot;
import static java.lang..out;
 
public interface MonteCarlo {
  public static void main(... arguments) {
    IntStream.of(
      10000,
      100000,
      1000000,
      10000000,
      100000000
    )
      .mapToDouble(MonteCarlo::pi)
      .forEach(out::println)
    ;
  }
 
  public static double range() {
    //a square with a side of length 2 centered at 0 has 
    //x and y range of -1 to 1
    return (random() * 2) - 1;
  }
 
  public static double pi(int numThrows){
    long inCircle = DoubleStream.generate(
      //distance from (0,0) = hypot(x, y)
      () -> hypot(range(), range())
    )
      .limit(numThrows)
      .unordered()
      .parallel()
      //circle with diameter of 2 has radius of 1
      .filter(d -> d < 1)
      .count()
    ;
    return (4.0 * inCircle) / numThrows;
  }
}"
"import java.util.Random;
public class Monty{
	public static void main([] args){
		int switchWins = 0;
		int stayWins = 0;
		 gen = new ();
		for(int plays = 0;plays < 32768;plays++ ){
			int[] doors = {0,0,0};//0 is a goat, 1 is a car
			doors[gen.nextInt(3)] = 1;//put a winner in a random door
			int choice = gen.nextInt(3); //pick a door, any door
			int shown; //the shown door
			do{
				shown = gen.nextInt(3);
			//don't show the winner or the choice
			}while(doors[shown] == 1 || shown == choice);
 
			stayWins += doors[choice];//if you won by staying, count it
 
			//the switched (last remaining) door is (3 - choice - shown), because 0+1+2=3
			switchWins += doors[3 - choice - shown];
		}
		.out.println(strv + switchWins + strv);
		.out.println(strv + stayWins + strv);
	}
}"
.out.println(.valueOf(42).modInverse(.valueOf(2017)));
"public class ScriptedMain {
	public static int meaningOfLife() {
		return 42;
	}
 
	public static void main([] args) {
		.out.println(strv + meaningOfLife());
	}
}public class Test {
	public static void main([] args) {
		.out.println(strv + ScriptedMain.meaningOfLife());
	}
}"
"import java.math.BigInteger;
 
public class PowMod {
    public static void main([] args){
         a = new (
      strv);
         b = new (
      strv);
         m = new (strv);
 
        .out.println(a.modPow(b, m));
    }
}"
"import java.math.BigInteger;
 
public class MillerRabinPrimalityTest {
  public static void main([] args) {
     n = new (args[0]);
    int certainty = .parseInt(args[1]);
    .out.println(n.toString() + strv + (n.isProbablePrime(certainty) ? strv : strv));
  }
}import java.math.BigInteger;
 
public class Prime {
 
    

    

    public static boolean isPrime( n, int precision) {
 
        if (n.compareTo(new (strv)) >= 0) {
            return n.isProbablePrime(precision);
        }
 
        int intN = n.intValue();
        if (intN == 1 || intN == 4 || intN == 6 || intN == 8) return false;
        if (intN == 2 || intN == 3 || intN == 5 || intN == 7) return true;
 
        int[] primesToTest = getPrimesToTest(n);
        if (n.equals(new (strv))) {
            return false;
        }
         d = n.subtract(.ONE);
         s = .ZERO;
        while (d.mod(.valueOf(2)).equals(.ZERO)) {
            d = d.shiftRight(1);
            s = s.add(.ONE);
        }
        for (int a : primesToTest) {
            if (try_composite(a, d, n, s)) {
                return false;
            }
        }
        return true;
    }
 
    public static boolean isPrime( n) {
        return isPrime(n, 100);
    }
 
    public static boolean isPrime(int n) {
        return isPrime(.valueOf(n), 100);
    }
 
    public static boolean isPrime(long n) {
        return isPrime(.valueOf(n), 100);
    }
 
    private static int[] getPrimesToTest( n) {
        if (n.compareTo(new (strv)) >= 0) {
            return new int[]{2, 3, 5, 7, 11, 13, 17};
        }
        if (n.compareTo(new (strv)) >= 0) {
            return new int[]{2, 3, 5, 7, 11, 13};
        }
        if (n.compareTo(new (strv)) >= 0) {
            return new int[]{2, 3, 5, 7, 11};
        }
        if (n.compareTo(new (strv)) >= 0) {
            return new int[]{2, 3, 5, 7};
        }
        if (n.compareTo(new (strv)) >= 0) {
            return new int[]{2, 3, 5};
        }
        return new int[]{2, 3};
    }
 
    private static boolean try_composite(int a,  d,  n,  s) {
         aB = .valueOf(a);
        if (aB.modPow(d, n).equals(.ONE)) {
            return false;
        }
        for (int i = 0; .valueOf(i).compareTo(s) < 0; i++) {
            

            if (aB.modPow(.valueOf(2).pow(i).multiply(d), n).equals(n.subtract(.ONE))) {
                return false;
            }
        }
        return true;
    }
}
 "
" 
 
This is a version of minesweeper with a gui. The code might not be optimal, but at least its not hard to understand.
 
//--------------------------------- START of Main.java ---------------------------------
 
/* * Main.java *  * Created by Potrik * Last modified: 07.22.13 */
 
public class Main
{
	public static void main ([] args)
	{
		int x = 10;		//Width of the board
		int y = 10;		//Height of the board
		int d = 25;		//The difficulty of the game, the percentage of mines in the board. The number of mines per board is random, but this number is the probability that a cell will become
					//a mine.
 
		new Minesweeper(x, y, d);
	}
}
 
//--------------------------------- END of Main.java ---------------------------------
 
//--------------------------------- START of Cell.java ---------------------------------
 
/* * Cell.java *  * Created by Potrik * Last modified: 07.22.13 */
 
public class Cell
{
	private boolean isMine, isFlagged, isObscured;
	private int number;
 
	public Cell()
	{
		isMine = false;
		isFlagged = false;
		isObscured = true;
		number = 0;
	}
 
	public void setMine()
	{
		isMine = true;
	}
 
	public void flag()
	{
		isFlagged = true;
	}
 
	public void unflag()
	{
		isFlagged = false;
	}
 
	public void reveal()
	{
		isObscured = false;
	}
 
	public void setNumber(int i)
	{
		number = i;
	}
 
	public boolean isMine()
	{
		return isMine;
	}
 
	public boolean isFlagged()
	{
		return isFlagged;
	}
 
	public boolean isObscured()
	{
		return isObscured;
	}
 
	public int getNumber()
	{
		return number;
	}
}
 
//--------------------------------- END of Cell.java ---------------------------------
 
//--------------------------------- START of Board.java ---------------------------------
 
/* * Board.java *  * Created by Potrik * Last modified: 07.22.13 */
 
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import javax.swing.JPanel;
 
public class Board extends 
{
	private static final long serialVersionUID = 1L;
	private Minesweeper mine;
	private Cell[][] cells;
 
	public Board(Minesweeper m)
	{
		mine = m;
		cells = mine.getCells();
 
		addMouseListener(new Actions(mine));
 
		setPreferredSize(new (mine.getx() * 20, mine.gety() * 20));
	}
 
	public void paintComponent( g)
	{
		cells = mine.getCells();
 
		for (int i = 0; i < mine.getx(); i++)
		{
			for (int j = 0; j < mine.gety(); j++)
			{
				Cell current = cells[i][j];
 
				if (current.isFlagged())
				{
					if (current.isMine() && mine.isFinished())
					{
						g.setColor(.ORANGE);
						g.fillRect(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
						g.setColor(.BLACK);
 
						g.drawLine(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
						g.drawLine(i * 20, j * 20 + 20, i * 20 + 20, j * 20);
					}
					else if (mine.isFinished())
					{
						g.setColor(.GREEN);
						g.fillRect(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
						g.setColor(.BLACK);
					}
					else
					{
						g.setColor(.YELLOW);
						g.fillRect(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
						g.setColor(.BLACK);
					}
				}
				else if (current.isObscured())
				{
					g.setColor(.GRAY);
					g.fillRect(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
					g.setColor(.BLACK);
				}
				else if (current.isMine())
				{
					g.setColor(.RED);
					g.fillRect(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
					g.setColor(.BLACK);
					g.drawLine(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
					g.drawLine(i * 20, j * 20 + 20, i * 20 + 20, j * 20);
				}
				else
				{
					g.setColor(.LIGHT_GRAY);
					g.fillRect(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
					g.setColor(.BLACK);
				}
				if (!current.isObscured())
				{
					if (current.getNumber() == 1)
					{
						g.drawLine(i * 20 + 13, j * 20 + 5, i * 20 + 13, j * 20 + 9);	//3
						g.drawLine(i * 20 + 13, j * 20 + 11, i * 20 + 13, j * 20 + 15);	//6
					}
					else if (current.getNumber() == 2)
					{
						g.drawLine(i * 20 + 8, j * 20 + 4, i * 20 + 12, j * 20 + 4);	//2
						g.drawLine(i * 20 + 13, j * 20 + 5, i * 20 + 13, j * 20 + 9);	//3
						g.drawLine(i * 20 + 8, j * 20 + 10, i * 20 + 12, j * 20 + 10);	//4
						g.drawLine(i * 20 + 7, j * 20 + 11, i * 20 + 7, j * 20 + 15);	//5
						g.drawLine(i * 20 + 8, j * 20 + 16, i * 20 + 12, j * 20 + 16);	//7
					}
					else if (current.getNumber() == 3)
					{
						g.drawLine(i * 20 + 8, j * 20 + 4, i * 20 + 12, j * 20 + 4);	//2
						g.drawLine(i * 20 + 13, j * 20 + 5, i * 20 + 13, j * 20 + 9);	//3
						g.drawLine(i * 20 + 8, j * 20 + 10, i * 20 + 12, j * 20 + 10);	//4
						g.drawLine(i * 20 + 13, j * 20 + 11, i * 20 + 13, j * 20 + 15);	//6
						g.drawLine(i * 20 + 8, j * 20 + 16, i * 20 + 12, j * 20 + 16);	//7
					}
					else if (current.getNumber() == 4)
					{
						g.drawLine(i * 20 + 7, j * 20 + 5, i * 20 + 7, j * 20 + 9);		//1
						g.drawLine(i * 20 + 13, j * 20 + 5, i * 20 + 13, j * 20 + 9);	//3
						g.drawLine(i * 20 + 8, j * 20 + 10, i * 20 + 12, j * 20 + 10);	//4
						g.drawLine(i * 20 + 13, j * 20 + 11, i * 20 + 13, j * 20 + 15);	//6
					}
					else if (current.getNumber() == 5)
					{
						g.drawLine(i * 20 + 7, j * 20 + 5, i * 20 + 7, j * 20 + 9);		//1
						g.drawLine(i * 20 + 8, j * 20 + 4, i * 20 + 12, j * 20 + 4);	//2
						g.drawLine(i * 20 + 8, j * 20 + 10, i * 20 + 12, j * 20 + 10);	//4
						g.drawLine(i * 20 + 13, j * 20 + 11, i * 20 + 13, j * 20 + 15);	//6
						g.drawLine(i * 20 + 8, j * 20 + 16, i * 20 + 12, j * 20 + 16);	//7
					}
					else if (current.getNumber() == 6)
					{
						g.drawLine(i * 20 + 7, j * 20 + 5, i * 20 + 7, j * 20 + 9);		//1
						g.drawLine(i * 20 + 8, j * 20 + 4, i * 20 + 12, j * 20 + 4);	//2
						g.drawLine(i * 20 + 8, j * 20 + 10, i * 20 + 12, j * 20 + 10);	//4
						g.drawLine(i * 20 + 7, j * 20 + 11, i * 20 + 7, j * 20 + 15);	//5
						g.drawLine(i * 20 + 13, j * 20 + 11, i * 20 + 13, j * 20 + 15);	//6
						g.drawLine(i * 20 + 8, j * 20 + 16, i * 20 + 12, j * 20 + 16);	//7
					}
					else if (current.getNumber() == 7)
					{
						g.drawLine(i * 20 + 8, j * 20 + 4, i * 20 + 12, j * 20 + 4);	//2
						g.drawLine(i * 20 + 13, j * 20 + 5, i * 20 + 13, j * 20 + 9);	//3
						g.drawLine(i * 20 + 13, j * 20 + 11, i * 20 + 13, j * 20 + 15);	//6
					}
					else if (current.getNumber() == 8)
					{
						g.drawLine(i * 20 + 7, j * 20 + 5, i * 20 + 7, j * 20 + 9);		//1
						g.drawLine(i * 20 + 8, j * 20 + 4, i * 20 + 12, j * 20 + 4);	//2
						g.drawLine(i * 20 + 13, j * 20 + 5, i * 20 + 13, j * 20 + 9);	//3
						g.drawLine(i * 20 + 8, j * 20 + 10, i * 20 + 12, j * 20 + 10);	//4
						g.drawLine(i * 20 + 7, j * 20 + 11, i * 20 + 7, j * 20 + 15);	//5
						g.drawLine(i * 20 + 13, j * 20 + 11, i * 20 + 13, j * 20 + 15);	//6
						g.drawLine(i * 20 + 8, j * 20 + 16, i * 20 + 12, j * 20 + 16);	//7
					}
				}
				g.setColor(.BLACK);
				g.drawRect(i * 20, j * 20, i * 20 + 20, j * 20 + 20);
			}
		}
	}
}
 
//--------------------------------- END of Board.java ---------------------------------
 
//--------------------------------- START of Actions.java ---------------------------------
 
/* * Board.java *  * Created by Potrik * Last modified: 07.22.13 */
 
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
 
public class Actions implements , 
{
	private Minesweeper mine;
 
	public Actions(Minesweeper m)
	{
		mine = m;
	}
 
	public void actionPerformed( e)
	{	
		mine.reset();
 
		mine.refresh();
	}
 
	public void mouseClicked( e)
	{
		if (e.getButton() == 1)
		{
			int x = e.getX() / 20;
			int y = e.getY() / 20;
 
			mine.select(x, y);
		}
 
		if (e.getButton() == 3)
		{
			int x = e.getX() / 20;
			int y = e.getY() / 20;
 
			mine.mark(x, y);
		}
 
		mine.refresh();
	}
 
	public void mouseEntered( e)
	{
 
	}
 
	public void mouseExited( e)
	{
 
	}
 
	public void mousePressed( e)
	{
 
	}
 
	public void mouseReleased( e)
	{
 
	}
 
}
 
//--------------------------------- END of Actions.java ---------------------------------
 
//--------------------------------- START of Minesweeper.java ---------------------------------
 
/* * Minesweeper.java *  * Created by Potrik * Last modified: 07.22.13 */
 
import java.awt.BorderLayout;
import java.util.Random;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
 
public class Minesweeper extends 
{
	private static final long serialVersionUID = 1L;
	private int width, height;
	private Cell[][] cells;
	private int difficulty;
	private Board board;
	private  reset;
	private boolean finished;
 
	public Minesweeper(int x, int y, int d)
	{
		width = x;
		height = y;
		difficulty = d;
		cells = new Cell[width][height];
 
		reset();
 
		board = new Board(this);
		reset = new (strv);
 
		add(board, .CENTER);
		add(reset, .SOUTH);
 
		reset.addActionListener(new Actions(this));
 
		setTitle(strv);
		setDefaultCloseOperation(.EXIT_ON_CLOSE);
		setResizable(false);
		pack();
		setVisible(true);
	}
 
	public int getx()
	{
		return width;
	}
 
	public int gety()
	{
		return height;
	}
 
	public Cell[][] getCells()
	{
		return cells;
	}
 
	public void reset()
	{
		 random = new ();
		finished = false;
 
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				Cell c = new Cell();
				cells[i][j] = c;
				int r = random.nextInt(100);
 
				if (r < difficulty)
				{
					cells[i][j].setMine();
				}
			}
		}
		setNumbers();
	}
 
	private void setNumbers()
	{
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				int count = 0;
 
				if (i > 0 &&	j > 0 && cells[i - 1]	[j - 1]	.isMine()) count++;
				if (j > 0 && cells[i][j - 1].isMine()) count++;
				if (i < width - 1 && j > 0 && cells[i + 1][j - 1].isMine()) count++;
 
				if (i > 0 && cells[i - 1][j].isMine()) count++;
				if (i < width - 1 && cells[i + 1][j].isMine()) count++;
 
				if (i > 0 && j < height - 1 && cells[i - 1][j + 1].isMine()) count++;
				if (j < height - 1	&& cells[i] [j + 1].isMine()) count++;
				if (i < width - 1 && j < height - 1 && cells[i + 1][j + 1].isMine()) count++;
 
				cells[i][j].setNumber(count);
 
				if (cells[i][j].isMine())
				{
					cells[i][j].setNumber(-1);
				}
 
				if (cells[i][j].getNumber() == 0)
				{
					cells[i][j].reveal();
				}
			}
		}
 
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				if (i > 0 &&	j > 0 && cells[i - 1][j - 1].getNumber() == 0) cells[i][j].reveal();
				if (j > 0 && cells[i][j - 1].getNumber() == 0) cells[i][j].reveal();
				if (i < width - 1 && j > 0 && cells[i + 1][j - 1].getNumber() == 0) cells[i][j].reveal();
 
				if (i > 0 && cells[i - 1][j].getNumber() == 0) cells[i][j].reveal();
				if (i < width - 1 && cells[i + 1]	[j]		.getNumber() == 0) cells[i][j].reveal();
 
				if (i > 0 && j < height - 1 && cells[i - 1][j + 1].getNumber() == 0) cells[i][j].reveal();
				if (j < height - 1 && cells[i][j + 1].getNumber() == 0) cells[i][j].reveal();
				if (i < width - 1 && j < height - 1 && cells[i + 1][j + 1]	.getNumber() == 0) cells[i][j].reveal();
			}
		}
	}
 
	public void refresh()
	{
		board.repaint();
	}
 
	public void select(int x, int y)
	{
		if (cells[x][y].isFlagged()) return;
		cells[x][y].reveal();
		resetMarks();
		refresh();
 
		if (cells[x][y].isMine())
		{
			loose();
		}
		else if (won())
		{
			win();
		}
	}
 
	private void loose()
	{
		finished = true;
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				if (!cells[i][j].isObscured()) cells[i][j].unflag();
				cells[i][j].reveal();
			}
		}
		refresh();
		.showMessageDialog(null, strv);
		reset();
	}
 
	private void win()
	{
		finished = true;
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				cells[i][j].reveal();
				if (!cells[i][j].isMine()) cells[i][j].unflag();
			}
		}
 
		refresh();
		.showMessageDialog(null, strv);
		reset();
	}
 
	private boolean won()
	{
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				if (cells[i][j].isObscured() && !cells[i][j].isMine())
				{
					return false;
				}
			}
		}
 
		return true;
	}
 
	public void mark(int x, int y)
	{
		if (cells[x][y].isFlagged()) cells[x][y].unflag();
		else if (cells[x][y].isObscured()) cells[x][y].flag();
 
		resetMarks();
	}
 
	private void resetMarks()
	{
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				if (!cells[i][j].isObscured()) cells[i][j].unflag();
			}
		}
	}
 
	public boolean isFinished()
	{
		return finished;
	}
}
 
//--------------------------------- END of Minesweeper.java ---------------------------------
 
 
 "
"public class MiddleThreeDigits {
 
    public static void main([] args) {
        final long[] passing = {123, 12345, 1234567, 987654321, 10001, -10001,
            -123, -100, 100, -12345, .MIN_VALUE, .MAX_VALUE};
 
        final int[] failing = {1, 2, -1, -10, 2002, -2002, 0, .MIN_VALUE,
            .MAX_VALUE};
 
        for (long n : passing)
            .out.printf(""middleThreeDigits(%s): %s"", n, middleThreeDigits(n));
 
        for (int n : failing)
            .out.printf(""middleThreeDigits(%s): %s"", n, middleThreeDigits(n));
    }
 
    public static <T>  middleThreeDigits(T n) {
         s = .valueOf(n);
        if (s.charAt(0) == '-')
            s = s.substring(1);
        int len = s.length();
        if (len < 3 || len % 2 == 0)
            return strv;
        int mid = len / 2;
        return s.substring(mid - 1, mid + 2);
    }
}"
" 
class Metronome{
	double bpm;
	int measure, counter;
	public Metronome(double bpm, int measure){
		this.bpm = bpm;
		this.measure = measure;	
	}
	public void start(){
		while(true){
			try {
				.sleep((long)(1000*(60/bpm)));
			}catch( e) {
				e.printStackTrace();
			}
			counter++;
			if (counter%measure==0){
				 .out.println(strv);
			}else{
				 .out.println(strv);
			}
		}
	}
}
public class test {
	public static void main([] args) {
		Metronome metronome1 = new Metronome(120,4);
		metronome1.start();
	}
}
 "
"public class CountingSemaphore{
   private int lockCount = 0;
   private int maxCount;
 
   CountingSemaphore(int Max){
      maxCount = Max;
   }
 
   public synchronized void acquire() throws {
      while( lockCount >= maxCount){
         wait();
      }
      lockCount++;
   }
   public synchronized void release(){
      if (lockCount > 0)
      {
         lockCount--;
         notifyAll();
      }
   }
   public synchronized int getCount(){
      return lockCount;
   }
}
 
public class Worker extends {
   private CountingSemaphore lock;
   private int id;
 
   Worker(CountingSemaphore coordinator, int num){
      lock = coordinator;
      id = num;
   }
   Worker(){
   }
   public void run(){
      try{
         lock.acquire();
         .out.println(strv + id + strv);
         sleep(2000);
      }
      catch ( e){
      }
      finally{
         lock.release();
      }
   }
   public static void main([] args){
      CountingSemaphore lock = new CountingSemaphore(3);
      Worker crew[];
      crew = new Worker[5];
      for (int i = 0; i < 5; i++){
         crew[i] = new Worker(lock, i);
         crew[i].start();
      }
 
   }
}"
"//All of these objects will be deallocated automatically once the program leaves
//their scope and there are no more pointers to the objects
 foo = new (); //Allocate an Object and a reference to it
int[] fooArray = new int[size]; //Allocate all spaces in an array and a reference to it
int x = 0; //Allocate an integer and set its value to 0public class Blah{
   //...other methods/data members...
   protected void finalize() throws {
      //Finalization code here
   }
   //...other methods/data members...
}public class NoFinalize {
    public static final void main([] params) {
        NoFinalize nf = new NoFinalize();
    }
    public NoFinalize() {
        .out.println(strv);
    }
    @Override
    protected void finalize() {
        .out.println(strv);
    }
}"
"class MD5
{
 
  private static final int INIT_A = 0x67452301;
  private static final int INIT_B = (int)0xEFCDAB89L;
  private static final int INIT_C = (int)0x98BADCFEL;
  private static final int INIT_D = 0x10325476;
 
  private static final int[] SHIFT_AMTS = {
    7, 12, 17, 22,
    5,  9, 14, 20,
    4, 11, 16, 23,
    6, 10, 15, 21
  };
 
  private static final int[] TABLE_T = new int[64];
  static
  {
    for (int i = 0; i < 64; i++)
      TABLE_T[i] = (int)(long)((1L << 32) * .abs(.sin(i + 1)));
  }
 
  public static byte[] computeMD5(byte[] message)
  {
    int messageLenBytes = message.length;
    int numBlocks = ((messageLenBytes + 8) >>> 6) + 1;
    int totalLen = numBlocks << 6;
    byte[] paddingBytes = new byte[totalLen - messageLenBytes];
    paddingBytes[0] = (byte)0x80;
 
    long messageLenBits = (long)messageLenBytes << 3;
    for (int i = 0; i < 8; i++)
    {
      paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits;
      messageLenBits >>>= 8;
    }
 
    int a = INIT_A;
    int b = INIT_B;
    int c = INIT_C;
    int d = INIT_D;
    int[] buffer = new int[16];
    for (int i = 0; i < numBlocks; i ++)
    {
      int index = i << 6;
      for (int j = 0; j < 64; j++, index++)
        buffer[j >>> 2] = ((int)((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8);
      int originalA = a;
      int originalB = b;
      int originalC = c;
      int originalD = d;
      for (int j = 0; j < 64; j++)
      {
        int div16 = j >>> 4;
        int f = 0;
        int bufferIndex = j;
        switch (div16)
        {
          case 0:
            f = (b & c) | (~b & d);
            break;
 
          case 1:
            f = (b & d) | (c & ~d);
            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;
            break;
 
          case 2:
            f = b ^ c ^ d;
            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;
            break;
 
          case 3:
            f = c ^ (b | ~d);
            bufferIndex = (bufferIndex * 7) & 0x0F;
            break;
        }
        int temp = b + .rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);
        a = d;
        d = c;
        c = b;
        b = temp;
      }
 
      a += originalA;
      b += originalB;
      c += originalC;
      d += originalD;
    }
 
    byte[] md5 = new byte[16];
    int count = 0;
    for (int i = 0; i < 4; i++)
    {
      int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d));
      for (int j = 0; j < 4; j++)
      {
        md5[count++] = (byte)n;
        n >>>= 8;
      }
    }
    return md5;
  }
 
  public static  toHexString(byte[] b)
  {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < b.length; i++)
    {
      sb.append(.format(strv, b[i] & 0xFF));
    }
    return sb.toString();
  }
 
  public static void main([] args)
  {
    [] testStrings = { strv, strv, strv, strv, strv, strv, strv };
    for ( s : testStrings)
      .out.println(strv + toHexString(computeMD5(s.getBytes())) + "" <== "" + s + """");
    return;
  }
 
}import java.nio.ByteBuffer;
import java.nio.ByteOrder;
 
class MD5
{
 
  private static final int INIT_A = 0x67452301;
  private static final int INIT_B = (int)0xEFCDAB89L;
  private static final int INIT_C = (int)0x98BADCFEL;
  private static final int INIT_D = 0x10325476;
 
  private static final int[] SHIFT_AMTS = {
    7, 12, 17, 22,
    5,  9, 14, 20,
    4, 11, 16, 23,
    6, 10, 15, 21
  };
 
  private static final int[] TABLE_T = new int[64];
  static
  {
    for (int i = 0; i < 64; i++)
      TABLE_T[i] = (int)(long)((1L << 32) * .abs(.sin(i + 1)));
  }
 
  public static byte[] computeMD5(byte[] message)
  {
    ByteBuffer padded = ByteBuffer.allocate((((message.length + 8) / 64) + 1) * 64).order(ByteOrder.LITTLE_ENDIAN);
    padded.put(message);
    padded.put((byte)0x80);
    long messageLenBits = (long)message.length * 8;
    padded.putLong(padded.capacity() - 8, messageLenBits);
 
    padded.rewind();
 
    int a = INIT_A;
    int b = INIT_B;
    int c = INIT_C;
    int d = INIT_D;
    while (padded.hasRemaining()) {
      

      

      IntBuffer chunk = padded.slice().order(ByteOrder.LITTLE_ENDIAN).asIntBuffer();
      int originalA = a;
      int originalB = b;
      int originalC = c;
      int originalD = d;
      for (int j = 0; j < 64; j++)
      {
        int div16 = j >>> 4;
        int f = 0;
        int bufferIndex = j;
        switch (div16)
        {
          case 0:
            f = (b & c) | (~b & d);
            break;
 
          case 1:
            f = (b & d) | (c & ~d);
            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;
            break;
 
          case 2:
            f = b ^ c ^ d;
            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;
            break;
 
          case 3:
            f = c ^ (b | ~d);
            bufferIndex = (bufferIndex * 7) & 0x0F;
            break;
        }
        int temp = b + .rotateLeft(a + f + chunk.get(bufferIndex) + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);
        a = d;
        d = c;
        c = b;
        b = temp;
      }
 
      a += originalA;
      b += originalB;
      c += originalC;
      d += originalD;
      padded.position(padded.position() + 64);
    }
 
    ByteBuffer md5 = ByteBuffer.allocate(16).order(ByteOrder.LITTLE_ENDIAN);
    for (int n : new int[]{a, b, c, d})
    {
      md5.putInt(n);
    }
    return md5.array();
  }
 
  public static  toHexString(byte[] b)
  {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < b.length; i++)
    {
      sb.append(.format(strv, b[i] & 0xFF));
    }
    return sb.toString();
  }
 
  public static void main([] args)
  {
    [] testStrings = { strv, strv, strv, strv, strv, strv, strv };
    for ( s : testStrings)
      .out.println(strv + toHexString(computeMD5(s.getBytes())) + "" <== "" + s + """");
    return;
  }
 
}"
"import org.bouncycastle.crypto.digests.MD4Digest;
import org.bouncycastle.util.encoders.Hex;
 
public class RosettaMD4
{
    public static void main ([] argv) throws 
    {
        byte[] r = strv.getBytes(strv);
        MD4Digest d = new MD4Digest();
        d.update (r, 0, r.length);
        byte[] o = new byte[d.getDigestSize()];
        d.doFinal (o, 0);
        Hex.encode (o, .out);
        .out.println();
    }
}"
"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
 
/** * Test MD5 digest computation * * @author Roedy Green * @version 1.0 * @since 2004-06-07 */
public final class MD5{
	public static void main([] args) throws ,
			{
		byte[] theTextToDigestAsBytes=
				strv
						.getBytes(strv);
		 md= .getInstance(strv);
		md.update(theTextToDigestAsBytes);
		byte[] digest= md.digest();
 
		

		for(byte b: digest){
			.out.printf(strv, b & 0xff);
		}
		.out.println();
	}
}"
"import java.nio.file.*;
import static java.util..stream;
 
public class MaxPathSum {
 
    public static void main([] args) throws  {
        int[][] data = Files.lines(Paths.get(strv))
                .map(s -> stream(s.trim().split(""s+""))
                        .mapToInt(::parseInt)
                        .toArray())
                .toArray(int[][]::new);
 
        for (int r = data.length - 1; r > 0; r--)
            for (int c = 0; c < data[r].length - 1; c++)
                data[r - 1][c] += .max(data[r][c], data[r][c + 1]);
 
        .out.println(data[0][0]);
    }
}"
"import java.util.Scanner;
 
public class MatrixArithmetic {
	public static double[][] minor(double[][] a, int x, int y){
		int length = a.length-1;
		double[][] result = new double[length][length];
		for(int i=0;i<length;i++) for(int j=0;j<length;j++){
			if(i<x && j<y){
				result[i][j] = a[i][j];
			}else if(i>=x && j<y){
				result[i][j] = a[i+1][j];
			}else if(i<x && j>=y){
				result[i][j] = a[i][j+1];
			}else{ //i>x && j>y
				result[i][j] = a[i+1][j+1];
			}
		}
		return result;
	}
	public static double det(double[][] a){
		if(a.length == 1){
			return a[0][0];
		}else{
			int sign = 1;
			double sum = 0;
			for(int i=0;i<a.length;i++){
				sum += sign * a[0][i] * det(minor(a,0,i));
				sign *= -1;
			}
			return sum;
		}
	}
	public static double perm(double[][] a){
		if(a.length == 1){
			return a[0][0];
		}else{
			double sum = 0;
			for(int i=0;i<a.length;i++){
				sum += a[0][i] * perm(minor(a,0,i));
			}
			return sum;
		}
	}
	public static void main( args[]){
		Scanner sc = new Scanner(.in);
		int size = sc.nextInt();
		double[][] a = new double[size][size];
		for(int i=0;i<size;i++) for(int j=0;j<size;j++){
			a[i][j] = sc.nextDouble();
		}
		sc.close();
		.out.println(strv+det(a));
		.out.println(strv+perm(a));
	}
}"
"public class Range {
	public static void main([] args){
		for(float s = 0;s <= 10; s++){
			.out.println(s + strv+ 
					mapRange(0, 10, -1, 0, s)+strv);
		}
	}
 
	public static double mapRange(double a1, double a2, double b1, double b2, double s){
		return b1 + ((s - a1)*(b2 - b1))/(a2 - a1);
	}
}"
"import java.io.*;
import java.util.*;
 
public class MazeSolver
{
    /**     * Reads a file into an array of strings, one per line.     */
    private static [] readLines ( f) throws 
    {
         r =
            new  (new  (f, strv));
        ArrayList<String> lines = new ArrayList<String>();
         line;
        while ((line = r.readLine()) != null)
            lines.add (line);
        return lines.toArray(new [0]);
    }
 
    /**     * Makes the maze half as wide (i. e. strv), so that     * each cell in the maze is the same size horizontally as vertically.     * (Versus the expanded version, which looks better visually.)     * Also, converts each line of the maze from a String to a     * char[], because we'll want mutability when drawing the solution later.     */
    private static char[][] decimateHorizontally ([] lines)
    {
        final int width = (lines[0].length() + 1) / 2;
        char[][] c = new char[lines.length][width];
        for (int i = 0  ;  i < lines.length  ;  i++)
            for (int j = 0  ;  j < width  ;  j++)
                c[i][j] = lines[i].charAt (j * 2);
        return c;
    }
 
    /**     * Given the maze, the x and y coordinates (which must be odd),     * and the direction we came from, return true if the maze is     * solvable, and draw the solution if so.     */
    private static boolean solveMazeRecursively (char[][] maze,
                                                 int x, int y, int d)
    {
        boolean ok = false;
        for (int i = 0  ;  i < 4  &&  !ok  ;  i++)
            if (i != d)
                switch (i)
                    {
                        

                    case 0:
                        if (maze[y-1][x] == ' ')
                            ok = solveMazeRecursively (maze, x, y - 2, 2);
                        break;
                    case 1:
                        if (maze[y][x+1] == ' ')
                            ok = solveMazeRecursively (maze, x + 2, y, 3);
                        break;
                    case 2:
                        if (maze[y+1][x] == ' ')
                            ok = solveMazeRecursively (maze, x, y + 2, 0);
                        break;
                    case 3:
                        if (maze[y][x-1] == ' ')
                            ok = solveMazeRecursively (maze, x - 2, y, 1);
                        break;
                    }
        

        if (x == 1  &&  y == 1)
            ok = true;
        

        if (ok)
            {
                maze[y][x] = '*';
                switch (d)
                    {
                    case 0:
                        maze[y-1][x] = '*';
                        break;
                    case 1:
                        maze[y][x+1] = '*';
                        break;
                    case 2:
                        maze[y+1][x] = '*';
                        break;
                    case 3:
                        maze[y][x-1] = '*';
                        break;
                    }
            }
        return ok;
    }
 
    /**     * Solve the maze and draw the solution.  For simplicity,     * assumes the starting point is the lower right, and the     * ending point is the upper left.     */
    private static void solveMaze (char[][] maze)
    {
        solveMazeRecursively (maze, maze[0].length - 2, maze.length - 2, -1);
    }
 
    /**     * Opposite of decimateHorizontally().  Adds extra characters to make     * the maze strv, and converts each line from char[] to     * String at the same time.     */
    private static [] expandHorizontally (char[][] maze)
    {
        char[] tmp = new char[3];
        [] lines = new [maze.length];
        for (int i = 0  ;  i < maze.length  ;  i++)
            {
                StringBuilder sb = new StringBuilder(maze[i].length * 2);
                for (int j = 0  ;  j < maze[i].length  ;  j++)
                    if (j % 2 == 0)
                        sb.append (maze[i][j]);
                    else
                        {
                            tmp[0] = tmp[1] = tmp[2] = maze[i][j];
                            if (tmp[1] == '*')
                                tmp[0] = tmp[2] = ' ';
                            sb.append (tmp);
                        }
                lines[i] = sb.toString();
            }
        return lines;
    }
 
    /**     * Accepts a maze as generated by:     * http://rosettacode.org/wiki/Maze_generation#Java     * in a file whose name is specified as a command-line argument,     * or on standard input if no argument is specified.     */
    public static void main ([] args) throws 
    {
         f = (args.length > 0
                         ?  new  (args[0])
                         :  .in);
        [] lines = readLines (f);
        char[][] maze = decimateHorizontally (lines);
        solveMaze (maze);
        [] solvedLines = expandHorizontally (maze);
        for (int i = 0  ;  i < solvedLines.length  ;  i++)
            .out.println (solvedLines[i]);
    }
}import java.awt.*;
import java.awt.event.*;
import java.awt.geom.Path2D;
import java.util.*;
import javax.swing.*;
 
public class MazeGenerator extends  {
    enum Dir {
        N(1, 0, -1), S(2, 0, 1), E(4, 1, 0), W(8, -1, 0);
        final int bit;
        final int dx;
        final int dy;
        Dir opposite;
 
        

        static {
            N.opposite = S;
            S.opposite = N;
            E.opposite = W;
            W.opposite = E;
        }
 
        Dir(int bit, int dx, int dy) {
            this.bit = bit;
            this.dx = dx;
            this.dy = dy;
        }
    };
    final int nCols;
    final int nRows;
    final int cellSize = 25;
    final int margin = 25;
    final int[][] maze;
    LinkedList<Integer> solution;
 
    public MazeGenerator(int size) {
        setPreferredSize(new (650, 650));
        setBackground(.white);
        nCols = size;
        nRows = size;
        maze = new int[nRows][nCols];
        solution = new LinkedList<>();
        generateMaze(0, 0);
 
        addMouseListener(new () {
            @Override
            public void mousePressed( e) {
                new (() -> {
                    solve(0);
                }).start();
            }
        });
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        g.setStroke(new (5));
        g.setColor(.black);
 
        

        for (int r = 0; r < nRows; r++) {
            for (int c = 0; c < nCols; c++) {
 
                int x = margin + c * cellSize;
                int y = margin + r * cellSize;
 
                if ((maze[r][c] & 1) == 0) 

                    g.drawLine(x, y, x + cellSize, y);
 
                if ((maze[r][c] & 2) == 0) 

                    g.drawLine(x, y + cellSize, x + cellSize, y + cellSize);
 
                if ((maze[r][c] & 4) == 0) 

                    g.drawLine(x + cellSize, y, x + cellSize, y + cellSize);
 
                if ((maze[r][c] & 8) == 0) 

                    g.drawLine(x, y, x, y + cellSize);
            }
        }
 
        

        int offset = margin + cellSize / 2;
 
        Path2D path = new Path2D.();
        path.moveTo(offset, offset);
 
        for (int pos : solution) {
            int x = pos % nCols * cellSize + offset;
            int y = pos / nCols * cellSize + offset;
            path.lineTo(x, y);
        }
 
        g.setColor(.orange);
        g.draw(path);
 
        g.setColor(.blue);
        g.fillOval(offset - 5, offset - 5, 10, 10);
 
        g.setColor(.green);
        int x = offset + (nCols - 1) * cellSize;
        int y = offset + (nRows - 1) * cellSize;
        g.fillOval(x - 5, y - 5, 10, 10);
 
    }
 
    void generateMaze(int r, int c) {
        Dir[] dirs = Dir.values();
        .shuffle(.asList(dirs));
        for (Dir dir : dirs) {
            int nc = c + dir.dx;
            int nr = r + dir.dy;
            if (withinBounds(nr, nc) && maze[nr][nc] == 0) {
                maze[r][c] |= dir.bit;
                maze[nr][nc] |= dir.opposite.bit;
                generateMaze(nr, nc);
            }
        }
    }
 
    boolean withinBounds(int r, int c) {
        return c >= 0 && c < nCols && r >= 0 && r < nRows;
    }
 
    boolean solve(int pos) {
        if (pos == nCols * nRows - 1)
            return true;
 
        int c = pos % nCols;
        int r = pos / nCols;
 
        for (Dir dir : Dir.values()) {
            int nc = c + dir.dx;
            int nr = r + dir.dy;
            if (withinBounds(nr, nc) && (maze[r][c] & dir.bit) != 0
                    && (maze[nr][nc] & 16) == 0) {
 
                int newPos = nr * nCols + nc;
 
                solution.add(newPos);
                maze[nr][nc] |= 16;
 
                animate();
 
                if (solve(newPos))
                    return true;
 
                animate();
 
                solution.removeLast();
                maze[nr][nc] &= ~16;
            }
        }
 
        return false;
    }
 
    void animate() {
        try {
            .sleep(50L);
        } catch ( ignored) {
        }
        repaint();
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new MazeGenerator(24), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"public static double[][] mult(double a[][], double b[][]){//a[m][n], b[n][p]
   if(a.length == 0) return new double[0][0];
   if(a[0].length != b.length) return null; //invalid dims
 
   int n = a[0].length;
   int m = a.length;
   int p = b[0].length;
 
   double ans[][] = new double[m][p];
 
   for(int i = 0;i < m;i++){
      for(int j = 0;j < p;j++){
         for(int k = 0;k < n;k++){
            ans[i][j] += a[i][k] * b[k][j];
         }
      }
   }
   return ans;
}"
"import java.util.Arrays;
public class Transpose{
       public static void main([] args){
               double[][] m = {{1, 1, 1, 1},
                               {2, 4, 8, 16},
                               {3, 9, 27, 81},
                               {4, 16, 64, 256},
                               {5, 25, 125, 625}};
               double[][] ans = new double[m[0].length][m.length];
               for(int rows = 0; rows < m.length; rows++){
                       for(int cols = 0; cols < m[0].length; cols++){
                               ans[cols][rows] = m[rows][cols];
                       }
               }
               for(double[] i:ans){//2D arrays are arrays of arrays
                       .out.println(.toString(i));
               }
       }
}"
"public class MagicSquareSinglyEven {
 
    public static void main([] args) {
        int n = 6;
        for (int[] row : magicSquareSinglyEven(n)) {
            for (int x : row)
                .out.printf(strv, x);
            .out.println();
        }
        .out.printf(""Magic constant: %d "", (n * n + 1) * n / 2);
    }
 
    public static int[][] magicSquareOdd(final int n) {
        if (n < 3 || n % 2 == 0)
            throw new (strv);
 
        int value = 0;
        int gridSize = n * n;
        int c = n / 2, r = 0;
 
        int[][] result = new int[n][n];
 
        while (++value <= gridSize) {
            result[r][c] = value;
            if (r == 0) {
                if (c == n - 1) {
                    r++;
                } else {
                    r = n - 1;
                    c++;
                }
            } else if (c == n - 1) {
                r--;
                c = 0;
            } else if (result[r - 1][c + 1] == 0) {
                r--;
                c++;
            } else {
                r++;
            }
        }
        return result;
    }
 
    static int[][] magicSquareSinglyEven(final int n) {
        if (n < 6 || (n - 2) % 4 != 0)
            throw new (strv
                    + strv);
 
        int size = n * n;
        int halfN = n / 2;
        int subSquareSize = size / 4;
 
        int[][] subSquare = magicSquareOdd(halfN);
        int[] quadrantFactors = {0, 2, 3, 1};
        int[][] result = new int[n][n];
 
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                int quadrant = (r / halfN) * 2 + (c / halfN);
                result[r][c] = subSquare[r % halfN][c % halfN];
                result[r][c] += quadrantFactors[quadrant] * subSquareSize;
            }
        }
 
        int nColsLeft = halfN / 2;
        int nColsRight = nColsLeft - 1;
 
        for (int r = 0; r < halfN; r++)
            for (int c = 0; c < n; c++) {
                if (c < nColsLeft || c >= n - nColsRight
                        || (c == nColsLeft && r == nColsLeft)) {
 
                    if (c == 0 && r == nColsLeft)
                        continue;
 
                    int tmp = result[r][c];
                    result[r][c] = result[r + halfN][c];
                    result[r + halfN][c] = tmp;
                }
            }
 
        return result;
    }
}"
"import java.awt.Graphics;
import java.awt.image.BufferedImage;
import javax.swing.JFrame;
 
public class Mandelbrot extends  {
 
    private final int MAX_ITER = 570;
    private final double ZOOM = 150;
    private  I;
    private double zx, zy, cX, cY, tmp;
 
    public Mandelbrot() {
        super(strv);
        setBounds(100, 100, 800, 600);
        setResizable(false);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        I = new (getWidth(), getHeight(), .TYPE_INT_RGB);
        for (int y = 0; y < getHeight(); y++) {
            for (int x = 0; x < getWidth(); x++) {
                zx = zy = 0;
                cX = (x - 400) / ZOOM;
                cY = (y - 300) / ZOOM;
                int iter = MAX_ITER;
                while (zx * zx + zy * zy < 4 && iter > 0) {
                    tmp = zx * zx - zy * zy + cX;
                    zy = 2.0 * zx * zy + cY;
                    zx = tmp;
                    iter--;
                }
                I.setRGB(x, y, iter | (iter << 8));
            }
        }
    }
 
    @Override
    public void paint( g) {
        g.drawImage(I, 0, 0, this);
    }
 
    public static void main([] args) {
        new Mandelbrot().setVisible(true);
    }
}"
"import java.util.function.DoubleSupplier;
 
public class ManOrBoy {
 
    static double A(int k, DoubleSupplier x1, DoubleSupplier x2,
                 DoubleSupplier x3, DoubleSupplier x4, DoubleSupplier x5) {
 
        DoubleSupplier B = new DoubleSupplier() {
            int m = k;
            public double getAsDouble() {
                return A(--m, this, x1, x2, x3, x4);
            }
        };
 
        return k <= 0 ? x4.getAsDouble() + x5.getAsDouble() : B.getAsDouble();
    }
 
    public static void main([] args) {
        .out.println(A(10, () -> 1.0, () -> -1.0, () -> -1.0, () -> 1.0, () -> 0.0));
    }
}public class ManOrBoy {
    interface Arg {
        public int run();
    }
 
    public static int A(final int k, final Arg x1, final Arg x2,
                          final Arg x3, final Arg x4, final Arg x5) {
        if (k <= 0)
            return x4.run() + x5.run();
        return new Arg() {
            int m = k;
            public int run() {
                m--;
                return A(m, this, x1, x2, x3, x4);
            }
        }.run();
    }
    public static Arg C(final int i) {
        return new Arg() {
            public int run() { return i; }
        };
    }
 
    public static void main([] args) {
        .out.println(A(10, C(1), C(-1), C(-1), C(1), C(0)));
    }
}"
"public class MagicSquare {
 
    public static void main([] args) {
        int n = 5;
        for (int[] row : magicSquareOdd(n)) {
            for (int x : row)
                .out.format(strv, x);
            .out.println();
        }
        .out.printf(""Magic constant: %d "", (n * n + 1) * n / 2);
    }
 
    public static int[][] magicSquareOdd(final int base) {
        if (base % 2 == 0 || base < 3)
            throw new (strv);
 
        int[][] grid = new int[base][base];
        int r = 0, number = 0;
        int size = base * base;
 
        int c = base / 2;
        while (number++ < size) {
            grid[r][c] = number;
            if (r == 0) {
                if (c == base - 1) {
                    r++;
                } else {
                    r = base - 1;
                    c++;
                }
            } else {
                if (c == base - 1) {
                    r--;
                    c = 0;
                } else {
                    if (grid[r - 1][c + 1] == 0) {
                        r--;
                        c++;
                    } else {
                        r++;
                    }
                }
            }
        }
        return grid;
    }
}"
"public class MagicSquareDoublyEven {
 
    public static void main([] args) {
        int n = 8;
        for (int[] row : magicSquareDoublyEven(n)) {
            for (int x : row)
                .out.printf(strv, x);
            .out.println();
        }
        .out.printf(""Magic constant: %d "", (n * n + 1) * n / 2);
    }
 
    static int[][] magicSquareDoublyEven(final int n) {
        if (n < 4 || n % 4 != 0)
            throw new (strv
                    + strv);
 
        

        int bits = 0b1001_0110_0110_1001;
        int size = n * n;
        int mult = n / 4;  

 
        int[][] result = new int[n][n];
 
        for (int r = 0, i = 0; r < n; r++) {
            for (int c = 0; c < n; c++, i++) {
                int bitPos = c / mult + (r / mult) * 4;
                result[r][c] = (bits & (1 << bitPos)) != 0 ? i + 1 : size - i;
            }
        }
        return result;
    }
}"
"import java.util.Map;
import java.util.HashMap;
import java.util.Scanner;
import java.util.StringTokenizer;
 
public class MadLibs 
{
	public static void main([] args)
	{
		Scanner s=new Scanner(.in);
		 line;
		 storybuffer=new ();
 
		//Accept lines until empty line is entered
		while(!(line=s.nextLine()).isEmpty())
			storybuffer.append(strv+line);
 
		//Remove first space
		storybuffer.delete(0, 1);
		 story=storybuffer.toString();
		//Split
		 str=new (story);
		 word;
		 finalstory=new ();
 
		//Store added elements
		Map<,String> hash=new HashMap<,String>();
		while(str.hasMoreTokens())
		{
			word=str.nextToken();
			if(word.contains(strv))
			{
				 add=strv;
				//Element prompt could be more than one word
				if(!word.contains(strv))
				{
					//Build multi-word prompt
					 phrase=strv;
					do{
						phrase+=word+strv;
					}while(!(word=str.nextToken()).contains(strv));
					word=phrase+word;
				}
				//Account for element placeholder being immediately followed by . or , or whatever.
				if(word.charAt(word.length()-1)!='>')
					add=word.substring(word.lastIndexOf('>')+1);
 
				//Store id of element in hash table
				 id=word.substring(0,word.lastIndexOf('>')+1);
				 value;
 
				if(!hash.containsKey(id))
				{
					//New element
					.out.println(strv+ id);
					value=s.nextLine()+add;
					hash.put(id, value);
				}
				//Previously entered element
				else
					value=hash.get(id);
				word=value;
			}
			finalstory.append(word+strv);
		}
		.out.println(finalstory.toString());
		s.close();
	}
}"
"package com.jamesdonnell.MACVendor;
 
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
 
/** MAC Vendor Lookup class. * www.JamesDonnell.com * @author James A. Donnell Jr. */
public class Lookup {
	/** Base URL for API. The API from www.macvendors.com was chosen. */
	private static final  baseURL = strv;
 
	/** Performs lookup on MAC address(es) supplied in arguments.	 * @param args MAC address(es) to lookup. */
	public static void main([] args) {
		for ( arguments : args)
			.out.println(arguments + strv + get(arguments));
	}
 
	/** Performs lookup on supplied MAC address.	 * @param macAddress MAC address to lookup.	 * @return Manufacturer of MAC address. */
	private static  get( macAddress) {
		try {
			StringBuilder result = new StringBuilder();
			 url = new (baseURL + macAddress);
			 conn = () url.openConnection();
			conn.setRequestMethod(strv);
			 rd = new (new (conn.getInputStream()));
			 line;
			while ((line = rd.readLine()) != null) {
				result.append(line);
			}
			rd.close();
			return result.toString();
		} catch ( e) {
			

			return strv;
		} catch ( e) {
			

			return null;
		}
	}
}"
"import java.math.BigInteger;
import java.util.*;
 
public class Lychrel {
 
    static Map<, Tuple> cache = new HashMap<>();
 
    static class Tuple {
        final  flag;
        final  bi;
 
        Tuple(boolean f,  b) {
            flag = f;
            bi = b;
        }
    }
 
    static  rev( bi) {
         s = new StringBuilder(bi.toString()).reverse().toString();
        return new (s);
    }
 
    static Tuple lychrel( n) {
        Tuple res;
        if ((res = cache.get(n)) != null)
            return res;
 
         r = rev(n);
        res = new Tuple(true, n);
        List<BigInteger> seen = new ArrayList<>();
 
        for (int i = 0; i < 500; i++) {
            n = n.add(r);
            r = rev(n);
 
            if (n.equals(r)) {
                res = new Tuple(false, .ZERO);
                break;
            }
 
            if (cache.containsKey(n)) {
                res = cache.get(n);
                break;
            }
 
            seen.add(n);
        }
 
        for ( bi : seen)
            cache.put(bi, res);
 
        return res;
    }
 
    public static void main([] args) {
 
        List<BigInteger> seeds = new ArrayList<>();
        List<BigInteger> related = new ArrayList<>();
        List<BigInteger> palin = new ArrayList<>();
 
        for (int i = 1; i <= 10_000; i++) {
             n = .valueOf(i);
 
            Tuple t = lychrel(n);
 
            if (!t.flag)
                continue;
 
            if (n.equals(t.bi))
                seeds.add(t.bi);
            else
                related.add(t.bi);
 
            if (n.equals(t.bi))
                palin.add(t.bi);
        }
 
        .out.printf(strv, seeds.size(), seeds);
        .out.printf(strv, related.size());
        .out.printf(strv, palin.size(), palin);
    }
}"
"import java.math.BigInteger;
public class Mersenne
{
 
    public static boolean isPrime(int p) {
        if (p == 2)
            return true;
        else if (p <= 1 || p % 2 == 0)
            return false;
        else {
            int to = (int).sqrt(p);
            for (int i = 3; i <= to; i += 2)
                if (p % i == 0)
                    return false;
            return true;
        }
    }
 
    public static boolean isMersennePrime(int p) {
        if (p == 2)
            return true;
        else {
             m_p = .ONE.shiftLeft(p).subtract(.ONE);
             s = .valueOf(4);
            for (int i = 3; i <= p; i++)
                s = s.multiply(s).subtract(.valueOf(2)).mod(m_p);
            return s.equals(.ZERO);
        }
    }
 
    

    public static void main([] args) {
        int upb;
        if (args.length == 0)
            upb = 500;
        else
            upb = .parseInt(args[0]);
 
        .out.print(strv + upb + ""]:M2 "");
        for (int p = 3; p <= upb; p += 2)
            if (isPrime(p) && isMersennePrime(p))
                .out.print(strv + p);
        .out.println();
    }
}"
"public class Luhn {
    public static void main([] args) {
        .out.println(luhnTest(strv));
        .out.println(luhnTest(strv));
        .out.println(luhnTest(strv));
        .out.println(luhnTest(strv));
    }
 
    public static boolean luhnTest( number){
        int s1 = 0, s2 = 0;
         reverse = new (number).reverse().toString();
        for(int i = 0 ;i < reverse.length();i++){
            int digit = .digit(reverse.charAt(i), 10);
            if(i % 2 == 0){//this is for odd digits, they are 1-indexed in the algorithm
                s1 += digit;
            }else{//add 2 * digit for 0-4, add 2 * digit - 9 for 5-9
                s2 += 2 * digit;
                if(digit >= 5){
                    s2 -= 9;
                }
            }
        }
        return (s1 + s2) % 10 == 0;
    }
}"
"import static java.util..stream;
import java.util.Locale;
import static java.util.stream.IntStream.range;
 
public class Test {
 
    static double dotProduct(double[] a, double[] b) {
        return range(0, a.length).mapToDouble(i -> a[i] * b[i]).sum();
    }
 
    static double[][] matrixMul(double[][] A, double[][] B) {
        double[][] result = new double[A.length][B[0].length];
        double[] aux = new double[B.length];
 
        for (int j = 0; j < B[0].length; j++) {
 
            for (int k = 0; k < B.length; k++)
                aux[k] = B[k][j];
 
            for (int i = 0; i < A.length; i++)
                result[i][j] = dotProduct(A[i], aux);
        }
        return result;
    }
 
    static double[][] pivotize(double[][] m) {
        int n = m.length;
        double[][] id = range(0, n).mapToObj(j -> range(0, n)
                .mapToDouble(i -> i == j ? 1 : 0).toArray())
                .toArray(double[][]::new);
 
        for (int i = 0; i < n; i++) {
            double maxm = m[i][i];
            int row = i;
            for (int j = i; j < n; j++)
                if (m[j][i] > maxm) {
                    maxm = m[j][i];
                    row = j;
                }
 
            if (i != row) {
                double[] tmp = id[i];
                id[i] = id[row];
                id[row] = tmp;
            }
        }
        return id;
    }
 
    static double[][][] lu(double[][] A) {
        int n = A.length;
        double[][] L = new double[n][n];
        double[][] U = new double[n][n];
        double[][] P = pivotize(A);
        double[][] A2 = matrixMul(P, A);
 
        for (int j = 0; j < n; j++) {
            L[j][j] = 1;
            for (int i = 0; i < j + 1; i++) {
                double s1 = 0;
                for (int k = 0; k < i; k++)
                    s1 += U[k][j] * L[i][k];
                U[i][j] = A2[i][j] - s1;
            }
            for (int i = j; i < n; i++) {
                double s2 = 0;
                for (int k = 0; k < j; k++)
                    s2 += U[k][j] * L[i][k];
                L[i][j] = (A2[i][j] - s2) / U[j][j];
            }
        }
        return new double[][][]{L, U, P};
    }
 
    static void print(double[][] m) {
        stream(m).forEach(a -> {
            stream(a).forEach(n -> .out.printf(.US, strv, n));
            .out.println();
        });
        .out.println();
    }
 
    public static void main([] args) {
        double[][] a = {{1.0, 3, 5}, {2.0, 4, 7}, {1.0, 1, 0}};
 
        double[][] b = {{11.0, 9, 24, 2}, {1.0, 5, 2, 6}, {3.0, 17, 18, 1},
        {2.0, 5, 7, 1}};
 
        for (double[][] m : lu(a))
            print(m);
 
        .out.println();
 
        for (double[][] m : lu(b))
            print(m);
    }
}"
"var out = .out
for(i in 1..10) {
  if(i > 1) out.print(strv)
  out.print(i)
}public static void main([] args) {
    for (int i = 1; ; i++) {
        .out.print(i);
        if (i == 10)
            break;
        .out.print(strv);
    }
    .out.println();
}"
"while(true){
   .out.println(strv);
}for(;;){
   .out.println(strv);
}"
"import java.util.Random;
 
public class NestedLoopTest {
    public static final  gen = new ();
    public static void main([] args) {
        int[][] a = new int[10][10];
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[i].length; j++)
                a[i][j] = gen.nextInt(20) + 1;
 
        Outer:for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                .out.print(strv + a[i][j]);
                if (a[i][j] == 20)
                    break Outer; //adding a label breaks out of all loops up to and including the labelled loop
            }
            .out.println();
        }
        .out.println();
    }
}"
"Iterable<Type> collect;
...
for(Type i:collect){
   .out.println(i);
}"
"for(int i = 2; i <= 8;i += 2){
   .out.print(i + strv);
}
.out.println(strv);"
"for(i = 10; i >= 0; --i){
   .out.println(i);
}"
"int val = 0;
do{
   val++;
   .out.println(val);
}while(val % 6 != 0);"
"for(int i = 1;i <= 10; i++){
   .out.print(i);
   if(i % 5 == 0){
      .out.println();
      continue;
   }
   .out.print(strv);
}"
"for ( i = 0; i < 5; i++) {
     line = '';
 
    for ( j = 0; j < i; j++) {
        line += '*';
    }
 
    .debug(line);
}
 
List<String> lines = new List<String> {
    '*',
    '**',
    '***',
    '****',
    '*****'
};
 
for ( line : lines) {
    .debug(line);
}for (int i = 0; i < 5; i++) {
   for (int j = 0; j <= i; j++) {
      .out.print(strv);
   }
   .out.println();
}"
"import java.util.Random;
 
 rand = new ();
while(true){
    int a = rand.nextInt(20);
    .out.println(a);
    if(a == 10) break;
    int b = rand.nextInt(20);
    .out.println(b);
}"
"import java.io.File;
import java.util.Scanner;
 
public class LongestStringChallenge {
 
    public static void main([] args) throws  {
         lines = strv, longest = strv;
        try (Scanner sc = new Scanner(new (strv))) {
            while(sc.hasNext()) {
                 line = sc.nextLine();
                if (longer(longest, line))
                    lines = longest = line;
                else if (!longer(line, longest))
                    lines = lines.concat("""").concat(line);
            }
        }
        .out.println(lines);
    }
 
    static boolean longer( a,  b) {
        try {
             dummy = a.substring(b.length());
        } catch ( e) {
            return true;
        }
        return false;
    }
}"
"[] a = {strv,strv,strv};
[] b = {strv,strv,strv};
int[] c = {1,2,3};
for(int i = 0;i < a.length;i++){
    .out.println(a[i] + b[i] + c[i]);
}"
"public class LongestCommonSubstring {
 
    public static void main([] args) {
        .out.println(lcs(strv, strv));
    }
 
    static  lcs( a,  b) {
        if (a.length() > b.length())
            return lcs(b, a);
 
         res = strv;
        for (int ai = 0; ai < a.length(); ai++) {
            for (int len = a.length() - ai; len > 0; len--) {
 
                for (int bi = 0; bi < b.length() - len; bi++) {
 
                    if (a.regionMatches(ai, b, bi, len) && len > res.length()) {
                        res = a.substring(ai, ai + len);
                    }
                }
            }
        }
        return res;
    }
}"
"import java.util.*;
 
public class LIS {
    public static <E extends Comparable<? super E>> List<E> lis(List<E> n) {
        List<Node<E>> pileTops = new ArrayList<Node<E>>();
        

        for (E x : n) {
	    Node<E> node = new Node<E>();
	    node.value = x;
            int i = .binarySearch(pileTops, node);
            if (i < 0) i = ~i;
	    if (i != 0)
		node.pointer = pileTops.get(i-1);
            if (i != pileTops.size())
                pileTops.set(i, node);
            else
                pileTops.add(node);
        }
	

	List<E> result = new ArrayList<E>();
	for (Node<E> node = pileTops.size() == 0 ? null : pileTops.get(pileTops.size()-1);
                node != null; node = node.pointer)
	    result.add(node.value);
	.reverse(result);
	return result;
    }
 
    private static class Node<E extends Comparable<? super E>> implements Comparable<Node<E>> {
	public E value;
	public Node<E> pointer;
        public int compareTo(Node<E> y) { return value.compareTo(y.value); }
    }
 
    public static void main([] args) {
	List<Integer> d = .asList(3,2,6,4,5,1);
	.out.printf(""an L.I.S. of %s is %s"", d, lis(d));
        d = .asList(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15);
	.out.printf(""an L.I.S. of %s is %s"", d, lis(d));
    }
}"
"public class LongMult {
 
	private static byte[] stringToDigits( num) {
		byte[] result = new byte[num.length()];
		for (int i = 0; i < num.length(); i++) {
			char c = num.charAt(i);
			if (c < '0' || c > '9') {
				throw new (strv + c
						+ strv + i);
			}
			result[num.length() - 1 - i] = (byte) (c - '0');
		}
		return result;
	}
 
	public static  longMult( num1,  num2) {
		byte[] left = stringToDigits(num1);
		byte[] right = stringToDigits(num2);
		byte[] result = new byte[left.length + right.length];
		for (int rightPos = 0; rightPos < right.length; rightPos++) {
			byte rightDigit = right[rightPos];
			byte temp = 0;
			for (int leftPos = 0; leftPos < left.length; leftPos++) {
				temp += result[leftPos + rightPos];
				temp += rightDigit * left[leftPos];
				result[leftPos + rightPos] = (byte) (temp % 10);
				temp /= 10;
			}
			int destPos = rightPos + left.length;
			while (temp != 0) {
				temp += result[destPos] & 0xFFFFFFFFL;
				result[destPos] = (byte) (temp % 10);
				temp /= 10;
				destPos++;
			}
		}
		StringBuilder stringResultBuilder = new StringBuilder(result.length);
		for (int i = result.length - 1; i >= 0; i--) {
			byte digit = result[i];
			if (digit != 0 || stringResultBuilder.length() > 0) {
				stringResultBuilder.append((char) (digit + '0'));
			}
		}
		return stringResultBuilder.toString();
	}
 
	public static void main([] args) {
		.out.println(longMult(strv,
				strv));
	}
}
 import java.util.Arrays;
 
public class LongMultBinary {
 
	/**	 * A very basic arbitrary-precision integer class. It only handles	 * non-negative numbers and doesn't implement any arithmetic not necessary	 * for the task at hand.	 */
	public static class MyLongNum implements  {
 
		/*		 * The actual bits of the integer, with the least significant place		 * first. The biggest native integer type of Java is the 64-bit long,		 * but since we need to be able to store the result of two digits		 * multiplied, we have to use the second biggest native type, the 32-bit		 * int. All numeric types are signed in Java, but we don't want to waste		 * the sign bit, so we need to take extra care while doing arithmetic to		 * ensure unsigned semantics.		 */
		private int[] digits;
 
		/*		 * The number of digits actually used in the digits array. Since arrays		 * cannot be resized in Java, we are better off remembering the logical		 * size ourselves, instead of reallocating and copying every time we need to shrink.		 */
		private int digitsUsed;
 
		@Override
		public MyLongNum clone() {
			try {
				MyLongNum clone = (MyLongNum) super.clone();
				clone.digits = clone.digits.clone();
				return clone;
			} catch ( e) {
				throw new (strv, e);
			}
		}
 
		private void resize(int newLength) {
			if (digits.length < newLength) {
				digits = .copyOf(digits, newLength);
			}
		}
 
		private void adjustDigitsUsed() {
			while (digitsUsed > 0 && digits[digitsUsed - 1] == 0) {
				digitsUsed--;
			}
		}
 
		/**		 * strv multiplication by one digit. Used to convert strings to long numbers.		 */
		public void multiply(int multiplier) {
			if (multiplier < 0) {
				throw new (
						strv);
			}
			resize(digitsUsed + 1);
			long temp = 0;
			for (int i = 0; i < digitsUsed; i++) {
				temp += (digits[i] & 0xFFFFFFFFL) * multiplier;
				digits[i] = (int) temp; 

				temp >>>= 32;
			}
			digits[digitsUsed] = (int) temp;
			digitsUsed++;
			adjustDigitsUsed();
		}
 
		/**		 * strv addition (adding a one-digit number). Used to convert strings to long numbers.		 */
		public void add(int addend) {
			if (addend < 0) {
				throw new (
						strv);
			}
			long temp = addend;
			for (int i = 0; i < digitsUsed && temp != 0; i++) {
				temp += (digits[i] & 0xFFFFFFFFL);
				digits[i] = (int) temp; 

				temp >>>= 32;
			}
			if (temp != 0) {
				resize(digitsUsed + 1);
				digits[digitsUsed] = (int) temp;
				digitsUsed++;
			}
		}
 
		/**		 * strv division (dividing by a one-digit number). Used to convert numbers to strings.		 * @param divisor The digit to divide by.		 * @return The remainder of the division.		 */
		public int divide(int divisor) {
			if (divisor < 0) {
				throw new (
						strv);
			}
			int remainder = 0;
			for (int i = digitsUsed - 1; i >= 0; i--) {
				long twoDigits = (((long) remainder << 32) | (digits[i] & 0xFFFFFFFFL));
				remainder = (int) (twoDigits % divisor);
				digits[i] = (int) (twoDigits / divisor);
			}
			adjustDigitsUsed();
			return remainder;
		}
 
		public MyLongNum( value) {
			

			this.digits = new int[value.length() / 9 + 1]; 
			this.digitsUsed = 0;
			

			for (int i = 0; i < value.length(); i+=9) {
				 chunk = value.substring(i, .min(i+9, value.length()));
				int multiplier = 1;
				int addend = 0;
				for (int j=0; j<chunk.length(); j++) {
					char c = chunk.charAt(j);
					if (c < '0' || c > '9') {
						throw new (strv + c
								+ strv);
					}
					multiplier *= 10;
					addend *= 10;
					addend += c - '0';
				}
				multiply(multiplier);
				add(addend);
			}
		}
 
		@Override
		public  toString() {
			if (digitsUsed == 0) {
				return strv;
			}
			MyLongNum dummy = this.clone();
			StringBuilder resultBuilder = new StringBuilder(digitsUsed * 9);
			while (dummy.digitsUsed > 0) {
				

				int decimalDigits = dummy.divide(1000000000);
				for (int i=0; i<9; i++) {
					resultBuilder.append((char) (decimalDigits % 10 + '0'));
					decimalDigits /= 10;
				}
			}
			

			while (resultBuilder.charAt(resultBuilder.length()-1) == '0') {
				resultBuilder.deleteCharAt(resultBuilder.length()-1);
			}
			return resultBuilder.reverse().toString();
		}
 
		/**		 * Long multiplication.		 */
		public void multiply(MyLongNum multiplier) {
			MyLongNum left, right;
			

			if (this.digitsUsed > multiplier.digitsUsed) {
				left = this;
				right = multiplier;
			} else {
				left = multiplier;
				right = this;
			}
			int[] newDigits = new int[left.digitsUsed + right.digitsUsed];
			for (int rightPos = 0; rightPos < right.digitsUsed; rightPos++) {
				long rightDigit = right.digits[rightPos] & 0xFFFFFFFFL;
				long temp = 0;
				for (int leftPos = 0; leftPos < left.digitsUsed; leftPos++) {
					temp += (newDigits[leftPos + rightPos] & 0xFFFFFFFFL);
					temp += rightDigit * (left.digits[leftPos] & 0xFFFFFFFFL);
					newDigits[leftPos + rightPos] = (int) temp;
					temp >>>= 32;
				}
				

				int destPos = rightPos + digitsUsed;
				while (temp != 0) {
					temp += (newDigits[destPos] & 0xFFFFFFFFL);
					newDigits[destPos] = (int) temp;
					temp >>>= 32;
					destPos++;
				}
			}
			this.digits = newDigits;
			this.digitsUsed = newDigits.length;
			adjustDigitsUsed();
		}
	}
 
	public static void main([] args) {
		MyLongNum one = new MyLongNum(strv);
		MyLongNum two = one.clone();
		one.multiply(two);
		.out.println(one);
	}
 
}
 "
"public static  lcs( a,  b){
    int aLen = a.length();
    int bLen = b.length();
    if(aLen == 0 || bLen == 0){
        return strv;
    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){
        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))
            + a.charAt(aLen-1);
    }else{
         x = lcs(a, b.substring(0,bLen-1));
         y = lcs(a.substring(0,aLen-1), b);
        return (x.length() > y.length()) ? x : y;
    }
}public static  lcs( a,  b) {
    int[][] lengths = new int[a.length()+1][b.length()+1];
 
    

 
    for (int i = 0; i < a.length(); i++)
        for (int j = 0; j < b.length(); j++)
            if (a.charAt(i) == b.charAt(j))
                lengths[i+1][j+1] = lengths[i][j] + 1;
            else
                lengths[i+1][j+1] =
                    .max(lengths[i+1][j], lengths[i][j+1]);
 
    

     sb = new ();
    for (int x = a.length(), y = b.length();
         x != 0 && y != 0; ) {
        if (lengths[x][y] == lengths[x-1][y])
            x--;
        else if (lengths[x][y] == lengths[x][y-1])
            y--;
        else {
            assert a.charAt(x-1) == b.charAt(y-1);
            sb.append(a.charAt(x-1));
            x--;
            y--;
        }
    }
 
    return sb.reverse().toString();
}"
"  char a = 'a';  

   b = strv;  

  char doubleQuote = '""';  

  char singleQuote = '';  

   singleQuotes = strv;  

   doubleQuotes = """";  
"
"boolean a = true;
boolean b = false;
.Debug('a AND b: ' + (a && b));
.Debug('a OR b: ' + (a || b));
.Debug('NOT a: ' + (!a));
.Debug('a XOR b: ' + (a ^ b));
 public static void logic(boolean a, boolean b){
  .out.println(strv + (a && b));
  .out.println(strv + (a || b));
  .out.println(strv + (!a));
}"
"1. //double equal to 1.0
1.0 //double
2432311.7567374 //double
1.234E-10 //double
1.234e-10 //double
758832d //double
728832f //float
1.0f //float
758832D //double
728832F //float
1.0F //float
1 / 2. //double
1 / 2 //int equal to 0"
"public class LevenshteinAlignment {
 
    public static [] alignment( a,  b) {
        a = a.toLowerCase();
        b = b.toLowerCase();
        

        int[][] costs = new int[a.length()+1][b.length()+1];
        for (int j = 0; j <= b.length(); j++)
            costs[0][j] = j;
        for (int i = 1; i <= a.length(); i++) {
            costs[i][0] = i;
            for (int j = 1; j <= b.length(); j++) {
                costs[i][j] = .min(1 + .min(costs[i-1][j], costs[i][j-1]), a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1);
            }
        }
 
	

	StringBuilder aPathRev = new StringBuilder();
	StringBuilder bPathRev = new StringBuilder();
	for (int i = a.length(), j = b.length(); i != 0 && j != 0; ) {
	    if (costs[i][j] == (a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1)) {
		aPathRev.append(a.charAt(--i));
		bPathRev.append(b.charAt(--j));
	    } else if (costs[i][j] == 1 + costs[i-1][j]) {
		aPathRev.append(a.charAt(--i));
		bPathRev.append('-');
	    } else if (costs[i][j] == 1 + costs[i][j-1]) {
		aPathRev.append('-');
		bPathRev.append(b.charAt(--j));
	    }
	}
        return new []{aPathRev.reverse().toString(), bPathRev.reverse().toString()};
    }
 
    public static void main([] args) {
	[] result = alignment(strv, strv);
	.out.println(result[0]);
	.out.println(result[1]);
    }
}"
"import java.util.stream.IntStream;
import static java.util.stream.IntStream.iterate;
 
public class LinearCongruentialGenerator {
    final static int mask = (1 << 31) - 1;
 
    public static void main([] args) {
        .out.println(strv);
        randBSD(0).limit(10).forEach(.out::println);
 
        .out.println(""MS:"");
        randMS(0).limit(10).forEach(.out::println);
    }
 
    static IntStream randBSD(int seed) {
        return iterate(seed, s -> (s * 1_103_515_245 + 12_345) & mask).skip(1);
    }
 
    static IntStream randMS(int seed) {
        return iterate(seed, s -> (s * 214_013 + 2_531_011) & mask).skip(1)
                .map(i -> i >> 16);
    }
}"
"public class Levenshtein {
 
    public static int distance( a,  b) {
        a = a.toLowerCase();
        b = b.toLowerCase();
        

        int [] costs = new int [b.length() + 1];
        for (int j = 0; j < costs.length; j++)
            costs[j] = j;
        for (int i = 1; i <= a.length(); i++) {
            

            costs[0] = i;
            int nw = i - 1;
            for (int j = 1; j <= b.length(); j++) {
                int cj = .min(1 + .min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);
                nw = costs[j];
                costs[j] = cj;
            }
        }
        return costs[b.length()];
    }
 
    public static void main( [] args) {
         [] data = { strv, strv, strv, strv, strv, strv };
        for (int i = 0; i < data.length; i += 2)
            .out.println(strv + data[i] + strv + data[i+1] + strv + distance(data[i], data[i+1]));
    }
}public class Levenshtein{
    public static int levenshtein( s,  t){
        /* if either string is empty, difference is inserting all chars          * from the other         */
        if(s.length() == 0) return t.length();
        if(t.length() == 0) return s.length();
 
        /* if first letters are the same, the difference is whatever is         * required to edit the rest of the strings         */
        if(s.charAt(0) == t.charAt(0))
            return levenshtein(s.substring(1), t.substring(1));
 
        /* else try:         *      changing first letter of s to that of t,         *      remove first letter of s, or         *      remove first letter of t         */
        int a = levenshtein(s.substring(1), t.substring(1));
        int b = levenshtein(s, t.substring(1));
        int c = levenshtein(s.substring(1), t);
 
        if(a > b) a = b;
        if(a > c) a = c;
 
        //any of which is 1 edit plus editing the rest of the strings
        return a + 1;
    }
 
    public static void main([] args) {
         s1 = strv;
         s2 = strv;
        .out.println(strv + s1 + strv
                + s2 + strv + levenshtein(s1, s2));
        s1 = strv;
        s2 = strv;
        .out.println(strv + s1 + strv
                + s2 + strv + levenshtein(s1, s2));
        StringBuilder sb1 = new StringBuilder(s1);
        StringBuilder sb2 = new StringBuilder(s2);
        .out.println(strv + sb1.reverse() + strv
                + sb2.reverse() + strv
                + levenshtein(sb1.reverse().toString(), sb2.reverse().toString()));
    }
}"
"import java.math.BigInteger;
 
public class LeftFac{
	public static  factorial( n){
		 ans = .ONE;
		for( x = .ONE; x.compareTo(n) <= 0; x = x.add(.ONE)){
			ans = ans.multiply(x);
		}
		return ans;
	}
 
	public static  leftFact( n){
		 ans = .ZERO;
		for( k = .ZERO; k.compareTo(n.subtract(.ONE)) <= 0; k = k.add(.ONE)){
			ans = ans.add(factorial(k));
		}
		return ans;
	}
 
	public static void main([] args){
		for(int i = 0; i <= 10; i++){
			.out.println(strv + i + strv + leftFact(.valueOf(i)));
		}
 
		for(int i = 20; i <= 110; i += 10){
			.out.println(strv + i + strv + leftFact(.valueOf(i)));
		}
 
		for(int i = 1000; i <= 10000; i += 1000){
			.out.println(strv + i + strv + leftFact(.valueOf(i)).toString().length() + strv);
		}
	}
}leftfactorial(n::) = n <= 0 ? zero(n) : sum(factorial, 0:n-1)
@vectorize_1arg  leftfactorial"
"import java.util.Scanner;
 
public class LCM{
   public static void main([] args){
      Scanner aScanner = new Scanner(.in);
 
      //prompts user for values to find the LCM for, then saves them to m and n
      .out.print(strv);
      int m = aScanner.nextInt();
      .out.print(strv);
      int n = aScanner.nextInt();
      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);
      /* this section increases the value of mm until it is greater        / than or equal to nn, then does it again when the lesser       / becomes the greater--if they aren't equal. If either value is 1,      / no need to calculate*/
      if (lcm == 0) {
         int mm = m, nn = n;
         while (mm != nn) {
             while (mm < nn) { mm += m; }
             while (nn < mm) { nn += n; }
         }  
         lcm = mm;
      }
      .out.println(strv + m + strv + n + strv + lcm);
   }
}"
"import java.util.GregorianCalendar;
import java.text.MessageFormat;
 
public class Leapyear{
        public static void main([] argv){
                int[] yrs = {1800,1900,1994,1998,1999,2000,2001,2004,2100};
                 cal = new ();
                for(int year : yrs){
                        .err.println(.format(strv,
                                                                 year, cal.isLeapYear(year), isLeapYear(year)));
                }
 
        }
        public static boolean isLeapYear(int year){
                return (year % 100 == 0) ? (year % 400 == 0) : (year % 4 == 0);
        }
}
 
 "
"

final class LastLetterFirstLetter {
    static int maxPathLength = 0;
    static int maxPathLengthCount = 0;
    static final  maxPathExample = new (500);
 
    static final [] names = {strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv,
        strv, strv, strv, strv, strv};
 
    static void recursive([] part, int offset) {
        if (offset > maxPathLength) {
            maxPathLength = offset;
            maxPathLengthCount = 1;
        } else if (offset == maxPathLength) {
            maxPathLengthCount++;
            maxPathExample.setLength(0);
            for (int i = 0; i < offset; i++) {
                maxPathExample.append((i % 5 == 0 ? ""  "" : strv));
                maxPathExample.append(part[i]);
            }
        }
        final char lastChar = part[offset - 1].charAt(part[offset - 1].length()-1);
        for (int i = offset; i < part.length; i++) {
            if (part[i].charAt(0) == lastChar) {
                 tmp = names[offset];
                names[offset] = names[i];
                names[i] = tmp;
                recursive(names, offset+1);
                names[i] = names[offset];
                names[offset] = tmp;
            }
        }
    }
 
    public static void main([] args) {
        for (int i = 0; i < names.length; i++) {
             tmp = names[0];
            names[0] = names[i];
            names[i] = tmp;
            recursive(names, 1);
            names[i] = names[0];
            names[0] = tmp;
       }
       .out.println(strv + maxPathLength);
       .out.println(strv + maxPathLengthCount);
       .out.println(strv + maxPathExample);
    }
}
 "
"import java.util.*;
 
class SOfN<T> {
    private static final  rand = new ();
 
    private List<T> sample;
    private int i = 0;
    private int n;
    public SOfN(int _n) {
	n = _n;
	sample = new ArrayList<T>(n);
    }
    public List<T> process(T item) {
	i++;
	if (i <= n) {
            sample.add(item);
	} else if (rand.nextInt(i) < n) {
	    sample.set(rand.nextInt(n), item);
	}
	return sample;
    }
}
 
public class AlgorithmS {
    public static void main([] args) {
	int[] bin = new int[10];
	for (int trial = 0; trial < 100000; trial++) {
	    SOfN<Integer> s_of_n = new SOfN<Integer>(3);
	    List<Integer> sample = null;
	    for (int i = 0; i < 10; i++)
		sample = s_of_n.process(i);
	    for (int s : sample)
		bin[s]++;
	}
	.out.println(.toString(bin));
    }
}import java.util.*;
 
interface Function<S, T> {
    public T call(S x);
}
 
public class AlgorithmS {
    private static final  rand = new ();
    public static <T> Function<T, List<T>> s_of_n_creator(final int n) {
	return new Function<T, List<T>>() {
	    private List<T> sample = new ArrayList<T>(n);
	    private int i = 0;
	    public List<T> call(T item) {
		i++;
		if (i <= n) {
		    sample.add(item);
		} else if (rand.nextInt(i) < n) {
		    sample.set(rand.nextInt(n), item);
		}
		return sample;
	    }
	};
    }
 
    public static void main([] args) {
	int[] bin = new int[10];
	for (int trial = 0; trial < 100000; trial++) {
	    Function<, List<Integer>> s_of_n = s_of_n_creator(3);
	    List<Integer> sample = null;
	    for (int i = 0; i < 10; i++)
		sample = s_of_n.call(i);
	    for (int s : sample)
		bin[s]++;
	}
	.out.println(.toString(bin));
    }
}"
"import java.util.Random;
 
public static final  gen = new ();
 


public static void shuffle (int[] array) {
    int n = array.length;
    while (n > 1) {
        int k = gen.nextInt(n--); //decrements after using the value
        int temp = array[n];
        array[n] = array[k];
        array[k] = temp;
    }
}


public static void shuffle ([] array) {
    int n = array.length;
    while (n > 1) {
        int k = gen.nextInt(n--); //decrements after using the value
         temp = array[n];
        array[n] = array[k];
        array[k] = temp;
    }
}"
"import java.awt.Color;
import java.awt.Graphics;
 
import javax.swing.JFrame;
import javax.swing.JPanel;
 
public class Langton extends {
	private  planePanel;
	private static final int ZOOM = 4;
 
	public Langton(final boolean[][] plane){
		planePanel = new (){
			@Override
			public void paint( g) {
				for(int y = 0; y < plane.length;y++){
					for(int x = 0; x < plane[0].length;x++){
						g.setColor(plane[y][x] ? .BLACK : .WHITE);
						g.fillRect(x * ZOOM, y * ZOOM, ZOOM, ZOOM);
					}
				}
				//mark the starting point
				g.setColor(.GREEN);
				g.fillRect(plane[0].length / 2 * ZOOM,
				           plane.length / 2 * ZOOM, ZOOM/2, ZOOM/2);
			}
		};
		planePanel.setSize(plane[0].length - 1, plane.length - 1);
		add(planePanel);
		setSize(ZOOM * plane[0].length, ZOOM * plane.length + 30);
		setDefaultCloseOperation(.EXIT_ON_CLOSE);
		setVisible(true);
	}
 
	public static void main([] args){
		new Langton(runAnt(100, 100));
	}
 
	private static boolean[][] runAnt(int height, int width){
		boolean[][] plane = new boolean[height][width];
		int antX = width/2, antY = height/2;//start in the middle-ish
		int xChange = 0, yChange = -1; //start moving up
		while(antX < width && antY < height && antX >= 0 && antY >= 0){
			if(plane[antY][antX]){
				//turn left
				if(xChange == 0){ //if moving up or down
					xChange = yChange;
					yChange = 0;
				}else{ //if moving left or right
					yChange = -xChange;
					xChange = 0;
				}
			}else{
				//turn right
				if(xChange == 0){ //if moving up or down
					xChange = -yChange;
					yChange = 0;
				}else{ //if moving left or right
					yChange = xChange;
					xChange = 0;
				}
			}
			plane[antY][antX] = !plane[antY][antX];
			antX += xChange;
			antY += yChange;
		}
		return plane;
	}
}"
"package hu.pj.alg;
 
import hu.pj.obj.Item;
import java.text.*;
 
public class UnboundedKnapsack {
 
    protected Item []  items = {
                               new Item(strv, 3000,  0.3, 0.025),
                               new Item(strv  , 1800,  0.2, 0.015),
                               new Item(strv   , 2500,  2.0, 0.002)
                               };
    protected final int    n = items.length; 

    protected Item      sack = new Item(strv   ,    0, 25.0, 0.250);
    protected Item      best = new Item(strv   ,    0,  0.0, 0.000);
    protected int  []  maxIt = new int [n];  

    protected int  []    iIt = new int [n];  

    protected int  [] bestAm = new int [n];  

 
    public UnboundedKnapsack() {
        

        for (int i = 0; i < n; i++) {
            maxIt [i] = .min(
                           (int)(sack.getWeight() / items[i].getWeight()),
                           (int)(sack.getVolume() / items[i].getVolume())
                        );
        } 

 
        

        calcWithRecursion(0);
 
        

         nf = .getInstance();
        .out.println(strv + best.getValue());
        .out.print(strv);
        for (int i = 0; i < n; i++) {
            .out.print(bestAm[i] + strv + items[i].getName() + strv);
        }
        .out.println();
        .out.println(strv + nf.format(best.getWeight()) +
                           strv + nf.format(best.getVolume())
                          );
 
    }
 
    

    

    public void calcWithRecursion(int item) {
        for (int i = 0; i <= maxIt[item]; i++) {
            iIt[item] = i;
            if (item < n-1) {
                calcWithRecursion(item+1);
            } else {
                int    currVal = 0;   

                double currWei = 0.0; 

                double currVol = 0.0; 

                for (int j = 0; j < n; j++) {
                    currVal += iIt[j] * items[j].getValue();
                    currWei += iIt[j] * items[j].getWeight();
                    currVol += iIt[j] * items[j].getVolume();
                }
 
                if (currVal > best.getValue()
                    &&
                    currWei <= sack.getWeight()
                    &&
                    currVol <= sack.getVolume()
                )
                {
                    best.setValue (currVal);
                    best.setWeight(currWei);
                    best.setVolume(currVol);
                    for (int j = 0; j < n; j++) bestAm[j] = iIt[j];
                } 

            } 

        } 

    } 

 
    

    public static void main([] args) {
        new UnboundedKnapsack();
    } 

 
} 
package hu.pj.obj;
 
public class Item {
    protected  name = strv;
    protected int value = 0;
    protected double weight = 0;
    protected double volume = 0;
 
    public Item() {
    }
 
    public Item( name, int value, double weight, double volume) {
        setName(name);
        setValue(value);
        setWeight(weight);
        setVolume(volume);
    }
 
    public int getValue() {
        return value;
    }
 
    public void setValue(int value) {
        this.value = .max(value, 0);
    }
 
    public double getWeight() {
        return weight;
    }
 
    public void setWeight(double weight) {
        this.weight = .max(weight, 0);
    }
 
    public double getVolume() {
        return volume;
    }
 
    public void setVolume(double volume) {
        this.volume = .max(volume, 0);
    }
 
    public  getName() {
        return name;
    }
 
    public void setName( name) {
        this.name = name;
    }
 
} 
"
" 
package hu.pj.alg.test;
 
import hu.pj.alg.ContinuousKnapsack;
import hu.pj.obj.Item;
import java.util.*;
import java.text.*;
 
public class ContinousKnapsackForRobber {
    final private double tolerance = 0.0005;
 
    public ContinousKnapsackForRobber() {
        ContinuousKnapsack cok = new ContinuousKnapsack(15); 

 
        

        cok.add(strv,     3.8, 36); 

        cok.add(strv,     5.4, 43); 

        cok.add(strv,      3.6, 90); 

        cok.add(strv,  2.4, 45); 

        cok.add(strv,   4.0, 30); 

        cok.add(strv,    2.5, 56); 

        cok.add(strv,     3.7, 67); 

        cok.add(strv,   3.0, 95); 

        cok.add(strv,  5.9, 98); 

 
        

        List<Item> itemList = cok.calcSolution();
 
        

        if (cok.isCalculated()) {
             nf  = .getInstance();
 
            .out.println(
                strv +
                nf.format(cok.getMaxWeight()) + strv
            );
            .out.println(
                strv +
                nf.format(cok.getSolutionWeight()) + strv
            );
            .out.println(
                strv +
                nf.format(cok.getProfit())
            );
            .out.println();
            .out.println(
                strv +
                strv
            );
            for (Item item : itemList) {
                if (item.getInKnapsack() > tolerance) {
                    .out.format(
                        ""%1$-10s %2$-15s %3$-15s "",
                        nf.format(item.getInKnapsack()) + strv,
                        item.getName(),
                        strv + nf.format(item.getInKnapsack() *
                                                (item.getValue() / item.getWeight())) + strv
                    );
                }
            }
        } else {
            .out.println(
                strv +
                strv
            );
        }
 
    }
 
    public static void main([] args) {
        new ContinousKnapsackForRobber();
    }
 
} 
 
package hu.pj.alg;
 
import hu.pj.obj.Item;
import java.util.*;
 
public class ContinuousKnapsack {
 
    protected List<Item> itemList   = new ArrayList<Item>();
    protected double maxWeight      = 0;
    protected double solutionWeight = 0;
    protected double profit         = 0;
    protected boolean calculated    = false;
 
    public ContinuousKnapsack() {}
 
    public ContinuousKnapsack(double _maxWeight) {
        setMaxWeight(_maxWeight);
    }
 
    public List<Item> calcSolution() {
        int n = itemList.size();
 
        setInitialStateForCalculation();
        if (n > 0  &&  maxWeight > 0) {
            .sort(itemList);
            for (int i = 0; (maxWeight - solutionWeight) > 0.0  &&  i < n; i++) {
                Item item = itemList.get(i);
                if (item.getWeight() >= (maxWeight - solutionWeight)) {
                    item.setInKnapsack(maxWeight - solutionWeight);
                    solutionWeight = maxWeight;
                    profit += item.getInKnapsack() / item.getWeight() * item.getValue();
                    break;
                } else {
                    item.setInKnapsack(item.getWeight());
                    solutionWeight += item.getInKnapsack();
                    profit += item.getValue();
                }
            }
            calculated = true;
        }
 
        return itemList;
    }
 
    

    public void add( name, double weight, double value) {
        if (name.equals(strv))
            name = strv + (itemList.size() + 1);
        itemList.add(new Item(name, weight, value));
        setInitialStateForCalculation();
    }
 
    public double getMaxWeight() {return maxWeight;}
    public double getProfit() {return profit;}
    public double getSolutionWeight() {return solutionWeight;}
    public boolean isCalculated() {return calculated;}
 
    public void setMaxWeight(double _maxWeight) {
        maxWeight = .max(_maxWeight, 0);
    }
 
    

    private void setInKnapsackByAll(double inKnapsack) {
        for (Item item : itemList)
            item.setInKnapsack(inKnapsack);
    }
 
    

    protected void setInitialStateForCalculation() {
        setInKnapsackByAll(-0.0001);
        calculated     = false;
        profit         = 0.0;
        solutionWeight = 0.0;
    }
 
} 
 
package hu.pj.obj;
 
public class Item implements  {
 
    protected  name       = strv;
    protected double weight     = 0;
    protected double value      = 0;
    protected double inKnapsack = 0; 

 
    public Item() {}
 
    public Item(Item item) {
        setName(item.name);
        setWeight(item.weight);
        setValue(item.value);
    }
 
    public Item(double _weight, double _value) {
        setWeight(_weight);
        setValue(_value);
    }
 
    public Item( _name, double _weight, double _value) {
        setName(_name);
        setWeight(_weight);
        setValue(_value);
    }
 
    public void setName( _name) {name = _name;}
    public void setWeight(double _weight) {weight = .max(_weight, 0);}
    public void setValue(double _value) {value = .max(_value, 0);}
 
    public void setInKnapsack(double _inKnapsack) {
        inKnapsack = .max(_inKnapsack, 0);
    }
 
    public void checkMembers() {
        setWeight(weight);
        setValue(value);
        setInKnapsack(inKnapsack);
    }
 
    public  getName() {return name;}
    public double getWeight() {return weight;}
    public double getValue() {return value;}
    public double getInKnapsack() {return inKnapsack;}
 
    

    public int compareTo( item) {
        int result = 0;
        Item i2 = (Item)item;
        double rate1 = value / weight;
        double rate2 = i2.value / i2.weight;
        if (rate1 > rate2) result = -1;  

        else if (rate1 < rate2) result = 1;
        return result;
    }
 
} 
"
"import java.util.*;
 
public class KnightsTour {
    private final static int base = 12;
    private final static int[][] moves = {{1,-2},{2,-1},{2,1},{1,2},{-1,2},
        {-2,1},{-2,-1},{-1,-2}};
    private static int[][] grid;
    private static int total;
 
    public static void main([] args) {
        grid = new int[base][base];
        total = (base - 4) * (base - 4);
 
        for (int r = 0; r < base; r++)
            for (int c = 0; c < base; c++)
                if (r < 2 || r > base - 3 || c < 2 || c > base - 3)
                    grid[r][c] = -1;
 
        int row = 2 + (int) (.random() * (base - 4));
        int col = 2 + (int) (.random() * (base - 4));
 
        grid[row][col] = 1;
 
        if (solve(row, col, 2))
            printResult();
        else .out.println(strv);
 
    }
 
    private static boolean solve(int r, int c, int count) {
        if (count > total)
            return true;
 
        List<int[]> nbrs = neighbors(r, c);
 
        if (nbrs.isEmpty() && count != total)
            return false;
 
        .sort(nbrs, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[2] - b[2];
            }
        });
 
        for (int[] nb : nbrs) {
            r = nb[0];
            c = nb[1];
            grid[r][c] = count;
            if (!orphanDetected(count, r, c) && solve(r, c, count + 1))
                return true;
            grid[r][c] = 0;
        }
 
        return false;
    }
 
    private static List<int[]> neighbors(int r, int c) {
        List<int[]> nbrs = new ArrayList<>();
 
        for (int[] m : moves) {
            int x = m[0];
            int y = m[1];
            if (grid[r + y][c + x] == 0) {
                int num = countNeighbors(r + y, c + x);
                nbrs.add(new int[]{r + y, c + x, num});
            }
        }
        return nbrs;
    }
 
    private static int countNeighbors(int r, int c) {
        int num = 0;
        for (int[] m : moves)
            if (grid[r + m[1]][c + m[0]] == 0)
                num++;
        return num;
    }
 
    private static boolean orphanDetected(int cnt, int r, int c) {
        if (cnt < total - 1) {
            List<int[]> nbrs = neighbors(r, c);
            for (int[] nb : nbrs)
                if (countNeighbors(nb[0], nb[1]) == 0)
                    return true;
        }
        return false;
    }
 
    private static void printResult() {
        for (int[] row : grid) {
            for (int i : row) {
                if (i == -1) continue;
                .out.printf(strv, i);
            }
            .out.println();
        }
    }
}"
"import java.awt.event.*;
import javax.swing.*;
 
public class Test extends  {
 
    Test() {
        addKeyListener(new () {
            @Override
            public void keyPressed( e) {
                int keyCode = e.getKeyCode();
                .out.println(keyCode);
            }
        });
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
            Test f = new Test();
            f.setFocusable(true);
            f.setVisible(true);
        });
    }
}"
"package hu.pj.alg.test;
 
import hu.pj.alg.BoundedKnapsack;
import hu.pj.obj.Item;
import java.util.*;
import java.text.*;
 
public class BoundedKnapsackForTourists {
    public BoundedKnapsackForTourists() {
        BoundedKnapsack bok = new BoundedKnapsack(400); 

 
        

        bok.add(strv, 9, 150, 1);
        bok.add(strv, 13, 35, 1);
        bok.add(strv, 153, 200, 3);
        bok.add(strv, 50, 60, 2);
        bok.add(strv, 15, 60, 2);
        bok.add(strv, 68, 45, 3);
        bok.add(strv, 27, 60, 3);
        bok.add(strv, 39, 40, 3);
        bok.add(strv, 23, 30, 1);
        bok.add(strv, 52, 10, 3);
        bok.add(strv, 11, 70, 1);
        bok.add(strv, 32, 30, 1);
        bok.add(strv, 24, 15, 2);
        bok.add(strv, 48, 10, 2);
        bok.add(strv, 73, 40, 1);
        bok.add(strv, 42, 70, 1);
        bok.add(strv, 43, 75, 1);
        bok.add(strv, 22, 80, 1);
        bok.add(strv, 7, 20, 1);
        bok.add(strv, 18, 12, 2);
        bok.add(strv, 4, 50, 1);
        bok.add(strv, 30, 10, 2);
 
        

        List<Item> itemList = bok.calcSolution();
 
        

        if (bok.isCalculated()) {
             nf  = .getInstance();
 
            .out.println(
                strv +
                nf.format(bok.getMaxWeight() / 100.0) + strv
            );
            .out.println(
                strv +
                nf.format(bok.getSolutionWeight() / 100.0) + strv
            );
            .out.println(
                strv +
                bok.getProfit()
            );
            .out.println();
            .out.println(
                strv +
                strv
            );
            for (Item item : itemList) {
                if (item.getInKnapsack() > 0) {
                    .out.format(
                        ""%1$-10s %2$-23s %3$-3s %4$-5s %5$-15s "",
                        item.getInKnapsack() + strv,
                        item.getName(),
                        item.getInKnapsack() * item.getWeight(), strv,
                        strv + item.getInKnapsack() * item.getValue() + strv
                    );
                }
            }
        } else {
            .out.println(
                strv +
                strv
            );
        }
 
    }
 
    public static void main([] args) {
        new BoundedKnapsackForTourists();
    }
} 
package hu.pj.alg;
 
import hu.pj.obj.Item;
import java.util.*;
 
public class BoundedKnapsack extends ZeroOneKnapsack {
    public BoundedKnapsack() {}
 
    public BoundedKnapsack(int _maxWeight) {
        setMaxWeight(_maxWeight);
    }
 
    public BoundedKnapsack(List<Item> _itemList) {
        setItemList(_itemList);
    }
 
    public BoundedKnapsack(List<Item> _itemList, int _maxWeight) {
        setItemList(_itemList);
        setMaxWeight(_maxWeight);
    }
 
    @Override
    public List<Item> calcSolution() {
        int n = itemList.size();
 
        

        for (int i = 0; i < n; i++) {
            Item item = itemList.get(i);
            if (item.getBounding() > 1) {
                for (int j = 1; j < item.getBounding(); j++) {
                    add(item.getName(), item.getWeight(), item.getValue());
                }
            }
        }
 
        super.calcSolution();
 
        

        while (itemList.size() > n) {
            Item lastItem = itemList.get(itemList.size() - 1);
            if (lastItem.getInKnapsack() == 1) {
                for (int i = 0; i < n; i++) {
                    Item iH = itemList.get(i);
                    if (lastItem.getName().equals(iH.getName())) {
                        iH.setInKnapsack(1 + iH.getInKnapsack());
                        break;
                    }
                }
            }
            itemList.remove(itemList.size() - 1);
        }
 
        return itemList;
    }
 
    

    public void add( name, int weight, int value, int bounding) {
        if (name.equals(strv))
            name = strv + (itemList.size() + 1);
        itemList.add(new Item(name, weight, value, bounding));
        setInitialStateForCalculation();
    }
} 
package hu.pj.alg;
 
import hu.pj.obj.Item;
import java.util.*;
 
public class ZeroOneKnapsack {
    protected List<Item> itemList  = new ArrayList<Item>();
    protected int maxWeight        = 0;
    protected int solutionWeight   = 0;
    protected int profit           = 0;
    protected boolean calculated   = false;
 
    public ZeroOneKnapsack() {}
 
    public ZeroOneKnapsack(int _maxWeight) {
        setMaxWeight(_maxWeight);
    }
 
    public ZeroOneKnapsack(List<Item> _itemList) {
        setItemList(_itemList);
    }
 
    public ZeroOneKnapsack(List<Item> _itemList, int _maxWeight) {
        setItemList(_itemList);
        setMaxWeight(_maxWeight);
    }
 
    

    public List<Item> calcSolution() {
        int n = itemList.size();
 
        setInitialStateForCalculation();
        if (n > 0  &&  maxWeight > 0) {
            List< List<Integer> > c = new ArrayList< List<Integer> >();
            List<Integer> curr = new ArrayList<Integer>();
 
            c.add(curr);
            for (int j = 0; j <= maxWeight; j++)
                curr.add(0);
            for (int i = 1; i <= n; i++) {
                List<Integer> prev = curr;
                c.add(curr = new ArrayList<Integer>());
                for (int j = 0; j <= maxWeight; j++) {
                    if (j > 0) {
                        int wH = itemList.get(i-1).getWeight();
                        curr.add(
                            (wH > j)
                            ?
                            prev.get(j)
                            :
                            .max(
                                prev.get(j),
                                itemList.get(i-1).getValue() + prev.get(j-wH)
                            )
                        );
                    } else {
                        curr.add(0);
                    }
                } 

            } 

            profit = curr.get(maxWeight);
 
            for (int i = n, j = maxWeight; i > 0  &&  j >= 0; i--) {
                int tempI   = c.get(i).get(j);
                int tempI_1 = c.get(i-1).get(j);
                if (
                    (i == 0  &&  tempI > 0)
                    ||
                    (i > 0  &&  tempI != tempI_1)
                )
                {
                    Item iH = itemList.get(i-1);
                    int  wH = iH.getWeight();
                    iH.setInKnapsack(1);
                    j -= wH;
                    solutionWeight += wH;
                }
            } 

            calculated = true;
        } 

        return itemList;
    }
 
    

    public void add( name, int weight, int value) {
        if (name.equals(strv))
            name = strv + (itemList.size() + 1);
        itemList.add(new Item(name, weight, value));
        setInitialStateForCalculation();
    }
 
    

    public void add(int weight, int value) {
        add(strv, weight, value); 

    }
 
    

    public void remove( name) {
        for (Iterator<Item> it = itemList.iterator(); it.hasNext(); ) {
            if (name.equals(it.next().getName())) {
                it.remove();
            }
        }
        setInitialStateForCalculation();
    }
 
    

    public void removeAllItems() {
        itemList.clear();
        setInitialStateForCalculation();
    }
 
    public int getProfit() {
        if (!calculated)
            calcSolution();
        return profit;
    }
 
    public int getSolutionWeight() {return solutionWeight;}
    public boolean isCalculated() {return calculated;}
    public int getMaxWeight() {return maxWeight;}
 
    public void setMaxWeight(int _maxWeight) {
        maxWeight = .max(_maxWeight, 0);
    }
 
    public void setItemList(List<Item> _itemList) {
        if (_itemList != null) {
            itemList = _itemList;
            for (Item item : _itemList) {
                item.checkMembers();
            }
        }
    }
 
    

    private void setInKnapsackByAll(int inKnapsack) {
        for (Item item : itemList)
            if (inKnapsack > 0)
                item.setInKnapsack(1);
            else
                item.setInKnapsack(0);
    }
 
    

    protected void setInitialStateForCalculation() {
        setInKnapsackByAll(0);
        calculated     = false;
        profit         = 0;
        solutionWeight = 0;
    }
} 
package hu.pj.obj;
 
public class Item {
    protected  name    = strv;
    protected int weight     = 0;
    protected int value      = 0;
    protected int bounding   = 1; 

    protected int inKnapsack = 0; 

 
    public Item() {}
 
    public Item(Item item) {
        setName(item.name);
        setWeight(item.weight);
        setValue(item.value);
        setBounding(item.bounding);
    }
 
    public Item(int _weight, int _value) {
        setWeight(_weight);
        setValue(_value);
    }
 
    public Item(int _weight, int _value, int _bounding) {
        setWeight(_weight);
        setValue(_value);
        setBounding(_bounding);
    }
 
    public Item( _name, int _weight, int _value) {
        setName(_name);
        setWeight(_weight);
        setValue(_value);
    }
 
    public Item( _name, int _weight, int _value, int _bounding) {
        setName(_name);
        setWeight(_weight);
        setValue(_value);
        setBounding(_bounding);
    }
 
    public void setName( _name) {name = _name;}
    public void setWeight(int _weight) {weight = .max(_weight, 0);}
    public void setValue(int _value) {value = .max(_value, 0);}
 
    public void setInKnapsack(int _inKnapsack) {
        inKnapsack = .min(getBounding(), .max(_inKnapsack, 0));
    }
 
    public void setBounding(int _bounding) {
        bounding = .max(_bounding, 0);
        if (bounding == 0)
            inKnapsack = 0;
    }
 
    public void checkMembers() {
        setWeight(weight);
        setValue(value);
        setBounding(bounding);
        setInKnapsack(inKnapsack);
    }
 
    public  getName() {return name;}
    public int getWeight() {return weight;}
    public int getValue() {return value;}
    public int getInKnapsack() {return inKnapsack;}
    public int getBounding() {return bounding;}
} 
"
" 
package keybord.macro.demo;
 
import javax.swing.JFrame;
import javax.swing.JLabel;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
 
class KeyboardMacroDemo {
    public static void main(  [] args ) {
        final  frame = new ();
 
         directions = strv
                                 +strv;
 
        frame.add( new (directions));
 
        frame.addKeyListener( new (){
            public void keyReleased(  e ) {
                if( e.isControlDown() && e.getKeyCode() == .VK_S){
                    frame.setTitle(strv);
                }else if( e.isControlDown() && e.getKeyCode() == .VK_H){
                    frame.setTitle(strv);
                }
            }
        });
        frame.pack();
        frame.setVisible(true);
    }
}
 "
"public class Kaprekar {
    private static [] splitAt( str, int idx){
        [] ans = new [2];
        ans[0] = str.substring(0, idx);
        if(ans[0].equals(strv)) ans[0] = strv; //parsing strv throws an exception
        ans[1] = str.substring(idx);
        return ans;
    }
 
    public static void main([] args){
        int count = 0;
        int base = (args.length > 0) ? .parseInt(args[0]) : 10;
        for(long i = 1; i <= 1000000; i++){
             sqrStr = .toString(i * i, base);
            for(int j = 0; j < sqrStr.length() / 2 + 1; j++){
                [] parts = splitAt(sqrStr, j);
                long firstNum = .parseLong(parts[0], base);
                long secNum = .parseLong(parts[1], base);
                //if the right part is all zeroes, then it will be forever, so break
                if(secNum == 0) break;
                if(firstNum + secNum == i){
                    .out.println(i + """" + .toString(i, base) +
                            """" + sqrStr + """" + parts[0] + strv + parts[1]);
                    count++;
                    break;
                }
            }
        }
        .out.println(count + strv+base);
    }
}"
"package hu.pj.alg.test;
 
import hu.pj.alg.ZeroOneKnapsack;
import hu.pj.obj.Item;
import java.util.*;
import java.text.*;
 
public class ZeroOneKnapsackForTourists {
 
    public ZeroOneKnapsackForTourists() {
        ZeroOneKnapsack zok = new ZeroOneKnapsack(400); 

 
        

        zok.add(strv, 9, 150);
        zok.add(strv, 13, 35);
        zok.add(strv, 153, 200);
        zok.add(strv, 50, 160);
        zok.add(strv, 15, 60);
        zok.add(strv, 68, 45);
        zok.add(strv, 27, 60);
        zok.add(strv, 39, 40);
        zok.add(strv, 23, 30);
        zok.add(strv, 52, 10);
        zok.add(strv, 11, 70);
        zok.add(strv, 32, 30);
        zok.add(strv, 24, 15);
        zok.add(strv, 48, 10);
        zok.add(strv, 73, 40);
        zok.add(strv, 42, 70);
        zok.add(strv, 43, 75);
        zok.add(strv, 22, 80);
        zok.add(strv, 7, 20);
        zok.add(strv, 18, 12);
        zok.add(strv, 4, 50);
        zok.add(strv, 30, 10);
 
        

        List<Item> itemList = zok.calcSolution();
 
        

        if (zok.isCalculated()) {
             nf  = .getInstance();
 
            .out.println(
                strv +
                nf.format(zok.getMaxWeight() / 100.0) + strv
            );
            .out.println(
                strv +
                nf.format(zok.getSolutionWeight() / 100.0) + strv
            );
            .out.println(
                strv +
                zok.getProfit()
            );
            .out.println();
            .out.println(
                strv +
                strv
            );
            for (Item item : itemList) {
                if (item.getInKnapsack() == 1) {
                    .out.format(
                        ""%1$-23s %2$-3s %3$-5s %4$-15s "",
                        item.getName(),
                        item.getWeight(), strv,
                        strv + item.getValue() + strv
                    );
                }
            }
        } else {
            .out.println(
                strv +
                strv
            );
        }
 
    }
 
    public static void main([] args) {
        new ZeroOneKnapsackForTourists();
    }
 
} 
package hu.pj.alg;
 
import hu.pj.obj.Item;
import java.util.*;
 
public class ZeroOneKnapsack {
 
    protected List<Item> itemList  = new ArrayList<Item>();
    protected int maxWeight        = 0;
    protected int solutionWeight   = 0;
    protected int profit           = 0;
    protected boolean calculated   = false;
 
    public ZeroOneKnapsack() {}
 
    public ZeroOneKnapsack(int _maxWeight) {
        setMaxWeight(_maxWeight);
    }
 
    public ZeroOneKnapsack(List<Item> _itemList) {
        setItemList(_itemList);
    }
 
    public ZeroOneKnapsack(List<Item> _itemList, int _maxWeight) {
        setItemList(_itemList);
        setMaxWeight(_maxWeight);
    }
 
    

    public List<Item> calcSolution() {
        int n = itemList.size();
 
        setInitialStateForCalculation();
        if (n > 0  &&  maxWeight > 0) {
            List< List<Integer> > c = new ArrayList< List<Integer> >();
            List<Integer> curr = new ArrayList<Integer>();
 
            c.add(curr);
            for (int j = 0; j <= maxWeight; j++)
                curr.add(0);
            for (int i = 1; i <= n; i++) {
                List<Integer> prev = curr;
                c.add(curr = new ArrayList<Integer>());
                for (int j = 0; j <= maxWeight; j++) {
                    if (j > 0) {
                        int wH = itemList.get(i-1).getWeight();
                        curr.add(
                            (wH > j)
                            ?
                            prev.get(j)
                            :
                            .max(
                                prev.get(j),
                                itemList.get(i-1).getValue() + prev.get(j-wH)
                            )
                        );
                    } else {
                        curr.add(0);
                    }
                } 

            } 

            profit = curr.get(maxWeight);
 
            for (int i = n, j = maxWeight; i > 0  &&  j >= 0; i--) {
                int tempI   = c.get(i).get(j);
                int tempI_1 = c.get(i-1).get(j);
                if (
                    (i == 0  &&  tempI > 0)
                    ||
                    (i > 0  &&  tempI != tempI_1)
                )
                {
                    Item iH = itemList.get(i-1);
                    int  wH = iH.getWeight();
                    iH.setInKnapsack(1);
                    j -= wH;
                    solutionWeight += wH;
                }
            } 

            calculated = true;
        } 

        return itemList;
    }
 
    

    public void add( name, int weight, int value) {
        if (name.equals(strv))
            name = strv + (itemList.size() + 1);
        itemList.add(new Item(name, weight, value));
        setInitialStateForCalculation();
    }
 
    

    public void add(int weight, int value) {
        add(strv, weight, value); 

    }
 
    

    public void remove( name) {
        for (Iterator<Item> it = itemList.iterator(); it.hasNext(); ) {
            if (name.equals(it.next().getName())) {
                it.remove();
            }
        }
        setInitialStateForCalculation();
    }
 
    

    public void removeAllItems() {
        itemList.clear();
        setInitialStateForCalculation();
    }
 
    public int getProfit() {
        if (!calculated)
            calcSolution();
        return profit;
    }
 
    public int getSolutionWeight() {return solutionWeight;}
    public boolean isCalculated() {return calculated;}
    public int getMaxWeight() {return maxWeight;}
 
    public void setMaxWeight(int _maxWeight) {
        maxWeight = .max(_maxWeight, 0);
    }
 
    public void setItemList(List<Item> _itemList) {
        if (_itemList != null) {
            itemList = _itemList;
            for (Item item : _itemList) {
                item.checkMembers();
            }
        }
    }
 
    

    private void setInKnapsackByAll(int inKnapsack) {
        for (Item item : itemList)
            if (inKnapsack > 0)
                item.setInKnapsack(1);
            else
                item.setInKnapsack(0);
    }
 
    

    protected void setInitialStateForCalculation() {
        setInKnapsackByAll(0);
        calculated     = false;
        profit         = 0;
        solutionWeight = 0;
    }
 
} 
package hu.pj.obj;
 
public class Item {
 
    protected  name    = strv;
    protected int weight     = 0;
    protected int value      = 0;
    protected int bounding   = 1; 

    protected int inKnapsack = 0; 

 
    public Item() {}
 
    public Item(Item item) {
        setName(item.name);
        setWeight(item.weight);
        setValue(item.value);
        setBounding(item.bounding);
    }
 
    public Item(int _weight, int _value) {
        setWeight(_weight);
        setValue(_value);
    }
 
    public Item(int _weight, int _value, int _bounding) {
        setWeight(_weight);
        setValue(_value);
        setBounding(_bounding);
    }
 
    public Item( _name, int _weight, int _value) {
        setName(_name);
        setWeight(_weight);
        setValue(_value);
    }
 
    public Item( _name, int _weight, int _value, int _bounding) {
        setName(_name);
        setWeight(_weight);
        setValue(_value);
        setBounding(_bounding);
    }
 
    public void setName( _name) {name = _name;}
    public void setWeight(int _weight) {weight = .max(_weight, 0);}
    public void setValue(int _value) {value = .max(_value, 0);}
 
    public void setInKnapsack(int _inKnapsack) {
        inKnapsack = .min(getBounding(), .max(_inKnapsack, 0));
    }
 
    public void setBounding(int _bounding) {
        bounding = .max(_bounding, 0);
        if (bounding == 0)
            inKnapsack = 0;
    }
 
    public void checkMembers() {
        setWeight(weight);
        setValue(value);
        setBounding(bounding);
        setInKnapsack(inKnapsack);
    }
 
    public  getName() {return name;}
    public int getWeight() {return weight;}
    public int getValue() {return value;}
    public int getInKnapsack() {return inKnapsack;}
    public int getBounding() {return bounding;}
 
} 
"
"loop1: while (x != 0) {
    loop2: for (int i = 0; i < 10; i++) {
        loop3: do {
            //some calculations...
            if (/*some condition*/) {
                //this continue will skip the rest of the while loop code and start it over at the next iteration
                continue loop1;
            }
            //more calculations skipped by the continue if it is executed
            if (/*another condition*/) {
                //this break will end the for loop and jump to its closing brace
                break loop2;
            }
        } while (y < 10);
        //loop2 calculations skipped if the break is executed
    }
    //loop1 calculations executed after loop2 is done or if the break is executed, skipped if the continue is executed
} 
public class FizzBuzzThrower {
    public static void main(  [] args ) {
        for ( int i = 1; i <= 30; i++ ) {
            try {
                 message = strv;
                if ( i % 3 == 0 ) message = strv;
                if ( i % 5 == 0 ) message += strv;
                if ( ! strv.equals( message ) ) throw new ( message );
                .out.print( i );
            } catch ( final  x ) {
                .out.print( x.getMessage() );
            } finally {
                .out.println();
            }
        }
    }
}
 "
"public class JortSort {
    public static void main([] args) {
        .out.println(jortSort(new int[]{1, 2, 3}));
    }
 
    static boolean jortSort(int[] arr) {
        return true;
    }
}"
"import java.util.function.*;
import java.util.stream.*;
 
public class Jensen {
    static double sum(int lo, int hi, IntToDoubleFunction f) {
        return IntStream.rangeClosed(lo, hi).mapToDouble(f).sum();
    }
 
    public static void main( args[]) {
        .out.println(sum(1, 100, (i -> 1.0/i)));
    }
}
 public class Jensen2 {
 
    interface IntToDoubleFunction {
        double apply(int n);
    }
 
    static double sum(int lo, int hi, IntToDoubleFunction f) {
        double res = 0;
        for (int i = lo; i <= hi; i++)
            res += f.apply(i);
        return res;
 
    }
    public static void main( args[]) {
        .out.println(
            sum(1, 100,
                new IntToDoubleFunction() {
                    public double apply(int i) { return 1.0/i;}
                }));
    }
}
 "
"import java.awt.*;
import java.awt.image.BufferedImage;
import javax.swing.*;
 
public class JuliaSet extends  {
    private final int maxIter = 300;
    private final double zoom = 1;
    private double cY, cX;
 
    public JuliaSet() {
        setPreferredSize(new (800, 600));
        setBackground(.white);
    }
 
    void drawJuliaSet( g) {
        int w = getWidth();
        int h = getHeight();
         image = new (w, h,
                .TYPE_INT_RGB);
 
        cX = -0.7;
        cY = 0.27015;
        double moveX = 0, moveY = 0;
        double zx, zy;
 
        for (int x = 0; x < w; x++) {
            for (int y = 0; y < h; y++) {
                zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;
                zy = (y - h / 2) / (0.5 * zoom * h) + moveY;
                float i = maxIter;
                while (zx * zx + zy * zy < 4 && i > 0) {
                    double tmp = zx * zx - zy * zy + cX;
                    zy = 2.0 * zx * zy + cY;
                    zx = tmp;
                    i--;
                }
                int c = .HSBtoRGB((maxIter / i) % 1, 1, i > 0 ? 1 : 0);
                image.setRGB(x, y, c);
            }
        }
        g.drawImage(image, 0, 0, null);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
        drawJuliaSet(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new JuliaSet(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}void setup() {
  size(640, 480);
}
 
float cX = -0.7;
float cY = 0.27015;
float zx, zy;
float maxIter = 300;
 
void draw() {
  for (int x = 0; x < width; x++) {
    for (int y = 0; y < height; y++) {
      zx = 1.5 * (x - width / 2) / (0.5 * width);
      zy = (y - height / 2) / (0.5 * height);
      float i = maxIter;
      while (zx * zx + zy * zy < 4 && i > 0) {
        float tmp = zx * zx - zy * zy + cX;
        zy = 2.0 * zx * zy + cY;
        zx = tmp;
        i -= 1;
      }
      color c = hsv2rgb(i / maxIter * 360, 1, i > 1 ? 1 : 0);
      set(x, y, c);
    }
  }
  noLoop();
}
 
color hsv2rgb(float h, float s, float v) {
  float c = v * s;
  float x = c * (1 - abs(((h/60) % 2) - 1));
  float m = v - c;
 
  float r, g, b;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
 
  int ri = round((r + m) * 255);
  int gi = round((g + m) * 255);
  int bi = round((b + m) * 255);
 
  return color(ri, gi, bi);
}"
" 


//


//
grammar JSON ;
@members {
 Indent = strv;
}
	:	(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;
WS	:	(' ' | '' | '' |'') {skip();};
Tz	:	' ' .. '!' | '#' .. '[' | ']' .. '~';
	:	'' ('""'|''|'/'|'b'|'f'|'n'|'r'|'t'|UCode);
UCode	:	'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');
Keyword	:	'true' | 'false' | 'null';
	:	'""' (? Tz)* '""';
object	:       '{' {.out.println(Indent + strv); Indent += strv;} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};
pair	:	e =  {.out.println(Indent + ""{Property}"" + $e.text);} ':' value;
value	:	             {.out.println(Indent + ""{Number}  "" + $Number.text);}
	|	object
	|	             {.out.println(Indent + ""{String}  "" + $String.text);}
	|	Keyword            {.out.println(Indent + ""{Keyword} "" + $Keyword.text);}
	|	array;
array	:	'[' {.out.println(Indent + strv); Indent += strv;} (value (',' value)*)? ']' {Indent = Indent.substring(4);};
 import com.google.gson.Gson;
 
public class JsonExample {
 
	public static void main([] args) {
		Gson gson = new Gson();
		 json = ""{ foo: 1, bar: [ 10, apples] }"";
 
		MyJsonObject obj = gson.fromJson(json, MyJsonObject.class);
 
		.out.println(obj.getFoo());
 
		for( bar : obj.getBar()) {
			.out.println(bar);
		}
 
		obj = new MyJsonObject(2, new [] { strv, strv });
		json = gson.toJson(obj);
 
		.out.println(json);
	}
 
}
 
class MyJsonObject {
 
	private int foo;
	private [] bar;
 
	public MyJsonObject(int foo, [] bar) {
		this.foo = foo;
		this.bar = bar;
	}
 
	public int getFoo() {
		return foo;
	}
 
	public [] getBar() {
		return bar;
	}
 
}"
"public class JaroDistance {
    public static double jaro( s,  t) {
        int s_len = s.length();
        int t_len = t.length();
 
        if (s_len == 0 && t_len == 0) return 1;
 
        int match_distance = .max(s_len, t_len) / 2 - 1;
 
        boolean[] s_matches = new boolean[s_len];
        boolean[] t_matches = new boolean[t_len];
 
        int matches = 0;
        int transpositions = 0;
 
        for (int i = 0; i < s_len; i++) {
            int start = .max(0, i-match_distance);
            int end = .min(i+match_distance+1, t_len);
 
            for (int j = start; j < end; j++) {
                if (t_matches[j]) continue;
                if (s.charAt(i) != t.charAt(j)) continue;
                s_matches[i] = true;
                t_matches[j] = true;
                matches++;
                break;
            }
        }
 
        if (matches == 0) return 0;
 
        int k = 0;
        for (int i = 0; i < s_len; i++) {
            if (!s_matches[i]) continue;
            while (!t_matches[k]) k++;
            if (s.charAt(i) != t.charAt(k)) transpositions++;
            k++;
        }
 
        return (((double)matches / s_len) +
                ((double)matches / t_len) +
                (((double)matches - transpositions/2.0) / matches)) / 3.0;
    }
 
    public static void main([] args) {
        .out.println(jaro(   strv,      strv));
        .out.println(jaro(    strv,    strv));
        .out.println(jaro(strv,  strv));
    }
}"
"import java.util.stream.IntStream;
 
public class IteratedDigitsSquaring {
 
    public static void main([] args) {
        long r = IntStream.range(1, 100_000_000)
                .parallel()
                .filter(n -> calc(n) == 89)
                .count();
        .out.println(r);
    }
 
    private static int calc(int n) {
        while (n != 89 && n != 1) {
            int total = 0;
            while (n > 0) {
                total += .pow(n % 10, 2);
                n /= 10;
            }
            n = total;
        }
        return n;
    }
}"
" 
package org.rosettacode;
 
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
 
public class InvertedIndex {
 
	List<String> stopwords = .asList(strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv, strv, strv,
			strv, strv, strv, strv, strv, strv);
 
	Map<, List<Tuple>> index = new HashMap<, List<Tuple>>();
	List<String> files = new ArrayList<String>();
 
	public void indexFile( file) throws  {
		int fileno = files.indexOf(file.getPath());
		if (fileno == -1) {
			files.add(file.getPath());
			fileno = files.size() - 1;
		}
 
		int pos = 0;
		 reader = new (new (file));
		for ( line = reader.readLine(); line != null; line = reader
				.readLine()) {
			for ( _word : line.split(""W+"")) {
				 word = _word.toLowerCase();
				pos++;
				if (stopwords.contains(word))
					continue;
				List<Tuple> idx = index.get(word);
				if (idx == null) {
					idx = new LinkedList<Tuple>();
					index.put(word, idx);
				}
				idx.add(new Tuple(fileno, pos));
			}
		}
		.out.println(strv + file.getPath() + strv + pos + strv);
	}
 
	public void search(List<String> words) {
		for ( _word : words) {
			Set<String> answer = new HashSet<String>();
			 word = _word.toLowerCase();
			List<Tuple> idx = index.get(word);
			if (idx != null) {
				for (Tuple t : idx) {
					answer.add(files.get(t.fileno));
				}
			}
			.out.print(word);
			for ( f : answer) {
				.out.print(strv + f);
			}
			.out.println(strv);
		}
	}
 
	public static void main([] args) {
		try {
			InvertedIndex idx = new InvertedIndex();
			for (int i = 1; i < args.length; i++) {
				idx.indexFile(new (args[i]));
			}
			idx.search(.asList(args[0].split(strv)));
		} catch ( e) {
			e.printStackTrace();
		}
	}
 
	private class Tuple {
		private int fileno;
		private int position;
 
		public Tuple(int fileno, int position) {
			this.fileno = fileno;
			this.position = position;
		}
	}
}
 
  
java -cp bin org.rosettacode.InvertedIndex strv pg30637.txt pg7025.txt pg82.txt pg9090.txt 
indexed pg30637.txt 106473 words
indexed pg7025.txt 205714 words
indexed pg82.txt 205060 words
indexed pg9090.txt 68962 words
huntsman pg82.txt pg7025.txt
merit pg9090.txt pg30637.txt pg82.txt pg7025.txt
dog pg30637.txt pg82.txt pg7025.txt
the
gutenberg pg9090.txt pg30637.txt pg82.txt pg7025.txt
lovecraft pg30637.txt
olympian pg30637.txt
 
 "
"public class VersCheck {
	public static void main([] args) {
		 vers = .getProperty(strv);
		vers = vers.substring(0,vers.indexOf('.')) + strv +  //some String fiddling to get the version number into a usable form
			vers.substring(vers.indexOf('.')+1,vers.lastIndexOf('.'));
		if(.parseDouble(vers) >= 1.5){
			.out.println(strv);
		}else{
			.err.println(strv);
		}
	}
}"
"public class Count{
    public static void main([] args){
        for(long i = 1; ;i++) .out.println(i);
    }
}import java.math.BigInteger;
 
public class Count{
    public static void main([] args){
        for( i = .ONE; ;i = i.add(.ONE)) .out.println(i);
    }
}"
"public class integerOverflow {
 
    public static void main([] args) {
        .out.println(strv);
        .out.println(-(-2147483647-1));
        .out.println(2000000000 + 2000000000);
        .out.println(-2147483647 - 2147483647);
        .out.println(46341 * 46341);
        .out.println((-2147483647-1) / -1);
        .out.println(strv);
        .out.println(-(-9223372036854775807L-1));
        .out.println(5000000000000000000L+5000000000000000000L);
        .out.println(-9223372036854775807L - 9223372036854775807L);
        .out.println(3037000500L * 3037000500L);
        .out.println((-9223372036854775807L-1) / -1);
    }
 
}"
"import java.io.*;
 
public class compInt {
   public static void main([] args) {
       try {
            in = new (new (.in));
 
           int nbr1 = .parseInt(in.readLine());
           int nbr2 = .parseInt(in.readLine());
 
           if(nbr1<nbr2)
               .out.println(nbr1 + strv + nbr2);
 
           if(nbr1>nbr2)
                .out.println(nbr1 + strv + nbr2);
 
           if(nbr1==nbr2)
                .out.println(nbr1 + strv + nbr2);
       } catch( e) { }
   }
}"
"import java.util.Scanner;
 
public class Main {
 
	public static int doStuff(int a, int b){
	    int sum = a+b;
	    return sum;
	}
 
	public static void main([] args) {
		Scanner in = new Scanner(.in);
 
		int n = in.nextInt();
		for(int i=0; i<n; i++){
			int a = in.nextInt();
			int b= in.nextInt();
			int result = doStuff(a, b);
			.out.println(result);
		}
	}
}"
"import java.util.Scanner;
 
public class Main {
	public static void doStuff( word){
	   .out.println(word);
	}
 
	public static void main([] args) {
		Scanner in = new Scanner(.in);
		int n = .parseInt(in.nextLine());  //doesn't use nextInt() so nextLine doesn't just read newline character
		for(int i=0; i<n; i++){		
			 word = in.nextLine();
			doStuff(word);
		}
	}
}"
"public class Animal{
   //functions go here...
}public class Dog extends Animal{
   //functions go here...
}public class Cat extends Animal{
   //functions go here...
}public class Lab extends Dog{
   //functions go here...
}public class Collie extends Dog{
   //functions go here...
}"
"import java.util.Scanner;
...
Scanner in = new Scanner(.in);//stdin
//new Scanner(new FileInputStream(filename)) for a file
//new Scanner(socket.getInputStream()) for a network stream
while(in.hasNext()){
	 input = in.next(); //in.nextLine() for line-by-line
	//process the input here
}import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
...
try{
	 inp = new (new (.in));//stdin
	//new BufferedReader(new FileReader(filename)) for a file
	//new BufferedReader(new InputStreamReader(socket.getInputStream())) for a network stream
		while(inp.ready()){
			 input = inp.readLine();//line-by-line only
			//in.read() for character-by-character
			//process the input here
		}
} catch ( e) {
	//There was an input error
}"
"public interface Camera{
   //functions here with no definition...
   //ex:
   //public void takePicture();
}public interface MobilePhone{
   //functions here with no definition...
   //ex:
   //public void makeCall();
}public class CameraPhone implements Camera, MobilePhone{
   //functions here...
}"
"import java.math.BigInteger;
import static java.util..stream;
import java.util.*;
import static java.util.stream.Collectors.*;
 
public class Test3 {
    static  rank(int[] x) {
         s = stream(x).mapToObj(::valueOf).collect(joining(strv));
        return new (s, 16);
    }
 
    static List<BigInteger> unrank( n) {
         sixteen = .valueOf(16);
         s = strv;
        while (!n.equals(.ZERO)) {
            s = strv.charAt(n.mod(sixteen).intValue()) + s;
            n = n.divide(sixteen);
        }
        return stream(s.split(strv)).map(x -> new (x)).collect(toList());
    }
 
    public static void main([] args) {
        int[] s = {1, 2, 3, 10, 100, 987654321};
        .out.println(.toString(s));
        .out.println(rank(s));
        .out.println(unrank(rank(s)));
    }
}"
"double infinity = .POSITIVE_INFINITY; //defined as 1.0/0.0
.isInfinite(infinity); //truepublic static double getInf(){
   return .POSITIVE_INFINITY;
}double biggestNumber = .MAX_VALUE;"
" s = strv;
s = .valueOf(.parseInt(s) + 1); s = strv;
s = new (s).add(.ONE).toString();"
"public class Class1 extends Class2
{
	//code here
}public class Class1
{
	Class2 c2=new Class2();
	static void main([] args)
	{
		c2.func1();
		c2.func2();
	}
}"
"import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.util.Arrays;
import java.util.Random;
import javax.swing.*;
 
public class ImageNoise {
    int framecount = 0;
    int fps = 0;
     image;
     kernel;
     cop;
     frame = new (strv);
 
     panel = new () {
        private int show_fps = 0; 

        private  ma = new () {
            @Override
            public void mouseClicked( e) {
                show_fps = (show_fps + 1) % 3;
            }
        };
        {addMouseListener(ma);}
 
        @Override
        public  getPreferredSize() {
            return new (320, 240);
        }
 
        @Override
        @SuppressWarnings(strv)
        public void paintComponent( g1) {
             g = () g1;
            drawNoise();
            g.drawImage(image, 0, 0, null);
 
            switch (show_fps) {
            case 0: 
                

                int xblur = getWidth() - 130, yblur = getHeight() - 32;
                 bc = image.getSubimage(xblur, yblur, 115, 32);
                 bs = new (bc.getWidth(), bc.getHeight(),
                                                     .TYPE_BYTE_GRAY);
                cop.filter(bc, bs);
                g.drawImage(bs, xblur, yblur , null);
            case 1: 
                

                g.setColor(.RED);
                g.setFont(new (strv, .BOLD, 20));
                g.drawString(strv + fps, getWidth() - 120, getHeight() - 10);
            }
            framecount++;
        }
    };
 
    

     repainter = new (1, new () {
        @Override
        public void actionPerformed( e) {
            panel.repaint();
        }
    });
 
    

     framerateChecker = new (1000, new () {
        @Override
        public void actionPerformed( e) {
            fps = framecount;
            framecount = 0;
        }
    });
 
    public ImageNoise() {
        

        float[] vals = new float[121];
        .fill(vals, 1/121f);
        kernel = new (11, 11, vals);
        cop = new (kernel, .EDGE_NO_OP, null);
 
        

        frame.add(panel);
        frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
        repainter.start();
        framerateChecker.start();
    }
 
    void drawNoise() {
        int w = panel.getWidth(), h = panel.getHeight();
 
        

        if (null == image || image.getWidth() != w || image.getHeight() != h) {
            image = new (w, h, .TYPE_BYTE_GRAY);
        }
         rand = new ();
        int[] data = new int[w * h];
        

        for (int x = 0; x < w * h / 32; x++) {
            int r = rand.nextInt();
            for (int i = 0; i < 32; i++) {
                data[x * 32 + i] = (r & 1) * .MAX_VALUE;
                r >>>= 1;
            }
        }
        

        image.getRaster().setPixels(0, 0, w, h, data);
    }
 
    public static void main([] args) {
        

        .invokeLater(new () {
            @Override
            public void run() {
                ImageNoise i = new ImageNoise();
            }
        });
    }
}"
"import java.awt.image.*;
import java.io.File;
import java.io.IOException;
import javax.imageio.*;
 
public class ImageConvolution
{
  public static class ArrayData
  {
    public final int[] dataArray;
    public final int width;
    public final int height;
 
    public ArrayData(int width, int height)
    {
      this(new int[width * height], width, height);
    }
 
    public ArrayData(int[] dataArray, int width, int height)
    {
      this.dataArray = dataArray;
      this.width = width;
      this.height = height;
    }
 
    public int get(int x, int y)
    {  return dataArray[y * width + x];  }
 
    public void set(int x, int y, int value)
    {  dataArray[y * width + x] = value;  }
  }
 
  private static int bound(int value, int endIndex)
  {
    if (value < 0)
      return 0;
    if (value < endIndex)
      return value;
    return endIndex - 1;
  }
 
  public static ArrayData convolute(ArrayData inputData, ArrayData kernel, int kernelDivisor)
  {
    int inputWidth = inputData.width;
    int inputHeight = inputData.height;
    int kernelWidth = kernel.width;
    int kernelHeight = kernel.height;
    if ((kernelWidth <= 0) || ((kernelWidth & 1) != 1))
      throw new (strv);
    if ((kernelHeight <= 0) || ((kernelHeight & 1) != 1))
      throw new (strv);
    int kernelWidthRadius = kernelWidth >>> 1;
    int kernelHeightRadius = kernelHeight >>> 1;
 
    ArrayData outputData = new ArrayData(inputWidth, inputHeight);
    for (int i = inputWidth - 1; i >= 0; i--)
    {
      for (int j = inputHeight - 1; j >= 0; j--)
      {
        double newValue = 0.0;
        for (int kw = kernelWidth - 1; kw >= 0; kw--)
          for (int kh = kernelHeight - 1; kh >= 0; kh--)
            newValue += kernel.get(kw, kh) * inputData.get(
                          bound(i + kw - kernelWidthRadius, inputWidth),
                          bound(j + kh - kernelHeightRadius, inputHeight));
        outputData.set(i, j, (int).round(newValue / kernelDivisor));
      }
    }
    return outputData;
  }
 
  public static ArrayData[] getArrayDatasFromImage( filename) throws 
  {
     inputImage = ImageIO.read(new (filename));
    int width = inputImage.getWidth();
    int height = inputImage.getHeight();
    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);
    ArrayData reds = new ArrayData(width, height);
    ArrayData greens = new ArrayData(width, height);
    ArrayData blues = new ArrayData(width, height);
    for (int y = 0; y < height; y++)
    {
      for (int x = 0; x < width; x++)
      {
        int rgbValue = rgbData[y * width + x];
        reds.set(x, y, (rgbValue >>> 16) & 0xFF);
        greens.set(x, y, (rgbValue >>> 8) & 0xFF);
        blues.set(x, y, rgbValue & 0xFF);
      }
    }
    return new ArrayData[] { reds, greens, blues };
  }
 
  public static void writeOutputImage( filename, ArrayData[] redGreenBlue) throws 
  {
    ArrayData reds = redGreenBlue[0];
    ArrayData greens = redGreenBlue[1];
    ArrayData blues = redGreenBlue[2];
     outputImage = new (reds.width, reds.height,
                                                  .TYPE_INT_ARGB);
    for (int y = 0; y < reds.height; y++)
    {
      for (int x = 0; x < reds.width; x++)
      {
        int red = bound(reds.get(x, y), 256);
        int green = bound(greens.get(x, y), 256);
        int blue = bound(blues.get(x, y), 256);
        outputImage.setRGB(x, y, (red << 16) | (green << 8) | blue | -0x01000000);
      }
    }
    ImageIO.write(outputImage, strv, new (filename));
    return;
  }
 
  public static void main([] args) throws 
  {
    int kernelWidth = .parseInt(args[2]);
    int kernelHeight = .parseInt(args[3]);
    int kernelDivisor = .parseInt(args[4]);
    .out.println(strv + kernelWidth + strv + kernelHeight +
                       strv + kernelDivisor);
    int y = 5;
    ArrayData kernel = new ArrayData(kernelWidth, kernelHeight);
    for (int i = 0; i < kernelHeight; i++)
    {
      .out.print(strv);
      for (int j = 0; j < kernelWidth; j++)
      {
        kernel.set(j, i, .parseInt(args[y++]));
        .out.print(strv + kernel.get(j, i) + strv);
      }
      .out.println(strv);
    }
 
    ArrayData[] dataArrays = getArrayDatasFromImage(args[0]);
    for (int i = 0; i < dataArrays.length; i++)
      dataArrays[i] = convolute(dataArrays[i], kernel, kernelDivisor);
    writeOutputImage(args[1], dataArrays);
    return;
  }
}"
"import java.util.stream.IntStream;
 
public class Test {
    public static void main([] args) throws  {
        .out.print(strv);
        IntStream.rangeClosed(0, 0x10FFFF)
                .filter(::isUpperCase)
                .limit(72)
                .forEach(cp -> .out.printf(strv, cp));
        .out.print(strv);
 
        .out.print(""Lower case: "");
        IntStream.rangeClosed(0, 0x10FFFF)
                .filter(::isLowerCase)
                .limit(72)
                .forEach(cp -> .out.printf(strv, cp));
        .out.println(strv);
    }
}"
"public class PrintIdentityMatrix {
 
    public static void main([] args) {
        int n = 5;
        int[][] array = new int[n][n];
 
        IntStream.range(0, n).forEach(i -> array[i][i] = 1);
 
        .stream(array)
                .map((int[] a) -> .toString(a))
                .forEach(.out::println);
    }
}"
" 
 url = new (strv);
HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
Scanner scanner = new Scanner(connection.getInputStream());
 
while (scanner.hasNext()) {
    .out.println(scanner.next());
}
 "
" 
import java.io.BufferedReader;
import java.io.FileReader;
 
public class IbeforeE 
{
	public static void main([] args)
	{
		IbeforeE now=new IbeforeE();
		 wordlist=strv;
		if(now.isPlausibleRule(wordlist))
			.out.println(strv);
		else
			.out.println(strv);
	}
	boolean isPlausibleRule( filename)
	{
		int truecount=0,falsecount=0;
		try
		{
			 br=new (new (filename));
			 word;
			while((word=br.readLine())!=null)
			{
				if(isPlausibleWord(word))
					truecount++;
				else if(isOppPlausibleWord(word))
					falsecount++;
			}
			br.close();
		}
		catch( e)
		{
			.out.println(strv+e.getMessage());
		}
 
		.out.println(strv+truecount);
		.out.println(strv+falsecount);
		if(truecount>2*falsecount)
			return true;
		return false;
	}
	boolean isPlausibleWord( word)
	{
		if(!word.contains(strv)&&word.contains(strv))
			return true;
		else if(word.contains(strv))
			return true;
		return false;
	}
	boolean isOppPlausibleWord( word)
	{
		if(!word.contains(strv)&&word.contains(strv))
			return true;
		else if(word.contains(strv))
			return true;
		return false;
	}
}
 "
"import java.awt.image.*;
import java.io.File;
import java.io.IOException;
import javax.imageio.*;
 
public class HoughTransform
{
  public static ArrayData houghTransform(ArrayData inputData, int thetaAxisSize, int rAxisSize, int minContrast)
  {
    int width = inputData.width;
    int height = inputData.height;
    int maxRadius = (int).ceil(.hypot(width, height));
    int halfRAxisSize = rAxisSize >>> 1;
    ArrayData outputData = new ArrayData(thetaAxisSize, rAxisSize);
    

    

    double[] sinTable = new double[thetaAxisSize];
    double[] cosTable = new double[thetaAxisSize];
    for (int theta = thetaAxisSize - 1; theta >= 0; theta--)
    {
      double thetaRadians = theta * .PI / thetaAxisSize;
      sinTable[theta] = .sin(thetaRadians);
      cosTable[theta] = .cos(thetaRadians);
    }
 
    for (int y = height - 1; y >= 0; y--)
    {
      for (int x = width - 1; x >= 0; x--)
      {
        if (inputData.contrast(x, y, minContrast))
        {
          for (int theta = thetaAxisSize - 1; theta >= 0; theta--)
          {
            double r = cosTable[theta] * x + sinTable[theta] * y;
            int rScaled = (int).round(r * halfRAxisSize / maxRadius) + halfRAxisSize;
            outputData.accumulate(theta, rScaled, 1);
          }
        }
      }
    }
    return outputData;
  }
 
  public static class ArrayData
  {
    public final int[] dataArray;
    public final int width;
    public final int height;
 
    public ArrayData(int width, int height)
    {
      this(new int[width * height], width, height);
    }
 
    public ArrayData(int[] dataArray, int width, int height)
    {
      this.dataArray = dataArray;
      this.width = width;
      this.height = height;
    }
 
    public int get(int x, int y)
    {  return dataArray[y * width + x];  }
 
    public void set(int x, int y, int value)
    {  dataArray[y * width + x] = value;  }
 
    public void accumulate(int x, int y, int delta)
    {  set(x, y, get(x, y) + delta);  }
 
    public boolean contrast(int x, int y, int minContrast)
    {
      int centerValue = get(x, y);
      for (int i = 8; i >= 0; i--)
      {
        if (i == 4)
          continue;
        int newx = x + (i % 3) - 1;
        int newy = y + (i / 3) - 1;
        if ((newx < 0) || (newx >= width) || (newy < 0) || (newy >= height))
          continue;
        if (.abs(get(newx, newy) - centerValue) >= minContrast)
          return true;
      }
      return false;
    }
 
    public int getMax()
    {
      int max = dataArray[0];
      for (int i = width * height - 1; i > 0; i--)
        if (dataArray[i] > max)
          max = dataArray[i];
      return max;
    }
  }
 
  public static ArrayData getArrayDataFromImage( filename) throws 
  {
     inputImage = ImageIO.read(new (filename));
    int width = inputImage.getWidth();
    int height = inputImage.getHeight();
    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);
    ArrayData arrayData = new ArrayData(width, height);
    

    for (int y = 0; y < height; y++)
    {
      for (int x = 0; x < width; x++)
      {
        int rgbValue = rgbData[y * width + x];
        rgbValue = (int)(((rgbValue & 0xFF0000) >>> 16) * 0.30 + ((rgbValue & 0xFF00) >>> 8) * 0.59 + (rgbValue & 0xFF) * 0.11);
        arrayData.set(x, height - 1 - y, rgbValue);
      }
    }
    return arrayData;
  }
 
  public static void writeOutputImage( filename, ArrayData arrayData) throws 
  {
    int max = arrayData.getMax();
     outputImage = new (arrayData.width, arrayData.height, .TYPE_INT_ARGB);
    for (int y = 0; y < arrayData.height; y++)
    {
      for (int x = 0; x < arrayData.width; x++)
      {
        int n = .min((int).round(arrayData.get(x, y) * 255.0 / max), 255);
        outputImage.setRGB(x, arrayData.height - 1 - y, (n << 16) | (n << 8) | 0x90 | -0x01000000);
      }
    }
    ImageIO.write(outputImage, strv, new (filename));
    return;
  }
 
  public static void main([] args) throws 
  {
    ArrayData inputData = getArrayDataFromImage(args[0]);
    int minContrast = (args.length >= 4) ? 64 : .parseInt(args[4]);
    ArrayData outputData = houghTransform(inputData, .parseInt(args[2]), .parseInt(args[3]), minContrast);
    writeOutputImage(args[1], outputData);
    return;
  }
}"
"import java.util.*;
 
abstract class HuffmanTree implements Comparable<HuffmanTree> {
    public final int frequency; 

    public HuffmanTree(int freq) { frequency = freq; }
 
    

    public int compareTo(HuffmanTree tree) {
        return frequency - tree.frequency;
    }
}
 
class HuffmanLeaf extends HuffmanTree {
    public final char value; 

 
    public HuffmanLeaf(int freq, char val) {
        super(freq);
        value = val;
    }
}
 
class HuffmanNode extends HuffmanTree {
    public final HuffmanTree left, right; 

 
    public HuffmanNode(HuffmanTree l, HuffmanTree r) {
        super(l.frequency + r.frequency);
        left = l;
        right = r;
    }
}
 
public class HuffmanCode {
    

    public static HuffmanTree buildTree(int[] charFreqs) {
        PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();
        

        

        for (int i = 0; i < charFreqs.length; i++)
            if (charFreqs[i] > 0)
                trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));
 
        assert trees.size() > 0;
        

        while (trees.size() > 1) {
            

            HuffmanTree a = trees.poll();
            HuffmanTree b = trees.poll();
 
            

            trees.offer(new HuffmanNode(a, b));
        }
        return trees.poll();
    }
 
    public static void printCodes(HuffmanTree tree,  prefix) {
        assert tree != null;
        if (tree instanceof HuffmanLeaf) {
            HuffmanLeaf leaf = (HuffmanLeaf)tree;
 
            

            .out.println(leaf.value + """" + leaf.frequency + """" + prefix);
 
        } else if (tree instanceof HuffmanNode) {
            HuffmanNode node = (HuffmanNode)tree;
 
            

            prefix.append('0');
            printCodes(node.left, prefix);
            prefix.deleteCharAt(prefix.length()-1);
 
            

            prefix.append('1');
            printCodes(node.right, prefix);
            prefix.deleteCharAt(prefix.length()-1);
        }
    }
 
    public static void main([] args) {
         test = strv;
 
        

        

        int[] charFreqs = new int[256];
        

        for (char c : test.toCharArray())
            charFreqs[c]++;
 
        

        HuffmanTree tree = buildTree(charFreqs);
 
        

        .out.println(""SYMBOLWEIGHTHUFFMAN CODE"");
        printCodes(tree, new ());
    }
}"
"import java.net.*;
class DiscoverHostName {
 public static void main(final [] args) {
  try {
   .out.println(.getLocalHost().getHostName());
  } catch ( e) { 

  }
 }
}"
"import java.nio.ByteOrder;
 
public class ShowByteOrder {
    public static void main([] args) {
        

        .out.println(ByteOrder.nativeOrder());
    }
}.out.println(strv+.getProperty(strv));
.out.println(strv+.getProperty(strv));"
"import java.util.Scanner;
public class Sundial {
    public static void main([] args) {
        double lat, slat, lng, ref;
        Scanner sc = new Scanner(.in);
 
        .out.print(strv);
        lat = sc.nextDouble();
        .out.print(strv);
        lng = sc.nextDouble();
        .out.print(strv);
        ref = sc.nextDouble();
        .out.println();
 
        slat = .sin(.toRadians(lat));
        .out.printf(""sine of latitude: %.3f"", slat);
        .out.printf(""diff longitude: %.3f"", lng - ref);
 
        .out.printf(""Hour, sun hour angle, dial hour line angle from 6am to 6pm"");
 
        for (int h = -6; h <= 6; h++) {
            double hla, hra;
            hra = 15.0 * h;
            hra = hra - lng + ref;
            hraRad = .toRadians(hra);
            hla = .toDegrees(.atan2(.sin(hraRad)*.sin(.toRadians(lat)), .cos(hraRad)));
            .out.printf(""HR= %3d;    HRA=%7.3f;    HLA= %7.3f"",
                    h, hra, hla);
        }
    }
}"
"public class HofCon
{
 public static void main(final [] args)
 {
  doSqnc(1<<20);
 }
 public static void doSqnc(int m)
 {
  int[] a_list = new int[m + 1];
  int max_df = 0;
  int p2_max = 2;
  int k1 = 2; 
  int lg2 = 1;
  double amax = 0;
  a_list[0] = a_list[1] = 1;
  int v = a_list[2];
  for (int n = 2; n <= m; n++)
  {
   v = a_list[n] = a_list[v] + a_list[n - v];
   if (amax < v * 1.0 / n)
    amax = v * 1.0 / n;
   if (0 == (k1 & n))
   {
    .out.printf(""Maximum between 2^%d and 2^%d was %f"", lg2, lg2 + 1, amax);
    amax = 0;
    lg2++;
   }
   k1 = n;
  }
 }
}"
"import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
 
public class Honeycombs extends  {
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new Honeycombs();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setVisible(true);
        });
    }
 
    public Honeycombs() {
        add(new HoneycombsPanel(), .CENTER);
        setTitle(strv);
        setResizable(false);
        pack();
        setLocationRelativeTo(null);
    }
}
 
class HoneycombsPanel extends  {
 
    Hexagon[] comb;
 
    public HoneycombsPanel() {
        setPreferredSize(new (600, 500));
        setBackground(.white);
        setFocusable(true);
 
        addMouseListener(new () {
            @Override
            public void mousePressed( e) {
                for (Hexagon hex : comb)
                    if (hex.contains(e.getX(), e.getY())) {
                        hex.setSelected();
                        break;
                    }
                repaint();
            }
        });
 
        addKeyListener(new () {
            @Override
            public void keyPressed( e) {
                for (Hexagon hex : comb)
                    if (hex.letter == .toUpperCase(e.getKeyChar())) {
                        hex.setSelected();
                        break;
                    }
                repaint();
            }
        });
 
        char[] letters = strv.toCharArray();
        comb = new Hexagon[20];
 
        int x1 = 150, y1 = 100, x2 = 225, y2 = 143, w = 150, h = 87;
        for (int i = 0; i < comb.length; i++) {
            int x, y;
            if (i < 12) {
                x = x1 + (i % 3) * w;
                y = y1 + (i / 3) * h;
            } else {
                x = x2 + (i % 2) * w;
                y = y2 + ((i - 12) / 2) * h;
            }
            comb[i] = new Hexagon(x, y, w / 3, letters[i]);
        }
 
        requestFocus();
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        g.setFont(new (strv, .BOLD, 30));
        g.setStroke(new (3));
 
        for (Hexagon hex : comb)
            hex.draw(g);
    }
}
 
class Hexagon extends  {
    final  baseColor = .yellow;
    final  selectedColor = .magenta;
    final char letter;
 
    private boolean hasBeenSelected;
 
    Hexagon(int x, int y, int halfWidth, char c) {
        letter = c;
        for (int i = 0; i < 6; i++)
            addPoint((int) (x + halfWidth * .cos(i * .PI / 3)),
                     (int) (y + halfWidth * .sin(i * .PI / 3)));
        getBounds();
    }
 
    void setSelected() {
        hasBeenSelected = true;
    }
 
    void draw( g) {
        g.setColor(hasBeenSelected ? selectedColor : baseColor);
        g.fillPolygon(this);
 
        g.setColor(.black);
        g.drawPolygon(this);
 
        g.setColor(hasBeenSelected ? .black : .red);
        drawCenteredString(g, .valueOf(letter));
    }
 
    void drawCenteredString( g,  s) {
         fm = g.getFontMetrics();
        int asc = fm.getAscent();
        int dec = fm.getDescent();
 
        int x = bounds.x + (bounds.width - fm.stringWidth(s)) / 2;
        int y = bounds.y + (asc + (bounds.height - (asc + dec)) / 2);
 
        g.drawString(s, x, y);
    }
}"
"import java.text.DateFormatSymbols;
import java.util.*;
 
public class EasterRelatedHolidays {
 
    final static Map<, Integer> holidayOffsets;
 
    static {
        holidayOffsets = new LinkedHashMap<>();
        holidayOffsets.put(strv, 0);
        holidayOffsets.put(strv, 39);
        holidayOffsets.put(strv, 10);
        holidayOffsets.put(strv, 7);
        holidayOffsets.put(strv, 4);
    }
 
    public static void main([] args) {
        .out.println(strv
                + strv);
 
        for (int y = 400; y <= 2100; y += 100)
            printEasterRelatedHolidays(y);
 
        .out.println(""Christian holidays, related to Easter,""
                + strv);
        for (int y = 2010; y < 2021; y++)
            printEasterRelatedHolidays(y);
    }
 
    static void printEasterRelatedHolidays(int year) {
        final int a = year % 19;
        final int b = year / 100;
        final int c = year % 100;
        final int d = b / 4;
        final int e = b % 4;
        final int f = (b + 8) / 25;
        final int g = (b - f + 1) / 3;
        final int h = (19 * a + b - d - g + 15) % 30;
        final int i = c / 4;
        final int k = c % 4;
        final int l = (32 + 2 * e + 2 * i - h - k) % 7;
        final int m = (a + 11 * h + 22 * l) / 451;
        final int n = h + l - 7 * m + 114;
        final int month = n / 31 - 1;
        final int day = (n % 31) + 1;
 
         date = new (year, month, day);
        [] months = new (.US).getShortMonths();
 
        .out.printf(strv, year);
        for ( hd : holidayOffsets.keySet()) {
            date.add(.DATE, holidayOffsets.get(hd));
            .out.printf(strv, hd,
                    date.get(.DAY_OF_MONTH),
                    months[date.get(.MONTH)]);
        }
        .out.println();
    }
}"
"import java.util.*;
 
class Hofstadter
{
  private static List<Integer> getSequence(int rlistSize, int slistSize)
  {
    List<Integer> rlist = new ArrayList<Integer>();
    List<Integer> slist = new ArrayList<Integer>();
    .addAll(rlist, 1, 3, 7);
    .addAll(slist, 2, 4, 5, 6);
    List<Integer> list = (rlistSize > 0) ? rlist : slist;
    int targetSize = (rlistSize > 0) ? rlistSize : slistSize;
    while (list.size() > targetSize)
      list.remove(list.size() - 1);
    while (list.size() < targetSize)
    {
      int lastIndex = rlist.size() - 1;
      int lastr = rlist.get(lastIndex).intValue();
      int r = lastr + slist.get(lastIndex).intValue();
      rlist.add(.valueOf(r));
      for (int s = lastr + 1; (s < r) && (list.size() < targetSize); s++)
        slist.add(.valueOf(s));
    }
    return list;
  }
 
  public static int ffr(int n)
  {  return getSequence(n, 0).get(n - 1).intValue();  }
 
  public static int ffs(int n)
  {  return getSequence(0, n).get(n - 1).intValue();  }
 
  public static void main([] args)
  {
    .out.print(strv);
    for (int n = 1; n <= 10; n++)
      .out.print(strv + ffr(n));
    .out.println();
 
    Set<Integer> first40R = new HashSet<Integer>();
    for (int n = 1; n <= 40; n++)
      first40R.add(.valueOf(ffr(n)));
 
    Set<Integer> first960S = new HashSet<Integer>();
    for (int n = 1; n <= 960; n++)
      first960S.add(.valueOf(ffs(n)));
 
    for (int i = 1; i <= 1000; i++)
    {
       n = .valueOf(i);
      if (first40R.contains(n) == first960S.contains(n))
        .out.println(strv + i + strv);
    }
    .out.println(strv);
  }
}"
"public class NewClass {
 
   public NewClass() {
       first(new AnEventOrCallback() {
           public void call() {
               second();
           }
       });
   }
 
   public void first(AnEventOrCallback obj) {
       obj.call();
   }
 
   public void second() {
       .out.println(strv);
   }
 
   public static void main([] args) {
       new NewClass();
   }
}
 
interface AnEventOrCallback {
   public void call();
}public class ListenerTest {
   public static void main([] args) {   
      testButton = new (strv);
     testButton.addActionListener(new (){
     @Override public void actionPerformed( ae){
         .out.println(strv);
       }
     });
 
     testButton.addActionListener(e -> .out.println(strv));
 
     

      frame = new (strv);
     frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
     frame.add(testButton, .CENTER);
     frame.pack();
     frame.setVisible(true);     
   }
}"
"import java.io.IOException;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
 
public class HelloWorld{
  public static void main([] args) throws {
     listener = new (8080);
    while(true){
       sock = listener.accept();
      new (sock.getOutputStream(), true).
                println(strv);
      sock.close();
    }
  }
}"
"import java.util.ArrayList;
 
public class Heron {
    public static void main([] args) {
        ArrayList<int[]> list = new ArrayList<>();
 
        for (int c = 1; c <= 200; c++) {
            for (int b = 1; b <= c; b++) {
                for (int a = 1; a <= b; a++) {
 
                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){
                        int area = (int) heronArea(a, b, c);
                        list.add(new int[]{a, b, c, a + b + c, area});
                    }
                }
            }
        }
        sort(list);
 
        .out.printf(strv
                + ""to 200: %dFirst ten when ordered by increasing area, then""
                + "" perimeter:Sides       Perimeter   Area"", list.size());
 
        for (int i = 0; i < 10; i++) {
            .out.printf(""%d x %d x %d   %d      %d"",
                    list.get(i)[0], list.get(i)[1], list.get(i)[2],
                    list.get(i)[3], list.get(i)[4]);
        }
 
        .out.printf(""Area = 210Sides        Perimeter   Area"");
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i)[4] == 210)
                .out.printf(""%d x %d x %d   %d      %d"",
                        list.get(i)[0], list.get(i)[1], list.get(i)[2],
                        list.get(i)[3], list.get(i)[4]);
        }
    }
 
    public static double heronArea(int a, int b, int c) {
        double s = (a + b + c) / 2f;
        return .sqrt(s * (s - a) * (s - b) * (s - c));
    }
 
    public static boolean isHeron(double h) {
        return h % 1 == 0 && h > 0;
    }
 
    public static int gcd(int a, int b) {
        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;
        while (leftover != 0) {
            leftover = dividend % divisor;
            if (leftover > 0) {
                dividend = divisor;
                divisor = leftover;
            }
        }
        return divisor;
    }
 
    public static void sort(ArrayList<int[]> list) {
        boolean swapped = true;
        int[] temp;
        while (swapped) {
            swapped = false;
            for (int i = 1; i < list.size(); i++) {
                if (list.get(i)[4] < list.get(i - 1)[4] ||
                        list.get(i)[4] == list.get(i - 1)[4] &&
                        list.get(i)[3] < list.get(i - 1)[3]) {
                    temp = list.get(i);
                    list.set(i, list.get(i - 1));
                    list.set(i - 1, temp);
                    swapped = true;
                }
            }
        }
    }
}"
"public class HelloWorld
{
 public static void main([] args)
 {
  .out.print(strv);
 }
}"
"public class Err{
   public static void main([] args){
      .err.println(strv);
   }
}"
"import java.io.FileWriter;
import java.io.IOException;
 
public class LinePrinter {
  public static void main([] args) {
    try {
       lp0 = new (strv);
      lp0.write(strv);
      lp0.close();
    } catch ( ioe) {
      ioe.printStackTrace();
    }
  }
}"
"public class HelloWorld
{
 public static void main([] args)
 {
  .out.println(strv);
 }
}"
"import javax.swing.*;
import java.awt.*;
 
public class OutputSwing {
 
    public static void main([] args) {
 
        .invokeLater(new (){
            public void run() {
                .showMessageDialog (null, strv); 

                 frame = new (strv);            

                 text = new (strv);       

                 button = new (strv);         

 
                frame.setLayout(new ());
                frame.add(button);
                frame.add(text);
                frame.pack();
                frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
                frame.setVisible(true);
            }
        });
    }
}import javax.swing.*;
import java.awt.*;
 
public class HelloWorld {
    public static void main([] args) {
 
        .invokeLater(() -> {
            .showMessageDialog(null, strv);
             frame = new (strv);
             text = new (strv);
             button = new (strv);
 
            frame.setLayout(new ());
            frame.add(button);
            frame.add(text);
            frame.pack();
            frame.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            frame.setVisible(true);
        });
    }
}"
"public class Haversine {
    public static final double R = 6372.8; 

    public static double haversine(double lat1, double lon1, double lat2, double lon2) {
        double dLat = .toRadians(lat2 - lat1);
        double dLon = .toRadians(lon2 - lon1);
        lat1 = .toRadians(lat1);
        lat2 = .toRadians(lat2);
 
        double a = .pow(.sin(dLat / 2),2) + .pow(.sin(dLon / 2),2) * .cos(lat1) * .cos(lat2);
        double c = 2 * .asin(.sqrt(a));
        return R * c;
    }
    public static void main([] args) {
        .out.println(haversine(36.12, -86.67, 33.94, -118.40));
    }
}"
"import sun.misc.Signal;
import sun.misc.SignalHandler;
 
public class ExampleSignalHandler {
    public static void main(... args) throws  {
        final long start = .nanoTime();
        Signal.handle(new Signal(strv), new SignalHandler() {
            public void handle(Signal sig) {
                .out.format(""Program execution took %f seconds"", (.nanoTime() - start) / 1e9f);
                .exit(0);
            }
        });
        int counter = 0;
        while(true) {
            .out.println(counter++);
            .sleep(500);
        }
    }
}
 public class ExampleSignalHandler {
    public static void main(... args) throws  {
        final long start = .nanoTime();
        .getRuntime().addShutdownHook(new (new () {
            public void run() {
                .out.format(""Program execution took %f seconds"", (.nanoTime() - start) / 1e9f);
            }
        }));
        int counter = 0;
        while(true) {
            .out.println(counter++);
            .sleep(500);
        }
    }
}
 "
"import java.util.HashMap;
public static void main([] args){
	[] keys= {strv, strv, strv};
	int[] vals= {1, 2, 3};
	HashMap<, Integer> hash= new HashMap<, Integer>();
 
	for(int i= 0; i < keys.length; i++){
	   hash.put(keys[i], vals[i]);
	}
}"
" 
 
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
 
public class HappyNumbers {
 
 
    public static void main([] args) {
 
        for (int current = 1, total = 0; total < 8; current++)
            if (isHappy(current)) {
                .out.println(current);
                total++;
            }
    }
 
 
    public static boolean isHappy(int number) {
        HashSet<Integer> cycle = new HashSet<>();
        while (number != 1 && cycle.add(number)) {
            List<String> numStrList = .asList(.valueOf(number).split(strv));
            number = numStrList.stream().map(i -> .pow(.parseInt(i), 2)).mapToInt(i -> i.intValue()).sum();
        }
        return number == 1;
    }
}"
"import java.util.*;
 
public class HashJoin {
 
    public static void main([] args) {
        [][] table1 = {{strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}};
 
        [][] table2 = {{strv, strv}, {strv, strv},
        {strv, strv}, {strv, strv}, {strv, strv},
        {strv, strv}};
 
        hashJoin(table1, 1, table2, 0).stream()
                .forEach(r -> .out.println(.deepToString(r)));
    }
 
    static List<[][]> hashJoin([][] records1, int idx1,
            [][] records2, int idx2) {
 
        List<[][]> result = new ArrayList<>();
        Map<, List<[]>> map = new HashMap<>();
 
        for ([] record : records1) {
            List<[]> v = map.getOrDefault(record[idx1], new ArrayList<>());
            v.add(record);
            map.put(record[idx1], v);
        }
 
        for ([] record : records2) {
            List<[]> lst = map.get(record[idx2]);
            if (lst != null) {
                lst.stream().forEach(r -> {
                    result.add(new [][]{r, record});
                });
            }
        }
 
        return result;
    }
}"
" 
import java.math.BigInteger;
 
public class Hamming
{
    public static void main( args[])
    {
        Stream hamming = makeHamming();
        .out.print(strv);
        for (int i=0; i<20; i++) {
            .out.print(hamming.value());
            .out.print(strv);
            hamming = hamming.advance();
        }
        .out.println();
 
        .out.print(strv);
        hamming = makeHamming();
        for (int i=1; i<1691; i++) {
            hamming = hamming.advance();
        }
        .out.println(hamming.value());
 
        hamming = makeHamming();
        .out.print(strv);
        for (int i=1; i<1000000; i++) {
            hamming = hamming.advance();
        }
        .out.println(hamming.value());
    }
 
    public interface Stream
    {
         value();
        Stream advance();
    }
 
    public static class MultStream implements Stream
    {
        MultStream(int mult)
        { m_mult = .valueOf(mult); }
        MultStream setBase(Stream s)
        { m_base = s; return this; }
        public  value()
        { return m_mult.multiply(m_base.value()); }
        public Stream advance()
        { return setBase(m_base.advance()); }
 
        private final  m_mult;
        private Stream m_base;
    }
 
    private final static class RegularStream implements Stream
    {
        RegularStream(Stream[] streams,  val)
        {
            m_streams = streams;
            m_val = val;
        }
        public  value()
        { return m_val; }
 
        public Stream advance()
        {
            

            if (m_advance != null) { return m_advance; }
 
            int minidx = 0 ;
             next = nextStreamValue(0);
            for (int i=1; i<m_streams.length; i++) {
                 v = nextStreamValue(i);
                if (v.compareTo(next) < 0) {
                    next = v;
                    minidx = i;
                }
            }
            RegularStream ret = new RegularStream(m_streams, next);
            

            m_advance = ret;
            m_streams[minidx].advance();
            return ret;
        }
        private  nextStreamValue(int streamidx)
        {
            

             ret = m_streams[streamidx].value();
            while (ret.equals(m_val)) {
                m_streams[streamidx] = m_streams[streamidx].advance();
                ret = m_streams[streamidx].value();
            }
            return ret;
        }
        private final Stream[] m_streams;
        private final  m_val;
        private RegularStream m_advance = null;
    }
 
    private final static Stream makeHamming()
    {
        MultStream nums[] = new MultStream[] {
            new MultStream(2),
            new MultStream(3),
            new MultStream(5)
        };
        Stream ret = new RegularStream(nums, .ONE);
        for (int i=0; i<nums.length; i++) {
            nums[i].setBase(ret);
        }
        return ret;
    }
}
 "
"import java.awt.*;
import javax.swing.JFrame;
 
public class Test extends  {
 
    public static void main([] args) {
        new Test();
    }
 
    Test() {
         toolkit = .getDefaultToolkit();
 
         screenSize = toolkit.getScreenSize();
        .out.println(strv + screenSize);
 
         insets = toolkit.getScreenInsets(getGraphicsConfiguration());
        .out.println(strv + insets);
 
        screenSize.width -= (insets.left + insets.right);
        screenSize.height -= (insets.top + insets.bottom);
        .out.println(strv + screenSize);
    }
}"
"import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
 
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
 
public class Interact extends {
	final  numberField;
	final  incButton, decButton;
 
	public Interact(){
		//stop the GUI threads when the user hits the X button
		setDefaultCloseOperation(.EXIT_ON_CLOSE); 
 
		numberField = new ();
		incButton = new (strv);
		decButton = new (strv);
 
		numberField.setText(strv);//start at 0
		decButton.setEnabled(false);//we're already at 0
 
		//listen for button presses in the text field
		numberField.addKeyListener(new (){
			@Override
			public void keyTyped( e) {
				//if the entered character is not a digit
				if(!.isDigit(e.getKeyChar())){
					//eat the event (i.e. stop it from being processed)
					e.consume();
				}else if(.isDigit(e.getKeyChar())){
					//This method is executed from the event thread and updating the GUI
					//from there doesn't always work. invokeLater will ensure that the
					//GUI is updated
					.invokeLater(new () {
						@Override
						public void run() {
							 text = numberField.getText();
							if(text.isEmpty()){//default to 0 when all text is erased
								numberField.setText(strv);
								decButton.setEnabled(false);
								incButton.setEnabled(true);
								return;
							}
							if(.valueOf(text) <= 0){
								decButton.setEnabled(false);
								incButton.setEnabled(true);
							}else if(.valueOf(text) >= 10){
								incButton.setEnabled(false);
								decButton.setEnabled(true);
							}else{
								incButton.setEnabled(true);
								decButton.setEnabled(true);
							}
						}
					});
				}
			}
			@Override
			public void keyReleased( e){}
			@Override
			public void keyPressed( e){
				//backspace and delete don't register in keyTyped because they don't
				//display a Unicode character, so they must be handled here
				if(e.getKeyCode() == .VK_BACK_SPACE ||
						e.getKeyCode() == .VK_DELETE){
					.invokeLater(new () {
						@Override
						public void run() {
							 text = numberField.getText();
							if(text.isEmpty()){
								numberField.setText(strv);
								decButton.setEnabled(false);
								incButton.setEnabled(true);
								return;
							}
							if(.valueOf(text) <= 0){
								decButton.setEnabled(false);
								incButton.setEnabled(true);
							}else if(.valueOf(text) >= 10){
								incButton.setEnabled(false);
								decButton.setEnabled(true);
							}else{
								incButton.setEnabled(true);
								decButton.setEnabled(true);
							}
						}
					});
				}
			}
		});
 
		//listen for button clicks on the increment button
		incButton.addActionListener(new (){
			@Override
			public void actionPerformed( e) {
				 text = numberField.getText();
				numberField.setText((.valueOf(text) + 1) + strv);
				if(.valueOf(text) + 1 >= 10){
					incButton.setEnabled(false);
				}
 
				if(.valueOf(text) + 1 > 0){
					decButton.setEnabled(true);
				}
			}
		});
 
		//listen for button clicks on the random button
		decButton.addActionListener(new (){
			@Override
			public void actionPerformed( e) {
				 text = numberField.getText();
				numberField.setText((.valueOf(text) - 1) + strv);
				if(.valueOf(text) - 1 <= 0){
					decButton.setEnabled(false);
				}
 
				if(.valueOf(text) - 1 < 10){
					incButton.setEnabled(true);
				}
			}
		});
 
		//arrange the components in a grid with 2 rows and 1 column
		setLayout(new (2, 1));
 
		//a secondary panel for arranging both buttons in one grid space in the window
		 buttonPanel = new ();
 
		//the buttons are in a grid with 1 row and 2 columns
		buttonPanel.setLayout(new (1, 2));
		//add the buttons
		buttonPanel.add(incButton);
		buttonPanel.add(decButton);
 
		//put the number field on top of the buttons
		add(numberField);
		add(buttonPanel);
		//size the window appropriately
		pack();
 
	}
 
	public static void main([] args){
		new Interact().setVisible(true);
	}
} 
import javafx.application.Application;
import javafx.beans.property.LongProperty;
import javafx.beans.property.SimpleLongProperty;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.util.converter.NumberStringConverter;
 
public class InteractFX extends Application {
 
    public static void main([] args) {
        launch(args);
    }
 
    @Override
    public void start(Stage stage) throws  {
 
         input = new (strv){
            

            @Override public void replaceText(int start, int end,  text) {
                if (text.matches(strv)) {
                    super.replaceText(start, end, text);
                }
            }
 
            

            @Override public void replaceSelection( text) {
                if (text.matches(strv)) {
                    super.replaceSelection(text);
                }
            }
        };
 
        

        input.textProperty().addListener((observable, oldValue, newValue)->{
            if(newValue == null || newValue.trim().isEmpty()){
                input.setText(strv);
            }
        });
 
 
        

        LongProperty inputValue = new SimpleLongProperty();
        input.textProperty().bindBidirectional(inputValue, new NumberStringConverter());
 
        

        input.disableProperty().bind(inputValue.isNotEqualTo(0));
 
 
         increment = new (strv);
        increment.setOnAction(event-> inputValue.set(inputValue.get() + 1));
 
        

        increment.disableProperty().bind(inputValue.greaterThanOrEqualTo(10));
 
 
         decrement = new (strv);
        decrement.setOnAction(event-> inputValue.set(inputValue.get() - 1));
 
        

        decrement.disableProperty().bind(inputValue.lessThanOrEqualTo(0));
 
 
        

        VBox root = new VBox();
        root.getChildren().add(input);
        HBox buttons = new HBox();
        buttons.getChildren().addAll(increment,decrement);
        root.getChildren().add(buttons);
 
        stage.setScene(new Scene(root));
        stage.sizeToScene();
        stage.show();
    }
}
 "
"import java.util.Random;
import java.util.Scanner;
public class Main
{
    public static void main([] args)
    {
        Scanner scan = new Scanner(.in);
         random = new ();
        long from = 1;
        long to = 100;
        int randomNumber = random.nextInt(to - from + 1) + from;
        int guessedNumber = 0;
 
        .out.printf(""The number is between %d and %d."", from, to);
 
        do
        {
            .out.print(strv);
            guessedNumber = scan.nextInt();
            if (guessedNumber > randomNumber)
                .out.println(strv);
            else if (guessedNumber < randomNumber)
                .out.println(strv);
            else
                .out.println(strv);
        } while (guessedNumber != randomNumber);
    }
}"
"import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
 
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
 
public class Interact extends {
	final  numberField;
	final  incButton, randButton;
 
	public Interact(){
		//stop the GUI threads when the user hits the X button
		setDefaultCloseOperation(.EXIT_ON_CLOSE); 
 
		numberField = new ();
		incButton = new (strv);
		randButton = new (strv);
 
		numberField.setText(strv);//start at 0
 
		//listen for button presses in the text field
		numberField.addKeyListener(new (){
			@Override
			public void keyTyped( e) {
				//if the entered character is not a digit
				if(!.isDigit(e.getKeyChar())){
					//eat the event (i.e. stop it from being processed)
					e.consume();
				}
			}
			@Override
			public void keyReleased( e){}
			@Override
			public void keyPressed( e){}
		});
 
		//listen for button clicks on the increment button
		incButton.addActionListener(new (){
			@Override
			public void actionPerformed( e) {
				 text = numberField.getText();
				if(text.isEmpty()){
					numberField.setText(strv);
				}else{
					numberField.setText((.valueOf(text) + 1) + strv);
				}
			}
		});
 
		//listen for button clicks on the random button
		randButton.addActionListener(new (){
			@Override
			public void actionPerformed( e) {
				//show a dialog and if they answer strv
				if(.showConfirmDialog(null, strv) ==
					.YES_OPTION){
					//set the text field text to a random positive long
					numberField.setText(.toString((long)(.random() 
							* .MAX_VALUE)));
				}
			}
		});
 
		//arrange the components in a grid with 2 rows and 1 column
		setLayout(new (2, 1));
 
		//a secondary panel for arranging both buttons in one grid space in the window
		 buttonPanel = new ();
 
		//the buttons are in a grid with 1 row and 2 columns
		buttonPanel.setLayout(new (1, 2));
		//add the buttons
		buttonPanel.add(incButton);
		buttonPanel.add(randButton);
 
		//put the number field on top of the buttons
		add(numberField);
		add(buttonPanel);
		//size the window appropriately
		pack();
 
	}
 
	public static void main([] args){
		new Interact().setVisible(true);
	}
}"
"import javax.swing.* ;
import java.awt.* ;
 
public class Greybars extends  {
   private int width ;
   private int height ;
 
   public Greybars( )  {
      super( strv ) ;
      width = 640 ;
      height = 320 ;
      setSize( width , height ) ;
      setDefaultCloseOperation( .EXIT_ON_CLOSE ) ;
      setVisible( true ) ;
    }
 
    public void paint (  g ) {
      int run = 0 ;
      double colorcomp = 0.0 ; //component of the color
      for ( int columncount = 8 ; columncount < 128 ; columncount *= 2 ) {
	 double colorgap = 255.0 / (columncount - 1) ; //by this gap we change the background color
	 int columnwidth = width / columncount ;
	 int columnheight = height / 4 ;
	 if ( run % 2 == 0 ) //switches color directions with every for loop
	    colorcomp = 0.0 ;
	 else {
	    colorcomp = 255.0 ;
	    colorgap *= -1.0 ;
	 }
	 int ystart = 0 + columnheight * run ;
	 int xstart = 0 ;
	 for ( int i = 0 ; i < columncount ; i++ ) {
            int icolor = (int).round(colorcomp) ; //round to nearer integer
	     nextColor = new ( icolor , icolor, icolor ) ;
	    g.setColor( nextColor ) ;
	    g.fillRect( xstart , ystart , columnwidth , columnheight ) ;
	    xstart += columnwidth ;
	    colorcomp += colorgap ;
	 }
	 run++ ;
      }
    }
 
    public static void main( [ ] args ) {
       Greybars gb = new Greybars( ) ;
    }
}"
"import java.util.Scanner;
import java.util.ArrayList;
 
public class Sub{
    private static int[] indices;
 
    public static void main([] args){
        ArrayList<Long> array= new ArrayList<Long>(); //the main set
        Scanner in = new Scanner(.in);
        while(in.hasNextLong()) array.add(in.nextLong());
        long highSum= .MIN_VALUE;//start the sum at the lowest possible value
        ArrayList<Long> highSet= new ArrayList<Long>();
        //loop through all possible subarray sizes including 0
        for(int subSize= 0;subSize<= array.size();subSize++){
            indices= new int[subSize];
            for(int i= 0;i< subSize;i++) indices[i]= i;
            do{
                long sum= 0;//this subarray sum variable
                ArrayList<Long> temp= new ArrayList<Long>();//this subarray
                //sum it and save it
                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}
                if(sum > highSum){//if we found a higher sum
                    highSet= temp;    //keep track of it
                    highSum= sum;
                }
            }while(nextIndices(array));//while we haven't tested all subarrays
        }
        .out.println(strv + highSum + ""Set: "" + 
        		highSet);
    }
    /**     * Computes the next set of choices from the previous. The     * algorithm tries to increment the index of the final choice     * first. Should that fail (index goes out of bounds), it     * tries to increment the next-to-the-last index, and resets     * the last index to one more than the next-to-the-last.     * Should this fail the algorithm keeps starting at an earlier     * choice until it runs off the start of the choice list without     * Finding a legal set of indices for all the choices.     *     * @return true unless all choice sets have been exhausted.     * @author James Heliotis     */
 
    private static boolean nextIndices(ArrayList<Long> a) {
        for(int i= indices.length-1;i >= 0;--i){
            indices[i]++;
            for(int j=i+1;j < indices.length;++j){
                indices[j]= indices[j - 1] + 1;//reset the last failed try
            }
            if(indices[indices.length - 1] < a.size()){//if this try went out of bounds
                return true;
            }
        }
        return false;
    }
}private static int BiggestSubsum(int[] t) {
    int sum = 0;
    int maxsum = 0;
 
    for (int i : t) {
        sum += i;
        if (sum < 0)
            sum = 0;
        maxsum = sum > maxsum ? sum : maxsum;
    }        
    return maxsum;
}"
"void convertToGrayscale(final  image){
    for(int i=0; i<image.getWidth(); i++){
        for(int j=0; j<image.getHeight(); j++){
            int color = image.getRGB(i,j);
 
            int alpha = (color >> 24) & 255;
            int red = (color >> 16) & 255;
            int green = (color >> 8) & 255;
            int blue = (color) & 255;
 
            final int lum = (int)(0.2126 * red + 0.7152 * green + 0.0722 * blue);
 
            alpha = (alpha << 24);
            red = (lum << 16);
            green = (lum << 8);
            blue = lum;
 
            color = alpha + red + green + blue;
 
            image.setRGB(i,j,color);
        }
    }
}
 "
"public static float max(float[] values) throws  {
    if (values.length == 0)
        throw new ();
    float themax = values[0];
    for (int idx = 1; idx < values.length; ++idx) {
        if (values[idx] > themax)
            themax = values[idx];
    }
    return themax;
}public static float max(float[] values) throws  {
    if (values.length == 0)
        throw new ();
    .sort(values);//sorts the values in ascending order
    return values[values.length-1];
}import java.util.List;
import java.util.Collections;
import java.util.Arrays;
 
public static <T extends Comparable<? super T>> T max(List<T> values) {
    return .max(values);
}
 
public static <T extends Comparable<? super T>> T max(T[] values) {
    return .max(.asList(values));
}"
"public static long gcd(long a, long b){
   long factor= .min(a, b);
   for(long loop= factor;loop > 1;loop--){
      if(a % loop == 0 && b % loop == 0){
         return loop;
      }
   }
   return 1;
} 
public static int gcd(int a, int b) //valid for positive integers.
{
	while(b > 0)
	{
		int c = a % b;
		a = b;
		b = c;
	}
	return a;
}
  
static int gcd(int a,int b)
	{
		int min=a>b?b:a,max=a+b-min, div=min;
		for(int i=1;i<min;div=min/++i)
			if(min%div==0&&max%div==0)
				return div;
		return 1;
	}
 public static long gcd(long u, long v){
  long t, k;
 
  if (v == 0) return u;
 
  u = .abs(u);
  v = .abs(v); 
  if (u < v){
    t = u;
    u = v;
    v = t;
  }
 
  for(k = 1; (u & 1) == 0 && (v & 1) == 0; k <<= 1){
    u >>= 1; v >>= 1;
  }
 
  t = (u & 1) != 0 ? -v : u;
  while (t != 0){
    while ((t & 1) == 0) t >>= 1;
 
    if (t > 0)
      u = t;
    else
      v = -t;
 
    t = u - v;
  }
  return u * k;
}public static long gcd(long a, long b){
   if(a == 0) return b;
   if(b == 0) return a;
   if(a > b) return gcd(b, a % b);
   return gcd(a, b % a);
}import java.math.BigInteger;
 
public static long gcd(long a, long b){
   return .valueOf(a).gcd(.valueOf(b)).longValue();
}"
" 
public class Gray {
	public static long grayEncode(long n){
		return n ^ (n >>> 1);
	}
 
	public static long grayDecode(long n) {
		long p = n;
		while ((n >>>= 1) != 0)
			p ^= n;
		return p;
	}
	public static void main([] args){
		.out.println(""iBinaryGrayDecoded"");
		for(int i = -1; i < 32;i++){
			.out.print(i +"""");
			.out.print(.toBinaryString(i) + """");
			.out.print(.toBinaryString(grayEncode(i))+ """");
			.out.println(grayDecode(grayEncode(i)));
		}
	}
}
 public static long grayEncode(long n){
	long result = 0;
	for(int exp = 0; n > 0; n /= 2, exp++){
		long nextHighestBit = (n >> 1) & 1;
		if(nextHighestBit == 1){
			result += ((n & 1) == 0) ? (1 << exp) : 0; //flip the bit
		}else{
			result += (n & 1) * (1 << exp); //strv, don't flip it
		}
	}
	return result;
}public static  grayDecode( n){
	 nBits = n.toString(2);
	 result = nBits.substring(0, 1);
	for(int i = 1; i < nBits.length(); i++){
		//bin[i] = gray[i] ^ bin[i-1]
 
		//XOR with characters 
		result += nBits.charAt(i) != result.charAt(i - 1) ? strv : strv;
	}
	return new (result, 2);
}"
"class Pair<T> {
    T first;
    T second;
}
public static <T> void swap(Pair<T> p) {
   T temp = p.first;
   p.first = p.second;
   p.second = temp;
}"
"import java.io.*;
import java.nio.file.*;
 
public class GloballyReplaceText {
 
    public static void main([] args) throws  {
 
        for ( fn : new []{strv, strv}) {
             s = new (Files.readAllBytes(Paths.get(fn)));
            s = s.replace(strv, strv);
            try ( fw = new (fn)) {
                fw.write(s);
            }
        }
    }
}"
"import java.io.*;
import java.util.*;
 
public class SystemCommand {
 
    public static void main( args[]) throws  {
 
         command = strv;
         p = .getRuntime().exec(command);
 
        try (Scanner sc = new Scanner(p.getInputStream())) {
 
            .out.printf(strv, command);
            while (sc.hasNext()) {
                .out.println(sc.nextLine());
            }
        }
    }
}"
"import static java.lang..abs;
import java.util.Random;
 
public class Fen {
    static  rand = new ();
 
    public static void main([] args) {
        .out.println(createFen());
    }
 
    static  createFen() {
        char[][] grid = new char[8][8];
 
        placeKings(grid);
        placePieces(grid, strv, true);
        placePieces(grid, strv, true);
        placePieces(grid, strv, false);
        placePieces(grid, strv, false);
 
        return toFen(grid);
    }
 
    static void placeKings(char[][] grid) {
        int r1, c1, r2, c2;
        while (true) {
            r1 = rand.nextInt(8);
            c1 = rand.nextInt(8);
            r2 = rand.nextInt(8);
            c2 = rand.nextInt(8);
            if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1)
                break;
        }
        grid[r1][c1] = 'K';
        grid[r2][c2] = 'k';
    }
 
    static void placePieces(char[][] grid,  pieces, boolean isPawn) {
        int numToPlace = rand.nextInt(pieces.length());
        for (int n = 0; n < numToPlace; n++) {
            int r, c;
            do {
                r = rand.nextInt(8);
                c = rand.nextInt(8);
 
            } while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));
 
            grid[r][c] = pieces.charAt(n);
        }
    }
 
    static  toFen(char[][] grid) {
        StringBuilder fen = new StringBuilder();
        int countEmpty = 0;
        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                char ch = grid[r][c];
                .out.printf(strv, ch == 0 ? '.' : ch);
                if (ch == 0) {
                    countEmpty++;
                } else {
                    if (countEmpty > 0) {
                        fen.append(countEmpty);
                        countEmpty = 0;
                    }
                    fen.append(ch);
                }
            }
            if (countEmpty > 0) {
                fen.append(countEmpty);
                countEmpty = 0;
            }
            fen.append(strv);
            .out.println();
        }
        return fen.append(strv).toString();
    }
}"
"import java.util.function.LongSupplier;
import static java.util.stream.LongStream.generate;
 
public class GeneratorExponential implements LongSupplier {
    private LongSupplier source, filter;
    private long s, f;
 
    public GeneratorExponential(LongSupplier source, LongSupplier filter) {
        this.source = source;
        this.filter = filter;
        f = filter.getAsLong();
    }
 
    @Override
    public long getAsLong() {
        s = source.getAsLong();
 
        while (s == f) {
            s = source.getAsLong();
            f = filter.getAsLong();
        }
 
        while (s > f) {
            f = filter.getAsLong();
        }
 
        return s;
    }
 
    public static void main([] args) {
        generate(new GeneratorExponential(new SquaresGen(), new CubesGen()))
                .skip(20).limit(10)
                .forEach(n -> .out.printf(strv, n));
    }
}
 
class SquaresGen implements LongSupplier {
    private long n;
 
    @Override
    public long getAsLong() {
        return n * n++;
    }
}
 
class CubesGen implements LongSupplier {
    private long n;
 
    @Override
    public long getAsLong() {
        return n * n * n++;
    }
}"
"public class FizzBuzz {
 
    public static void main([] args) {
        Sound[] sounds = {new Sound(3, strv), new Sound(5, strv),  new Sound(7, strv)};
        for (int i = 1; i <= 20; i++) {
            StringBuilder sb = new StringBuilder();
            for (Sound sound : sounds) {
                sb.append(sound.generate(i));
            }
            .out.println(sb.length() == 0 ? i : sb.toString());
        }
    }
 
    private static class Sound {
        private final int trigger;
        private final  onomatopoeia;
 
        public Sound(int trigger,  onomatopoeia) {
            this.trigger = trigger;
            this.onomatopoeia = onomatopoeia;
        }
 
        public  generate(int i) {
            return i % trigger == 0 ? onomatopoeia : strv;
        }
 
    }
 
}"
"public class LowerAscii {
 
    public static void main([] args) {
        StringBuilder sb = new StringBuilder(26);
        for (char ch = 'a'; ch <= 'z'; ch++)
            sb.append(ch);
        .out.printf(strv, sb, sb.length());
    }
}"
"public class GammaFunction {
 
	public double st_gamma(double x){
		return .sqrt(2*.PI/x)*.pow((x/.E), x);
	}
 
	public double la_gamma(double x){
		double[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,
			     	  771.32342877765313, -176.61502916214059, 12.507343278686905,
			     	  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};
		int g = 7;
		if(x < 0.5) return .PI / (.sin(.PI * x)*la_gamma(1-x));
 
		x -= 1;
		double a = p[0];
		double t = x+g+0.5;
		for(int i = 1; i < p.length; i++){
			a += p[i]/(x+i);
		}
 
		return .sqrt(2*.PI)*.pow(t, x+0.5)*.exp(-t)*a;
	}
 
	public static void main([] args) {
		GammaFunction test = new GammaFunction();
		.out.println(""Gamma Stirling Lanczos"");
		for(double i = 1; i <= 20; i += 1){
			.out.println(strv + i/10.0 + """" + test.st_gamma(i/10.0) + """" + test.la_gamma(i/10.0));
		}
	}
}"
"import java.util.Random;
import java.util.List;
import java.util.ArrayList;
 
public class GaltonBox {
    public static void main( final [] args ) {
        new GaltonBox( 8, 200 ).run();
    }
 
    private final int        m_pinRows;
    private final int        m_startRow;
    private final [] m_balls;
    private final      m_random = new ();
 
    public GaltonBox( final int pinRows, final int ballCount ) {
        m_pinRows  = pinRows;
        m_startRow = pinRows + 1;
        m_balls    = new [ ballCount ];
 
        for ( int ball = 0; ball < ballCount; ball++ )
            m_balls[ ball ] = new ( m_startRow, 0, 'o' );
    }
 
    private static class  {
        int  m_row;
        int  m_col;
        char m_char;
 
        ( final int row, final int col, final char ch ) {
            m_row  = row;
            m_col  = col;
            m_char = ch;
        }
    }
 
    public void run() {
        for ( int ballsInPlay = m_balls.length; ballsInPlay > 0;  ) {
            ballsInPlay = dropBalls();
            print();
        }
    }
 
    private int dropBalls() {
        int ballsInPlay = 0;
        int ballToStart = -1;
 
        

        for ( int ball = 0; ball < m_balls.length; ball++ )
            if ( m_balls[ ball ].m_row == m_startRow )
                ballToStart = ball;
 
        

        for ( int ball = 0; ball < m_balls.length; ball++ )
            if ( ball == ballToStart ) {
                m_balls[ ball ].m_row = m_pinRows;
                ballsInPlay++;
            }
            else if ( m_balls[ ball ].m_row > 0 && m_balls[ ball ].m_row != m_startRow ) {
                m_balls[ ball ].m_row -= 1;
                m_balls[ ball ].m_col += m_random.nextInt( 2 );
                if ( 0 != m_balls[ ball ].m_row )
                    ballsInPlay++;
            }
 
        return ballsInPlay;
    }
 
    private void print() {
        for ( int row = m_startRow; row --> 1;  ) {
            for ( int ball = 0; ball < m_balls.length; ball++ )
                if ( m_balls[ ball ].m_row == row )
                    printBall( m_balls[ ball ] );
            .out.println();
            printPins( row );
        }
        printCollectors();
        .out.println();
    }
 
    private static void printBall( final  pos ) {
        for ( int col = pos.m_row + 1; col --> 0;  )
            .out.print( ' ' );
        for ( int col = 0; col < pos.m_col; col++ )
            .out.print( strv );
        .out.print( pos.m_char );
    }
 
    private void printPins( final int row ) {
        for ( int col = row + 1; col --> 0;  )
            .out.print( ' ' );
        for ( int col = m_startRow - row; col --> 0;  )
            .out.print( strv );
        .out.println();
    }
 
    private void printCollectors() {
        final List<List<Position>> collectors = new ArrayList<List<Position>>();
 
        for ( int col = 0; col < m_startRow; col++ ) {
            final List<Position> collector = new ArrayList<Position>();
 
            collectors.add( collector );
            for ( int ball = 0; ball < m_balls.length; ball++ )
                if ( m_balls[ ball ].m_row == 0 && m_balls[ ball ].m_col == col )
                    collector.add( m_balls[ ball ] );
        }
 
        for ( int row = 0, rows = longest( collectors ); row < rows; row++ ) {
            for ( int col = 0; col < m_startRow; col++ ) {
                final List<Position> collector = collectors.get( col );
                final int            pos       = row + collector.size() - rows;
 
                .out.print( '|' );
                if ( pos >= 0 )
                    .out.print( collector.get( pos ).m_char );
                else
                    .out.print( ' ' );
            }
            .out.println( '|' );
        }
    }
 
    private static final int longest( final List<List<Position>> collectors ) {
        int result = 0;
 
        for ( final List<Position> collector : collectors )
            result = .max( collector.size(), result );
 
        return result;
    }
}"
"public class Compose {
 
    

    

    public interface Fun<A,B> {
        B call(A x);
    }
 
    public static <A,B,C> Fun<A,C> compose(final Fun<B,C> f, final Fun<A,B> g) {
        return new Fun<A,C>() {
            public C call(A x) {
                return f.call(g.call(x));
            }
        };
    }
 
    public static void main([] args) {
        Fun<,Double> sin = new Fun<,Double>() {
            public  call( x) {
                return .sin(x);
            }
        };
        Fun<,Double> asin = new Fun<,Double>() {
            public  call( x) {
                return .asin(x);
            }
        };
 
        Fun<,Double> sin_asin = compose(sin, asin);
 
        .out.println(sin_asin.call(0.5)); 

    }
}import java.util.function.Function;
 
public class Compose {
    public static void main([] args) {
        Function<,Double> sin_asin = ((Function<,Double>)::sin).compose(::asin);
 
        .out.println(sin_asin.apply(0.5)); 

    }
}import java.util.function.Function;
 
public class Compose {
    public static <A,B,C> Function<A,C> compose(Function<B,C> f, Function<A,B> g) {
        return x -> f.apply(g.apply(x));
    }
 
    public static void main([] args) {
        Function<,Double> sin_asin = compose(::sin, ::asin);
 
        .out.println(sin_asin.apply(0.5)); 

    }
}"
"import java.awt.Point;
import java.util.*;
import static java.util..asList;
import java.util.function.Function;
import static java.util..comparing;
import static java.util.stream.Collectors.toList;
 
public class FreePolyominoesEnum {
    static final List<Function<, Point>> transforms = new ArrayList<>();
 
    static {
        transforms.add(p -> new (p.y, -p.x));
        transforms.add(p -> new (-p.x, -p.y));
        transforms.add(p -> new (-p.y, p.x));
        transforms.add(p -> new (-p.x, p.y));
        transforms.add(p -> new (-p.y, -p.x));
        transforms.add(p -> new (p.x, -p.y));
        transforms.add(p -> new (p.y, p.x));
    }
 
    static  findMinima(List<Point> poly) {
        return new (
                poly.stream().mapToInt(a -> a.x).min().getAsInt(),
                poly.stream().mapToInt(a -> a.y).min().getAsInt());
    }
 
    static List<Point> translateToOrigin(List<Point> poly) {
        final  min = findMinima(poly);
        poly.replaceAll(p -> new (p.x - min.x, p.y - min.y));
        return poly;
    }
 
    static List<List<Point>> rotationsAndReflections(List<Point> poly) {
        List<List<Point>> lst = new ArrayList<>();
        lst.add(poly);
        for (Function<, Point> t : transforms)
            lst.add(poly.stream().map(t).collect(toList()));
        return lst;
    }
 
    static Comparator<Point> byCoords = .<Point>comparingInt(p -> p.x)
            .thenComparingInt(p -> p.y);
 
    static List<Point> normalize(List<Point> poly) {
        return rotationsAndReflections(poly).stream()
                .map(lst -> translateToOrigin(lst))
                .map(lst -> lst.stream().sorted(byCoords).collect(toList()))
                .min(comparing(::toString)) 

                .get();
    }
 
    static List<Point> neighborhoods( p) {
        return asList(new (p.x - 1, p.y), new (p.x + 1, p.y),
                new (p.x, p.y - 1), new (p.x, p.y + 1));
    }
 
    static List<Point> concat(List<Point> lst,  pt) {
        List<Point> r = new ArrayList<>();
        r.addAll(lst);
        r.add(pt);
        return r;
    }
 
    static List<Point> newPoints(List<Point> poly) {
        return poly.stream()
                .flatMap(p -> neighborhoods(p).stream())
                .filter(p -> !poly.contains(p))
                .distinct()
                .collect(toList());
    }
 
    static List<List<Point>> constructNextRank(List<Point> poly) {
        return newPoints(poly).stream()
                .map(p -> normalize(concat(poly, p)))
                .distinct()
                .collect(toList());
    }
 
    static List<List<Point>> rank(int n) {
        if (n < 0)
            throw new (strv);
 
        if (n < 2) {
            List<List<Point>> r = new ArrayList<>();
            if (n == 1)
                r.add(asList(new (0, 0)));
            return r;
        }
 
        return rank(n - 1).stream()
                .parallel()
                .flatMap(lst -> constructNextRank(lst).stream())
                .distinct()
                .collect(toList());
    }
 
    public static void main([] args) {
        for (List<Point> poly : rank(5)) {
            for ( p : poly)
                .out.printf(strv, p.x, p.y);
            .out.println();
        }
    }
}"
"import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class Fractran{
 
   public static void main( []args){ 
 
       new Fractran(strv, 2);
   }
   final int limit = 15;
 
 
   Vector<Integer> num = new Vector<>(); 
   Vector<Integer> den = new Vector<>(); 
   public Fractran( prog,  val){
      compile(prog);
      dump();
      exec(2);
    }
 
 
   void compile( prog){
      Pattern regexp = Pattern.compile(""s*(d*)s*/s*(d*)s*(.*)"");
      Matcher matcher = regexp.matcher(prog);
      while(matcher.find()){
         num.add(.parseInt(matcher.group(1)));
         den.add(.parseInt(matcher.group(2)));
         matcher = regexp.matcher(matcher.group(3));
      }
   }
 
   void exec( val){
       int n = 0;
       while(val != null && n<limit){
           .out.println(n+strv+val);
           val = step(val);
           n++;
       }
   }
    step(int val){
       int i=0; 
       while(i<den.size() && val%den.get(i) != 0) i++;
       if(i<den.size())
           return num.get(i)*val/den.get(i);
       return null;
   }
 
   void dump(){
       for(int i=0; i<den.size(); i++)
           .out.print(num.get(i)+strv+den.get(i)+strv);
       .out.println();
   }
}"
"public class 
{
     public static    int multiply(   int a,    int b) { return a*b; }
     public static double multiply(double a, double b) { return a*b; }
}"
"import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JFrame;
 
public class FractalTree extends  {
 
    public FractalTree() {
        super(strv);
        setBounds(100, 100, 800, 600);
        setResizable(false);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
    }
 
    private void drawTree( g, int x1, int y1, double angle, int depth) {
        if (depth == 0) return;
        int x2 = x1 + (int) (.cos(.toRadians(angle)) * depth * 10.0);
        int y2 = y1 + (int) (.sin(.toRadians(angle)) * depth * 10.0);
        g.drawLine(x1, y1, x2, y2);
        drawTree(g, x2, y2, angle - 20, depth - 1);
        drawTree(g, x2, y2, angle + 20, depth - 1);
    }
 
    @Override
    public void paint( g) {
        g.setColor(.BLACK);
        drawTree(g, 400, 500, -90, 9);
    }
 
    public static void main([] args) {
        new FractalTree().setVisible(true);
    }
}"
"import java.util.Arrays;
public class FD {
    public static void main( args[]) {
        double[] a = {90, 47, 58, 29, 22, 32, 55, 5, 55, 73};
        .out.println(.toString(dif(a, 1)));
        .out.println(.toString(dif(a, 2)));
        .out.println(.toString(dif(a, 9)));
        .out.println(.toString(dif(a, 10)));      //let's test
        .out.println(.toString(dif(a, 11)));
        .out.println(.toString(dif(a, -1)));
        .out.println(.toString(dif(a, 0)));
    }
 
    public static double[] dif(double[] a, int n) {
        if (n < 0)
            return null; 

 
        for (int i = 0; i < n && a.length > 0; i++) {
            double[] b = new double[a.length - 1];
            for (int j = 0; j < b.length; j++){
                b[j] = a[j+1] - a[j];
            }
            a = b; //strv
        }
        return a;
    }
}"
"public class GateLogic
{
  

  public interface OneInputGate
  {  boolean eval(boolean input);  }
 
  public interface TwoInputGate
  {  boolean eval(boolean input1, boolean input2);  }
 
  public interface MultiGate
  {  boolean[] eval(boolean... inputs);  }
 
  

  public static OneInputGate NOT = new OneInputGate() {
    public boolean eval(boolean input)
    {  return !input;  }
  };
 
  

  public static TwoInputGate AND = new TwoInputGate() {
    public boolean eval(boolean input1, boolean input2)
    {  return input1 && input2;  }
  };
 
  

  public static TwoInputGate OR = new TwoInputGate() {
    public boolean eval(boolean input1, boolean input2)
    {  return input1 || input2;  }
  };
 
  

  public static TwoInputGate XOR = new TwoInputGate() {
    public boolean eval(boolean input1, boolean input2)
    {
      return OR.eval(
               AND.eval(input1, NOT.eval(input2)),
               AND.eval(NOT.eval(input1), input2)
             );
    }
  };
 
  

  public static MultiGate HALF_ADDER = new MultiGate() {
    public boolean[] eval(boolean... inputs)
    {
      if (inputs.length != 2)
        throw new ();
      return new boolean[] {
        XOR.eval(inputs[0], inputs[1]),  

        AND.eval(inputs[0], inputs[1])   

      };
    }
  };
 
  

  public static MultiGate FULL_ADDER = new MultiGate() {
    public boolean[] eval(boolean... inputs)
    {
      if (inputs.length != 3)
        throw new ();
      

      

      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);
      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);
      return new boolean[] {
        haOutputs2[0],                         

        OR.eval(haOutputs1[1], haOutputs2[1])  

      };
    }
  };
 
  public static MultiGate buildAdder(final int numBits)
  {
    return new MultiGate() {
      public boolean[] eval(boolean... inputs)
      {
        

        if (inputs.length != (numBits << 1))
          throw new ();
        boolean[] outputs = new boolean[numBits + 1];
        boolean[] faInputs = new boolean[3];
        boolean[] faOutputs = null;
        for (int i = 0; i < numBits; i++)
        {
          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  

          faInputs[1] = inputs[i];                                   

          faInputs[2] = inputs[numBits + i];                         

          faOutputs = FULL_ADDER.eval(faInputs);
          outputs[i] = faOutputs[0];                                 

        }
        if (faOutputs != null)
          outputs[numBits] = faOutputs[1];                           

        return outputs;
      }
    };
  }
 
  public static void main([] args)
  {
    int numBits = .parseInt(args[0]);
    int firstNum = .parseInt(args[1]);
    int secondNum = .parseInt(args[2]);
    int maxNum = 1 << numBits;
    if ((firstNum < 0) || (firstNum >= maxNum))
    {
      .out.println(strv);
      return;
    }
    if ((secondNum < 0) || (secondNum >= maxNum))
    {
      .out.println(strv);
      return;
    }
 
    MultiGate multiBitAdder = buildAdder(numBits);
    

    boolean[] inputs = new boolean[numBits << 1];
     firstNumDisplay = strv;
     secondNumDisplay = strv;
    for (int i = 0; i < numBits; i++)
    {
      boolean firstBit = ((firstNum >>> i) & 1) == 1;
      boolean secondBit = ((secondNum >>> i) & 1) == 1;
      inputs[i] = firstBit;
      inputs[numBits + i] = secondBit;
      firstNumDisplay = (firstBit ? strv : strv) + firstNumDisplay;
      secondNumDisplay = (secondBit ? strv : strv) + secondNumDisplay;
    }
 
    boolean[] outputs = multiBitAdder.eval(inputs);
    int outputNum = 0;
     outputNumDisplay = strv;
     outputCarryDisplay = null;
    for (int i = numBits; i >= 0; i--)
    {
      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);
      if (i == numBits)
        outputCarryDisplay = outputs[i] ? strv : strv;
      else
        outputNumDisplay += (outputs[i] ? strv : strv);
    }
    .out.println(strv + numBits);
    .out.println(strv + firstNumDisplay + strv + firstNum + strv + secondNumDisplay + strv + secondNum + strv + outputCarryDisplay + strv + outputNumDisplay + strv + outputNum + strv);
    return;
  }
 
}"
" 
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
 
public class RFork {
 
  public static void main([] args) {
    ProcessBuilder pb;
     pp;
    List<String> command;
    Map<, String> env;
     ir;
     currentuser;
     line;
    try {
      command = .asList(strv);
      pb = new ProcessBuilder(command);
      env = pb.environment();
      currentuser = env.get(strv);
      command = .asList(strv, strv, strv, currentuser);
      pb.command(command);
      pp = pb.start();
      ir = new (new (pp.getInputStream()));
      line = strv + command.toString() + strv;
      do {
        .out.println(line);
      } while ((line = ir.readLine()) != null);
    }
    catch ( iox) {
      iox.printStackTrace();
    }
 
    return;
  }
}
 "
"import static java.lang..format;
import java.util.Arrays;
 
public class FloydWarshall {
 
    public static void main([] args) {
        int[][] weights = {{1, 3, -2}, {2, 1, 4}, {2, 3, 3}, {3, 4, 2}, {4, 2, -1}};
        int numVertices = 4;
 
        floydWarshall(weights, numVertices);
    }
 
    static void floydWarshall(int[][] weights, int numVertices) {
 
        double[][] dist = new double[numVertices][numVertices];
        for (double[] row : dist)
            .fill(row, .POSITIVE_INFINITY);
 
        for (int[] w : weights)
            dist[w[0] - 1][w[1] - 1] = w[2];
 
        int[][] next = new int[numVertices][numVertices];
        for (int i = 0; i < next.length; i++) {
            for (int j = 0; j < next.length; j++)
                if (i != j)
                    next[i][j] = j + 1;
        }
 
        for (int k = 0; k < numVertices; k++)
            for (int i = 0; i < numVertices; i++)
                for (int j = 0; j < numVertices; j++)
                    if (dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                        next[i][j] = next[i][k];
                    }
 
        printResult(dist, next);
    }
 
    static void printResult(double[][] dist, int[][] next) {
        .out.println(strv);
        for (int i = 0; i < next.length; i++) {
            for (int j = 0; j < next.length; j++) {
                if (i != j) {
                    int u = i + 1;
                    int v = j + 1;
                     path = format(strv, u, v,
                            (int) dist[i][j], u);
                    do {
                        u = next[u - 1][v - 1];
                        path += strv + u;
                    } while (u != v);
                    .out.println(path);
                }
            }
        }
    }
}"
" 
public class Floyd {
	public static void main([] args){
		printTriangle(5);
		printTriangle(14);
	}
 
	private static void printTriangle(int n){
		.out.println(n + strv);
		for(int rowNum = 1, printMe = 1, numsPrinted = 0;
				rowNum <= n; printMe++){
			int cols = (int).ceil(.log10(n*(n-1)/2 + numsPrinted + 2));
			.out.printf(strv+cols+strv, printMe);
			if(++numsPrinted == rowNum){
				.out.println();
				rowNum++;
				numsPrinted = 0;
			}
		}
	}
}"
"switch (xx) {
  case 1:
  case 2:
    /* 1 & 2 both come here... */
    ...
    break;
  case 4:
    /* 4 comes here... */
    ...
    break;
  case 5:
    /* 5 comes here... */
    ...
    break;
  default:
    /* everything else */
    break;
}
 
for (int i = 0; i < 10; ++i) {
  ...
  if (some_condition) { break; }
  ...
}
 
_Time_: do {
  for (int i = 0; i < 10; ++i) {
    ...
    if (some_condition) { break _Time_; /* terminate the do-while loop */}
    ...
    }
  ...
} while (thisCondition);while (condition) {
  ...
  if (someCondition) { continue; /* skip to beginning of this loop */ }
  ...
}
 
top: for (int 1 = 0; i < 10; ++i) {
  ...
  middle: for (int j = 0; j < 10; ++j) {
    ...
    bottom: for (int k = 0; k < 10; ++k) {
    ...
    if (top_condition) { continue top; /* restart outer loop */ }
    ...
    if (middle_condition) { continue middle; /* restart middle loop */ }
    ...
    if (bottom_condition) { continue bottom; /* restart bottom loop */ }
    ...
    if (bottom_condition) { continue; /* this will also restart bottom loop */ }
    ...
    }
    ... 
  }
  ....
}"
"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
 
public class FlippingBitsGame extends  {
    final int maxLevel = 7;
    final int minLevel = 3;
 
    private  rand = new ();
    private int[][] grid, target;
    private  box;
    private int n = maxLevel;
    private boolean solved = true;
 
    FlippingBitsGame() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
        setFont(new (strv, .PLAIN, 18));
 
        box = new (120, 90, 400, 400);
 
        startNewGame();
 
        addMouseListener(new () {
            @Override
            public void mousePressed( e) {
                if (solved) {
                    startNewGame();
                } else {
                    int x = e.getX();
                    int y = e.getY();
 
                    if (box.contains(x, y))
                        return;
 
                    if (x > box.x && x < box.x + box.width) {
                        flipCol((x - box.x) / (box.width / n));
 
                    } else if (y > box.y && y < box.y + box.height)
                        flipRow((y - box.y) / (box.height / n));
 
                    if (solved(grid, target))
                        solved = true;
 
                    printGrid(solved ? strv : strv, grid);
                }
                repaint();
            }
        });
    }
 
    void startNewGame() {
        if (solved) {
 
            n = (n == maxLevel) ? minLevel : n + 1;
 
            grid = new int[n][n];
            target = new int[n][n];
 
            do {
                shuffle();
 
                for (int i = 0; i < n; i++)
                    target[i] = .copyOf(grid[i], n);
 
                shuffle();
 
            } while (solved(grid, target));
 
            solved = false;
            printGrid(strv, target);
            printGrid(strv, grid);
        }
    }
 
    void printGrid( msg, int[][] g) {
        .out.println(msg);
        for (int[] row : g)
            .out.println(.toString(row));
        .out.println();
    }
 
    boolean solved(int[][] a, int[][] b) {
        for (int i = 0; i < n; i++)
            if (!.equals(a[i], b[i]))
                return false;
        return true;
    }
 
    void shuffle() {
        for (int i = 0; i < n * n; i++) {
            if (rand.nextBoolean())
                flipRow(rand.nextInt(n));
            else
                flipCol(rand.nextInt(n));
        }
    }
 
    void flipRow(int r) {
        for (int c = 0; c < n; c++) {
            grid[r][c] ^= 1;
        }
    }
 
    void flipCol(int c) {
        for (int[] row : grid) {
            row[c] ^= 1;
        }
    }
 
    void drawGrid( g) {
        g.setColor(getForeground());
 
        if (solved)
            g.drawString(strv, 180, 600);
        else
            g.drawString(strv, 170, 600);
 
        int size = box.width / n;
 
        for (int r = 0; r < n; r++)
            for (int c = 0; c < n; c++) {
                g.setColor(grid[r][c] == 1 ? .blue : .orange);
                g.fillRect(box.x + c * size, box.y + r * size, size, size);
                g.setColor(getBackground());
                g.drawRect(box.x + c * size, box.y + r * size, size, size);
                g.setColor(target[r][c] == 1 ? .blue : .orange);
                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);
            }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawGrid(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new FlippingBitsGame(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.util.Calendar;
import java.util.GregorianCalendar;
 
public class FiveFSS {
    private static boolean[] years = new boolean[201];
    private static int[] month31 = {.JANUARY, .MARCH, .MAY,
        .JULY, .AUGUST, .OCTOBER, .DECEMBER};
 
    public static void main([] args) {
        StringBuilder months = new StringBuilder();
        int numMonths = 0;
        for (int year = 1900; year <= 2100; year++) {
            for (int month : month31) {
                 date = new (year, month, 1);
                if (date.get(.DAY_OF_WEEK) == .FRIDAY) {
                    years[year - 1900] = true;
                    numMonths++;
                    //months are 0-indexed in Calendar
                    months.append((date.get(.MONTH) + 1) + strv + year +"""");
                }
            }
        }
        .out.println(strv+numMonths+strv);
        .out.println(months);
        .out.println(strv);
        for (int year = 1900; year <= 2100; year++) {
            if(!years[year - 1900]){
                .out.println(year);
            }
        }
    }
}"
"public class Pali23 {
	public static boolean isPali( x){
		return x.equals(new StringBuilder(x).reverse().toString());
	}
 
	public static void main([] args){
 
		for(long i = 0, count = 0; count < 6;i++){
			if((i & 1) == 0 && (i != 0)) continue; //skip non-zero evens, nothing that ends in 0 in binary can be in this sequence
			//maybe speed things up through short-circuit evaluation by putting toString in the if
			//testing up to 10M, base 2 has slightly fewer palindromes so do that one first
			if(isPali(.toBinaryString(i)) && isPali(.toString(i, 3))){
				.out.println(i + strv + .toBinaryString(i) + strv + .toString(i, 3));
				count++;
			}
		}
	}
}"
"import java.util.ArrayList;
 
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
 
public class FindMissingPermutation {
	public static void main([] args) {
		Joiner joiner = Joiner.on(strv).skipNulls();
		ImmutableSet<String> s = ImmutableSet.of(strv, strv, strv,
				strv, strv, strv, strv, strv, strv, strv, strv,
				strv, strv, strv, strv, strv, strv, strv, strv,
				strv, strv, strv, strv);
 
		for (ArrayList<Character> cs : Utils.Permutations(Lists.newArrayList(
				'A', 'B', 'C', 'D')))
			if (!s.contains(joiner.join(cs)))
				.out.println(joiner.join(cs));
	}
}public class FindMissingPermutation
{
  public static void main([] args)
  {
    [] givenPermutations = { strv, strv, strv, strv, strv, strv,
                                   strv, strv, strv, strv, strv, strv,
                                   strv, strv, strv, strv, strv, strv,
                                   strv, strv, strv, strv, strv };
     characterSet = givenPermutations[0];
    

    int maxCode = characterSet.length() - 1;
    for (int i = characterSet.length(); i >= 3; i--)
      maxCode *= i;
    StringBuilder missingPermutation = new StringBuilder();
    for (int i = 0; i < characterSet.length(); i++)
    {
      int code = 0;
      for ( permutation : givenPermutations)
        code += characterSet.indexOf(permutation.charAt(i));
      missingPermutation.append(characterSet.charAt(maxCode - code));
    }
    .out.println(strv + missingPermutation.toString());
  }
}"
" 
public class RecursionTest {
 
    private static void recurse(int i) {
        try {
	    recurse(i+1);
	} catch ( e) {
	    .out.print(strv + i + strv);
	}
    }
 
    public static void main([] args) {
        recurse(0);
    }
}
 "
"import java.math.BigInteger;
import java.util.*;
 
class LeftTruncatablePrime
{
  private static List<BigInteger> getNextLeftTruncatablePrimes( n, int radix, int millerRabinCertainty)
  {
    List<BigInteger> probablePrimes = new ArrayList<BigInteger>();
     baseString = n.equals(.ZERO) ? strv : n.toString(radix);
    for (int i = 1; i < radix; i++)
    {
       p = new (.toString(i, radix) + baseString, radix);
      if (p.isProbablePrime(millerRabinCertainty))
        probablePrimes.add(p);
    }
    return probablePrimes;
  }
 
  public static  getLargestLeftTruncatablePrime(int radix, int millerRabinCertainty)
  {
    List<BigInteger> lastList = null;
    List<BigInteger> list = getNextLeftTruncatablePrimes(.ZERO, radix, millerRabinCertainty);
    while (!list.isEmpty())
    {
      lastList = list;
      list = new ArrayList<BigInteger>();
      for ( n : lastList)
        list.addAll(getNextLeftTruncatablePrimes(n, radix, millerRabinCertainty));
    }
    if (lastList == null)
      return null;
    .sort(lastList);
    return lastList.get(lastList.size() - 1);
  }
 
  public static void main([] args)
  {
    int maxRadix = .parseInt(args[0]);
    int millerRabinCertainty = .parseInt(args[1]);
    for (int radix = 3; radix <= maxRadix; radix++)
    {
       largest = getLargestLeftTruncatablePrime(radix, millerRabinCertainty);
      .out.print(strv + radix + strv);
      if (largest == null)
        .out.println(strv);
      else
        .out.println(largest + strv + radix + strv + largest.toString(radix));
    }
  }
 
}"
"import java.util.Scanner;
 
public class LastSunday 
{
	static final [] months={strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv,strv};
 
	public static int[] findLastSunday(int year)
	{
		boolean isLeap = isLeapYear(year);
 
		int[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};
		int[] lastDay=new int[12];
 
		for(int m=0;i<12;i++)
		{
			int d;
			for(d=days[m]; getWeekDay(year,m,d)!=0; d--)
				;
			lastDay[m]=d;
		}
 
		return lastDay;
	}
 
	private static boolean isLeapYear(int year)
	{
		if(year%4==0)
		{
			if(year%100!=0)
				return true;
			else if (year%400==0)
				return true;
		}
		return false;
	}
 
	private static int getWeekDay(int y, int m, int d)
	{
		int f=y+d+3*m-1;
		m++;
 
		if(m<3)
			y--;
		else
			f-=(int)(0.4*m+2.3);
 
		f+=(int)(y/4)-(int)((y/100+1)*0.75);
		f%=7;
 
		return f;
	}
 
	private static void display(int year, int[] lastDay)
	{
		.out.println(""YEAR: ""+year);
		for(int m=0;i<12;i++)
			.out.println(months[m]+strv+lastDay[m]);
	}
 
	public static void main([] args) throws 
	{
		.out.print(strv);
		Scanner s=new Scanner(.in);
 
		int y=.parseInt(s.next());
 
		int[] lastDay = findLastSunday(y);
		display(y, lastDay);
 
		s.close();
	}
}import java.time.*;
import java.util.stream.*;
import static java.time.temporal.TemporalAdjusters.*;
 
public class FindTheLastSundayOfEachMonth {
    public static Stream<LocalDate> lastSundaysOf(int year) {
        return IntStream.rangeClosed(1, 12).mapToObj(month ->
            LocalDate.of(year, month, 1).with(lastDayOfMonth())
            .with(previousOrSame(DayOfWeek.SUNDAY))
        );
    }
 
    public static java.util.List<LocalDate> listLastSundaysOf(int year) {
        return lastSundaysOf(year).collect(Collectors.toList());
    }
 
    public static void main([] args) throws  {
        int year = args.length > 0 ? .parseInt(args[0]) : LocalDate.now().getYear();
 
        for (LocalDate d : listLastSundaysOf(year)) {
            .out.println(d);
        };
 
         result = lastSundaysOf(2013).map(LocalDate::toString).collect(Collectors.joining(""""));
         test = ""2013-01-272013-02-242013-03-312013-04-282013-05-262013-06-302013-07-282013-08-252013-09-292013-10-272013-11-242013-12-29"";
        if (!test.equals(result)) throw new AssertionError(strv);
    }
 
}"
"public class FirstLastBits {
 
    

    public static int mssb(int x) {
        return .highestOneBit(x);
    }
 
    public static long mssb(long x) {
        return .highestOneBit(x);
    }
 
    public static int mssb_idx(int x) {
        return .SIZE - 1 - .numberOfLeadingZeros(x);
    }
 
    public static int mssb_idx(long x) {
        return .SIZE - 1 - .numberOfLeadingZeros(x);
    }
 
    public static int mssb_idx( x) {
	return x.bitLength() - 1;
    }
 
    

    public static int lssb(int x) {
        return .lowestOneBit(x);
    }
 
    public static long lssb(long x) {
        return .lowestOneBit(x);
    }
 
    public static int lssb_idx(int x) {
        return .numberOfTrailingZeros(x);
    }
 
    public static int lssb_idx(long x) {
        return .numberOfTrailingZeros(x);
    }
 
    public static int lssb_idx( x) {
	return x.getLowestSetBit();
    }
 
    public static void main([] args) {
        .out.println(strv);
        int n1 = 1;
        for (int i = 0; ; i++, n1 *= 42) {
            .out.printf(""42**%d = %10d(x%08x): M x%08x(%2d) L x%03x(%2d)"",
                              i, n1, n1,
                              mssb(n1), mssb_idx(n1),
                              lssb(n1), lssb_idx(n1));
            if (n1 >= .MAX_VALUE / 42)
                break;
        }
        .out.println();
        .out.println(strv);
        long n2 = 1;
        for (int i = 0; ; i++, n2 *= 42) {
            .out.printf(""42**%02d = %20d(x%016x): M x%016x(%2d) L x%06x(%2d)"",
                              i, n2, n2,
                              mssb(n2), mssb_idx(n2),
                              lssb(n2), lssb_idx(n2));
            if (n2 >= .MAX_VALUE / 42)
                break;
        }
	.out.println();
	.out.println(strv);
	 n3 = .ONE;
	 k = .valueOf(1302);
	for (int i = 0; i < 10; i++, n3 = n3.multiply(k)) {
	    .out.printf(""1302**%02d = %30d(x%28x): M %2d L %2d"",
			      i, n3, n3,
			      mssb_idx(n3),
			      lssb_idx(n3));
	}
    }
}"
"int[] array = {1, 2, 3, 4, 5 };
List<Integer> evensList = new ArrayList<Integer>();
for (int  i: array) {
    if (i % 2 == 0) evensList.add(i);
}
int[] evens = evensList.toArray(new int[0]);"
"import java.io.File;
import java.util.Date;
public class FileModificationTimeTest {
   public static void test( type,  file) {
       long t = file.lastModified();
       .out.println(strv + type + strv + file.getPath() +
            (t == 0 ? strv : strv + new (t).toString() )
       );
       .out.println(strv + type + strv + file.getPath() + 
            (!file.setLastModified(.currentTimeMillis()) ? strv : strv )
       );
       .out.println(strv + type + strv + file.getPath() + 
            (!file.setLastModified(t) ? strv : strv )
       );
   }
   public static void main( args[]) {
       test(strv, new (strv));
       test(strv, new (strv));
   }
}"
"import java.io.File;
 
public class FileSize
{
    public static void main ( [] args )
    {
        .out.println(strv + new (strv).length() + strv);
        .out.println(strv + new (strv).length() + strv);
    }
}
 "
"import java.io.*;
 
public class FileIODemo {
  public static void main([] args) {
    try {
       in = new (strv);
       out = new (strv);
      int c;
      while ((c = in.read()) != -1) {
        out.write(c);
      }
    } catch ( e) {
      e.printStackTrace();
    } catch ( e){
      e.printStackTrace();
    }
  }
}import java.io.*;
 
public class FileIODemo2 {
  public static void main( args[]) {
    try {
      

      final  in = new (strv);
      try {
        

        final  out = new (strv);
        try {
          int c;
          while ((c = in.read()) != -1) {
            out.write(c);
          }
        }
        finally {
          out.close();
        }
      }
      finally {
        in.close();
      }
    } catch ( e) {
      e.printStackTrace();
    } catch ( e){
      e.printStackTrace();
    }
  }
}import java.io.*;
import java.nio.channels.*;
 
public class FileIODemo3 {
  public static void main( args[]) {
    try {
      final FileChannel in = new (strv).getChannel();
      try {
        final FileChannel out = new (strv).getChannel();
        try {
          out.transferFrom(in, 0, in.size());
        }
        finally {
          out.close();
        }
      }
      finally {
        in.close();
      }
    }
    catch ( e) {
      .err.println(strv+e);
      e.printStackTrace(); 

    }
  }
}import java.io.*;
public class Test {
  public static void main ([] args) throws  {
     br = new (new (strv));
     bw = new (new (strv));
     line;
    while ((line = br.readLine()) != null) {
      bw.write(line);
      bw.newLine();
    }
    br.close();
    bw.close();
  }
}"
"import java.awt.*;
import javax.swing.*;
 
public class FibonacciWordFractal extends  {
     wordFractal;
 
    FibonacciWordFractal(int n) {
        setPreferredSize(new (450, 620));
        setBackground(.white);
        wordFractal = wordFractal(n);
    }
 
    public  wordFractal(int n) {
        if (n < 2)
            return n == 1 ? strv : strv;
 
        

        StringBuilder f1 = new StringBuilder(strv);
        StringBuilder f2 = new StringBuilder(strv);
 
        for (n = n - 2; n > 0; n--) {
             tmp = f2.toString();
            f2.append(f1);
 
            f1.setLength(0);
            f1.append(tmp);
        }
 
        return f2.toString();
    }
 
    void drawWordFractal( g, int x, int y, int dx, int dy) {
        for (int n = 0; n < wordFractal.length(); n++) {
            g.drawLine(x, y, x + dx, y + dy);
            x += dx;
            y += dy;
            if (wordFractal.charAt(n) == '0') {
                int tx = dx;
                dx = (n % 2 == 0) ? -dy : dy;
                dy = (n % 2 == 0) ? tx : -tx;
            }
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawWordFractal(g, 20, 20, 1, 0);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new FibonacciWordFractal(23), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"class Fibonacci
{
  public static int[] lucas(int n, int numRequested)
  {
    if (n < 2)
      throw new (strv);
    return fibonacci((n == 2) ? new int[] { 2, 1 } : lucas(n - 1, n), numRequested);
  }
 
  public static int[] fibonacci(int n, int numRequested)
  {
    if (n < 2)
      throw new (strv);
    return fibonacci((n == 2) ? new int[] { 1, 1 } : fibonacci(n - 1, n), numRequested);
  }
 
  public static int[] fibonacci(int[] startingValues, int numRequested)
  {
    int[] output = new int[numRequested];
    int n = startingValues.length;
    .arraycopy(startingValues, 0, output, 0, n);
    for (int i = n; i < numRequested; i++)
      for (int j = 1; j <= n; j++)
        output[i] += output[i - j];
    return output;
  }
 
  public static void main([] args)
  {
    for (int n = 2; n <= 10; n++)
    {
      .out.print(strv + n + strv);
      for (int value : fibonacci(n, 15))
        .out.print(strv + value);
      .out.println();
    }
    for (int n = 2; n <= 10; n++)
    {
      .out.print(strv + n + strv);
      for (int value : lucas(n, 15))
        .out.print(strv + value);
      .out.println();
    }
  }
}"
"import java.io.*;
import java.util.Scanner;
 
public class ReadFastaFile {
 
    public static void main([] args) throws  {
 
        boolean first = true;
 
        try (Scanner sc = new Scanner(new (strv))) {
            while (sc.hasNextLine()) {
                 line = sc.nextLine().trim();
                if (line.charAt(0) == '>') {
                    if (first)
                        first = false;
                    else
                        .out.println();
                    .out.printf(strv, line.substring(1));
                } else {
                    .out.print(line);
                }
            }
        }
        .out.println();
    }
}"
"import static java.lang..*;
 
public class FastFourierTransform {
 
    public static int bitReverse(int n, int bits) {
        int reversedN = n;
        int count = bits - 1;
 
        n >>= 1;
        while (n > 0) {
            reversedN = (reversedN << 1) | (n & 1);
            count--;
            n >>= 1;
        }
 
        return ((reversedN << count) & ((1 << bits) - 1));
    }
 
    static void fft(Complex[] buffer) {
 
        int bits = (int) (log(buffer.length) / log(2));
        for (int j = 1; j < buffer.length / 2; j++) {
 
            int swapPos = bitReverse(j, bits);
            Complex temp = buffer[j];
            buffer[j] = buffer[swapPos];
            buffer[swapPos] = temp;
        }
 
        for (int N = 2; N <= buffer.length; N <<= 1) {
            for (int i = 0; i < buffer.length; i += N) {
                for (int k = 0; k < N / 2; k++) {
 
                    int evenIndex = i + k;
                    int oddIndex = i + k + (N / 2);
                    Complex even = buffer[evenIndex];
                    Complex odd = buffer[oddIndex];
 
                    double term = (-2 * PI * k) / (double) N;
                    Complex exp = (new Complex(cos(term), sin(term)).mult(odd));
 
                    buffer[evenIndex] = even.add(exp);
                    buffer[oddIndex] = even.sub(exp);
                }
            }
        }
    }
 
    public static void main([] args) {
        double[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};
 
        Complex[] cinput = new Complex[input.length];
        for (int i = 0; i < input.length; i++)
            cinput[i] = new Complex(input[i], 0.0);
 
        fft(cinput);
 
        .out.println(strv);
        for (Complex c : cinput) {
            .out.println(c);
        }
    }
}
 
class Complex {
    public final double re;
    public final double im;
 
    public Complex() {
        this(0, 0);
    }
 
    public Complex(double r, double i) {
        re = r;
        im = i;
    }
 
    public Complex add(Complex b) {
        return new Complex(this.re + b.re, this.im + b.im);
    }
 
    public Complex sub(Complex b) {
        return new Complex(this.re - b.re, this.im - b.im);
    }
 
    public Complex mult(Complex b) {
        return new Complex(this.re * b.re - this.im * b.im,
                this.re * b.im + this.im * b.re);
    }
 
    @Override
    public  toString() {
        return .format(strv, re, im);
    }
}"
"import java.util.*;
 
public class FWord {
    private /*v*/  fWord0 = strv;
    private /*v*/  fWord1 = strv;
 
    private  nextFWord () {
        final  result;
 
        if ( strv.equals ( fWord1 ) )      result = strv;
        else if ( strv.equals ( fWord0 ) ) result = strv;
        else                             result = fWord1 + fWord0;
 
        fWord0 = fWord1;
        fWord1 = result;
 
        return result;
    }
 
    public static double entropy ( final  source ) {
        final int                        length = source.length ();
        final  < ,  > counts = new  < ,  > ();
        /*v*/ double                     result = 0.0;
 
        for ( int i = 0; i < length; i++ ) {
            final char c = source.charAt ( i );
 
            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );
            else                            counts.put ( c, 1 );
        }
 
        for ( final int count : counts.values () ) {
            final double proportion = ( double ) count / length;
 
            result -= proportion * ( .log ( proportion ) / .log ( 2 ) );
        }
 
        return result;
    }
 
    public static void main ( final  [] args ) {
        final FWord fWord = new FWord ();
 
        for ( int i = 0; i < 37;  ) {
            final  word = fWord.nextFWord ();
 
            .out.printf ( strv, ++i, word.length (), entropy ( word ) );
        }
    }
}"
" 
import java.math.BigInteger;
 
class MersenneFactorCheck
{
 
  private final static  TWO = .valueOf(2);
 
  public static boolean isPrime(long n)
  {
    if (n == 2)
      return true;
    if ((n < 2) || ((n & 1) == 0))
      return false;
    long maxFactor = (long).sqrt((double)n);
    for (long possibleFactor = 3; possibleFactor <= maxFactor; possibleFactor += 2)
      if ((n % possibleFactor) == 0)
        return false;
    return true;
  }
 
  public static  findFactorMersenneNumber(int primeP)
  {
    if (primeP <= 0)
      throw new ();
     bigP = .valueOf(primeP);
     m = .ONE.shiftLeft(primeP).subtract(.ONE);
    

     maxFactor = .ONE.shiftLeft((primeP + 1) >>> 1);
     twoP = .valueOf(primeP << 1);
     possibleFactor = .ONE;
    int possibleFactorBits12 = 0;
    int twoPBits12 = primeP & 3;
 
    while ((possibleFactor = possibleFactor.add(twoP)).compareTo(maxFactor) <= 0)
    {
      possibleFactorBits12 = (possibleFactorBits12 + twoPBits12) & 3;
      

      if ((possibleFactorBits12 == 0) || (possibleFactorBits12 == 3))
        if (TWO.modPow(bigP, possibleFactor).equals(.ONE))
          return possibleFactor;
    }
    return null;
  }
 
  public static void checkMersenneNumber(int p)
  {
    if (!isPrime(p))
    {
      .out.println(strv + p + strv);
      return;
    }
     factor = findFactorMersenneNumber(p);
    if (factor == null)
      .out.println(strv + p + strv);
    else
      .out.println(strv + p + strv + factor);
    return;
  }
 
  public static void main([] args)
  {
    for (int p = 1; p <= 50; p++)
      checkMersenneNumber(p);
    checkMersenneNumber(929);
    return;
  }
 
}
 "
"public static long itFibN(int n)
{
 if (n < 2)
  return n;
 long ans = 0;
 long n1 = 0;
 long n2 = 1;
 for(n--; n > 0; n--)
 {
  ans = n1 + n2;
  n1 = n2;
  n2 = ans;
 }
 return ans;
} 
/** * O(log(n)) */
public static long fib(long n) {
    if (n <= 0)
	return 0;
 
    long i = (int) (n - 1);
    long a = 1, b = 0, c = 0, d = 1, tmp1,tmp2;
 
    while (i > 0) {
	if (i % 2 != 0) {
            tmp1 = d * b + c * a;
	    tmp2 = d * (b + a) + c * b;
	    a = tmp1;
	    b = tmp2;
	}
 
        tmp1 = (long) (.pow(c, 2) + .pow(d, 2));
        tmp2 = d * (2 * c + d);
 
        c = tmp1;
        d = tmp2;
 
        i = i / 2;
    }
    return a + b;
}
 public static long recFibN(final int n)
{
 return (n < 2) ? n : recFibN(n - 1) + recFibN(n - 2);
}public static long anFibN(final long n)
{
 double p = (1 + .sqrt(5)) / 2;
 double q = 1 / p;
 return (long) ((.pow(p, n) + .pow(q, n)) / .sqrt(5));
}public static long fibTailRec(final int n)
{
 return fibInner(0, 1, n);
}
 
private static long fibInner(final long a, final long b, final int n)
{
 return n < 1 ? a : n == 1 ?  b : fibInner(b, a + b, n - 1);
}"
"public class Test {
 
    public static void main([] args) {
        [] filenames = { strv,
                               strv,
                               strv,
                               strv,
                               strv,
                               strv
        };
 
        for ( filename : filenames) {
             ext = strv;
            int idx = filename.lastIndexOf('.');
            if (idx != -1) {
                 tmp = filename.substring(idx);
                if (tmp.matches("".[a-zA-Z0-9]+"")) {
                    ext = tmp;
                }
            }
            .out.println(filename + strv + ext);
        }
    }
}"
"public class Extreme {
    public static void main([] args) {
        double negInf = -1.0 / 0.0; //also Double.NEGATIVE_INFINITY
        double inf = 1.0 / 0.0; //also Double.POSITIVE_INFINITY
        double nan = 0.0 / 0.0; //also Double.NaN
        double negZero = -2.0 / inf;
 
        .out.println(strv + negInf);
        .out.println(strv + inf);
        .out.println(strv + nan);
        .out.println(strv + negZero);
        .out.println(strv + (inf + negInf));
        .out.println(strv + (0 * nan));
        .out.println(strv + (nan == nan));
    }
}"
"public class Exp{
   public static void main([] args){
      .out.println(pow(2,30));
      .out.println(pow(2.0,30)); //tests
      .out.println(pow(2.0,-2));
   }
 
   public static double pow(double base, int exp){
      if(exp < 0) return 1 / pow(base, -exp);
      double ans = 1.0;
      for(;exp > 0;--exp) ans *= base;
      return ans;
   }
}"
"import java.io.IOException;
import java.io.InputStream;
 
public class MainEntry {
    public static void main([] args) {
        executeCmd(strv);
    }
 
    private static void executeCmd( string) {
         pipedOut = null;
        try {
             aProcess = .getRuntime().exec(string);
            aProcess.waitFor();
 
            pipedOut = aProcess.getInputStream();
            byte buffer[] = new byte[2048];
            int read = pipedOut.read(buffer);
            

            while(read >= 0) {
                .out.write(buffer, 0, read);
 
                read = pipedOut.read(buffer);
            }
        } catch ( e) {
            e.printStackTrace();
        } catch ( ie) {
            ie.printStackTrace();
        } finally {
            if(pipedOut != null) {
                try {
                    pipedOut.close();
                } catch ( e) {
                }
            }
        }
    }
 
 
}import java.io.IOException;
import java.io.InputStream;
 
public class MainEntry {
    public static void main([] args) {
        

        executeCmd(strv);
    }
 
    private static void executeCmd( string) {
         pipedOut = null;
        try {
             aProcess = .getRuntime().exec(string);
 
            

             pipeThread = new (new StreamGobber(aProcess.getInputStream()));
             errorThread = new (new StreamGobber(aProcess.getErrorStream()));
 
            pipeThread.start();
            errorThread.start();
 
            aProcess.waitFor();
        } catch ( e) {
            e.printStackTrace();
        } catch ( ie) {
            ie.printStackTrace();
        }
    }
}
 
//Replace the following thread with your intends reader
class StreamGobber implements  {
 
    private  Pipe;
 
    public StreamGobber( pipe) {
        if(pipe == null) {
            throw new (strv);
        }
        Pipe = pipe;
    }
 
    public void run() {
        try {
            byte buffer[] = new byte[2048];
 
            int read = Pipe.read(buffer);
            while(read >= 0) {
                .out.write(buffer, 0, read);
 
                read = Pipe.read(buffer);
            }
        } catch ( e) {
            e.printStackTrace();
        } finally {
            if(Pipe != null) {
                try {
                    Pipe.close();
                } catch ( e) {
                }
            }
        }
    }
}"
"import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class Markov {
 
    public static void main([] args) throws  {
 
        List<[]> rules = readRules(strv);
        List<String> tests = readTests(strv);
 
        Pattern pattern = Pattern.compile(""^([^#]*?)s+->s+(.?)(.*)"");
 
        for (int i = 0; i < tests.size(); i++) {
             origTest = tests.get(i);
 
            List<[]> captures = new ArrayList<>();
            for ( rule : rules.get(i)) {
                Matcher m = pattern.matcher(rule);
                if (m.find()) {
                    [] groups = new [m.groupCount()];
                    for (int j = 0; j < groups.length; j++)
                        groups[j] = m.group(j + 1);
                    captures.add(groups);
                }
            }
 
             test = origTest;
             copy = test;
            for (int j = 0; j < captures.size(); j++) {
                [] c = captures.get(j);
                test = test.replace(c[0], c[2]);
                if (c[1].equals(strv))
                    break;
                if (!test.equals(copy)) {
                    j = -1; 

                    copy = test;
                }
            }
            .out.printf(""%s%s"", origTest, test);
        }
    }
 
    private static List<String> readTests( path)
            throws  {
        return Files.readAllLines(Paths.get(path), StandardCharsets.UTF_8);
    }
 
    private static List<[]> readRules( path)
            throws  {
         ls = .lineSeparator();
         lines = new (Files.readAllBytes(Paths.get(path)), strv);
        List<[]> rules = new ArrayList<>();
        for ( line : lines.split(ls + ls))
            rules.add(line.split(ls));
        return rules;
    }
}"
"//Checked exception
public class MyException extends  {
   //Put specific info in here
}
 
//Unchecked exception
public class MyRuntimeException extends  {}public void fooChecked() throws MyException {
   throw new MyException();
}
 
public void fooUnchecked() {
   throw new MyRuntimeException();
}try {
   fooChecked();
}
catch(MyException exc) {
   //Catch only your specified type of exception
}
catch( exc) {
   //Catch any non-system error exception
}
catch( exc) {
   //Catch everything including system errors (not recommended)
}
finally {
   //This code is always executed after exiting the try block
}"
"class U0 extends  { }
class U1 extends  { }
 
public class ExceptionsTest {
    public static void foo() throws U1 {
        for (int i = 0; i <= 1; i++) {
            try {
                bar(i);
            } catch (U0 e) {
                .out.println(strv);
            }
        }
    }
 
    public static void bar(int i) throws U0, U1 {
        baz(i); 

    }
 
    public static void baz(int i) throws U0, U1 {
        if (i == 0)
            throw new U0();
        else
            throw new U1();
    }
 
    public static void main([] args) throws U1 {
        foo();
    }
}"
"public static boolean isEven(int i){
    return (i & 1) == 0;
}public static boolean isEven(int i){
    return (i % 2) == 0;
}public static boolean isEven( i){
    return i.and(.ONE).equals(.ZERO);
}public static boolean isEven( i){
    return !i.testBit(0);
}public static boolean isEven( i){
    return i.mod(.valueOf(2)).equals(.ZERO);
}"
"public class Binomial
{
    private static long binomial(int n, int k)
    {
        if (k>n-k)
            k=n-k;
 
        long b=1;
        for (int i=1, m=n; i<=k; i++, m--)
            b=b*m/i;
        return b;
    }
 
    public static void main([] args)
    {
        .out.println(binomial(5, 3));
    }
}public class Binom {
    public static double binomCoeff(double n, double k) {
        double result = 1;
        for (int i = 1; i < k + 1; i++) {
            result *= (n - i + 1) / i;
        }
        return result;
    }
 
    public static void main([] args) {
        .out.println(binomCoeff(5, 3));
    }
}
 public class Binomial
{
    private static long binom(int n, int k)
    {
        if (k==0)
            return 1;
        else if (k>n-k)
            return binom(n, n-k);
        else
            return binom(n-1, k-1)*n/k;
    }
 
    public static void main([] args)
    {
        .out.println(binom(5, 3));
    }
}"
"public class eulerSopConjecture
{
 
    static final int    MAX_NUMBER = 250;
 
    public static void main( [] args )
    {
        boolean found = false;
        long[]  fifth = new long[ MAX_NUMBER ];
 
        for( int i = 1; i <= MAX_NUMBER; i ++ )
        {
            long i2 =  i * i;
            fifth[ i - 1 ] = i2 * i2 * i;
        } 

 
        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )
        {
            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )
            {
                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )
                {
                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )
                    {
                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];
                        int  e = java.util..binarySearch( fifth, sum );
                        found  = ( e >= 0 );
                        if( found )
                        {
                            

                            .out.print( (a+1) + strv
                                            + (b+1) + strv
                                            + (c+1) + strv
                                            + (d+1) + strv
                                            + (e+1) + strv
                                            );
                        } 

                    } 

                } 

            } 

        } 

    } 

 
} 
"
" 
public class Euler {
  private static void euler (Callable f, double y0, int a, int b, int h) {
    int t = a;
    double y = y0;
    while (t < b) {
      .out.println (strv + t + strv + y);
      t += h;
      y += h * f.compute (t, y);
    }
    .out.println (strv);
  }
 
  public static void main ([] args) {
    Callable cooling = new Cooling ();
    int[] steps = {2, 5, 10};
    for (int stepSize : steps) {
      .out.println (strv + stepSize);
      euler (cooling, 100.0, 0, 100, stepSize);
    }
  }
}
 


interface Callable {
  public double compute (int time, double t);
}
 


class Cooling implements Callable {
  public double compute (int time, double t) {
    return -0.07 * (t - 20);
  }
}
 "
".getenv(strv) 

.getenv()       
"
"final int immutableInt = 4;
int mutableInt = 4;
mutableInt = 6; //this is fine
immutableInt = 6; //this is an errorfinal  immutableString = strv;
immutableString = new (strv); //this is an error
final  immutableBuffer = new ();
immutableBuffer.append(strv); //this is fine and it changes the state of the object
immutableBuffer = new (strv); //this is an errorpublic class Immute{
    private final int num;
    private final  word;
    private final  buff; //still mutable inside this class, but there is no access outside this class
 
    public Immute(int num){
        this.num = num;
        word = num + strv;
        buff = new (strv + word);
    }
 
    public int getNum(){
        return num;
    }
 
    public  getWord(){
        return word; //String objects are immutable so passing the object back directly won't harm anything
    }
 
    public  getBuff(){
        return new (buff);
        //using strv here compromises immutability, but copying the object via the constructor makes it ok
    }
    //no strv methods are given
}"
"public class Emirp{
 
	//trivial prime algorithm, sub in whatever algorithm you want
	public static boolean isPrime(long x){
		if(x < 2) return false;
		if(x == 2) return true;
		if((x & 1) == 0) return false;
 
		for(long i = 3; i <= .sqrt(x);i+=2){
			if(x % i == 0) return false;
		}
 
		return true;
	}
 
	public static boolean isEmirp(long x){
		 xString = .toString(x);
		if(xString.length() == 1) return false;
		if(xString.matches(strv) || xString.matches(strv)) return false; //eliminate some easy rejects
		long xR = .parseLong(new StringBuilder(xString).reverse().toString());
		if(xR == x) return false;
		return isPrime(x) && isPrime(xR);
	}
 
	public static void main([] args){
		int count = 0;
		long x = 1;
 
		.out.println(strv);
		while(count < 20){
			if(isEmirp(x)){
				count++;
				.out.print(x + strv);
			}
			x++;
		}
 
		.out.println(""Emirps between 7700 and 8000:"");
		for(x = 7700; x <= 8000; x++){
			if(isEmirp(x)){
				.out.print(x +strv);
			}
		}
 
		.out.println(""10,000th emirp:"");
		for(x = 1, count = 0;count < 10000; x++){
			if(isEmirp(x)){
				count++;
			}
		}
		//--x to fix the last increment from the loop
		.out.println(--x);
	}
}"
"import java.awt.*;
import java.awt.event.ActionEvent;
import javax.swing.*;
import javax.swing.Timer;
 
public class WolframCA extends  {
    final int[] ruleSet = {30, 45, 50, 57, 62, 70, 73, 75, 86, 89, 90, 99,
        101, 105, 109, 110, 124, 129, 133, 135, 137, 139, 141, 164,170, 232};
    byte[][] cells;
    int rule = 0;
 
    public WolframCA() {
         dim = new (900, 450);
        setPreferredSize(dim);
        setBackground(.white);
        setFont(new (strv, .BOLD, 28));
 
        cells = new byte[dim.height][dim.width];
        cells[0][dim.width / 2] = 1;
 
        new (5000, ( e) -> {
            rule++;
            if (rule == ruleSet.length)
                rule = 0;
            repaint();
        }).start();
    }
 
    private byte rules(int lhs, int mid, int rhs) {
        int idx = (lhs << 2 | mid << 1 | rhs);
        return (byte) (ruleSet[rule] >> idx & 1);
    }
 
    void drawCa( g) {
        g.setColor(.black);
        for (int r = 0; r < cells.length - 1; r++) {
            for (int c = 1; c < cells[r].length - 1; c++) {
                byte lhs = cells[r][c - 1];
                byte mid = cells[r][c];
                byte rhs = cells[r][c + 1];
                cells[r + 1][c] = rules(lhs, mid, rhs); 

                if (cells[r][c] == 1) {
                    g.fillRect(c, r, 1, 1);
                }
            }
        }
    }
 
    void drawLegend( g) {
         s = .valueOf(ruleSet[rule]);
        int sw = g.getFontMetrics().stringWidth(s);
 
        g.setColor(.white);
        g.fillRect(16, 5, 55, 30);
 
        g.setColor(.darkGray);
        g.drawString(s, 16 + (55 - sw) / 2, 30);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawCa(g);
        drawLegend(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new WolframCA(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"public class EmptyApplet extends java.applet. {
    @Override public void init() {
    }
}public class EmptyMainClass {
    public static void main(... args) {
    }
}method(arg0, arg1, arg2, arg3)public class EmptyMainClass {
    public static void main([] args) {
    }
}public class EmptyApplet extends java.applet. {
    public void init() {
    }
}"
" 
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.stream.Stream;
 
@SuppressWarnings(strv)
public class ElementWiseOp {
	static final Map<, BiFunction<, , Double>> OPERATIONS = new HashMap<, BiFunction<, , Double>>() {
		{
			put(strv, (a, b) -> a + b);
			put(strv, (a, b) -> a - b);
			put(strv, (a, b) -> a * b);
			put(strv, (a, b) -> a / b);
			put(strv, (a, b) -> .pow(a, b));
			put(strv, (a, b) -> a % b);
		}
	};
	public static [][] scalarOp( op, [][] matr,  scalar) {
		BiFunction<, , Double> operation = OPERATIONS.getOrDefault(op, (a, b) -> a);
		[][] result = new [matr.length][matr[0].length];
		for (int i = 0; i < matr.length; i++) {
			for (int j = 0; j < matr[i].length; j++) {
				result[i][j] = operation.apply(matr[i][j], scalar);
			}
		}
		return result;
	}
	public static [][] matrOp( op, [][] matr, [][] scalar) {
		BiFunction<, , Double> operation = OPERATIONS.getOrDefault(op, (a, b) -> a);
		[][] result = new [matr.length][Stream.of(matr).mapToInt(a -> a.length).max().getAsInt()];
		for (int i = 0; i < matr.length; i++) {
			for (int j = 0; j < matr[i].length; j++) {
				result[i][j] = operation.apply(matr[i][j], scalar[i % scalar.length][j
						% scalar[i % scalar.length].length]);
			}
		}
		return result;
	}
	public static void printMatrix([][] matr) {
		Stream.of(matr).map(::toString).forEach(.out::println);
	}
	public static void main([] args) {
		printMatrix(scalarOp(strv, new [][] {
				{ 1.0, 2.0, 3.0 }, 
				{ 4.0, 5.0, 6.0 }, 
				{ 7.0, 8.0, 9.0 }
		}, 3.0));
 
		printMatrix(matrOp(strv, new [][] {
				{ 1.0, 2.0, 3.0 }, 
				{ 4.0, 5.0, 6.0 }, 
				{ 7.0, 8.0, 9.0 }
		}, new [][] {
				{ 1.0, 2.0}, 
				{ 3.0, 4.0} 
		}));
	}
}
 "
"import static java.lang..*;
import java.util.Locale;
 
public class Test {
 
    public static void main([] args) {
        Pt a = Pt.fromY(1);
        Pt b = Pt.fromY(2);
        .out.printf(strv, a);
        .out.printf(strv, b);
        Pt c = a.plus(b);
        .out.printf(strv, c);
        Pt d = c.neg();
        .out.printf(strv, d);
        .out.printf(strv, c.plus(d));
        .out.printf(strv, a.plus(b).plus(d));
        .out.printf(strv, a.mult(12345));
    }
}
 
class Pt {
    final static int bCoeff = 7;
 
    double x, y;
 
    Pt(double x, double y) {
        this.x = x;
        this.y = y;
    }
 
    static Pt zero() {
        return new Pt(.POSITIVE_INFINITY, .POSITIVE_INFINITY);
    }
 
    boolean isZero() {
        return this.x > 1e20 || this.x < -1e20;
    }
 
    static Pt fromY(double y) {
        return new Pt(cbrt(pow(y, 2) - bCoeff), y);
    }
 
    Pt dbl() {
        if (isZero())
            return this;
        double L = (3 * this.x * this.x) / (2 * this.y);
        double x2 = pow(L, 2) - 2 * this.x;
        return new Pt(x2, L * (this.x - x2) - this.y);
    }
 
    Pt neg() {
        return new Pt(this.x, -this.y);
    }
 
    Pt plus(Pt q) {
        if (this.x == q.x && this.y == q.y)
            return dbl();
 
        if (isZero())
            return q;
 
        if (q.isZero())
            return this;
 
        double L = (q.y - this.y) / (q.x - this.x);
        double xx = pow(L, 2) - this.x - q.x;
        return new Pt(xx, L * (this.x - xx) - this.y);
    }
 
    Pt mult(int n) {
        Pt r = Pt.zero();
        Pt p = this;
        for (int i = 1; i <= n; i <<= 1) {
            if ((i & n) != 0)
                r = r.plus(p);
            p = p.dbl();
        }
        return r;
    }
 
    @Override
    public  toString() {
        if (isZero())
            return strv;
        return .format(.US, strv, this.x, this.y);
    }
}"
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
 
public class EchoServer {
	 serverSocket;	
	public EchoServer(){		
	}
 
	public void start() {		
		try {
			serverSocket = new (12321);
			while(true){
				 clientThread = new (new ClientHandler(serverSocket.accept()));
				clientThread.start();
			}
		} catch ( e) {
			e.printStackTrace();
		} finally {
			try {
				.out.println(strv);
				serverSocket.close();
			} catch ( e) {
				e.printStackTrace();
			}
		}
 
	}
 
	public static void main([] args) {
		EchoServer es = new EchoServer();
		es.start();
	}
}
 
class ClientHandler implements  {
	private static int numConnections;
	private int connectionId = 0;
	 clientSocket;
 
	public ClientHandler( s) {
		connectionId = numConnections++;
		.out.println(strv + connectionId);
		clientSocket = s;
	}
 
	public void run() {
		 out = null;
		 in = null;
		try {
			out = new (clientSocket.getOutputStream(), true);
			in = new (new (clientSocket.getInputStream()));
			 inputLine, outputLine;
			while((inputLine = in.readLine()) != null){
				outputLine = inputLine;
				.out.println(strv + outputLine);
				out.write(outputLine+"""");
				out.flush();
				if (outputLine.equals(strv))
					break;
			}
		} catch( e) {
			e.printStackTrace();
		} finally {
			out.close();
			try {
				in.close();
				clientSocket.close();
				.out.println(strv + connectionId);
			} catch ( e) {
				e.printStackTrace();
			}
		}
	}
}"
"import java.awt.*;
import java.awt.event.*;
import static java.lang..*;
import javax.swing.*;
 
public class Cuboid extends  {
    double[][] nodes = {{-1, -1, -1}, {-1, -1, 1}, {-1, 1, -1}, {-1, 1, 1},
    {1, -1, -1}, {1, -1, 1}, {1, 1, -1}, {1, 1, 1}};
 
    int[][] edges = {{0, 1}, {1, 3}, {3, 2}, {2, 0}, {4, 5}, {5, 7}, {7, 6},
    {6, 4}, {0, 4}, {1, 5}, {2, 6}, {3, 7}};
 
    int mouseX, prevMouseX, mouseY, prevMouseY;
 
    public Cuboid() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
 
        scale(80, 120, 160);
        rotateCube(PI / 5, PI / 9);
 
        addMouseListener(new () {
            @Override
            public void mousePressed( e) {
                mouseX = e.getX();
                mouseY = e.getY();
            }
        });
 
        addMouseMotionListener(new () {
            @Override
            public void mouseDragged( e) {
                prevMouseX = mouseX;
                prevMouseY = mouseY;
                mouseX = e.getX();
                mouseY = e.getY();
 
                double incrX = (mouseX - prevMouseX) * 0.01;
                double incrY = (mouseY - prevMouseY) * 0.01;
 
                rotateCube(incrX, incrY);
                repaint();
            }
        });
    }
 
    private void scale(double sx, double sy, double sz) {
        for (double[] node : nodes) {
            node[0] *= sx;
            node[1] *= sy;
            node[2] *= sz;
        }
    }
 
    private void rotateCube(double angleX, double angleY) {
        double sinX = sin(angleX);
        double cosX = cos(angleX);
 
        double sinY = sin(angleY);
        double cosY = cos(angleY);
 
        for (double[] node : nodes) {
            double x = node[0];
            double y = node[1];
            double z = node[2];
 
            node[0] = x * cosX - z * sinX;
            node[2] = z * cosX + x * sinX;
 
            z = node[2];
 
            node[1] = y * cosY - z * sinY;
            node[2] = z * cosY + y * sinY;
        }
    }
 
    void drawCube( g) {
        g.translate(getWidth() / 2, getHeight() / 2);
 
        for (int[] edge : edges) {
            double[] xy1 = nodes[edge[0]];
            double[] xy2 = nodes[edge[1]];
            g.drawLine((int) round(xy1[0]), (int) round(xy1[1]),
                    (int) round(xy2[0]), (int) round(xy2[1]));
        }
 
        for (double[] node : nodes) {
            g.fillOval((int) round(node[0]) - 4, (int) round(node[1]) - 4, 8, 8);
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawCube(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new Cuboid(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.awt.*;
import java.awt.event.ActionEvent;
import static java.lang..*;
import javax.swing.*;
 
public class RotatingCube extends  {
    double[][] nodes = {{-1, -1, -1}, {-1, -1, 1}, {-1, 1, -1}, {-1, 1, 1},
    {1, -1, -1}, {1, -1, 1}, {1, 1, -1}, {1, 1, 1}};
 
    int[][] edges = {{0, 1}, {1, 3}, {3, 2}, {2, 0}, {4, 5}, {5, 7}, {7, 6},
    {6, 4}, {0, 4}, {1, 5}, {2, 6}, {3, 7}};
 
    public RotatingCube() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
 
        scale(100);
        rotateCube(PI / 4, atan(sqrt(2)));
 
        new (17, ( e) -> {
            rotateCube(PI / 180, 0);
            repaint();
        }).start();
    }
 
    final void scale(double s) {
        for (double[] node : nodes) {
            node[0] *= s;
            node[1] *= s;
            node[2] *= s;
        }
    }
 
    final void rotateCube(double angleX, double angleY) {
        double sinX = sin(angleX);
        double cosX = cos(angleX);
 
        double sinY = sin(angleY);
        double cosY = cos(angleY);
 
        for (double[] node : nodes) {
            double x = node[0];
            double y = node[1];
            double z = node[2];
 
            node[0] = x * cosX - z * sinX;
            node[2] = z * cosX + x * sinX;
 
            z = node[2];
 
            node[1] = y * cosY - z * sinY;
            node[2] = z * cosY + y * sinY;
        }
    }
 
    void drawCube( g) {
        g.translate(getWidth() / 2, getHeight() / 2);
 
        for (int[] edge : edges) {
            double[] xy1 = nodes[edge[0]];
            double[] xy2 = nodes[edge[1]];
            g.drawLine((int) round(xy1[0]), (int) round(xy1[1]),
                    (int) round(xy2[0]), (int) round(xy2[1]));
        }
 
        for (double[] node : nodes) 
            g.fillOval((int) round(node[0]) - 4, (int) round(node[1]) - 4, 8, 8);        
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawCube(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new RotatingCube(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.util.Arrays;
import java.util.Random;
 
public class DutchNationalFlag {
    enum DutchColors {
        RED, WHITE, BLUE
    }
 
    public static void main([] args) {
        DutchColors[] balls = new DutchColors[12];
 
        DutchColors[] values = DutchColors.values();
         rand = new ();
        for (int i = 0; i < balls.length; i++)
            balls[i] = values[rand.nextInt(values.length)];
 
        .out.println(strv + .toString(balls));
 
        dutchNationalFlagSort(balls);
 
        .out.println(strv + .toString(balls));
    }
 
    private static void dutchNationalFlagSort(DutchColors[] items) {
        int lo = 0, mid = 0, hi = items.length - 1;
 
        while (mid <= hi)
            switch (items[mid]) {
                case RED:
                    swap(items, lo++, mid++);
                    break;
                case WHITE:
                    mid++;
                    break;
                case BLUE:
                    swap(items, mid, hi--);
                    break;
            }
    }
 
    private static void swap(DutchColors[] arr, int a, int b) {
        DutchColors tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}"
"import java.util.LinkedList;
 
public static void main(){
    LinkedList<String> LL = new LinkedList<String>();
    traverse(LL.iterator());
    traverse(LL.descendingIterator());
}
 
private static void traverse(Iterator<String> iter){
    while(iter.hasNext()){
        iter.next();
    }
}"
"import java.awt.*;
import java.awt.event.*;
import static java.lang..*;
import java.time.LocalTime;
import javax.swing.*;
 
class Clock extends  {
 
    final float degrees06 = (float) (PI / 30);
    final float degrees30 = degrees06 * 5;
    final float degrees90 = degrees30 * 3;
 
    final int size = 590;
    final int spacing = 40;
    final int diameter = size - 2 * spacing;
    final int cx = diameter / 2 + spacing;
    final int cy = diameter / 2 + spacing;
 
    public Clock() {
        setPreferredSize(new (size, size));
        setBackground(.white);
 
        new (1000, ( e) -> {
            repaint();
        }).start();
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawFace(g);
 
        final LocalTime time  = LocalTime.now();
        int hour = time.getHour();
        int minute = time.getMinute();
        int second = time.getSecond();
 
        float angle = degrees90 - (degrees06 * second);
        drawHand(g, angle, diameter / 2 - 30, .red);
 
        float minsecs = (minute + second / 60.0F);
        angle = degrees90 - (degrees06 * minsecs);
        drawHand(g, angle, diameter / 3 + 10, .black);
 
        float hourmins = (hour + minsecs / 60.0F);
        angle = degrees90 - (degrees30 * hourmins);
        drawHand(g, angle, diameter / 4 + 10, .black);
    }
 
    private void drawFace( g) {
        g.setStroke(new (2));
        g.setColor(.white);
        g.fillOval(spacing, spacing, diameter, diameter);
        g.setColor(.black);
        g.drawOval(spacing, spacing, diameter, diameter);
    }
 
    private void drawHand( g, float angle, int radius,  color) {
        int x = cx + (int) (radius * cos(angle));
        int y = cy - (int) (radius * sin(angle));
        g.setColor(color);
        g.drawLine(cx, cy, x, y);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new Clock(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.awt.Color;
import java.awt.Graphics;
import java.util.*;
import javax.swing.JFrame;
 
public class DragonCurve extends  {
 
    private List<Integer> turns;
    private double startingAngle, side;
 
    public DragonCurve(int iter) {
        super(strv);
        setBounds(100, 100, 800, 600);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        turns = getSequence(iter);
        startingAngle = -iter * (.PI / 4);
        side = 400 / .pow(2, iter / 2.);
    }
 
    public List<Integer> getSequence(int iterations) {
        List<Integer> turnSequence = new ArrayList<Integer>();
        for (int i = 0; i < iterations; i++) {
            List<Integer> copy = new ArrayList<Integer>(turnSequence);
            .reverse(copy);
            turnSequence.add(1);
            for ( turn : copy) {
                turnSequence.add(-turn);
            }
        }
        return turnSequence;
    }
 
    @Override
    public void paint( g) {
        g.setColor(.BLACK);
        double angle = startingAngle;
        int x1 = 230, y1 = 350;
        int x2 = x1 + (int) (.cos(angle) * side);
        int y2 = y1 + (int) (.sin(angle) * side);
        g.drawLine(x1, y1, x2, y2);
        x1 = x2;
        y1 = y2;
        for ( turn : turns) {
            angle += turn * (.PI / 2);
            x2 = x1 + (int) (.cos(angle) * side);
            y2 = y1 + (int) (.sin(angle) * side);
            g.drawLine(x1, y1, x2, y2);
            x1 = x2;
            y1 = y2;
        }
    }
 
    public static void main([] args) {
        new DragonCurve(14).setVisible(true);
    }
}"
"using ;
 
namespace Sphere {
    internal class Program {
        private const string Shades = strv;
        private static readonly double[] Light = {30, 30, -50};
 
        private static void Normalize(double[] v) {
            double len = .Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            v[0] /= len;
            v[1] /= len;
            v[2] /= len;
        }
 
        private static double Dot(double[] x, double[] y) {
            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];
            return d < 0 ? -d : 0;
        }
 
        public static void DrawSphere(double r, double k, double ambient) {
            var vec = new double[3];
            for(var i = (int).Floor(-r); i <= (int).Ceiling(r); i++) {
                double x = i + .5;
                for(var j = (int).Floor(-2*r); j <= (int).Ceiling(2*r); j++) {
                    double y = j/2.0 + .5;
                    if(x*x + y*y <= r*r) {
                        vec[0] = x;
                        vec[1] = y;
                        vec[2] = .Sqrt(r*r - x*x - y*y);
                        Normalize(vec);
                        double b = .Pow(Dot(Light, vec), k) + ambient;
                        int intensity = (b <= 0)
                                            ? Shades.Length - 2
                                            : (int).Max((1 - b)*(Shades.Length - 1), 0);
                        Console.Write(Shades[intensity]);
                    }
                    else
                        Console.Write(' ');
                }
                Console.WriteLine();
            }
        }
 
        private static void Main() {
            Normalize(Light);
            DrawSphere(6, 4, .1);
            DrawSphere(10, 2, .4);
            Console.ReadKey();
        }
    }
}public class Sphere{
    static char[] shades = {'.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@'};
 
    static double[] light = { 30, 30, -50 };
    private static void normalize(double[] v){
        double len = .sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
        v[0] /= len; v[1] /= len; v[2] /= len;
    }
 
    private static double dot(double[] x, double[] y){
        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];
        return d < 0 ? -d : 0;
    }
 
    public static void drawSphere(double R, double k, double ambient){
        double[] vec = new double[3];
        for(int i = (int).floor(-R); i <= (int).ceil(R); i++){
            double x = i + .5;
            for(int j = (int).floor(-2 * R); j <= (int).ceil(2 * R); j++){
                double y = j / 2. + .5;
                if(x * x + y * y <= R * R) {
                    vec[0] = x;
                    vec[1] = y;
                    vec[2] = .sqrt(R * R - x * x - y * y);
                    normalize(vec);
                    double b = .pow(dot(light, vec), k) + ambient;
                    int intensity = (b <= 0) ?
                                shades.length - 2 :
                                (int).max((1 - b) * (shades.length - 1), 0);
                    .out.print(shades[intensity]);
                } else
                    .out.print(' ');
            }
            .out.println();
        }
    }
 
    public static void main([] args){
        normalize(light);
        drawSphere(20, 4, .1);
        drawSphere(10, 2, .4);
    }
}"
"public class Node<T> {
   private T element;
   private Node<T> next, prev;
 
   public Node<T>(){
      next = prev = element = null;
   }
 
   public Node<T>(Node<T> n, Node<T> p, T elem){
      next = n;
      prev = p;
      element = elem;
   }
 
   public void setNext(Node<T> n){
      next = n;
   }
 
   public Node<T> getNext(){
      return next;
   }
 
   public void setElem(T elem){
      element = elem;
   }
 
   public T getElem(){
      return element;
   }
 
   public void setNext(Node<T> n){
      next = n;
   }
 
   public Node<T> setPrev(Node<T> p){
      prev = p;
   }
 
   public getPrev(){
      return prev;
   }
}"
"public class DotProduct {
 
	public static void main([] args) {
		double[] a = {1, 3, -5};
		double[] b = {4, -2, -1};
 
		.out.println(dotProd(a,b));
	}
 
	public static double dotProd(double[] a, double[] b){
		if(a.length != b.length){
			throw new (strv);
		}
		double sum = 0;
		for(int i = 0; i < a.length; i++){
			sum += a[i] * b[i];
		}
		return sum;
	}
}"
"import java.net.InetAddress;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.UnknownHostException;
 
class DnsQuery {
    public static void main([] args) {
        try {
            [] ipAddr = .getAllByName(strv);
            for(int i=0; i < ipAddr.length ; i++) {
                if (ipAddr[i] instanceof Inet4Address) {
                    .out.println(strv + ipAddr[i].getHostAddress());
                } else if (ipAddr[i] instanceof Inet6Address) {
                    .out.println(strv + ipAddr[i].getHostAddress());
                }
            }
        } catch ( uhe) {
            .err.println(strv);
        }
    }
}
 "
"/** * This is a class documentation comment. This text shows at the top of the page for this class * @author Joe Schmoe */
public class Doc{
   /**    * This is a field comment for a variable    */
   private  field;
 
   /**    * This is a method comment. It has parameter tags (param), an exception tag (throws),    * and a return value tag (return).    *    * @param num a number with the variable name strv    * @throws BadException when something bad happens    * @return another number    */
   public int method(long num) throws BadException{
      //...code here
   }
}"
"import java.util.Calendar;
import java.util.GregorianCalendar;
 
public class DiscordianDate {
    final static [] seasons = {strv, strv, strv,
        strv, strv};
 
    final static [] weekday = {strv, strv, strv,
        strv, strv};
 
    final static [] apostle = {strv, strv, strv,
        strv, strv};
 
    final static [] holiday = {strv, strv, strv,
        strv, strv};
 
    public static  discordianDate(final  date) {
        int y = date.get(.YEAR);
        int yold = y + 1166;
        int dayOfYear = date.get(.DAY_OF_YEAR);
 
        if (date.isLeapYear(y)) {
            if (dayOfYear == 60)
                return strv + yold;
            else if (dayOfYear > 60)
                dayOfYear--;
        }
 
        dayOfYear--;
 
        int seasonDay = dayOfYear % 73 + 1;
        if (seasonDay == 5)
            return apostle[dayOfYear / 73] + strv + yold;
        if (seasonDay == 50)
            return holiday[dayOfYear / 73] + strv + yold;
 
         season = seasons[dayOfYear / 73];
         dayOfWeek = weekday[dayOfYear % 5];
 
        return .format(strv,
                dayOfWeek, seasonDay, season, yold);
    }
 
    public static void main([] args) {
 
        .out.println(discordianDate(new ()));
 
        test(2010, 6, 22, strv);
        test(2012, 1, 28, strv);
        test(2012, 1, 29, strv);
        test(2012, 2, 1, strv);
        test(2010, 0, 5, strv);
        test(2011, 4, 3, strv);
        test(2015, 9, 19, strv);
    }
 
    private static void test(int y, int m, int d, final  result) {
        assert (discordianDate(new (y, m, d)).equals(result));
    }
}"
" 
package diningphilosophers;
 
import java.util.ArrayList;
import java.util.Random;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
 
enum PhilosopherState { Get, Eat, Pon }
 
class Fork {
    public static final int ON_TABLE = -1;
    static int instances = 0;
    public int id;
    public AtomicInteger holder = new AtomicInteger(ON_TABLE);
 
    Fork() { id = instances++; }
}
 
class Philosopher implements  {
    static final int maxWaitMs = 100;                          

    static AtomicInteger token = new AtomicInteger(0);
    static int instances = 0;
    static  rand = new ();
    AtomicBoolean end = new AtomicBoolean(false);
    int id;
    PhilosopherState state = PhilosopherState.Get;
    Fork left;
    Fork right;
    int timesEaten = 0;
 
    Philosopher() {
        id = instances++;
        left = Main.forks.get(id);
        right = Main.forks.get((id+1)%Main.philosopherCount);
    }
 
    void sleep() { try { .sleep(rand.nextInt(maxWaitMs)); }
        catch ( ex) {} }
 
    void waitForFork(Fork fork) {
        do {
            if (fork.holder.get() == Fork.ON_TABLE) {
                fork.holder.set(id);                

                return;
            } else {                                

                sleep();                            

            }
        } while (true);
    }
 
    public void run() {
        do {
            if (state == PhilosopherState.Pon) {    

                state = PhilosopherState.Get;       

            } else { 

                if (token.get() == id) {            

                    waitForFork(left);
                    waitForFork(right);             

                    token.set((id+2)% Main.philosopherCount);
                    state = PhilosopherState.Eat;
                    timesEaten++;
                    sleep();                        

                    left.holder.set(Fork.ON_TABLE);
                    right.holder.set(Fork.ON_TABLE);
                    state = PhilosopherState.Pon;   

                    sleep();
                } else {                    

                    sleep();
                }
            }
        } while (!end.get());
    }
}
 
public class Main {
    static final int philosopherCount = 5; 

    static final int runSeconds = 15;
    static ArrayList<Fork> forks = new ArrayList<Fork>();
    static ArrayList<Philosopher> philosophers = new ArrayList<Philosopher>();
 
    public static void main([] args) {
        for (int i = 0 ; i < philosopherCount ; i++) forks.add(new Fork());
        for (int i = 0 ; i < philosopherCount ; i++)
            philosophers.add(new Philosopher());
        for (Philosopher p : philosophers) new (p).start();
        long endTime = .currentTimeMillis() + (runSeconds * 1000);
 
        do {                                                    

            StringBuilder sb = new StringBuilder(strv);
 
            for (Philosopher p : philosophers) {
                sb.append(p.state.toString());
                sb.append(strv);            

            }                              

 
            sb.append(strv);
 
            for (Fork f : forks) {
                int holder = f.holder.get();
                sb.append(holder==-1?strv:.format(strv,holder));
                sb.append(strv);
            }
 
            .out.println(sb.toString());
            try {.sleep(1000);} catch ( ex) {}
        } while (.currentTimeMillis() < endTime);
 
        for (Philosopher p : philosophers) p.end.set(true);
        for (Philosopher p : philosophers)
            .out.printf(""P%02d: ate %,d times, %,d/sec"",
                p.id, p.timesEaten, p.timesEaten/runSeconds);
    }
}
 "
"import java.util.*;
 
class DinesmanMultipleDwelling
{
  private static void generatePermutations([] apartmentDwellers, Set<String> set,  curPermutation)
  {
    for ( s : apartmentDwellers)
    {
      if (!curPermutation.contains(s))
      {
         nextPermutation = curPermutation + s;
        if (nextPermutation.length() == apartmentDwellers.length)
          set.add(nextPermutation);
        else
          generatePermutations(apartmentDwellers, set, nextPermutation);
      }
    }
    return;
  }
 
  private static boolean topFloor( permutation,  person)
  {  return permutation.endsWith(person);  }
 
  private static boolean bottomFloor( permutation,  person)
  {  return permutation.startsWith(person);  }
 
  public static boolean livesAbove( permutation,  upperPerson,  lowerPerson)
  {  return permutation.indexOf(upperPerson) > permutation.indexOf(lowerPerson);  }
 
  public static boolean adjacent( permutation,  person1,  person2)
  {  return (.abs(permutation.indexOf(person1) - permutation.indexOf(person2)) == 1);  }
 
  private static boolean isPossible( s)
  {
    

    if (topFloor(s, strv))
      return false;
    if (bottomFloor(s, strv))
      return false;
    if (topFloor(s, strv) || bottomFloor(s, strv))
      return false;
    if (!livesAbove(s, strv, strv))
      return false;
    if (adjacent(s, strv, strv))
      return false;
    if (adjacent(s, strv, strv))
      return false;
    return true;
  }
 
  public static void main([] args)
  {
    Set<String> set = new HashSet<String>();
    generatePermutations(new [] { strv, strv, strv, strv, strv }, set, strv);
    for (Iterator<String> iterator = set.iterator(); iterator.hasNext(); )
    {
       permutation = iterator.next();
      if (!isPossible(permutation))
        iterator.remove();
    }
    for ( s : set)
      .out.println(strv + s);
  }
}"
"import java.math.BigInteger;
 
class DigitalRoot
{
  public static int[] calcDigitalRoot( number, int base)
  {
     bi = new (number, base);
    int additivePersistence = 0;
    if (bi.signum() < 0)
      bi = bi.negate();
     biBase = .valueOf(base);
    while (bi.compareTo(biBase) >= 0)
    {
      number = bi.toString(base);
      bi = .ZERO;
      for (int i = 0; i < number.length(); i++)
        bi = bi.add(new (number.substring(i, i + 1), base));
      additivePersistence++;
    }
    return new int[] { additivePersistence, bi.intValue() };
  }
 
  public static void main([] args)
  {
    for ( arg : args)
    {
      int[] results = calcDigitalRoot(arg, 10);
      .out.println(arg + strv + results[0] + strv + results[1]);
    }
  }
}"
"import java.util.Random;
 
public class Dice{
	private static int roll(int nDice, int nSides){
		int sum = 0;
		 rand = new ();
		for(int i = 0; i < nDice; i++){
			sum += rand.nextInt(nSides) + 1;
		}
		return sum;
	}
 
	private static int diceGame(int p1Dice, int p1Sides, int p2Dice, int p2Sides, int rolls){
		int p1Wins = 0;
		for(int i = 0; i < rolls; i++){
			int p1Roll = roll(p1Dice, p1Sides);
			int p2Roll = roll(p2Dice, p2Sides);
			if(p1Roll > p2Roll) p1Wins++;
		}
		return p1Wins;
	}
 
	public static void main([] args){
		int p1Dice = 9; int p1Sides = 4;
		int p2Dice = 6; int p2Sides = 6;
		int rolls = 10000;
		int p1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);
		.out.println(rolls + strv + p1Dice + strv + p1Sides + strv + p2Dice + strv + p2Sides);
		.out.println(strv + (100.0 * p1Wins / rolls) + strv);
 
		.out.println();
 
		p1Dice = 5; p1Sides = 10;
		p2Dice = 6; p2Sides = 7;
		rolls = 10000;
		p1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);
		.out.println(rolls + strv + p1Dice + strv + p1Sides + strv + p2Dice + strv + p2Sides);
		.out.println(strv + (100.0 * p1Wins / rolls) + strv);
 
		.out.println();
 
		p1Dice = 9; p1Sides = 4;
		p2Dice = 6; p2Sides = 6;
		rolls = 1000000;
		p1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);
		.out.println(rolls + strv + p1Dice + strv + p1Sides + strv + p2Dice + strv + p2Sides);
		.out.println(strv + (100.0 * p1Wins / rolls) + strv);
 
		.out.println();
 
		p1Dice = 5; p1Sides = 10;
		p2Dice = 6; p2Sides = 7;
		rolls = 1000000;
		p1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);
		.out.println(rolls + strv + p1Dice + strv + p1Sides + strv + p2Dice + strv + p2Sides);
		.out.println(strv + (100.0 * p1Wins / rolls) + strv);
	}
}"
"import java.util.*;
 
public class MultiplicativeDigitalRoot {
 
    public static void main([] args) {
 
        .out.println(strv);
        for (long n : new long[]{123321, 7739, 893, 899998}) {
            long[] a = multiplicativeDigitalRoot(n);
            .out.printf(strv, a[0], a[1], a[2]);
        }
 
        .out.println();
 
        Map<, List<Long>> table = new HashMap<>();
        for (long i = 0; i < 10; i++)
            table.put(i, new ArrayList<>());
 
        for (long cnt = 0, n = 0; cnt < 10;) {
            long[] res = multiplicativeDigitalRoot(n++);
            List<Long> list = table.get(res[1]);
            if (list.size() < 5) {
                list.add(res[0]);
                cnt = list.size() == 5 ? cnt + 1 : cnt;
            }
        }
 
        .out.println(strv);
        table.forEach((key, lst) -> {
            .out.printf(strv, key);
            lst.forEach(e -> .out.printf(strv, e));
            .out.println();
        });
    }
 
    public static long[] multiplicativeDigitalRoot(long n) {
        int mp = 0;
        long mdr = n;
        while (mdr > 9) {
            long m = mdr;
            long total = 1;
            while (m > 0) {
                total *= m % 10;
                m /= 10;
            }
            mdr = total;
            mp++;
        }
        return new long[]{n, mdr, mp};
    }
}"
"import java.io.IOExeception;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.UnknownHostException;
 
public class SingletonApp
{
	private static final int PORT = 12345;		

	private static  s;
 
	

	{
		try {
			s = new (PORT, 10, .getLocalHost());
		} catch ( e) {
			

		} catch ( e) {
			

			.exit(0);
		}
	}
	

}"
" 
import java.io.*;
import java.util.*;
 
public class Dijkstra {
   private static final Graph.Edge[] GRAPH = {
      new Graph.Edge(strv, strv, 7),
      new Graph.Edge(strv, strv, 9),
      new Graph.Edge(strv, strv, 14),
      new Graph.Edge(strv, strv, 10),
      new Graph.Edge(strv, strv, 15),
      new Graph.Edge(strv, strv, 11),
      new Graph.Edge(strv, strv, 2),
      new Graph.Edge(strv, strv, 6),
      new Graph.Edge(strv, strv, 9),
   };
   private static final  START = strv;
   private static final  END = strv;
 
   public static void main([] args) {
      Graph g = new Graph(GRAPH);
      g.dijkstra(START);
      g.printPath(END);
      //g.printAllPaths();
   }
}
 
class Graph {
   private final Map<, Vertex> graph; 

 
   /** One edge of the graph (only used by Graph constructor) */
   public static class Edge {
      public final  v1, v2;
      public final int dist;
      public Edge( v1,  v2, int dist) {
         this.v1 = v1;
         this.v2 = v2;
         this.dist = dist;
      }
   }
 
   /** One vertex of the graph, complete with mappings to neighbouring vertices */
  public static class Vertex implements Comparable<Vertex>{
	public final  name;
	public int dist = .MAX_VALUE; 

	public Vertex previous = null;
	public final Map<Vertex, Integer> neighbours = new HashMap<>();
 
	public Vertex( name)
	{
		this.name = name;
	}
 
	private void printPath()
	{
		if (this == this.previous)
		{
			.out.printf(strv, this.name);
		}
		else if (this.previous == null)
		{
			.out.printf(strv, this.name);
		}
		else
		{
			this.previous.printPath();
			.out.printf(strv, this.name, this.dist);
		}
	}
 
	public int compareTo(Vertex other)
	{
		if (dist == other.dist)
			return name.compareTo(other.name);
 
		return .compare(dist, other.dist);
	}
 
	@Override public  toString()
	{
		return strv + name + strv + dist + strv;
	}
}
 
   /** Builds a graph from a set of edges */
   public Graph(Edge[] edges) {
      graph = new HashMap<>(edges.length);
 
      //one pass to find all vertices
      for (Edge e : edges) {
         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
      }
 
      //another pass to set neighbouring vertices
      for (Edge e : edges) {
         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph
      }
   }
 
   /** Runs dijkstra using a specified source vertex */ 
   public void dijkstra( startName) {
      if (!graph.containsKey(startName)) {
         .err.printf(""Graph doesn't contain start vertex %s"", startName);
         return;
      }
      final Vertex source = graph.get(startName);
      NavigableSet<Vertex> q = new TreeSet<>();
 
      

      for (Vertex v : graph.values()) {
         v.previous = v == source ? source : null;
         v.dist = v == source ? 0 : .MAX_VALUE;
         q.add(v);
      }
 
      dijkstra(q);
   }
 
   /** Implementation of dijkstra's algorithm using a binary heap. */
   private void dijkstra(final NavigableSet<Vertex> q) {      
      Vertex u, v;
      while (!q.isEmpty()) {
 
         u = q.pollFirst(); 

         if (u.dist == .MAX_VALUE) break; 

 
         //look at distances to each neighbour
         for (.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
            v = a.getKey(); //the neighbour in this iteration
 
            final int alternateDist = u.dist + a.getValue();
            if (alternateDist < v.dist) { 

               q.remove(v);
               v.dist = alternateDist;
               v.previous = u;
               q.add(v);
            } 
         }
      }
   }
 
   /** Prints a path from the source to the specified vertex */
   public void printPath( endName) {
      if (!graph.containsKey(endName)) {
         .err.printf(""Graph doesn't contain end vertex %s"", endName);
         return;
      }
 
      graph.get(endName).printPath();
      .out.println();
   }
   /** Prints the path from the source to every vertex (output order is not guaranteed) */
   public void printAllPaths() {
      for (Vertex v : graph.values()) {
         v.printPath();
         .out.println();
      }
   }
}"
"public boolean isNumeric( input) {
  try {
    .parseInt(input);
    return true;
  }
  catch ( e) {
    

    return false;
  }
}private static final boolean isNumeric(final  s) {
  if (s == null || s.isEmpty()) return false;
  for (int x = 0; x < s.length(); x++) {
    final char c = s.charAt(x);
    if (x == 0 && (c == '-')) continue;  

    if ((c >= '0') && (c <= '9')) continue;  

    return false; 

  }
  return true; 

}public static boolean isNumeric( inputData) {
  return inputData.matches(""[-+]?d+(.d+)?"");
}public static boolean isNumeric( inputData) {
   formatter = .getInstance();
   pos = new (0);
  formatter.parse(inputData, pos);
  return inputData.length() == pos.getIndex();
}public static boolean isNumeric( inputData) {
  Scanner sc = new Scanner(inputData);
  return sc.hasNextInt();
}"
"public static boolean infinity(double numer, double denom){
	return .isInfinite(numer/denom);
}public static boolean except(double numer, double denom){
	try{
		int dummy = (int)numer / (int)denom;//ArithmeticException is only thrown from integer math
		return false;
	}catch( e){return true;}
}"
"import java.io.File;
public class FileDeleteTest {
   public static boolean deleteFile( filename) {
       boolean exists = new (filename).delete();
       return exists;
   }
   public static void test( type,  filename) {
       .out.println(strv + type + strv + filename + 
           (deleteFile(filename) ? strv : strv)
       );
   }
   public static void main( args[]) {
        test(strv, strv);
        test(strv, .seperator + strv);
        test(strv, strv);
        test(strv, .seperator + strv + .seperator);
   }
}"
"interface Thingable {
     thing();
}
 
class Delegator {
    public Thingable delegate;
 
    public  operation() {
        if (delegate == null)
            return strv;
        else
            return delegate.thing();
    }
}
 
class  implements Thingable {
    public  thing() {
        return strv;
    }
}
 




public class DelegateExample {
    public static void main([] args) {
        

        Delegator a = new Delegator();
        assert a.operation().equals(strv);
 
        

         d = new ();
        a.delegate = d;
        assert a.operation().equals(strv);
 
        

        a.delegate = new Thingable() {
                public  thing() {
                    return strv;
                }
            };
        assert a.operation().equals(strv);
    }
}package delegate;
 
@FunctionalInterface
public interface Thingable {
  public  thing();
}package delegate;
 
import java.util.Optional;
 
public interface Delegator {
  public Thingable delegate();
  public Delegator delegate(Thingable thingable);
 
  public static Delegator new_() {
    return $Delegator.new_();
  }
 
  public default  operation() {
    return Optional.ofNullable(delegate())
      .map(Thingable::thing)
      .orElse(strv)
    ;
  }
}package delegate;
 
@FunctionalInterface
/* package */ interface $Delegator extends Delegator {
  @Override
  public default Delegator delegate(Thingable thingable) {
    return new_(thingable);
  }
 
  public static $Delegator new_() {
    return new_(() -> null);
  }
 
  public static $Delegator new_(Thingable thingable) {
    return () -> thingable;
  }
}package delegate;
 
public final class  implements Thingable {
  @Override
  public  thing() {
    return strv;
  }
}package delegate;
 




public interface DelegateTest {
  public static  thingable() {
    return strv;
  }
 
  public static void main(... arguments) {
    

    Delegator d1 = Delegator.new_();
    assert d1.operation().equals(strv);
 
    

    Delegator d2 = d1.delegate(new ());
    assert d2.operation().equals(strv);
 
    

    Delegator d3 = d2.delegate(new Thingable() {
      @Override
      public  thing() {
        return strv;
      }
    });
    assert d3.operation().equals(strv);
 
    

    Delegator d4 = d3.delegate(DelegateTest::thingable);
    assert d4.operation().equals(strv);
 
    

    Delegator d5 = d4.delegate(() -> strv);
    assert d5.operation().equals(strv);
  }
}"
"import static java.lang..*;
import java.util.Arrays;
import java.util.function.BiFunction;
 
public class DemingsFunnel {
 
    public static void main([] args) {
        double[] dxs = {
            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,
            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,
            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,
            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,
            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,
            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,
            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,
            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,
            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,
            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,
            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,
            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,
            0.443, -0.521, -0.799, 0.087};
 
        double[] dys = {
            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,
            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,
            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,
            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,
            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,
            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,
            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,
            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,
            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,
            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,
            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,
            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,
            -0.947, -1.424, -0.542, -1.032};
 
        experiment(strv, dxs, dys, (z, dz) -> 0.0);
        experiment(strv, dxs, dys, (z, dz) -> -dz);
        experiment(strv, dxs, dys, (z, dz) -> -(z + dz));
        experiment(strv, dxs, dys, (z, dz) -> z + dz);
    }
 
    static void experiment( label, double[] dxs, double[] dys,
            BiFunction<, , Double> rule) {
 
        double[] resx = funnel(dxs, rule);
        double[] resy = funnel(dys, rule);
        .out.println(label);
        .out.printf(strv, mean(resx), mean(resy));
        .out.printf(strv, stdDev(resx), stdDev(resy));
        .out.println();
    }
 
    static double[] funnel(double[] input, BiFunction<, , Double> rule) {
        double x = 0;
        double[] result = new double[input.length];
 
        for (int i = 0; i < input.length; i++) {
            double rx = x + input[i];
            x = rule.apply(x, input[i]);
            result[i] = rx;
        }
        return result;
    }
 
    static double mean(double[] xs) {
        return .stream(xs).sum() / xs.length;
    }
 
    static double stdDev(double[] xs) {
        double m = mean(xs);
        return sqrt(.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);
    }
}"
"import java.util.Arrays;
 
public class Deconvolution1D {
    public static int[] deconv(int[] g, int[] f) {
        int[] h = new int[g.length - f.length + 1];
        for (int n = 0; n < h.length; n++) {
            h[n] = g[n];
            int lower = .max(n - f.length + 1, 0);
            for (int i = lower; i < n; i++)
                h[n] -= h[i] * f[n - i];
            h[n] /= f[0];
        }
        return h;
    }
 
    public static void main([] args) {
        int[] h = { -8, -9, -3, -1, -6, 7 };
        int[] f = { -3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1 };
        int[] g = { 24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96,
                96, 31, 55, 36, 29, -43, -7 };
 
        StringBuilder sb = new StringBuilder();
        sb.append(strv + .toString(h) + """");
        sb.append(strv + .toString(deconv(g, f)) + """");
        sb.append(strv + .toString(f) + """");
        sb.append(strv + .toString(deconv(g, h)) + """");
        .out.println(sb.toString());
    }
}"
"class BoundedIntOutOfBoundsException extends 
{
  public BoundedIntOutOfBoundsException(int v, int l, int u) {
    super(strv + v + strv + l + strv + u + strv);
  }
}
 
class BoundedInt {
  private int value;
  private int lower;
  private int upper;
 
  public BoundedInt(int l, int u) {
    lower = .min(l, u);
    upper = .max(l, u);
  }
 
  private boolean checkBounds(int v) {
    return (v >= this.lower) && (v <= this.upper);
  }
 
  public void assign(BoundedInt i) throws BoundedIntOutOfBoundsException {{
    assign(i.value()); //could still throw Exception if the other BoundedInt has different bounds
  }
 
  public void assign(int v) throws BoundedIntOutOfBoundsException {
    if ( checkBounds(v) ) {
      this.value = v;
    } else {
      throw new BoundedIntOutOfBoundsException(v, this.lower, this.upper);
    }
  }
 
  public int add(BoundedInt i) throws BoundedIntOutOfBoundsException {
    return add(i.value());
  }
 
  public int add(int i) throws BoundedIntOutOfBoundsException {
    if ( checkBounds(this.value + i) ) {
      this.value += i;
    }  else {
      throw new BoundedIntOutOfBoundsException(this.value + i, this.lower, this.upper);
    }
    return this.value;
  }
 
  public int value() {
    return this.value;
  }
}
 
 
public class Bounded {
  public static void main([] args) throws BoundedIntOutOfBoundsException {
    BoundedInt a = new BoundedInt(1, 10);
    BoundedInt b = new BoundedInt(1, 10);
 
    a.assign(6);
    try {
      b.assign(12);
    } catch ( e) {
      .out.println(e.getMessage());
    }
    b.assign(9);
    try {
      a.add(b.value());
    } catch ( e) {
      .out.println(e.getMessage());
    }
  }
}"
" 
 
import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.geometry.Point3D;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.shape.MeshView;
import javafx.scene.shape.TriangleMesh;
import javafx.scene.transform.Rotate;
import javafx.stage.Stage;
public class DeathStar extends Application {
 
	private static final int DIVISION = 200;

	float radius = 300;

 
	@Override
	public void start(Stage primaryStage) throws  {
		Point3D otherSphere = new Point3D(-radius, 0, -radius * 1.5);
		final TriangleMesh triangleMesh = createMesh(DIVISION, radius, otherSphere);
		MeshView a = new MeshView(triangleMesh);
 
		a.setTranslateY(radius);
		a.setTranslateX(radius);
		a.setRotationAxis(Rotate.Y_AXIS);
		Scene scene = new Scene(new (a));
//		uncomment if you want to move the other sphere
 
//		scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
//			Point3D sphere = otherSphere;
//
//			@Override
//			public void handle(KeyEvent e) {
//				KeyCode code = e.getCode();
//				switch (code) {
//				case UP:
//					sphere = sphere.add(0, -10, 0);
//					break;
//				case DOWN:
//					sphere = sphere.add(0, 10, 0);
//					break;
//				case LEFT:
//					sphere = sphere.add(-10, 0, 0);
//					break;
//				case RIGHT:
//					sphere = sphere.add(10, 0, 0);
//					break;
//				case W:
//					sphere = sphere.add(0, 0, 10);
//					break;
//				case S:
//					sphere = sphere.add(0, 0, -10);
//					break;
//				default:
//					return;
//				}
//				a.setMesh(createMesh(DIVISION, radius, sphere));
//
//			}
//		});
 
		primaryStage.setScene(scene);
		primaryStage.show();
	}
 
	static TriangleMesh createMesh(final int division, final float radius, final Point3D centerOtherSphere) {
		Rotate rotate = new Rotate(180, centerOtherSphere);
		final int div2 = division / 2;
 
		final int nPoints = division * (div2 - 1) + 2;
		final int nTPoints = (division + 1) * (div2 - 1) + division * 2;
		final int nFaces = division * (div2 - 2) * 2 + division * 2;
 
		final float rDiv = 1.f / division;
 
		float points[] = new float[nPoints * 3];
		float tPoints[] = new float[nTPoints * 2];
		int faces[] = new int[nFaces * 6];
 
		int pPos = 0, tPos = 0;
 
		for (int y = 0; y < div2 - 1; ++y) {
			float va = rDiv * (y + 1 - div2 / 2) * 2 * (float) .PI;
			float sin_va = (float) .sin(va);
			float cos_va = (float) .cos(va);
 
			float ty = 0.5f + sin_va * 0.5f;
			for (int i = 0; i < division; ++i) {
				double a = rDiv * i * 2 * (float) .PI;
				float hSin = (float) .sin(a);
				float hCos = (float) .cos(a);
				points[pPos + 0] = hSin * cos_va * radius;
				points[pPos + 2] = hCos * cos_va * radius;
				points[pPos + 1] = sin_va * radius;
 
				final Point3D point3D = new Point3D(points[pPos + 0], points[pPos + 1], points[pPos + 2]);
				double distance = centerOtherSphere.distance(point3D);
				if (distance <= radius) {
					Point3D subtract = centerOtherSphere.subtract(point3D);
					Point3D transform = rotate.transform(subtract);
					points[pPos + 0] = (float) transform.getX();
					points[pPos + 1] = (float) transform.getY();
					points[pPos + 2] = (float) transform.getZ();
 
				}
				tPoints[tPos + 0] = 1 - rDiv * i;
				tPoints[tPos + 1] = ty;
				pPos += 3;
				tPos += 2;
			}
			tPoints[tPos + 0] = 0;
			tPoints[tPos + 1] = ty;
			tPos += 2;
		}
 
		points[pPos + 0] = 0;
		points[pPos + 1] = -radius;
		points[pPos + 2] = 0;
		points[pPos + 3] = 0;
		points[pPos + 4] = radius;
		points[pPos + 5] = 0;
		pPos += 6;
 
		int pS = (div2 - 1) * division;
 
		float textureDelta = 1.f / 256;
		for (int i = 0; i < division; ++i) {
			tPoints[tPos + 0] = rDiv * (0.5f + i);
			tPoints[tPos + 1] = textureDelta;
			tPos += 2;
		}
 
		for (int i = 0; i < division; ++i) {
			tPoints[tPos + 0] = rDiv * (0.5f + i);
			tPoints[tPos + 1] = 1 - textureDelta;
			tPos += 2;
		}
 
		int fIndex = 0;
		for (int y = 0; y < div2 - 2; ++y) {
			for (int x = 0; x < division; ++x) {
				int p0 = y * division + x;
				int p1 = p0 + 1;
				int p2 = p0 + division;
				int p3 = p1 + division;
 
				int t0 = p0 + y;
				int t1 = t0 + 1;
				int t2 = t0 + division + 1;
				int t3 = t1 + division + 1;
 
				

				faces[fIndex + 0] = p0;
				faces[fIndex + 1] = t0;
				faces[fIndex + 2] = p1 % division == 0 ? p1 - division : p1;
				faces[fIndex + 3] = t1;
				faces[fIndex + 4] = p2;
				faces[fIndex + 5] = t2;
				fIndex += 6;
 
				

				faces[fIndex + 0] = p3 % division == 0 ? p3 - division : p3;
				faces[fIndex + 1] = t3;
				faces[fIndex + 2] = p2;
				faces[fIndex + 3] = t2;
				faces[fIndex + 4] = p1 % division == 0 ? p1 - division : p1;
				faces[fIndex + 5] = t1;
				fIndex += 6;
			}
		}
 
		int p0 = pS;
		int tB = (div2 - 1) * (division + 1);
		for (int x = 0; x < division; ++x) {
			int p2 = x, p1 = x + 1, t0 = tB + x;
			faces[fIndex + 0] = p0;
			faces[fIndex + 1] = t0;
			faces[fIndex + 2] = p1 == division ? 0 : p1;
			faces[fIndex + 3] = p1;
			faces[fIndex + 4] = p2;
			faces[fIndex + 5] = p2;
			fIndex += 6;
		}
 
		p0 = p0 + 1;
		tB = tB + division;
		int pB = (div2 - 2) * division;
 
		for (int x = 0; x < division; ++x) {
			int p1 = pB + x, p2 = pB + x + 1, t0 = tB + x;
			int t1 = (div2 - 2) * (division + 1) + x, t2 = t1 + 1;
			faces[fIndex + 0] = p0;
			faces[fIndex + 1] = t0;
			faces[fIndex + 2] = p1;
			faces[fIndex + 3] = t1;
			faces[fIndex + 4] = p2 % division == 0 ? p2 - division : p2;
			faces[fIndex + 5] = t2;
			fIndex += 6;
		}
 
		TriangleMesh m = new TriangleMesh();
		m.getPoints().setAll(points);
		m.getTexCoords().setAll(tPoints);
		m.getFaces().setAll(faces);
 
		return m;
	}
 
	public static void main([] args) {
 
		launch(args);
	}
 
}
 "
"import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
 
public class Yuletide{
	public static void main([] args) {
		for(int i = 2008;i<=2121;i++){
			 cal = new (i, .DECEMBER,
					25);
			if(cal.get(.DAY_OF_WEEK)==.SUNDAY){
				.out.println(cal.getTime());
			}
		}
	}
}"
"import java.util.Date;
import java.text.SimpleDateFormat;
public class DateManip{
    public static void main([] args) throws {
	 dateStr = strv;
 
	 sdf = new (strv);
 
	 date = sdf.parse(dateStr);
 
	date.setTime(date.getTime() + 43200000l);
 
	.out.println(sdf.format(date));
    }
 
}"
" 
import java.util.Arrays;
 
public class Shuffler {
 
	private int seed;
 
	private [] deck = {
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
			strv, strv, strv, strv,
	};
 
	private int random() {
		seed = (214013 * seed + 2531011) & .MAX_VALUE;
		return seed >> 16;
	}
 
	//shuffled cards go to the end
	private [] getShuffledDeck() {
		[] deck = .copyOf(this.deck, this.deck.length);
		for(int i = deck.length - 1; i > 0; i--) {
			int r = random() % (i + 1);
			 card = deck[r];
			deck[r] = deck[i];
			deck[i] = card;
		}
		return deck;
	}
 
	//deal from end first
	public void dealGame(int seed) {
		this.seed = seed;
		[] shuffledDeck = getShuffledDeck();
		for(int count = 1, i = shuffledDeck.length - 1; i >= 0; count++, i--) {
			.out.print(shuffledDeck[i]);
			if(count % 8 == 0) {
				.out.println();
			} else {
				.out.print(strv);
			}
		}
		.out.println();
	}
 
	public static void main([] args) {
		Shuffler s = new Shuffler();
		s.dealGame(1);
		.out.println();
		s.dealGame(617);
	}
 
}
 "
"import java.util.function.*;
import static java.util.stream.IntStream.*;
 
public class CycleDetection {
 
    public static void main([] args) {
        brent(i -> (i * i + 1) % 255, 3);
    }
 
    static void brent(IntUnaryOperator f, int x0) {
        int cycleLength;
        int hare = x0;
        FOUND:
        for (int power = 1; ; power *= 2) {
            int tortoise = hare;
            for (int i = 1; i <= power; i++) {
                hare = f.applyAsInt(hare);
                 if (tortoise == hare) {
                    cycleLength = i;
                    break FOUND;
                }
            }
        }
 
        hare = x0;
        for (int i = 0; i < cycleLength; i++)
            hare = f.applyAsInt(hare);
 
        int cycleStart = 0;
        for (int tortoise = x0; tortoise != hare; cycleStart++) {
            tortoise = f.applyAsInt(tortoise);
            hare = f.applyAsInt(hare);
        }
 
        printResult(x0, f, cycleLength, cycleStart);
    }
 
    static void printResult(int x0, IntUnaryOperator f, int len, int start) {
        .out.printf(strv, len);
        iterate(x0, f).skip(start).limit(len)
                .forEach(n -> .out.printf(strv, n));
    }
}"
" 
Datetime dtNow = datetime.now();
 strDt1 = dtNow.format('yyyy-MM-dd');
 strDt2 = dtNow.format('EEEE, MMMM dd, yyyy');
system.debug(strDt1); 

system.debug(strDt2); //strv
 import java.util.Calendar;
import java.util.GregorianCalendar;
import java.text.DateFormatSymbols;
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
public class Dates
{
 public static void main(final [] args)
 {
   now = new (); //months are 0 indexed, dates are 1 indexed
   symbols = new (); //names for our months and weekdays
 
  //plain numbers way
  .out.println(now.get(.YEAR)  + strv + (now.get(.MONTH) + 1) + strv + now.get(.DATE));
 
  //words way
  .out.print(symbols.getWeekdays()[now.get(.DAY_OF_WEEK)] + strv);
  .out.print(symbols.getMonths()[now.get(.MONTH)] + strv);
  .out.println(now.get(.DATE) + strv + now.get(.YEAR));
 
  //using DateFormat
   date = new ();
   format1 = new (strv);
  .out.println(format1.format(date)); 
   format2 = new (strv);
  .out.println(format2.format(date));
 }
} 
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
public class Dates
{
 public static void main(final [] args)
 {
  //using DateTimeFormatter
  LocalDate date = LocalDate.now();
  DateTimeFormatter dtFormatter = DateTimeFormatter.ofPattern(strv);
 
  .out.println(dtFormatter.format(date));
 }
}
 "
"import java.util.*;
 
public class CutRectangle {
 
    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
 
    public static void main([] args) {
        cutRectangle(2, 2);
        cutRectangle(4, 3);
    }
 
    static void cutRectangle(int w, int h) {
        if (w % 2 == 1 && h % 2 == 1)
            return;
 
        int[][] grid = new int[h][w];
        Stack<Integer> stack = new Stack<>();
 
        int half = (w * h) / 2;
        long bits = (long) .pow(2, half) - 1;
 
        for (; bits > 0; bits -= 2) {
 
            for (int i = 0; i < half; i++) {
                int r = i / w;
                int c = i % w;
                grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;
                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];
            }
 
            stack.push(0);
            grid[0][0] = 2;
            int count = 1;
            while (!stack.empty()) {
 
                int pos = stack.pop();
                int r = pos / w;
                int c = pos % w;
 
                for (int[] dir : dirs) {
 
                    int nextR = r + dir[0];
                    int nextC = c + dir[1];
 
                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {
 
                        if (grid[nextR][nextC] == 1) {
                            stack.push(nextR * w + nextC);
                            grid[nextR][nextC] = 2;
                            count++;
                        }
                    }
                }
            }
            if (count == half) {
                printResult(grid);
            }
        }
    }
 
    static void printResult(int[][] arr) {
        for (int[] a : arr)
            .out.println(.toString(a));
        .out.println();
    }
}"
"import java.math.*;
import java.util.*;
 
public class Currency {
    final static  taxrate = strv;
 
    enum  {
 
        Hamburger(strv), Milkshake(strv);
 
        private ( p) {
            price = new (p);
        }
 
        public final  price;
    }
 
    public static void main([] args) {
        .setDefault(.ENGLISH);
 
        MathContext mc = MathContext.DECIMAL128;
 
        Map<, BigDecimal> order = new HashMap<>();
        order.put(.Hamburger, new (strv));
        order.put(.Milkshake, new (strv));
 
         subtotal = .ZERO;
        for ( it : order.keySet())
            subtotal = subtotal.add(it.price.multiply(order.get(it), mc));
 
         tax = new (taxrate, mc);
        tax = tax.divide(new (strv), mc);
        tax = subtotal.multiply(tax, mc);
 
        .out.printf(strv, subtotal);
        .out.printf(strv, tax);
        .out.printf(strv, subtotal.add(tax));
    }
}"
"public class StdDev {
    int n = 0;
    double sum = 0;
    double sum2 = 0;
 
    public double sd(double x) {
	n++;
	sum += x;
	sum2 += x*x;
 
	return .sqrt(sum2/n - sum*sum/n/n);
    }
 
    public static void main([] args) {
        double[] testData = {2,4,4,4,5,5,7,9};
        StdDev sd = new StdDev();
 
        for (double x : testData) {
            .out.println(sd.sd(x));
        }
    }
}"
"import java.util.Scanner;
 
public class twoDimArray {
  public static void main([] args) {
        Scanner in = new Scanner(.in);
 
        int nbr1 = in.nextInt();
        int nbr2 = in.nextInt();
 
        double[][] array = new double[nbr1][nbr2];
        array[0][0] = 42.0;
        .out.println(strv + array[0][0]);
  }
}"
"import java.io.*;
import java.awt.Point;
import java.util.HashMap;
import java.util.Scanner;
 
public class CSV {
 
    private HashMap<, String> _map = new HashMap<, String>();
    private int _cols;
    private int _rows;
 
    public void open( file) throws ,  {
        open(file, ',');
    }
 
    public void open( file, char delimiter)
            throws ,  {
        Scanner scanner = new Scanner(file);
        scanner.useDelimiter(.toString(delimiter));
 
        clear();
 
        while(scanner.hasNextLine()) {
            [] values = scanner.nextLine().split(.toString(delimiter));
 
            int col = 0;
            for (  value: values ) {
                _map.put(new (col, _rows), value);
                _cols = .max(_cols, ++col);
            }
            _rows++;
        }
        scanner.close();
    }
 
    public void save( file) throws  {
        save(file, ',');
    }
 
    public void save( file, char delimiter) throws  {
         fw = new (file);
         bw = new (fw);
 
        for (int row = 0; row < _rows; row++) {
            for (int col = 0; col < _cols; col++) {
                 key = new (col, row);
                if (_map.containsKey(key)) {
                    bw.write(_map.get(key));
                }
 
                if ((col + 1) < _cols) {
                    bw.write(delimiter);
                }
            }
            bw.newLine();
        }
        bw.flush();
        bw.close();
    }
 
    public  get(int col, int row) {
         val = strv;
         key = new (col, row);
        if (_map.containsKey(key)) {
            val = _map.get(key);
        }
        return val;
    }
 
    public void put(int col, int row,  value) {
        _map.put(new (col, row), value);
        _cols = .max(_cols, col+1);
        _rows = .max(_rows, row+1);
    }
 
    public void clear() {
        _map.clear();
        _cols = 0;
        _rows = 0;
    }
 
    public int rows() {
        return _rows;
    }
 
    public int cols() {
        return _cols;
    }
 
    public static void main([] args) {
        try {
            CSV csv = new CSV();
 
            csv.open(new (strv));
            csv.put(0, 0, strv);
            csv.put(1, 1, strv);
            csv.put(2, 2, strv);
            csv.put(3, 3, strv);
            csv.put(4, 4, strv);
            csv.save(new (strv));
        } catch ( e) {
        }
    }
}import java.io.*;
import java.util.*;
 
import org.apache.commons.csv.*;
 
public class RCsv {
  private static final  NL = .getProperty(strv);
  private static final  FILENAME_IR = strv;
  private static final  FILENAME_OR = strv;
  private static final  COL_NAME_SUM = ""SUM, integers""; 

 
  public static void main([] args) {
     iCvs = null;
     oCvs = null;
    .out.println(textFileContentsToString(FILENAME_IR));
    try {
      iCvs = new (new (FILENAME_IR));
      oCvs = new (new (FILENAME_OR));
      processCsv(iCvs, oCvs);
    }
    catch ( ex) {
      ex.printStackTrace();
    }
    finally {
      try {
        if (iCvs != null) { iCvs.close(); }
        if (oCvs != null) { oCvs.close(); }
      }
      catch ( ex) {
        ex.printStackTrace();
      }
    }
    .out.println(textFileContentsToString(FILENAME_OR));
    return;
  }
 
  public static void processCsv( iCvs,  oCvs) throws  {
    CSVPrinter printer = null;
    try {
      printer = new CSVPrinter(oCvs, CSVFormat.DEFAULT.withRecordSeparator(NL));
      List<String> oCvsHeaders;
      List<String> oCvsRecord;
      CSVParser records = CSVFormat.DEFAULT.withHeader().parse(iCvs);
      Map<, Integer> irHeader = records.getHeaderMap();
      oCvsHeaders = new ArrayList<String>(.asList((irHeader.keySet()).toArray(new [0])));
      oCvsHeaders.add(COL_NAME_SUM);
      printer.printRecord(oCvsHeaders);
      for (CSVRecord record : records) {
        oCvsRecord = record2list(record, oCvsHeaders);
        printer.printRecord(oCvsRecord);
      }
    }
    finally {
      if (printer != null) {
        printer.close();
      }
    }
    return;
  }
 
  private static List<String> record2list(CSVRecord record, List<String> oCvsHeaders) {
    List<String> cvsRecord;
    Map<, String> rMap = record.toMap();
    long recNo = record.getRecordNumber();
    rMap = alterRecord(rMap, recNo);
    int sum = 0;
    sum = summation(rMap);
    rMap.put(COL_NAME_SUM, .valueOf(sum));
    cvsRecord = new ArrayList<String>();
    for ( key : oCvsHeaders) {
      cvsRecord.add(rMap.get(key));
    }
    return cvsRecord;
  }
 
  private static Map<, String> alterRecord(Map<, String> rMap, long recNo) {
    int rv;
     rg = new (recNo);
    rv = rg.nextInt(50);
    [] ks = rMap.keySet().toArray(new [0]);
    int ix = rg.nextInt(ks.length);
    long yv = 0;
     ky = ks[ix];
     xv = rMap.get(ky);
    if (xv != null && xv.length() > 0) {
      yv = .valueOf(xv) + rv;
      rMap.put(ks[ix], .valueOf(yv));
    }
    return rMap;
  }
 
  private static int summation(Map<, String> rMap) {
    int sum = 0;
    for ( col : rMap.keySet()) {
       nv = rMap.get(col);
      sum += nv != null && nv.length() > 0 ? .valueOf(nv) : 0;
    }
    return sum;
  }
 
  private static  textFileContentsToString( filename) {
    StringBuilder lineOut = new StringBuilder();
    Scanner fs = null;
    try {
      fs = new Scanner(new (filename));
      lineOut.append(filename);
      lineOut.append(NL);
      while (fs.hasNextLine()) {
         line = fs.nextLine();
        lineOut.append(line);
        lineOut.append(NL);
      }
    }
    catch ( ex) {
      

      ex.printStackTrace();
    }
    finally {
      if (fs != null) {
        fs.close();
      }
    }
    return lineOut.toString();
  }
}
  
public static void main([] args) throws  {
 
        

        CsvParserSettings settings = new CsvParserSettings();
        settings.getFormat().setLineSeparator("""");
 
        

        BeanListProcessor<Employee> rowProcessor = new BeanListProcessor<Employee>(Employee.class);
        settings.setRowProcessor(rowProcessor);
 
        

        CsvParser parser = new CsvParser(settings);
 
        

        parser.parse(new (strv));
        List<Employee> resolvedBeans = rowProcessor.getBeans();
 
        

        

 
        

        CsvWriterSettings writerSettings = new CsvWriterSettings();
 
        

        writerSettings.setRowWriterProcessor(new BeanWriterProcessor<Employee>(Employee.class));
 
        

        CsvWriter writer = new CsvWriter(new (strv), writerSettings);
        writer.processRecords(resolvedBeans);
        writer.writeRows(new ArrayList<List<Object>>());
    }
 "
" 




grammar csv2html;
dialog : {.out.println(strv);}header body+{.out.println(strv);} ;
header : {.out.println(""<THEAD align=center><TR bgcolor=blue>"");}row{.out.println(strv);};
body   : {.out.println(strv);}row{.out.println(strv);};
row    : field ',' field ''? '';
field  : {.out.println(strv + $Field.text.replace(strv,strv).replace(strv,strv) + strv);};
  : ~[,\n\r]+;
 import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
 
class Csv2Html {
 
	public static  escapeChars( lineIn) {
		StringBuilder sb = new StringBuilder();
		int lineLength = lineIn.length();
		for (int i = 0; i < lineLength; i++) {
			char c = lineIn.charAt(i);
			switch (c) {
				case '""': 
					sb.append(strv);
					break;
				case '&':
					sb.append(strv);
					break;
				case '':
					sb.append(strv);
					break;
				case '<':
					sb.append(strv);
					break;
				case '>':
					sb.append(strv);
					break;
				default: sb.append(c);
			}
		}
		return sb.toString();
	}
 
	public static void tableHeader( ps, [] columns) {
		ps.print(strv);
		for (int i = 0; i < columns.length; i++) {
			ps.print(strv);
			ps.print(columns[i]);
			ps.print(strv);
		}
		ps.println(strv);
	}
 
	public static void tableRow( ps, [] columns) {
		ps.print(strv);
		for (int i = 0; i < columns.length; i++) {
			ps.print(strv);
			ps.print(columns[i]);
			ps.print(strv);
		}
		ps.println(strv);
	}
 
	public static void main([] args) throws  {
		boolean withTableHeader = (args.length != 0);
 
		 isr = new (.in);
		 br = new (isr);
		 stdout = .out;
 
		stdout.println(""<!DOCTYPE html PUBLIC -//W3C//DTD XHTML 1.0 Strict//EN http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd>"");
		stdout.println(""<html xmlns=http://www.w3.org/1999/xhtml>"");
		stdout.println(""<head><meta http-equiv=Content-type content=text/html;charset=UTF-8/>"");
		stdout.println(strv);
		stdout.println(""<style type=text/css>"");
		stdout.println(strv);
		stdout.println(strv);
		stdout.println(strv);
		stdout.println(strv);
		stdout.println(strv);
 
		stdout.println(strv);
		 stdinLine;
		boolean firstLine = true;
		while ((stdinLine = br.readLine()) != null) {
			[] columns = escapeChars(stdinLine).split(strv);
			if (withTableHeader == true && firstLine == true) {
				tableHeader(stdout, columns);
				firstLine = false;
			} else {
				tableRow(stdout, columns);
			}
		}
		stdout.println(strv);
	}
}
 "
"import java.util.zip.* ;
 
public class CRCMaker {
   public static void main( [ ] args ) {
       toBeEncoded = new ( strv ) ;
       myCRC = new ( ) ;
      myCRC.update( toBeEncoded.getBytes( ) ) ;
      .out.println( strv + .toHexString( myCRC.getValue( ) ) + strv ) ;
   }
}"
"import java.io.*;
public class CreateFileTest {
	public static void main( args[]) {
		try {
			new (strv).createNewFile();
			new (.separator + strv).createNewFile();
			new (strv).mkdir();
			new (.separator + strv).mkdir();
		} catch ( e) {
			.err.println(e.getMessage());
		}
	}
}"
"public class Count{
    public static void main([] args){
        for(int i = 0;i >= 0;i++){
            .out.println(.toOctalString(i)); //optionally use strv
        }
    }
}"
"public class CountSubstring {
	public static int countSubstring( subStr,  str){
		return (str.length() - str.replace(subStr, strv).length()) / subStr.length();
	}
 
	public static void main([] args){
		.out.println(countSubstring(strv, strv));
		.out.println(countSubstring(strv, strv));
		.out.println(countSubstring(strv, strv));
	}
}import java.util.regex.Pattern;
 
public class CountSubstring {
	public static int countSubstring( subStr,  str){
		

		

		return str.split(Pattern.quote(subStr), -1).length - 1;
	}
 
	public static void main([] args){
		.out.println(countSubstring(strv, strv));
		.out.println(countSubstring(strv, strv));
		.out.println(countSubstring(strv, strv));
	}
}public class CountSubstring {
	public static int countSubstring( subStr,  str){
		int count = 0;
		for (int loc = str.indexOf(subStr); loc != -1;
		     loc = str.indexOf(subStr, loc + subStr.length()))
			count++;
		return count;
	}
 
	public static void main([] args){
		.out.println(countSubstring(strv, strv));
		.out.println(countSubstring(strv, strv));
		.out.println(countSubstring(strv, strv));
	}
}"
" src = strv;
 newAlias = src;
 strCopy = new (src);
 
//strv is true
//strv is false
//strv is true srcCopy = new (strv);"
"public class CountingInFactors{ 
    public static void main([] args){
        for(int i = 1; i<= 10; i++){
            .out.println(i + strv+ countInFactors(i));
        }
 
        for(int i = 9991; i <= 10000; i++){
        	.out.println(i + strv+ countInFactors(i));
        }
    }
 
    private static  countInFactors(int n){
        if(n == 1) return strv;
 
        StringBuilder sb = new StringBuilder();
 
        n = checkFactor(2, n, sb);
        if(n == 1) return sb.toString();
 
        n = checkFactor(3, n, sb);
        if(n == 1) return sb.toString();
 
        for(int i = 5; i <= n; i+= 2){
            if(i % 3 == 0)continue;
 
            n = checkFactor(i, n, sb);
            if(n == 1)break;
        }
 
        return sb.toString();
    }
 
    private static int checkFactor(int mult, int n, StringBuilder sb){
        while(n % mult == 0 ){
            if(sb.length() > 0) sb.append(strv);
            sb.append(mult);
            n /= mult;
        }
        return n;
    }
}"
"import org.apache.commons.math3.fraction.BigFraction;
 
public class Test {
 
    public static void main([] args) {
        double[] n = {0.750000000, 0.518518000, 0.905405400, 0.142857143,
            3.141592654, 2.718281828, -0.423310825, 31.415926536};
 
        for (double d : n)
            .out.printf(strv, d, new BigFraction(d, 0.00000002D, 10000));
    }
}"
"public class CompoundDuration {
 
    public static void main([] args) {
        compound(7259);
        compound(86400);
        compound(6000_000);
    }
 
    private static void compound(long seconds) {
        StringBuilder sb = new StringBuilder();
 
        seconds = addUnit(sb, seconds, 604800, strv);
        seconds = addUnit(sb, seconds, 86400, strv);
        seconds = addUnit(sb, seconds, 3600, strv);
        seconds = addUnit(sb, seconds, 60, strv);
        addUnit(sb, seconds, 1, strv);
 
        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);
 
        .out.println(sb);
    }
 
    private static long addUnit(StringBuilder sb, long sec, long unit,  s) {
        long n;
        if ((n = sec / unit) > 0) {
            sb.append(n).append(s);
            sec %= (n * unit);
        }
        return sec;
    }
}"
"public class GameOfLife{
	public static void main([] args){
		[] dish= {
				strv,
				strv,
				strv,};
		int gens= 3;
		for(int i= 0;i < gens;i++){
			.out.println(strv + i + strv);
			print(dish);
			dish= life(dish);
		}
	}
 
	public static [] life([] dish){
		[] newGen= new [dish.length];
		for(int row= 0;row < dish.length;row++){//each row
			newGen[row]= strv;
			for(int i= 0;i < dish[row].length();i++){//each char in the row
				 above= strv;//neighbors above
				 same= strv;//neighbors in the same row
				 below= strv;//neighbors below
				if(i == 0){//all the way on the left
					//no one above if on the top row
					//otherwise grab the neighbors from above
					above= (row == 0) ? null : dish[row - 1].substring(i,
									i + 2);
					same= dish[row].substring(i + 1, i + 2);
					//no one below if on the bottom row
					//otherwise grab the neighbors from below
					below= (row == dish.length - 1) ? null : dish[row + 1]
									.substring(i, i + 2);
				}else if(i == dish[row].length() - 1){//right
					//no one above if on the top row
					//otherwise grab the neighbors from above
					above= (row == 0) ? null : dish[row - 1].substring(i - 1,
									i + 1);
					same= dish[row].substring(i - 1, i);
					//no one below if on the bottom row
					//otherwise grab the neighbors from below
					below= (row == dish.length - 1) ? null : dish[row + 1]
									.substring(i - 1, i + 1);
				}else{//anywhere else
					//no one above if on the top row
					//otherwise grab the neighbors from above
					above= (row == 0) ? null : dish[row - 1].substring(i - 1,
									i + 2);
					same= dish[row].substring(i - 1, i)
									+ dish[row].substring(i + 1, i + 2);
					//no one below if on the bottom row
					//otherwise grab the neighbors from below
					below= (row == dish.length - 1) ? null : dish[row + 1]
									.substring(i - 1, i + 2);
				}
				int neighbors= getNeighbors(above, same, below);
				if(neighbors < 2 || neighbors > 3){
					newGen[row]+= strv;//<2 or >3 neighbors -> die
				}else if(neighbors == 3){
					newGen[row]+= strv;//3 neighbors -> spawn/live
				}else{
					newGen[row]+= dish[row].charAt(i);//2 neighbors -> stay
				}
			}
		}
		return newGen;
	}
 
	public static int getNeighbors( above,  same,  below){
		int ans= 0;
		if(above != null){//no one above
			for(char x: above.toCharArray()){//each neighbor from above
				if(x == '#') ans++;//count it if someone is here
			}
		}
		for(char x: same.toCharArray()){//two on either side
			if(x == '#') ans++;//count it if someone is here
		}
		if(below != null){//no one below
			for(char x: below.toCharArray()){//each neighbor below
				if(x == '#') ans++;//count it if someone is here
			}
		}
		return ans;
	}
 
	public static void print([] dish){
		for( s: dish){
			.out.println(s);
		}
	}
} 
//package conway;
 
import java.util.*;
import java.io.*;
 
public class GameOfLife 
{
	//Set grid size
	int l=20,b=60;
	public static void main([] args)
	{
 
		GameOfLife now=new GameOfLife();
		now.setGame();
	}
	void setGame()
	{
		char[][] config=new char[l][b];
		startGame(config,l,b);
	}
	void startGame(char[][] mat,int l, int b)
	{
		Scanner s=new Scanner(.in);
		 ch=strv;
		float per=0;
		while(!ch.equals(strv))
		{
			per=setConfig(mat);
			//setCustomConfig(mat,strv);
			display2D(mat);
			.out.println((per*100)+strv);
			.out.println(strv);
			ch=s.nextLine();
		}
		while(!ch.equals(strv))
		{
			mat=transform(mat,l,b);
			display2D(mat);
 
			.out.println(strv);
 
			try
			{
				.sleep(100);
			}
			catch( e)
			{
				.out.println(strv);
			}
 
			//ch=s.nextLine();
		}
		s.close();
		.out.println(strv);
	}
 
	char[][] transform(char[][] mat,int l, int b)
	{
 
		char[][] newmat=new char[l][b];
		for(int i=0;i<l;i++)
			for(int j=0;j<b;j++)
				newmat[i][j]=flip(mat,i,j);
		return newmat;
	}
	char flip(char[][] mat,int i, int j)
	{
		int count=around(mat,i,j);
		if(mat[i][j]=='*')
		{
			if(count<2||count>3)
				return '_';
			return '*';
		}
		else
		{
			if(count==3)
				return '*';
			return '_';
		}
	}
	int around(char[][] mat, int i, int j)
	{
		int count=0;
		for(int x=i-1;x<=i+1;x++)
			for(int y=j-1;y<=j+1;y++)
			{
				if(x==i&&y==j)
					continue;
				count+=eval(mat,x,y);
			}
		return count;
	}
	int eval(char[][] mat, int i, int j)
	{
		if(i<0||j<0||i==l||j==b)
			return 0;
		if(mat[i][j]=='*')
			return 1;
		return 0;
	}
 
	float setCustomConfig(char[][] arr, infile)
	{
		try
		{
			 br=new (new (infile));
			 line;
			for(int i=0;i<arr.length;i++)
			{
				line=br.readLine();
				for(int j=0;j<arr[0].length;j++)
					arr[i][j]=line.charAt(j);
			}
			br.close();
		}
		catch( e)
		{
			.out.println(e.getMessage());
		}
		return 0;
	}
 
	float setConfig(char[][] arr)
	{
		//Enter percentage of grid to be filled.
		float per=0.10f;//(float)Math.random();
		for(int i=0;i<arr.length;i++)
			setConfig1D(arr[i],per);
		return per;
	}
	void setConfig1D(char[] arr,float per)
	{
		for(int i=0;i<arr.length;i++)
		{
			if(.random()<per)
				arr[i]='*';
			else
				arr[i]='_';
		}
	}
	void display2D(char[][] arr)
	{
		for(int i=0;i<arr.length;i++)
			display1D(arr[i]);
		.out.println();
	}
	void display1D(char[] arr)
	{
		for(int i=0;i<arr.length;i++)
			.out.print(arr[i]);
		.out.println();
	}
}
 "
"import static java.lang..pow;
import java.util.*;
import java.util.function.Function;
 
public class Test {
    static double calc(Function<, []> f, int n) {
        double temp = 0;
 
        for (int ni = n; ni >= 1; ni--) {
            [] p = f.apply(ni);
            temp = p[1] / (double) (p[0] + temp);
        }
        return f.apply(0)[0] + temp;
    }
 
    public static void main([] args) {
        List<Function<, []>> fList = new ArrayList<>();
        fList.add(n -> new []{n > 0 ? 2 : 1, 1});
        fList.add(n -> new []{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});
        fList.add(n -> new []{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});
 
        for (Function<, []> f : fList)
            .out.println(calc(f, 200));
    }
}"
"if (s == 'Hello World') {
    foo();
} else if (s == 'Bye World') {
    bar();
} else {
    deusEx();
}if(obj != null && obj.foo()){
   aMethod();
}if(obj != null & obj.foo()){
   aMethod();
}s == 'Hello World' ? foo() : bar();a = 3
if( a == 1 ){
    io.writeln( 'a == 1' )
}else if( a== 3 ){
    io.writeln( 'a == 3' )
}else{
    io.writeln( 'a is neither 1 nor 3' )
}a = 3
switch( a ){
case 0: io.writeln( 'case 0' )
case 1, 2: io.writeln( 'case 1,2' )
case 3, 4, 5: io.writeln( 'case 3,4,5' )
default: io.writeln( 'default' )
}if(s.equals(strv))
{
    foo();
}
else if(s.equals(strv))
    bar();//{}'s optional for one-liners
else
{
    deusEx();
}if(obj != null && obj.foo()){
   aMethod();
}if(obj != null & obj.foo()){
   aMethod();
}s.equals(strv) ? foo() : bar();switch(c) {
case 'a':
   foo();
   break;
case 'b':
   bar();
default:
   foobar();
}if(c == 'a'){
   foo();
}else if(c == 'b'){
   bar();
   foobar();
}else{
   foobar();
}"
"import java.util.Random;
 
public class FuzzyCircle {
	static final  rnd = new ();
	public static void main([] args){
		char[][] field = new char[31][31];
		for(int i = 0; i < field.length; i++){
			for(int j = 0; j < field[i].length; j++){
				field[i][j] = ' ';
			}
		}
		int pointsInDisc = 0;
		while(pointsInDisc < 100){
			int x = rnd.nextInt(31) - 15;
			int y = rnd.nextInt(31) - 15;
			double dist = .hypot(x, y);
			if(dist >= 10 && dist <= 15 && field[x + 15][y + 15] == ' '){
				field[x + 15][y + 15] = 'X';
				pointsInDisc++;
			}
		}
		for(char[] row:field){
			for(char space:row){
				.out.print(space);
			}
			.out.println();
		}
	}
}"
"public class 
{
  public int x, y;
  public () { this(0); }
  public (int x0) { this(x0,0); }
  public (int x0, int y0) { x = x0; y = y0; }
 
  public static void main( args[])
  {
     point = new (1,2);
    .out.println(strv + point.x );
    .out.println(strv + point.y );
  }
}"
"import java.io.File;
import java.util.*;
import java.util.regex.*;
 
public class CommatizingNumbers {
 
    public static void main([] args) throws  {
        commatize(strv
                + strv, 6, 5, strv);
 
        commatize(strv
                + strv, 0, 3, strv);
 
        try (Scanner sc = new Scanner(new (strv))) {
            while(sc.hasNext())
                commatize(sc.nextLine());
        }
    }
 
    static void commatize( s) {
        commatize(s, 0, 3, strv);
    }
 
    static void commatize( s, int start, int step,  ins) {
        if (start < 0 || start > s.length() || step < 1 || step > s.length())
            return;
 
        Matcher m = Pattern.compile(strv).matcher(s.substring(start));
         result = new (s.substring(0, start));
 
        if (m.find()) {
            StringBuilder sb = new StringBuilder(m.group(1)).reverse();
            for (int i = step; i < sb.length(); i += step)
                sb.insert(i++, ins);
            m.appendReplacement(result, sb.reverse().toString());
        }
 
        .out.println(m.appendTail(result));
    }
}"
"/* This is a comment *//* * This is * a multiple * line comment. */
/** This is a Javadoc comment *//** * This is * a multiple * line Javadoc comment */public class JustComments {
    /*    \u002A\u002F\u0070\u0075\u0062\u006C\u0069\u0063\u0020\u0073\u0074\u0061\u0074\u0069\u0063    \u0020\u0076\u006F\u0069\u0064\u0020\u006D\u0061\u0069\u006E\u0028    \u0053\u0074\u0072\u0069\u006E\u0067\u005B\u005D\u0061\u0072\u0067\u0073\u0029    \u007B\u0053\u0079\u0073\u0074\u0065\u006D\u002E\u006F\u0075\u0074\u002E    \u0070\u0072\u0069\u006E\u0074\u006C\u006E\u0028\u0022\u0048\u0065\u006C\u006C\u006F\u0022    \u002B\u0022\u0020\u0057\u006F\u0072\u006C\u0064\u0021\u0022\u0029\u003B\u007D\u002F\u002A    */
}"
"public class Arguments {
  public static void main([] args) {
     .out.println(strv + args.length + strv);
     for(int i = 0; i < args.length; i++) 
        .out.println(strv + (i+1) + strv + args[i] + strv + i);
  }
}"
" 
import com.objectwave.utility.*;
 
public class MultiCombinationsTester {
 
    public MultiCombinationsTester() throws CombinatoricException {
        [] objects = {strv, strv, strv};
        //Object[] objects = {strv};
        //Object[] objects = {strv};
        //Object[] objects = {(Integer)1, (Integer)2, (Integer)3, (Integer)4};
        MultiCombinations mc = new MultiCombinations(objects, 2);
        while (mc.hasMoreElements()) {
            for (int i = 0; i < mc.nextElement().length; i++) {
                .out.print(mc.nextElement()[i].toString() + strv);
            }
            .out.println();
        }
 
        

        .out.println(strv);
        .out.println(strv + MultiCombinations.c(10, 3));
    } 

 
    public static void main([] args) throws CombinatoricException {
        new MultiCombinationsTester();
    }
} 

  
import com.objectwave.utility.*;
import java.util.*;
 
public class MultiCombinations {
 
    private HashSet<String> set = new HashSet<String>();
    private Combinations comb = null;
    private [] nextElem = null;
 
    public MultiCombinations([] objects, int k) throws CombinatoricException {
        k = .max(0, k);
        [] myObjects = new [objects.length * k];
        for (int i = 0; i < objects.length; i++) {
            for (int j = 0; j < k; j++) {
                myObjects[i * k + j] = objects[i];
            }
        }
        comb = new Combinations(myObjects, k);
    } 

 
    boolean hasMoreElements() {
        boolean ret = false;
        nextElem = null;
        int oldCount = set.size();
        while (comb.hasMoreElements()) {
            [] elem = ([]) comb.nextElement();
             str = strv;
            for (int i = 0; i < elem.length; i++) {
                str += (strv + elem[i].toString() + strv);
            }
            set.add(str);
            if (set.size() > oldCount) {
                nextElem = elem;
                ret = true;
                break;
            }
        }
        return ret;
    } 

 
    [] nextElement() {
        return nextElem;
    }
 
    static java.math. c(int n, int k) throws CombinatoricException {
        return Combinatoric.c(n + k - 1, k);
    }
} 

 "
"public class Quibbler {
 
	public static  quibble([] words) {
		 qText = strv;
		for(int wIndex = 0; wIndex < words.length; wIndex++) {
			qText += words[wIndex] + (wIndex == words.length-1 ? strv : 
						  wIndex == words.length-2 ? strv :
						  strv;
		}
		qText += strv;
		return qText;
	}
 
	public static void main([] args) {
		.out.println(quibble(new []{}));
		.out.println(quibble(new []{strv}));
		.out.println(quibble(new []{strv, strv}));
		.out.println(quibble(new []{strv, strv, strv}));
		.out.println(quibble(new []{strv, strv, strv, strv}));
	}
}"
"import java.awt.*;
import static java.awt..*;
import javax.swing.*;
 
public class ColourPinstripeDisplay extends  {
    final static [] palette = {black, red, green, blue, magenta,cyan,
        yellow, white};
 
    final int bands = 4;
 
    public ColourPinstripeDisplay() {
        setPreferredSize(new (900, 600));
    }
 
    @Override
    public void paintComponent( g) {
        super.paintComponent(g);
        int h = getHeight();
        for (int b = 1; b <= bands; b++) {
            for (int x = 0, colIndex = 0; x < getWidth(); x += b, colIndex++) {
                g.setColor(palette[colIndex % palette.length]);
                g.fillRect(x, (b - 1) * (h / bands), x + b, b * (h / bands));
            }
        }
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.add(new ColourPinstripeDisplay(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"public static  getColorAt(int x, int y){
   return new ().getPixelColor(x, y);
}"
" 
import java.awt.Color;
import java.awt.Graphics;
 
import javax.swing.JFrame;
 
public class ColorFrame extends  {
	public ColorFrame(int width, int height) {
		this.setDefaultCloseOperation(EXIT_ON_CLOSE);
		this.setSize(width, height);
		this.setVisible(true);
	}
 
	@Override
	public void paint( g) {
		[] colors = { .black, .red, .green, .blue,
				.pink, .CYAN, .yellow, .white };
 
		for (int i = 0; i < colors.length; i++) {
			g.setColor(colors[i]);
			g.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()
					/ colors.length, this.getHeight());
		}
	}
 
	public static void main( args[]) {
		new ColorFrame(200, 200);
	}
}
 "
"import java.util.function.Supplier;
import java.util.ArrayList;
 
public class ValueCapture {
    public static void main([] args) {
	ArrayList<Supplier<Integer>> funcs = new ArrayList<>();
	for (int i = 0; i < 10; i++) {
	    int j = i;
	    funcs.add(() -> j * j);
	}
 
	Supplier<Integer> foo = funcs.get(3);
	.out.println(foo.get()); 

    }
}import java.util.List;
import java.util.function.IntSupplier;
import java.util.stream.IntStream;
 
import static java.util.stream.Collectors.toList;
 
public interface ValueCapture {
  public static void main(... arguments) {
    List<IntSupplier> closures = IntStream.rangeClosed(0, 10)
      .<IntSupplier>mapToObj(i -> () -> i * i)
      .collect(toList())
    ;
 
    IntSupplier closure = closures.get(3);
    .out.println(closure.getAsInt()); 

  }
}"
"import java.util.*;
 
public class ClosestPair
{
  public static class 
  {
    public final double x;
    public final double y;
 
    public (double x, double y)
    {
      this.x = x;
      this.y = y;
    }
 
    public  toString()
    {  return strv + x + strv + y + strv;  }
  }
 
  public static class Pair
  {
    public  point1 = null;
    public  point2 = null;
    public double distance = 0.0;
 
    public Pair()
    {  }
 
    public Pair( point1,  point2)
    {
      this.point1 = point1;
      this.point2 = point2;
      calcDistance();
    }
 
    public void update( point1,  point2, double distance)
    {
      this.point1 = point1;
      this.point2 = point2;
      this.distance = distance;
    }
 
    public void calcDistance()
    {  this.distance = distance(point1, point2);  }
 
    public  toString()
    {  return point1 + strv + point2 + strv + distance;  }
  }
 
  public static double distance( p1,  p2)
  {
    double xdist = p2.x - p1.x;
    double ydist = p2.y - p1.y;
    return .hypot(xdist, ydist);
  }
 
  public static Pair bruteForce(List<? extends Point> points)
  {
    int numPoints = points.size();
    if (numPoints < 2)
      return null;
    Pair pair = new Pair(points.get(0), points.get(1));
    if (numPoints > 2)
    {
      for (int i = 0; i < numPoints - 1; i++)
      {
         point1 = points.get(i);
        for (int j = i + 1; j < numPoints; j++)
        {
           point2 = points.get(j);
          double distance = distance(point1, point2);
          if (distance < pair.distance)
            pair.update(point1, point2, distance);
        }
      }
    }
    return pair;
  }
 
  public static void sortByX(List<? extends Point> points)
  {
    .sort(points, new Comparator<Point>() {
        public int compare( point1,  point2)
        {
          if (point1.x < point2.x)
            return -1;
          if (point1.x > point2.x)
            return 1;
          return 0;
        }
      }
    );
  }
 
  public static void sortByY(List<? extends Point> points)
  {
    .sort(points, new Comparator<Point>() {
        public int compare( point1,  point2)
        {
          if (point1.y < point2.y)
            return -1;
          if (point1.y > point2.y)
            return 1;
          return 0;
        }
      }
    );
  }
 
  public static Pair divideAndConquer(List<? extends Point> points)
  {
    List<Point> pointsSortedByX = new ArrayList<Point>(points);
    sortByX(pointsSortedByX);
    List<Point> pointsSortedByY = new ArrayList<Point>(points);
    sortByY(pointsSortedByY);
    return divideAndConquer(pointsSortedByX, pointsSortedByY);
  }
 
  private static Pair divideAndConquer(List<? extends Point> pointsSortedByX, List<? extends Point> pointsSortedByY)
  {
    int numPoints = pointsSortedByX.size();
    if (numPoints <= 3)
      return bruteForce(pointsSortedByX);
 
    int dividingIndex = numPoints >>> 1;
    List<? extends Point> leftOfCenter = pointsSortedByX.subList(0, dividingIndex);
    List<? extends Point> rightOfCenter = pointsSortedByX.subList(dividingIndex, numPoints);
 
    List<Point> tempList = new ArrayList<Point>(leftOfCenter);
    sortByY(tempList);
    Pair closestPair = divideAndConquer(leftOfCenter, tempList);
 
    tempList.clear();
    tempList.addAll(rightOfCenter);
    sortByY(tempList);
    Pair closestPairRight = divideAndConquer(rightOfCenter, tempList);
 
    if (closestPairRight.distance < closestPair.distance)
      closestPair = closestPairRight;
 
    tempList.clear();
    double shortestDistance =closestPair.distance;
    double centerX = rightOfCenter.get(0).x;
    for ( point : pointsSortedByY)
      if (.abs(centerX - point.x) < shortestDistance)
        tempList.add(point);
 
    for (int i = 0; i < tempList.size() - 1; i++)
    {
       point1 = tempList.get(i);
      for (int j = i + 1; j < tempList.size(); j++)
      {
         point2 = tempList.get(j);
        if ((point2.y - point1.y) >= shortestDistance)
          break;
        double distance = distance(point1, point2);
        if (distance < closestPair.distance)
        {
          closestPair.update(point1, point2, distance);
          shortestDistance = distance;
        }
      }
    }
    return closestPair;
  }
 
  public static void main([] args)
  {
    int numPoints = (args.length == 0) ? 1000 : .parseInt(args[0]);
    List<Point> points = new ArrayList<Point>();
     r = new ();
    for (int i = 0; i < numPoints; i++)
      points.add(new (r.nextDouble(), r.nextDouble()));
    .out.println(strv + numPoints + strv);
    long startTime = .currentTimeMillis();
    Pair bruteForceClosestPair = bruteForce(points);
    long elapsedTime = .currentTimeMillis() - startTime;
    .out.println(strv + elapsedTime + strv + bruteForceClosestPair);
    startTime = .currentTimeMillis();
    Pair dqClosestPair = divideAndConquer(points);
    elapsedTime = .currentTimeMillis() - startTime;
    .out.println(strv + elapsedTime + strv + dqClosestPair);
    if (bruteForceClosestPair.distance != dqClosestPair.distance)
      .out.println(strv);
  }
}"
"public class MyClass{
 
  

  private int variable;  

 
  /**  * The constructor  */
  public MyClass(){
    

  }
 
  /**  * A method  */
  public void someMethod(){
   this.variable = 1;
  }
}new MyClass();"
"import static java.util..stream;
 
public class ChineseRemainderTheorem {
 
    public static int chineseRemainder(int[] n, int[] a) {
 
        int prod = stream(n).reduce(1, (i, j) -> i * j);
 
        int p, sm = 0;
        for (int i = 0; i < n.length; i++) {
            p = prod / n[i];
            sm += a[i] * mulInv(p, n[i]) * p;
        }
        return sm % prod;
    }
 
    private static int mulInv(int a, int b) {
        int b0 = b;
        int x0 = 0;
        int x1 = 1;
 
        if (b == 1)
            return 1;
 
        while (a > 1) {
            int q = a / b;
            int amb = a % b;
            a = b;
            b = amb;
            int xqx = x1 - q * x0;
            x1 = x0;
            x0 = xqx;
        }
 
        if (x1 < 0)
            x1 += b0;
 
        return x1;
    }
 
    public static void main([] args) {
        int[] n = {3, 5, 7};
        int[] a = {2, 3, 2};
        .out.println(chineseRemainder(n, a));
    }
}"
"import java.util.Scanner;
import java.util.Random;
 
public class CheckpointSync{
	public static void main([] args){
		.out.print(strv);
		Scanner in = new Scanner(.in);
		Worker.nWorkers = in.nextInt();
		.out.print(strv);
		runTasks(in.nextInt());
	}
 
	/*	 * Informs that workers started working on the task and	 * starts running threads. Prior to proceeding with next	 * task syncs using static Worker.checkpoint() method.	 */
	private static void runTasks(int nTasks){
		for(int i = 0; i < nTasks; i++){
			.out.println(strv + (i+1) + strv);
			runThreads();
			Worker.checkpoint();
		}
	}
 
	/*	 * Creates a thread for each worker and runs it.	 */
	private static void runThreads(){
		for(int i = 0; i < Worker.nWorkers; i ++){
			new (new Worker(i+1)).start();
		}
	}
 
	/*	 * Worker inner static class.	 */
	public static class Worker implements {
		public Worker(int threadID){
			this.threadID = threadID;
		}
		public void run(){
			work();
		}
 
		/*		 *  Notifies that thread started running for 100 to 1000 msec.		 *  Once finished increments static counter 'nFinished'		 *  that counts number of workers finished their work.		 */
		private synchronized void work(){
			try {
				int workTime = rgen.nextInt(900) + 100;
				.out.println(strv + threadID + strv + workTime + strv);
				.sleep(workTime); //work for 'workTime'
				nFinished++; //increases work finished counter
				.out.println(strv + threadID + strv);
			} catch ( e) {
				.err.println(strv);
				e.printStackTrace();
			}
		}
 
		/*		 * Used to synchronize Worker threads using 'nFinished' static integer.		 * Waits (with step of 10 msec) until 'nFinished' equals to 'nWorkers'.		 * Once they are equal resets 'nFinished' counter.		 */
		public static synchronized void checkpoint(){
			while(nFinished != nWorkers){
				try {
					.sleep(10);
				} catch ( e) {
					.err.println(strv);
					e.printStackTrace();
				}
			}
			nFinished = 0;
		}
 
		/* inner class instance variables */
		private int threadID;
 
		/* static variables */
		private static  rgen = new ();
		private static int nFinished = 0;
		public static int nWorkers = 0;
	}
}"
"import java.io.File;
public class FileExistsTest {
   public static boolean isFileExists( filename) {
       boolean exists = new (filename).exists();
       return exists;
   }
   public static void test( type,  filename) {
       .out.println(strv + type + strv + filename + 
           (isFileExists(filename) ? strv : strv)
       );
   }
   public static void main( args[]) {
        test(strv, strv);
        test(strv, .separator + strv);
        test(strv, strv);
        test(strv, .separator + strv + .separator);
   }
}"
"import static java.lang..*;
import java.util.function.Function;
 
public class ChebyshevCoefficients {
 
    static double map(double x, double min_x, double max_x, double min_to,
            double max_to) {
        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;
    }
 
    static void chebyshevCoef(Function<, Double> func, double min,
            double max, double[] coef) {
 
        int N = coef.length;
 
        for (int i = 0; i < N; i++) {
 
            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);
            double f = func.apply(m) * 2 / N;
 
            for (int j = 0; j < N; j++) {
                coef[j] += f * cos(PI * j * (i + 0.5f) / N);
            }
        }
    }
 
    public static void main([] args) {
        final int N = 10;
        double[] c = new double[N];
        double min = 0, max = 1;
        chebyshevCoef(x -> cos(x), min, max, c);
 
        .out.println(strv);
        for (double d : c)
            .out.println(d);
    }
}"
"import java.io.*;
import java.net.*;
import java.util.*;
 
public class ChatServer implements 
{
  private int port = 0;
  private List<Client> clients = new ArrayList<Client>();
 
  public ChatServer(int port)
  {  this.port = port;  }
 
  public void run()
  {
    try
    {
       ss = new (port);
      while (true)
      {
         s = ss.accept();
        new (new Client(s)).start();
      }
    }
    catch ( e)
    {  e.printStackTrace();  }
  }
 
  private synchronized boolean registerClient(Client client)
  {
    for (Client otherClient : clients)
      if (otherClient.clientName.equalsIgnoreCase(client.clientName))
        return false;
    clients.add(client);
    return true;
  }
 
  private void deregisterClient(Client client)
  {
    boolean wasRegistered = false;
    synchronized (this)
    {  wasRegistered = clients.remove(client);  }
    if (wasRegistered)
      broadcast(client, strv + client.clientName + strv);
  }
 
  private synchronized  getOnlineListCSV()
  {
    StringBuilder sb = new StringBuilder();
    sb.append(clients.size()).append(strv);
    for (int i = 0; i < clients.size(); i++)
      sb.append((i > 0) ? strv : strv).append(clients.get(i).clientName);
    return sb.toString();
  }
 
  private void broadcast(Client fromClient,  msg)
  {
    

    List<Client> clients = null;
    synchronized (this)
    {  clients = new ArrayList<Client>(this.clients);  }
    for (Client client : clients)
    {
      if (client.equals(fromClient))
        continue;
      try
      {  client.write(msg + """");  }
      catch ( e)
      {  }
    }
  }
 
  public class Client implements 
  {
    private  socket = null;
    private  output = null;
    private  clientName = null;
 
    public Client( socket)
    {
      this.socket = socket;
    }
 
    public void run()
    {
      try
      {
        socket.setSendBufferSize(16384);
        socket.setTcpNoDelay(true);
         input = new (new (socket.getInputStream()));
        output = new (socket.getOutputStream());
        write(strv);
         line = null;
        while ((line = input.readLine()) != null)
        {
          if (clientName == null)
          {
            line = line.trim();
            if (line.isEmpty())
            {
              write(strv);
              continue;
            }
            clientName = line;
            if (!registerClient(this))
            {
              clientName = null;
              write(strv);
              continue;
            }
            write(getOnlineListCSV() + """");
            broadcast(this, strv + clientName + strv);
            continue;
          }
          if (line.equalsIgnoreCase(strv))
            return;
          broadcast(this, clientName + strv + line);
        }
      }
      catch ( e)
      {  }
      finally
      {
        deregisterClient(this);
        output = null;
        try
        {  socket.close();  }
        catch ( e)
        {  }
        socket = null;
      }
    }
 
    public void write( msg) throws 
    {
      output.write(msg);
      output.flush();
    }
 
    public boolean equals(Client client)
    {
      return (client != null) && (client instanceof Client) && (clientName != null) && (client.clientName != null) && clientName.equals(client.clientName);
    }
  }
 
  public static void main([] args)
  {
    int port = 4004;
    if (args.length > 0)
      port = .parseInt(args[0]);
    new ChatServer(port).run();
  }
}
 "
"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;
 
public class ChaosGame extends  {
    class ColoredPoint extends  {
        int colorIndex;
 
        ColoredPoint(int x, int y, int idx) {
            super(x, y);
            colorIndex = idx;
        }
    }
 
    Stack<ColoredPoint> stack = new Stack<>();
    [] points = new [3];
    [] colors = {.red, .green, .blue};
     r = new ();
 
    public ChaosGame() {
         dim = new (640, 640);
        setPreferredSize(dim);
        setBackground(.white);
 
        int margin = 60;
        int size = dim.width - 2 * margin;
 
        points[0] = new (dim.width / 2, margin);
        points[1] = new (margin, size);
        points[2] = new (margin + size, size);
 
        stack.push(new ColoredPoint(-1, -1, 0));
 
        new (10, ( e) -> {
            if (stack.size() < 50_000) {
                for (int i = 0; i < 1000; i++)
                    addPoint();
                repaint();
            }
        }).start();
    }
 
    private void addPoint() {
        try {
            int colorIndex = r.nextInt(3);
             p1 = stack.peek();
             p2 = points[colorIndex];
            stack.add(halfwayPoint(p1, p2, colorIndex));
        } catch ( e) {
            .out.println(e);
        }
    }
 
    void drawPoints( g) {
        for (ColoredPoint p : stack) {
            g.setColor(colors[p.colorIndex]);
            g.fillOval(p.x, p.y, 1, 1);
        }
    }
 
    ColoredPoint halfwayPoint( a,  b, int idx) {
        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawPoints(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new ChaosGame(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}size(300, 260);
 
background(#ffffff); 

 
int x = floor(random(width));
int y = floor(random(height));
 
int colour = #ffffff;
 
for (int i=0; i<30000; i++) {
  int v = floor(random(3));
  switch (v) {
  case 0:
    x = x / 2;
    y = y / 2;
    colour = #00ff00; 

    break;
  case 1:
    x = width/2 + (width/2 - x)/2;
    y = height - (height - y)/2;
    colour = #ff0000; 

    break;
  case 2:
    x = width - (width - x)/2;
    y = y / 2;
    colour = #0000ff; 

  }
  set(x, height-y, colour);
}"
"public class Foo {
    public static void main([] args) {
        .out.println((int)'a'); 

        .out.println((char)97); 

    }
}public class Bar {
    public static void main([] args) {
        .out.println((int)'π'); 

        .out.println((char)960); 

    }
}"
"public class Test {
    public static void main([] args) {
        int N = 15;
        int[] t = new int[N + 2];
        t[1] = 1;
 
        for (int i = 1; i <= N; i++) {
 
            for (int j = i; j > 1; j--)
                t[j] = t[j] + t[j - 1];
 
            t[i + 1] = t[i];
 
            for (int j = i + 1; j > 1; j--)
                t[j] = t[j] + t[j - 1];
 
            .out.printf(strv, t[i + 1] - t[i]);
        }
    }
}"
"import java.util.stream.Stream;
 
public class ReduceTask {
 
    public static void main([] args) {
        .out.println(Stream.of(1, 2, 3, 4, 5).mapToInt(i -> i).sum());
        .out.println(Stream.of(1, 2, 3, 4, 5).reduce(1, (a, b) -> a * b));
    }
}"
"import java.util.*;
import java.util.stream.IntStream;
 
public class CastingOutNines {
 
    public static void main([] args) {
        .out.println(castOut(16, 1, 255));
        .out.println(castOut(10, 1, 99));
        .out.println(castOut(17, 1, 288));
    }
 
    static List<Integer> castOut(int base, int start, int end) {
        int[] ran = IntStream
                .range(0, base - 1)
                .filter(x -> x % (base - 1) == (x * x) % (base - 1))
                .toArray();
 
        int x = start / (base - 1);
 
        List<Integer> result = new ArrayList<>();
        while (true) {
            for (int n : ran) {
                int k = (base - 1) * x + n;
                if (k < start)
                    continue;
                if (k > end)
                    return result;
                result.add(k);
            }
            x++;
        }
    }
}"
" dog = strv;
 Dog = strv; //in general, identifiers that start with capital letters are class names
 DOG = strv; //in general, identifiers in all caps are constants
//the conventions listed in comments here are not enforced by the language
.out.println(strv + dog + strv + Dog + strv + DOG + strv);"
"public class Test {
 
    static int mod(int n, int m) {
        return ((n % m) + m) % m;
    }
 
    static boolean isPrime(int n) {
        if (n == 2 || n == 3)
            return true;
        else if (n < 2 || n % 2 == 0 || n % 3 == 0)
            return false;
        for (int div = 5, inc = 2; .pow(div, 2) <= n;
                div += inc, inc = 6 - inc)
            if (n % div == 0)
                return false;
        return true;
    }
 
    public static void main([] args) {
        for (int p = 2; p < 62; p++) {
            if (!isPrime(p))
                continue;
            for (int h3 = 2; h3 < p; h3++) {
                int g = h3 + p;
                for (int d = 1; d < g; d++) {
                    if ((g * (p - 1)) % d != 0 || mod(-p * p, h3) != d % h3)
                        continue;
                    int q = 1 + (p - 1) * g / d;
                    if (!isPrime(q))
                        continue;
                    int r = 1 + (p * q / h3);
                    if (!isPrime(r) || (q * r) % (p - 1) != 1)
                        continue;
                    .out.printf(strv, p, q, r);
                }
            }
        }
    }
}"
"

MyClass.method(someParameter);
 


myInstance.method(someParameter);ClassWithStaticMethod.staticMethodName(argument1, argument2);//for methods with no arguments, use empty parenthesesClassWithMethod varName = new ClassWithMethod();
varName.methodName(argument1, argument2);
//or
new ClassWithMethod().methodName(argument1, argument2);"
"public class LoadLib{
   private static native void functionInSharedLib(); //change return type or parameters as necessary
 
   public static void main([] args){
      .loadLibrary(strv);
      functionInSharedLib();
   }
}import com.sun.jna.Library;
import com.sun.jna.Native;
 
public class LoadLibJNA{
   private interface YourSharedLibraryName extends Library{
      //put shared library functions here with no definition
      public void sharedLibraryfunction();
   }
 
   public static void main([] args){
      YourSharedLibraryName lib = (YourSharedLibraryName)Native.loadLibrary(strv,//as in strv
                                                                          YourSharedLibraryName.class);
      lib.sharedLibraryFunction();
   }
}"
"myMethod()myMethod(97, 3.14)int myMethod(int a, double b){
    

}
 
int myMethod(int a){
    return f(a, 1.414);
}.out.println( myMethod( 97, 3.14 ) );
.out.println( myMethod( 97 ) );void printAll(... strings){
    for (  s : strings )
        .out.println( s );
}printAll( strv );
printAll( strv, strv, strv );int myMethod( Map<,Object> params ){
    return
       (()params.get(strv)).intValue()
       + (()params.get(strv)).intValue();
}.out.println( myMethod(new HashMap<,Object>(){{put(strv,27);put(strv,52);}}) );int i = myMethod(x);myMethod(List<String> list){
    

}"
"public class JNIDemo
{
  static
  {  .loadLibrary(strv);  }
 
  public static void main([] args)
  {
    .out.println(callStrdup(strv));
  }
 
  private static native  callStrdup( s);
}"
"import java.text.*;
import java.util.*;
 
public class CalendarTask {
 
    public static void main([] args) {
        printCalendar(1969, 3);
    }
 
    static void printCalendar(int year, int nCols) {
        if (nCols < 1 || nCols > 12)
            throw new (strv);
 
         date = new (year, 0, 1);
 
        int nRows = (int) .ceil(12.0 / nCols);
        int offs = date.get(.DAY_OF_WEEK) - 1;
        int w = nCols * 24;
 
        [] monthNames = new (.US).getMonths();
 
        [][] mons = new [12][8];
        for (int m = 0; m < 12; m++) {
 
             name = monthNames[m];
            int len = 11 + name.length() / 2;
             format = .format(strv, len, 21 - len);
 
            mons[m][0] = .format(format, name, strv);
            mons[m][1] = strv;
            int dim = date.getActualMaximum(.DAY_OF_MONTH);
 
            for (int d = 1; d < 43; d++) {
                boolean isDay = d > offs && d <= offs + dim;
                 entry = isDay ? .format(strv, d - offs) : strv;
                if (d % 7 == 1)
                    mons[m][2 + (d - 1) / 7] = entry;
                else
                    mons[m][2 + (d - 1) / 7] += entry;
            }
            offs = (offs + dim) % 7;
            date.add(.MONTH, 1);
        }
 
        .out.printf(strv + (w / 2 + 10) + strv, strv);
        .out.printf(strv + (w / 2 + 4) + strv, year);
 
        for (int r = 0; r < nRows; r++) {
            for (int i = 0; i < 8; i++) {
                for (int c = r * nCols; c < (r + 1) * nCols && c < 12; c++)
                    .out.printf(strv, mons[c][i]);
                .out.println();
            }
            .out.println();
        }
    }
}"
"import java.lang.reflect.*;
 
class Example {
    private  _name;
    public Example( name) { _name = name; }
    public  toString() { return strv + _name; }
}
 
public class BreakPrivacy {
    public static final void main([] args) throws  {
        Example foo = new Example(strv);
 
        for ( f : Example.class.getDeclaredFields()) { 
	    if (f.getName().equals(strv)) {
                

                f.setAccessible(true);
 
                

                .out.println(f.get(foo));
 
                

                f.set(foo, strv);
		.out.println(foo);
 
                break;
            }
        }
    }
}"
"import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.util.*;
import javax.swing.JFrame;
 
public class BrownianTree extends  implements  {
 
     I;
    private List<Particle> particles;
    static  rand = new ();
 
    public BrownianTree() {
        super(strv);
        setBounds(100, 100, 400, 300);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        I = new (getWidth(), getHeight(), .TYPE_INT_RGB);
        I.setRGB(I.getWidth() / 2, I.getHeight() / 2, 0xff00);
        particles = new LinkedList<Particle>();
    }
 
    @Override
    public void paint( g) {
        g.drawImage(I, 0, 0, this);
    }
 
    public void run() {
        for (int i = 0; i < 20000; i++) {
            particles.add(new Particle());
        }
        while (!particles.isEmpty()) {
            for (Iterator<Particle> it = particles.iterator(); it.hasNext();) {
                if (it.next().move()) {
                    it.remove();
                }
            }
            repaint();
        }
    }
 
    public static void main([] args) {
        BrownianTree b = new BrownianTree();
        b.setVisible(true);
        new (b).start();
    }
 
    private class Particle {
 
        private int x, y;
 
        private Particle() {
            x = rand.nextInt(I.getWidth());
            y = rand.nextInt(I.getHeight());
        }
 
        /* returns true if either out of bounds or collided with tree */
        private boolean move() {
            int dx = rand.nextInt(3) - 1;
            int dy = rand.nextInt(3) - 1;
            if ((x + dx < 0) || (y + dy < 0)
                    || (y + dy >= I.getHeight()) || (x + dx >= I.getWidth())) {
                return true;
            }
            x += dx;
            y += dy;
            if ((I.getRGB(x, y) & 0xff00) == 0xff00) {
                I.setRGB(x - dx, y - dy, 0xff00);
                return true;
            }
            return false;
        }
    }
}import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
 
import javax.imageio.ImageIO;
 
public class BasicBrownianTree {
 
    private int pixelsLost;
    private  p;
    private  nextP;
    private int pixelCount;
    private int width;
    private int height;
    private int color;
    private  img;
 
    public BasicBrownianTree( int argb, int size, double density ) {
        pixelsLost = 0;
        p = new ();
        nextP = new ();
        width = size;
        height = size;
        color = argb;
        pixelCount = (int) ( width * height * density );
        img = new ( width, height, .TYPE_INT_ARGB );
    }
 
    public void generate() {
        

        .out.println( strv + pixelCount + strv );
        int background = img.getRGB( 0, 0 );
        img.setRGB( width / 2, height / 2, color );
 
        for( int i = 0; i < pixelCount; i++ ) {
            p.x = (int) ( .random() * width );
            p.y = (int) ( .random() * height );
 
            while ( true ) {
                int dx = (int) ( .random() * 3 ) - 1;
                int dy = (int) ( .random() * 3 ) - 1;
                nextP.setLocation( p.x + dx, p.y + dy );
                

                if ( nextP.x < 0 || nextP.x >= width || nextP.y < 0
                        || nextP.y >= height ) {
                        

                    pixelsLost++;
                    break;
                }
                if ( img.getRGB( nextP.x, nextP.y ) != background ) {
                    img.setRGB( p.x, p.y, color );
                    break;
                }
                p.setLocation( nextP );
            }
            

            if ( i % ( pixelCount / 50 ) == 0 ) {
                .out.println( strv + i + strv );
            }
        }
        

        .out.println( strv + pixelsLost );
    }
 
    public  getImage() {
        return img;
    }
 
    public int getWidth() {
        return width;
    }
 
    public int getHeight() {
        return height;
    }
 
    public static void main( [] args ) {
        

        BasicBrownianTree generator = new BasicBrownianTree( 0x664444ff, 400, 0.4 );
        

        generator.generate();
        try {
            

            ImageIO.write( generator.getImage(), strv, new ( strv ) );
        } catch (  e ) {
            e.printStackTrace();
        }
    }
}boolean SIDESTICK = false;
boolean[][] isTaken;
 
void setup() {
  size(512, 512);
  isTaken = new boolean[width][height];
  isTaken[width/2][height/2] = true;
}
 
void draw() {
  for (int i = 0; i < width*height; i++) {
    int x = floor(random(width));
    int y = floor(random(height));
    if (isTaken[x][y]) { continue; }
    while (true) {
      int xp = x + floor(random(-1, 2));
      int yp = y + floor(random(-1, 2));
      boolean iscontained = (
        0 <= xp && xp < width  && 
        0 <= yp && yp < height
      );
      if (iscontained && !isTaken[xp][yp]) {
        x = xp;
        y = yp;
        continue;
      }
      else {
        if (SIDESTICK || (iscontained && isTaken[xp][yp])) {
          isTaken[x][y] = true;
          set(x, y, #000000);
        }
        break;
      }
    }
  }
  noLoop();
}"
"public class BraceExpansion {
 
    public static void main([] args) {
        for ( s : new []{strv,
            strv,
            ""{,{,gotta have{ ,, again, }}more }cowbell!"",
            ""{}} some }{,{{ edge, edge} ,}{ cases, {here} }""}) {
            .out.println();
            expand(s);
        }
    }
 
    public static void expand( s) {
        expandR(strv, s, strv);
    }
 
    private static void expandR( pre,  s,  suf) {
        int i1 = -1, i2 = 0;
         noEscape = s.replaceAll(""([]{2}|[][,}{])"", strv);
        StringBuilder sb = null;
 
        outer:
        while ((i1 = noEscape.indexOf('{', i1 + 1)) != -1) {
            i2 = i1 + 1;
            sb = new StringBuilder(s);
            for (int depth = 1; i2 < s.length() && depth > 0; i2++) {
                char c = noEscape.charAt(i2);
                depth = (c == '{') ? ++depth : depth;
                depth = (c == '}') ? --depth : depth;
                if (c == ',' && depth == 1) {
                    sb.setCharAt(i2, '0000');
                } else if (c == '}' && depth == 0 && sb.indexOf(""0000"") != -1)
                    break outer;
            }
        }
        if (i1 == -1) {
            if (suf.length() > 0)
                expandR(pre + s, suf, strv);
            else
                .out.printf(strv, pre, s, suf);
        } else {
            for ( m : sb.substring(i1 + 1, i2).split(""0000"", -1))
                expandR(pre + s.substring(0, i1), m, s.substring(i2 + 1) + suf);
        }
    }
}"
"public class BoxingTheCompass{
    private static [] points = new [32];
 
    public static void main([] args){
        buildPoints();
 
        double heading = 0;
 
        for(int i = 0; i<= 32;i++){
            heading = i * 11.25;
            switch(i % 3){
                case 1:
                    heading += 5.62;
                    break;
                case 2:
                    heading -= 5.62;
                    break;
                default:
            }
 
            .out.printf(""%s%18s%s°"",(i % 32) + 1, initialUpper(getPoint(heading)), heading);
        }
    }
 
    private static void buildPoints(){
        [] cardinal = {strv, strv, strv, strv};
        [] pointDesc = {strv, strv, strv, strv, strv, strv, strv, strv};
 
         str1, str2, strC;
 
        for(int i = 0;i <= 3;i++){
            str1 = cardinal[i];
            str2 = cardinal[(i + 1) % 4];
            strC = (str1.equals(strv) || str1.equals(strv)) ? (str1 + str2): (str2 + str1);
            for(int j = 0;j <= 7;j++){
                points[i * 8 + j] = pointDesc[j].replace(strv, str1).replace(strv, str2).replace(strv, strC);
            }
        }
    }
 
    private static  initialUpper( s){
        return s.substring(0, 1).toUpperCase() + s.substring(1);
    }
 
    private static  getPoint(double degrees){
        double testD = (degrees / 11.25) + 0.5;
        return points[(int).floor(testD % 32)];
    }
}"
"public static void bitwise(int a, int b){
  .out.println(strv + (a & b));
  .out.println(strv+ (a | b));
  .out.println(strv+ (a ^ b));
  .out.println(strv + ~a);
  .out.println(strv + (a << b)); 

  .out.println(strv + (a >> b)); 

  .out.println(strv + (a >>> b)); 

  .out.println(strv + .rotateLeft(a, b)); //rotate left, Java 1.5+
  .out.println(strv + .rotateRight(a, b)); //rotate right, Java 1.5+
}a <<= 3;
a = a << 3;
a *= 8; //2 * 2 * 2 = 8
a = a * 8;"
" 
package bitmap;
 
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;
 
/*** Image processing functions such as histogram, grayscale,..* here we assume we  have a YUV image. so we process only luma component Y* the histogram can be called on luma pixel only (values from 0 to 255)* greyscale is done with a constant middle value of FullRange / 2 = 127*/
public class ImageProc {
 
    static final private  MAX_VAL = 255;
    static final private  MIN_VAL = 0;
    static final private  MID_RANGE = (MAX_VAL - MIN_VAL) >> 1;
 
    private static [] lumaHist([] luma, length) {
        

        

            if ((length == 0 )|| (luma == null)){
                return null;
            }
            double stepd = .sqrt(length);
            

            int step = (int)stepd ;
             width = (int)(length / stepd);
            

            

            

            

 
            List<Integer> interv[] = new [step];
             hist[] = new [step];
            interv[0] = .stream(luma)
                                .parallel() 
                                .sorted()
                                .filter(value -> value >= width) 
                                .collect(Collectors.toList());
            hist[0] = length - interv[0].size();
 
            

            

            

            

            

            

            for (int i =1; i < step; i++){
 
                interv[i] = interv[i-1].stream()
                                     .map(value -> value -= width)
                                     .filter(value -> value >= width) 
                                     .collect(Collectors.toList());
                hist[i] = interv[i-1].size() - interv[i].size();
          }
 
            return hist;
	}
 
        private static [] blackAndWhite([] luma, length) {
 
            List<Integer>  bwPict ;
            

            

 
           double average;
            average = Stream.of(luma).map(i -> i.toString())
                                     .mapToInt(::parseInt)
                                     .average()
                                     .getAsDouble();
           .out.println(strv  +average);
           

           

            bwPict= .stream(luma)
                          .parallel() 
                          .map(value -> (value > average) ?MAX_VAL: MIN_VAL) 
                          .collect(Collectors.toList());
 
             retPict[] = new [bwPict.size()];
            return bwPict.toArray(retPict);
        }
 
	public static void main ([] args)
	{
            [] histo;
             img_y[] = new [256];
            

             r = new ();
            for (int i=0;i< img_y.length; i++) {
                img_y[i] = r.nextInt(MAX_VAL);
            }
 
           

            histo = lumaHist(img_y,img_y.length);
 
	    .out.println(strv + histo.length );
 
            int sum = 0;
            for (int i=0; i< histo.length;i++) {
                .out.println(strv + i + strv + histo[i]);
                sum +=histo[i];
            }
            

            

            if (sum != img_y.length){
                .out.println(""Error in histogram processing!""
                                + strv);
            }
             hist[] = new [16];
            .fill(hist, 0);
            for (int i=0;i< 256; i++) {
                if (img_y[i] < 16) hist[0]++;
                else if (img_y[i] < 32) hist[1]++;
                else if (img_y[i] < 48) hist[2]++;
                else if (img_y[i] < 64) hist[3]++;
                else if (img_y[i] < 80) hist[4]++;
                else if (img_y[i] < 96) hist[5]++;
                else if (img_y[i] < 112) hist[6]++;
                else if (img_y[i] < 128) hist[7]++;
                else if (img_y[i] < 144) hist[8]++;
                else if (img_y[i] < 160) hist[9]++;
                else if (img_y[i] < 176) hist[10]++;
                else if (img_y[i] < 192) hist[11]++;
                else if (img_y[i] < 208) hist[12]++;
                else if (img_y[i] < 224) hist[13]++;
                else if (img_y[i] < 240) hist[14]++;
                else  hist[15]++;
 
            }
            if (hist.length != histo.length) {
                .out.println(""Error in histogram processing!""
                                    + strv);
                return;
            }
            else {
                for (int i=0; i< histo.length;i++) {
                    if (!Objects.equals(hist[i], histo[i])) {
                        .out.println(""Error in histogram processing!""
                                    + strv + i 
                                    + strv + histo[i] 
                                    +  strv + hist[i] + """");
                        return;
                    }
                }
            }
            .out.println(""Test OK"");
 
          

             pictBW[];
            pictBW = blackAndWhite(img_y,img_y.length);
 
             for (int i=0;i< img_y.length; i++) {
                 .out.println(strv + i +strv + img_y[i] +
                                    strv + i +strv +pictBW[i] );
             }
 
	}
}
 "
"import java.awt.Color;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.util.Deque;
import java.util.LinkedList;
 
public class FloodFill {
  public void floodFill( image,  node,  targetColor,  replacementColor) {
    int width = image.getWidth();
    int height = image.getHeight();
    int target = targetColor.getRGB();
    int replacement = replacementColor.getRGB();
    if (target != replacement) {
      Deque<Point> queue = new LinkedList<Point>();
      do {
        int x = node.x;
        int y = node.y;
        while (x > 0 && image.getRGB(x - 1, y) == target) {
          x--;
        }
        boolean spanUp = false;
        boolean spanDown = false;
        while (x < width && image.getRGB(x, y) == target) {
          image.setRGB(x, y, replacement);
          if (!spanUp && y > 0 && image.getRGB(x, y - 1) == target) {
            queue.add(new (x, y - 1));
            spanUp = true;
          } else if (spanUp && y > 0 && image.getRGB(x, y - 1) != target) {
            spanUp = false;
          }
          if (!spanDown && y < height - 1 && image.getRGB(x, y + 1) == target) {
            queue.add(new (x, y + 1));
            spanDown = true;
          } else if (spanDown && y < height - 1 && image.getRGB(x, y + 1) != target) {
            spanDown = false;
          }
          x++;
        }
      } while ((node = queue.pollFirst()) != null);
    }
  }
}import java.io.IOException;
import java.awt.Color;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;
 
public class Test {
  public Test() throws  {
     image = ImageIO.read(new (strv));
    new FloodFill().floodFill(image, new (50, 50), .WHITE, .RED);
    ImageIO.write(image, strv, new (strv));
  }
 
  public static void main([] args) throws  {
    new Test();
  }
}"
" 
import java.awt.Color;
 
public class MidPointCircle {
	private BasicBitmapStorage image;
 
	public MidPointCircle(final int imageWidth, final int imageHeight) {
		this.image = new BasicBitmapStorage(imageWidth, imageHeight);
	}
 
	private void drawCircle(final int centerX, final int centerY, final int radius) {
		int d = (5 - r * 4)/4;
		int x = 0;
		int y = radius;
		 circleColor = .white;
 
		do {
			image.setPixel(centerX + x, centerY + y, circleColor);
			image.setPixel(centerX + x, centerY - y, circleColor);
			image.setPixel(centerX - x, centerY + y, circleColor);
			image.setPixel(centerX - x, centerY - y, circleColor);
			image.setPixel(centerX + y, centerY + x, circleColor);
			image.setPixel(centerX + y, centerY - x, circleColor);
			image.setPixel(centerX - y, centerY + x, circleColor);
			image.setPixel(centerX - y, centerY - x, circleColor);
			if (d < 0) {
				d += 2 * x + 1;
			} else {
				d += 2 * (x - y) + 1;
				y--;
			}
			x++;
		} while (x <= y);
 
	}
}
 "
"private final static  ALPHABET = strv;
 
public static void main([] args) {
    Assert(strv, ValidateBitcoinAddress(strv), true);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), true);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
    Assert(strv, ValidateBitcoinAddress(strv), false);
}
 
public static boolean ValidateBitcoinAddress( addr) {
    if (addr.length() < 26 || addr.length() > 35) return false;
    byte[] decoded = DecodeBase58(addr, 58, 25);
    if (decoded == null) return false;
 
    byte[] hash = Sha256(decoded, 0, 21, 2);
 
    return .equals(.copyOfRange(hash, 0, 4), .copyOfRange(decoded, 21, 25));
}
 
private static byte[] DecodeBase58( input, int base, int len) {
    byte[] output = new byte[len];
    for (int i = 0; i < input.length(); i++) {
        char t = input.charAt(i);
 
        int p = ALPHABET.indexOf(t);
        if (p == -1) return null;
        for (int j = len - 1; j >= 0; j--, p /= 256) {
            p += base * (output[j] & 0xFF);
            output[j] = (byte) (p % 256);
        }
        if (p != 0) return null;
    }
 
    return output;
}
 
private static byte[] Sha256(byte[] data, int start, int len, int recursion) {
    if (recursion == 0) return data;
 
    try {
         md = .getInstance(strv);
        md.update(.copyOfRange(data, start, start + len));
        return Sha256(md.digest(), 0, 32, recursion - 1);
    } catch ( e) {
        return null;
    }
}
 
public static void Assert( name, boolean value, boolean expected) {
    if (value ^ expected)
        throw new (strv + name + strv);
    else
        .out.println(name + strv);
}"
"import java.awt.*;
import javax.swing.*;
 
public class Bresenham extends  {
 
    public static void main([] args) {
        .invokeLater(new () {
            @Override
            public void run() {
                 f = new Bresenham();
                f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
                f.setVisible(true);
                f.add(new BresenhamPanel(), .CENTER);
                f.setTitle(strv);
                f.setResizable(false);
                f.pack();
                f.setLocationRelativeTo(null);
            }
        });
    }
}
 
class BresenhamPanel extends  {
    final int centerX, centerY;
 
    public BresenhamPanel() {
        int w = 600;
        int h = 500;
        centerX = w / 2;
        centerY = h / 2;
        setPreferredSize(new (w, h));
        setBackground(.white);
    }
 
    @Override
    public void paintComponent( g) {
        super.paintComponent(g);
 
        drawLine(g, 0, 0, 8, 19); 

        drawLine(g, 0, 0, 19, 8); 

        drawLine(g, 0, 0, 19, -8); 

        drawLine(g, 0, 0, 8, -19); 

        drawLine(g, 0, 0, -8, -19); 

        drawLine(g, 0, 0, -19, -8); 

        drawLine(g, 0, 0, -19, 8); 

        drawLine(g, 0, 0, -8, 19); 

    }
 
    private void plot( g, int x, int y) {
        g.setColor(.black);
        g.drawOval(centerX + (x * 10), centerY + (-y * 10), 10, 10);
    }
 
    private void drawLine( g, int x1, int y1, int x2, int y2) {
        

        int d = 0;
 
        int dy = .abs(y2 - y1);
        int dx = .abs(x2 - x1);
 
        int dy2 = (dy << 1); 

        int dx2 = (dx << 1); 

 
        int ix = x1 < x2 ? 1 : -1; 

        int iy = y1 < y2 ? 1 : -1;
 
        if (dy <= dx) {
            for (;;) {
                plot(g, x1, y1);
                if (x1 == x2)
                    break;
                x1 += ix;
                d += dy2;
                if (d > dx) {
                    y1 += iy;
                    d -= dx2;
                }
            }
        } else {
            for (;;) {
                plot(g, x1, y1);
                if (y1 == y2)
                    break;
                y1 += iy;
                d += dx2;
                if (d > dy) {
                    x1 += ix;
                    d -= dy2;
                }
            }
        }
    }
}"
"import static java.util..stream;
import java.util.Random;
 
public class Test {
 
    static double equalBirthdays(int nSharers, int groupSize, int nRepetitions) {
         rand = new (1);
 
        int eq = 0;
 
        for (int i = 0; i < nRepetitions; i++) {
            int[] group = new int[365];
            for (int j = 0; j < groupSize; j++)
                group[rand.nextInt(group.length)]++;
            eq += stream(group).anyMatch(c -> c >= nSharers) ? 1 : 0;
        }
 
        return (eq * 100.0) / nRepetitions;
    }
 
    public static void main([] a) {
 
        int groupEst = 2;
 
        for (int sharers = 2; sharers < 6; sharers++) {
            

            int groupSize = groupEst + 1;
            while (equalBirthdays(sharers, groupSize, 100) < 50.0)
                groupSize++;
 
            

            int inf = (int) (groupSize - (groupSize - groupEst) / 4.0);
            for (int gs = inf; gs < groupSize + 999; gs++) {
                double eq = equalBirthdays(sharers, groupSize, 250);
                if (eq > 50.0) {
                    groupSize = gs;
                    break;
                }
            }
 
            

            for (int gs = groupSize - 1; gs < groupSize + 999; gs++) {
                double eq = equalBirthdays(sharers, gs, 50_000);
                if (eq > 50.0) {
                    groupEst = gs;
                    .out.printf(strv
                            + strv,
                            sharers, gs, eq);
                    break;
                }
            }
        }
    }
}"
"import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
 
public class BasicBitmapStorage
{
 private  image;
 
 public BasicBitmapStorage(final int width, final int height)
 {
  image = new (width, height, .TYPE_3BYTE_BGR);
 }
 
 public void fill(final  c)
 {
   g = image.getGraphics();
  g.setColor(c);
  g.fillRect(0, 0, image.getWidth(), image.getHeight());
 }
 
 public void setPixel(final int x, final int y, final  c)
 {
  image.setRGB(x, y, c.getRGB());
 }
 
 public  getPixel(final int x, final int y)
 {
  return new (image.getRGB(x, y));
 }
 
 public  getImage()
 {
  return image;
 }
}import java.awt.Color;
import junit.framework.TestCase;
 
public class BasicBitmapStorageTest extends TestCase
{
 public static final int WIDTH = 640, HEIGHT = 480;
 
 BasicBitmapStorage bbs = new BasicBitmapStorage(WIDTH, HEIGHT);
 
 public void testHappy()
 {
  bbs.fill(.cyan);
  bbs.setPixel(WIDTH / 2, HEIGHT / 2, .BLACK);
   c1 = bbs.getPixel(WIDTH / 2, HEIGHT / 2);
   c2 = bbs.getPixel(20, 20);
  assertEquals(.BLACK, c1);
  assertEquals(.CYAN, c2);
 }
}"
"...
//check will be the number we are looking for
//nums will be the array we are searching through
public static int binarySearch(int[] nums, int check){
        int hi = nums.length - 1;
        int lo = 0;
        while(hi >= lo){
                int guess = lo + ((hi - lo) / 2);
                if(nums[guess] > check){
                        hi = guess - 1;
                }else if(nums[guess] < check){
                        lo = guess + 1;
                }else{
                        return guess;
                }
        }
        return -1;
}
 
public static void main([] args){
        int[] searchMe;
        int someNumber;
        ...
        int index = binarySearch(searchMe, someNumber);
        .out.println(someNumber + ((index == -1) ? strv : (strv + index)));
        ...
}public static void main([] args){
        int[] searchMe;
        int someNumber;
        ...
        int index = binarySearch(searchMe, someNumber, 0, searchMe.length);
        .out.println(someNumber + ((index == -1) ? strv : (strv + index)));
        ...
}
 
public static int binarySearch(int[] nums, int check, int lo, int hi){
        if(hi < lo){
                return -1; //impossible index for strv
        }
        int guess = (hi + lo) / 2;
        if(nums[guess] > check){
                return binarySearch(nums, check, lo, guess - 1);
        }else if(nums[guess]<check){
                return binarySearch(nums, check, guess + 1, hi);
        }
        return guess;
}import java.util.Arrays;
 
int index = .binarySearch(array, thing);
int index = .binarySearch(array, startIndex, endIndex, thing);
 


int index = .binarySearch(array, thing, comparator);
int index = .binarySearch(array, startIndex, endIndex, thing, comparator);import java.util.Collections;
 
int index = .binarySearch(list, thing);
int index = .binarySearch(list, thing, comparator);"
"public class Main {
    public static void main([] args) {
        .out.println(.toBinaryString(5));
        .out.println(.toBinaryString(50));
        .out.println(.toBinaryString(9000));
    }
}"
"import java.util.Random;
 
public class BestShuffle {
    private final static  rand = new ();
 
    public static void main([] args) {
        [] words = {strv, strv, strv, strv, strv, strv};
        for ( w : words)
            .out.println(bestShuffle(w));
    }
 
    public static  bestShuffle(final  s1) {
        char[] s2 = s1.toCharArray();
        shuffle(s2);
        for (int i = 0; i < s2.length; i++) {
            if (s2[i] != s1.charAt(i))
                continue;
            for (int j = 0; j < s2.length; j++) {
                if (s2[i] != s2[j] && s2[i] != s1.charAt(j) && s2[j] != s1.charAt(i)) {
                    char tmp = s2[i];
                    s2[i] = s2[j];
                    s2[j] = tmp;
                    break;
                }
            }
        }
        return s1 + strv + new (s2) + strv + count(s1, s2) + strv;
    }
 
    public static void shuffle(char[] text) {
        for (int i = text.length - 1; i > 0; i--) {
            int r = rand.nextInt(i + 1);
            char tmp = text[i];
            text[i] = text[r];
            text[r] = tmp;
        }
    }
 
    private static int count(final  s1, final char[] s2) {
        int count = 0;
        for (int i = 0; i < s2.length; i++)
            if (s1.charAt(i) == s2[i])
                count++;
        return count;
    }
}"
"package org.rosettacode;
 
import java.io.IOException;
import java.io.InputStream;
 
public class Base64
{
    static  base64 (final  is) throws 
    {
        final char[] alpha = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
                'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0',
                '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };
        final StringBuilder sb = new StringBuilder ();
        final byte c[] = new byte[4];
        long u;
        int len;
        int w = 0;
 
        do
        {
            c[1] = c[2] = 0;
 
            if ( (len = is.read (c, 0, 3)) == 0)
                break;
            u = ( ((long) c[0]) << 16) | ( ((long) c[1]) << 8) | c[2];
 
            sb.append (alpha[(int) ( (u >> 18) & 63)]);
            sb.append (alpha[(int) ( (u >> 12) & 63)]);
            sb.append (len < 2 ? '=' : alpha[(int) (u >> 6) & 63]);
            sb.append (len < 3 ? '=' : alpha[(int) u & 63]);
 
            if (++w == 19)
            {
                w = 0;
                sb.append ('');
            }
        }
        while (len == 3);
 
        if (w > 0)
            sb.append ('');
 
        return sb.toString ();
    }
    public static void main (final [] args)
    {
        

        

 
        

        try ( is = Base64.class.getResourceAsStream(strv))
        {
            .out.println (Base64.base64 (is));
        }
        catch (final  e)
        {
            e.printStackTrace (.err);
        }
    }
}
 import java.nio.file.*;
import java.util.Base64;
 
public class Base64Task {
 
    public static void main([] args) throws  {
        byte[] bytes = Files.readAllBytes(Paths.get(strv));
         result = Base64.getEncoder().encodeToString(bytes);
        .out.println(result);
    }
}"
"import java.math.BigInteger;
 
public class Benford {
    private static interface NumberGenerator {
        [] getNumbers();
    }
 
    private static class FibonacciGenerator implements NumberGenerator {
        public [] getNumbers() {
            final [] fib = new [ 1000 ];
            fib[ 0 ] = fib[ 1 ] = .ONE;
            for ( int i = 2; i < fib.length; i++ )
                fib[ i ] = fib[ i - 2 ].add( fib[ i - 1 ] );
            return fib;
        }
    }
 
    private final int[] firstDigits = new int[ 9 ];
    private final int   count;
 
    private Benford( final NumberGenerator ng ) {
        final [] numbers = ng.getNumbers();
        count = numbers.length;
        for ( final  number : numbers )
            firstDigits[ .valueOf( number.toString().substring( 0, 1 ) ) - 1 ]++;
    }
 
    public  toString() {
        final StringBuilder result = new StringBuilder();
        for ( int i = 0; i < firstDigits.length; i++ )
            result.append( i + 1 )
                .append( '' ).append( firstDigits[ i ] / ( double )count )
                .append( '' ).append( .log10( 1 + 1d / ( i + 1 ) ) )
                .append( '' );
        return result.toString();
    }
 
    public static void main( final [] args ) {
        .out.println( new Benford( new FibonacciGenerator() ) );
    }
}"
"import org.apache.commons.math3.fraction.BigFraction;
 
public class BernoulliNumbers {
 
    public static void main([] args) {
        for (int n = 0; n <= 60; n++) {
            BigFraction b = bernouilli(n);
            if (!b.equals(BigFraction.ZERO))
                .out.printf(strv, n , b);
        }
    }
 
    static BigFraction bernouilli(int n) {
        BigFraction[] A = new BigFraction[n + 1];
        for (int m = 0; m <= n; m++) {
            A[m] = new BigFraction(1, (m + 1));
            for (int j = m; j >= 1; j--)
                A[j - 1] = (A[j - 1].subtract(A[j])).multiply(new BigFraction(j));
        }
        return A[0];
    }
}"
"import java.awt.*;
import java.awt.image.BufferedImage;
import javax.swing.*;
 
public class BarnsleyFern extends  {
 
     img;
 
    public BarnsleyFern() {
        final int dim = 640;
        setPreferredSize(new (dim, dim));
        setBackground(.white);
        img = new (dim, dim, .TYPE_INT_ARGB);
        createFern(dim, dim);
    }
 
    void createFern(int w, int h) {
        double x = 0;
        double y = 0;
 
        for (int i = 0; i < 200_000; i++) {
            double tmpx, tmpy;
            double r = .random();
 
            if (r <= 0.01) {
                tmpx = 0;
                tmpy = 0.16 * y;
            } else if (r <= 0.08) {
                tmpx = 0.2 * x - 0.26 * y;
                tmpy = 0.23 * x + 0.22 * y + 1.6;
            } else if (r <= 0.15) {
                tmpx = -0.15 * x + 0.28 * y;
                tmpy = 0.26 * x + 0.24 * y + 0.44;
            } else {
                tmpx = 0.85 * x + 0.04 * y;
                tmpy = -0.04 * x + 0.85 * y + 1.6;
            }
            x = tmpx;
            y = tmpy;
 
            img.setRGB((int) .round(w / 2 + x * w / 11),
                    (int) .round(h - y * h / 11), 0xFF32CD32);
        }
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        g.drawImage(img, 0, 0, null);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new BarnsleyFern(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}void setup() {
  size(640, 640);
  background(0, 0, 0);
}
 
float x = 0;
float y = 0;
 
void draw() {
  for (int i = 0; i < 100000; i++) {
 
    float xt = 0;
    float yt = 0;
 
    float r = random(100);
 
    if (r <= 1) {
      xt = 0;
      yt = 0.16*y;
    } else if (r <= 8) {
      xt = 0.20*x - 0.26*y;
      yt = 0.23*x + 0.22*y + 1.60;
    } else if (r <= 15) {
      xt = -0.15*x + 0.28*y;
      yt =  0.26*x + 0.24*y + 0.44;
    } else {
      xt =  0.85*x + 0.04*y;
      yt = -0.04*x + 0.85*y + 1.60;
    }
 
    x = xt;
    y = yt;
 
    int m = round(width/2 + 60*x);
    int n = height-round(60*y);
 
    set(m, n, #00ff00);
  }
  noLoop();
}"
"public class Test {
 
    public static void main([] args) {
 
        

        int n = 0;
 
        

        do {
 
            

            n++;
 
        

        } while (n * n % 1000_000 != 269696);
 
        

        .out.println(n);
    }
}



 


 
int n;
 


 


 
n = 0;
 




 




 
do {
    n = n + 1;
} while (n * n % 1000000 != 269696);
 










 


 


 
println(n);"
"public class AVLtree {
 
    private Node root;
 
    private class Node {
        private int key;
        private int balance;
        private int height;
        private Node left, right, parent;
 
        Node(int k, Node p) {
            key = k;
            parent = p;
        }
    }
 
    public boolean insert(int key) {
        if (root == null)
            root = new Node(key, null);
        else {
            Node n = root;
            Node parent;
            while (true) {
                if (n.key == key)
                    return false;
 
                parent = n;
 
                boolean goLeft = n.key > key;
                n = goLeft ? n.left : n.right;
 
                if (n == null) {
                    if (goLeft) {
                        parent.left = new Node(key, parent);
                    } else {
                        parent.right = new Node(key, parent);
                    }
                    rebalance(parent);
                    break;
                }
            }
        }
        return true;
    }
 
    private void delete(Node node){
        if(node.left == null && node.right == null){
            if(node.parent == null) root = null;
            else{
                Node parent = node.parent;
                if(parent.left == node){
                    parent.left = null;
                }else parent.right = null;
                rebalance(parent);
            }
            return;
        }
        if(node.left!=null){
            Node child = node.left;
            while (child.right!=null) child = child.right;
            node.key = child.key;
            delete(child);
        }else{
            Node child = node.right;
            while (child.left!=null) child = child.left;
            node.key = child.key;
            delete(child);
        }
    }
 
    public void delete(int delKey) {
        if (root == null)
            return;
        Node node = root;
        Node child = root;
 
        while (child != null) {
            node = child;
            child = delKey >= node.key ? node.right : node.left;
            if (delKey == node.key) {
                delete(node);
                return;
            }
        }
    }
 
    private void rebalance(Node n) {
        setBalance(n);
 
        if (n.balance == -2) {
            if (height(n.left.left) >= height(n.left.right))
                n = rotateRight(n);
            else
                n = rotateLeftThenRight(n);
 
        } else if (n.balance == 2) {
            if (height(n.right.right) >= height(n.right.left))
                n = rotateLeft(n);
            else
                n = rotateRightThenLeft(n);
        }
 
        if (n.parent != null) {
            rebalance(n.parent);
        } else {
            root = n;
        }
    }
 
    private Node rotateLeft(Node a) {
 
        Node b = a.right;
        b.parent = a.parent;
 
        a.right = b.left;
 
        if (a.right != null)
            a.right.parent = a;
 
        b.left = a;
        a.parent = b;
 
        if (b.parent != null) {
            if (b.parent.right == a) {
                b.parent.right = b;
            } else {
                b.parent.left = b;
            }
        }
 
        setBalance(a, b);
 
        return b;
    }
 
    private Node rotateRight(Node a) {
 
        Node b = a.left;
        b.parent = a.parent;
 
        a.left = b.right;
 
        if (a.left != null)
            a.left.parent = a;
 
        b.right = a;
        a.parent = b;
 
        if (b.parent != null) {
            if (b.parent.right == a) {
                b.parent.right = b;
            } else {
                b.parent.left = b;
            }
        }
 
        setBalance(a, b);
 
        return b;
    }
 
    private Node rotateLeftThenRight(Node n) {
        n.left = rotateLeft(n.left);
        return rotateRight(n);
    }
 
    private Node rotateRightThenLeft(Node n) {
        n.right = rotateRight(n.right);
        return rotateLeft(n);
    }
 
    private int height(Node n) {
        if (n == null)
            return -1;
        return n.height;
    }
 
    private void setBalance(Node... nodes) {
        for (Node n : nodes)
            reheight(n);
            n.balance = height(n.right) - height(n.left);
    }
 
    public void printBalance() {
        printBalance(root);
    }
 
    private void printBalance(Node n) {
        if (n != null) {
            printBalance(n.left);
            .out.printf(strv, n.balance);
            printBalance(n.right);
        }
    }
 
    private void reheight(Node node){
        if(node!=null){
            node.height=1 + .max(height(node.left), height(node.right));
        }
    }
 
    public static void main([] args) {
        AVLtree tree = new AVLtree();
 
        .out.println(strv);
        for (int i = 1; i < 10; i++)
            tree.insert(i);
 
        .out.print(strv);
        tree.printBalance();
    }
}"
"public class RMS {
    public static double rms(double[] nums){
        double ms = 0;
        for (int i = 0; i < nums.length; i++)
            ms += nums[i] * nums[i];
        ms /= nums.length;
        return .sqrt(ms);
    }
 
    public static	void main([] args){
        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};
        .out.println(strv + rms(nums));
    }
}"
" 
/* * Test case  * With balanced ternaries a from string strv: * Write out a, b and c in decimal notation; * Calculate a × (b − c), write out the result in both ternary and decimal notations.  */
public class BalancedTernary 
{
	public static void main([] args)
	{
 		BTernary a=new BTernary(strv);
		BTernary b=new BTernary(-436);
		BTernary c=new BTernary(strv);
 
		.out.println(strv+a.intValue());
		.out.println(strv+b.intValue());
		.out.println(strv+c.intValue());
		.out.println();
 
		//result=a*(b-c)
		BTernary result=a.mul(b.sub(c));
 
		.out.println(strv+result+strv+result.intValue());
	}
 
 
	public static class BTernary
	{
		 value;
		public BTernary( s)
		{
			int i=0;
			while(s.charAt(i)=='0')
				i++;
			this.value=s.substring(i);
		}
		public BTernary(int v)
		{
			this.value=strv;
			this.value=convertToBT(v);
		}
 
		private  convertToBT(int v)
		{
			if(v<0)
				return flip(convertToBT(-v));
			if(v==0)
				return strv;
			int rem=mod3(v);
			if(rem==0)
				return convertToBT(v/3)+strv;
			if(rem==1)
				return convertToBT(v/3)+strv;
			if(rem==2)
				return convertToBT((v+1)/3)+strv;
			return strv;
		}
		private  flip( s)
		{
			 flip=strv;
			for(int i=0;i<s.length();i++)
			{
				if(s.charAt(i)=='+')
					flip+='-';
				else if(s.charAt(i)=='-')
					flip+='+';
				else
					flip+='0';
			}
			return flip;
		}
		private int mod3(int v)
		{
			if(v>0)
				return v%3;
			v=v%3;
			return (v+3)%3;
		}
 
		public int intValue()
		{
			int sum=0;
			 s=this.value;
			for(int i=0;i<s.length();i++)
			{
				char c=s.charAt(s.length()-i-1);
				int dig=0;
				if(c=='+')
					dig=1;
				else if(c=='-')
					dig=-1;
				sum+=dig*.pow(3, i);
			}
			return sum;
		}
 
 
		public BTernary add(BTernary that)
		{
			 a=this.value;
			 b=that.value;
 
			 longer=a.length()>b.length()?a:b;
			 shorter=a.length()>b.length()?b:a;
 
			while(shorter.length()<longer.length())
				shorter=0+shorter;
 
			a=longer;
			b=shorter;
 
			char carry='0';
			 sum=strv;
			for(int i=0;i<a.length();i++)
			{
				int place=a.length()-i-1;
				 digisum=addDigits(a.charAt(place),b.charAt(place),carry);
				if(digisum.length()!=1)
					carry=digisum.charAt(0);
				else
					carry='0';
				sum=digisum.charAt(digisum.length()-1)+sum;
			}
			sum=carry+sum;
 
			return new BTernary(sum);
		}
		private  addDigits(char a,char b,char carry)
		{
			 sum1=addDigits(a,b);
			 sum2=addDigits(sum1.charAt(sum1.length()-1),carry);
			//System.out.println(carry+strv+sum2);
			if(sum1.length()==1)
				return sum2;
			if(sum2.length()==1)
				return sum1.charAt(0)+sum2;
			return sum1.charAt(0)+strv;
		}
		private  addDigits(char a,char b)
		{
			 sum=strv;
			if(a=='0')
				sum=b+strv;
			else if (b=='0')
				sum=a+strv;
			else if(a=='+')
			{
				if(b=='+')
					sum=strv;
				else
					sum=strv;
			}
			else
			{
				if(b=='+')
					sum=strv;
				else
					sum=strv;
			}
			return sum;
		}
 
		public BTernary neg()
		{
			return new BTernary(flip(this.value));
		}
 
		public BTernary sub(BTernary that)
		{
			return this.add(that.neg());
		}
 
		public BTernary mul(BTernary that)
		{
			BTernary one=new BTernary(1);
			BTernary zero=new BTernary(0);
			BTernary mul=new BTernary(0);
 
			int flipflag=0;
			if(that.compareTo(zero)==-1)
			{
				that=that.neg();
				flipflag=1;
			}
			for(BTernary i=new BTernary(1);i.compareTo(that)<1;i=i.add(one))
				mul=mul.add(this);
 
			if(flipflag==1)
				mul=mul.neg();
			return mul;
		}
 
		public boolean equals(BTernary that)
		{
			return this.value.equals(that.value);
		}
		public int compareTo(BTernary that)
		{
			if(this.intValue()>that.intValue())
				return 1;
			else if(this.equals(that))
				return 0;
			 return -1;
		}
 
		public  toString()
		{
			return value;
		}
	}
}
 "
"import java.util.*;
 
public class Mode {
    public static <T> List<T> mode(List<? extends T> coll) {
        Map<T, Integer> seen = new HashMap<T, Integer>();
        int max = 0;
        List<T> maxElems = new ArrayList<T>();
        for (T value : coll) {
            if (seen.containsKey(value))
                seen.put(value, seen.get(value) + 1);
            else
                seen.put(value, 1);
            if (seen.get(value) > max) {
                max = seen.get(value);
                maxElems.clear();
                maxElems.add(value);
            } else if (seen.get(value) == max) {
                maxElems.add(value);
            }
        }
        return maxElems;
    }
 
    public static void main([] args) {
        .out.println(mode(.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); 

        .out.println(mode(.asList(1, 1, 2, 4, 4))); 

    }
}"
"import java.util.Arrays;
import java.util.List;
 
public class PythagoreanMeans {
    public static double arithmeticMean(List<Double> numbers) {
        if (numbers.isEmpty()) return .NaN;
        double mean = 0.0;
        for ( number : numbers) {
            mean += number;
        }
        return mean / numbers.size();
    }
 
    public static double geometricMean(List<Double> numbers) {
        if (numbers.isEmpty()) return .NaN;
        double mean = 1.0;
        for ( number : numbers) {
            mean *= number;
        }
        return .pow(mean, 1.0 / numbers.size());
    }
 
    public static double harmonicMean(List<Double> numbers) {
        if (numbers.isEmpty() || numbers.contains(0.0)) return .NaN;
        double mean = 0.0;
        for ( number : numbers) {
            mean += (1.0 / number);
        }
        return numbers.size() / mean;
    }
 
    public static void main([] args) {
        [] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};
        List<Double> list = .asList(array);
        double arithmetic = arithmeticMean(list);
        double geometric = geometricMean(list);
        double harmonic = harmonicMean(list);
        .out.format(strv, arithmetic, geometric, harmonic);
        .out.format(strv, (arithmetic >= geometric), (geometric >= harmonic));
    }
} 
   public static double arithmAverage(double array[]){
       if (array == null ||array.length == 0) {
         return 0.0;
      }
      else {
         return DoubleStream.of(array).average().getAsDouble();
      }
   }
 
    public static double geomAverage(double array[]){
      if (array == null ||array.length == 0) {
         return 0.0;
      }
      else {
         double aver = DoubleStream.of(array).reduce(1, (x, y) -> x * y);
         return   .pow(aver, 1.0 / array.length);
      }
   }
 
     public static double harmAverage(double array[]){
         if (array == null ||array.length == 0) {
         return 0.0;
      }
      else {
         double aver = DoubleStream.of(array)
                  

                  .filter(n -> n > 0.0)
                  

                  .map( n-> 1.0/n)
                  

                  .reduce(0, (x, y) -> x + y);
                  

                 

         return   array.length / aver ;
      }
   }
 "
"import java.util.ArrayList;
 
public class AverageLoopLength {
	private static final int N = 100000;
	//analytical(n) = sum_(i=1)^n (n!/(n-i)!/n**i)
	public static float analytical(int n){
		float[] factorial = new float[n+1];
		float[] powers = new float[n+1];
		factorial[0] = powers[0] = 1;
		for(int i=1;i<=n;i++){
			factorial[i] = factorial[i-1] * i;
			powers[i] = powers[i-1] * n;
		}
		float sum = 0;
		//memoized factorial and powers
		for(int i=1;i<=n;i++){
			sum += factorial[n]/factorial[n-i]/powers[i];
		}
		return sum;
	}
	public static float average(int n){
		float sum = 0;
		for(int a=0;a<N;a++){
			int[] random = new int[n];
			for(int i=0;i<n;i++){
				random[i] = (int)(.random()*n);
			}
			ArrayList<Integer> seen = new ArrayList<>(n);
			int current = 0;
			int length = 0;
			while(true){
				length++;
				seen.add(current);
				current = random[current];
				if(seen.contains(current)){
					break;
				}
			}
			sum += length;
		}
		return sum/N;
	}
	public static void main( args[]){
		.out.println("" N    average    analytical    (error)===  =========  ============  ========="");
		for(int i=1;i<=20;i++){
			float avg = average(i);
			float ana = analytical(i);
			.out.println(.format(strv,i,avg,ana,((ana-avg)/ana*100)));;
		}
	}
}
 "
" 
    (...)
    int feedForward(double[] inputs) {
        assert inputs.length == weights.length : strv;
 
        double sum = 0;
        for (int i = 0; i < weights.length; i++) {
            sum += inputs[i] * weights[i];
        }
        return activate(sum);
    }
    (...)
 "
"Map<, Integer> myDict = new HashMap<, Integer>();
myDict.put(strv, 1);
myDict.put(strv, 2);
myDict.put(strv, 3);
 


for (.Entry<, Integer> e : myDict.entrySet()) {
     key = e.getKey();
     value = e.getValue();
    .out.println(strv + key + strv + value);
}
 


for ( key : myDict.keySet()) {
    .out.println(strv + key);
}
 


for ( value : myDict.values()) {
    .out.println(strv + value);
}Map<, Integer> myDict = new HashMap<>();
myDict.put(strv, 1);
myDict.put(strv, 2);
myDict.put(strv, 3);
 


myDict.forEach((k, v) -> {
    .out.printf(strv, k, v);
});
 


myDict.keySet().forEach(k -> .out.printf(strv, k));
 


myDict.values().forEach(v -> .out.printf(strv, v));"
"import java.util.Arrays;
import java.util.Random;
 
public class AtomicUpdates
{
  public static class Buckets
  {
    private final int[] data;
 
    public Buckets(int[] data)
    {
      this.data = data.clone();
    }
 
    public int getBucket(int index)
    {
      synchronized (data)
      {  return data[index];  }
    }
 
    public int transfer(int srcBucketIndex, int destBucketIndex, int amount)
    {
      if (amount == 0)
        return 0;
      

      if (amount < 0)
      {
        int tempIndex = srcBucketIndex;
        srcBucketIndex = destBucketIndex;
        destBucketIndex = tempIndex;
        amount = -amount;
      }
      synchronized (data)
      {
        if (amount > data[srcBucketIndex])
          amount = data[srcBucketIndex];
        if (amount <= 0)
          return 0;
        data[srcBucketIndex] -= amount;
        data[destBucketIndex] += amount;
        return amount;
      }
    }
 
    public int[] getBuckets()
    {
      synchronized (data)
      {  return data.clone();  }
    }
  }
 
  public static int getTotal(int[] values)
  {
    int totalValue = 0;
    for (int i = values.length - 1; i >= 0; i--)
      totalValue += values[i];
    return totalValue;
  }
 
  public static void main([] args)
  {
    final int NUM_BUCKETS = 10;
     rnd = new ();
    final int[] values = new int[NUM_BUCKETS];
    for (int i = 0; i < values.length; i++)
      values[i] = rnd.nextInt(10);
    .out.println(strv + getTotal(values) + strv + .toString(values));
    final Buckets buckets = new Buckets(values);
 
    new (new () {
        public void run()
        {
           r = new ();
          while (true)
          {
            int srcBucketIndex = r.nextInt(NUM_BUCKETS);
            int destBucketIndex = r.nextInt(NUM_BUCKETS);
            int amount = (buckets.getBucket(srcBucketIndex) - buckets.getBucket(destBucketIndex)) >> 1;
            if (amount != 0)
              buckets.transfer(srcBucketIndex, destBucketIndex, amount);
          }
        }
      }
    ).start();
 
    new (new () {
        public void run()
        {
           r = new ();
          while (true)
          {
            int srcBucketIndex = r.nextInt(NUM_BUCKETS);
            int destBucketIndex = r.nextInt(NUM_BUCKETS);
            int srcBucketAmount = buckets.getBucket(srcBucketIndex);
            int destBucketAmount = buckets.getBucket(destBucketIndex);
            int amount = r.nextInt(srcBucketAmount + destBucketAmount + 1) - destBucketAmount;
            if (amount != 0)
              buckets.transfer(srcBucketIndex, destBucketIndex, amount);
          }
        }
      }
    ).start();
 
    while (true)
    {
      long nextPrintTime = .currentTimeMillis() + 3000;
      long curTime;
      while ((curTime = .currentTimeMillis()) < nextPrintTime)
      {
        try
        {  .sleep(nextPrintTime - curTime);  }
        catch ( e)
        {  }
      }
      int[] bucketValues = buckets.getBuckets();
      .out.println(strv + getTotal(bucketValues) + strv + .toString(bucketValues));
    }
  }
}
 "
"public class ArrayLength {
    public static void main([] args) {
        .out.println(new []{strv, strv}.length);
    }
}"
"int[] array = new int[10]; //optionally, replace strv
array[0] = 42;
.out.println(array[3]);"
"class BigRationalFindPerfectNumbers {
  public static void main([] args) {
    .out.println(strv);
    if (BigRational.testFeatures()) {
      int MAX_NUM = (1 << 19);
      .out.println();
      .out.println(strv + (MAX_NUM - 1) + strv);
      BigRational TWO = BigRational.valueOf(2);
      for (int i = 1; i < MAX_NUM; i++) {
        BigRational reciprocalSum = BigRational.ONE;
        if (i > 1)
          reciprocalSum = reciprocalSum.add(BigRational.valueOf(i).reciprocal());
        int maxDivisor = (int).sqrt(i);
        if (maxDivisor >= i)
          maxDivisor--;
        for (int divisor = 2; divisor <= maxDivisor; divisor++) {
          if ((i % divisor) == 0) {
            reciprocalSum = reciprocalSum.add(BigRational.valueOf(divisor).reciprocal());
            int dividend = i / divisor;
            if (divisor != dividend)
              reciprocalSum = reciprocalSum.add(BigRational.valueOf(dividend).reciprocal());
          }
        }
        if (reciprocalSum.equals(TWO))
          .out.println(.valueOf(i) + strv);
      }
    }
    return;
  }
}"
"public class Complex {
    public final double real;
    public final double imag;
 
    public Complex() {
        this(0, 0);
    }
 
    public Complex(double r, double i) {
        real = r;
        imag = i;
    }
 
    public Complex add(Complex b) {
        return new Complex(this.real + b.real, this.imag + b.imag);
    }
 
    public Complex mult(Complex b) {
        

        return new Complex(this.real * b.real - this.imag * b.imag,
                this.real * b.imag + this.imag * b.real);
    }
 
    public Complex inv() {
        

        double denom = real * real + imag * imag;
        return new Complex(real / denom, -imag / denom);
    }
 
    public Complex neg() {
        return new Complex(-real, -imag);
    }
 
    public Complex conj() {
        return new Complex(real, -imag);
    }
 
    @Override
    public  toString() {
        return real + strv + imag + strv;
    }
 
    public static void main([] args) {
        Complex a = new Complex(.PI, -5); //just some numbers
        Complex b = new Complex(-1, 2.5);
        .out.println(a.neg());
        .out.println(a.add(b));
        .out.println(a.inv());
        .out.println(a.mult(b));
        .out.println(a.conj());
    }
}"
"import java.util.Scanner;
public class Int{
  public static void main([] args){
    Scanner sc = new Scanner(.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
 
    int sum = a + b;//integer addition is discouraged in print statements due to confusion with String concatenation
    .out.println(strv + sum);
    .out.println(strv + (a - b));
    .out.println(strv + (a * b));
    .out.println(strv + (a / b)); 

    .out.println(strv + (a % b)); 

  }
}"
"/*         Arithmetic-Geometric Mean of 1 & 1/sqrt(2)         Brendan Shaklovitz        5/29/12 */
 
public class ArithmeticMean {
        public static void agm (double a, double g){
                double a1 = a;
                double g1 = g;
                while (.abs(a1-g1) >= .pow(10, -14)){
                        double aTemp = (a1+g1)/2.0;
                        g1 = .sqrt(a1*g1);
                        a1 = aTemp;
                }
                .out.println(a1);
        }
 
        public static void main([] args){
                agm(1,1/.sqrt(2));
        }
}"
"import java.awt.*;
import static java.lang..*;
import javax.swing.*;
 
public class ArchimedeanSpiral extends  {
 
    public ArchimedeanSpiral() {
        setPreferredSize(new (640, 640));
        setBackground(.white);
    }
 
    void drawGrid( g) {
        g.setColor(new (0xEEEEEE));
        g.setStroke(new (2));
 
        double angle = toRadians(45);
 
        int w = getWidth();
        int center = w / 2;
        int margin = 10;
        int numRings = 8;
 
        int spacing = (w - 2 * margin) / (numRings * 2);
 
        for (int i = 0; i < numRings; i++) {
            int pos = margin + i * spacing;
            int size = w - (2 * margin + i * 2 * spacing);
            g.drawOval(pos, pos, size, size);
 
            double ia = i * angle;
            int x2 = center + (int) (cos(ia) * (w - 2 * margin) / 2);
            int y2 = center - (int) (sin(ia) * (w - 2 * margin) / 2);
 
            g.drawLine(center, center, x2, y2);
        }
    }
 
    void drawSpiral( g) {
        g.setStroke(new (2));
        g.setColor(.orange);
 
        double degrees = toRadians(0.1);
        double center = getWidth() / 2;
        double end = 360 * 2 * 10 * degrees;
        double a = 0;
        double b = 20;
        double c = 1;
 
        for (double theta = 0; theta < end; theta += degrees) {
            double r = a + b * pow(theta, 1 / c);
            double x = r * cos(theta);
            double y = r * sin(theta);
            plot(g, (int) (center + x), (int) (center - y));
        }
    }
 
    void plot( g, int x, int y) {
        g.drawOval(x, y, 1, 1);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawGrid(g);
        drawSpiral(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new ArchimedeanSpiral(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"import java.math.BigInteger;
 
class Program {
    public static void main([] args) {
         x = .valueOf(5).pow(.valueOf(4).pow(.valueOf(3).pow(2).intValue()).intValue());
         y = x.toString();
        int l = y.length();
        .out.printf(""5**4**3**2 = %s...%s and has %d digits"",
                          y.substring(0,20), y.substring(l-20), l);
    }
}"
"interface IntToVoid {
    void run(int x);
}
 
for (int z : myIntArray) {
    new IntToVoid() {
        public void run(int x) {
            .out.println(x);
        }
    }.run(z);
}interface IntToInt {
    int run(int x);
}
 
int[] result = new int[myIntArray.length];
for (int i = 0; i < myIntArray.length; i++) {
    result[i] =
        new IntToInt() {
            public int run(int x) {
                return x * x;
            }
        }.run(myIntArray[i]);
}"
"import java.util.Stack;
 
public class ArithmeticEvaluation
{
  public static enum Parentheses { LEFT, RIGHT }
 
  public static enum BinaryOperator
  {
    ADD('+', 1) {
      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.add(rightValue);  }
    },
    SUB('-', 1) {
      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.subtract(rightValue);  }
    },
    MUL('*', 2) {
      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.multiply(rightValue);  }
    },
    DIV('/', 2) {
      public BigRational eval(BigRational leftValue, BigRational rightValue) {  return leftValue.divide(rightValue);  }
    };
 
    public final char symbol;
    public final int precedence;
 
    BinaryOperator(char symbol, int precedence)
    {
      this.symbol = symbol;
      this.precedence = precedence;
    }
 
    public abstract BigRational eval(BigRational leftValue, BigRational rightValue);
  }
 
  public static class BinaryExpression
  {
    public  leftOperand = null;
    public BinaryOperator operator = null;
    public  rightOperand = null;
 
    public BinaryExpression( leftOperand, BinaryOperator operator,  rightOperand)
    {
      this.leftOperand = leftOperand;
      this.operator = operator;
      this.rightOperand = rightOperand;
    }
 
    public BigRational eval()
    {
      BigRational leftValue = (leftOperand instanceof BinaryExpression) ? ((BinaryExpression)leftOperand).eval() : (BigRational)leftOperand;
      BigRational rightValue = (rightOperand instanceof BinaryExpression) ? ((BinaryExpression)rightOperand).eval() : (BigRational)rightOperand;
      return operator.eval(leftValue, rightValue);
    }
 
    public  toString()
    {  return strv + leftOperand + strv + operator.symbol + strv + rightOperand + strv;  }
  }
 
  public static void createNewOperand(BinaryOperator operator, Stack<Object> operands)
  {
     rightOperand = operands.pop();
    operands.push(new BinaryExpression(operands.pop(), operator, rightOperand));
    return;
  }
 
  public static  createExpression( inputString)
  {
    int curIndex = 0;
    boolean afterOperand = false;
    Stack<Object> operands = new Stack<Object>();
    Stack<Object> operators = new Stack<Object>();
inputStringLoop:
    while (curIndex < inputString.length())
    {
      int startIndex = curIndex;
      char c = inputString.charAt(curIndex++);
      if (.isWhitespace(c))
        continue;
      if (afterOperand)
      {
        if (c == ')')
        {
           operator = null;
          while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))
            createNewOperand((BinaryOperator)operator, operands);
          continue;
        }
        afterOperand = false;
        for (BinaryOperator operator : BinaryOperator.values())
        {
          if (c == operator.symbol)
          {
            while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator)operators.peek()).precedence >= operator.precedence))
              createNewOperand((BinaryOperator)operators.pop(), operands);
            operators.push(operator);
            continue inputStringLoop;
          }
        }
        throw new ();
      }
      if (c == '(')
      {
        operators.push(Parentheses.LEFT);
        continue;
      }
      afterOperand = true;
      while (curIndex < inputString.length())
      {
        c = inputString.charAt(curIndex);
        if (((c < '0') || (c > '9')) && (c != '.'))
          break;
        curIndex++;
      }
      operands.push(BigRational.valueOf(inputString.substring(startIndex, curIndex)));
    }
 
    while (!operators.isEmpty())
    {
       operator = operators.pop();
      if (operator == Parentheses.LEFT)
        throw new ();
      createNewOperand((BinaryOperator)operator, operands);
    }
     expression = operands.pop();
    if (!operands.isEmpty())
      throw new ();
    return expression;
  }
 
  public static void main([] args)
  {
    [] testExpressions = { strv, strv, strv, strv, strv, strv };
    for ( testExpression : testExpressions)
    {
       expression = createExpression(testExpression);
      .out.println(""Input: "" + testExpression + "", AST: "" + expression + "", eval="" + (expression instanceof BinaryExpression ? ((BinaryExpression)expression).eval() : expression));
    }
  }
}"
"public static long fib(int n)
{
  if (n < 0)
    throw new (strv);
  return new () {
    private long fibInner(int n)
    {  return (n < 2) ? n : (fibInner(n - 1) + fibInner(n - 2));  }
  }.fibInner(n);
}"
" 
import static java.lang..parseInt;
import static java.nio.file.StandardOpenOption.APPEND;
import static java.util..asList;
import static java.util..stream;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
 
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Stream;
 
public class RecordAppender {
  static class Record {
    private final  account;
    private final  password;
    private final int uid;
    private final int gid;
    private final List<String> gecos;
    private final  directory;
    private final  shell;
 
    public Record( account,  password, int uid, int gid, List<String> gecos,  directory,  shell) {
      this.account = requireNonNull(account);
      this.password = requireNonNull(password);
      this.uid = uid;
      this.gid = gid;
      this.gecos = requireNonNull(gecos);
      this.directory = requireNonNull(directory);
      this.shell = requireNonNull(shell);
    }
 
    @Override
    public  toString() {
      return account + ':' + password + ':' + uid + ':' + gid + ':' + gecos.stream().collect(joining(strv)) + ':' + directory + ':' + shell;
    }
 
    public static Record parse( text) {
      [] tokens = text.split(strv);
      return new Record(
          tokens[0],
          tokens[1],
          parseInt(tokens[2]),
          parseInt(tokens[3]),
          asList(tokens[4].split(strv)),
          tokens[5],
          tokens[6]);
    }
  }
 
  public static void main([] args) throws  {
    [] rawData = {
        strv,
        strv,
        strv
    };
 
    List<Record> records = stream(rawData).map(Record::parse).collect(toList());
 
    Path tmp = Paths.get(strv, strv);
    Files.createDirectories(tmp.getParent());
    Files.write(tmp, (Iterable<String>)records.stream().limit(2).map(Record::toString)::iterator);
 
    Files.write(tmp, asList(records.get(2).toString()), APPEND);
 
    try(Stream<String> lines = Files.lines(tmp)) {
      lines.map(Record::parse).forEach(.out::println);
    }
  }
}
 "
"public class AngleDifference {
 
	public static double getDifference(double b1, double b2) {
		double r = (b2 - b1) % 360.0;
		if (r < -180.0)
			r += 360.0;
		if (r >= 180.0)
			r -= 360.0;
		return r;
	}
 
	public static void main([] args) {
		.out.println(strv);
		.out.println(getDifference(20.0, 45.0));
		.out.println(getDifference(-45.0, 45.0));
		.out.println(getDifference(-85.0, 90.0));
		.out.println(getDifference(-95.0, 90.0));
		.out.println(getDifference(-45.0, 125.0));
		.out.println(getDifference(-45.0, 145.0));
		.out.println(getDifference(-45.0, 125.0));
		.out.println(getDifference(-45.0, 145.0));
		.out.println(getDifference(29.4803, -88.6381));
		.out.println(getDifference(-78.3251, -159.036));
 
		.out.println(strv);
		.out.println(getDifference(-70099.74233810938, 29840.67437876723));
		.out.println(getDifference(-165313.6666297357, 33693.9894517456));
		.out.println(getDifference(1174.8380510598456, -154146.66490124757));
		.out.println(getDifference(60175.77306795546, 42213.07192354373));
	}
}"
"import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Timer;
import java.util.TimerTask;
import javax.swing.JFrame;
import javax.swing.JLabel;
 
public class Rotate extends  {
   text = strv;
   label = new (text);
  boolean rotRight = true;
  int startIdx = 0;
 
  public Rotate() {
    label.addMouseListener(new () {
      @Override
      public void mouseClicked( evt) {
        rotRight = !rotRight;
      }
    });
    add(label);
    pack();
    setDefaultCloseOperation(.EXIT_ON_CLOSE);
    setVisible(true);
  }
 
  public static void main([] args) {
    final Rotate rot = new Rotate();
     task = new () {
      public void run() {
        if (rot.rotRight) {
          rot.startIdx++;
          if (rot.startIdx >= rot.text.length()) {
            rot.startIdx -= rot.text.length();
          }
        } else {
          rot.startIdx--;
          if (rot.startIdx < 0) {
            rot.startIdx += rot.text.length();
          }
        }
        rot.label.setText(getRotatedText(rot.text, rot.startIdx));
      }
    };
     timer = new (false);
    timer.schedule(task, 0, 500);
  }
 
  public static  getRotatedText( text, int startIdx) {
     ret = strv;
    int i = startIdx;
    do {
      ret += text.charAt(i) + strv;
      i++;
      i = i % text.length();
    } while (i != startIdx);
    return ret;
  }
}"
"import java.awt.*;
import javax.swing.*;
 
public class Pendulum extends  implements  {
 
    private double angle = .PI / 2;
    private int length;
 
    public Pendulum(int length) {
        this.length = length;
        setDoubleBuffered(true);
    }
 
    @Override
    public void paint( g) {
        g.setColor(.WHITE);
        g.fillRect(0, 0, getWidth(), getHeight());
        g.setColor(.BLACK);
        int anchorX = getWidth() / 2, anchorY = getHeight() / 4;
        int ballX = anchorX + (int) (.sin(angle) * length);
        int ballY = anchorY + (int) (.cos(angle) * length);
        g.drawLine(anchorX, anchorY, ballX, ballY);
        g.fillOval(anchorX - 3, anchorY - 4, 7, 7);
        g.fillOval(ballX - 7, ballY - 7, 14, 14);
    }
 
    public void run() {
        double angleAccel, angleVelocity = 0, dt = 0.1;
        while (true) {
            angleAccel = -9.81 / length * .sin(angle);
            angleVelocity += angleAccel * dt;
            angle += angleVelocity * dt;
            repaint();
            try { .sleep(15); } catch ( ex) {}
        }
    }
 
    @Override
    public  getPreferredSize() {
        return new (2 * length + 50, length / 2 * 3);
    }
 
    public static void main([] args) {
         f = new (strv);
        Pendulum p = new Pendulum(200);
        f.add(p);
        f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
        f.pack();
        f.setVisible(true);
        new (p).start();
    }
}"
"import java.io.*;
import java.util.*;
 
public class DerangedAnagrams {
 
    public static void main(final [] args) throws  {
        if (!findAnagrams(readLines(strv)))
            .out.println(strv);
    }
 
    private static boolean isDeranged(final  w, final List<String> lst) {
        for ( w2 : lst) {
            int k = w.length() - 1;
            while (k >= 0 && w.charAt(k) != w2.charAt(k)) {
                k--;
            }
            if (k == -1) {
                .out.println(w + strv + w2);
                return true;
            }
        }
        return false;
    }
 
    private static boolean findAnagrams(final List<String> words) {
        .sort(words, new Comparator<String>() {
            public int compare( a,  b) {
                return b.length() - a.length();
            }
        });
        Map<, ArrayList<String>> map = new HashMap<>();
        for ( w : words) {
            char[] srt = w.toCharArray();
            .sort(srt);
             key = .valueOf(srt);
            ArrayList<String> lst;
            if (map.containsKey(key)) {
                lst = map.get(key);
                if (isDeranged(w, lst)) {
                    return true;
                }
                lst.add(w);
            } else {
                lst = new ArrayList<>();
                lst.add(w);
                map.put(key, lst);
            }
        }
        return false;
    }
 
    private static List<String> readLines(final  fn) throws  {
        List<String> lines;
        try ( br = new (new (fn))) {
            lines = new ArrayList<>();
             line = null;
            while ((line = br.readLine()) != null)
                lines.add(line);
        }
        return lines;
    }
}"
"import java.util.Map;
import static java.util.function.Function.*;
import static java.util.stream.Collectors.*;
import static java.util.stream.LongStream.*;
 
public class AmicablePairs {
 
    public static void main([] args) {
        final int limit = 20_000;
 
        Map<, Long> map = rangeClosed(1, limit)
                .parallel()
                .boxed()
                .collect(toMap(identity(), AmicablePairs::properDivsSum));
 
        rangeClosed(1, limit)
                .forEach(n -> {
                    long m = map.get(n);
                    if (m > n && m <= limit && map.get(m) == n)
                        .out.printf(strv, n, m);
                });
    }
 
    public static  properDivsSum(long n) {
        return rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0).sum();
    }
}"
"public class AlmostPrime
{
    public static void main( args[])
    {
        for (int k = 1; k <= 5; k++) {
            .out.print(strv + k + strv);
 
            for (int i = 2, c = 0; c < 10; i++)
                if (kprime(i, k)) {
                    .out.print(strv + i);
                    c++;
                }
 
            .out.println(strv);
        }
    }
 
    public static boolean kprime(int n, int k) 
    {
        int f = 0;
    	for (int p = 2; f < k && p*p <= n; p++)
    		while (0 == n % p){
    			n /= p;
    			f++;
            }
    	return f + ((n > 1)?1:0) == k;
    }
}"
"import java.util.*;
import java.util.stream.LongStream;
import static java.util.stream.LongStream.rangeClosed;
 
public class AliquotSequenceClassifications {
 
    public static  properDivsSum(long n) {
        return rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();
    }
 
    static boolean aliquot(long n, int maxLen, long maxTerm) {
        List<Long> s = new ArrayList<>(maxLen);
        s.add(n);
        long newN = n;
 
        while (s.size() <= maxLen && newN < maxTerm) {
 
            newN = properDivsSum(s.get(s.size() - 1));
 
            if (s.contains(newN)) {
 
                if (s.get(0) == newN) {
 
                    switch (s.size()) {
                        case 1:
                            return report(strv, s);
                        case 2:
                            return report(strv, s);
                        default:
                            return report(strv + s.size(), s);
                    }
 
                } else if (s.get(s.size() - 1) == newN) {
                    return report(strv, s);
 
                } else
                    return report(strv + newN, s);
 
            } else {
                s.add(newN);
                if (newN == 0)
                    return report(strv, s);
            }
        }
 
        return report(strv, s);
    }
 
    static boolean report( msg, List<Long> result) {
        .out.println(msg + strv + result);
        return false;
    }
 
    public static void main([] args) {
        long[] arr = {11L, 12, 28, 496, 220, 1184,  12496, 1264460,
                           790, 909, 562, 1064, 1488};
 
        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));
        .out.println();
        .stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));
    }
}"
" 
 
public class AksTest 
{
	static [] c = new [100];
 
	public static void main([] args)
	{
		for (int n = 0; n < 10; n++) {
			coef(n);
			.out.print(strv + n + strv);
			show(n);
			.out.println(strv);
		}
 
		.out.print(strv);
		for (int n = 1; n <= 63; n++)
			if (is_prime(n))
				.out.printf(strv, n);
 
		.out.println('');
	}
 
	static void coef(int n)
	{
		int i, j;
 
		if (n < 0 || n > 63) .exit(0); 

 
		for (c[i=0] = 1l; i < n; c[0] = -c[0], i++)
			for (c[1 + (j=i)] = 1l; j > 0; j--)
				c[j] = c[j-1] - c[j];
	}
 
	static boolean is_prime(int n)
	{
		int i;
 
		coef(n);
		c[0] += 1;
		c[i=n] -= 1;
 
		while (i-- != 0 && (c[i] % n) == 0);
 
		return i < 0;
	}
 
	static void show(int n)
	{
		do {
			.out.print(strv + c[n] + strv+ n);
		}while (n-- != 0);
	}
}
 "
"import java.io.IOException;
import java.util.Arrays;
 
import org.apache.directory.ldap.client.api.LdapConnection;
import org.apache.directory.ldap.client.api.LdapNetworkConnection;
import org.apache.directory.shared.ldap.model.cursor.EntryCursor;
import org.apache.directory.shared.ldap.model.entry.Entry;
import org.apache.directory.shared.ldap.model.exception.LdapException;
import org.apache.directory.shared.ldap.model.message.SearchScope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 
 
public class RDirectorySearchLDAP {
 
  protected static final Logger log_;
  private static LdapConnection connection;
  private static final  ldapHostName;
  private static final int ldapPort;
  private static final  ldapDnStr;
  private static final  ldapCreds;
 
  static {
 
    log_ = LoggerFactory.getLogger(RDirectorySearchLDAP.class);
 
    ldapHostName = strv;
    ldapPort = 11389;
    ldapDnStr=strv;
    ldapCreds=strv;
  }
 
  public static void main([] args) {
 
    boolean connected = false;
 
    try {
      connected = setUp();
      if (connected) {
        search(strv);
      }
    }
    finally {
      if (connected) {
        tearDown();
      }
    }
 
    return;
  }
 
  private static boolean search( uid) {
 
    boolean state;
    EntryCursor cursor;
    Entry ev;
     baseDn;
     filter;
    SearchScope scope;
     attributes[];
    int ksearch = 0;
 
    state = true;
 
    baseDn = strv;
    filter = strv + uid + strv;
    scope = SearchScope.SUBTREE;
    attributes = new java.lang.[] { strv, strv, strv, strv };
 
    try {
      if (log_.isTraceEnabled()) { log_.trace(strv); }
      if (log_.isInfoEnabled()) {
        log_.info(strv);
        log_.info(strv + baseDn);
        log_.info(strv + filter);
        log_.info(strv + (.asList(attributes).toString()));
      }
      cursor = connection.search(baseDn, filter, scope, attributes);
      while (cursor.next()) {
        ksearch++;
        ev = cursor.get();
        if (log_.isInfoEnabled()) { log_.info(strv + ksearch); }
        if (log_.isInfoEnabled()) { log_.info(ev.toString()); }
      }
    }
    catch (LdapException lex) {
      state = false;
      log_.error(strv + ksearch, lex);
    }
    catch ( ex) {
      state = false;
      log_.error(strv + ksearch, ex);
    }
 
    return state;
  }
 
  private static boolean search() {
 
    return search(strv);
  }
 
  private static boolean setUp() {
 
    boolean state = false;
 
    try {
      if (log_.isInfoEnabled()) { log_.info(strv + ldapHostName + strv + ldapPort); }
      connection = new LdapNetworkConnection(ldapHostName, ldapPort);
 
      if (log_.isTraceEnabled()) { log_.trace(strv); }
      connection.bind(ldapDnStr, ldapCreds);
 
      state = true;
    }
    catch (LdapException lex) {
      state = false;
      log_.error(strv, lex);
    }
    catch ( iox) {
      state = false;
      log_.error(strv, iox);
    }
 
    return state;
  }
 
  private static boolean tearDown() {
 
    boolean state = false;
 
    try {
      if (log_.isTraceEnabled()) { log_.trace(strv); }
      connection.unBind();
      state = true;
    }
    catch (LdapException lex) {
      state = false;
      log_.error(strv, lex);
    }
    finally {
      try {
        connection.close();
      }
      catch ( iox) {
        state = false;
        log_.error(strv, iox);
      }
    }
 
    return state;
  }
}"
"import java.io.IOException;
 
import org.apache.directory.ldap.client.api.LdapConnection;
import org.apache.directory.ldap.client.api.LdapNetworkConnection;
import org.apache.directory.shared.ldap.model.cursor.EntryCursor;
import org.apache.directory.shared.ldap.model.entry.Entry;
import org.apache.directory.shared.ldap.model.exception.LdapException;
import org.apache.directory.shared.ldap.model.message.SearchScope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 
public class RDirectoryLDAP {
 
  static final Logger log_;
  private static final  ldapHostName;
  private static final int ldapPort;
  private static LdapConnection connection;
 
  static {
    log_ = LoggerFactory.getLogger(RDirectoryLDAP.class);
    connection = null;
    ldapHostName = strv;
    ldapPort = 10389;
  }
 
  public static void main([] args) {
    try {
      if (log_.isInfoEnabled()) { log_.info(strv + ldapHostName + strv + ldapPort); }
      connection = new LdapNetworkConnection(ldapHostName, ldapPort);
 
      try {
        if (log_.isTraceEnabled()) { log_.trace(strv); }
        connection.bind();
 
        if (log_.isTraceEnabled()) { log_.trace(strv); }
        connection.unBind();
      }
      catch (LdapException lex) {
        log_.error(strv, lex);
      }
      catch ( ex) {
        log_.error(strv, ex);
      }
    }
    finally {
      if (log_.isTraceEnabled()) { log_.trace(strv); }
      try {
        if (connection != null) {
          connection.close();
        }
      }
      catch ( ex) {
        log_.error(strv, ex);
      }
    }
 
    return;
  }
}"
" 
package rosetta;
 
import java.util.function.Function;
 
/** * Integrates input function K over time *  S + (K(t1) + K(t0)) * (t1 - t0) / 2 * *  */
public class Integrator {
 
	private Function<, Double> f;
	private double s, lastS;
	private long t0, t1;
	private volatile boolean run;
 
	public Integrator(Function<, Double> input) {
		this.s = 0;
		this.lastS = 0;
		this.t0 = .currentTimeMillis();
		setInput(input);
		run = true;
		new (() -> {
			while (run) {
				try {
					.sleep(1);
					update();
				} catch ( e) {
					e.printStackTrace();
					.exit(1);
				}
			}
		}).start();
	}
 
	private void update() {
		long t = .currentTimeMillis() - this.t0;
		double v = this.f.apply(t);
		this.s += (lastS + v) * (t - this.t1) / 2;
		this.t1 = t;
	}
 
	public void setInput(Function<, Double> input) {
		this.f = input;
		lastS = input.apply(0L);
		t1 = 0;
	}
 
	public double getOutput() {
		return s;
	}
 
	public void stop() {
		run = false;
	}
 
	public static void main([] args) throws  {
		Integrator i = new Integrator((t) -> .sin(.PI * t));
		.sleep(2000);
		i.setInput((t) -> 0.);
		.sleep(500);
		.out.println(i.getOutput());
		i.stop();
	}
}
 
 "
"import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
 
import org.apache.commons.lang3.StringUtils;
 
/** * Aligns fields into columns, separated by strv */
public class ColumnAligner {
    private List<[]> words = new ArrayList<>();
    private int columns = 0;
    private List<Integer> columnWidths = new ArrayList<>();
 
    /**     * Initialize columns aligner from lines in a single string     *      * @param s     *            lines in a single string. Empty string does form a column.     */
    public ColumnAligner( s) {
        [] lines = s.split(""n"");
        for ( line : lines) {
            processInputLine(line);
        }
    }
 
    /**     * Initialize columns aligner from lines in a list of strings     *      * @param lines     *            lines in a single string. Empty string does form a column.     */
    public ColumnAligner(List<String> lines) {
        for ( line : lines) {
            processInputLine(line);
        }
    }
 
    private void processInputLine( line) {
        [] lineWords = line.split(""$"");
        words.add(lineWords);
        columns = .max(columns, lineWords.length);
        for (int i = 0; i < lineWords.length; i++) {
             word = lineWords[i];
            if (i >= columnWidths.size()) {
                columnWidths.add(word.length());
            } else {
                columnWidths.set(i, .max(columnWidths.get(i), word.length()));
            }
        }
    }
 
    interface AlignFunction {
         align( s, int length);
    }
 
    /**     * Left-align all columns     *      * @return Lines, terminated by strv     */
    public  alignLeft() {
        return align(new AlignFunction() {
            @Override
            public  align( s, int length) {
                return StringUtils.rightPad(s, length);
            }
        });
    }
 
    /**     * Right-align all columns     *      * @return Lines, terminated by strv     */
    public  alignRight() {
        return align(new AlignFunction() {
            @Override
            public  align( s, int length) {
                return StringUtils.leftPad(s, length);
            }
        });
    }
 
    /**     * Center-align all columns     *      * @return Lines, terminated by strv     */
    public  alignCenter() {
        return align(new AlignFunction() {
            @Override
            public  align( s, int length) {
                return StringUtils.center(s, length);
            }
        });
    }
 
    private  align(AlignFunction a) {
        StringBuilder result = new StringBuilder();
        for ([] lineWords : words) {
            for (int i = 0; i < lineWords.length; i++) {
                 word = lineWords[i];
                if (i == 0) {
                    result.append(strv);
                }
                result.append(a.align(word, columnWidths.get(i)) + strv);
            }
            result.append("""");
        }
        return result.toString();
    }
 
    public static void main( args[]) throws  {
        if (args.length < 1) {
            .out.println(strv);
            return;
        }
         filePath = args[0];
         alignment = strv;
        if (args.length >= 2) {
            alignment = args[1];
        }
        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));
        switch (alignment) {
        case strv:
            .out.print(ca.alignLeft());
            break;
        case strv:
            .out.print(ca.alignRight());
            break;
        case strv:
            .out.print(ca.alignCenter());
            break;
        default:
            .err.println(.format(strv, alignment));
            break;
        }
    }
}"
"import static java.util.stream.LongStream.rangeClosed;
 
public class NumberClassifications {
 
    public static void main([] args) {
        int countDeficient = 0;
        int countPerfect = 0;
        int countAbundant = 0;
 
        for (long i = 1; i <= 20_000L; i++) {
            long sum = properDivsSum(i);
            if (sum < i)
                countDeficient++;
            else if (sum == i)
                countPerfect++;
            else
                countAbundant++;
        }
        .out.println(strv + countDeficient);
        .out.println(strv + countPerfect);
        .out.println(strv + countAbundant);
    }
 
    public static  properDivsSum(long n) {
        return rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();
    }
}"
"import java.math.BigInteger;
 
public static  ack( m,  n) {
    return m.equals(.ZERO)
            ? n.add(.ONE)
            : ack(m.subtract(.ONE),
                        n.equals(.ZERO) ? .ONE : ack(m, n.subtract(.ONE)));
}"
"public class Accumulator {
    private double sum;
    public Accumulator(double sum0) {
        sum = sum0;
    }
    public double call(double n) {
        return sum += n;
    }
 
    public static void main([] args) {
        Accumulator x = new Accumulator(1);
        x.call(5);
        .out.println(new Accumulator(3));
        .out.println(x.call(2.3));
    }
}import com.google.common.base.Function;
 
public class AccumulatorFactory {
	private static Function<, Double> accumulator(final  elem) {
		return new Function<, Double>() {
			 sum = elem;
			@Override public  apply( val) {
				return sum += val;
			}
		};
	}
 
	public static void main([] args) {
		Function<, Double> x = accumulator(1d);
		x.apply(5d);
		.out.println(accumulator(3d));		
		.out.println(x.apply(2.3));
	}
}import java.util.function.DoubleUnaryOperator;
 
public interface AccumulatorFactory {
  public static DoubleUnaryOperator accumulator(double element) {
    double[] sum = new double[] { element };
    return value -> sum[0] += value;
  }
 
  public static void main(... arguments) {
    DoubleUnaryOperator x = accumulator(1d);
    x.applyAsDouble(5d);
    .out.println(accumulator(3d));		
    .out.println(x.applyAsDouble(2.3));
  }
}"
"public abstract class Abs {
	abstract public int method1(double value);
	abstract protected int method2( name);
	int add(int a, int b){
		return a+b;
	}
}public interface Inter {
	int method1(double value);
	int method2( name);
	int add(int a, int b);
}"
"import java.util.*;
 
public class Sum2 {
   public static void main([] args) {
      Scanner in = new Scanner(.in); 

      .out.println(in.nextInt() + in.nextInt()); 

   }
}import java.io.*;
import java.util.*;
 
public class SumDif {
    in;
    out;
 
   public static void main([] args) throws  {
      new SumDif().run();
   }
 
   private int nextInt() throws  {
      in.nextToken();
      return (int)in.nval;
   }
 
   public void run() throws  {
      in = new (new (new (.in))); 

      out = new (new (.out)); 

      solve();
      out.flush();
   }
 
   private void solve() throws  {
      out.println(nextInt() + nextInt());
   }
}import java.io.*; 
 
public class AplusB {
	public static void main([] args) {
		try {
			 in = new (new (strv));
			in.nextToken();
			int a = (int) in.nval;
			in.nextToken();
			int b = (int) in.nval;
			 outFile = new (strv);
			outFile.write(.toString(a + b));
			outFile.close();
		}
		catch ( e) {
			.out.println(strv);
		}
	}
}"
"static  canMakeWord(List<String> src_blocks,  word) {
    if (.isEmpty(word)) {
        return true;
    }
 
    List<String> blocks = new List<String>();
    for ( block : src_blocks) {
        blocks.add(block.toUpperCase());
    }
 
    for ( i = 0; i < word.length(); i++) {
         blockIndex = -1;
         c = word.mid(i, 1).toUpperCase();
 
        for ( j = 0; j < blocks.size(); j++) {
            if (blocks.get(j).contains(c)) {
                blockIndex = j;
                break;
            }
        }
 
        if (blockIndex == -1) {
            return false;
        } else {
            blocks.remove(blockIndex);
        }
    }
 
    return true;
}
 
List<String> blocks = new List<String>{
    'BO', 'XK', 'DQ', 'CP', 'NA',
    'GT', 'RE', 'TG', 'QD', 'FS', 
    'JW', 'HU', 'VI', 'AN', 'OB', 
    'ER', 'FS', 'LY', 'PC', 'ZM'
};
.debug('strv: ' + canMakeWord(blocks, ''));
.debug('strv: ' + canMakeWord(blocks, 'A'));
.debug('strv: ' + canMakeWord(blocks, 'BARK'));
.debug('strv: ' + canMakeWord(blocks, 'book'));
.debug('strv: ' + canMakeWord(blocks, 'treat'));
.debug('strv: ' + canMakeWord(blocks, 'COMMON'));
.debug('strv: ' + canMakeWord(blocks, 'SQuAd'));
.debug('strv: ' + canMakeWord(blocks, 'CONFUSE'));"
"import java.math.BigInteger;
import java.util.*;
import static java.util..asList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;
import static java.lang..min;
 
public class Test {
 
    static List<BigInteger> cumu(int n) {
        List<List<BigInteger>> cache = new ArrayList<>();
        cache.add(asList(.ONE));
 
        for (int L = cache.size(); L < n + 1; L++) {
            List<BigInteger> r = new ArrayList<>();
            r.add(.ZERO);
            for (int x = 1; x < L + 1; x++)
                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));
            cache.add(r);
        }
        return cache.get(n);
    }
 
    static List<BigInteger> row(int n) {
        List<BigInteger> r = cumu(n);
        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))
                .collect(toList());
    }
 
    public static void main([] args) {
        .out.println(strv);
        for (int x = 1; x < 11; x++)
            .out.printf(strv, x, row(x));
 
        .out.println(""Sums:"");
        for (int x : new int[]{23, 123, 1234}) {
            List<BigInteger> c = cumu(x);
            .out.printf(strv, x, c.get(c.size() - 1));
        }
    }
}"
"import java.text.MessageFormat;
public class Beer
{
 static  bottles(final int n)
 {
  return .format(strv, n);
 }
 public static void main(final [] args)
 {
   byob = bottles(99);
  for (int x = 99; x > 0;)
  {
   .out.println(byob + strv);
   .out.println(byob);
   .out.println(strv);
   byob = bottles(--x);
   .out.println(byob + "" on the wall"");
  }
 }
}public class Beer
{
 public static void main(final [] args)
 {
  int beer = 99;
  StringBuilder sb = new StringBuilder();
   data[] = new [] { "" bottles of beer on the wall"",
                                 "" bottles of beer.Take one down, pass it around,"",
                                 strv };
 
  while (beer > 0)
   sb.append(beer).append(data[0]).append(beer).append(data[1]).append(--beer).append(data[0]).append("""");
 
  .out.println(sb.append(data[2]).toString());
 }
}public class Beer
{
	public static void main( args[])
	{
		song(99);	
	}
 
	public static void song(int b)
	{
		if(b>=0)
		{
			if(b>1)
			.out.println(b+"" bottles of beer on the wall""+b+"" bottles of beerTake one down, pass it around""+(b-1)+"" bottles of beer on the wall."");	
			else if(b==1)
			.out.println(b+"" bottle of beer on the wall""+b+"" bottle of beerTake one down, pass it around""+(b-1)+"" bottles of beer on the wall."");
			else
			.out.println(b+"" bottles of beer on the wall""+b+"" bottles of beerBetter go to the store and buy some more!"");
			song(b-1);
		}	
	}
}import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;
public class Beer extends  implements {
        private int x;
        private  take;
        private  text;
        public static void main([] args){
                new Beer();//build and show the GUI
        }
 
        public Beer(){
                x= 99;
                take= new (strv);
                text= new (4,30);//size the area to 4 lines, 30 chars each
                text.setText(x + "" bottles of beer on the wall"" + x + strv);
                text.setEditable(false);//so they can't change the text after it's displayed
                take.addActionListener(this);//listen to the button
                setLayout(new ());//handle placement of components
                add(text, .CENTER);//put the text area in the largest section
                add(take, .SOUTH);//put the button underneath it
                pack();//auto-size the window
                setDefaultCloseOperation(.EXIT_ON_CLOSE);//exit on strv (I hate System.exit...)
                setVisible(true);//show it
        }
 
        public void actionPerformed( arg0){
                if(arg0.getSource() == take){//if they clicked the button
                        .showMessageDialog(null, --x + strv);//show a popup message
                        text.setText(x + "" bottles of beer on the wall"" + x + strv);//change the text
                }
                if(x == 0){//if it's the end
                        dispose();//end
                }
        }
}"
"import java.util.*;
 
public class Game24 {
    static  r = new ();
 
    public static void main([] args) {
 
        int[] digits = randomDigits();
        Scanner in = new Scanner(.in);
 
        .out.print(strv);
        .out.println(.toString(digits));
        .out.print(strv);
 
        Stack<Float> s = new Stack<>();
        long total = 0;
        for (char c : in.nextLine().toCharArray()) {
            if ('0' <= c && c <= '9') {
                int d = c - '0';
                total += (1 << (d * 5));
                s.push((float) d);
            } else if (strv.indexOf(c) != -1) {
                s.push(applyOperator(s.pop(), s.pop(), c));
            }
        }
        if (tallyDigits(digits) != total)
            .out.print(strv);
        else if (.abs(24 - s.peek()) < 0.001F)
            .out.println(strv);
        else
            .out.print(strv);
    }
 
    static float applyOperator(float a, float b, char c) {
        switch (c) {
            case '+':
                return a + b;
            case '-':
                return b - a;
            case '*':
                return a * b;
            case '/':
                return b / a;
            default:
                return .NaN;
        }
    }
 
    static long tallyDigits(int[] a) {
        long total = 0;
        for (int i = 0; i < 4; i++)
            total += (1 << (a[i] * 5));
        return total;
    }
 
    static int[] randomDigits() {        
        int[] result = new int[4];
        for (int i = 0; i < 4; i++)
            result[i] = r.nextInt(9) + 1;
        return result;
    }
}"
"import java.util.*;
 
public class Game24Player {
    final [] patterns = {strv, strv, strv, strv,
        strv};
    final  ops = strv;
 
     solution;
    List<Integer> digits;
 
    public static void main([] args) {
        new Game24Player().play();
    }
 
    void play() {
        digits = getSolvableDigits();
 
        Scanner in = new Scanner(.in);
        while (true) {
            .out.print(strv);
            .out.println(digits);
            .out.println(strv);
            .out.print(strv);
 
             line = in.nextLine();
            if (line.equalsIgnoreCase(strv)) {
                .out.println(""Thanks for playing"");
                return;
            }
 
            if (line.equalsIgnoreCase(strv)) {
                .out.println(solution);
                digits = getSolvableDigits();
                continue;
            }
 
            char[] entry = line.replaceAll(""[^*+-/)(d]"", strv).toCharArray();
 
            try {
                validate(entry);
 
                if (evaluate(infixToPostfix(entry))) {
                    .out.println(""Correct! Want to try another? "");
                    digits = getSolvableDigits();
                } else {
                    .out.println(""Not correct."");
                }
 
            } catch ( e) {
                .out.printf(strv, e.getMessage());
            }
        }
    }
 
    void validate(char[] input) throws  {
        int total1 = 0, parens = 0, opsCount = 0;
 
        for (char c : input) {
            if (.isDigit(c))
                total1 += 1 << (c - '0') * 4;
            else if (c == '(')
                parens++;
            else if (c == ')')
                parens--;
            else if (ops.indexOf(c) != -1)
                opsCount++;
            if (parens < 0)
                throw new (strv);
        }
 
        if (parens != 0)
            throw new (strv);
 
        if (opsCount != 3)
            throw new (strv);
 
        int total2 = 0;
        for (int d : digits)
            total2 += 1 << d * 4;
 
        if (total1 != total2)
            throw new (strv);
    }
 
    boolean evaluate(char[] line) throws  {
        Stack<Float> s = new Stack<>();
        try {
            for (char c : line) {
                if ('0' <= c && c <= '9')
                    s.push((float) c - '0');
                else
                    s.push(applyOperator(s.pop(), s.pop(), c));
            }
        } catch ( e) {
            throw new (strv);
        }
        return (.abs(24 - s.peek()) < 0.001F);
    }
 
    float applyOperator(float a, float b, char c) {
        switch (c) {
            case '+':
                return a + b;
            case '-':
                return b - a;
            case '*':
                return a * b;
            case '/':
                return b / a;
            default:
                return .NaN;
        }
    }
 
    List<Integer> randomDigits() {
         r = new ();
        List<Integer> result = new ArrayList<>(4);
        for (int i = 0; i < 4; i++)
            result.add(r.nextInt(9) + 1);
        return result;
    }
 
    List<Integer> getSolvableDigits() {
        List<Integer> result;
        do {
            result = randomDigits();
        } while (!isSolvable(result));
        return result;
    }
 
    boolean isSolvable(List<Integer> digits) {
        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);
        permute(digits, dPerms, 0);
 
        int total = 4 * 4 * 4;
        List<List<Integer>> oPerms = new ArrayList<>(total);
        permuteOperators(oPerms, 4, total);
 
        StringBuilder sb = new StringBuilder(4 + 3);
 
        for ( pattern : patterns) {
            char[] patternChars = pattern.toCharArray();
 
            for (List<Integer> dig : dPerms) {
                for (List<Integer> opr : oPerms) {
 
                    int i = 0, j = 0;
                    for (char c : patternChars) {
                        if (c == 'n')
                            sb.append(dig.get(i++));
                        else
                            sb.append(ops.charAt(opr.get(j++)));
                    }
 
                     candidate = sb.toString();
                    try {
                        if (evaluate(candidate.toCharArray())) {
                            solution = postfixToInfix(candidate);
                            return true;
                        }
                    } catch ( ignored) {
                    }
                    sb.setLength(0);
                }
            }
        }
        return false;
    }
 
     postfixToInfix( postfix) {
        class Expression {
             op, ex;
            int prec = 3;
 
            Expression( e) {
                ex = e;
            }
 
            Expression( e1,  e2,  o) {
                ex = .format(strv, e1, o, e2);
                op = o;
                prec = ops.indexOf(o) / 2;
            }
        }
 
        Stack<Expression> expr = new Stack<>();
 
        for (char c : postfix.toCharArray()) {
            int idx = ops.indexOf(c);
            if (idx != -1) {
 
                Expression r = expr.pop();
                Expression l = expr.pop();
 
                int opPrec = idx / 2;
 
                if (l.prec < opPrec)
                    l.ex = '(' + l.ex + ')';
 
                if (r.prec <= opPrec)
                    r.ex = '(' + r.ex + ')';
 
                expr.push(new Expression(l.ex, r.ex, strv + c));
            } else {
                expr.push(new Expression(strv + c));
            }
        }
        return expr.peek().ex;
    }
 
    char[] infixToPostfix(char[] infix) throws  {
        StringBuilder sb = new StringBuilder();
        Stack<Integer> s = new Stack<>();
        try {
            for (char c : infix) {
                int idx = ops.indexOf(c);
                if (idx != -1) {
                    if (s.isEmpty())
                        s.push(idx);
                    else {
                        while (!s.isEmpty()) {
                            int prec2 = s.peek() / 2;
                            int prec1 = idx / 2;
                            if (prec2 >= prec1)
                                sb.append(ops.charAt(s.pop()));
                            else
                                break;
                        }
                        s.push(idx);
                    }
                } else if (c == '(') {
                    s.push(-2);
                } else if (c == ')') {
                    while (s.peek() != -2)
                        sb.append(ops.charAt(s.pop()));
                    s.pop();
                } else {
                    sb.append(c);
                }
            }
            while (!s.isEmpty())
                sb.append(ops.charAt(s.pop()));
 
        } catch ( e) {
            throw new (strv);
        }
        return sb.toString().toCharArray();
    }
 
    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {
        for (int i = k; i < lst.size(); i++) {
            .swap(lst, i, k);
            permute(lst, res, k + 1);
            .swap(lst, k, i);
        }
        if (k == lst.size())
            res.add(new ArrayList<>(lst));
    }
 
    void permuteOperators(List<List<Integer>> res, int n, int total) {
        for (int i = 0, npow = n * n; i < total; i++)
            res.add(.asList((i / npow), (i % npow) / n, i % n));
    }
}"
"import java.awt.*;
import java.awt.event.*;
import java.util.Random;
import javax.swing.*;
 
public class Game2048 extends  {
 
    enum State {
        start, won, running, over
    }
 
    final [] colorTable = {
        new (0x701710), new (0xFFE4C3), new (0xfff4d3),
        new (0xffdac3), new (0xe7b08e), new (0xe7bf8e),
        new (0xffc4c3), new (0xE7948e), new (0xbe7e56),
        new (0xbe5e56), new (0x9c3931), new (0x701710)};
 
    final static int target = 2048;
 
    static int highest;
    static int score;
 
    private  gridColor = new (0xBBADA0);
    private  emptyColor = new (0xCDC1B4);
    private  startColor = new (0xFFEBCD);
 
    private  rand = new ();
 
    private Tile[][] tiles;
    private int side = 4;
    private State gamestate = State.start;
    private boolean checkingAvailableMoves;
 
    public Game2048() {
        setPreferredSize(new (900, 700));
        setBackground(new (0xFAF8EF));
        setFont(new (strv, .BOLD, 48));
        setFocusable(true);
 
        addMouseListener(new () {
            @Override
            public void mousePressed( e) {
                startGame();
                repaint();
            }
        });
 
        addKeyListener(new () {
            @Override
            public void keyPressed( e) {
                switch (e.getKeyCode()) {
                    case .VK_UP:
                        moveUp();
                        break;
                    case .VK_DOWN:
                        moveDown();
                        break;
                    case .VK_LEFT:
                        moveLeft();
                        break;
                    case .VK_RIGHT:
                        moveRight();
                        break;
                }
                repaint();
            }
        });
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawGrid(g);
    }
 
    void startGame() {
        if (gamestate != State.running) {
            score = 0;
            highest = 0;
            gamestate = State.running;
            tiles = new Tile[side][side];
            addRandomTile();
            addRandomTile();
        }
    }
 
    void drawGrid( g) {
        g.setColor(gridColor);
        g.fillRoundRect(200, 100, 499, 499, 15, 15);
 
        if (gamestate == State.running) {
 
            for (int r = 0; r < side; r++) {
                for (int c = 0; c < side; c++) {
                    if (tiles[r][c] == null) {
                        g.setColor(emptyColor);
                        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);
                    } else {
                        drawTile(g, r, c);
                    }
                }
            }
        } else {
            g.setColor(startColor);
            g.fillRoundRect(215, 115, 469, 469, 7, 7);
 
            g.setColor(gridColor.darker());
            g.setFont(new (strv, .BOLD, 128));
            g.drawString(strv, 310, 270);
 
            g.setFont(new (strv, .BOLD, 20));
 
            if (gamestate == State.won) {
                g.drawString(strv, 390, 350);
 
            } else if (gamestate == State.over)
                g.drawString(strv, 400, 350);
 
            g.setColor(gridColor);
            g.drawString(strv, 330, 470);
            g.drawString(strv, 310, 530);
        }
    }
 
    void drawTile( g, int r, int c) {
        int value = tiles[r][c].getValue();
 
        g.setColor(colorTable[(int) (.log(value) / .log(2)) + 1]);
        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);
         s = .valueOf(value);
 
        g.setColor(value < 128 ? colorTable[0] : colorTable[1]);
 
         fm = g.getFontMetrics();
        int asc = fm.getAscent();
        int dec = fm.getDescent();
 
        int x = 215 + c * 121 + (106 - fm.stringWidth(s)) / 2;
        int y = 115 + r * 121 + (asc + (106 - (asc + dec)) / 2);
 
        g.drawString(s, x, y);
    }
 
 
    private void addRandomTile() {
        int pos = rand.nextInt(side * side);
        int row, col;
        do {
            pos = (pos + 1) % (side * side);
            row = pos / side;
            col = pos % side;
        } while (tiles[row][col] != null);
 
        int val = rand.nextInt(10) == 0 ? 4 : 2;
        tiles[row][col] = new Tile(val);
    }
 
    private boolean move(int countDownFrom, int yIncr, int xIncr) {
        boolean moved = false;
 
        for (int i = 0; i < side * side; i++) {
            int j = .abs(countDownFrom - i);
 
            int r = j / side;
            int c = j % side;
 
            if (tiles[r][c] == null)
                continue;
 
            int nextR = r + yIncr;
            int nextC = c + xIncr;
 
            while (nextR >= 0 && nextR < side && nextC >= 0 && nextC < side) {
 
                Tile next = tiles[nextR][nextC];
                Tile curr = tiles[r][c];
 
                if (next == null) {
 
                    if (checkingAvailableMoves)
                        return true;
 
                    tiles[nextR][nextC] = curr;
                    tiles[r][c] = null;
                    r = nextR;
                    c = nextC;
                    nextR += yIncr;
                    nextC += xIncr;
                    moved = true;
 
                } else if (next.canMergeWith(curr)) {
 
                    if (checkingAvailableMoves)
                        return true;
 
                    int value = next.mergeWith(curr);
                    if (value > highest)
                        highest = value;
                    score += value;
                    tiles[r][c] = null;
                    moved = true;
                    break;
                } else
                    break;
            }
        }
 
        if (moved) {
            if (highest < target) {
                clearMerged();
                addRandomTile();
                if (!movesAvailable()) {
                    gamestate = State.over;
                }
            } else if (highest == target)
                gamestate = State.won;
        }
 
        return moved;
    }
 
    boolean moveUp() {
        return move(0, -1, 0);
    }
 
    boolean moveDown() {
        return move(side * side - 1, 1, 0);
    }
 
    boolean moveLeft() {
        return move(0, 0, -1);
    }
 
    boolean moveRight() {
        return move(side * side - 1, 0, 1);
    }
 
    void clearMerged() {
        for (Tile[] row : tiles)
            for (Tile tile : row)
                if (tile != null)
                    tile.setMerged(false);
    }
 
    boolean movesAvailable() {
        checkingAvailableMoves = true;
        boolean hasMoves = moveUp() || moveDown() || moveLeft() || moveRight();
        checkingAvailableMoves = false;
        return hasMoves;
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(true);
            f.add(new Game2048(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}
 
class Tile {
    private boolean merged;
    private int value;
 
    Tile(int val) {
        value = val;
    }
 
    int getValue() {
        return value;
    }
 
    void setMerged(boolean m) {
        merged = m;
    }
 
    boolean canMergeWith(Tile other) {
        return !merged && other != null && !other.merged && value == other.getValue();
    }
 
    int mergeWith(Tile other) {
        if (canMergeWith(other)) {
            value *= 2;
            merged = true;
            return value;
        }
        return -1;
    }
}"
"import java.awt.*;
import java.awt.event.*;
import java.util.Random;
import javax.swing.*;
 
public class FifteenPuzzle extends  {
    final static int numTiles = 15;
    final static int side = 4;
 
     rand = new ();
    int[] tiles = new int[numTiles + 1];
    int tileSize, blankPos, margin, gridSize;
 
    public FifteenPuzzle() {
        final int dim = 640;
 
        margin = 80;
        tileSize = (dim - 2 * margin) / side;
        gridSize = tileSize * side;
 
        setPreferredSize(new (dim, dim));
        setBackground(.white);
        setForeground(new (0x6495ED)); 

        setFont(new (strv, .BOLD, 60));
 
        addMouseListener(new () {
            @Override
            public void mousePressed( e) {
                int ex = e.getX() - margin;
                int ey = e.getY() - margin;
 
                if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize)
                    return;
 
                int c1 = ex / tileSize;
                int r1 = ey / tileSize;
                int c2 = blankPos % side;
                int r2 = blankPos / side;
 
                if ((c1 == c2 && .abs(r1 - r2) == 1)
                        || (r1 == r2 && .abs(c1 - c2) == 1)) {
 
                    int clickPos = r1 * side + c1;
                    tiles[blankPos] = tiles[clickPos];
                    tiles[clickPos] = 0;
                    blankPos = clickPos;
                }
                repaint();
            }
        });
 
        shuffle();
    }
 
    final void shuffle() {
        do {
            reset();
            

            

            int n = numTiles;
            while (n > 1) {
                int r = rand.nextInt(n--);
                int tmp = tiles[r];
                tiles[r] = tiles[n];
                tiles[n] = tmp;
            }
        } while (!isSolvable());
    }
 
    void reset() {
        for (int i = 0; i < tiles.length; i++)
            tiles[i] = (i + 1) % tiles.length;
        blankPos = numTiles;
    }
 
    /*  Only half the permutations of the puzzle are solvable.         Whenever a tile is preceded by a tile with higher value it counts        as an inversion. In our case, with the blank space in the home        position, the number of inversions must be even for the puzzle        to be solvable.         See also:        www.cs.bham.ac.uk/~mdr/teaching/modules04/java2/TilesSolvability.html    */
    boolean isSolvable() {
        int countInversions = 0;
        for (int i = 0; i < numTiles; i++) {
            for (int j = 0; j < i; j++) {
                if (tiles[j] > tiles[i])
                    countInversions++;
            }
        }
        return countInversions % 2 == 0;
    }
 
    void drawGrid( g) {
        for (int i = 0; i < tiles.length; i++) {
            if (tiles[i] == 0)
                continue;
 
            int r = i / side;
            int c = i % side;
            int x = margin + c * tileSize;
            int y = margin + r * tileSize;
 
            g.setColor(getForeground());
            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);
            g.setColor(.black);
            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);
            g.setColor(.white);
 
            drawCenteredString(g, .valueOf(tiles[i]), x, y);
        }
    }
 
    void drawCenteredString( g,  s, int x, int y) {
         fm = g.getFontMetrics();
        int asc = fm.getAscent();
        int dec = fm.getDescent();
 
        x = x + (tileSize - fm.stringWidth(s)) / 2;
        y = y + (asc + (tileSize - (asc + dec)) / 2);
 
        g.drawString(s, x, y);
    }
 
    @Override
    public void paintComponent( gg) {
        super.paintComponent(gg);
         g = () gg;
        g.setRenderingHint(.KEY_ANTIALIASING,
                .VALUE_ANTIALIAS_ON);
 
        drawGrid(g);
    }
 
    public static void main([] args) {
        .invokeLater(() -> {
             f = new ();
            f.setDefaultCloseOperation(.EXIT_ON_CLOSE);
            f.setTitle(strv);
            f.setResizable(false);
            f.add(new FifteenPuzzle(), .CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}"
"N.println(IntStream.rangeClosed(1, 100).filter(i -> .pow((int) .sqrt(i), 2) == i).boxed().join(strv, strv, strv)); 
public class HundredDoors {
    public static void main([] args) {
        boolean[] doors = new boolean[101];
        for (int i = 1; i <= 100; i++) {
            for (int j = i; j <= 100; j++) {
                if(j % i == 0) doors[j] = !doors[j];
            }
        }
        for (int i = 1; i <= 100; i++) {
            .out.printf(strv, i, doors[i] ? strv : strv);
        }
    }
} 
public class Doors 
{
	public static void main([] args)
	{
		boolean[] doors=new boolean[100];
		for(int i=0;i<10;i++)
			doors[i*(i+2)]=true;
		for(int i=0;i<100;i++)
			.out.println(strv+(i+1)+strv+(doors[i]?strv:strv));
	}
}
  
public class Doors 
{
	public static void main([] args)
	{
		for(int i=0;i<10;i++)
			.out.println(strv+(i*(i+2)+1)+strv);
	}
}
 public class Doors
{
 public static void main(final [] args)
 {
  boolean[] doors = new boolean[100];
 
  for (int pass = 0; pass < 10; pass++)
   doors[(pass + 1) * (pass + 1) - 1] = true;
 
  for(int i = 0; i < 100; i++)
   .out.println(strv + (i + 1) + strv + (doors[i] ? strv : strv));
 }
}public class Doors
{
 public static void main(final [] args)
 {
  StringBuilder sb = new StringBuilder();
 
  for (int i = 1; i <= 10; i++)
   sb.append(strv).append(i*i).append("" is open"");
 
  .out.println(sb.toString());
 }
}public class Doors{
   public static void main([] args){
      int i;		
      for(i = 1; i < 101; i++){
         double sqrt = .sqrt(i);
         if(sqrt != (int)sqrt){
            .out.println(strv + i + strv);
         }else{
            .out.println(strv + i + strv);
         }
      }
   } 	
}"
