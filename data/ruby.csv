keywords
" class Example  def initialize     @private_data = strv 
  end  private  def hidden_method     strv  endendexample = Example.newp example.private_methods(false) 
#p example.hidden_method # => NoMethodError: private method `name' called for #<Example:0x101308408>p example.send(:hidden_method) 
p example.instance_variables 
p example.instance_variable_get :@private_data 
p example.instance_variable_set :@private_data, 42 
p example.instance_variable_get :@private_data 
 class Example {    has public = strv    method init {        self{:private} = strv    }} var obj = Example(); 
say obj.public;                 #=> strvsay obj{:public};               #=> strv 
say obj{:private};              #=> strv"
"def comma_quibbling(a)  %w<{ }>.join(a.length < 2 ? a.first :               strv)end [[], %w<ABC>, %w<ABC DEF>, %w<ABC DEF G H>].each do |a|  puts comma_quibbling(a)endfunc comma_quibbling(words) {    '{' + ([words.ft(0, -2).join(', ')]-[''] + [words.last] -> join(' and ')) + '}';} [<>, <ABC>, <ABC DEF>, <ABC DEF G H>].each { |w|    say comma_quibbling(w);}"
"possible_doughnuts = ['iced', 'jam', 'plain'].repeated_combination(2)puts strvpossible_doughnuts.each{|doughnut_combi| puts doughnut_combi.join(' and ')} 
possible_doughnuts = [*1..10].repeated_combination(3)
puts strv, strvfunc p (n, a, l) { n>0 ? (l.range.map{p(n-1, a+[l[_]], l.ft(_))}) : a };func f (n)       { n>0 ? (n * f(n - 1)) : 1 };func n (n, m)    { f(n + m - 1) / f(n) / f(m - 1) }; p(2, [], %w(iced jam plain)).each { |a|    say a.map{|pair| pair.join(strv)}.join("""");} printf(""There are %d ways to pick 7 out of 10"", n(7, 10));"
"


#



#








#def findCycle(x0)  power = lambda = 1  tortoise = x0  hare = yield(x0)   
  while tortoise != hare    if power == lambda      tortoise = hare      power *= 2      lambda = 0    end    hare = yield(hare)    lambda += 1  end   
  hare = x0  lambda.times { hare = yield(hare) }   tortoise, mu = x0, 0  while tortoise != hare    tortoise = yield(tortoise)    hare = yield(hare)    mu += 1  end   return lambda, muend 
def f(x) (x * x + 1) % 255 end 
puts (1..40).reduce([3]){|acc,_| acc << f(acc.last)}.join(strv) 
clength, cstart = findCycle(3) { |x| f(x) }puts ""Cycle length = #{clength}Start index = #{cstart}""func brent (f, x0) {    var power = 1    var λ = 1    var tortoise = x0    var hare = f(x0)     while (tortoise != hare) {        if (power == λ) {            tortoise = hare            power *= 2            λ = 0        }        hare = f(hare)        λ += 1    }     var μ = 0    tortoise = x0    hare = x0    { hare = f(hare) } * λ     while (tortoise != hare) {        tortoise = f(tortoise)        hare = f(hare)        μ += 1    }     return (λ, μ)} func cyclical_function(x) { (x*x + 1) % 255 } var (l, s) = brent(cyclical_function, 3) var seq = gather {    var x = 3    { take(x); x = cyclical_function(x) } * 20} say seq.join(', ')+', ...' say strv;say strvsay [seq[s .. (s + l - 1)]]"
" 
#

K = 17F = Array.new(K+1){|n| n==0?1:(1..n).inject(:*)}   #Some small factorialsg = -> n, gn=[n,0], res=0 { while gn[0]>0                              gn = gn[0].divmod(10)                              res += gn[1]**2                            end                            return res==89?0:res                           }#An array: N[n]==1 means that n translates to 1, 0 means that it does not.N = (G=Array.new(K*81+1){|n| n==0? 0:(i=g.call(n))==89 ? 0:i}).collect{|n| while n>1 do n = G[n] end; n }z = 0   #Running count of numbers translating to 1(0..9).collect{|n| n**2}.repeated_combination(K).each{|n|   #Iterate over unique digit combinations    next if N[n.inject(:+)] == 0                            #Count only ones    nn = Hash.new{0}                                        #Determine how many numbers this digit combination corresponds to    n.each{|n| nn[n] += 1}                                  #and    z += nn.values.inject(F[K]){|gn,n| gn/F[n]}             #Add to the count of numbers terminating in 1}puts ""k=(#{K}) in the range 1 to #{10**K-1}#{z} numbers produce 1 and #{10**K-1-z} numbers produce 89"" "
"require 'bigdecimal' [0, 0.0, Complex(0), Rational(0), BigDecimal.new(strv)].each do |n|  printf ""%10s: ** -> %s"" % [n.class, n**n]end[0, Complex(0, 0)].each {|n|    say n**n;    say n.pow(n);    say pow(n, n);    say Math.pow(n, n);}say 0.root(0).pow(0);       
say ((0**(1/0))**0);        
"
"class ZhangSuen  NEIGHBOUR8 = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]  
  CIRCULARS = NEIGHBOUR8 + [NEIGHBOUR8.first]                       
  def initialize(str, black=strv)    s1 = str.each_line.map{|line| line.chomp.each_char.map{|c| c==black ? 1 : 0}}    s2 = s1.map{|line| line.map{0}}    xrange = 1 ... s1.size-1    yrange = 1 ... s1[0].size-1    printout(s1)    begin      @r = 0      xrange.each{|x| yrange.each{|y| s2[x][y] = s1[x][y] - zs(s1,x,y,1)}}  
      xrange.each{|x| yrange.each{|y| s1[x][y] = s2[x][y] - zs(s2,x,y,0)}}  
    end until @r == 0    printout(s1)  end  def zs(ng,x,y,g)    return 0 if ng[x][y] == 0 or                                    
               (ng[x-1][y] + ng[x][y+1] + ng[x+g][y-1+g]) == 3 or   
               (ng[x-1+g][y+g] + ng[x+1][y] + ng[x][y-1]) == 3      
    bp1 = NEIGHBOUR8.inject(0){|res,(i,j)| res += ng[x+i][y+j]}     
    return 0 if bp1 < 2 or 6 < bp1    ap1 = CIRCULARS.map{|i,j| ng[x+i][y+j]}.each_cons(2).count{|a,b| a<b}   
    return 0 if ap1 != 1    @r = 1  end  def printout(image)    puts image.map{|row| row.map{|col| strv[col]}.join}  endend str = <<EOS
...........................................................
.#################...................#############.........
.##################...............################.........
.###################............##################.........
.########.....#######..........###################.........
...######.....#######.........#######.......######.........
...######.....#######........#######.......................
...#################.........#######.......................
...################..........#######.......................
...#################.........#######.......................
...######.....#######........#######.......................
...######.....#######........#######.......................
...######.....#######.........#######.......######.........
.########.....#######..........###################.........
.########.....#######.######....##################.######..
.########.....#######.######......################.######..
.########.....#######.######.........#############.######..
...........................................................
EOS ZhangSuen.new(str) task_example = <<EOS
00000000000000000000000000000000
01111111110000000111111110000000
01110001111000001111001111000000
01110000111000001110000111000000
01110001111000001110000000000000
01111111110000001110000000000000
01110111100000001110000111000000
01110011110011101111001111011100
01110001111011100111111110011100
00000000000000000000000000000000
EOS ZhangSuen.new(task_example, strv)class ZhangSuen(str, black=strv) {  const NEIGHBOURS = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]  
  const CIRCULARS = (NEIGHBOURS + [NEIGHBOURS.first])                         
   has r = 0;  has image = [[]];   method init {    var s1 = str.lines.map{|line| line.chars.map{|c| c==black ? 1 : 0 }}    var s2 = s1.len.of { s1[0].len.of(0) }    var xr = RangeNum(1, s1.end-1)    var yr = RangeNum(1, s1[0].end-1)    do {        r = 0;        xr.each{|x| yr.each{|y| s2[x][y] = (s1[x][y] - self.zs(s1,x,y,1)) }}  
        xr.each{|x| yr.each{|y| s1[x][y] = (s2[x][y] - self.zs(s2,x,y,0)) }}  
    } while !r.is_zero;    image = s1;  }   method zs(ng,x,y,g) {       (ng[x][y] == 0)                                   ->    || (ng[x-1][y] + ng[x][y+1] + ng[x+g][y+g - 1] == 3) ->    || (ng[x+g - 1][y+g] + ng[x+1][y] + ng[x][y-1] == 3) ->    && return 0;     var bp1 = NEIGHBOURS.map {|p| ng[x+p[0]][y+p[1]] }.sum(0);  
    return 0 if ((bp1 < 2) || (6 < bp1));     var ap1 = 0;    CIRCULARS.map {|p| ng[x+p[0]][y+p[1]] }.each_cons(2, {|p|        ++ap1 if (p[0] < p[1])                                  
    })     return 0 if (ap1 != 1);    r = 1  }   method display {    image.each{|row| say row.map{|col| col ? '#' : ' ' }.join }  }} var text = <<EOS
00000000000000000000000000000000
01111111110000000111111110000000
01110001111000001111001111000000
01110000111000001110000111000000
01110001111000001110000000000000
01111111110000001110000000000000
01110111100000001110000111000000
01110011110011101111001111011100
01110001111011100111111110011100
00000000000000000000000000000000
EOS ZhangSuen.new(text, black: strv).display"
"def zigzag(n)  (seq=*0...n).product(seq)    .sort_by {|x,y| [x+y, (x+y).even? ? y : -y]}    .each_with_index.sort.map(&:last).each_slice(n).to_aend def print_matrix(m)  format = strv * m[0].size  puts m.map {|row| format % row}end print_matrix zigzag(5)func zig_zag(w, h) {     var r = [];    var n = 0;     h.of { |e|        w.of { |f|            [e-1, f-1]        }    } \    -> reduce('+') \    -> sort { |a, b|           (a[0]+a[1] <=> b[0]+b[1]) ||           (a[0]+a[1] -> is_even ? a[0]<=>b[0]                                 : a[1]<=>b[1])    } \    -> each { |a|       r[a[1]][a[0]] = n++;    }     return r;} zig_zag(5, 5).each {say .join('', {|i| strv % i})};"
"def zeckendorf  return to_enum(__method__) unless block_given?  x = 0  loop do    bin = x.to_s(2)    yield bin unless bin.include?(strv)     x += 1  endend zeckendorf.take(21).each_with_index{|x,i| puts strv% [i, x]} def zeckendorf(n)  return 0 if n.zero?  fib = [1,2]  fib << fib[-2] + fib[-1] while fib[-1] < n  dig = strv  fib.reverse_each do |f|    if f <= n      dig, n = dig + strv, n - f    else      dig += strv    end  end  dig.to_iend for i in 0..20  puts '%3d: %8d' % [i, zeckendorf(i)]endfunc fib(n) is cached {    n < 2 ? 1          : (fib(n-1) + fib(n-2));} func zeckendorf(n) {    n == 0 && return '0';    var i = 1;    ++i while (fib(i) <= n);    gather {        while (--i > 0) {            var f = fib(i);            f > n ? (take '0')                  : (take '1'; n -= f);        }    }.join('');} range(0, 20).each { |n|    printf(""%4d: %8s"", n, zeckendorf(n))}"
"require 'open-uri'require 'hpricot' SearchResult = Struct.new(:url, :title, :content) class SearchYahoo  @@urlinfo = [nil, 'ca.search.yahoo.com', 80, '/search', nil, nil]   def initialize(term)    @term = term    @page = 1    @results = nil    @url = .build(@@urlinfo)  end   def next_result    if not @results      @results = []      fetch_results    elsif @results.empty?      next_page    end    @results.shift  end   def fetch_results    @url.query = URI.escape(strv % [@term, @page])    doc = open(@url) { |f| Hpricot(f) }      parse_html(doc)  end   def next_page    @page += 10    fetch_results  end   def parse_html(doc)    doc.search(strv).search(strv).each do |div|      next unless div.has_attribute?(strv) and div.get_attribute(strv).index(strv) == 0      result = SearchResult.new      div.search(strv).each do |link|        next unless link.has_attribute?(strv) and link.get_attribute(strv) == strv        result.url = link.get_attribute(strv)        result.title = link.inner_text      end      div.search(strv).each do |abstract|        next unless abstract.has_attribute?(strv) and abstract.get_attribute(strv).index(strv)        result.content = abstract.inner_text      end      @results << result    end  endend s = SearchYahoo.new(strv)15.times do |i|  result = s.next_result  puts i+1  puts result.title  puts result.url  puts result.content  putsend"
"Shoes.app(:width => 470, :height => 380) do  PI = Shoes::TWO_PI/2   strokewidth 1   def yin_yang(x, y, radius)    fill black; stroke black    arc x, y, radius, radius, -PI/2, PI/2     fill white; stroke white    arc x, y, radius, radius, PI/2, -PI/2    oval x-radius/4, y-radius/2, radius/2-1     fill black; stroke black    oval x-radius/4, y, radius/2-1    oval x-radius/12, y-radius/4-radius/12, radius/6-1     fill white; stroke white    oval x-radius/12, y+radius/4-radius/12, radius/6-1     nofill    stroke black    oval x-radius/2, y-radius/2, radius  end   yin_yang 190, 190, 360  yin_yang 410, 90, 90endfunc circle (rad, cx, cy, fill='white', stroke='black') {    say strv;} func yin_yang (rad, cx, cy, fill='white', stroke='black', angle=90) {    var (c, w) = (1, 0);    angle != 0 && say strv;    circle(rad, cx, cy, fill, stroke);    say(strv,        strv,        strv);    circle(rad/5, cx, cy + rad/2, fill, stroke);    circle(rad/5, cx, cy - rad/2, stroke, fill);    angle != 0 && say strv;} say '<?xml version=strv?>
<!DOCTYPE svg PUBLIC strv>
<svg xmlns=strv>'; yin_yang(40, 50, 50);yin_yang(20, 120, 120); say '</svg>';"
"CONTENT = { House:       '',            Nationality: %i[English Swedish Danish Norwegian German],            Colour:      %i[Red Green White Blue Yellow],            Pet:         %i[Dog Birds Cats Horse Zebra],            Drink:       %i[Tea Coffee Milk Beer Water],            Smoke:       %i[PallMall Dunhill BlueMaster Prince Blend] } def adjacent? (n,i,g,e)  (0..3).any?{|x| (n[x]==i and g[x+1]==e) or (n[x+1]==i and g[x]==e)}end def leftof? (n,i,g,e)  (0..3).any?{|x| n[x]==i and g[x+1]==e}end def coincident? (n,i,g,e)  n.each_index.any?{|x| n[x]==i and g[x]==e}end def solve_zebra_puzzle  CONTENT[:Nationality].permutation{|nation|    next unless nation.first == :Norwegian                              
    CONTENT[:Colour].permutation{|colour|      next unless leftof?(colour, :Green, colour, :White)               
      next unless coincident?(nation, :English, colour, :Red)           
      next unless adjacent?(nation, :Norwegian, colour, :Blue)          
      CONTENT[:Pet].permutation{|pet|        next unless coincident?(nation, :Swedish, pet, :Dog)            
        CONTENT[:Drink].permutation{|drink|          next unless drink[2] == :Milk                                 
          next unless coincident?(nation, :Danish, drink, :Tea)         
          next unless coincident?(colour, :Green, drink, :Coffee)       
          CONTENT[:Smoke].permutation{|smoke|            next unless coincident?(smoke, :PallMall, pet, :Birds)      
            next unless coincident?(smoke, :Dunhill, colour, :Yellow)   
            next unless coincident?(smoke, :BlueMaster, drink, :Beer)   
            next unless coincident?(smoke, :Prince, nation, :German)    
            next unless adjacent?(smoke, :Blend, pet, :Cats)            
            next unless adjacent?(smoke, :Blend, drink, :Water)         
            next unless adjacent?(smoke, :Dunhill,pet, :Horse)          
            print_out(nation, colour, pet, drink, smoke)  } } } } }end def print_out (nation, colour, pet, drink, smoke)  width = CONTENT.map{|x| x.flatten.map{|y|y.size}.max}  fmt = width.map{|w| strv}.join(strv)  national = nation[ pet.find_index(:Zebra) ]  puts strv,strv  puts fmt % CONTENT.keys, fmt % width.map{|w| strv*w}  [nation,colour,pet,drink,smoke].transpose.each.with_index(1){|x,n| puts fmt % [n,*x]}end solve_zebra_puzzlevar CONTENT = Hash(            :House       => nil,            :Nationality => [:English, :Swedish, :Danish, :Norwegian, :German],            :Colour      => [:Red, :Green, :White, :Blue, :Yellow],            :Pet         => [:Dog, :Birds, :Cats, :Horse, :Zebra],            :Drink       => [:Tea, :Coffee, :Milk, :Beer, :Water],            :Smoke       => [:PallMall, :Dunhill, :BlueMaster, :Prince, :Blend]) func adjacent(n,i,g,e) {  (0..3).any {|x| (n[x]==i && g[x+1]==e) || (n[x+1]==i && g[x]==e) }} func leftof(n,i,g,e) {  (0..3).any {|x| n[x]==i && g[x+1]==e }} func coincident(n,i,g,e) {  n.indices.any {|x| n[x]==i && g[x]==e }} func solve {  CONTENT{:Nationality}.permutations{|nation|    nation.first == :Norwegian ->      && CONTENT{:Colour}.permutations {|colour|          leftof(colour,:Green,colour,:White) ->       && coincident(nation,:English,colour,:Red) ->       && adjacent(nation,:Norwegian,colour,:Blue) ->       && CONTENT{:Pet}.permutations {|pet|             coincident(nation,:Swedish,pet,:Dog) ->          && CONTENT{:Drink}.permutations {|drink|               drink[2] == :Milk ->            && coincident(nation,:Danish,drink,:Tea) ->            && coincident(colour,:Green,drink,:Coffee) ->            && CONTENT{:Smoke}.permutations {|smoke|                coincident(smoke,:PallMall,pet,:Birds) ->             && coincident(smoke,:Dunhill,colour,:Yellow) ->             && coincident(smoke,:BlueMaster,drink,:Beer) ->             && coincident(smoke,:Prince,nation,:German) ->             && adjacent(smoke,:Blend,pet,:Cats) ->             && adjacent(smoke,:Blend,drink,:Water) ->             && adjacent(smoke,:Dunhill,pet,:Horse) ->             && return [nation,colour,pet,drink,smoke]} } } } } } var res = solve();var keys = [:House, :Nationality, :Colour, :Pet, :Drink, :Smoke]var width = keys.map{ .len }var fmt = width.map{|w| strv }.join(strv)say ""The Zebra is owned by the man who is #{res[0][res[2].first_index(:Zebra)]}""say (fmt % keys..., """", fmt % width.map{|w| strv*w }...)res[0].indices.map{|i| res.map{|a| a[i] }}.each_kv {|k,v| say fmt%(k,v...) }"
"#Example taken from the REXML tutorial (http://www.germane-software.com/software/rexml/docs/tutorial.html)require strvinclude REXML#create the REXML Document from the string (%q is Ruby's multiline string, everything between the two @-characters is the string)doc = Document.new(        %q@<inventory title=strv>             ...           </inventory>          @                          )
invisibility = XPath.first( doc, strv ) 
XPath.each( doc, strv) { |element| puts element.text }
names = XPath.match( doc, strv )require('XML::XPath'); var x = %s'XML::XPath'.new(ARGF.slurp); [x.findnodes('//item[1]')][0];say [x.findnodes('//price')].map{x.getNodeText(_)};[x.findnodes('//name')];"
"y = lambda do |f|  lambda {|g| g[g]}[lambda do |g|      f[lambda {|*args| g[g][*args]}]    end]end fac = lambda{|f| lambda{|n| n < 2 ? 1 : n * f[n-1]}}p Array.new(10) {|i| y[fac][i]}   #=> [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880] fib = lambda{|f| lambda{|n| n < 2 ? n : f[n-1] + f[n-2]}}p Array.new(10) {|i| y[fib][i]}   #=> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]y = ->(f) {->(g) {g.(g)}.(->(g) { f.(->(*args) {g.(g).(*args)})})} fac = ->(f) { ->(n) { n < 2 ? 1 : n * f.(n-1) } } p 10.times.map {|i| y.(fac).(i)} fib = ->(f) { ->(n) { n < 2 ? n : f.(n-2) + f.(n-1) } } p 10.times.map {|i| y.(fib).(i)}def y(&f)  lambda do |g|    f.call {|*args| g[g][*args]}  end.tap {|g| break g[g]}end fac = y {|&f| lambda {|n| n < 2 ? 1 : n * f[n - 1]}}fib = y {|&f| lambda {|n| n < 2 ? n : f[n - 1] + f[n - 2]}} p Array.new(10) {|i| fac[i]}
p Array.new(10) {|i| fib[i]}
y = lambda do |f|  lambda {|*args| f[y[f]][*args]}endvar y = ->(f) {->(g) {g(g)}(->(g) { f(->(*args) {g(g)(args...)})})}; var fac = ->(f) { ->(n) { n < 2 ? 1 : (n * f(n-1)) } };say 10.of { |i| y(fac)(i) }; var fib = ->(f) { ->(n) { n < 2 ? n : (f(n-2) + f(n-1)) } };say 10.of { |i| y(fib)(i) };"
"require 'rexml/document'include REXML remarks = {  %q(April)         => %q(Bubbly: I'm > Tam and <= Emily),
  %q(Tam O'Shanter) => %q(Burns: strv),  %q(Emily)         => %q(Short & shrift),} doc = Document.newroot = doc.add_element(strv) remarks.each do |name, remark|  root.add_element(strv, {'Name' => name}).add_text(remark)end 
doc.write($stdout, 2)require('XML::Mini::Document'); var students = [                [strv,         strv],                [strv, ""Burns: When chapman billies leave the street ...""],                [strv,         strv]               ]; var doc   = %s'XML::Mini::Document'.new;var root  = doc.getRoot;var studs = root.createChild(strv); students.each { |s|    var stud = studs.createChild(strv);    stud.attribute(strv, s[0]);    stud.text(s[1]);}; print doc.toString;"
"require(strv)include REXML(doc = Document.new) << XMLDecl.newroot = doc.add_element('root')element = root.add_element('element')element.add_text('Some text here') 

serialized = String.newdoc.write(serialized, 4)puts serializedrequire('XML::Simple');print %S'XML::Simple'.XMLout(    :(root => :( element => 'Some text here' )),    NoAttr => 1, RootName => '',);"
"require 'rexml/document'include REXML doc = Document.new(File.new(strv))

 
doc.each_recursive do |node|  puts node.attributes[strv] if node.name == strvend 
doc.each_element(strv) {|node| puts node.attributes[strv]}require('XML::Simple'); var ref = %S'XML::Simple'.XMLin('<Students>
  <Student Name=strv />
  <Student Name=strv />
  <Student Name=strv />
  <Student Name=strv>
    <Pet Type=strv />
  </Student>
  <Student DateOfBirth=strv />
</Students>'); ref{:Student}.each { say _{:Name} };"
"require 'win32/eventlog'logger = Win32::EventLog.newlogger.report_event(:event_type => Win32::EventLog::INFO, :data => strv)"
"def ipart(n); n.truncate; enddef fpart(n); n - ipart(n); enddef rfpart(n); 1.0 - fpart(n); end class Pixmap  def draw_line_antialised(p1, p2, colour)    x1, y1 = p1.x, p1.y    x2, y2 = p2.x, p2.y     steep = (y2 - y1).abs > (x2 - x1).abs    if steep      x1, y1 = y1, x1      x2, y2 = y2, x2    end    if x1 > x2      x1, x2 = x2, x1      y1, y2 = y2, y1    end    deltax = x2 - x1    deltay = (y2 - y1).abs    gradient = 1.0 * deltay / deltax     
    xend = x1.round    yend = y1 + gradient * (xend - x1)    xgap = rfpart(x1 + 0.5)    xpxl1 = xend    ypxl1 = ipart(yend)    put_colour(xpxl1, ypxl1, colour, steep, rfpart(yend)*xgap)    put_colour(xpxl1, ypxl1 + 1, colour, steep, fpart(yend)*xgap)    itery = yend + gradient     
    xend = x2.round    yend = y2 + gradient * (xend - x2)    xgap = rfpart(x2 + 0.5)    xpxl2 = xend    ypxl2 = ipart(yend)    put_colour(xpxl2, ypxl2, colour, steep, rfpart(yend)*xgap)    put_colour(xpxl2, ypxl2 + 1, colour, steep, fpart(yend)*xgap)     
    (xpxl1 + 1).upto(xpxl2 - 1).each do |x|      put_colour(x, ipart(itery), colour, steep, rfpart(itery))      put_colour(x, ipart(itery) + 1, colour, steep, fpart(itery))      itery = itery + gradient    end  end   def put_colour(x, y, colour, steep, c)    x, y = y, x if steep    self[x, y] = anti_alias(colour, self[x, y], c)  end   def anti_alias(new, old, ratio)    blended = new.values.zip(old.values).map {|n, o| (n*ratio + o*(1.0 - ratio)).round}    RGBColour.new(*blended)  endend bitmap = Pixmap.new(500, 500)bitmap.fill(RGBColour::BLUE)10.step(430, 60) do |a|  bitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)  bitmap.draw_line_antialised(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)endbitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)func plot(x, y, c) {    c && printf(""plot %d %d %.1f"", x, y, c);} func fpart(x) {    x - int(x);} func rfpart(x) {    1 - fpart(x);} func drawLine(x0, y0, x1, y1) {     var p = plot;    if (abs(y1 - y0) > abs(x1 - x0)) {        p = {|arg| plot(arg[1, 0, 2]) };        (x0, y0, x1, y1) = (y0, x0, y1, x1);    }     if (x0 > x1) {        (x0, x1, y0, y1) = (x1, x0, y1, y0);    }     var dx = (x1 - x0);    var dy = (y1 - y0);    var gradient = (dy / dx);     var xends = [];    var intery;     
    for x,y in [[x0, y0], [x1, y1]] {        var xend = int(x + 0.5);        var yend = (y + gradient*(xend-x));        var xgap = rfpart(x + 0.5);         var x_pixel = xend;        var y_pixel = yend.int;        xends << x_pixel;         p.call(x_pixel, y_pixel  , rfpart(yend) * xgap);        p.call(x_pixel, y_pixel+1,  fpart(yend) * xgap);        defined(intery) && next;         
        intery = (yend + gradient);    }     
    range(xends[0]+1, xends[1]-1).each { |x|        p.call(x, intery.int,  rfpart(intery));        p.call(x, intery.int+1, fpart(intery));        intery += gradient;    }} drawLine(0, 1, 10, 2);"
"teams = [:a, :b, :c, :d]matches = teams.combination(2).to_aoutcomes = [:win, :draw, :loss]gains = {win:[3,0], draw:[1,1], loss:[0,3]}places_histogram = Array.new(4) {Array.new(10,0)} 

outcomes.repeated_permutation(6).each do |outcome|  results = Hash.new(0)   
  outcome.zip(matches).each do |decision, (team1, team2)|    results[team1] += gains[decision][0]    results[team2] += gains[decision][1]  end    
  results.values.sort.reverse.each_with_index do |points, place|    places_histogram[place][points] += 1  endend fmt = strv + strv*10puts fmt % [strv, *0..9]puts fmt % [strv, *[strv]*10]places_histogram.each.with_index(1) {|hist,place| puts fmt % [place, *hist]}"
"open(fname, 'w'){|f| f.write(str) }var file = File(__FILE__)file.open_w(\var fh, \var err) || die strvfh.print(strv)       || die strvFile(__FILE__).open_w.print(strv)"
"text = <<EOS
####        #




####  #  #  ###  #   #






                 #
                #
EOS def banner3D_1(text, shift=-1)  txt = text.each_line.map{|line| line.gsub('#','__/').gsub(' ','   ')}  offset = Array.new(txt.size){|i| strv * shift.abs * i}  offset.reverse! if shift < 0  puts offset.zip(txt).map(&:join)endbanner3D_1(text) puts
def banner3D_2(text, shift=-2)  txt = text.each_line.map{|line| line.chomp + ' '}  offset = txt.each_index.map{|i| strv * shift.abs * i}  offset.reverse! if shift < 0  txt.each_with_index do |line,i|    line2 = offset[i] + line.gsub(' ','   ').gsub('#','///').gsub('/ ','/')    puts line2, line2.tr('/','/')  endendbanner3D_2(text) puts
def banner3D_3(text)  txt = text.each_line.map(&:rstrip)  offset = [*0...txt.size].reverse  area = Hash.new(' ')  box = [%w(/ / / \\), %w(\\ \\ \\ /)]  txt.each_with_index do |line,i|    line.each_char.with_index do |c,j|      next if c==' '      x = offset[i] + 2*j      box[0].each_with_index{|c,k| area[[x+k,i  ]] = c}      box[1].each_with_index{|c,k| area[[x+k,i+1]] = c}    end  end  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)  puts (ymin..ymax).map{|y| (xmin..xmax).map{|x| area[[x,y]]}.join}end banner3D_3 <<EOS
####         #






####   #  #  ####  #     #








                    #
                   #
EOSenc = ""9 8u18 2u18 1s 6u1 b16 1s sb6 2 s1b4u1s sb13 3 s15 3 s3 3s 11 3 s14 2 s1us3u1su2s 2u4 2u3 2 s1us3u4 2u6 2u14 1s 6u1sbubs2 s1b 2 s1b2 1s 6u1 b2 1susb3 2 s1b2 2 s1b2 3u1bs2 8 s1b4u1s s4b 3 s1 3 s3b 2 9 s3 3s 3 b2s 1s 3s 3 b1 2 s2us4 s1us2u2us1 s3 3 b1s ssu2s 2 4 b6u2s 1s7u1sbubs6 1bub2 1sbubs6 1bubs2 1b5u1bs  b7u1bs8 3 s142 2u2s 1s41 1s3u1s s41 1b3u1bs""def decode(str)  str.split(/(\d+)(\D+)/).each_slice(3).map{|_,n,s| s * n.to_i}.join.tr('sub','/_')endputs decode(enc)var text = <<'EOT';      ***    *     *     *        **    *           *       *    *     *     *  ***  **     ***  *  **** *   * *        * * *   * ***** *        * * *   * *     *        * * *   * *     *     ***  *  ****  ***  *EOT func banner3D(text, shift=-1) {    var txt = text.lines.map{|line| line.gsub('*','__/').gsub(' ','   ')};    var offset = txt.len.of {|i| strv * (shift.abs * i)};    shift < 0 && offset.reverse!;    (offset »+« txt).join("""");}; say banner3D(text);"
"
x = [1, 2, 3, 1e11]y = x.collect { |xx| Math.sqrt xx }xprecision = 3yprecision = 5 
open('sqrt.dat', 'w') do |f|  x.zip(y) { |xx, yy| f.printf(""%.*g%.*g"", xprecision, xx, yprecision, yy) }end 
open('sqrt.dat', 'r') { |f| puts f.read }func writedat(filename, x, y, x_precision=3, y_precision=5) {    var fh = File.new(filename).open_w;     MultiArray.new(x, y).each { |x, y|        fh.printf(""%.*g%.*g"", x_precision, x, y_precision, y);    }     fh.close;} var x = [1, 2, 3, 1e11];var y = x»sqrt»(); writedat('sqrt.dat', x, y);"
"class String  def wrap(width)    txt = gsub("""", strv)    para = []    i = 0    while i < length       j = i + width      j -= 1 while j != txt.length && j > i + 1 && !(txt[j] =~ /\s/)      para << txt[i ... j]      i = j + 1    end    para  endend text = <<END
In olden times when wishing still helped one, there lived a king
whose daughters were all beautiful, but the youngest was so beautiful
that the sun itself, which has seen so much, was astonished whenever
it shone in her face.  Close by the king's castle lay a great dark
forest, and under an old lime-tree in the forest was a well, and when
the day was very warm, the king's child went out into the forest and
sat down by the side of the cool fountain, and when she was bored she
took a golden ball, and threw it up on high and caught it, and this
ball was her favorite plaything.
END [72,80].each do |w|  puts strv * w  puts text.wrap(w)endclass String {    method wrap(width) {        var txt = self.gsub(/\s+/, strv);        var len = txt.len;        var para = [];        var i = 0;        while (i < len) {            var j = (i + width);            while ((j < len) && (txt.char_at(j) != ' ')) { --j };            para.append(txt.substr(i, j-i));            i = j+1;        };        return para.join("""");    }} var text = 'aaa bb cc ddddd';say text.wrap(6);class SmartWordWrap {     has width = 80     method prepare_words(array, depth=0, callback) {         var root = []        var len = 0        var i = -1         var limit = array.end        while (++i <= limit) {            len += (var word_len = array[i].len)             if (len > width) {                if (word_len > width) {                    len -= word_len                    array.splice(i, 1, array[i].split(width)...)                    limit = array.end                    --i; next                }                break            }             root << [                array.first(i+1).join(' '),                self.prepare_words(array.ft(i+1), depth+1, callback)            ]             if (depth.is_zero) {                callback(root[0])                root = []            }             break if (++len >= width)        }         root    }     method combine(root, path, callback) {        var key = path.shift        path.each { |value|            root << key            if (value.is_empty) {                callback(root)            }            else {                value.each { |item|                    self.combine(root, item, callback)                }            }            root.pop        }    }     method wrap(text, width) {         self.width = width        var words = (text.kind_of(Array) ? text : text.words)         var best = Hash(            score => Inf,            value => [],        )         self.prepare_words(words, callback: { |path|            self.combine([], path, { |combination|                var score = 0                combination.ft(0, -2).each { |line|                    score += (width - line.len -> sqr)                }                 if (score < best{:score}) {                    best{:score} = score                    best{:value} = []+combination                }            })        })         best{:value}.join("""")    }} var sww = SmartWordWrap(); var words = %w(aaa bb cc ddddd);var wrapped = sww.wrap(words, 6); say wrapped;"
"var f = [[], DATA.lines.map {['', .chars..., '']}..., []]; 10.times {    say f.map { .join(strv) + """" }.join;    var a = [[]];    for y in (1 .. f.end-1) {        var r = f[y];        var rr = [''];        for x in (1 .. r.end-1) {            var c = r[x];            rr << (              given(c) {                when('H') { 't' }                when('t') { '.' }                when('.') { <. H>[f.ft(y-1, y+1).map{.ft(x-1, x+1)...}.count('H') ~~ [1,2]] }                default   { c }              }            )        }        rr << '';        a << rr;    }    f = [a..., []];} __DATA__tH..........   .   ....   .Ht.. ......"
" def a(array)n=array.lengthleft={}right={}left[0]=array[0]i=1loop do   break if i >=nleft[i]=[left[i-1],array[i]].max   i += 1  endright[n-1]=array[n-1]i=n-2loop do break if i<0 right[i]=[right[i+1],array[i]].maxi-=1endi=0water=0loop dobreak if i>=nwater+=[left[i],right[i]].min-array[i]i+=1endputs waterend a([ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ])a([ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ])a([ 5, 5,  5, 5 ])a([ 5, 6,  7, 8 ])a([ 8, 7,  7, 6 ])a([ 6, 7, 10, 7, 6 ])returnfunc max_l(Array a, m = a[0]) {    gather { a.each {|e| take(m = max(m, e)) } }} func max_r(Array a) {    max_l(a.flip).flip} func water_collected(Array towers) {    var levels = (max_l(towers) »min« max_r(towers))    (levels »-« towers).grep{ _ > 0 }.sum} [    [ 1, 5,  3, 7, 2 ],    [ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ],    [ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ],    [ 5, 5,  5, 5 ],    [ 5, 6,  7, 8 ],    [ 8, 7,  7, 6 ],    [ 6, 7, 10, 7, 6 ],].map { water_collected(_) }.say"
 require 'tk'  window = TkRoot::new() window::mainloop() require 'gtk2'  window = Gtk::Window.new.show Gtk.mainShoes.app {}var tk = require('Tk');%s'MainWindow'.new;tk.MainLoop;var gtk2 = require('Gtk2') -> init;var window = %s'Gtk2::Window'.new;window.signal_connect(destroy => func(*_) { gtk2.main_quit });window.show_all;gtk2.main;
"require strv open('http://tycho.usno.navy.mil/cgi-bin/timer.pl') do |p|  p.each_line do |line|    if line =~ /UTC/      puts line.match(/ (\d{1,2}:\d{1,2}:\d{1,2}) /)      break    end  endend require 'open-uri'puts URI.parse('http://tycho.usno.navy.mil/cgi-bin/timer.pl').read.match(/ (\d{1,2}:\d{1,2}:\d{1,2}) UTC/)[1] var ua = frequire('LWP::Simple');var url = 'http://tycho.usno.navy.mil/cgi-bin/timer.pl';var match = /<BR>(.+? UTC)/.match(ua.get(url));say match[0] if match;"
"
Dir.glob('*') { |file| puts file } 
Dir.glob( File.join('/foo/bar', '*') ) { |file| puts file } 
def file_match(pattern=/\.txt/, path='.')  Dir[File.join(path,'*')].each do |file|    puts file if file =~ pattern  endend'*.p[lm]'.glob.each { |file| say file };    
func file_match(Block callback, pattern=/\.txt\z/, path=Dir.cwd) {    path.open(\var dir_h) || return;    dir_h.entries.each { |entry|        if (entry.basename ~~ pattern) {            callback(entry);        }    }} file_match(    path: %d'/tmp',    pattern: /\.p[lm]\z/i,    callback: { |file|        say file;    });"
"require 'find' Find.find('/your/path') do |f|   
   puts f if f.match(/\.mp3\Z/)endputs Dir['**/*.mp3']func traverse(Block callback, Dir dir) {    dir.open(\var dir_h) || return;     dir_h.entries.each { |entry|        if (entry.is_a(Dir)) {            traverse(callback, entry);        } else {            callback(entry);        }    }} var dir = Dir.cwd;var pattern = /foo/;   
 traverse(    { |file|        if (file.basename ~~ pattern) {            say file;        }    } => dir);"
"load 'raster_graphics.rb' class ColourPixel < Pixel  def initialize(x, y, colour)    @colour = colour    super x, y  end  attr_accessor :colour   def distance_to(px, py)    Math::hypot(px - x, py - y)  end end width, height = 300, 200npoints = 20pixmap = Pixmap.new(width,height) @bases = npoints.times.collect do |i|  ColourPixel.new(      3+rand(width-6), 3+rand(height-6),  
      RGBColour.new(rand(256), rand(256), rand(256))  )end pixmap.each_pixel do |x, y|   nearest = @bases.min_by {|base| base.distance_to(x, y)}  pixmap[x, y] = nearest.colourend @bases.each do |base|   pixmap[base.x, base.y] = RGBColour::BLACK  pixmap.draw_circle(base, 2, RGBColour::BLACK)end pixmap.save_as_png(strv)require('Imager') func generate_voronoi_diagram(width, height, num_cells) {    var img = %s<Imager>.new(xsize => width, ysize => height)    var (nx,ny,nr,ng,nb) = 5.of { [] }...     for i in ^num_cells {        nx << rand(^width)        ny << rand(^height)        nr << rand(^256)        ng << rand(^256)        nb << rand(^256)    }     for y in ^height {        for x in ^width {            var dmin = hypot(width-1, height-1)            var j = -1            for i in ^num_cells {                var d = hypot(nx[i]-x, ny[i]-y)                if (d < dmin) { (dmin, j) = (d, i) }            }            img.setpixel(x => x, y => y, color => [nr[j], ng[j], nb[j]])        }    }    return img} var img = generate_voronoi_diagram(500, 500, 25)img.write(file => 'VoronoiDiagram.png')"
"
#

COSTS  = {W: {A: 16, B: 16, C: 13, D: 22, E: 17},          X: {A: 14, B: 14, C: 13, D: 19, E: 15},          Y: {A: 19, B: 19, C: 20, D: 23, E: 50},          Z: {A: 50, B: 12, C: 50, D: 15, E: 11}}demand = {A: 30, B: 20, C: 70, D: 30, E: 60}supply = {W: 50, X: 60, Y: 50, Z: 50}COLS = demand.keysres = {}; COSTS.each_key{|k| res[k] = Hash.new(0)}g = {}; supply.each_key{|x| g[x] = COSTS[x].keys.sort_by{|g| COSTS[x][g]}}        demand.each_key{|x| g[x] = COSTS.keys.sort_by{|g| COSTS[g][x]}} until g.empty?   d = demand.collect{|x,y| [x, z = COSTS[g[x][0]][x], g[x][1] ? COSTS[g[x][1]][x] - z : z]}  dmax = d.max_by{|n| n[2]}  d = d.select{|x| x[2] == dmax[2]}.min_by{|n| n[1]}  s = supply.collect{|x,y| [x, z = COSTS[x][g[x][0]], g[x][1] ? COSTS[x][g[x][1]] - z : z]}  dmax = s.max_by{|n| n[2]}  s = s.select{|x| x[2] == dmax[2]}.min_by{|n| n[1]}  t,f = d[2]==s[2] ? [s[1], d[1]] : [d[2],s[2]]   d,s = t > f ? [d[0],g[d[0]][0]] : [g[s[0]][0],s[0]]  v = [supply[s], demand[d]].min  res[s][d] += v  demand[d] -= v  if demand[d] == 0 then    supply.reject{|k, n| n == 0}.each_key{|x| g[x].delete(d)}    g.delete(d)    demand.delete(d)  end  supply[s] -= v  if supply[s] == 0 then    demand.reject{|k, n| n == 0}.each_key{|x| g[x].delete(s)}    g.delete(s)    supply.delete(s)  endend COLS.each{|n| print """", n}putscost = 0COSTS.each_key do |g|  print g, """"  COLS.each do |n|    y = res[g][n]    print y if y != 0    cost += y * COSTS[g][n]    print """"  end  putsendprint ""Total Cost = "", costCOSTS  = {S1: {D1: 46, D2:  74, D3:  9, D4: 28, D5: 99},          S2: {D1: 12, D2:  75, D3:  6, D4: 36, D5: 48},          S3: {D1: 35, D2: 199, D3:  4, D4:  5, D5: 71},          S4: {D1: 61, D2:  81, D3: 44, D4: 88, D5:  9},          S5: {D1: 85, D2:  60, D3: 14, D4: 25, D5: 79}}demand = {D1: 278, D2: 60, D3: 461, D4: 116, D5: 1060}supply = {S1: 461, S2: 277, S3: 356, S4: 488, S5: 393}"
" root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]  require 'pp'pp root  def ptree(tree,indent=strv)  case tree  when Array    head,*tail=tree    ptree(head,indent)    s=tail.size-1    tail.each_with_index { |tree1,i| ptree(tree1,strv) }   else     puts(indent.gsub(/\s\s$/,strv).gsub(/ --$/,""--"")+tree.to_s)  endendptree [1,2,3,[4,5,6,[7,8,9]],3,[22,33]] func visualize_tree(tree, label, children,                    indent = '',                    mids = ['├─', '│ '],                    ends = ['└─', '  '],) {    func visit(node, pre) {        gather {            take(pre[0] + label(node))            var chldn = children(node)            var end = chldn.end            chldn.each_kv { |i, child|                if (i == end) { take(visit(child, [pre[1]] ~X+ ends)) }                else          { take(visit(child, [pre[1]] ~X+ mids)) }            }        }    }    visit(tree, [indent] * 2)} var tree = 'root':['a':['a1':['a11':[]]],'b':['b1':['b11':[]],'b2':[],'b3':[]]]say visualize_tree(tree, { .first }, { .second }).flatten.join("""")"
"def distcheck(n, delta=1)  unless block_given?    raise ArgumentError, strv  end   h = Hash.new(0)  n.times {h[ yield ] += 1}   target = 1.0 * n / h.length  h.each do |key, value|     if (value - target).abs > 0.01 * delta * n      raise StandardError,        strv    end  end   puts h.sort.map{|k, v| strv}end if __FILE__ == $0  begin    distcheck(100_000) {rand(10)}    distcheck(100_000) {rand > 0.95}   rescue StandardError => e    p e  endend"
"def gammaInc_Q(a, x)  a1, a2 = a-1, a-2  f0  = lambda {|t| t**a1 * Math.exp(-t)}  df0 = lambda {|t| (a1-t) * t**a2 * Math.exp(-t)}   y = a1  y += 0.3  while f0[y]*(x-y) > 2.0e-8 and y < x  y = x  if y > x   h = 3.0e-4  n = (y/h).to_i  h = y/n  hh = 0.5 * h  sum = 0  (n-1).step(0, -1) do |j|    t = h * j    sum += f0[t] + hh * df0[t]  end  h * sum / gamma_spounge(a)end A = 12k1_factrl = 1.0coef = [Math.sqrt(2.0*Math::PI)]COEF = (1...A).each_with_object(coef) do |k,c|  c << Math.exp(A-k) * (A-k)**(k-0.5) / k1_factrl  k1_factrl *= -kend def gamma_spounge(z)  accm = (1...A).inject(COEF[0]){|res,k| res += COEF[k] / (z+k)}  accm * Math.exp(-(z+A)) * (z+A)**(z+0.5) / zend def chi2UniformDistance(dataSet)  expected = dataSet.inject(:+).to_f / dataSet.size  dataSet.map{|d|(d-expected)**2}.inject(:+) / expectedend def chi2Probability(dof, distance)  1.0 - gammaInc_Q(0.5*dof, 0.5*distance)end def chi2IsUniform(dataSet, significance=0.05)  dof = dataSet.size - 1  dist = chi2UniformDistance(dataSet)  chi2Probability(dof, dist) > significanceend dsets = [ [ 199809, 200665, 199607, 200270, 199649 ],          [ 522573, 244456, 139979,  71531,  21461 ] ] for ds in dsets  puts strv  dof = ds.size - 1  puts strv % dof  distance = chi2UniformDistance(ds)  puts strv % distance  puts strv % chi2Probability(dof, distance)  puts strv % (chi2IsUniform(ds) ? strv : strv)end"
"module VigenereCipher   BASE = 'A'.ord  SIZE = 'Z'.ord - BASE + 1   def encrypt(text, key)    crypt(text, key, :+)  end   def decrypt(text, key)    crypt(text, key, :-)  end   def crypt(text, key, dir)    text = text.upcase.gsub(/[^A-Z]/, '')    key_iterator = key.upcase.gsub(/[^A-Z]/, '').chars.map{|c| c.ord - BASE}.cycle    text.each_char.inject('') do |ciphertext, char|      offset = key_iterator.next      ciphertext << ((char.ord - BASE).send(dir, offset) % SIZE + BASE).chr    end  end endinclude VigenereCipher plaintext = 'Beware the Jabberwock, my son! The jaws that bite, the claws that catch!'key = 'Vigenere cipher'ciphertext = VigenereCipher.encrypt(plaintext, key)recovered  = VigenereCipher.decrypt(ciphertext, key) puts strvputs strvputs strvfunc s2v(s) { s.uc.scan(/[A-Z]/)»ord»() »-» 65 };func v2s(v) { (v »%» 26 »+» 65)»chr»().join }; func blacken (red, key) { v2s(s2v(red) »+« s2v(key)) };func redden  (blk, key) { v2s(s2v(blk) »-« s2v(key)) }; var red = strv;var key = strv; say red;say (var black = blacken(red, key));say redden(black, key);"
"class Vector  def self.polar(r, angle=0)    new(r*Math.cos(angle), r*Math.sin(angle))  end   attr_reader :x, :y   def initialize(x, y)    raise TypeError unless x.is_a?(Numeric) and y.is_a?(Numeric)    @x, @y = x, y  end   def +(other)    raise TypeError if self.class != other.class    self.class.new(@x + other.x, @y + other.y)  end   def -@;       self.class.new(-@x, -@y)        end  def -(other)  self + (-other)                 end   def *(scalar)    raise TypeError unless scalar.is_a?(Numeric)    self.class.new(@x * scalar, @y * scalar)  end   def /(scalar)    raise TypeError unless scalar.is_a?(Numeric) and scalar.nonzero?    self.class.new(@x / scalar, @y / scalar)  end   def r;        @r     ||= Math.hypot(@x, @y)   end  def angle;    @angle ||= Math.atan2(@y, @x)   end  def polar;    [r, angle]                      end  def rect;     [@x, @y]                        end  def to_s;     strv      end  alias inspect to_send p v = Vector.new(1,1)                   #=> Vector[1, 1]p w = Vector.new(3,4)                   #=> Vector[3, 4]p v + w                                 #=> Vector[4, 5]p v - w                                 #=> Vector[-2, -3]p -v                                    #=> Vector[-1, -1]p w * 5                                 #=> Vector[15, 20]p w / 2.0                               #=> Vector[1.5, 2.0]p w.x                                   #=> 3p w.y                                   #=> 4p v.polar                               #=> [1.4142135623730951, 0.7853981633974483]p w.polar                               #=> [5.0, 0.9272952180016122]p z = Vector.polar(1, Math::PI/2)       #=> Vector[6.123031769111886e-17, 1.0]p z.rect                                #=> [6.123031769111886e-17, 1.0]p z.polar                               #=> [1.0, 1.5707963267948966]p z = Vector.polar(-2, Math::PI/4)      #=> Vector[-1.4142135623730951, -1.414213562373095]p z.polar                               #=> [2.0, -2.356194490192345]class Vector(:args) {     has Number x    has Number y     method init {        if ([:x, :y] ~~ args) {            x = args{:x}            y = args{:y}        }        elsif ([:length, :angle] ~~ args) {            x = args{:length}*args{:angle}.cos            y = args{:length}*args{:angle}.sin        }        elsif ([:from, :to] ~~ args) {            x = args{:to}[0]-args{:from}[0]            y = args{:to}[1]-args{:from}[1]        }        else {            die strv        }    }     method length { hypot(x, y) }    method angle  { atan2(y, x) }     method +(Vector v) { Vector(x => x + v.x,  y => y + v.y) }    method -(Vector v) { Vector(x => x - v.x,  y => y - v.y) }    method *(Number n) { Vector(x => x * n,    y => y * n)   }    method /(Number n) { Vector(x => x / n,    y => y / n)   }     method neg  { self * -1 }    method to_s { strv }} var u = Vector(x => 3, y => 4)var v = Vector(from => [1, 0], to => [2, 3])var w = Vector(length => 1, angle => 45.deg2rad) say u    #: vec[3, 4]say v    #: vec[1, 3]say w    #: vec[0.70710678118654752440084436210485, 0.70710678118654752440084436210485] say u.length                             #: 5say u.angle.rad2deg                      #: 53.13010235415597870314438744090659 say u+v                                  #: vec[4, 7]say u-v                                  #: vec[2, 1]say -u                                   #: vec[-3, -4]say u*10                                 #: vec[30, 40]say u/2                                  #: vec[1.5, 2]"
"require 'matrix' class Vector  def scalar_triple_product(b, c)    self.inner_product(b.cross_product c)  end   def vector_triple_product(b, c)    self.cross_product(b.cross_product c)  endend a = Vector[3, 4, 5]b = Vector[4, 3, 5]c = Vector[-5, -12, -13] puts strvputs strvputs strvputs strvclass Vector(x, y, z) {    method ∙(vec) {        [self{:x,:y,:z}] »*« [vec{:x,:y,:z}] «+»;    }     method ⨉(vec) {        Vector(self.y*vec.z - self.z*vec.y,               self.z*vec.x - self.x*vec.z,               self.x*vec.y - self.y*vec.x);    }     method to_s {        strv;    }} var a = Vector(3, 4, 5);var b = Vector(4, 3, 5);var c = Vector(-5, -12, -13); say strv;say strv;say strv;say strv;say strv;"
$a_global_var = 5class Demo  @@a_class_var = 6  A_CONSTANT = 8  def initialize    @an_instance_var = 7  end  def incr(a_local_var)    @an_instance_var += a_local_var  endend
"[0x200000, 0x1fffff].each do |i|  
  ber = [i].pack(strv)  hex = ber.unpack(strv).collect {|c| strv % c}.join(strv)  printf ""%s => %s"", i, hex   
  j = ber.unpack(strv).first  i == j or fail strvend"
 require 'objspace' p ObjectSpace.memsize_of(strv*23)    #=> 0p ObjectSpace.memsize_of(strv*24)    #=> 25p ObjectSpace.memsize_of(strv*1000) #=> 1001 
"def print_all(*things)  puts thingsendprint_all(4, 3, 5, 6, 4, 3)print_all(4, 3, 5)print_all(strv, strv, strv, strv)args = [strv, strv, strv, strv]print_all(*args)func print_all(*things) {    things.each { |x| say x };}print_all(4, 3, 5, 6, 4, 3);print_all(4, 3, 5);print_all(strv, strv, strv, strv);var args = [strv, strv, strv, strv];print_all(args...);"
"def vdc(n, base=2)  str = n.to_s(base).reverse  str.to_i(base).quo(base ** str.length)end (2..5).each do |base|  puts strv + Array.new(10){|i| vdc(i,base)}.join(strv)endfunc vdc(value, base=2) {    while (value[-1] > 0) {        value.append(value[-1] / base -> int);    }    var (x, sum) = (1, 0);    value.each { |i|        sum += ((i % base) / (x *= base));    }    return sum;} 2.to(5).each { |base|    var seq = (10.range.map {|i| vdc([i], base) });    ""base %d: %s"".printf(base, seq.map{|n| strv % n}.join(', '));}"
"def factor_pairs n  first = n / (10 ** (n.to_s.size / 2) - 1)  (first .. n ** 0.5).map { |i| [i, n / i] if n % i == 0 }.compactend def vampire_factors n  return [] if n.to_s.size.odd?  half = n.to_s.size / 2  factor_pairs(n).select do |a, b|    a.to_s.size == half && b.to_s.size == half &&    [a, b].count {|x| x%10 == 0} != 2          &&    strv.chars.sort == n.to_s.chars.sort  endend i = vamps = 0until vamps == 25  vf = vampire_factors(i += 1)  unless vf.empty?    puts ""#{i}:#{vf}""    vamps += 1  endend [16758243290880, 24959017348650, 14593825548650].each do |n|  if (vf = vampire_factors n).empty?    puts strv  else    puts ""#{n}:#{vf}""  endend"
"load 'speechsynthesis.rb' if ARGV.length == 1  $text = strvelse  $text = ARGV[1..-1].join(strv)end$words = $text.split Shoes.app do  @idx = 0   stack do    @sentence = para(strong($words[0] + strv), $words[1..-1].map {|word| span(word + strv)})    button strv do      say_and_highlight    end  end   keypress do |key|    case key    when :control_q, ""11"" then exit    end  end   def say_and_highlight    speak $words[@idx]    @idx = (@idx + 1) % $words.length    @sentence.replace($words.each_with_index.map {|word, idx| idx == @idx ? strong(word + strv) : span(word + strv)})  endend"
"RE = /\A[A-Z]{2}[A-Z0-9]{9}[0-9]{1}\z/ def valid_isin?(str)  return false unless str =~ RE  luhn(str.chars.map{|c| c.to_i(36)}.join)end p %w(US0378331005US0373831005U50378331005US03378331005AU0000XVGZA3AU0000VXGZA3FR0000988040).map{|tc| valid_isin?(tc) }	  
"
"print strvs = getsprintf strvi = gets.to_i   
printf strvf = Float(gets) rescue nil   
puts strvputs strvputs strvvar s = read(String);var i = read(Number);    
var s = Sys.readln(strv);var i = Sys.readln(strv).to_i;"
require 'cgi'$SAFE = 4cgi = CGI::new(strv)eval(cgi[strv].to_s)
"require 'uri' test_cases = [  strv,  strv,  ""jdbc:mysql://test_user::3306/sakila?profileSQL=true"",  strv,  strv,  strv,  ""mailto:"",  strv,  strv,  strv,  strv,  ""ssh:"",  ""https://bob:/place"",  strv] class ; alias_method :domain, :host; end test_cases.each do |test_case|  puts test_case  uri = URI.parse(test_case)  %w[ scheme domain port path query fragment user password ].each do |attr|    puts strv if uri.send(attr)  endend"
"require 'cgi'puts CGI.escape(strv).gsub(strv, strv)
require 'uri'puts URI.encode_www_form_component(strv).gsub(strv, strv)
func urlencode(str) {    str.gsub!(%rstrv, {|a| strv % a.ord});    str.gsub!(' ', '+');    return str;} say urlencode('http://foo bar/');"
"require 'tk' def main  root = TkRoot.new  l1 = TkLabel.new(root, strv => strv)  e1 = TkEntry.new(root)  l2 = TkLabel.new(root, strv => strv)  e2 = TkEntry.new(root) do    validate strv    validatecommand lambda {e2.value.to_i == 75_000}    invalidcommand  lambda {focus_number_entry(e2)}  end  ok = TkButton.new(root) do    text strv    command lambda {validate_input(e1, e2)}  end  Tk.grid(l1, e1)  Tk.grid(l2, e2)  Tk.grid(strv,ok, strv => strv)    Tk.mainloopend def validate_input(text_entry, number_entry)  if number_entry.value.to_i != 75_000    focus_number_entry(number_entry)  else    puts %Q{You entered: strv and strv}    root.destroy  endend def focus_number_entry(widget)  widget \    .configure(strv => strv, strv => strv) \    .selection_range(0, strv) \    .focusend mainShoes.app do  string = ask('Enter a string:')  begin    number = ask('Enter the number 75000:')  end while number.to_i != 75000  para %Q{you entered the string strv and the number #{number}}endvar gtk2 = require('Gtk2') -> init; var gui = %s'Gtk2::Builder'.new;gui.add_from_string(DATA.slurp); func clicked_ok(*_) {    var entry = gui.get_object('entry1');    var text = entry.get_text;     var spinner = gui.get_object('spinbutton1');    var number = spinner.get_text;     say strv;    say strv;     number == 75000 ? gtk2.main_quit : warn strv;} func clicked_cancel(*_) {    gtk2.main_quit;} gui.get_object('button1').signal_connect('clicked', clicked_ok);gui.get_object('button2').signal_connect('clicked', clicked_cancel); gtk2.main; __DATA__<?xml version=strv encoding=strv?><interface>  <requires lib=strv version=strv/>  <!-- interface-naming-policy project-wide -->  <object class=strv id=strv>    <property name=strv>100000</property>    <property name=strv>75000</property>    <property name=strv>1</property>    <property name=strv>10</property>  </object>  <object class=strv id=strv>    <property name=strv>True</property>    <property name=strv>False</property>    <child>      <object class=strv id=strv>        <property name=strv>True</property>        <property name=strv>False</property>        <child>          <object class=strv id=strv>            <property name=strv>True</property>            <property name=strv>False</property>            <property name=strv translatable=strv>Please insert a string and a number:</property>          </object>          <packing>            <property name=strv>True</property>            <property name=strv>True</property>            <property name=strv>0</property>          </packing>        </child>        <child>          <object class=strv id=strv>            <property name=strv>True</property>            <property name=strv>False</property>            <child>              <object class=strv id=strv>                <property name=strv>True</property>                <property name=strv>False</property>                <property name=strv translatable=strv>string:</property>              </object>              <packing>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>55</property>                <property name=strv>0</property>              </packing>            </child>            <child>              <object class=strv id=strv>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>•</property>                <property name=strv>False</property>                <property name=strv>False</property>                <property name=strv>True</property>                <property name=strv>True</property>              </object>              <packing>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>1</property>              </packing>            </child>          </object>          <packing>            <property name=strv>True</property>            <property name=strv>True</property>            <property name=strv>1</property>          </packing>        </child>        <child>          <object class=strv id=strv>            <property name=strv>True</property>            <property name=strv>False</property>            <child>              <object class=strv id=strv>                <property name=strv>True</property>                <property name=strv>False</property>                <property name=strv translatable=strv>number:</property>              </object>              <packing>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>0</property>              </packing>            </child>            <child>              <object class=strv id=strv>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>•</property>                <property name=strv>False</property>                <property name=strv>False</property>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>adjustment1</property>                <property name=strv>True</property>              </object>              <packing>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>1</property>              </packing>            </child>          </object>          <packing>            <property name=strv>True</property>            <property name=strv>True</property>            <property name=strv>2</property>          </packing>        </child>        <child>          <object class=strv id=strv>            <property name=strv>True</property>            <property name=strv>False</property>            <property name=strv>spread</property>            <child>              <object class=strv id=strv>                <property name=strv>gtk-ok</property>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>True</property>              </object>              <packing>                <property name=strv>False</property>                <property name=strv>False</property>                <property name=strv>0</property>              </packing>            </child>            <child>              <object class=strv id=strv>                <property name=strv>gtk-cancel</property>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>True</property>                <property name=strv>True</property>              </object>              <packing>                <property name=strv>False</property>                <property name=strv>False</property>                <property name=strv>1</property>              </packing>            </child>          </object>          <packing>            <property name=strv>True</property>            <property name=strv>True</property>            <property name=strv>3</property>          </packing>        </child>      </object>    </child>  </object></interface>"
"require 'cgi'puts CGI.unescape(strv)
require 'uri'puts URI.decode_www_form_component(strv)
func urldecode(str) {    str.gsub!('+', ' ');    str.gsub!(/\%([A-Fa-f0-9]{2})/, {|a| 'C'.pack(a.hex)});    return str;} say urldecode('http%3A%2F%2Ffoo+bar%2F');  
"
 Dir.foreach(strv){|n| puts n} var content = [];Dir.cwd.open.each { |file|    file ~~ < . .. > && next;    content.append(file);} content.sort.each { |file|    say file;}'*'.glob.each { |file|    say file;}
"require 'stringio' class ConfigFile   
  def self.file(filename)    fh = File.open(filename)    obj = self.new(fh)    obj.filename = filename    fh.close    obj  end   
  def self.data(string)    fh = StringIO.new(string)    obj = self.new(fh)    fh.close    obj  end   def initialize(filehandle)    @lines = filehandle.readlines    @filename = nil    tidy_file  end  attr :filename   def save()    if @filename      File.open(@filename, strv) {|f| f.write(self)}    end  end   def tidy_file()    @lines.map! do |line|      
      line.lstrip!       if line.match(/^#/)        
        
        line      else        
        line.sub!(/^;+\s+/, strv)         if line.match(/^; \s*$/)           
          
          line = strv        else          
          line = line.rstrip + """"           
          
          if m = line.match(/^(; )?([[:upper:]]+)\s+(.*)/)            line = (m[1].nil? ? strv : m[1]) + format_line(m[2], m[3])          end        end         line      end    end  end   def format_line(option, value)    ""%s%s"" % [option.upcase.strip, value.nil? ? strv : strv + value.to_s.strip]  end   
  def find_option(option)    @lines.find_index {|line| line.match(/^#{option.upcase.strip}\b/)}  end   
  def enable_option(option)    if idx = find_option(strv + option)      @lines[idx][/^; /] = strv    end  end   
  def disable_option(option)    if idx = find_option(option)      @lines[idx][/^/] = strv    end  end   
  
  def set_value(option, value)    if idx = find_option(option)      @lines[idx] = format_line(option, value)    else      @lines << format_line(option, value)     end  end   def to_s    @lines.join('')  endend  config = ConfigFile.data(DATA.read)config.disable_option('needspeeling')config.enable_option('seedsremoved')config.set_value('numberofbananas', 1024)config.set_value('numberofstrawberries', 62000)puts config  __END__
#

 


 


 
FAVOURITEFRUIT 		banana 
  NEEDSPEELING 
;;; SEEDSREMOVED;;;  
NUMBEROFBANANAS 48"
"Δ = 1Δ += 1puts Δ  
var Δ = 1;Δ += 1;say Δ;"
"str = strvstr.include?(strv) 
def Σ(array)  array.inject(:+)end puts Σ([4,5,6]) #=>15  p bad = ""¿como0301 esta0301s?"" 
p bad.unicode_normalized?          
p bad.unicode_normalize!           
p bad.unicode_normalized?          
 
 class 国際( なまえ, Straße ) {     
    method 言え {        say strv;    }}  
 var 民族 = [              国際( strv, strv ),              国際( strv, strv ),              国際( strv, strv ),            ]; 民族.each { |garçon|    garçon.言え;}"
"
puts strv unless defined? var 
var = strv 

puts strv unless defined? var 
 

puts strvvar x;      
x == nil   && say strv;defined(x) || say strv; 
x = 42; defined(x) && say strv; 
x = nil; defined(x) || say strv;"
"def rand_n(bias)  rand(bias) == 0 ? 1 : 0end def unbiased(bias)  a, b = rand_n(bias), rand_n(bias) until a != b #loop until a and b are 0,1 or 1,0  aend runs = 1_000_000keys = %i(bias biased unbiased) #use [:bias,:biased,:unbiased] in Ruby < 2.0puts keys.join("""") (3..6).each do |bias|  counter = Hash.new(0) 
  runs.times do    counter[:biased] += 1 if rand_n(bias) == 1 #the first time, counter has no key for :biased, so it will respond 0    counter[:unbiased] += 1 if unbiased(bias) == 1  end  counter[:bias] = bias  puts counter.values_at(*keys).join("""")endfunc randN (n) {    n.rand / (n-1) -> int} func unbiased(n) {    var n1 = nil    do { n1 = randN(n) } while (n1 == randN(n))    return n1} var iterations = 1000 for n in (3..6) {    var raw = []    var fixed = []    iterations.times {          raw[    randN(n) ] := 0 ++        fixed[ unbiased(n) ] := 0 ++    }    printf(""N=%d   randN: %s, %4.1f%%   unbiased: %s, %4.1f%%"",        n, [raw, fixed].map {|a| (a.dump, a[1] * 100 / iterations) }...)}"
"class Turing    class Tape        def initialize(symbols, blank, starting_tape)            @symbols = symbols            @blank = blank            @tape = starting_tape            @index = 0        end        def read            retval = @tape[@index]            unless retval                retval = @tape[@index] = @blank            end            raise strv unless @tape.member?(retval)            return retval        end        def write(symbol)            @tape[@index] = symbol        end        def right            @index += 1        end        def left            if @index == 0              @tape.unshift @blank            else              @index -= 1            end        end        def stay            
        end        def get_tape            return @tape        end    end     def initialize(symbols, blank,                   initial_state, halt_states, running_states,                   rules, starting_tape = [])        @tape = Tape.new(symbols, blank, starting_tape)        @initial_state = initial_state        @halt_states = halt_states        @running_states = running_states        @rules = rules        @halted = false    end    def run        raise strv if @halted        state = @initial_state        while (true)            break if @halt_states.member? state            raise strv unless @running_states.member? state            symbol = @tape.read            outsym, action, state = @rules[state][symbol]            @tape.write outsym            @tape.send action        end        @halted = true        return @tape.get_tape    endendincrementer_rules = {    :q0 => { 1  => [1, :right, :q0],             :b => [1, :stay,  :qf]}}t = Turing.new([:b, 1],           
               :b,                
               :q0,               
               [:qf],             
               [:q0],             
               incrementer_rules, 
               [1, 1, 1])         
print t.run, """"busy_beaver_rules = {    :a => { 0 => [1, :right, :b],            1 => [1, :left,  :c]},    :b => { 0 => [1, :left,  :a],            1 => [1, :right, :b]},    :c => { 0 => [1, :left,  :b],            1 => [1, :stay,  :halt]}}t = Turing.new([0, 1],            
               0,                 
               :a,                
               [:halt],           
               [:a, :b, :c],      
               busy_beaver_rules, 
               [])                
print t.run, """"func run_utm(state=strv, blank=strv, rules=[], tape=[blank], halt=strv, pos=0) {     if (pos < 0) {        pos += tape.len;    }     if (pos !~ tape.range) {        die strv;    }     loop {        print ""#{state}"";        tape.range.each { |i|            var v = tape[i];            print (i == pos ? strv : strv);        };        print """";         if (state == halt) {            break;        }         rules.each { |rule|            var (s0, v0, v1, dir, s1) = rule...;            if ((s0 != state) || (tape[pos] != v0)) {                next;            }             tape[pos] = v1;             given(dir) {                when ('left') {                     if (pos == 0) { tape.unshift(blank) }                     else          { --pos };                }                when ('right') {                    if (++pos >= tape.len) {                        tape.append(blank)                    }                }            }             state = s1;            goto :NEXT;        }         die 'No matching rules';        @:NEXT;    }} print ""incr machine"";run_utm(    halt:  'qf',    state: 'q0',    tape:  %w(1 1 1),    blank: 'B',    rules: [        %w(q0 1 1 right q0),        %w(q0 B 1 stay  qf),    ]); say ""busy beaver"";run_utm(    halt:  'halt',    state: 'a',    blank: '0',    rules: [        %w(a 0 1 right b),        %w(a 1 1 left  c),        %w(b 0 1 left  a),        %w(b 1 1 right b),        %w(c 0 1 left  b),        %w(c 1 1 stay  halt),    ]); say ""sorting test"";run_utm(    halt:  'STOP',    state: 'A',    blank: '0',    tape:  %w(2 2 2 1 2 2 1 2 1 2 1 2 1 2),    rules: [        %w(A 1 1 right A),        %w(A 2 3 right B),        %w(A 0 0 left  E),        %w(B 1 1 right B),        %w(B 2 2 right B),        %w(B 0 0 left  C),        %w(C 1 2 left  D),        %w(C 2 2 left  C),        %w(C 3 2 left  E),        %w(D 1 1 left  D),        %w(D 2 2 left  D),        %w(D 3 1 right A),        %w(E 1 1 left  E),        %w(E 0 0 right STOP),    ]);"
"def two_sum(numbers, sum)  numbers.each_with_index do |x,i|    if j = numbers.index(sum - x) then return [i,j] end  end  []end numbers = [0, 2, 11, 19, 90]p two_sum(numbers, 21)p two_sum(numbers, 25)def two_sum(numbers, sum)  numbers.each_with_index do |x,i|    key = sum - x    if j = numbers.bsearch_index{|y| key<=>y}      return [i,j]    end  end  []endfunc two_sum(numbers, sum) {    var (i, j) = (0, numbers.end)    while (i < j) {        given (sum <=> numbers[i]+numbers[j]) {            when (-1) { --j }            when (+1) { ++i }            default { return [i, j] }        }    }    return []} say two_sum([0, 2, 11, 19, 90], 21)say two_sum([0, 2, 11, 19, 90], 25)"
"require 'prime' def cell(n, x, y, start=1)  y, x = y - n/2, x - (n - 1)/2  l = 2 * [x.abs, y.abs].max  d = y >= x ? l*3 + x + y : l - x - y  (l - 1)**2 + d + start - 1end def show_spiral(n, symbol=nil, start=1)  puts ""N : #{n}""  format = strv  n.times do |y|    n.times do |x|      i = cell(n,x,y,start)      if symbol        print i.prime? ? symbol[0] : symbol[1]      else        print format % (i.prime? ? i : '')      end    end    puts  endend show_spiral(9)show_spiral(25)show_spiral(25, strv)require 'prime' def spiral_generator(x=0, y=0)  Enumerator.new do |yielder|    yielder << [x, y]                           
    dx, dy = 0, 1                               
    yielder << [x+=dx, y+=dy]                   
    0.step do |i|      2.times do        i.times{ yielder << [x+=dx, y+=dy] }    
        dx, dy = -dy, dx                        
        yielder << [x+=dx, y+=dy]      end    end  endend def ulam_spiral(n, start=1)  h = Hash.new(0)  position = spiral_generator  (start ... start+n*n).each do |i|    pos = position.next    h[pos] = 1  if i.prime?  end   chr = [[' ', '▄'], ['▀', '█']]  (xmin, xmax), (ymin, ymax) = h.keys.transpose.map(&:minmax)  (xmin..xmax).step(2).each do |x|    puts (ymin..ymax).map{|y| chr[h[[x,y]]][h[[x+1,y]]]}.join  endend [11, 122].each do |n|  puts ""N : #{n}""  ulam_spiral(n)endrequire('Imager'); var (n=512, start=1, file='ulam.png') = ARGV»to_i»()...; func cell(n, x, y, start) {    y -= (n   >> 1);    x -= (n-1 >> 1);    var l = 2*(x.abs > y.abs ? x.abs : y.abs);    var d = (y > x  ? (l*3 + x + y) : (l - x - y));    (l-1)**2 + d + start - 1;} var black = %s'Imager::Color'.new('#000000');var white = %s'Imager::Color'.new('#FFFFFF'); var img = %s'Imager'.new(xsize => n, ysize => n, channels => 1);img.box(filled => 1, color => white); for y in ^n {    for x in ^n {        var v = cell(n, x, y, start);        v.is_prime &&            img.setpixel(x => x, y => y, color => black);    }} img.write(file => file);"
"constraints = [  ->(st) { st.size == 12 },   ->(st) { st.last(6).count(true) == 3 },  ->(st) { st.each_slice(2).map(&:last).count(true) == 2 },  ->(st) { st[4] ? (st[5] & st[6]) : true },  ->(st) { st[1..3].none? },  ->(st) { st.each_slice(2).map(&:first).count(true) == 4 },  ->(st) { st[1] ^ st[2] },  ->(st) { st[6] ? (st[4] & st[5]) : true  },   ->(st) { st.first(6).count(true) == 3 },  ->(st) { st[10] & st[11] },  ->(st) { st[6..8].one? },  ->(st) { st[0,11].count(true) == 4 },] Result = Struct.new(:truths, :consistency) results = [true, false].repeated_permutation(12).map do |truths|  Result.new(truths, constraints.zip(truths).map {|cn,truth| cn[truths] == truth })end puts strv,   results.find {|r| r.consistency.all? }.truths.to_s puts ""near misses: ""near_misses = results.select {|r| r.consistency.count(false) == 1 }near_misses.each do |r|  puts strv, r.truths.to_send"
"loop do  print ""input a boolean expression (e.g. 'a & b'): ""  expr = gets.strip.downcase   break if expr.empty?   vars = expr.scan(/\p{Alpha}+/)  if vars.empty?    puts strv    next  end   vars.each {|v| print ""#{v}""}  puts strv   prefix = []  suffix = []  vars.each do |v|    prefix << strv    suffix << strv  end   body = vars.inject(strv) {|str, v| str + ""#{v}.to_s + '' + ""}   body += 'strv + eval(expr).to_s'   eval (prefix + [body] + suffix).join("""")endloop {  var expr = Sys.readln(""Boolean expression (e.g. 'a & b'): "").strip.lc  break if expr.is_empty;   var vars = expr.scan(/[[:alpha:]]+/)  if (vars.is_empty) {    say strv    next  }   var prefix = [];  var suffix = [];   vars.each { |v|    print ""#{v}""    prefix << strv    suffix << strv  }  say strv   var body = (strv + vars.map{|v| v+"",'',"" }.join + strv)  eval(prefix + [body] + suffix -> join(""""))}"
"
File.open(strv, strv) do |f|  f.truncate(1234)  f << strv 
end  
 
File.truncate(strv, 567)func truncate(filename, len) {    var file = File(filename);    len > file.size ->        && die strv;    file.truncate(len);} 
truncate(strv, 1234);"
"def left_truncatable?(n)  truncatable?(n) {|i| i.to_s[1..-1].to_i}end  def right_truncatable?(n)  truncatable?(n) {|i| i/10}end def truncatable?(n, &trunc_func)  return false if n.to_s.include? strv  loop do    n = trunc_func.call(n)    return true if n.zero?    return false unless Prime.prime?(n)  endend require 'prime'primes = Prime.each(1_000_000).to_a.reverse p primes.detect {|p| left_truncatable? p}p primes.detect {|p| right_truncatable? p}func t_prime(n, left=true) {    var p = %w(2 3 5 7);    var f = (        left ? { '1'..'9' ~X+ p }             : { p ~X+ '1'..'9' }    )    n.times {        p = f().grep{ .to_i.is_prime }    }    p.map{.to_i}.max} say t_prime(5, left: true)say t_prime(5, left: false)"
"def f(x) x.abs ** 0.5 + 5 * x ** 3 end puts strvnums = 11.times.map{ gets.to_f } nums.reverse_each do |n|  print strv  res = f(n)  puts res > 400 ? strv : resendvar nums; do {    nums = Sys.readln(strv).nums} while(nums.len != 11) nums.reverse.each { |n|    var r = (n.abs.sqrt + (5 * n**3));    say ""#{n}#{ r > 400 ? 'Urk!' : r }"";}"
"radians = Math::PI / 4degrees = 45.0 def deg2rad(d)  d * Math::PI / 180end def rad2deg(r)  r * 180 / Math::PIend #sineputs strv#cosineputs strv#tangentputs strv#arcsinearcsin = Math.asin(Math.sin(radians))puts strv#arccosinearccos = Math.acos(Math.cos(radians))puts strv#arctangentarctan = Math.atan(Math.tan(radians))puts strvrequire 'bigdecimal'       
require 'bigdecimal/math'  
 include BigMath  
 
def tan(x, prec)  sin(x, prec) / cos(x, prec)end 
def asin(y, prec)  
  return -PI / 2 if y == -1  return PI / 2 if y == 1   
  atan(y / sqrt(1 - y * y, prec), prec)end 
def acos(x, prec)  
  return PI / 2 if x == 0   
  a = atan(sqrt(1 - x * x, prec) / x, prec)  if a < 0    a + PI(prec)  else    a  endend  prec = 52pi = PI(prec)degrees = pi / 180  
 b1 = BigDecimal.new strvb2 = BigDecimal.new strvb3 = BigDecimal.new strv f = proc { |big| big.round(50).to_s('F') }print(strv,      ""  sin(-pi / 6) = "", f[ sin(-pi / 6, prec) ],      ""  cos(3 * pi / 4) = "", f[ cos(3 * pi / 4, prec) ],      ""  tan(pi / 3) = "", f[ tan(pi / 3, prec) ],      ""  asin(-1 / 2) = "", f[ asin(-b1 / 2, prec) ],      ""  acos(-sqrt(2) / 2) = "", f[ acos(-sqrt(b2, prec) / 2, prec) ],      ""  atan(sqrt(3)) = "", f[ atan(sqrt(b3, prec), prec) ],      """")print(strv,      ""  sin(-30) = "", f[ sin(-30 * degrees, prec) ],      ""  cos(135) = "", f[ cos(135 * degrees, prec) ],      ""  tan(60) = "", f[ tan(60 * degrees, prec) ],      ""  asin(-1 / 2) = "",      f[ asin(-b1 / 2, prec) / degrees ],      ""  acos(-sqrt(2) / 2) = "",      f[ acos(-sqrt(b2, prec) / 2, prec) / degrees ],      ""  atan(sqrt(3)) = "",      f[ atan(sqrt(b3, prec), prec) / degrees ],      """")var angle_deg = 45;var angle_rad = Num.pi/4; for arr in [    [sin(angle_rad), sin(deg2rad(angle_deg))],    [cos(angle_rad), cos(deg2rad(angle_deg))],    [tan(angle_rad), tan(deg2rad(angle_deg))],    [cot(angle_rad), cot(deg2rad(angle_deg))],] {    say arr.join(strv);} for n in [    asin(sin(angle_rad)),    acos(cos(angle_rad)),    atan(tan(angle_rad)),    acot(cot(angle_rad)),] {    say [n, rad2deg(n)].join(' ');}"
"def move(num_disks, start=0, target=1, using=2)  if num_disks == 1   @towers[target] << @towers[start].pop    puts ""Move disk from #{start} to #{target} : }""  else    move(num_disks-1, start, using, target)    move(1,           start, target, using)    move(num_disks-1, using, target, start)  end end n = 5@towers = [[*1..n].reverse, [], []]move(n)




def solve(*towers)  
  disks = towers.inject(0){|sum, tower| sum+tower.length}  x=0 
  p towers 
  
  while towers.last.length < disks do    x+=1 
    from = (x&x-1)%3    to = ((x|(x-1))+1)%3    
    if top = towers[from].last      bottom = towers[to].last      
      if !bottom || bottom > top        
        towers[to].push(towers[from].pop)        p towers 
      end    end  endend solve([5, 4, 3, 2, 1], [], [])func hanoi(n, from=1, to=2, via=3) {    if (n == 1) {        say strv;    } else {        hanoi(n-1, from, via,   to);        hanoi(  1, from,  to,  via);        hanoi(n-1,  via,  to, from);    }} hanoi(4);"
"BinaryTreeNode = Struct.new(:value, :left, :right) do  def self.from_array(nested_list)    value, left, right = nested_list    if value       self.new(value, self.from_array(left), self.from_array(right))    end  end   def walk_nodes(order, &block)    order.each do |node|      case node      when :left  then left && left.walk_nodes(order, &block)      when :self  then yield self      when :right then right && right.walk_nodes(order, &block)      end    end  end   def each_preorder(&b)  walk_nodes([:self, :left, :right], &b) end  def each_inorder(&b)   walk_nodes([:left, :self, :right], &b) end  def each_postorder(&b) walk_nodes([:left, :right, :self], &b) end   def each_levelorder    queue = [self]    until queue.empty?      node = queue.shift      yield node      queue << node.left if node.left      queue << node.right if node.right    end  endend root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]  BinaryTreeNode.instance_methods.select{|m| m=~/.+order/}.each do |mthd|  printf strv, mthd[5..-1] + ':'  root.send(mthd) {|node| print strv}  putsendfunc preorder(t) {    t ? [t[0], __FUNC__(t[1])..., __FUNC__(t[2])...] : [];} func inorder(t) {    t ? [__FUNC__(t[1])..., t[0], __FUNC__(t[2])...] : [];} func postorder(t) {    t ? [__FUNC__(t[1])..., __FUNC__(t[2])..., t[0]] : [];} func depth(t) {    var a = [t];    var ret = [];    while (a.len > 0) {        var v = (a.shift \\ next);        ret « v[0];        a += [v[1,2]];    };    return ret;} var x = [1,[2,[4,[7]],[5]],[3,[6,[8],[9]]]];say strv;say strv;say strv;say strv;"
"circles = [  [ 1.6417233788,  1.6121789534, 0.0848270516],  [-1.4944608174,  1.2077959613, 1.1039549836],  [ 0.6110294452, -0.6907087527, 0.9089162485],  [ 0.3844862411,  0.2923344616, 0.2375743054],  [-0.2495892950, -0.3832854473, 1.0845181219],  [ 1.7813504266,  1.6178237031, 0.8162655711],  [-0.1985249206, -0.8343333301, 0.0538864941],  [-1.7011985145, -0.1263820964, 0.4776976918],  [-0.4319462812,  1.4104420482, 0.7886291537],  [ 0.2178372997, -0.9499557344, 0.0357871187],  [-0.6294854565, -1.3078893852, 0.7653357688],  [ 1.7952608455,  0.6281269104, 0.2727652452],  [ 1.4168575317,  1.0683357171, 1.1016025378],  [ 1.4637371396,  0.9463877418, 1.1846214562],  [-0.5263668798,  1.7315156631, 1.4428514068],  [-1.2197352481,  0.9144146579, 1.0727263474],  [-0.1389358881,  0.1092805780, 0.7350208828],  [ 1.5293954595,  0.0030278255, 1.2472867347],  [-0.5258728625,  1.3782633069, 1.3495508831],  [-0.1403562064,  0.2437382535, 1.3804956588],  [ 0.8055826339, -0.0482092025, 0.3327165165],  [-0.6311979224,  0.7184578971, 0.2491045282],  [ 1.4685857879, -0.8347049536, 1.3670667538],  [-0.6855727502,  1.6465021616, 1.0593087096],  [ 0.0152957411,  0.0638919221, 0.9771215985],] def minmax_circle(circles)  xmin = circles.map {|xc, yc, radius| xc - radius}.min  xmax = circles.map {|xc, yc, radius| xc + radius}.max  ymin = circles.map {|xc, yc, radius| yc - radius}.min  ymax = circles.map {|xc, yc, radius| yc + radius}.max  [xmin, xmax, ymin, ymax]end 
def select_circle(circles)  circles = circles.sort_by{|cx,cy,r| -r}  size = circles.size  select = [*0...size]  for i in 0...size-1    xi,yi,ri = circles[i].to_a    for j in i+1...size      xj,yj,rj = circles[j].to_a      select -= [j]  if (xi-xj)**2 + (yi-yj)**2 <= (ri-rj)**2    end  end  circles.values_at(*select)endcircles = select_circle(circles)def grid_sample(circles, box_side=500)  
  xmin, xmax, ymin, ymax = minmax_circle(circles)   dx = (xmax - xmin) / box_side  dy = (ymax - ymin) / box_side   circle2 = circles.map{|cx,cy,r| [cx,cy,r*r]}  include = ->(x,y){circle2.any?{|cx, cy, r2| (x-cx)**2 + (y-cy)**2 < r2}}  count = 0   box_side.times do |r|    y = ymin + r * dy    box_side.times do |c|      x = xmin + c * dx      count += 1  if include[x,y]    end  end  #puts box_side => strv  count * dx * dyend puts strvn = 5002.times do  t0 = Time.now  puts strv  n *= 2  puts strvenddef area_scan(prec, circles)  sect = ->(y) do    circles.select{|cx,cy,r| (y - cy).abs < r}.map do |cx,cy,r|      dr = Math.sqrt(r ** 2 - (y - cy) ** 2)      [cx - dr, cx + dr]    end  end  xmin, xmax, ymin, ymax = minmax_circle(circles)  ymin = (ymin / prec).floor  ymax = (ymax / prec).ceil   total = 0  for y in ymin..ymax    y *= prec    right = xmin    for x0, x1 in sect[y].sort      next  if x1 <= right      total += x1 - [x0, right].max      right = x1    end  end  total * precend puts strvprec = 1e-23.times do  t0 = Time.now  puts strv % [prec, area_scan(prec, circles), Time.now-t0]  prec /= 10end"
"def f1(a)  i = 0  while (a0 = a[0]) > 1    a[0...a0] = a[0...a0].reverse    i += 1  end  iend def fannkuch(n)  [*1..n].permutation.map{|a| f1(a)}.maxend for n in 1..10  puts strv % [n, fannkuch(n)]enddef try_swaps(deck, f, d, n)  @best[n] = d  if d > @best[n]  (n-1).downto(0) do |i|    break  if deck[i] == -1 || deck[i] == i    return if d + @best[i] <= @best[n]  end  deck2 = deck.dup  for i in 1...n    k = 1 << i    if deck2[i] == -1      next  if f & k != 0    elsif deck2[i] != i      next    end    deck2[0] = i    deck2[1..i] = deck[0...i].reverse    try_swaps(deck2, f | k, d+1, n)  endend def topswops(n)  @best[n] = 0  deck0 = [-1] * (n + 1)  try_swaps(deck0, 1, 0, n)  @best[n]end @best = [0] * 16for i in 1..10  puts strv % [i, topswops(i)]end"
"while DATA.gets     
  print             
end__END__This is line oneThis is line twoThis is line threeDATA.getsp [$_.to_i ** 2, Math.sqrt($_.to_i)]        #=> [9, 1.7320508075688772]__END__3say [9,16,25].map {.sqrt};   
"
"puts strv.split(',').join('.')'Hello,How,Are,You,Today'.split(',').join('.').say;"
"require strv data = <<EOS
Employee Name,Employee ID,Salary,Department
Tyler Bennett,E10297,32000,D101
John Rappl,E21437,47000,D050
George Woltman,E00127,53500,D101
Adam Smith,E63535,18000,D202
Claire Buckman,E39876,27800,D202
David McClellan,E04242,41500,D101
Rich Holcomb,E01234,49500,D202
Nathan Adams,E41298,21900,D050
Richard Potter,E43128,15900,D101
David Motsinger,E27002,19250,D202
Tim Sampair,E03033,27000,D101
Kim Arlich,E10001,57000,D190
Timothy Grove,E16398,29900,D190
EOS def show_top_salaries_per_group(data, n)  table = CSV.parse(data, :headers=>true, :header_converters=>:symbol)  groups = table.group_by{|emp| emp[:department]}.sort  groups.each do |dept, emps|    puts dept    
    emps.max_by(n) {|emp| emp[:salary].to_i}.each do |e|      puts strv % [e[:employee_name], e[:employee_id], e[:salary]]    end    puts  endend show_top_salaries_per_group(data, 3)var data = <<'EOF'.lines.map{ (var h = Hash()){@|<name id salary dept>} = @|.split(','); h }Tyler Bennett,E10297,32000,D101John Rappl,E21437,47000,D050George Woltman,E00127,53500,D101Adam Smith,E63535,18000,D202Claire Buckman,E39876,27800,D202David McClellan,E04242,41500,D101Rich Holcomb,E01234,49500,D202Nathan Adams,E41298,21900,D050Richard Potter,E43128,15900,D101David Motsinger,E27002,19250,D202Tim Sampair,E03033,27000,D101Kim Arlich,E10001,57000,D190Timothy Grove,E16398,29900,D190EOF var n = (ARGV ? ARGV[0].to_i : ""usage: #{__MAIN__} [n]"".die) for d in (data.map {|h| h{:dept} }.uniq.sort) {    var es = data.grep { _{:dept} == d }.sort_by { -Num(_{:salary}) }    say d    n.times {        es || break        printf(""%-15s | %-6s | %5d"", es.shift(){@|<name id salary>})    }    print """"}"
" def tokenize(string, sep, esc)  sep = Regexp.escape(sep)  esc = Regexp.escape(esc)  string.scan(/\G (?:^ | #{sep}) (?: [^#{sep}#{esc}] | #{esc} .)*/x).collect do |m|    m.gsub(/#{esc}(.)/, '\1').gsub(/^#{sep}/, '')  endend p tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^')  func tokenize(string, sep, esc) {    var fields = string.split(        Regex(esc.escape + '.(*SKIP)(*FAIL)|' + sep.escape, 's'), -1    )    fields.map{.gsub(Regex(esc + '(.)'), {|s1| s1 }) }} tokenize(strv, '|', '^').each { |str|    say str.dump}"
"require 'benchmark' Benchmark.bm(8) do |x|  x.report(strv)  {  }  x.report(strv)  { (1..1_000_000).inject(4) {|sum, x| sum + x} }endBenchmark.measure { whatever }.totalvar benchmark = frequire('Benchmark') func fac_rec(n) {    n == 0 ? 1 : (n * __FUNC__(n - 1))} func fac_iter(n) {    var prod = 1    n.times { |i|        prod *= i    }    prod} var result = benchmark.timethese(-3, Hash(    'fac_rec'  => { fac_rec(20)  },    'fac_iter' => { fac_iter(20) },)) benchmark.cmpthese(result)"
"puts s = strv6.times{puts s << s.tr(strv,strv)}func recmap(repeat, seed, transform, callback) {    func (repeat, seed) {        callback(seed)        repeat > 0 && __FUNC__(repeat-1, transform(seed))    }(repeat, seed)} recmap(6, strv, {|s| s + s.tr('01', '10') }, { .say })"
" Textonyms = Hash.new {|n, g| n[g] = []}File.open(strv) do |file|  file.each_line {|line|    Textonyms[(n=line.chomp).gsub(/a|b|c|A|B|C/, '2').gsub(/d|e|f|D|E|F/, '3').gsub(/g|h|i|G|H|I/, '4').gsub(/p|q|r|s|P|Q|R|S/, '7')                     .gsub(/j|k|l|J|K|L/, '5').gsub(/m|n|o|M|N|O/, '6').gsub(/t|u|v|T|U|V/, '8').gsub(/w|x|y|z|W|X|Y|Z/, '9')] += [n]  }end var words = ARGF.grep(/^[[:alpha:]]+\z/); var dials = words.group_by {    .tr('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',        '2223334445556667777888999922233344455566677778889999');} var textonyms = dials.grep_v { .len > 1 }; say <<-END;    There are #{words.len} words which can be represented by the digit key mapping.    They require #{dials.len} digit combinations to represent them.    #{textonyms.len} digit combinations represent Textonyms.    END say strv;say textonyms.sort_by { |_,v| -v.len }.first(5).join(""""); say ""Top 5 in length:"";say textonyms.sort_by { |k,_| -k.len }.first(5).join("""");"
"require 'set' module TicTacToe  LINES = [[1,2,3],[4,5,6],[7,8,9],[1,4,7],[2,5,8],[3,6,9],[1,5,9],[3,5,7]]   class Game    def initialize(player_1_class, player_2_class)      @board = Array.new(10) 
       @current_player_id = 0      @players = [player_1_class.new(self, strv), player_2_class.new(self, strv)]      puts strv    end    attr_reader :board, :current_player_id     def play      loop do        place_player_marker(current_player)         if player_has_won?(current_player)          puts strv          print_board          return        elsif board_full?          puts strv          print_board          return        end         switch_players!      end    end     def free_positions      Set.new((1..9).select {|position| @board[position].nil?})    end     def place_player_marker(player)      position = player.select_position!      puts strv      @board[position] = player.marker    end     def player_has_won?(player)      LINES.any? do |line|        line.all? {|position| @board[position] == player.marker}      end    end     def board_full?      free_positions.empty?    end     def other_player_id      1 - @current_player_id    end     def switch_players!      @current_player_id = other_player_id    end     def current_player      @players[current_player_id]    end     def opponent      @players[other_player_id]    end     def turn_num      10 - free_positions.size    end     def print_board      col_separator, row_separator = strv, strv      label_for_position = lambda{|position| @board[position] ? @board[position] : position}       row_for_display = lambda{|row| row.map(&label_for_position).join(col_separator)}      row_positions = [[1,2,3], [4,5,6], [7,8,9]]      rows_for_display = row_positions.map(&row_for_display)      puts rows_for_display.join("""" + row_separator + """")    end  end   class Player    def initialize(game, marker)      @game = game      @marker = marker    end    attr_reader :marker  end   class HumanPlayer < Player    def select_position!      @game.print_board      loop do        print strv        selection = gets.to_i        return selection if @game.free_positions.include?(selection)        puts strv      end    end     def to_s      strv    end  end   class ComputerPlayer < Player    DEBUG = false 
     def group_positions_by_markers(line)      markers = line.group_by {|position| @game.board[position]}      markers.default = []      markers    end     def select_position!      opponent_marker = @game.opponent.marker       winning_or_blocking_position = look_for_winning_or_blocking_position(opponent_marker)      return winning_or_blocking_position if winning_or_blocking_position       if corner_trap_defense_needed?        return corner_trap_defense_position(opponent_marker)      end       
       return random_prioritized_position    end     def look_for_winning_or_blocking_position(opponent_marker)      for line in LINES        markers = group_positions_by_markers(line)        next if markers[nil].length != 1        if markers[self.marker].length == 2          log_debug strv          return markers[nil].first        elsif markers[opponent_marker].length == 2          log_debug strv          blocking_position = markers[nil].first        end      end      if blocking_position        log_debug strv        return blocking_position      end    end     def corner_trap_defense_needed?      corner_positions = [1, 3, 7, 9]      opponent_chose_a_corner = corner_positions.any?{|pos| @game.board[pos] != nil}      return @game.turn_num == 2 && opponent_chose_a_corner    end     def corner_trap_defense_position(opponent_marker)      
      log_debug strv      
      opponent_position = @game.board.find_index {|marker| marker == opponent_marker}      safe_responses = {1=>[2,4], 3=>[2,6], 7=>[4,8], 9=>[6,8]}      return safe_responses[opponent_position].sample    end     def random_prioritized_position      log_debug strv      ([5] + [1,3,7,9].shuffle + [2,4,6,8].shuffle).find do |pos|        @game.free_positions.include?(pos)      end    end     def log_debug(message)      puts strv if DEBUG    end     def to_s      ""_player_id}""    end  endend include TicTacToe Game.new(ComputerPlayer, ComputerPlayer).playputsplayers_with_human = [HumanPlayer, ComputerPlayer].shuffleGame.new(*players_with_human).play"
"require 'tsort'class Hash  include TSort  alias tsort_each_node each_key  def tsort_each_child(node, &block)    fetch(node).each(&block)  endend depends = {}DATA.each do |line|  key, *libs = line.split  depends[key] = libs  libs.each {|lib| depends[lib] ||= []}end begin  p depends.tsort  depends[strv] << strv  p depends.tsortrescue TSort::Cyclic => e  puts ""cycle detected: #{e}""end __END__des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieeedw01             ieee dw01 dware gtechdw02             ieee dw02 dwaredw03             std synopsys dware dw03 dw02 dw01 ieee gtechdw04             dw04 ieee dw01 dware gtechdw05             dw05 ieee dwaredw06             dw06 ieee dwaredw07             ieee dwaredware            ieee dwaregtech            ieee gtechramlib           std ieeestd_cell_lib     ieee std_cell_libsynopsysfunc print_topo_sort (deps) {    var ba = Hash.new;    deps.each { |before, afters|        afters.each { |after|            if (before != after) {                ba{before}{after} = 1;            };            ba{after} \\= Hash.new;        }    };     loop {        var afters = ba.keys.grep {|k| ba{k}.values.len == 0 }.sort;        afters.len || break;        say afters.join(strv);        ba.delete(afters...);        ba.values.each { |v| v.delete(afters...) };    };     say (ba.len ? strv : strv);} var deps = Hash.new(    des_system_lib => < std synopsys std_cell_lib des_system_lib dw02                                                     dw01 ramlib ieee >,    dw01           => < ieee dw01 dware gtech                         >,    dw02           => < ieee dw02 dware                               >,    dw03           => < std synopsys dware dw03 dw02 dw01 ieee gtech  >,    dw04           => < dw04 ieee dw01 dware gtech                    >,    dw05           => < dw05 ieee dware                               >,    dw06           => < dw06 ieee dware                               >,    dw07           => < ieee dware                                    >,    dware          => < ieee dware                                    >,    gtech          => < ieee gtech                                    >,    ramlib         => < std ieee                                      >,    std_cell_lib   => < ieee std_cell_lib                             >,    synopsys       => <                                               >); print_topo_sort(deps);deps{:dw01}.append('dw04');     
print_topo_sort(deps);"
"gifts = ""A partridge in a pear tree
Two turtle doves and
Three french hens
Four calling birds
Five golden rings
Six geese a-laying
Seven swans a-swimming
Eight maids a-milking
Nine ladies dancing
Ten lords a-leaping
Eleven pipers piping
Twelve drummers drumming"".split("""") days = %w(first second third fourth fifth sixthseventh eighth ninth tenth eleventh twelfth) days.each_with_index do |day, i|   puts strv  puts strv  puts gifts[0, i+1].reverse  putsendvar days = <first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth>; var gifts = <<'EOT'.lines;  And a partridge in a pear tree.  Two turtle doves,  Three french hens,  Four calling birds,  Five golden rings,  Six geese a-laying,  Seven swans a-swimming,  Eight maids a-milking,  Nine ladies dancing,  Ten lords a-leaping,  Eleven pipers piping,  Twelve drummers drumming,EOT func nth(n) { say strv }; nth(0);say gifts[0].sub('And a', 'A'); range(1, 11).each { |d|    say '';    nth(d);    d.downto(0).each { |i|        say gifts[i];    }}"
out = 0max_out = -1max_times = [] File.foreach('mlijobs.txt') do |line|  out += line.include?(strv) ? 1 : -1  if out > max_out    max_out = out    max_times = []  end  max_times << line.split[3]  if out == max_outend puts strvmax_times.each {|time| puts strv}var out = 0;var max_out = -1;var max_times = []; ARGF.each { |line|    out += (line ~~ /OUT/ ? 1 : -1);    out > max_out && (        max_out = out;        max_times = [];    );    out == max_out && (        max_times << line.split(' ')[3];    );} say strv;max_times.each {|t| strv.say };
"def palindrome?(s)  s == s.reverseend require 'test/unit'class MyTests <   def test_palindrome_ok    assert(palindrome? strv)  end   def test_palindrome_nok    assert_equal(false, palindrome?(strv))  end   def test_object_without_reverse    assert_raise(NoMethodError) {palindrome? 42}  end   def test_wrong_number_args    assert_raise(ArgumentError) {palindrome? strv, strv}  end   def test_show_failing_test    assert(palindrome?(strv), strv)  endend
def palindrome?(s)  s == s.reverseend require 'minitest/spec'require 'minitest/autorun'describe strv do  it strv do    (palindrome? strv).must_equal true  end   it strv do    palindrome?(strv).must_equal false  end   it strv do    proc { palindrome? 42 }.must_raise NoMethodError  end   it strv do    proc { palindrome? strv, strv }.must_raise ArgumentError  end   it strv do    palindrome?(strv).must_equal true, strv  endend"
"filename = strvtotal = { strv => 0, strv => 0, strv => 0.0 }invalid_count = 0max_invalid_count = 0invalid_run_end = strv File.new(filename).each do |line|  num_readings = 0  num_good_readings = 0  sum_readings = 0.0   fields = line.split  fields[1..-1].each_slice(2) do |reading, flag|    num_readings += 1    if Integer(flag) > 0      num_good_readings += 1      sum_readings += Float(reading)      invalid_count = 0    else      invalid_count += 1      if invalid_count > max_invalid_count        max_invalid_count = invalid_count        invalid_run_end = fields[0]      end    end  end   printf ""Line: %11s  Reject: %2d  Accept: %2d  Line_tot: %10.3f  Line_avg: %10.3f"",    fields[0], num_readings - num_good_readings, num_good_readings, sum_readings,    num_good_readings > 0 ? sum_readings/num_good_readings : 0.0   total[strv] += num_readings  total[strv] += num_good_readings  total[strv] += sum_readingsend puts strvputs strvprintf ""Total    = %.3f"", total['sum_readings']puts strvprintf ""Average  = %.3f"", total['sum_readings']/total['num_good_readings']puts strvputs strvReading = Struct.new(:date, :value, :flag) DailyReading = Struct.new(:date, :readings) do  def good() readings.select(&:flag) end  def bad() readings.reject(&:flag) end  def sum() good.map(&:value).inject(0.0) {|sum, val| sum + val } end  def avg() good.size > 0 ? (sum / good.size) : 0 end  def print_status    puts strv % [date, good.count, bad.count, sum, avg]    self  endend daily_readings = IO.foreach(ARGV.first).map do |line|  (date, *parts) = line.chomp.split(/\s/)  readings = parts.each_slice(2).map {|pair| Reading.new(date, pair.first.to_f, pair.last.to_i > 0)}  DailyReading.new(date, readings).print_statusend all_readings = daily_readings.flat_map(&:readings)good_readings = all_readings.select(&:flag)all_streaks = all_readings.slice_when {|bef, aft| bef.flag != aft.flag }worst_streak = all_streaks.reject {|grp| grp.any?(&:flag)}.sort_by(&:size).last total = good_readings.map(&:value).reduce(:+)num_readings = good_readings.countputsputs strv % totalputs strvputs strv % total./(num_readings)putsputs strv var gaps = [];var previous = :valid; ARGF.each { |line|    var (date, *readings) = line.words...;    var valid = [];    var hour = 0;    readings.map{.to_n}.each_slice(2, { |slice|        var(reading, flag) = slice...;        if (flag > 0) {            valid << reading;            if (previous == :invalid) {                gaps[-1]{:end} = strv;                previous = :valid;            }        }        else {            if (previous == :valid) {                gaps << Hash(start => strv);            }            gaps[-1]{:count} := 0 ++;            previous = :invalid;        }        ++hour;    })    say (strv,         strv);} var longest = gaps.sort_by{|a| -a{:count} }.first; say (""Longest period of invalid readings was #{longest{:count}} hours,"",    strv);"
" class Numeric  def to_i?    self == self.to_i rescue false   endend 
ar = [25.000000, 24.999999, 25.000100, -2.1e120, -5e-2,  
      Float::NAN, Float::INFINITY,                       
      2r, 2.5r,                                          
      2+0i, 2+0.0i, 5-5i]                                
 ar.each{|num| puts strv } "
"#encoding: UTF-8       # superfluous in Ruby >1.9.3 if ENV.values_at(strv,strv,strv).compact.first.include?(strv)  puts strvelse  raise strvend if (/\bUTF-?8/i ~~ [ENV{strv,strv,strv}]) {    say strv} else {    die ""Terminal can't handle UTF-8."";}"
"

 require 'singleton' 

#




#


class MaybeClass  include Singleton   
  def to_s; strv; endend MAYBE = MaybeClass.instance class TrueClass  TritMagic = Object.new  class << TritMagic    def index; 0; end    def !; false; end    def & other; other; end    def | other; true; end    def ^ other; [false, MAYBE, true][other.trit.index]; end    def == other; other; end  end   
  
  
  
  
  
  def trit; TritMagic; endend class MaybeClass  TritMagic = Object.new  class << TritMagic    def index; 1; end    def !; MAYBE; end    def & other; [MAYBE, MAYBE, false][other.trit.index]; end    def | other; [true, MAYBE, MAYBE][other.trit.index]; end    def ^ other; MAYBE; end    def == other; MAYBE; end  end   
  
  
  
  
  
  def trit; TritMagic; endend class FalseClass  TritMagic = Object.new  class << TritMagic    def index; 2; end    def !; true; end    def & other; false; end    def | other; other; end    def ^ other; other; end    def == other; [false, MAYBE, true][other.trit.index]; end  end   
  
  
  
  
  
  def trit; TritMagic; endend$ irbirb(main):001:0> require './trit'=> trueirb(main):002:0> maybe = MAYBE=> maybeirb(main):003:0> !true.trit       => falseirb(main):004:0> !maybe.trit=> maybeirb(main):005:0> maybe.trit & false=> falseirb(main):006:0> maybe.trit | true=> trueirb(main):007:0> false.trit == true       => falseirb(main):008:0> false.trit == maybe=> mayberequire 'trit'maybe = MAYBE [true, maybe, false].each do |a|  [true, maybe, false].each do |b|    printf ""%5s ^ %5s => %5s"", a, b, a.trit ^ b  endend"
require strvinclude Curses init_screenbegin  curs_set(1) #visible cursor  sleep 3  curs_set(0) #invisible cursor  sleep 3  curs_set(1) #visible cursor  sleep 3ensure  close_screenend
"print """"print """";"
"require 'set' def munge2(readings, debug=false)   datePat = /^\d{4}-\d{2}-\d{2}/   valuPat = /^[-+]?\d+\.\d+/   statPat = /^-?\d+/   totalLines = 0   dupdate, badform, badlen, badreading = Set[], Set[], Set[], 0   datestamps = Set[[]]   for line in readings      totalLines += 1      fields = line.split(/\t/)      date = fields.shift      pairs = fields.enum_slice(2).to_a       lineFormatOk = date =~ datePat &&        pairs.all? { |x,y| x =~ valuPat && y =~ statPat }      if !lineFormatOk         puts 'Bad formatting ' + line if debug         badform << date      end       if pairs.length != 24 ||           pairs.any? { |x,y| y.to_i < 1 }         puts 'Missing values ' + line if debug      end      if pairs.length != 24         badlen << date      end      if pairs.any? { |x,y| y.to_i < 1 }         badreading += 1      end       if datestamps.include?(date)         puts 'Duplicate datestamp ' + line if debug         dupdate << date      end       datestamps << date   end    puts 'Duplicate dates:', dupdate.sort.map { |x| '  ' + x }   puts 'Bad format:', badform.sort.map { |x| '  ' + x }   puts 'Bad number of fields:', badlen.sort.map { |x| '  ' + x }   puts 'Records with good readings: %i = %5.2f%%' % [      totalLines-badreading, (totalLines-badreading)/totalLines.to_f*100 ]   puts   puts 'Total records:  %d' % totalLinesend open('readings.txt','r') do |readings|   munge2(readings)endvar good_records = 0;var dates = Hash(); ARGF.each { |line|    var m = /^(\d\d\d\d-\d\d-\d\d)((?:\h+\d+\.\d+\h+-?\d+){24})\s*$/.match(line);    m || (warn strv; next);    dates{m[0]} := 0 ++;    var i = 0;    m[1].words.all{|n| i++.is_even || (n.to_num >= 1) } && ++good_records;} say strv;say 'Repeated timestamps:';say dates.to_a.grep{ .value > 1 }.map { .key }.sort.join("""");"
"#encoding: UTF-8  #superfluous in Ruby > 1.9.3puts strvsay '￡';say ""{FFE1}"";say ""{FULLWIDTH POUND SIGN}"";say 0xffe1.chr;"
"def winsize  
  require 'io/console'  IO.console.winsizerescue LoadError  
  
  [Integer(`tput li`), Integer(`tput co`)]end rows, cols = winsizeprintf ""%d rows by %d columns"", rows, colsrequire 'curses' begin  Curses.init_screen   r, c = Curses.lines, Curses.cols   Curses.setpos r / 2, 0  Curses.addstr strv.center(c)  Curses.getchensure  Curses.close_screenendvar stty = `stty -a`;var lines = stty.match(/\brows\h+(\d+)/);var cols  = stty.match(/\bcolumns\h+(\d+)/);say strv;"
"require 'curses' Curses.init_screenbegin  Curses.setpos(6, 3)  
  Curses.addstr(strv)   Curses.getch  
ensure  Curses.close_screenend"
"system 'clear'puts ""[H[2J""func clear { print(static x = `clear`) };clear();Sys.run('clear');print ""[3J[H[2J"";"
"#!/usr/bin/ruby -wrequire 'rubygems'require 'colored' print 'Colors are'.boldprint ' black'.blackprint ' blue'.blueprint ' cyan'.cyanprint ' green'.greenprint ' magenta'.magentaprint ' red'.redprint ' white '.whiteprint 'and'.underline, ' yellow'.yellow, """"puts 'black on blue'.black_on_blueputs 'black on cyan'.black_on_cyanputs 'black on green'.black_on_greenputs 'black on magenta'.black_on_magentaputs 'black on red'.black_on_redputs 'white on black'.white_on_blackputs 'white on blue'.white_on_blueputs 'white on cyan'.white_on_cyanputs 'white on green'.white_on_greenputs 'white on magenta'.white_on_magentaputs 'white on red'.white_on_redvar a = frequire('Term::ANSIColor'); say a.colored('RED ON WHITE', 'bold red on_white');say a.colored('GREEN', 'bold green');say a.colored('BLUE ON YELLOW', 'bold blue on_yellow');say a.colored('MAGENTA', 'bold magenta');say a.colored('CYAN ON RED', 'bold cyan on_red');say a.colored('YELLOW', 'bold yellow');"
"notes = 'NOTES.TXT'if ARGV.empty?  File.copy_stream(notes, $stdout) rescue nilelse  File.open(notes, 'a') {|file| file.puts ""%s%s"" % [Time.now, ARGV.join(' ')]}endvar file = %f'notes.txt'; if (ARGV.len > 0) {    var fh = file.open_a;    fh.say(Time.local.ctime + """" + ARGV.join(strv));    fh.close;} else {    file.open_r.each { .print };}"
"require 'pstore'require 'set' Address = Struct.new :id, :street, :city, :state, :zip db = PStore.new(strv)db.transaction do  db[:next] ||= 0       
  db[:ids] ||= Set[]    
enddb.transaction do  id = (db[:next] += 1)  db[id] = Address.new(id,                       strv,                       strv, strv, 20500)  db[:ids].add idendrequire 'sqlite3' db = SQLite3::Database.new(':memory:')db.execute(""
    CREATE TABLE address (
        addrID     INTEGER PRIMARY KEY AUTOINCREMENT,
        addrStreet TEXT NOT NULL,
        addrCity   TEXT NOT NULL,
        addrState  TEXT NOT NULL,
        addrZIP    TEXT NOT NULL
    )
"")require('DBI'); var db = %s'DBI'.connect('DBI:mysql:database:server','login','password'); var statment = <<'EOF';CREATE TABLE `Address` (    `addrID`       int(11)     NOT NULL   auto_increment,    `addrStreet`   varchar(50) NOT NULL   default '',    `addrCity`     varchar(25) NOT NULL   default '',    `addrState`    char(2)     NOT NULL   default '',    `addrZIP`      char(10)    NOT NULL   default '',    PRIMARY KEY (`addrID`));EOF var exec = db.prepare(statment);exec.execute;"
require 'pstore'db = PStore.new strv
"module TempConvert   FROM_TEMP_SCALE_TO_K =   {'kelvin'     => lambda{|t| t},   'celsius'    => lambda{|t| t + 273.15},   'fahrenheit' => lambda{|t| (t + 459.67) * 5/9.0},   'rankine'    => lambda{|t| t * 5/9.0},   'delisle'    => lambda{|t| 373.15 - t * 2/3.0},   'newton'     => lambda{|t| t * 100/33.0 + 273.15},   'reaumur'    => lambda{|t| t * 5/4.0 + 273.15},   'roemer'     => lambda{|t| (t - 7.5) * 40/21.0 + 273.15}}   TO_TEMP_SCALE_FROM_K =   {'kelvin'     => lambda{|t| t},   'celsius'    => lambda{|t| t - 273.15},   'fahrenheit' => lambda{|t| t * 9/5.0 - 459.67},   'rankine'    => lambda{|t| t * 9/5.0},   'delisle'    => lambda{|t| (373.15 - t) * 3/2.0},   'newton'     => lambda{|t| (t - 273.15) * 33/100.0},   'reaumur'    => lambda{|t| (t - 273.15) * 4/5.0},   'roemer'     => lambda{|t| (t - 273.15) * 21/40.0 + 7.5}}   SUPPORTED_SCALES = FROM_TEMP_SCALE_TO_K.keys.join('|')   def self.method_missing(meth, *args, &block)    if valid_temperature_conversion?(meth) then      convert_temperature(meth, *args)    else      super    end  end   def self.respond_to_missing?(meth, include_private = false)    valid_temperature_conversion?(meth) || super  end   def self.valid_temperature_conversion?(meth)    !!(meth.to_s =~ /(#{SUPPORTED_SCALES})_to_(#{SUPPORTED_SCALES})/)   end   def self.convert_temperature(meth, temp)    from_scale, to_scale = meth.to_s.split(strv)    return temp.to_f if from_scale == to_scale 
    TO_TEMP_SCALE_FROM_K[to_scale].call(FROM_TEMP_SCALE_TO_K[from_scale].call(temp)).round(2)  end endTempConvert.kelvin_to_celsius 100 #=> -173.15TempConvert.kelvin_to_fahrenheit 100 #=> -279.67TempConvert.kelvin_to_rankine 100 #=> 180.0TempConvert.kelvin_to_delisle 100 #=> 409.73TempConvert.kelvin_to_newton 100 #=> -57.14TempConvert.kelvin_to_reaumur 100 #=> -138.52TempConvert.kelvin_to_roemer 100 #=> -83.4 TempConvert.newton_to_celsius 100 #=> 303.03TempConvert.newton_to_fahrenheit 100 #=> 577.45
var scale = Hash(    Celcius    => Hash.new(factor => 1  , offset => -273.15 ),    Rankine    => Hash.new(factor => 1.8, offset =>    0    ),    Fahrenheit => Hash.new(factor => 1.8, offset => -459.67 ),); var kelvin = Sys.readln(strv).to_n;kelvin >= 0 || die strv; scale.keys.sort.each { |key|    printf(""%12s:%8.2f"", key, kelvin*scale{key}{:factor} + scale{key}{:offset});}"
"t = Time.now 
puts t        
 
puts t.to_i   
 
puts t.to_f   
 
puts Time.now.to_r  
 
say Time.local.ctime;        
 
say Time.sec;                
 
say Time.micro_sec;          
"
"def taxicab_number(nmax=1200)  [*1..nmax].repeated_combination(2).group_by{|x,y| x**3 + y**3}.select{|k,v| v.size>1}.sortend t = [0] + taxicab_number [*1..25, *2000...2007].each do |i|  puts strv % [i, t[i][0]] + t[i][1].map{|a| strv % a}.joinendvar (start=1, end=25) = ARGV.map{.to_i}...; func display (h, start, end) {    var i = start    h.grep { |_,v| v.len > 1 }.keys.sort_by{.to_i}.ft(start-1, end-1).each {|n|        printf(""%4d %10d  =>%s"", i++, n,            h{n}.map{ strv % (.first, strv) }.join("",""))    }} var taxi = Hash()var taxis = 0var terminate = 0 Inf.times { |c1|    if (terminate>0 && terminate>c1) {        display(taxi, start, end)        break    }    var c = c1**3    c1.times { |c2|        var this = (c2**3 + c)        taxi{this} := [] << [c2, c1]        ++taxis if (taxi{this}.len == 2);        if (taxis == end && terminate.is_zero) {            terminate = taxi.grep{|_,v| v.len > 1 }.keys.map{.to_i}.max.root(3)        }    }}"
"count = 0IO.foreach(strv) { |line| print line; count += 1 }puts strvcount = 0reader = Fiber.new do  IO.foreach(strv) { |line| Fiber.yield line }  puts strv  nilend 
while line = reader.resume  print line  count += 1endrequire 'continuation' unless defined? Continuation count = 0reader = proc do |cont|  IO.foreach(strv) { |line| cont = callcc { |cc| cont[cc, line] }}  puts strv  cont[nil]end 
while array = callcc { |cc| reader[cc] }  reader, line = array  print line  count += 1endrequire 'thread' counts = Queue.newlines = Queue.newreader = Thread.new do  begin    File.foreach(strv) { |line| lines << line }    lines << :EOF    puts strv  ensure    lines << nil  endend 
count = 0while line = lines.pop  case line  when String    print line    count += 1  when :EOF    counts << count  endendreader.join"
"#A straight forward implementation of N. Johnston's algorithm. I prefer to look at this as 2n+1 where#the second n is first n reversed, and the 1 is always the second symbol. This algorithm will generate#just the left half of the result by setting l to [1,2] and looping from 3 to 6. For the purpose of#this task I am going to start from an empty array and generate the whole strings using just the #rules.##Nigel Galloway: December 16th., 2014#l = [](1..6).each{|e|  a, i = [], e-2  (0..l.length-e+1).each{|g|     if not (n = l[g..g+e-2]).uniq!       a.concat(n[(a[0]? i : 0)..-1]).push(e).concat(n)       i = e-2     else       i -= 1     end   }   a.each{|n| print n}; puts """"   l = a}def superperm(n)  return [1] if n==1  superperm(n-1).each_cons(n-1).with_object([]) do |sub, ary|    next if sub.uniq!    i = ary.empty? ? 0 : sub.index(ary.last)+1    ary.concat(sub[i..-1] + [n] + sub)  endend def to_16(a) a.map{|x| x.to_s(16)}.join end for n in 1..10  ary = superperm(n)  print strv % [n, ary.size]  puts n<5 ? ary.join : to_16(ary.first(20)) + strv + to_16(ary.last(20))end1..8 -> each { |len|    var (pre=strv, post=strv)    ^len -> to_a.permutations {|p|        var t = p.join        post.append!(t) if !post.contains(t)        pre.prepend!(t) if !pre.contains(t)    }    printf(""%2d: %8d %8d"", len, pre.len, post.len)}"
"def gen_expr  x = ['-', '']  y = ['+', '-', '']  x.product(y,y,y,y,y,y,y,y)   .map do |a,b,c,d,e,f,g,h,i|      strv    endend def sum_to(val)  gen_expr.map{|expr| [eval(expr), expr]}.select{|v,expr| v==val}.each{|x| p x}end def max_solve  n,size = gen_expr.group_by{|expr| eval(expr)}                   .select{|val,_| val>=0}                   .map{|val,exprs| [val, exprs.size]}                   .max_by{|_,size| size}  puts strvend def min_solve  solves = gen_expr.group_by{|expr| eval(expr)}  n = 0.step{|i| break i unless solves[i]}  puts strvend def highest_sums(n=10)  n = gen_expr.map{|expr| eval(expr)}.uniq.sort.reverse.take(n)  puts strvend sum_to(100)max_solvemin_solvehighest_sums"
"Point = Struct.new(:x,:y) do  def to_s; strv endend def sutherland_hodgman(subjectPolygon, clipPolygon)  
  
  cp1, cp2, s, e = nil  inside = proc do |p|    (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x)  end  intersection = proc do    dcx, dcy = cp1.x-cp2.x, cp1.y-cp2.y    dpx, dpy = s.x-e.x, s.y-e.y    n1 = cp1.x*cp2.y - cp1.y*cp2.x    n2 = s.x*e.y - s.y*e.x    n3 = 1.0 / (dcx*dpy - dcy*dpx)    Point[(n1*dpx - n2*dcx) * n3, (n1*dpy - n2*dcy) * n3]  end   outputList = subjectPolygon  cp1 = clipPolygon.last  for cp2 in clipPolygon    inputList = outputList    outputList = []    s = inputList.last    for e in inputList      if inside[e]        outputList << intersection[] unless inside[s]        outputList << e      elsif inside[s]        outputList << intersection[]      end      s = e    end    cp1 = cp2  end  outputListend subjectPolygon = [[50, 150], [200, 50], [350, 150], [350, 300],                  [250, 300], [200, 250], [150, 350], [100, 250],                  [100, 200]].collect{|pnt| Point[*pnt]} clipPolygon = [[100, 100], [300, 100], [300, 300], [100, 300]].collect{|pnt| Point[*pnt]} puts sutherland_hodgman(subjectPolygon, clipPolygon)class Point(x, y) {    method to_s {        strv    }} func sutherland_hodgman(subjectPolygon, clipPolygon) {  var inside = { |cp1, cp2, p|    ((cp2.x-cp1.x)*(p.y-cp1.y)) > ((cp2.y-cp1.y)*(p.x-cp1.x))  }   var intersection = { |cp1, cp2, s, e|    var (dcx, dcy) = (cp1.x-cp2.x, cp1.y-cp2.y)    var (dpx, dpy) = (s.x-e.x, s.y-e.y)    var n1 = (cp1.x*cp2.y - cp1.y*cp2.x)    var n2 = (s.x*e.y - s.y*e.x)    var n3 = (1 / (dcx*dpy - dcy*dpx))    Point((n1*dpx - n2*dcx) * n3, (n1*dpy - n2*dcy) * n3)  }   var outputList = subjectPolygon  var cp1 = clipPolygon.last  for cp2 in clipPolygon {    var inputList = outputList    outputList = []    var s = inputList.last    for e in inputList {      if (inside(cp1, cp2, e)) {        outputList << intersection(cp1, cp2, s, e) if !inside(cp1, cp2, s)        outputList << e      }      elsif(inside(cp1, cp2, s)) {        outputList << intersection(cp1, cp2, s, e)      }      s = e    }    cp1 = cp2  }  outputList} var subjectPolygon = [    [50,  150], [200,  50], [350, 150], [350, 300],    [250, 300], [200, 250], [150, 350], [100, 250],    [100, 200]].map{|pnt| Point(pnt...) } var clipPolygon = [    [100, 100], [300, 100],    [300, 300], [100, 300]].map{|pnt| Point(pnt...) } sutherland_hodgman(subjectPolygon, clipPolygon).each { .say }"
"a = [strv, strv, strv, strv, strv]b = [strv, strv, strv, strv, strv]
p sym_diff = (a | b)-(a & b)  
require 'set'a = Set[strv, strv, strv, strv, strv] #Set removes duplicatesb = Set[strv, strv, strv, strv, strv]p sym_diff = a ^ b 
var a = [strv, strv, strv, strv, strv];var b = [strv, strv, strv, strv, strv];a ^ b -> unique.dump.say;"
"[3,1,4,1,5,9].reduce(0){|sum,x| sum + x*x}[3,1,4,1,5,9].map{|x| x*x}.reduce :+func sum_of_squares(vector) {    var sum = 0;    vector.each { |n| sum += n**2 };    return sum;} say sum_of_squares([]);         
say sum_of_squares([1,2,3]);    
"
"def sum35(n)  (1...n).select{|i|i%3==0 or i%5==0}.inject(:+)endputs sum35(1000)      #=> 233168
#

def g(n1, n2, n3)   g1 = n1*n2   (1..g1).select{|x| x%n1==0 or x%n2==0}.collect{|x| g2=(n3-x)/g1; (x+g1*g2+x)*(g2+1)}.inject{|sum,x| sum+x}/2end puts g(3,5,999) 
puts g(3,5,100000000000000000000-1)def sumMul(n, f)  n1 = (n - 1) / f  f * n1 * (n1 + 1) / 2end def sum35(n)  sumMul(n, 3) + sumMul(n, 5) - sumMul(n, 15)end for i in 1..20  puts strv % [i, 10**i, sum35(10**i)]endfunc sumMul(n, f) {    var n1 = int((n - 1) / f);    f * n1 * (n1 + 1) / 2;} func sum35(n) {    sumMul(n, 3) + sumMul(n, 5) - sumMul(n, 15);} 20.times { |i|    printf(""%2s:%22s %s"", i, 10**i, sum35(10**i));};"
"puts (1..1000).inject{|sum, x| sum + 1.0 / x ** 2}#=> 1.64393456668156say sum(1..1000, {|n| 1 / n**2 })say (1..1000 -> reduce { |a,b| a + (1 / b**2) })"
">> def sumDigits(num, base = 10)>>     num.to_s(base).split(//).inject(0) {|z, x| z + x.to_i(base)}>> end=> nil>> sumDigits(1)=> 1>> sumDigits(12345)=> 15>> sumDigits(123045)=> 15>> sumDigits(0xfe, 16)=> 29>> sumDigits(0xf0e, 16)=> 29 func Σ(String str, base=36) {    str.chars.map{ Num(_, base) }.sum} <1 1234 1020304 fe f0e DEADBEEF>.each { |n|    say strv}"
"def add(x,y) x + y enddef mul(x,y) x * y end def sumEq(s,p) s.select{|q| add(*p) == add(*q)} enddef mulEq(s,p) s.select{|q| mul(*p) == mul(*q)} end s1 = (a = *2...100).product(a).select{|x,y| x<y && x+y<100}s2 = s1.select{|p| sumEq(s1,p).all?{|q| mulEq(s1,q).size != 1} }s3 = s2.select{|p| (mulEq(s1,p) & s2).size == 1}p    s3.select{|p| (sumEq(s1,p) & s3).size == 1}func grep_uniq(a, by) { a.group_by{ .(by) }.values.grep{.len == 1}.map{_[0]} }func sums     (n)     { 2 .. n//2 -> map {|i| [i, n-i] } } var pairs = (2..97 -> map {|i| ([i] ~X (i+1 .. 98))... }) var p_uniq = Hash()p_uniq{grep_uniq(pairs, :prod).map { .to_s }...} = () var s_pairs = pairs.grep {|p| sums(p.sum).all { !p_uniq.contains(.to_s) } }var p_pairs = grep_uniq(s_pairs, :prod)var f_pairs = grep_uniq(p_pairs, :sum) f_pairs.each { |p| printf(""X = %d, Y = %d"", p...) }"
"arr = [1,2,3,4,5]     
p sum = arr.inject(0) { |sum, item| sum + item }
p product = arr.inject(1) { |prod, element| prod * element }
arr = [1,2,3,4,5]p sum = arr.inject(0, :+)         #=> 15p product = arr.inject(1, :*)     #=> 120 

p sum = arr.inject(:+)            #=> 15p product = arr.inject(:*)        #=> 120arr = []p arr.inject(0, :+)               #=> 0p arr.inject(1, :*)               #=> 1p arr.inject(:+)                  #=> nilp arr.inject(:*)                  #=> nilarr = [1,2,3,4,5]p sum = arr.sum                   #=> 15p [].sum                          #=> 0var ary = [1, 2, 3, 4, 5];say ary.sum;                 
say ary.prod;                
var ary = [1, 2, 3, 4, 5];say ary«+»;                  
say ary«*»;                  
"
"

class SubRandom  
  attr_reader :seed   
  
  def initialize(seed = Kernel.rand(1_000_000_000))    (0..999_999_999).include? seed or      raise ArgumentError, strv     
    ary = [seed, 1]    53.times { ary << ary[-2] - ary[-1] }    @state = []    34.step(1870, 34) {|i| @state << ary[i % 55] }     220.times { rand }  
     @seed = seed        
  end   
  def initialize_copy(orig)    @state = @state.dup  end   
  def rand    @state << (@state[-55] - @state[-24]) % 1_000_000_000    @state.shift  endend rng = SubRandom.new(292929)p (1..3).map { rng.rand }class SubRandom(seed, state=[]) {     const mod = 1_000_000_000;     method init {        var s = [seed % mod, 1];        53.times {            s.append((s[-2] - s[-1]) % mod);        }        state = s.range.map {|i| s[(34 + 34*i) % 55] };        range(55, 219).each { self.subrand };    }     method subrand {        var x = ((state.shift - state[-24]) % mod);        state.append(x);        return x;    }} var r = SubRandom(292929);10.times { say r.subrand };"
"puts strv[1..-1]   
puts strv[0..-2]    
puts strv.chop      
puts strv[1..-2]   
puts strv[1..-2]    
say strv.substr(1);       
say strv.substr(0, -1);    
say strv.substr(1, -1);   
say strv.substr(1, -1);    
var gstr = ""J{332}o{332}s{332}e{301}{332}"";say gstr-/^\X/;                    
say gstr-/\X\z/;                   
say gstr.sub(/^\X/).sub(/\X\z/);   
"
"def read_matrix(data)  lines = data.lines  9.times.collect { |i| 9.times.collect { |j| lines[i][j].to_i } }end def permissible(matrix, i, j)  ok = [nil, *1..9]  check = ->(x,y) { ok[matrix[x][y]] = nil  if matrix[x][y].nonzero? }  
  9.times { |x| check[x, j] }  
  9.times { |y| check[i, y] }  
  xary = [ *(x = (i / 3) * 3) .. x + 2 ]        #=> [0,1,2], [3,4,5] or [6,7,8]  yary = [ *(y = (j / 3) * 3) .. y + 2 ]  xary.product(yary).each { |x, y| check[x, y] }  
  ok.compactend def deep_copy_sudoku(matrix)  matrix.collect { |row| row.dup }end def solve_sudoku(matrix)  loop do    options = []    9.times do |i|      9.times do |j|        next if matrix[i][j].nonzero?        p = permissible(matrix, i, j)        
        return if p.empty?              
        options << [i, j, p]      end    end    
    return matrix if options.empty?     i, j, permissible = options.min_by { |x| x.last.length }     
    if permissible.length == 1      matrix[i][j] = permissible[0]      next    end     
    permissible.each do |v|      mtmp = deep_copy_sudoku(matrix)      mtmp[i][j] = v      ret = solve_sudoku(mtmp)      return ret if ret    end     
    return  endend def print_matrix(matrix)  puts strv or return  unless matrix   border = strv  9.times do |i|    puts border if i%3 == 0    9.times do |j|      print j%3 == 0 ? strv : strv      print matrix[i][j] == 0 ? strv : matrix[i][j]    end    puts strv  end  puts borderend data = <<EOS
394__267_
___3__4__
5__69__2_
_45___9__
6_______7
__7___58_
_1__67__8
__9__8___
_264__735
EOS matrix = read_matrix(data)print_matrix(matrix)putsprint_matrix(solve_sudoku(matrix))func check(i, j) is cached {    var (id, im) = i.divmod(9)    var (jd, jm) = j.divmod(9)     jd == id && return true    jm == im && return true     (id//3 == jd//3) &&    (jm//3 == im//3)} func solve(grid) {    for i in ^grid {        grid[i] && next        var t = [grid[^grid->grep{|j| check(i, j) }]].freq         { |k|            t.has_key(k) && next            grid[i] = k            solve(grid)        } * 9         grid[i] = 0        return nil    }     for i in ^grid {        print strv        print strv  if (3  -> divides(i+1))        print """" if (9  -> divides(i+1))        print """" if (27 -> divides(i+1))    }} var grid = %i(    5 3 0  0 2 4  7 0 0    0 0 2  0 0 0  8 0 0    1 0 0  7 0 3  9 0 2     0 0 8  0 7 2  0 4 9    0 2 0  9 8 0  0 7 0    7 9 0  0 0 0  0 8 0     0 0 0  0 3 0  5 0 6    9 6 0  0 1 0  3 0 0    0 5 0  6 9 0  0 1 0) solve(grid)"
"class Computer  def initialize program    @memory = program.map{|instruction| instruction.to_i}    @instruction_pointer = 0  end   def step    return nil if @instruction_pointer < 0     a, b, c = @memory[@instruction_pointer .. @instruction_pointer + 2]    @instruction_pointer += 3     if a == -1      b = readchar    elsif b == -1      writechar @memory[a]    else      difference = @memory[b] - @memory[a]      @memory[b] = difference      @instruction_pointer = c if difference <= 0    end     @instruction_pointer  end   def run    current_pointer = @instruction_pointer    current_pointer = step while current_pointer >= 0  end   private   def readchar    gets[0].ord  end   def writechar code_point    print code_point.chr  endend subleq = Computer.new ARGV subleq.runvar memory = ARGV.map{.to_i};var ip = 0; while (ip.ge(0) && ip.lt(memory.len)) {    var (a, b, c) = memory[ip, ip+1, ip+2];    ip += 3;    if (a < 0) {        memory[b] = STDIN.getc.ord;    }    elsif (b < 0) {        print memory[a].chr;    }    elsif ((memory[b] -= memory[a]) <= 0) {        ip = c    }}"
"weights = {  'alliance'   =>-624, 'archbishop'=>-915, 'balm'       => 397, 'bonnet'   => 452,  'brute'      => 870, 'centipede' =>-658, 'cobol'      => 362, 'covariate'=> 590,  'departure'  => 952, 'deploy'    =>  44, 'diophantine'=> 645, 'efferent' =>  54,  'elysee'     =>-326, 'eradicate' => 376, 'escritoire' => 856, 'exorcism' =>-983,  'fiat'       => 170, 'filmy'     =>-874, 'flatworm'   => 503, 'gestapo'  => 915,  'infra'      =>-847, 'isis'      =>-982, 'lindholm'   => 999, 'markham'  => 475,  'mincemeat'  =>-880, 'moresby'   => 756, 'mycenae'    => 183, 'plugging' =>-266,  'smokescreen'=> 423, 'speakeasy' =>-745, 'vein'       => 813,} words = weights.keys1.upto(words.length) do |n|  zerosum = words.combination(n).find do |subset|    subset.reduce(0) {|sum, word| sum + weights[word]} == 0  end   if zerosum    puts strv  else    puts strv  endendvar pairs = Hash(    alliance    => -624, archbishop => -915,    brute       =>  870, centipede  => -658,    departure   =>  952, deploy     =>   44,    elysee      => -326, eradicate  =>  376,    fiat        =>  170, filmy      => -874,    infra       => -847, isis       => -982,    mincemeat   => -880, moresby    =>  756,    smokescreen =>  423, speakeasy  => -745,    balm        =>  397, bonnet     =>  452,    cobol       =>  362, covariate  =>  590,    diophantine =>  645, efferent   =>   54,    escritoire  =>  856, exorcism   => -983,    flatworm    =>  503, gestapo    =>  915,    lindholm    =>  999, markham    =>  475,    mycenae     =>  183, plugging   => -266,    vein        =>  813,) var weights = pairs.keys.sort.map{|k| pairs{k} }var inverse = pairs.flip for n in (1 .. weights.end) {    var found = false    weights.combinations(n, {|comb|        if (comb.sum == 0) {            say strv+strv.join(inverse{comb...})            found = true            break        }    })    found || say strv}"
"str = 'abcdefgh'n = 2m = 3puts str[n, m]                  #=> cdeputs str[n..m]                  #=> cdputs str[n..-1]                 #=> cdefghputs str[0..-2]                 #=> abcdefgputs str[str.index('d'), m]     #=> defputs str[str.index('de'), m]    #=> defputs str[/a.*d/]                #=> abcdvar str = 'abcdefgh';var n = 2;var m = 3;say str.substr(n, m);                   #=> cdesay str.substr(n);                      #=> cdefghsay str.substr(0, -1);                  #=> abcdefgsay str.substr(str.index('d'), m);      #=> defsay str.substr(str.index('de'), m);     #=> def"
"s = "" foo bar ""p sp s.lstrip    
p s.rstrip    
p s.strip     
 var s = "" foo bar "";say s.strip_beg.dump;    
say s.strip_end.dump;    
say s.strip.dump;        
"
"class String  def strip_control_characters()    chars.each_with_object(strv) do |char, str|      str << char unless char.ascii_only? and (char.ord < 32 or char.ord == 127)    end  end   def strip_control_and_extended_characters()    chars.each_with_object(strv) do |char, str|      str << char if char.ascii_only? and char.ord.between?(32,126)    end  endend p s = ""a00bcdc37ffoo""p s.strip_control_charactersp s.strip_control_and_extended_charactersvar str = ""a00bcdc37ffoo"" var letters = str.chars.map{.ord}say letters.map{.chr}.join.dump var nocontrols = letters.grep{ (_ > 32) && (_ != 127) }say nocontrols.map{.chr}.join.dump var noextended = nocontrols.grep{ _ < 127 }say noextended.map{.chr}.join.dump"
"def remove_comments!(str, comment_start='/*', comment_end='*/')  while start_idx = str.index(comment_start)     end_idx = str.index(comment_end, start_idx + comment_start.length) + comment_end.length - 1    str[start_idx .. end_idx] = strv   end  strend def remove_comments(str, comment_start='/*', comment_end='*/')  remove_comments!(str.dup, comment_start, comment_end)end example = <<END_OF_STRING
  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */
 
   /**
    * Another comment.
    */
    function something() {
    }
END_OF_STRING puts remove_comments examplefunc strip_block_comments(code, beg='/*', end='*/') {    var re = Regex.new(beg.escape + '.*?' + end.escape, 's');    code.gsub(re, '');} say strip_block_comments(ARGF.slurp);"
"class String  def strip_comment( markers = ['#',';'] )    re = Regexp.union( markers ) 
    if index = (self =~ re)      self[0, index].rstrip      
    else      rstrip    end  endend p 'apples, pears # and bananas'.strip_commentstr = 'apples, pears ; and bananas'p str.strip_commentstr = 'apples, pears and bananas 'p str.strip_commentp str.strip_comment('and')p ""   ;"".strip_commentp strv.strip_commentfunc strip_comment(s) {    (s - %r'[#;].*').strip;} [strv, strv, strv].each { |s|    say strip_comment(s).dump;};"
"str = strvstr.prepend(strv)p str #=> strvvar str = 'llo!';str.sub!(/^/, 'He');say str;var str = 'llo!';str.prepend!('He');say str;"
">> strv.delete(strv)=> strvfunc stripchars(str, char_list) {    str.tr(char_list, strv, strv);}func stripchars(str, char_list) {    str.chars.grep {|c| !char_list.contains(c)}.join;}say stripchars(strv, strv);"
"p 'abcd'.start_with?('ab')  #returns truep 'abcd'.end_with?('ab')    #returns falsep 'abab'.include?('bb')     #returns falsep 'abab'.include?('ab')     #returns truep 'abab'['bb']              #returns nilp 'abab'['ab']              #returns strvp 'abab'.index('bb')        #returns nilp 'abab'.index('ab')        #returns 0p 'abab'.index('ab', 1)     #returns 2p 'abab'.rindex('ab')       #returns 2var first = strv;var second = strv; say first.begins_with(second);      #=> truesay first.contains(second);         #=> truesay first.ends_with(second);        #=> false 
say first.index(second);            #=> 0 
var pos = -1;while (pos = first.index(second, pos+1) != -1) {    say strv;}"
"s = strvp s + strv        #=> strvs1 = s + strvp s1                    #=> strvs1 << strv 
p s1                    #=> strv s = strvp s.concat(strv)  #=> strvp s                     #=> strvvar s = 'hello';say s+' literal';var s1 = s+' literal';say s1;s += ' literal';say s;"
irb(main):001:0> extra = 'little'=> strvirb(main):002:0> strv=> strvirb(main):003:0> strv % extra=> strvvar extra = 'little';say strv;say (strv % 'little');
"
 puts strv.bytesize

 puts strv.length
 puts strv.size  


s = strvputs strv % s.bytesizeputs strv % s.length
s = strvputs strv % s.bytesizeputs strv % s.length
s = strvputs strv % s.bytesizeputs strv % s.length
 class String  
  unless method_defined?(:bytesize)    alias bytesize length  endend s = strvputs strv % s.bytesizeputs strv % s.gsub(/./u, ' ').sizevar str = ""J{332}o{332}s{332}e{301}{332}"";say str.bytes.len;       #=> 14say str.encode('UTF-16').bytes.len;      #=> 20say str.chars.len;    #=> 9say str.graphs.len;   #=> 4"
"method_names = [:==,:!=, :>, :>=, :<, :<=, :<=>, :casecmp][[strv, strv], [strv, strv], [strv,strv], [strv, strv]].each do |str1, str2|  method_names.each{|m| puts ""%s %s %s%s"" % [str1, m, str2, str1.send(m, str2)]}  putsendvar methods = %w(== != > >= < <= <=>)for s1, s2 in [<YUP YUP>,<YUP Yup>,<bot bat>,<aaa zz>] {    methods.each{|m| ""%s %s %s%s"".printf(s1, m, s2, s1.(m)(s2))}    print """"}"
"def stream_merge(*files)  fio = files.map{|fname| open(fname)}  merge(fio.map{|io| [io, io.gets]})end def merge(fdata)  until fdata.empty?    io, min = fdata.min_by{|_,data| data}    puts min    if (next_data = io.gets).nil?      io.close      fdata.delete([io, min])    else      i = fdata.index{|x,_| x == io}      fdata[i] = [io, next_data]    end  endend files = %w(temp1.dat temp2.dat temp3.dat)files.each do |fname|  data = IO.read(fname).gsub("""", strv)  puts strvendstream_merge(*files)"
"s = strvs += strv 
s << strv   
puts svar str = 'Foo';str += 'bar';say str;"
"strv.downcase 
strv.upcase 
 strv.swapcase 
strv.capitalize 
'ĥåçýджк'.upcase  
say strv.lc;             #=> alphabetasay strv.uc;             #=> ALPHABETAsay strv.tc;             #=> AlphaBETAsay strv.wc;            #=> Alpha Betasay strv.tc;            #=> Alpha BETAsay strv.tclc;          #=> Alpha beta"
"class StraddlingCheckerboard  EncodableChars = strv  SortedChars = strv].join   def initialize(board = nil)    if board.nil?      # create a new random board      rest = strv.chars.shuffle      @board = [strv.chars.shuffle, rest[0..9], rest[10..19]]    elsif board.chars.sort.join == SortedChars      @board = board.chars.each_slice(10).to_a    else      raise ArgumentError, strv    end    # find the indices of the first row blanks    @row_labels = @board[0].each_with_index.select {|v, i| v == strv}.map {|v,i| i}     @mapping = {}    @board[0].each_with_index {|char, idx| @mapping[char] = idx.to_s unless char == strv}    @board[1..2].each_with_index do |row, row_idx|      row.each_with_index do |char, idx|        @mapping[char] = strv % [@row_labels[row_idx], idx]      end    end  end   def encode(message)    msg = message.upcase.delete(strv)    msg.chars.inject(strv) do |crypt, char|      crypt << (char =~ /[0-9]/ ? @mapping[strv] + char : @mapping[char])    end  end   def decode(code)    msg = strv    tokens = code.chars    until tokens.empty?      token = tokens.shift      itoken = token.to_i      unless @row_labels.include?(itoken)        msg << @board[0][itoken]      else        token2 = tokens.shift        if @mapping[strv] == token + token2          msg << tokens.shift        else          msg << @board[_labels.index(itoken)][token2.to_i]        end      end    end    msg  end   def to_s    @board.inject(strv) {|res, row| res << row.join}  end   def inspect    ""#<%s board=%p, row_labels=%p, mapping=%p>"" % [self.class, to_s, @row_labels, @mapping]
  end
endrequire 'test/unit'class StraddlingCheckerboardTest <   def setup    @msg = strv    @expected = strv  end   def test1    sc = StraddlingCheckerboard.new strv    code = sc.encode(@msg)    plaintext = sc.decode(code)     puts strv    puts ""original: }""    puts strv    puts strv    assert_equal(strv, code)    assert_equal(@expected, plaintext)  end   def test_board_with_space_in_first_char    sc = StraddlingCheckerboard.new strv    code = sc.encode(@msg)    plaintext = sc.decode(code)    #p sc    #puts strv    #puts strv    assert_equal(@expected, plaintext)  end   def test_random_board    sc = StraddlingCheckerboard.new    plaintext = sc.decode(sc.encode(@msg))    assert_equal(@expected, plaintext)  end   def test_invalid_input    assert_raise(ArgumentError) {StraddlingCheckerboard.new strv}  endend"
"def sb  return enum_for :sb unless block_given?  a=[1,1]  0.step do |i|    yield a[i]    a << a[i]+a[i+1] << a[i+1]  endend puts strv [*1..10,100].each do |n|   puts strvend if sb.take(1000).each_cons(2).map { |a,b| a.gcd(b) }.all? { |n| n==1 }  puts strvelse  puts strvend
func stern_brocot {    var list = [1, 1];    func {        list.append(list[0]+list[1], list[1]);        list.shift;    }} 
1..15 -> map(stern_brocot()).join(' ').say; 

[(1..10)..., 100].each { |i|    var index = 1;    var generator = stern_brocot();    while (generator() != i) {        ++index;    }    say strv;} 

var generator = stern_brocot();var (a, b) = (generator(), generator());{    assert_eq(Math.gcd(a, b), 1);    a = b;    b = generator();} * 1000; say strv;"
"def generate_statistics(n)  sum = sum2 = 0.0  hist = Array.new(10, 0)  n.times do    r = rand    sum += r    sum2 += r**2    hist[(10*r).to_i] += 1  end  mean = sum / n  stddev = Math::sqrt((sum2 / n) - mean**2)   puts strv  puts strv  puts strv  hist.each_with_index {|x,i| puts strv % [0.1*i, strv * (70*x/hist.max)]}  putsend [100, 1000, 10000].each {|n| generate_statistics n}func generate_statistics(n) {    var(sum=0, sum2=0);    var hist = 10.of(0);     n.times {        var r = 1.rand;        sum += r;        sum2 += r**2;        hist[10*r] += 1;    }     var mean = sum/n;    var stddev = Math.sqrt(sum2/n - mean**2);     say strv;    say strv;    say strv;     var max = hist.max;    hist.range.each {|i|        printf(""%.1f:%s"", 0.1*i, strv * 70*hist[i]/max);    }    print """";} [100, 1000, 10000].each {|n| generate_statistics(n) }"
"class StemLeafPlot  def initialize(data, options = {})    opts = {:leaf_digits => 1}.merge(options)    @leaf_digits = opts[:leaf_digits]    @multiplier = 10 ** @leaf_digits    @plot = generate_structure(data)  end   private   def generate_structure(data)    plot = Hash.new {|h,k| h[k] = []}    data.sort.each do |value|       stem, leaf = parse(value)      plot[stem] << leaf    end    plot  end   def parse(value)    stem, leaf = value.abs.divmod(@multiplier)    [Stem.get(stem, value), leaf.round]  end   public   def print    stem_width = Math.log10(@plot.keys.max_by {|s| s.value}.value).ceil + 1    Stem.get_range(@plot.keys).each do |stem|      leaves = @plot[stem].inject(strv) {|str,leaf| str << strv % [@leaf_digits, leaf]}      puts strv % [stem_width, stem, leaves]    end     puts strv    puts strv    puts ""stem unit: ""  endend class Stem  @@cache = {}   def self.get(stem_value, datum)    sign = datum < 0 ? :- : :+    cache(stem_value, sign)  end   private   def self.cache(value, sign)    if @@cache[[value, sign]].nil?      @@cache[[value, sign]] = self.new(value, sign)    end    @@cache[[value, sign]]   end   def initialize(value, sign)    @value = value    @sign = sign  end   public    attr_accessor :value, :sign   def negative?    @sign == :-  end   def <=>(other)    if self.negative?      if other.negative?        other.value <=> self.value      else        -1      end    else      if other.negative?        1      else        self.value <=> other.value      end    end  end   def to_s    strv % [(self.negative? ? '-' : ' '), @value]  end   def self.get_range(array_of_stems)    min, max = array_of_stems.minmax    if min.negative?      if max.negative?        min.value.downto(max.value).collect {|n| cache(n, :-)}      else        min.value.downto(0).collect {|n| cache(n, :-)} + 0.upto(max.value).collect {|n| cache(n, :+)}      end    else      min.value.upto(max.value).collect {|n| cache(n, :+)}    end  end end data = DATA.read.split.map {|s| Float(s)}StemLeafPlot.new(data).print __END__12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 125 139 131115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 1327 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33 117 116111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34133 45 120 30 127 31 116 146class StemLeafPlot  def initialize(data, leaf_digits=1)    @leaf_digits = leaf_digits    multiplier = 10 ** @leaf_digits    @plot = data.sort.group_by{|x| x / multiplier}    @plot.default = []    @plot.each{|k,v| @plot[k] = v.map{|val| val % multiplier}}  end   def print    min, max = @plot.keys.minmax    stem_width = max.to_s.size    (min..max).each do |stem|      leaves = @plot[stem].inject(strv) {|str,leaf| str << strv % [@leaf_digits, leaf]}      puts strv % [stem_width, stem, leaves]    end  endend data = DATA.read.split.map {|s| Integer(s)}StemLeafPlot.new(data).print __END__12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 125 139 131115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 1327 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33 117 116111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34133 45 120 30 127 31 116 146var data = %i(     12 127  28  42  39 113  42  18  44 118  44     37 113 124  37  48 127  36  29  31 125 139    131 115 105 132 104 123  35 113 122  42 117    119  58 109  23 105  63  27  44 105  99  41    128 121 116 125  32  61  37 127  29 113 121     58 114 126  53 114  96  25 109   7  31 141     46  13  27  43 117 116  27   7  68  40  31    115 124  42 128  52  71 118 117  38  27 106     33 117 116 111  40 119  47 105  57 122 109    124 115  43 120  43  27  27  18  28  48 125    107 114  34 133  45 120  30 127  31 116 146).sort; var stem_unit = 10;var h = data.group_by { |i| i / stem_unit -> int } var rng = RangeNum(h.keys.map{.to_i}.minmax);var stem_format =  strv; rng.each { |stem|    var leafs = (h{stem} \\ [])    say(stem_format % stem, ' | ', leafs.map { _ % stem_unit }.join(' '))}"
"BEGIN {  
} END {  
}"
"require 'set' 
Primes = [ 2,  3,  5,  7, 11, 13, 17, 19, 23, 29, 31, 37, 41,           43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]States = [    strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv,    strv, strv, strv, strv, strv, strv,    strv, strv, strv, strv] def print_answer(states)  
  goedel = lambda {|str| str.chars.map {|c| Primes[c.ord - 65]}.reduce(:*)}  pairs = Hash.new {|h,k| h[k] = Array.new}  map = states.uniq.map {|state| [state, goedel[state.upcase.delete(strv)]]}  map.combination(2) {|(s1,g1), (s2,g2)| pairs[g1 * g2] << [s1, s2]}   
  result = []  pairs.values.select {|val| val.length > 1}.each do |list_of_pairs|    list_of_pairs.combination(2) do |pair1, pair2|      if Set[*pair1, *pair2].length == 4        result << [pair1, pair2]      end    end  end   
  result.each_with_index do |(pair1, pair2), i|     puts ""%d%s%s"" % [i+1, pair1.join(', '), pair2.join(', ')]  endend puts strvprint_answer(States)puts strvputs strvprint_answer(States + [strv, strv, strv, strv, strv])"
"def step_up  start_position = $position  step until ($position == start_position + 1)end 


def step  if rand < 0.5    $position -= 1    p strv if $DEBUG    return false  else    $position += 1    p strv if $DEBUG    return true  endend $position = 0step_upfunc step_up() {    while (!step()) {        step_up();    }}"
"def outer(a,b,c)  middle a+b, b+cend def middle(d,e)  inner d+eend def inner(f)  puts caller(0)  puts strvend outer 2,3,5def outer(a,b,c)  middle a+b, b+cend def middle(d,e)  inner d+eend def inner(f)  raise  puts strvend begin  outer 2,3,5rescue Exception => e  puts e.backtraceendputs strvp Thread.current.backtrace"
"def split(str)  puts strv  s = str.chars.chunk(&:itself).map{|_,a| a.join}.join(strv)  puts strv  send split(""gHHH5YY++///"")func group(str) {    gather {        while (var match = (str =~ /((.)\g{-1}*)/g)) {            take(match[0])        }    }} say group(ARGV[0] \\ 'gHHH5YY++///').join(', ')"
"module OperatingSystem  require 'rbconfig'  module_function  def operating_system    case RbConfig::CONFIG[strv]    when /linux/i      :linux    when /cygwin|mswin|mingw|windows/i      :windows    when /darwin/i      :mac    when /solaris/i      :solaris    else      nil    end  end  def linux?;   operating_system == :linux;   end  def windows?; operating_system == :windows; end  def mac?;     operating_system == :mac;     endendload 'operating_system.rb' def speak(text)  if OperatingSystem.windows?    require 'win32/sapi5'    v = Win32::SpVoice.new    v.Speak(text)  elsif OperatingSystem.mac?    IO.popen([strv], strv) {|pipe| pipe.puts text}  else    
    
    IO.popen([strv, strv], strv) {|pipe| pipe.puts text}  endend speak 'This is an example of speech synthesis.'func text2speech(text, lang='en') {    Sys.run(strv);}text2speech(strv);"
"stack = []stack.push(value) 
value = stack.pop 
stack.empty? 
require 'forwardable' 


class Stack  extend Forwardable   
  def self.[](*objects)    new.push(*objects)  end   
  def initialize    @ary = []  end   
  def initialize_copy(obj)    super    @ary = @ary.dup  end   
  def push(*objects)    @ary.push(*objects)    self  end  alias << push   ##  # :method: pop  # :call-seq:  
  
  #  
  
  #  
  
  
  def_delegator :@ary, :pop   ##  # :method: top  # :call-seq:  
  
  
  def_delegator :@ary, :last, :top   ##  # :method: empty?  
  def_delegator :@ary, :empty?   ##  # :method: size  
  def_delegator :@ary, :size  alias length size   
  def to_s    ""}""  end  alias inspect to_sendp s = Stack.new                 
p s.empty?                      
p s.size                        
p s.top                         
p s.pop                         
p s.pop(1)                      
p s.push(1)                     
p s.push(2, 3)                  
p s.top                         
p s.top(2)                      
p s                             
p s.size                        
p s.pop                         
p s.pop(1)                      
p s.empty?                      
 p s = Stack[:a, :b, :c]         
p s << :d                       
p s.pop                         
var stack = [];stack.push(42);         
say stack.pop;          
say stack.is_empty;     
class Stack(stack=[]) {    method pop        { stack.pop };    method push(item) { stack.push(item) };    method empty      { stack.is_empty };} var stack = Stack();stack.push(42);say stack.pop;          
say stack.empty;        
"
"def spiral(n)  spiral = Array.new(n) {Array.new(n, nil)}     
  runs = n.downto(0).each_cons(2).to_a.flatten  
  delta = [[1,0], [0,1], [-1,0], [0,-1]].cycle  x, y, value = -1, 0, -1  for run in runs    dx, dy = delta.next    run.times { spiral[y+=dy][x+=dx] = (value+=1) }  end  spiralend def print_matrix(m)  width = m.flatten.map{|x| x.to_s.size}.max  m.each {|row| puts row.map {|x| strv % x}.join}end print_matrix spiral(5)n = 5m = Array.new(n){Array.new(n)}pos, side = -1, nfor i in 0 .. (n-1)/2  (0...side).each{|j| m[i][i+j]     = (pos+=1) }  (1...side).each{|j| m[i+j][n-1-i] = (pos+=1) }  side -= 2  side.downto(0) {|j| m[n-1-i][i+j] = (pos+=1) }  side.downto(1) {|j| m[i+j][i]     = (pos+=1) }end fmt = strv * nputs m.map{|row| fmt % row}def spiral_matrix(n)  x, y, dx, dy = -1, 0, 0, -1  fmt = strv * n  n.downto(1).flat_map{|x| [x, x-1]}.flat_map{|run|    dx, dy = -dy, dx                    
    run.times.map { [y+=dy, x+=dx] }  }.each_with_index.sort.map(&:last).each_slice(n){|row| puts fmt % row}end spiral_matrix(5)func spiral(n) {    var (x, y, dx, dy, a) = (0, 0, 1, 0, []);    { |i|        a[y][x] = i;        var (nx, ny) = (x+dx, y+dy);        (  if (dx ==  1 && (nx == n || a[ny][nx]!=nil)) { [ 0,  1] }        elsif (dy ==  1 && (ny == n || a[ny][nx]!=nil)) { [-1,  0] }        elsif (dx == -1 && (nx  < 0 || a[ny][nx]!=nil)) { [ 0, -1] }        elsif (dy == -1 && (ny  < 0 || a[ny][nx]!=nil)) { [ 1,  0] }        else                                            { [dx, dy] }        ) » (\dx, \dy);        x = x+dx;        y = y+dy;    } * n**2;    return a;} spiral(5).each { |row|    row.map {strv % _}.join(' ').say;}"
"class Person  def initialize(name)    @name = name    @fiance = nil    @preferences = []    @proposals = []  end  attr_reader :name, :proposals  attr_accessor :fiance, :preferences   def to_s    @name  end   def free    @fiance = nil  end   def single?    @fiance == nil  end   def engage(person)    self.fiance = person    person.fiance = self  end   def better_choice?(person)    @preferences.index(person) < @preferences.index(@fiance)  end   def propose_to(person)    puts strv if $DEBUG    @proposals << person    person.respond_to_proposal_from(self)  end   def respond_to_proposal_from(person)    if single?      puts strv if $DEBUG      engage(person)    elsif better_choice?(person)      puts ""#{self} dumps } for #{person}"" if $DEBUG      @fiance.free      engage(person)    else      puts strv if $DEBUG    end  endend ########################################################################
 prefs = {  'abe'  => %w[abi eve cath ivy jan dee fay bea hope gay],  'bob'  => %w[cath hope abi dee eve fay bea jan ivy gay],  'col'  => %w[hope eve abi dee bea fay ivy gay cath jan],  'dan'  => %w[ivy fay dee gay hope eve jan bea cath abi],  'ed'   => %w[jan dee bea cath fay eve abi ivy hope gay],  'fred' => %w[bea abi dee gay eve ivy cath jan hope fay],  'gav'  => %w[gay eve ivy bea cath abi dee hope jan fay],  'hal'  => %w[abi eve hope fay ivy cath jan bea gay dee],  'ian'  => %w[hope cath dee gay bea abi fay ivy jan eve],  'jon'  => %w[abi fay jan gay eve bea dee cath ivy hope],  'abi'  => %w[bob fred jon gav ian abe dan ed col hal],  'bea'  => %w[bob abe col fred gav dan ian ed jon hal],  'cath' => %w[fred bob ed gav hal col ian abe dan jon],  'dee'  => %w[fred jon col abe ian hal gav dan bob ed],  'eve'  => %w[jon hal fred dan abe gav col ed ian bob],  'fay'  => %w[bob abe ed ian jon dan fred gav col hal],  'gay'  => %w[jon gav hal fred bob abe col ed dan ian],  'hope' => %w[gav jon bob abe ian dan hal ed col fred],  'ivy'  => %w[ian col hal gav fred bob abe ed jon dan],  'jan'  => %w[ed hal gav abe bob jon col ian fred dan],} @men = Hash[  %w[abe bob col dan ed fred gav hal ian jon].collect do |name|    [name, Person.new(name)]  end] @women = Hash[  %w[abi bea cath dee eve fay gay hope ivy jan].collect do |name|    [name, Person.new(name)]  end] @men.each {|name, man| man.preferences = @women.values_at(*prefs[name])}@women.each {|name, woman| woman.preferences = @men.values_at(*prefs[name])} ########################################################################
 def match_couples(men, women)  men.each_value {|man| man.free}  women.each_value {|woman| woman.free}   while m = men.values.find {|man| man.single?} do    puts strv if $DEBUG    w = m.preferences.find {|woman| not m.proposals.include?(woman)}    m.propose_to(w)  endend match_couples @men, @women @men.each_value.collect {|man| puts strv} ########################################################################
 class Person  def more_preferable_people    ( @preferences.partition {|p| better_choice?(p)} ).first  endend require 'set' def stability(men)  unstable = Set.new  men.each_value do |man|    woman = man.fiance    puts strv if $DEBUG     man.more_preferable_people.each do |other_woman|      if other_woman.more_preferable_people.include?(man)        puts strv if $DEBUG        unstable << [man, other_woman]      end    end    woman.more_preferable_people.each do |other_man|      if other_man.more_preferable_people.include?(woman)        puts strv if $DEBUG        unstable << [other_man, woman]      end    end  end   if unstable.empty?    puts strv  else    puts strv    unstable.each do |a,b|      puts strv    end  endend stability @men ########################################################################
 puts ""what if abe and bob swap..."" def swap(m1, m2)  w1 = m1.fiance  w2 = m2.fiance  m1.fiance = w2  w1.fiance = m2  m2.fiance = w1  w2.fiance = m1end swap *@men.values_at('abe','bob') @men.each_value.collect {|man| puts strv}stability @menvar he_likes = Hash(    abe  => < abi eve cath ivy jan dee fay bea hope gay >,    bob  => < cath hope abi dee eve fay bea jan ivy gay >,    col  => < hope eve abi dee bea fay ivy gay cath jan >,    dan  => < ivy fay dee gay hope eve jan bea cath abi >,    ed   => < jan dee bea cath fay eve abi ivy hope gay >,    fred => < bea abi dee gay eve ivy cath jan hope fay >,    gav  => < gay eve ivy bea cath abi dee hope jan fay >,    hal  => < abi eve hope fay ivy cath jan bea gay dee >,    ian  => < hope cath dee gay bea abi fay ivy jan eve >,    jon  => < abi fay jan gay eve bea dee cath ivy hope >,); var she_likes = Hash(    abi  => < bob fred jon gav ian abe dan ed col hal >,    bea  => < bob abe col fred gav dan ian ed jon hal >,    cath => < fred bob ed gav hal col ian abe dan jon >,    dee  => < fred jon col abe ian hal gav dan bob ed >,    eve  => < jon hal fred dan abe gav col ed ian bob >,    fay  => < bob abe ed ian jon dan fred gav col hal >,    gay  => < jon gav hal fred bob abe col ed dan ian >,    hope => < gav jon bob abe ian dan hal ed col fred >,    ivy  => < ian col hal gav fred bob abe ed jon dan >,    jan  => < ed hal gav abe bob jon col ian fred dan >,); var guys = he_likes.keys;var gals = she_likes.keys; var (:fiancé, :fiancée, :proposed); func she_prefers (her, hottie) { var a = she_likes{her}; a.index(hottie) < a.index(fiancé{her}) }func he_prefers  (him, hottie) { var a =  he_likes{him}; a.index(hottie) < a.index(fiancée{him}) } func unmatched_guy { guys.first {|k| !defined fiancée{k} } }func preferred_choice(guy) { he_likes{guy}.first {|k| !defined proposed{guy}{k} } } func engage(guy, gal) {    fiancé{gal} = guy;    fiancée{guy} = gal;} func match_em {    say 'Matchmaking:';    while (defined(var guy = unmatched_guy())) {        var gal = preferred_choice(guy);        proposed{guy}{gal} = '❤';        if (!defined fiancé{gal}) {            engage(guy, gal);            say ""#{gal} and #{guy}"";        }        elsif (she_prefers(gal, guy)) {            var engaged_guy = fiancé{gal};            engage(guy, gal);            fiancée{engaged_guy} = nil;            say ""#{gal} dumped #{engaged_guy} for #{guy}"";        }    }} func check_stability {    var instabilities = gather {        guys.each { |m|            gals.each { |w|                if (he_prefers(m, w) && she_prefers(w, m)) {                    take ""#{w} prefers #{m} to #{fiancé{w}} and #{m} prefers #{w} to #{fiancée{m}}"";                }            }        }    }     say 'Stablility:';    instabilities.is_empty        ? say ""(all marriages stable)""        : instabilities.each { |i| say i };} func perturb_em {    say 'Perturb:';    say ""engage abi with fred and bea with jon"";    engage('fred', 'abi');    engage('jon', 'bea');} match_em();check_stability(); perturb_em();check_stability();"
"bar = ('▁'..'█').to_a loop {print 'Numbers please separated by space/commas: '  numbers = gets.split(/[\s,]+/).map(&:to_f)  min, max = numbers.minmax  puts strv% [min, max]  div = (max - min) / (bar.size - 1)  puts min == max ? bar.last*numbers.size : numbers.map{|num| bar[((num - min) / div).to_i]}.join}var bar = @('▁'..'█');loop {    print 'Numbers, please, separated by space/commas: ';    var numbers = read(String).trim.split(/[\s,]+/).map{.to_n};    var (min, max) = numbers.minmax;    say strv%(min, max);    var div = ((max - min) / bar.end);    say (min == max ? bar.last*numbers.len : numbers.map{|num| bar[(num - min) / div]}.join);}"
"
 def get_code(c : Char)  case c  when 'B', 'F', 'P', 'V'     strv  when 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z'    strv  when 'D', 'T'    strv  when 'L'    strv  when 'M', 'N'    strv  when 'R'    strv  when 'H', 'W'    strv  else     strv  endend def soundex(s : String)  return strv if s == strv  s = s.upcase  result = s[0,1]   prev = get_code s[0]  s.lchop.each_char {|c|    curr = get_code c    result += curr if curr != strv && curr != strv && curr != prev    prev = curr unless curr == strv  }  result.ljust(4, '0')[0, 4]end pairs = [          [strv  , strv],          [strv  , strv],          [strv     , strv],          [strv     , strv],          [strv   , strv],          [strv , strv],          [strv       , strv],          [strv     , strv],          [strv     , strv],          [strv   , strv],          [strv    , strv],          [strv    , strv],          [strv     , strv],          [strv   , strv],          [strv   , strv],          [strv   , strv]         ] pairs.each { |pair|  puts strv}class String   SoundexChars = 'BFPVCGJKQSXZDTLMNR'  SoundexNums  = '111122222222334556'  SoundexCharsEx = '^' + SoundexChars  SoundexCharsDel = '^A-Z'   
  def soundex(census = true)    str = self.upcase.delete(SoundexCharsDel)    str[0,1] + str[1..-1].delete(SoundexCharsEx).                          tr_s(SoundexChars, SoundexNums)\                          [0 .. (census ? 2 : -1)].                          ljust(3, '0') rescue ''  end   def sounds_like(other)    self.soundex == other.soundex  endend %w(Soundex Sownteks Example Ekzampul foo bar).each_slice(2) do |word1, word2|  [word1, word2].each {|word| puts '%-8s -> %s' % [word, word.soundex]}   print strv  print word1.sounds_like(word2) ? strv : strv  print "" like '#{word2}'""endfunc soundex(word, length=3) {     
    
    word.uc!.tr!('A-Z', '', 'cd')     
    return(nil) if (word.is_empty)     var firstLetter = word.char(0)     
    word.tr!('BFPV',     '1', 's')    word.tr!('CGJKQSXZ', '2', 's')    word.tr!('DT',       '3', 's')    word.tr!('L',        '4', 's')    word.tr!('MN',       '5', 's')    word.tr!('R',        '6', 's')     
    word.ft!(1)     
    word.tr!('AEHIOUWY', '', 'd')     
    firstLetter + (word.chars + length.of('0') -> first(length).join)} func testSoundex {     
    var sndx = Hash(                strv                => strv,                strv                => strv,                strv              => strv,                strv                => strv,                strv                => strv,                strv           => strv,                'fulkerson'            => 'F4262',                'faulkersuhn'          => 'F4262',                'fpfffffauhlkkersssin' => 'F4262',                'Aaeh'                 => 'A0000',               )     sndx.keys.sort.each { |name|        var findSdx = soundex(name, 4)        say strv        if (findSdx != sndx{name}) {            say ""However, that is incorrect!""        }    }} testSoundex()"
"class Array  def strandsort    a = dup    result = []    until a.empty?      v = a.first      sublist, a = a.partition{|val| v=val if v<=val}   
       result.each_index do |idx|        break if sublist.empty?        result.insert(idx, sublist.shift) if sublist.first < result[idx]      end      result += sublist    end    result  end   def strandsort!    replace(strandsort)  endend p [1, 6, 3, 2, 1, 7, 5, 3].strandsortfunc merge(x, y) {    var out = [];    while (x && y) {        given (x[-1] <=> y[-1]) {            when ( 1) { out.prepend(x.pop) }            when (-1) { out.prepend(y.pop) }            default   { out.prepend(x.pop, y.pop) }        }    }    x + y + out;} func strand(x) {    x || return [];    var out = [x.shift];    if (x.len) {        for i in (-x.len .. -1) {            if (x[i] >= out[-1]) {                out.append(x.pop_at(i));            }        }    }    return out;} func strand_sort(x) {    var out = [];    while (var strd = strand(x)) {        out = merge(out, strd);    }    return out;} var a = 10.of { 100.irand };say strv;say strv;"
"class Array  def stoogesort    self.dup.stoogesort!  end   def stoogesort!(i = 0, j = self.length-1)    if self[j] < self[i]      self[i], self[j] = self[j], self[i]    end    if j - i > 1      t = (j - i + 1)/3      stoogesort!(i, j-t)      stoogesort!(i+t, j)      stoogesort!(i, j-t)    end    self  endend p [1,4,5,3,-6,3,7,10,-2,-5].stoogesort func stooge(x, i, j) {    if (x[j] < x[i]) {        x.swap(i, j)    }     if (j-i > 1) {        var t = ((j - i + 1) / 3)        stooge(x, i,     j - t)        stooge(x, i + t, j    )        stooge(x, i,     j - t)    }} var a = 10.of { 100.irand } say strvstooge(a, 0, a.end)say strv"
require 'thread' nums = ARGV.collect(&:to_i)sorted = []mutex = Mutex.new threads = nums.collect do |n|  Thread.new do    sleep 0.01 * n    mutex.synchronize {sorted << n}  endendthreads.each {|t| t.join} p sortedARGV.map{.to_i}.map{ |i|    {Sys.sleep(i); say i}.fork;}.each{.wait};
"class Array  def shellsort!    inc = length / 2    while inc != 0      inc.step(length-1) do |i|        el = self[i]        while i >= inc and self[i - inc] > el          self[i] = self[i - inc]          i -= inc        end        self[i] = el      end      inc = (inc == 2 ? 1 : (inc * 5.0 / 11).to_i)    end    self  endend data = [22, 7, 2, -5, 8, 4]data.shellsort!p data 
func shell_sort(a) {    var h = a.len;    while (h >>= 1) {        for i in (h .. a.end) {            var k = a[i];            for (var j = i; (j >= h) && (k < a[j - h]); j -= h) {                a[j] = a[j - h];            }            a[j] = k;        }    }    return a;} var a = 10.of {100.irand};say a;shell_sort(a);say a;"
"class Array  def radix_sort(base=10)    ary = dup    rounds = (Math.log(ary.minmax.map(&:abs).max)/Math.log(base)).floor + 1    rounds.times do |i|      buckets = Array.new(2*base){[]}      base_i = base**i      ary.each do |n|        digit = (n/base_i) % base        digit += base if 0<=n        buckets[digit] << n      end      ary = buckets.flatten      p [i, ary] if $DEBUG    end    ary  end  def radix_sort!(base=10)    replace radix_sort(base)  endend p [1, 3, 8, 9, 0, 0, 8, 7, 1, 6].radix_sortp [170, 45, 75, 90, 2, 24, 802, 66].radix_sortp [170, 45, 75, 90, 2, 24, -802, -66].radix_sortp [100000, -10000, 400, 23, 10000].radix_sortclass Array  def radix_sort(base=10)    ary = dup    m, max = 1, ary.minmax.map(&:abs).max    while m <= max      buckets = Array.new(base){[]}      ary.each {|n| buckets[(n.abs / m) % base] << n}      ary = buckets.flatten      m *= base    end    ary.partition{|n| n<0}.inject{|minus,plus| minus.reverse + plus}  endendclass Array {    method radix_sort(base=10) {        var arr = self.clone;        var rounds = ([arr.minmax].map{.abs}.max -> log(base).floor + 1);        for i in ^rounds {            var buckets = (2*base -> of {[]});            var base_i = base**i;            for n in arr {                var digit = (n/base_i % base);                digit += base if (0 <= n);                buckets[digit].append(n);            }            arr = buckets.flatten;        }        return arr;    }} for arr in [    [1, 3, 8, 9, 0, 0, 8, 7, 1, 6],    [170, 45, 75, 90, 2, 24, 802, 66],    [170, 45, 75, 90, 2, 24, -802, -66],    [100000, -10000, 400, 23, 10000],] {    say arr.radix_sort;}"
"class Array  def selectionsort!    for i in 0..length-2      min_idx = i      for j in (i+1)...length        min_idx = j  if self[j] < self[min_idx]      end      self[i], self[min_idx] = self[min_idx], self[i]    end    self  endendary = [7,6,5,9,8,4,3,1,2,0]p ary.selectionsort!
class Array {    method selectionsort {        for i in ^(self.end) {            var min_idx = i            for j in (i+1 .. self.end) {                if (self[j] < self[min_idx]) {                    min_idx = j                }            }            self.swap(i, min_idx)        }        return self    }} var nums = [7,6,5,9,8,4,3,1,2,0];say nums.selectionsort; var strs = [strv, strv, strv, strv, strv, strv];say strs.selectionsort;"
"class Array  def patience_sort    piles = []    each do |i|      if (idx = piles.index{|pile| pile.last <= i})        piles[idx] << i      else        piles << [i]    #create a new pile      end    end    
    result = []    until piles.empty?      first = piles.map(&:first)      idx = first.index(first.min)      result << piles[idx].shift      piles.delete_at(idx) if piles[idx].empty?    end    result  endend a = [4, 65, 2, -31, 0, 99, 83, 782, 1]p a.patience_sortfunc patience(deck) {  var stacks = [];  deck.each { |card|    given (stacks.first { card < .last }) { |stack|      case (defined stack) {        stack << card      }      default {        stacks << [card]      }    }  }   gather {    while (stacks) {      take stacks.min_by { .last }.pop      stacks.grep!{ !.is_empty }    }  }} var a = [4, 65, 2, -31, 0, 99, 83, 782, 1]say patience(a)"
"class Array  def pancake_sort!    num_flips = 0    (self.size-1).downto(1) do |end_idx|      max     = self[0..end_idx].max      max_idx = self[0..end_idx].index(max)      next if max_idx == end_idx       if max_idx > 0        self[0..max_idx] = self[0..max_idx].reverse         p [num_flips += 1, self]  if $DEBUG      end       self[0..end_idx] = self[0..end_idx].reverse       p [num_flips += 1, self]  if $DEBUG    end    self  endend p a = (1..9).to_a.shufflep a.pancake_sort!func pancake(a) {    for idx in ^(a.end) {        var min = idx        for i in (idx+1 .. a.end) { min = i if (a[min] > a[i]) }        next if (a[min] == a[idx])        a[min..a.end] = [a[min..a.end]].reverse...        a[idx..a.end] = [a[idx..a.end]].reverse...    }    return a} var arr = 10.of{ 100.irand }say strvsay strv"
"class Array  def permutationsort    permutation.each{|perm| return perm if perm.sorted?}  end   def sorted?    each_cons(2).all? {|a, b| a <= b}  endendfunc psort(x, d=x.end) {     if (d.is_zero) {        for i in (1 .. x.end) {            (x[i] < x[i-1]) && return false;        }        return true;    }     (d+1).times {        x.prepend(x.splice(d, 1)...);        x[d] < x[d-1] && next;        psort(x, d-1) && return true;    }     return false;} var a = 10.of { 100.irand };say ""Before:#{a}"";psort(a);say ""After:#{a}"";"
"def quick_sort(a : Array(Int32)) : Array(Int32)  return a if a.size <= 1  p = a[0]  lt, rt = a[1 .. -1].partition { |x| x < p }  return quick_sort(lt) + [p] + quick_sort(rt)end a = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]puts quick_sort(a) 
class Array  def quick_sort    return self if length <= 1    pivot = self[0]    less, greatereq = self[1..-1].partition { |x| x < pivot }    less.quick_sort + [pivot] + greatereq.quick_sort  endendclass Array  def quick_sort    return self if length <= 1    pivot = sample    group = group_by{ |x| x <=> pivot }    group.default = []    group[-1].quick_sort + group[0] + group[1].quick_sort  endendclass Array  def quick_sort    h, *t = self    h ? t.partition { |e| e < h }.inject { |l, r| l.quick_sort + [h] + r.quick_sort } : []  endendfunc quicksort (a) {    a.len < 2 && return(a);    var p = a.pop_rand;          
    __FUNC__(a.grep{ .< p}) + [p] + __FUNC__(a.grep{ .>= p});}"
"class Array  def insertionsort!    1.upto(length - 1) do |i|      value = self[i]      j = i - 1      while j >= 0 and self[j] > value        self[j+1] = self[j]        j -= 1      end      self[j+1] = value    end    self  endendary = [7,6,5,9,8,4,3,1,2,0]p ary.insertionsort!
class Array  def insertionsort!    1.upto(length - 1) do |i|      value = delete_at i      j = i - 1      j -= 1 while j >= 0 && value < self[j]      insert(j + 1, value)    end    self  endend ary = [7,6,5,9,8,4,3,1,2,0]p ary.insertionsort!
class Array {    method insertion_sort {        { |i|            var j = i;            var k = self[i];            while ((j > 0) && (k < self[j - 1])) {                self[j] = self[j - 1];                j--;            };            self[j] = k;        } * self.end;        return self;    }} var a = 10.of {100.rand.int};say a.insertion_sort;"
"class Array  def heapsort    self.dup.heapsort!  end   def heapsort!    
    ((length - 2) / 2).downto(0) {|start| siftdown(start, length - 1)}     
    (length - 1).downto(1) do |end_|      self[end_], self[0] = self[0], self[end_]      siftdown(0, end_ - 1)    end    self  end   def siftdown(start, end_)    root = start    loop do      child = root * 2 + 1      break if child > end_      if child + 1 <= end_ and self[child] < self[child + 1]        child += 1      end      if self[root] < self[child]        self[root], self[child] = self[child], self[root]        root = child      else        break      end    end  endendfunc sift_down(a, start, end) {    var root = start;    while ((2*root + 1) <= end) {        var child = (2*root + 1);        if ((child+1 <= end) && (a[child] < a[child + 1])) {            child += 1;        }        if (a[root] < a[child]) {            a[child, root] = a[root, child];            root = child;        } else {            return;        }    }} func heapify(a, count) {    var start = ((count - 2) / 2);    while (start >= 0) {        sift_down(a, start, count-1);        start -= 1;    }} func heap_sort(a, count) {    heapify(a, count);    var end = (count - 1);    while (end > 0) {        a[0, end] = a[end, 0];        end -= 1;        sift_down(a, 0, end)    }    return a} var arr = (1..10 -> shuffle);  
say arr;                       
heap_sort(arr, arr.len);       
say arr;                       
"
"def merge_sort(a : Array(Int32)) : Array(Int32)  return a if a.size <= 1  m = a.size / 2  lt = merge_sort(a[0 ... m])  rt = merge_sort(a[m .. -1])  return merge(lt, rt)end def merge(lt : Array(Int32), rt : Array(Int32)) : Array(Int32)  result = Array(Int32).new  until lt.empty? || rt.empty?    result << (lt.first < rt.first ? lt.shift : rt.shift)  end  return result + lt + rtend a = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]puts merge_sort(a) 
def merge_sort(m)  return m if m.length <= 1   middle = m.length / 2  left = merge_sort(m[0...middle])  right = merge_sort(m[middle..-1])  merge(left, right)end def merge(left, right)  result = []  until left.empty? || right.empty?    result << (left.first<=right.first ? left.shift : right.shift)  end  result + left + rightend ary = [7,6,5,9,8,4,3,1,2,0]p merge_sort(ary)                  
class Array  def mergesort(&comparitor)    return self if length <= 1    comparitor ||= proc{|a, b| a <=> b}    middle = length / 2    left  = self[0...middle].mergesort(&comparitor)    right = self[middle..-1].mergesort(&comparitor)    merge(left, right, comparitor)   end   private  def merge(left, right, comparitor)    result = []    until left.empty? || right.empty?      
      if comparitor[left.first, right.first] <= 0        result << left.shift      else        result << right.shift      end    end    result + left + right  endend ary = [7,6,5,9,8,4,3,1,2,0]p ary.mergesort                    
p ary.mergesort {|a, b| b <=> a}   
 ary = [[strv, strv], [strv, strv], [strv, strv], [strv, strv]]p ary.mergesort
p ary.mergesort {|a, b| a[1] <=> b[1]}
func merge(left, right) {    var result = [];    while (!left.is_empty && !right.is_empty) {        result.append([right,left][left.first <= right.first].shift);    };    result + left + right;} func mergesort(array) {    var len = array.len;    len < 2 && return array;     var mid   = (len/2 -> int);    var left  = array.ft(0, mid-1);    var right = array.ft(mid);     left  = __FUNC__(left);    right = __FUNC__(right);     merge(left, right);} 
var nums = (0..7 -> shuffle);say mergesort(nums); 
var strings = ('a'..'e' -> shuffle);say mergesort(strings);"
"def cycleSort!(array)  writes = 0   
  for cycleStart in 0 .. array.size-2    item = array[cycleStart]     
    pos = cycleStart    for i in cycleStart+1 ... array.size      pos += 1  if array[i] < item    end     
    next  if pos == cycleStart     
    pos += 1  while item == array[pos]    array[pos], item = item, array[pos]    writes += 1     
    while pos != cycleStart       
      pos = cycleStart      for i in cycleStart+1 ... array.size        pos += 1  if array[i] < item      end       
      pos += 1  while item == array[pos]      array[pos], item = item, array[pos]      writes += 1    end  end  writesend  p a = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]puts strvp afunc cycle_sort (array) {    var (writes=0, pos=0)     func f(i, Ref item, bool=false) {        pos = (i + array.ft(i+1).count{ _ < *item })        return(false) if (bool && pos==i)        while (*item == array[pos]) { ++pos }        (array[pos], *item) = (*item, array[pos])        ++writes        return true    }     array.each_kv { |i, item|        f(i, \item, true) || next        while (pos != i) {            f(i, \item)        }    }     return writes} var a = %n(0 1 2 2 2 2 1 9 3.5 5 8 4 7 0 6) say a.join(' ')say ('writes ', cycle_sort(a))say a.join(' ')"
"class Array  def gnomesort!    i, j = 1, 2    while i < length      if self[i-1] <= self[i]        i, j = j, j+1      else        self[i-1], self[i] = self[i], self[i-1]        i -= 1        if i == 0          i, j = j, j+1        end      end    end    self  endendary = [7,6,5,9,8,4,3,1,2,0]ary.gnomesort!
class Array {    method gnomesort {        var (i=1, j=2);        var len = self.len;        while (i < len) {            if (self[i-1] <= self[i]) {                (i, j) = (j, j+1);            }            else {                self[i-1, i] = self[i, i-1];                if (--i == 0) {                    (i, j) = (j, j+1);                }            }        }        return self;    }} var ary = [7,6,5,9,8,4,3,1,2,0];say ary.gnomesort;"
"class Array  def counting_sort!    replace counting_sort  end   def counting_sort    min, max = minmax    count = Array.new(max - min + 1, 0)    each {|number| count[number - min] += 1}    (min..max).each_with_object([]) {|i, ary| ary.concat([i] * count[i - min])}  endend ary = [9,7,10,2,9,7,4,3,10,2,7,10,2,1,3,8,7,3,9,5,8,5,1,6,3,7,5,4,6,9,9,6,6,10,2,4,5,2,8,2,2,5,2,9,3,3,5,7,8,4]p ary.counting_sort.join(strv)
 p ary = Array.new(20){rand(-10..10)}
p ary.counting_sort
func counting_sort(a, min, max) {    var cnt = ([0] * (max - min + 1));    a.each { |i| cnt[i-min]++ };    return cnt.map {|i| min++; [min-1] * i}.sum;} var a = 100.of {100.rand.int};say counting_sort(a, 0, 100).dump;"
"class Array  def circle_sort!    while _circle_sort!(0, size-1) > 0    end    self  end   private  def _circle_sort!(lo, hi, swaps=0)    return swaps if lo == hi    low, high = lo, hi    mid = (lo + hi) / 2    while lo < hi      if self[lo] > self[hi]        self[lo], self[hi] = self[hi], self[lo]        swaps += 1      end      lo += 1      hi -= 1    end    if lo == hi && self[lo] > self[hi+1]      self[lo], self[hi+1] = self[hi+1], self[lo]      swaps += 1    end    swaps + _circle_sort!(low, mid) + _circle_sort!(mid+1, high)  endend ary = [6, 7, 8, 9, 2, 5, 3, 4, 1]puts strvputs strvfunc circlesort(arr, beg=0, end=arr.end) {    var swaps = 0    if (beg < end) {        var (lo, hi) = (beg, end)        do {            if (arr[lo] > arr[hi]) {                arr.swap(lo, hi)                ++swaps            }            ++hi if (--hi == ++lo)        } while (lo < hi)        swaps += circlesort(arr, beg, hi)        swaps += circlesort(arr, lo, end)    }    return swaps} var numbers = %n(2 3 3 5 5 1 1 7 7 6 6 4 4 0 0)do { say numbers } while circlesort(numbers) var strs = [strv, strv, strv, strv, strv, strv, strv]do { say strs } while circlesort(strs)"
def shuffle(l)    l.sort_by { rand }end def bogosort(l)    l = shuffle(l) until in_order(l)    lend def in_order(l)    (0..l.length-2).all? {|i| l[i] <= l[i+1] }enddef shuffle(l)    l.sort_by { rand }end def bogosort(l)   l = shuffle(l) until l == l.sort   lenddef in_order(l)    (0..l.length-2).all? {|i| l[i] <= l[i+1] }end def bogosort(l)   l.shuffle! until in_order(l)   lendfunc in_order(a) {    return true if (a.len <= 1);    var first = a[0];    a.ft(1).all { |elem| first <= elem  ? do { first = elem; true } : false }} func bogosort(a) {    a.shuffle! while !in_order(a);    return a;} var arr = 5.of{ 100.rand.int };say strv;say strv;
"ary = [[strv, strv],       [strv, strv],       [strv, strv],       [strv, strv]]p ary.sort {|a,b| a[1] <=> b[1]}

class Array  def stable_sort    n = -1    if block_given?      collect {|x| n += 1; [x, n]      }.sort! {|a, b|        c = yield a[0], b[0]        if c.nonzero? then c else a[1] <=> b[1] end      }.collect! {|x| x[0]}    else      sort_by {|x| n += 1; [x, n]}    end  end   def stable_sort_by    block_given? or return enum_for(:stable_sort_by)    n = -1    sort_by {|x| n += 1; [(yield x), n]}  endendary = [[strv, strv],       [strv, strv],       [strv, strv],       [strv, strv]]p ary.stable_sort {|a, b| a[1] <=> b[1]}
p ary.stable_sort_by {|x| x[1]}
var table = [  <UK  London>,  <US  New\ York>,  <US  Birmingham>,  <UK  Birmingham>,]; table.sort {|a,b| a[0] <=> b[0]}.each { |col|    say strv}"
"class Array  def bubblesort1!    length.times do |j|      for i in 1...(length - j)        if self[i] < self[i - 1]          self[i], self[i - 1] = self[i - 1], self[i]        end      end    end    self  end   def bubblesort2!    each_index do |index|      (length - 1).downto( index ) do |i|        self[i-1], self[i] = self[i], self[i-1] if self[i-1] < self[i]      end    end    self  endendary = [3, 78, 4, 23, 6, 8, 6]ary.bubblesort1!p ary
func bubble_sort(arr) {    loop {        var swapped = false        { |i|            if (arr[i-1] > arr[i]) {                arr[i-1, i] = arr[i, i-1]                swapped = true            }        } * arr.end        swapped || break    }    return arr}"
"class Array  def combsort!    gap = size    swaps = true    while gap > 1 or swaps      gap = [1, (gap / 1.25).to_i].max      swaps = false      0.upto(size - gap - 1) do |i|        if self[i] > self[i+gap]          self[i], self[i+gap] = self[i+gap], self[i]          swaps = true        end      end    end    self  endend p [23, 76, 99, 58, 97, 57, 35, 89, 51, 38, 95, 92, 24, 46, 31, 24, 14, 12, 57, 78].combsort!func comb_sort(arr) {    var gap = arr.len;    var swaps = true;    while (gap > 1 || swaps) {        gap.div!(1.25).int! if (gap > 1);        swaps = false;        for i in ^(arr.len - gap) {            if (arr[i] > arr[i+gap]) {                arr[i, i+gap] = arr[i+gap, i];                swaps = true;            }        }    }    return arr;}"
"def sort_disjoint_sublist!(ar, indices)  values = ar.values_at(*indices).sort  indices.sort.zip(values).each{ |i,v| ar[i] = v }  arend values = [7, 6, 5, 4, 3, 2, 1, 0]indices = [6, 1, 7]p sort_disjoint_sublist!(values, indices)func disjointSort(values, indices) {    values[indices.sort] = [values[indices]].sort...} var values =  [7, 6, 5, 4, 3, 2, 1, 0];var indices = [6, 1, 7]; disjointSort(values, indices);say values;"
"words = %w(Here are some sample strings to be sorted)p words.sort_by {|word| [-word.size, word.downcase]}p words.sort {|a, b| d = b.size <=> a.size                     d != 0 ? d : a.upcase <=> b.upcase}func mycmp(a, b) { (b.len <=> a.len) || (a.lc <=> b.lc) };var strings = %w(Here are some sample strings to be sorted);var sorted = strings.sort(mycmp);"
"class Array  def cocktailsort!    begin      swapped = false      0.upto(length - 2) do |i|        if self[i] > self[i + 1]          self[i], self[i + 1] = self[i + 1], self[i]          swapped = true        end      end      break unless swapped       swapped = false      (length - 2).downto(0) do |i|        if self[i] > self[i + 1]          self[i], self[i + 1] = self[i + 1], self[i]          swapped = true        end      end    end while swapped    self  endendclass Array  def cocktailsort!    start, finish, way = 0, size-1, 1    loop do      swapped = false      start.step(finish-way, way) do |i|        if (self[i] <=> self[i + way]) == way          self[i], self[i + way] = self[i + way], self[i]          swapped = i        end      end      break unless swapped      start, finish, way = swapped, start, -way    end    self  endendary = [7,6,5,9,8,4,3,1,2,0]p ary.cocktailsort!ary = [strv, strv, strv, strv, strv, strv]p ary.cocktailsort!func cocktailsort(a) {    var swapped = false;    func cmpsw(i) {        if (a[i] > a[i+1]) {            a[i, i+1] = a[i+1, i];            swapped = true;        }    }    var max = a.end;    do {        { |i| cmpsw(i-1) } * max;        swapped.not! && break;        { |i| cmpsw(max-i) } * max;    } while (swapped);    return a;}var numbers = [7,6,5,9,8,4,3,1,2,0];say cocktailsort(numbers).dump; var strs = [strv, strv, strv, strv, strv, strv];say cocktailsort(strs).dump;"
"class Array  def beadsort    map {|e| [1] * e}.columns.columns.map(&:length)  end   def columns    y = length    x = map(&:length).max    Array.new(x) do |row|      Array.new(y) { |column| self[column][row] }.compact 
    end  endend 
p [5,3,1,7,4,1,1].beadsortfunc beadsort(arr) {     var rows = []    var columns = []     for datum in arr {        for column in ^datum {            ++(columns[column] := 0)            ++(rows[columns[column] - 1] := 0)        }    }     rows.reverse} say beadsort([5,3,1,7,4,1,1])"
"nums = [2,4,3,1,2]sorted = nums.sort      
p sorted                #=> [1, 2, 2, 3, 4]p nums                  #=> [2, 4, 3, 1, 2] nums.sort!              
p nums                  #=> [1, 2, 2, 3, 4]var nums = [2,4,3,1,2];var sorted = nums.sort;  
nums.sort!;              
"
%w[  1.3.6.1.4.1.11.2.17.19.3.4.0.10  1.3.6.1.4.1.11.2.17.5.2.0.79  1.3.6.1.4.1.11.2.17.19.3.4.0.4  1.3.6.1.4.1.11150.3.4.0.1  1.3.6.1.4.1.11.2.17.19.3.4.0.1  1.3.6.1.4.1.11150.3.4.0].sort_by{|oid| oid.split(strv).map(&:to_i)}.each{|oid| puts oid}func sort_OIDs(ids) {    ids.sort_by { |id|        id.split('.').map { Num(_) }    }} var OIDs = %w(    1.3.6.1.4.1.11.2.17.19.3.4.0.10    1.3.6.1.4.1.11.2.17.5.2.0.79    1.3.6.1.4.1.11.2.17.19.3.4.0.4    1.3.6.1.4.1.11150.3.4.0.1    1.3.6.1.4.1.11.2.17.19.3.4.0.1    1.3.6.1.4.1.11150.3.4.0) sort_OIDs(OIDs).each { .say }
"Person = Struct.new(:name,:value) do  def to_s; strv endend list = [Person.new(strv,3),        Person.new(strv,4),        Person.new(strv,20),        Person.new(strv,3)]puts list.sort_by{|x|x.name}putsputs list.sort_by(&:value)
var people = [['joe', 120], ['foo', 31], ['bar', 51]]; 
people.sort! {|a,b| a[0] <=> b[0] }; 
var sorted = people.sort_by { |item| item[0] }; 
say people;"
"require 'HLPsolver' ADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]] board1 = <<EOS
 0  0  0  0  0  0  0  0  0
 0  0 46 45  0 55 74  0  0
 0 38  0  0 43  0  0 78  0
 0 35  0  0  0  0  0 71  0
 0  0 33  0  0  0 59  0  0
 0 17  0  0  0  0  0 67  0
 0 18  0  0 11  0  0 64  0
 0  0 24 21  0  1  2  0  0
 0  0  0  0  0  0  0  0  0
EOSHLPsolver.new(board1).solve board2 = <<EOS
 0  0  0  0  0  0  0  0  0
 0 11 12 15 18 21 62 61  0
 0  6  0  0  0  0  0 60  0
 0 33  0  0  0  0  0 57  0
 0 32  0  0  0  0  0 56  0
 0 37  0  1  0  0  0 73  0
 0 38  0  0  0  0  0 72  0
 0 43 44 47 48 51 76 77  0
 0  0  0  0  0  0  0  0  0
EOSHLPsolver.new(board2).solve"
"require 'HLPsolver' ADJACENT = [[-3, 0], [0, -3], [0, 3], [3, 0], [-2, -2], [-2, 2], [2, -2], [2, 2]] board1 = <<EOS
. 0 0 . 0 0 .
0 0 0 0 0 0 0
0 0 0 0 0 0 0
. 0 0 0 0 0 .
. . 0 0 0 . .
. . . 1 . . .
EOSt0 = Time.nowHLPsolver.new(board1).solveputs strv"
" 
#

require 'HLPSolver'ADJACENT = [[0,0]]A,B,C,D,E,F,G,H = [0,1],[0,2],[1,0],[1,1],[1,2],[1,3],[2,1],[2,2] board1 = <<EOS
  . 0 0 .
  0 0 1 0 
  . 0 0 .
 
EOSg = HLPsolver.new(board1)g.board[A[0]][A[1]].adj = [B,G,H,F]            g.board[B[0]][B[1]].adj = [A,C,G,H]            g.board[C[0]][C[1]].adj = [B,E,F,H]          g.board[D[0]][D[1]].adj = [F]                g.board[E[0]][E[1]].adj = [C]                g.board[F[0]][F[1]].adj = [A,C,D,G]          g.board[G[0]][G[1]].adj = [A,B,F,H]            g.board[H[0]][H[1]].adj = [A,B,C,G]            g.solve "
"require 'socket'sock = TCPSocket.open(strv, 256)sock.write(strv)sock.closevar host = Socket.gethostbyname('localhost');var in = Socket.sockaddr_in(256, host);var proto = Socket.getprotobyname('tcp'); var sock = Socket.open(Socket.AF_INET, Socket.SOCK_STREAM, proto);sock.connect(in);sock.send('hello socket world', 0, in);sock.close;"
"require 'set' class Sokoban  def initialize(level)    board = level.each_line.map(&:rstrip)    @nrows = board.map(&:size).max    board.map!{|line| line.ljust(@nrows)}    board.each_with_index do |row, r|      row.each_char.with_index do |ch, c|        @px, @py = c, r  if ch == '@' or ch == '+'      end    end    @goal = board.join.tr(' .@#$+*', ' .   ..')                 .each_char.with_index.select{|ch, c| ch == '.'}                 .map(&:last)    @board = board.join.tr(' .@#$+*', '  @#$ $')  end   def pos(x, y)    y * @nrows + x  end   def push(x, y, dx, dy, board)         
    return  if board[pos(x+2*dx, y+2*dy)] != ' '    board[pos(x     , y     )] = ' '    board[pos(x + dx, y + dy)] = '@'    board[pos(x+2*dx, y+2*dy)] = '$'  end   def solved?(board)    @goal.all?{|i| board[i] == '$'}  end   DIRS = [[0, -1, 'u', 'U'], [ 1, 0, 'r', 'R'], [0,  1, 'd', 'D'], [-1, 0, 'l', 'L']]  def solve    queue = [[@board, strv, @px, @py]]    visited = Set[@board]     until queue.empty?      current, csol, x, y = queue.shift       for dx, dy, cmove, cpush in DIRS        work = current.dup        case work[pos(x+dx, y+dy)]      
        when '$'          next  unless push(x, y, dx, dy, work)          next  unless visited.add?(work)          return csol+cpush  if solved?(work)          queue << [work, csol+cpush, x+dx, y+dy]        when ' '          work[pos(x, y)]       = ' '          work[pos(x+dx, y+dy)] = '@'          queue << [work, csol+cmove, x+dx, y+dy]  if visited.add?(work)        end      end    end    strv  endendlevel = <<EOS
#######




#. #  #
#. $$ #
#.$$  #
#.#  @#
#######
EOSputs level, strv, Sokoban.new(level).solveclass Sokoban  def initialize(level)    board = level.lines.map(&:rstrip)    leng  = board.map(&:length).max    board = board.map{|line| line.ljust(leng)}.join    @goal = []    board.each_char.with_index do |c, i|      @player = i  if c == '@' or c == '+'      @goal << i   if c == '.' or c == '+' or c == '*'    end    @board = board.tr(' .@#$+*', '  @#$ $')    @lurd = [[-1, 'l', 'L'], [-leng, 'u', 'U'], [1, 'r', 'R'], [leng, 'd', 'D']]    @dirs = @lurd.map(&:first)    set_dead_zone(board.tr('^#', ' '))  end   def set_dead_zone(wall)    corner = search_corner(wall)    @dead = corner.dup    begin      size = @dead.size      corner.each do |pos|        @dirs.each do |dir|          next  if wall[pos + dir] == '#'          @dead.concat(check_side(wall, pos+dir, dir))        end      end    end until size == @dead.size  end   def search_corner(wall)    wall.size.times.with_object([]) do |i, corner|      next  if wall[i] == '#' or @goal.include?(i)      case count_wall(wall, i)      when 2        corner << i  if wall[i-1] != wall[i+1]      when 3        corner << i      end    end  end   def check_side(wall, pos, dir)    wk = []    until wall[pos] == '#' or count_wall(wall, pos) == 0 or @goal.include?(pos)      return wk if @dead.include?(pos)      wk << pos      pos += dir    end    []  end   def count_wall(wall, pos)    @dirs.count{|dir| wall[pos + dir] == '#'}  end   def push_box(pos, dir, board)    return board  if board[pos + 2*dir] != ' '    board[pos        ] = ' '    board[pos +   dir] = '@'    board[pos + 2*dir] = '$'    board  end   def solved?(board)    @goal.all?{|i| board[i] == '$'}  end   def solve    queue = [[@board, strv, @player]]    
    visited = Hash.new{|h,k| h[k]=true; false}    visited[@board]                     
     until queue.empty?      board, route, pos = queue.shift      @lurd.each do |dir, move, push|        work = board.dup        case work[pos+dir]        when '$'    
          work = push_box(pos, dir, work)          next  if visited[work]          return route+push  if solved?(work)          queue << [work, route+push, pos+dir]  unless @dead.include?(pos+2*dir)        when ' '    
          work[pos    ] = ' '          work[pos+dir] = '@'          next  if visited[work]          queue << [work, route+move, pos+dir]        end      end    end    strv  endend"
"require 'HLPsolver' ADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]] boardy = <<EOS
. . 0 0 0
. . 0 . 0 0
. 0 0 0 0 0 0 0
0 0 0 . . 0 . 0
0 . 0 . . 0 0 0
1 0 0 0 0 0 0
. . 0 0 . 0
. . . 0 0 0
EOSt0 = Time.nowHLPsolver.new(boardy).solveputs strv"
require 'soap/wsdlDriver' wsdl = SOAP::WSDLDriverFactory.new(strv)soap = wsdl.create_rpc_driver response1 = soap.soapFunc(:elementName => strv)puts response1.soapFuncReturn response2 = soap.anotherSoapFunc(:aNumber => 42)puts response2.anotherSoapFuncReturn
"
#class Hidato  Cell = Struct.new(:value, :used, :adj)  ADJUST = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]   def initialize(board, pout=true)    @board = []    board.each_line do |line|      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]    end    @board << []                                
    @board.each_with_index do |row, x|      row.each_with_index do |cell, y|        if cell          @sx, @sy = x, y  if cell.value==1     
          cell.adj = ADJUST.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}        end      end    end    @xmax = @board.size - 1    @ymax = @board.map(&:size).max - 1    @end  = @board.flatten.compact.size    puts to_s('Problem:')  if pout  end   def solve    @zbl = Array.new(@end+1, false)    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : strv)  end   def try(cell, seq_num)    return true  if seq_num > @end    return false if cell.used    value = cell.value    return false if value > 0 and value != seq_num    return false if value == 0 and @zbl[seq_num]    cell.used = true    cell.adj.each do |x, y|      if try(@board[x][y], seq_num+1)        cell.value = seq_num        return true      end    end    cell.used = false  end   def to_s(msg=nil)    str = (0...@xmax).map do |x|      (0...@ymax).map{|y| strv % (([x][y]) ? c.value : c)}.join    end    (msg ? [msg] : []) + str + [strv]  endend
board1 = <<EOS
  .  4
  0  7  0
  1  0  0
EOSHidato.new(board1).solve 
board2 = <<EOS
  0 33 35  0  0
  0  0 24 22  0
  0  0  0 21  0  0
  0 26  0 13 40 11
 27  0  0  0  9  0  1
  .  .  0  0 18  0  0
  .  .  .  .  0  7  0  0
  .  .  .  .  .  .  5  0
EOSHidato.new(board2).solve 
board3 = <<EOS
  1  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  . 74
  .  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .
  .  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .
EOSt0 = Time.nowHidato.new(board3).solveputs strv
#class HLPsolver  attr_reader :board  Cell = Struct.new(:value, :used, :adj)   def initialize(board, pout=true)    @board = []    frame = ADJACENT.flatten.map(&:abs).max    board.each_line do |line|      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]*frame    end    frame.times {@board << []}                  
    @board.each_with_index do |row, x|      row.each_with_index do |cell, y|        if cell          @sx, @sy = x, y  if cell.value==1     
          cell.adj = ADJACENT.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}        end      end    end    @xmax = @board.size - frame    @ymax = @board.map(&:size).max - frame    @end  = @board.flatten.compact.size    @format = "" _s.size}s""    puts to_s('Problem:')  if pout  end   def solve    @zbl = Array.new(@end+1, false)    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : strv)  end   def try(cell, seq_num)    value = cell.value    return false if value > 0 and value != seq_num    return false if value == 0 and @zbl[seq_num]    cell.used = true    if seq_num == @end      cell.value = seq_num      return true    end    a = []    cell.adj.each_with_index do |(x, y), n|      cl = @board[x][y]      a << [wdof(cl.adj)*10+n, x, y]  unless cl.used    end    a.sort.each do |key, x, y|      if try(@board[x][y], seq_num+1)        cell.value = seq_num        return true      end    end    cell.used = false  end   def wdof(adj)    adj.count {|x,y| not @board[x][y].used}  end   def to_s(msg=nil)    str = (0...@xmax).map do |x|      (0...@ymax).map{|y| @format % (([x][y]) ? c.value : c)}.join    end    (msg ? [msg] : []) + str + [strv]  endendrequire 'HLPsolver' ADJACENT = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]] 
board1 = <<EOS
  .  4
  0  7  0
  1  0  0
EOSHLPsolver.new(board1).solve boardx = <<EOS
  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0
  0  1  0  0  0  0  0  0
  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0
  0  0  0  0  0  0  0  0
EOSHLPsolver.new(boardx).solve 
board2 = <<EOS
  0 33 35  0  0
  0  0 24 22  0
  0  0  0 21  0  0
  0 26  0 13 40 11
 27  0  0  0  9  0  1
  .  .  0  0 18  0  0
  .  .  .  .  0  7  0  0
  .  .  .  .  .  .  5  0
EOSHLPsolver.new(board2).solve #solve The Snake in the Grass:board3 = <<EOS
  1  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  . 74
  .  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .  0  .
  .  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .  .  0  0  .
EOSt0 = Time.nowHLPsolver.new(board3).solveputs strv"
"require strv class Integer   def smith?    return false if prime?    digits.sum == prime_division.map{|pr,n| pr.digits.sum * n}.sum  end end n   = 10_000res = 1.upto(n).select(&:smith?) puts ""#{res.size} smith numbers below #{n}:
#{res.first(5).join("", strv, strvvar primes = Enumerator({ |callback|    static primes = Hash()    var p = 2    loop {        callback(p)        p = (primes{p} := p.next_prime)    }}) func factors(remainder) {     remainder == 1 && return([remainder])     gather {        primes.each { |factor|            if (factor*factor > remainder) {                take(remainder) if (remainder > 1)                break            }             while (factor.divides(remainder)) {                take(factor)                break if ((remainder /= factor) == 1)            }        }    }} func is_smith_number(n) {    !n.is_prime && (n.digits.sum == factors(n).join.to_i.digits.sum)} var s = range(2, 10_000).grep { is_smith_number(_) }say strvsay strvsay strv"
"seconds = gets.to_fputs strvsleep(seconds) 

puts strvvar sec = read(Number);       
say strv;Sys.sleep(sec);               
#Sys.usleep(sec);             # in microseconds#Sys.nanosleep(sec);          # in nanosecondssay strv;"
"head = ListNode.new(strv, ListNode.new(strv, ListNode.new(strv)))head.insertAfter(strv, strv) 
head.each {|node| print node.value, strv}puts 
current = headbegin  print current.value, strvend while current = current.succputsvar list = 'a':'b':'c':nil;#var list = ['a', ['b', ['c']]];#var list = Pair.new('a', Pair.new('b', Pair.new('c', nil))); for (var l = list; l != nil; l = l[1]) {    say l[0];}"
"class ListNode  attr_accessor :value, :succ   def initialize(value, succ=nil)    self.value = value    self.succ = succ  end   def each(&b)    yield self    succ.each(&b) if succ  end   include Enumerable   def self.from_array(ary)    head = self.new(ary[0], nil)    prev = head    ary[1..-1].each do |val|      node = self.new(val, nil)      prev.succ = node      prev = node    end    head  endend list = ListNode.from_array([1,2,3,4])var node = Hash.new(    data => 'say what',    next => foo_node,); node{:next} = bar_node;  
"
"class ListNode  def insert_after(search_value, new_value)    if search_value == value      self.succ = self.class.new(new_value, succ)    elsif self.succ.nil?      raise StandardError, strv    else      self.succ.insert_after(search_value, new_value)    end  endend list = ListNode.new(:a, ListNode.new(:b))list.insert_after(:a, :c)func insert_after(a,b) {    b{:next} = a{:next};    a{:next} = b;} var B = Hash.new(    data => 3,    next => nil,    
);var A = Hash.new(    data => 1,    next => B,);var C = Hash.new(    data => 2,); insert_after(A, C);"
"require 'singleton'class MySingleton   include Singleton   
end a = MySingleton.instance 
b = MySingleton.instanceputs a.equal?(b) 
class Singleton(name) {    static instance;     method new(name) {        instance := Singleton.bless(Hash(:name => name));    }    method new {        Singleton.new(nil);    }} var s1 = Singleton('foo');say s1.name;                #=> 'foo'say s1.object_id;           #=> '30424504' var s2 = Singleton();say s2.name;                #=> 'foo'say s2.object_id;           #=> '30424504' s2.name = 'bar';            
say s1.name;                #=> 'bar'"
"require 'date'require 'json'require 'securerandom' class SimpleDatabase  def initialize(dbname, *fields)    @dbname = dbname    @filename = @dbname + strv    @fields = fields    @maxl = @fields.collect {|f| f.length}.max    @data = {      'fields' => fields,      'items' => {},      'history' => [],      'tags' => {},    }  end  attr_reader :dbname, :fields   def self.open(dbname)    db = new(dbname)    db.read    db  end   def read()    if not File.exists?(@filename)      raise ArgumentError, ""Database  has not been created""    end    @data = JSON.parse(File.read(@filename))    @fields = @data['fields']    @maxl = @fields.collect {|f| f.length}.max  end   def write()    File.open(@filename, 'w') {|f| f.write(JSON.generate(@data))}  end   def add(*values)    id = SecureRandom.uuid    @data['items'][id] = Hash[ @fields.zip(values) ]    @data['history'] << [Time.now.to_f, id]    id  end   def tag(id, *tags)    tags.each do |tag|      if @data['tags'][tag].nil?        @data['tags'][tag] = [id]      else        @data['tags'][tag] << id      end    end    id  end   def latest    @data['history'].sort_by {|val| val[0]}.last.last  end   def get_item(id)    @data['items'][id]  end   def tags()    @data['tags'].keys.sort  end   def ids_for_tag(tag)    @data['tags'][tag]  end   def tags_for_id(id)    @data['tags'].keys.inject([]) do |tags, tag|       tags << tag if @data['tags'][tag].include?(id)      tags    end  end   def display(id)    item = get_item(id)    fmt = ""}s - %s""    puts fmt % ['id', id]    @fields.each {|f| print fmt % [f, item[f]]}    puts fmt % ['tags', tags_for_id(id).join(',')]    added = @data['history'].find {|x| x[1] == id}.first    puts fmt % ['date added', Time.at(added).ctime]    puts strv  end   def each()    @data['history'].each {|time, id| yield id}  end   def each_item_with_tag(tag)    @data['tags'][tag].each {|id| yield id}  endenddef usage()  puts <<END
usage: #{$0} command args ...
 
commands:
  help 
  create dbname field ...
  fields dbname
  add dbname value ...
  tag dbname id tag ...
  tags dbname
  list dbname [tag ...]
  latest dbname
  latest_by_tag dbname
ENDend def open_database(args)  dbname = args.shift  begin    SimpleDatabase.open(dbname)  rescue ArgumentError => e    STDERR.puts e.message    exit 1  endend def process_command_line(command, *args)  case command  when 'help'    usage   when 'create'    db = SimpleDatabase.new(*args)    db.write    puts strv   when 'fields'    db = open_database(args)    puts strv    puts db.fields.join(',')   when 'add'    db = open_database(args)    id = db.add(*args)    db.write    puts strv   when 'tag'    db = open_database(args)    id = args.shift    db.tag(id, *args)    db.write    db.display(id)   when 'tags'    db = open_database(args)    puts strv    puts db.tags.join(',')   when 'list'    db = open_database(args)    if args.empty?      db.each {|id| db.display(id)}    else      args.each do |tag|         puts strv        db.each_item_with_tag(tag) {|id| db.display(id)}      end    end   when 'latest'    db = open_database(args)    db.display(db.latest)   when 'latest_by_tag'    db = open_database(args)    db.tags.each do |tag|      puts tag      db.display(db.ids_for_tag(tag).last)    end   else    puts strv    usage  endend process_command_line *ARGV"
"require 'tk'str = TkVariable.new(strv)count = 0root = TkRoot.newTkLabel.new(root, strv => str).packTkButton.new(root) do  text strv  command {str.value = count += 1}  packendTk.mainloopShoes.app do  stack do    @count = 0    @label = para strv    button strv do       @count += 1      @label.text = ""click: ""    end  endendrequire('Gtk2') -> init 
var window = %s<Gtk2::Window>.newwindow.signal_connect('destroy' => { %s<Gtk2>.main_quit }) 
var vbox = %s<Gtk2::VBox>.new(0, 0)window.add(vbox) 
var label = %s<Gtk2::Label>.new('There have been no clicks yet.')vbox.add(label) 
var count = 0var button = %s<Gtk2::Button>.new(' Click Me ')vbox.add(button)button.signal_connect('clicked' => {    label.set_text(++count)}) 
window.show_all 
%s<Gtk2>.main"
"Shoes.app(:height=>540,:width=>540, :title=>strv) do  def triangle(slot, tri, color)    x, y, len = tri    slot.append do      fill color      shape do        move_to(x,y)        dx = len * Math::cos(Math::PI/3)        dy = len * Math::sin(Math::PI/3)        line_to(x-dx, y+dy)        line_to(x+dx, y+dy)        line_to(x,y)      end    end  end  @s = stack(:width => 520, :height => 520) {}  @s.move(10,10)   length = 512  @triangles = [[length/2,0,length]]  triangle(@s, @triangles[0], rgb(0,0,0))   @n = 1  animate(1) do    if @n <= 7      @triangles = @triangles.inject([]) do |sum, (x, y, len)|        dx = len/2 * Math::cos(Math::PI/3)        dy = len/2 * Math::sin(Math::PI/3)        triangle(@s, [x, y+2*dy, -len/2], rgb(255,255,255))        sum += [[x, y, len/2], [x-dx, y+dy, len/2], [x+dx, y+dy, len/2]]      end    end    @n += 1  end   keypress do |key|    case key    when :control_q, ""11"" then exit    end  endendfunc sierpinski_triangle(n) -> Array {  var triangle = ['*']  { |i|    var sp = (' ' * Math.pow(2, i-1));    triangle = (triangle.map {|x| sp + x + sp} +                triangle.map {|x| x + ' ' + x})  } * n  triangle} class Array {  method to_png(scale=1, bgcolor='white', fgcolor='black') {     static gd = require('GD::Simple')    var width = self.max_by{.len}.len    self.map!{|r| strv % r}     var img = gd.new(width * scale, self.len * scale)     for i in ^self {      for j in RangeNum(i*scale, i*scale + scale) {        img.moveTo(0, j)        for line in (self[i].scan(/(\s+|\S+)/)) {          img.fgcolor(line.contains(/\S/) ? fgcolor : bgcolor)          img.line(scale * line.len)        }      }    }    img.png  }} var triangle = sierpinski_triangle(8)var raw_png = triangle.to_png(bgcolor:'black', fgcolor:'red')File('triangle.png').write(raw_png, :raw)"
"require 'lcs' def scs(u, v)  lcs = lcs(u, v)  u, v = u.dup, v.dup  scs = strv  
  until lcs.empty?    if u[0]==lcs[0] and v[0]==lcs[0]      
      scs << lcs.slice!(0)      u.slice!(0)      v.slice!(0)    elsif u[0]==lcs[0]      
      scs << v.slice!(0)    else      
      scs << u.slice!(0)    end  end  
  scs + u + vend u = strvv = strvputs strvfunc scs(u, v) {    var ls = lcs(u, v).chars    var pat = Regex('(.*)'+ls.join('(.*)')+'(.*)')    u.scan!(pat)    v.scan!(pat)    var ss = (u.shift + v.shift)    ls.each { |c| ss += (c + u.shift + v.shift) }    return ss} say scs(strv, strv)"
"ruby -le'16.times{|y|printstrv}}'def sierpinski_triangle(n)  triangle = [strv]  n.times do |i|    sp = strv * (2**i)    triangle = triangle.collect {|x| sp + x + sp} +               triangle.collect {|x| x + strv + x}  end  triangleend puts sierpinski_triangle(4)def sierpinski_triangle(n)  (0...n).inject([strv]) {|triangle, i|     space = strv * (2**i)    triangle.map {|x| space + x + space} + triangle.map {|x| x + strv + x}  }end puts sierpinski_triangle(4)func sierpinski_triangle(n) {    var triangle = ['*'];    { |i|        var sp = (' ' * Math.pow(2, i-1));        triangle = (triangle.map {|x| sp + x + sp} +                    triangle.map {|x| x + ' ' + x});    } * n;    triangle.join("""");} say sierpinski_triangle(4);"
"def eratosthenes(n)  nums = [nil, nil, *2..n]  (2..Math.sqrt(n)).each do |i|    (i**2..n).step(i){|m| nums[m] = nil}  if nums[i]  end  nums.compactend p eratosthenes(100)def eratosthenes2(n)  
  
  nums = [true, false, true] * ((n + 5) / 6)  nums[0] = false  
  nums[1] = true   
   
  
  i = 5  until (m = i * i) > n    if nums[i >> 1]      i_times_2 = i << 1      i_times_4 = i << 2      while m <= n        nums[m >> 1] = false        m += i_times_2        nums[m >> 1] = false        m += i_times_4  
      end    end    i += 2    if nums[i >> 1]      m = i * i      i_times_2 = i << 1      i_times_4 = i << 2      while m <= n        nums[m >> 1] = false        m += i_times_4  
        nums[m >> 1] = false        m += i_times_2      end    end    i += 4  end   primes = [2]  nums.each_index {|i| primes << (i * 2 + 1) if nums[i]}  primes.pop while primes.last > n  primesend p eratosthenes2(100)require 'benchmark'Benchmark.bmbm {|x|  x.report(strv) { eratosthenes(1_000_000) }  x.report(strv) { eratosthenes2(1_000_000) }}require 'prime'p Prime::EratosthenesGenerator.new.take_while {|i| i <= 100}func sieve(limit) {    var sieve_arr = [false, false, [true]*(limit-1)...]    gather {        sieve_arr.each_kv { |number, is_prime|            if (is_prime) {                take(number)                number.sqr.to(limit).by(number).each { |i|                    sieve_arr[i] = false                }            }        }    }} say sieve(100).join(strv)"
irb(main):001:0> Time.at(0).utc=> 1970-01-01 00:00:00 UTCsay Time.new(0).gmtime.ctime;
"def sierpinski_carpet(n)  carpet = [strv]  n.times do    carpet = carpet.collect {|x| x + x + x} +             carpet.collect {|x| x + x.tr(strv,strv) + x} +             carpet.collect {|x| x + x + x}  end  carpetend 4.times{|i| puts ""N=#{i}"", sierpinski_carpet(i)}var c = ['##']3.times {    c = (c.map{|x| x * 3 }             +         c.map{|x| x + ' '*x.len + x } +         c.map{|x| x * 3 })}say c.join("""")"
"require 'digest'puts Digest::SHA1.hexdigest('Rosetta Code')require 'openssl'puts OpenSSL::Digest::SHA1.hexdigest('Rosetta Code')require 'stringio' 

#--

#++def sha1(string)  
  mask = 0xffffffff  s = proc{|n, x| ((x << n) & mask) | (x >> (32 - n))}  f = [    proc {|b, c, d| (b & c) | (b.^(mask) & d)},    proc {|b, c, d| b ^ c ^ d},    proc {|b, c, d| (b & c) | (b & d) | (c & d)},    proc {|b, c, d| b ^ c ^ d},  ].freeze  k = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6].freeze   
  h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]   bit_len = string.size << 3  string += ""80""  while (string.size % 64) != 56    string += """"  end  string = string.force_encoding('ascii-8bit') + [bit_len >> 32, bit_len & mask].pack(strv)   if string.size % 64 != 0    fail strv  end   io = StringIO.new(string)  block = strv   while io.read(64, block)    w = block.unpack(strv)     
    (16..79).each {|t| w[t] = s[1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]]}     a, b, c, d, e = h    t = 0    4.times do |i|      20.times do        temp = (s[5, a] + f[i][b, c, d] + e + w[t] + k[i]) & mask        a, b, c, d, e = temp, a, s[30, b], c, d        t += 1      end    end     [a,b,c,d,e].each_with_index {|x,i| h[i] = (h[i] + x) & mask}  end   h.pack(strv)end if __FILE__ == $0  
  
  [ 'abc',    'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq',    'Rosetta Code',  ].each {|s| printf(""%s:  %s"", s, *sha1(s).unpack('H*'))}endvar sha = frequire('Digest::SHA');say sha.sha1_hex('Rosetta Code');"
require 'digest/sha2'puts Digest::SHA256.hexdigest('Rosetta code')var sha = frequire('Digest::SHA');say sha.sha256_hex('Rosetta code');
% sidef -E strv
"require 'set' tests = [[[:A,:B], [:C,:D]],         [[:A,:B], [:B,:D]],         [[:A,:B], [:C,:D], [:D,:B]],         [[:H,:I,:K], [:A,:B], [:C,:D], [:D,:B], [:F,:G,:H]]]tests.map!{|sets| sets.map(&:to_set)} tests.each do |sets|  until sets.combination(2).none?{|a,b| a.merge(b) && sets.delete(b) if a.intersect?(b)}  end  p setsendfunc consolidate() { [] }func consolidate(this, *those) {    gather {        consolidate(those...).each { |that|            if (this & that) { this |= that }            else             { take that }        }        take this;    }} enum |A=strv, B, C, D, _E, F, G, H, I, _J, K|; func format(ss) {    ss.map{ '(' + .join(' ') + ')' }.join(' ')} [    [[A,B], [C,D]],    [[A,B], [B,D]],    [[A,B], [C,D], [D,B]],    [[H,I,K], [A,B], [C,D], [D,B], [F,G,H]]].each { |ss|    say (format(ss), ""==> "", format(consolidate(ss...)));}"
"def a( bool )  puts strv  boolend def b( bool )  puts strv  boolend  [true, false].each do |a_val|   [true, false].each do |b_val|     puts strv     puts     puts strv     puts   end endfunc a(bool) { print 'A'; return bool }func b(bool) { print 'B'; return bool } 
func test() {    for op in ['&&', '||'] {        for x,y in [[1,1],[1,0],[0,1],[0,0]] {            strv.printf(x, op, y)            eval strv            print """"        }    }} 
test()"
"require './distcheck.rb' def d5  1 + rand(5)end def d7  loop do    d55 = 5*d5 + d5 - 6    return (d55 % 7 + 1) if d55 < 21  endend distcheck(1_000_000) {d5}distcheck(1_000_000) {d7}func dice5 { 1 + 5.rand.int } func dice7 {  loop {    var d7 = ((5*dice5() + dice5() - 6) % 8);    d7 && return d7;  }} var count7 = Hash.new; var n = 1e6;n.times { count7{dice7()} := 0 ++ }count7.keys.sort.each { |k|    printf(""%s: %5.2f%%"", k, 100*(count7{k}/n * 7 - 1));}"
"class Rset  Set = Struct.new(:lo, :hi, :inc_lo, :inc_hi) do    def include?(x)      (inc_lo ? lo<=x : lo<x) and (inc_hi ? x<=hi : x<hi)    end    def length      hi - lo    end    def to_s      strv    end  end   def initialize(lo=nil, hi=nil, inc_lo=false, inc_hi=false)    if lo.nil? and hi.nil?      @sets = []            
    else      raise TypeError      unless lo.is_a?(Numeric) and hi.is_a?(Numeric)      raise ArgumentError  unless valid?(lo, hi, inc_lo, inc_hi)      @sets = [Set[lo, hi, !!inc_lo, !!inc_hi]]         # !! -> Boolean values    end  end   def self.[](lo, hi, inc_hi=true)    self.new(lo, hi, true, inc_hi)  end   def self.parse(str)    raise ArgumentError  unless str =~ /(\[|\()(.+),(.+)(\]|\))/    b0, lo, hi, b1 = $~.captures        
    lo = Rational(lo)    lo = lo.numerator  if lo.denominator == 1    hi = Rational(hi)    hi = hi.numerator  if hi.denominator == 1    self.new(lo, hi, b0=='[', b1==']')  end   def initialize_copy(obj)    super    @sets = @sets.map(&:dup)  end   def include?(x)    @sets.any?{|set| set.include?(x)}  end   def empty?    @sets.empty?  end   def union(other)    sets = (@sets+other.sets).map(&:dup).sort_by{|set| [set.lo, set.hi]}    work = []    pre = sets.shift    sets.each do |post|      if valid?(pre.hi, post.lo, !pre.inc_hi, !post.inc_lo)        work << pre        pre = post      else        pre.inc_lo |= post.inc_lo  if pre.lo == post.lo        if pre.hi < post.hi          pre.hi = post.hi          pre.inc_hi = post.inc_hi        elsif pre.hi == post.hi          pre.inc_hi |= post.inc_hi        end      end    end    work << pre  if pre    new_Rset(work)  end  alias | union   def intersection(other)    sets = @sets.map(&:dup)    work = []    other.sets.each do |oset|      sets.each do |set|        if set.hi < oset.lo or oset.hi < set.lo          
        elsif oset.lo < set.lo and set.hi < oset.hi          work << set        else          lo = [set.lo, oset.lo].max          if set.lo == oset.lo            inc_lo = set.inc_lo && oset.inc_lo          else            inc_lo = (set.lo < oset.lo) ? oset.inc_lo : set.inc_lo          end          hi = [set.hi, oset.hi].min          if set.hi == oset.hi            inc_hi = set.inc_hi && oset.inc_hi          else            inc_hi = (set.hi < oset.hi) ? set.inc_hi : oset.inc_hi          end          work << Set[lo, hi, inc_lo, inc_hi]  if valid?(lo, hi, inc_lo, inc_hi)        end      end    end    new_Rset(work)  end  alias & intersection   def difference(other)    sets = @sets.map(&:dup)    other.sets.each do |oset|      work = []      sets.each do |set|        if set.hi < oset.lo or oset.hi < set.lo          work << set        elsif oset.lo < set.lo and set.hi < oset.hi          
        else          if set.lo < oset.lo            inc_hi = (set.hi==oset.lo and !set.inc_hi) ? false : !oset.inc_lo            work << Set[set.lo, oset.lo, set.inc_lo, inc_hi]          elsif valid?(set.lo, oset.lo, set.inc_lo, !oset.inc_lo)            work << Set[set.lo, set.lo, true, true]          end          if oset.hi < set.hi            inc_lo = (oset.hi==set.lo and !set.inc_lo) ? false : !oset.inc_hi            work << Set[oset.hi, set.hi, inc_lo, set.inc_hi]          elsif valid?(oset.hi, set.hi, !oset.inc_hi, set.inc_hi)            work << Set[set.hi, set.hi, true, true]          end        end      end      sets = work    end    new_Rset(sets)  end  alias - difference   
  def ^(other)    (self - other) | (other - self)  end   def ==(other)    self.class == other.class and @sets == other.sets  end   def length    @sets.inject(0){|len, set| len + set.length}  end   def to_s    ""}""  end  alias inspect to_s   protected   attr_accessor :sets   private   def new_Rset(sets)    rset = self.class.new          
    rset.sets = sets    rset  end   def valid?(lo, hi, inc_lo, inc_hi)    lo < hi or (lo==hi and inc_lo and inc_hi)  endend def Rset(lo, hi, inc_hi=false)  Rset.new(lo, hi, false, inc_hi)endp a = Rset[1,2,false][1,2,3].each{|x|puts strv}putsa = Rset[0,2,false]             #=> Rset[0,2)b = Rset(1,3)                   #=> Rset(1,3)c = Rset[0,1,false]             #=> Rset[0,1)d = Rset(2,3,true)              #=> Rset(2,3]puts strvputs strvputsputs strvputs strvputs strvputsputs strvputs strve = Rset(0,3,true)f = Rset[1,2]puts strv puts ""Test :""test_set = [[strv, strv, strv],            [strv, strv, strv],            [strv, strv, strv],            [strv, strv, strv] ] test_set.each do |sa,ope,sb|  str = strv  e = eval(strv)  puts strv % [str, e]  (0..2).each{|i| puts strv}end putstest_set = [strv,            strv,            strv, strv, strv, strv, strv,            strv]x = y = niltest_set.each {|str| puts strv} putsinf = 1.0 / 0.0             
puts strvputs strvputs strvstr, e = strv, nilputs ""#{str} -> #{eval(str)}
str = strvputs strvputs include Mathlohi = Enumerator.new do |y|  t = 1 / sqrt(6)  0.step do |n|    y << [sqrt(12*n+1) * t, sqrt(12*n+5) * t]    y << [sqrt(12*n+7) * t, sqrt(12*n+11) * t]  endend a = Rset.newloop do  lo, hi = lohi.next  break  if 10 <= lo  a |= Rset(lo, hi)enda &= Rset(0,10) b = (0...10).inject(Rset.new){|res,i| res |= Rset(i+1/6r,i+5/6r)} puts strvputs strvputs strvputs strvputs strvputs strv"
"COLORS   = %i(red green purple) #use [:red, :green, :purple] in Ruby < 2.0SYMBOLS  = %i(oval squiggle diamond)NUMBERS  = %i(one two three)SHADINGS = %i(solid open striped)DECK = COLORS.product(SYMBOLS, NUMBERS, SHADINGS) def get_all_sets(hand)   hand.combination(3).select do |candidate|    grouped_features = candidate.flatten.group_by{|f| f}    grouped_features.values.none?{|v| v.size == 2}  endend def get_puzzle_and_answer(hand_size, num_sets_goal)  begin    hand = DECK.sample(hand_size)    sets = get_all_sets(hand)  end until sets.size == num_sets_goal  [hand, sets]end def print_cards(cards)  puts cards.map{|card| strv * 4 % card}  putsend def set_puzzle(deal, goal=deal/2)  puzzle, sets = get_puzzle_and_answer(deal, goal)  puts strv  print_cards(puzzle)  puts strv  sets.each{|set| print_cards(set)}end set_puzzle(9)set_puzzle(12)"
"require strv pg = Prime::TrialDivisionGenerator.newp pg.take(10) 
p pg.next 
func prime_seq(amount, callback) {    var (counter, number) = (0, 0);    while (counter < amount) {        if (is_prime(number)) {            callback(number);            ++counter;        }        ++number;    }} prime_seq(100, {|p| say p});     
"
">> require 'set'=> true>> s1, s2 = Set[1, 2, 3, 4], [3, 4, 5, 6].to_set 
=> [#<Set: {1, 2, 3, 4}>, #<Set: {5, 6, 3, 4}>]>> s1 | s2 
=> #<Set: {5, 6, 1, 2, 3, 4}>>> s1 & s2 
=> #<Set: {3, 4}>>> s1 - s2 
=> #<Set: {1, 2}>>> s1.proper_subset?(s1) 
=> false>> Set[3, 1].proper_subset?(s1) 
=> true>> s1.subset?(s1) 
=> true>> Set[3, 1].subset?(s1) 
=> true>> Set[3, 2, 4, 1] == s1 
=> true>> s1 == s2 
=> false>> s1.include?(2) 
=> true>> Set[1, 2, 3, 4, 5].proper_superset?(s1) 
=> true>> Set[1, 2, 3, 4].proper_superset?(s1) 
=> false>> Set[1, 2, 3, 4].superset?(s1) 
=> true>> s1 ^ s2 
=> #<Set: {5, 6, 1, 2}>>> s1.size 
=> 4>> s1 << 99 
=> #<Set: {99, 1, 2, 3, 4}>>> s1.delete(99) 
=> #<Set: {1, 2, 3, 4}>>> s1.merge(s2) 
=> #<Set: {5, 6, 1, 2, 3, 4}>>> s1.subtract(s2) 
=> #<Set: {1, 2}>>> class Set(*set) {     method init {        var elems = set;        set = Hash.new;        elems.each { |e| self += e }    }     method +(elem) {        set{elem} = elem;        self;    }     method del(elem) {        set.delete(elem);    }     method has(elem) {        set.has_key(elem);    }     method ∪(Set that) {        Set(set.values..., that.values...);    }     method ∩(Set that) {        Set(set.keys.grep{ |k| k ∈ that } \                    .map { |k| set{k} }...);    }     method ∖(Set that) {        Set(set.keys.grep{|k| !(k ∈ that) } \                    .map {|k| set{k} }...);    }     method ^(Set that) {        var d = ((self ∖ that) ∪ (that ∖ self));        Set(d.values...);    }     method count { set.len }     method ≡(Set that) {        (self ∖ that -> count.is_zero) && (that ∖ self -> count.is_zero);    }     method values { set.values }     method ⊆(Set that) {        that.set.keys.each { |k|            k ∈ self || return false;        }        return true;    }     method to_s {        strv + set.values.map{|e| strv}.sort.join(', ') + strv    }} class Object {    method ∈(Set set) {        set.has(self);    }}var x = Set(1, 2, 3);5..7 -> each { |i| x += i }; var y = Set(1, 2, 4, x); say strv;say strv; [1,2,3,4,x].each { |elem|    say (strv, elem ∈ y ? '' : 'not', strv);} var (w, z);say (strv, x ∪ y);say (strv, x ∩ y);say (strv, z = (x ∖ y) );say (strv, x ⊆ y ? strv : strv, strv);say (strv, x ⊆ z ? strv : strv, strv);say (strv, z = ((x ∪ y) ∖ (x ∩ y)));say (strv, w = (x ^ y));say (strv, w ≡ z ? strv : strv, strv);say (strv, w ≡ x ? strv : strv, strv);"
"require 'base64'require 'net/smtp'require 'tmail'require 'mime/types' class Email  def initialize(from, to, subject, body, options={})    @opts = {:attachments => [], :server => 'localhost'}.update(options)    @msg = TMail::Mail.new    @msg.from    = from    @msg.to      = to    @msg.subject = subject    @msg.cc      = @opts[:cc]  if @opts[:cc]    @msg.bcc     = @opts[:bcc] if @opts[:bcc]     if @opts[:attachments].empty?      
      @msg.body = body    else      
      @msg.body = ""This is a multi-part message in MIME format.""       msg_body = TMail::Mail.new      msg_body.body = body      msg_body.set_content_type(strv,strv, {:charset => strv})      @msg.parts << msg_body       octet_stream = MIME::Types['application/octet-stream'].first       @opts[:attachments].select {|file| File.readable?(file)}.each do |file|        mime_type = MIME::Types.type_for(file).first || octet_stream        @msg.parts << create_attachment(file, mime_type)      end    end  end  attr_reader :msg   def create_attachment(file, mime_type)    attach = TMail::Mail.new    if mime_type.binary?      attach.body = Base64.encode64(File.read(file))      attach.transfer_encoding = 'base64'    else      attach.body = File.read(file)    end    attach.set_disposition(strv, {:filename => file})    attach.set_content_type(mime_type.media_type, mime_type.sub_type, {:name=>file})    attach  end   
  def send    args = @opts.values_at(:server, :port, :helo, :username, :password, :authtype)    Net::SMTP.start(*args) do |smtp|      smtp.send_message(@msg.to_s, @msg.from[0], @msg.to)    end  end   
  def self.send(*args)    self.new(*args).send  endend Email.send(  'sender@sender.invalid',  %w{ recip1@recipient.invalid recip2@example.com },  'the subject',  ""the bodyhas lines"",  {    :attachments => %w{ file1 file2 file3 },    :server => 'mail.example.com',    :helo => 'sender.invalid',    :username => 'user',    :password => 'secret'  })"
"class Example  def foo    42  end  def bar(arg1, arg2, &block)    block.call arg1, arg2  endend symbol = :fooExample.new.send symbol                         
Example.new.send( :bar, 1, 2 ) { |x,y| x+y }    
args = [1, 2]Example.new.send( strv, *args ) { |x,y| x+y }  
class Example  private  def privacy; strv; end  public  def publicity; strv; endend e = Example.newe.public_send :publicity  
e.public_send :privacy    
e.send :privacy           
class Example {    method foo(x) {        42 + x    }} var name = 'foo'var obj = Example() say obj.(name)(5)          
say obj.method(name)(5)    
"
"def f(n)  n + (0.5 + Math.sqrt(n)).floorend (1..22).each { |n| puts strv } non_squares = (1..1_000_000).map { |n| f(n) }squares = (1..1001).map { |n| n**2 } 
(squares & non_squares).each do |n|  puts strvendfunc nonsqr(n) { 0.5 + n.sqrt -> floor + n }22.of {|i| nonsqr(i)}.join(' ').say { |i|  if (nonsqr(i).is_sqr) {     die strv  }} * 1e6"
"require 'prime'
 class Integer  def semi_prime?    prime_division.map( &:last ).inject( &:+ ) == 2  endend p 1679.semi_prime? 
p ( 1..100 ).select( &:semi_prime? )
 require('ntheory'); func is_semiprime(n) {    static nt = %S'ntheory';    if (var p = [nt.trial_factor(n, 500)]) {        return false if (p.len > 2);        return !!nt.is_prime(p[1]) if (p.len == 2);  }  [nt.factor(n)].len == 2;} say [2,4,99,100,1679,32768,1234567,9876543,900660121].grep{ is_semiprime(_) }"
"dict = File.readlines(strv).collect(&:strip)i = 0res = dict.collect(&:reverse).sort.select do |z|   i += 1  while z > dict[i] and i < dict.length-1  z == dict[i] and z < z.reverseendputs strvres.take(5).each {|z| puts strv}words = File.readlines(strv)            .group_by{|x| [x.strip!, x.reverse].min}            .values            .select{|v| v.size==2}puts strvwords.take(5).each {|a,b| puts strv}var c = 0var seen = Hash() ARGF.each { |line|    line.chomp!    var r = line.reverse    ((seen{r} := 0 ++) && (c++ < 5) && say strv) ->        || (seen{line} := 0 ++)} say c"
"def self_describing?(n)  digits = n.digits.reverse  digits.each_with_index.all?{|digit, idx| digits.count(idx) == digit}end 3_300_000.times {|n| puts n if self_describing?(n)}func sdn(Number n) {    var b = [0]*n.len    var a = n.digits    a.each { |i| b[i] := 0 ++ }    a == b} var values = [1210, 2020, 21200, 3211000,42101000, 521001000, 6210001000, 27, 115508] values.each { |test|    say strv} say ""Self-descriptive numbers less than 1e5 (in base 10):""^1e5 -> each { |i| say i if sdn(i) }for b in (7 .. 36) {    var n = ((b-4) * b**(b-1) + 2*(b**(b-2)) + b**(b-3) + b**3 -> base(b))    say strv}"
"irb(main):001:0> require 'tempfile'=> trueirb(main):002:0> f = Tempfile.new('foo')=> #<File:/tmp/foo20081226-307-10p746n-0>irb(main):003:0> f.path=> strvirb(main):004:0> f.close=> nilirb(main):005:0> f.unlink=> #<Tempfile: (closed)>var tmpfile = require('File::Temp');var fh = tmpfile.new(UNLINK => 0);say fh.filename;fh.print(""Hello, World!"");fh.close;"
"$cache = {}def selfReferentialSequence_cached(n, seen = [])  return $cache[n] if $cache.include? n  return [] if seen.include? n   digit_count = Array.new(10, 0)  n.to_s.chars.collect {|char| digit_count[char.to_i] += 1}  term = ''  9.downto(0).each do |d|    if digit_count[d] > 0      term += digit_count[d].to_s + d.to_s    end  end  term = term.to_i  $cache[n] = [n] + selfReferentialSequence_cached(term, [n] + seen)end limit = 1_000_000max_len = 0max_vals = [] 1.upto(limit - 1) do |n|   seq = selfReferentialSequence_cached(n)  if seq.length > max_len    max_len = seq.length    max_vals = [n]  elsif seq.length == max_len    max_vals << n  endend puts strvputs strvputs strvselfReferentialSequence_cached(max_vals[0]).each_with_index do |val, idx|   puts strv % [idx + 1, val]end"
"Sedol_char = strv def char2value(c)  raise ArgumentError, strv unless Sedol_char.include?(c)  c.to_i(36)end Sedolweight = [1,3,1,7,3,9] def checksum(sedol)  raise ArgumentError, strv unless sedol.size == Sedolweight.size  sum = sedol.split('').zip(Sedolweight).map { |ch, weight|            char2value(ch) * weight }.inject(:+)  ((10 - (sum % 10)) % 10).to_send data = %w{          710889          B0YBKJ          406566          B0YBLH          228276          B0YBKL          557910          B0YBKR          585284          B0YBKT          B00030          C0000          1234567          00000A         } for sedol in data  print strv % sedol  begin    puts sedol + checksum(sedol)  rescue => e    p e  endendfunc sedol(s) {     die 'No vowels allowed' if (s ~~ /[AEIOU]/);    die 'Invalid format'    if (s !~ /^[0-9B-DF-HJ-NP-TV-Z]{6}$/);     const base36 = ((@(0..9) + @('A'..'Z')) ~Z @(0..35) -> flatten.to_h);    const weights = [1, 3, 1, 7, 3, 9];     var vs = [base36{ s.chars... }];    var checksum = (vs ~Z* weights -> sum);    var check_digit = ((10 - checksum%10) % 10);    return (s + check_digit);} %w(    710889    B0YBKJ    406566    B0YBLH    228276    B0YBKL    557910    B0YBKR    585284    B0YBKT    B00030).each { |s|    say sedol(s);}"
" def welcome(name)   puts strvendputs strv$name = STDIN.getswelcome($name)return 
func outer {    func inner {};   
} 
class Outer {    class Inner {};  
}"
"cities = [    {name: strv, population: 21},     {name: strv, population: 15.2},     {name: strv, population: 11.3},     {name: strv, population: 7.55},     {name: strv, population: 5.85},     {name: strv, population: 4.98},     {name: strv, population: 4.7},     {name: strv, population: 4.58},     {name: strv, population: 4.4},     {name: strv, population: 3.98},] puts cities.index{|city| city[:name] == strv}      
puts cities.find {|city| city[:population] < 5.0}[:name]      
puts cities.find {|city| city[:name][0] == strv}[:population]  
 struct City {    String name,    Number population,} var cities = [    City(strv, 21),    City(strv, 15.2),    City(strv, 11.3),    City(strv, 7.55),    City(strv, 5.85),    City(strv, 4.98),    City(strv, 4.7),    City(strv, 4.58),    City(strv, 4.4),    City(strv, 3.98),] say cities.index{|city| city.name == strv}say cities.first{|city| city.population < 5.0}.namesay cities.first{|city| city.name.begins_with(strv)}.population"
"require 'bigdecimal'require 'bigdecimal/util'  
 def safe_add(a, b, prec)  a, b = a.to_d, b.to_d  rm = BigDecimal::ROUND_MODE  orig = BigDecimal.mode(rm)   BigDecimal.mode(rm, BigDecimal::ROUND_FLOOR)  low = a.add(b, prec)   BigDecimal.mode(rm, BigDecimal::ROUND_CEILING)  high = a.add(b, prec)   BigDecimal.mode(rm, orig)  low..highend [[strv, strv], [strv, strv], [strv, strv], [strv, strv],].each { |a, b| puts strv }"
"def valid?(sailor, nuts)  sailor.times do    return false if (nuts % sailor) != 1    nuts -= 1 + nuts / sailor  end  nuts > 0 and nuts % sailor == 0end [5,6].each do |sailor|  n = sailor  n += 1 until valid?(sailor, n)  puts ""#{sailor} sailors => #{n} coconuts""  (sailor+1).times do    div, mod = n.divmod(sailor)    puts strv    n -= 1 + div  endenddef coconuts(sailor)  sailor.step(by:sailor) do |nuts|    flag = sailor.times do      break if nuts % (sailor-1) != 0      nuts += nuts / (sailor-1) + 1    end    return nuts if flag  endend (2..9).each do |sailor|  puts strvend def ng (sailors)  def _ng (sailors, iter, start)    n, g = [start], [start/sailors]    (1..iter).each{|s|      g[s],rem = n[s-1].divmod(sailors-1)      rem > 0 ? (return false) : n[s] = g[s]*sailors + 1    }    return [n,g]  end  n, start, step = [], sailors*(sailors-1), 1  (2..sailors).each{|s|    g=0; until n=_ng(sailors,s,start + g*step*sailors*(sailors-1)) do g=g+1 end    start,step = n[0][0], step*(sailors-1)  }  return nend  (3..10).each{|sailors| puts strv; p ng(sailors)}  n = ng(100)(0..100).each{|g| puts strv} func coconuts(sailors, monkeys=1) {    if ((sailors < 2) || (monkeys < 1) || (sailors <= monkeys)) {        return 0    }    var blue_cocos = sailors-1    var pow_bc = blue_cocos**sailors    var x_cocos = pow_bc    while ((x_cocos-blue_cocos)%sailors || ((x_cocos-blue_cocos)/sailors < 1)) {        x_cocos += pow_bc    }    return monkeys*(x_cocos / pow_bc * sailors**sailors - blue_cocos)} 2.to(9).each { |sailor|    say strv;}"
class Demo  #public methods here   protected  #protect methods here   private  #private methodsend
"def bind_x_to_value(x)  bindingend def eval_with_x(code, a, b)  eval(code, bind_x_to_value(b)) - eval(code, bind_x_to_value(a))end puts eval_with_x('2 ** x', 3, 5) 
func eval_with_x(code, x, y) {    var f = eval(code);    x = y;    eval(code) - f;} say eval_with_x(x: 3, y: 5, code: '2 ** x');   
"
"haystack = %w(Zig Zag Wally Ronald Bush Krusty Charlie Bush Bozo) %w(Bush Washington).each do |needle|  if (i = haystack.index(needle))    puts strv  else    raise ""#{needle} is not in haystack""  endendhaystack.each do |item|   last = haystack.rindex(item)  if last > haystack.index(item)    puts strv    break  endend#=> Bush last appears at index 7multi_item = haystack.each_index.group_by{|idx| haystack[idx]}.select{|key, val| val.length > 1}
multi_item.each do |key, val|  puts strvend#=> Bush appears at index [4, 7]var haystack = %w(Zig Zag Wally Ronald Bush Krusty Charlie Bush Bozo); %w(Bush Washington).each { |needle|    var i = haystack.first_index{|item| item == needle};    if (i >= 0) {        say strv;    } else {        die strv;    }}var haystack = %w(Zig Zag Wally Ronald Bush Krusty Charlie Bush Bozo);say haystack.last_index{|item| item == strv};"
"a, b = 5, -7ans = eval strv  
def first(main_var, main_binding)  foo = 42  second [[main_var, main_binding], [strv, binding]]end def second(args)  sqr = lambda {|x| x**2}  deref(args << [strv, binding])end def deref(stuff)  stuff.each do |varname, context|    puts strv  endend hello = strvfirst strv, bindingvar (a, b) = (-5, 7);say eval '(a * b).abs';  
say (a * b -> abs);      
"
" 
def run_encode(string)  string    .chars    .chunk{|i| i}    .map {|kind, array| [kind, array.length]}end 
def run_decode(char_counts)  char_counts    .map{|char, count| char * count}    .joinend  def encode(string)  string.scan(/(.)(\1*)/).collect do |char, repeat|    [1 + repeat.length, char]   end.joinend def decode(string)  string.scan(/(\d+)(\D)/).collect {|length, char| char * length.to_i}.joinenddef encode(string)  string.scan(/(.)(\1*)/).inject(strv) do |encoding, (char, repeat)|    encoding << (1 + repeat.length).to_s << char  endend def decode(string)  string.scan(/(\d+)(\D)/).inject(strv) do |decoding, (length, char)|    decoding << char * length.to_i  endenddef encode(str)    str.gsub(/(.)\1*/) {$&.length.to_s + $1}end def decode(str)    str.gsub(/(\d+)(\D)/) {$2 * $1.to_i}endorig = strvp enc = encode(orig)p dec = decode(enc)puts strv if dec == origfunc encode(str) {  str.gsub(/((.)(\2*))/, {|a,b| strv });} func decode(str) {  str.gsub(/(\d+)(.)/, {|a,b| b * a.to_i });}func encode(str) {    str.gsub(/(.)(\1{0,254})/, {|a,b| b.len+1 -> chr + a});} func decode(str) {     var chars = str.chars;     var r = '';     (chars.len/2 -> int).range.each { |i|         r += (chars[2*i + 1] * chars[2*i].ord);     }     return r;}"
" #!/usr/bin/ruby require 'openssl' 
require 'prime' def rsa_encode blocks, e, n  blocks.map{|b| b.to_bn.mod_exp(e, n).to_i}end def rsa_decode ciphers, d, n  rsa_encode ciphers, d, nend 

def text_to_blocks text, blocksize=64 
  text.each_byte.reduce(strv){|acc,b| acc << b.to_s(16).rjust(2, strv)} 
      .each_char.each_slice(blocksize).to_a                          
      .map{|a| a.join(strv).to_i(16)}                                  
end def blocks_to_text blocks  blocks.map{|d| d.to_s(16)}.join(strv)                                
        .each_char.each_slice(2).to_a                                
	.map{|s| s.join(strv).to_i(16)}                                
	.flatten.pack(strv)                                          
	.force_encoding(Encoding::default_external)                  
end def generate_keys p1, p2  n = p1 * p2  t = (p1 - 1) * (p2 - 1)  e = 2.step.each do |i|    break i if i.gcd(t) == 1  end  d = 1.step.each do |i|    break i if (i * e) % t == 1  end  return e, d, nend p1, p2 = Prime.take(100).last(2)public_key, private_key, modulus =  generate_keys p1, p2 print strvmessage = getsblocks = text_to_blocks message, 4 
print strv; p blocksencoded = rsa_encode(blocks, public_key, modulus)print strv; p encodeddecoded = rsa_decode(encoded, private_key, modulus)print strv; p decodedfinal = blocks_to_text(decoded)print strv; puts final const n = 9516311845790656153499716760847001433441357const e = 65537const d = 5617843187844953170308463622230283376298685 module Message {    var alphabet = [('A' .. 'Z')..., ' ']    var rad = alphabet.len    var code = Hash(^rad -> map {|i| (alphabet[i], i) }...)    func encode(String t) {        [code{t.reverse.chars...}] ~Z* t.len.range.map { |i| rad**i } -> sum(0)    }    func decode(Number n) {        ''.join(alphabet[            gather {                loop {                    var (d, m) = n.divmod(rad)                    take(m)                    break if (n < rad)                    n = d                }            }...]        ).reverse    }} var secret_message = strvsay strv var numeric_message = Message::encode(secret_message)say strv var numeric_cipher = expmod(numeric_message, e, n)say strv var text_cipher = Message::decode(numeric_cipher)say strv var numeric_cipher2 = Message::encode(text_cipher)say strv var numeric_message2 = expmod(numeric_cipher2, d, n)say strv var secret_message2 = Message::decode(numeric_message2)say strv"
"class SExpr  def initialize(str)    @original = str    @data = parse_sexpr(str)  end  attr_reader :data, :original   def to_sexpr    @data.to_sexpr  end   private   def parse_sexpr(str)    state = :token_start    tokens = []    word = strv    str.each_char do |char|      case state       when :token_start        case char        when strv           tokens << :lbr        when strv           tokens << :rbr        when /\s/          
        when  '""'          state = :read_quoted_string          word = strv        else          state = :read_string_or_number          word = char        end       when :read_quoted_string        case char        when '""'          tokens << word          state = :token_start        else          word << char        end       when :read_string_or_number        case char        when /\s/          tokens << symbol_or_number(word)          state = :token_start        when ')'          tokens << symbol_or_number(word)          tokens << :rbr          state = :token_start        else          word << char        end      end    end     sexpr_tokens_to_array(tokens)  end   def symbol_or_number(word)    Integer(word)  rescue ArgumentError    begin       Float(word)    rescue ArgumentError      word.to_sym    end  end   def sexpr_tokens_to_array(tokens, idx = 0)    result = []    while idx < tokens.length      case tokens[idx]      when :lbr        tmp, idx = sexpr_tokens_to_array(tokens, idx + 1)        result << tmp      when :rbr        return [result, idx]      else         result << tokens[idx]      end      idx += 1    end    result[0]  endend class Object  def to_sexpr    self  endend class String  def to_sexpr    self.match(/[\s()]/) ? self.inspect : self  endend class Symbol  alias :to_sexpr :to_send class Array  def to_sexpr    strv % inject([]) {|a, elem| a << elem.to_sexpr}.join(strv)  endend  sexpr = SExpr.new <<END
((data strv 123 4.5)
 (data (!@# (4.5) strv)))
END puts ""original sexpr:#{sexpr.original}""puts ""ruby data structure:#{sexpr.data}""puts ""and back to S-Expr:#{sexpr.to_sexpr}""var t = frequire('Text::Balanced'); func sexpr(txt) {    txt.trim!;     var m = txt.match(/^\((.*)\)$/s) || die strv;    txt = m[0];     var w;    var ret = [];    while (!txt.is_empty) {        given (txt.first) {            when('(') {                (w, txt) = t.extract_bracketed(txt, '()');                w = sexpr(w);            }            when ('""') {                (w, txt) = t.extract_delimited(txt, '""')                w.sub!(/^strv/, {|s1| s1 });            }            default {                txt.sub!(/^(\S+)/, {|s1| w = s1; '' });            }        }        ret << w;        txt.trim_beg!;    }    return ret;} func sexpr2txt(String e) {    e ~~ /[\s""]/ ? do { e.gsub!('""', '\\strv#{e}"") } : e;} func sexpr2txt(expr) {    '(' + expr.map {|e| sexpr2txt(e) }.join(' ') + ')';} var s = sexpr(%q{ ((data strv 123 4.5) (data (!@
 }); say s;              
say sexpr2txt(s);   
"
"def calc_rk4(f)  return ->(t,y,dt){         ->(dy1   ){         ->(dy2   ){         ->(dy3   ){         ->(dy4   ){ ( dy1 + 2*dy2 + 2*dy3 + dy4 ) / 6 }.call(           dt * f.call( t + dt  , y + dy3   ))}.call(           dt * f.call( t + dt/2, y + dy2/2 ))}.call(           dt * f.call( t + dt/2, y + dy1/2 ))}.call(           dt * f.call( t       , y         ))}end TIME_MAXIMUM, WHOLE_TOLERANCE = 10.0, 1.0e-5T_START, Y_START, DT          =  0.0, 1.0, 0.10 def my_diff_eqn(t,y) ; t * Math.sqrt(y)                    ; enddef my_solution(t  ) ; (t**2 + 4)**2 / 16                  ; enddef  find_error(t,y) ; (y - my_solution(t)).abs            ; enddef   is_whole?(t  ) ; (t.round - t).abs < WHOLE_TOLERANCE ; end dy = calc_rk4( ->(t,y){my_diff_eqn(t,y)} ) t, y = T_START, Y_STARTwhile t <= TIME_MAXIMUM  printf(""y(%4.1f)= %12.6f  error: %12.6e"",t,y,find_error(t,y)) if is_whole?(t)  t, y = t + DT, y + dy.call(t,y,DT)endfunc runge_kutta(yp) {    func (t, y, δt) {        var a = (δt * yp(t, y));        var b = (δt * yp(t + δt/2, y + a/2));        var c = (δt * yp(t + δt/2, y + b/2));        var d = (δt * yp(t + δt, y + c));        (a + 2*(b + c) + d) / 6;    }} define δt = 0.1;var δy = runge_kutta(func(t, y) { t * y.sqrt }); var(t, y) = (0, 1);loop {    t.is_int &&        printf(""y(%2d) = %12f ± %e"", t, y, abs(y - ((t**2 + 4)**2 / 16)));    t <= 10 || break;    y += δy(t, y, δt);    t += δt;}"
"require 'rosettacode' langs = []RosettaCode.category_members(strv) {|lang| langs << lang} 

langcount = {}langs.each_slice(20) do |sublist|  url = RosettaCode.get_api_url({    strv => strv,    strv => strv,    strv => strv,    strv => sublist.join(strv),  })   doc = REXML::Document.new open(url)  REXML::XPath.each(doc, strv) do |page|    lang = page.attribute(strv).value    info = REXML::XPath.first(page, strv)    langcount[lang] = info.nil? ? 0 : info.attribute(strv).value.to_i  endend puts Time.nowputs strvputs strvlangcount.sort_by {|key,val| val}.reverse[0,25].each_with_index do |(lang, count), i|  puts strvendrequire('MediaWiki::API') var api = %s<MediaWiki::API>.new(    Hash(api_url => 'http://rosettacode.org/mw/api.php')) var languages = []var gcmcontinueloop {    var apih = api.api(        Hash(            action      => 'query',            generator   => 'categorymembers',            gcmtitle    => 'Category:Programming Languages',            gcmlimit    => 250,            prop        => 'categoryinfo',            gcmcontinue => gcmcontinue,        )    )     languages.append(apih{:query}{:pages}.values...)    gcmcontinue = apih{:continue}{:gcmcontinue}    gcmcontinue || break} languages.each { |lang|    lang{:title} -= /^Category:/    lang{:categoryinfo}{:size} := 0} var sorted_languages = languages.sort_by { |lang|    -lang{:categoryinfo}{:size}} sorted_languages.each_kv { |i, lang|    printf(""%3d. %20s - %3d"", i+1, lang{:title}, lang{:categoryinfo}{:size})}"
"
#text = $stdin.read
text = DATA.readslash_lang = '/lang'langs = %w(foo bar baz) 
for lang in langs  text.gsub!(Regexp.new(strv)) {strv}  text.gsub!(Regexp.new(strv), strv)endtext.gsub!(/<code (.*?)>/, '<lang >')text.gsub!(/<\/code>/, strv)print text __END__Lorem ipsum <code foo>saepe audire</code> elaboraret ne quo, id equidematomorum inciderint usu. <foo>In sit inermis deleniti percipit</foo>,ius ex tale civibus omittam. <barf>Vix ut doctus cetero invenire</barf>, his eualtera electram. Tota adhuc altera te sea, <code bar>soluta appetere ut mel</bar>.Quo quis graecis vivendo te, <baz>posse nullam lobortis ex usu</code>. Eam volumus perpetuaconstituto id, mea an omittam fierent vituperatoribus. var langs = %w(ada cpp-qt pascal lscript z80 visualprologhtml4strict cil objc asm progress teraterm hq9plus genero tsqlemail pic16 tcl apt_sources io apache vhdl avisynth winbatchvbnet ini scilab ocaml-brief sas actionscript3 qbasic perl bnfcobol powershell php kixtart visualfoxpro mirc make javascriptcpp sdlbasic cadlisp php-brief rails verilog xml csharpactionscript nsis bash typoscript freebasic dot applescripthaskell dos oracle8 cfdg glsl lotusscript mpasm latex sql klonecruby ocaml smarty python oracle11 caddcl robots groovy smalltalkdiff fortran cfm lua modula3 vb autoit java text scalalotusformulas pixelbender reg _div whitespace providex asp csslolcode lisp inno mysql plsql matlab oobas vim delphi xorg_confgml prolog bf per scheme mxml d basic4gl m68k gnuplot idl abapintercal c_mac thinbasic java5 xpp boo klonecpp blitzbasic eiffelpovray c gettext).join('|'); var text = ARGF.slurp; text.gsub!(Regex.new('<(' + langs + ')>'), {|s1| strv });text.gsub!(Regex.new('</(' + langs + ')>'), strv + strv);text.gsub!(    Regex.new('<code+(' + langs + ')>(.*?)</code>', 's'),    {|s1,s2| strv + strv}); print text;"
"require strvrequire strv  tasks  = [strv, strv, strv]part_uri  = strvReport = Struct.new(:count, :tasks)result = Hash.new{|h,k| h[k] = Report.new(0, [])} tasks.each do |task|  puts strv  current_lang = strv  open(part_uri + CGI.escape(task)).each_line do |line|    current_lang = Regexp.last_match[strv] if /==\{\{header\|(?<lang>.+)\}\}==/ =~ line     num_no_langs = line.scan(/<lang\s*>/).size    if num_no_langs > 0 then      result[current_lang].count += num_no_langs      result[current_lang].tasks << task    end  endend puts ""#{result.values.map(&:count).inject(&:+)} bare language tags.""result.each{|k,v| puts strv}"
"
def rot13(s)  s.tr('A-Za-z', 'N-ZA-Mn-za-m')end 
while line = ARGF.gets  print rot13(line)end
func rot13(s) {    s.tr('A-Za-z', 'N-ZA-Mn-za-m');} 
STDIN.each { |line| print rot13(line) }"
"require 'rosettacode'require 'time' module RosettaCode  def self.get_unimplemented(lang)    programming_tasks = []    category_members(strv) {|task| programming_tasks << task}     lang_tasks = []    category_members(lang) {|task| lang_tasks << task}     lang_tasks_omit = []    category_members(strv) {|task| lang_tasks_omit << task}     [programming_tasks - lang_tasks, lang_tasks_omit]  end   def self.created_time(title)    url = get_api_url({      strv => strv,      strv => title,      strv => strv,      strv => 500,      strv => strv,      strv => strv    })    doc = REXML::Document.new open(url)    REXML::XPath.each(doc, strv).collect do |node|       Time.parse( node.attribute(strv).value )    end.min   end end puts Time.nowlang = ARGV[0] || strvunimplemented, omitted = RosettaCode.get_unimplemented(lang)unimplemented.collect {|title| [title, RosettaCode.created_time(title)]} .              sort_by {|e| e[1]} .              each do |title, date|                puts strv % [                  date.strftime(strv),                   omitted.include?(title) ? strv : strv ,                  title                ]              end "
"require 'open-uri'require 'rexml/document' module RosettaCode   URL_ROOT = strv   def self.get_url(page, query)    begin      
      pstr = URI.encode_www_form_component(page)      qstr = URI.encode_www_form(query)    rescue NoMethodError      require 'cgi'      pstr = CGI.escape(page)      qstr = query.map {|k,v|        strv % [CGI.escape(k.to_s), CGI.escape(v.to_s)]}.join(strv)    end    url = strv    p url if $DEBUG    url  end   def self.get_api_url(query)    get_url strv, query  end   def self.category_members(category)    query = {      strv => strv,      strv => strv,      strv => strv,      strv => strv,      strv => 500,    }    while true      url = get_api_url query      doc = REXML::Document.new open(url)       REXML::XPath.each(doc, strv) do |task|        yield task.attribute(strv).value      end       continue = REXML::XPath.first(doc, strv)      break if continue.nil?      cm = REXML::XPath.first(continue, strv)      query[strv] = cm.attribute(strv).value    end  end endrequire 'rosettacode' total_examples = 0 RosettaCode.category_members(strv) do |task|  url = RosettaCode.get_url(strv, {strv => strv, strv => task})  examples = open(url).read.scan(strv).length  puts strv  total_examples += examplesend putsputs strvvar lwp = require('LWP::UserAgent').new(agent => 'Mozilla/5.0'); var site = 'http://rosettacode.org';var list_url = '/mw/api.php?action=query&list=categorymembers&'+               'cmtitle=Category:Programming_Tasks&cmlimit=500&format=xml'; var content = lwp.get(site + list_url).decoded_content; while (var m = content.match(/cm.*?title=strv/g)) {    (var slug = m[0]).gsub!(' ', '_');    var count = lwp.get(strv).decoded_content.count(/toclevel-1/g);    say strv;}"
"def roots_of_unity(n)  (0...n).map {|k| Complex.polar(1, 2 * Math::PI * k / n)}end p roots_of_unity(3)func roots_of_unity (n) {    n.of { |j|        exp(2.i * Complex.pi / n * (j-1))    }} roots_of_unity(5).each { |c|    printf(""%+.5f%+.5fi"", c.reals);}5.times { |n|    var roots = Complex(1).roots(n);    printf (strv, n);    say roots.map{ strv % .reals }.join(' ');}"
"require 'cmath' def quadratic(a, b, c)  sqrt_discriminant = CMath.sqrt(b**2 - 4*a*c)  [(-b + sqrt_discriminant) / (2.0*a), (-b - sqrt_discriminant) / (2.0*a)]end p quadratic(3, 4, 4/3.0)  
p quadratic(3, 2, -1)     
p quadratic(3, 2,  1)     
p quadratic(1, 0,  1)     
p quadratic(1, -1e6, 1)   
p quadratic(-2,  7, 15)   
p quadratic(1, -2,  1)    
p quadratic(1,  3,  3)    
var sets = [            [1,    2,  1],            [1,    2,  3],            [1,   -2,  1],            [1,    0, -4],            [1, -1e6,  1],           ]; func quadroots(a, b, c) {    var root = sqrt(b**2 - 4*a*c)     [(-b + root) / (2 * a),     (-b - root) / (2 * a)]} sets.each { |coefficients|    say (strv,        strv);}"
"def sign(x)  x <=> 0end def find_roots(f, range, step=0.001)  sign = sign(f[range.begin])  range.step(step) do |x|    value = f[x]    if value == 0      puts strv    elsif sign(value) == -sign      puts strv    end    sign = sign(value)  endend f = lambda { |x| x**3 - 3*x**2 + 2*x }find_roots(f, -1..3)class Numeric  def sign    self <=> 0  endend def find_roots(range, step = 1e-3)  range.step( step ).inject( yield(range.begin).sign ) do |sign, x|    value = yield(x)    if value == 0      puts strv    elsif value.sign == -sign      puts strv    end    value.sign  endend find_roots(-1..3) { |x| x**3 - 3*x**2 + 2*x }func f(x) {    x*x*x - 3*x*x + 2*x;} var step = 0.001;var start = -1;var stop = 3; range(start+step, stop, step).each { |x|    static sign = false;    given (var value = f(x)) {        when (0) {            say strv;        }        case (sign && ((value > 0) != sign)) {            say strv;        }    }    sign = value>0;}"
"require 'digest'puts Digest::RMD160.hexdigest('Rosetta Code')require 'openssl'puts OpenSSL::Digest::RIPEMD160.hexdigest('Rosetta Code')require 'stringio' module RMD160  
  MASK = (1 << 32) - 1  F = [    proc {|x, y, z| x ^ y ^ z},    proc {|x, y, z| (x & y) | (x.^(MASK) & z)},    proc {|x, y, z| (x | y.^(MASK)) ^ z},    proc {|x, y, z| (x & z) | (y & z.^(MASK))},    proc {|x, y, z| x ^ (y | z.^(MASK))},  ].freeze  K  = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]  KK = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]  R  = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,        3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,        1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,        4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]  RR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,        6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,        15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,        8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,        12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]  S  = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,        7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,        11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,        11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,        9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]  SS = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,        9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,        9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,        15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,        8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]   module_function   def rol(value, shift)    (value << shift).&(MASK) | (value.&(MASK) >> (32 - shift))  end   
  
  
  def rmd160(string)    
    h0 = 0x67452301    h1 = 0xefcdab89    h2 = 0x98badcfe    h3 = 0x10325476    h4 = 0xc3d2e1f0     io = StringIO.new(string)    block = strv    term = false  
    last = false  
    until last      
      io.read(64, block) or (        
        
        block.replace(strv)      )       
      case len = block.length      when 64        
        x = block.unpack(strv)      when 56..63        
        block.concat(""80""); term = true        block.concat("""" * (63 - len))        x = block.unpack(strv)      when 0..55        
        block.concat(term ? """" : ""80"")        block.concat("""" * (55 - len))        x = block.unpack(strv)         
        bit_len = string.length << 3        x.push(bit_len & MASK, bit_len >> 32)        last = true      else        fail strv      end       
      a,  b,  c,  d,  e  = h0, h1, h2, h3, h4      aa, bb, cc, dd, ee = h0, h1, h2, h3, h4      j = 0      5.times {|ro|        f, ff = F[ro], F[4 - ro]        k, kk = K[ro], KK[ro]        16.times {          a, e, d, c, b = e, d, rol(c, 10), b,            rol(a + f[b, c, d] + x[R[j]] + k, S[j]) + e          aa, ee, dd, cc, bb = ee, dd, rol(cc, 10), bb,            rol(aa + ff[bb, cc, dd] + x[RR[j]] + kk, SS[j]) + ee          j += 1        }      }      h0, h1, h2, h3, h4 =        (h1 + c + dd) & MASK, (h2 + d + ee) & MASK,        (h3 + e + aa) & MASK, (h4 + a + bb) & MASK,        (h0 + b + cc) & MASK    end  
     [h0, h1, h2, h3, h4].pack(strv)  endend if __FILE__ == $0  
  str = 'Rosetta Code'  printf ""%s:  %s"", str, *RMD160.rmd160(str).unpack('H*')end"
"def fromRoman(roman)  r = roman.upcase  n = 0  until r.empty? do    case    when r.start_with?('M')  then v = 1000; len = 1    when r.start_with?('CM') then v = 900;  len = 2    when r.start_with?('D')  then v = 500;  len = 1    when r.start_with?('CD') then v = 400;  len = 2    when r.start_with?('C')  then v = 100;  len = 1    when r.start_with?('XC') then v = 90;   len = 2    when r.start_with?('L')  then v = 50;   len = 1    when r.start_with?('XL') then v = 40;   len = 2    when r.start_with?('X')  then v = 10;   len = 1    when r.start_with?('IX') then v = 9;    len = 2    when r.start_with?('V')  then v = 5;    len = 1    when r.start_with?('IV') then v = 4;    len = 2    when r.start_with?('I')  then v = 1;    len = 1    else      raise ArgumentError.new(strv + roman)    end    n += v    r.slice!(0,len)  end  nend [ strv, strv, strv ].each {|r| p r => fromRoman(r)}SYMBOLS = [ ['M', 1000], ['CM', 900], ['D', 500], ['CD', 400], ['C', 100], ['XC', 90],            ['L', 50], ['XL', 40], ['X', 10], ['IX', 9], ['V', 5], ['IV', 4], ['I', 1] ] def parseRoman(roman)  r = roman.upcase  n = 0  SYMBOLS.each { |sym, val| n += val while r.sub!(/^#{sym}/, strv) }  nend [ strv, strv, strv ].each {|r| puts strv % [r, parseRoman(r)]}"
"class RockPaperScissorsGame  CHOICES = %w[rock paper scissors quit]  BEATS = {    'rock'     => 'paper',    'paper'    => 'scissors',    'scissors' => 'rock',  }   def initialize()    @plays = {      'rock'     => 1,      'paper'    => 1,      'scissors' => 1,    }    @score = [0, 0, 0]          
     play  end   def humanPlay    loop do      print ""Your choice: #{CHOICES}? ""      answer = STDIN.gets.strip.downcase      next if answer.empty?      idx = CHOICES.find_index {|choice| choice.match(/^#{answer}/)}      return CHOICES[idx] if idx      puts strv    end  end   def computerPlay    total = @plays.values.reduce(:+)    r = rand(total) + 1    sum = 0    CHOICES.each do |choice|      sum += @plays[choice]      return BEATS[choice] if r <= sum    end  end   def play    loop do      h = humanPlay      break if h == strv      c = computerPlay      print strv       
      @plays[h] += 1       if h == c        puts strv        @score[2] += 1      elsif h == BEATS[c]        puts strv        @score[0] += 1      else        puts strv        @score[1] += 1      end      puts strv % [*@score]    end    @plays.each_key{|k| @plays[k] -= 1}    puts ""humans chose }""  endend RockPaperScissorsGame.newconst rps = %w(r p s) const msg = [    strv,    strv,    strv,] say <<strv;\n>> Rock Paper Scissors <<\n** Enter 'r', 'p', or 's' as your play.** Enter 'q' to exit the game.** Running score shown as <your wins>:<my wins>EOT var plays   = 0var aScore  = 0var pScore  = 0var pcf     = [0,0,0]      
var aChoice = 3.irand      
 loop {    var pi = Sys.scanln(strv)    pi == 'q' && break     var pChoice = rps.index(pi)     if (pChoice == -1) {        STDERR.print(""Invalid input!"")        next    }     ++pcf[pChoice]    ++plays     
    strv.printf(rps[aChoice])     given ((aChoice - pChoice + 3) % 3) {        when (0) { say strv }        when (1) { strv.printlnf(30, msg[aChoice], 'My point');   aScore++ }        when (2) { strv.printlnf(30, msg[pChoice], 'Your point'); pScore++ }    }     
    strv.printf(strv % (pScore, aScore))     
    given (plays.irand) { |rn|        case (rn < pcf[0])        { aChoice = 1 }        case (pcf[0]+pcf[1] > rn) { aChoice = 2 }        default                   { aChoice = 0 }    }}"
"puts <<EOS
---------- Ice and Fire ------------
 
fire, in end will world the say Some
ice. in say Some
desire of tasted I've what From
fire. favor who those with hold I
 
... elided paragraph last ...
 
Frost Robert -----------------------
EOS  .each_line.map {|line| line.split.reverse.join(' ')}DATA.each{|line| line.words.reverse.join(strv).say}; __DATA__---------- Ice and Fire ------------ fire, in end will world the say Someice. in say Somedesire of tasted I've what From
fire. favor who those with hold I
 
... elided paragraph last ...
 
Frost Robert -----------------------"
"class Example    def foo        puts strv    end    def bar        puts strv    end    def method_missing(name, *args, &block)        puts strv % name 
        unless args.empty?            puts strv % [args]        end    endend example = Example.new example.foo          
example.bar          
example.grill        
example.ding(strv) 
                     
class Example {    method foo {        say strv    }    method bar {        say strv    }    method AUTOLOAD(_, name, *args) {        say (strv % name);        if (args.len > 0) {            say (strv % args.join(', '));        }    }} var example = Example.new; example.foo;          
example.bar;          
example.grill;        
example.ding(strv); 
                      
"
"Symbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }Subtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ] def roman(num)  return Symbols[num]  if Symbols.has_key?(num)  Subtractors.each do |cutPoint, subtractor|     return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint  endend [1990, 2008, 1666].each do |i|  puts strv % [i, roman(i)]end Symbols = [ [1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'], [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I'] ] def arabic_to_roman(arabic)  return '' if arabic.zero?  Symbols.each { |arabic_rep, roman_rep| return roman_rep + arabic_to_roman(arabic - arabic_rep) if arabic >= arabic_rep }end  Symbols = [ [1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'], [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I'] ] def to_roman(num)    Symbols.reduce strv do |memo, (divisor, letter)|        div, num = num.divmod(divisor)        memo + letter * div    endend func arabic2roman(num, roman='') {    static lookup = [        :M:1000, :CM:900, :D:500,        :CD:400, :C:100,  :XC:90,        :L:50,   :XL:40,  :X:10,        :IX:9,   :V:5,    :IV:4,        :I:1    ];    lookup.each { |pair|        while (num >= pair.second) {            roman += pair.first;            num -= pair.second;        }    }    return roman;}say(strv + arabic2roman(1990));say(strv + arabic2roman(2008));say(strv + arabic2roman(1666));"
"4.times{ puts strv }  
 def repeat(proc,num)  num.times{ proc.call }end repeat(->{ puts strv }, 4)func repeat(f, n) {    { f() } * n;} func example {    say strv;} repeat(example, 4);"
"def addsub(x, y)  [x + y, x - y]enddef addsub(x, y)  return x + y, x - yendsum, difference = addsub(33, 12)puts strvputs strvfunc foo(a,b) {    return (a+b, a*b);}var (x, y) = foo(4, 5);say x;   #=> 9say y;   #=> 20"
"paste(rep(strv,5), collapse='')strv * 5  
'ha' * 5;  
"
"
 strings = [strv, strv]strings.each do |s|  puts strvendstr = strvreversed = str.reverse#encoding: utf-8strv.reverse #=> strvstrv.reverse;             
strv.reverse;      
"
"File.rename('input.txt', 'output.txt')File.rename('/input.txt', '/output.txt')File.rename('docs', 'mydocs')File.rename('/docs', '/mydocs')require 'fileutils'moves = { strv => strv, strv => strv, strv => strv,strv => strv}moves.each{ |src, dest| FileUtils.move( src, dest, :verbose => true ) }
File.rename('input.txt', 'output.txt');File.rename('docs',      'mydocs'); 
File.rename(Dir.root + %f'input.txt', Dir.root + %f'output.txt');File.rename(Dir.root + %f'docs',      Dir.root + %f'mydocs');"
"ar = %w(1001110011        1110111011        0010010010        1010101010        1111111111        0100101101        0100100        101        11        00        1) ar.each do |str|  rep_pos = (str.size/2).downto(1).find{|pos| str.start_with? str[pos..-1]}  puts str, rep_pos ? strv*rep_pos + str[0, rep_pos] : strv, strvendvar arr = <1001110011 1110111011           0010010010 1010101010           1111111111 0100101101           0100100  101  11 00 1>;  arr.each { |n|    if (var m = /^(.+)\1+(.*$)(?(?{ substr($1, 0, length $2) eq $2 })|(?!))/.match(n)) {       var i = m[0].len;       say (n.substr(0, i),            n.substr(i, i).tr('01', '𝟘𝟙'),            n.substr(i*2));    } else {        say strv;    }}"
"require 'tempfile' def remove_lines(filename, start, num)  tmp = Tempfile.open(filename) do |fp|    File.foreach(filename) do |line|      if $. >= start and num > 0        num -= 1      else        fp.puts line      end    end    fp  end  puts strv if num > 0  FileUtils.copy(tmp.path, filename)  tmp.unlinkend 
def setup(filename, start, remove)  puts strv  File.open(filename, strv) {|fh| (1..5).each {|i| fh.puts strv*i + i.to_s}}  puts strv, File.read(filename)end def teardown(filename)  puts strv, File.read(filename)  puts  File.unlink(filename)end filename = strvstart = 2[2, 6].each do |remove|  setup(filename, start, remove)  remove_lines(filename, start, remove)  teardown(filename)endfunc remove_lines(file, beg, len) {    var lines = file.open_r.lines;    lines.splice(beg, len).len == len || warn strv;    file.open_w.print(lines.join)} remove_lines(File(__FILE__), 2, 3);"
"class Foo  @@xyz = nil  def initialize(name, age)    @name, @age = name, age  end  def add_sex(sex)    @sex = sex  endend p foo = Foo.new(strv, 18)            #=> #<Foo:0x0000000305a688 @name=strv, @age=18>p foo.instance_variables                #=> [:@name, :@age]p foo.instance_variable_defined?(:@age) #=> truep foo.instance_variable_get(:@age)      #=> 18p foo.instance_variable_set(:@age, 19)  #=> 19p foo                                   #=> #<Foo:0x0000000305a688 @name=strv, @age=19>foo.add_sex(:woman)p foo.instance_variables                #=> [:@name, :@age, :@sex]p foo                                   #=> #<Foo:0x0000000305a688 @name=strv, @age=19, @sex=:woman>foo.instance_variable_set(:@bar, nil)p foo.instance_variables                #=> [:@name, :@age, :@sex, :@bar] p Foo.class_variables                   #=> [:@@xyz]p Foo.class_variable_defined?(:@@xyz)   #=> truep Foo.class_variable_get(:@@xyz)        #=> nilp Foo.class_variable_set(:@@xyz, :xyz)  #=> :xyzp Foo.class_variable_get(:@@xyz)        #=> :xyzp Foo.class_variable_set(:@@abc, 123)   #=> 123p Foo.class_variables                   #=> [:@@xyz, :@@abc]"
"str = strvp strv if str =~ /string$/p strv unless str =~ /^You/str.sub(/ a /, ' another ') #=> strv
str[/ a /] = ' another '    #=> strvstr                         #=> strvstr.gsub(/\bam\b/) { |match| match.upcase } #=> strvvar str = strv;if (str =~ /string$/) {    print ""Ends with 'string'"";}var str = <<'EOF';    x:Foo    y:BarEOF while (var m = str=~/(\w+):(\S+)/g) {    say strv;}var str = strv; 
str.sub!(/ a /, ' another ');   
 
str -= / \Kanother /i;          
 
str = str.gsub(/(\w+)/, {|s1| 'x' * s1.len});  
 say str;     
"
"
class Super  CLASSNAME = 'super'   def initialize(name)    @name = name    def self.superOwn      'super owned'    end  end   def to_s    ""Super(})""  end   def doSup    'did super stuff'  end   def self.superClassStuff    'did super class stuff'  end   protected  def protSup    strv  end   private  def privSup    strv  endend module Other  def otherStuff    'did other stuff'  endend class Sub < Super  CLASSNAME = 'sub'  attr_reader :dynamic   include Other   def initialize(name, *args)    super(name)    @rest = args;    @dynamic = {}    def self.subOwn      'sub owned'    end  end   def methods(regular=true)    super + @dynamic.keys  end   def method_missing(name, *args, &block)    return super unless @dynamic.member?(name)    method = @dynamic[name]    if method.arity > 0      if method.parameters[0][1] == :self        args.unshift(self)      end      if method.lambda?        
        args += args + [nil] * [method.arity - args.length, 0].max        
        if method.parameters[-1][0] != :rest          args = args[0,method.arity]        end      end      method.call(*args)    else      method.call    end  end   def public_methods(all=true)    super + @dynamic.keys  end   def respond_to?(symbol, include_all=false)    @dynamic.member?(symbol) || super  end   def to_s    ""Sub(})""  end   def doSub    'did sub stuff'  end   def self.subClassStuff    'did sub class stuff'  end   protected  def protSub    strv  end   private  def privSub    strv  endend sup = Super.new('sup')sub = Sub.new('sub', 0, 'I', 'two')sub.dynamic[:incr] = proc {|i| i+1} p sub.public_methods(false)#=> [:superOwn, :subOwn, :respond_to?, :method_missing, :to_s, :methods, :public_methods, :dynamic, :doSub, :incr] p sub.methods - Object.methods#=> [:superOwn, :subOwn, :method_missing, :dynamic, :doSub, :protSub, :otherStuff, :doSup, :protSup, :incr] p sub.public_methods - Object.public_methods#=> [:superOwn, :subOwn, :method_missing, :dynamic, :doSub, :otherStuff, :doSup, :incr] p sub.methods - sup.methods#=> [:subOwn, :method_missing, :dynamic, :doSub, :protSub, :otherStuff, :incr] 
p sub.methods(false)#=> [:superOwn, :subOwn, :incr]p sub.singleton_methods#=> [:superOwn, :subOwn]class Example {    method foo { }    method bar(arg) { say strv }} var obj = Example()say obj.methods.keys.sort          #=> [strv] var meth = obj.methods.item(:bar)  
meth(123)                          
"
"require 'mathn'Math.method(:sqrt).source_location
 Class.method(:nesting).source_location
 "
"ary = [1,1,2,1,'redundant',[1,2,3],[1,2,3],'redundant']p ary.uniq              
class Array  
  def uniq1    each_with_object({}) {|elem, h| h[elem] = true}.keys  end  
  def uniq2    sorted = sort    pre = sorted.first    sorted.each_with_object([pre]){|elem, uniq| uniq << (pre = elem) if elem != pre}  end  
  def uniq3    each_with_object([]) {|elem, uniq| uniq << elem unless uniq.include?(elem)}  endend ary = [1,1,2,1,'redundant',[1,2,3],[1,2,3],'redundant']p ary.uniq1             #=> [1, 2, strv, [1, 2, 3]]p ary.uniq2 rescue nil  
p ary.uniq3             #=> [1, 2, strv, [1, 2, 3]] ary = [1,2,3,7,6,5,2,3,4,5,6,1,1,1]p ary.uniq1             #=> [1, 2, 3, 7, 6, 5, 4]p ary.uniq2             #=> [1, 2, 3, 4, 5, 6, 7]p ary.uniq3             #=> [1, 2, 3, 7, 6, 5, 4]def unique(array)    pure = Array.new    for i in array        flag = false        for j in pure            flag = true if j==i        end        pure << i unless flag    end    return pureend unique [strv,strv,strv,strv,strv,strv]   
unique [1,2,3,4,1,2,3,5,1,2,3,4,5]              
var ary = [1,1,2,1,'redundant',[1,2,3],[1,2,3],'redundant'];say ary.uniq.dump;say ary.last_uniq.dump;"
"require strvrequire strv commands = %w[search download open help history quit url prev past]Readline.completion_proc = commands.abbrev.to_proc while buf = Readline.readline(strv, true) 
  exit if buf.strip == strv  p bufend"
"
def reduced_row_echelon_form(ary)  lead = 0  rows = ary.size  cols = ary[0].size  rary = convert_to(ary, :to_r)  
  catch :done  do    rows.times do |r|      throw :done  if cols <= lead      i = r      while rary[i][lead] == 0        i += 1        if rows == i          i = r          lead += 1          throw :done  if cols == lead        end      end      
      rary[i], rary[r] = rary[r], rary[i]      
      v = rary[r][lead]      rary[r].collect! {|x| x / v}      
      rows.times do |i|        next if i == r        v = rary[i][lead]        rary[i].each_index {|j| rary[i][j] -= v * rary[r][j]}      end      lead += 1    end  end  raryend 
def convert_to(ary, type)  ary.each_with_object([]) do |row, new|    new << row.collect {|elem| elem.send(type)}  endend class Rational  alias _to_s to_s  def to_s    denominator==1 ? numerator.to_s : _to_s  endend def print_matrix(m)  max = m[0].collect {-1}  m.each {|row| row.each_index {|i| max[i] = [max[i], row[i].to_s.length].max}}  m.each {|row| row.each_index {|i| print strv % row[i]}; puts}end mtx = [  [ 1, 2, -1, -4],  [ 2, 3, -1,-11],  [-2, 0, -3, 22]]print_matrix reduced_row_echelon_form(mtx)puts mtx = [  [ 1, 2, 3, 7],  [-4, 7,-2, 7],  [ 3, 3, 0, 7]]reduced = reduced_row_echelon_form(mtx)print_matrix reducedprint_matrix convert_to(reduced, :to_f)func rref (Array m) {    m.is_empty && return;    var (lead, rows, cols) = (0, m.len, m[0].len);     rows.range.each { |r|        lead >= cols && return m;        var i = r;         while (!m[i][lead]) {            ++i == rows || next;            i = r;            ++lead == cols && return m;        }         m[i, r] = m[r, i];        var lv = m[r][lead];        m[r] = (m[r] »/» lv);         rows.range.each { |n|            n == r && next;            m[n] = (m[n] »-« (m[r] «*« m[n][lead]))        }        ++lead;    }    return m} func say_it (message, array) {    say ""#{message}"";    array.each { |row|        say row.map { |n| strv % n.as_rat }.join    }} var M = [    [ 
      [  1,  2,  -1,  -4 ],      [  2,  3,  -1, -11 ],      [ -2,  0,  -3,  22 ],    ],    [ 
      [  3,   0,  -3,    1 ],      [ .5, 3/2,  -3,   -2 ],      [ .2, 4/5,  -1.6, .3 ],    ],    [ 
      [ 1,  2,  3,  4,  3,  1],      [ 2,  4,  6,  2,  6,  2],      [ 3,  6, 18,  9,  9, -6],      [ 4,  8, 12, 10, 12,  4],      [ 5, 10, 24, 11, 15, -4],    ],]; M.each { |matrix|    say_it('Original Matrix', matrix);    say_it('Reduced Row Echelon Form Matrix', rref(matrix));    say '';}"
" seventh_line = open(strv).each_line.take(7).last func getNthLine(filename, n) {  var file = File.new(filename);  file.open_r.each { |line|    Num($.) == n && return line;  }  warn ""file #{file} does not have #{n} lines, only #{$.}"";  return nil;} var line = getNthLine(strv, 7);print line if defined line;"
"x.abs #absolute valuex.magnitude #absolute valuex.floor #floorx.ceil #ceilingx ** y #powerinclude MathE #ePI #pisqrt(x) #square rootlog(x) #natural logarithmlog(x, y) #logarithm base ylog10(x) #base 10 logarithmexp(x) #exponential Math.e;    
Math.pi;   
x.sqrt;    
x.log;     
x.log10;   
x.exp;     
x.abs;     
x.floor;   
x.ceil;    
x**y;      
"
"File.open('input.txt', 'r:utf-8') do |f|  f.each_char{|c| p c}endFile.open('input.txt', 'r:utf-8') do |f|  while c = f.getc    p c  endendvar file = File('input.txt')        
var fh = file.open_r                
fh.each_char { |char|    printf(""got character #{char} [U+%04x]"", char.ord)}"
"
str = IO.read strv 
str = IO.read strvpath = strvstr = File.open(path) {|f| f.read}
str = File.open(path, strv) {|f| f.read}
str = File.open(path, strv) {|f| f.read} 
str = File.open(path, strv) {|f| f.read}var file = File.new(__FILE__);var content = file.open_r.slurp;print content;var file = File(__FILE__)var content = file.read(:utf8)print content"
"###########################################################################
class RGBColour  
  def initialize(red, green, blue)    ok = [red, green, blue].inject(true) {|ok,c| ok &= c.between?(0,255)}    unless ok      raise ArgumentError, strv    end    @red, @green, @blue = red, green, blue  end  attr_reader :red, :green, :blue  alias_method :r, :red  alias_method :g, :green  alias_method :b, :blue   
  
  
  
  #  def values    [@red, @green, @blue]  end   
  
  
  
  #  def ==(a_colour)    values == a_colour.values  end   
  
  
  #  def <=>(a_colour)    self.luminosity <=> a_colour.luminosity  end   
  
  
  
  #  def luminosity    Integer(0.2126*@red + 0.7152*@green + 0.0722*@blue)  end   
  
  
  
  
  #  def to_grayscale    l = luminosity    self.class.new(l, l, l)  end   
  
  def self.mandel_colour(i)    self.new( 16*(i % 15), 32*(i % 7), 8*(i % 31) )  end   RED   = RGBColour.new(255,0,0)  GREEN = RGBColour.new(0,255,0)  BLUE  = RGBColour.new(0,0,255)  YELLOW= RGBColour.new(255,255,0)  BLACK = RGBColour.new(0,0,0)  WHITE = RGBColour.new(255,255,255)end ###########################################################################
Pixel = Struct.new(:x, :y) ###########################################################################class Pixmap  def initialize(width, height)    @width = width    @height = height    @data = fill(RGBColour::WHITE)  end  attr_reader :width, :height   def fill(colour)    @data = Array.new(@width) {Array.new(@height, colour)}  end   def validate_pixel(x,y)    unless x.between?(0, @width-1) and y.between?(0, @height-1)      raise ArgumentError, strv    end  end   ###############################################  def [](x,y)    validate_pixel(x,y)    @data[x][y]  end  alias_method :get_pixel, :[]   def []=(x,y,colour)    validate_pixel(x,y)    @data[x][y] = colour  end  alias_method :set_pixel, :[]=   def each_pixel    if block_given?      @height.times {|y| @width.times {|x| yield x,y}}    else      to_enum(:each_pixel)    end  end   ###############################################  
  PIXMAP_FORMATS = [strv, strv]   
  PIXMAP_BINARY_FORMATS = [strv]  
   def write_ppm(ios, format=strv)    if not PIXMAP_FORMATS.include?(format)      raise NotImplementedError, strv     end    ios.puts format, ""} }"", strv    ios.binmode if PIXMAP_BINARY_FORMATS.include?(format)    each_pixel do |x, y|      case format      when strv then ios.print @data[x][y].values.join(strv),""""      when strv then ios.print @data[x][y].values.pack('C3')      end    end  end   def save(filename, opts={:format=>strv})    File.open(filename, 'w') do |f|      write_ppm(f, opts[:format])    end  end  alias_method :write, :save   def print(opts={:format=>strv})    write_ppm($stdout, opts[:format])  end   def save_as_jpeg(filename, quality=75)    
    begin      pipe = IO.popen(strv, 'w')      write_ppm(pipe)    rescue SystemCallError => e      warn strv    ensure      pipe.close rescue false    end  end   def save_as_png(filename)    require 'chunky_png'    stream = StringIO.new(strv, strv)    each_pixel {|x, y| stream << self[x, y].values.pack(strv)}    stream.seek(0)    ChunkyPNG::Canvas.extend(ChunkyPNG::Canvas::StreamImporting)    canvas = ChunkyPNG::Canvas.from_rgb_stream(width, height, stream)    canvas.to_image.save(filename)  end   ###############################################  
  def self.read_ppm(ios)    format = ios.gets.chomp    width, height = ios.gets.chomp.split.map {|n| n.to_i }    max_colour = ios.gets.chomp     if (not PIXMAP_FORMATS.include?(format)) or         width < 1 or height < 1 or        max_colour != '255'    then      ios.close      raise StandardError, strv    end    ios.binmode if PIXMAP_BINARY_FORMATS.include?(format)     bitmap = self.new(width, height)    bitmap.each_pixel do |x,y|      
      red, green, blue = case format        when 'P3' then ios.gets.chomp.split        when 'P6' then ios.read(3).unpack('C3')      end      bitmap[x,y] = RGBColour.new(red, green, blue)    end    ios.close    bitmap  end   def self.open(filename)    read_ppm(File.open(filename, 'r'))  end   def self.open_from_jpeg(filename)    unless File.readable?(filename)      raise ArgumentError, strv    end    begin      pipe = IO.popen(strv, 'r')      read_ppm(pipe)    rescue SystemCallError => e      warn strv    ensure      pipe.close rescue false    end  end   ###############################################  
  def to_grayscale    gray = self.class.new(@width, @height)    each_pixel do |x,y|      gray[x,y] = self[x,y].to_grayscale    end    gray  end   def to_blackandwhite    hist = histogram     
    median = nil    sum = 0    hist.keys.sort.each do |lum|      sum += hist[lum]      if sum > @height * @width / 2        median = lum        break      end    end     
    bw = self.class.new(@width, @height)    each_pixel do |x,y|      bw[x,y] = self[x,y].luminosity < median ? RGBColour::BLACK : RGBColour::WHITE    end    bw  end   def save_as_blackandwhite(filename)    to_blackandwhite.save(filename)  end   ###############################################  def draw_line(p1, p2, colour)    validate_pixel(p1.x, p2.y)    validate_pixel(p2.x, p2.y)     x1, y1 = p1.x, p1.y    x2, y2 = p2.x, p2.y     steep = (y2 - y1).abs > (x2 - x1).abs    if steep      x1, y1 = y1, x1      x2, y2 = y2, x2    end    if x1 > x2      x1, x2 = x2, x1      y1, y2 = y2, y1    end     deltax = x2 - x1    deltay = (y2 - y1).abs    error = deltax / 2    ystep = y1 < y2 ? 1 : -1     y = y1    x1.upto(x2) do |x|      pixel = steep ? [y,x] : [x,y]      self[*pixel] = colour      error -= deltay      if error < 0        y += ystep        error += deltax      end    end  end   ###############################################  def draw_line_antialised(p1, p2, colour)    x1, y1 = p1.x, p1.y    x2, y2 = p2.x, p2.y     steep = (y2 - y1).abs > (x2 - x1).abs    if steep      x1, y1 = y1, x1      x2, y2 = y2, x2    end    if x1 > x2      x1, x2 = x2, x1      y1, y2 = y2, y1    end    deltax = x2 - x1    deltay = (y2 - y1).abs    gradient = 1.0 * deltay / deltax     
    xend = x1.round    yend = y1 + gradient * (xend - x1)    xgap = (x1 + 0.5).rfpart    xpxl1 = xend    ypxl1 = yend.truncate    put_colour(xpxl1, ypxl1, colour, steep, yend.rfpart * xgap)    put_colour(xpxl1, ypxl1 + 1, colour, steep, yend.fpart * xgap)    itery = yend + gradient     
    xend = x2.round    yend = y2 + gradient * (xend - x2)    xgap = (x2 + 0.5).rfpart    xpxl2 = xend    ypxl2 = yend.truncate    put_colour(xpxl2, ypxl2, colour, steep, yend.rfpart * xgap)    put_colour(xpxl2, ypxl2 + 1, colour, steep, yend.fpart * xgap)     
    (xpxl1 + 1).upto(xpxl2 - 1).each do |x|      put_colour(x, itery.truncate, colour, steep, itery.rfpart)      put_colour(x, itery.truncate + 1, colour, steep, itery.fpart)      itery = itery + gradient    end  end   def put_colour(x, y, colour, steep, c)    x, y = y, x if steep    self[x, y] = anti_alias(colour, self[x, y], c)  end   def anti_alias(new, old, ratio)    blended = new.values.zip(old.values).map {|n, o| (n*ratio + o*(1.0 - ratio)).round}    RGBColour.new(*blended)  end   ###############################################  def draw_circle(pixel, radius, colour)    validate_pixel(pixel.x, pixel.y)     self[pixel.x, pixel.y + radius] = colour    self[pixel.x, pixel.y - radius] = colour    self[pixel.x + radius, pixel.y] = colour    self[pixel.x - radius, pixel.y] = colour     f = 1 - radius    ddF_x = 1    ddF_y = -2 * radius    x = 0    y = radius    while x < y      if f >= 0        y -= 1        ddF_y += 2        f += ddF_y      end      x += 1      ddF_x += 2      f += ddF_x      self[pixel.x + x, pixel.y + y] = colour      self[pixel.x + x, pixel.y - y] = colour      self[pixel.x - x, pixel.y + y] = colour      self[pixel.x - x, pixel.y - y] = colour      self[pixel.x + y, pixel.y + x] = colour      self[pixel.x + y, pixel.y - x] = colour      self[pixel.x - y, pixel.y + x] = colour      self[pixel.x - y, pixel.y - x] = colour    end  end   ###############################################  def flood_fill(pixel, new_colour)    current_colour = self[pixel.x, pixel.y]    queue = Queue.new    queue.enqueue(pixel)    until queue.empty?      p = queue.dequeue      if self[p.x, p.y] == current_colour        west = find_border(p, current_colour, :west)        east = find_border(p, current_colour, :east)        draw_line(west, east, new_colour)        q = west        while q.x <= east.x          [:north, :south].each do |direction|            n = neighbour(q, direction)            queue.enqueue(n) if self[n.x, n.y] == current_colour          end          q = neighbour(q, :east)        end      end    end  end   def neighbour(pixel, direction)    case direction    when :north then Pixel[pixel.x, pixel.y - 1]    when :south then Pixel[pixel.x, pixel.y + 1]    when :east  then Pixel[pixel.x + 1, pixel.y]    when :west  then Pixel[pixel.x - 1, pixel.y]    end  end   def find_border(pixel, colour, direction)    nextp = neighbour(pixel, direction)    while self[nextp.x, nextp.y] == colour      pixel = nextp      nextp = neighbour(pixel, direction)    end    pixel  end   ###############################################  def median_filter(radius=3)    if radius.even?      radius += 1    end    filtered = self.class.new(@width, @height)      $stdout.puts ""processing } rows""    pb = ProgressBar.new(@height) if $DEBUG     @height.times do |y|      @width.times do |x|        window = []        (x - radius).upto(x + radius).each do |win_x|          (y - radius).upto(y + radius).each do |win_y|            win_x = 0 if win_x < 0            win_y = 0 if win_y < 0            win_x = @width-1 if win_x >= @width            win_y = @height-1 if win_y >= @height            window << self[win_x, win_y]          end        end        
        filtered[x, y] = window.sort[window.length / 2]      end      pb.update(y) if $DEBUG    end     pb.close if $DEBUG     filtered  end   ###############################################  def magnify(factor)    bigger = self.class.new(@width * factor, @height * factor)    each_pixel do |x,y|      colour = self[x,y]      (x*factor .. x*factor + factor-1).each do |xx|        (y*factor .. y*factor + factor-1).each do |yy|          bigger[xx,yy] = colour        end      end    end    bigger  end   ###############################################  def histogram    histogram = Hash.new(0)    each_pixel do |x,y|      histogram[self[x,y].luminosity] += 1    end    histogram   end   ###############################################  def draw_bezier_curve(points, colour)    
    points = points.sort_by {|p| [p.x, p.y]}    xmin = points[0].x    xmax = points[-1].x    increment = 2    prev = points[0]    ((xmin + increment) .. xmax).step(increment) do |x|      t = 1.0 * (x - xmin) / (xmax - xmin)      p = Pixel[x, bezier(t, points).round]      draw_line(prev, p, colour)      prev = p    end  end   
  def bezier(t, points)    n = points.length - 1    points.each_with_index.inject(0.0) do |sum, (point, i)|      sum += n.choose(i) * (1-t)**(n - i) * t**i * point.y    end  end   ###############################################  def self.mandelbrot(width, height)    mandel = Pixmap.new(width,height)    pb = ProgressBar.new(width) if $DEBUG    width.times do |x|      height.times do |y|        x_ish = Float(x - width*11/15) / (width/3)        y_ish = Float(y - height/2) / (height*3/10)        mandel[x,y] = RGBColour.mandel_colour(mandel_iters(x_ish, y_ish))      end      pb.update(x) if $DEBUG    end    pb.close if $DEBUG    mandel  end   def self.mandel_iters(cx,cy)    x = y = 0.0    count = 0    while Math.hypot(x,y) < 2 and count < 255      x, y = (x**2 - y**2 + cx), (2*x*y + cy)      count += 1    end    count  end    ###############################################  
  def convolute(kernel)    newimg = Pixmap.new(@width, @height)    pb = ProgressBar.new(@width) if $DEBUG    @width.times do |x|      @height.times do |y|        apply_kernel(x, y, kernel, newimg)      end      pb.update(x) if $DEBUG    end    pb.close if $DEBUG    newimg  end   
  def apply_kernel(x, y, kernel, newimg)    x0 = [0, x-1].max    y0 = [0, y-1].max    x1 = x    y1 = y    x2 = [@width-1, x+1].min    y2 = [@height-1, y+1].min     r = g = b = 0.0    [x0, x1, x2].zip(kernel).each do |xx, kcol|      [y0, y1, y2].zip(kcol).each do |yy, k|        r += k * self[xx,yy].r        g += k * self[xx,yy].g        b += k * self[xx,yy].b	    end    end    newimg[x,y] = RGBColour.new(luma(r), luma(g), luma(b))  end   
  def luma(value)    if value < 0      0    elsif value > 255      255    else      value    end  endend  ###########################################################################
class ProgressBar  def initialize(max)    $stdout.sync = true    @progress_max = max    @progress_pos = 0    @progress_view = 68    $stdout.print ""[_view}][""  end   def update(n)    new_pos = n * @progress_view/@progress_max    if new_pos > @progress_pos      @progress_pos = new_pos       $stdout.print '='    end  end   def close    $stdout.puts '=]'  endend class Queue < Array  alias_method :enqueue, :push  alias_method :dequeue, :shiftend class Numeric  def fpart    self - self.truncate  end  def rfpart    1.0 - self.fpart  endend class Integer  def choose(k)    self.factorial / (k.factorial * (self - k).factorial)  end  def factorial    (2 .. self).reduce(1, :*)  endenddef display_pixmap(filename)  puts strv  system strvend ###########################################################################if $0 == __FILE__    old_debug = $DEBUG  $DEBUG = true   
  class Pixmap    def ==(a_bitmap)      return false if @width != a_bitmap.width or @height != a_bitmap.height      @width.times {|x| @height.times {|y|         return false if not self[x,y] == (a_bitmap[x,y])      }}      true    end  end   require 'test/unit'  class TestRGBColour <     def test_init      color = RGBColour.new(0,100,200)      assert_equal(100, color.g)    end    def test_constants      assert_equal([255,0,0], [RGBColour::RED.r,RGBColour::RED.g,RGBColour::RED.b])      assert_equal([0,255,0], [RGBColour::GREEN.r,RGBColour::GREEN.g,RGBColour::GREEN.b])      assert_equal([0,0,255], [RGBColour::BLUE.r,RGBColour::BLUE.g,RGBColour::BLUE.b])    end    def test_error      color = RGBColour.new(0,100,200)      assert_raise(ArgumentError) {RGBColour.new(0,0,256)}    end  end  class TestPixmap <     def setup      @w = 20      @h = 30      @bitmap = Pixmap.new(@w,@h)    end    def test_init      assert_equal(@w, @bitmap.width)      assert_equal(@h, @bitmap.height)      assert_equal(RGBColour::WHITE, @bitmap.get_pixel(10,10))    end    def test_fill      @bitmap.fill(RGBColour::RED)      assert_equal(255,@bitmap[10,10].red)      assert_equal(0,@bitmap[10,10].green)      assert_equal(0,@bitmap[10,10].blue)    end    def test_get_pixel      assert_equal(@bitmap[5,6], @bitmap.get_pixel(5,6))      assert_raise(ArgumentError) {@bitmap[100,100]}    end    def test_grayscale      @bitmap.fill(RGBColour::BLUE)      @bitmap.height.times {|y| [9,10,11].each {|x| @bitmap[x,y]=RGBColour::GREEN}}      @bitmap.width.times  {|x| [14,15,16].each {|y| @bitmap[x,y]=RGBColour::GREEN}}      @bitmap.save('testcross.ppm')      Pixmap.open('testcross.ppm').to_grayscale.save('testgray.ppm')    end    def test_save      @bitmap.fill(RGBColour::BLUE)      filename = 'test.ppm'      @bitmap.save(filename)      expected_size = 3 + (@w.to_s.length + 1 + @h.to_s.length + 1) + 4 + (@w * @h * 3)      assert_equal(expected_size, File.size(filename))    end     def test_open      @bitmap.fill(RGBColour::RED)      @bitmap.set_pixel(10,15, RGBColour::WHITE)      filename = 'test.ppm'      @bitmap.save(filename)      new = Pixmap.open(filename)      assert(@bitmap == new)    end  end   
  colour_bitmap = Pixmap.new(20, 30)  colour_bitmap.fill(RGBColour::BLUE)  colour_bitmap.height.times {|y| [9,10,11].each {|x| colour_bitmap[x,y]=RGBColour::GREEN}}  colour_bitmap.width.times  {|x| [14,15,16].each {|y| colour_bitmap[x,y]=RGBColour::GREEN}}  colour_bitmap.save('testcross.ppm')  display_pixmap 'testcross.ppm'   Pixmap.open('testcross.ppm').to_grayscale.save('testgray.ppm')   image = Pixmap.open('testcross.ppm')  image.save_as_jpeg('testcross.jpg')  #image.print(:format => strv)   bitmap = Pixmap.open_from_jpeg('testcross.jpg')  savefile = 'testcross_from_jpeg.ppm'  bitmap.save(savefile)  display_pixmap savefile   bitmap = Pixmap.new(500, 500)  bitmap.fill(RGBColour::BLUE)  10.step(430, 60) do |a|    bitmap.draw_line(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)    bitmap.draw_line(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)  end  bitmap.draw_line(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)  savefile = 'testlines4.ppm'  bitmap.save(savefile)  display_pixmap savefile   bitmap = Pixmap.new(30, 30)  bitmap.draw_circle(Pixel[14,14], 12, RGBColour::BLACK)  savefile = 'testcircle.ppm'  bitmap.save(savefile)  display_pixmap savefile   bitmap = Pixmap.new(300, 300)  bitmap.draw_circle(Pixel[149,149], 120, RGBColour::BLACK)  bitmap.draw_circle(Pixel[200,100], 40, RGBColour::BLACK)  bitmap.flood_fill(Pixel[140,160], RGBColour::BLUE)  savefile = 'testflood.ppm'  bitmap.save(savefile)  display_pixmap savefile   bitmap = Pixmap.new(500, 500)  bitmap.fill(RGBColour::BLUE)  10.step(430, 60) do |a|    bitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)    bitmap.draw_line_antialised(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)  end  bitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)  bitmap.save('testantialias.ppm')  display_pixmap 'testantialias.ppm'   file = 'teapot.ppm'  display_pixmap file  bitmap = Pixmap.open(file)  
  savefile = 'teapotgray.ppm'  gray = bitmap.to_grayscale  gray.save(savefile)  display_pixmap savefile  #  savefile = 'testfiltered.ppm'  filtered = bitmap.median_filter  filtered.save(savefile)  display_pixmap savefile   file = 'teapot.ppm'  savefile = 'teapotbw.ppm'  display_pixmap file  Pixmap.open(file).save_as_blackandwhite(savefile)  display_pixmap savefile   bitmap = Pixmap.new(400, 400)  points = [    Pixel[40,100], Pixel[100,350], Pixel[150,50],     Pixel[150,150], Pixel[350,250], Pixel[250,250]  ]  points.each {|p| bitmap.draw_circle(p, 3, RGBColour::RED)}  bitmap.draw_bezier_curve(points, RGBColour::BLUE)  savefile = 'testbezier.ppm'  bitmap.save(savefile)  display_pixmap savefile   savefile = 'testmandel.ppm'  Pixmap.mandelbrot(500,500).save(savefile)  display_pixmap savefile   
  teapot = Pixmap.open('teapot.ppm')  [ ['Emboss',  [[-2.0, -1.0, 0.0],  [-1.0, 1.0, 1.0],  [0.0, 1.0, 2.0]]],     ['Sharpen', [[-1.0, -1.0, -1.0], [-1.0, 9.0, -1.0], [-1.0, -1.0, -1.0]]],     ['Blur',    [[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111]]],  ].each do |label, kernel|    savefile = 'test' + label.downcase + '.ppm'    teapot.convolute(kernel).save(savefile)    display_pixmap savefile  end   $DEBUG = old_debug end #!/usr/bin/ruby require 'tk' if ARGV.empty?  $stderr.puts strv  exit 1end filename = ARGV.shiftunless File.readable?(filename)  raise ArgumentError, strvend root = TkRoot.new('title' => File.basename(filename))label = TkLabel.new(root) {image TkPhotoImage.new('file' => filename)}label.packTk.mainloop "
"IO.foreach strv do |line|  
  puts lineend
File.foreach(strv) {|line| puts line}
IO.foreach strv do |line|  puts lineendfilename = strvFile.open(filename) do |file|  file.each {|line| puts line}endFile(__FILE__).open_r.each { |line|    print line}var fh = File(__FILE__).open_rwhile (fh.readline(\var line)) {    print line}"
"require 'benchmark'Document = Struct.new(:id,:a,:b,:c)documents_a = []documents_h = {}1.upto(10_000) do |n|  d = Document.new(n)  documents_a << d  documents_h[d.id] = dendsearchlist = Array.new(1000){ rand(10_000)+1 } Benchmark.bm(10) do |x|  x.report('array'){searchlist.each{|el| documents_a.any?{|d| d.id == el}} }  x.report('hash'){searchlist.each{|el| documents_h.has_key?(el)} }end var benchmark = frequire('Benchmark'); func job1 {    #...job1 code...}func job2 {    #...job2 code...} const COUNT = -1;   
benchmark.timethese(COUNT, Hash.new('Job1' => job1, 'Job2' => job2));"
"ar = ""44 Solomon
42 Jason
42 Errol
41 Garry
41 Bernard
41 Barry
39 Stephen"".lines.map{|line| line.split}grouped = ar.group_by{|pair| pair.shift.to_i}s_rnk = 1m_rnk = o_rnk = 0puts ""stand.mod.denseord.fract."" grouped.each.with_index(1) do |(score, names), d_rnk|  m_rnk += names.flatten!.size  f_rnk = (s_rnk + m_rnk)/2.0  names.each do |name|    o_rnk += 1    puts ""#{s_rnk}#{m_rnk}#{d_rnk}#{o_rnk}#{f_rnk.to_s.sub("".0strv"")}#{score} #{name}""  end  s_rnk += names.sizeendvar scores = [    Pair(Solomon => 44),    Pair(Jason   => 42),    Pair(Errol   => 42),    Pair(Garry   => 41),    Pair(Bernard => 41),    Pair(Barry   => 41),    Pair(Stephen => 39),] func tiers(s) {    s.group_by { .value }.kv.sort.flip.map { .value.map{.key} }} func standard(s) {    var rank = 1    gather {        for players in tiers(s) {            take(Pair(rank, players))            rank += players.len        }    }} func modified(s) {    var rank = 0    gather {        for players in tiers(s) {            rank += players.len            take(Pair(rank, players))        }    }} func dense(s) {    tiers(s).map_kv { |k,v| Pair(k+1, v) }} func ordinal(s) {    s.map_kv { |k,v| Pair(k+1, v.key) }} func fractional(s) {    var rank = 1    gather {        for players in tiers(s) {            var beg = rank            var end = (rank += players.len)            take(Pair(sum(beg ..^ end) / players.len, players))        }    }} func display(r) {    say r.map {|a| '%3s : %s' % a... }.join("""")} say   strv;   display(  standard(scores))say ""Modified:"";   display(  modified(scores))say ""Dense:"";      display(     dense(scores))say ""Ordinal:"";    display(   ordinal(scores))say ""Fractional:""; display(fractional(scores))"
"fullname = favouritefruit = strvneedspeeling = seedsremoved = falseotherfamily = [] IO.foreach(strv) do |line|  line.chomp!  key, value = line.split(nil, 2)  case key  when /^([#;]|$)/; # ignore line  when strv; fullname = value  when strv; favouritefruit = value  when strv; needspeeling = true  when strv; seedsremoved = true  when strv; otherfamily = value.split(strv).map(&:strip)  when /^./; puts strv  endend puts strvputs strvputs strvputs strvotherfamily.each_with_index do |name, i|  puts strvendvar fullname = (var favouritefruit = strv);var needspeeling = (var seedsremoved = false);var otherfamily = []; ARGF.each { |line|    var(key, value) = line.strip.split(/\h+/, 2)...;     given(key) {        when (nil)              { }        when (/^([#;]|\h*$)/)   { }        when (strv)       { fullname = value }        when (strv) { favouritefruit = value }        when (strv)   { needspeeling = true }        when (strv)   { seedsremoved = true }        when (strv)    { otherfamily = value.split(',')»strip»() }        default                 { say strv }    }} say strv;say strv;say strv;say strv; otherfamily.each_kv {|i, name|    say strv;}"
"def range_expand(rng)  rng.split(',').flat_map do |part|    if part =~ /^(-?\d+)-(-?\d+)$/      ($1.to_i .. $2.to_i).to_a    else      Integer(part)    end  endend p range_expand('-6,-3--1,3-5,7-11,14,15,17-20')func rangex(str) {    str.split(',').map { |r|        var m = r.match(/^            (?(DEFINE) (?<int>[+-]?[0-9]+) )            (?<from>(?&int))-(?<to>(?&int))        $/x)        m ? do {var c = m.ncap; (Num(c{:from}) .. Num(c{:to}))...}          : Num(r)    }} say rangex('-6,-3--1,3-5,7-11,14,15,17-20').join(',')"
"a = Array.new(17){['0'] * 17}17.times{|i| a[i][i] = '-'}4.times do |k|  17.times do |i|    j = (i + 2 ** k) % 17    a[i][j] = a[j][i] = '1'  endenda.each {|row| puts row.join(' ')}
(0...17).to_a.combination(4) do |quartet|  links = quartet.combination(2).map{|i,j| a[i][j].to_i}.reduce(:+)  abort strv unless 0 < links && links < 6endputs strv var a = 17.of { 17.of(0) } 17.itimes{|i| a[i][i] = '-' }4.itimes { |k|  17.itimes { |i|    var j = ((i + 1<<k) % 17)    a[i][j] = (a[j][i] = 1)  }} a.each {|row| say row.join(' ') } @(0..16).combinations(4).each { |quartet|  var links = quartet.combinations(2).map{|p| a.dig(p...) }.sum  ((0 < links) && (links < 6)) || die strv}say strv"
"say 1.rand          
say 100.irand       
"
"def range_extract(l)  
  
  sorted, range = l.sort.concat([Float::MAX]), []  canidate_number = sorted.first   
  sorted.each_cons(2) do |current_number, next_number|    
    if current_number.succ < next_number      
      if canidate_number == current_number        
        range << canidate_number.to_s      else        
        
        seperator = canidate_number.succ == current_number ? strv : strv        range << strv % [canidate_number, seperator, current_number]      end      
      canidate_number = next_number    end  end  range.join(',')end lst = [    0,  1,  2,  4,  6,  7,  8, 11, 12, 14,   15, 16, 17, 18, 19, 20, 21, 22, 23, 24,   25, 27, 28, 29, 30, 31, 32, 33, 35, 36,   37, 38, 39] p rng = range_extract(lst)ary = [0,1,2,4,6,7,8,11,12,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,31,32,33,35,36,37,38,39]puts ary.sort.slice_when{|i,j| i+1 != j}.map{|a| a.size<3 ? a : strv}.join(strv)"
"require 'securerandom'SecureRandom.random_number(1 << 32)func urandom() {    const device = %f'/dev/urandom';     device.open('<:raw', \var fh, \var err) ->        || die strv;     fh.sysread(\var noise, 4);    'L'.unpack(noise);} say urandom();    
"
Array.new(1000) { 1 + Math.sqrt(-2 * Math.log(rand)) * Math.cos(2 * Math::PI * rand) }var arr = 1000.of { 1 + (0.5 * (-2 * 1.rand.log -> sqrt) * (Number.tau * 1.rand -> cos)) }arr.each { .say }
"def quickselect(a, k)  arr = a.dup 
  loop do    pivot = arr.delete_at(rand(arr.length))    left, right = arr.partition { |x| x < pivot }    if k == left.length      return pivot    elsif k < left.length      arr = left    else      k = k - left.length - 1      arr = right    end  endend v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]p v.each_index.map { |i| quickselect(v, i) }func quickselect(a, k) {    var pivot = a.pick;    var left  = a.grep{|i| i < pivot};    var right = a.grep{|i| i > pivot};     given(var l = left.len) {        when (k)     { pivot }        case (k < l) { __FUNC__(left, k) }        default      { __FUNC__(right, k - l - 1) }    }} var v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4];say v.range.map{|i| quickselect(v, i)};"
"var f = FIFO();say f.empty;        
f.push('foo');f.push('bar', 'baz');say f.pop;          
say f.empty;        
 var g = FIFO('xxx', 'yyy');say g.pop;          
say f.pop;          
"
"x = strv; puts x % xputs <<e*2,'e'puts <<e*2,'e'eeval s=strv f = File.open __FILE__f.each_line do |line| puts linef.close  p open(__FILE__).read s = %(s = %%(%s); printf(s, s);); printf(s, s);say(<<e*2, 'e')say(<<e*2, 'e')e"
"require 'forwardable' 


class FIFO  extend Forwardable   
  def self.[](*objects)    new.push(*objects)  end   
  def initialize; @ary = []; end   
  def push(*objects)    @ary.push(*objects)    self  end  alias << push  alias enqueue push   ##  # :method: pop  # :call-seq:  
  
  #  
  
  #  
  
  
  def_delegator :@ary, :shift, :pop  alias shift pop  alias dequeue shift   ##  # :method: empty?  
  def_delegator :@ary, :empty?   ##  # :method: size  
  def_delegator :@ary, :size  alias length size   
  def to_s    ""}""  end  alias inspect to_sendf = FIFO.newf.empty?                           
f.pop                              
f.pop(2)                           
f.push(14)                         
f << strv << [1,2,3]              
f.enqueue(strv, Hash.new, strv)
f.size                             
f.pop(3)                           
f.dequeue                          
f.empty?                           
g = FIFO[:a, :b, :c]g.pop(2)                           
g.pop(2)                           
g.pop(2)                           
class FIFO(*array) {    method pop {        array.is_empty && die strv;        array.shift;    }    method push(*items) {        array += items;        self;    }    method empty {        array.len == 0;    }}"
"class Quaternion  def initialize(*parts)    raise ArgumentError, strv unless parts.size == 4    raise ArgumentError, strv unless parts.all? {|x| x.is_a?(Numeric)}    @parts = parts  end   def to_a;          @parts;                                       end  def to_s;          ""_s}""                    end  alias inspect to_s  def complex_parts; [Complex(*to_a[0..1]), Complex(*to_a[2..3])]; end   def real;          @parts.first;                                 end  def imag;          @parts[1..3];                                 end  def conj;          Quaternion.new(real, *imag.map(&:-@));        end  def norm;          Math.sqrt(to_a.reduce(0){|sum,e| sum + e**2}) end 
   def ==(other)    case other    when Quaternion; to_a == other.to_a    when Numeric;    to_a == [other, 0, 0, 0]    else             false    end  end  def -@;            Quaternion.new(*to_a.map(&:-@));              end  def -(other);      self + -other;                                end   def +(other)    case other    when Numeric      Quaternion.new(real + other, *imag)    when Quaternion      Quaternion.new(*to_a.zip(other.to_a).map { |x,y| x + y }) 
    end  end   def *(other)    case other    when Numeric      Quaternion.new(*to_a.map { |x| x * other })    when Quaternion      
      a, b, c, d = *complex_parts, *other.complex_parts      x, y = a*c - d.conj*b, a*d + b*c.conj      Quaternion.new(x.real, x.imag, y.real, y.imag)    end  end   
  def coerce(other)    case other    when Numeric then [Scalar.new(other), self]    else raise TypeError, strv    end  end   class Scalar    def initialize(val); @val = val;                            end    def +(other);        other + @val;                          end    def *(other);        other * @val;                          end    def -(other);        Quaternion.new(@val, 0, 0, 0) - other; end  endend if __FILE__ == $0  q  = Quaternion.new(1,2,3,4)  q1 = Quaternion.new(2,3,4,5)  q2 = Quaternion.new(3,4,5,6)  r  = 7  expressions = [strv, strv, strv,                 strv, strv, strv, strv, strv,strv, strv,                 strv, strv, strv, strv, strv,                 strv, strv]  expressions.each do |exp|    puts strv % [exp, eval(exp)]  endendclass Quaternion(r, i, j, k) {     func qu(*r) { Quaternion(r...) }     method to_s  { strv }    method reals { [r, i, j, k] }    method conj  { qu(r, -i, -j, -k) }    method norm  { self.reals.map { _*_ }.sum.sqrt }     method ==(Quaternion b) { self.reals == b.reals }     method +(Number     b) { qu(b+r, i, j, k) }    method +(Quaternion b) { qu((self.reals ~Z+ b.reals)...) }     method neg { qu(self.reals.map{ .neg }...) }     method *(Number     b) { qu((self.reals»*»b)...) }    method *(Quaternion b) {        var (r,i,j,k) = b.reals...        qu(sum(self.reals ~Z* [r, -i, -j, -k]),           sum(self.reals ~Z* [i,  r,  k, -j]),           sum(self.reals ~Z* [j, -k,  r,  i]),           sum(self.reals ~Z* [k,  j, -i,  r]))    }} var q  = Quaternion(1, 2, 3, 4)var q1 = Quaternion(2, 3, 4, 5)var q2 = Quaternion(3, 4, 5, 6)var r  = 7 say strvsay strvsay strvsay strvsay strvsay strvsay strvsay strv"
"class PythagoranTriplesCounter  def initialize(limit)    @limit = limit    @total = 0    @primitives = 0    generate_triples(3, 4, 5)  end  attr_reader :total, :primitives   private  def generate_triples(a, b, c)    perim = a + b + c    return if perim > @limit     @primitives += 1    @total += @limit / perim     generate_triples( a-2*b+2*c, 2*a-b+2*c, 2*a-2*b+3*c)    generate_triples( a+2*b+2*c, 2*a+b+2*c, 2*a+2*b+3*c)    generate_triples(-a+2*b+2*c,-2*a+b+2*c,-2*a+2*b+3*c)  endend perim = 10while perim <= 100_000_000   c = PythagoranTriplesCounter.new perim  p [perim, c.total, c.primitives]  perim *= 10endfunc triples(limit) {    var primitive = 0;    var civilized = 0;     func oyako(a, b, c) {        (var perim = a+b+c) > limit || (            primitive++;            civilized += int(limit / perim);            oyako( a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c);            oyako( a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c);            oyako(-a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c);        );    }     oyako(3,4,5);    strv;} Inf.times { |n|    say triples(10**n);}"
"class Circle  def initialize(x, y, r)    @x, @y, @r = [x, y, r].map(&:to_f)  end  attr_reader :x, :y, :r   def self.apollonius(c1, c2, c3, s1=1, s2=1, s3=1)    x1, y1, r1 = c1.x, c1.y, c1.r    x2, y2, r2 = c2.x, c2.y, c2.r    x3, y3, r3 = c3.x, c3.y, c3.r     v11 = 2*x2 - 2*x1    v12 = 2*y2 - 2*y1    v13 = x1**2 - x2**2 + y1**2 - y2**2 - r1**2 + r2**2    v14 = 2*s2*r2 - 2*s1*r1     v21 = 2*x3 - 2*x2    v22 = 2*y3 - 2*y2    v23 = x2**2 - x3**2 + y2**2 - y3**2 - r2**2 + r3**2    v24 = 2*s3*r3 - 2*s2*r2     w12 = v12/v11    w13 = v13/v11    w14 = v14/v11     w22 = v22/v21 - w12    w23 = v23/v21 - w13    w24 = v24/v21 - w14     p = -w23/w22    q = w24/w22    m = -w12*p - w13    n = w14 - w12*q     a = n**2 + q**2 - 1    b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1    c = x1**2 + m**2 - 2*m*x1 + p**2 + y1**2 - 2*p*y1 - r1**2     d = b**2 - 4*a*c    rs = (-b - Math.sqrt(d)) / (2*a)    xs = m + n*rs    ys = p + q*rs     self.new(xs, ys, rs)  end   def to_s    ""Circle: }, }, }""  endend puts c1 = Circle.new(0, 0, 1)puts c2 = Circle.new(2, 4, 2)puts c3 = Circle.new(4, 0, 1) puts Circle.apollonius(c1, c2, c3)puts Circle.apollonius(c1, c2, c3, -1, -1, -1)class Circle(x,y,r) {    method to_s { strv }} func solve_apollonius(c, s) {     var(c1, c2, c3) = c...;    var(s1, s2, s3) = s...;     var 𝑣11 = (2*c2.x - 2*c1.x);    var 𝑣12 = (2*c2.y - 2*c1.y);    var 𝑣13 = (c1.x**2 - c2.x**2 + c1.y**2 - c2.y**2 - c1.r**2 + c2.r**2);    var 𝑣14 = (2*s2*c2.r - 2*s1*c1.r);     var 𝑣21 = (2*c3.x - 2*c2.x);    var 𝑣22 = (2*c3.y - 2*c2.y);    var 𝑣23 = (c2.x**2 - c3.x**2 + c2.y**2 - c3.y**2 - c2.r**2 + c3.r**2);    var 𝑣24 = (2*s3*c3.r - 2*s2*c2.r);     var 𝑤12 = (𝑣12 / 𝑣11);    var 𝑤13 = (𝑣13 / 𝑣11);    var 𝑤14 = (𝑣14 / 𝑣11);     var 𝑤22 = (𝑣22/𝑣21 - 𝑤12);    var 𝑤23 = (𝑣23/𝑣21 - 𝑤13);    var 𝑤24 = (𝑣24/𝑣21 - 𝑤14);     var 𝑃 = (-𝑤23 / 𝑤22);    var 𝑄 = (𝑤24 / 𝑤22);    var 𝑀 = (-𝑤12*𝑃 - 𝑤13);    var 𝑁 = (𝑤14 - 𝑤12*𝑄);     var 𝑎 = (𝑁**2 + 𝑄**2 - 1);    var 𝑏 = (2*𝑀*𝑁 - 2*𝑁*c1.x + 2*𝑃*𝑄 - 2*𝑄*c1.y + 2*s1*c1.r);    var 𝑐 = (c1.x**2 + 𝑀**2 - 2*𝑀*c1.x + 𝑃**2 + c1.y**2 - 2*𝑃*c1.y - c1.r**2);     var 𝐷 = (𝑏**2 - 4*𝑎*𝑐);    var rs = ((-𝑏 - 𝐷.sqrt) / 2*𝑎);     var xs = (𝑀 + 𝑁*rs);    var ys = (𝑃 + 𝑄*rs);     Circle(xs, ys, rs);} var c = [Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)];say solve_apollonius(c, %n<1 1 1>);say solve_apollonius(c, %n<-1 -1 -1>);"
"require strv class Integer  def proper_divisors    return [] if self == 1    primes = prime_division.flat_map{|prime, freq| [prime] * freq}    (1...primes.size).each_with_object([1]) do |n, res|      primes.combination(n).map{|combi| res << combi.inject(:*)}    end.flatten.uniq  endend (1..10).map{|n| puts strv} size, select = (1..20_000).group_by{|n| n.proper_divisors.size}.maxselect.each do |n|  puts strvend#Determine the integer within a range of integers that has the most proper divisors#Nigel Galloway: December 23rd., 2014require strvn, g = 0(1..20000).each{|i| e = i.prime_division.inject(1){|n,g| n * (g[1]+1)}                    n, g = e, i if e > n}puts strvfunc propdiv (x) {    var divs = []    divs << 1 if (x > 1)     for d in (2 .. x.isqrt) {        var y = (x // d)        if (y*d == x) {            divs << d            y == d || (divs << y)        }    }     divs} 10.times { |i| say ""#{i}#{propdiv(i)}"" } var max = 0var candidates = []20_000.times { |i|    var divs = propdiv(i).len    if (divs > max) {        candidates = []        max = divs    }    candidates << i if (divs == max)} say strv"
"if problem  exit(1)end 
if problem  abort   
endif problem  exit!   
endif (problem) {    Sys.exit(code);}"
"#!/usr/bin/env ruby puts strv  
puts strvsay __MAIN__;if (__MAIN__ != __FILE__) {    say strv;}"
"require 'prime' def primorial_number(n)  pgen = Prime.each  (1..n).inject(1){|p,_| p*pgen.next}end puts strv (1..5).each do |n|  puts strvendsay (    'First ten primorials: ',    10.of {|i| pn_primorial(i-1) }.join(', ')) 6.times { |i|    say (strv + pn_primorial(10**i).len + ' digits')}"
"probabilities = {  strv  => 1/5.0,  strv   => 1/6.0,  strv  => 1/7.0,  strv => 1/8.0,  strv     => 1/9.0,  strv    => 1/10.0,  strv  => 1/11.0,}probabilities[strv] = 1.0 - probabilities.each_value.inject(:+)ordered_keys = probabilities.keys sum, sums = 0.0, {}ordered_keys.each do |key|  sum += probabilities[key]  sums[key] = sumend actual = Hash.new(0) samples = 1_000_000samples.times do  r = rand  for k in ordered_keys    if r < sums[k]      actual[k] += 1      break    end  endend puts  strvfor k in ordered_keys  act = Float(actual[k]) / samples  val = probabilities[k]  printf ""%-8s%.8f  %.8f  %6.3f %%"", k, val, act, 100*(act-val)/valenddefine TRIALS = 1e4; func prob_choice_picker(options) {    var n = 0;    var a = [];    options.each { |k,v|        n += v;        a << [n, k];    }    func {        var r = 1.rand;        a.first{|e| r <= e[0] }[1];    }} var ps = Hash(   aleph  => 1/5,   beth   => 1/6,   gimel  => 1/7,   daleth => 1/8,   he     => 1/9,   waw    => 1/10,   zayin  => 1/11) ps{:heth} = (1 - ps.values.sum) var picker = prob_choice_picker(ps)var results = Hash() TRIALS.times {    results{picker()} := 0 ++;} say strv;for k,v in (results.sort_by {|k| results{k} }.reverse) {    printf(""%-6s  %f  %f  %f"",        k, v/TRIALS, ps{k},        abs(v/TRIALS - ps{k})    );}"
"require strv def prime_conspiracy(m)  conspiracy = Hash.new(0)  Prime.take(m).map{|n| n%10}.each_cons(2){|a,b| conspiracy[[a,b]] += 1}  puts strv  conspiracy.sort.each do |(a,b),v|    puts strv % [a, b, v, 100.0*v/m]  endend prime_conspiracy(1_000_000)var primes = (^Inf -> lazy.grep{.is_prime}) var upto = 1e6var conspiracy = Hash() primes.first(upto+1).reduce { |a,b|    var d = b%10    conspiracy{strv} := 0 ++    d} for k,v in (conspiracy.sort_by{|k,_v| k }) {    printf(""%s count: %6sfrequency: %2.2f %"", k, v.commify, v / upto * 100)}"
"class PriorityQueueNaive  def initialize(data=nil)    @q = Hash.new {|h, k| h[k] = []}    data.each {|priority, item| @q[priority] << item}  if data    @priorities = @q.keys.sort  end   def push(priority, item)    @q[priority] << item    @priorities = @q.keys.sort  end   def pop    p = @priorities[0]    item = @q[p].shift    if @q[p].empty?      @q.delete(p)      @priorities.shift    end    item  end   def peek    unless empty?      @q[@priorities[0]][0]    end  end   def empty?    @priorities.empty?  end   def each    @q.each do |priority, items|      items.each {|item| yield priority, item}    end  end   def dup    @q.each_with_object(self.class.new) do |(priority, items), obj|      items.each {|item| obj.push(priority, item)}    end  end   def merge(other)    raise TypeError  unless self.class == other.class    pq = dup    other.each {|priority, item| pq.push(priority, item)}    pq                  
  end   def inspect    @q.inspect  endend test = [  [6, strv],  [3, strv],  [4, strv],  [5, strv],  [6, strv],  [1, strv],  [2, strv],] pq = PriorityQueueNaive.newtest.each {|pr, str| pq.push(pr, str) }until pq.empty?   puts pq.popend putstest2 = test.shift(3)p pq1 = PriorityQueueNaive.new(test)p pq2 = PriorityQueueNaive.new(test2)p pq3 = pq1.merge(pq2)puts strvuntil pq3.empty?  puts pq3.popendputs strvclass PriorityQueue {    has tasks = []     method insert (Number priority { _ >= 0 }, task) {        for n in range(tasks.len, priority) {            tasks[n] = []        }        tasks[priority].append(task)    }     method get      { tasks.first { !.is_empty } -> shift }    method is_empty { tasks.all   {  .is_empty } }} var pq = PriorityQueue() [    [3, 'Clear drains'],    [4, 'Feed cat'],    [5, 'Make tea'],    [9, 'Sleep'],    [3, 'Check email'],    [1, 'Solve RC tasks'],    [9, 'Exercise'],    [2, 'Do taxes'],].each { |pair|    pq.insert(pair...)} say pq.get while !pq.is_empty"
"irb(main):001:0> require 'prime'=> trueirb(main):003:0> 2543821448263974486045199.prime_division=> [[701, 1], [1123, 2], [2411, 1], [1092461, 2]]

def prime_factors(i)  v = (2..i-1).detect{|j| i % j == 0}   v ? ([v] + prime_factors(i/v)) : [i]end 

(2..31).each do |i|  factors = prime_factors(2**i-1)  puts strvend


def prime_factors_faster(i)  factors = []  check = proc do |p|    while(q, r = i.divmod(p)          r.zero?)      factors << p      i = q    end  end  check[2]  check[3]  p = 5  while p * p <= i    check[p]    p += 2    check[p]    p += 4    
  end  factors << i if i > 1  factorsend 


(2..70).each do |i|  factors = prime_factors_faster(2**i-1)  puts strvendrequire 'benchmark'require 'mathn'Benchmark.bm(24) do |x|  [2**25 - 6, 2**35 - 7].each do |i|    puts strv    x.report(strv) { prime_factors(i) }    x.report(strv) { prime_factors_faster(i) }    x.report(strv) { i.prime_division }  endendrequire('ntheory')func prime_factors(n) {    [%S<ntheory>.factor(n.to_s)]}func prime_factors(n) {    var p = 3;    var out = [];    return out if (n < 1);    while (!(n & 1)) {        n >>= 1;        out << 2;    }    while ((n > 1) && (p*p <= n)) {        while (n %% p) {            n /= p;            out << p;        }        p += 2;    }    out << n if (n > 1);    return out;}say prime_factors(536870911);"
"


class Array  
  def power_set     
    
    
    inject([[]]) do |acc, you|      ret = []             
      acc.each do |i|      
        ret << i           
        ret << i + [you]   
      end      ret       
    end   end   
  def func_power_set    inject([[]]) { |ps,item|    
      ps +                      
      ps.map { |e| e + [item] } 
    }  endend #A direct translation of the strv version aboverequire 'set'class Set  def powerset     inject(Set[Set[]]) do |ps, item|       ps.union ps.map {|e| e.union (Set.new [item])}    end  endend p [1,2,3,4].power_setp %w(one two three).func_power_set p Set[1,2,3].powersetvar arr = %w(a b c)for i in (0 .. arr.len) {    say arr.combinations(i)}"
"class Integer   def popcount    self.digits(2).count(1)     #pre Ruby 2.4: self.to_s(2).count(strv)  end   def evil?    self >= 0 && popcount.even?  end   def odious?    self > 0  && popcount.odd?  end end puts strv,  (0...30).map{|n| (3**n).popcount}.join(' ')puts strv  , 0.step.lazy.select(&:evil?  ).first(30).join(' ')puts strv, 0.step.lazy.select(&:odious?).first(30).join(' ')func population_count(n) { n.as_bin.count('1') };say strv; var numbers = 60.of { |i|    [i-1, population_count(i-1)];}; say strv;say strv;"
"require 'matrix' def regress x, y, degree  x_data = x.map { |xi| (0..degree).map { |pow| (xi**pow).to_f } }   mx = Matrix[*x_data]  my = Matrix.column_vector(y)   ((mx.t * mx).inv * mx.t * my).transpose.to_a[0]endbetas = regress [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],                [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321],                2 p betasvar Matrix = require('Math::Matrix'); func regress(x, y, degree) {    var x_data = x.map { |xi| (0..degree).map { |pow| (xi**pow).to_f } };     var mx = Matrix.new(x_data...);    var my = Matrix.new(y.map{[_]}...);     mx.transpose.multiply(mx).invert.multiply(mx.transpose).multiply(my).transpose;} var betas = regress(    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],    [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321],    2); betas.print;"
"def prime(a)  if a == 2    true  elsif a <= 1 || a % 2 == 0    false  else    divisors = (3..Math.sqrt(a)).step(2)    divisors.none? { |d| a % d == 0 }  endendp (1..50).select{|i| prime(i)}require strvdef prime?(value, generator = Prime::Generator23.new)  return false if value < 2  for num in generator    q,r = value.divmod num    return true if q < num    return false if r == 0  endendp (1..50).select{|i| prime?(i)}def primes(limit)  (enclose = lambda { |primes|    primes.last.succ.upto(limit) do |trial_pri|      if primes.none? { |pri| (trial_pri % pri).zero? }        return enclose.call(primes << trial_pri)      end    end    primes  }).call([2])endp primes(50)def isprime(n)  '1'*n !~ /^1?$|^(11+?)\1+$/endfunc is_prime(a) {  given (a) {    when (2)                   { true  }    case (a <= 1 || a.is_even) { false }    default                    { 3 .. a.isqrt -> any { .divides(a) } -> not }  }}"
"def rescale_price_fraction(value)  raise ArgumentError, strv if value < 0 || value >= 1.01  if     value < 0.06  then  0.10  elsif  value < 0.11  then  0.18  elsif  value < 0.16  then  0.26  elsif  value < 0.21  then  0.32  elsif  value < 0.26  then  0.38  elsif  value < 0.31  then  0.44  elsif  value < 0.36  then  0.50  elsif  value < 0.41  then  0.54  elsif  value < 0.46  then  0.58  elsif  value < 0.51  then  0.62  elsif  value < 0.56  then  0.66  elsif  value < 0.61  then  0.70  elsif  value < 0.66  then  0.74  elsif  value < 0.71  then  0.78  elsif  value < 0.76  then  0.82  elsif  value < 0.81  then  0.86  elsif  value < 0.86  then  0.90  elsif  value < 0.91  then  0.94  elsif  value < 0.96  then  0.98  elsif  value < 1.01  then  1.00  endendclass Price  ConversionTable = <<-END_OF_TABLE    >=  0.00  <  0.06  :=  0.10    >=  0.06  <  0.11  :=  0.18    >=  0.11  <  0.16  :=  0.26    >=  0.16  <  0.21  :=  0.32    >=  0.21  <  0.26  :=  0.38    >=  0.26  <  0.31  :=  0.44    >=  0.31  <  0.36  :=  0.50    >=  0.36  <  0.41  :=  0.54    >=  0.41  <  0.46  :=  0.58    >=  0.46  <  0.51  :=  0.62    >=  0.51  <  0.56  :=  0.66    >=  0.56  <  0.61  :=  0.70    >=  0.61  <  0.66  :=  0.74    >=  0.66  <  0.71  :=  0.78    >=  0.71  <  0.76  :=  0.82    >=  0.76  <  0.81  :=  0.86    >=  0.81  <  0.86  :=  0.90    >=  0.86  <  0.91  :=  0.94    >=  0.91  <  0.96  :=  0.98    >=  0.96  <  1.01  :=  1.00  END_OF_TABLE   RE = %r{ ([<>=]+) \s* (\d\.\d\d) \s* ([<>=]+) \s* (\d\.\d\d) \D+ (\d\.\d\d) }x   
  CONVERSION_TABLE = ConversionTable.lines.inject([]) do |table, line|     m = line.match(RE)     if not m.nil? and m.length == 6      table << [m[1], m[2].to_f, m[3], m[4].to_f, m[5].to_f]     end    table  end   MIN_COMP, MIN = CONVERSION_TABLE[0][0..1]   MAX_COMP, MAX = CONVERSION_TABLE[-1][2..3]   def initialize(value)    if (not value.send(MIN_COMP, MIN)) or (not value.send(MAX_COMP, MAX))      raise ArgumentError, strv    end    @standard_value = CONVERSION_TABLE.find do |comp1, lower, comp2, upper, standard|      value.send(comp1, lower) and value.send(comp2, upper)    end.last  end  attr_reader :standard_valueendrequire 'test/unit' class PriceFractionTests <   @@ok_tests = [    [0.3793, 0.54],    [0.4425, 0.58],    [0.0746, 0.18],    [0.6918, 0.78],    [0.2993, 0.44],    [0.5486, 0.66],    [0.7848, 0.86],    [0.9383, 0.98],    [0.2292, 0.38],  ]  @@bad_tests = [1.02, -3]   def test_ok    @@ok_tests.each do |val, exp|       assert_equal(exp, rescale_price_fraction(val))      assert_equal(exp, Price.new(val).standard_value)    end    @@bad_tests.each do |val|       assert_raise(ArgumentError) {rescale_price_fraction(val)}      assert_raise(ArgumentError) {Price.new(val).standard_value}    end  endendvar table = <<'EOT'.lines.map { .words.grep{.is_numeric}.map{.to_n} }>=  0.00  <  0.06  :=  0.10>=  0.06  <  0.11  :=  0.18>=  0.11  <  0.16  :=  0.26>=  0.16  <  0.21  :=  0.32>=  0.21  <  0.26  :=  0.38>=  0.26  <  0.31  :=  0.44>=  0.31  <  0.36  :=  0.50>=  0.36  <  0.41  :=  0.54>=  0.41  <  0.46  :=  0.58>=  0.46  <  0.51  :=  0.62>=  0.51  <  0.56  :=  0.66>=  0.56  <  0.61  :=  0.70>=  0.61  <  0.66  :=  0.74>=  0.66  <  0.71  :=  0.78>=  0.71  <  0.76  :=  0.82>=  0.76  <  0.81  :=  0.86>=  0.81  <  0.86  :=  0.90>=  0.86  <  0.91  :=  0.94>=  0.91  <  0.96  :=  0.98>=  0.96  <  1.01  :=  1.00EOT func price(money) {    table.each { |row|           (row[0] <= money) ->        && (row[1] >  money) ->        && return row[2];    }    die strv;} for n in %n(0.3793 0.4425 0.0746 0.6918 0.2993 0.5486 0.7848 0.9383 0.2292) {    say price(n);}"
"class Point  attr_accessor :x,:y  def initialize(x=0, y=0)    self.x = x    self.y = y  end  def to_s    strv  endend 
class Circle < Point  attr_accessor :r  def initialize(x=0, y=0, r=0)    self.x = x    self.y = y    self.r = r  end  def to_s    strv  endend
puts Point.new          
p = Point.new(1, 2)puts p                  
puts p.x                
p.y += 1puts p                  
 
c = Circle.new(4,5,6)
d = c.dupd.r = 7.5puts c                  
puts d                  
class Point(x=0, y=0) { } class Circle(x=0, y=0, r=0) { } func pp(Point obj) {    say strv;} func pp(Circle obj) {    say strv;}pp(Point.new);              
var p = Point(1, 2);        
pp(p);                      
say p.x;                    
p.y += 1;                   
pp(p);                      
 var c = Circle(4,5,6);      
var d = c.clone;            
d.r = 7.5;                  
pp(c);                      
pp(d);                      
"
"require 'win32/sound'include Win32 sound1 = ENV['WINDIR'] + 'ediaindows XP Startup.wav' sound2 = ENV['WINDIR'] + 'ediaindows XP Shutdown.wav'  puts strv[sound1, sound2].each do |s|   t1 = Time.now  Sound.play(s)  puts strvend puts strv[sound1, sound2].each {|s| Sound.play(s, Sound::ASYNC)} puts <<END
the above only plays the second sound2 because the library only appears 
to be able to play one sound at a time.
END puts strvputs Time.nowSound.play(sound1, Sound::ASYNC + Sound::LOOP)sleep 10Sound.stopputs Time.now puts strvvol_left, vol_right = Sound.wave_volumeSound.play(sound1, Sound::ASYNC)sleep 1puts strvSound.set_wave_volume(vol_left, 0)sleep 1puts strvSound.set_wave_volume(0, vol_right)sleep 1puts strvSound.set_wave_volume(vol_left, vol_right) sleep 1puts strv"
"class T  def name    strv  endend class S  def name    strv  endend obj1 = T.newobj2 = S.newputs obj1.dup.name 
puts obj2.dup.name 
class T(value) {    method display {        say value;    }} class S(value) < T {    method display {        say value;    }} var obj1 = T(strv);var obj2 = S(strv);var obj3 = obj2.dclone;         
 obj1.value = strv;             
obj2.value = strv;             
 obj1.display;                   
obj2.display;                   
obj3.display;                   
"
"require 'gnuplot' x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]Gnuplot.open do |gp|  Gnuplot::Plot.new( gp ) do |plot|    plot.data << Gnuplot::DataSet.new( [x, y] ) do |ds|      ds.with = strv      ds.notitle    end  endendrequire('GD::Graph::points') var data = [    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],    [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0],] var graph = %s'GD::Graph::points'.new(400, 300)var gd = graph.plot(data) var format = 'png'File(strv).write(gd.(format), :raw)"
"def polynomial_long_division(numerator, denominator)  dd = degree(denominator)  raise ArgumentError, strv if dd < 0  if dd == 0    return [multiply(numerator, 1.0/denominator[0]), [0]*numerator.length]  end   q = [0] * numerator.length   while (dn = degree(numerator)) >= dd    d = shift_right(denominator, dn - dd)    q[dn-dd] = numerator[dn] / d[degree(d)]    d = multiply(d, q[dn-dd])    numerator = subtract(numerator, d)  end   [q, numerator]end def degree(ary)  idx = ary.rindex(&:nonzero?)  idx ? idx : -1end def shift_right(ary, n)  [0]*n + ary[0, ary.length - n]end def subtract(a1, a2)  a1.zip(a2).collect {|v1,v2| v1 - v2}end def multiply(ary, num)  ary.collect {|x| x * num}end f = [-42, 0, -12, 1]g = [-3, 1, 0, 0]q, r = polynomial_long_division(f, g)puts strv
 g = [-3, 1, 1, 0]q, r = polynomial_long_division(f, g)puts strv
def polynomial_division(f, g)  if g.length == 0 or (g.length == 1 and g[0] == 0)    raise ArgumentError, strv  elsif g.length == 1    [f.collect {|x| Float(x)/g[0]}, [0]]  elsif g.length == 2    synthetic_division(f, g)  else     higher_degree_synthetic_division(f, g)  endend def synthetic_division(f, g)  board = [f] << Array.new(f.length) << Array.new(f.length)  board[2][0] = board[0][0]   1.upto(f.length - 1).each do |i|    board[1][i] = board[2][i-1] * -g[1]    board[2][i] = board[0][i] + board[1][i]  end   [board[2][0..-2], [board[2][-1]]]end 

def higher_degree_synthetic_division(f, g)   
  lhs = g[1..-1].collect {|x| -x}  board = [f]   q = []  1.upto(f.length - lhs.length).each do |i|    n = 2*i - 1     
    
    
    q << board[n-1][i-1]    board << Array.new(f.length).fill(0, i) 
    (lhs.length).times do |j|      board[n][i+j] = q[-1]*lhs[j]    end     
    board << Array.new(f.length).fill(0, i) 
    (lhs.length + 1).times do |j|      board[n+1][i+j] = board[n-1][i+j] + board[n][i+j] if i+j < f.length    end  end   
  r = board[-1].compact  q = [0] if q.empty?  [q, r]end f = [1, -12, 0, -42]g = [1, -3]q, r = polynomial_division(f, g)puts strv
 g = [1, 1, -3]q, r = polynomial_division(f, g)puts strv
def polynomial_division(f, g)  if g.length == 0 or (g.length == 1 and g[0] == 0)    raise ArgumentError, strv  end  return [[0], f] if f.length < g.length   q, n = [], f.dup  while n.length >= g.length    q << Float(n[0]) / g[0]    n[0, g.length].zip(g).each_with_index do |pair, i|      n[i] = pair[0] - q[-1] * pair[1]    end    n.shift  end  q = [0] if q.empty?  n = [0] if n.empty?  [q, n]end f = [1, -12, 0, -42]g = [1, -3]q, r = polynomial_division(f, g)puts strv
 g = [1, 1, -3]q, r = polynomial_division(f, g)puts strv
func poly_long_div(rn, rd) {     var n = rn.map{_}    var gd = rd.len     if (n.len >= gd) {        return(gather {            while (n.len >= gd) {                var piv = n[0]/rd[0]                take(piv)                0.to(n.len.min(gd)-1).each { |i|                    n[i] -= (rd[i] * piv)                }                n.shift            }        }, n)    }     return([0], rn)}func poly_print(c) {    var l = c.len    c.each_kv {|i, n|        print n        print(strv, (l - i - 1), strv) if (i < l-1)    }    print """";} var poly = [    Pair([1,-12,0,-42],  [1, -3]),    Pair([1,-12,0,-42], [1,1,-3]),    Pair(      [1,3,2],    [1,1]),    Pair( [1,-4,6,5,3],  [1,2,1]),] poly.each { |pair|    var (q, r) = poly_long_div(pair.first, pair.second)    poly_print(q)    poly_print(r)    print """"}"
"class Card  include Comparable  attr_accessor :ordinal  attr_reader :suit, :face    SUITS = %i(♥ ♦ ♣ ♠)  FACES = %i(2 3 4 5 6 7 8 9 10 j q k a)   def initialize(str)    @face, @suit = parse(str)    @ordinal = FACES.index(@face)  end   def <=> (other) #used for sorting    self.ordinal <=> other.ordinal  end   def to_s    """"  end   private  def parse(str)    face, suit = str.chop.to_sym, str[-1].to_sym    raise ArgumentError, strv unless FACES.include?(face) && SUITS.include?(suit)    [face, suit]  endend class Hand  include Comparable  attr_reader :cards, :rank   RANKS       = %i(high-card one-pair two-pair three-of-a-kind straight flush                   full-house four-of-a-kind straight-flush five-of-a-kind)  WHEEL_FACES = %i(2 3 4 5 a)   def initialize(str_of_cards)    @cards = str_of_cards.downcase.tr(',',' ').split.map{|str| Card.new(str)}    grouped = @cards.group_by(&:face).values    @face_pattern = grouped.map(&:size).sort    @rank = categorize    @rank_num = RANKS.index(@rank)    @tiebreaker = grouped.map{|ar| [ar.size, ar.first.ordinal]}.sort.reverse  end   def <=> (other)    
    self.compare_value <=> other.compare_value  end   def to_s    @cards.map(&:to_s).join(strv)  end   protected          
  def compare_value    [@rank_num, @tiebreaker]  end   private  def one_suit?    @cards.map(&:suit).uniq.size == 1  end   def consecutive?    sort.each_cons(2).all? {|c1,c2| c2.ordinal - c1.ordinal == 1 }  end   def sort    if @cards.sort.map(&:face) == WHEEL_FACES      @cards.detect {|c| c.face == :a}.ordinal = -1    end     @cards.sort  end   def categorize    if consecutive?      one_suit? ? :'straight-flush' : :straight    elsif one_suit?      :flush    else      case @face_pattern        when [1,1,1,1,1] then :'high-card'        when [1,1,1,2]   then :'one-pair'        when [1,2,2]     then :'two-pair'        when [1,1,3]     then :'three-of-a-kind'        when [2,3]       then :'full-house'        when [1,4]       then :'four-of-a-kind'        when [5]         then :'five-of-a-kind'      end    end  endend 
test_hands = <<EOS
2♥ 2♦ 2♣ k♣ q♦
2♥ 5♥ 7♦ 8♣ 9♠
a♥ 2♦ 3♣ 4♣ 5♦
2♥ 3♥ 2♦ 3♣ 3♦
2♥ 7♥ 2♦ 3♣ 3♦
2♥ 6♥ 2♦ 3♣ 3♦
10♥ j♥ q♥ k♥ a♥
4♥ 4♠ k♠ 2♦ 10♠
4♥ 4♠ k♠ 3♦ 10♠
q♣ 10♣ 7♣ 6♣ 4♣
q♣ 10♣ 7♣ 6♣ 3♣
9♥ 10♥ q♥ k♥ j♣
2♥ 3♥ 4♥ 5♥ a♥
2♥ 2♥ 2♦ 3♣ 3♦
EOS hands = test_hands.each_line.map{|line| Hand.new(line) }puts strvhands.sort.reverse.each{|hand| puts ""#{hand} #{hand.rank}"" }puts str = <<EOS
joker  2♦  2♠  k♠  q♦
joker  5♥  7♦  8♠  9♦
joker  2♦  3♠  4♠  5♠
joker  3♥  2♦  3♠  3♦
joker  7♥  2♦  3♠  3♦
joker  7♥  7♦  7♠  7♣
joker  j♥  q♥  k♥  A♥
joker  4♣  k♣  5♦ 10♠
joker  k♣  7♣  6♣  4♣
joker  2♦  joker  4♠  5♠
joker  Q♦  joker  A♠ 10♠
joker  Q♦  joker  A♦ 10♦
joker  2♦  2♠  joker  q♦
EOS 


 DECK = Card::FACES.product(Card::SUITS).map(&:join)str.each_line do |line|  cards_in_arrays = line.split.map{|c| c == strv ? DECK.dup : [c]} #joker is array of all cards  all_tries  = cards_in_arrays.shift.product(*cards_in_arrays).map{|ar| Hand.new(ar.joinstrv)} #calculate the Whatshisname product  best = all_tries.max  puts strvend"
"class PigGame  Player = Struct.new(:name, :safescore, :score) do    def bust!() self.score = safescore end    def stay!() self.safescore = score end    def to_s() strv end  end   def initialize(names, maxscore=100, die_sides=6)    rotation = names.map {|name| Player.new(name,0,0) }     rotation.cycle do |player|      loop do        if wants_to_roll?(player)          puts strv          if bust?(roll)            puts strv,''            player.bust!            break          else            player.score += roll            if player.score >= maxscore              puts player.name + strv              return            end          end        else          player.stay!          puts strv, ''          break        end      end    end  end   def roll_dice(die_sides) rand(1..die_sides) end  def bust?(roll) roll==1 end  def wants_to_roll?(player)    print strv    ['Y','y',''].include?(gets.chomp)  endend PigGame.new( %w|Samuel Elizabeth| )"
" def player1(sum,sm)for i in 1..100puts strva=gets.chomp().to_iif (a>1 && a<7)	sum+=a	if sum>=100	puts strv	break	endelse goto player2(sum,sm)endi+=1endend def player2(sum,sm)for j in 1..100puts strvb=gets.chomp().to_iif(b>1 && b<7) sm+=b	if sm>=100	 puts strv	break	endelse player1(sum,sm)endj+=1endendi=0j=0sum=0sm=0player1(sum,sm)returnvar (games=100) = ARGV.map{.to_i}... define DIE = 1..6;define GOAL = 100; class Player(score=0, ante=0, rolls=0, strategy={false}) {    method turn {        rolls = 0;        ante  = 0;        loop {            rolls++;            given (var roll = DIE.rand) {                when (1) {                    ante = 0;                    break;                }                case (roll > 1) {                    ante += roll;                }            }            ((score + ante >= GOAL) || strategy) && break;        }        score += ante;    }} var players = []; 
players[0] = Player.new; 
players[1] = Player.new( strategy: { players[1].rolls >= 5 } ); 
players[2] = Player.new( strategy: { players[2].ante > 20 } ); 
players[3] = Player.new( strategy: { 1.rand < 0.1 } ); 
players[4] = Player.new( strategy: { 1.rand < ((GOAL - players[4].score) * 0.6 / GOAL) } ); var wins = [0]*players.len; games.times {    var player = -1;    loop {        player++;        var p = players[player % players.len];        p.turn;        p.score >= GOAL && break;    }    wins[player % players.len]++;    players.map{.score}.join("""").say;    players.each { |p| p.score = 0 };} say ""SCORES: for #{games} games"";say wins.join("""");"
"class Card  
  SUITS = %i[ Clubs Hearts Spades Diamonds ]  PIPS  = %i[ 2 3 4 5 6 7 8 9 10 Jack Queen King Ace ]   
  @@suit_value = Hash[ SUITS.each_with_index.to_a ]  @@pip_value  = Hash[ PIPS.each_with_index.to_a ]   attr_reader :pip, :suit   def initialize(pip,suit)    @pip = pip    @suit = suit  end   def to_s    ""} }""  end   
  def <=>(other)    (@@suit_value[@suit] <=> @@suit_value[other.suit]).nonzero? or    @@pip_value[@pip] <=> @@pip_value[other.pip]  endend class Deck  def initialize    @deck = Card::SUITS.product(Card::PIPS).map{|suit,pip| Card.new(pip,suit)}  end   def to_s    @deck.inspect  end   def shuffle!    @deck.shuffle!    self  end   def deal(*args)    @deck.shift(*args)  endend deck = Deck.new.shuffle!puts card = deck.dealhand = deck.deal(5)puts hand.join(strv)puts hand.sort.join(strv)define Pip = <A 2 3 4 5 6 7 8 9 10 J Q K>;define Suit = <♦ ♣ ♥ ♠>; class Card(pip, suit) {    method to_s { pip + suit }} class Deck(cards=[]) {     method init {        cards = gather {            Pip.each { |p| Suit.each { |s| take(Card(p, s)) } }        }    }     method shuffle {        cards.shuffle!;    }     method deal { cards.shift };    method to_s { cards.join(strv) };} var d = Deck();say strv; var top = d.deal;say strv; d.shuffle;say strv;"
"irb(main):001:0> %w(north east south west).sample=> strvirb(main):002:0> (1..100).to_a.sample(2)=> [17, 79]var arr = %w(north east south west);say arr.rand;say arr.rand(2).dump;"
"str = strv puts str.reverse                          
puts str.split.map(&:reverse).join(strv)   
puts str.split.reverse.join(strv)          
var str    = strv; say str.reverse;                            
say str.words.map{.reverse}.join(' ');      
say str.words.reverse.join(' ');            
"
"class Permutation  include Enumerable  attr_reader :num_elements, :size   def initialize(num_elements)    @num_elements = num_elements    @size = fact(num_elements)  end   def each    return self.to_enum unless block_given?    (0...@size).each{|i| yield unrank(i)}  end   def unrank(r)  
    pi = (0...num_elements).to_a    (@num_elements-1).downto(1) do |n|      s, r = r.divmod(fact(n))      pi[n], pi[s] = pi[s], pi[n]    end    pi  end   def rank(pi)  
    pi = pi.dup    pi1 = pi.zip(0...pi.size).sort.map(&:last)    (pi.size-1).downto(0).inject(0) do |memo,i|      pi[i], pi[pi1[i]] = pi[pi1[i]], (s = pi[i])      pi1[s], pi1[i] = pi1[i], pi1[s]      memo += s * fact(i)    end  end   private  def fact(n)    n.zero? ? 1 : n.downto(1).inject(:*)  endendputs strvperm = Permutation.new(3)(0...perm.size).each{|num| puts strv} puts ""4 random samples of 12 items from and back to rank.""perm = Permutation.new(12)4.times{ puts strv % [r=rand(perm.size), prm=perm.unrank(r), perm.rank(prm)]} puts ""4 random uniq samples of 144 items:""perm, rands = Permutation.new(144), {}
rands[rand(perm.size)] = true until rands.size == 1_000_000 random_perms = rands.each_key.lazy{|k| perm.unrank(k)}
4.times do  p r = random_perms.next  p prm = perm.unrank(r)  p perm.rank(prm) == rend"
"require strv class Integer   def popcount    to_s(2).count(strv)   #Ruby 2.4:  digits(2).count(1)  end   def pernicious?    popcount.prime?  end end p 1.step.lazy.select(&:pernicious?).take(25).to_ap ( 888888877..888888888).select(&:pernicious?)func is_pernicious(n) {    var c = 2693408940;  
    while (n > 0) { c >>= 1; n &= (n - 1) }    c & 1;} var (i, *p) = 0;while (p.len < 25) {    p << i if is_pernicious(i);    ++i;} say p.join(' '); var (i, *p) = 888888877;while (i < 888888888) {    p << i if is_pernicious(i);    ++i;} say p.join(' ');"
"def pi  q, r, t, k, n, l = 1, 0, 1, 1, 3, 3  dot = nil  loop do    if 4*q+r-t < n*t      yield n      if dot.nil?         yield '.'        dot = '.'      end      nr = 10*(r-n*t)      n = ((10*(3*q+r)) / t) - 10*n      q *= 10      r = nr    else      nr = (2*q+r) * l      nn = (q*(7*k+2)+r*l) / (t*l)      q *= k      t *= l      l += 2      k += 1      n = nn      r = nr    end  endend pi {|digit| print digit; $stdout.flush}func pi(callback) {    var (q, r, t, k, n, l) = (1, 0, 1, 1, 3, 3);    loop {        if ((4*q + r - t) < n*t) {            callback(n);            static _dot = callback('.');            var nr = 10*(r-n*t);            n = (int((10*(3*q + r)) / t) - 10*n);            q *= 10;            r = nr;        }        else {            var nr = ((2*q + r) * l);            var nn = int((q*(7*k + 2) + r*l) / (t*l));            q *= k;            t *= l;            l += 2;            k += 1;            n = nn;            r = nr;        }    }} STDOUT.autoflush(1);pi(func(digit){ print digit });"
"def derangements(n)  ary = (1 .. n).to_a  ary.permutation.select do |perm|    ary.zip(perm).all? {|a,b| a != b}  endend def subfact(n)  case n  when 0 then 1  when 1 then 0  else (n-1)*(subfact(n-1) + subfact(n-2))  endend puts strvderangements(4).each{|d|p d} puts "" n   derange  subfact""(0..9).each do |n|  puts strv % [n, derangements(n).size, subfact(n)]end puts ""Number of derangements""(10..20).each do |n|  puts strvend"
"rp = [1,2,3].repeated_permutation(2) 
p rp.to_a #=>[[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]] #yield permutations until their sum happens to exceed 4, then quit:p rp.take_while{|(a, b)| a + b < 5}  #=>[[1, 1], [1, 2], [1, 3], [2, 1], [2, 2]]"
"def perms(n)  p = Array.new(n+1){|i| -i}  s = 1  loop do    yield p[1..-1].map(&:abs), s    k = 0    for i in 2..n      k = i if p[i] < 0 and p[i].abs > p[i-1].abs and p[i].abs > p[k].abs    end    for i in 1...n      k = i if p[i] > 0 and p[i].abs > p[i+1].abs and  p[i].abs > p[k].abs    end    break if k.zero?    for i in 1..n      p[i] *= -1 if p[i].abs > p[k].abs    end    i = k + (p[k] <=> 0)    p[k], p[i] = p[i], p[k]    s = -s  endend for i in 3..4  perms(i){|perm, sign| puts strv}  putsendfunc perms(n) {   var perms = [[+1]]   n.times { |x|      var sign = -1;      perms = gather {        for s,*p in perms {          var r = (0 .. p.len);          take((s < 0 ? r : r.flip).map {|i|            [sign *= -1, p[0..i-1], x, p[i..p.end]]          }...)        }      }   }   perms;} var n = 4;for p in perms(n) {    var s = p.shift    s > 0 && (s = '+1')    say strv}"
"def statistic(ab, a)  sumab, suma = ab.inject(:+).to_f, a.inject(:+).to_f  suma / a.size - (sumab - suma) / (ab.size - a.size)end def permutationTest(a, b)  ab = a + b  tobs = statistic(ab, a)  under = count = 0  ab.combination(a.size) do |perm|    under += 1 if statistic(ab, perm) <= tobs    count += 1  end  under * 100.0 / countend treatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]controlGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]under = permutationTest(treatmentGroup, controlGroup)puts strv % [under, 100 - under]func statistic(ab, a) {    var(sumab, suma) = (ab.sum, a.sum);    suma/a.size - ((sumab-suma) / (ab.size-a.size))} func permutationTest(a, b) {    var ab = (a + b);    var tobs = statistic(ab, a);    var under = (var count = 0);    ab.combinations(a.len).each { |perm|        statistic(ab, perm) <= tobs && (under += 1);        count += 1;    };    under * 100 / count;} var treatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97];var controlGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98];var under = permutationTest(treatmentGroup, controlGroup);say (strv % (under, 100 - under));"
"def perfect_shuffle(deck_size = 52)	deck = (0...deck_size).to_a	shuffled_deck = [deck.first(deck_size / 2), deck.last(deck_size / 2)]	1.step do |i|		return i if deck == (shuffled_deck = shuffled_deck.transpose.flatten)		shuffled_deck = [shuffled_deck.shift(deck_size / 2), shuffled_deck]	endend [8, 24, 52, 100, 1020, 1024, 10000].each do |i| puts strv endfunc perfect_shuffle(deck) {     var a = deck/2     a[0] ~Z a[1] -> flatten} [8, 24, 52, 100, 1020, 1024, 10000].each { |size|     var deck = @(1..size);    var shuffled = deck;     var n = 0;    loop {        ++n;        shuffled = perfect_shuffle(shuffled);         shuffled.each_index { |i|            shuffled[i] == deck[i] || goto :NEXT;        }         break;        @:NEXT;    }     printf(""%5d cards: %4d"", size, n);}"
"require 'raster_graphics' class RGBColour  
  def -(a_colour)    (@red - a_colour.red).abs +    (@green - a_colour.green).abs +    (@blue - a_colour.blue).abs  endend class Pixmap  
  def -(a_pixmap)    if @width != a_pixmap.width or @height != a_pixmap.height      raise ArgumentError, strv    end    sum = 0    each_pixel {|x,y| sum += self[x,y] - a_pixmap[x,y]}    Float(sum) / (@width * @height * 255 * 3)  endend lenna50 = Pixmap.open_from_jpeg('Lenna50.jpg')lenna100 = Pixmap.open_from_jpeg('Lenna100.jpg') puts strv % (100.0 * (lenna50 - lenna100))require('Imager') func img_diff(a, b) {     func from_file(name) {         %s|Imager|.new(file => name)    }     func size(img) {        (img.getwidth, img.getheight)    }     func pixel_diff(p1, p2) {        [p1.rgba] »-« [p2.rgba] -> map { .abs }.sum    }     func read_pixel(img, x, y) {        img.getpixel(x => x, y => y)    }     var(img1, img2) = (from_file(a), from_file(b))     var(w1, h1) = size(img1)    var(w2, h2) = size(img2)     if ((w1 != w2) || (h1 != h2)) {        return nil    }     var sum = 0    for y,x in (^h1 ~X ^w1) {        sum += pixel_diff(read_pixel(img1, x, y), read_pixel(img2, x, y))    }     sum / (w1 * h1 * 255 * 3)} say 100*img_diff('Lenna50.jpg', 'Lenna100.jpg')"
"p [1,2,3].permutation.to_aclass Array  
  
  def distinct_permutation  # :yields: _ary_    
    block_given? or return enum_for(:distinct_permutation)     copy = self.sort    yield copy.dup    return if size < 2     while true      
      j = size - 2;      j -= 1 while j > 0 && copy[j] >= copy[j+1]      if copy[j] < copy[j+1]        l = size - 1        l -= 1 while copy[j] >= copy[l]         copy[j] , copy[l] = copy[l] , copy[j]        copy[j+1..-1] = copy[j+1..-1].reverse        yield copy.dup      else        break      end    end  endend permutations = [][1,1,2].distinct_permutation do |p| permutations << p endp permutations
 if RUBY_VERSION >= strv  p [1,1,2].distinct_permutation.to_a  
end[0,1,2].permutations { |p|    say p}func forperm(callback, n) {    var idx = @^n     loop {        callback([idx...])         var p = n-1        while (idx[p-1] > idx[p]) {--p}        p == 0 && return()         var d = p        idx += idx.splice(p).reverse         while (idx[p-1] > idx[d]) {++d}        idx.swap(p-1, d)    }     return()} forperm({|p| say p }, 3)func permutations(callback, set, perm=[]) {    set.is_empty && callback(perm)    for i in ^set {        __FUNC__(callback, [            set[(0 ..^ i)..., (i+1 ..^ set.len)...]        ], [perm..., set[i]])    }    return()} permutations({|p| say p }, [0,1,2])"
"Toss = [:Heads, :Tails] def yourChoice  puts strv  choice = []  3.times do    until (c = $stdin.getc.upcase) == strv or c == strv    end    choice << (c==strv ? Toss[0] : Toss[1])  end  puts strv  choiceend loop do  puts ""%s I start, %s you start ..... %s"" % [*Toss, coin = Toss.sample]  if coin == Toss[0]    myC = Toss.shuffle << Toss.sample    puts strv    yC = yourChoice  else    yC = yourChoice    myC = Toss - [yC[1]] + yC.first(2)    puts strv  end   seq = Array.new(3){Toss.sample}  print seq.join(' ')  loop do    puts "" I win!"" or break   if seq == myC    puts "" You win!"" or break if seq == yC    seq.push(Toss.sample).shift    print strv  endend"
"def perf(n)  sum = 0  for i in 1...n    sum += i  if n % i == 0  end  sum == nenddef perf(n)  n == (1...n).select {|i| n % i == 0}.inject(:+)enddef perf(n)  divisors = []  for i in 1..Math.sqrt(n)    divisors << i << n/i  if n % i == 0  end  divisors.uniq.inject(:+) == 2*nendfor n in 1..10000  puts n if perf(n)endrequire strv def mersenne_prime_pow?(p)  
  return true  if p == 2  m_p = ( 1 << p ) - 1   s = 4  (p-2).times{ s = (s**2 - 2) % m_p }  s == 0end @perfect_numerator = Prime.each.lazy.select{|p| mersenne_prime_pow?(p)}.map{|p| 2**(p-1)*(2**p-1)}@perfects = @perfect_numerator.take(1).to_a def perfect?(num)  @perfects << @perfect_numerator.next until @perfects.last >= num  @perfects.include? numend 
p (1..10000).select{|num| perfect?(num)}t1 = Time.nowp perfect?(13164036458569648337239753460458722910223472318386943117783728128)p Time.now - t1   func is_perfect(n) {    var sum = 0;    for i in (1 ..^ n) {        i.divides(n) && (sum += i);    }    sum == n;} 10000.times { |i|    is_perfect(i) && say i;}func is_even_perfect(n) {     var square = (8*n + 1)    square.is_sqr || return false     var tp = ((square.isqrt + 1) / 2)    tp.is_pow || return false     (tp-1).is_prime ? true : false} for i in range(0, 10000, 2) {    is_even_perfect(i) && say i}"
"ARRS = [(strv..strv).to_a,        (strv..strv).to_a,         (strv..strv).to_a,        %q(!strv quote to reset clumsy code colorizerALL  = ARRS.flatten def generate_pwd(size, num)  raise ArgumentError, strv unless size >= ARRS.size  num.times.map do    arr = ARRS.map(&:sample)    (size - ARRS.size).times{ arr << ALL.sample}    arr.shuffle.join  endend puts generate_pwd(8,3) "
"require 'rref' pyramid = [           [ 151],          [nil,nil],        [40,nil,nil],      [nil,nil,nil,nil],    [strv, 11,strv, 4,strv]]pyramid.each{|row| p row} equations = [[1,-1,1,0]]   
 def parse_equation(str)  eqn = [0] * 4  lhs, rhs = str.split(strv)  eqn[3] = rhs.to_i  for term in lhs.split(strv)    case term    when strv then eqn[0] += 1    when strv then eqn[1] += 1    when strv then eqn[2] += 1    else          eqn[3] -= term.to_i    end  end  eqn end -2.downto(-5) do |row|  pyramid[row].each_index do |col|    val = pyramid[row][col]    sum = strv % [pyramid[row+1][col], pyramid[row+1][col+1]]    if val.nil?      pyramid[row][col] = sum    else      equations << parse_equation(sum + strv)    end  endend reduced = convert_to(reduced_row_echelon_form(equations), :to_i) for eqn in reduced  if eqn[0] + eqn[1] + eqn[2] != 1    fail strv  elsif eqn[0] == 1 then x = eqn[3]  elsif eqn[1] == 1 then y = eqn[3]  elsif eqn[2] == 1 then z = eqn[3]  endend putsputs strvputs strvputs strv answer = []for row in pyramid  answer << row.collect {|cell| eval cell.to_s}endputsanswer.each{|row| p row}
var rows = 5;var tri = rows.of {|i| i.of { Hash(x => 0, z => 0, v => 0, rhs => nil) } }tri[0][0]{:rhs} = 151;tri[2][0]{:rhs} = 40;tri[4][0]{:x} = 1;tri[4][1]{:v} = 11;tri[4][2]{:x} = 1;tri[4][2]{:z} = 1;tri[4][3]{:v} = 4;tri[4][4]{:z} = 1; 
for row in (tri.end -> downto(1)) {    for col in (tri[row-1].range) {        [:x, :z, :v].each { |key|            tri[row-1][col]{key} = (tri[row][col]{key} + tri[row][col+1]{key})        }    }} 
var eqn = gather {    for r in tri {        for c in r {            take([c{:x}, c{:z}, c{:rhs} - c{:v}]) if defined(c{:rhs})        }    }} 
say strv;say strv;for x,z,y in eqn { say strv } 
var f = (eqn[0][1] / eqn[1][1]);for i in (0..2) { eqn[0][i] -= (f * eqn[1][i]) }f = (eqn[1][0] / eqn[0][0]);for i in (0..2) { eqn[1][i] -= (f * eqn[0][i]) } 
say strv;var x = (eqn[0][2] / eqn[0][0]);var z = (eqn[1][2] / eqn[1][1]);var y = (x + z);say strv;"
"def pascal(n)  raise ArgumentError, strv if n < 1  yield ar = [1]  (n-1).times do    ar.unshift(0).push(0) 
    yield ar = ar.each_cons(2).map{|a, b| a + b }   endend pascal(8){|row| puts row.join(strv).center(20)}def next_row(row) ([0] + row).zip(row + [0]).collect {|l,r| l + r } end def pascal(n) n.times.inject([1]) {|x,_| next_row x } end 8.times{|i| p pascal(i)}func pascal(rows) {    var row = [1];    { | n|        say row.join(' ');        row = [1, 0..(n-2).map {|i| row[i] + row[i+1] }..., 1];    } * rows;} pascal(10);"
"class RPNExpression   
  Operator = Struct.new(:precedence, :associativity, :english, :ruby_operator)  class Operator    def left_associative?; associativity == :left; end    def <(other)      if left_associative?         precedence <= other.precedence      else         precedence < other.precedence      end    end  end   Operators = {    strv => Operator.new(2, :left, strv, strv),    strv => Operator.new(2, :left, strv, strv),    strv => Operator.new(3, :left, strv, strv),    strv => Operator.new(3, :left, strv, strv),    strv => Operator.new(4, :right, strv, strv),  }   
  def initialize(str)    @expression = str    @infix_tree = nil    @value = nil  end  attr_reader :expression   
  def self.from_infix(expression)    debug ""for Infix expression: #{expression}TermActionOutputStack""    rpn_expr = []    op_stack = []    tokens = expression.split    until tokens.empty?      term = tokens.shift       if Operators.has_key?(term)        op2 = op_stack.last        if Operators.has_key?(op2) and Operators[term] < Operators[op2]          rpn_expr << op_stack.pop          debug ""#{term}#{Operators[op2].english}#{rpn_expr}#{op_stack}#{op2} has higher precedence than #{term}""        end        op_stack << term        debug ""#{term}PUSH OP#{rpn_expr}#{op_stack}""       elsif term == strv        op_stack << term        debug ""#{term}OPEN_P#{rpn_expr}#{op_stack}""       elsif term == strv        until op_stack.last == strv          rpn_expr << op_stack.pop          debug ""#{term}#{Operators[rpn_expr.last].english}#{rpn_expr}#{op_stack}unwinding parenthesis""        end        op_stack.pop        debug ""#{term}CLOSE_P#{rpn_expr}#{op_stack}""       else        rpn_expr << term        debug ""#{term}PUSH V#{rpn_expr}#{op_stack}""      end    end    until op_stack.empty?      rpn_expr << op_stack.pop    end    obj = self.new(rpn_expr.join(strv))    debug strv    obj  end   
  def eval    return @value unless @value.nil?     debug ""for RPN expression: #{expression}TermActionStack""    stack = []    expression.split.each do |term|      if Operators.has_key?(term)        a, b = stack.pop(2)        raise ArgumentError, strv if b.nil?        a = a.to_f if term == strv        op = (term == strv ? strv : term)        stack.push(a.method(op).call(b))        debug ""#{term}#{Operators[term].english}#{stack}""      else        begin          number = Integer(term) rescue Float(term)        rescue ArgumentError          raise ArgumentError, strv        end        stack.push(number)        debug ""#{number}PUSH#{stack}""      end    end    @value = stack.pop    debug ""Value = ""    @value  end   private  
  def to_infix_tree    return @infix_tree unless @infix_tree.nil?     debug ""for RPN expression: #{expression}TermActionStack""    stack = []    expression.split.each do |term|      if Operators.has_key?(term)        a, b = stack.pop(2)        raise ArgumentError, strv if b.nil?        op = InfixNode.new(term)        op.left = a        op.right = b        stack.push(op)        debug ""#{term}#{Operators[term].english}#{stack.inspect}""      else        begin          Integer(term) rescue Float(term)        rescue ArgumentError          raise ArgumentError, strv        end        stack.push(InfixNode.new(term))        debug ""#{term}PUSH#{stack.inspect}""      end    end    @infix_tree = stack.pop  end   public  
  def to_infix    expr = to_infix_tree.to_s    debug strv    expr  end   
  def to_ruby    expr = to_infix_tree.to_ruby    debug strv    expr  end   def to_s    expression  end    private  class InfixNode    def initialize(value)      @value = value      @left = nil      @right = nil    end    attr_reader :value    attr_accessor :left, :right     def leaf?      left.nil? and right.nil?    end     def to_s;    to_string(false); end    def to_ruby; to_string(true);  end      def to_string(to_ruby)      result = []      result << display_child(left, to_ruby, (to_ruby and value == strv))      result << (to_ruby ? Operators[value].ruby_operator : value)      result << display_child(right, to_ruby)      result.join(strv)    end     def display_child(child, to_ruby, need_float = false)      result = if child.leaf?                 child.value               elsif Operators[child.value].precedence < Operators[value].precedence                 strv               else                 child.to_string(to_ruby)               end      result += strv if need_float      result    end     def inspect      str = strv      str << strv unless leaf?      str    end  endend def debug(msg)  puts msg if $DEBUGend  require 'test/unit'class TestRPNExpression <   def setup    @rpn_expr = strv    @infix_expr = strv    @ruby_expr = strv    @value = 3.0001220703125   end   def test_eval    rpn = RPNExpression.new @rpn_expr    value = rpn.eval    assert_equal @value, value  end   def test_rpn_to_infix    rpn = RPNExpression.new @rpn_expr    infix = rpn.to_infix    assert_equal @infix_expr, infix    assert_equal @value, eval(rpn.to_ruby)  end   def test_infix_to_rpn    rpn = RPNExpression.from_infix @infix_expr    assert_equal @rpn_expr, rpn.to_s  end   def test_other_expressions    old_debug = $DEBUG    $DEBUG = false     rpn =   [strv,     strv]    infix = [strv, strv]    value = [strv,                   strv]     [0, 1].each do |idx|      obj = RPNExpression.new rpn[idx]      assert_equal value[idx], strv % obj.eval      assert_equal infix[idx], obj.to_infix      assert_equal value[idx], strv % eval(obj.to_ruby)      obj = RPNExpression.from_infix infix[idx]      assert_equal rpn[idx], obj.to_s    end    $DEBUG = old_debug   endend"
"fs = proc { |f, s| s.map &f }f1 = proc { |n| n * 2 }f2 = proc { |n| n ** 2 }fsf1 = fs.curry[f1]fsf2 = fs.curry[f2] [0..3, (2..8).step(2)].each do |e|  p fsf1[e]  p fsf2[e]endfunc fs(f) {    func(*args) {        args.map {f(_)}    }} func double(n) { n  * 2 };func square(n) { n ** 2 }; var fs_double = fs(double);var fs_square = fs(square); var s = (0 .. 3);say strv;say strv; s = [2, 4, 6, 8];say strv;say strv;"
"#Upper, lower, and symetric Pascal Matrix - Nigel Galloway: May 3rd., 21015require 'pp' ng = (g = 0..4).collect{[]}g.each{|i| g.each{|j| ng[i][j] = i==0 ? 1 : j<i ? 0 : ng[i-1][j-1]+ng[i][j-1]}}pp ng; putsg.each{|i| g.each{|j| ng[i][j] = j==0 ? 1 : i<j ? 0 : ng[i-1][j-1]+ng[i-1][j]}}pp ng; putsg.each{|i| g.each{|j| ng[i][j] = (i==0 or j==0) ? 1 : ng[i-1][j  ]+ng[i][j-1]}}pp ngrequire 'pp' def binomial_coeff(n,k) (1..k).inject(1){|res,i| res * (n-i+1) / i}             end def pascal_upper(n)     (0...n).map{|i| (0...n).map{|j| binomial_coeff(j,i)}}   enddef pascal_lower(n)     (0...n).map{|i| (0...n).map{|j| binomial_coeff(i,j)}}   enddef pascal_symmetric(n) (0...n).map{|i| (0...n).map{|j| binomial_coeff(i+j,j)}} end puts strvpp pascal_upper(5) puts ""Pascal lower-triangular matrix:""pp pascal_lower(5) puts ""Pascal symmetric matrix:""pp pascal_symmetric(5)func grow_matrix(matrix, callback) {    var m = matrix;    var s = m.len;    m[s][0] = callback(0, m[s-1][0], 0);    m[0][s] = callback(m[0][s-1], 0, 0);    {|i| m[i][s] = callback(m[i][s-1], m[i-1][s], m[i-1][s-1])} * (s-1);    {|i| m[s][i] = callback(m[s][i-1], m[s-1][i], m[s-1][i-1])} * (s);    return m;} func transpose(matrix) {    matrix[0].range.map{|i| matrix.map{_[i]}};} func madd_n_nw(m) { grow_matrix(m, ->(_, n, nw) { n + nw }) };func madd_w_nw(m) { grow_matrix(m, ->(w, _, nw) { w + nw }) };func madd_w_n(m)  { grow_matrix(m, ->(w, n, _)  { w + n  }) }; var functions = [madd_n_nw, madd_w_nw, madd_w_n].map { |f|    func(n) {        var r = [[1]];        n.times { f(r) };        transpose(r);    }} functions.map { |f|    f(4).map { .map{ '%2s' % _ }.join(' ') }.join("""");}.join("""").say;"
"#--


#

#++ require 'strscan' 


Line = Struct.new :where, :str 




Token = Struct.new :cat, :str, :line, :pos 
#--
#++def next_token  
  loop do    
    
    if @scanner.eos?      if s = @in.gets        
        
        @line = Line.new(""}:}"", s)        @scanner.string = s      else        return nil  
      end    end     
    break unless @scanner.skip(/[[:space:]]+/)  end   
  if s = @scanner.scan(/:/)    c = :colon  elsif s = @scanner.scan(/;/)    c = :semicolon  elsif s = @scanner.scan(/\(/)    c = :paren  elsif s = @scanner.scan(/\)\?/)    c = :option  elsif s = @scanner.scan(/\)\*/)    c = :repeat  elsif s = @scanner.scan(/\)/)    c = :group  elsif s = @scanner.scan(/\|/)    c = :bar  elsif s = @scanner.scan(/[[:alpha:]][[:alnum:]]*/)    c = :ident  elsif s = @scanner.scan(/'[^']*'|strv/)
    # Fix syntax highlighting for Rosetta Code. => '    c = :string  elsif s = @scanner.scan(/'[^']*|strv]*/)    c = :bad_string  elsif s = @scanner.scan(/.*/)    c = :unknown  end   Token.new(c, s, @line, (@scanner.pos - s.length))end 
def error(token, message)  line = token.line   
  
  
  
  STDERR.puts <<EOF
#{line.where}: #{message}
#{line.str.gsub(/[^[:print:]]/, strv)}
#{strv * token.pos}^
EOFend  #--

#++ 
class Grammar < Array; end 


Production = Struct.new :ident, :alts 
class Group < Array; end 
class OptionalGroup < Group; end 
class RepeatedGroup < Group; end 
class Alternative < Array; end #--
#++def parse  
  while t = next_token    error(t, strv)  endend 
case ARGV.lengthwhen 0 then @filename = strvwhen 1 then @filename = ARGV[0]else fail strvendopen(@filename) do |f|  @in = f  @scanner = StringScanner.new(strv)  parseend "
"rpn = RPNExpression.from_infix(strv)var prec = Hash(    '^' => 4,    '*' => 3,    '/' => 3,    '+' => 2,    '-' => 2,    '(' => 1,); var assoc = Hash(    '^' => 'right',    '*' => 'left',    '/' => 'left',    '+' => 'left',    '-' => 'left',); func shunting_yard(prog) {    var inp = prog.words;    var ops = [];    var res = [];     func report (op) { printf(""%25s    %-7s %10s %s"", res.join(' '), ops.join(' '), op, inp.join(' ')) }    func shift  (t)  { report( strv); ops << t }    func reduce (t)  { report(strv); res << t }     while (inp) {        given(var t = inp.shift) {           when (/\d/) { reduce(t) }           when ('(')  { shift(t) }           when (')')  { var x; while (ops && (x = ops.pop) && (x != '(')) { reduce(x) } }           default {                var newprec = prec{t};                while (ops) {                    var oldprec = prec{ops[-1]};                     break if (newprec > oldprec)                    break if ((newprec == oldprec) && (assoc{t} == 'right'))                     reduce(ops.pop);                }                shift(t);            }        }    }    while (ops) { reduce(ops.pop) }    return res} say shunting_yard('3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3').join(' ');"
"#!/usr/bin/env ruby 
#
#
#
#

#

#

#

 require strvrequire strv def phone(name, message)	puts strv	puts messageend def test	phone(strv, strv)	phone(strv, strv)end def main	mode = :usage 	name = strv	message = strv 	opts=GetoptLong.new(		[strv, strv, GetoptLong::NO_ARGUMENT],		[strv, strv, GetoptLong::REQUIRED_ARGUMENT],		[strv, strv, GetoptLong::REQUIRED_ARGUMENT],		[strv, strv, GetoptLong::NO_ARGUMENT]	) 	opts.each { |option, value|		case option		when strv			RDoc::usage(strv)		when strv			mode = :call			name = strv			message = value		when strv			mode = :call			name = strv			message = value		when strv			mode = :test		end	} 	case mode	when :usage		RDoc::usage(strv)	when :call		phone(name, message)	when :test		test	endend if __FILE__==$0	begin		main	rescue Interrupt => e		nil	endendrequire 'optparse' sflag = falselongflag = falsecount = 0percent = 50fruit = nil OptionParser.new do |opts|  
  opts.banner += strv  opts.separator strv  opts.version = strv   opts.on(strv, strv) {sflag = true}  opts.on(strv, strv) {longflag = true}  opts.on(strv, strv, strv          ) {sflag = true; longflag = true}  opts.on(strv, strv, strv) {count += 1}   
  opts.on(strv, strv, /[0-9]+%?/i,          strv) {|arg| percent = arg.to_i}   
  opts.on(strv, strv,          [:apple, :banana, :orange, :pear],          strv          ) {|arg| fruit = arg}   begin    
    opts.parse!  rescue OptionParser::ParseError => error    
    
    
     $stderr.puts error    $stderr.puts strv    exit 1  endend print <<EOF
Short flag: #{sflag}
Long flag: #{longflag}
Count: #{count}
Percent: #{percent}%
Fruit: #{fruit}
Arguments: #{ARGV.inspect}
EOF"
"rpn = RPNExpression.new(strv)infix = rpn.to_infixruby = rpn.to_rubyfunc p(pair, prec) {    pair[0] < prec ? strv : pair[1];} func rpm_to_infix(string) {    say ""#{'='*17}#{string}"";    var stack = [];    string.each_word { |w|        if (w ~~ /\d/) {            stack << [9, w.to_f];        }        else {            var y = stack.pop;            var x = stack.pop;            given(w) {              when ('^')   { stack << [4, [p(x,5), w, p(y,4)].join(' ')] }              when (<* />) { stack << [3, [p(x,3), w, p(y,3)].join(' ')] }              when (<+ ->) { stack << [2, [p(x,2), w, p(y,2)].join(' ')] }            }            say stack;        }    };    '-'*17 -> say;    stack.map{_[1]};} var tests = [    '3 4 2 * 1 5 - 2 3 ^ ^ / +',    '1 2 + 3 4 + ^ 5 6 + ^',]; tests.each { say rpm_to_infix(_).join(' ') }"
"require 'sqlite3' db = SQLite3::Database.new(strv) 
db.execute('create temp table players (name, score, active, jerseyNum)')db.execute('insert into players values (strv,99)')db.execute('insert into players values (strv,100)')db.execute('insert into players values (strv,101)') 
 
db.execute('update players set name=?, score=?, active=? where jerseyNum=?', 'Smith, Steve', 42, true, 99) 
db.execute('update players set name=:name, score=:score, active=:active where jerseyNum=:num',    :num => 100,    :name => 'John Doe',    :active => false,    :score => -1) 
stmt = db.prepare('update players set name=?4, score=?3, active=?2 where jerseyNum=?1')stmt.bind_param(1, 101)stmt.bind_param(2, true)stmt.bind_param(3, 3)stmt.bind_param(4, strv)stmt.execute 
db.execute2('select * from players') {|row| p row}"
rpn = RPNExpression(strv)value = rpn.evalvar proggie = '3 4 2 * 1 5 - 2 3 ^ ^ / +'; class RPN(arr=[]) {     method binop(op) {        var x = arr.pop        var y = arr.pop        arr << y.(op)(x)    }     method run(p) {        p.each_word { |w|            say strv;            given (w) {                when (/\d/) {                    arr << w.to_f                }                when (<+ - * />) {                    self.binop(w)                }                when ('^') {                    self.binop('**')                }                default {                    die strv                }            }        }        say arr[0]    }} RPN.new.run(proggie);
"require 'ipaddr'  TESTCASES = [strv,                strv,                strv,                      strv,                strv, strv]                             output = [%w(String Address Port Family Hex),          %w(------ ------- ---- ------ ---)] def output_table(rows)  widths = []  rows.each {|row| row.each_with_index {|col, i| widths[i] = [widths[i].to_i, col.to_s.length].max }}  format = widths.map {|size| strv}.join("""")  rows.each {|row| puts format % row}end TESTCASES.each do |str|  case str  
  when /\A\[(?<address> .* )\]:(?<port> \d+ )\z/x      
    address, port = $~[:address], $~[:port]  when /\A(?<address> [^:]+ ):(?<port> \d+ )\z/x       
    address, port = $~[:address], $~[:port]  else                                                 
    address, port = str, nil  end   ip_addr = IPAddr.new(address)   family = strv if ip_addr.ipv4?  family = strv if ip_addr.ipv6?   output << [str, ip_addr.to_s, port.to_s, family, ip_addr.to_i.to_s(16)]end output_table(output)"
"MAX_N = 500BRANCH = 4 def tree(br, n, l=n, sum=1, cnt=1)  for b in br+1 .. BRANCH    sum += n    return if sum >= MAX_N    
    return if l * 2 >= sum and b >= BRANCH    if b == br + 1      c = $ra[n] * cnt    else      c = c * ($ra[n] + (b - br - 1)) / (b - br)    end    $unrooted[sum] += c if l * 2 < sum    next if b >= BRANCH    $ra[sum] += c    (1...n).each {|m| tree(b, m, l, sum, c)}  endend def bicenter(s)  return if s.odd?  aux = $ra[s / 2]  $unrooted[s] += aux * (aux + 1) / 2end $ra       = [0] * MAX_N$unrooted = [0] * MAX_N $ra[0] = $ra[1] = $unrooted[0] = $unrooted[1] = 1for n in 1...MAX_N  tree(0, n)  bicenter(n)  puts strv % [n, $unrooted[n]]end"
"require 'open-uri'ordered_words = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt', 'r').select do |word|   word.strip!  word.chars.sort.join == wordend grouped = ordered_words.group_by &:sizeputs grouped[grouped.keys.max]words = IO.foreach('unixdict.txt').map(&:chomp).select {|word| word.chars.sort.join == word}puts words.group_by(&:size).sort_by(&:first).last.lastvar words = [[]]var file = %f'unixdict.txt' file.open_r(\var fh, \var err) ->    || die strv fh.each { |line|    line.trim!    if (line == line.sort) {        words[line.length] := [] << line    }} say words[-1].join(' ')"
"def partition(mask)  return [[]] if mask.empty?  [*1..mask.inject(:+)].permutation.map {|perm|    mask.map {|num_elts| perm.shift(num_elts).sort }  }.uniqenddef part(s, args)  return [[]] if args.empty?  s.combination(args[0]).each_with_object([]) do |c, res|    part(s - c, args[1..-1]).each{|r| res << ([c] + r)}  endenddef partitions(args)  return [[]] if args.empty?  part((1..args.inject(:+)).to_a, args)end[[],[0,0,0],[1,1,1],[2,0,2]].each do |test_case|  puts strv  partition(test_case).each{|part| p part }  putsendfunc part(_,    {.is_empty}) { [[]] }func partitions({.is_empty}) { [[]] } func part(s, args) {  gather {    s.combinations(args[0], { |c|      part(s - c, args.ft(1)).each{|r| take([c] + r) }    })  }} func partitions(args) {  part(@(1..args.sum), args)} [[],[0,0,0],[1,1,1],[2,0,2]].each { |test_case|  say strv  partitions(test_case).each{|part| say part }  print """"}"
"def palindrome?(s)  s == s.reverseenddef r_palindrome?(s)  if s.length <= 1    true  elsif s[0] != s[-1]    false  else    r_palindrome?(s[1..-2])  endendstr = strv.downcase.delete('^a-z')puts palindrome?(str)    
puts r_palindrome?(str)  
 require 'benchmark'Benchmark.bm do |b|  b.report('iterative') {10000.times {palindrome?(str)}}  b.report('recursive') {10000.times {r_palindrome?(str)}}endsay strv.is_palindrome;    
func palindrome(s) {    s == s.reverse}func palindrome(s) {    if (s.len <= 1) {        true    }    elsif (s.first != s.last) {        false    }    else {        __FUNC__(s.ft(1, -2))    }}"
"def pangram?(sentence)  unused_letters = ('a'..'z').to_a - sentence.downcase.chars.to_a  unused_letters.empty?end p pangram?('this is a sentence')  
p pangram?('The quick brown fox jumps over the lazy dog.')  
define Eng = 'a'..'z';define Hex = 'a'..'f';define Cyr = %w(а б в г д е ж з и й к л м н о п р с т у ф х ц ч ш щ ъ ы ь э ю я ё); func pangram(str, alpha=Eng) {    var lstr = str.lc;    alpha.all {|c| lstr.contains(c) };} say pangram(strv);say pangram(strv);say pangram(strv, Hex);say pangram(strv, Hex);say pangram(strv, Cyr);"
"def order_disjoint(m,n)  print strv  m, n = m.split, n.split  from = 0  n.each_slice(2) do |x,y|    next unless y    sd = m[from..-1]    if x > y && (sd.include? x) && (sd.include? y) && (sd.index(x) > sd.index(y))      new_from = m.index(x)+1      m[m.index(x)+from], m[m.index(y)+from] = m[m.index(y)+from], m[m.index(x)+from]      from = new_from    end  end  puts m.join(' ')end [  ['the cat sat on the mat', 'mat cat'],  ['the cat sat on the mat', 'cat mat'],  ['A B C A B C A B C'     , 'C A C A'],  ['A B C A B D A B E'     , 'E A D A'],  ['A B'                   , 'B'      ],  ['A B'                   , 'B A'    ],  ['A B B A'               , 'B A'    ]].each {|m,n| order_disjoint(m,n)}func dsort(m, n) {    var h = Hash()    n.each {|item| h{item} := 0 ++ }    m.map  {|item| h{item} := 0 -- > 0 ? n.shift : item}} <<'EOT'.lines.each { |line|        the cat sat on the mat  | mat cat        the cat sat on the mat  | cat mat        A B C A B C A B C       | C A C A        A B C A B D A B E       | E A D A        A B                     | B        A B                     | B A        A B B A                 | B AEOT        var (a, b) = line.split('|').map{.words}...        say strv}"
">> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0=> falsefunc ordered(a, b) {    (a <=> b) < 0} for p in [    Pair([1,2,4], [1,2,4]),    Pair([1,2,4], [1,2]  ),    Pair([1,2],   [1,2,4]),] {    var a = p.first    var b = p.second    var before = ordered(a, b)    say strv}"
"1+2 * 3+4    
"
"def table_sort(table, ordering=:<=>, column=0, reverse=false)  
def table_sort(table, ordering: :<=>, column: 0, reverse: false)  p = ordering.to_proc  if reverse    table.sort {|a, b| p.(b[column], a[column])}  else    table.sort {|a, b| p.(a[column], b[column])}  endend 
table = [  [strv, strv],  [strv, strv],  [strv, strv],]p table_sort(table, column: 1)def table_sort(table, opts = {})  defaults = {:ordering => :<=>, :column => 0, :reverse => false}  opts = defaults.merge(opts)   c = opts[:column]  p = opts[:ordering].to_proc  if opts[:reverse]    table.sort {|a, b| p.call(b[c], a[c])}  else    table.sort {|a, b| p.call(a[c], b[c])}  endendfunc table_sort(table, ordering: '<=>', column: 0, reverse: false) {  if (reverse) {    table.sort {|a,b| b[column].$ordering(a[column])}  } else {    table.sort {|a,b| a[column].$ordering(b[column])}  }} 
var table = [  [strv, strv],  [strv, strv],  [strv, strv],]; say table_sort(table, column: 1);class String {    method my_sort(arg) {           (self.len <=> arg.len) ->        || (self.lc <=> arg.lc)   ->        || (self <=> arg)    }} say table_sort(table, column: 1, ordering: 'my_sort');"
"require 'rubygems'require 'gl'require 'glut' include Glinclude Glut paint = lambda do  glClearColor(0.3,0.3,0.3,0.0)  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)   glShadeModel(GL_SMOOTH)   glLoadIdentity  glTranslatef(-15.0, -15.0, 0.0)   glBegin(GL_TRIANGLES)    glColor3f(1.0, 0.0, 0.0)    glVertex2f(0.0, 0.0)    glColor3f(0.0, 1.0, 0.0)    glVertex2f(30.0, 0.0)    glColor3f(0.0, 0.0, 1.0)    glVertex2f(0.0, 30.0)  glEnd   glFlushend reshape = lambda do |width, height|  glViewport(0, 0, width, height)  glMatrixMode(GL_PROJECTION)  glLoadIdentity  glOrtho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)  glMatrixMode(GL_MODELVIEW)end glutInitglutInitWindowSize(640, 480)glutCreateWindow(strv) glutDisplayFunc(paint)glutReshapeFunc(reshape) glutMainLoop"
"


def random_line(io)  choice = io.gets; count = 1  while line = io.gets    rand(count += 1).zero? and choice = line  end  choiceend def one_of_n(n)  
  
  (mock_io = Object.new).instance_eval do    @count = 0    @last = n    def self.gets      (@count < @last) ? (@count += 1) : nil    end  end  random_line(mock_io)end chosen = Hash.new(0)1_000_000.times { chosen[one_of_n(10)] += 1 }chosen.keys.sort.each do |key|  puts strvendfunc one_of_n(n) {    var choice    n.times { |i|        choice = i if (1 > i.rand)    }    choice - 1} func one_of_n_test(n = 10, trials = 1_000_000) {    var bins = []    trials.times {        bins[one_of_n(n)] := 0 ++    }    bins} say one_of_n_test()"
"def evolve(ary)  ([0]+ary+[0]).each_cons(3).map{|a,b,c| a+b+c == 2 ? 1 : 0}end def printit(ary)  puts ary.join.tr(strv,strv)end ary = [0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0]printit aryuntil ary == (new = evolve(ary))  printit ary = newendvar seq = strv;var x = ''; loop {    seq.tr!('01', '_#');    say seq;    seq.tr!('_#', '01');    seq.gsub!(/(?<=(.))(.)(?=(.))/, {|s1,s2,s3| s1 == s3 ? (s1 ? 1-s2 : 0) : s2});    (x != seq) && (x = seq) || break;}class Automaton(rule, cells) {     method init {        rule = sprintf(strv, rule).chars.map{.to_i}.reverse;    }     method next {        var previous = cells.map{_};        var len = previous.len;        cells[] = rule[                previous.range.map { |i|                    4*previous[i-1 % len] +                    2*previous[i]         +                      previous[i+1 % len]                }...            ]    }     method to_s {        cells.map { _ ? '#' : ' ' }.join;    }} var size = 10;var auto = Automaton(    rule: 104,    cells: [(size/2).of(0)..., 111011010101.digits..., (size/2).of(0)...],); size.times {    say strv;    auto.next;}"
"f, r = nilfwd = proc {|c|  c =~ /[[:alpha:]]/ ? [(print c), fwd[Fiber.yield f]][1] : c }rev = proc {|c|  c =~ /[[:alpha:]]/ ? [rev[Fiber.yield r], (print c)][0] : c } (f = Fiber.new { loop { print fwd[Fiber.yield r] }}).resume(r = Fiber.new { loop { print rev[Fiber.yield f] }}).resume coro = funtil $stdin.eof?  coro = coro.resume($stdin.getc)endrequire 'continuation' unless defined? Continuationrequire 'stringio' 
def savecc(*data)  
  
  
  
  continuation = callcc {|cc| cc}  [continuation, *data]end 
def jump_back(continuation)  continuation[nil]end def read_odd_word(input, output)  first_continuation, last_continuation = nil  reverse = false  
  while c = input.getc    c = c.chr   
    if c =~ /[[:alpha:]]/      
      if reverse        
        saving, last_continuation, c = savecc(last_continuation, c)        if saving          last_continuation = saving        else          
          output.print c          jump_back last_continuation        end      else        
        output.print c      end    else      
      if reverse        
        
        first_continuation, c = savecc(c)        if first_continuation          jump_back last_continuation        end        output.print c      
        reverse = false     
      else        output.print c      
        reverse = true      
        
        last_continuation, = savecc        unless last_continuation          jump_back first_continuation        end      end    end  end  output.puts   
end def odd_word(string)  read_odd_word StringIO.new(string), $stdoutend odd_word strvodd_word strvfunc rev {    (var c = STDIN.getc) \\ return()    if (c ~~ /^[a-z]\z/i) {        var r = rev()        print c        return r    }    return c} var (n=0, l=false)while (defined(var c = STDIN.getc)) {    var w = (c ~~ /^[a-z]\z/i)    ++n if (w && !l)    l = w    if (n & 1) {        print c    } else {        var r = rev()        print(c, r)        n = 0        l = false    }}"
"descriptions = {  :fly    => strv,  :spider => strv,  :bird   => strv,  :cat    => strv,  :dog    => strv,  :goat   => strv,  :cow    => strv,  :horse  => strv,}animals = descriptions.keys animals.each_with_index do |animal, idx|  puts strv   d = descriptions[animal]  case d[-1]  when strv then d[-1] = strv  when strv then d[-1] = strv  end  puts d  break if animal == :horse   idx.downto(1) do |i|    puts strv    case animals[i-1]    when :spider, :fly then puts descriptions[animals[i-1]]    end  end   print ""Perhaps she'll die.""endvar victims = [    :fly:    strv,    :spider: strv,    :bird:   strv,    :cat:    strv,    :dog:    strv,    :goat:   strv,    :cow:    strv,    :horse:  strv,]; var history = [""I guess she'll die...""]; victims.each { |pair|    var (victim, verse) = pair...;    say strv;     verse.sub!(/\bS\b/, strv);    verse.sub!(/\bT\b/, strv);     say verse;    verse ~~ /dead/ && break;     history[0].sub!(/^X/, strv);    history.each{.say};    history.len < 5 && history.unshift(verse);    history.unshift(strv);};"
"class Being  def initialize(specialty=nil)    @specialty=specialty  end  def to_s    ""(object_id = #{object_id})""+strv.ljust(12)+to_s4Being+(@specialty ? """"+strv*12+@specialty : strv)  end  def to_s4Being    strv  endend class Earthling < Being  def to_s4Being    ""I originate from a blue planet.""+strv*12+to_s4Earthling  endend class Mammal < Earthling  def initialize(type)    @type=type  end  def to_s4Earthling    ""I am champion in taking care of my offspring and eating everything I can find, except mammals of type }.""  endend class Fish < Earthling  def initialize(iq)    @iq=(iq>1 ? :instrustableValue : iq)  end  def to_s4Earthling    strv  endend class Moonling < Being  def to_s4Being    strv  endend diverseCollection=[]diverseCollection << (marsian=Being.new(strv))diverseCollection << (me=Mammal.new(:human))diverseCollection << (nemo=Fish.new(0.99))diverseCollection << (jannakeMaan=Moonling.new) puts strvdiverseCollection.each do |being|  puts strv,being.to_sendputs strvputs """"+strv*50+"""" #Marshal the diverse Array of beingsFile.open('diverseCollection.bin','w') do |fo|  fo << Marshal.dump(diverseCollection)end #load the Array of diverse beingssameDiverseCollection=Marshal.load(File.read('diverseCollection.bin')) puts strvputs(     sameDiverseCollection.collect do |being|       being.to_s     end.join("""")     )puts strv"
"ary = (1..9).to_aary.shuffle! while ary == ary.sortscore = 0until ary == ary.sort  print strv  num = gets.to_i  
  ary[0, num] = ary[0, num].reverse  score += 1endp aryputs strvvar turn = 0;var jumble = @(1..9).bshuffle;        
 for (turn; jumble != 1..9; ++turn) {    printf(strv, turn, jumble.join(' '));    var d = read(Number) \\ break;    jumble[0 .. d-1] = [jumble[0 .. d-1]].reverse...;} print ""    #{jumble.join(' ')}"";print ""You won in #{turn} turns."";"
"class NumberWithUncertainty  def initialize(number, error)    @num = number    @err = error.abs  end  attr_reader :num, :err   def +(other)    if other.kind_of?(self.class)      self.class.new(num + other.num, Math::hypot(err, other.err))    else      self.class.new(num + other, err)    end  end   def -(other)    if other.kind_of?(self.class)      self.class.new(num - other.num, Math::hypot(err, other.err))    else      self.class.new(num - other, err)    end  end   def *(other)    if other.kind_of?(self.class)      prod = num * other.num      e = Math::hypot((prod * err / num), (prod * other.err / other.num))      self.class.new(prod, e)    else      self.class.new(num * other, (err * other).abs)    end  end   def /(other)    if other.kind_of?(self.class)      quo = num / other.num      e = Math::hypot((quo * err / num), (quo * other.err / other.num))      self.class.new(quo, e)    else      self.class.new(num / other, (err * other).abs)    end  end   def **(exponent)    Float(exponent) rescue raise ArgumentError, strv    prod = num ** exponent    self.class.new(prod, (prod * exponent * err / num).abs)  end   def sqrt    self ** 0.5  end   def to_s    ""#{num} 00b1 #{err}""  endend x1 = NumberWithUncertainty.new(100, 1.1)y1 = NumberWithUncertainty.new( 50, 1.2)x2 = NumberWithUncertainty.new(200, 2.2)y2 = NumberWithUncertainty.new(100, 2.3) puts ((x1 - x2) ** 2 + (y1 - y2) ** 2).sqrt"
"puts strv if @object.nil?		
 puts strv if $object.nil?		
 
object = 1  if falseputs strv if object.nil? 
puts nil.class  
var undefined;         
say undefined==nil;    
say defined(nil)       
var null_obj = null;        
say null_obj.is_a(null);    
say defined(null_obj);      
"
"SMALL = %w(zero one two three four five six seven eight nine ten           eleven twelve thirteen fourteen fifteen sixteen seventeen           eighteen nineteen) TENS = %w(wrong wrong twenty thirty forty fifty sixty seventy          eighty ninety) BIG = [nil, strv] +      %w( m b tr quadr quint sext sept oct non dec).map{ |p| strv } def wordify number  case  when number < 0    strv   when number < 20    SMALL[number]   when number < 100    div, mod = number.divmod(10)    TENS[div] + (mod==0 ? strv : strv)   when number < 1000    div, mod = number.divmod(100)    strv + (mod==0 ? strv : strv)   else    
    chunks = []    div = number    while div != 0      div, mod = div.divmod(1000)      chunks << mod                 
    end     raise ArgumentError, strv if chunks.size > BIG.size     chunks.map{ |c| wordify c }.           zip(BIG).    
           find_all { |c| c[0] != 'zero' }.           map{ |c| c.join ' '}.    
           reverse.           join(', ').              
           strip  endend data = [-1123, 0, 1, 20, 123, 200, 220, 1245, 2000, 2200, 2220, 467889,        23_000_467, 23_234_467, 2_235_654_234, 12_123_234_543_543_456,        987_654_321_098_765_432_109_876_543_210_987_654,        123890812938219038290489327894327894723897432] data.each do |n|  print strv  begin    puts strv  rescue => e    puts strv  endendvar l = frequire('Lingua::EN::Numbers');say l.num2en(123456789);"
"def nonoblocks(cell, blocks)  raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1  nblock(cell, blocks, '', [])end def nblock(cell, blocks, position, result)  if cell <= 0    result << position[0..cell-1]  elsif blocks.empty? or blocks[0].zero?    result << position + '.' * cell  else    rest = cell - blocks.inject(:+) - blocks.size + 2    bl, *brest = blocks    rest.times.inject(result) do |res, i|      nblock(cell-i-bl-1, brest, position + '.'*i + '#'*bl + '.', res)    end  endend conf = [[ 5, [2, 1]],        [ 5, []],        [10, [8]],        [15, [2, 3, 2, 3]],        [ 5, [2, 3]],      ]conf.each do |cell, blocks|  begin    puts strv    result = nonoblocks(cell, blocks)    puts result, result.size, strv  rescue => e    p e  endendclass NonoBlock  def initialize(cell, blocks)    raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1    @result = []    nonoblocks(cell, blocks, '')  end   def result(correct=true)    correct ? @result.map(&:nonocell) : @result  end   private  def nonoblocks(cell, blocks, position)    if cell <= 0      @result << position[0..cell-1]    elsif blocks.empty? or blocks[0].zero?      @result << position + '.' * cell    else      rest = cell - blocks.inject(0,:+) - blocks.size + 2      bl, *brest = blocks      rest.times do |i|        nonoblocks(cell-i-bl-1, brest, position + '.'*i + '#'*bl + '.')      end    end  endend class String  def nonocell                  
    chr = ('A'..'Z').each    s = tr('.','_').gsub(/#+/){|sharp| chr.next * sharp.size}    strv  endend if __FILE__ == $0  conf = [[ 5, [2, 1]],          [ 5, []],          [10, [8]],          [15, [2, 3, 2, 3]],          [ 5, [2, 3]]       ]  conf.each do |cell, blocks|    begin      puts strv,           strv,           strv      result = NonoBlock.new(cell, blocks).result      puts result,           strv, strv    rescue => e      p e    end  endend"
"def leftrect(f, left, right)  f.call(left)end def midrect(f, left, right)  f.call((left+right)/2.0)end def rightrect(f, left, right)  f.call(right)end def trapezium(f, left, right)  (f.call(left) + f.call(right)) / 2.0end def simpson(f, left, right)  (f.call(left) + 4*f.call((left+right)/2.0) + f.call(right)) / 6.0end def integrate(f, a, b, steps, method)  delta = 1.0 * (b - a) / steps  total = 0.0  steps.times do |i|    left = a + i*delta    right = left + delta    total += delta * send(method, f, left, right)  end  totalend def square(x)  x**2end def def_int(f, a, b)  l = case f.to_s      when /sin>/        lambda {|x| -Math.cos(x)}      when /square>/        lambda {|x| (x**3)/3.0}      end  l.call(b) - l.call(a)end a = 0b = Math::PIsteps = 10 for func in [method(:square), Math.method(:sin)]  puts strv  actual = def_int(func, a, b)  for method in [:leftrect, :midrect, :rightrect, :trapezium, :simpson]    int = integrate(func, a, b, steps, method)    diff = (int - actual) * 100.0 / actual    printf ""   %-10s  %s(%.1f%%)"", method, int, diff  endendfunc sum(f, start, from, to) {    var s = 0;    RangeNum(start, to, from-start).each { |i|        s += f(i);    }    return s} func leftrect(f, a, b, n) {    var h = ((b - a) / n);    h * sum(f, a, a+h, b-h);} func rightrect(f, a, b, n) {    var h = ((b - a) / n);    h * sum(f, a+h, a + 2*h, b);} func midrect(f, a, b, n) {    var h = ((b - a) / n);    h * sum(f, a + h/2, a + h + h/2, b - h/2)} func trapez(f, a, b, n) {    var h = ((b - a) / n);    h/2 * (f(a) + f(b) + sum({ f(_)*2 }, a+h, a + 2*h, b-h));} func simpsons(f, a, b, n) {    var h = ((b - a) / n);    var h2 = h/2;     var sum1 = f(a + h2);    var sum2 = 0;     sum({|i| sum1 += f(i + h2); sum2 += f(i); 0 }, a+h, a+h+h, b-h);    h/6 * (f(a) + f(b) + 4*sum1 + 2*sum2);} func tryem(label, f, a, b, n, exact) {    say ""#{label}   in [#{a}..#{b}] / #{n}"";     say('              exact result: ', exact);    say('     rectangle method left: ', leftrect(f, a, b, n));    say('    rectangle method right: ', rightrect(f, a, b, n));    say('      rectangle method mid: ', midrect(f, a, b, n));    say('composite trapezoidal rule: ', trapez(f, a, b, n));    say('   quadratic simpsons rule: ', simpsons(f, a, b, n));} tryem('x^3', { _ ** 3 }, 0, 1, 100, 0.25);tryem('1/x', { 1 / _ }, 1, 100, 1000, log(100));tryem('x', { _ }, 0, 5_000, 5_000_000, 12_500_000);tryem('x', { _ }, 0, 6_000, 6_000_000, 18_000_000);"
"dec1 = strvhex2 = strvoct3 = strvbin4 = strv p dec1.to_i   
p hex2.hex    
p oct3.oct    

p dec1.to_i(10)         
p hex2.to_i(16)         
p oct3.to_i(8)          
p bin4.to_i(2)          
p strv.to_i(10)       
p ((Integer(dec1) rescue nil)) 
p Integer(dec1.sub(/^0+/,strv))  
p Integer(strv + dec1)         
p Integer(strv + hex2)         
p Integer(strv  + oct3)         
p Integer(strv + oct3)         
p Integer(strv + bin4)         
p dec1.to_i(0)      
p (strv + dec1).to_i(0)        
p (strv + hex2).to_i(0)        
p (strv  + oct3).to_i(0)        
p (strv + oct3).to_i(0)        
p (strv + bin4).to_i(0)        
require 'scanf'p dec1.scanf(strv)  
p hex2.scanf(strv)  
p oct3.scanf(strv)  

var dec            = '0123459';var hex_noprefix   = 'abcf123';var hex_withprefix = '0xabcf123';var oct_noprefix   = '7651';var oct_withprefix = '07651';var bin_noprefix   = '101011001';var bin_withprefix = '0b101011001'; say dec.num;                    
say hex_noprefix.hex;           
say hex_withprefix.hex;         
say oct_noprefix.oct;           
say oct_withprefix.oct;         
say bin_noprefix.bin;           
say bin_withprefix.bin;         
"
"for n in 0..33  puts strv % [n, n, n, n]endputs[2,8,10,16,36].each {|i| puts strv}range(0, 33).each { |n|    printf("" %6b %3o %2d %2X"", ([n]*4)...);}"
"def nthroot(n, a, precision = 1e-5)  x = Float(a)  begin    prev = x    x = ((n - 1) * prev + a / (prev ** (n - 1))) / n  end while (prev - x).abs > precision  x end p nthroot(5,34)  
func nthroot(n, a, precision=1e-5) {  var x = 1;  var prev = 0;  while ((prev-x).abs > precision) {    prev = x;    x = (((n-1)*prev + a/(prev**(n-1))) / n);  };  return x;} say nthroot(5, 34);  
func nthroot_fast(n, a, precision=1e-5) {  { a = nthroot(2, a, precision) } * int(n-1);  a ** (2**int(n-1) / n);} say nthroot_fast(5, 34, 1e-64);  
"
"def makeList(separator)  counter = 1   makeItem = lambda {|item|    result = ""#{counter}#{separator}#{item}""    counter += 1    result  }   makeItem[strv] + makeItem[strv] + makeItem[strv]end print makeList(strv)func make_list(separator = ') ') {     var count = 1    func make_item(item) {        [count++, separator, item].join    }     <first second third> «call« make_item -> join("""")} say make_list('. ')"
"class Array  def func_power_set    inject([[]]) { |ps,item|    
      ps +                      
      ps.map { |e| e + [item] } 
    }  end   def non_continuous_subsequences    func_power_set.reject {|seq| continuous?(seq)}  end   def continuous?(seq)    seq.each_cons(2) {|a, b| return false if a.succ != b}    true  endend p (1..3).to_a.non_continuous_subsequencesp (1..4).to_a.non_continuous_subsequencesp (1..5).to_a.non_continuous_subsequencesp (strv..strv).to_a.non_continuous_subsequencesclass Array  def continuous?(seq)    seq.each_cons(2) {|a, b| return false if index(a)+1 != index(b)}    true  endend p %w(a e i o u).non_continuous_subsequencesfunc non_continuous(min, max, subseq=[], has_gap=false) {     static current = [];     range(min, max).each { |i|        current.push(i);        has_gap && subseq.append([current...]);        i < max && non_continuous(i.inc, max, subseq, has_gap);        current.pop;        has_gap = current.len;    }     subseq;} say non_continuous(1, 3);say non_continuous(1, 4);say non_continuous(strv, strv);"
"watches = [ strv, strv, strv, strv, strv, strv, strv, strv ]watch_ends = [ strv, strv, strv, strv, strv, strv, strv, strv ]words = [strv,strv,strv,strv,strv,strv,strv,strv]sound = strv loop do  time = Time.now  if time.sec == 0 and time.min % 30 == 0    num = (time.hour * 60 + time.min) / 30 % 8    num = 8 if num == 0    hr_min = time.strftime strv    idx = watch_ends.find_index {|t| hr_min <= t}    text = strv % [        hr_min,         watches[idx],         words[num-1],         num==1 ? strv : strv    ]    bells = (sound * num).gsub(sound + sound) {|dd| dd + ' '}    puts strv % [text, bells]  end  sleep 1end"
#!/usr/bin/sidefsay ARGV.join(strv)
"class String  def convert_base(from, to)    Integer(self, from).to_s(to)      
  endend 
p strv.convert_base(10, 23) 
p strv.convert_base(23, 7) 
p strv.convert_base(7, 10) 
p strv.convert_base(10, 36) 
p strv.convert_base(15, 10) 
say 60272032366.base(36)    
say Number(strv, 36)   
static to = [@|'0'..'9', @|'a'..'z']static from = Hash(to.pairs.map{@|_}.flip...) func base_to(n, b) {    var s = strv    while (n) {        s += to[n % b]        n //= b    }    s.reverse} func base_from(n, b) {    var t = 0    n.each { |c| t = (b*t + from{c}) }    t} say base_from(strv, 36)        
say base_to(60272032366, 36)        
"
"s = strv; puts(gets.chomp == (s % [34.chr, s, 34.chr]) ? 'accept' : 'reject')say (File.new(__FILE__).open_r.slurp == ARGF.slurp);"
"ar.sort_by{|str| str.downcase.gsub(/\Athe |\Aa |\Aan /, strv).lstrip.gsub(/\s+/, strv)}class NatSortString   include Comparable  attr_reader :scrubbed, :ints_and_strings, :i_s_pattern   def initialize(str)    @str = str    @scrubbed = str.downcase.gsub(/\Athe |\Aa |\Aan /, strv).lstrip.gsub(/\s+/, strv)    @ints_and_strings = @scrubbed.scan(/\d+|\D+/).map{|s| s =~ /\d/ ? s.to_i : s}    @i_s_pattern = @ints_and_strings.map{|el| el.is_a?(Integer) ? :i : :s}.join  end   def <=> (other)    if i_s_pattern.start_with?(other.i_s_pattern) or other.i_s_pattern.start_with?(i_s_pattern) then      ints_and_strings <=> other.ints_and_strings    else      scrubbed <=> other.scrubbed    end  end   def to_s    @str.dup  end end tests =   {strv =>  [ strv,  strv,  strv,  strv],  strv =>  [ strv,  strv,  strv,  strv],  strv =>  [strv, ""Equiv.spaces: 3-2"", ""Equiv.0cspaces: 3-1"", ""Equiv.0bspaces: 3+0"", ""Equiv.spaces: 3+1"", ""Equiv.spaces: 3+2""],  strv =>  [ strv,  strv,  strv,  strv],  strv =>  [ strv,  strv,  strv,  strv],  strv =>  [ strv,  strv,  strv,  strv]} tests.each do |title, ar|  nat_sorts = ar.map{|s| NatSortString.new(s)}  puts [title,strv, ar, strv, ar.sort, strv, nat_sorts.sort, """"] end class String {    
    -> naturally { self.lc.gsub(/(\d+)/, {|s1| strv + s1.len.chr + s1 }) + ""0"" + self };     
    -> collapse { self.gsub(/(\s)\1+/, {|s1| s1 }) };     
    -> normalize { self.gsub(/(\s)/, ' ') };     
    -> title { self.sub(/^(?:a|an|the)\b\s*/i, '') };     
    -> latin1_decompose {        static tr = Hash.new(%w(           Æ AE æ ae Þ TH þ th Ð TH ð th ß ss À A Á A Â A Ã A Ä A Å A à a á a            â a ã a ä a å a Ç C ç c È E É E Ê E Ë E è e é e ê e ë e Ì I Í I Î            I Ï I ì i í i î i ï i Ò O Ó O Ô O Õ O Ö O Ø O ò o ó o ô o õ o ö o            ø o Ñ N ñ n Ù U Ú U Û U Ü U ù u ú u û u ü u Ý Y ÿ y ý y        )...);         var re = Regex.new('(' + tr.keys.join('|') + ')');        self.gsub(re, {|s1| tr{s1} });    }}var tests = [    [        ""Task 1aSort while ignoring leading spaces."",        [          'ignore leading spaces: 1', '   ignore leading spaces: 4',          '  ignore leading spaces: 3', ' ignore leading spaces: 2'        ],        { .trim } 
    ],    [        ""Task 1bSort while ignoring multiple adjacent spaces."",        [          'ignore m.a.s   spaces: 3', 'ignore m.a.s spaces: 1',          'ignore m.a.s    spaces: 4', 'ignore m.a.s  spaces: 2'        ],        { .collapse }    ],    [        ""Task 2Sort with all white space normalized to regular spaces."",        [          ""Normalizedspaces: 4"", ""Normalizeda0spaces: 1"",          ""Normalized20spaces: 2"", ""Normalizedspaces: 3""        ],        { .normalize }    ],    [        ""Task 3Sort case independently."",        [          'caSE INDEPENDENT: 3', 'casE INDEPENDENT: 2',          'cASE INDEPENDENT: 4', 'case INDEPENDENT: 1'        ],        { .lc } 
    ],    [        ""Task 4Sort groups of digits in natural number order."",        %w(Foo100bar99baz0.txt foo100bar10baz0.txt foo1000bar99baz10.txt           foo1000bar99baz9.txt 201st 32nd 3rd 144th 17th 2 95),        { .naturally }    ],    [        ""Task 5 ( mixed with 1, 2, 3 & 4 )""        + ""Sort titles, normalize white space, collapse multiple spaces to""        + ""single, trim leading white space, ignore common leading articles""        + 'and sort digit groups in natural order.',        [          'The Wind     in the Willows  8', '  The 39 Steps               3',          'The    7th Seal              1', 'Wanda                        6',          'A Fish Called Wanda          5', ' The Wind and the Lion       7',          'Any Which Way But Loose      4', '12 Monkeys                   2'        ],        { .normalize.collapse.trim.title.naturally }    ],    [        ""Task 6, 7, 8Map letters in Latin1 that have accents or decompose to two""        + 'characters to their base characters for sorting.',        %w(apple Ball bald car Card above Æon æon aether            niño nina e-mail Évian evoke außen autumn),        { .latin1_decompose.naturally }    ]]; tests.each { |case|    var code = case.pop;    var array = case.pop;    say case.pop+"""";     say ""Standard Sort:"";    array.sort.each { .say };     say ""Natural Sort:"";    array.sort_by(code).each { .say };     say ""#{'*' * 40}"";}"
" test_variable = [1, 9, 8, 3]test_variable.sort    
test_variable         
test_variable.sort!   
test_variable         
  
$number_of_continents = 7 module Banking  
  VERSION = '1.0.0.1'  class BankAccount    attr_accessor :first_name, :last_name    attr_reader :account_number     @@ATM_FEE = 3.75    @@adiministrator_password = 'secret'     
    def initialize(first_name, last_name, account_number)      @first_name = first_name      @last_name = last_name      @account_number = account_number      @balance = 0    end     
    def account_number=(account_number)      puts 'Enter administrator override'      if gets == @@adiministrator_password        @account_number = account_number      else        puts 'Sorry. Incorrect password. Account number not changed'      end    end     
    def balance      "" /  % 100}""    end     
    def sufficient_funds? (withdrawal_amount)      withdrawal_amount <= @balance    end     
    def donate_all_money!      @balance = 0    end  endend "
"require 'number_names' def int_from_words(num)  words = num.downcase.gsub(/(,| and |-)/,' ').split  if words[0] =~ /(minus|negative)/    negmult = -1    words.shift  else    negmult = 1  end  small, total = 0, 0  for word in words    case word    when *SMALL      small += SMALL.index(word)    when *TENS      small += TENS.index(word) * 10    when 'hundred'      small *= 100    when 'thousand'      total += small * 1000      small = 0    when *BIG      total += small * 1000 ** BIG.index(word)      small = 0    else      raise ArgumentError, strv % [word, num]    end  end  negmult * (total + small)endfor n in (-10000..10000).step(17)  raise unless n == int_from_words(wordify(n))end for n in 0...20  raise unless 13**n == int_from_words(wordify(13**n))end puts strvfor n in [0, -3, 5, -7, 11, -13, 17, -19, 23, -29]  txt = wordify(n)  num = int_from_words(txt)  puts '%+4i <%s> %s' % [n, n==num ? '==' : '??', txt]
end
puts
 
n = 201021002001
loop do
  txt = wordify(n)
  num = int_from_words(txt)
  puts '%12i <%s> %s' % [n, n==num ? '==' : '??', txt]
  break if n==0
  n /= -10
endfunc names_to_number(str) {     static nums = Hash.new(           zero => 0,             one => 1,             two => 2,          three => 3,            four => 4,            five => 5,            six => 6,           seven => 7,           eight => 8,           nine => 9,             ten => 10,         eleven => 11,         twelve => 12,       thirteen => 13,       fourteen => 14,        fifteen => 15,        sixteen => 16,      seventeen => 17,       eighteen => 18,       nineteen => 19,         twenty => 20,         thirty => 30,          forty => 40,          fifty => 50,          sixty => 60,        seventy => 70,         eighty => 80,         ninety => 90,        hundred => 1e2,      thousand => 1e3,        million => 1e6,       billion => 1e9,      trillion => 1e12,    quadrillion => 1e15,  quintillion => 1e18,    );     
    static groups = /\d{4}|\d{7}|\d{10}|\d{13}|\d{16}|\d{19}/;     
    static num = /\d+/;     str.trim!;                      
    str.gsub!('-', ' ');            
    str.words!.join!(' ');          
    str.lc!;                        
     
    str.gsub!(/([.?!]) /, {|a| ' ' + a + """"});    str.gsub!(/([.?!])$/, {|a| ' ' + a + """"});     
    str.gsub!(/\$(.)/,           {|a| strv });       
    str.gsub!(/(.)([;:%'',])/, {|a,b| strv});     
     nums.each { |key, value| str.gsub!(Regex.new('' + key + ''), value) };     str.gsub!(/(\d) , (\d)/,   {|a,b| a + ' ' + b});    str.gsub!(/(\d) and (\d)/, {|a,b| a + ' ' + b});     static regex = [        Regex.new('() 100 () () (' + groups + ')'),        Regex.new('() 100 () (' + groups + ')'),        Regex.new('() 100 () (' + groups + ')'),        Regex.new('() 100 (' + groups + ')'),        Regex.new('100 () () (' + groups + ')'),        Regex.new('100 () (' + groups + ')'),        Regex.new('100 () (' + groups + ')'),        Regex.new('100 (' + groups + ')'),        Regex.new('() () (' + groups + ')'),        Regex.new('({1,2}) (' + groups + ')'),        Regex.new('((?:' + num + ' )*' + num + ')'),    ];     str.gsub!(regex[0], {|a,b,c,d| (a.to_i*100 + b.to_i + c.to_i) * d.to_i });    str.gsub!(regex[1], {|a,b,c|   (a.to_i*100 + b.to_i) * c.to_i });    str.gsub!(regex[2], {|a,b,c|   (a.to_i*100 + b.to_i) * c.to_i });    str.gsub!(regex[3], {|a,b|     (a.to_i * b.to_i * 100) });    str.gsub!(regex[4], {|a,b,c|   (100 + a.to_i + b.to_i) * c.to_i });    str.gsub!(regex[5], {|a,b|     (100 + a.to_i) * b.to_i });    str.gsub!(regex[6], {|a,b|     (100 + a.to_i) * b.to_i });    str.gsub!(regex[7], {|a|       (a.to_i * 100) });    str.gsub!(regex[8], {|a,b,c|   (a.to_i + b.to_i) * c.to_i });    str.gsub!(regex[9], {|a,b|     (a.to_i * b.to_i) });     str.gsub!(/\b(\d\d) (\d) 100\b/, {|a,b| (a.to_i + b.to_i) * 100});    str.gsub!(/\b(\d{1,2}) 100\b/,   {|a|   (a.to_i * 100) });    str.gsub!(/\b(\d{2}) (\d{2})\b/, {|a,b| (a.to_i * 100) + b.to_i});    str.gsub!(regex[10], {|a| a.split(' ').map{.to_i}.sum });}ARGF.each { |line|    say strv;}"
"class Integer  def narcissistic?    return false if self < 0    len = to_s.size    n = self    sum = 0    while n > 0      n, r = n.divmod(10)      sum += r ** len    end    sum == self  endend numbers = []n = 0while numbers.size < 25  numbers << n if n.narcissistic?  n += 1end 

 max = numbers.max.to_s.sizeg = numbers.group_by{|n| n.to_s.size}g.default = [](1..max).each{|n| puts strv, strv}func is_narcissistic(n) {    n.digits »**» n.len -> sum(0) == n} var count = 0for i in (0..^Inf) {    if (is_narcissistic(i)) {        say ""#{++count}#{i}""        break if (count == 25)    }}"
"def example(foo: 0, bar: 1, grill: strv)  puts strvend 
example(grill: strv, bar: 3.14)def example(opts = {})  
  
  defaults = {foo: 0, bar: 1, grill: strv}  opts = defaults.merge(opts)   printf(""foo is %s, bar is %s, and grill is %s"",         opts[:foo], opts[:bar], opts[:grill])end example(grill: strv, bar: 3.14)def example(opts = {})  defaults = {:foo => 0, :bar => 1, :grill => strv}  opts = defaults.merge(opts)  printf(""foo is %s, bar is %s, and grill is %s"",         opts[:foo], opts[:bar], opts[:grill])end example(:grill => strv, :bar => 3.14)func example(foo: 0, bar: 1, grill: strv) {    say strv;} 
example(grill: strv, bar: 3.14);"
"class Integer  def ordinalize    num = self.abs    ordinal = if (11..13).include?(num % 100)      strv    else      case num % 10        when 1; strv        when 2; strv        when 3; strv        else    strv      end    end    strv  endend [(0..25),(250..265),(1000..1025)].each{|r| puts r.map(&:ordinalize).join(strv); puts} func nth(n) {    static irregulars = Hash.new(<1 ˢᵗ 2 ⁿᵈ 3 ʳᵈ 11 ᵗʰ 12 ᵗʰ 13 ᵗʰ>...);    n.to_s + (irregulars{n % 100} \\ irregulars{n % 10} \\ 'ᵗʰ');} [range(0, 25), range(250, 265), range(1000, 1025)].each { |r|    say r.map {|n| nth(n) }.join(strv);}"
"require 'mutex_m' class SomethingWithMutex  include Mutex_m  ...endan_object = Object.newan_object.extend(Mutex_m)
an_object.mu_lock 
got_lock = an_object.mu_try_lock 
if an_object.mu_locked? then ... 
an_object.mu_unlock 
an_object.my_synchronize do  do critical stuffend"
"POW = [0] + (1..9).map{|i| i**i} def munchausen_number?(n)  digits(n).inject(0){|sum,i| sum + POW[i]} == nend def digits(n)  ary = []  while n > 0    n,mod = n.divmod(10)    ary << mod  end  aryend (1..5000).each do |i|  puts i if munchausen_number?(i)endfunc is_munchausen(n) {    n.digits.map{|d| d**d }.sum == n} say (1..5000 -> grep(is_munchausen))"
"load 'raster_graphics.rb' class Pixmap  def self.xor_pattern(width, height, rgb1, rgb2)    
    size = 256    colours = Array.new(size) do |i|      RGBColour.new(        (rgb1.red + (rgb2.red - rgb1.red) * i / size),         (rgb1.green + (rgb2.green - rgb1.green) * i / size),         (rgb1.blue + (rgb2.blue - rgb1.blue) * i / size),       )    end     
    pixmap = new(width, height)    pixmap.each_pixel do |x, y|      pixmap[x,y] = colours[(x^y)%size]    end    pixmap  endend img = Pixmap.xor_pattern(384, 384, RGBColour::RED, RGBColour::YELLOW)img.save_as_png('xorpattern.png')require('GD') var img = %s<GD::Image>.new(256, 256, 1) for y,x in (^256 ~X ^256) {    var color = img.colorAllocate((255 - x - y).abs, (255-x)^y, x^(255-y))    img.setPixel(x, y, color)} File('xor.png').write(img.png, :raw)"
"def F(n)  n == 0 ? 1 : n - M(F(n-1))enddef M(n)  n == 0 ? 0 : n - F(M(n-1))end p (Array.new(20) {|n| F(n) })p (Array.new(20) {|n| M(n) })func F(){};func M(){}; F = func(n) { n > 0 ? (n - M(F(n-1))) : 1 };M = func(n) { n > 0 ? (n - F(M(n-1))) : 0 }; [F, M].each { |seq|    (0..19).map {|i| seq.call(i)}.join(' ').say;}"
"require 'prime' def powerMod(b, p, m)  p.to_s(2).each_char.inject(1) do |result, bit|    result = (result * result) % m    bit=='1' ? (result * b) % m : result  endend def multOrder_(a, p, k)  pk = p ** k  t = (p - 1) * p ** (k - 1)  r = 1  for q, e in t.prime_division    x = powerMod(a, t / q**e, pk)    while x != 1      r *= q      x = powerMod(x, q, pk)    end  end        rend def multOrder(a, m)  m.prime_division.inject(1) do |result, f|    result.lcm(multOrder_(a, *f))  endend puts multOrder(37, 1000)b = 10**20-1puts multOrder(2, b)puts multOrder(17,b)b = 100001puts multOrder(54,b)puts powerMod(54, multOrder(54,b), b)if (1...multOrder(54,b)).any? {|r| powerMod(54, r, b) == 1}  puts 'Exists a power r < 9090 where powerMod(54,r,b)==1'else  puts 'Everything checks.'end"
"text = 'a!===b=!=c'separators = ['==', '!=', '='] def multisplit_simple(text, separators)  text.split(Regexp.union(separators))end p multisplit_simple(text, separators) 
 def multisplit(text, separators)  sep_regex = Regexp.union(separators)  separator_info = []  pieces = []  i = prev = 0  while i = text.index(sep_regex, i)    separator = Regexp.last_match(0)    pieces << text[prev .. i-1]    separator_info << [separator, i]    i = i + separator.length    prev = i  end  pieces << text[prev .. -1]  [pieces, separator_info]end p multisplit(text, separators)
def multisplit_rejoin(info)  str = info[0].zip(info[1])[0..-2].inject(strv) {|str, (piece, (sep, idx))| str << piece << sep}   str << info[0].lastend p multisplit_rejoin(multisplit(text, separators)) == text
func multisplit(sep, str, keep_sep=false) {    sep = sep.map{.escape}.join('|');    var re = Regex.new(keep_sep ? strv : sep);    str.split(re, -1);} [false, true].each { |bool|    say multisplit(%w(== != =), 'a!===b=!=c', keep_sep: bool);}"
"require 'matrix' def regression_coefficients y, x  y = Matrix.column_vector y.map { |i| i.to_f }  x = Matrix.columns x.map { |xi| xi.map { |i| i.to_f }}   (x.t * x).inverse * x.t * yendputs regression_coefficients([1, 2, 3, 4, 5], [ [2, 1, 3, 4, 5] ])puts regression_coefficients([3,4,5], [ [1,2,1], [1,1,2] ])"
"[Foo.new] * n         
Array.new(n, Foo.new)Array.new(n) { Foo.new }[Foo.new] * n;      
n.of {Foo.new};     
"
" #!/usr/bin/env julia __precompile__(true) strv""


 
Ported to **Julia** from examples in several languages from
here: https://hbfs.wordpress.com/2009/11/10/is-python-slow
""strvmodule EightQueensPuzzle export main type Board    cols::Int    nodes::Int    diag45::Int    diag135::Int    solutions::Int     Board() = new(0, 0, 0, 0, 0)end strvfunction mark!(b::Board, k::Int, j::Int)    b.cols    $= (1 << j)    b.diag135 $= (1 << (j+k))    b.diag45  $= (1 << (32+j-k))end strvfunction test(b::Board, k::Int, j::Int)    b.cols    & (1 << j)        +    b.diag135 & (1 << (j+k))    +    b.diag45  & (1 << (32+j-k)) == 0end strvfunction solve!(b::Board, niv::Int, dx::Int)    if niv > 0        for i in 0:dx-1            if test(b, niv, i) == true                mark!(b, niv, i)                solve!(b, niv-1, dx)                mark!(b, niv, i)            end        end    else        for i in 0:dx-1            if test(b, 0, i) == true                b.solutions += 1            end        end    end    b.nodes += 1    b.solutionsend strvfunction main()    for n = 1:17        gc()        b = Board()        @show n        print(strv)        solutions = @time solve!(b, n-1, n)        @show solutions        println()    endend end using  EightQueensPuzzle main()  :~$ /opt/julia-0.5/bin/julia eight_queen_puzzle.jln = 1elapsed:  0.000001 secondssolutions = 1 n = 2elapsed:  0.000001 secondssolutions = 0 n = 3elapsed:  0.000001 secondssolutions = 0 n = 4elapsed:  0.000001 secondssolutions = 2 n = 5elapsed:  0.000003 secondssolutions = 10 n = 6elapsed:  0.000008 secondssolutions = 4 n = 7elapsed:  0.000028 secondssolutions = 40 n = 8elapsed:  0.000108 secondssolutions = 92 n = 9elapsed:  0.000463 secondssolutions = 352 n = 10elapsed:  0.002146 secondssolutions = 724 n = 11elapsed:  0.010646 secondssolutions = 2680 n = 12elapsed:  0.057603 secondssolutions = 14200 n = 13elapsed:  0.334600 secondssolutions = 73712 n = 14elapsed:  2.055078 secondssolutions = 365596 n = 15elapsed: 13.480449 secondssolutions = 2279184 n = 16elapsed: 97.192552 secondssolutions = 14772512 n = 17elapsed:720.314676 secondssolutions = 95815104 











 def n_queens(n)  if n == 1    return strv  elsif n < 4    puts strv    return strv  end   evens = (2..n).step(2).to_a  odds = (1..n).step(2).to_a   rem = n % 12  
  nums = evens  
   nums.push(nums.shift) if rem == 3 or rem == 9  
   
  if rem == 8    odds = odds.each_slice(2).inject([]) {|ary, (a,b)| ary += [b,a]}  end  nums.concat(odds)   
  if rem == 2    idx = []    [1,3,5].each {|i| idx[i] = nums.index(i)}    nums[idx[1]], nums[idx[3]] = nums[idx[3]], nums[idx[1]]    nums.slice!(idx[5])    nums.push(5)  end   
  if rem == 3 or rem == 9    [1,3].each do |i|      nums.slice!( nums.index(i) )      nums.push(i)    end  end   
  board = Array.new(n) {Array.new(n) {strv}}  n.times {|i| board[i][nums[i] - 1] = strv}  board.inject(strv) {|str, row| str << row.join(strv) << """"}end (1 .. 15).each {|n| puts strv; puts n_queens(n); puts}class Queen  attr_reader :count   def initialize(num=8, out=true)    @num   = num    @out   = out    @row   = *0...@num    @frame = strv + strv * @num + strv    @count = 0    add = Array.new(2 * @num - 1, true)       
    sub = Array.new(2 * @num - 1, true)       
    solve([], add, sub)  end   private  def solve(row, add, sub)    y = row.size    if y == @num      print_out(row) if @out      @count += 1    else      (@row-row).each do |x|        next unless add[x+y] and sub[x-y]        add[x+y] = sub[x-y] = false        solve(row+[x], add, sub)        add[x+y] = sub[x-y] = true      end    end  end   def print_out(row)    puts @frame    row.each do |i|      line = @num.times.map {|j| j==i ? strv : strv}.join      puts strv    end    puts @frame  endend(1..6).each do |n|  puzzle = Queen.new(n)  puts strvend (7..12).each do |n|  puzzle = Queen.new(n, false)                
  puts strvend"
"#!/bin/sh 
printf '%s' strvi=1for arg do  printf '  %s' ""{$i}: $arg""  i=`expr $i + 1`done 
exec ${RUBY-ruby} -x strv --coming-from-sh strv #!ruby ARGV[0] == strv or exec strv, $0, *ARGVARGV.shift 
puts strvARGV.each_with_index do |arg, i|  puts strvend#!/bin/sh #`(if running under some shell) {    eval 'exec /usr/bin/sidef $0 ${1+strv'} say strv"
" def multifact(n, d)  n.step(1, -d).inject( :* )end (1..5).each {|d| puts strv\tstrv} func mfact(s, n) {    n > 0 ? (n * mfact(s, n-s)) : 1} 10.times { |s|    say strv}"
"Shoes.app(:title => strv, :width => 400, :height => 400) do  @position = para strv, :size => 12, :margin => 10   motion do |x, y|    @position.text = strv  endend"
"module MoveToFront   ABC = (strv..strv).to_a.freeze   def self.encode(str)    ar = ABC.dup    str.chars.each_with_object([]) do |char, memo|      memo << (i = ar.index(char))      ar = m2f(ar,i)    end  end   def self.decode(indices)    ar = ABC.dup    indices.each_with_object(strv) do |i, str|      str << ar[i]      ar = m2f(ar,i)    end  end   private  def self.m2f(ar,i)    [ar.delete_at(i)] + ar  end end ['broood', 'bananaaa', 'hiphophiphop'].each do |word|  p word == MoveToFront.decode(p MoveToFront.encode(p word))endfunc encode(str) {    var table = ('a'..'z' -> join);    str.chars.map { |c|        var s = '';        table.sub!(Regex('(.*?)' + c), {|s1| s=s1; c + s1});        s.len;    }} func decode(nums) {    var table = ('a'..'z' -> join);    nums.map { |n|        var s = '';        table.sub!(Regex('(.{' + n + '})(.)'), {|s1, s2| s=s2; s2 + s1});        s;    }.join;} %w(broood bananaaa hiphophiphop).each { |test|    var encoded = encode(test);    say strv;    var decoded = decode(encoded);    print strv if (decoded != test);    say strv;}module MoveToFront {   define ABC = @(strv..strv)   func m2f(ar,i) {    [ar.delete_index(i)] + ar  }   func encode(str) {    var ar = ABC+[]    gather {      str.each_char { |char|        take(var i = ar.index(char))        ar = m2f(ar, i);      }    }  }   func decode(indices) {    var ar = ABC+[]    gather {      indices.each { |i|        take ar[i];        ar = m2f(ar, i)      }    }.join  }} %w(broood bananaaa hiphophiphop).each { |test|    var encoded = MoveToFront::encode(test);    say strv;    var decoded = MoveToFront::decode(encoded);    print strv if (decoded != test);    say strv;}"
"def multiplication_table(n)  puts strv + (strv * n) % [*1..n]  puts strv + strv * n  1.upto(n) do |x|    print strv % x    1.upto(x-1) {|y| print strv}    x.upto(n)   {|y| print strv % (x*y)}    puts  endend multiplication_table 12var max = 12;var width = (max**2 -> len+1); func fmt_row(*items) {    items.map { |s| strv % (width, s) }.join('');} say fmt_row('x┃', (1..max)...);say strv; max.times { |i|    say fmt_row(strv, (1..max).map {|j| i <= j ? i*j : ''}...);};"
"class Maybe  def initialize(value)    @value = value  end   def map    if @value.nil?      self    else      Maybe.new(yield @value)    end  endend Maybe.new(3).map { |n| 2*n }.map { |n| n+1 }#=> #<Maybe @value=7> Maybe.new(nil).map { |n| 2*n }.map { |n| n+1 }#=> #<Maybe @value=nil> Maybe.new(3).map { |n| nil }.map { |n| n+1 }#=> #<Maybe @value=nil> 
 class Maybe  class << self    alias :unit :new  end   def bind    if @value.nil?      self    else      yield @value    end  endend Maybe.unit(3).bind { |n| Maybe.unit(2*n) }.bind { |n| Maybe.unit(n+1) }#=> #<Maybe @value=7> Maybe.unit(nil).bind { |n| Maybe.unit(2*n) }.bind { |n| Maybe.unit(n+1) }#=> #<Maybe @value=nil> "
"def approx_pi(throws)  times_inside = throws.times.count {Math.hypot(rand, rand) <= 1.0}  
  4.0 * times_inside / throwsend [1000, 10_000, 100_000, 1_000_000, 10_000_000].each do |n|       puts strv % [n, approx_pi(n)]endfunc monteCarloPi(nthrows) {    4 * (^nthrows -> count_by {        hypot(1.rand(2) - 1, 1.rand(2) - 1) < 1    }) / nthrows} for n in [1e2, 1e3, 1e4, 1e5, 1e6] {    printf(""%9d: %07f"", n, monteCarloPi(n))}"
"require 'win32/sound' class MorseCode  MORSE = {      strv => strv, """" => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv, strv => strv, strv => strv,      strv => strv, strv => strv, strv => strv,  }   T_UNIT = 75 
  FREQ = 700  DIT = 1 * T_UNIT  DAH = 3 * T_UNIT  CHARGAP = 1 * T_UNIT  WORDGAP = 7 * T_UNIT   def initialize(string)    @message = string    puts strv  end   def send    @message.strip.upcase.split.each do |word|      word.each_char do |char|        send_char char        pause CHARGAP        print strv      end      pause WORDGAP      puts strv    end  end   private  def send_char(char)    MORSE[char].each_char do |code|      case code      when '.' then beep DIT      when '-' then beep DAH      end      pause CHARGAP      print code    end  end   def beep(ms)    ::Win32::Sound.beep(FREQ, ms)  end   def pause(ms)    sleep(ms.to_f/1000.0)  endend MorseCode.new('sos').sendMorseCode.new('this is a test.').send"
"n = 10_000                  #number of times to play stay = switch = 0           #sum of each strategy's wins n.times do                  #play the game n times   #the doors reveal 2 goats and a car  doors = [ :goat, :goat, :car ].shuffle   #random guess  guess = rand(3)   #random door shown, but it is neither the guess nor the car  begin shown = rand(3) end while shown == guess || doors[shown] == :car   if doors[guess] == :car    #staying with the initial guess wins if the initial guess is the car    stay += 1  else    #switching guesses wins if the unshown door is the car    switch += 1  end end puts strv   % (100.0 * stay   / n)puts strv % (100.0 * switch / n)var n = 1000;                                 
var switchWins = (var stayWins = 0);          
 n.times {                                     
   var prize = 3.rand.int;   var chosen = 3.rand.int;    var show;   do {        show = 3.rand.int   } while (show ~~ [chosen, prize]);    given(chosen) {     when (prize)                 { stayWins   += 1 }     when ([3 - show - prize])    { switchWins += 1 }     default                      { die strv }    }} say (strv   % (100.0 * stayWins   / n));say (strv % (100.0 * switchWins / n));"
" class Array  def bind(f)    flat_map(&f)  end  def self.unit(*args)    args  end  
  
  def self.lift(f)    -> e { self.unit(f[e]) }  endend inc = -> n { n + 1 }str = -> n { n.to_s }listy_inc = Array.lift(inc)listy_str = Array.lift(str) Array.unit(3,4,5).bind(listy_inc).bind(listy_str) #=> [strv] 



 doub = -> n { 2*n }listy_doub = Array.lift(doub)[3,4,5].bind(listy_inc).bind(listy_doub) #=> [8, 10, 12] 

comp = -> f, g {-> x {f[g[x]]}}[3,4,5].bind(comp[listy_doub, listy_inc]) #=> TypeError: Array can't be coerced into Fixnum 
class Array  def bind_comp(f, g)    bind(g).bind(f)  endend [3,4,5].bind_comp(listy_doub, listy_inc) #=> [8, 10, 12] "
"
 def meaning_of_life  42end if __FILE__ == $0  puts strvend
 require 'life' puts strvputs strv"
"
 class Modulo  include Comparable   def initialize(n = 0, m = 13)    @n, @m = n % m, m  end   def to_i    @n  end   def <=>(other_n)    @n <=> other_n.to_i  end   [:+, :-, :*, :**].each do |meth|    define_method(meth) { |other_n| Modulo.new(@n.send(meth, other_n.to_i), @m) }  end   def coerce(numeric)    [numeric, @n]  end end 
x, y = Modulo.new(10), Modulo.new(20) p x > y          
p x == y         
p [x,y].sort     #[#<Modulo:0x000000012ae0f8 @n=7, @m=13>, #<Modulo:0x000000012ae148 @n=10, @m=13>]p x + y          ##<Modulo:0x0000000117e110 @n=4, @m=13>p 2 + y          
p y + 2          ##<Modulo:0x00000000ad1d30 @n=9, @m=13> p x**100 + x +1  ##<Modulo:0x00000000ad1998 @n=1, @m=13> class Modulo(n=0, m=13) {   method init {     (n, m) = (n % m, m)  }   method to_n { n }   < + - * ** >.each { |meth|      Modulo.def_method(meth, method(n2) { Modulo(n.(meth)(n2.to_n), m) })  }   method to_s { strv }} func f(x) { x**100 + x + 1 }say f(Modulo(10, 13))"
"require 'openssl' a = 2988348162058574136915891421498819466320163312926952423791023078876139b = 2351399303373464486466122544523690094744975233415544072992656881240319m = 10 ** 40puts a.to_bn.mod_exp(b, m)class Integer  def rosetta_mod_exp(exp, mod)    exp < 0 and raise ArgumentError, strv    prod = 1    base = self % mod    until exp.zero?      exp.odd? and prod = (prod * base) % mod      exp >>= 1      base = (base * base) % mod    end    prod  endend a = 2988348162058574136915891421498819466320163312926952423791023078876139b = 2351399303373464486466122544523690094744975233415544072992656881240319m = 10 ** 40puts a.rosetta_mod_exp(b, m)say expmod(    2988348162058574136915891421498819466320163312926952423791023078876139,    2351399303373464486466122544523690094744975233415544072992656881240319,    10**40)func expmod(a, b, n) {    var c = 1    do {        (c *= a) %= n if b.is_odd        (a *= a) %= n    } while (b //= 2)    c}"
"#based on pseudo code from http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Iterative_method_2 and from translating the python implementation.def extended_gcd(a, b)  last_remainder, remainder = a.abs, b.abs  x, last_x, y, last_y = 0, 1, 1, 0  while remainder != 0    last_remainder, (quotient, remainder) = remainder, last_remainder.divmod(remainder)    x, last_x = last_x - quotient*x, x    y, last_y = last_y - quotient*y, y  end   return last_remainder, last_x * (a < 0 ? -1 : 1)end def invmod(e, et)  g, x = extended_gcd(e, et)  if g != 1    raise 'The maths are broken!'  end  x % etendsay 42.modinv(2017)func invmod(a, n) {  var (t, nt, r, nr) = (0, 1, n, a % n)  while (nr != 0) {    var quot = int((r - (r % nr)) / nr);    (nt, t) = (t - quot*nt, nt);    (nr, r) = (r - quot*nr, nr);  }  r > 1 && return()  t < 0 && (t += n)  t} say invmod(42, 2017)"
" #!/usr/bin/ruby bpm = Integer(ARGV[0]) rescue 60 
msr = Integer(ARGV[1]) rescue 4 
i = 0 loop do  (msr-1).times do     puts """"    sleep(60.0/bpm)  end  puts ""AND #{i += 1}""  sleep(60.0/bpm)end "
"puts <<EOS
    Minesweeper game.
 
    There is an n by m grid that has a random number of between 20% to 60%
    of randomly hidden mines that need to be found. 
 
    Positions in the grid are modified by entering their coordinates
    where the first coordinate is horizontal in the grid and the second
    vertical. The top left of the grid is position 1,1; the bottom right is
    at n,m.
 
    * The total number of mines to be found is shown at the beginning of the
    game.
    * Each mine occupies a single grid point, and its position is initially
    unknown to the player
    * The grid is shown as a rectangle of characters between moves.
    * You are initially shown all grids as obscured, by a single dot '.'
    * You may mark what you think is the position of a mine which will show
    as a '?'
    * You can mark what you think is free space by entering its coordinates.
    :*  If the point is free space then it is cleared, as are any adjacent
    points that are also free space- this is repeated recursively for
    subsequent adjacent free points unless that point is marked as a mine
    or is a mine.
    ::*   Points marked as a mine show as a '?'.
    ::*   Other free points show as an integer count of the number of adjacent
    true mines in its immediate neighbourhood, or as a single space ' ' if the
    free point is not adjacent to any true mines.
    * Of course you loose if you try to clear space that starts on a mine.
    * You win when you have correctly identified all mines.
 
 
    When prompted you may:
        Toggle where you think a mine is at position x, y:
          m <x> <y>
        Clear the grid starting at position x, y (and print the result):
          c <x> <y>
        Print the grid so far:
          p
        Quit
          q
    Resigning will first show the grid with an 'N' for unfound true mines, a
    'Y' for found true mines and a '?' for where you marked clear space as a
    mine
EOS WIDTH, HEIGHT = 6, 4PCT = 0.15NUM_MINES = (WIDTH * HEIGHT * PCT).round def create_mines sx, sy  arr = Array.new(WIDTH) { Array.new(HEIGHT, false) }  NUM_MINES.times do    x, y = rand(WIDTH), rand(HEIGHT)    
    redo if arr[x][y] or (x == sx and y == sy)    arr[x][y] = true  end  arrend def num_marks  $screen.inject(0) { |sum, row| sum + row.count(strv) }end def show_grid revealed = false  if revealed    puts $mines.transpose.map { |row| row.map { |cell| cell ? strv : strv }.join(strv) }  else    puts strv    puts $screen.transpose.map{ |row| row.join(strv) }  endend SURROUND = [-1,0,1].product([-1,0,1]) - [[0,0]]     
def surrounding x, y  
  SURROUND.each do |dx, dy|    
    yield(x+dx, y+dy) if (0...WIDTH).cover?(x+dx) and (0...HEIGHT).cover?(y+dy)  endend def clear_space x, y  return unless $screen[x][y] == strv  
  count = 0  surrounding(x, y) { |px, py| count += 1 if $mines[px][py] }  if count == 0    $screen[x][y] = strv    surrounding(x, y) { |px, py| clear_space px, py }  else    $screen[x][y] = count.to_s  endend def victory?  return false if $mines.nil?  
  return false if num_marks != NUM_MINES  mines_left = NUM_MINES  WIDTH.times do |x|    HEIGHT.times do |y|      mines_left -= 1 if $mines[x][y] and $screen[x][y] == strv    end  end   mines_left == 0end def check_input x, y  x, y = x.to_i - 1, y.to_i - 1  [x, y] if (0...WIDTH).cover?(x) and (0...HEIGHT).cover?(y)end $mines = nil$screen = Array.new(WIDTH) { Array.new(HEIGHT, strv) } puts strvshow_grid loop do  print strv  action = gets.chomp.downcase   case action  when strv, strv, strv, strv    puts strv    break  when /^m (\d+) (\d+)$/    
    x, y = check_input $1, $2    next unless x    if $screen[x][y] == strv      
      $screen[x][y] = strv      if victory?        show_grid        puts strv        break      end    elsif $screen[x][y] == strv      
      $screen[x][y] = strv    end    show_grid  when /^c (\d+) (\d+)$/    x, y = check_input $1, $2    next unless x    $mines ||= create_mines(x, y)    if $mines[x][y]      puts strv      show_grid true      break    else      clear_space x, y      show_grid      if victory?        puts strv        break      end    end  when strv    show_grid  endend"
" require 'thread' 
class Semaphore  def initialize(size = 1)    @queue = SizedQueue.new(size)    size.times { acquire }  end   def acquire    tap { @queue.push(nil) }  end   def release    tap { @queue.pop }  end   
  def count    @queue.length  end   def synchronize    release    yield  ensure    acquire  endend def foo(id, sem)  sem.synchronize do    puts strv    sleep(2)  endend threads = []n = 5s = Semaphore.new(3)n.times do |i|  threads << Thread.new { foo i, s }endthreads.each(&:join)  "
" def mod_exp(n, e, mod)  fail ArgumentError, 'negative exponent' if e < 0  prod = 1  base = n % mod  until e.zero?    prod = (prod * base) % mod if e.odd?    e >>= 1    base = (base * base) % mod  end  prodend def miller_rabin_prime?(n, g)  d = n - 1  s = 0  while d % 2 == 0    d /= 2    s += 1  end  g.times do    a = 2 + rand(n - 4)    x = mod_exp(a, d, n) 
    next if x == 1 || x == n - 1    for r in (1..s - 1)      x = mod_exp(x, 2, n) 
      return false if x == 1      break if x == n - 1    end    return false if x != n - 1  end  true 
end p primes = (3..1000).step(2).find_all {|i| miller_rabin_prime?(i,10)}  puts miller_rabin_prime?(94366396730334173383107353049414959521528815310548187030165936229578960209523421808912459795329035203510284576187160076386643700441216547732914250578934261891510827140267043592007225160798348913639472564715055445201512461359359488795427875530231001298552452230535485049737222714000227878890892901228389026881,1000)puts miller_rabin_prime?(138028649176899647846076023812164793645371887571371559091892986639999096471811910222267538577825033963552683101137782650479906670021895135954212738694784814783986671046107023185842481502719762055887490765764329237651328922972514308635045190654896041748716218441926626988737664133219271115413563418353821396401,1000)puts miller_rabin_prime?(123301261697053560451930527879636974557474268923771832437126939266601921428796348203611050423256894847735769138870460373141723679005090549101566289920247264982095246187318303659027201708559916949810035265951104246512008259674244307851578647894027803356820480862664695522389066327012330793517771435385653616841,1000)puts miller_rabin_prime?(119432521682023078841121052226157857003721669633106050345198988740042219728400958282159638484144822421840470442893056822510584029066504295892189315912923804894933736660559950053226576719285711831138657839435060908151231090715952576998400120335346005544083959311246562842277496260598128781581003807229557518839,1000)puts miller_rabin_prime?(132082885240291678440073580124226578272473600569147812319294626601995619845059779715619475871419551319029519794232989255381829366374647864619189704922722431776563860747714706040922215308646535910589305924065089149684429555813953571007126408164577035854428632242206880193165045777949624510896312005014225526731,1000)puts miller_rabin_prime?(153410708946188157980279532372610756837706984448408515364579602515073276538040155990230789600191915021209039203172105094957316552912585741177975853552299222501069267567888742458519569317286299134843250075228359900070009684517875782331709619287588451883575354340318132216817231993558066067063143257425853927599,1000)puts miller_rabin_prime?(103130593592068072608023213244858971741946977638988649427937324034014356815504971087381663169829571046157738503075005527471064224791270584831779395959349442093395294980019731027051356344056416276026592333932610954020105156667883269888206386119513058400355612571198438511950152690467372712488391425876725831041,1000) func is_prime(n, k) {     n == 2 && return true    n <= 1 && return false    n %% 2 && return false     var d = n-1    var s = valuation(d, 2)    d >>= s     k.times {        var a = 2.irand(n)        var x = expmod(a, d, n)        next if (x ~~ [1, n-1])         (s-1).times {            x.expmod!(2, n)            return false if x==1            break if (x == n-1)        }        return false if (x != n-1)    }     return true} say(^1000->grep {|n| is_prime(n, 10) }.join(', '))"
"def middle_three_digits(num)  
  
  num = num.abs   
  length = (str = num.to_s).length   
  raise ArgumentError, strv if length < 3  raise ArgumentError, strv if length.even?   return str[length/2 - 1, 3].to_iendsamples = [   123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345,  1, 2, -1, -10, 2002, -2002, 0 ] left_column_width = samples.map { |n| n.to_s.length }.maxsamples.each do |n|  print strv % n  begin    puts strv % middle_three_digits(n)  rescue ArgumentError => e    puts e  endendfunc middle_three(n) {  var l = n.len;  if (l < 3) {    strv  } elsif (l.is_even) {    strv  } else {    strv + n.digits.ft(l-3 / 2, l/2 + 1).join  }} var nums = %n(    123 12345 1234567 987654321 10001 -10001 -123 -100 100 -12345    1 2 -1 -10 2002 -2002 0);nums.each { say middle_three(_) };"
"require 'bit-struct' class RS232_9 < BitStruct  unsigned :cd,  1, strv       #1  unsigned :rd,  1, strv        #2  unsigned :td,  1, strv     #3  unsigned :dtr, 1, strv  #4  unsigned :sg,  1, strv        #5  unsigned :dsr, 1, strv       #6  unsigned :rts, 1, strv      #7  unsigned :cts, 1, strv        #8  unsigned :ri,  1, strv       #9   def self.new_with_int(value)    data = {}    fields.each_with_index {|f, i| data[f.name] = value[i]}    new(data)  endend num = rand(2**9 - 1)puts strv sample1 = RS232_9.new([(strv % num.to_s(2)).reverse].pack(strv))puts sample1.inspect_detailed sample2 = RS232_9.new_with_int(num)puts sample2.inspect_detailed puts strv"
"class IDVictim   
  attr_accessor :name, :birthday, :gender, :hometown   
  
  def self.new_element(element)    attr_accessor element  end endclass Number {    method ⊕(arg) {        self + arg    }} say (21 ⊕ 42)var colors = Hash(               'black'   => strv,               'red'     => strv,               'green'   => strv,               'yellow'  => strv,               'blue'    => strv,               'magenta' => strv,               'cyan'    => strv,               'white'   => strv,             ) colors.each { |color, code|    String.def_method(strv, func (self) {        '<span style=""color: #' + code + '"">' + self + '</span>'    })} say strv.in_blue;say strv.in_red;say strv.in_white;"
"class Pixmap  def median_filter(radius=3)    radius += 1 if radius.even?    filtered = self.class.new(@width, @height)    pb = ProgressBar.new(@height) if $DEBUG    @height.times do |y|      @width.times do |x|        window = []        (x - radius).upto(x + radius).each do |win_x|          (y - radius).upto(y + radius).each do |win_y|            win_x = 0 if win_x < 0            win_y = 0 if win_y < 0            win_x = @width-1 if win_x >= @width            win_y = @height-1 if win_y >= @height            window << self[win_x, win_y]          end        end        
        filtered[x, y] = window.sort[window.length / 2]      end      pb.update(y) if $DEBUG    end    pb.close if $DEBUG    filtered  endend class RGBColour  
  def luminosity    Integer(0.2126*@red + 0.7152*@green + 0.0722*@blue)  end  def to_grayscale    l = luminosity    self.class.new(l, l, l)  end   
  def <=>(other)    self.luminosity <=> other.luminosity  endend class ProgressBar  def initialize(max)    $stdout.sync = true    @progress_max = max    @progress_pos = 0    @progress_view = 68    $stdout.print ""[_view}][""  end   def update(n)    new_pos = n * @progress_view/@progress_max    if new_pos > @progress_pos      @progress_pos = new_pos       $stdout.print '='    end  end   def close    $stdout.puts '=]'  endend bitmap = Pixmap.open('file')filtered = bitmap.median_filter"
class Thingamajig  def initialize    fail 'not yet implemented'  endendt = Thingamajig.allocate
" def select(prompt, items = [])  if items.empty?    ''  else    answer = -1    until (0...items.length).cover?(answer)      items.each_with_index {|i,j| puts strv}      print strv      begin        answer = Integer(gets)      rescue ArgumentError        redo      end    end    items[answer]  endend 
response = select('Which is empty')puts ""empty list returns: >#{response}<"" 
items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']response = select('Which is from the three pigs', items)puts strv func menu (prompt, arr) {    arr.len > 0 || return ''    loop {        for i in ^arr {            say strv        }        var n = Sys.scanln(prompt) \\ return()        n ~~ /^[0-9]+\z/ ? Num(n) : next        arr.exists(n) && return arr[n]    }} var list = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']var prompt = 'Please choose an item number: ' var answer = menu(prompt, list)say strv"
"require 'openssl'puts OpenSSL::Digest::MD4.hexdigest('Rosetta Code')require 'stringio' 

def md4(string)  
  mask = (1 << 32) - 1  f = proc {|x, y, z| x & y | x.^(mask) & z}  g = proc {|x, y, z| x & y | x & z | y & z}  h = proc {|x, y, z| x ^ y ^ z}  r = proc {|v, s| (v << s).&(mask) | (v.&(mask) >> (32 - s))}   
  a, b, c, d = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476   bit_len = string.size << 3  string += ""80""  while (string.size % 64) != 56    string += """"  end  string = string.force_encoding('ascii-8bit') + [bit_len & mask, bit_len >> 32].pack(strv)   if string.size % 64 != 0    fail strv  end   io = StringIO.new(string)  block = strv   while io.read(64, block)    x = block.unpack(strv)     
    aa, bb, cc, dd = a, b, c, d    [0, 4, 8, 12].each {|i|      a = r[a + f[b, c, d] + x[i],  3]; i += 1      d = r[d + f[a, b, c] + x[i],  7]; i += 1      c = r[c + f[d, a, b] + x[i], 11]; i += 1      b = r[b + f[c, d, a] + x[i], 19]    }    [0, 1, 2, 3].each {|i|      a = r[a + g[b, c, d] + x[i] + 0x5a827999,  3]; i += 4      d = r[d + g[a, b, c] + x[i] + 0x5a827999,  5]; i += 4      c = r[c + g[d, a, b] + x[i] + 0x5a827999,  9]; i += 4      b = r[b + g[c, d, a] + x[i] + 0x5a827999, 13]    }    [0, 2, 1, 3].each {|i|      a = r[a + h[b, c, d] + x[i] + 0x6ed9eba1,  3]; i += 8      d = r[d + h[a, b, c] + x[i] + 0x6ed9eba1,  9]; i -= 4      c = r[c + h[d, a, b] + x[i] + 0x6ed9eba1, 11]; i += 8      b = r[b + h[c, d, a] + x[i] + 0x6ed9eba1, 15]    }    a = (a + aa) & mask    b = (b + bb) & mask    c = (c + cc) & mask    d = (d + dd) & mask  end   [a, b, c, d].pack(strv)end if __FILE__ == $0  
  str = 'Rosetta Code'  printf ""%s:  %s"", str, *md4(str).unpack('H*')endvar digest = frequire('Digest::MD4');say digest.md4_hex('Rosetta Code');"
"require 'digest'Digest::MD5.hexdigest(strv)
var digest = frequire('Digest::MD5');say digest.md5_hex(strv);var md5 = require('Digest::MD5').new;md5.add(strv);say md5.hexdigest;"
"class Maze  
  
  
  def solve     
    reset_visiting_state     
    @queue = []    enqueue_cell([], @start_x, @start_y)     
    
    path = nil    until path || @queue.empty?      path = solve_visit_cell    end     if path      
      for x, y in path        @path[x][y] = true      end    else      puts strv    end  end   private   
  def solve_visit_cell    
    path = @queue.shift    
    x, y = path.last     
    return path  if x == @end_x && y == @end_y     
    @visited[x][y] = true     for dx, dy in DIRECTIONS      if dx.nonzero?        
        new_x = x + dx        if move_valid?(new_x, y) && _walls[ [x, new_x].min ][y]          enqueue_cell(path, new_x, y)        end      else        
        new_y = y + dy        if move_valid?(x, new_y) && _walls[x][ [y, new_y].min ]          enqueue_cell(path, x, new_y)        end      end    end     nil         
  end   
  def enqueue_cell(path, x, y)    
    @queue << path + [[x, y]]  endend 
maze = Maze.new 20, 10maze.solvemaze.print"
"m=[[1,  1,  1,   1],   [2,  4,  8,  16],   [3,  9, 27,  81],   [4, 16, 64, 256],   [5, 25,125, 625]]puts m.transposerequire 'matrix' m=Matrix[[1,  1,  1,   1],         [2,  4,  8,  16],         [3,  9, 27,  81],         [4, 16, 64, 256],         [5, 25,125, 625]]puts m.transposedef transpose(m)  m[0].zip(*m[1..-1])endp transpose([[1,2,3],[4,5,6]])func transpose(matrix) {    matrix[0].range.map{|i| matrix.map{_[i]}};}; var m = [  [1,  1,   1,   1],  [2,  4,   8,  16],  [3,  9,  27,  81],  [4, 16,  64, 256],  [5, 25, 125, 625],]; transpose(m).each { |row|    strv * row.len -> printlnf(row...);}"
"require 'matrix' class Matrix  
  def permanent    r = (0...row_count).to_a 
    r.permutation.inject(0) do |sum, sigma|       sum += sigma.zip(r).inject(1){|prod, (row, col)| prod *= self[row, col] }    end  endend m1 = Matrix[[1,2],[3,4]] 
 m2 = Matrix[[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]] m3 = Matrix[[0, 1, 2, 3, 4],            [5, 6, 7, 8, 9],            [10, 11, 12, 13, 14],            [15, 16, 17, 18, 19],             [20, 21, 22, 23, 24]] [m1, m2, m3].each do |m|  puts ""determinant: #{m.determinant}"", ""permanent: #{m.permanent}""  puts end"
"def map_range(a, b, s)  af, al, bf, bl = a.first, a.last, b.first, b.last  bf + (s - af)*(bl - bf).quo(al - af)end (0..10).each{|s| puts strv % [s, map_range(0..10, -1..0, s)]}(0..10).each do |s|  puts strv % [s, map_range(0..10, -1..0, s)]endfunc map_range(a, b, x) {    var (a1, a2, b1, b2) = (a.bounds, b.bounds);    x-a1 * b2-b1 / a2-a1 + b1;} var a = 0..10;var b = -1..0; for x in a {    say strv;}"
"triangle = ""                         55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93"" ar = triangle.each_line.map{|line| line.split.map(&:to_i)}puts ar.inject([]){|res,x|  maxes = [0, *res, 0].each_cons(2).map(&:max)  x.zip(maxes).map{|a,b| a+b}}.max
var sum = [0] ARGF.each {  |line|    var x = line.words.map{.to_n}    sum = [            x.first + sum.first,            1 ..^ x.end -> map{|i| x[i] + [sum[i-1, i]].max}...,            x.last + sum.last,          ]} say sum.maxvar triangle = ARGF.slurp.lines.map{.words.map{.to_n}} func max_value(i=0, j=0) is cached {    i == triangle.len && return 0    triangle[i][j] + [max_value(i+1, j), max_value(i+1, j+1)].max} say max_value()"
"class Maze  DIRECTIONS = [ [1, 0], [-1, 0], [0, 1], [0, -1] ]   def initialize(width, height)    @width   = width    @height  = height    @start_x = rand(width)    @start_y = 0    @end_x   = rand(width)    @end_y   = height - 1     
    
    
    
    @vertical_walls   = Array.new(width) { Array.new(height, true) }    @horizontal_walls = Array.new(width) { Array.new(height, true) }    
    @path             = Array.new(width) { Array.new(height) }     
    @horizontal_walls[@end_x][@end_y] = false     
    generate  end   
  def print    
    puts @width.times.inject(strv) {|str, x| str << (x == @start_x ? strv : strv)}     
    @height.times do |y|      line = @width.times.inject(strv) do |str, x|        str << (@path[x][y] ? strv : strv) << (@vertical_walls[x][y] ? strv : strv)      end      puts line       puts @width.times.inject(strv) {|str, x| str << (@horizontal_walls[x][y] ? strv : strv)}    end  end   private   
  def reset_visiting_state    @visited = Array.new(@width) { Array.new(@height) }  end   
  def move_valid?(x, y)    (0...@width).cover?(x) && (0...@height).cover?(y) && [x][y]  end   
  def generate    reset_visiting_state    generate_visit_cell(@start_x, @start_y)  end   
  def generate_visit_cell(x, y)    
    @visited[x][y] = true     
    
    coordinates = DIRECTIONS.shuffle.map { |dx, dy| [x + dx, y + dy] }     for new_x, new_y in coordinates      next unless move_valid?(new_x, new_y)       
      
      connect_cells(x, y, new_x, new_y)      generate_visit_cell(new_x, new_y)    end  end   
  def connect_cells(x1, y1, x2, y2)    if x1 == x2      
      @horizontal_walls[x1][ [y1, y2].min ] = false    else      
      @vertical_walls[ [x1, x2].min ][y1] = false    end  endend 
maze = Maze.new 20, 10maze.printvar(w:5, h:5) = ARGV.map{.to_i}...var avail = (w * h) 
var cell = (1..h -> map {([true] * w) + [false]} + [[false] * w+1])var ver  = (1..h -> map {[strv] * w })var hor  = (0..h -> map {[strv] * w }) func walk(x, y) {    cell[y][x] = false;    avail-- > 0 || return;  
     var d = [[-1, 0], [0, 1], [1, 0], [0, -1]]    while (!d.is_empty) {        var i = d.pop_rand        var (x1, y1) = (x + i[0], y + i[1])         cell[y1][x1] || next         if (x == x1) { hor[[y1, y].max][x] = '+  ' }        if (y == y1) { ver[y][[x1, x].max] = '   ' }        walk(x1, y1)    }} walk(w.rand.int, h.rand.int)   
 for i in (0 .. h) {    say (hor[i].join('') + '+')    if (i < h) {        say (ver[i].join('') + '|')    }}"
"def backup_and_open(filename)  filename = File.realpath(filename)  bkup = filename + strv  backup_files = Dir.glob(bkup + strv).sort_by do |f|    f.match(/\d+$/)    $&.nil? ? 0 : $&.to_i  end  backup_files.reverse.each do |fname|    if m = fname.match(/\.backup\.(\d+)$/)      File.rename(fname, strv % [bkup, m[1].to_i + 1])    elsif fname == bkup      File.rename(bkup, bkup + strv)    end  end  File.rename(filename, bkup)  File.open(filename, strv) {|handle| yield handle}end 1.upto(12) {|i| backup_and_open(ARGV[0]) {|fh| fh.puts strv}}"
"require 'fileutils'FileUtils.mkdir_p(strv) Dir.new(Dir.cwd, strv, strv, strv).make_path;   
"
"def a(k, x1, x2, x3, x4, x5)  b = uninitialized -> typeof(k)  b = ->() { k -= 1; a(k, b, x1, x2, x3, x4) }  k <= 0 ? x4.call + x5.call : b.callend puts a(10, -> {1}, -> {-1}, -> {-1}, -> {1}, -> {0})def a(k, x1, x2, x3, x4, x5)  b = lambda { k -= 1; a(k, b, x1, x2, x3, x4) }  k <= 0 ? x4[] + x5[] : b[]end puts a(10, lambda {1}, lambda {-1}, lambda {-1}, lambda {1}, lambda {0})func a(k, x1, x2, x3, x4, x5) {    func b { a(--k, b, x1, x2, x3, x4) };    k <= 0 ? (x4() + x5()) : b();}say a(10, ->{1}, ->{-1}, ->{-1}, ->{1}, ->{0});      #=> -67func a(k, x1, x2, x3, x4, x5) {    k <= 0 ? (x4() + x5())           : func b { a(--k, b, x1, x2, x3, x4) }();}say a(10, ->{1}, ->{-1}, ->{-1}, ->{1}, ->{0});      #=> -67class MOB {    method a(k, x1, x2, x3, x4, x5) {        func b { self.a(--k, b, x1, x2, x3, x4) };        k <= 0 ? (x4() + x5()) : b();    }} var obj = MOB();say obj.a(10, ->{1}, ->{-1}, ->{-1}, ->{1}, ->{0});"
"require 'matrix' Matrix[[1, 2],       [3, 4]] * Matrix[[-3, -8, 3],                        [-2,  1, 4]]def matrix_mult(a, b)  a.map do |ar|    b.transpose.map do |bc|      ar.zip(bc).map(&:*).inject(&:+)    end  endendfunc matrix_multi(a, b) {    var m = [[]]    for r in ^a {        for c in ^b[0] {            for i in ^b {                m[r][c] := 0 += (a[r][i] * b[i][c])            }        }    }    return m} var a = [          [1, 2],          [3, 4],          [5, 6],          [7, 8]        ] var b = [          [1, 2, 3],          [4, 5, 6]        ] for line in matrix_multi(a, b) {    say line.map{|i|'%3d' % i }.join(', ')}"
"def odd_magic_square(n)  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }end def single_even_magic_square(n)   raise ArgumentError, strv unless (n-2) % 4 == 0  raise ArgumentError, strv if n == 2   order = (n-2)/4  odd_square = odd_magic_square(n/2)  to_add = (0..3).map{|f| f*n*n/4}  quarts = to_add.map{|f| odd_square.dup.map{|row|row.map{|el| el+f}} }   sq = []  quarts[0].zip(quarts[2]){|d1,d2| sq << [d1,d2].flatten}  quarts[3].zip(quarts[1]){|d1,d2| sq << [d1,d2].flatten}   sq = sq.transpose  order.times{|i| sq[i].rotate!(n/2)}  swap(sq[0][order], sq[0][-order-1])  swap(sq[order][order], sq[order][-order-1])  (order-1).times{|i| sq[-(i+1)].rotate!(n/2)}  randomize(sq)end def swap(a,b)  a,b = b,aend def randomize(square)  square.shuffle.transpose.shuffleend def to_string(square)  n = square.size  fmt = strv * n  square.inject(strv){|str,row| str << fmt % row << """"}end puts to_string(single_even_magic_square(6))class Magic_square  attr_reader :square  LUX = { L: [[4, 1], [2, 3]], U: [[1, 4], [2, 3]], X: [[1, 4], [3, 2]] }   def initialize(n)    raise ArgumentError, strv unless (n-2) % 4 == 0    raise ArgumentError, strv if n == 2    @n = n    oms = odd_magic_square(n/2)    mat = make_lux_matrix(n/2)    @square = synthesize(oms, mat)    puts to_s  end   def odd_magic_square(n)       
    n.times.map{|i| n.times.map{|j| (n*((i+j+1+n/2)%n) + ((i+2*j-5)%n)) * 4} }  end   def make_lux_matrix(n)    center = n / 2    lux = [*[:L]*(center+1), :U, *[:X]*(n-center-2)]    matrix = lux.map{|x| Array.new(n, x)}    matrix[center][center] = :U    matrix[center+1][center] = :L    matrix  end   def synthesize(oms, mat)    range = 0...@n/2    range.inject([]) do |matrix,i|      row = [[], []]      range.each do |j|        x = oms[i][j]        LUX[mat[i][j]].each_with_index{|lux,k| row[k] << lux.map{|y| x+y}}      end      matrix << row[0].flatten << row[1].flatten    end  end   def to_s    format = ""%#{(@).to_s.size}d "" * @n + """"    @square.map{|row| format % row}.join  endend sq = Magic_square.new(6).square"
"def double_even_magic_square(n)  raise ArgumentError, strv if n%4 > 0  block_size, max = n/4, n*n  pre_pat = [true, false, false, true,             false, true, true, false]  pre_pat += pre_pat.reverse  pattern = pre_pat.flat_map{|b| [b] * block_size} * block_size  flat_ar = pattern.each_with_index.map{|yes, num| yes ? num+1 : max-num}  flat_ar.each_slice(n).to_aend def to_string(square)  n = square.size  fmt = strv * n  square.inject(strv){|str,row| str << fmt % row << """"}end puts to_string(double_even_magic_square(8))"
"def odd_magic_square(n)  raise ArgumentError strv if n.even? || n <= 0  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }end [3, 5, 9].each do |n|  puts ""Size #{n}, magic sum #{(n*n+1)/2*n}""  fmt = strv * n  odd_magic_square(n).each{|row| puts fmt % row}end func magic_square(n {.is_pos && .is_odd}) {    var i = 0    var j = int(n/2)     var magic_square = []    for l in (1 .. n**2) {        magic_square[i][j] = l         if (magic_square[i.dec % n][j.inc % n]) {            i = (i.inc % n)        }        else {            i = (i.dec % n)            j = (j.inc % n)        }    }     return magic_square} func print_square(sq) {    var f = strv;    for row in sq {        say row.map{ f % _ }.join(' ')    }} var(n=5) = ARGV»to_i»()...var sq = magic_square(n)print_square(sq) say ""The magic number is: #{sq[0].sum}"""
"require 'complex' def mandelbrot(a)  Array.new(50).inject(0) { |z,c| z*z + a }end (1.0).step(-1,-0.05) do |y|  (-2.0).step(0.5,0.0315) do |x|    print mandelbrot(Complex(x,y)).abs < 2 ? '*' : ' '  end  putsendclass RGBColour  def self.mandel_colour(i)    self.new( 16*(i % 15), 32*(i % 7), 8*(i % 31) )  endend class Pixmap  def self.mandelbrot(width, height)    mandel = Pixmap.new(width,height)    pb = ProgressBar.new(width) if $DEBUG    width.times do |x|      height.times do |y|        x_ish = Float(x - width*11/15) / (width/3)        y_ish = Float(y - height/2) / (height*3/10)        mandel[x,y] = RGBColour.mandel_colour(mandel_iters(x_ish, y_ish))      end      pb.update(x) if $DEBUG    end    pb.close if $DEBUG    mandel  end   def self.mandel_iters(cx,cy)    x = y = 0.0    count = 0    while Math.hypot(x,y) < 2 and count < 255      x, y = (x**2 - y**2 + cx), (2*x*y + cy)      count += 1    end    count  end end Pixmap.mandelbrot(300,300).save('mandel.ppm')func mandelbrot(z) {    var c = z;    {   z = (z*z + c);        z.abs > 2 && return true;    } * 20;    return false;} 1 ^.. (-1, 0.05) -> each { |y|    -2 ..^ (0.5, 0.0315) -> each { |x|        print(mandelbrot(y.i + x) ? ' ' : '#');    }    print """";}"
"puts strvstory = strvuntil (line = gets).chomp.empty?  story << lineend story.scan(/(?<=[<]).+?(?=[>])/).uniq.each do |var|  print strv  story.gsub!(/<#{var}>/, gets.chomp)end putsputs storyvar story = ARGF.slurp; var blanks = Hash.new;while (var m = /<(.*?)>/.gmatch(story)) {    blanks.append(m[0]);} blanks.keys.sort.each { |blank|    var replacement = Sys.scanln(strv);    blanks{blank} = replacement;} print story.gsub(/<(.*?)>/, {|s1| blanks{s1} });"
"require 'set' def add_reverse(num, max_iter=1000)  (1..max_iter).each_with_object(Set.new([num])) do |_,nums|    num += reverse_int(num)    nums << num    return nums if palindrome?(num)  endend def palindrome?(num)  num == reverse_int(num)end def reverse_int(num)  num.to_s.reverse.to_iend def split_roots_from_relateds(roots_and_relateds)  roots = roots_and_relateds.dup  i = 1  while i < roots.length    this = roots[i]    if roots[0...i].any?{|prev| this.intersect?(prev)}      roots.delete_at(i)    else      i += 1    end  end  root = roots.map{|each_set| each_set.min}  related = roots_and_relateds.map{|each_set| each_set.min}  related = related.reject{|n| root.include?(n)}  return root, relatedend def find_lychrel(maxn, max_reversions)  series = (1..maxn).map{|n| add_reverse(n, max_reversions*2)}  roots_and_relateds = series.select{|s| s.length > max_reversions}  split_roots_from_relateds(roots_and_relateds)end maxn, reversion_limit = 10000, 500puts strvlychrel, l_related = find_lychrel(maxn, reversion_limit)puts strvputs strvputs strvpals = (lychrel + l_related).select{|x| palindrome?(x)}.sortputs strvputs strvvar (    lychrels = [],    palindromes = [],    seeds = [],    max = 500,) for int in (1 .. 10_000) {    var (test = [], count = 0)     func lychrel(l) {        count++ > max && return true        test << (var m = (l + Num(Str(l).flip)))        Str(m).is_palindrome && return false        lychrel(m)    }     if (lychrel(int)) {        lychrels << Pair(Str(int), test)    }} seeds << lychrels[0] for l in lychrels {    if (l.key.is_palindrome) {        palindromes << l.key    }     (var h = Hash()){l.value} = ()     var trial = seeds.count_by { |s|        s.value.any { |k| h.contains(k) } ? break : true    }     if (trial == seeds.len) {        seeds << l    }} say (strv, seeds.len)say (strv, seeds.map{.key}.join(', '))say (strv, lychrels.len - seeds.len)say (strv, palindromes.len)say (strv, palindromes.join(', '))"
"def generator(even=false, nmax=1000000)  start = even ? 2 : 1  Enumerator.new do |y|    n = 1    ary = [0] + (start..nmax).step(2).to_a      
    y << ary[n]    while (m = ary[n+=1]) < ary.size      y << m      (m...ary.size).step(m){|i| ary[i]=nil}      ary.compact!                              
    end    
    ary[n..-1].each{|i| y << i}    raise StopIteration  endend def lucky(argv)  j, k = argv[0].to_i, argv[1].to_i  mode = /even/i=~argv[2] ? :'even lucky' : :lucky  seq = generator(mode == :'even lucky')  ord = ->(n){strv}  if k.zero?    puts strv  elsif 0 < k    puts strv,         strv  else    k = -k    ary = []    loop do      case num=seq.next      when 1...j      when j..k  then ary << num      else break      end    end    puts strv,         strv  endend if __FILE__ == $0  lucky(ARGV)end"
"
def compress(uncompressed)    
    dict_size = 256    dictionary = Hash[ Array.new(dict_size) {|i| [i.chr, i.chr]} ]     w = strv    result = []    for c in uncompressed.split('')        wc = w + c        if dictionary.has_key?(wc)            w = wc        else            result << dictionary[w]            
            dictionary[wc] = dict_size            dict_size += 1            w = c        end    end     
    result << dictionary[w] unless w.empty?    resultend 
def decompress(compressed)    
    dict_size = 256    dictionary = Hash[ Array.new(dict_size) {|i| [i.chr, i.chr]} ]     w = result = compressed.shift    for k in compressed        if dictionary.has_key?(k)            entry = dictionary[k]        elsif k == dict_size            entry = w + w[0,1]        else            raise 'Bad compressed k: %s' % k        end        result += entry         
        dictionary[dict_size] = w + entry[0,1]        dict_size += 1         w = entry    end    resultend 
compressed = compress('TOBEORNOTTOBEORTOBEORNOT')p compresseddecompressed = decompress(compressed)puts decompressed
func compress(String uncompressed) -> Array {     
    var dict_size = 256    var dictionary = Hash()     for i in range(dict_size) {        dictionary{i.chr} = i.chr    }     var w = ''    var result = []    uncompressed.each { |c|        var wc = w+c        if (dictionary.exists(wc)) {            w = wc        } else {            result << dictionary{w}            
            dictionary{wc} = dict_size            dict_size++            w = c        }    }     
    if (w != '') {        result << dictionary{w}    }     return result} 
func decompress(Array compressed) -> String {     
    var dict_size = 256    var dictionary = Hash()     for i in range(dict_size) {        dictionary{i.chr} = i.chr    }     var w = compressed.shift    var result = w    compressed.each { |k|        var entry = nil        if (dictionary.exists(k)) {            entry = dictionary{k}        } elsif (k == dict_size) {            entry = w+w.first        } else {            die strv        }        result += entry         
        dictionary{dict_size} = w+entry.first        dict_size++         w = entry    }    return result} 
var compressed = compress('TOBEORNOTTOBEORTOBEORNOT')say compressed.join(' ')var decompressed = decompress(compressed)say decompressed"
"def ludic(nmax=100000)  Enumerator.new do |y|    y << 1    ary = *2..nmax    until ary.empty?      y << (n = ary.first)      (0...ary.size).step(n){|i| ary[i] = nil}      ary.compact!    end  endend puts strv, ludic.first(25).to_s puts strv, ludic(1000).count puts strv, ludic.first(2005).last(6).to_s ludics = ludic(250).to_aputs strv,     ludics.select{|x| ludics.include?(x+2) and ludics.include?(x+6)}.map{|x| [x, x+2, x+6]}.to_sfunc ludics_upto(nmax=100000) {  Enumerator({ |collect|    collect(1)    var arr = @(2..nmax)    while (arr) {      collect(var n = arr[0])      arr.range.by(n).each {|i| arr[i] = nil}      arr.compact!    }  })} func ludics_first(n) {    ludics_upto(n * n.log2).first(n)} say(strv,     ludics_first(25).join(' '))say(strv,          ludics_upto(1000).len)say(strv, ludics_first(2005).last(6).join(' ')) var a = ludics_upto(250).to_asay(strv, a.grep{|x| a.contains_all([x+2, x+6]) } \                                  .map {|x| '(' + [x, x+2, x+6].join(' ') + ')' } \                                  .join(' '))"
"def is_prime ( p )  return true  if p == 2  return false if p <= 1 || p.even?  (3 .. Math.sqrt(p)).step(2) do |i|    return false  if p % i == 0  end  trueend def is_mersenne_prime ( p )  return true  if p == 2  m_p = ( 1 << p ) - 1  s = 4  (p-2).times { s = (s ** 2 - 2) % m_p }  s == 0end precision = 20000   
long_bits_width = precision / Math.log(2) * Math.log(10)upb_prime = (long_bits_width - 1).to_i / 2    
upb_count = 45      
 puts strv % upb_prime count = 0for p in 2..upb_prime  if is_prime(p) && is_mersenne_prime(p)    print strv % p    count += 1  end  break  if count >= upb_countendputsfunc is_mersenne_prime(p) {    p == 2 && return(true);    var s = 4    var mp = (2**p - 1)    (p-2).times {      s = (s.expmod(2, mp) - 2)      s < 0 && (s += mp)    }    s == 0} Inf.times { |n|       n.is_prime           ->    && is_mersenne_prime(n) ->    && say strv}"
"require 'matrix' class Matrix  def lu_decomposition    p = get_pivot    tmp = p * self    u = Matrix.zero(row_size).to_a    l = Matrix.identity(row_size).to_a    (0 ... row_size).each do |i|      (0 ... row_size).each do |j|        if j >= i          
          u[i][j] = tmp[i,j] - (0 ... i).inject(0.0) {|sum, k| sum + u[k][j] * l[i][k]}        else          
          l[i][j] = (tmp[i,j] - (0 ... j).inject(0.0) {|sum, k| sum + u[k][j] * l[i][k]}) / u[j][j]        end      end    end    [ Matrix[*l], Matrix[*u], p ]  end   def get_pivot    raise ArgumentError, strv unless square?    id = Matrix.identity(row_size).to_a    (0 ... row_size).each do |i|      max = self[i,i]      row = i      (i ... row_size).each do |j|        if self[j,i] > max          max = self[j,i]          row = j        end      end      id[i], id[row] = id[row], id[i]    end    Matrix[*id]  end   def pretty_print(format, head=nil)    puts head if head    puts each_slice(column_size).map{|row| format*row_size % row}  endend puts strva = Matrix[[1,  3,  5],           [2,  4,  7],           [1,  1,  0]]a.pretty_print(strv, strv)l, u, p = a.lu_decompositionl.pretty_print(strv, strv)u.pretty_print(strv, strv)p.pretty_print(strv,    strv) puts ""Example 2:""a = Matrix[[11, 9,24,2],            [ 1, 5, 2,6],            [ 3,17,18,1],            [ 2, 5, 7,1]]a.pretty_print(strv, strv)l, u, p = a.lu_decompositionl.pretty_print(strv, strv)u.pretty_print(strv, strv)p.pretty_print(strv,    strv)l, u, p = a.lup_decompositionl.pretty_print(strv, strv)u.pretty_print(strv, strv)p.pretty_print(strv,    strv)func is_square(m) { m.all { .len == m.len } }func matrix_zero(n, m=n) { m.of { n.of(0) } }func matrix_ident(n) { n.of {|i| [(i-1).of(0)..., 1, (n-i).of(0)...] } } func pivotize(m) {    var size = m.len    var id = matrix_ident(size)    for i in ^size {        var max = m[i][i]        var row = i        for j in range(i, size-1) {            if (m[j][i] > max) {                max = m[j][i]                row = j            }        }        if (row != i) {            id.swap(row, i)        }    }    return id} func mmult(a, b) {    var p = []    for r,c in (^a ~X ^b[0]) {        for i in ^b {            p[r][c] := 0 += (a[r][i] * b[i][c])        }    }    return p} func lu(a) {    is_square(a) || die strv;    var n = a.len    var P = pivotize(a)    var Aʼ = mmult(P, a)    var L = matrix_ident(n)    var U = matrix_zero(n)    for i,j in (^n ~X ^n) {        if (j >= i) {            U[i][j] = (Aʼ[i][j] - (^i->map { U[_][j] * L[i][_] }.sum(0)))        } else {            L[i][j] = ((Aʼ[i][j] - (^j->map { U[_][j] * L[i][_] }.sum(0))) / U[j][j])        }    }    return [P, Aʼ, L, U]} func say_it(message, array) {    say ""#{message}""    array.each { |row|        say row.map{strv % .as_rat}.join(' ')    }} var t = [[   %n(1 3 5),   %n(2 4 7),   %n(1 1 0),],[   %n(11  9 24  2),   %n( 1  5  2  6),   %n( 3 17 18  1),   %n( 2  5  7  1),]] t.each { |test|    say_it('A Matrix', test);    for a in (['P Matrix', 'Aʼ Matrix', 'L Matrix', 'U Matrix'] ~Z lu(test)) {        say_it(a[0], a[1])    }}"
"ary = (1..20).to_a.shuffle.each_slice(4).to_ap ary catch :found_it do  for row in ary    for element in row      print strv % element      throw :found_it if element == 20    end    puts strv  endend puts strvp slices = [*1..20].shuffle.each_slice(4) slices.any? do |slice|  puts  slice.any? do |element|    print strv    element == 20  endendputs strvvar arr = 10.of{ 10.of{ 20.irand + 1 } } for row in arr {    for num in row {        strv.printf(num);        num == 20 && goto :OUT    }    print """"} @:OUT print """""
"def luhn(code)  csum = 0  code.digits.each_slice(2) do |odd, even|     double = even.to_i * 2    double -= 9 if double > 9    csum += double + odd  end  csum % 10 == 0end [49927398716, 49927398717, 1234567812345678, 1234567812345670].each do |n|  p [n, luhn(n)]endfunc luhn (n) {    var chars = n.digits.reverse;    var (i, sum) = (0, 0);    static a = (0..9 -> map {|j| (2*j / 10 -> int) + (2*j % 10 -> int) });    chars.each { |j|        sum += (i++.is_odd ? a[j] : j);    }    return (sum % 10 == 0);} 
[49927398716, 49927398717, 1234567812345678, 1234567812345670].each { |n|    say [n, luhn(n)];}"
i = 1024while i > 0 do   puts i   i /= 2endputs i = 1024puts i /= 2 while i > 0i = 1024until i <= 0 do   puts i   i /= 2endvar i = 1024while (i > 0) {    say i    i //= 2}
" (1..10).each do |i|  print i  break if i == 10  print strvendputs puts (1..10).join(strv)for (1..10) { |i|    print i;    i == 10 && break;    print ', ';} print """";"
loop {puts strv} loop { say strv };
"2.step(8,2) {|n| print strv}puts strv(2..8).step(2) {|n| print strv}puts strvfor n in (2..8).step(2)  print strvendputs strvfor (var i = 2; i <= 8; i += 2) {    say i}for i in (2 .. (8, 2)) {    say i}2.to(8).by(2).each { |i|    say i}"
"for i in collection do  puts iendcollection.each do |i|  puts iendforeach [1,2,3] { |i|    say i}for i in [1,2,3] {    say i}[1,2,3].each { |i|    say i}"
"for i in 1..5  for j in 1..i    print strv  end  putsend(1..5).each do |i|  (1..i).each do |j|    print strv  end  putsend1.upto(5) do |i|  1.upto(i) do |j|    print strv  end  putsend5.times do |i|  
  (i+1).times do    print strv  end  putsendi = 1loop do  j = 1  loop do    print strv    break if (j += 1) > i  end  puts  break if (i += 1) > 5endputs (1..5).map { |i| strv * i }for (var i = 1; i <= 5; i++) {    for (var j = 1; j <= i; j++) {        print '*'    }    print """"}for (1..5) { |i|    for (1..i) { print '*' }    print """"}for i in (1..5) {    for j in (1..i) { print '*' }    print """"}5.times { |i|    i.times { print '*' }    print """"}"
val = 0begin   val += 1   puts valend while val % 6 != 0val = 0begin   val += 1   puts valend until val % 6 == 0val = 0loop do   val += 1   puts val   break unless val %6 != 0endval = 0loop do   val += 1   puts val   break if val %6 == 0endvar value = 0;do {    say ++value;} while (value % 6);
"for i in 1..10 do   print i   if i % 5 == 0 then      puts      next   end   print ', 'end(1..10).each do |i| ...1.upto(10) do |i| ...10.times do |n| i=n+1; ...(1..10).each_slice(5){|ar| puts ar.join(strv)}for i in (1..10) {    print i    if (i %% 5) {        print """"        next    }    print ', '}"
"loop do  a = rand(20)  print a  if a == 10    puts    break  end  b = rand(20)  puts ""#{b}""endloop do  print a = rand(20)  puts or break if a == 10  puts ""#{rand(20)}""endvar lim = 20;loop {    say (var n = lim.rand.int);    n == 10 && break;    say lim.rand.int;}"
10.downto(0) do |i|   puts iendfor (var i = 10; i >= 0; i--) {    say i}for i in (11 ^.. 0) {    say i}10.downto(0).each { |i|    say i}
"
BEGIN {   v = [ ]   m = 0} n = $_.lengthif n == m then   v <<= $_elsif n > m then   v = [$_]   m = nend END {   v.each { |s| puts s }}h = $stdin.group_by(&:size)puts h.max.last  unless h.empty?var l = '';  
var a = '';  
 STDIN.each { |n|    n.substr(l.len) ? (a = n; l = n)                    : (!l.substr(n.len) && a.concat!(n));} print a;"
"['a','b','c'].zip(['A','B','C'], [1,2,3]) {|i,j,k| puts strv}['a','b','c'].zip(['A','B','C'], [1,2,3]) {|a| puts a.join}irb(main):001:0> ['a','b','c'].zip(['A','B'], [1,2,3,4]) {|a| puts a.join}aA1bB2c3=> nilirb(main):002:0> ['a','b','c'].zip(['A','B'], [1,2,3,4])=> [[strv, strv, 1], [strv, strv, 2], [strv, nil, 3]]MultiArray.new(%w(a b c),%w(A B C),%w(1 2 3)).each { |i,j,k|    say (i, j, k);}"
"def longest_common_substring(a,b)  lengths = Array.new(a.length){Array.new(b.length, 0)}  greatestLength = 0  output = strv  a.each_char.with_index do |x,i|    b.each_char.with_index do |y,j|      next if x != y      lengths[i][j] = (i.zero? || j.zero?) ? 1 : lengths[i-1][j-1] + 1      if lengths[i][j] > greatestLength        greatestLength = lengths[i][j]        output = a[i - greatestLength + 1, greatestLength]      end    end  end  outputend p longest_common_substring(strv, strv)func createSubstrings(String word) -> Array {  gather {    for i,j in @(0 .. word.len).combinations(2) {        take(word.substr(i, j-i))    }  }} func findLongestCommon(String first, String second) -> String {    createSubstrings(first) & createSubstrings(second) -> max_by { .len }} say findLongestCommon(strv, strv)"
"Node = Struct.new(:val, :back) def lis(n)  pileTops = []  
  for x in n    
    low, high = 0, pileTops.size-1    while low <= high      mid = low + (high - low) / 2      if pileTops[mid].val >= x        high = mid - 1      else        low = mid + 1      end    end    i = low    node = Node.new(x)    node.back = pileTops[i-1]  if i > 0    pileTops[i] = node  end   result = []  node = pileTops.last  while node    result.unshift(node.val)    node = node.back  end  resultend p lis([3, 2, 6, 4, 5, 1])p lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])func lis(a) {    var l = a.len.of { [] }    l[0] << a[0]    for i in (1..a.end) {        for j in ^i {            if ((a[j] < a[i]) && (l[i].len < l[j].len+1)) {                l[i] = [l[j]...]            }        }        l[i] << a[i]    }    l.max_by { .len }} say lis(%i<3 2 6 4 5 1>)say lis(%i<0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15>)func lis(deck) {    var pileTops = []    deck.each { |x|        var low = 0;        var high = pileTops.end        while (low <= high) {            var mid = ((low + high) // 2)            if (pileTops[mid]{:val} >= x) {                high = mid-1            } else {                low = mid+1            }        }        var i = low        var node = Hash(val => x)        node{:back} = pileTops[i-1] if (i != 0)        pileTops[i] = node    }    var result = []    for (var node = pileTops[-1]; node; node = node{:back}) {        result << node{:val}    }    result.reverse} say lis(%i<3 2 6 4 5 1>)say lis(%i<0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15>)"
" class String  def look_and_say    gsub(/(.)\1*/){|s| s.size.to_s + s[0]}  endend ss = '1'12.times {puts ss; ss = ss.look_and_say} def lookandsay(str)  str.gsub(/(.)\1*/) {$&.length.to_s + $1}end num = strv10.times do  puts num  num = lookandsay(num)enddef lookandsay(str)  str.chars.chunk{|c| c}.map{|c,x| [x.size, c]}.joinend puts num = strv9.times do  puts num = lookandsay(num)end
module Enumerable  
  
  
  def cluster    cluster = []    each do |element|      if cluster.last && cluster.last.last == element        cluster.last << element      else        cluster << [element]      end    end    cluster  endenddef print_sequence(input_sequence, seq=10)  return unless seq > 0  puts input_sequence.join  result_array = input_sequence.cluster.map do |cluster|    [cluster.count, cluster.first]  end  print_sequence(result_array.flatten, seq-1)end print_sequence([1])func lookandsay(str) {    str.gsub(/((.)\2*)/, {|a,b| a.len.to_s + b });} var num = strv;{  say num;  num = lookandsay(num);} * 10;"
"def lcp(*strs)  return strv if strs.empty?  min, max = strs.minmax  idx = min.size.times{|i| break i if min[i] != max[i]}  min[0...idx]end data = [  [strv,strv,strv],  [strv,strv],  [strv,strv],  [strv,strv,strv],  [strv],  [strv],  [],  [strv,strv],  [strv,strv]] data.each do |set|  puts strvend
func find_common_prefix(hash, acc) {    if (hash.len == 1) {        var pair = hash.to_a[0]        return __FUNC__(pair.value, acc+pair.key)    }    return acc} 
func lcp(*strings) {    var hash = Hash()     for str in (strings.sort_by{.len}) {        var ref = hash        str.is_empty && return ''        for char in str {            if (ref.contains(char)) {                ref = ref{char}                ref.len == 0 && break            }            else {                ref = (ref{char} = Hash())            }        }    }     return find_common_prefix(hash, '')}var data = [  [strv,strv,strv],  [strv,strv],  [strv,strv],  [strv,strv,strv],  [strv],  [strv],  [],  [strv,strv],  [strv,strv]]; data.each { |set|    say strv;};"
"=begin
irb(main):001:0> lcs('thisisatest', 'testing123testing')
=> strv
=enddef lcs(xstr, ystr)  return strv if xstr.empty? || ystr.empty?   x, xs, y, ys = xstr[0..0], xstr[1..-1], ystr[0..0], ystr[1..-1]  if x == y    x + lcs(xs, ys)  else    [lcs(xstr, ys), lcs(xs, ystr)].max_by {|x| x.size}  endendclass LCS  SELF, LEFT, UP, DIAG = [0,0], [0,-1], [-1,0], [-1,-1]   def initialize(a, b)    @m = Array.new(a.length) { Array.new(b.length) }    a.each_char.with_index do |x, i|      b.each_char.with_index do |y, j|        match(x, y, i, j)      end    end  end   def match(c, d, i, j)    @i, @j = i, j    @m[i][j] = compute_entry(c, d)  end   def lookup(x, y)        [@i+x, @j+y]                      end  def valid?(, )  i >= 0 && j >= 0                  end   def peek(x, y)    i, j = lookup(x, y)    valid?(i, j) ? @m[i][j] : 0  end    def compute_entry(c, d)    c == d ? peek(*DIAG) + 1 : [peek(*LEFT), peek(*UP)].max  end   def backtrack    @i, @j = @m.length-1, @m[0].length-1    y = []    y << @i+1 if backstep? while valid?    y.reverse  end   def backtrack2    @i, @j = @m.length-1, @m[0].length-1    y = []    y << @j+1 if backstep? while valid?    [backtrack, y.reverse]  end   def backstep?    backstep = compute_backstep    @i, @j = lookup(*backstep)    backstep == DIAG  end   def compute_backstep    case peek(*SELF)    when peek(*LEFT) then LEFT    when peek(*UP)   then UP    else                  DIAG    end  endend def lcs(a, b)  walker = LCS.new(a, b)  walker.backtrack.map{|i| a[i]}.joinend if $0 == __FILE__  puts lcs('thisisatest', 'testing123testing')  puts lcs(strv, strv)endfunc lcs(xstr, ystr) is cached {     xstr.is_empty && return xstr;    ystr.is_empty && return ystr;     var(x, xs, y, ys) = (xstr.ft(0,0), xstr.ft(1),                         ystr.ft(0,0), ystr.ft(1));     if (x == y) {        x + lcs(xs, ys)    } else {        [lcs(xstr, ys), lcs(xs, ystr)].max_by { .len };    }} say lcs(strv, strv);"
"def logic(a, b)  print 'a and b: ', a && b, """"  print 'a or b: ' , a || b, """"  print 'not a: '  , !a    , """"  print 'a xor b: ' , a ^ b, """"endfunc logic(a, b) {    say (strv, a && b);    say (strv, a || b);    say (strv, a ^ b);    say (strv, !a);} logic(false, true);"
"'single quotes with embedded quote and backslash'%q(not interpolating with (nested) parenthesesand newline)a = 42""double quotes with embedded quotenewline and variable interpolation: #{a} % 10 = #{a % 10}""%Q(same as above)%|same as above|print <<HERE
With an unquoted delimiter, this interpolates:
a = #{a}
HEREprint <<-INDENTED   This delimiter can have whitespace before it   INDENTEDprint <<'NON_INTERPOLATING'This will not interpolate: #{a}NON_INTERPOLATING'single quotes with embedded quote and backslash';‚unicode single quoted’;%q(not interpolating with (nested) parenthesesand newline);var a = 42;""double quotes with embedded quotenewline and variable interpolation: #{a} % 10 = #{a % 10}"";„same as above”;%Q(same as above);print <<EOT
Implicit double-quoted (interpolates):
a = #{a}
EOT print <<strvExplicit double-quoted with interpolation:a = #{a}EOD print <<'NON_INTERPOLATING'This will not interpolate: #{a}NON_INTERPOLATING"
say 1.234;say .1234;say 1234e-5;say 12.34e5;
"727 == 0b1011010111  
727 == 0x2d7   
727 == 0o1327  
727 == 01327   
 12345 == 12_345 
 say 255;say 0xff;say 0377;say 0b1111_1111;"
"def longmult(x,y)  digits = reverse_split_number(x)  result = [0]  j = 0  reverse_split_number(y).each do |m|    c = 0    i = j    digits.each do |d|      v = result[i]      result << 0 if v.zero?      c, v = (v + c + d*m).divmod(10)      result[i] = v      i += 1    end    result[i] += c    j += 1  end  
  result.reverse.inject(0) {|sum, n| 10*sum + n}end def reverse_split_number(m)  digits = []  while m > 0    m, v = m.divmod 10    digits << v  end  digitsend n=2**64printf ""         %d * %d = %d"", n, n, n*nprintf ""longmult(%d, %d) = %d"", n, n, longmult(n,n)say (2**64 * 2**64);func add_with_carry(result, addend, addendpos) {    loop {        while (result.len < addendpos+1) {            result.append(0);        };        var addend_digits = (addend.to_i + result[addendpos].to_i -> to_chars);        result[addendpos] = addend_digits.pop;        addend_digits.len > 0 || break;        addend = addend_digits.pop;        addendpos++;    }} func longhand_multiplication(multiplicand, multiplier) {     var result = [];    var multiplicand_offset = 0;     multiplicand.reverse.each { |multiplicand_digit|        var multiplier_offset = multiplicand_offset;        multiplier.reverse.each { |multiplier_digit|            var multiplication_result = (multiplicand_digit.to_i * multiplier_digit.to_i -> to_s);             var addend_offset = multiplier_offset;            multiplication_result.reverse.each { |result_digit_addend|                add_with_carry(result, result_digit_addend, addend_offset);                addend_offset++;            };            multiplier_offset++;        };        multiplicand_offset++;    };     return result.join.reverse;} say longhand_multiplication('18446744073709551616', '18446744073709551616');func long_multiplication(String a, String b) -> String {     if (a.len < b.len) {        (a, b) = (b, a)    }     '0' ~~ [a, b] && return '0'     var x = a.reverse.chars.map{.to_n}    var y = b.reverse.chars.map{.to_n}     var xlen = x.end    var ylen = y.end     var mem = 0    var map = y.len.of { [] }     for j in ^y {        for i in ^x {            var n = (x[i]*y[j] + mem)            var(d, m) = n.divmod(10)            if (i == xlen) {                map[j] << (m, d)                mem = 0;            }            else {                map[j] << m                mem = d            }        }         var n = (ylen - j)        n > 0 && map[j].append(n.of(0)...)        var m = (ylen - n)        m > 0 && map[j].prepend(m.of(0)...)    }     var result = []    var mrange = ^map    var end    = (xlen + ylen + 2)     for i in ^end {        var n = (mrange.map {|j| map[j][i] }.sum + mem)        (mem, result[result.end+1]) = n.divmod(10)    }     result.join.reverse -= /^0+/} say long_multiplication('18446744073709551616', '18446744073709551616')"
"n = 20 
r = ((1..n).flat_map { |x|       (x..n).flat_map { |y|         (y..n).flat_map { |z|           [[x, y, z]].keep_if { x * x + y * y == z * z }}}}) p r 
n = 20 unless Enumerable.method_defined? :flat_map  module Enumerable    def flat_map      inject([]) { |a, x| a.concat yield(x) }    end  endend unless Array.method_defined? :keep_if  class Array    def keep_if      delete_if { |x| not yield(x) }    end  endend 
r = ((1..n).flat_map { |x|       (x..n).flat_map { |y|         (y..n).flat_map { |z|           [[x, y, z]].keep_if { x * x + y * y == z * z }}}}) p r 
var n = 20say gather {    for x in (1 .. n) {        for y in (x .. n) {           for z in (y .. n) {             take([x,y,z]) if (x*x + y*y == z*z)           }        }    }}"
"require 'lcs' def levenshtein_align(a, b)  apos, bpos = LCS.new(a, b).backtrack2   c = strv  d = strv  x0 = y0 = -1  dx = dy = 0  apos.zip(bpos) do |x,y|    diff = x + dx - y - dy    if diff < 0      dx -= diff      c += strv * (-diff)    elsif diff > 0      dy += diff      d += strv * diff    end    c += a[x0+1..x]    x0 = x    d += b[y0+1..y]    y0 = y  end   c += a[x0+1..-1]  d += b[y0+1..-1]  diff = a.length + y0 - b.length - x0  if diff < 0    c += strv * (-diff)  elsif diff > 0    d += strv * diff  end  [c, d]end puts levenshtein_align(strv, strv)func align(s, t) {    s.chars!.prepend!('^')    t.chars!.prepend!('^')     var A = []    for i in ^s { A[i][0]{@|<d s t>} = (i, s.ft(1, i).join, '~' * i) }    for i in ^t { A[0][i]{@|<d s t>} = (i, '-' * i, t.ft(1, i).join) }     s.end.times { |i|      t.end.times { |j|        if (s[i] != t[j]) {          A[i][j]{:d} = 1+(            var min = Math.min(A[i-1][j]{:d}, A[i][j-1]{:d}, A[i-1][j-1]{:d})          )          A[i][j]{@|<s t>} = @|(A[i-1][j]{:d} == min              ? [A[i-1][j]{:s}+s[i], A[i-1][j]{:t}+'-']              : (A[i][j-1]{:d} == min              ? [A[i][j-1]{:s}+'-', A[i][j-1]{:t}+t[j]]              : [A[i-1][j-1]{:s}+s[i], A[i-1][j-1]{:t}+t[j]]))        }        else {          A[i][j]{@|<d s t>} = (              A[i-1][j-1]{:d},              A[i-1][j-1]{:s}+s[i],              A[i-1][j-1]{:t}+t[j],          )        }      }    }    return [A[-1][-1]{@|<s t>}]} align(strv, strv).each { .say }"
"module LCG  module Common    
    attr_reader :seed     
    def initialize(seed)      @seed = @r = seed    end  end   
  
  class Berkeley    include Common    def rand      @r = (1103515245 * @r + 12345) & 0x7fff_ffff    end  end   
  
  class Microsoft    include Common    def rand      @r = (214013 * @r + 2531011) & 0x7fff_ffff      @r >> 16    end  endendlcg = LCG::Berkeley.new(1)p (1..5).map {lcg.rand}
 lcg = LCG::Microsoft.new(1)p (1..5).map {lcg.rand}
module LCG {   
  class Common(r) {     has seed = r  }   
  
  class Berkeley < Common {    method rand {      self.r = ((1103515245 * self.r + 12345) & 0x7fff_ffff);    }  }   
  
  class Microsoft < Common {    method rand {      self.r = ((214013 * self.r + 2531011) & 0x7fff_ffff);      self.r >> 16;    }  }} var lcg1 = LCG::Berkeley(1)say 5.of { lcg1.rand } var lcg2 = LCG::Microsoft(1)say 5.of { lcg2.rand }"
"module Levenshtein   def self.distance(a, b)    a, b = a.downcase, b.downcase    costs = Array(0..b.length) 
    (1..a.length).each do |i|      costs[0], nw = i, i - 1  
      (1..b.length).each do |j|        costs[j], nw = [costs[j] + 1, costs[j-1] + 1, a[i-1] == b[j-1] ? nw : nw + 1].min, costs[j]      end    end    costs[b.length]  end   def self.test    %w{kitten sitting saturday sunday rosettacode raisethysword}.each_slice(2) do |a, b|      puts strv    end  end end Levenshtein.testdef levenshtein_distance(str1, str2)  n = str1.length  m = str2.length  max = n/2   return m if 0 == n  return n if 0 == m  return n if (n - m).abs > max   d = (0..m).to_a  x = nil   str1.each_char.with_index do |char1,i|    e = i+1     str2.each_char.with_index do |char2,j|      cost = (char1 == char2) ? 0 : 1      x = [ d[j+1] + 1, 
            e + 1,      
            d[j] + cost 
          ].min      d[j] = e      e = x    end     d[m] = x  end   xend %w{kitten sitting saturday sunday rosettacode raisethysword}.each_slice(2) do |a, b|  puts strvendfunc lev(s, t) is cached {     s.is_empty && return t.len;    t.is_empty && return s.len;     var s1 = s.ft(1);    var t1 = t.ft(1);     s[0] == t[0] ? __FUNC__(s1, t1)                 : 1+[                        __FUNC__(s1, t1),                        __FUNC__(s,  t1),                        __FUNC__(s1, t )                     ].min;}func lev(s, t) {    var d = [@(0 .. t.len), s.len.of {[_]}...]    for i,j in (^s ~X ^t) {        d[i+1][j+1] = (            s[i] == t[j]                ? d[i][j]                : 1+Math.min(d[i][j+1], d[i+1][j], d[i][j])        )    }    d[-1][-1]}say lev(%c'kitten', %c'sitting');               
say lev(%c'rosettacode', %c'raisethysword');    
"
"def letter_frequency(file)  letters = 'a' .. 'z'  File.read(file) .       split(//) .       group_by {|letter| letter.downcase} .       select   {|key, val| letters.include? key} .       collect  {|key, val| [key, val.length]} end letter_frequency(ARGV[0]).sort_by {|key, val| -val}.each {|pair| p pair}def letter_frequency(file)  freq = Hash.new(0)  file.each_char.lazy.grep(/[[:alpha:]]/).map(&:upcase).each_with_object(freq) do |char, freq_map|    freq_map[char] += 1  endend letter_frequency(ARGF).sort.each do |letter, frequency|  puts strvendfunc letter_frequency(File file) {    file.read.chars.grep{.match(/[[:alpha:]]/)} \        .group_by {|letter| letter.downcase}    \        .map_val  {|_, val| val.len}            \        .sort_by  {|_, val| -val}} var top = letter_frequency(File(__FILE__))top.each{|pair| say strv}"
"left_fact = Enumerator.new do |y|  n, f, lf = 0, 1, 0  loop do    y  << lf #yield left_factorial    n  += 1    lf += f    f  *= n  endendleft_fact = Enumerator.new do |y|  f, lf = 1, 0  1.step do |n|    y  << lf #yield left_factorial    lf += f    f  *= n  endendtens = 20.step(110, 10)thousands = 1000.step(10_000, 1000) 10001.times do |n|  lf = left_fact.next  case n  when 0..10, *tens    puts strv  when *thousands    puts strv  endendfunc left_fact(k) {    ^k -> map {|n| n! } -> sum(0)}func left_fact(k) {    ^k -> reduce { |a,b| a + b! } + 1}func left_fact(n) {    static cached    = 0    static factorial = 1    static leftfact  = 0     if (n < cached) {        cached    = 0        factorial = 1        leftfact  = 0    }     while (n > cached) {        leftfact  += factorial        factorial *= ++cached    }     leftfact}for r in [range(0, 10), range(20, 110).by(10)] {    for i in r {        printf(""!%d  = %s"", i, left_fact(i));    }} for i in range(1000, 10000).by(1000) {    printf(""!%d has %d digits."", i, left_fact(i).len);}"
"class LastL_FirstL  def initialize(names)    @names = names.dup    @first = names.group_by {|name| name[0]}    @sequences = []  end   def add_name(seq)    last_letter = seq[-1][-1]    potentials = @first.include?(last_letter) ? (@first[last_letter] - seq) : []    if potentials.empty?      @sequences << seq    else      potentials.each {|name| add_name(seq + [name])}    end  end   def search    @names.each {|name| add_name [name]}    max = @sequences.max_by {|seq| seq.length}.length    max_seqs = @sequences.select {|seq| seq.length == max}    puts ""there are } possible sequences""    puts strv    puts strv    max_seqs.last.each_with_index {|name, idx| puts strv % [idx+1, name]}  endend names = %w{  audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon  cresselia croagunk darmanitan deino emboar emolga exeggcute gabite  girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan  kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine  nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2  porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking  sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko  tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask} lf = LastL_FirstL.new(names)lf.search"
require 'date' Date.leap?(year)func isleap(year) {    if (year %% 100) {        return (year %% 400);    }    return (year %% 4);}func isleap(year) { year %% 100 ? (year %% 400) : (year %% 4) };
"irb(main):001:0> 12.lcm 18=> 36def gcd(m, n)  m, n = n, m % n until n.zero?  m.absend def lcm(*args)  args.inject(1) do |m, n|    return 0 if n.zero?    (m * n).abs / gcd(m, n)  endend p lcm 12, 18, 22p lcm 15, 14, -6, 10, 21say Math.lcm(1001, 221)func gcd(a, b) {    while (a) { (a, b) = (b % a, a) }    return b} func lcm(a, b) {    (a && b) ? (a / gcd(a, b) * b) : 0} say lcm(1001, 221)"
"def s_of_n_creator(n)  sample = []  i = 0  Proc.new do |item|    i += 1    if i <= n      sample << item    elsif rand(i) < n      sample[rand(n)] = item    end    sample  endend frequency = Array.new(10,0)100_000.times do  s_of_n = s_of_n_creator(3)  sample = nil  (0..9).each {|digit| sample = s_of_n[digit]}  sample.each {|digit| frequency[digit] += 1}end (0..9).each {|digit| puts ""#{digit}#{frequency[digit]}""}func s_of_n_creator(n) {    var i = 0    var sample = []    { |item|        if (++i <= n) {            sample << item;        }        elsif (i.rand < n) {            sample[n.rand] = item;        }        sample;    }} var items = 0..9;var bin = []; 100000.times {    var s_of_n = s_of_n_creator(3);    var sample = []    for item in items {        sample = s_of_n(item);    }    for s in sample {        bin[s] := 0 ++;    }} say bin;"
"require 'date' def last_friday(year, month)  
  d = Date.new(year, month, -1)  d -= (d.wday - 5) % 7  
end year = Integer(ARGV.shift)(1..12).each {|month| puts last_friday(year, month)}require 'date' def last_friday(year, month)  d = Date.new(year, month, -1)  d = d.prev_day until d.friday?  dend require('DateTime');var (year=2015) = ARGV»to_i»()...; range(1, 12).each { |month|   var dt = %s'DateTime'.last_day_of_month(year => year, month => month);   while (dt.day_of_week != 5) {      dt.subtract(days => 1);   };   say dt.ymd;}"
"class Ant   class OutOfBoundsException < StandardError; end   class Plane    def initialize(x, y)      @size_x, @size_y = x, y      @cells = Array.new(y) {Array.new(x, :white)}    end     def white?(px, py)      @cells[py][px] == :white    end     def toggle_colour(px, py)      @cells[py][px] = (white?(px, py) ? :black : :white)    end     def check_bounds(px, py)      unless (0 <= px and px < @size_x) and (0 <= py and py < @size_y)        raise OutOfBoundsException, ""(_x, _y)""      end    end     def to_s      @cells.collect {|row|        row.collect {|cell| cell == :white ? strv : strv}.join + """"      }.join    end  end   dir_move = [[:north, [0,-1]], [:east, [1,0]], [:south, [0,1]], [:west, [-1,0]]]  Move = Hash[dir_move]  directions = dir_move.map{|dir, move| dir}       
  Right = Hash[ directions.zip(directions.rotate).to_a ]  Left  = Right.invert   def initialize(size_x, size_y, pos_x=size_x/2, pos_y=size_y/2)    @plane = Plane.new(size_x, size_y)    @pos_x, @pos_y = pos_x, pos_y    @direction = :south    @plane.check_bounds(@pos_x, @pos_y)  end   def run    moves = 0    loop do      begin        moves += 1        move      rescue OutOfBoundsException        break      end    end    moves  end   def move    @plane.toggle_colour(@pos_x, @pos_y)    advance    if @plane.white?(@pos_x, @pos_y)      @direction = Right[@direction]    else      @direction = Left[@direction]    end  end   def advance    dx, dy = Move[@direction]    @pos_x += dx    @pos_y += dy    @plane.check_bounds(@pos_x, @pos_y)  end   def position    ""(_x, _y)""  end   def to_s    @plane.to_s  endend #
#ant = Ant.new(100, 100)moves = ant.runputs strvputs antclass Ant  MOVE = [[1,0], [0,1], [-1,0], [0,-1]]   
   def initialize(size_x, size_y, pos_x=size_x/2, pos_y=size_y/2)    @plane = Array.new(size_y) {Array.new(size_x, true)}  
    @sx, @sy = size_x, size_y    @px, @py = pos_x, pos_y       
    @direction = 0                
    @moves = 0    move  while (0 <= @px and @px < @sx) and (0 <= @py and @py < @sy)  end   def move    @moves += 1    @direction = (@plane[@py][@px] ? @direction+1 : @direction-1) % 4    @plane[@py][@px] = [@py][@px]    @px += MOVE[@direction][0]    @py += MOVE[@direction][1]  end   def to_s    [""out of bounds after } moves: (, )""] +      (0...@sy).map {|y| (0...@sx).map {|x| @plane[y][x] ? strv : strv}.join}  endend puts Ant.new(100, 100).to_sdefine dirs = [[1,0], [0,-1], [-1,0], [0,1]]define size = 100 enum |White, Black|var plane = size.of { size.of (White) } var (x, y) = @|([size/2 -> int]*2)var dir = dirs.len.irand var moves = 0loop {    (x >= 0) && (y >= 0) && (x < size) && (y < size) || break     given(plane[x][y]) {        when (White) { dir--; plane[x][y] = Black }        when (Black) { dir++; plane[x][y] = White }    }     ++moves    [\x, \y]:dirs[dir %= dirs.len] -> each {|a,b| *a += b }} say strvplane.map{.map {|square| square == Black ? '#' : '.' }}.each{.join.say}"
"class Array  def knuth_shuffle!    j = length    i = 0    while j > 1      r = i + rand(j)      self[i], self[r] = self[r], self[i]      i += 1      j -= 1    end    self  endend r = Hash.new(0)100_000.times do |i|  a = [1,2,3].knuth_shuffle!  r[a] += 1end r.keys.sort.each {|a| puts strv}class Array  def knuth_shuffle!    (length - 1).downto(1) do |i|      j = rand(i + 1)      self[i], self[j] = self[j], self[i]    end    self  endendfunc shuffle(a) {     { |n|        var k = (n+1 -> irand);        k == n || (a[k, n] = a[n, k]);    } * a.end;     return a;} say shuffle(@(1..10));"
"def icsort nums  nums.sort { |x, y| strv <=> strv }end [[54, 546, 548, 60], [1, 34, 3, 98, 9, 76, 45, 4]].each do |c|  p c 
  puts icsort(c).joinenddef icsort nums  maxlen = nums.max.to_s.length  nums.map{ |x| x.to_s }.sort_by { |x| x * (maxlen * 2 / x.length) }.reverseend [[54, 546, 548, 60], [1, 34, 3, 98, 9, 76, 45, 4]].each do |c|  p c 
  puts icsort(c).joinendrequire 'rational' #Only needed in Ruby < 1.9 def icsort nums  nums.sort_by { |i| Rational(i, 10**(Math.log10(i).to_i+1)-1) }.reverseend [[54, 546, 548, 60], [1, 34, 3, 98, 9, 76, 45, 4]].each do |c|  p c 
  puts icsort(c).joinendfunc maxnum(nums) {    nums.sort {|x,y|  strv <=> strv };} [[54, 546, 548, 60], [1, 34, 3, 98, 9, 76, 45, 4]].each { |c|    say maxnum(c).join.to_num;}"
"class Board  Cell = Struct.new(:value, :adj) do    def self.end=(end_val)      @@end = end_val    end     def try(seq_num)      self.value = seq_num      return true  if seq_num==@@end      a = []      adj.each_with_index do |cell, n|        a << [wdof(cell.adj)*10+n, cell]  if cell.value.zero?      end      a.sort.each {|_, cell| return true  if cell.try(seq_num+1)}      self.value = 0      false    end     def wdof(adj)      adj.count {|cell| cell.value.zero?}    end  end   def initialize(rows, cols)    @rows, @cols = rows, cols    unless defined? ADJACENT                      
      eval(strv)    end    frame = ADJACENT.flatten.map(&:abs).max    @board = Array.new(rows+frame) do |i|      Array.new(cols+frame) do |j|        (i<rows and j<cols) ? Cell.new(0) : nil   
      end    end    rows.times do |i|      cols.times do |j|        @board[i][j].adj = ADJACENT.map{|di,dj| @board[i+di][j+dj]}.compact      end    end    Cell.end = rows * cols    @format = strv  end   def solve(sx, sy)    if (@rows*@cols).odd? and (sx+sy).odd?      puts strv    else      puts (@board[sx][sy].try(1) ? to_s : strv)    end  end   def to_s    (0...@rows).map do |x|      (0...@cols).map{|y| @format % @board[x][y].value}.join    end  endend def knight_tour(rows=8, cols=rows, sx=rand(rows), sy=rand(cols))  puts ""Board (%d x %d), Start:[%d, %d]"" % [rows, cols, sx, sy]  Board.new(rows, cols).solve(sx, sy)end knight_tour(8,8,3,1) knight_tour(5,5,2,2) knight_tour(4,9,0,0) knight_tour(5,5,0,1) knight_tour(12,12,1,1)var board = []var I = 8var J = 8var F = (I*J > 99 ? '%3d' : '%2d') var (i, j) = (I.irand, J.irand) func from_algebraic(square) {     if (var match = square.match(/^([a-z])([0-9])\z/)) {         return(I - Num(match[1]), match[0].ord - 'a'.ord)     }     die strv} func possible_moves(i,j) {    gather {        for ni,nj in [            [i-2,j-1], [i-2,j+1], [i-1,j-2], [i-1,j+2],            [i+1,j-2], [i+1,j+2], [i+2,j-1], [i+2,j+1],        ] {            if ((ni ~~ ^I) && (nj ~~ ^J) && !board[ni][nj]) {                take([ni, nj])            }        }    }} func to_algebraic(i,j) {    ('a'.ord + j).chr + Str(I - i)} if (ARGV[0]) {    (i, j) = from_algebraic(ARGV[0])} var moves = []for move in (1 .. I*J) {    moves << to_algebraic(i, j)    board[i][j] = move    var min = [9]    for target in possible_moves(i, j) {        var (ni, nj) = target...        var nxt = possible_moves(ni, nj).len        if (nxt < min[0]) {            min = [nxt, ni, nj]        }    }     (i, j) = min[1,2]} say (moves/4 -> map { .join(', ') }.join("""") + """") for i in ^I {    for j in ^J {        (i%2 == j%2) && print ""[7m""        F.printf(board[i][j])        print ""[0m""    }    print """"}"
"KnapsackItem = Struct.new(:volume, :weight, :value)panacea = KnapsackItem.new(0.025, 0.3, 3000)ichor   = KnapsackItem.new(0.015, 0.2, 1800)gold    = KnapsackItem.new(0.002, 2.0, 2500)maximum = KnapsackItem.new(0.25,  25,  0) max_items = {}for item in [panacea, ichor, gold]  max_items[item] = [(maximum.volume/item.volume).to_i, (maximum.weight/item.weight).to_i].minend maxval = 0solutions = [] 0.upto(max_items[ichor]) do |i|  0.upto(max_items[panacea]) do |p|    0.upto(max_items[gold]) do |g|      break if i*ichor.weight + p*panacea.weight + g*gold.weight > maximum.weight      break if i*ichor.volume + p*panacea.volume + g*gold.volume > maximum.volume      val = i*ichor.value + p*panacea.value + g*gold.value      if val > maxval        maxval = val        solutions = [[i, p, g]]      elsif val == maxval        solutions << [i, p, g]      end    end  endend puts strvsolutions.each do |i, p, g|  printf ""  ichor=%2d, panacea=%2d, gold=%2d -- weight:%.1f, volume=%.3f"",    i, p, g,    i*ichor.weight + p*panacea.weight + g*gold.weight,    i*ichor.volume + p*panacea.volume + g*gold.volume endstruct KnapsackItem {    Number volume,    Number weight,    Number value,    String name,} var items = [    KnapsackItem(25,  3, 3000, strv)    KnapsackItem(15,  2, 1800, strv  )    KnapsackItem( 2, 20, 2500, strv   )] var (    max_weight = 250,    max_vol = 250,    vsc = 1000,    wsc = 10) func solve(i, w, v) is cached {    return [0, []] if i.is_neg;     var x = solve(i.dec, w, v);     var (w1, v1);    Inf.times { |t|        var item = items[i];        break if ((w1 = (w - t*item.weight)).is_neg)        break if ((v1 = (v - t*item.volume)).is_neg)         var y = solve(i.dec, w1, v1);        if ((var tmp = (y[0] + t*item.value)) > x[0]) {            x = [tmp, [y[1]..., [i, t]]];        }    }     return x} var x = solve(items.end, max_weight, max_vol) print <<strvMax value #{x[0]}, with:    Item        Qty     Weight   Vol    Value#{strv * 50}EOT var (wtot=0, vtot=0);x[1].each { |s|    var item = items[s[0]];    ""    #{item.name}:% 3d  % 8d% 8g% 8d"".printf(        s[1],        item.weight * s[1] / wsc,        item.volume * s[1] / vsc,        item.value  * s[1]    );    wtot += (item.weight * s[1]);    vtot += (item.volume * s[1]);} print <<strv#{strv * 50}    Total:\t     #{strv % (wtot/wsc, vtot/vsc, x[0])}EOT"
"Shoes.app do  @info = para strv  keypress do |k|    @info.replace strv  endendShoes.app do  keypress do |key|    case key    when ""04""  
      delete_char    when :backspace      delete_previous_char    when ""14""  
      transpose_chars    when :alt_t      transpose_words    when ""18""  
      @ctrl_x = true    when ""13""  
      if @ctrl_x        save_text         @ctrl_x = false        end    when ""11""  
      exit if @ctrl_x    end  endend"
"items = [ [:beef   , 3.8, 36],          [:pork   , 5.4, 43],          [:ham    , 3.6, 90],          [:greaves, 2.4, 45],          [:flitch , 4.0, 30],          [:brawn  , 2.5, 56],          [:welt   , 3.7, 67],          [:salami , 3.0, 95],          [:sausage, 5.9, 98] ].sort_by{|item, weight, price| -price / weight}maxW, value = 15.0, 0items.each do |item, weight, price|  if (maxW -= weight) > 0    puts strv    value += price  else    puts strv % [t=weight+maxW, item], strv,         strv % (value+(price/weight)*t)    break  endendvar items =[        [:beef,    3.8, 36],        [:pork,    5.4, 43],        [:ham,     3.6, 90],        [:greaves, 2.4, 45],        [:flitch,  4.0, 30],        [:brawn,   2.5, 56],        [:welt,    3.7, 67],        [:salami,  3.0, 95],        [:sausage, 5.9, 98],].sort {|a,b| b[2]/b[1] <=> a[2]/a[1] } var (limit, value) = (15, 0);print ""Item   Fraction Weight Value""; items.each { |item|    var ratio = (item[1] > limit ? limit/item[1] : 1);    value += item[2]*ratio;    limit -= item[1];    if (ratio == 1) {        printf(""%-8s %4s %7.2f %6.2f"", item[0], 'all', item[1], item[2]);    }    else {        printf(""%-8s %-4.2f %7.2f %6.2f"", item[0], ratio, item[1]*ratio, item[2]*ratio);        break;    }} say ""#{'-'*28}total value: #{'%.14g' % value }"""
 begin  check = STDIN.read_nonblock(1)rescue IO::WaitReadable  check = falseend puts check if check 
" def yesno  begin    system(strv)    str = STDIN.getc  ensure    system(strv)  end  if str == strv    return true  elsif str == strv    return false  else    raise strv  endend  require 'io/console' def yesno  case $stdin.getch    when strv then true    when strv then false    else raise strv  endend func prompt_yn {    static rk = frequire('Term::ReadKey');    rk.ReadMode(4);     
     var key = '';    while (key !~ /[yn]/i) {        while (rk.ReadKey(-1) != nil) {};   
        print strv;        say (key = rk.ReadKey(0));          
    }     rk.ReadMode(0);     
    return key.uc;} var key = prompt_yn();say strv;"
"require 'io/console'$stdin.iflushloop { $stdin.read_nonblock(256) } rescue nilclass IO  def discard_input    icanon = false    if tty?      begin        
        require 'io/console'        return iflush      rescue LoadError        
        
        
        r, w, pid = nil        begin          r, w = IO.pipe          pid = fork do            IO.for_fd(0).reopen(self)  
            IO.for_fd(1).reopen(w)     
            exec 'stty', '-a'          end          w.close; w = nil          icanon = (not r.read.include? strv)        rescue          
        ensure          pid and Process.wait pid          w and w.close          r and r.close        end      end    end     if icanon      
      pid = nil      begin        pid = fork do          IO.for_fd(0).reopen(self)  
          exec 'stty', '-icanon'        end      ensure        pid and Process.wait pid      end    end     
    loop { $stdin.read_nonblock(256) } rescue nil     if icanon      
      pid = nil      begin        pid = fork do          IO.for_fd(0).reopen(self)  
          exec 'stty', 'icanon'        end      ensure        pid and Process.wait pid      end    end     nil  endend
puts 'Type anything for 2 seconds.'sleep 2$stdin.discard_inputprint 'Enter a line? 'if line = $stdin.getsthen print 'Got line. ', lineelse puts 'No line!'endvar k = frequire('Term::ReadKey'); k.ReadMode('restore');    

 

 k.ReadMode('cbreak'); 
while (k.ReadKey(-1) != nil) {   
} 
k.ReadMode('restore');"
" 
Struct.new('Item', :name, :weight, :value, :count) $items = [  Struct::Item.new('map', 9, 150, 1),  Struct::Item.new('compass', 13, 35, 1),  Struct::Item.new('water', 153, 200, 3),  Struct::Item.new('sandwich', 50, 60, 2),  Struct::Item.new('glucose', 15, 60, 2),  Struct::Item.new('tin', 68, 45, 3),  Struct::Item.new('banana', 27, 60, 3),  Struct::Item.new('apple', 39, 40, 3),  Struct::Item.new('cheese', 23, 30, 1),  Struct::Item.new('beer', 52, 10, 3),  Struct::Item.new('suntan cream', 11, 70, 1),  Struct::Item.new('camera', 32, 30, 1),  Struct::Item.new('t-shirt', 24, 15, 2),  Struct::Item.new('trousers', 48, 10, 2),  Struct::Item.new('umbrella', 73, 40, 1),  Struct::Item.new('w-trousers', 42, 70, 1),  Struct::Item.new('w-overcoat', 43, 75, 1),  Struct::Item.new('note-case', 22, 80, 1),  Struct::Item.new('sunglasses', 7, 20, 1),  Struct::Item.new('towel', 18, 12, 2),  Struct::Item.new('socks', 4, 50, 1),  Struct::Item.new('book', 30, 10, 2)] def choose_item(weight, id, cache)  return 0, [] if id < 0   k = [weight, id]  return cache[k] unless cache[k].nil?  value = $items[id].value  best_v = 0  best_list = []  ($items[id].count+1).times do |i|    wlim = weight - i * $items[id].weight    break if wlim < 0    val, taken = choose_item(wlim, id - 1, cache)    if val + i * value > best_v      best_v = val + i * value      best_list = taken + [i]    end  end  cache[k] = [best_v, best_list]  return [best_v, best_list]end val, list = choose_item(400, $items.length - 1, {})w = 0list.each_with_index do |cnt, i|  if cnt > 0    print ""#{cnt} #{$items[i].name}""    w += $items[i][1] * cnt  endend p strv var raw = <<'TABLE'map           9     150      1compass      13      35      1water       153     200      2sandwich     50      60      2glucose      15      60      2tin          68      45      3banana       27      60      3apple        39      40      3cheese       23      30      1beer         52      10      1suntancream  11      70      1camera       32      30      1T-shirt      24      15      2trousers     48      10      2umbrella     73      40      1w_trousers   42      70      1w_overcoat   43      75      1note-case    22      80      1sunglasses    7      20      1towel        18      12      2socks         4      50      1book         30      10      2TABLE struct KnapsackItem {    String name,    Number weight,    Number value,    Number quant,} var items = []raw.each_line{ |row|    var fields = row.words;    items << KnapsackItem(          name: fields[0],        weight: fields[1].to_n,         value: fields[2].to_n,         quant: fields[3].to_n,    )} func pick(weight, pos) is cached {     if (pos.is_neg || weight.is_neg || weight.is_zero) {        return (0, 0, [])    }     var (bv=0, bi=0, bw=0, bp=[])    var item = items[pos];     for i in range(0, item.quant) {        break if (i*item.weight > weight)        var (v, w, p) = pick(weight - i*item.weight, pos.dec)        next if ((v += i*item.value) <= bv)        (bv, bi, bw, bp) = (v, i, w, p)    }     (bv, bw + bi*item.weight, [bp..., bi])} var (v, w, p) = pick(400, items.end)p.range.each { |i|    say strv if p[i].is_pos}say strv"
"require 'continuation' unless defined? Continuation if a = callcc { |c| [c, 1] }  c, i = a  c[nil] if i > 100   case 0  when i % 3    print strv    case 0    when i % 5      print strv    end  when i % 5    print strv  else    print i  end   puts  c[c, i + 1]end"
"def kaprekar(n, base = 10)  return [1, 1, 1, strv] if n == 1   return if n*(n-1) % (base-1) != 0     
  sqr = (n ** 2).to_s(base)  (1...sqr.length).each do |i|    a = sqr[0 ... i]    b = sqr[i .. -1]    break if b.delete(strv).empty?    sum = a.to_i(base) + b.to_i(base)    return n.to_s(base), sqr, a, b if sum == n  end  nilend count = 01.upto(10_000 - 1) do |i|   if result = kaprekar(i)    puts strv % result    count += 1  endend 10_000.upto(1_000_000 - 1) {|i| count += 1 if kaprekar(i)}puts strv puts ""base17 kaprekar numbers under (base10)1,000,000""base = 171.upto(1_000_000) do |decimal|  if result = kaprekar(decimal, base)    puts strv % [decimal, *result]  endendrequire('ntheory')var kap = Hash() 15.times { |n|    var np = (10**n - 1)    %S<ntheory>.fordivisors({ |d|        var dp = np//d        if (gcd(d, dp) == 1) {            kap{ dp == 1 ? d : d.invmod(dp)*d } := 0 ++        }    }, np)} var nums = kap.keys.map{.to_n}.sort for n in (6 .. 14) {    var np = (10**n - 1)    printf(""Kaprekar numbers <= 10^%2d:  %5d"", n, nums.count_by { .<= np })}"
"KnapsackItem = Struct.new(:name, :weight, :value)potential_items = [  KnapsackItem['map', 9, 150],              KnapsackItem['compass', 13, 35],  KnapsackItem['water', 153, 200],          KnapsackItem['sandwich', 50, 160],  KnapsackItem['glucose', 15, 60],          KnapsackItem['tin', 68, 45],  KnapsackItem['banana', 27, 60],           KnapsackItem['apple', 39, 40],  KnapsackItem['cheese', 23, 30],           KnapsackItem['beer', 52, 10],  KnapsackItem['suntan cream', 11, 70],     KnapsackItem['camera', 32, 30],  KnapsackItem['t-shirt', 24, 15],          KnapsackItem['trousers', 48, 10],  KnapsackItem['umbrella', 73, 40],         KnapsackItem['waterproof trousers', 42, 70],  KnapsackItem['waterproof overclothes', 43, 75], KnapsackItem['note-case', 22, 80],  KnapsackItem['sunglasses', 7, 20],        KnapsackItem['towel', 18, 12],  KnapsackItem['socks', 4, 50],             KnapsackItem['book', 30, 10],]knapsack_capacity = 400 class Array  
  def power_set    yield [] if block_given?    self.inject([[]]) do |ps, elem|      ps.each_with_object([]) do |i,r|        r << i        new_subset = i + [elem]        yield new_subset if block_given?        r << new_subset      end    end  endend maxval, solutions = potential_items.power_set.group_by {|subset|  weight = subset.inject(0) {|w, elem| w + elem.weight}  weight>knapsack_capacity ? 0 : subset.inject(0){|v, elem| v + elem.value}}.max puts strvsolutions.each do |set|  wt, items = 0, []  set.each {|elem| wt += elem.weight; items << elem.name}  puts strv  puts strvendKnapsackItem = Struct.new(:name, :weight, :value) def dynamic_programming_knapsack(items, max_weight)  num_items = items.size  cost_matrix = Array.new(num_items){Array.new(max_weight+1, 0)}   num_items.times do |i|    (max_weight + 1).times do |j|      if(items[i].weight > j)        cost_matrix[i][j] = cost_matrix[i-1][j]      else        cost_matrix[i][j] = [cost_matrix[i-1][j], items[i].value + cost_matrix[i-1][j-items[i].weight]].max      end    end  end  used_items = get_used_items(items, cost_matrix)  [get_list_of_used_items_names(items, used_items),                     
   items.zip(used_items).map{|item,used| item.weight*used}.inject(:+),  
   cost_matrix.last.last]                                               
end def get_used_items(items, cost_matrix)  i = cost_matrix.size - 1  currentCost = cost_matrix[0].size - 1  marked = cost_matrix.map{0}   while(i >= 0 && currentCost >= 0)    if(i == 0 && cost_matrix[i][currentCost] > 0 ) || (cost_matrix[i][currentCost] != cost_matrix[i-1][currentCost])      marked[i] = 1      currentCost -= items[i].weight    end    i -= 1  end  markedend def get_list_of_used_items_names(items, used_items)  items.zip(used_items).map{|item,used| item.name if used>0}.compact.join(', ')end if $0 == __FILE__  items = [    KnapsackItem['map'                   ,   9, 150], KnapsackItem['compass'            , 13,  35],    KnapsackItem['water'                 , 153, 200], KnapsackItem['sandwich'           , 50, 160],    KnapsackItem['glucose'               ,  15,  60], KnapsackItem['tin'                , 68,  45],    KnapsackItem['banana'                ,  27,  60], KnapsackItem['apple'              , 39,  40],    KnapsackItem['cheese'                ,  23,  30], KnapsackItem['beer'               , 52,  10],    KnapsackItem['suntan cream'          ,  11,  70], KnapsackItem['camera'             , 32,  30],    KnapsackItem['t-shirt'               ,  24,  15], KnapsackItem['trousers'           , 48,  10],    KnapsackItem['umbrella'              ,  73,  40], KnapsackItem['waterproof trousers', 42,  70],    KnapsackItem['waterproof overclothes',  43,  75], KnapsackItem['note-case'          , 22,  80],    KnapsackItem['sunglasses'            ,   7,  20], KnapsackItem['towel'              , 18,  12],    KnapsackItem['socks'                 ,   4,  50], KnapsackItem['book'               , 30,  10]  ]   names, weight, value = dynamic_programming_knapsack(items, 400)  puts  puts 'Dynamic Programming:'  puts  puts strv  puts strv  puts strvendvar raw = <<'TABLE'map,                      9, 150compass,                 13,  35water,                  153, 200sandwich,                50, 160glucose,                 15,  60tin,                     68,  45banana,                  27,  60apple,                   39,  40cheese,                  23,  30beer,                    52,  10suntancream,             11,  70camera,                  32,  30T-shirt,                 24,  15trousers,                48,  10umbrella,                73,  40waterproof trousers,     42,  70waterproof overclothes,  43,  75note-case,               22,  80sunglasses,               7,  20towel,                   18,  12socks,                    4,  50book,                    30,  10TABLE struct KnapsackItem {    String name,    Number weight,    Number value,} var items = []raw.each_line{ |row|    var fields = row.split(/\s*,\s*/)    items << KnapsackItem(          name: fields[0],        weight: fields[1].to_n,         value: fields[2].to_n,    )} var max_weight = 400var p = [    items.len.of { [[0, []], max_weight.of(nil)...] }...,    max_weight.inc.of {[0, []]}] func optimal(i, w) {    if (!defined p[i][w]) {        var item = items[i];        if (item.weight > w) {            p[i][w] = optimal(i.dec, w)        }        else {            var x = optimal(i.dec, w)            var y = optimal(i.dec, w - item.weight)             if (x[0] > (y[0] + item.value)) {                p[i][w] = x;            }            else {                p[i][w] = [y[0] + item.value, [y[1]..., item.name]]            }        }    }    return p[i][w]} var sol = optimal(items.end, max_weight)say strv"
"def julia(c_real, c_imag)  puts Complex(c_real, c_imag)  -1.0.step(1.0, 0.04) do |v|    puts -1.4.step(1.4, 0.02).map{|h| judge(c_real, c_imag, h, v)}.join  endend def judge(c_real, c_imag, x, y)  50.times do    z_real = (x * x - y * y) + c_real    z_imag = x * y * 2 + c_imag    return strv  if z_real**2 > 10000    x, y = z_real, z_imag  end  strvend julia(-0.8, 0.156)require('Imager') var (w, h) = (640, 480)var img = %s'Imager'.new(xsize => w, ysize => h, channels => 3) var maxIter = 50var c = Complex(-0.388, 0.613) var color = %s'Imager::Color'.new('#000000') for x,y in (^w ~X ^h) {    var i = maxIter    var z = Complex((x - w/2) / w * 3, (y - h/2) / h * 2)    while (z.abs < 2 && --i) {        z = (z*z + c)    }    color.set(hsv => [i / maxIter * 360, 1, i])    img.setpixel(x => x, y => y, color => color)} img.write(file => strv)var (w, h) = (141, 50) var maxIter = 40var c = Complex(-0.8, 0.156) for y in ^h {    for x in ^w {        var i = maxIter        var z = Complex(3 * (x - w/2) / w, 2 * (y - h/2) / h)        while (z.abs < 2 && --i) {            z = (z*z + c)        }        print (i > 0 ? ' ' : '#')    }    print """"}"
"def jort_sort(array)  array == array.sortenddef jort_sort(array)  
  original_array = array.dup  array.sort!   
  original_array.length.times do |i|    return false if original_array[i] != array[i]  end   trueendfunc jort_sort(array) { array == array.sort };"
"def sum(var, lo, hi, term, context)  sum = 0.0  lo.upto(hi) do |n|    sum += eval strv, context  end  sumendp sum strv, 1, 100, strv, binding   
def sum2(lo, hi)  lo.upto(hi).inject(0.0) {|sum, n| sum += yield n}endp sum2(1, 100) {|i| 1.0/i}  
 def sum lo, hi, &term    (lo..hi).map(&term).reduce(:+)endp sum(1,100){|i|1.0/i}   

p sum(1,100){|i|Rational(1)/i}  
 var i;func sum (i, lo, hi, term) {    var temp = 0;    for (*i = lo; *i <= hi; (*i)++) {        temp += term.run;    };    return temp;};say sum(\i, 1, 100, { 1 / i });"
"def jaro(s, t)    return 1.0 if s == t     s_len = s.size    t_len = t.size    match_distance = ([s_len, t_len].max / 2) - 1     s_matches = []    t_matches = []    matches = 0.0     s_len.times do |i|        j_start = [0, i-match_distance].max        j_end = [i+match_distance, t_len-1].min         (j_start..j_end).each do |j|            t_matches[j] && next            s[i] == t[j] || next            s_matches[i] = true            t_matches[j] = true            matches += 1.0            break        end    end     return 0.0 if matches == 0.0     k = 0    transpositions = 0.0    s_len.times do |i|        s_matches[i] || next        k += 1 until t_matches[k]        s[i] == t[k] || (transpositions += 1.0)        k += 1    end     ((matches / s_len) +     (matches / t_len) +     ((matches - transpositions/2.0) / matches)) / 3.0end %w(    MARTHA    MARHTA    DIXON     DICKSONX    JELLYFISH SMELLYFISH).each_slice(2) do |s,t|    puts strvendfunc jaro(s, t) {     return 1 if (s == t)     var s_len = s.len    var t_len = t.len     var match_distance = ((::max(s_len, t_len) // 2) - 1)     var s_matches = []    var t_matches = []     var matches = 0    var transpositions = 0     for i in ^s_len {        var start = ::max(0, i-match_distance)        var end = ::min(i+match_distance, t_len-1)         for k in (start .. end) {            t_matches[k] && next            s[i] == t[k] || next            s_matches[i] = true            t_matches[k] = true            matches++            break        }    }     return 0 if (matches == 0)     var k = 0    for i in ^s_len {        s_matches[i] || next        while (!t_matches[k]) { ++k }        s[i] == t[k] || ++transpositions        ++k    }     ((matches / s_len) +      (matches / t_len) +        ((matches - transpositions/2) / matches)) / 3} for pair in [    [%cstrv,    %cstrv],    [%cstrv,     %cstrv],    [%cstrv, %cstrv],] {    say strv}"
"def main  n = (ARGV[0] || 41).to_i  k = (ARGV[1] || 3).to_i  puts josephus(n,k)end def josephus(n, k)  prisoners = (0...n).to_a  prisoners.rotate!(k-1).shift  while prisoners.length > 1  return prisoners.firstend mainfunc josephus(n, k) {    var prisoners = @^n    while (prisoners.len > 1) {        prisoners.rotate!(k - 1).shift    }    return prisoners[0]}func josephus(n, k) {    n == 1 ? 0 : ((__FUNC__(n-1, k) + k) % n)};var survivor = josephus(41, 3);say strv;"
"require 'socket' 
system '/bin/sh', '-c', <<EOF or aborttest -p in || mkfifo in || exittest -p out || mkfifo out || exitEOF 

def open_sesame(path, mode)  reader, writer = UNIXSocket.pair  pid = fork do    begin      reader.close      file = File.open(path, mode)      writer.send_io file    ensure      exit!    end  end  Process.detach pid  writer.close  return readerend insock = open_sesame(strv, strv)outsock = open_sesame(strv, strv)inpipe, outpipe = nilcount = 0readers = [insock, outsock]writers = []loop do  selection = select(readers, writers)  selection[0].each do |reader|    case reader    when insock      inpipe = insock.recv_io      puts strv      insock.close      readers.delete insock      readers.push inpipe    when outsock      outpipe = outsock.recv_io      puts strv      outsock.close      readers.delete outsock      writers.push outpipe    when inpipe      count += (inpipe.read_nonblock(4096).size rescue 0)    end  end  selection[1].each do |writer|    case writer    when outpipe      outpipe.puts count      puts strv      exit    end  endend"
"require 'json' ruby_obj = JSON.parse('{strv}')puts ruby_obj ruby_obj[strv] = { strv => [strv, strv] }puts JSON.generate(ruby_obj)puts JSON.pretty_generate(ruby_obj)var json = require('JSON').new;var data = json.decode('{strv}');say data;data{:ocean} = Hash.new(water => %w[fishy salty]);say json.encode(data);"
" from itertools import combinations_with_replacementfrom array import arrayfrom time import clockD = 8F = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000]def b(n):    yield 1    for g in range(1,n+1):        gn = g        res = 0        while gn > 0:            gn,rem = divmod(gn,10)            res += rem**2        if res==89:            yield 0        else:            yield resN = array('I',b(81*D))for n in range(2,len(N)):    q = N[n]    while q>1:        q = N[q]    N[n] = q es = clock()z = 0for n in combinations_with_replacement(range(10),D):    t = 0    for g in n:        t += g*g    if N[t] == 0:        continue    t = [0,0,0,0,0,0,0,0,0,0]    for g in n:        t[g] += 1    t1 = F[D]    for g in t:        t1 /= F[g]    z += t1ee = clock() - esprint ""D=="" + str(D) + ""  "" + str(z) + strv + str(10**D-z) + strvprint strv + str(ee) + strv 
def iterated_square_digit(d)  f = Array.new(d+1){|n| (1..n).inject(1, :*)}      #Some small factorials  g = -> (n) { res = 0               while n>0                 n, mod = n.divmod(10)                 res += mod**2               end               res==89 ? 0 : res             }   #An array: table[n]==0 means that n translates to 89 and 1 means that n translates to 1  table = Array.new(d*81+1){|n| n.zero? ? 1 : (i=g.call(n))==89 ? 0 : i}  table.collect!{|n| n = table[n] while n>1; n}  z = 0                                             #Running count of numbers translating to 1  [*0..9].repeated_combination(d) do |rc|           #Iterate over unique digit combinations    next if table[rc.inject(0){|g,n| g+n*n}].zero?  #Count only ones    nn = [0] * 10                                   #Determine how many numbers this digit combination corresponds to    rc.each{|n| nn[n] += 1}    z += nn.inject(f[d]){|gn,n| gn / f[n]}          #Add to the count of numbers terminating in 1  end  puts ""d=(#{d}) in the range 1 to #{10**d-1}"",       strvend [8, 11, 14, 17].each do |d|  t0 = Time.now  iterated_square_digit(d)  puts strvend"
"
if n < 0 then raise ArgumentError, strv endraise ArgumentError, strv if n < 0 
unless Process.respond_to? :fork then exit 1 endexit 1 unless Process.respond_to? :fork 
while ary.length > 0 do puts ary.shift endputs ary.shift while ary.length > 0 
until ary.empty? do puts ary.shift endputs ary.shift until ary.empty?
var raining = true;[false]»(\var needumbrella); 
if (raining==true) {needumbrella=true};{needumbrella=true} -> if (raining==true);(needumbrella=true) if (raining==true);"
"if File.exist? strv  @data = Marshal.load open(strv)else  @data = {}end 

class String  def index_sanitize    self.split.collect do |token|      token.downcase.gsub(/\W/, '')    end  endend 
ARGV.each do |filename|  open filename do |file|    file.read.index_sanitize.each do |word|      @data[word] ||= []      @data[word] << filename unless @data[word].include? filename    end  endend open(strv, strv) do |index|  index.write Marshal.dump(@data)endif File.exist? strv  @data = Marshal.load open(strv)else  raise strvend class String  def index_sanitize    self.split.collect do |token|      token.downcase.gsub(/\W/, '')    end  endend 

ARGV.join(' ').index_sanitize.each do |word|  @result ||= @data[word]  @result &= @data[word]end p @result"
"exit if RUBY_VERSION < '1.8.6'puts bloop.abs if defined?(bloop) and bloop.respond_to?(:abs)def variable_counter(b)  int_vars = []  sum = 0  check_var = lambda do |name, value|    if value.is_a?(Integer)      int_vars << name      sum += value    end  end   global_variables.each {|varname| check_var.call(varname, eval(varname.to_s))}  eval('local_variables', b).each {|varname| check_var.call(varname, eval(varname.to_s, b))}   puts strv  puts int_vars.inspect  puts strvend an_int = 5a_string = 'foo'a_float = 3.14 variable_counter(binding)"
"def root(a,b)  return b if b<2  a1, c = a-1, 1  f = -> x {(a1*x+b/(x**a1))/a}  
  d = f[c]  e = f[d]  c, d, e = d, e, f[e] until [d,e].include?(c)  [d,e].minend puts strvputs root(2, 2*100**2000) func root(a, b) {    b < 2 && return(b)    var (a1, c) = (a-1, 1)    var f = {|x| (a1*x + b//(x**a1)) // a }    var d = f(c)    var e = f(d)    while (c !~ [d, e]) {        (c, d, e) = (d, e, f(e))    }    [d, e].min} say strvsay root(2, 2 * 100**2000)"
"$ irbirb(main):001:0> def f(string1, string2, separator)irb(main):002:1>     [string1, '', string2].join(separator)irb(main):003:1> end=> nilirb(main):004:0> f('Rosetta', 'Code', ':')=> strvirb(main):005:0> exit$$ sidef -i>>> func f(s1, s2, sep) { s1 + sep*2 + s2 };f>>> f('Rosetta', 'Code', ':')strv>>> "
"n = gets.to_in.times do  a, b = gets.split.map(&:to_i)  puts a + bend"
1.step{|n| puts n}{|i| say i } * Math.inf;
"2.1.1 :001 > a = 2**62 -1 => 4611686018427387903 2.1.1 :002 > a.class => Fixnum 2.1.1 :003 > (b = a + 1).class => Bignum 2.1.1 :004 > (b-1).class => Fixnum var (a, b, c) = (9223372036854775807, 5000000000000000000, 3037000500);[-(-a - 1), b + b, -a - a, c * c, (-a - 1)/-1].each { say _ };"
def do_stuff(line)  puts lineend n = gets.to_in.times do  line = gets  do_stuff(line)end
"a = (print strv; gets).to_ib = (print strv; gets).to_i puts strv if a < bputs strv if a > bputs strv if a == ba = (print strv; gets).to_ib = (print strv; gets).to_i case a <=> bwhen -1; puts strvwhen  0; puts strvwhen +1; puts strvend
def prompt str  print str, strv  gets.chompend 
a = prompt('Enter value of a').to_i
b = prompt('Enter value of b').to_i 




dispatch = {  -1 => strv,  0 => strv,  1 => strv} 
puts strvvar a = read(strv, Number);var b = read(strv, Number); if (a < b) {    say 'Lower';}elsif (a == b) {    say 'Equal';}elsif (a > b) {    say 'Greater';}"
"def rank(arr)  arr.join('a').to_i(11)end def unrank(n)  n.to_s(11).split('a').collect{|x| x.to_i}end l = [1, 2, 3, 10, 100, 987654321]p ln = rank(l)p nl = unrank(n)p ldef unrank(n)  return [0] if n==1  n.to_s(2)[1..-1].split('0',-1).map(&:size)end def rank(x)  return 0 if x.empty?  ('1' + x.map{ |a| '1'*a }.join('0')).to_i(2)end for x in 0..10  puts strv % [x, a=unrank(x), rank(a)]end putsx = [1, 2, 3, 5, 8]puts strv"
"module Camera  
endclass MobilePhone  
endclass CameraPhone < MobilePhone  include Camera  
endclass Camera {};class MobilePhone {};class CameraPhone << Camera, MobilePhone {};"
class Animal  #functions go here...  def self.inherited(subclass)    puts strv  endend class Dog < Animal  #functions go here...end class Cat < Animal  #functions go here...end class Lab < Dog  #functions go here...end class Collie < Dog  #functions go here...endclass Animal {};class Dog << Animal {};class Cat << Animal {};class Lab << Dog {};class Collie << Dog {};
"stream = $stdinstream.each do |line|  
end
ary = stream.map {|line| line.chomp.length}var file = File(__FILE__)file.open_r(\var fh, \var err) || die strv fh.each { |line|              
    line.each_word { |word|   
        say word    }}"
"a = 1.0/0       
a.finite?       
a.infinite?     
 a = -1/0.0      
a.infinite?     
 a = Float::MAX  
a.finite?       
a.infinite?     
a = Float::INFINITY       
var a = 1.5/0;        
say a.is_inf;         
say a.is_pos;         
 var b = -1.5/0;       
say b.is_inf;         
say b.is_neg;         
 var inf = Math.inf;var ninf = -Math.inf;say (inf == -ninf);   
"
"require 'file'include 'file.sf';include Some::Name;
"
"class Pixmap  
  def convolute(kernel)    newimg = Pixmap.new(@width, @height)    pb = ProgressBar.new(@width) if $DEBUG    @width.times do |x|      @height.times do |y|        apply_kernel(x, y, kernel, newimg)      end      pb.update(x) if $DEBUG    end    pb.close if $DEBUG    newimg  end   
  def apply_kernel(x, y, kernel, newimg)    x0 = x==0 ? 0 : x-1    y0 = y==0 ? 0 : y-1    x1 = x    y1 = y    x2 = x+1  ? x : x+1    y2 = y+1 ? y : y+1     r = g = b = 0.0    [x0, x1, x2].zip(kernel).each do |xx, kcol|      [y0, y1, y2].zip(kcol).each do |yy, k|        r += k * self[xx,yy].r        g += k * self[xx,yy].g        b += k * self[xx,yy].b      end    end    newimg[x,y] = RGBColour.new(luma(r), luma(g), luma(b))  end   
  def luma(value)    if value < 0      0    elsif value > 255      255    else      value    end  endend  
teapot = Pixmap.open('teapot.ppm')[ ['Emboss',  [[-2.0, -1.0, 0.0],  [-1.0, 1.0, 1.0],  [0.0, 1.0, 2.0]]],   ['Sharpen', [[-1.0, -1.0, -1.0], [-1.0, 9.0, -1.0], [-1.0, -1.0, -1.0]]],   ['Blur',    [[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111]]],].each do |label, kernel|  savefile = 'teapot_' + label.downcase + '.ppm'  teapot.convolute(kernel).save(savefile)end"
"require 'rubygems'require 'gl'require 'glut' W, H = 320, 240SIZE = W * H Glut.glutInit ARGVGlut.glutInitWindowSize W, H Glut.glutIdleFunc lambda {  i = Time.now  noise = (1..SIZE).map { rand > 0.5 ? 0xFFFFFFFF : 0xFF000000 }.pack(strv)   Gl.glClear Gl::GL_COLOR_BUFFER_BIT  Gl.glDrawPixels W, H, Gl::GL_RGBA, Gl::GL_UNSIGNED_BYTE, noise  Gl.glFlush   puts 1.0 / (Time.now - i)} Glut.glutCreateWindow strvGlut.glutMainLoop"
'1234'.succ #=> '1235''99'.succ #=> '100'say '1234'.inc;    #=> '1235'say '99'.inc;      #=> '100'
"
pegs = (N = [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1]).inject(:+)G = [[0,1,3],[0,2,5],[1,3,6],[1,4,8],[2,4,7],[2,5,9],[3,4,5],[3,6,10],[3,7,12],[4,7,11],[4,8,13],[5,8,12],[5,9,14],[6,7,8],[7,8,9],[10,11,12],[11,12,13],[12,13,14]]FORMAT = (1..5).map{|i| strv*(5-i)+strv*i+""""}.join+""""def solve n,i,g  return strv if i == 1  return false unless n[g[1]]==1  if n[g[0]] == 0    return false unless n[g[2]]==1    s = ""#{g[2]} to #{g[0]}""  else    return false unless n[g[2]]==0    s = ""#{g[0]} to #{g[2]}""   end  a = n.clone; g.each{|n| a[n] = 1 - a[n]}  l=false; G.each{|g| l=solve(a,i-1,g); break if l}  return l ? s + FORMAT % a + l : lendputs FORMAT % Nl=false; G.each{|g| l=solve(N,pegs,g); break if l}puts l ? l : strvconst N = [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1] const G = [    [ 0, 1, 3],[ 0, 2, 5],[ 1, 3, 6],    [ 1, 4, 8],[ 2, 4, 7],[ 2, 5, 9],    [ 3, 4, 5],[ 3, 6,10],[ 3, 7,12],    [ 4, 7,11],[ 4, 8,13],[ 5, 8,12],    [ 5, 9,14],[ 6, 7, 8],[ 7, 8, 9],    [10,11,12],[11,12,13],[12,13,14],] const format = (5.of {|i| ""#{' '*(5-i)}#{'%d '*i}"" }.join + """") func solve(n, i, g) is cached {    i == N.end && return strv    n[g[1]] == 0 && return nil     var s = given(n[g[0]]) {        when(0) {            n[g[2]] == 0 && return nil            ""#{g[2]} to #{g[0]}""        }        default {            n[g[2]] == 1 && return nil            ""#{g[0]} to #{g[2]}""        }    }     var a = n.clone    g.each {|n| a[n] = 1-a[n] }    var r = ''    G.each {|g| (r = solve(a, i+1, g)) && break }    r ? (s + (format % (a...)) + r) : r} format.printf(N...) var r = ''G.each {|g| (r = solve(N, 1, g)) && break }say (r ? r : strv)"
"def identity(size)  Array.new(size){|i| Array.new(size){|j| i==j ? 1 : 0}}end [4,5,6].each do |size|  puts size, identity(size).map {|r| r.to_s}, strvend 2.1.1 :001 > require strv => true 2.1.1 :002 > Matrix.identity(5) => Matrix[[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]] func identity_matrix(n) {    1..n -> map { |i|        1..n -> map {|j| j == i ? 1 : 0 }    }} (ARGV.len ? ARGV.map{.to_i} : [4, 5, 6]) -> each { |n|  say ""#{n}:"";  identity_matrix(n).each { |row|    say row.join(' ');  }}"
"def valid_iban? iban  len = {    AL: 28, AD: 24, AT: 20, AZ: 28, BE: 16, BH: 22, BA: 20, BR: 29,    BG: 22, CR: 21, HR: 21, CY: 28, CZ: 24, DK: 18, DO: 28, EE: 20,    FO: 18, FI: 18, FR: 27, GE: 22, DE: 22, GI: 23, GR: 27, GL: 18,    GT: 28, HU: 28, IS: 26, IE: 22, IL: 23, IT: 27, KZ: 20, KW: 30,    LV: 21, LB: 28, LI: 21, LT: 20, LU: 20, MK: 19, MT: 31, MR: 27,    MU: 30, MC: 27, MD: 24, ME: 22, NL: 18, NO: 15, PK: 24, PS: 29,    PL: 28, PT: 25, RO: 24, SM: 27, SA: 24, RS: 22, SK: 24, SI: 19,    ES: 24, SE: 24, CH: 21, TN: 24, TR: 26, AE: 23, GB: 22, VG: 24  }   
  iban.delete! "" ""  return false unless iban =~ /^[\dA-Z]+$/   
  cc = iban[0, 2].to_sym  return false unless iban.size == len[cc]   
  iban = iban[4..-1] + iban[0, 4]  iban.gsub!(/./) { |c| c.to_i(36) }   iban.to_i % 97 == 1end p valid_iban? strv #=> truep valid_iban? strv #=> falsefunc valid_iban(iban) {  static len = Hash.new(    AD=>24, AE=>23, AL=>28, AO=>25, AT=>20, AZ=>28, BA=>20, BE=>16, BF=>27,    BG=>22, BH=>22, BI=>16, BJ=>28, BR=>29, CG=>27, CH=>21, CI=>28, CM=>27,    CR=>21, CV=>25, CY=>28, CZ=>24, DE=>22, DK=>18, DO=>28, DZ=>24, EE=>20,    EG=>27, ES=>24, FI=>18, FO=>18, FR=>27, GA=>27, GB=>22, GE=>22, GI=>23,    GL=>18, GR=>27, GT=>28, HR=>21, HU=>28, IE=>22, IL=>23, IR=>26, IS=>26,    IT=>27, JO=>30, KW=>30, KZ=>20, LB=>28, LI=>21, LT=>20, LU=>20, LV=>21,    MC=>27, MD=>24, ME=>22, MG=>27, MK=>19, ML=>28, MR=>27, MT=>31, MU=>30,    MZ=>25, NL=>18, NO=>15, PK=>24, PL=>28, PS=>29, PT=>25, QA=>29, RO=>24,    RS=>22, SA=>24, SE=>24, SI=>19, SK=>24, SM=>27, SN=>28, TN=>24, TR=>26,    UA=>29, VG=>24,  );   
  iban -= /\s+/g;  iban.uc! ~~ /^[0-9A-Z]+\z/ || return false;   
  var cc = iban.substr(0, 2);  iban.len == len{cc} || return false;   
  iban.sub!(/(.{4})(.+)/, {|a,b| b+a});  iban.gsub!(/([A-Z])/,   {|a| a.ord - 55});   iban.to_i % 97 == 1;} say valid_iban(strv); #=> truesay valid_iban(strv); #=> false"
" NOTHING = 0; WUMPUS = 1; BAT = 2; PIT = 4; PLAYER = 8; FINISH = 1PLAY_NEW = 2; PLAY_SAME = 4; S_PLAYER = 0;  MAX_ARROWS = 5; S_WUMPUS = 1S_BAT1 = 2; S_BAT2 = 3; S_PIT1 = 4; S_PIT2 = 5; MAX_ROOMS = 20; SAVED = 6MAX_EXITS = 3; A_PATH_LEN = 5class Room    attr_reader :obj    @obj; @exit    def initialize()        @obj = NOTHING        @exit = Array.new(MAX_EXITS)     end    def get_exit(i)        return @exit[i]    end    def clear(obj)        @obj -= obj        if @obj < NOTHING then @obj = NOTHING end    end    def empty()        @obj = NOTHING    end    def set_exit(i, e)        @exit[i] = e    end    def set_object(obj)        @obj = @obj + obj    endendclass Cave    @rooms    def initialize()        @rooms = Array.new(MAX_ROOMS)        exits = [1, 4, 7, 0, 2, 9, 1, 3, 11, 2, 4, 13, 0, 3, 5, 4, 6, 14, 5, 7,                 16, 0, 6, 8, 7, 9, 17, 1, 8, 10, 9, 11, 18, 2, 10, 12, 11, 13,                  19, 3, 12, 14, 5, 13, 15, 14, 16, 19, 6, 15, 17, 8, 16, 18,                  10, 17, 19, 12, 15, 18]        for i in 0..@rooms.length            @rooms[i] = Room.new()            r = i * MAX_EXITS; a = 0            for e in r..(r + (MAX_ROOMS - 1))                @rooms[i].set_exit(a, exits[e])                a += 1            end        end    end    def clear_all_rooms()        @rooms.each do |room|            room.empty()        end    end    def room(i)        return @rooms[i]    endendclass Game    @cave; @player; @wumpus; @arrows; @exits; @path; @saved;     @gameOver; @playerWins; @game_res     def initialize()        @player = MAX_ROOMS; @game_res = PLAY_NEW        @exits = Array.new(MAX_EXITS); @path = Array.new(A_PATH_LEN);        @saved = Array.new(SAVED); @cave = Cave.new()        instructions()    end    def look()        room = @cave.room(@player)        puts ""-----------------------------------""        puts ""You are in room  + 1}""        print strv         @exits.each do |x|            print strv         end        look_around()    end    def shoot(pathLen)        room = @cave.room(@player)        @path.each do |x|            if exits(x)                r = @cave.room(x)            else                 r = @cave.room(room.get_exit(rand(MAX_EXITS)))             end            obj = r.obj            if ((WUMPUS & obj) == WUMPUS)                  @gameOver = true; @playerWins = true                return            end             if ((PLAYER & obj) == PLAYER)                 @gameOver = true; @playerWins = false                puts ""  OUCH! Arrow got you!""                return            end        end        puts ""  Missed!""; @arrows -= 1        if @arrows == 0            iputs ""  You run out of arrows...""            @gameOver = true; @playerWins = false            return        end        wumpus(@player)    end    def result()        if @playerWins            puts ""  AHA! You got the Wumpus!  HEE HEE HEE - "" <<            ""The Wumpus'll getcha next time!!""        else             puts ""  HA HA HA - You lose!""        end        print ""Play again (Y/N)? ""; i = gets[0].downcase        if i == strv            print strv; i = gets[0].downcase            if i == strv                 return PLAY_SAME            else                return PLAY_NEW            end        end        return FINISH    end    def look_around()        msg = 0        @exits.each do |x|            obj = @cave.room(x).obj            if ((WUMPUS & obj) == WUMPUS) then msg += WUMPUS end            if ((BAT & obj) == BAT) then msg += BAT end            if ((PIT & obj) == PIT) then msg += PIT end        end        puts """"        if ((msg & WUMPUS) == WUMPUS)             puts strv         end        if ((msg & PIT) == PIT)             puts strv         end        if ((msg & BAT) == BAT)            puts strv         end    end    def exits(e)        @exits.each do |x|            return true if e == x        end        return false    end    def input()        print ""Shoot or Move (S/M)? ""; r = gets[0].downcase        case r            when strv                puts @cave.room(@player).obj            when strv                print strv; ex = gets.to_i                return false if ex == nil or ex < 0 or ex > MAX_ROOMS + 1                ex -= 1                if exits(ex)                    set_player(ex)                else                     puts ""Arrggh! --- You cannot go there!""                end                return true            when strv                  pathLen = 0                loop do                    print ""Number of rooms (1-5)? ""                      pathLen = gets.to_i                      break if pathLen > 0 and pathLen < (A_PATH_LEN + 1)                end                cnt = 0                loop do                    print strv; n = gets.to_i                    if n != nil and n > 0 and n < (MAX_ROOMS + 1)                        @path[cnt] = n - 1                        if cnt < 2 or @path[cnt] != @path[cnt - 2]                            cnt += 1                        else                            puts ""Arrows aren't that crooked! - "" <<                            ""Please, try another room.""                        end                    end                    break if cnt == pathLen                end                shoot(pathLen)                return true        end        return false    end    def set_player(pos)        @cave.room(@player).clear(PLAYER) if @player < MAX_ROOMS         return if hazards(pos)         @player = pos        room = @cave.room(@player)        room.set_object(PLAYER)        for i in 0..(MAX_EXITS - 1)            @exits[i] = room.get_exit(i)        end    end    def hazards(pos)        room = @cave.room(pos); obj = room.obj        if ((WUMPUS & obj) == WUMPUS)            puts ""  ...OOPS! Bumped a Wumpus!""            if wumpus(pos)                puts ""  TSK TSK TSK - Wumpus got you!""                @gameOver = true; @playerWins = false                return true            end        end        if ((PIT & obj) == PIT)            puts ""  YYYYIIIIEEEE!!!! Fell in pit!""            @gameOver = true; @playerWins = false            return true        end        if ((BAT & obj) == BAT)            puts ""  ZAP -- Super bat snatch! Elsewhereville for you!""            set_player(rand(MAX_ROOMS))            return true;        end        return false    end    def wumpus(pos)        if rand(100) < 75             room = @cave.room(@wumpus)            room.clear(WUMPUS)            @wumpus = room.get_exit(rand(MAX_EXITS))            @cave.room(@wumpus).set_object(WUMPUS)        end        return pos == @wumpus    end    def init()        puts ""HUNT THE WUMPUS---------------""        @cave.clear_all_rooms(); @gameOver = false; @arrows = MAX_ARROWS        if @game_res == PLAY_NEW            @saved[S_PLAYER] = rand(MAX_ROOMS); set_player(@saved[S_PLAYER])            @saved[S_BAT1] = fill_room(BAT); @saved[S_BAT2] = fill_room(BAT)            @saved[S_PIT1] = fill_room(PIT); @saved[S_PIT2] = fill_room(PIT)            @wumpus = @saved[S_WUMPUS] = fill_room(WUMPUS)        else            set_player(@saved[S_PLAYER]); @wumpus = @saved[S_WUMPUS]            @cave.room(@wumpus).set_object(WUMPUS)            @cave.room(@saved[S_BAT1]).set_object(BAT)            @cave.room(@saved[S_BAT2]).set_object(BAT)            @cave.room(@saved[S_PIT1]).set_object(PIT)            @cave.room(@saved[S_PIT2]).set_object(PIT)        end    end    def fill_room(obj)        i = 0; room = nil        loop do            i = rand(MAX_ROOMS)            room = @cave.room(i)            break if room.obj == NOTHING         end        room.set_object(obj)        return i    end    def instructions()        print ""Welcome to 'HUNT THE WUMPUS'Instructions (Y/N)? "";         return if gets.chomp.downcase == 'n'        puts ""The Wumpus lives in a cave of 20 rooms: each room has 3 "" <<             ""tunnels leading to other rooms.(Look at a Dodecahedron to "" <<             strv <<             "" ask someone)HAZARDS:--------Bottomless pits:"" <<             ""----------------Two rooms have bottomless pits in them "" <<             ""- if you go there, you fall into the pit and lose!Super"" <<             ""bats:-----------Two other rooms have super bats - if "" <<             strv <<              "" room at random,which might be troublesome.Wumpus:-"" <<             ""------The Wumpus is not bothered by the hazards, he has "" <<             strv <<             ""asleep.Two things wake him up: your entering his room or"" <<             "" your shooting an arrow.If the Wumpus wakes, he has 75% "" <<             ""chance to move one room or 25% chance to stay still.After"" <<             strv <<             ""You:----Each turn you may move or shoot a crooked "" <<             ""arrow.- Moving: you can move one room (thru one tunnel)"" <<             ""- Arrows: you have 5 arrows. You lose when you run out."" <<             strv <<              ""the computer the  rooms #s you want the arrow to go to."" <<             strv <<             "" random to the   next room.  If the arrow hits the "" <<             ""Wumpus: you win, if the arrow hits you: you lose. "" <<             ""WARNINGS:--------When you are one room away from "" <<             ""Wumpus or any other hazard, the computer says:Wumpus:"" <<             "" 'You smell something terrible nearby.'Bat: 'You hear"" <<             "" a rustling.'Pit: 'You feel a cold wind blowing from"" <<             "" a nearby cavern.'Press return to play...""        gets       end    def main_loop()        while @game_res != FINISH            init()            while not @gameOver                 look()                begin                    i = input()                end while not i            end            @game_res = result();        end    endend@game = Game.new().main_loop() "
"require 'open-uri' plausibility_ratio = 2counter = Hash.new(0)path = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'rules = [['I before E when not preceded by C:', 'ie', 'ei'],         ['E before I when preceded by C:', 'cei', 'cie']] open(path){|f| f.each{|line| line.scan(/ie|ei|cie|cei/){|match| counter[match] += 1 }}} overall_plausible = rules.all? do |(str, x, y)|  num_x, num_y, ratio = counter[x], counter[y], counter[x] / counter[y].to_f  plausibility = ratio > plausibility_ratio  puts str  puts strv  plausibilityend puts strv "
" require 'net/https'require 'uri'require 'pp' uri = URI.parse('https://sourceforge.net')http = Net::HTTP.new(uri.host,uri.port)http.use_ssl = truehttp.verify_mode = OpenSSL::SSL::VERIFY_NONE http.start do  content = http.get(uri)  p [content.code, content.message]  pp content.to_hash  puts content.bodyend var lwp = require('LWP::UserAgent');    
var url = 'https://rosettacode.org'; var ua = lwp.new(    agent    => 'Mozilla/5.0',    ssl_opts => Hash.new(verify_hostname => 1),); var resp = ua.get(url);resp.is_success || die strv;print resp.decoded_content;"
" require 'mathn'require 'rubygems'require 'gd2'include GD2 def hough_transform(img)  mx, my = img.w*0.5, img.h*0.5  max_d = Math.sqrt(mx**2 + my**2)  min_d = max_d * -1  hough = Hash.new(0)  (0..img.w).each do |x|    puts strv    (0..img.h).each do |y|      if img.pixel2color(img.get_pixel(x,y)).g > 32        (0...180).each do |a|          rad = a * (Math::PI / 180.0)          d = (x-mx) * Math.cos(rad) + (y-my) * Math.sin(rad)          hough[strv] = hough[strv] + 1        end      end    end  end  heat = GD2::Image.import 'heatmap.png'  out = GD2::Image::TrueColor.new(180,max_d*2)  max = hough.values.max  p max  hough.each_pair do |k,v|    a,d = k.split('_').map(&:to_i)    c = (v / max) * 255    c = heat.get_pixel(c,0)    out.set_pixel(a, max_d + d, c)  end  outendrequire('Imager') func hough(im, width=460, height=360) {     height = 2*floor(height / 2)     var xsize = im.getwidth    var ysize = im.getheight     var ht = %s|Imager|.new(xsize => width, ysize => height)    var canvas = height.of { width.of(255) }     ht.box(filled => true, color => 'white')     var rmax = hypot(xsize, ysize)    var dr = 2*(rmax / height)    var dth = (Num.pi / width)     for y,x in (^ysize ~X ^xsize) {        var col = im.getpixel(x => x, y => y)        var (r,g,b) = col.rgba        (r==255 && g==255 && b==255) && next        for k in ^width {            var th = dth*k            var r = (x*cos(th) + y*sin(th))            var iry = (height/2 + int(r/dr + 0.5))            ht.setpixel(x => k, y => iry, color => 3.of(--canvas[iry][k]))        }    }     return ht} var img = %s|Imager|.new(file => 'Pentagon.png')var ht = hough(img)ht.write(file => 'Hough transform.png')"
" require 'open-uri' print open(strv) {|f| f.read}  require 'fileutils'require 'open-uri' open(strv) {|f| FileUtils.copy_stream(f, $stdout)} func get(url) {    var lwp = (        try   { require('LWP::UserAgent') }        catch { warn strv; return }    );    var ua = lwp.new(agent => 'Mozilla/5.0');    if (var resp = ua.get(url); resp.is_success) {        return resp.decoded_content;    };    return;} print get(strv);"
"

word_size = 42.size * 8puts strv 

bytes = [1].pack('S').unpack('C*')byte_order = (bytes[0] == 0 ? 'big' : 'little') + ' endian'puts strv"
"require 'priority_queue' def huffman_encoding(str)  char_count = Hash.new(0)  str.each_char {|c| char_count[c] += 1}   pq = CPriorityQueue.new  
  char_count.each {|char, count| pq.push(char, count)}   while pq.length > 1    key1, prio1 = pq.delete_min    key2, prio2 = pq.delete_min    pq.push([key1, key2], prio1 + prio2)  end   Hash[*generate_encoding(pq.min_key)]end def generate_encoding(ary, prefix=strv)  case ary  when Array    generate_encoding(ary[0], strv) + generate_encoding(ary[1], strv)  else    [ary, prefix]  endend def encode(str, encoding)  str.each_char.collect {|char| encoding[char]}.joinend def decode(encoded, encoding)  rev_enc = encoding.invert  decoded = strv  pos = 0  while pos < encoded.length    key = strv    while rev_enc[key].nil?      key << encoded[pos]      pos += 1    end    decoded << rev_enc[key]  end  decodedend str = strvencoding = huffman_encoding(str)encoding.to_a.sort.each {|x| p x} enc = encode(str, encoding)dec = decode(enc, encoding)puts strv if str == decfunc walk(n, s, h) {    if (n.contains(:a)) {        h{n{:a}} = s        say strv        return nil    }    walk(n{:0}, s+'0', h)    walk(n{:1}, s+'1', h)} func make_tree(text) {    var letters = Hash()    text.each { |c| letters{c} := 0 ++ }    var nodes = letters.keys.map { |l|        Hash(a => l, freq => letters{l})    }     var n = Hash()    while (nodes.sort_by!{|c| c{:freq} }.len > 1) {        n = Hash(:0 => nodes.shift, :1 => nodes.shift)        n{:freq} = (n{:0}{:freq} + n{:1}{:freq})        nodes.append(n)    }     walk(n, strv, n{:tree} = Hash())    return n} func encode(s, t) {    t = t{:tree}    s.chars.map{|c| t{c} }.join} func decode (enc, tree) {    var n = tree    var out = strv     enc.each {|bit|        n = n{bit}        if (n.contains(:a)) {            out += n{:a}            n = tree        }    }     return out} var text = strvvar tree = make_tree(text)var enc = encode(text, tree) say encsay decode(enc, tree)"
require 'socket'host = Socket.gethostnamevar sys = frequire('Sys::Hostname');var host = sys.hostname;var host = `hostname`.chomp;
"def horner(coeffs, x)  coeffs.reverse.inject(0) {|acc, coeff| acc * x + coeff}endp horner([-19, 7, -4, 6], 3)  
func horner(coeff, x) {    coeff.reverse.reduce { |a,b| a*x + b };} say horner([-19, 7, -4, 6], 3);   
func horner(coeff, x) {    coeff.len > 0        && (coeff[0] + x*horner(coeff.ft(1), x));} say horner([-19, 7, -4, 6], 3);   
"
"include MathDtoR = PI/180 print 'Enter latitude: 'lat = Float( gets )print 'Enter longitude: 'lng = Float( gets )print 'Enter legal meridian: 'ref = Float( gets )puts slat = sin( lat * DtoR ) puts strv% slatputs strv% (lng-ref)putsputs 'Hour, sun hour angle, dial hour line angle from 6am to 6pm'-6.upto(6) do |h|  hra = 15 * h  hra -= lng - ref  hla =  atan( slat * tan( hra * DtoR ))/ DtoR   puts strv % [h, hra, hla]endvar latitude  = read('Enter latitude       => ', Number);var longitude = read('Enter longitude      => ', Number);var meridian  = read('Enter legal meridian => ', Number); var lat_sin = Math.sin(Math.deg2rad(latitude));var offset = (meridian - longitude); say('Sine of latitude: ', strv % lat_sin);say('Longitude offset: ', offset);say('=' * 48);say(' Hour  : Sun hour angle° : Dial hour line angle°'); for hour in range(-6, 6) {    var sun_deg  = (15*hour + offset);    var line_deg = Math.rad2deg(        Math.atan2(            Math.sin(Math.deg2rad(sun_deg)) * lat_sin,            Math.cos(Math.deg2rad(sun_deg))        )    )    printf(""%2d %s      %7.3f             %7.3f"",      (hour + 12) % 12 || 12, (hour < 0 ? 'AM' : 'PM'), sun_deg, line_deg);}"
"class HofstadterConway10000  def initialize    @sequence = [nil, 1, 1]  end   def [](n)    raise ArgumentError, strv if n < 1    a = @sequence    a.length.upto(n) {|i| a[i] = a[a[i-1]] + a[i-a[i-1]] }    a[n]  endend hc = HofstadterConway10000.new mallows = nil(1...20).each do |i|  j = i + 1  max_n, max_v = -1, -1  (2**i .. 2**j).each do |n|    v = hc[n].to_f / n    max_n, max_v = n, v if v > max_v    
    mallows = n if v >= 0.55  end  puts strv % [i, j, max_n, max_v]end puts strvclass HofstadterConway10000 {  has sequence = [nil, 1, 1]   method term(n {.is_pos}) {    var a = sequence    a.len .. n -> each {|i| a[i] = a[a[i-1]]+a[i-a[i-1]] }    a[n]  }} var hc = HofstadterConway10000() var mallows = nilfor i in (1..19) {  var j = i+1  var (max_n, max_v) = (-1, -1)  for n in (1<<i .. 1<<j) {    var v = (hc.term(n) / n)    (max_n, max_v) = (n, v) if (v > max_v)    mallows = n if (v >= 0.55)  }  say (strv % (i, j, max_n, max_v))} say strv"
"Shoes.app(title: strv, height: 700, width: 700) do  C = Math::cos(Math::PI/3)  S = Math::sin(Math::PI/3)  Radius = 60.0  letters = [    %w[L A R N D 1 2],     %w[G U I Y T 3 4],     %w[P C F E B 5 6],     %w[V S O M K 7 8],    %w[Q X J Z H 9 0],  ]   def highlight(hexagon)    hexagon.style(fill: magenta)  end   def unhighlight(hexagon)    hexagon.style(fill: yellow)  end   def choose(hexagon)    hexagon.choose    highlight hexagon    chosen = @hexagons.find_all {|h| h.chosen?}.map {|h| h.letter}    if chosen.size == @hexagons.size      @chosen.text = 'Every hexagon has been chosen.'    else      @chosen.text = strv +                     strv     end  end   width = 20 + (Radius*(7*letters[0].size - 3)/4.0).ceil  height = 60 + (Radius*(1 + 2*S*letters.size)).ceil  @hexagons = []  letter_to_hex = {}   # create the GUI  stack(height: height, width: width) do    @chosen = para(strv)     # draw the hexagrams    letters.each_index do |row|      letters[0].each_index do |column|        x = 60 + column * Radius * 0.75 + (1-S) * Radius        y = 80 + row * S * Radius + (column.odd? ? S * Radius * 0.5 : 0)        h = shape(x-Radius, y-S*Radius) do          strokewidth 3          move_to(x-C*Radius, y-S*Radius)          line_to(x+C*Radius, y-S*Radius)          line_to(x+Radius,   y)          line_to(x+C*Radius, y+S*Radius)          line_to(x-C*Radius, y+S*Radius)          line_to(x-Radius,   y)          line_to(x-C*Radius, y-S*Radius)        end         # add some attributes and methods to the shape        class << h          attr_accessor :x, :y, :state, :letter          def chosen?            not @state.nil?          end          def choose            @state = :chosen          end          def contains?(px, py)            if @x-Radius < px and px <= @x-C*Radius              ratio = (px - @x + Radius)/(Radius*(1-C))              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius            elsif @x-C*Radius < px and px <= @x+C*Radius              @y - S*Radius < py and py < @y + S*Radius            elsif @x+C*Radius < px and px <= @x+Radius              ratio = (@x + Radius - px)/(Radius*(1-C))              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius            else              false            end          end          def inspect            %q(<%s,strv,%s,%d@%d>) % [self.class, letter, chosen?, x, y]          end        end         h.x = x + x - Radius        h.y = y + y - S*Radius        h.letter = letters[row][column]        unhighlight h         @hexagons << h        letter_to_hex[h.letter.downcase] = h        letter_to_hex[h.letter.upcase] = h         
        para(h.letter).style(size:56, stroke:red) \                      .move(h.x - C*Radius, h.y - S*Radius)      end    end     
    hex_over = nil    motion do |x, y|      hex = @hexagons.find {|h| h.contains?(x,y)}      unless hex.nil? or hex.chosen?        highlight hex       end      unless hex_over == hex or hex_over.nil? or hex_over.chosen?        unhighlight hex_over       end      hex_over = hex    end     
    click do |button, x, y|      info(strv)      hexagon = @hexagons.find {|h| h.contains?(x,y)}      if hexagon        info(strv)        choose hexagon      end    end     
    keypress do |key|       if key == ""11""  
        exit      elsif key == strv        info @hexagons.collect {|h| h.inspect}.join("""")      elsif letter_to_hex.has_key?(key)        info(strv)        choose letter_to_hex[key]      end    end  endendrequire('Tk') class Honeycombs(    Number size   = 36,    Array letters = @('A' .. 'Z').shuffle.first(20),) {     define tk   = %S<Tk>    has changed = Hash()     func altitude(n) {        sqrt(3/4) * n    }     method polygon_coordinates(x, y, size) {        var alt = altitude(size)        return (x - size,       y,                x - size/2, y - alt,                x + size/2, y - alt,                x + size,       y,                x + size/2, y + alt,                x - size/2, y + alt,               );    }     method change(canvas, id, letter_id) {        return {            canvas.itemconfigure(id,        '-fill' => 'magenta')            canvas.itemconfigure(letter_id, '-fill' => 'black')            changed{id} = true             if (20 == changed.len) {                say strv                canvas.MainWindow.after(10, { tk.exit })            }        }    }     method comb(canvas, fromx, fromy, size, count) {        for x,y in (            RangeNum(fromx, 3*count*size - 1,          3*size) ~X            RangeNum(fromy,     7.5*size - 1, 2*altitude(size))        ) {            var id = canvas.createPolygon(                                  self.polygon_coordinates(x, y, size),                                  '-outline' => 'black',                                  '-fill'    => 'yellow',                                  '-width'   => 2,                                )            var letter = letters.shift            var letter_id = canvas.createText(x, y,                                     '-fill' => 'red',                                     '-text' => letter,                                     '-font' => strv,                                )            canvas.MainWindow.bind('all', letter.lc,                                      self.change(canvas, id, letter_id))            [id, letter_id].each { |b|                canvas.bind(b, '<Button-1>',                                      self.change(canvas, id, letter_id))            }        }    }     method display(title) {        fork {            var mw     = %s'MainWindow'.new('-title' => title)            var canvas = mw.Canvas('-width'  => 8*size,                                   '-height' => 8*size).pack             self.comb(canvas, size,       size,                  size, 3)            self.comb(canvas, size * 2.5, size + altitude(size), size, 2)             var btn = mw.Button('-text'      => 'Quit',                                '-underline' => 0,                                '-command'   => { tk.exit },                               ).pack            mw.bind('<Alt-q>', { btn.invoke })            tk.MainLoop()        }    }} Honeycombs().display(title: 'Honeycombs')"
"require 'date' def easter_date(year)  
  
   a    = year % 19  b, c = year.divmod(100)  d, e = b.divmod(4)  f    = (b + 8) / 25  g    = (b - f + 1) / 3  h    = (19*a + b - d - g + 15) % 30  i, k = c.divmod(4)  l    = (32 + 2*e + 2*i - h - k) % 7  m    = (a + 11*h + 22*l) / 451  numerator = h + l - 7*m + 114  month = numerator / 31  day = (numerator % 31) + 1  Date.new(year, month, day)end OFFSETS = [  [:easter,     0],  [:ascension, 39],  [:pentecost, 49],  [:trinity,   56],  [:corpus,    60],] def emit_dates(year)  e = easter_date year  dates = OFFSETS.collect {|item, offset| (e + offset).strftime(strv)}  puts strv % [year, dates.join(',  ')]end puts strv + OFFSETS.collect{|item, offset| strv % item}.join(', ')400.step(2100, 100).each {|year| emit_dates year}puts(2010 .. 2020).each {|year| emit_dates year}require('Date::Calc'); var abbr = < Nil Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec >; var holidays = [    [Easter    => 0],    [Ascension => 39],    [Pentecost => 49],    [Trinity   => 56],    [Corpus    => 60],]; func easter(year) {    var ay = (year % 19);    var by = int(year / 100);    var cy = (year % 100);    var dy = int(by / 4);    var ey = (by % 4);    var fy = int((by + 8) / 25);    var gy = int((by - fy + 1) / 3);    var hy = ((19*ay + by - dy - gy + 15) % 30);    var iy = int(cy / 4);    var ky = (cy % 4);    var ly = ((32 + 2*ey + 2*iy - hy - ky) % 7);    var md = (hy + ly - 7*int((ay + 11*hy + 22*ly) / 451) + 114);    var month = int(md / 31);    var day = (md % 31 + 1);    return(month, day);} func cholidays(year) {    var (emon, eday) = easter(year);    printf(strv, year);    say gather {        holidays.each { |holiday|            var (_, mo, da) = %S'Date::Calc'.Add_Delta_Days(year, emon, eday, holiday[1]);            take(strv)        }    }.join(', ');} [400..(2100, 100), 2010..2020, 2100].flatten.each { |year|    cholidays(year);}"
"foo_hist = []trace_var(:$foo){|v| foo_hist.unshift(v)} $foo = strv$foo = strv$foo = strv p foo_hist 
 class HistoryVar(v) {     has history = []    has variable = v     method ≔(value) {        history << variable        variable = value    }     method to_s {        strv    }     method AUTOLOAD(_, name, *args) {        variable.(name)(args...)    }} var foo = HistoryVar(0) foo ≔ 1foo ≔ 2foo ≔ foo+3foo ≔ 42 say strvsay strv"
"@cache = []def Q(n)  if @cache[n].nil?    case n    when 1, 2 then @cache[n] = 1    else @cache[n] = Q(n - Q(n-1)) + Q(n - Q(n-2))    end  end  @cache[n]end puts strvputs strv  prev = Q(1)count = 02.upto(100_000) do |n|   q = Q(n)  count += 1 if q < prev   prev = qendputs strvfunc Q(n) is cached {    n <= 2 ? 1           : Q(n - Q(n-1))+Q(n-Q(n-2))} say strvsay strvsay strvvar Q = [0, 1, 1];100_000.times {    Q << (Q[-Q[-1]] + Q[-Q[-2]])} say strvsay strvsay strv"
"$r = [nil, 1]$s = [nil, 2] def buildSeq(n)  current = [ $r[-1], $s[-1] ].max  while $r.length <= n || $s.length <= n    idx = [ $r.length, $s.length ].min - 1    current += 1    if current == $r[idx] + $s[idx]      $r << current    else      $s << current    end  endend def ffr(n)  buildSeq(n)  $r[n]end def ffs(n)  buildSeq(n)  $s[n]end require 'set'require 'test/unit' class TestHofstadterFigureFigure <   def test_first_ten_R_values    r10 = 1.upto(10).map {|n| ffr(n)}    assert_equal(r10, [1, 3, 7, 12, 18, 26, 35, 45, 56, 69])  end   def test_40_R_and_960_S_are_1_to_1000    rs_values = Set.new    rs_values.merge( 1.upto(40).collect  {|n| ffr(n)} )    rs_values.merge( 1.upto(960).collect {|n| ffs(n)} )    assert_equal(rs_values, Set.new( 1..1000 ))  endendR = Enumerator.new do |y|  y << n = 1  S.each{|s_val| y << n += s_val}end S = Enumerator.new do |y|  y << 2  y << 4  u = 5  R.each do |r_val|    next if u > r_val    (u...r_val).each{|r| y << r}    u = r_val+1  endend p R.take(10)p S.take(10)p (R.take(40)+ S.take(960)).sort == (1..1000).to_a var r = [nil, 1]var s = [nil, 2] func ffsr(n) {  while(r.end < n) {    r << s[r.end]+r[-1];    s << [(s[-1]+1 .. r[-1]-1)..., r[-1]+1].grep{ s[-1] < _ }...  }  return n;} func ffr(n) { r[ffsr(n)] }func ffs(n) { s[ffsr(n)] } printf(""  i: R(i) S(i)"");printf(""=============="");10.of { |i|    printf(""%3d:  %3d  %3d"", i, ffr(i), ffs(i))}printf(""R(40)=%3d S(960)=%3d R(41)=%3d"", ffr(40), ffs(960), ffr(41)); var seen = Hash() 40.of  { |i| seen{ffr(i)} := 0 ++ }960.of { |i| seen{ffs(i)} := 0 ++ } if (seen.count {|k,v| (k.to_i >= 1) && (k.to_i <= 1000) && (v == 1) } == 1000) {    say strv;}else {    var missed = (1..1000 -> grep { !seen.has_key(_) })    var dupped = seen.grep { |_, v| v > 1 }.keys.sort;    say strv;    say strv;}"
"succ = proc{|x| x+1}def to2(&f)  f[2]end to2(&succ) #=> 3to2{|x| x+1} #=> 3def succ(n)  n+1enddef to2(m)  m[2]end meth = method(:succ)to2(meth) #=> 3func first(f) {  return f();} func second {  return strv;} say first(second);              
say first(func { strv });    
"
"require strv LN2 = BigMath::log(2,16)  #Use LN2 = Math::log(2) to see the difference with floatsFACTORIALS = Hash.new{|h,k| h[k] = k * h[k-1]}FACTORIALS[0] = 1 def hickerson(n)  FACTORIALS[n] / (2 * LN2 ** (n+1))end def nearly_int?(n)  int = n.round  n.between?(int - 0.1, int + 0.1)end 1.upto(17) do |n|  h = hickerson(n)  str = nearly_int?(h) ? strv : strv  puts ""n:%3i h: %s%s"" % [n, h.to_s('F')[0,25], str] #increase the 25 to print more digits, there are 856 of themendfunc h(n) {    n! / (2 * Math.pow(2.log, n+1));} 17.times { |n|    ""h(%2d) = %22s is%s almost an integer."".printf(        n, var hn = h(n).roundf(-3), hn.to_s ~~ /\.[09]/ ? '' : ' NOT');}"
"address = <<END
1, High Street,
#{town_name},
West Midlands.
WM4 5HD.
ENDpancake = <<strveggmilkflourNO MORE INGREDIENTSx = <<'FOO'No#{interpolation}hereFOOoutput = <<`BAR`ls /homeBARputs <<EOF + strvMary had  a littleEOFvar text = <<strv;a = #{1+2}b = #{3+4}EOFvar x = <<'FOO';No#{interpolation}hereFOOsay (<<EOF + strv);Mary had  a littleEOFsay (<<EOF
Mary had
  a little
EOF+ strv);"
"class Triangle  def self.valid?(a,b,c)      
    short, middle, long = [a, b, c].sort    short + middle > long  end   attr_reader :sides, :perimeter, :area   def initialize(a,b,c)    @sides = [a, b, c].sort    @perimeter = a + b + c    s = @perimeter / 2.0    @area = Math.sqrt(s * (s - a) * (s - b) * (s - c))  end   def heronian?    area == area.to_i  end   def <=>(other)    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]  end   def to_s    strv % [sides.join('x'), perimeter, area]  endend max, area = 200, 210prim_triangles = []1.upto(max) do |a|  a.upto(max) do |b|    b.upto(max) do |c|      next if a.gcd(b).gcd(c) > 1      prim_triangles << Triangle.new(a, b, c) if Triangle.valid?(a, b, c)    end  endend sorted = prim_triangles.select(&:heronian?).sort puts strvputs ""sides       perim.   area""puts sorted.first(10).map(&:to_s)puts ""Triangles with an area of: #{area}""sorted.each{|tr| puts tr if tr.area == area}class Triangle(a, b, c) {   has (sides, perimeter, area)   method init {    sides = [a, b, c].sort    perimeter = [a, b, c].sum    var s = (perimeter / 2)    area = sqrt(s * (s - a) * (s - b) * (s - c))  }   method is_valid(a,b,c) {    var (short, middle, long) = [a, b, c].sort...;    (short + middle) > long  }   method is_heronian {    area == area.to_i  }   method <=>(other) {    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]  }   method to_s {    strv % (sides.join('x'), perimeter, area)  }} var (max, area) = (200, 210)var prim_triangles = [] for a in (1..max) {  for b in (a..max) {    for c in (b..max) {      next if (Math.gcd(a, b, c) > 1)      prim_triangles << Triangle(a, b, c) if Triangle.is_valid(a, b, c)    }  }} var sorted = prim_triangles.grep{.is_heronian}.sort say strvsay ""sides       perim.   area""say sorted.first(10).join("""")say ""Triangles with an area of: #{area}""sorted.each{|tr| say tr if (tr.area == area)}"
$stderr.puts strvwarn strvSTDERR.println(strv);
   puts strv 
"require 'webrick'server = WEBrick::HTTPServer.new(:Port => 8080)server.mount_proc('/') {|request, response| response.body = strv}trap(strv) {server.shutdown}server.startrequire 'webrick'WEBrick::HTTPServer.new(:Port => 80).tap {|srv|    srv.mount_proc('/') {|request, response| response.body = strv}}.startrequire 'sinatra'get(strv) { strv }var port = 8080;var protocol = Socket.getprotobyname(strv); var sock = (Socket.open(Socket.PF_INET, Socket.SOCK_STREAM, protocol) || die strv);  
  
 sock.setsockopt(Socket.SOL_SOCKET, Socket.SO_REUSEADDR, 1) || die strv;  
  
 sock.bind(Socket.sockaddr_in(port, Socket.INADDR_ANY)) || die strv;  
 sock.listen(Socket.SOMAXCONN) || die strv;  
 while (var client = sock.accept) {  client.print (""HTTP/1.1 200 OK"" +               ""Content-Type: text/html; charset=UTF-8"" +               strv +               ""<body>Goodbye, world!</body></html>"");  client.close;}var inet = require('IO::Socket::INET'); var sock = inet.new( LocalAddr => strv,                     Listen    => 1,                     Reuse     => 1,            ); while (var client = sock.accept) {    client.print (""HTTP/1.1 200 OK"" +                ""Content-Type: text/html; charset=UTF-8"" +                strv +                ""<body>Goodbye, world!</body></html>"");    client.close;}"
print strvprint strv;strv.printf(strv);
"open(strv, strv) { |f| f.puts strv }Sys.open(\var fh, '>', '/dev/lp0')    && fh.println(strv)    && fh.close;"
"puts strvputs strv$stdout.puts strv STDOUT.write ""Hello world!""$>.puts strv$>.write ""Hello world!"""
"def hashJoin(table1, index1, table2, index2)  
  h = table1.group_by {|s| s[index1]}  h.default = []  
  table2.collect {|r|    h[r[index2]].collect {|s| [s, r]}  }.flatten(1)end table1 = [[27, strv],          [18, strv],          [28, strv],          [18, strv],          [28, strv]]table2 = [[strv, strv],          [strv, strv],          [strv, strv],          [strv, strv],          [strv, strv]] hashJoin(table1, 1, table2, 0).each { |row| p row }func hashJoin(table1, index1, table2, index2) {    var a = []    var h = Hash()     
    table1.each { |s|        h{s[index1]} := [] << s    }     
    table2.each { |r|        a += h{r[index2]}.map{[_,r]}    }     return a} var t1  = [[27, strv],           [18, strv],           [28, strv],           [18, strv],           [28, strv]] var t2  = [[strv, strv],           [strv, strv],           [strv, strv],           [strv, strv],           [strv, strv]] hashJoin(t1, 1, t2, 0).each { .say }"
"include Math Radius = 6371  
 def spherical_distance(start_coords, end_coords)  lat1, long1 = deg2rad *start_coords  lat2, long2 = deg2rad *end_coords  2 * Radius * asin(sqrt(sin((lat2-lat1)/2)**2 + cos(lat1) * cos(lat2) * sin((long2 - long1)/2)**2))end def deg2rad(lat, long)  [lat * PI / 180, long * PI / 180]end bna = [36.12, -86.67]lax = [33.94, -118.4] puts strv % spherical_distance(bna, lax)class EarthPoint(lat, lon) {     const earth_radius = 6371;       
    const radian_ratio = Math.pi/180;     
    method latR { self.lat * radian_ratio };    method lonR { self.lon * radian_ratio };     method haversine_dist(EarthPoint p) {        var arc = EarthPoint(              self.lat - p.lat,              self.lon - p.lon,        );         var a = Math.sum(                  (arc.latR / 2).sin**2,                  (arc.lonR / 2).sin**2 *                    self.latR.cos * p.latR.cos                )         earth_radius * a.sqrt.asin * 2;    }} var BNA = EarthPoint.new(lat: 36.12, lon: -86.67);var LAX = EarthPoint.new(lat: 33.94, lon: -118.4); say BNA.haversine_dist(LAX);   
"
" keys = ['hal',666,[1,2,3]]vals = ['ibm','devil',123] hash = Hash[keys.zip(vals)] p hash  
 #retrieve the value linked to the key [1,2,3]puts hash[ [1,2,3] ]  
  class Array  def zip_hash(other)    Hash[self.zip(other)]  endend hash = %w{ a b c }.zip_hash( %w{ 1 2 3 } )p hash  
 keys = ['hal', 666, [1,2,3]]vals = ['ibm', 'devil', 123] keys.zip(vals).to_hvar keys = %w(a b c)var vals = [1, 2, 3] var hash = Hash()hash{keys...} = vals...say hash"
harshad = 1.step.lazy.select { |n| n % n.digits.sum == 0 } p harshad.first(20)p harshad.find { |n| n > 1000 }func harshad() {    var n = 0;    {        ++n while !(n %% n.digits.sum);        n;    }} var iter = harshad();say 20.of { iter.run }; var n;do {    n = iter.run} while (n <= 1000); say n;
"t1 = Time.now catch :done do  Signal.trap('INT') do    Signal.trap('INT', 'DEFAULT') 
    throw :done  end  n = 0  loop do    sleep(0.5)    n += 1    puts n  endend tdelt = Time.now - t1puts 'Program has run for %5.3f seconds.' % tdeltvar start = Time.sec; Sig.INT { |_|    Sys.say(strv);    Sys.exit;} { |i|    Sys.say(i);    Sys.sleep(0.5);} * Math.inf;"
"require 'gtk2' window = Gtk::Window.newwindow.title = 'Goodbye, World'window.signal_connect(:delete-event) { Gtk.main_quit }window.show_all Gtk.mainrequire 'tk'root = TkRoot.new(strv => strv)TkLabel.new(root, strv=>strv).pack(strv=>'top')Tk.mainloop#_Note: this code MUST be executed through the Shoes GUI!! Shoes.app do  para strv, :size => 72end require 'gosu' class Window < Gosu::Window   def initialize    super(150, 50, false)    @font = Gosu::Font.new(self, strv, 32)  end   def draw    @font.draw(strv, 0, 10, 1, 1, 1)  end end Window.new.show #_Note: this code must not be executed through a GUIrequire 'green_shoes' Shoes.app do  para strvend  require 'win32ole'WIN32OLE.new('WScript.Shell').popup(strv)  #!r6rs ;; PS-TK example: display frame + label (import (rnrs)         (lib pstk main) ; change this to refer to your PS/Tk installation        ) (define tk (tk-start))(tk/wm 'title tk strv)
 
(let ((label (tk 'create-widget 'label 'text: strv)))  (tk/place label 'height: 20 'width: 50 'x: 10 'y: 20)) (tk-event-loop tk) var tk = require('Tk');var main = %s'MainWindow'.new;main.Button(    '-text'    => 'Goodbye, World!',    '-command' => 'exit',).pack;tk.MainLoop;var gtk2 = require('Gtk2') -> init; var window = %s'Gtk2::Window'.new;var label  = %s'Gtk2::Label'.new('Goodbye, World!'); window.set_title('Goodbye, World!');window.signal_connect(destroy => func(*_){ gtk2.main_quit }); window.add(label);window.show_all; gtk2.main;"
Shoes.app do  @number = edit_line  @number.change {update_controls}   @incr = button('Increment') {update_controls(@number.text.to_i + 1)}  @decr = button('Decrement') {update_controls(@number.text.to_i - 1)}   def update_controls(value = @number.text.to_i)    @number.text = value    @incr.state = value.to_i >= 10 ? strv : nil    @decr.state = value.to_i <=  0 ? strv : nil  end   update_controls 0end
"hamming = Enumerator.new do |yielder|  next_ham = 1  queues = [[ 2, []], [3, []], [5, []] ]   loop do    yielder << next_ham   
     queues.each {|m,queue| queue << next_ham * m}    next_ham = queues.collect{|m,queue| queue.first}.min    queues.each {|m,queue| queue.shift if queue.first==next_ham}  endendstart = Time.now hamming.each.with_index(1) do |ham, idx|  case idx  when (1..20), 1691    puts strv  when 1_000_000    puts strv    break  endend puts strvfunc ham_gen {    var s = [[1], [1], [1]];    var m = [2, 3, 5];     func {        var n = [s[0][0], s[1][0], s[2][0]].min;        for i in (0..2) {            s[i].shift if (s[i][0] == n);            s[i].append(n * m[i]);        }        return n    }} var h = ham_gen(); var i = 20;say i.of { h() }.join(' '); range(i+1, 1691-1).each { h() }say h();"
"def hailstone n  seq = [n]  until n == 1    n = (n.even?) ? (n / 2) : (3 * n + 1)    seq << n
  end
  seq
end
 
puts strv
hs27 = hailstone 27
p [hs27.length, hs27[0..3], hs27[-4..-1]]
 


n = (1 ... 100_000).max_by{|n| hailstone(n).length}puts strvputs strvmodule Hailstone  ListNode = Struct.new(:value, :size, :succ) do    def each      node = self      while node        yield node.value        node = node.succ      end    end  end   @@sequence = {1 => ListNode[1,1]}   module_function   def sequence(n)    unless @@sequence[n]      m, ary = n, []      until succ = @@sequence[m]        ary << m        m = m.even? ? (m / 2) : (3 * m + 1)      end      ary.reverse_each do |m|        @@sequence[m] = succ = ListNode[m, succ.size + 1, succ]      end    end    @@sequence[n]  endend puts strvhs27 = Hailstone.sequence(27).entriesp [hs27.size, hs27[0..3], hs27[-4..-1]] 
n = (1 ... 100_000).max_by{|n| Hailstone.sequence(n).size}puts strvputs strvfunc hailstone (n) {    var sequence = [n];    while (n > 1) {        sequence.append(            n.is_even ? n.div!(2)                      : n.mul!(3).add!(1)        );    }    return(sequence);} 
var arr = hailstone(var nr = 27);say strv; 
var h = [0, 0];99_999.times { |i|    (var l = hailstone(i).len) > h[1] && (        h = [i, l];    );} printf(""%d: (%d)"", h...);"
number = rand(1..10) puts strv loop do  begin    user_number = Integer(gets)    if user_number == number      puts strv      break    elsif user_number > number        puts strv    else      puts strv    end  rescue ArgumentError    puts strv  endendvar number = rand(1..10);say strv; loop {    given(var n = Sys.scanln(strv).to_i) {        when (number)     { say strv; break }        case (n < number) { say strv }        default           { say strv }    }}
"require 'set' 
 @seen_numbers = Set.new@happy_numbers = Set.new def happy?(n)  return true if n == 1 
  return @happy_numbers.include?(n) if @seen_numbers.include?(n) 
   @seen_numbers << n  digit_squared_sum = n.to_s.each_char.inject(0) { |sum, c| sum + c.to_i**2 } 
   if happy?(digit_squared_sum)    @happy_numbers << n    true 
  else    false 
  endenddef print_happy  happy_numbers = []   1.step do |i|    break if happy_numbers.length >= 8    happy_numbers << i if happy?(i)  end   p happy_numbersend print_happy[1, 7, 10, 13, 19, 23, 28, 31]@memo = [0,1]def happy(n)  sum = n.to_s.chars.map{|c| c.to_i**2}.inject(:+)  return @memo[sum] if @memo[sum]==0 or @memo[sum]==1  @memo[sum] = 0                        
  @memo[sum] = happy(sum)               
end i = count = 0while count < 8  i += 1  puts i or count+=1 if happy(i)==1end putsfor i in 99999999999900..99999999999999  puts i if happy(i)==1endfunc happy(n) is cached {    static seen = Hash()     return true  if n.is_one    return false if seen.has_key(n)     seen{n} = 1    happy(n.digits »**» 2 -> sum)} var count = 0;Inf.times { |i|    happy(i) ? say i : next    ++count == 8 && break}"
 n = rand(1..10)puts 'Guess the number: 'puts 'Wrong! Guess again: ' until gets.to_i == nputs 'Well guessed!' var n = 10.rand(1).int;print 'Guess the number: ';while (n != read(Number).int) {    print 'Wrong! Guess again: '}say 'Well guessed!';
"def play(low, high, turns=1)  num = (low + high) / 2  print ""guessing #{num}""  case is_it?(num)  when 1    puts strv    play(low, num - 1, turns + 1)  when -1    puts strv    play(num + 1, high, turns + 1)  else    puts strv  endend def is_it?(num)  num <=> $numberend low, high = 1, 100$number = rand(low .. high) puts strvplay(low, high)r = (1..100)secret = rand(r)turns = 0 puts strvr.bsearch do |guess|                
  print ""Guessing #{guess} ""  turns += 1  low_high = secret <=> guess       
  puts [strv, strv, strv][low_high]  low_highend var min = 1;var max = 99;var tries = 0;var guess = max.rand(min).int; print <<strv.chomp;\n=>> Think of a number between #{min} and #{max} and I'll guess it!\nPress <ENTER> when are you ready...EOT STDIN.readline; loop {    print <<-EOT.chomp    \n=>> My guess is: #{guess} Is your number higher, lower, or equal? (h/l/e)    >#{' '}    EOT     ++tries;    given (STDIN.readline) {        case (max <= min) {            say ""I give up..."";            break;        }        when (/^h/i) {            min = guess+1;        }        when (/^l/i) {            max = guess;        }        when (/^e/i) {            say ""I knew it! It took me only #{tries} tries."";            break;        }        default {            say strv;            next;        }    }     guess = (min+max / 2 -> int);}"
values.maxvalues.max;
"def subarray_sum(arr)  max, slice = 0, []  arr.each_index do |i|    (i...arr.length).each do |j|      sum = arr[i..j].inject(0, :+)      max, slice = sum, arr[i..j]  if sum > max    end  end  [max, slice]end[ [1, 2, 3, 4, 5, -8, -9, -20, 40, 25, -5],  [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1],  [-1, -2, -3, -4, -5],  []].each do |input|  puts ""Input seq: #{input}""  puts ""  Max sum: %d   Subseq: %s"" % subarray_sum(input)end




def subarray_sum(arr)  curr = max = 0  first, last, curr_first = arr.size, 0, 0  arr.each_with_index do |e,i|    curr += e    if e > curr      curr = e      curr_first = i    end    if curr > max      max = curr      first = curr_first      last = i    end  end  return max, arr[first..last]endfunc maxsubseq(*a) {    var (start, end, sum, maxsum) = (-1, -1, 0, 0);    a.each_kv { |i, x|        sum += x;        if (maxsum < sum) {            maxsum = sum;            end = i;        }        elsif (sum < 0) {            sum = 0;            start = i;        }    };    a.ft(start+1, end);} say maxsubseq(-1, -2,  3,  5,  6, -2, -1,  4, -4,  2, -1);say maxsubseq(-2, -2, -1,  3,  5,  6, -1,  4, -4,  2, -1);say maxsubseq(-2, -2, -1, -3, -5, -6, -1, -4, -4, -2, -1);"
"Shoes.app(title: strv) do  stack do    textbox = edit_line     textbox.change do      textbox.text = textbox.text.gsub(/[^\d]/, '') and alert strv if textbox.text !~ /^\d*$/    end     flow do      button strv do        textbox.text = textbox.text.to_i + 1      end       button strv do        textbox.text = rand 5000 if confirm strv      end    end  endend"
" irb(main):001:0> 40902.gcd(24140)=> 34def gcd(u, v)  u, v = u.abs, v.abs  while v > 0    u, v = v, u % v  end  uendvar arr = [100, 1_000, 10_000, 20];say Math.gcd(arr...);func gcd(a, b) {    b.is_zero ? a.abs : gcd(b, a % b);}"
"class RGBColour  def to_grayscale    luminosity = Integer(0.2126*@red + 0.7152*@green + 0.0722*@blue)    self.class.new(luminosity, luminosity, luminosity)  endend class Pixmap  def to_grayscale    gray = self.class.new(@width, @height)    @width.times do |x|      @height.times do |y|        gray[x,y] = self[x,y].to_grayscale      end    end    gray  endendrequire('Image::Imlib2') func tograyscale(img) {    var (width, height) = (img.width, img.height)    var gimg = %s'Image::Imlib2'.new(width, height)    for y,x in (^height ~X ^width) {        var (r, g, b) = img.query_pixel(x, y)        var gray = int(0.2126*r + 0.7152*g + 0.0722*b)        gimg.set_color(gray, gray, gray, 255)        gimg.draw_point(x, y)    }    return gimg} var (input='input.png', output='output.png') = ARGV...var image = %s'Image::Imlib2'.load(input)var gscale = tograyscale(image)gscale.set_quality(80)gscale.save(output)"
"str = `ls`   arr = `ls`.linesvar output = `ls`;           
var lines  = `ls`.lines;     
var pipe   = %p(ls);          
var pipe_h = pipe.open_r;     
var lines  = [];              
pipe_h.each { |line| lines.append(line.chomp) };"
"var files = %w(                a.txt                b.txt                c.txt              ); files.map{.to_file}.each { |file|    say file.edit { |line|        line.gsub(strv, strv);    };}"
"class Integer  
  def to_gray    raise Math::DomainError, strv if self < 0    self ^ (self >> 1)  end   
  def from_gray    raise Math::DomainError, strv if self < 0    recurse = proc do |i|      next 0 if i == 0      o = recurse[i >> 1] << 1      o | (i[0] ^ o[1])    end    recurse[self]  endend (0..31).each do |number|  encoded = number.to_gray  decoded = encoded.from_gray  printf ""%2d : %5b => %5b => %5b : %2d"",         number, number, encoded, decoded, decodedendfunc bin2gray(n) {    n ^ (n >> 1);} func gray2bin(num) {    var bin = num;    while (num >>= 1) { bin ^= num };    return bin;} 0..31 -> each { |i|    var gr = bin2gray(i);    printf(""%d%b%b%b"", i, i, gr, gray2bin(gr));}"
p ('a' .. 'z').to_ap [*'a' .. 'z']var arr = 'a'..'z';say arr.join(' ');
p 12345679e63 * 81 + 1e63p 12345679012345679e54 * 81 + 1e54p 12345679012345679012345679e45 * 81 + 1e45p 12345679012345679012345679012345679e36 * 81 + 1e36
"pieces = %i(♔ ♕ ♘ ♘ ♗ ♗ ♖ ♖)regexes = [/♗(..)*♗/, /♖.*♔.*♖/]row = pieces.shuffle.join until regexes.all?{|re| re.match(row)} puts rowrow = [:♖, :♔, :♖][:♕, :♘, :♘].each{|piece| row.insert(rand(row.size+1), piece)}[[0, 2, 4, 6].sample, [1, 3, 5, 7].sample].sort.each{|pos| row.insert(pos, :♗)} puts rowKRN = %w(NNRKR NRNKR NRKNR NRKRN RNNKR RNKNR RNKRN RKNNR RKNRN RKRNN) def chess960(id=rand(960))  pos = Array.new(8)  q, r = id.divmod(4)  pos[r * 2 + 1] = strv  q, r = q.divmod(4)  pos[r * 2] = strv  q, r = q.divmod(6)  pos[pos.each_index.reject{|i| pos[i]}[r]] = strv  krn = KRN[q].each_char  pos.each_index {|i| pos[i] ||= krn.next}  pos.joinend puts strv[0,518,959].each do |id|  puts strv % [id, chess960(id)]end puts ""Generate random Start Position""5.times {puts chess960}"
"a, b = b, adef swap(a, b)    return b, aendx = 42y = strvx, y = swap x, yputs x  
puts y  
func swap(Ref a, Ref b) {    var tmp = *a;    *a = *b;    *b = tmp;}func swap(Ref a, Ref b) {    (*a, *b) = (*b, *a);}func swap(Ref a, Ref b) {    [*a, *b] » (b, a);}var (x, y) = (1, 2);swap(\x, \y);"
"
 def powers(m)  return enum_for(__method__, m) unless block_given?  0.step{|n| yield n**m}end def squares_without_cubes  return enum_for(__method__) unless block_given?   cubes = powers(3)  c = cubes.next  powers(2) do |s|    c = cubes.next while c < s    yield s unless c == s  endend p squares_without_cubes.take(30).drop(20)

 def powers(m)  return enum_for(__method__, m) unless block_given?  0.step{|n| yield n**m}end def squares_without_cubes  return enum_for(__method__) unless block_given?   cubes = powers(3) #no block, so this is the first generator  c = cubes.next  squares = powers(2) 
  loop do    s = squares.next    c = cubes.next while c < s    yield s unless c == s  endend answer = squares_without_cubes 
20.times { answer.next }p 10.times.map { answer.next }def filtered(s1, s2)  return enum_for(__method__, s1, s2) unless block_given?  v, f = s1.next, s2.next  loop do    v > f and f = s2.next and next    v < f and yield v    v = s1.next  endend squares, cubes = powers(2), powers(3)f = filtered(squares, cubes)p f.take(30).last(10)
func gen_pow(m) {    var e = 0;    func { e++ ** m };} func gen_filter(g1, g2) {    var v2 = g2.run;    func {        loop {            var v1 = g1.run;            while (v1 > v2) { v2 = g2.run };            v1 == v2 || return v1;        }    }} 
var squares = gen_pow(2);var cubes = gen_pow(3);var squares_without_cubes = gen_filter(squares, cubes); 
20.times { squares_without_cubes() }; 
var answer = [];10.times { answer.append(squares_without_cubes()) };say answer;"
"def general_fizzbuzz(text)  num, *nword = text.split  num = num.to_i  dict = nword.each_slice(2).map{|n,word| [n.to_i,word]}  (1..num).each do |i|    str = dict.map{|n,word| word if i%n==0}.join    puts str.empty? ? i : str  endend text = <<EOS
20
3 Fizz
5 Buzz
7 Baxx
EOS general_fizzbuzz(text)class FizzBuzz(schema=Hash.new(<3 Fizz 5 Buzz>...)) {    method filter(this) {        var fb = '';        schema.sort_by {|k,_| k.to_i }.each { |pair|            fb += (pair[0].to_i.divides(this) ? pair[1] : '');        }        fb.len > 0 ? fb : this;    }} func GeneralFizzBuzz(upto, schema) {    var ping = FizzBuzz();    nil != schema && (        ping.schema = schema.to_hash;    );    upto.of {|i| ping.filter(i) };} GeneralFizzBuzz(20, <3 Fizz 5 Buzz 7 Baxx>).each { .say };"
"$rows_of_pins = 12$width = $rows_of_pins * 10 + ($rows_of_pins+1)*14 Shoes.app(    :width => $width + 14,    :title => strv) do  @bins = Array.new($rows_of_pins+1, 0)   @x_coords = Array.new($rows_of_pins) {Array.new}  @y_coords = Array.new($rows_of_pins)  stack(:width => $width) do    stroke gray    fill gray    1.upto($rows_of_pins) do |row|      y = 14 + 24*row      @y_coords[row-1] = y      row.times do |i|        x = $width / 2 + (i - 0.5*row)*24 + 14        @x_coords[row-1] << x        oval x+2, y, 6      end    end  end  @y_coords << @y_coords[-1] + 24  @x_coords << @x_coords[-1].map {|x| x-12} + [@x_coords[-1][-1]+12]   @balls = stack(:width => $width) do    stroke red    fill red  end.move(0,0)   @histogram = stack(:width => $width) do    nostroke    fill black  end.move(0, @y_coords[-1] + 10)   @paused = false  keypress do |key|    case key    when ""11"", :control_q      exit    when ""10"", :control_p      @paused =     end  end   @ball_row = 0  @ball_col = 0  animate(2*$rows_of_pins) do    if not @paused      y = @y_coords[@ball_row] - 12      x = @x_coords[@ball_row][@ball_col]      @balls.clear {oval x, y, 10}      @ball_row += 1      if @ball_row <= $rows_of_pins        @ball_col += 1 if rand >= 0.5      else        @bins[@ball_col] += 1        @ball_row = @ball_col = 0        update_histogram      end    end  end   def update_histogram    y = @y_coords[-1] + 10    @histogram.clear do      @bins.each_with_index do |num, i|        if num > 0          x = @x_coords[-1][i]          rect x-6, 0, 24, num        end      end    end  endend"
"$a = [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,      -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,      -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,      -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,      -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,       0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,       0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,       0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,       0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,       0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ] def gamma(x)  y = Float(x) - 1  1.0 / $a.reverse.inject {|sum, an| sum * y + an}end (1..10).each {|i| puts format(strv, gamma(i/3.0))}(1..10).each{|i| puts Math.gamma(i/3.0)}var a = [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,         -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,         -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,         -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,         -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,          0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,          0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,          0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,          0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,          0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ]; func gamma(x) {    var y = (x - 1);    1 / a.reverse.reduce {|sum, an| sum*y + an};} for i in 1..10 {    say (strv % gamma(i/3));}func gamma(z) {    var epsilon = 0.0000001    func withinepsilon(x) {        abs(x - abs(x)) <= epsilon    }     var p = [        676.5203681218851,     -1259.1392167224028,        771.32342877765313,    -176.61502916214059,        12.507343278686905,    -0.13857109526572012,        9.9843695780195716e-6,  1.5056327351493116e-7,    ]     var result;    z = Complex(z)    const pi = Complex.pi     if (z.real < 0.5) {        result = (pi / (sin(pi * z) * gamma(Complex(1) - z)))    }     else {        z -= 1        var x = 0.99999999999980993         p.each_kv { |i, v|            x += v/(z + i + 1)        }         var t = (z + p.len - 0.5)        result = (sqrt(pi*2) * t**(z+0.5) * exp(-t) * x)    }     withinepsilon(result.im) ? result.real : result} for i in 1..10 {    say (strv % gamma(i/3));}define e  = Math.e;define pi = Math.pi; func Γ(t) {    t < 20 ? (__FUNC__(t + 1) / t)           : (Math.sqrt(2*pi*t) * Math.pow(t/e + 1/(12*e*t), t) / t);} for i in 1..10 {    say (strv % Γ(i/3));}"
"require 'net/ftp' Net::FTP.open('ftp.ed.ac.uk', strv,"""" ) do |ftp|  ftp.passive = true  ftp.chdir('pub/courses')  ftp.list.each{|e| puts e}  ftp.getbinaryfile(strv)endrequire('Net::FTP'); var ftp = %s'Net::FTP'.new('ftp.ed.ac.uk', Passive => 1);ftp.login('anonymous',');ftp.cwd('pub/courses');[ftp.dir].each {|line| say line };ftp.binary;   
ftp.get(strv);ftp.quit;"
" require 'bigdecimal/ludcmp'include LUSolve BigDecimal::limit(30) a = [1.00, 0.00, 0.00, 0.00, 0.00, 0.00,     1.00, 0.63, 0.39, 0.25, 0.16, 0.10,     1.00, 1.26, 1.58, 1.98, 2.49, 3.13,     1.00, 1.88, 3.55, 6.70, 12.62, 23.80,     1.00, 2.51, 6.32, 15.88, 39.90, 100.28,     1.00, 3.14, 9.87, 31.01, 97.41, 306.02].map{|i|BigDecimal(i,16)}b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02].map{|i|BigDecimal(i,16)} n = 6zero = BigDecimal(strv)one  = BigDecimal(strv) lusolve(a, b, ludecomp(a, n, zero,one), zero).each{|v| puts v.to_s('F')[0..20]}var Matrix = require('Math::Matrix'); var a = Matrix.new([0,1,0],                   [0,0,1],                   [2,0,1]); var b = Matrix.new([1],                   [2],                   [4]); a.concat(b).solve.print;"
"
def reverse_domain(domain)  domain.sp­lit('.').r­everse.j­oin('.')end"
"require 'set' def translate2origin(poly)  
  minx = poly.map(&:first).min  miny = poly.map(&:last).min  poly.map{|x,y| [x - minx, y - miny]}.sortend def rotate90(x,y) [y, -x] enddef reflect(x,y)  [-x, y] end 
def rotations_and_reflections(poly)  [poly,   poly = poly.map{|x,y| rotate90(x,y)},   poly = poly.map{|x,y| rotate90(x,y)},   poly = poly.map{|x,y| rotate90(x,y)},   poly = poly.map{|x,y| reflect(x,y)},   poly = poly.map{|x,y| rotate90(x,y)},   poly = poly.map{|x,y| rotate90(x,y)},          poly.map{|x,y| rotate90(x,y)} ]end def canonical(poly)  rotations_and_reflections(poly).map{|pl| translate2origin(pl)}end 
def contiguous(x,y)  [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]end 
def new_points(poly)  points = []  poly.each{|x,y| contiguous(x,y).each{|point| points << point}}  (points - poly).uniqend def new_polys(polys)  pattern = Set.new  polys.each_with_object([]) do |poly, polyomino|    new_points(poly).each do |point|      next if pattern.include?(pl = translate2origin(poly + [point]))      polyomino << canonical(pl).each{|p| pattern << p}.min    end  endend 
def rank(n)  case n  when 0 then [[]]  when 1 then [[[0,0]]]  else        new_polys(rank(n-1))  endend 
def text_representation(poly)  table = Hash.new(' ')  poly.each{|x,y| table[[x,y]] = '#'}  maxx = poly.map(&:first).max  maxy = poly.map(&:last).max  (0..maxx).map{|x| (0..maxy).map{|y| table[[x,y]]}.join}end p (0..10).map{|n| rank(n).size}n = ARGV[0] ? ARGV[0].to_i : 5puts ""All free polyominoes of rank %d:"" % nrank(n).sort.each{|poly| puts text_representation(poly),strv}"
"def multiply(a, b)    a * bendfunc multiply(a, b) {    a * b;}"
"def compose(f,g)  lambda {|x| f[g[x]]}ends = compose(Math.method(:sin), Math.method(:cos))p s[0.5]  
 
p Math.sin(Math.cos(0.5))  
func compose(f, g) {    func(x) { f(g(x)) };};var fg = compose(func(x){Math.sin(x)}, func(x){Math.cos(x)});say fg(0.5);   
"
"str = %w[17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1]FractalProgram = str.map(&:to_r)                                #=> array of rationals Runner = Enumerator.new do |y|  num = 2  loop{ y << num *= FractalProgram.detect{|f| (num*f).denominator == 1} }end prime_generator = Enumerator.new do |y|   Runner.each do |num|    l = Math.log2(num)    y << l.to_i if l.floor == l  endend 
p Runner.take(20).map(&:numerator)p prime_generator.take(20)var str =strvconst FractalProgram = str.split(',').map{.num}      #=> array of rationals func runner(n, callback) {    var num = 2    n.times {        callback(num *= FractalProgram.find { |f| f * num -> is_int })    }} func prime_generator(n, callback) {    var x = 0;    runner(Inf, { |num|        var l = num.log2        if (l.floor == l) {            callback(l.int)            ++x == n && return nil        }    })} STDOUT.autoflush(true) runner(20, {|n| print (n, ' ') })print """" prime_generator(20, {|n| print (n, ' ') })print """""
"def floyd_warshall(n, edge)  dist = Array.new(n){|i| Array.new(n){|j| i==j ? 0 : Float::INFINITY}}  nxt = Array.new(n){Array.new(n)}  edge.each do |u,v,w|    dist[u-1][v-1] = w    nxt[u-1][v-1] = v-1  end   n.times do |k|    n.times do |i|      n.times do |j|        if dist[i][j] > dist[i][k] + dist[k][j]          dist[i][j] = dist[i][k] + dist[k][j]          nxt[i][j] = nxt[i][k]        end      end    end  end   puts strv  n.times do |i|    n.times do |j|      next  if i==j      u = i      path = [u]      path << (u = nxt[u][j])  while u != j      path = path.map{|u| u+1}.join(strv)      puts strv % [i+1, j+1, dist[i][j], path]    end  endend n = 4edge = [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]]floyd_warshall(n, edge)func floyd_warshall(n, edge) {    var dist = n.of { |i| n.of { |j| i == j ? 0 : Inf }}    var nxt  = n.of { n.of(nil) }    for u,v,w in edge {        dist[u-1][v-1] = w         nxt[u-1][v-1] = v-1    }     for k in ^n {        for i in ^n {            for j in ^n {                if (dist[i][j] > dist[i][k]+dist[k][j]) {                    dist[i][j] = dist[i][k]+dist[k][j]                     nxt[i][j] = nxt[i][k]                }            }        }    }     var summary = ""pair     dist    path""    for i in ^n {        for j in ^n {            i==j && next            var u = i            var path = [u]            while (u != j) {                path << (u = nxt[u][j])            }            path.map!{|u| u+1 }.join!(strv)            summary += (""%d -> %d  %4d     %s"" % (i+1, j+1, dist[i][j], path))        }    }     return summary} var n = 4var edge = [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]]print floyd_warshall(n, edge)"
"Shoes.app(:title => strv, :width => 600, :height => 600) do  background strv  stroke strv  @deg_to_rad = Math::PI / 180.0   def drawTree(x1, y1, angle, depth)    if depth != 0      x2 = x1 + (Math.cos(angle * @deg_to_rad) * depth * 10.0).to_i      y2 = y1 + (Math.sin(angle * @deg_to_rad) * depth * 10.0).to_i       line x1, y1, x2, y2       drawTree(x2, y2, angle - 20, depth - 1)      drawTree(x2, y2, angle + 20, depth - 1)          end  end   drawTree(300,550,-90,9)endfunc tree(img, x, y, scale=6/10, len=400, angle=270) {     len < 1 && return()     img.moveTo(x, y)    img.angle(angle)    img.line(len)     var (x1, y1) = img.curPos    tree(img, x1, y1, scale, len*scale, angle+35)    tree(img, x1, y1, scale, len*scale, angle-35)} require('GD::Simple') var (width=1000, height=1000)var img = %s|GD::Simple|.new(width, height)img.fgcolor('black')img.penSize(1, 1) tree(img, width/2, height) File('tree.png').write(img.png, :raw)"
"pid = forkif pid 
else 
endfork do  
end
var x = 42;{ x += 1; say x }.fork.wait;     
say x;                           
"
"r = 7.125printf "" %9.3f"",   r          #=>      7.125printf "" %09.3f"",  r          #=>  00007.125printf "" %09.3f"", -r          #=>  -0007.125printf "" %+09.3f"", r          #=>  +0007.125puts strv  %  r             #=>      7.125puts strv %  r             #=>  00007.125puts strv % -r             #=>  -0007.125puts strv % r             #=>  +0007.125printf(""%09.3f"", 7.125);say (strv % 7.125);"
"class Forest_Fire  Neighborhood = [-1,0,1].product([-1,0,1]) - [0,0]  States = {empty:strv, tree:strv, fire:strv}   def initialize(xsize, ysize=xsize, p=0.5, f=0.01)    @xsize, @ysize, @p, @f = xsize, ysize, p, f    @field = Array.new(xsize+1) {|i| Array.new(ysize+1, :empty)}    @generation = 0  end   def evolve    @generation += 1    work = @field.map{|row| row.map{|cell| cell}}    for i in 0...@xsize      for j in 0...@ysize        case [i][j]        when :empty          cell = :tree  if rand < @p        when :tree          cell = :fire  if fire?(i,j)        else          cell = :empty        end        work[i][j] = cell      end    end    @field = work  end   def fire?(i,j)    rand < @f or Neighborhood.any? {|di,dj| @field[i+di][j+dj] == :fire}  end   def display    puts ""Generation : ""    puts @xsize.times.map{|i| @ysize.times.map{|j| States[@field[i][j]]}.join}  endend forest = Forest_Fire.new(10,30)10.times do |i|  forest.evolve  forest.displayenddefine w = `tput cols`.to_i-1define h = `tput lines`.to_i-1define r = ""33[H"" define red = ""33[31m""define green = ""33[32m""define yellow = ""33[33m"" define chars = [' ', green+'*', yellow+'&', red+'&'] define tree_prob = 0.05define burn_prob = 0.0002 enum |Empty, Tree, Heating, Burning| define dirs = [    %n(-1 -1), %n(-1 0), %n(-1 1), %n(0 -1),    %n(0   1), %n(1 -1), %n(1  0), %n(1  1),] var forest = h.of { w.of { 1.rand < tree_prob ? Tree : Empty } } var range_h = h.rangevar range_w = w.range func iterate {    var new = h.of{ w.of(0) }    for i in range_h {        for j in range_w {            given (new[i][j] = forest[i][j]) {              when (Tree) {                1.rand < burn_prob && (new[i][j] = Heating; next)                dirs.each { |pair|                    var y = pair[0]+i                    range_h.contains(y) || next                    var x = pair[1]+j                    range_w.contains(x) || next                    forest[y][x] == Heating && (new[i][j] = Heating; break)                }              }              when (Heating)            { new[i][j] = Burning }              when (Burning)            { new[i][j] = Empty   }              case (1.rand < tree_prob) { new[i][j] = Tree    }            }        }    }    forest = new} STDOUT.autoflush(true) func init_forest {    print r    forest.each { |row|        print chars[row]        print ""33[E33[1G""    }    iterate()} loop { init_forest() }define RED = ""[1;31m""define YELLOW = ""[1;33m""define GREEN = ""[1;32m"" define DIRS = [    [-1, -1], [0, -1], [1, -1],    [-1,  0],          [1,  0],    [-1,  1], [0,  1], [1,  1],] enum (Empty, Tree, Heating, Burning)define pix = [' ', GREEN + strv, YELLOW + strv, RED + strv] class Forest(p=0.01, f=0.001, height, width) {     has coords = []    has spot = []    has neighbors = []     method init {        coords = (0..height ~X 0..width)        spot = height.of { width.of { [true, false].pick ? Tree : Empty } }        self.init_neighbors    }     method init_neighbors {        for i,j in coords {            neighbors[i][j] = gather {                for dir in DIRS {                    take(\(spot[i + dir[0]][j + dir[1]] \\ next))                 }            }        }    }     method step {        var heat = []         for i,j in coords {            given (spot[i][j]) {                when Empty   { spot[i][j] = Tree    if (1.rand < p) }                when Tree    { spot[i][j] = Heating if (1.rand < f) }                when Heating { spot[i][j] = Burning; heat << [i, j] }                when Burning { spot[i][j] = Empty }            }        }         for i,j in heat {            neighbors[i][j].each { |ref|                *ref = Heating if (*ref == Tree)            }        }    }     method show {        for i in ^height {            say pix[spot[i]]        }    }} STDOUT.autoflush(true)var(height, width) = `stty size`.nums.map{.dec}... var forest = Forest(height: height, width: width)print ""[2J"" loop {    print ""[H""    forest.show    forest.step}"
"def dif(s)  s.each_cons(2).collect { |x, y| y - x }end def difn(s, n)  n.times.inject(s) { |s, | dif(s) }endp dif([1, 23, 45, 678])      
p difn([1, 23, 45, 678], 2)  
func dif(arr) {    gather {        range(0, arr.end-1).each { |i|            take(arr[i+1] - arr[i]);        }    }} func difn(n, arr) {    n.times { arr = dif(arr) };    arr;} say dif([1, 23, 45, 678]);       
say difn(2, [1, 23, 45, 678]);   
"
"
def four_bit_adder(a, b)  a_bits = binary_string_to_bits(a,4)  b_bits = binary_string_to_bits(b,4)   s0, c0 = full_adder(a_bits[0], b_bits[0],  0)  s1, c1 = full_adder(a_bits[1], b_bits[1], c0)  s2, c2 = full_adder(a_bits[2], b_bits[2], c1)  s3, c3 = full_adder(a_bits[3], b_bits[3], c2)   [bits_to_binary_string([s0, s1, s2, s3]), c3.to_s]end 
def full_adder(a, b, c0)  s, c = half_adder(c0, a)  s, c1 = half_adder(s, b)  [s, _or(c,c1)]end 
def half_adder(a, b)  [xor(a, b), _and(a,b)]end def xor(a, b)  _or(_and(a, _not(b)), _and(_not(a), b))end 
def _and(a, b)  a & b  enddef _or(a, b)   a | b  enddef _not(a)    ~a & 1  end def int_to_binary_string(n, length)  strv % nend def binary_string_to_bits(s, length)  (strv % s).reverse.chars.map(&:to_i)end def bits_to_binary_string(bits)  bits.map(&:to_s).reverse.joinend puts strv 0.upto(15) do |a|  0.upto(15) do |b|    bin_a = int_to_binary_string(a, 4)    bin_b = int_to_binary_string(b, 4)    sum, carry = four_bit_adder(bin_a, bin_b)    puts strv %         [a, b, bin_a, bin_b, carry, sum, (carry + sum).to_i(2)]  endendfunc bxor(a, b) {  (~a & b) | (a & ~b)} func half_adder(a, b) {  return (bxor(a, b), a & b)} func full_adder(a, b, c) {  var (s1, c1) = half_adder(a, c)  var (s2, c2) = half_adder(s1, b)  return (s2, c1 | c2)} func four_bit_adder(a, b) {  var (s0, c0) = full_adder(a[0], b[0], 0)  var (s1, c1) = full_adder(a[1], b[1], c0)  var (s2, c2) = full_adder(a[2], b[2], c1)  var (s3, c3) = full_adder(a[3], b[3], c2)  return ([s3,s2,s1,s0].join, c3.to_s)} say strvfor a in ^16 {  for b in ^16 {    var(abin, bbin) = [a,b].map{|n| strv%n->chars.reverse.map{.to_i} }...    var(s, c) = four_bit_adder(abin, bbin)    printf(""%2d + %2d = %s + %s = %s %s = %2d"",        a, b, abin.join, bbin.join, c, s, strv.bin)    }}"
"def floyd(rows)  max = (rows * (rows + 1)) / 2  widths = ((max - rows + 1)..max).map {|n| n.to_s.length + 1}  n = 0  rows.times do |r|    puts (0..r).map {|i| n += 1; strv % n}.join  endend floyd(5)floyd(14)func floyd(rows, n=1) {    var max = Math.range_sum(1, rows);    var widths = (max-rows .. max-1 -> map{(.+n).to_s.len});    { |r|        say %'#{1..r -> map{|i| strv)}';    } * rows;} floyd(5);     
floyd(14);    
"
"begin  
rescue ExceptionClassA => a  
rescue ExceptionClassB, ExceptionClassC => b_or_c  
rescue  
else  
ensure  
endvalues = [strv, strv, /pattern/]result = values.map {|v| Integer(v) rescue Float(v) rescue String(v)}
def some_method  
  if some_condition    throw :get_me_out_of_here  end  
end catch :get_me_out_of_here do  for ...    for ...      some_method    end  endend puts strv"
"class FlipBoard  def initialize(size)    raise ArgumentError.new(strv) if size < 2     @size = size    @board = Array.new(size**2, 0)     randomize_board    loop do      @target = generate_target      break unless solved?    end      
    @columns = [*'a'...('a'.ord+@size).chr]    @rows = (1..@size).map(&:to_s)  end   ############################################################   def play    moves = 0    puts strv, target     until solved?       puts strv, strv, self      print strv      ans = $stdin.gets.strip       if @columns.include? ans        flip_column @columns.index(ans)        moves += 1      elsif @rows.include? ans        flip_row @rows.index(ans)        moves += 1      else        puts strv + ans      end    end     puts strv, strv, self  end   
  def target    format_array @target  end   
  def to_s    format_array @board  end   ############################################################  private   def solved?    @board == @target  end   
  def randomize_board    (@size + rand(@size)).times do      flip_bit rand(@size), rand(@size)    end  end   
  def generate_target    orig_board = @board.clone    (@size + rand(@size)).times do       rand(2).zero? ? flip_row( rand(@size) ) : flip_column( rand(@size) )    end    target, @board = @board, orig_board    target  end   def flip_row(row)    @size.times {|col| flip_bit(row, col)}  end   def flip_column(col)    @size.times {|row| flip_bit(row, col)}  end   def flip_bit(row, col)    @board[@size * row + col] ^= 1  end   def format_array(ary)    str = strv + @columns.join(strv) + """"    @size.times do |row|      str << strv % @rows[row] + ary[@size*row, @size].join(strv) + """"    end    str  endend ######################################################################begin  FlipBoard.new(ARGV.shift.to_i).playrescue => e  puts e.messageend"
"require 'date'

 dates = []1900.upto(2100) do |year|  1.upto(12) do |month|    d = Date.new(year, month, -1) 
    dates << d if d.sunday? && d.day == 31  endend puts strvputs dates.first(5).map { |d| d.strftime(strv) }puts strvputs dates.last(5).map { |d| d.strftime(strv) } years_with_5w = dates.map(&:year) years = (1900..2100).to_a - years_with_5w puts strvputs years.join(strv)require('DateTime'); var happymonths = [];var workhardyears = [];var longmonths = [1, 3, 5, 7, 8, 10, 12]; range(1900, 2100).each { |year|   var countmonths = 0;   longmonths.each { |month|        var dt = %s'DateTime'.new(            year => year,            month => month,            day   => 1        );         if (dt.day_of_week == 5) {            countmonths++;            var yearfound = dt.year;            var monthfound = dt.month_name;            happymonths.append(join(strv, yearfound, monthfound));      }   }     if (countmonths == 0) {        workhardyears.append(year);    }} say strv;say strv;say happymonths.first(5).join("""");say happymonths.last(5).join("""");say strv;say workhardyears.join(strv);"
"
envs = (1..12).map do |n|  Object.new.instance_eval {@n = n; @cnt = 0; self}end 
until envs.all? {|e| e.instance_eval{@n} == 1}  envs.each do |e|    e.instance_eval do          
      printf strv, @n      if @n > 1        @cnt += 1               
        @n = if @n.odd?         
               @n * 3 + 1             else               @n / 2             end      end    end  end  putsendputs '=' * 48envs.each do |e|                
  e.instance_eval do    printf strv, @cnt          
  endendputs
envs = (1..12).map do |n|  e = class Object        
        
        binding      end  eval(<<-EOS, e).call(n)    n, cnt = nil, 0    proc {|arg| n = arg}  EOS  eend 
until envs.all? {|e| eval('n == 1', e)}  envs.each do |e|    eval(<<-EOS, e)           
      printf strv, n      if n > 1        cnt += 1              
        n = if n.odd?         
              n * 3 + 1            else              n / 2            end      end    EOS  end  putsendputs '=' * 48envs.each do |e|                
  eval('printf strv, cnt', e)  
endputsfunc calculator({.is_one}   ) { 1 }func calculator(n {.is_even}) { n / 2 }func calculator(n           ) { 3*n + 1 } func succ(this {_{:value}.is_one}, _) {    return this} func succ(this, get_next) {    this{:value} = get_next(this{:value})    this{:count}++    return this} var enviornments = (1..12 -> map {|i| Hash(value => i, count => 0) }); while (!enviornments.map{ _{:value} }.all { .is_one }) {    say enviornments.map {|h| strv % h{:value} }.join;    enviornments.range.each { |i|        enviornments[i] = succ(enviornments[i], calculator);    }} say 'Counts';say enviornments.map{ |h| strv % h{:count} }.join;"
"multiplier = proc {|n1, n2| proc {|m| n1 * n2 * m}}numlist = [x=2, y=4, x+y]invlist = [0.5, 0.25, 1.0/(x+y)]p numlist.zip(invlist).map {|n, invn| multiplier[invn, n][0.5]}
func multiplier(n1, n2) {    func (n3) {        n1 * n2 * n3;    }} var x  = 2.0;var xi = 0.5;var y  = 4.0;var yi = 0.25;var z  = (x + y);var zi = (1 / (x + y)); var numbers = [x, y, z];var inverses = [xi, yi, zi]; numbers.pair_with(inverses).each { |g, f|    say multiplier(g, f)(0.5);}"
"flat = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []].flattenp flat  
p flatten_once = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []].flatten(1)
 func flatten(a) {    var flat = [];    a.each { |item|        flat += (item.is_an(Array) ? flatten(item) : [item]);    };    return flat;} var arr = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []];say flatten(arr).dump;      
say arr.flatten.dump;       
"
" require  'uri' str = 'this URI contains an illegal character, parentheses and a misplaced full stop:
http://en.wikipedia.org/wiki/Erich_Kästner_(camera_designer). (which is handled by http://mediawiki.org/).
and another one just to confuse the parser: http://en.wikipedia.org/wiki/-)
strv is handled the wrong way by the mediawiki parser.
ftp://domain.name/path(balanced_brackets)/foo.html
ftp://domain.name/path(balanced_brackets)/ending.in.dot.
ftp://domain.name/path(unbalanced_brackets/ending.in.dot.
leading junk ftp://domain.name/path/embedded?punct/uation.
leading junk ftp://domain.name/dangling_close_paren)
if you have other interesting URIs for testing, please add them here:'  puts URI.extract(str)  puts ""Filtered for HTTP and HTTPS:""puts URI.extract(str, [strv, strv]) puts ""This is the (extendible) list of supported schemes: #{URI.scheme_list.keys}"""
"cube = proc{|x| x ** 3}croot = proc{|x| x ** (1.quo 3)}compose = proc {|f,g| proc {|x| f[g[x]]}}funclist = [Math.method(:sin), Math.method(:cos), cube]invlist = [Math.method(:asin), Math.method(:acos), croot] puts funclist.zip(invlist).map {|f, invf| compose[invf, f][0.5]}func compose(f,g) {    func (*args) {        f(g(args...));    }} var cube  = func(a) { a.pow(3) };var croot = func(a) { a.root(3) }; var flist1 = [Math.method(:sin), Math.method(:cos), cube];var flist2 = [Math.method(:asin), Math.method(:acos), croot]; flist1.range.each { |i|    say compose(flist1[i], flist2[i])(0.5);}"
"require 'date' def last_sundays_of_year(year = Date.today.year)  (1..12).map do |month|    d = Date.new(year, month, -1) 
    d - d.wday  endend puts last_sundays_of_year(2013)var dt = require('DateTime');var (year=2016) = ARGV.map{.to_i}... for i in (1 .. 12) {    var date = dt.last_day_of_month(        year  => year,        month => i    );     while (date.dow != 7) {        date = date.subtract(days => 1);    }     say date.ymd;}"
"pal23 = Enumerator.new do |y|  y << 0  y << 1  for i in 1 .. 1.0/0.0                 
    n3 = i.to_s(3)    n = (n3 + strv + n3.reverse).to_i(3)    n2 = n.to_s(2)    y << n  if n2.size.odd? and n2 == n2.reverse  endend puts strv6.times do |i|  n = pal23.next  puts strv % [i, n, n.to_s(3).center(25), n.to_s(2).center(39)]endvar format = ""%11s %24s %38s""format.printf(strv, strv, strv)format.printf(0, 0, 0) for n in (0 .. 2e5) {    var pal = n.base(3)||''    var b3 = (pal + '1' + pal.flip)    var b2 = Num(b3, 3).base(2)    if (b2 == b2.flip) {        format.printf(Num(b2, 2), b3, b2)    }}"
"require 'digest/md5' def find_duplicate_files(dir)  puts ""Directory : #{dir}""  Dir.chdir(dir) do    file_size = Dir.foreach('.').select{|f| FileTest.file?(f)}.group_by{|f| File.size(f)}    file_size.each do |size, files|      next if files.size==1      files.group_by{|f| Digest::MD5.file(f).to_s}.each do |md5,fs|        next if fs.size==1        puts strv        fs.each{|file| puts strv}      end    end  endend find_duplicate_files(strv)
 require('File::Find') func find_duplicate_files(Block code, size_min=0, *dirs) {    var files = Hash()    %S<File::Find>.find(        Hash(            no_chdir => true,            wanted   => func(arg) {                var file = File(arg)                file.is_file || return()                file.is_link && return()                var size = file.size                size >= size_min || return()                files{size} := [] << file            },        ) => dirs...    )     files.values.each { |set|        set.len > 1 || next        var dups = Hash()        for i in (^set.end) {            for (var j = set.end; j > i; --j) {                if (set[i].compare(set[j]) == 0) {                    dups{set[i]} := [] << set.pop_at(j++)                }            }        }        dups.each{ |k,v| code(k.to_file, v...) }    }     return()} var duplicates = Hash()func collect(*files) {    duplicates{files[0].size} := [] << files} find_duplicate_files(collect, Num(ARGV.shift), ARGV...) for k,v in (duplicates.sort_by { |k| -k.to_i }) {    say ""=> Size: #{k}#{'~'*80}""    for files in v {        say ""#{files.sort.join(%Q[])}#{'-'*80}""    }}"
"def msb(x)  x.to_s(2).size - 1end def lsb(x)  msb(x & -x)end for i in 0...6  x = 42 ** i  puts strv % [x, msb(x), lsb(x)]end for i in 0...6  x = 1302 ** i  puts strv % [x, msb(x), lsb(x)]endfunc msb(n) {    var b = 0    while(n >>= 1) { ++b }    return b} func lsb(n) {    msb(n & -n)}func table (base,power) {    var digits = length(base**power)    printf(""%#{digits}s  lsb msb"", 'number')    for n in (0..power) {        var x = base**n        printf(""%#{digits}s  %2s  %3s"", x, lsb(x), msb(x))    }} table(42, 20)table(1302, 20)"
def recurse x  puts x  recurse(x+1)end recurse(0)def recurse n  recurse(n+1)rescue SystemStackError  nend puts recurse(0)func recurse(n) {   say n;   recurse(n+1);} recurse(0);
"given = %w{  ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA  CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB} all = given[0].chars.permutation.collect(&:join) puts strvfunc check_perm(arr) {    (var hash = Hash.new).@{arr} = @[1]*arr.len;    arr.each { |s|        s.len.times {            var t = (s.substr(1) + s.substr(0, 1));            hash.has_key(t) || return t;        }    }} var perms = %w(ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA               CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB); say check_perm(perms);"
"require 'abbrev' dirs = %w( /home/user1/tmp/coverage/test /home/user1/tmp/covert/operator /home/user1/tmp/coven/members ) common_prefix = dirs.abbrev.keys.min_by {|key| key.length}.chop  
common_directory = common_prefix.sub(%r{/[^/]*$}, '')            
separator = '/'path0, *paths = dirs.collect {|dir| dir.split(separator)}uncommon_idx = path0.zip(*paths).index {|dirnames| dirnames.uniq.length > 1}uncommon_idx = path0.length  unless uncommon_idx                
common_directory = path0[0...uncommon_idx].join(separator)      
def common_directory_path(dirs, separator='/')  dir1, dir2 = dirs.minmax.map{|dir| dir.split(separator)}  dir1.zip(dir2).take_while{|dn1,dn2| dn1==dn2}.map(&:first).join(separator)end p common_directory_path(dirs)           #=> strvvar dirs = %w(    /home/user1/tmp/coverage/test    /home/user1/tmp/covert/operator    /home/user1/tmp/coven/members); var unique_pref = dirs.map{.split('/')}.abbrev.min_by{.len};var common_dir  = [unique_pref, unique_pref.pop][0].join('/');say common_dir;   
"
"1.upto(100) do |v|  p fizz_buzz(v)end def fizz_buzz(value)  word = strv  word += strv if value % 3 == 0  word += strv if value % 5 == 0  word += value.to_s if word.empty?  wordend1.upto(100) do |n|  print strv if a = (n % 3).zero?  print strv if b = (n % 5).zero?  print n unless (a || b)  putsend(1..100).each do |n|  puts if (n % 15).zero?    strv  elsif (n % 5).zero?    strv  elsif (n % 3).zero?    strv  else    n  endend class Enumerator::Lazy  def filter_map    Lazy.new(self) do |holder, *values|      result = yield *values      holder << result if result    end  endend class Fizz  def initialize(head, tail)    @list = (head..Float::INFINITY).lazy.filter_map{|i| i if i % 3 == 0}.first(tail)  end   def fizz?(num)    search = @list    search.include?(num)  end   def drop(num)    list = @list    list.delete(num)  end   def to_a    @list.to_a  endend class Buzz  def initialize(head, tail)    @list = (head..Float::INFINITY).lazy.filter_map{|i| i if i % 5 == 0}.first(tail)  end   def buzz?(num)    search = @list    search.include?(num)  end   def drop(num)    list = @list    list.delete(num)  end   def to_a    @list.to_a  endend class FizzBuzz  def initialize(head, tail)    @list = (head..Float::INFINITY).lazy.filter_map{|i| i if i % 15 == 0}.first(tail)  end   def fizzbuzz?(num)    search = @list    search.include?(num)  end   def to_a    @list.to_a  end   def drop(num)    list = @list    list.delete(num)  endendstopper = 100@fizz = Fizz.new(1,100)@buzz = Buzz.new(1,100)@fizzbuzz = FizzBuzz.new(1,100)def min(v, n)  if v == 1    puts strv    @fizz::drop(n)  elsif v == 2    puts strv    @buzz::drop(n)  else    puts strv    @fizzbuzz::drop(n)  endend(@fizz.to_a & @fizzbuzz.to_a).map{|d| @fizz::drop(d)}(@buzz.to_a & @fizzbuzz.to_a).map{|d| @buzz::drop(d)}while @fizz.to_a.min < stopper or @buzz.to_a.min < stopper or @fizzbuzz.to_a.min < stopper  f, b, fb = @fizz.to_a.min, @buzz.to_a.min, @fizzbuzz.to_a.min  min(1,f)  if f < fb and f < b  min(2,b)  if b < f and b < fb  min(0,fb) if fb < b and fb < fend(1..100).each do |n|  v = strvFizzstrvBuzzstrv  puts v.empty? ? n : vend1.upto(100) { |n| puts strv }1.upto 100 do |n|  r = ''  r << 'Fizz' if n % 3 == 0  r << 'Buzz' if n % 5 == 0  r << n.to_s if r.empty?  puts rend1.upto(100){|i|puts'FizzBuzz '[n=i**4%-15,n+13]||i}f = [nil, nil, :Fizz].cycleb = [nil, nil, nil, nil, :Buzz].cycle(1..100).each do |i|  puts strv[/.+/] || iendseq = *0..100{Fizz:3, Buzz:5, FizzBuzz:15}.each{|k,n| n.step(100,n){|i|seq[i]=k}}puts seq.drop(1)class Integer  def fizzbuzz    v = strvFizzstrvBuzzstrv    v.empty? ? self : v  endend puts *(1..100).map(&:fizzbuzz)fizzbuzz = ->(i) do  (i%15).zero? and next strv  (i%3).zero?  and next strv  (i%5).zero?  and next strv  iend puts (1..100).map(&fizzbuzz).join("""") require 'fizzbuzz' describe 'FizzBuzz' do  context 'knows that a number is divisible by' do    it '3' do      expect(is_divisible_by_three?(3)).to be_true    end    it '5' do      expect(is_divisible_by_five?(5)).to be_true    end    it '15' do      expect(is_divisible_by_fifteen?(15)).to be_true    end  end  context 'knows that a number is not divisible by' do    it '3' do      expect(is_divisible_by_three?(1)).not_to be_true    end    it '5' do      expect(is_divisible_by_five?(1)).not_to be_true    end    it '15' do      expect(is_divisible_by_fifteen?(1)).not_to be_true    end  end  context 'while playing the game it returns' do    it 'the number' do      expect(fizzbuzz(1)).to eq 1    end    it 'Fizz' do      expect(fizzbuzz(3)).to eq 'Fizz'    end    it 'Buzz' do      expect(fizzbuzz(5)).to eq 'Buzz'    end    it 'FizzBuzz' do      expect(fizzbuzz(15)).to eq 'FizzBuzz'    end  endend  def fizzbuzz(number)  return 'FizzBuzz' if is_divisible_by_fifteen?(number)  return 'Buzz' if is_divisible_by_five?(number)  return 'Fizz' if is_divisible_by_three?(number)  numberend def is_divisible_by_three?(number)  is_divisible_by(number, 3)end def is_divisible_by_five?(number)  is_divisible_by(number, 5)end def is_divisible_by_fifteen?(number)  is_divisible_by(number, 15)end def is_divisible_by(number, divisor)  number % divisor == 0end  { |i|    if (i %% 3) {        print strv        i %% 5 && print strv        print """"    }    elsif (i %% 5) { say strv }    else  { say i }} * 100func fizzbuzz({ _ %% 15 }) { strv }func fizzbuzz({ _ %%  5 }) {     strv }func fizzbuzz({ _ %%  3 }) {     strv }func fizzbuzz(        n  ) {          n } for n in (1..100) { say fizzbuzz(n) }{|i|say strv||i}*100"
"
ary = [1, 2, 3, 4, 5, 6]even_ary = ary.select {|elem| elem.even?}p even_ary 
 
range = 1..6even_ary = range.select {|elem| elem.even?}p even_ary 


unless Integer.method_defined? :even?  class Integer    def even?      self % 2 == 0    end  endendary = [1, 2, 3, 4, 5, 6]ary.select! {|elem| elem.even?}p ary 


unless Array.method_defined? :select!  class Array    def select!      enum_for(:select!) unless block_given?      delete_if { |elem| not yield elem }      self    end  endendvar arr = [1,2,3,4,5]; 
var new = arr.grep {|i| i %% 2};say new.dump;     
 
arr.grep! {|i| i %% 2};say arr.dump;    
"
" 
#

#require 'prime'BASE = 3MAX = 500stems = Prime.each(BASE-1).to_a(1..MAX-1).each {|i|  print strv  t = []  b = BASE ** i  stems.each {|z|    (1..BASE-1).each {|n|      c = n*b+z      t.push(c) if c.prime?  }}  break if t.empty?  stems = t}puts strvless than #{BASE ** MAX} strv  
#

#require 'prime'require 'java'BASE = 10MAX = 500stems = Prime.each(BASE-1).to_a(1..MAX-1).each {|i|  print strv  t = []  b = BASE ** i  stems.each {|z|    (1..BASE-1).each {|n|      c = n*b+z      t.push(c) if java.math.BigInteger.new(c.to_s).isProbablePrime(100)  }}  break if t.empty?  stems = t}puts ""The largest left truncatable prime #{""less than #{BASE ** MAX} strv func primes(n) {    var (i, j) = (0, 0)    gather {        loop {            i = j.next_prime            i <= n || break            take(i)            j = i        }    }} func lltp(n) {    var b = 1    var best = nil    var v = primes(n-1)     while (v) {        best = v.max        b *= n        v = gather {            v.each { |vi|                take((n-1).of { |i| i*b + vi }.grep{.is_prime}...)            }        }    }     return best} for i in (3..17) {    printf(""%2d %s"", i, lltp(i))}"
"#Get modification time:modtime = File.mtime('filename') #Set the access and modification times:File.utime(actime, mtime, 'path') #Set just the modification time:File.utime(File.atime('path'), mtime, 'path') #Set the access and modification times to the current time:File.utime(nil, nil, 'path')var file = File.new(__FILE__);say file.stat.mtime;            
 

file.utime(file.stat.atime, Time.now);"
size = File.size('input.txt')size = File.size('/input.txt')say (Dir.cwd  + %f'input.txt' -> size);say (Dir.root + %f'input.txt' -> size);
"extensions = [strv,strv,strv][strv,strv,strv,strv].each do |f|  puts strv % [extensions.include?( File.extname(f).downcase ), f]endfunc check_extension(filename, extensions) {    filename ~~ Regex('(' + extensions.map { .escape }.join('|') + ')', :i)}var extensions = ['zip', 'rar', '7z', 'gz', 'archive', 'A##', 'tar.bz2'] var files = [    'MyData.a##', 'MyData.tar.Gz', 'MyData.gzip', 'MyData.7z.backup',    'MyData...', 'MyData', 'MyData_v1.0.tar.bz2', 'MyData_v1.0.bz2'] for file in files {    printf(""%-19s - %s"", file, check_extension(file, extensions))}"
"#encoding: ASCII-8BIT def entropy(s)  counts = Hash.new(0.0)  s.each_char { |c| counts[c] += 1 }  leng = s.length   counts.values.reduce(0) do |entropy, count|    freq = count / leng    entropy - freq * Math.log2(freq)  endend n_max = 37words = ['1', '0'] for n in words.length ... n_max  words << words[-1] + words[-2]end puts '%3s %9s %15s  %s' % %w[N Length Entropy Fibword]words.each.with_index(1) do |word, i|  puts '%3i %9i %15.12f  %s' % [i, word.length, entropy(word), word.length<60 ? word : '<too long>']endfunc entropy(s) {    [0] + (s.chars.freq.values »/» s.len) -> reduce { |a,b|        a - b*b.log2    }} var n_max = 37var words = ['1', '0'] {    words.append(words[-1] + words[-2])} * (n_max - words.len) say ('%3s %10s %15s  %s' % <N Length Entropy Fibword>...) for i in ^words {    var word = words[i]    say ('%3i %10i %15.12f  %s' % (i+1,                                   word.len,                                   entropy(word),                                   word.len<30 ? word : '<too long>'))}"
"str = File.open('input.txt', 'rb') {|f| f.read}File.open('output.txt', 'wb') {|f| f.write str}

str = IO.read('input.txt')open('output.txt', 'w') {|f| f.write str}require 'fileutils'FileUtils.copy_file 'input.txt', 'output.txt'var in = %f'input.txt'.open_r;var out = %f'output.txt'.open_w; in.each { |line|    out.print(line);};"
"def fasta_format(strings)  out, text = [], strv  strings.split("""").each do |line|    if line[0] == '>'      out << text unless text.empty?      text = line[1..-1] + strv    else      text << line    end  end  out << text unless text.empty?end data = <<'EOS'>Rosetta_Example_1THERECANBENOSPACE>Rosetta_Example_2THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATEDEOS puts fasta_format(data)func fasta_format(strings) {    var out = []    var text = ''    for line in (strings.lines) {        if (line.begins_with('>')) {            text.len && (out << text)            text = line.substr(1)+': '        }        else {            text += line        }    }    text.len && (out << text)    return out} fasta_format(DATA.slurp).each { .say } __DATA__>Rosetta_Example_1THERECANBENOSPACE>Rosetta_Example_2THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED"
"def fibonacci_word(n)  words = [strv, strv]  (n-1).times{ words << words[-1] + words[-2] }  words[n]end def print_fractal(word)  area = Hash.new(strv)  x = y = 0  dx, dy = 0, -1  area[[x,y]] = strv  word.each_char.with_index(1) do |c,n|    area[[x+dx, y+dy]] = dx.zero? ? strv : strv    x, y = x+2*dx, y+2*dy    area[[x, y]] = strv    dx,dy = n.even? ? [dy,-dx] : [-dy,dx]  if c==strv  end   (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)  for y in ymin..ymax    puts (xmin..xmax).map{|x| area[[x,y]]}.join  endend word = fibonacci_word(16)print_fractal(word)var(m=17, scale=3) = ARGV.map{.to_i}... (var world = Hash.new){0}{0} = 1var loc = Complex(0, 0)var dir = Complex.i var fib = ['1', '0']func fib_word(n) {    fib[n] \\= (fib_word(n-1) + fib_word(n-2))} func step {    scale.times {        loc += dir        world{loc.im}{loc.re} = 1    }} func turn_left  { dir *=  Complex.i }func turn_right { dir *= -Complex.i } var n = 1fib_word(m).each_char { |c|    if (c == '0') {        step()        n % 2 == 0 ? turn_left()                   : turn_right()    } else { n++ }} func braille_graphics(a) {    var (xlo, xhi, ylo, yhi) = +([Inf, -Inf]*2)...     a.each_key { |y|        ylo.min!(y.to_i)        yhi.max!(y.to_i)        a{y}.each_key { |x|            xlo.min!(x.to_i)            xhi.max!(x.to_i)        }    }     for y in (ylo .. (yhi, 4)) {        for x in (xlo .. (xhi, 2)) {            var cell = 0x2800             a{y+0}{x+0} && (cell += 1)            a{y+1}{x+0} && (cell += 2)            a{y+2}{x+0} && (cell += 4)            a{y+0}{x+1} && (cell += 8)            a{y+1}{x+1} && (cell += 16)            a{y+2}{x+1} && (cell += 32)            a{y+3}{x+0} && (cell += 64)            a{y+3}{x+1} && (cell += 128)             print cell.chr        }        print """"    }} braille_graphics(world)"
"def fft(x : Array(Float64)) : Array(Complex)  return [x[0].to_c] if x.size <= 1  even = fft(Array.new(x.size / 2) { |k| x[2 * k] })  odd = fft(Array.new(x.size / 2) { |k| x[2 * k + 1] })  c = Array.new(x.size / 2) { |k| Complex.new(0, -2 * Math::PI * k / x.size).exp }  codd = Array.new(x.size / 2) { |k| c[k] * odd[k] }  return Array.new(x.size / 2) { |k| even[k] + codd[k] } + Array.new(x.size / 2) { |k| even[k] - codd[k] }enddef fft(vec)  return vec if vec.size <= 1  evens_odds = vec.partition.with_index{|_,i| i.even?}  evens, odds = evens_odds.map{|even_odd| fft(even_odd)*2}   evens.zip(odds).map.with_index do |(even, odd),i|    even + odd * Math::E ** Complex(0, -2 * Math::PI * i / vec.size)  endend fft([1,1,1,1,0,0,0,0]).each{|c| puts strv % c.rect}func fft(arr) {    arr.len == 1 && return arr     var evn = fft([arr[^arr -> grep { .is_even }]])    var odd = fft([arr[^arr -> grep { .is_odd  }]])    var twd = (Num.tau.i / arr.len)     ^odd -> map {|n| odd[n] *= ::exp(twd * n)}    (evn »+« odd) + (evn »-« odd)} var cycles = 3var sequence = 0..15var wave = sequence.map {|n| ::sin(n * Num.tau / sequence.len * cycles) }say strvsay strv"
"def farey(n, length=false)  if length    (n*(n+3))/2 - (2..n).inject(0){|sum,k| sum + farey(n/k, true)}  else    (1..n).each_with_object([]){|k,a|(0..k).each{|m|a << Rational(m,k)}}.uniq.sort  endend puts 'Farey sequence for order 1 through 11 (inclusive):'for n in 1..11  puts strv + farey(n).join(strv)endputs 'Number of fractions in the Farey sequence:'for i in (100..1000).step(100)  puts strv % [i, farey(i, true)]endfunc farey_count(n) {    (n*(n+3))//2 - (2..n -> sum_by {|k| farey_count(n//k) })} func farey(n) {    gather {        1..n -> each {|k| 0..k -> each {|m| take(m/k) }}    }.uniq.sort} say 'Farey sequence for order 1 through 11 (inclusive):'for n in (1..11) {    say(strv % (n, farey(n).map{.as_frac}.join(strv)))} say 'Number of fractions in the Farey sequence:'for i in (100..1000 -> by(100)) {    say (strv % (i, farey_count(i)))}"
"def anynacci(start_sequence, count)  n = start_sequence.length    
  result = start_sequence.dup  
   (n+1..count).each do         
    result << result.last(n).reduce(:+)    
  end   result                       
end naccis = { lucus:      [2,1],           fibonacci:  [1,1],           tribonacci: [1,1,2],           tetranacci: [1,1,2,4],           pentanacci: [1,1,2,4,8],           hexanacci:  [1,1,2,4,8,16],           heptanacci: [1,1,2,4,8,16,32],           octonacci:  [1,1,2,4,8,16,32,64],           nonanacci:  [1,1,2,4,8,16,32,64,128],           decanacci:  [1,1,2,4,8,16,32,64,128,256] } def print_nacci(naccis, count=15)  puts naccis.map {|name, seq| strv % [name, anynacci(seq, count)]}end print_nacci(naccis)       lucus : [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322, 521, 843]   fibonacci : [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]  tribonacci : [1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136]  tetranacci : [1, 1, 2, 4, 8, 15, 29, 56, 108, 208, 401, 773, 1490, 2872, 5536]  pentanacci : [1, 1, 2, 4, 8, 16, 31, 61, 120, 236, 464, 912, 1793, 3525, 6930]   hexanacci : [1, 1, 2, 4, 8, 16, 32, 63, 125, 248, 492, 976, 1936, 3840, 7617]  heptanacci : [1, 1, 2, 4, 8, 16, 32, 64, 127, 253, 504, 1004, 2000, 3984, 7936]   octonacci : [1, 1, 2, 4, 8, 16, 32, 64, 128, 255, 509, 1016, 2028, 4048, 8080]   nonanacci : [1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 511, 1021, 2040, 4076, 8144]   decanacci : [1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1023, 2045, 4088, 8172] func fib(n, xs=[1]) {    loop {        var len = xs.len        len >= 20 && break        xs.append(xs.ft(0.max(len - n)).sum)    }    return xs} for i in (2..10) {    say fib(i).join(' ')}say fib(2, [2, 1]).join(' ')"
"require 'prime' def mersenne_factor(p)  limit = Math.sqrt(2**p - 1)  k = 1  while (2*k*p - 1) < limit    q = 2*k*p + 1    if q.prime? and (q % 8 == 1 or q % 8 == 7) and trial_factor(2,p,q)      
      return q    end    k += 1  end  nilend def trial_factor(base, exp, mod)  square = 1  (strv % exp).each_char {|bit| square = square**2 * (bit == strv ? base : 1) % mod}  (square == 1)end def check_mersenne(p)  print strv  f = mersenne_factor(p)  if f.nil?    puts strv  else    puts strv  endend Prime.each(53) { |p| check_mersenne p }check_mersenne 929func mtest(b, p) {    var bits = b.base(2).to_i.digits    for (var sq = 1; bits; sq %= p) {        sq *= sq;        sq += sq if bits.shift.is_one    }    sq == 1} for m in (2..60 -> grep{.is_prime} + [929]) {    var f = 0    var x = (2**m - 1)    var q    Inf.times { |k|        q = (2*k*m + 1)        q%8 ~~ [1,7] || q.is_prime || next        q*q > x || (f = mtest(m, q)) && break    }    say (f ? strv           : strv)}"
"names = %w(http://example.com/download.tar.gz   CharacterModel.3DS   .desktop   document   /etc/pam.d/login)names.each{|name| p File.extname(name)} func extension(filename) {    filename.match(/(\.[a-z0-9]+)\z/i).to_s} var files = [    'http://example.com/download.tar.gz',    'CharacterModel.3DS',    '.desktop',    'document',    'document.txt_backup',    '/etc/pam.d/login',] files.each {|f|    printf(""%-36s -> %-11s"", f.dump, extension(f).dump)}"
"inf = 1.0 / 0.0    #=> Infinitynan = 0.0 / 0.0    #=> NaN expression = [  strv, strv, strv, strv,  strv, strv, strv, strv, strv,  strv, strv, strv, strv,  strv, strv, strv, strv, strv,  strv, strv, strv, strv, strv,  strv, strv, strv, strv, strv, strv,] expression.each do |exp|  puts strv % [exp, eval(exp)]endvar inf = (1 / 0)    #=> Infvar nan = (0 / 0)    #=> NaN var exprs = [  strv, strv, strv, strv,  strv, strv, strv, strv, strv,  strv, strv, strv, strv,  strv, strv, strv, strv, strv,  strv, strv, strv, strv, strv,  strv, strv, strv, strv, strv,] exprs.each { |expr|  ""%15s => %s"".printf(expr, eval(expr))} say strv*40say(strv,        NaN ==  nan)   #=> truesay(strv,   Inf ==  inf)   #=> truesay(strv, -Inf == -inf)   #=> true say strv*40say(strv,   sqrt(-1));     #=> isay(strv, tanh(-inf));     #=> -1say(strv,  (-inf)**2);     #=> Infsay(strv,  (-inf)**3);     #=> -Infsay(strv,  acos(inf));     #=> Inf*isay(strv,  atan(inf));     #=> pi/2say(strv,    log(-1));     #=> pi*isay(strv, atanh(inf));     #=> -pi/2*i"
"class Integer  def factors() (1..self).select { |n| (self % n).zero? } endendp 45.factorsclass Integer  def factors    1.upto(Math.sqrt(self)).select {|i| (self % i).zero?}.inject([]) do |f, i|       f << self/i unless i == self/i      f << i    end.sort  endend[45, 53, 64].each {|n| puts strv}func factors(n) {  var divs = []  range(1, n.sqrt.int).each { |d|    divs << d if n%%d  }  divs + [divs[-1]**2 == n ? divs.pop : ()] + divs.reverse.map{|d| n/d }} [53, 64, 32766].each { |n|    say strv}"
"
class HopelesslyEgocentric  def method_missing(what, *args) self endend def if2(cond1, cond2)  if cond1 and cond2    yield    HopelesslyEgocentric.new  elsif cond1    Class.new(HopelesslyEgocentric) do      def else1; yield; HopelesslyEgocentric.new end    end.new  elsif cond2    Class.new(HopelesslyEgocentric) do      def else2; yield; HopelesslyEgocentric.new end    end.new  else    Class.new(HopelesslyEgocentric) do      def neither; yield end    end.new  endend[true,false].product([true,false]).each do |cond1, cond2|  print strv % [cond1, cond2]  if2(cond1, cond2) do    puts strv  end.else1 do    puts strv  end.else2 do    puts strv  end.neither do    puts strv  endendclass if2(cond1, cond2) {    method then(block) {    
        if (cond1 && cond2) {            block.run;        }        return self;    }    method else1(block) {   
        if (cond1 && !cond2) {            block.run;        }        return self;    }    method else2(block) {   
        if (cond2 && !cond1) {            block.run;        }        return self;    }    method else(block) {    
        if (!cond1 && !cond2) {            block.run;        }        return self;    }} if2(false, true).then {    say strv;}.else1 {    say strv;}.else2 {    say strv;        
}.else {    say strv}"
"ar = [strv, strv, strv, strv]ar.each{|exp| puts ""#{exp}:#{eval exp}""} var a = [    '5**3**2',    '(5**3)**2',    '5**(3**2)',    '5 ** 3 ** 2',    '5 ** 3**2',    '5**3 ** 2',    '[5,3,2]«**»',] a.each {|e|    ""%-12s == %s"".printf(e, eval(e))}"
"
def factorial_recursive(n)  n.zero? ? 1 : n * factorial_recursive(n - 1)end 
def factorial_tail_recursive(n, prod = 1)  n.zero? ? prod : factorial_tail_recursive(n - 1, prod * n)end 
def factorial_iterative(n)  (2...n).each { |i| n *= i }  n.zero? ? 1 : nend 
def factorial_inject(n)  (1..n).inject(1){ |prod, i| prod * i }end 
def factorial_reduce(n)  (2..n).reduce(1, :*)end  require 'benchmark' n = 400m = 10000 Benchmark.bm(16) do |b|  b.report('recursive:')       {m.times {factorial_recursive(n)}}  b.report('tail recursive:')  {m.times {factorial_tail_recursive(n)}}  b.report('iterative:')       {m.times {factorial_iterative(n)}}  b.report('inject:')          {m.times {factorial_inject(n)}}  b.report('reduce:')          {m.times {factorial_reduce(n)}}end
func factorial_recursive(n) {    n == 0 ? 1 : (n * __FUNC__(n-1));} 
func factorial_reduce(n) {    1..n -> reduce('*');} 
func factorial_iterative(n) {    var f = 1;    {|i| f *= i } * n;    return f;} 
say 5!;"
"def fib(n, sequence=[1])  n.times do    current_number, last_number = sequence.last(2)    sequence << current_number + (last_number or 0)  end   sequence.lastenddef fib(n, sequence=[1])  return sequence.last if n == 0   current_number, last_number = sequence.last(2)  sequence << current_number + (last_number or 0)   fib(n-1, sequence)end 

 fib = Hash.new do |f, n|  f[n] = if n <= -2           (-1)**(n + 1) * f[n.abs]         elsif n <= 1           n.abs         else           f[n - 1] + f[n - 2]         endend
require 'matrix' 





 M = Matrix[[0, 1], [1,1]] 




#





def self.fib_matrix(n)  return 0 if n <= 0 
  return 1 if n == 1 
  
  return CS::lower_right(M**(n - 1))end 

def self.lower_right matrix  return nil if matrix.row_size == 0  return matrix[matrix.row_size - 1, matrix.column_size - 1]endfib = Enumerator.new do |y|  f0, f1 = 0, 1  loop do    y <<  f0    f0, f1 = f1, f0 + f1  endendfib = Fiber.new do  a,b = 0,1  loop do    Fiber.yield a    a,b = b,a+b  endend9.times {puts fib.resume}def fib_gen    a, b = 1, 1    lambda {ret, a, b = a, b, a+b; ret}enddef fib    phi = (1 + Math.sqrt(5)) / 2    ((phi**self - (-1 / phi)**self) / Math.sqrt(5)).to_iendfunc fib_iter(n) {    var fib = [1, 1];    (n - fib.len).times {        fib = [fib[-1], fib[-2] + fib[-1]]    };    fib[-1];}func fib_rec(n) {    n < 2 ? n : (__FUNC__(n-1) + __FUNC__(n-2));}func fib_mem (n) is cached {    n < 2 ? n : (__FUNC__(n-1) + __FUNC__(n-2));}func fib_closed(n) {    define S = (1.25.sqrt + 0.5);    define T = (-S + 1);    (S**n - T**n) / (-T + S) -> roundf(0);}"
"class Numeric  def pow(m)    raise TypeError, strv unless m.is_a? Integer    puts strv    Array.new(m, self).reduce(1, :*)  endend p 5.pow(3)p 5.5.pow(3)p 5.pow(3.1)class Numeric  def **(m)    pow(m)  endendclass Fixnum  def **(m)    print strv    pow(m)  endendclass Bignum  def **(m)    print strv    pow(m)  endendclass Float  def **(m)    print strv    pow(m)  endend p i=2**64p i ** 2p 2.2 ** 3func expon(_, {.is_zero}) { 1 } func expon(base, exp {.is_neg}) {    expon(1/base, -exp)} func expon(base, exp {.is_int}) {   var c = 1  while (exp > 1) {    c *= base if exp.is_odd    base *= base    exp >>= 1  }   return (base * c)} say expon(3, 10)say expon(5.5, -3)class Number {    method ⊙(exp) {        expon(self, exp)    }} say (3 ⊙ 10)say (5.5 ⊙ -3)"
"class HQ9Interpreter {    has pointer;    has accumulator;     func bob (beer) {        func what  { strv }        func where { 'on the wall' }        func drink { beer--; strv }         while (beer.is_pos) {            [[what(), where()], [what()],            [drink()], [what(), where()], []].each{.join(' ').say}        }    }     method run (code) {        var chars = code.chars;        accumulator = 0;        pointer = 0;        while (pointer < chars.len) {            given (chars[pointer].lc) {                when ('h') { say 'Hello world!' }                when ('q') { say code }                when ('9') { bob(99) }                when ('+') { accumulator++ }                default    { warn %Q(Syntax error: Unknown command strv) }            }            pointer++;        }    }}var hq9 = HQ9Interpreter();hq9.run(strv);var hq9 = HQ9Interpreter();loop {    var in = read('HQ9+>', String) \\ break;    hq9.run(in)}"
"require strv puts Prime.take(20).join(strv)puts Prime.each(150).drop_while{|pr| pr < 100}.join(strv)puts Prime.each(8000).drop_while{|pr| pr < 7700}.countputs Prime.take(10_000).lastvar nt = frequire('ntheory') say (strv, nt.primes(nt.nth_prime(20)).join(' '))say (strv, nt.primes(100,150).join(' '))say (nt.prime_count(7700,8000), strv)say (strv, nt.nth_prime(10_000))"
"define tape_length = 50_000;define eof_val = -1;define unbalanced_exit_code = 1; var cmd = 0;var cell = 0;var code = [];var loops = [];var tape = tape_length.of(0); func get_input {    static input_buffer = [];    input_buffer.len || (input_buffer = ((STDIN.readline \\ return eof_val).chomp.chars.map{.ord}));    input_buffer.shift \\ eof_val;} func jump {    var depth = 0;    while (depth >= 0) {        ++cmd < code.len || Sys.exit(unbalanced_exit_code);        if (code[cmd] == '[') {            ++depth;        }        elsif (code[cmd] == ']') {            --depth;        }    }} var commands = Hash.new(    '>' => { ++cell },    '<' => { --cell },    '+' => { ++tape[cell] },    '-' => { --tape[cell] },    '.' => { tape[cell].chr.print },    ',' => { tape[cell] = get_input() },    '[' => { tape[cell] ? loops.append(cmd) : jump() },    ']' => { cmd = (loops.pop - 1) },); STDOUT.autoflush(1);code = ARGF.slurp.chars.grep {|c| commands.exists(c)};var code_len = code.len; while (cmd < code_len) {    commands{code[cmd]}.run;    cmd++;}"
"string = `ls`
string = %x{ls}
 system strv
 print `ls`#The same, but with back quotes exec strv
 
io = IO.popen('ls')
io.each {|line| puts line}
%p(ls).open_r.each { |line|    print line;}; var str1 = `ls`;         
var str2 = %x(ls);       
 Sys.system('ls');   
Sys.exec('ls');     
"
"
module Hailstone  module_function  def hailstone n    seq = [n]    until n == 1      n = (n.even?) ? (n / 2) : (3 * n + 1)      seq << n    end    seq  endend if __FILE__ == $0  include Hailstone   
  hs27 = hailstone 27  p [hs27.length, hs27[0..3], hs27[-4..-1]]   
  n, len = (1 ... 100_000) .collect {|n|    [n, hailstone(n).length]} .max_by {|n, len| len}  puts strv  puts strvend
require 'hailstone' h = Hash.new(0)last = 99_999(1..last).each {|n| h[Hailstone.hailstone(n).length] += 1}length, count = h.max_by {|length, count| count} puts strvputs strvputs strvfunc hailstone(n) {    gather {        while (n > 1) {            take(n)            n = (n.is_even ? n/2 : (3*n + 1))        }        take(1)    }} if (__FILE__ == __MAIN__) {             
    var seq = hailstone(27)    say strv     var n = 0    var max = 0    100_000.times { |i|        var seq = hailstone(i)        if (seq.len > max) {            max = seq.len            n = i        }    }     say strv}include Hailstone var score = Hash()100_000.times { |i| score{ Hailstone::hailstone(i).len } := 0 ++ } var k = score.keys.max_by {|k| score{k} }say strv"
"def setup(ruleset)  ruleset.each_line.inject([]) do |rules, line|    if line =~ /^\s*#/      rules    elsif line =~ /^(.+)\s+->\s+(\.?)(.*)$/      rules << [$1, $3, $2 != strv]    else      raise strv    end  endend def morcov(ruleset, input_data)  rules = setup(ruleset)  while (matched = rules.find { |match, replace, term|    input_data[match] and input_data.sub!(match, replace)    }) and !matched[2]  end  input_dataendruleset1 = <<EOS




A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule
EOS puts morcov(ruleset1, strv) ruleset2 = <<EOS


A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
EOS puts morcov(ruleset2, strv) ruleset3 = <<EOS


A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
EOS puts morcov(ruleset3, strv) ruleset4 = <<EOS
### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.


_+1 -> _1+
1+1 -> 11+




1! -> !1
,! -> !+
_! -> _


1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _


 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +


_1 -> 1
1+_ -> 1
_+_ -> 
EOS puts morcov(ruleset4, strv) ruleset5 = <<EOS


#


A0 -> 1B


0A1 -> C01
1A1 -> C11


0B0 -> A01
1B0 -> A11


B1 -> 1B


0C0 -> B01
1C0 -> B11


0C1 -> H01
1C1 -> H11
EOS puts morcov(ruleset5, strv)"
"
class SillyError < Exceptionendclass MyInvalidArgument < ArgumentErrorend 
def spam  raise SillyError, 'egg'end 
begin  spamrescue SillyError => se  puts se  
endbegin  foorescue ArgumentError => e  
  barrescue => e  
  quackelse  
  quuxensure  
  bazend
quotient = 1 / 0 rescue strvdef foo    throw :doneend catch :done do    fooendtry  {    die strv;        
}catch { |type, msg|    say strv;    
    say strv;      
}; say strv;die strv;        
say strv;             
"
"def foo  2.times do |i|    begin      bar(i)    rescue U0      $stderr.puts strv    end  endend def bar(i)  baz(i)end def baz(i)  raise i == 0 ? U0 : U1end class U0 < StandardError; end class U1 < StandardError; end foofunc baz(i) { die strv };func bar(i) { baz(i)      }; func foo {    [0, 1].each { |i|        try   { bar(i) }        catch { |_, msg|            msg ~~ /^U0/ ? say strv                         : die msg;       
        };    }} foo();"
"class Integer  
  def choose(k)    
    pTop = (self-k+1 .. self).inject(1, &:*)     
    pBottom = (2 .. k).inject(1, &:*)    pTop / pBottom  endend p 5.choose(3)p 60.choose(30) def c n, r  (0...r).inject(1) do |m,i| (m * (n - i)) / (i + 1) endend (1..60).to_a.combination(30).size  #=> 118264581564861424func binomial(n,k) {    n! / ((n-k)! * k!)} say binomial(400, 200)say 400.nok(200)"
"print strvp -5.upto(5).select(&:even?)print strvp -5.upto(5).select(&:odd?)n & 1 == 0quotient, remainder = n.divmod(2); remainder == 0 

n.to_f/2 == n/2 

n[0].zero?var n = 42;say n.is_odd;       
say n.is_even;      
func is_odd(n)  { n&1 == 1 };func is_even(n) { n&1 == 0 };func is_odd(n)  { n%2 == 1 };func is_even(n) { n%2 == 0 };"
"power5 = (1..250).each_with_object({}){|i,h| h[i**5]=i}result = power5.keys.repeated_combination(4).select{|a| power5[a.inject(:+)]}puts result.map{|a| a.map{|i| strv}.join(' + ') + strv}p5, sum2, max = {}, {}, 250(1..max).each do |i|  p5[i**5] = i  (i..max).each{|j| sum2[i**5 + j**5] = [i,j]}end result = {}sk = sum2.keys.sortp5.keys.sort.each do |p|  sk.each do |s|    break if p <= s    result[(sum2[s] + sum2[p-s]).sort] = p5[p]  if sum2[p - s]  endendresult.each{|k,v| puts k.map{|i| strv}.join(' + ') + strv}define MAX = 250 var p5 = Hash()var sum2 = Hash() MAX.times { |i|    p5{i**5} = i    MAX.times { |j|        sum2{i**5 + j**5} = [i, j]    }} var sk = sum2.keys.map{.to_n}.sortp5.keys.map{.to_n}.sort.each { |p|    sk.each { |s|        next if (p <= s)        if (sum2.exists(p - s)) {            sum2{s} + sum2{p-s} -> map{|n| strv }             \                                -> join(' + ') + strv \                                -> say            goto :END        }    }} @:END"
"def euler(y, a, b, h)  a.step(b,h) do |t|    puts strv % [t,y]    y += h * yield(t,y)  endend [10, 5, 2].each do |step|  puts strv  euler(100,0,100,step) {|time, temp| -0.07 * (temp - 20) }  putsendfunc euler_method(t0, t1, k, step_size) {    var results = [[0, t0]]    for s in (step_size..100 -> by(step_size)) {        t0 -= ((t0 - t1) * k * step_size)        results << [s, t0]    }    return results;} func analytical(t0, t1, k, time) {    (t0 - t1) * exp(-time * k) + t1} var (T0, T1, k) = (100, 20, .07)var r2  = euler_method(T0, T1, k,  2).grep { _[0] %% 10 }var r5  = euler_method(T0, T1, k,  5).grep { _[0] %% 10 }var r10 = euler_method(T0, T1, k, 10).grep { _[0] %% 10 } say ""Time      2     err(%)      5     err(%)    10      err(%)  Analytic""say strv*76 r2.range.each { |i|    var an = analytical(T0, T1, k, r2[i][0])    printf(""%4d#{'%9.3f' * 7}"",                 r2[i][0],                 r2[i][1], ( r2[i][1] / an) * 100 - 100,                 r5[i][1], ( r5[i][1] / an) * 100 - 100,                r10[i][1], (r10[i][1] / an) * 100 - 100,                an)}"
"@target = strvCharset = [strv, *strv..strv]COPIES = 100 def random_char; Charset.sample end def fitness(candidate)  sum = 0  candidate.chars.zip(@target.chars) {|x,y| sum += (x[0].ord - y[0].ord).abs}  100.0 * Math.exp(Float(sum) / -10.0)end def mutation_rate(candidate)  1.0 - Math.exp( -(100.0 - fitness(candidate)) / 400.0)end def mutate(parent, rate)  parent.each_char.collect {|ch| rand <= rate ? random_char : ch}.joinend def log(iteration, rate, parent)  puts strv % [iteration, rate, fitness(parent), parent]end iteration = 0parent = Array.new(@target.length) {random_char}.joinprev = strv while parent != @target  iteration += 1  rate = mutation_rate(parent)  if prev != parent    log(iteration, rate, parent)    prev = parent  end  copies = [parent] + Array.new(COPIES) {mutate(parent, rate)}  parent = copies.max_by {|c| fitness(c)}endlog(iteration, rate, parent)define target = strvdefine mutate_chance = 0.08define alphabet = [('A'..'Z')..., ' ']define C = 100 func fitness(str) { str.chars ~Z== target.chars -> count(true) }func mutate(str)  { str.gsub(/(.)/, {|s1| 1.rand < mutate_chance ? alphabet.pick : s1 }) } for (    var (i, parent) = (0, alphabet.rand(target.len).join);    parent != target;    parent = C.of{ mutate(parent) }.max_by(fitness)) { printf(""%6d: '%s'"", i++, parent) }"
"def eq_indices(list)  list.each_index.select do |i|    list[0...i].inject(0, :+) == list[i+1..-1].inject(0, :+)  endenddef eq_indices(list)  result = []  list.empty? and return result  final = list.size - 1   helper = lambda do |left, current, right, index|    left == right and result << index   
    index == final and return           
    new = list[index + 1]    helper.call(left + current, new, right - new, index + 1)  end  helper.call 0, list.first, list.drop(1).inject(:+), 0  resultenddef eq_indices(list)  left, right = 0, list.inject(0, :+)  equilibrium_indices = []   list.each_with_index do |val, i|    right -= val    equilibrium_indices << i if right == left    left += val  end   equilibrium_indicesendindices = [  [-7, 1, 5, 2,-4, 3, 0],  [2, 4, 6],  [2, 9, 2],  [1,-1, 1,-1, 1,-1, 1]]indices.each do |x|  puts strv % [x, eq_indices(x)]endfunc eq_index(nums) {    var (i, sum, sums) = (0, 0, Hash.new);    nums.each { |n|        sums{2*sum + n} := [] -> append(i++);        sum += n;    }    sums{sum} \\ [];}var indices = [  [-7, 1, 5, 2,-4, 3, 0],  [2, 4, 6],  [2, 9, 2],  [1,-1, 1,-1, 1,-1, 1],] for x in indices {    say (strv % @|[x, eq_index(x)].map{.dump});}"
ENV['HOME']say ENV{'HOME'};
"def entropy(s)  counts = s.each_char.with_object(Hash.new(0.0)) {|c,h| h[c] += 1}  counts.values.reduce(0) do |entropy, count|    freq = count / s.size    entropy - freq * Math.log2(freq)  endends = File.read(__FILE__)p entropy(s)func entropy(s) {    [0,        s.chars.freq.values.map {|c|            var f = c/s.len            f * f.log2        }...    ]«-»} say entropy(File(__FILE__).open_r.slurp)"
"module Fruits  APPLE  = 0  BANANA = 1  CHERRY = 2end 
 FRUITS = [:apple, :banana, :cherry]val = :bananaFRUITS.include?(val)      #=> truemodule Card  
  SUITS = %i(Clubs Hearts Spades Diamonds)  SUIT_VALUE = SUITS.each_with_index.to_h               

  #=> {:Clubs=>0, :Hearts=>1, :Spades=>2, :Diamonds=>3}   PIPS = %i(2 3 4 5 6 7 8 9 10 Jack Queen King Ace)  PIP_VALUE = PIPS.each.with_index(2).to_h              

  #=> {:strv=>10, :Jack=>11, :Queen=>12, :King=>13, :Ace=>14}endenum {Apple, Banana, Cherry};   
enum {    Apple=3,    Banana,         
    Cherry=strv,    Orange,         
};"
"def halve(x)   x/2  enddef double(x)  x*2  end 
def ethiopian_multiply(a, b)  product = 0  while a >= 1     p [a, b, a.even? ? strv : strv] if $DEBUG    product += b unless a.even?    a = halve(a)    b = double(b)  end  productend 
def rec_ethiopian_multiply(a, b)  return 0 if a < 1  p [a, b, a.even? ? strv : strv] if $DEBUG  (a.even? ? 0 : b) + rec_ethiopian_multiply(halve(a), double(b))end $DEBUG = true   
a, b = 20, 5puts strv; putsrequire 'test/unit'class EthiopianTests <   def test_iter1; assert_equal(578, ethopian_multiply(17,34)); end  def test_iter2; assert_equal(100, ethopian_multiply(20,5));  end  def test_iter3; assert_equal(5,   ethopian_multiply(5,1));   end  def test_iter4; assert_equal(5,   ethopian_multiply(1,5));   end  def test_iter5; assert_equal(0,   ethopian_multiply(5,0));   end  def test_iter6; assert_equal(0,   ethopian_multiply(0,5));   end  def test_rec1;  assert_equal(578, rec_ethopian_multiply(17,34)); end  def test_rec2;  assert_equal(100, rec_ethopian_multiply(20,5));  end  def test_rec3;  assert_equal(5,   rec_ethopian_multiply(5,1));   end  def test_rec4;  assert_equal(5,   rec_ethopian_multiply(1,5));   end  def test_rec5;  assert_equal(0,   rec_ethopian_multiply(5,0));   end  def test_rec6;  assert_equal(0,   rec_ethopian_multiply(0,5));   endendfunc double (n) { n * 2 };func halve  (n) { int(n / 2) }; func ethiopic_mult(a, b) {    var r = 0;    while (a > 0) {        a.is_even || (r += b);        a = halve(a);        b = double(b);    };    return r;} say ethiopic_mult(17, 34);"
"msg = strvmsg << strvputs msg                #=> Hello World! puts msg.frozen?        #=> falsemsg.freezeputs msg.frozen?        #=> truebegin  msg << strvrescue => e  p e                   #=> #<RuntimeError: can't modify frozen String>end puts msg                #=> Hello World!msg2 = msg 
msg = strv     
 puts msg.frozen?        #=> falseputs msg2.frozen?       #=> true
msg = strv.freezemsg2 = msg.clone        
msg3 = msg.dup          
puts msg2               #=> Hello World!puts msg3               #=> Hello World!puts msg2.frozen?       #=> trueputs msg3.frozen?       #=> falsedefine PI = 3.14159;            
const MSG = strv;     
"
"def entropy(s)  counts = Hash.new(0.0)  s.each_char { |c| counts[c] += 1 }  leng = s.length   counts.values.reduce(0) do |entropy, count|    freq = count / leng    entropy - freq * Math.log2(freq)  endend p entropy(strv)def entropy2(s)  s.each_char.group_by(&:to_s).values.map { |x| x.length / s.length.to_f }.reduce(0) { |e, x| e - x*Math.log2(x) }endfunc entropy(s) {  var counts = Hash.new;  s.each { |c| counts{c} := 0 ++ };  var len = s.len;  [0, counts.values.map {|count|    var freq = count/len; freq * freq.log2 }...  ]«-»;} say entropy(strv);"
"s = strvs = String.news = strv; s.clears == strvs.eql?(strv)s.empty?s.length == 0s[/\A\z/] 
s.each_char.to_a.empty?s != strvs.length > 0s[/./m]if s then puts strv end  
var s = strv;var s = String.new;s == strv;s.length == 0;s.is_empty;s ~~ /^\z/;s ~~ /\A\z/;s != strv;s.length > 0;s ~~ /./s;s !~ /^\z/;"
"Dir.entries(strv).empty? Dir.new('/my/dir').is_empty;    
func is_empty(dir) {    dir.open(\var dir_h) || return nil;    dir_h.each { |file|        file ~~ ['.', '..'] && next;        return false;    };    return true;};"
#!/usr/bin/env ruby 
"size = 100eca = ElemCellAutomat.new(strv+strv*(size-1), 30)eca.take(80).map{|line| line[0]}.each_slice(8){|bin| p bin.join.to_i(2)}var auto = Automaton(30, [1] + 100.of(0)); 10.times {    var sum = 0;    8.times {        sum = (2*sum + auto.cells[0]);        auto.next;    };    say sum;};"
"def notcell(c)  c.tr('01','10')end def eca_infinite(cells, rule)  neighbours2next = Hash[8.times.map{|i|[strv%i, strv[rule[i]]]}]  c = cells  Enumerator.new do |y|    loop do      y << c      c = notcell(c[0])*2 + c + notcell(c[-1])*2        
      c = (1..c.size-2).map{|i| neighbours2next[c[i-1..i+1]]}.join    end  endend if __FILE__ == $0  lines = 25  for rule in [90, 30]    puts ""Rule: %i"" % rule    for i, c in (0...lines).zip(eca_infinite('1', rule))      puts '%2i: %s%s' % [i, ' '*(lines - i), c.tr('01', '.#')]    end  endendfunc evolve(rule, bin) {    var offset = 0    var (l='', r='')    Inf.times {        bin.sub!(/^((.)\g2*)/, {|_s1, s2| l = s2; offset -= s2.len; s2*2 })        bin.sub!(/(.)\g1*$/, {|s1| r = s1; s1*2 })        printf(""%5d| %s%s"", offset, ' ' * (40 + offset), bin.tr('01','.#'))        bin = [l*3, 0.to(bin.len-3).map{|i| bin.substr(i, 3) }..., r*3 ].map { |t|                1 & (rule >> t.bin)        }.join    }} evolve(90, strv)"
"class ElemCellAutomat  include Enumerable   def initialize (start_str, rule, disp=false)    @cur = start_str    @patterns = Hash[8.times.map{|i|[strv%i, strv[rule[i]]]}]    puts ""Rule (#{rule}) : "" if disp  end   def each    return to_enum unless block_given?    loop do      yield @cur      str = @cur[-1] + @cur + @cur[0]      @cur = @cur.size.times.map {|i| @patterns[str[i,3]]}.join    end  end end eca = ElemCellAutomat.new('1'.center(39, strv), 18, true)eca.take(30).each{|line| puts line.tr(strv, strv)}class Automaton(rule, cells) {     method init {        rule = sprintf(strv, rule).chars.map{.to_i}.reverse    }     method next {        var previous = cells.map{_}        var len = previous.len        cells[] = rule[                    previous.range.map { |i|                        4*previous[i-1 % len] +                        2*previous[i]         +                        previous[i+1 % len]                    }                  ]    }     method to_s {        cells.map { _ ? '#' : ' ' }.join    }} var size = 20var arr = size.of(0)arr[size/2] = 1 var auto = Automaton(90, arr) (size/2).times {    print ""|#{auto}|""    auto.next}"
"def ef(fr)  ans = []  if fr >= 1    return [[fr.to_i], Rational(0, 1)]  if fr.denominator == 1    intfr = fr.to_i    ans, fr = [intfr], fr - intfr  end  x, y = fr.numerator, fr.denominator  while x != 1    ans << Rational(1, (1/fr).ceil)    fr = Rational(-y % x, y * (1/fr).ceil)    x, y = fr.numerator, fr.denominator  end  ans << frend for fr in [Rational(43, 48), Rational(5, 121), Rational(2014, 59)]  puts '%s => %s' % [fr, ef(fr).join(' + ')]end lenmax = denommax = [0]for b in 2..99  for a in 1...b    fr = Rational(a,b)    e = ef(fr)    elen, edenom = e.length, e[-1].denominator    lenmax = [elen, fr] if elen > lenmax[0]    denommax = [edenom, fr] if edenom > denommax[0]  endendputs 'Term max is %s with %i terms' % [lenmax[1], lenmax[0]]dstr = denommax[0].to_sputs 'Denominator max is %s with %i digits' % [denommax[1], dstr.size], dstrfunc ef(fr) {  var ans = []  if (fr >= 1) {    return([fr]) if (fr.is_int)    var intfr = fr.to_i    ans << intfr    fr -= intfr  }  var (x, y) = fr.parts  while (x != 1) {    ans << fr.inv.ceil.inv    fr = ((-y % x) / y*fr.inv.ceil)    (x, y) = fr.parts  }  ans << fr  return ans} for fr in [43/48, 5/121, 2014/59] {  ""%s => %s"".printf(fr.as_rat, ef(fr).map{.as_rat}.join(' + '))} var lenmax = (var denommax = [0])for b in range(2, 99) {  for a in range(1, b-1) {    var fr = a/b    var e = ef(fr)    var (elen, edenom) = (e.length, e[-1].denominator)    lenmax = [elen, fr] if (elen > lenmax[0])    denommax = [edenom, fr] if (edenom > denommax[0])  }} ""Term max is %s with %i terms"".printf(lenmax[1].as_rat, lenmax[0])""Denominator max is %s with %i digits"".printf(denommax[1].as_rat, denommax[0].size)say denommax[0]"
"require 'prime' emirp = Enumerator.new do |y|  Prime.each do |prime|    rev = prime.to_s.reverse.to_i    y << prime  if rev.prime? and rev != prime  endend puts strv, emirp.first(20).join(strv)puts strvemirp.each.with_index(1) do |prime,i|  print strv  if (7700..8000).cover?(prime)  if i==10000    puts strv, strv, prime    break  endendfunc forprimes(a, b, callback) {    for (var p = a.dec.next_prime; p <= b; p.next_prime!) {        callback(p)    }} func is_emirp(p) {    var str = Str(p)    var rev = str.reverse    (str != rev) && is_prime(Num(rev))} func emirp_list(count) {    var i = 13    var inc = (100 + 10*count)    var n = []    while (n.len < count) {        forprimes(i, i+inc - 1, {|p|            is_emirp(p) && (n << p)        })        (i, inc) = (i+inc, int(inc * 1.03) + 1000)    }    n.splice(count)    return n} say (strv, emirp_list(20).join(' '))say (strv, gather {        forprimes(7700, 8000, {|p| is_emirp(p) && take(p) })    }.join(' '))say (strv, emirp_list(10000)[-1])"
"require 'matrix' class Matrix  def element_wise( operator, other )    Matrix.build(row_size, column_size) do |row, col|      self[row, col].send(operator, other[row, col])    end  endend m1, m2 = Matrix[[3,1,4],[1,5,9]], Matrix[[2,7,1],[8,2,2]]puts ""m1: #{m1}m2: #{m2}"" [:+, :-, :*, :/, :fdiv, :**, :%].each do |op|  puts strv % [op, m1.element_wise(op, m2)]end"
"module Dutch  
  
   
  Symbols = [:red, :white, :blue]   
  Values  = Hash[Symbols.each_with_index.to_a]   
  def self.random_ball    Symbols[rand 3]  end   
  class Balls < Array     
    def self.random(n)      self.new(n.times.map { Dutch.random_ball })    end     
    def dutch?       return true if length < 2       Values[self[0]] < Values[self[1]] && slice(1..-1).dutch?    end     
    def dutch!      lo = -1      hi = length      i = 0      while i < hi do        case self[i]          when :red            lo += 1            self[lo], self[i] = self[i], self[lo]            i += 1          when :white            i += 1          when :blue            hi -= 1            self[hi], self[i] = self[i], self[hi]        end      end      self    end     
    def dutch(acc = { :red => 0, :white => 0, :blue => 0})      return self.class.new(        Symbols.map { |c| [c] * acc[c] }.inject(&:+)      ) if length == 0      acc[first]+=1      return slice(1..-1).dutch( acc )    end  endendballs = nilwhile balls.nil? or balls.dutch? do  balls = Dutch::Balls.random 8endputs strvputs strvputs strvputs strvputs strv"
"require 'socket'server = TCPServer.new(12321) while (connection = server.accept)  Thread.new(connection) do |conn|    port, host = conn.peeraddr[1,2]    client = strv    puts strv    begin      loop do        line = conn.readline        puts strv        conn.puts(line)      end    rescue EOFError      conn.close      puts strv    end  endendrequire 'socket' Socket.tcp_server_loop(12321) do |conn, addr|  Thread.new do    client = strv    puts strv    begin      loop do        line = conn.readline        puts strv        conn.puts(line)      end    rescue EOFError      conn.close      puts strv    end  endend"
"p strvx = strv + gets.chomp!instance_variable_set x, 42p strv var name = read(strv, String);     
 class DynamicVar(name, value) {    method init {        DynamicVar.def_method(name, ->(_) { value })    }} var v = DynamicVar(name, 42);       
say v.foo;                          
"
"X, Y, Z = 6, 2, 3DIR = {strv => [1,0], strv => [0,1], strv => [1,1]} def cuboid(nx, ny, nz)  puts strv % [nx, ny, nz]  x, y, z = X*nx, Y*ny, Z*nz  area = Array.new(y+z+1){strv * (x+y+1)}  draw_line = lambda do |n, sx, sy, c|    dx, dy = DIR[c]    (n+1).times do |i|      xi, yi = sx+i*dx, sy+i*dy      area[yi][xi] = (area[yi][xi]==strv ? c : strv)    end  end  nz    .times {|i| draw_line[x,     0,   Z*i, strv]}  (ny+1).times {|i| draw_line[x,   Y*i, z+Y*i, strv]}  nx    .times {|i| draw_line[z,   X*i,     0, strv]}  (ny+1).times {|i| draw_line[z, x+Y*i,   Y*i, strv]}  nz    .times {|i| draw_line[y,     x,   Z*i, strv]}  (nx+1).times {|i| draw_line[y,   X*i,     z, strv]}  puts area.reverseend cuboid(2, 3, 4)cuboid(1, 1, 1)cuboid(6, 2, 1)cuboid(2, 4, 1)var DIR = Hash.new(strv => [1,0], strv => [0,1], strv => [1,1]); func cuboid(nx, ny, nz) {  say(strv % [nx, ny, nz]);  var(x, y, z) = (8*nx, 2*ny, 4*nz);  var area = [];  var line = func(n, sx, sy, c) {    var(dx, dy) = DIR{c}...;    0..n -> each {|i|      var (xi, yi) = (sx + i*dx, sy + i*dy);      area[yi] \\= [strv]*(x+y+1);      area[yi][xi] = (area[yi][xi] == strv ? c : '+');    };  };   0 .. nz-1 -> each {|i| line.call(x,       0,     4*i, strv)};  0 .. ny   -> each {|i| line.call(x,     2*i, z + 2*i, strv)};  0 .. nx-1 -> each {|i| line.call(z,     8*i,       0, strv)};  0 .. ny   -> each {|i| line.call(z, x + 2*i,     2*i, strv)};  0 .. nz-1 -> each {|i| line.call(y,       x,     4*i, strv)};  0 .. nx   -> each {|i| line.call(y,     8*i,       z, strv)};   area.reverse.each { |line|     say line.join('');  };} cuboid(2, 3, 4);cuboid(1, 1, 1);cuboid(6, 2, 1);cuboid(2, 4, 1);func cuboid (x=1,y=1,z=1,s=' ',c='+',h='-',v='|',d='/') {    say(strv % (x, y, z));    ' ' * z+1 + c + h*x + c -> say;     { |i|        ' ' * (z - i + 1) + d + s*x + d +              (s * (i - (i > y ? i-y : 1))) +              (i - 1 == y ? c : (i > y ? d : v)) -> say    } * z;     c + h*x + c + (s * (z < y ? z : y) +        (z < y ? v : (z == y ? c : d))) -> say;     { |i|        v + s*x + v + (z > y            ? (i >= z ? (s*x + c) : (s * y-i + d))            : (y - i > z                ? (s * z + v)                : (s * y-i + (y-i == z ? c : d))               )        ) -> say;    } * y;     c + h*x + c -> say;}; cuboid(2, 3, 4);cuboid(1, 1, 1);cuboid(6, 2, 1);cuboid(2, 4, 1);"
"Shoes.app :width => 500, :height => 500, :resizable => false do  image 400, 470, :top => 30, :left => 50 do    nostroke    fill strv    image :top => 230, :left => 0 do      oval 70, 130, 260, 40      blur 30    end    oval 10, 10, 380, 380    image :top => 0, :left => 0 do      fill strv      oval 30, 30, 338, 338      blur 10    end    fill gradient(rgb(1.0, 1.0, 1.0, 0.7), rgb(1.0, 1.0, 1.0, 0.0))    oval 80, 14, 240, 176    image :top => 0, :left => 0 do      fill strv      oval 134, 134, 130, 130      blur 40    end    image :top => 150, :left => 40, :width => 320, :height => 260 do      fill gradient(rgb(0.7, 0.9, 1.0, 0.0), rgb(0.7, 0.9, 1.0, 0.6))      oval 60, 60, 200, 136      blur 20    end  endendfunc normalize (vec)  { vec »/» (vec »*« vec -> sum.sqrt) }func dot       (x, y) { -(x »*« y -> sum) `max` 0 } var x = var y = 255x += 1 if x.is_even    
 var light = normalize([ 3, 2, -5 ])var depth = 255 func draw_sphere(rad, k, ambient) {    var pixels = []    var r2 = (rad * rad)    var range = (-rad .. rad)    for x,y in (range ~X range) {        if ((var x2 = x*x) + (var y2 = y*y) < r2) {            var vector = normalize([x, y, (r2 - x2 - y2).sqrt])            var intensity = (dot(light, vector)**k + ambient)            var pixel = (0 `max` (intensity*depth -> int) `min` depth)            pixels << pixel        }        else {            pixels << 0        }    }    return pixels} var outfile = %f'sphere-sidef.pgm'var out = outfile.open('>:raw') out.say(""P5#{x} #{y}#{depth}"")    
out.print(draw_sphere((x-1)/2, .9, .2).map{.chr}.join)out.close"
"Shoes.app(:width=>205, :height => 228, :title => strv) do  def draw_ray(width, start, stop, ratio)    angle = Math::PI * 2 * ratio - Math::PI/2    strokewidth width    cos = Math::cos(angle)    sin = Math::sin(angle)    line 101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop  end   def update    t = Time.now    @time.text = t.strftime(strv)    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f    s += t.to_f - t.to_i  
     @hands.clear do      draw_ray(3, 0, 70, (h + m/60)/12)      draw_ray(2, 0, 90, (m + s/60)/60)      draw_ray(1, 0, 95, s/60)    end  end   
  @time = para(:align=>strv, :family => strv)   
  stack(:width=>203, :height=>203) do    strokewidth 1    fill gradient(deepskyblue, aqua)    oval 1, 1, 200    fill black    oval 98, 98, 6    
    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}  end.move(0,23)   
  @hands = stack(:width=>203, :height=>203) {}.move(0,23)   animate(5) {update}endShoes.app(:title => strv, :width => 209, :height => 300) do  background lightgrey   Red = rgb(255, 20, 20)  Yellow = rgb(173, 255, 47)  Green = rgb(154, 205, 50)  Gray = rgb(128, 128, 128)   @time = para(:align => strv)  stack do    fill Gray    stroke black    strokewidth 2    @seconds = oval 75, 3, 50    @hrs_a  =  4.times.collect {|i| rect   51*i,  56, 48, 30, 4}    @hrs_b  =  4.times.collect {|i| rect   51*i,  89, 48, 30, 4}    @mins_a = 11.times.collect {|i| rect 2+18*i, 122, 15, 30, 4}    @mins_b =  4.times.collect {|i| rect   51*i, 155, 48, 30, 4}    
    fill white    stroke darkslategray    rect -10, -30, 75, 70, 10    rect 140, -30, 75, 70, 10    rect -13, 192, 105, 100, 10    rect 110, 192, 105, 100, 10  end.move(3,20)   animate(1) do    now = Time.now    @time.text = now.strftime(strv)    @seconds.style(:fill => now.sec.even? ? Green : Gray)    a, b = now.hour.divmod(5)    4.times {|i| @hrs_a[i].style(:fill => i < a ? Red : Gray)}    4.times {|i| @hrs_b[i].style(:fill => i < b ? Red : Gray)}    a, b = now.min.divmod(5)    11.times {|i| @mins_a[i].style(:fill => i < a ? (i%3==2 ? Red : Yellow) : Gray)}    4.times  {|i| @mins_b[i].style(:fill => i < b ? Yellow : Gray)}  end   keypress do |key|    case key    when :control_q, ""11"" then exit    end  endendSTDOUT.autoflush(1) var (rows, cols) = `stty size`.words.map{.to_i}... var x = (rows/2 - 1  -> int)var y = (cols/2 - 16 -> int) var chars = [                 strv,                 strv,                 strv             ].map {|s| s.split(3) } func position(i,j) {    ""[%d;%dH"" % (i, j)} func indices {    var t = Time.local    strv % (t.hour, t.min, t.sec) -> split(1).map{|c| c.ord - '0'.ord }} loop {    print ""[H[J""    for i in ^chars {      print position(x + i, y)      print [chars[i][indices()]].join(' ')    }    print position(1, 1)    Sys.sleep(0.5)}"
"class DListNode < ListNode  attr_accessor :prev  
   def initialize(value, prev=nil, succ=nil)    @value = value    @prev = prev    @prev.succ = self if prev    @succ = succ    @succ.prev = self if succ  end   def self.from_values(*ary)    ary << (f = ary.pop)    ary.map! {|i| new i }    ary.inject(f) {|p, c| p.succ = c; c.prev = p; c }  endend list = DListNode.from_values 1,2,3,4var node = Hash.new(     data => 'say what',     next => foo_node,     prev => bar_node,); node{:next} = quux_node;  
"
"class DListNode  def insert_after(search_value, new_value)    if search_value == value      new_node = self.class.new(new_value, nil, nil)      next_node = self.succ      self.succ = new_node      new_node.prev = self      new_node.succ = next_node      next_node.prev = new_node    elsif self.succ.nil?      raise StandardError, strv    else      self.succ.insert_after(search_value, new_value)    end  endend head = DListNode.from_array([:a, :b])head.insert_after(:a, :c)"
"class DListNode  def get_tail    
    self.find {|node| node.succ.nil?}  end   def each_previous(&b)    yield self    self.prev.each_previous(&b) if self.prev  endend head = DListNode.from_array([:a, :b, :c])head.each {|node| p node.value}head.get_tail.each_previous {|node| p node.value}"
"Point = Struct.new(:x, :y)Line = Struct.new(:start, :stop) Shoes.app(:width => 800, :height => 600, :resizable => false) do   def split_segments(n)    dir = 1    @segments = @segments.inject([]) do |new, l|      a, b, c, d = l.start.x, l.start.y, l.stop.x, l.stop.y       mid_x = a + (c-a)/2.0 - (d-b)/2.0*dir      mid_y = b + (d-b)/2.0 + (c-a)/2.0*dir      mid_p = Point.new(mid_x, mid_y)       dir *= -1      new << Line.new(l.start, mid_p)      new << Line.new(mid_p, l.stop)    end  end   @segments = [Line.new(Point.new(200,200), Point.new(600,200))]  15.times do |n|    info strv    split_segments(n)  end   stack do    @segments.each do |l|      line l.start.x, l.start.y, l.stop.x, l.stop.y    end  endenddefine halfpi = Math.pi/2; 
var dragon = 'FX';{    dragon.gsub!('X', 'x+yF+');    dragon.gsub!('Y', '-Fx-y');    dragon.tr!('xy', 'XY');} * 10; 
var (x, y) = (100, 100);var theta = 0;var r = 2; print <<'EOT';<?xml version='1.0' encoding='utf-8' standalone='no'?><!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN''http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'><svg width='100%' height='100%' version='1.1'xmlns='http://www.w3.org/2000/svg'>EOT dragon.each { |c|    given(c) {        when ('F') {            printf(strv, x, y);            printf(strv, x += r*Math.cos(theta));            printf(strv, y += r*Math.sin(theta));            printf(""style='stroke:rgb(0,0,0);stroke-width:1'/>"");        }        when ('+') { theta += halfpi }        when ('-') { theta -= halfpi }    }} print '</svg>';"
"=begin rdoc
RDoc is documented here[http://www.ruby-doc.org/core/classes/RDoc.html].
 
This is a class documentation comment.  This text shows at the top of the page
for the class.
 
Comments can be written inside strv blocks or 
in normal '#' comment blocks.
 
There are no ' like javadoc, but 'name-value' lists can be written:
Author:: Joe Schmoe
Date:: today
=end class Doc  
  Constant = nil   
  
  #  
  
  #  def a_method(arg1, arg2='default value')    do_stuff   end   
  def self.class_method    Constant  endend # :include:boilerplate.txt"
"irb(main):001:0> require 'matrix'=> trueirb(main):002:0> Vector[1, 3, -5].inner_product Vector[4, -2, -1]=> 3class Array  def dot_product(other)    raise strv if self.length != other.length    self.zip(other).inject(0) {|dp, (a, b)| dp += a*b}  endend p [1, 3, -5].dot_product [4, -2, -1]   
func dot_product(a, b) {    (a »*« b)«+»;};say dot_product([1,3,-5], [4,-2,-1]);   
"
"require 'drb/drb' 
URI=strv class TimeServer   def get_current_time    return Time.now  end end 
FRONT_OBJECT = TimeServer.new $SAFE = 1   
 DRb.start_service(URI, FRONT_OBJECT)
DRb.thread.joinrequire 'drb/drb' 
SERVER_URI = strv 
#


DRb.start_service timeserver = DRbObject.new_with_uri(SERVER_URI)puts timeserver.get_current_time"
"def solve( problem )  lines = problem.split(strv)  names = lines.first.scan( /[A-Z]\w*/ )  re_names = Regexp.union( names )  
  words = %w(first second third fourth fifth sixth seventh eighth ninth tenth   bottom top higher lower adjacent)  re_keywords = Regexp.union( words )   predicates = lines[1..-2].flat_map do |line|  #build an array of lambda's    keywords = line.scan( re_keywords )    name1, name2 = line.scan( re_names )    keywords.map do |keyword|      l = case keyword         when strv   then ->(c){ c.first == name1 }        when strv      then ->(c){ c.last == name1 }        when strv   then ->(c){ c.index( name1 ) > c.index( name2 ) }        when strv    then ->(c){ c.index( name1 ) < c.index( name2 ) }        when strv then ->(c){ (c.index( name1 ) - c.index( name2 )).abs == 1 }        else                 ->(c){ c[words.index(keyword)] == name1 }      end      line =~ /\bnot\b/ ? ->(c){not l.call(c) } : l  
    end  end   names.permutation.detect{|candidate| predicates.all?{|predicate| predicate.(candidate)}}end#Direct positional words like top, bottom, first, second etc. can be combined; they refer to one name.#The relative positional words higher, lower and adjacent can be combined; they need two names, not positions. demo1 = ""Abe Ben Charlie David. Abe not second top. not adjacent Ben Charlie.
David Abe adjacent. David adjacent Ben. Last line."" demo2 = strv problem1 = ""Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that
contains only five floors. Baker does not live on the top floor. Cooper does not live on the bottom floor.
Fletcher does not live on either the top or the bottom floor. Miller lives on a higher floor than does Cooper.
Smith does not live on a floor adjacent to Fletcher's. Fletcher does not live on a floor adjacent to Cooper's.
Where does everyone live?"" 
problem2 = ""Baker, Cooper, Fletcher, Miller, Guinan, and Smith
live on different floors of an apartment house that contains
only seven floors. Guinan does not live on either the top or the third or the fourth floor.
Baker does not live on the top floor. Cooper
does not live on the bottom floor. Fletcher does not live on
either the top or the bottom floor. Miller lives on a higher
floor than does Cooper. Smith does not live on a floor
adjacent to Fletcher's. Fletcher does not live on a floor
adjacent to Cooper's. Where does everyone live?"" [demo1, demo2, problem1, problem2].each{|problem| puts solve( problem ) ;puts }names = %i( Baker Cooper Fletcher Miller Smith ) predicates = [->(c){ :Baker != c.last },              ->(c){ :Cooper != c.first },              ->(c){ :Fletcher != c.first && :Fletcher != c.last },               ->(c){ c.index(:Miller) > c.index(:Cooper) },              ->(c){ (c.index(:Smith) - c.index(:Fletcher)).abs != 1 },              ->(c){ (c.index(:Cooper) - c.index(:Fletcher)).abs != 1 }] puts names.permutation.detect{|candidate| predicates.all?{|predicate| predicate.call(candidate)}}func dinesman(problem) {  var lines = problem.split('.');  var names = lines.first.scan(/\b[A-Z]\w*/);  var re_names = Regex(names.join('|'));   
  var words = %w(first second third fourth fifth sixth seventh eighth ninth tenth                 bottom top higher lower adjacent);  var re_keywords = Regex(words.join('|'));   
  var predicates = lines.ft(1, lines.end-1).map{ |line|    var keywords = line.scan(re_keywords);    var (name1, name2) = line.scan(re_names)...;     keywords.map{ |keyword|      var l = do {        given(keyword) {            when (strv)   { ->(c) { c.first == name1 } }            when (strv)      { ->(c) { c.last == name1 } }            when (strv)   { ->(c) { c.index(name1) > c.index(name2) } }            when (strv)    { ->(c) { c.index(name1) < c.index(name2) } }            when (strv) { ->(c) { c.index(name1) - c.index(name2) -> abs == 1 } }            default           { ->(c) { c[words.index(keyword)] == name1 } }        }      }      line ~~ /\bnot\b/ ? func(c) { l(c) -> not } : l;  
    }  }.flatten;   names.permutations { |candidate|    predicates.all { |predicate| predicate(candidate) } && return candidate;  }}var demo1 = ""Abe Ben Charlie David. Abe not second top. not adjacent Ben Charlie.
David Abe adjacent. David adjacent Ben. Last line."" var demo2 = strv var problem1 = ""Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that
contains only five floors. Baker does not live on the top floor. Cooper does not live on the bottom floor.
Fletcher does not live on either the top or the bottom floor. Miller lives on a higher floor than does Cooper.
Smith does not live on a floor adjacent to Fletcher's. Fletcher does not live on a floor adjacent to Cooper's.
Where does everyone live?"" var problem2 = ""Baker, Cooper, Fletcher, Miller, Guinan, and Smith
live on different floors of an apartment house that contains
only seven floors. Guinan does not live on either the top or the third or the fourth floor.
Baker does not live on the top floor. Cooper
does not live on the bottom floor. Fletcher does not live on
either the top or the bottom floor. Miller lives on a higher
floor than does Cooper. Smith does not live on a floor
adjacent to Fletcher's. Fletcher does not live on a floor
adjacent to Cooper's. Where does everyone live?"" [demo1, demo2, problem1, problem2].each{|problem| say dinesman(problem).join(""""); say '' };var names = %w(Baker Cooper Fletcher Miller Smith) var predicates = [    ->(c){ :Baker != c.last },    ->(c){ :Cooper != c.first },    ->(c){ (:Fletcher != c.first) && (:Fletcher != c.last) },    ->(c){ c.index(:Miller) > c.index(:Cooper) },    ->(c){ (c.index(:Smith) - c.index(:Fletcher)).abs != 1 },    ->(c){ (c.index(:Cooper) - c.index(:Fletcher)).abs != 1 },] names.permutations { |candidate|    if (predicates.all {|predicate| predicate(candidate) }) {        say candidate.join("""")        break    }}"
"irb(main):001:0> require 'socket'=> trueirb(main):002:0> Addrinfo.getaddrinfo(strv, nil, nil, :DGRAM) \irb(main):003:0*   .map! { |ai| ai.ip_address }=> [strv, strv]var (err, *res) = Socket.getaddrinfo(        'www.kame.net', 0,        Hash.new(protocol => Socket.IPPROTO_TCP));err && die err;res.each { |z|    say [Socket.getnameinfo(z{:addr}, Socket.NI_NUMERICHOST)][1];}"
"class Graph  Vertex = Struct.new(:name, :neighbours, :dist, :prev)   def initialize(graph)    @vertices = Hash.new{|h,k| h[k]=Vertex.new(k,[],Float::INFINITY)}    @edges = {}    graph.each do |(v1, v2, dist)|      @vertices[v1].neighbours << v2      @vertices[v2].neighbours << v1      @edges[[v1, v2]] = @edges[[v2, v1]] = dist    end    @dijkstra_source = nil  end   def dijkstra(source)    return  if @dijkstra_source == source    q = @vertices.values    q.each do |v|      v.dist = Float::INFINITY      v.prev = nil    end    @vertices[source].dist = 0    until q.empty?      u = q.min_by {|vertex| vertex.dist}      break if u.dist == Float::INFINITY      q.delete(u)      u.neighbours.each do |v|        vv = @vertices[v]        if q.include?(vv)          alt = u.dist + @edges[[u.name, v]]          if alt < vv.dist            vv.dist = alt            vv.prev = u.name          end        end      end    end    @dijkstra_source = source  end   def shortest_path(source, target)    dijkstra(source)    path = []    u = target    while u      path.unshift(u)      u = @vertices[u].prev    end    return path, @vertices[target].dist  end   def to_s    ""#<%s vertices=%p edges=%p>"" % [self.class.name, @vertices.values, @edges] 
  end
end
 
g = Graph.new([ [:a, :b, 7],
                [:a, :c, 9],
                [:a, :f, 14],
                [:b, :c, 10],
                [:b, :d, 15],
                [:c, :d, 11],
                [:c, :f, 2],
                [:d, :e, 6],
                [:e, :f, 9],
              ])
 
start, stop = :a, :e
path, dist = g.shortest_path(start, stop)
puts ""shortest path from #{start} to #{stop} has cost #{dist}:""puts path.join(strv)class Graph(*args) {     struct Node {        String name,        Array edges = [],        Number dist = Inf,        prev = nil,        Bool visited = false,    }     struct Edge {        Number weight,        Node vertex,    }     has g = Hash()     method init {        args.each { |a|            self.add_edge(a...)        }    }     method get(name) {        g{name}    }     method add_edge(a, b, weight) {        g{a} ||= Node(name: a)        g{b} ||= Node(name: b)        g{a}.edges << Edge(weight, g{b})    }     method push_priority(a, v) {        var i = 0        var j = a.end        while (i <= j) {            var k = ((i + j) // 2)            if (a[k].dist >= v.dist) {                j = k-1            }            else {                i = k+1            }        }        a.insert(i, v)    }     method dijkstra(a, b) {        g{a}.dist = 0        var h = []        self.push_priority(h, g{a})        while (!h.is_empty) {            var v = h.shift            break if (v.name == b)            v.visited = true            v.edges.each { |e|                var u = e.vertex                if (!u.visited && (v.dist+e.weight <= u.dist)) {                    u.prev = v                    u.dist = (v.dist + e.weight)                    self.push_priority(h, u)                }            }        }    }} var g = Graph(    [strv, strv, 7],    [strv, strv, 9],    [strv, strv, 14],    [strv, strv, 10],    [strv, strv, 15],    [strv, strv, 11],    [strv, strv, 2],    [strv, strv, 6],    [strv, strv, 9],) g.dijkstra('a', 'e') var v = g.get('e')var a = []while (v != nil) {    a << v.name    v = v.prev} var path = a.reverse.joinsay strv"
"require 'date' class DiscordianDate  SEASON_NAMES = [strv,strv,strv,strv,strv]  DAY_NAMES = [strv,strv,strv,strv,strv]  YEAR_OFFSET = 1166  DAYS_PER_SEASON = 73  DAYS_PER_WEEK = 5  ST_TIBS_DAY_OF_YEAR = 60   def initialize(year, month, day)    gregorian_date = Date.new(year, month, day)    @day_of_year = gregorian_date.yday     @st_tibs = false    if gregorian_date.leap?      if @day_of_year == ST_TIBS_DAY_OF_YEAR        @st_tibs = true      elsif @day_of_year > ST_TIBS_DAY_OF_YEAR        @day_of_year -= 1      end    end     @season, @day = (@day_of_year-1).divmod(DAYS_PER_SEASON)    @day += 1     #←              ↑ fixes of-by-one error (only visible at season changes)    @year = gregorian_date.year + YEAR_OFFSET  end  attr_reader :year, :day   def season    SEASON_NAMES[@season]  end   def weekday    if @st_tibs      strv    else      DAY_NAMES[(@day_of_year - 1) % DAYS_PER_WEEK]    end  end   def to_s    %Q{_tibs ? strv % [weekday, season, day]}, #{year} YOLD}  endend[[2012, 2, 28], [2012, 2, 29], [2012, 3, 1], [2011, 10, 5], [2015, 10, 19]].each do |date|  dd = DiscordianDate.new(*date)  puts strv%4d-%02d-%02dstrvendrequire('Time::Piece'); var seasons = %w(Chaos Discord Confusion Bureaucracy The\ Aftermath);var week_days = %w(Sweetmorn Boomtime Pungenday Prickle-Prickle Setting\ Orange); func ordinal (n) {    strv + (n % 100 ~~ [11,12,13] ? 'th'                                    : <th st nd rd th th th th th th>[n % 10])} func ddate(ymd) {    var d = %s'Time::Piece'.strptime(ymd, '%Y-%m-%d');    var yold = strv;     var day_of_year0 = d.day_of_year;     if (d.is_leap_year) {        return strv if ([d.mon, d.mday] == [2, 29]);        day_of_year0-- if (day_of_year0 >= 60); 
    }     var weekday = week_days[day_of_year0 % week_days.len];    var season = seasons[day_of_year0 / 73];    var season_day = ordinal(day_of_year0 % 73 + 1);     return strv;} %w(2010-07-22 2012-02-28 2012-02-29 2012-03-01).each { |ymd|    say strv}"
"def mdroot(n)  mdr, persist = n, 0  until mdr < 10 do    mdr = mdr.to_s.each_char.map(&:to_i).inject(:*)    persist += 1  end  [mdr, persist]end puts strv, strv[123321, 7739, 893, 899998].each{|n| puts strv % [n, *mdroot(n)]} counter = Hash.new{|h,k| h[k]=[]}0.step do |i|  counter[mdroot(i).first] << i  break if counter.values.all?{|v| v.size >= 5 }endputs strv, strv, strv10.times{|i| puts strv % [i, counter[i].first(5)]}func mdroot(n) {  var (mdr, persist) = (n, 0)  while (mdr >= 10) {    mdr = mdr.digits.product    ++persist  }  [mdr, persist]} say ""Number: MDR  MP======  ===  ==""[123321, 7739, 893, 899998].each{|n| ""%6d: %3d %3d"" \                           .printf(n, mdroot(n)...) } var counter = Hash() Inf.times { |i|  var j = i-1  counter{mdroot(j).first} := [] << j  break if counter.values.all {|v| v.len >= 5 }} say ""MDR: [n0..n4]===  ========""10.times {|i| ""%3d: %s"".printf(i-1, counter{i-1}.first(5)) }"
"class String  def digroot_persistence(base=10)    num = self.to_i(base)    persistence = 0    until num < base do      num = num.to_s(base).each_char.reduce(0){|m, c| m + c.to_i(base) }      persistence += 1    end    [num.to_s(base), persistence]  endend puts strv%w(627615 39390 588225 393900588225).each do |str|  puts strv % [str, *str.digroot_persistence]endputs ""--- Examples in other Base ---""format = strv[[strv, 2], [ strv, 16], [strv, 8], [strv, 36]].each do |(str, base)|   puts format % [str, base, *str.digroot_persistence(base)]endfunc digroot (r, base = 10) {    var root = r.base(base)    var persistence = 0    while (root.len > 1) {        root = root.chars.map{|n| Number(n, 36) }.sum(0).base(base)        ++persistence    }    return(persistence, root)} var nums = [5, 627615, 39390, 588225, 393900588225]var bases = [2, 3, 8, 10, 16, 36]var fmt = ""%25s(%2s): persistance = %s, root = %2s"" nums << (550777011503 *         105564897893993412813307040538786690718089963180462913406682192479) bases.each { |b|    nums.each { |n|        var x = n.base(b)        x = 'BIG' if (x.len > 25)        fmt.printf(x, b, digroot(n, b))    }    print """"}"
"def roll_dice(n_dice, n_faces)  return [[0,1]] if n_dice.zero?  one  = [1] * n_faces  zero = [0] * (n_faces-1)  (1...n_dice).inject(one){|ary,_|    (zero + ary + zero).each_cons(n_faces).map{|a| a.inject(:+)}  }.map.with_index(n_dice){|n,sum| [sum,n]}  
end def game(dice1, faces1, dice2, faces2)  p1 = roll_dice(dice1, faces1)  p2 = roll_dice(dice2, faces2)  p1.product(p2).each_with_object([0,0,0]) do |((sum1, n1), (sum2, n2)), win|    win[sum1 <=> sum2] += n1 * n2        
  endend [[9, 4, 6, 6], [5, 10, 6, 7]].each do |d1, f1, d2, f2|  puts strv  puts strv  win = game(d1, f1, d2, f2)  sum = win.inject(:+)  puts strv,       strv, strvendfunc combos(sides, n) {    n || return [1]    var ret = ([0] * (n*sides.max + 1))    combos(sides, n-1).each_kv { |i,v|        v && for s in sides { ret[i + s] += v }    }    return ret} func winning(sides1, n1, sides2, n2) {    var (p1, p2) = (combos(sides1, n1), combos(sides2, n2))    var (win,loss,tie) = (0,0,0)    p1.each_kv { |i, x|        win  += x*p2.ft(0,i-1).sum(0)        tie  += x*p2.ft(i, i).sum(0)        loss += x*p2.ft(i+1).sum(0)    }    [win, tie, loss] »/» p1.sum*p2.sum} func display_results(String title, Array res) {    say strv    for name, prob in (%w(p₁\ win tie p₂\ win) ~Z res) {        say strv    }    print """"} display_results('9D4 vs 6D6',  winning(range(1, 4), 9, range(1,6), 6))display_results('5D10 vs 6D7', winning(range(1,10), 5, range(1,7), 6))"
"def main  puts strv  sleep 20  puts :doneend if $0 == __FILE__  if File.new(__FILE__).flock(File::LOCK_EX | File::LOCK_NB)    main  else    raise strv  endend __END__

var fh = File(__FILE__).open_r 
fh.flock(File.LOCK_EX | File.LOCK_NB) ->    || die strv 
say strvSys.sleep(20)say 'Done!'"
"require 'mutex_m' class Philosopher  def initialize(name, left_fork, right_fork)    @name = name    @left_fork = left_fork    @right_fork = right_fork    @meals = 0  end   def go    while @meals < 5      think      dine    end    puts ""philosopher  is full!""  end   def think    puts ""philosopher  is thinking...""    sleep(rand())    puts ""philosopher  is hungry...""  end   def dine    fork1, fork2 = @left_fork, @right_fork    while true      pickup(fork1, :wait => true)      puts ""philosopher  has fork #{fork1.fork_id}...""      if pickup(fork2, :wait => false)        break      end      puts ""philosopher  cannot pickup second fork #{fork2.fork_id}...""      release(fork1)      fork1, fork2 = fork2, fork1    end    puts ""philosopher  has the second fork #{fork2.fork_id}...""     puts ""philosopher  eats...""    sleep(rand())    puts ""philosopher  belches""    @meals += 1     release(@left_fork)    release(@right_fork)  end   def pickup(fork, opt)    puts ""philosopher  attempts to pickup fork #{fork.fork_id}...""    opt[:wait] ? fork.mutex.mu_lock : fork.mutex.mu_try_lock  end   def release(fork)    puts ""philosopher  releases fork #{fork.fork_id}...""    fork.mutex.unlock  endend n = 5 Fork = Struct.new(:fork_id, :mutex)forks = Array.new(n) {|i| Fork.new(i, Object.new.extend(Mutex_m))} philosophers = Array.new(n) do |i|                  Thread.new(i, forks[i], forks[(i+1)%n]) do |id, f1, f2|                   ph = Philosopher.new(id, f1, f2).go                 end               end philosophers.each {|thread| thread.join}"
"def div_check(x, y)  begin    x / y  rescue ZeroDivisionError    true  else    false  endendirb(main):010:0> div_check(5, 0)=> trueirb(main):011:0> div_check(5.0, 0)=> falsedef div_check(x, y)  begin    x.div y  rescue ZeroDivisionError    true  else    false  endendirb(main):010:0> div_check(5, 0)=> trueirb(main):011:0> div_check(5.0, 0)=> truefunc div(a, b){    try {        a / b    }    catch { |_, msg|        say strv if (msg ~~ /Division by zero/)        nil    }} say div(10, 2);      
say div(1, 0);       
say div(1.c, 0.c);   
"
"def funnel(dxs, &rule)  x, rxs = 0, []  for dx in dxs    rxs << (x + dx)    x = rule[x, dx]  end  rxsend def mean(xs) xs.inject(:+) / xs.size end def stddev(xs)  m = mean(xs)  Math.sqrt(xs.inject(0.0){|sum,x| sum + (x-m)**2} / xs.size)end def experiment(label, dxs, dys, &rule)  rxs, rys = funnel(dxs, &rule), funnel(dys, &rule)  puts label  puts 'Mean x, y    : %7.4f, %7.4f' % [mean(rxs), mean(rys)]  puts 'Std dev x, y : %7.4f, %7.4f' % [stddev(rxs), stddev(rys)]  putsend dxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,         0.443, -0.521, -0.799,  0.087] dys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,        -0.947, -1.424, -0.542, -1.032] experiment('Rule 1:', dxs, dys) {|z, dz| 0}experiment('Rule 2:', dxs, dys) {|z, dz| -dz}experiment('Rule 3:', dxs, dys) {|z, dz| -(z+dz)}experiment('Rule 4:', dxs, dys) {|z, dz| z+dz}"
"class Delegator   attr_accessor :delegate   def operation      if @delegate.respond_to?(:thing)         @delegate.thing      else         'default implementation'      end   endend class Delegate   def thing      'delegate implementation'   endend if __FILE__ == $PROGRAM_NAME    
   a = Delegator.new   puts a.operation 
    
   a.delegate = 'A delegate may be any object'   puts a.operation 
    
   a.delegate = Delegate.new   puts a.operation 
endrequire 'forwardable' class Delegator; extend Forwardable  attr_accessor :delegate  def_delegator :@delegate, :thing, :delegated   def initialize    @delegate = Delegate.new()  endend class Delegate  def thing    'Delegate'  endend a = Delegator.newputs a.delegated 
 "
"File.delete(strv, strv)Dir.delete(strv)Dir.delete(strv)
%f'input.txt' -> delete;%d'docs'      -> delete; 
Dir.root + %f'input.txt' -> delete;Dir.root + %d'docs'      -> delete;"
"
orig = { :num => 1, :ary => [2, 3] }orig[:cycle] = orig	
 
copy = Marshal.load(Marshal.dump orig) 

orig[:ary] << 4orig[:rng] = (5..6) 

p orig	
p copy	
 

p [(orig.equal? orig[:cycle]),   (copy.equal? copy[:cycle]),   (not orig.equal? copy)]	
var src = Hash(foo => 0, bar => [0,1]) 
src{:baz} = src 
var dst = src.dclone 
say src.object_idsay src{:baz}.object_id 
say dst.object_idsay dst{:baz}.object_id"
"require 'test/unit'include ::Assertions class MyInt  @@min = 1  @@max = 10   attr_reader :value  private :value   def initialize(val)    begin      v = Integer(val)    rescue ArgumentError      raise ArgumentError, strv    end     unless v.between?(@@min, @@max)      raise ArgumentError, strv    end     @value = v  end   def method_missing(m, *args)    super unless @value.respond_to?(m)    myint_args = args.collect do |arg|      arg.kind_of?(self.class) ? arg.to_int : arg    end    result = @value.send(m, *myint_args)    return result if m == :coerce    case result    when Integer      MyInt.new(result)    when Array      result.collect do |element|        element.kind_of?(Integer) ? MyInt.new(element) : element      end    else      result    end  end   def respond_to?(method)    super or @value.respond_to? method  end   def to_int    @value  end  def to_f    Float(@value)  end  def to_s    @value.to_s  end  def inspect    to_s  endend  assert_raise(ArgumentError) { MyInt.new(strv) }    
assert_raise(ArgumentError) { MyInt.new(11) }       
 a = MyInt.new(7)b = MyInt.new(5) c = 5 + aassert_kind_of(Fixnum, c)assert_equal(12, c) c = a + 2assert_kind_of(MyInt, c)assert_equal(9, c.to_int) c = a + 2.8assert_kind_of(Float, c)assert_equal(9.8, c) c = a - bassert_kind_of(MyInt, c)assert_equal(2, c.to_int) assert_raise(ArgumentError) { c = a + b }    
assert_raise(ArgumentError) { c = b - a }    
subset Integer    < Number  { .is_int }subset MyIntLimit < Integer { . ~~ (1 ..^ 10) } class MyInt(value < MyIntLimit) {     method to_s      { value.to_s }    method get_value { value.get_value }     method ==(Number x) { value == x }    method ==(MyInt  x) { value == x.value }     method AUTOLOAD(_, name, *args) {        var results = [value.(name)(args.map {|n| Number(n) }...)]        results.map{|r| r.kind_of(Number) ? MyInt(r.int) : r}...    }} ### Example:#var a = MyInt(2)    
a += 7              
say a               
say a/2             
 var b = (a - 3)     
say b               
 say a.as_hex.dump   
 a -= 6              
var c = (a + b)     
say c               
say c.class         
 a *= 2              
say a+b             
"
"def is_numeric?(s)  begin    Float(s)  rescue    false 
  else    true 
  endenddef is_numeric?(s)    !!Float(s) rescue falseendstrings = %w(0 0.0 -123 abc 0x10 0xABC 123a -123e3 0.1E-5 50e)strings.each do |str|  puts strv % [str, is_numeric?(str)]endsay strv.looks_like_number;       #=> truefunc is_numeric(s) {    (s ~~ /^[+-]?+(?=\.?[0-9])[0-9_]*+(?:\.[0-9_]++)?(?:[Ee](?:[+-]?+[0-9_]+))?\z/) ||    (s ~~ /^0(?:b[10_]*|x[0-9A-Fa-f_]*|[0-9_]+\b)\z/)}var strings = %w(0 0.0 -123 abc 0x10 0xABC 123a -123e3 0.1E-5 50e);for str in strings {    say (strv % (str, is_numeric(str)))}"
"def dec2bin(dec, precision=16)    
  int, df = dec.split(strv)  minus = int.delete!(strv)  bin = (minus ? strv : strv) + int.to_i.to_s(2) + strv  if df and df.to_i>0    fp = (strv+df).to_f    digit = 1    until fp.zero? or digit>precision      fp *= 2      n = fp.to_i      bin << n.to_s      fp -= n      digit += 1    end  else    bin << strv  end  binend def bin2dec(bin)              
  int, df = bin.split(strv)  minus = int.delete!(strv)  dec = (minus ? strv : strv) + int.to_i(2).to_s  if df    dec << (df.to_i(2) / 2.0**(df.size)).to_s[1..-1]  else    dec << strv  endend data = %w[23.34375 11.90625 -23.34375 -11.90625]data.each do |dec|  bin  = dec2bin(dec)  dec2 = bin2dec(bin)  puts strv % [dec, bin, dec2]endfunc dec2bin(String n) {    Num(Num(n, 10).base(2), 10)} func bin2dec(String n) {    Num(Num(n, 10).base(10), 2)} with(strv)   { |s| say (strv, dec2bin(s)) }with(strv) { |s| say (  strv, bin2dec(s)) }"
"class DecisionTable  def initialize(conditions, actions)    @conditions = conditions    @actions = []    @rules = []    actions.each {|action, ruleset| @actions << action; @rules << ruleset}   end   def run    puts strv    index = ask_conditions    puts strv    results = @rules.each_with_index.inject([]) do |sum, (ruleset, idx)|       sum << @actions[idx] if ruleset[index] == 1      sum    end    results << strv if results.empty?    results.each {|res| puts strv}    puts strv  end   private  def ask_conditions    answers = @conditions.inject(strv) {|sum, c| sum + get_response(c)}    answers.to_i(2)  end   def get_response(prompt)    loop do      print strv      case STDIN.gets.strip.downcase      when /^y/ then return strv      when /^n/ then return strv      end    end  endend dt = DecisionTable.new(      [        strv,              
        strv,             
        strv,             
      ],       [        [strv,                [0,0,1,0,0,0,0,0]],        [strv,     [1,0,1,0,0,0,0,0]],        [strv, [1,0,1,0,1,0,1,0]],        [strv,                    [1,1,0,0,1,1,0,0]],        [strv,                  [0,1,0,1,0,0,0,0]],      ]     )loop {dt.run}"
"

begin  games = ARGV.map {|s| Integer(s)}rescue => err  $stderr.puts err.inspect  $stderr.puts strv  abortendgames.empty? and games = [rand(32000)] 
orig_deck = %w{A 2 3 4 5 6 7 8 9 T J Q K}.product(%w{C D H S}).map(&:join) games.each do |seed|  deck = orig_deck.dup   
  
  state = seed  52.downto(2) do |len|    state = ((214013 * state) + 2531011) & 0x7fff_ffff    index = (state >> 16) % len    last = len - 1    deck[index], deck[last] = deck[last], deck[index]  end   deck.reverse!  
   
  puts strv  deck.each_slice(8) {|row| puts strv + row.join(strv)}  putsend"
"require 'time'd = strvt = Time.parse(d)puts t.rfc2822puts t.zone new = t + 12*3600puts new.rfc2822puts new.zone 
require 'rubygems'require 'active_support'zone = ActiveSupport::TimeZone['Beijing']remote = zone.at(new)
puts remote.rfc2822puts remote.zonenew = t + 12.hoursnew = t.in(12.hours)new = t.advance(:hours => 12)require strv puts d1 = DateTime.parse(strv)  
puts d2 = d1 + 1/2r 
puts d3 = d2.new_offset('+09:00')var dt = frequire('DateTime::Format::Strptime') var input =  'March 7 2009 7:30pm EST'input.sub!('EST', 'America/New_York') say dt.strptime('%b %d %Y %I:%M%p %O', input)   \      .add(hours => 12)                         \      .set_time_zone('America/Edmonton')        \      .format_cldr('MMMM d yyyy h:mma zzz')"
"require 'date' (2008..2121).each {|year| puts strv if Date.new(year, 12, 25).sunday? }(2008..2121).each {|year| puts strv if Time.local(year, 12, 25).sunday?}var tl = frequire('Time::Local'); for year in (2008 ..^ 2121) {    var time = tl.timelocal(0,0,0,25,11,year);    var wd = Time.new(time).local.wday;    if (wd == 0) {        say strv;    }}"
"def cut_it(h, w)  if h.odd?    return 0  if w.odd?    h, w = w, h  end  return 1  if w == 1   nxt = [[w+1, 1, 0], [-w-1, -1, 0], [-1, 0, -1], [1, 0, 1]]  
  blen = (h + 1) * (w + 1) - 1  grid = [false] * (blen + 1)   walk = lambda do |y, x, count=0|    return count+1  if y==0 or y==h or x==0 or x==w    t = y * (w + 1) + x    grid[t] = grid[blen - t] = true    nxt.each do |nt, dy, dx|      count += walk[y + dy, x + dx]  unless grid[t + nt]    end    grid[t] = grid[blen - t] = false    count  end   t = h / 2 * (w + 1) + w / 2  if w.odd?    grid[t] = grid[t + 1] = true    count = walk[h / 2, w / 2 - 1]    count + walk[h / 2 - 1, w / 2] * 2  else    grid[t] = true    count = walk[h / 2, w / 2 - 1]    return count * 2  if h == w    count + walk[h / 2 - 1, w / 2]  endend for w in 1..9  for h in 1..w    puts strv % [w, h, cut_it(w, h)]  if (w * h).even?  endendclass Rectangle  DIRS = [[1, 0], [-1, 0], [0, -1], [0, 1]]  def initialize(h, w)    raise ArgumentError  if (h.odd? and w.odd?) or h<=0 or w<=0    @h, @w = h, w    @limit = h * w / 2  end   def cut(disp=true)    @cut = {}    @select = []    @result = []    @grid = make_grid    walk(0,0)    display  if disp    @result  end   def make_grid    Array.new(@h+1) {|i| Array.new(@w+1) {|j| true if i<@h and j<@w }}  end   def walk(y, x)    @grid[y][x] = @grid[@h-y-1][@w-x-1] = false    @select.push([y,x])    select = @select.sort    unless @cut[select]      @cut[select] = true      if @select.size == @limit        @result << select      else        search_next.each {|yy,xx| walk(yy,xx)}      end    end    @select.pop    @grid[y][x] = @grid[@h-y-1][@w-x-1] = true  end   def search_next    nxt = {}    @select.each do |y,x|      DIRS.each do |dy, dx|        nxt[[y+dy, x+dx]] = true  if @grid[y+dy][x+dx]      end    end    nxt.keys  end   def display    @result.each do |select|      @grid = make_grid      select.each {|y,x| @grid[y][x] = false}      puts to_s    end  end   def to_s    text = Array.new(@h*2+1) {strv * (@w*4+1)}    for i in 0..@h      for j in 0..@w        text[i*2][j*4+1,3] = strv  if @grid[i][j] != @grid[i-1][j]        text[i*2+1][j*4]   = strv    if @grid[i][j] != @grid[i][j-1]        text[i*2][j*4]     = strv      end    end    text.join("""")  endend rec = Rectangle.new(2,2)puts rec.cut.size rec = Rectangle.new(3,4)puts rec.cut.size"
"puts Time.nowputs Time.now.strftime('%Y-%m-%d')puts Time.now.strftime('%F')            
puts Time.now.strftime('%A, %B %d, %Y')var time = Time.local;say time.ctime;say time.strftime(strv);say time.strftime(strv);"
" b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }p b.curry[1][2][3]           #=> 6p b.curry[1, 2][3, 4]        #=> 6p b.curry(5)[1][2][3][4][5]  #=> 6p b.curry(5)[1, 2][3, 4][5]  #=> 6p b.curry(1)[1]              #=> 1 b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }p b.curry[1][2][3]           #=> 6p b.curry[1, 2][3, 4]        #=> 10p b.curry(5)[1][2][3][4][5]  #=> 15p b.curry(5)[1, 2][3, 4][5]  #=> 15p b.curry(1)[1]              #=> 1 var adder = 1.method(:add);say adder(3);                #=> 4func curry(f, *args1) {    func (*args2) {        f(args1..., args2...);    }} func add(a, b) {    a + b} var adder = curry(add, 1);say adder(3);                 #=>4"
"class StdDevAccumulator  def initialize    @n, @sum, @sumofsquares = 0, 0.0, 0.0  end   def <<(num)    
    @n += 1    @sum += num    @sumofsquares += num**2    self  end   def stddev    Math.sqrt( (@sumofsquares / @n) - (@sum / @n)**2 )  end   def to_s    stddev.to_s  endend sd = StdDevAccumulator.newi = 0[2,4,4,4,5,5,7,9].each {|n| puts strv }def sdaccum  n, sum, sum2 = 0, 0.0, 0.0  lambda do |num|    n += 1    sum += num    sum2 += num**2    Math.sqrt( (sum2 / n) - (sum / n)**2 )  endend sd = sdaccum[2,4,4,4,5,5,7,9].each {|n| print sd.call(n), strv}class StdDevAccumulator(n=0, sum=0, sumofsquares=0) {  method <<(num) {    n += 1;    sum += num;    sumofsquares += num**2;    self;  }   method stddev {    Math.sqrt(sumofsquares/n - Math.pow(sum/n, 2));  }   method to_s {    self.stddev.to_s;  }} var i = 0;var sd = StdDevAccumulator.new;[2,4,4,4,5,5,7,9].each {|n|    say strv}func stddev(x) {    static(num=0, sum=0, sum2=0);    num++;    sqrt(        (sum2 += x**2) / num -        (((sum += x) / num)**2)    );} %n(2 4 4 4 5 5 7 9).each { say stddev(_) };"
"



#


class FencedHash   
  
  #  
  
  
  
  def initialize(hash, obj=nil)    @default = obj    @hash = {}    hash.each_pair do |key, value|      
      
      @hash[key] = [value, value]    end  end   def initialize_clone(orig)    
    
    super    copy = {}    @hash.each_pair {|key, values| copy[key] = values.clone }    @hash = copy  end   def initialize_dup(orig)    
    
    super    copy = {}    @hash.each_pair {|key, values| copy[key] = values.dup }    @hash = copy  end   
  
  def [](key)    values = @hash[key]    if values      values[0]    else      @default    end  end   
  
  
  #  
  
  def []=(key, value)    values = @hash[key]    if values      values[0] = value    else      raise KeyError, strv    end  end  alias store []=   
  def clear    @hash.each_value {|values| values[0] = values[1]}    self  end   
  
  def delete(key)    values = @hash[key]    if values      old = values[0]      values[0] = values[1]      old  
    end    
  end   
  
  
  #  
  
  def delete_if    if block_given?      @hash.each_pair do |key, values|        yield(key, values[0]) and values[0] = values[1]      end      self    else      enum_for(:delete_if) { @hash.size }    end  end   
  attr_accessor :default   
  
  
  #  
  def each_key(&block)    if block      @hash.each_key(&block)      self    else      enum_for(:each_key) { @hash.size }    end  end   
  
  
  #  
  
  def each_pair    if block_given?      @hash.each_pair {|key, values| yield [key, values[0]] }      self    else      enum_for(:each_pair) { @hash.size }    end  end   
  
  
  #  
  def each_value    if block_given?      @hash.each_value {|values| yield values[0] }    else      enum_for(:each_value) { @hash.size }    end  end   
  
  
  #  
  def fetch(*argv)    argc = argv.length    unless argc.between?(1, 2)      raise(ArgumentError,            strv)    end    if argc == 2 and block_given?      warn(strv +           strv)    end     key, default = argv    values = @hash[key]    if values      values[0]    elsif block_given?      yield key    elsif argc == 2      default    else      raise KeyError, strv    end  end   
  def freeze    @hash.each_value {|values| values.freeze }    super  end   
  def has_key?(key)    @hash.has_key?(key)  end  alias include? has_key?  alias member? has_key?   
  
  
  #  
  
  def keep_if    if block_given?      @hash.each_pair do |key, values|        yield(key, values[0]) or values[0] = values[1]      end      self    else      enum_for(:keep_if) { @hash.size }    end  end   
  def keys    @hash.keys  end   
  def length    @hash.length  end  alias size length   
  def to_h    result = Hash.new(@default)    @hash.each_pair {|key, values| result[key] = values[0]}    result  end   
  def to_s    strv  end  alias inspect to_s   
  def values    @hash.each_value.map {|values| values[0]}  end   
  def values_at(*keys)    keys.map {|key| self[key]}  endend"
"require 'csv'
ar = CSV.table(strv).to_a #table method assumes headers and converts numbers if possible. 
ar.first << strvar[1..-1].each{|row| row << row.inject(:+)} 
CSV.open(strv, 'w') do |csv|  ar.each{|line| csv << line}end
var csvfile = %f'data.csv';var fh = csvfile.open_r;var header = fh.line.trim_end.split(',');var csv = fh.lines.map { .trim_end.split(',').map{.to_num} };fh.close; 
var out = csvfile.open_w;out.say([header..., 'SUM'].join(','));csv.each { |row| out.say([row..., row.sum].join(',')) };out.close;var csv = require('Text::CSV').new(    Hash(eol => """")); 
var csvfile = %f'data.csv';var fh = csvfile.open_r; 
var rows = [];var header = csv.getline(fh);while (var row = csv.getline(fh)) {    rows.append(row.map{.to_num});} 
header.append('SUM');rows.each { |row| row.append(row.sum) }; 
var out = csvfile.open_w;[header, rows...].each { |row|    csv.print(out, row);};"
"puts 'Enter width and height: 'w=gets.to_iarr = Array.new(gets.to_i){Array.new(w)}arr[1][3] = 5p arr[1][3]func make_matrix(x, y) {    y.of { x.of(0) };} var y = Sys.scanln(strv).to_i;var x = Sys.scanln(strv).to_i; var matrix = make_matrix(x, y);   
matrix[y/2][x/2] = 1;             
say matrix;                       
"
" def r  rand(10000)end STDOUT << strv.tap do |html|  html << strv  [    ['X', 'Y', 'Z'],    [r ,r ,r],    [r ,r ,r],    [r ,r ,r],    [r ,r ,r]   ].each_with_index do |row, index|    html << strv    html << strv    html << row.map { |e| strv}.join    html << strv  end   html << strvend def r; rand(10000); endtable = [[strv, strv, strv, strv],         [ 1,   r,   r,   r],         [ 2,   r,   r,   r],         [ 3,   r,   r,   r]] require 'rexml/document' xtable = REXML::Element.new(strv)table.each do |row|  xrow = REXML::Element.new(strv, xtable)  row.each do |cell|    xcell = REXML::Element.new(strv, xrow)    REXML::Text.new(cell.to_s, false, xcell)  endend formatter = REXML::Formatters::Pretty.newformatter.compact = trueformatter.write(xtable, $stdout)class HTML {    method _attr(Hash h) {        h.keys.sort.map {|k| %Q' #{k}=strv' }.join('')    }     method _tag(Hash h, name, value) {        strv + self._attr(h) + '>' + value + strv    }     method table(Hash h, *data) { self._tag(h, 'table', data.join('')) }    method table(*data)         { self.table(Hash(), data...) }} class Table < HTML {    method th(Hash h, value) { self._tag(h, 'th', value) }    method th(value)         { self.th(Hash(), value) }     method tr(Hash h, *rows) { self._tag(h, 'tr', rows.join('')) }    method tr(*rows)         { self.tr(Hash(), rows...) }     method td(Hash h, value) { self._tag(h, 'td', value) }    method td(value)         { self.td(Hash(), value) }} var header = %w(&nbsp; X Y Z);var rows = 5; var html = HTML.new;var table = Table.new; say html.table(    
    Hash(        cellspacing => 4,        style => strv     ),     
    table.tr(header.map{|elem| table.th(elem)}...),     
    (1..rows).map { |i|        table.tr(            table.td(:(align => 'right'), i),            (header.len - 1).of {                table.td(Hash(align => 'right'), 10000.rand.int)            }...        )    }...);"
"['/', './'].each{|dir|  Dir.mkdir(dir + 'docs')      
  File.open(dir + 'output.txt', 'w') {}  
}
%f'output.txt' -> create;%d'docs'       -> create; 
Dir.root + %f'output.txt' -> create;Dir.root + %d'docs'       -> create;"
"require 'matrix' def cramers_rule(a, terms)  raise ArgumentError, strv  unless a.square?  cols = a.to_a.transpose  cols.each_index.map do |i|    c = cols.dup    c[i] = terms    Matrix.columns(c).det / a.det  endend matrix = Matrix[    [2, -1,  5,  1],    [3,  2,  2, -6],    [1,  3,  3, -1],    [5, -2, -3,  3],] vector = [-3, -32, -47, 49]puts cramers_rule(matrix, vector)func det(a) {    a = a.map{.map{_}}    var sign = +1    var pivot = 1     for k in ^a {      var r = (k+1 .. a.end)      var previous_pivot = pivot       if ((pivot = a[k][k]) == 0) {        a.swap(r.first_by { a[_][k] != 0 } \\ return 0, k)        pivot = a[k][k]        sign.neg!      }       for i,j in (r ~X r) {        a[i][j] *= pivot           ->                -= a[i][k]*a[k][j] ->                /= previous_pivot      }    }    sign * pivot} func cramers_rule(A, terms) {    gather {        for i in ^A {            var Ai = A.map{.map{_}}            for j in ^terms {                Ai[j][i] = terms[j]            }            take(det(Ai))        }    } »/» det(A)} var matrix = [    [2, -1,  5,  1],    [3,  2,  2, -6],    [1,  3,  3, -1],    [5, -2, -3,  3],] var free_terms = [-3, -32, -47, 49]var (w, x, y, z) = cramers_rule(matrix, free_terms)... say strvsay strvsay strvsay strv"
"require 'cgi' puts '<table summary=strv>' def row2html str, wrap = strv  strv +    str.split(strv).map { |cell| strv }.join +  strvend puts row2html gets.chomp, strv if ARGV.delete strv while str = gets  puts row2html str.chompend puts strvfunc escape(str) { str.trans(« & < > », « &amp; &lt; &gt; ») }func tag(t, d)   { strv } func csv2html(str) {     var template = <<-'EOT'    <!DOCTYPE html>    <html>    <head><title>Some Text</title></head>    <body><table>    %s    </table></body></html>    EOT     template.sprintf(escape(str).lines.map{ |line|            tag('tr', line.split(',').map{|cell| tag('td', cell) }.join)        }.join("""")    )} var str = <<'EOT';Character,SpeechThe multitude,The messiah! Show us the messiah!Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>The multitude,Who are you?Brians mother,I'm his mother; that's who!The multitude,Behold his mother! Behold his mother!EOT print csv2html(str)"
"require 'zlib'printf ""0x%08x"", Zlib.crc32('The quick brown fox jumps over the lazy dog')
module CRC  
  
  
  Divisor = [0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26, 32] \    .inject(0) {|sum, exponent| sum + (1 << (32 - exponent))}   
  
  
  
  
  
  Table = Array.new(256) do |octet|    
    
    
    remainder = octet    (0..7).each do |i|      
      
      
      if remainder[i].zero?        
        
      else        
        
        
        
        
        remainder ^= (Divisor << i)      end    end    remainder >> 8      
  end   module_function   def crc32(string, crc = 0)    
    
    crc ^= 0xffff_ffff     
    string.each_byte do |octet|       
      
      
      
      
      
      #      
      
      
      
       remainder_1 = crc >> 8      remainder_2 = Table[(crc & 0xff) ^ octet]       
      
      crc = remainder_1 ^ remainder_2    end     
    
    crc ^ 0xffff_ffff  endend printf ""0x%08x"", CRC.crc32(strv)
"
"def make_change(amount, coins)  @cache = Array.new(amount+1){|i| Array.new(coins.size, i.zero? ? 1 : nil)}  @coins = coins  do_count(amount, @coins.length - 1)end def do_count(n, m)  if n < 0 || m < 0    0  elsif @cache[n][m]    @cache[n][m]  else    @cache[n][m] = do_count(n-@coins[m], m) + do_count(n, m-1)  endend p make_change(   1_00, [1,5,10,25])p make_change(1000_00, [1,5,10,25,50,100])def make_change2(amount, coins)  n, m = amount, coins.size  table = Array.new(n+1){|i| Array.new(m, i.zero? ? 1 : nil)}  for i in 1..n    for j in 0...m      table[i][j] = (i<coins[j] ? 0 : table[i-coins[j]][j]) +                    (j<1        ? 0 : table[i][j-1])    end  end  table[-1][-1]end p make_change2(   1_00, [1,5,10,25])p make_change2(1000_00, [1,5,10,25,50,100])func cc(_)                { 0 }func cc({ .is_neg  }, *_) { 0 }func cc({ .is_zero }, *_) { 1 } func cc(amount, first, *rest) is cached {    cc(amount, rest...) + cc(amount - first, first, rest...);} func cc_optimized(amount, *rest) {    cc(amount, rest.sort_by{|v| -v }...);} var x = cc_optimized(100, 1, 5, 10, 25);say strv; var y = cc_optimized(1000 * 100, 1, 5, 10, 25, 50, 100);say strv;"
"def countSubstrings str, subStr  str.scan(subStr).lengthend p countSubstrings strv, strv      #=> 3p countSubstrings strv, strv          #=> 2say strv.count(strv);say strv.count(strv);func countSubstring(s, ss) {    var re = Regex.new(ss.escape, 'g');      
    var counter = 0;    while (s =~ re) { ++counter };    return counter;} say countSubstring(strv,strv);say countSubstring(strv,strv);"
"

 (0_u8..255_u8).each { |i| puts i.to_s(8) }n = 0loop do  puts strv % n  n += 1end 
for n in 0..Float::INFINITY  puts n.to_s(8)end 
0.upto(1/0.0) do |n|  printf ""%o"", nend 
0.step do |n|  puts format(strv, n)endvar i = 0;loop { say i++.as_oct }"
"require 'optparse'require 'prime' maximum = 10OptionParser.new do |o|  o.banner = strv  o.on(strv, Integer,       strv) { |m| maximum = m }  o.parse! rescue ($stderr.puts $!, o; exit 1)  ($stderr.puts o; exit 1) unless ARGV.size == 0end 
puts strv unless maximum < 1 2.upto(maximum) do |i|  
  f = i.prime_division.map! do |factor, exponent|    
    ([factor] * exponent).join strv  end.join strv  puts strvendclass Counter {    method factors(n, p=2) {        var out = [];        while (n >= p*p) {            while (n % p == 0) {                out.append(p);                n /= p;            }            p = self.next_prime(p);        }        (n > 1 || out.len.is_zero) && out.append(n);        return out;    }     method is_prime(n) {        self.factors(n).len == 1    }     method next_prime(p) {        do {            p == 2 ? (p = 3) : (p+=2)        } while (!self.is_prime(p));        return p;    }} 100.times { |i|    say strv;}"
"original = strvreference = original          
copy1 = original.dup          
copy2 = String.new(original)  
 original << strv         
p reference                   #=> strvp copy1                       #=> strvp copy2                       #=> strvoriginal = strv.freeze     
copy1 = original.dup          
copy2 = original.clone        
p copy1.frozen?               #=> falsep copy1 << strv          #=> strvp copy2.frozen?               #=> truep copy2 << strv          #=> can't modify frozen String (RuntimeError)var original = strv;               
var reference = original;             
var copy1 = String.new(original);     
var copy2 = original+'';              
"
"MINUTE = 60HOUR   = MINUTE*60DAY    = HOUR*24WEEK   = DAY*7 def sec_to_str(sec)  w, rem = sec.divmod(WEEK)  d, rem = rem.divmod(DAY)  h, rem = rem.divmod(HOUR)  m, s   = rem.divmod(MINUTE)  units  = [strv, strv, strv, strv, strv]  units.reject{|str| str.start_with?(strv)}.join(strv)end [7259, 86400, 6000000].each{|t| puts ""#{t}: #{sec_to_str(t)}""}func polymod(n, *divs) {    gather {        divs.each { |i|            var m = take(n % i)            (n -= m) /= i        }        take(n)    }} func compound_duration(seconds) {    (polymod(seconds, 60, 60, 24, 7) ~Z <sec min hr d wk>).grep { |a|        a[0] > 0    }.reverse.map{.join(' ')}.join(', ')} [7259, 86400, 6000000].each { |s|    say strv}"
"
class NG  def initialize(a1, a, b1, b)    @a1, @a, @b1, @b = a1, a, b1, b  end  def ingress(n)    @a, @a1 = @a1, @a + @a1 * n    @b, @b1 = @b1, @b + @b1 * n  end  def needterm?    return true if @b == 0 or @b1 == 0    return true unless @a/@b == @a1/@b1    false  end  def egress    n = @a / @b    @a,  @b  = @b,  @a  - @b  * n    @a1, @b1 = @b1, @a1 - @b1 * n    n  end  def egress_done    @a, @b = @a1, @b1 if needterm?    egress  end  def done?    @b == 0 and @b1 == 0  endenddata = [[strv,      [2,1,0,2], [13,11]],        [strv,        [2,1,0,2], [22, 7]],        [strv, [1,0,0,4], [22, 7]]] data.each do |str, ng, r|  printf strv, str  op = NG.new(*ng)  r2cf(*r) do |n|    print strv unless op.needterm?    op.ingress(n)  end  print strv until op.done?  putsend"
"def game_of_life(name, size, generations, initial_life=nil)  board = new_board size  seed board, size, initial_life  print_board board, name, 0  reason = generations.times do |gen|    new = evolve board, size    print_board new, name, gen+1    break :all_dead if barren? new, size    break :static   if board == new    board = new  end  if    reason == :all_dead then puts strv  elsif reason == :static   then puts strv  else                           puts strv  end  putsend def new_board(n)  Array.new(n) {Array.new(n, 0)}end def seed(board, n, points=nil)  if points.nil?    
    indices = []    n.times {|x| n.times {|y| indices << [x,y] }}    indices.shuffle[0,10].each {|x,y| board[y][x] = 1}  else    points.each {|x, y| board[y][x] = 1}  endend def evolve(board, n)  new = new_board n  n.times {|i| n.times {|j| new[i][j] = fate board, i, j, n}}  newend def fate(board, i, j, n)  i1 = [0, i-1].max; i2 = [i+1, n-1].min  j1 = [0, j-1].max; j2 = [j+1, n-1].min  sum = 0  for ii in (i1..i2)    for jj in (j1..j2)      sum += board[ii][jj] if not (ii == i and jj == j)    end  end  (sum == 3 or (sum == 2 and board[i][j] == 1)) ? 1 : 0end def barren?(board, n)  n.times {|i| n.times {|j| return false if board[i][j] == 1}}  trueend def print_board(m, name, generation)  puts strv  m.each {|row| row.each {|val| print strv}; puts}end game_of_life strv, 3, 2, [[1,0],[1,1],[1,2]]game_of_life strv, 4, 4, [[1,0],[2,1],[0,2],[1,2],[2,2]]game_of_life strv, 5, 10class Game  def initialize(name, size, generations, initial_life=nil)    @size = size    @board = GameBoard.new size, initial_life    @board.display name, 0     reason = generations.times do |gen|      new_board = evolve      new_board.display name, gen+1      break :all_dead if new_board.barren?      break :static   if @board == new_board      @board = new_board    end     case reason    when :all_dead  then puts strv    when :static    then puts strv    else                 puts strv    end    puts  end   def evolve    life = @board.each_index.select {|i,j| cell_fate(i,j)}    GameBoard.new @size, life  end   def cell_fate(i, j)    left_right = [0, i-1].max .. [i+1, @size-1].min    top_bottom = [0, j-1].max .. [j+1, @size-1].min    sum = 0    for x in left_right      for y in top_bottom        sum += @board[x,y].value if x != i or y != j      end    end    sum == 3 or (sum == 2 and @board[i,j].alive?)  endend class GameBoard  include Enumerable   def initialize(size, initial_life=nil)    @size = size    @board = Array.new(size) {Array.new(size) {Cell.new false}}    seed_board initial_life  end   def seed_board(life)    if life.nil?      
      each_index.to_a.sample(10).each {|x,y| @board[y][x].live}    else      life.each {|x,y| @board[y][x].live}    end  end   def each    @size.times {|x| @size.times {|y| yield @board[y][x] }}  end   def each_index    return to_enum(__method__) unless block_given?    @size.times {|x| @size.times {|y| yield x,y }}  end   def [](x, y)    @board[y][x]  end   def ==(board)    self.life == board.life  end   def barren?    none? {|cell| cell.alive?}  end   def life    each_index.select {|x,y| @board[y][x].alive?}  end   def display(name, generation)    puts strv    puts @board.map {|row| row.map {|cell| cell.alive? ? '#' : '.'}.join(' ')}  end   def apocalypse    
    each {|cell| cell.die}  endend class Cell  def initialize(alive) @alive = alive  end  def alive?;           @alive          end  def value;            @alive ? 1 : 0  end  def live;             @alive = true   end  def die;              @alive = false  endend Game.new strv, 3, 2, [[1,0],[1,1],[1,2]]Game.new strv, 4, 4, [[1,0],[2,1],[0,2],[1,2],[2,2]]Game.new strv, 5, 10var w = `tput cols`.to_ivar h = `tput lines`.to_ivar r = ""33[H"" var dirs = [[-1,-1], [-1, 0], [-1, 1], [ 0,-1],            [ 0, 1], [ 1,-1], [ 1, 0], [ 1, 1]] var universe = h.of { w.of {1.rand < 0.1} } var rh = h.rangevar rw = w.range func iterate {    var new = h.of { w.of(false) }    for i in rh {        for j in rw {        var neighbor = 0        for y,x in (dirs.map {|dir| dir »+« [i, j] }) {            universe[y % h][x % w] && ++neighbor            neighbor > 3 && break        }        new[i][j] = (universe[i][j]                        ? (neighbor==2 || neighbor==3)                        : (neighbor==3))       }    }    universe = new} STDOUT.autoflush(true) loop {    print r    say universe.map{|row| row.map{|cell| cell ? '#' : ' '}.join }.join("""")    iterate()}"
"> '0.9054054 0.518518 0.75'.split.each { |d| puts strv % [d, Rational(d)] }0.9054054 4527027/50000000.518518 259259/5000000.75 3/4=> [strv, strv, strv][0.9054054, 0.518518, 0.75].each { |f| puts strv }


 '0.9054054 0.518518 0.75'.split.each { |d|    say d.num.as_rat;}say 0.9054054.as_rat;say 0.518518.as_rat;say 0.75.as_rat;"
"
 def r2cf(n1,n2)  while n2 > 0    n1, (t1, n2) = n2, n1.divmod(n2)    yield t1  endend[[1,2], [3,1], [23,8], [13,11], [22,7], [-151,77]].each do |n1,n2|  print strv % strv  r2cf(n1,n2) {|n| print strv}  putsend(5..8).each do |digit|  n2 = 10 ** (digit-1)  n1 = (Math.sqrt(2) * n2).round  print strv % [n1, n2]  r2cf(n1,n2) {|n| print strv}  putsenda =[ [31,10],     [314,100],     [3142,1000],     [31428,10000],     [314285,100000],     [3142857,1000000],     [31428571,10000000],     [314285714,100000000]   ]a.each do |n1,n2|  print strv % [n1, n2]  r2cf(n1,n2) {|n| print strv}  putsendfunc r2cf(num, den) {    func() {        den.is_zero && return()        var q = int(num/den)        (num, den) = (den, num - q*den)        return q    }} func showcf(f) {    print strv    var n = f()    print strv if defined(n)    print strv while defined(n = f())    print ""]""} [    [1/2, 3/1, 23/8, 13/11, 22/7, -151/77],    [14142/10000, 141421/100000, 1414214/1000000, 14142136/10000000],    [314285714/100000000],].each { |seq|    seq.each { |r| showcf(r2cf(r.parts)) }    print """"}"
"class Foodbox  def initialize (*food)    raise ArgumentError, strv unless  food.all?{|f| f.respond_to?(:eat)}    @box = food  endend class Fruit  def eat; endend class Apple < Fruit; end p Foodbox.new(Fruit.new, Apple.new)
 p Foodbox.new(Apple.new, strv)
 class FoodBox(*food { .all { .respond_to(:eat) } }) { } class Fruit { method eat { ... } }class Apple < Fruit {  } say FoodBox(Fruit(), Apple()).dump  #=> FoodBox(food: [Fruit(), Apple()])say FoodBox(Apple(), strv)         #!> ERROR: class `FoodBox` !~ (Apple, String)"
"require 'bigdecimal' 
sqrt2 = Object.newdef sqrt2.a(n); n == 1 ? 1 : 2; enddef sqrt2.b(n); 1; end 
napier = Object.newdef napier.a(n); n == 1 ? 2 : n - 1; enddef napier.b(n); n == 1 ? 1 : n - 1; end pi = Object.newdef pi.a(n); n == 1 ? 3 : 6; enddef pi.b(n); (2*n - 1)**2; end 


def estimate(cfrac, prec)  last_result = nil  terms = prec   loop do    
    result = cfrac.a(terms)    (terms - 1).downto(1) do |n|      a = BigDecimal cfrac.a(n)      b = BigDecimal cfrac.b(n)      digits = [b.div(result, 1).exponent + prec, 1].max      result = a + b.div(result, digits)    end    result = result.round(prec)     if result == last_result      return result    else      
      last_result = result      terms *= 2    end  endend puts estimate(sqrt2, 50).to_s('F')puts estimate(napier, 50).to_s('F')puts estimate(pi, 10).to_s('F')func continued_fraction(a, _, (0)) { a() }func continued_fraction(a, b, n=100) {    a() + (b() / continued_fraction(a, b, n-1));} var f = Hash.new(    strv => [        do { var n = 0; { n++ ? 2 : 1 } },        { 1 },    ],    strv => [        do { var n = 0; { n++ || 2 } },        do { var n = 0; { n++ || 1 } },    ],    strv => [        do { var n = 0; { n++ ? 6 : 3 } },        do { var n = 0; { (2*(n++) + 1)**2 } },        1_000,    ],    strv => [        do { var n = 0; { 1/(n++ || 1) } },        { 1 },        1_000,    ]); f.each { |k,v|    printf(""%3s ≈ %.9f"", k, continued_fraction(v...));}"
"require 'matrix' 
i = Complex::Imatrix = Matrix[[i, 0, 0],                [0, i, 0],                [0, 0, i]] 

conjt = matrix.conj.t           
print 'conjugate tranpose: '; puts conjt if matrix.square?  
  print 'Hermitian? '; puts matrix.hermitian?  print '   normal? '; puts matrix.normal?  print '  unitary? '; puts matrix.unitary?else  
  
  print 'Hermitian? false'  print '   normal? false'  print '  unitary? false'end"
"points = (1..100).map do  
  angle = rand * 2.0 * Math::PI  rad   = rand * 5.0 + 10.0  
  [rad * Math::cos(angle), rad * Math::sin(angle)].map(&:round)end (-15..15).each do |row|  puts (-15..15).map { |col| points.include?([row, col]) ? strv : strv }.joinend load 'raster_graphics.rb' pixmap = Pixmap.new(321,321)pixmap.draw_circle(Pixel.new(160,160),90,RGBColour::BLACK)pixmap.draw_circle(Pixel.new(160,160),160,RGBColour::BLACK)points.each {|(x,y)| pixmap[10*(x+16),10*(y+16)] = RGBColour::BLACK}pngfile = __FILE__pngfile[/\.rb/] = strvpixmap.save_as_png(pngfile)r2 = 10*10..15*15range = (-15..15).to_apoints = range.product(range).select {|i,j| r2.cover?(i*i + j*j)} puts strvpt = Hash.new(strv)points.sample(100).each{|ij| pt[ij] = strv}puts range.map{|i| range.map{|j| pt[[i,j]]}.join}var points = [];while (points.len < 100) {    var (x, y) = 2.of{31.rand.int - 15}...;    var r2 = (x**2 + y**2);    if ((r2 >= 100) && (r2 <= 225)) {        points.append([x, y]);    }} print <<'HEAD';%!PS-Adobe-3.0 EPSF-3.0%%BoundingBox 0 0 400 400200 200 translate 10 10 scale0 setlinewidth1 0 0 setrgbcolor0 0 10 0 360 arc stroke0 0 15 360 0 arcn stroke0 setgray/pt { .1 0 360 arc fill } defHEAD points.each { |pt| say strv };print '%%EOF';"
%w{Enjoy Rosetta Code}.map do |x|    Thread.new do        sleep rand        puts x    endend.each do |t|   t.joinendvar a = <Enjoy Rosetta Code> a.map{|str|    {   Sys.sleep(1.rand)        say str    }.fork}.map{|thr| thr.wait }
"Point = Struct.new(:x,:y)pt = Point.new(6,7)puts pt.x        #=> 6pt.y = 3puts pt          #=> #<struct Point x=6, y=3> 
pt = Point[2,3]puts pt[:x]      #=> 2pt['y'] = 5puts pt          #=> #<struct Point x=2, y=5> pt.each_pair{|member, value| puts strv}                 #=> x : 2                 #=> y : 5struct Point {x, y};var point = Point(1, 2);say point.y;                #=> 2"
"class Array  def radix_sort(base=10)       
    ary = dup    rounds = (Math.log(ary.max)/Math.log(base)).ceil    rounds.times do |i|      buckets = Array.new(base){[]}      base_i = base**i      ary.each do |n|        digit = (n/base_i) % base        buckets[digit] << n      end      ary = buckets.flatten    end    ary  end   def quick_sort    return self  if size <= 1    pivot = sample    g = group_by{|x| x<=>pivot}    g.default = []    g[-1].quick_sort + g[0] + g[1].quick_sort  end   def shell_sort    inc = size / 2    while inc > 0      (inc...size).each do |i|        value = self[i]        while i >= inc and self[i - inc] > value          self[i] = self[i - inc]          i -= inc        end        self[i] = value      end      inc = (inc == 2 ? 1 : (inc * 5.0 / 11).to_i)    end    self  end   def insertion_sort    (1...size).each do |i|      value = self[i]      j = i - 1      while j >= 0 and self[j] > value        self[j+1] = self[j]        j -= 1      end      self[j+1] = value    end    self  end   def bubble_sort    (1...size).each do |i|      (0...size-i).each do |j|        self[j], self[j+1] = self[j+1], self[j]  if self[j] > self[j+1]      end    end    self  endend data_size = [1000, 10000, 100000, 1000000]data = []data_size.each do |size|  ary = *1..size  data << [ [1]*size, ary, ary.shuffle, ary.reverse ]enddata = data.transpose data_type = [strv, strv, strv, strv]print strvputs data_size.map{|size| strv % size}.join data.each_with_index do |arys,i|  puts ""Data #{data_type[i]}:""  [:sort, :radix_sort, :quick_sort, :shell_sort, :insertion_sort, :bubble_sort].each do |m|    printf strv, m    flag = true    arys.each do |ary|      if flag        t0 = Time.now        ary.dup.send(m)        printf strv, (t1 = Time.now - t0)        flag = false  if t1 > 2      else        print strv      end    end    puts  endend"
"strings.uniq.one?                 
strings == strings.uniq.sort      
strings.all?{|str| str == strings.first} 
strings.each_cons(2).all?{|str1, str2| str1 < str2} 
1..arr.end -> all{ arr[0] == arr[_] }   
1..arr.end -> all{ arr[_-1] < arr[_] }  
arr.uniq.len == 1      
arr == arr.uniq.sort   
"
#! /usr/bin/env rubyp ARGVsay ARGV;
"x = strv 
 =begin hello
I a POD documentation comment like Perl
=end puts strv
var i = 1; 
var distance #`{in meters} = (30 #`{meters} * 100 #`{seconds});say distance; 
/*    This is a multi-line comment*/"
"module Screen  IMPORT_COMMAND = '/usr/bin/import'   
  def self.pixel(x, y)    if m = `#{IMPORT_COMMAND} -silent -window root -crop 1x1+#{x.to_i}+#{y.to_i} -depth 8 txt:-`.match(/\((\d+),(\d+),(\d+)\)/)      m[1..3].map(&:to_i)    else      false    end  endend"
"include Math class Integer   def permutation(k)    (self-k+1 .. self).inject( :*)  end   def combination(k)    self.permutation(k) / (1 .. k).inject( :*)  end   def big_permutation(k)    exp( lgamma_plus(self) - lgamma_plus(self -k))   end   def big_combination(k)    exp( lgamma_plus(self) - lgamma_plus(self - k) - lgamma_plus(k))  end   private  def lgamma_plus(n)    lgamma(n+1)[0]  #lgamma is the natural log of gamma  end end p 12.permutation(9)               #=> 79833600p 12.big_permutation(9)           #=> 79833600.00000021p 60.combination(53)              #=> 386206920p 145.big_permutation(133)        #=> 1.6801459655817956e+243p 900.big_combination(450)        #=> 2.247471882064647e+269p 1000.big_combination(969)       #=> 7.602322407770517e+58p 15000.big_permutation(73)       #=> 6.004137561717704e+304#That's about the maximum of Float:p 15000.big_permutation(74)       #=> Infinity#Fixnum has no maximum:p 15000.permutation(74)           #=> 896237613852967826239917238565433149353074416025197784301593335243699358040738127950872384197159884905490054194835376498534786047382445592358843238688903318467070575184552953997615178973027752714539513893159815472948987921587671399790410958903188816684444202526779550201576117111844818124800000000000000000000 (1..60).to_a.combination(53).size  #=> 386206920func P(n, k) { n! / ((n-k)!) };func C(n, k) { binomial(n, k) }; class Logarithm(value) {    method get_value { value };    method to_s {        var e = int(value/10.log);        strv % (exp(value - e*10.log), e);    }} func lstirling(n) {    n < 10 ? (lstirling(n+1) - log(n+1))           : (0.5*log(2*Number.pi*n) + n*log(n/Number.e + 1/(12*Number.e*n)));} func P_approx(n, k) {    Logarithm((lstirling(n) - lstirling(n -k)))} func C_approx(n, k) {    Logarithm((lstirling(n) - lstirling(n -k) - lstirling(k)))} say strv;range(1, 12).each { |n|    var p = int(n / 3);    say strv;} range(10, 60, 10).each { |n|    var p = int(n / 3);    say strv;} say '';say strv;[5, 50, 500, 1000, 5000, 15000].each { |n|    var p = int(n / 3);    say strv;} range(100, 1000, 100).each { |n|    var p = int(n / 3);    say strv;}"
"def comb(m, n)  (0...n).to_a.combination(m).to_aend comb(3, 5)  
(@^5).combinations(3, {|c| say c })func combine(n, set) {     set.len || return []    n == 1  && return set.map{[_]}     var (head, result)    head   = set.shift    result = combine(n-1, [set...])     for subarray in result {        subarray.prepend(head)    }     result + combine(n, set)} combine(3, @^5).each {|c| say c }func forcomb(callback, n, k) {     if (k == 0) {        callback([])        return()    }     if (k<0 || k>n || n==0) {        return()    }     var c = @^k     loop {        callback([c...])        c[k-1]++ < n-1 && next        var i = k-2        while (i>=0 && c[i]>=(n-(k-i))) {            --i        }        i < 0 && break        c[i]++        while (++i < k) {            c[i] = c[i-1]+1        }    }     return()} forcomb({|c| say c }, 5, 3)"
"procs = Array.new(10){|i| ->{i*i} } 
p procs[7].call 
var f = (    0 ..^ 9 -> map {|i| func(j){i * j} }); 0 ..^ 8 -> each { |j|    say f[j](j);}var f = 10.of { |i|    func(j){i * j}} 9.times { |j|    say f[j-1](j);}"
"Point = Struct.new(:x, :y) def distance(p1, p2)  Math.hypot(p1.x - p2.x, p1.y - p2.y)end def closest_bruteforce(points)  mindist, minpts = Float::MAX, []  points.combination(2) do |pi,pj|    dist = distance(pi, pj)    if dist < mindist      mindist = dist      minpts = [pi, pj]    end  end  [mindist, minpts]end def closest_recursive(points)  return closest_bruteforce(points) if points.length <= 3  xP = points.sort_by(&:x)  mid = points.length / 2  xm = xP[mid].x  dL, pairL = closest_recursive(xP[0,mid])  dR, pairR = closest_recursive(xP[mid..-1])  dmin, dpair = dL<dR ? [dL, pairL] : [dR, pairR]  yP = xP.find_all {|p| (xm - p.x).abs < dmin}.sort_by(&:y)  closest, closestPair = dmin, dpair  0.upto(yP.length - 2) do |i|    (i+1).upto(yP.length - 1) do |k|      break if (yP[k].y - yP[i].y) >= dmin      dist = distance(yP[i], yP[k])      if dist < closest        closest = dist        closestPair = [yP[i], yP[k]]      end    end  end  [closest, closestPair]end points = Array.new(100) {Point.new(rand, rand)}p ans1 = closest_bruteforce(points)p ans2 = closest_recursive(points)fail strv if ans1[0] != ans2[0] require 'benchmark' points = Array.new(10000) {Point.new(rand, rand)}Benchmark.bm(12) do |x|  x.report(strv) {ans1 = closest_bruteforce(points)}  x.report(strv)  {ans2 = closest_recursive(points)}endfunc dist_squared(a, b) {    sqr(a[0] - b[0]) + sqr(a[1] - b[1])} func closest_pair_simple(arr) {    arr.len < 2 && return Inf    var (a, b, d) = (arr[0, 1], dist_squared(arr[0,1]))    arr.clone!    while (arr) {        var p = arr.pop        for l in arr {            var t = dist_squared(p, l)            if (t < d) {                (a, b, d) = (p, l, t)            }        }    }    return(a, b, d.sqrt)} func closest_pair_real(rx, ry) {    rx.len <= 3 && return closest_pair_simple(rx)     var N = rx.len    var midx = (ceil(N/2)-1)    var (PL, PR) = rx.part(midx)     var xm = rx[midx][0]     var yR = []    var yL = []     for item in ry {        (item[0] <= xm ? yR : yL) << item    }     var (al, bl, dL) = closest_pair_real(PL, yR)    var (ar, br, dR) = closest_pair_real(PR, yL)     al == Inf && return (ar, br, dR)    ar == Inf && return (al, bl, dL)     var (m1, m2, dmin) = (dR < dL ? [ar, br, dR]...                                  : [al, bl, dL]...)     var yS = ry.grep { |a| abs(xm - a[0]) < dmin }     var (w1, w2, closest) = (m1, m2, dmin)    for i in (0 ..^ yS.end) {        for k in (i+1 .. yS.end) {            yS[k][1] - yS[i][1] < dmin || break            var d = dist_squared(yS[k], yS[i]).sqrt            if (d < closest) {                (w1, w2, closest) = (yS[k], yS[i], d)            }        }    }     return (w1, w2, closest)} func closest_pair(r) {    var ax = r.sort_by { |a| a[0] }    var ay = r.sort_by { |a| a[1] }    return closest_pair_real(ax, ay);} var N = 5000var points = N.of { [1.rand*20 - 10, 1.rand*20 - 10] }var (af, bf, df) = closest_pair(points)say strv"
"
a = []              #=> []a[0] = 1            #=> [1]a[3] = strv        #=> [1, nil, nil, strv]a << 3.14           #=> [1, nil, nil, strv, 3.14] 
a = Array.new               #=> []a = Array.new(3)            #=> [nil, nil, nil]a = Array.new(3, 0)         #=> [0, 0, 0]a = Array.new(3){|i| i*2}   #=> [0, 2, 4]
h = {}              #=> {}h[strv] = 1          #=> {strv=>1}h[strv] = 2.4     #=> {strv=>2.4}h[3] = strv      #=> {strv}h = {a:1, test:2.4, World!:strv}                    #=> {:a=>1, :test=>2.4, :World!=>strv} 
h = Hash.new        #=> {}   (default value : nil)p h[1]              #=> nilh = Hash.new(0)     #=> {}   (default value : 0)p h[1]              #=> 0p h                 #=> {}h = Hash.new{|hash, key| key.to_s}                    #=> {}p h[123]            #=> strvp h                 #=> {}h = Hash.new{|hash, key| hash[key] = strv}                    #=> {}p h[1]              #=> strvp h                 #=> {1=>strv}
 Person = Struct.new(:name, :age, :sex) a = Person.new(strv, 15, :Man)p a[0]              #=> strvp a[:age]           #=> 15p a.sex             #=> :Manp a.to_a            #=> [strv, 15, :Man]p a.to_h            #=> {:name=>strv, :age=>15, :sex=>:Man} b = Person.newp b                 #=> #<struct Person name=nil, age=nil, sex=nil>b.name = strvb[strv] = 18b[-1] = :Womanp b.values          #=> [strv, 18, :Woman]p b.members         #=> [:name, :age, :sex]p b.size            #=> 3 c = Person[strv, 22, :Man]p c.to_h            #=> {:name=>strv, :age=>22, :sex=>:Man}require 'set' 
p s1 = Set[1, 2, 3, 4]          #=> #<Set: {1, 2, 3, 4}>p s2 = [8, 6, 4, 2].to_set      #=> #<Set: {8, 6, 4, 2}>p s3 = Set.new(1..4) {|x| x*2}  #=> #<Set: {2, 4, 6, 8}> 
p s1 | s2                       #=> #<Set: {1, 2, 3, 4, 8, 6}>
p s1 & s2                       #=> #<Set: {4, 2}>
p s1 - s2                       #=> #<Set: {1, 3}> p s1 ^ s2                       #=> #<Set: {8, 6, 1, 3}> p s2 == s3                      #=> true p s1.add(5)                     #=> #<Set: {1, 2, 3, 4, 5}>p s1 << 0                       #=> #<Set: {1, 2, 3, 4, 5, 0}>p s1.delete(3)                  #=> #<Set: {1, 2, 4, 5, 0}>require 'matrix' 
p m0 = Matrix.zero(3)       #=> Matrix[[0, 0, 0], [0, 0, 0], [0, 0, 0]]p m1 = Matrix.identity(3)   #=> Matrix[[1, 0, 0], [0, 1, 0], [0, 0, 1]]p m2 = Matrix[[11, 12], [21, 22]]                            #=> Matrix[[11, 12], [21, 22]]p m3 = Matrix.build(3) {|row, col| row - col}                            #=> Matrix[[0, -1, -2], [1, 0, -1], [2, 1, 0]] p m2[0,0]               #=> 11p m1 * 5                #=> Matrix[[5, 0, 0], [0, 5, 0], [0, 0, 5]]p m1 + m3               #=> Matrix[[1, -1, -2], [1, 1, -1], [2, 1, 1]]p m1 * m3               #=> Matrix[[0, -1, -2], [1, 0, -1], [2, 1, 0]] 
p v1 = Vector[1,3,5]    #=> Vector[1, 3, 5]p v2 = Vector[0,1,2]    #=> Vector[0, 1, 2]p v1[1]                 #=> 3p v1 * 2                #=> Vector[2, 6, 10]p v1 + v2               #=> Vector[1, 4, 7] p m1 * v1               #=> Vector[1, 3, 5]p m3 * v1               #=> Vector[-13, -4, 5]require 'ostruct' 
ab = OpenStruct.newp ab                #=> #<OpenStruct>ab.foo = 25p ab.foo            #=> 25ab[:bar] = 2p ab[strv]         #=> 2p ab                #=> #<OpenStruct foo=25, bar=2>ab.delete_field(strv)p ab.foo            #=> nilp ab                #=> #<OpenStruct bar=2> p son = OpenStruct.new({ :name => strv, :age => 3 })                    #=> #<OpenStruct name=strv, age=3>p son.name          #=> strvp son[:age]         #=> 3son.age += 1p son.age           #=> 4son.items = [strv,strv]p son.items         #=> [strv]p son               #=> #<OpenStruct name=strv]
var a = []          #=> []a[0] = 1            #=> [1]a[3] = strv        #=> [1, nil, nil, strv]a << 3.14           #=> [1, nil, nil, strv, 3.14]
var h = Hash()    #=> Hash()h{:foo} = 1       #=> Hash(strv=>1)h{:bar} = 2.4     #=> Hash(strv=>2.4)h{:bar} += 3      #=> Hash(strv=>5.4)
var p = Pair('a', 'b')say p.first;            #=> 'a'say p.second;           #=> 'b' 
var pair = 'foo':'bar':'baz':();   
 
loop {    say pair.first;                #=> 'foo', 'bar', 'baz'    pair = pair.second;    pair == nil && break;}
struct Person {    String name,    Number age,    String sex} var a = Person(strv, 41, :man) a.age += 1                  
a.name = strv    
 say a.name          #=> strvsay a.age           #=> 42say a.sex           #=> strv"
"
pinyin = {  '甲' => 'jiă',  '乙' => 'yĭ',  '丙' => 'bĭng',  '丁' => 'dīng',  '戊' => 'wù',  '己' => 'jĭ',  '庚' => 'gēng',  '辛' => 'xīn',  '壬' => 'rén',  '癸' => 'gŭi',   '子' => 'zĭ',  '丑' => 'chŏu',  '寅' => 'yín',  '卯' => 'măo',  '辰' => 'chén',  '巳' => 'sì',  '午' => 'wŭ',  '未' => 'wèi',  '申' => 'shēn',  '酉' => 'yŏu',  '戌' => 'xū',  '亥' => 'hài'}celestial     = %w(甲 乙 丙 丁 戊 己 庚 辛 壬 癸)terrestrial   = %w(子 丑 寅 卯 辰 巳 午 未 申 酉 戌 亥)animals       = %w(Rat   Ox   Tiger  Rabbit  Dragon Snake                   Horse Goat Monkey Rooster Dog    Pig)elements      = %w(Wood Fire Earth Metal Water)aspects       = %w(yang yin) BASE = 4 args = if !ARGV.empty?         ARGV       else         [Time.new.year]       end args.each do |arg|  ce_year = Integer(arg)  print strv if ARGV.length > 1  cycle_year     = ce_year - BASE   stem_number    = cycle_year % 10  stem_han       = celestial[stem_number]  stem_pinyin    = pinyin[stem_han]   element_number = stem_number / 2  element        = elements[element_number]   branch_number  = cycle_year % 12  branch_han     = terrestrial[branch_number]  branch_pinyin  = pinyin[branch_han]  animal         = animals[branch_number]   aspect_number = cycle_year % 2  aspect        = aspects[aspect_number]   index         = cycle_year % 60 + 1   print stem_han, branch_han  puts strvend"
" def chinese_remainder(mods, remainders)  max = mods.inject( :* )                              series = remainders.zip( mods ).map{|r,m| r.step( max, m ).to_a }   series.inject( :& ).first #returns nil when emptyend p chinese_remainder([3,5,7], [2,3,2])     #=> 23p chinese_remainder([10,4,9], [11,22,19]) #=> nil  def extended_gcd(a, b)  last_remainder, remainder = a.abs, b.abs  x, last_x, y, last_y = 0, 1, 1, 0  while remainder != 0    last_remainder, (quotient, remainder) = remainder, last_remainder.divmod(remainder)    x, last_x = last_x - quotient*x, x    y, last_y = last_y - quotient*y, y  end  return last_remainder, last_x * (a < 0 ? -1 : 1)end def invmod(e, et)  g, x = extended_gcd(e, et)  if g != 1    raise 'Multiplicative inverse modulo does not exist!'  end  x % etend def chinese_remainder(mods, remainders)  max = mods.inject( :* )  
  series = remainders.zip(mods).map{ |r,m| (r * max * invmod(max/m, m) / m) }  series.inject( :+ ) % max end p chinese_remainder([3,5,7], [2,3,2])     #=> 23p chinese_remainder([17353461355013928499, 3882485124428619605195281, 13563122655762143587], [7631415079307304117, 1248561880341424820456626, 2756437267211517231]) #=> 937307771161836294247413550632295202816p chinese_remainder([10,4,9], [11,22,19]) #=> nil func mul_inv(a, b) {    b == 1 && return 1;    var (b0, x0, x1) = (0, 0, 1);    while (a > 1) {        (a, b, x0, x1) = (b, a % b, x1 - x0*int(a / b), x0);    };    x1 < 0 ? x1+b0 : x1;} func chinese_remainder(*n) {    var N = n«*»;    func (*a) {        n.range.map { |i|            var p = int(N / n[i]);            a[i] * mul_inv(p, n[i]) * p;        }.sum    }}"
"class MyClass   def initialize    @instance_var = 0  end   def add_1    @instance_var += 1  end end my_class = MyClass.new #allocates an object and calls it's initialize method, then returns it. class MyClass(instance_var) {    method add(num) {        instance_var += num;    }} var obj = MyClass(3);   
obj.add(5);             
say obj.instance_var;   
"
"Pt     = Struct.new(:x, :y)Circle = Struct.new(:x, :y, :r) def circles_from(pt1, pt2, r)  raise ArgumentError, strv if pt1 == pt2 && r > 0  
  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y  
  q = Math.hypot(dx, dy)  
  raise ArgumentError, strv if q > 2.0*r  
  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0  d = (r**2 - (q/2)**2)**0.5  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniqend 
ar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]] ar.each do |p1, p2, r|  print ""Given points:  #{p1.values},  #{p2.values}  and radius #{r}""  begin    circles = circles_from(p1, p2, r)    puts strv    circles.each{|c| puts strv}  rescue ArgumentError => e    puts e  end  putsend"
File.new(strv).tty?   #=> falseFile.new(strv).tty?   #=> trueSTDOUT.tty?  #=> true
"require 'matrix' class Matrix  def symmetric?    return false if not square?    (0 ... row_size).each do |i|      (0 .. i).each do |j|        return false if self[i,j] != self[j,i]      end    end    true  end   def cholesky_factor    raise ArgumentError, strv unless symmetric?    l = Array.new(row_size) {Array.new(row_size, 0)}    (0 ... row_size).each do |k|      (0 ... row_size).each do |i|        if i == k          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[k][j] ** 2}          val = Math.sqrt(self[k,k] - sum)          l[k][k] = val        elsif i > k          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[i][j] * l[k][j]}          val = (self[k,i] - sum) / l[k][k]          l[i][k] = val        end      end    end    Matrix[*l]  endend puts Matrix[[25,15,-5],[15,18,0],[-5,0,11]].cholesky_factorputs Matrix[[18, 22,  54,  42],            [22, 70,  86,  62],            [54, 86, 174, 134],            [42, 62, 134, 106]].cholesky_factorfunc cholesky(matrix) {    var chol = matrix.len.of { matrix.len.of(0) }    for row in ^matrix {        for col in (0..row) {            var x = matrix[row][col]            for i in (0..col) {                x -= (chol[row][i] * chol[col][i])            }            chol[row][col] = (row == col ? x.sqrt : x/chol[col][col])        }    }    return chol}var example1 = [ [ 25, 15, -5 ],                 [ 15, 18,  0 ],                 [ -5,  0, 11 ] ]; say strv;cholesky(example1).each { |row|    say row.map {'%7.4f' % _}.join(' ');} var example2 = [ [ 18, 22,  54,  42],                 [ 22, 70,  86,  62],                 [ 54, 86, 174, 134],                 [ 42, 62, 134, 106] ]; say ""Example 2:"";cholesky(example2).each { |row|    say row.map {'%7.4f' % _}.join(' ');}"
File.new(strv).tty?   #=> falseFile.new(strv).tty?   #=> trueSTDIN.tty?  #=> trueFile.new(strv).isatty   #=> falseFile.new(strv).isatty   #=> true
"File.file?(strv)File.file?(strv)File.directory?(strv)File.directory?(strv)[strv, strv].each { |f|  printf ""%s is a regular file? %s"", f, File.file?(f) }[strv, strv].each { |d|  printf ""%s is a directory? %s"", d, File.directory?(d) }
say (Dir.cwd  + %f'input.txt' -> is_file);say (Dir.cwd  + %d'docs'      -> is_dir); 
say (Dir.root + %f'input.txt' -> is_file);say (Dir.root + %d'docs'      -> is_dir);"
"require 'socket' 

#


#




class Workshop  
  def initialize    @sockets = {}  end   
  
  
  #  
  
  
  
  
  def add    child, parent = UNIXSocket.pair     wid = fork do      
      child.close      @sockets.each_value { |sibling| sibling.close }       
      
      Signal.trap(strv) { exit! }       loop do        
        begin          command, args = Marshal.load(parent)        rescue EOFError          
          break        end         case command        when :work          
          result = yield *args          Marshal.dump(result, parent)        when :remove          break        else          fail strv        end      end    end     
    parent.close    @sockets[wid] = child    wid  end   
  
  
  
  #  
  
  
  
  
  def work(*args)    message = [:work, args]    @sockets.each_pair do |wid, child|      Marshal.dump(message, child)    end     
    result = {}    @sockets.each_pair do |wid, child|      begin        
        result[wid] = Marshal.load(child)      rescue EOFError        fail strv      end    end    result  end   
  
  #  
  def remove(wid)    unless child = @sockets.delete(wid)      raise ArgumentError, strv    else      Marshal.dump([:remove, nil], child)      child.close      Process.wait(wid)    end  endend   
require 'pp'shop = Workshop.newwids = [] 
@fixed_rand = falsedef fix_rand  unless @fixed_rand; srand; @fixed_rand = true; endend 
6.times do  wids << shop.add do |i|    
    fix_rand    f = proc { |n| if n < 2 then n else f[n - 1] + f[n - 2] end }    [i, f[25 + rand(10)]]  endend 6.times do |i|  
  pp shop.work(i)   
  victim = rand(wids.length)  shop.remove wids[victim]  wids.slice! victim   
  wids << shop.add do |j|    
    
    fix_rand    f = proc { |n| if n < 3 then n else f[n - 1] + f[n - 2] + f[n - 3] end }    [j, i, f[20 + rand(10)]]  endend 
wids.each { |wid| shop.remove wid }pp shop.work(6)"
"require 'gserver' class ChatServer < GServer  def initialize *args    super     #Keep a list for broadcasting messages    @chatters = []     #We'll need this for thread safety    @mutex = Mutex.new   end   #Send message out to everyone but sender  def broadcast message, sender = nil    #Need to use \r\n for our Windows friends    message = message.strip << """"     #Mutex for safety - GServer uses threads    @mutex.synchronize do      @chatters.each do |chatter|        begin          chatter.print message unless chatter == sender        rescue          @chatters.delete chatter        end      end    end  end   #Handle each connection  def serve io    io.print 'Name: '    name = io.gets     #They might disconnect    return if name.nil?     name.strip!     broadcast strv     #Add to our list of connections    @mutex.synchronize do      @chatters << io    end     #Get and broadcast input until connection returns nil    loop do      message = io.gets       if message        broadcast strv, io      else        break      end    end     broadcast strv  endend #Start up the server on port 7000#Accept connections for any IP address#Allow up to 100 connections#Send information to stderr#Turn on informational messagesChatServer.new(7000, '0.0.0.0', 100, $stderr, true).start.join "
"> ?a=> 97> strv[0]=> 97> 97.chr=> strv> strv.ord=> 97> 97.chr=> strvsay 'a'.ord;    
say 97.chr;     
"
"func catalan(num) {  var t = [0, 1];  range(1, num).map { |i|    range(i, 1, -1).each {|j| t[j] += t[j-1]};    t[i+1] = t[i];    range(i+1, 1, -1).each {|j| t[j] += t[j-1]};    t[i+1] - t[i];  }}say catalan(15).join(' ');"
"
p (1..10).inject(:+)
p (1..20).inject(:lcm) #lcm: lowest common multiple p row = [1]10.times{p row = row.each_cons(2).inject([1,1]){|ar,(a,b)| ar.insert(-2, a+b)} } 







 say (1..10 -> reduce('+'));say (1..10 -> reduce{|a,b| a + b});"
"module FiveDogs  dog = strv  dOg = strv  doG = strv  Dog = strv   
  DOG = strv  
   names = [dog, dOg, doG, Dog, DOG]  names.uniq!  puts strv % [names.length, names.join(strv)]  puts  puts strv % local_variables.join(strv)  puts strv % constants.join(strv)endvar dog = 'Benjamin';var Dog = 'Samba';var DOG = 'Bernie';say strv;"
"
 require 'prime' Prime.each(61) do |p|  (2...p).each do |h3|    g = h3 + p    (1...g).each do |d|      next if (g*(p-1)) % d != 0 or (-p*p) % h3 != d % h3      q = 1 + ((p - 1) * g / d)      next unless q.prime?      r = 1 + (p * q / h3)      next unless r.prime? and (q * r) % (p - 1) == 1      puts strv     end  end  putsendfunc forprimes(a, b, callback) {    for (a = (a-1 -> next_prime); a <= b; a.next_prime!) {        callback(a)    }} forprimes(3, 61, func(p) {   for h3 in (2 .. p-1) {      var ph3 = (p + h3)      for d in (1 .. ph3-1) {         ((-p * p) % h3) != (d % h3) && next         ((p-1) * ph3) % d && next         var q = 1+((p-1) * ph3 / d)         q.is_prime || next         var r = 1+((p*q - 1)/h3)         r.is_prime || next         (q*r) % (p-1) == 1 || next         printf(""%2d x %5d x %5d = %s"",p,q,r, p*q*r)      }   }})"
"
MyClass.some_method(some_parameter) 
foo = MyClassfoo.some_method(some_parameter)  
my_instance.method(some_parameter) 
my_instance.method some_parameter 
my_instance.another_methodclass MyClass {    method foo(arg) { say arg }} var arg = 42; 
MyClass.foo(arg); 
MyClass.(:foo)(arg); 
var instance = MyClass(); 
instance.foo(arg); 
instance.(:foo)(arg); 
instance.method(:foo)(arg);"
"def factorial(n)  (1..n).reduce(1, :*)end 
 def catalan_direct(n)  factorial(2*n) / (factorial(n+1) * factorial(n))end 
 def catalan_rec1(n)  return 1 if n == 0  (0...n).inject(0) {|sum, i| sum + catalan_rec1(i) * catalan_rec1(n-1-i)}end def catalan_rec2(n)  return 1 if n == 0  2*(2*n - 1) * catalan_rec2(n-1) / (n+1)end 
 require 'benchmark'require 'memoize'include Memoize Benchmark.bm(17) do |b|  b.report('catalan_direct')    {16.times {|n| catalan_direct(n)} }  b.report('catalan_rec1')      {16.times {|n| catalan_rec1(n)} }  b.report('catalan_rec2')      {16.times {|n| catalan_rec2(n)} }   memoize :catalan_rec1  b.report('catalan_rec1(memo)'){16.times {|n| catalan_rec1(n)} }end puts ""       direct     rec1     rec2""16.times {|n| puts strv % [n, catalan_direct(n), catalan_rec1(n), catalan_rec2(n)]}func f(i) { i==0 ? 1 : (i * f(i-1)) }func c(n) { f(2*n) / f(n) / f(n+1) }func c(n) is cached {    n == 0 ? 1 : (c(n-1) * (4 * n - 2) / (n + 1));}15.times { |i|    say ""#{i-1}#{c(i-1)}"";}"
"require 'dl/import' FakeImgLib = DL.dlopen(strv) module FakeImage  def self.openimage filename    FakeImgLib[strv, strv].call(filename)[0]  endend handle = FakeImage.openimage(strv)require 'ffi'module FakeImgLib  extend FFI::Library  ffi_lib strv  attach_function :openimage, [:string], :intend handle = FakeImgLib.openimage(strv)"
" require 'ffi' module LibC  extend FFI::Library  ffi_lib FFI::Platform::LIBC   attach_function :strdup, [:string], :pointer  attach_function :free, [:pointer], :voidend string = strvduplicate = LibC.strdup(string)puts duplicate.get_string(0)LibC.free(duplicate) require 'dl'require 'fiddle' 


strdup = Fiddle::Function.new(DL::Handle['strdup'],                              [DL::TYPE_VOIDP], DL::TYPE_VOIDP) 


duplicate = strdup.call(strv) 
puts duplicate.to_s 
DL.free duplicaterequire 'rubygems'require 'inline' class InlineTester  def factorial_ruby(n)    (1..n).inject(1, :*)  end   inline do |builder|    builder.c <<-'END_C'      long factorial_c(int max) {        long result = 1;        int i;        for (i = 1; i <= max; ++i)          result *= i;        return result;      }    END_C  end   inline do |builder|    builder.include %q(strv)    builder.c <<-'END_C'      int my_ilogb(double value) {        return ilogb(value);      }    END_C  endend t = InlineTester.new11.upto(14) {|n| p [n, t.factorial_ruby(n), t.factorial_c(n)]}p t.my_ilogb(1000)"
"def foo() p strv end foo                             #=> strvfoo()                           #=> strvdef foo arg; p arg end          
 foo(1)                          #=> 1foo strv                         #=> strvfoo [0,1,2]                     #=> [0, 1, 2]   (one Array)def foo(x=0, y=x, flag=true) p [x,y,flag] end foo                             #=> [0, 0, true]foo(1)                          #=> [1, 1, true]foo(1,2)                        #=> [1, 2, true]foo 1,2,false                   #=> [1, 2, false]def foo(*args) p args end foo                             #=> []foo(1,2,3,4,5)                  #=> [1, 2, 3, 4, 5]def foo(id:0, name:strv, age:0) p [id, name, age] end foo(age:22, name:strv)         #=> [0, strv, 22]def foo(a,b) a + b end bar = foo 10,20p bar                           #=> 30p foo(strv,strv)              #=> strv 
def sum_and_product(a,b) return a+b,a*b end x,y = sum_and_product(3,5)p x                             #=> 8p y                             #=> 15puts strv                      
raise strv             
Integer(strv)                  
rand(6)                         
throw(:exit)                    
 
attr_accessor                   
include                         
private                         
require                         
loop { }                        
class Array  def sum(init=0, &blk)    if blk      inject(init){|s, n| s + blk.call(n)}    else      inject(init){|s, n| s + n}    end  endend ary = [1,2,3,4,5]p ary.sum                               #=> 15p ary.sum(''){|n| (-n).to_s}            #=> strvp (ary.sum do |n| n * n end)            #=> 55def foo(a,b,c) p [a,b,c] end args = [1,2,3]foo *args                       #=> [1, 2, 3]args = [1,2]foo(0,*args)                    #=> [0, 1, 2]
i = 3p 1 + i                         #=> 4                   1.+(i)p i < 5                         #=> true                i.<(5)p 2 ** i                        #=> 8                   2.**(i)p -i                            #=> -3                  i.-@()a = [1,2,3]p a[0]                          #=> 1                   a.[](0)a[2] = strv                      
p a << 5                        #=> [1, 2, strv, 5]      a.<<(5)p a & [4,2]                     #=> [2]                 a.&([4,2])p strv[1..3]                 #=> strv.[](1..3)p strv % [1,strv]         #=> strv])foo();                       
foo(1, 2);                   
foo(args...);                
foo(name: 'Bar', age: 42);   
 var f = foo;                 
var result = f();            
 var arr = [1,2,3];foo(arr);                    
func curry(f, *args1) {    func (*args2) {        f(args1..., args2...);    }} func add(a, b) {    a + b} var adder = curry(add, 1);say adder(3);                 #=>4"
"size = 4scores = []guesses = []puts strvpossible_guesses = [*'1'..'9'].permutation(size).to_a.shuffle loop do  guesses << current_guess = possible_guesses.pop  print strv  scores << score = gets.split(',').map(&:to_i)   
  break (puts strv) if score == [size,0]   
  possible_guesses.select! do |guess|    bulls = guess.zip(current_guess).count{|g,cg| g == cg}    cows = size - (guess - current_guess).size - bulls    [bulls, cows] == score  end   
  if possible_guesses.empty?    puts strv    guesses.zip(scores).each{|g, (b, c)| puts strv}    break  endend

var candidates = (1234..9876 -> grep {|n| !(strv =~ /0 | (\d) .*? \1 /x) }.map{.digits}); 

func read_score(guess) {    loop {        ""My guess: %s   (from %d possibilities)"" \            -> printf(guess.join, candidates.len);         if (var m = (Sys.scanln(strv) =~ /^\h*(\d)\h*(\d)\h*$/)) {            var (bulls, cows) = m.cap.map{.to_i}...;            bulls+cows <= 4 && return(bulls, cows);        }         say strv;    }} func score_correct(a, b, bulls, cows) {    var (exact, loose) = (0, 0);     for i in ^4 {        a[i] == b[i] ? ++exact                     : (a[i]~~b && ++loose)    }     (bulls == exact) && (cows == loose)} 

loop {    var guess = candidates.pick;    var (bulls, cows) = read_score(guess);    candidates.grep!{|n| score_correct(n, guess, bulls, cows) }    candidates.len > 1 || break} 
(    candidates.len == 1 ? (strv % candidates[0].join)                        : (strv))->say"
"
 class Object  alias lowercase_method_missing method_missing   
  def method_missing(sym, *args, &block)    str = sym.to_s    if str == (down = str.downcase)      lowercase_method_missing sym, *args, &block    else      send down, *args, &block    end  end   
  def RESCUE(_BEGIN, _CLASS, _RESCUE)    begin _BEGIN.CALL    rescue _CLASS      _RESCUE.CALL; end  endend _PROGRAM = ARGV.SHIFT_PROGRAM || ABORT(strv)LOAD($0 = _PROGRAM)
REQUIRE 'DATE'.DOWNCASE 
OBJECT = [].CLASS.SUPERCLASSDATE = OBJECT.CONST_GET('DATE'.DOWNCASE.CAPITALIZE) 

OBJECT.SEND(:DEFINE_METHOD, :CAL) {|_YEAR, _COLUMNS|   
  #  
  
  
  #  _DATE = DATE.NEW(_YEAR, 1, 1, DATE::ENGLAND)   
  _MONTHS = (1..12).COLLECT {|_MONTH|    _ROWS = [DATE::MONTHNAMES[_MONTH].UPCASE.CENTER(20),             strv]     
    _DAYS = []    _DATE.WDAY.TIMES { _DAYS.PUSH strv }    CATCH(:BREAK) {      LOOP {        (_DATE.MONTH == _MONTH) || THROW(:BREAK)        _DAYS.PUSH(strv.DOWNCASE % _DATE.MDAY)        _DATE += 1 }}    (42 - _DAYS.LENGTH).TIMES { _DAYS.PUSH strv }     _DAYS.EACH_SLICE(7) {|_WEEK| _ROWS.PUSH(_WEEK.JOIN strv) }    _ROWS }   
  
  
  
  
  
  _MPR = (_COLUMNS + 2).DIV 22  _MPR = 12.DIV((12 + _MPR - 1).DIV _MPR)   
  _WIDTH = _MPR * 22 - 2   
  _ROWS = [strv.CENTER(_WIDTH), strv.CENTER(_WIDTH)]  _MONTHS.EACH_SLICE(_MPR) {|_SLICE|    _SLICE[0].EACH_INDEX {|_I|      _ROWS.PUSH(_SLICE.MAP {|_A| _A[_I]}.JOIN strv) }}  _ROWS.JOIN(""12"") }  (ARGV.LENGTH == 1) || ABORT(strv) 




LOADERROR = OBJECT.CONST_GET('LOAD'.DOWNCASE.CAPITALIZE +                             'ERROR'.DOWNCASE.CAPITALIZE)STANDARDERROR = OBJECT.CONST_GET('STANDARD'.DOWNCASE.CAPITALIZE +                                 'ERROR'.DOWNCASE.CAPITALIZE)_INTEGER = 'INTEGER'.DOWNCASE.CAPITALIZE_TPUT_CO = 'TPUT CO'.DOWNCASE_COLUMNS = RESCUE(PROC {SEND(_INTEGER, ENV[strv] || strv)},                  STANDARDERROR,                  PROC {                    RESCUE(PROC {                             REQUIRE 'IO/CONSOLE'.DOWNCASE                             IO.CONSOLE.WINSIZE[1]                           }, LOADERROR,                           PROC {                             RESCUE(PROC {                                      SEND(_INTEGER, `#{_TPUT_CO}`)                                    }, STANDARDERROR,                                    PROC {80}) }) }) PUTS CAL(ARGV[0].TO_I, _COLUMNS)-> DT { ('DATE'.(""WC"") + 'TIME'.(""WC"")).(""REQUIRE"") } -> MONTHS_PER_COL { 6 }-> WEEK_DAY_NAMES { <MO TU WE TH FR SA SU> }-> MONTH_NAMES    { <JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC> } -> FMT_MONTH (YEAR, MONTH, STR=strv, WEEK_DAY=0) {    STR  = ""%11S%9S2"".(""SPRINTF"")(MONTH_NAMES()[MONTH-1],'')    STR += (WEEK_DAY_NAMES().(""JOIN"")(' ') + ""2"")     -> DATE { DT().(""NEW"")(""YEAR"" => YEAR, ""MONTH"" => MONTH) }     WEEK_DAY = DATE().(""DAY_OF_WEEK"")    STR += ([strv] * WEEK_DAY-1 -> (""JOIN"")(strv))     -> LAST_DAY {        DT().(""LAST_DAY_OF_MONTH"")(            ""YEAR"" => YEAR, ""MONTH"" => MONTH        ).(""DAY"")    }     (DATE().(""DAY"") .. LAST_DAY()).(""EACH"")({ |DAY|        (WEEK_DAY ~~ (2..7)) && (STR += strv)         (WEEK_DAY == 8) && (            STR += ""2""            WEEK_DAY = 1        )        STR += (""%2D"" % DAY)        ++WEEK_DAY    })    (WEEK_DAY < 8) && (STR += strv)    STR += ([strv] * 8-WEEK_DAY -> (""JOIN"")(strv))    STR += ""2""} -> FMT_YEAR (YEAR, STR=strv, MONTH_STRS=[]) {    MONTH_STRS = 12.(""OF"")({|I| FMT_MONTH(YEAR, I).(""LINES"") })     STR += (' '*(MONTHS_PER_COL()*10 + 2) + YEAR + ""2"")    (0..11 -> (""BY"")(MONTHS_PER_COL())).(""EACH"")({ |MONTH|        MONTH_STRS[MONTH] && ->() {            { |I|                MONTH_STRS[MONTH + I - 1] && (                    STR += MONTH_STRS[MONTH + I - 1].(""SHIFT"")                    STR += ' '*2                )            } * MONTHS_PER_COL()             STR += ""2""            MONTH_STRS[MONTH] && __FUNC__()        }()        STR += ""2""    })     STR} FMT_YEAR(ARGV ? ARGV[0].(""TO_I"") : 1969).(""PRINT"")"
"class String  ALFABET = (strv..strv).to_a   def caesar_cipher(num)    self.tr(ALFABET.join, ALFABET.rotate(num).join)  end end #demo:encypted  = strv.caesar_cipher(3)decrypted = encypted.caesar_cipher(-3) func caesar(msg, key, decode=false) {    decode && (key = (26 - key));    msg.gsub(/([A-Z])/i, {|c| ((c.uc.ord - 65 + key) % 26) + 65 -> chr});}; var msg = 'THE FIVE BOXING WIZARDS JUMP QUICKLY'; var enc = caesar(msg, 10);var dec = caesar(enc, 10, true); say strv;say strv;say strv;"
"def generate_word(len)  [*strv..strv].shuffle.first(len)        
end def get_guess(len)  loop do    print strv    guess = gets.strip    err = case          when guess.match(/[^1-9]/)             ; strv          when guess.length != len               ; strv          when guess.split(strv).uniq.length != len; strv          else return guess.split(strv)          end    puts strv  endend def score(word, guess)  bulls = cows = 0  guess.each_with_index do |num, idx|    if word[idx] == num      bulls += 1    elsif word.include? num      cows += 1    end  end   [bulls, cows]end word_length = 4puts strvword = generate_word(word_length)count = 0loop do  guess = get_guess(word_length)  count += 1  break if word == guess  puts strv % score(word, guess)endputs strvsize = 4secret = [*'1' .. '9'].sample(size)guess = nil i=0loop do  i+=1  loop do    print strv    guess = gets.chomp.chars    exit if guess.empty?     break if guess.size == size and              guess.all? { |x| ('1'..'9').include? x } and             guess.uniq.size == size     puts strv  end   if guess == secret    puts strv    break  end   bulls = cows = 0  size.times do |j|    if guess[j] == secret[j]      bulls += 1    elsif secret.include? guess[j]      cows += 1    end  end   puts strvendvar size = 4var num = @(1..9).shuffle.first(size) for (var guesses = 1; true; guesses++) {     var bulls = 0    var cows  = 0     var input = Sys.scanln(strv).chars                \                                     .unique               \                                     .grep {.~~/^[1-9]$/}  \                                     .map  {.to_i}     if (input.len != size) {        warn ""Invalid input!""        guesses--        next    }     if (input == num) {        printf(""You did it in %d attempts!"", guesses)        break    }     num.range.each { |i|        if (num[i] == input[i]) {            bulls++        }        elsif (num.contains(input[i])) {            cows++        }    }     ""Bulls: %d; Cows: %d"".printf(bulls, cows)}"
"require 'date' 

def cal(year, columns)   
  #  
  
  
  #  date = Date.new(year, 1, 1, Date::ENGLAND)   
  months = (1..12).collect do |month|    rows = [Date::MONTHNAMES[month].center(20), strv]     
    days = []    date.wday.times { days.push strv }    while date.month == month      days.push(strv % date.mday)      date += 1    end    (42 - days.length).times { days.push strv }     days.each_slice(7) { |week| rows.push(week.join strv) }    next rows  end   
  
  
  
  
  
  mpr = (columns + 2).div 22  mpr = 12.div((12 + mpr - 1).div mpr)   
  width = mpr * 22 - 2   
  rows = [strv.center(width), strv.center(width)]  months.each_slice(mpr) do |slice|    slice[0].each_index do |i|      rows.push(slice.map {|a| a[i]}.join strv)    end  end  return rows.join("""")end  ARGV.length == 1 or abort strv 




columns = begin Integer(ENV[strv] || strv)          rescue            begin require 'io/console'; IO.console.winsize[1]            rescue LoadError              begin Integer(`tput cols`)              rescue                80; end; end; end puts cal(Integer(ARGV[0]), columns)require('DateTime') define months_per_col = 3define week_day_names = <Mo Tu We Th Fr Sa Su>define month_names = <Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec> func fmt_month (year, month) {    var str = sprintf(""%-20s"", month_names[month-1])    str += week_day_names.join(' ')+""""     var dt = %s'DateTime'    var date = dt.new(year => year, month => month)    var week_day = date.day_of_week    str += ([strv] * week_day-1 -> join(strv))     var last_day = dt.last_day_of_month(year => year, month => month).day    for day in range(date.day, last_day) {        date = dt.new(year => year, month => month, day => day)         str += strv if (week_day ~~ range(2,7))        if (week_day == 8) {            str += """"            week_day = 1        }        str += sprintf(strv, day)        ++week_day    }    str += strv if (week_day < 8)    str += ([strv] * 8-week_day -> join(strv))    str += """"} func fmt_year (year) {    var month_strs = 12.of { |i| fmt_month(year, i).lines }     var str = (' '*30 + year + """")    for month in range(0, 11, months_per_col) {        while (month_strs[month]) {            months_per_col.times { |i|                month_strs[month + i - 1] || next                str += month_strs[month + i - 1].shift                str += ' '*3            }            str += """"        }        str += """"    }     return str} print fmt_year(ARGV.is_empty ? 1969 : ARGV[0].to_i)"
"def getitem(s, depth=0)  out = [strv]  until s.empty?    c = s[0]    break  if depth>0 and (c == ',' or c == '}')    if c == '{' and x = getgroup(s[1..-1], depth+1)      out = out.product(x[0]).map{|a,b| a+b}      s = x[1]    else      s, c = s[1..-1], c + s[1]  if c == '' and s.size > 1      out, s = out.map{|a| a+c}, s[1..-1]    end  end  return out, send def getgroup(s, depth)  out, comma = [], false  until s.empty?    g, s = getitem(s, depth)    break  if s.empty?    out += g    case s[0]      when '}' then return (comma ? out : out.map{|a| strv}), s[1..-1]      when ',' then comma, s = true, s[1..-1]    end  endend strs = <<'EOS'~/{Downloads,Pictures}/*.{jpg,gif,png}It{{em,alic}iz,erat}e{d,}, please.{,{,gotta have{ ,\, again\, }}more }cowbell!{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}EOS strs.each_line do |s|  puts s.chomp!  puts getitem(s)[0].map{|str| """"+str}  putsend"
"require 'rubygems'require 'RMagick' NUM_PARTICLES = 1000SIZE          = 800 def draw_brownian_tree world  
  world[rand SIZE][rand SIZE] = 1   NUM_PARTICLES.times do    
    px = rand SIZE    py = rand SIZE     loop do      
      dx = rand(3) - 1      dy = rand(3) - 1       if dx + px < 0 or dx + px >= SIZE or dy + py < 0 or dy + py >= SIZE        
        px = rand SIZE        py = rand SIZE      elsif world[py + dy][px + dx] != 0        
        world[py][px] = 1        break      else        py += dy        px += dx      end    end  endend world = Array.new(SIZE) { Array.new(SIZE, 0) }srand Time.now.to_i draw_brownian_tree world img = Magick::Image.new(SIZE, SIZE) do   self.background_color = strvend draw = Magick::Draw.newdraw.fill strv world.each_with_index do |row, y|  row.each_with_index do |colour, x|    draw.point x, y if colour != 0  endend draw.draw imgimg.write strv"
var t = true;var f = false;if (0 || strv || false || nil || strv || [] || :()) {    say strv} else {    say strv;}
"h = [][strv, strv, strv, strv, strv].each_cons(2) do |a, b|  c = if [strv, strv].include? a then strv else strv end  h << a  h << strv  h << strv  h << strv  h << strv  h << strv  h << strv  h << strvend puts strvh.each_with_index { |n, i| puts strv }puts strvHeadings = {  1 => strv,  2 => strv,  3 => strv,  4 => strv,  5 => strv,  6 => strv,  7 => strv,  8 => strv,  9 => strv,  10 => strv,  11 => strv,  12 => strv,  13 => strv,  14 => strv,  15 => strv,  16 => strv,  17 => strv,  18 => strv,  19 => strv,  20 => strv,  21 => strv,  22 => strv,  23 => strv,  24 => strv,  25 => strv,  26 => strv,  27 => strv,  28 => strv,  29 => strv,  30 => strv,  31 => strv,  32 => strv,} 

#

#def heading(degrees)  i = degrees.quo(360).*(32).round.%(32).+(1)  [i, Headings[i]]end 
angles = (0..32).map { |i| i * 11.25 + [0, 5.62, -5.62][i % 3] } angles.each do |degrees|  index, name = heading degrees  printf ""%2d %20s %6.2f"", index, name.center(20), degreesendfunc point (index) {    var ix = (index % 32);    if    (ix & 1) { strv }    elsif (ix & 2) { strv }    elsif (ix & 4) { strv }    else           { <north east south west>[ix / 8] }} func test_angle (ix) { ix * 11.25 + [0, 5.62, -5.62][ ix % 3 ] };func angle_to_point(𝜽) { (𝜽 / 360 * 32) + 0.5 -> floor }; for ix in range(0, 32) {    var 𝜽 = test_angle(ix);    printf(""  %2d %6.2f° %s"", ix % 32 + 1, 𝜽, point(angle_to_point(𝜽)).tc);}"
"def crunch(ascii)  bitstring = ascii.bytes.collect {|b| strv % b}.join  [bitstring].pack(strv)end def expand(binary)  bitstring = binary.unpack(strv)[0]  bitstring.scan(/[01]{7}/).collect {|b| b.to_i(2).chr}.joinend original = strvputs strv filename = strv 
File.open(filename, strv) do |fh|  fh.binmode  fh.print crunch(original)end filesize = File.size(filename)puts strv 
expanded = File.open(filename, strv) do |fh|   fh.binmode  expand(fh.read)end if original == expanded  puts strvelse  puts strvend"
"class Pixmap  def self.read_ppm(ios)    format = ios.gets.chomp    width, height = ios.gets.chomp.split.map {|n| n.to_i }    max_colour = ios.gets.chomp     if (not PIXMAP_FORMATS.include?(format)) or         width < 1 or height < 1 or        max_colour != '255'    then      ios.close      raise StandardError, strv    end    ios.binmode if PIXMAP_BINARY_FORMATS.include?(format)     bitmap = self.new(width, height)    height.times do |y|      width.times do |x|        
        red, green, blue = case format          when 'P3' then ios.gets.chomp.split          when 'P6' then ios.read(3).unpack('C3')        end        bitmap[x,y] = RGBColour.new(red, green, blue)      end    end    ios.close    bitmap  end   def self.open(filename)    read_ppm(File.open(filename, 'r'))  end   def self.open_from_jpeg(filename)    read_ppm(IO.popen(strv, 'r'))  endend bitmap = Pixmap.open_from_jpeg('file.jpg')"
"class Pixmap  
  def self.open(filename)    bitmap = nil    File.open(filename, 'r') do |f|      header = [f.gets.chomp, f.gets.chomp, f.gets.chomp]      width, height = header[1].split.map {|n| n.to_i }      if header[0] != 'P6' or header[2] != '255' or width < 1 or height < 1        raise StandardError, strv      end      f.binmode      bitmap = self.new(width, height)      height.times do |y|        width.times do |x|          
          red, green, blue = f.read(3).unpack('C3')          bitmap[x,y] = RGBColour.new(red, green, blue)        end      end    end    bitmap  endend 
colour_bitmap = Pixmap.new(20, 30)colour_bitmap.fill(RGBColour::BLUE)colour_bitmap.height.times {|y| [9,10,11].each {|x| colour_bitmap[x,y]=RGBColour::GREEN}}colour_bitmap.width.times  {|x| [14,15,16].each {|y| colour_bitmap[x,y]=RGBColour::GREEN}}colour_bitmap.save('testcross.ppm') 
Pixmap.open('testcross.ppm').to_grayscale!.save('testgray.ppm')"
"class Pixmap  PIXMAP_FORMATS = [strv, strv]   
  PIXMAP_BINARY_FORMATS = [strv]  
   def write_ppm(ios, format=strv)    if not PIXMAP_FORMATS.include?(format)      raise NotImplementedError, strv     end    ios.puts format, ""} }"", strv    ios.binmode if PIXMAP_BINARY_FORMATS.include?(format)    @height.times do |y|      @width.times do |x|        case format        when strv then ios.print @data[x][y].values.join(strv),""""        when strv then ios.print @data[x][y].values.pack('C3')        end      end    end  end   def save(filename, opts={:format=>strv})    File.open(filename, 'w') do |f|      write_ppm(f, opts[:format])    end  end   def print(opts={:format=>strv})    write_ppm($stdout, opts[:format])  end   def save_as_jpeg(filename, quality=75)    pipe = IO.popen(strv, 'w')    write_ppm(pipe)    pipe.close  endend image = Pixmap.open('file.ppm')image.save_as_jpeg('file.jpg')"
"def bitwise(a, b)  form = strv  puts form % [strv, a]  puts form % [strv, b]  puts form % [strv, a & b]  puts form % [strv, a | b]  puts form % [strv, a ^ b]  puts form % [strv, ~a]  puts form % [strv, a << b]  
  puts form % [strv, a >> b]  
end bitwise(14,3)func bitwise(a, b) {    
   a.to_int!;   b.to_int!;    say ('a and b : ',  a & b);   say ('a or b  : ',  a | b);   say ('a xor b : ',  a ^ b);   say ('not a   : ',     ~a);   say ('a << b  : ', a << b);  
   say ('a >> b  : ', a >> b);  
} bitwise(14,3)"
"Pixel = Struct.new(:x, :y) class Pixmap  def draw_circle(pixel, radius, colour)    validate_pixel(pixel.x, pixel.y)     self[pixel.x, pixel.y + radius] = colour    self[pixel.x, pixel.y - radius] = colour    self[pixel.x + radius, pixel.y] = colour    self[pixel.x - radius, pixel.y] = colour     f = 1 - radius    ddF_x = 1    ddF_y = -2 * radius    x = 0    y = radius    while x < y      if f >= 0        y -= 1        ddF_y += 2        f += ddF_y      end      x += 1      ddF_x += 2      f += ddF_x      self[pixel.x + x, pixel.y + y] = colour      self[pixel.x + x, pixel.y - y] = colour      self[pixel.x - x, pixel.y + y] = colour      self[pixel.x - x, pixel.y - y] = colour      self[pixel.x + y, pixel.y + x] = colour      self[pixel.x + y, pixel.y - x] = colour      self[pixel.x - y, pixel.y + x] = colour      self[pixel.x - y, pixel.y - x] = colour    end  endend bitmap = Pixmap.new(30, 30)bitmap.draw_circle(Pixel[14,14], 12, RGBColour::BLACK)"
"class RGBColour  def values    [@red, @green, @blue]  endend class Pixmap  def save(filename)    File.open(filename, 'w') do |f|      f.puts strv, ""} }"", strv      f.binmode      @height.times do |y|        @width.times do |x|          f.print @data[x][y].values.pack('C3')        end      end    end  end  alias_method :write, :saveendsubset Int   < Number {|n| n.is_int  }subset Uint  < Int    {|n| n >= 0    }subset Uint8 < Int    {|n| n ~~ ^256 } struct Pixel {    R < Uint8,    G < Uint8,    B < Uint8} class Bitmap(width < Uint, height < Uint) {    has data = []     method fill(Pixel p) {        data = (width*height -> of { Pixel(p.R, p.G, p.B) })    }     method setpixel(i < Uint, j < Uint, Pixel p) {         subset WidthLimit  < Uint { |n| n ~~ ^width  }        subset HeightLimit < Uint { |n| n ~~ ^height }         func (w < WidthLimit, h < HeightLimit) {            data[w*height + h] = p        }(i, j)    }     method p6 {        ""P6#{width} #{height}255"" +            data.map {|p| [p.R, p.G, p.B].pack('C3') }.join    }} var b = Bitmap(width: 125, height: 125) for i,j in (^b.height ~X ^b.width) {    b.setpixel(i, j, Pixel(2*i, 2*j, 255 - 2*i))} var file = File(strv)var fh = file.open('>:raw')fh.print(b.p6)fh.close"
"class Pixmap  def histogram    histogram = Hash.new(0)    @height.times do |y|      @width.times do |x|        histogram[self[x,y].luminosity] += 1      end    end    histogram   end   def to_blackandwhite    hist = histogram     
    median = nil    sum = 0    hist.keys.sort.each do |lum|      sum += hist[lum]      if sum > @height * @width / 2        median = lum        break      end    end     
    bw = self.class.new(@width, @height)    @height.times do |y|      @width.times do |x|        bw[x,y] = self[x,y].luminosity < median ? RGBColour::BLACK : RGBColour::WHITE      end    end    bw  end   def save_as_blackandwhite(filename)    to_blackandwhite.save(filename)  endend Pixmap.open('file.ppm').save_as_blackandwhite('file_bw.ppm')"
"class Pixmap  def draw_bezier_curve(points, colour)    
    points = points.sort_by {|p| [p.x, p.y]}    xmin = points[0].x    xmax = points[-1].x    increment = 2    prev = points[0]    ((xmin + increment) .. xmax).step(increment) do |x|      t = 1.0 * (x - xmin) / (xmax - xmin)      p = Pixel[x, bezier(t, points).round]      draw_line(prev, p, colour)      prev = p    end  endend 
def bezier(t, points)  n = points.length - 1  points.each_with_index.inject(0.0) do |sum, (point, i)|    sum += n.choose(i) * (1-t)**(n - i) * t**i * point.y  endend class Fixnum  def choose(k)    self.factorial / (k.factorial * (self - k).factorial)  end  def factorial    (2 .. self).reduce(1, :*)  endend bitmap = Pixmap.new(400, 400)points = [  Pixel[40,100], Pixel[100,350], Pixel[150,50],   Pixel[150,150], Pixel[350,250], Pixel[250,250]]points.each {|p| bitmap.draw_circle(p, 3, RGBColour::RED)}bitmap.draw_bezier_curve(points, RGBColour::BLUE)"
" 
#

require 'digest/sha2'def convert g  i,e = '',[]  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}  e.pack(i)endX = '50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352'Y = '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'n = '00'+Digest::RMD160.hexdigest(Digest::SHA256.digest(convert('04'+X+Y)))n+= Digest::SHA256.hexdigest(Digest::SHA256.digest(convert(n)))[0,8]G = strvn,res = n.hex,''while n > 0 do  n,ng = n.divmod(58)  res << G[ng]endputs res.reverse "
"Pixel = Struct.new(:x, :y) class Pixmap   def draw_line(p1, p2, colour)    validate_pixel(p1.x, p2.y)    validate_pixel(p2.x, p2.y)     x1, y1 = p1.x, p1.y    x2, y2 = p2.x, p2.y     steep = (y2 - y1).abs > (x2 - x1).abs     if steep      x1, y1 = y1, x1      x2, y2 = y2, x2    end     if x1 > x2      x1, x2 = x2, x1      y1, y2 = y2, y1    end     deltax = x2 - x1    deltay = (y2 - y1).abs    error = deltax / 2    ystep = y1 < y2 ? 1 : -1     y = y1    x1.upto(x2) do |x|      pixel = steep ? [y,x] : [x,y]      self[*pixel] = colour      error -= deltay      if error < 0        y += ystep        error += deltax      end    end  endend bitmap = Pixmap.new(500, 500)bitmap.fill(RGBColour::BLUE)10.step(430, 60) do |a|  bitmap.draw_line(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)  bitmap.draw_line(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)endbitmap.draw_line(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)func my_draw_line(img, x0, y0, x1, y1) {     var steep = (abs(y1 - y0) > abs(x1 - x0))     if (steep) {        (y0, x0) = (x0, y0)        (y1, x1) = (x1, y1)    }    if (x0 > x1) {        (x1, x0) = (x0, x1)        (y1, y0) = (y0, y1)    }     var deltax = (x1 - x0)    var deltay = abs(y1 - y0)    var error  = (deltax / 2)    var y = y0    var ystep = (y0 < y1 ? 1 : -1)     x0.to(x1).each { |x|        img.draw_point(steep ? ((y, x)) : ((x, y)))        error -= deltay        if (error < 0) {            y += ystep            error += deltax        }    }} require('Image::Imlib2') var img = %s'Image::Imlib2'.new(160, 160)img.set_color(255, 255, 255, 255) 
img.fill_rectangle(0,0,160,160) img.set_color(0,0,0,255) 
my_draw_line(img, 10, 80, 80, 160)my_draw_line(img, 80, 160, 160, 80)my_draw_line(img, 160, 80, 80, 10)my_draw_line(img, 80, 10, 10, 80) img.save(strv); 
img.set_color(255, 255, 255, 255) 
img.fill_rectangle(0,0,160,160)img.set_color(0,0,0,255) 
img.draw_line(10, 80, 80, 160)img.draw_line(80, 160, 160, 80)img.draw_line(160, 80, 80, 10)img.draw_line(80, 10, 10, 80) img.save(strv)"
"class RGBColour  def ==(a_colour)    values == a_colour.values  endend class Queue < Array  alias_method :enqueue, :push  alias_method :dequeue, :shiftend class Pixmap  def flood_fill(pixel, new_colour)    current_colour = self[pixel.x, pixel.y]    queue = Queue.new    queue.enqueue(pixel)    until queue.empty?      p = queue.dequeue      if self[p.x, p.y] == current_colour        west = find_border(p, current_colour, :west)        east = find_border(p, current_colour, :east)        draw_line(west, east, new_colour)        q = west        while q.x <= east.x          [:north, :south].each do |direction|            n = neighbour(q, direction)            queue.enqueue(n) if self[n.x, n.y] == current_colour          end          q = neighbour(q, :east)        end      end    end  end   def neighbour(pixel, direction)    case direction    when :north then Pixel[pixel.x, pixel.y - 1]    when :south then Pixel[pixel.x, pixel.y + 1]    when :east  then Pixel[pixel.x + 1, pixel.y]    when :west  then Pixel[pixel.x - 1, pixel.y]    end  end   def find_border(pixel, colour, direction)    nextp = neighbour(pixel, direction)    while self[nextp.x, nextp.y] == colour      pixel = nextp      nextp = neighbour(pixel, direction)    end    pixel  endend bitmap = Pixmap.new(300, 300)bitmap.draw_circle(Pixel[149,149], 120, RGBColour::BLACK)bitmap.draw_circle(Pixel[200,100], 40, RGBColour::BLACK)bitmap.flood_fill(Pixel[140,160], RGBColour::BLUE)"
"
x = strv 
x = nil 
x = ""ab""x.length  
 
if x == strv  puts strvelse  puts strvendy = 'bc'if x < y  puts strvend 
xx = x.dupx == xx       
x.equal?(xx)  
 
if x.empty?  puts strvend 
p x << ""7"" 
p xx = x[0..-2]x[1,2] = strvp x 
p y = strv.tr(strv, strv) 
a = strvb = strvc = strvp d = a + b + c"
" 
#

require 'digest/sha2'def convert g  i,e = '',[]  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}  e.pack(i)endN = [0,1,2,3,4,5,6,7,8,nil,nil,nil,nil,nil,nil,nil,9,10,11,12,13,14,15,16,nil,17,18,19,20,21,nil,22,23,24,25,26,27,28,29,30,31,32,nil,nil,nil,nil,nil,nil,33,34,35,36,37,38,39,40,41,42,43,nil,44,45,46,47,48,49,50,51,52,53,54,55,56,57]A = '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62x'g = A.bytes.inject(0){|g,n| g*58+N[n-49]}.to_s(16) 
n = g.slice!(0..-9)(n.length...42).each{n.insert(0,'0')}puts ""I think the checksum should be #{g}I calculate that it is         #{Digest::SHA256.hexdigest(Digest::SHA256.digest(convert(n)))[0,8]}"" "
"class RGBColour  def initialize(red, green, blue)    unless red.between?(0,255) and green.between?(0,255) and blue.between?(0,255)      raise ArgumentError, strv    end    @red, @green, @blue = red, green, blue  end  attr_reader :red, :green, :blue  alias_method :r, :red  alias_method :g, :green  alias_method :b, :blue   RED   = RGBColour.new(255,0,0)  GREEN = RGBColour.new(0,255,0)  BLUE  = RGBColour.new(0,0,255)  BLACK = RGBColour.new(0,0,0)  WHITE = RGBColour.new(255,255,255)end class Pixmap  def initialize(width, height)    @width = width    @height = height    @data = fill(RGBColour::WHITE)  end  attr_reader :width, :height   def fill(colour)    @data = Array.new(@width) {Array.new(@height, colour)}  end   def validate_pixel(x,y)    unless x.between?(0, @width-1) and y.between?(0, @height-1)      raise ArgumentError, strv    end  end   def [](x,y)    validate_pixel(x,y)    @data[x][y]  end  alias_method :get_pixel, :[]   def []=(x,y,colour)    validate_pixel(x,y)    @data[x][y] = colour  end  alias_method :set_pixel, :[]=end"
"def best_shuffle(s)  
  
  pos = []  
  g = s.length.times.group_by { |i| s[i] }   
  k = g.sort_by { |k, v| v.length }.map { |k, v| k }   until g.empty?    k.each do |letter|      g[letter] or next      pos.push(g[letter].pop)      g[letter].empty? and g.delete letter    end  end   
  
  
  letters = s.dup  new = strv * s.length  until letters.empty?    i, p = 0, pos.pop    i += 1 while letters[i] == s[p] and i < (letters.length - 1)    new[p] = letters.slice! i  end   score = new.chars.zip(s.chars).count { |c, d| c == d }  [new, score]end %w(abracadabra seesaw elk grrrrrr up a).each do |word|  puts strv % [word, *best_shuffle(word)]endfunc best_shuffle(String orig) -> (String, Number) {     var s = orig.chars    var t = s.shuffle     s.range.each { |i|        s.range.each { |j|            if (i!=j && t[i]!=s[j] && t[j]!=s[i]) {                t[i, j] = t[j, i];                break;            }        }    }     var word = t.join;    (word, orig ^ word -> count(""""));} <abracadabra seesaw elk grrrrrr up a>.each { |word|    var (sword, score) = best_shuffle(word)    ""%-12s %12s: %d"".printf(word, sword, score)}"
"[5,50,9000].each do |n|  puts strv % nendfor n in [5,50,9000]  puts n.to_s(2)end[5, 50, 9000].each { |n|    say n.as_bin;}"
"require 'open-uri'require 'base64' puts Base64.encode64 open('http://rosettacode.org/favicon.ico') {|f| f.read}var base64 = frequire('MIME::Base64'); var file = %f'favicon.ico';file.open('<:raw', \var fh); print base64.encode_base64(fh.slurp);"
"bernoulli = Enumerator.new do |y|  ar, m = [], 0  loop do    ar << Rational(1, m+1)    m.downto(1){|j| ar[j-1] = j*(ar[j-1] - ar[j]) }    y << ar.first  
    m += 1  endend b_nums = bernoulli.take(61)width  = b_nums.map{|b| b.numerator.to_s.size}.maxb_nums.each_with_index {|b,i| puts strv % [i, width, b.numerator, b.denominator] unless b.zero? }  func bernoulli_number{};     
 func bern_helper(n, k) {    binomial(n, k) * (bernoulli_number(k) / (n - k + 1));} func bern_diff(n, k, d) {    n < k ? d : bern_diff(n, k + 1, d - bern_helper(n + 1, k));} bernoulli_number = func(n) is cached {     n.is_one && return 1/2;    n.is_odd && return   0;     n > 0 ? bern_diff(n - 1, 0, 1) : 1;} range(0, 60).each { |i|    var num = bernoulli_number(i) || next;    printf(""B(%2d) = %44s / %s"", i, num.parts);}func bernoulli_print {    var a = []    range(0, 60).each { |m|        a << (m+1 -> inv)        m.downto(1).each { |j|            (a[j-1] -= a[j]) *= j        }        a[0] || next        printf(""B(%2d) = %44s / %s"", m, a[0].parts)    }} bernoulli_print()"
"class Array  def binary_search(val, low=0, high=(length - 1))    return nil if high < low    mid = (low + high) >> 1    case val <=> self[mid]      when -1        binary_search(val, low, mid - 1)      when 1        binary_search(val, mid + 1, high)      else mid    end  endend ary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324] [0,42,45,24324,99999].each do |val|  i = ary.binary_search(val)  if i    puts strv  else    puts strv  endendclass Array  def binary_search_iterative(val)    low, high = 0, length - 1    while low <= high      mid = (low + high) >> 1      case var <=> self[mid]        when 1          low = mid + 1        when -1          high = mid - 1        else          return mid      end    end    nil  endend ary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324] [0,42,45,24324,99999].each do |val|  i = ary.binary_search_iterative(val)  if i    puts strv  else    puts strv  endendhaystack = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]needles = [0,42,45,24324,99999] needles.select{|needle| haystack.bsearch{|hay| needle <=> hay} } 
 func binary_search(a, i) {     var l = 0;    var h = a.end;     while (l <= h) {        var mid = (h+l / 2 -> int);        a[mid] > i && (h = mid-1; next);        a[mid] < i && (l = mid+1; next);        return mid;    }     return -1;}func binary_search(arr, value, low=0, high=arr.end) {    high < low && return -1;    var middle = (high+low / 2 -> int);     if (value < arr[middle]) {        return binary_search(arr, value, low, middle-1);    }    elsif (value > arr[middle]) {        return binary_search(arr, value, middle+1, high);    }     return middle;}say binary_search([34, 42, 55, 778], 55);       #=> 2"
n = 0n = n + 2 until (n*n).modulo(1000000) == 269696 puts n  var n = 0while (n*n % 1000000 != 269696) {    n += 2}say n
"EXPECTED = (1..9).map{|d| Math.log10(1+1.0/d)} def fib(n)  a,b = 0,1  n.times.map{ret, a, b = a, b, a+b; ret}end 
def power_of_threes(n)  n.times.map{|k| 3**k}end def heads(s)  s.map{|a| a.to_s[0].to_i}end def show_dist(title, s)  s = heads(s)  c = Array.new(10, 0)  s.each{|x| c[x] += 1}  size = s.size.to_f  res = (1..9).map{|d| c[d]/size}  puts ""    %s Benfords deviation"" % title  res.zip(EXPECTED).each.with_index(1) do |(r, e), i|    puts strv % [i, r*100, e*100, (r - e).abs*100]  endend def random(n)  n.times.map{rand(1..n)}end show_dist(strv, fib(1000))show_dist(strv, power_of_threes(1000)) 
show_dist(strv, random(10000))var fibonacci = [0, 1] ;{    fibonacci.append(fibonacci[-1] + $fibonacci[-2]);} * (1000 - fibonacci.len); var (actuals, expected) = ([], []); { |i|    var num = 0;    fibonacci.each { |j| j.digit(-1) == i && (num++)};    actuals.append(num / 1000);    expected.append(1 + (1/i) -> log10);} * 9; ""%17s%17s"".printf(strv,strv);{ |i|    ""%d : %11s %%%15s %%"".printf(            i, strv.sprintf(100 *  actuals[i - 1]),               strv.sprintf(100 * expected[i - 1]),    );} * 9;"
"re = /\A     
  (?<bb>     
    \[       
    \g<bb>*  
    \]       
  )*         
\z/x         
 10.times do |i|  s = (%w{[ ]} * i).shuffle.join  puts (s =~ re ? strv : strv) + send [strv, strv, strv].each do |s|  t = s.gsub(/[^\[\]]/, strv)  puts (t =~ re ? strv : strv) + sendfunc balanced (str) {     var depth = 0;    str.each { |c|           if(c=='['){ ++depth }        elsif(c==']'){ --depth < 0 && return false }    };     return !depth;} [']','[','[[]','][]','[[]]','[[]]]][][]]','x[ y [ [] z ]][ 1 ][]abcd'].each { |str|    printf(""%sbalanced: %s"", balanced(str) ? strv : strv, str);};"
"def simple_moving_average(size)  nums = []  sum = 0.0  lambda do |hello|    nums << hello    goodbye = nums.length > size ? nums.shift : 0    sum += hello - goodbye    sum / nums.length  endend ma3 = simple_moving_average(3)ma5 = simple_moving_average(5) (1.upto(5).to_a + 5.downto(1).to_a).each do |num|  printf ""Next number = %d, SMA_3 = %.3f, SMA_5 = %.1f"",     num, ma3.call(num), ma5.call(num)endclass MovingAverager  def initialize(size)    @size = size    @nums = []    @sum = 0.0  end  def <<(hello)    @nums << hello    goodbye = @nums.length > @size ? @nums.shift : 0    @sum += hello - goodbye    self  end  def average    @sum / @nums.length  end  alias to_f average  def to_s    average.to_s  endend ma3 = MovingAverager.new(3)ma5 = MovingAverager.new(5) (1.upto(5).to_a + 5.downto(1).to_a).each do |num|  printf ""Next number = %d, SMA_3 = %.3f, SMA_5 = %.1f"",     num, ma3 << num, ma5 <<numendfunc simple_moving_average(period) {     var list = []    var sum = 0     func (number) {        list.append(number)        sum += number        if (list.len > period) {            sum -= list.shift        }        (sum / list.length)    }} var ma3 = simple_moving_average(3);var ma5 = simple_moving_average(5); [1 ..^ 6, 6 ^.. 1].map{@|_} -> each {|num|  printf(""Next number = %d, SMA_3 = %.3f, SMA_5 = %.1f"",    num, ma3.call(num), ma5.call(num))}class sma_generator(period, list=[], sum=0) {     method SMA(number) {        list.append(number)        sum += number        if (list.len > period) {            sum -= list.shift        }        (sum / list.len)    }} var ma3 = sma_generator(3)var ma5 = sma_generator(5) for num in [@|(1..5), @|(1..5 -> flip)] {  printf(""Next number = %d, SMA_3 = %.3f, SMA_5 = %.1f"",    num, ma3.SMA(num), ma5.SMA(num))}"
"class BalancedTernary  include Comparable  def initialize(str = strv)    if str =~ /[^-+0]+/      raise ArgumentError, strv    end    @digits = trim0(str)  end   I2BT = {0 => [strv,0], 1 => [strv,0], 2 => [strv,1]}  def self.from_int(value)    n = value.to_i    digits = strv    while n != 0      quo, rem = n.divmod(3)      bt, carry = I2BT[rem]      digits = bt + digits      n = quo + carry    end    new(digits)  end   BT2I = {strv => -1, strv => 0, strv => 1}  def to_int    @digits.chars.inject(0) do |sum, char|      sum = 3 * sum + BT2I[char]    end  end  alias :to_i :to_int   def to_s    @digits.dup                 
  end  alias :inspect :to_s   def <=>(other)    to_i <=> other.to_i  end   ADDITION_TABLE = {    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],    strv => [strv,strv], strv => [strv,strv], strv => [strv,strv],  }   def +(other)    maxl = [to_s.length, other.to_s.length].max    a = pad0_reverse(to_s, maxl)    b = pad0_reverse(other.to_s, maxl)    carry = strv    sum = a.zip( b ).inject(strv) do |sum, (c1, c2)|      carry, digit = ADDITION_TABLE[carry + c1 + c2]      sum = digit + sum    end    self.class.new(carry + sum)  end   MULTIPLICATION_TABLE = {    strv => strv,    strv => strv,    strv => strv,  }   def *(other)    product = self.class.new    other.to_s.each_char do |bdigit|      row = to_s.tr(strv, MULTIPLICATION_TABLE[bdigit])      product += self.class.new(row)      product << 1    end    product >> 1  end   
  def -@()    self.class.new(@digits.tr('-+','+-'))  end   
  def -(other)    self + (-other)  end   
  def <<(count)    @digits = trim0(@digits + strv*count)    self  end   
  def >>(count)    @digits[-count..-1] = strv if count > 0    @digits = trim0(@digits)    self  end   private   def trim0(str)    str = str.sub(/^0+/, strv)    str = strv if str.empty?    str  end   def pad0_reverse(str, len)    str.rjust(len, strv).reverse.chars  endend a = BalancedTernary.new(strv)b = BalancedTernary.from_int(-436)c = BalancedTernary.new(strv) %w[a b c a*(b-c)].each do |exp|  val = eval(exp)  puts strv % [exp, val, val.to_i]end"
"class Array  def arithmetic_mean    inject(0.0, :+) / length  end   def geometric_mean    inject(:*) ** (1.0 / length)  end   def harmonic_mean    length / inject(0.0) {|s, m| s + 1.0/m}  endend class Range  def method_missing(m, *args)    case m    when /_mean$/ then to_a.send(m)    else super    end  endend p a = (1..10).arithmetic_meanp g = (1..10).geometric_meanp h = (1..10).harmonic_mean
p g.between?(h, a)"
"class Array  def quadratic_mean    Math.sqrt( self.inject(0.0) {|s, y| s + y*y} / self.length )  endend class Range  def quadratic_mean    self.to_a.quadratic_mean  endend (1..10).quadratic_mean  
def rms(seq)  Math.sqrt(seq.inject(0.0) {|sum, x| sum + x*x} / seq.length)endputs rms (1..10).to_a   
func rms(a) {    Math.sqrt(a.map{.**2}.sum / a.len);} say rms(1..10);"
"def mode(ary)  seen = Hash.new(0)  ary.each {|value| seen[value] += 1}  max = seen.values.max  seen.find_all {|key,value| value == max}.map {|key,value| key}end def mode_one_pass(ary)  seen = Hash.new(0)  max = 0  max_elems = []  ary.each do |value|    seen[value] += 1    if seen[value] > max      max = seen[value]      max_elems = [value]    elsif seen[value] == max      max_elems << value    end  end  max_elemsend p mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  
p mode([1, 1, 2, 4, 4]) 
p mode_one_pass([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  
p mode_one_pass([1, 1, 2, 4, 4]) 
def one_mode(ary)  ary.max_by { |x| ary.count(x) }endfunc mode(array) {    var c = Hash.new;    array.each{|i| c{i} := 0 ++};    var max = c.values.max;    c.keys.grep{|i| c{i} == max};}say mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]).join(' ');say mode([1, 1, 2, 4, 4]).join(' ');func one_mode(arr) {    arr.max_by{|i| arr.count(i)};}"
"require 'complex' 
 def deg2rad(d)  d * Math::PI / 180end def rad2deg(r)  r * 180 / Math::PIend def mean_angle(deg)  rad2deg((deg.inject(0) {|z, d| z + Complex.polar(1, deg2rad(d))} / deg.length).arg)end [[350, 10], [90, 180, 270, 360], [10, 20, 30]].each {|angles|  puts strv % [angles, mean_angle(angles)]}func mean_angle(angles) {    Math.atan2(        Math.avg(angles.map{ .deg2rad.sin }...),        Math.avg(angles.map{ .deg2rad.cos }...),    ) -> rad2deg;} [[350,10], [90,180,270,360], [10,20,30]].each { |angles|  say strv;}"
"def time2deg(t)  raise strv unless m = t.match(/^(\d\d):(\d\d):(\d\d)$/)  hh,mm,ss = m[1..3].map {|e| e.to_i}  raise strv unless (0..23).include? hh and                              (0..59).include? mm and                              (0..59).include? ss  (hh*3600 + mm*60 + ss) * 360 / 86400.0end def deg2time(d)  sec = (d % 360) * 86400 / 360.0  strv % [sec/3600, (sec%3600)/60, sec%60]end def mean_time(times)  deg2time(mean_angle(times.map {|t| time2deg t}))end puts mean_time [strv, strv, strv, strv]func time2deg(t) {  (var m = t.match(/^(\d\d):(\d\d):(\d\d)$/)) || die strv  var (hh,mm,ss) = m.cap.map{.to_i}...  ((hh ~~ 24.range) && (mm ~~ 60.range) && (ss ~~ 60.range)) || die strv  (hh*3600 + mm*60 + ss) * 360 / 86400} func deg2time(d) {  var sec = ((d % 360) * 86400 / 360)  strv % (sec/3600, (sec%3600)/60, sec%60)} func mean_time(times) {  deg2time(mean_angle(times.map {|t| time2deg(t)}))} say mean_time([strv, strv, strv, strv])"
"def median(ary)  return nil if ary.empty?  mid, rem = ary.length.divmod(2)  if rem == 0    ary.sort[mid-1,2].inject(:+) / 2.0  else    ary.sort[mid]  endend p median([])                        
p median([5,3,4])                   
p median([5,4,2,3])                 
p median([3,4,1,-8.4,7.2,4,1,1.2])  
def median(aray)    srtd = aray.sort    alen = srtd.length    (srtd[(alen-1)/2] + srtd[alen/2]) / 2.0endfunc median(arry) {    var srtd = arry.sort;    var alen = srtd.length;    srtd[(alen-1)/2]+srtd[alen/2] / 2;}"
"def mean(nums)  nums.inject(0.0, :+) / nums.sizeend nums = [3, 1, 4, 1, 5, 9]nums.size.downto(0) do |i|  ary = nums[0,i]  puts strvendfunc avg(Array list) {    list.len > 0 || return 0;    list.sum / list.len;} say avg([Math.inf, Math.inf]);say avg([3,1,4,1,5,9]);say avg([1e+20, 3, 1, 4, 1, 5, 9, -1e+20]);say avg([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0.11]);say avg([10, 20, 30, 40, 50, -100, 4.7, -1100]);"
"require 'thread' 


class BucketStore   
  
  def initialize nbuckets    
    @buckets = (0...nbuckets).map { rand(1024) }     
    @mutex = Mutex.new  end   
  def buckets    @mutex.synchronize { Array.new(@buckets) }  end   
  
  def transfer destination, source, amount    
    return nil if destination == source     @mutex.synchronize do      
      amount = [amount, @buckets[source]].min       @buckets[source] -= amount      @buckets[destination] += amount    end    nil  endend 
bucket_store = BucketStore.new 8 
TOTAL = bucket_store.buckets.inject { |a, b| a += b } 
Thread.new do  loop do    
    buckets = bucket_store.buckets    first = rand buckets.length    second = rand buckets.length     
    first, second = second, first if buckets[first] > buckets[second]     
    bucket_store.transfer first, second, (buckets[second] - buckets[first]) / 2  endend 
Thread.new do  loop do    
    buckets = bucket_store.buckets    first = rand buckets.length    second = rand buckets.length     
    bucket_store.transfer first, second, rand(buckets[second])  endend 
loop do  sleep 1   buckets = bucket_store.buckets   
  
  
  n = buckets.inject { |a, b| a += b }   
  printf ""%s, total %d"", (buckets.map { |v| sprintf strv, v }.join strv), n   if n != TOTAL    
    $stderr.puts strv    exit 1  endend"
 require 'contracts'include Contracts Contract Num => Numdef double(x)  x * 2end puts double(strv) 
"class Integer  def factorial    self == 0 ? 1 : (1..self).inject(:*)  endend def rand_until_rep(n)  rands = {}  loop do    r = rand(1..n)    return rands.size if rands[r]    rands[r] = true  endend runs = 1_000_000 puts strv,     strv(1..20).each do |n|  sum_of_runs = runs.times.inject(0){|sum, _| sum += rand_until_rep(n)}  avg = sum_of_runs / runs.to_f  analytical = (1..n).inject(0){|sum, i| sum += (n.factorial / (n**i).to_f / (n-i).factorial)}  puts strv % [n, avg, analytical, (avg/analytical - 1)*100]end"
" dict = { 'def' => 1, 'abc' => 2 } for( keyvalue in dict ) io.writeln( keyvalue );for( key in dict.keys(); value in dict.values() ) io.writeln( key, value )dict.iterate { [key, value]    io.writeln( key, value )} my_dict = { strv => 13,	   strv => 31,	   strv     => 71 } 
my_dict.each {|key, value| puts strv}
my_dict.each_pair {|key, value| puts strv} 
my_dict.each_key {|key| puts strv} 
my_dict.each_value {|value| puts strv}for key, value in my_dict  puts strvend for key in my_dict.keys  puts strvend for value in my_dict.values  puts strvendvar hash = Hash.new(    key1 => 'value1',    key2 => 'value2',) 
hash.each { |key, value|    say strv;} 
hash.keys.each { |key|    say key;} 
hash.values.each { |value|    say value;}"
"hash={}hash[666]='devil'hash[777]  
hash[666]  
hash=Hash.new('unknown key')hash[666]='devil'hash[777]  
hash[666]  
hash=Hash.new{|h,k| strv}hash[666]='devil'hash[777]  
hash[666]  
hash=Hash.new{|h,k|h[k]=strv}hash[777]  
hash[555]  
hash[777]  
var hash = Hash.new(    key1 => 'value1',    key2 => 'value2',); 
hash{:key3} = 'value3';"
"require strvinclude ::Assertions n = 5begin  assert_equal(42, n)rescue Exception => e  
  
  puts eendvar num = pick(0..100);assert_eq(num, 42);         
"
"puts ['apple', 'orange'].length  
var arr = ['apple', 'orange'];say arr.len;        #=> 2say arr.end;        #=> 1 (zero based)"
"
a = ['foo'] 
 
a << 1         
a.push(3,4,5)  
 
a[0] = 2       
 
a[0,3] = 'bar'    
a[1..-1] = 'baz'  
a[0] = nil        
a[0,1] = nil      
 
puts a[0]
var arr = []; 
arr << strv;           #: ['a']arr.append(1,2,3);    #: ['a', 1, 2, 3] 
arr[2] = strv;         #: ['a', 1, 'b', 3] 
arr[5] = strv;       #: ['a', 1, 'b', 3, nil, 'end'] 
arr.resize_to(-1);    #: [] 
arr[0..2] = @|('a'..'c');       #: ['a', 'b', 'c'] 
var indices = [0, -1];arr[indices] = (strv, strv);  #: ['foo', 'b', 'baz'] 
var *elems = arr[0, -1]say elems                #=> ['foo', 'baz'] 
say arr[-1];             #=> 'baz'"
"arr1 = [1, 2, 3]arr2 = [4, 5, 6]arr3 = [7, 8, 9]arr4 = arr1 + arr2  
arr4.concat(arr3)  
 
[arr1,arr2,arr3].flatten(1)
[arr1,arr2,arr3].compact.flatten(1) var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];var arr3 = (arr1 + arr2);   
"
"require 'rational' #Only needed in Ruby < 1.9 for candidate in 2 .. 2**19  sum = Rational(1, candidate)  for factor in 2 ... candidate**0.5    if candidate % factor == 0      sum += Rational(1, factor) + Rational(1, candidate / factor)    end  end  if sum.denominator == 1    puts strv %           [candidate, sum.to_i, sum == 1 ? strv : strv]  endend"
"
##

#require 'flt'Flt::BinNum.Context.precision = 8192a = n = 1g = 1 / Flt::BinNum(2).sqrtz = 0.25(0..17).each{  x = [(a + g) * 0.5, (a * g).sqrt]  var = x[0] - a  z -= var * var * n  n += n  a = x[0]  g = x[1]}puts a * a / zfunc agm_pi(digits) {    var acc = (digits + 8);     local Num!PREC = 4*digits;     var an = 1;    var bn = sqrt(0.5);    var tn = 0.5**2;    var pn = 1;     while (pn < acc) {        var prev_an = an;        an = (bn+an / 2);        bn = sqrt(bn * prev_an);        prev_an -= an;        tn -= (pn * prev_an**2);        pn *= 2;    }     ((an+bn)**2 / 4*tn).to_s} say agm_pi(100);"
"


 require 'flt'include Flt BinNum.Context.precision = 512  
 def agm(a,g)  new_a = BinNum a  new_g = BinNum g  while new_a - new_g > new_a.class.Context.epsilon do    old_g = new_g    new_g = (new_a * new_g).sqrt    new_a = (old_g + new_a) * 0.5  end  new_gend puts agm(1, 1 / BinNum(2).sqrt)require 'bigdecimal' PRECISION = 100EPSILON = 0.1 ** (PRECISION/2)BigDecimal::limit(PRECISION) def agm(a,g)  while a - g > EPSILON    a, g = (a+g)/2, (a*g).sqrt(PRECISION)  end  [a, g]end a = BigDecimal(1)g = 1 / BigDecimal(2).sqrt(PRECISION)puts agm(a, g)func agm(a, g) {    loop {        var x = [float(a+g / 2), sqrt(a*g)]        x == [a, g] && return a        x >> \(a, g)    }} say agm(1, 1/sqrt(2))"
"$op_priority = {strv => 0, strv => 0, strv => 1, strv => 1} class TreeNode  OP_FUNCTION = {    strv => lambda {|x, y| x + y},    strv => lambda {|x, y| x - y},    strv => lambda {|x, y| x * y},    strv => lambda {|x, y| x / y}}  attr_accessor :info, :left, :right   def initialize(info)    @info = info  end   def leaf?    @left.nil? and @right.nil?  end   def to_s(order)    if leaf?      @info    else      left_s, right_s = @left.to_s(order), @right.to_s(order)       strs = case order             when :prefix  then [@info, left_s, right_s]             when :infix   then [left_s, @info, right_s]             when :postfix then [left_s, right_s, @info]             else               []             end       strv + strs.join(strv) + strv    end  end   def eval    if !leaf? and operator?(@info)      OP_FUNCTION[@info].call(@left.eval, @right.eval)    else      @info.to_f    end  endend def tokenize(exp)  exp    .gsub('(', ' ( ')    .gsub(')', ' ) ')    .gsub('+', ' + ')    .gsub('-', ' - ')    .gsub('*', ' * ')    .gsub('/', ' / ')    .split(' ')end def operator?(token)  $op_priority.has_key?(token)end def pop_connect_push(op_stack, node_stack)  temp = op_stack.pop  temp.right = node_stack.pop  temp.left = node_stack.pop  node_stack.push(temp)end def infix_exp_to_tree(exp)  tokens = tokenize(exp)  op_stack, node_stack = [], []   tokens.each do |token|    if operator?(token)      
      until (op_stack.empty? or             op_stack.last.info == strv or             $op_priority[op_stack.last.info] < $op_priority[token])        pop_connect_push(op_stack, node_stack)      end       op_stack.push(TreeNode.new(token))    elsif token == strv      op_stack.push(TreeNode.new(token))    elsif token == strv      while op_stack.last.info != strv        pop_connect_push(op_stack, node_stack)      end       
      op_stack.pop    else      node_stack.push(TreeNode.new(token))    end  end   until op_stack.empty?    pop_connect_push(op_stack, node_stack)  end   node_stack.lastendexp = strvputs(strv + exp) tree = infix_exp_to_tree(exp)puts(strv + tree.to_s(:prefix))puts(strv + tree.to_s(:infix))puts(strv + tree.to_s(:postfix))puts(strv + tree.eval.to_s)func evalArithmeticExp(s) {     func evalExp(s) {         func operate(s, op) {           s.split(op).map{|c| c.to_num }.reduce(op);        }         func add(s) {            operate(s.sub(/^\+/,'').sub(/\++/,'+'), '+');        }         func subtract(s) {            s.gsub!(/(\+-|-\+)/,'-');             if (s ~~ /--/) {                return(add(s.sub(/--/,'+')));            }             var b = s.split('-');            b.len == 3 ? (-1*b[1].to_num - b[2].to_num)                       : operate(s, '-');        }         s.gsub!(/[()]/,'').gsub!(/-\+/, '-');         var reM  = /\*/;        var reMD = %r""(+?**[*/]*[+-]?+?*)"";         var reA  = /\d\+/;        var reAS = /(-?\d+\.?\d*\s*[+-]\s*[+-]?\d+\.?\d*)/;         while (var match = reMD.match(s)) {            match[0] ~~ reM                ? s.sub!(reMD, operate(match[0], '*').to_s)                : s.sub!(reMD, operate(match[0], '/').to_s);        }         while (var match = reAS.match(s)) {            match[0] ~~ reA                ? s.sub!(reAS,      add(match[0]).to_s)                : s.sub!(reAS, subtract(match[0]).to_s);        }         return s;    }     var rePara = /(\([^\(\)]*\))/;    s.split!.join!('').sub!(/^\+/,'');     while (var match = s.match(rePara)) {        s.sub!(rePara, evalExp(match[0]));    }     return evalExp(s).to_num;}for expr,res in [     ['2+3'                                      =>        5],     ['-4-3'                                     =>       -7],     ['-+2+3/4'                                  =>    -1.25],     ['2*3-4'                                    =>        2],     ['2*(3+4)+2/4'                              => 2/4 + 14],     ['2*-3--4+-0.25'                            =>    -2.25],     ['2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10' =>     7000],] {     var num = evalArithmeticExp(expr);    assert_eq(num, res);    ""%-45s == %10g"".printf(expr, num);}"
"def cumulative_freq(freq)  cf = {}  total = 0  freq.keys.sort.each do |b|    cf[b] = total    total += freq[b]  end  return cfend def arithmethic_coding(bytes, radix)   
  freq = Hash.new(0)  bytes.each { |b| freq[b] += 1 }   
  cf = cumulative_freq(freq)   
  base = bytes.size   
  lower = 0   
  pf = 1   
  
  bytes.each do |b|    lower = lower*base + cf[b]*pf    pf *= freq[b]  end   
  upper = lower+pf   pow = 0  loop do    pf /= radix    break if pf==0    pow += 1  end   enc = ((upper-1) / radix**pow)  [enc, pow, freq]end def arithmethic_decoding(enc, radix, pow, freq)   
  enc *= radix**pow;   
  base = freq.values.reduce(:+)   
  cf = cumulative_freq(freq)   
  dict = {}  cf.each_pair do |k,v|    dict[v] = k  end   
  lchar = nil  (0...base).each do |i|    if dict.has_key?(i)      lchar = dict[i]    elsif lchar != nil      dict[i] = lchar    end  end   
  decoded = []  (0...base).reverse_each do |i|    pow = base**i    div = enc/pow     c  = dict[div]    fv = freq[c]    cv = cf[c]     rem = ((enc - pow*cv) / fv)     enc = rem    decoded << c  end   
  return decodedend radix = 10      
 %w(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT).each do |str|   enc, pow, freq = arithmethic_coding(str.bytes, radix)  dec = arithmethic_decoding(enc, radix, pow, freq).map{|b| b.chr }.join   printf(""%-25s=> %19s * %d^%s"", str, enc, radix, pow)   if str != dec    raise ""However that is incorrect!""  endendfunc cumulative_freq(freq) {    var cf = Hash()    var total = 0    256.range.each { |b|        if (freq.contains(b)) {            cf{b} = total            total += freq{b}        }    }    return cf} func arithmethic_coding(bytes, radix=10) {     
    var freq = Hash()    bytes.each { |b| freq{b} := 0 ++ }     
    var cf = cumulative_freq(freq)     
    var base = bytes.len     
    var L = 0     
    var pf = 1     
    
    bytes.each { |b|        L = (L*base + cf{b}*pf)        pf *= freq{b}    }     
    var U = L+pf     var pow = pf.log(radix).int    var enc = ((U-1) // radix**pow)     return (enc, pow, freq)} func arithmethic_decoding(enc, radix, pow, freq) {     
    enc *= radix**pow;     
    var base = freq.values.sum     
    var cf = cumulative_freq(freq);     
    var dict = Hash()    cf.each_kv { |k,v|        dict{v} = k    }     
    var lchar = ''    base.range.each { |i|        if (dict.contains(i)) {            lchar = dict{i}        }        elsif (!lchar.is_empty) {            dict{i} = lchar        }    }     
    var decoded = []    base.range.reverse.each { |i|         var pow = base**i;        var div = enc//pow         var c  = dict{div}        var fv = freq{c}        var cv = cf{c}         var rem = ((enc - pow*cv) // fv)         enc = rem        decoded << c    }     
    return decoded} var radix = 10;      
 %w(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT).each { |str|     var (enc, pow, freq) = arithmethic_coding(str.bytes, radix)    var dec = arithmethic_decoding(enc, radix, pow, freq).join_bytes('UTF-8')     printf(""%-25s=> %19s * %d^%s"", str, enc, radix, pow);     if (str != dec) {        die ""However that is incorrect!""    }}"
"puts 'Enter x and y'x = gets.to_i  
y = gets.to_i puts strv,     strv,     strv,     strv,       
     strv, 
     strv,      
     strvvar a = Sys.scanln(strv).to_i;var b = Sys.scanln(strv).to_i; %w'+ - * // % ** ^ | & << >>'.each { |op|    strv.say;}"
"irb(main):001:0> y = ( 5**4**3**2 ).to_s; puts strv5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digitsvar x = 5**(4**(3**2));var y = x.to_s;printf(""5**4**3**2 = %s...%s and has %i digits"", y.ft(0,19), y.ft(-20), y.len);"
"require 'complex'  
 
a = Complex(1, 1)       
i = Complex::I          
b = 3.14159 + 1.25 * ic = '1/2+3/4i'.to_c     
 #Ruby 2.1 introduced a suffix to create a complex:c =  1.0/2+3/4i         
 
puts a + b              
puts a * b              
puts -a                 
puts 1.quo a            
puts a.conjugate        
puts a.conj             

puts 1.quo a            
puts 1.0 / a            
puts 1 / a              
require strvCMath.sqrt(-9)      #=> 0+3.0iCMath.acos(0+3.0i)  #=> (1.5707963267948966-1.8184464592320668i)#etcvar a = 1:1;                
var b = 3.14159:1.25;       
 [   a + b,                  
    a * b,                  
    -a,                     
    1 / a,                  
    ~a,                     
    a.abs,                  
    a.sqrt,                 
    b.re,                   
    b.im,                   
].each { |c| say c }"
"for i in [1,2,3,4,5] do   puts i**2end[1,2,3,4,5].each{ |i| puts i**2 }[1,2,3,4,5].map{ |i| i**2 }func callback(i) { say i**2 };[1,2,3,4].each(callback);[1,2,3,4].each{|i| say i**2 };[1,2,3,4,5].map{|i| i**2 };"
"Gecos = Struct.new :fullname, :office, :extension, :homephone, :email class Gecos  def to_s    strv % to_a  endend 
Passwd = Struct.new(:account, :password, :uid, :gid, :gecos, :directory, :shell) do  def to_s    to_a.join(':')  endend jsmith = Passwd.new('jsmith','x',1001, 1000, Gecos.new('Joe Smith', 'Room 1007', '(234)555-8917', '(234)555-0077', 'jsmith@rosettacode.org'), '/home/jsmith', '/bin/bash')jdoe = Passwd.new('jdoe','x',1002, 1000, Gecos.new('Jane Doe', 'Room 1004', '(234)555-8914', '(234)555-0044', 'jdoe@rosettacode.org'), '/home/jdoe', '/bin/bash')xyz = Passwd.new('xyz','x',1003, 1000, Gecos.new('X Yz', 'Room 1003', '(234)555-8913', '(234)555-0033', 'xyz@rosettacode.org'), '/home/xyz', '/bin/bash') filename = 'append.records.test' 
File.open(filename, 'w') do |io|  io.puts jsmith  io.puts jdoeend puts strvputs File.readlines(filename) 
File.open(filename, 'a') do |io|  io.puts xyzend puts strvputs File.readlines(filename)define (    RECORD_FIELDS = %w(account password UID GID GECOS directory shell),    GECOS_FIELDS  = %w(fullname office extension homephone email),    RECORD_SEP    = ':',    GECOS_SEP     = ',',    PASSWD_FILE   = 'passwd.txt',) 
var records_to_write = [    Hash(        account  => 'jsmith',        password => 'x',        UID      => 1001,        GID      => 1000,        GECOS    => Hash(            fullname  => 'John Smith',            office    => 'Room 1007',            extension => '(234)555-8917',            homephone => '(234)555-0077',            email     => 'jsmith@rosettacode.org',        ),        directory => '/home/jsmith',        shell     => '/bin/bash',    ),    Hash(        account  => 'jdoe',        password => 'x',        UID      => 1002,        GID      => 1000,        GECOS    => Hash(            fullname  => 'Jane Doe',            office    => 'Room 1004',            extension => '(234)555-8914',            homephone => '(234)555-0044',            email     => 'jdoe@rosettacode.org',        ),        directory => '/home/jdoe',        shell     => '/bin/bash',    ),]; var record_to_append = Hash(    account  => 'xyz',    password => 'x',    UID      => 1003,    GID      => 1000,    GECOS    => Hash(        fullname  => 'X Yz',        office    => 'Room 1003',        extension => '(234)555-8913',        homephone => '(234)555-0033',        email     => 'xyz@rosettacode.org',    ),    directory => '/home/xyz',    shell     => '/bin/bash',); func record_to_string(rec, sep = RECORD_SEP, fields = RECORD_FIELDS) {    gather {        fields.each { |field|            var r = rec{field} \\ die strv            take(field == 'GECOS' ? record_to_string(r, GECOS_SEP, GECOS_FIELDS)                                  : r)        }    }.join(sep)} func write_records_to_file(records, filename = PASSWD_FILE, append = false) {    File(filename).(append ? :open_a : :open_w)(\var fh, \var err)    err && die strv;    fh.flock(File.LOCK_EX) || die strv    fh.seek(0, File.SEEK_END) || die strv    records.each { |record| fh.say(record_to_string(record)) }    fh.flock(File.LOCK_UN) || die strv    fh.close} 
write_records_to_file(records: records_to_write); 
write_records_to_file(records: [record_to_append], append: true); 
 File(PASSWD_FILE).open_r(\var fh, \var err)err && die strvvar lines = fh.lines 
assert(lines.len > 1) 
assert_eq(lines[-1], 'xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,' +                     '(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash') say strv"
"require 'tk'$str = TkVariable.new(strv)$dir = :right def animate  $str.value = shift_char($str.value, $dir)  $root.after(125) {animate}end def shift_char(str, dir)  case dir  when :right then str[-1,1] + str[0..-2]  when :left  then str[1..-1] + str[0,1]  endend $root = TkRoot.new(strv => strv) TkLabel.new($root) do  textvariable $str  font strv  pack {side 'top'}  bind(strv) {$dir = {:right=>:left,:left=>:right}[$dir]}end animateTk.mainloopShoes.app do  @direction = 1  @label = para strv, :family => 'monospace'   click {|button, left, top| @direction *= -1 if button == 1}   animate(8) do |f|     t = @label.text    @label.text = @direction > 0 ? t[-1] + t[0..-2] : t[1..-1] + t[0]  endend"
"def fib(n)  raise RangeError, strv if n < 0  (fib2 = proc { |m| m < 2 ? m : fib2[m - 1] + fib2[m - 2] })[n]end(-2..12).map { |i| fib i rescue :error }=> [:error, :error, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]def fib(n)  raise RangeError, strv if n < 0  (fib2 = proc { |n| n < 2 ? n : fib2[n - 1] + fib2[n - 2] })[n]end
(-2..12).map { |i| fib i rescue :error }=> [:error, :error, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144] 
(-2..12).map { |i| fib i rescue :error }=> [:error, :error, 0, 1, 0, -3, -8, -15, -24, -35, -48, -63, -80, -99, -120]def fib(n)  raise RangeError, strv if n < 0  Hash.new { |fib2, m|    fib2[m] = (m < 2 ? m : fib2[m - 1] + fib2[m - 2]) }[n]endrequire 'continuation' unless defined? Continuation module Kernel  module_function   def recur(*args, &block)    cont = catch(:recur) { return block[*args] }    cont[block]  end   def recurse(*args)    block = callcc { |cont| throw(:recur, cont) }    block[*args]  endend def fib(n)  raise RangeError, strv if n < 0  recur(n) { |m| m < 2 ? m : (recurse m - 1) + (recurse m - 2) }endrequire 'continuation' unless defined? Continuation module Kernel  module_function   def function(&block)    f = (proc do |*args|           (class << args; self; end).class_eval do             define_method(:callee) { f }           end           ret = nil           cont = catch(:function) { ret = block.call(*args); nil }           cont[args] if cont           ret         end)  end   def arguments    callcc { |cont| throw(:function, cont) }  endend def fib(n)  raise RangeError, strv if n < 0  function { |m|    if m < 2      m    else      arguments.callee[m - 1] + arguments.callee[m - 2]    end  }[n]end{ |i|    func (n) {        if (n < 0) { return };        n < 2 ? n              : (__FUNC__(n-2) + __FUNC__(n-1));    }(i).to_s.say;} * 10;{ |i|    { |n|        if (n < 0) { return };        n < 2 ? n              : (__BLOCK__(n-2) + __BLOCK__(n-1));    }(i).to_s.say;} * 10;"
"def getDifference(b1, b2)	r = (b2 - b1) % 360.0	
	
	if r >= 180.0		r -= 360.0	end	return rend if __FILE__ == $PROGRAM_NAME	puts strv	puts getDifference(20.0, 45.0)	puts getDifference(-45.0, 45.0)	puts getDifference(-85.0, 90.0)	puts getDifference(-95.0, 90.0)	puts getDifference(-45.0, 125.0)	puts getDifference(-45.0, 145.0)	puts getDifference(-45.0, 125.0)	puts getDifference(-45.0, 145.0)	puts getDifference(29.4803, -88.6381)	puts getDifference(-78.3251, -159.036) 	puts strv	puts getDifference(-70099.74233810938, 29840.67437876723)	puts getDifference(-165313.6666297357, 33693.9894517456)	puts getDifference(1174.8380510598456, -154146.66490124757)	puts getDifference(60175.77306795546, 42213.07192354373)endfunc bearingAngleDiff(b1, b2) {    (var b = ((b2 - b1 + 720) % 360)) > 180 ? (b - 360) : b} printf(""%25s %25s %25s"", strv, strv, strv)printf(""%25s %25s %25s"", strv*20, strv*20, strv*20)  for b1,b2 in ([                       20,                       45                      -45,                       45                      -85,                       90                      -95,                       90                      -45,                      125                      -45,                      145                  29.4803,                 -88.6381                 -78.3251,                 -159.036       -70099.74233810938,        29840.67437876723       -165313.6666297357,         33693.9894517456       1174.8380510598456,      -154146.66490124757        60175.77306795546,        42213.07192354373    ].slices(2)) {    printf(""%25s %25s %25s"", b1, b2, bearingAngleDiff(b1, b2))}"
"require 'tk' $root = TkRoot.new(strv => strv)$canvas = TkCanvas.new($root) do  width 320  height 200  create TkcLine, 0,25,320,25,   'tags' => 'plate', 'width' => 2, 'fill' => 'grey50'  create TkcOval, 155,20,165,30, 'tags' => 'pivot', 'outline' => strv, 'fill' => 'grey50'  create TkcLine, 1,1,1,1, 'tags' => 'rod', 'width' => 3, 'fill' => 'black'  create TkcOval, 1,1,2,2, 'tags' => 'bob', 'outline' => 'black', 'fill' => 'yellow'end$canvas.raise('pivot')$canvas.pack('fill' => 'both', 'expand' => true) $Theta = 45.0$dTheta = 0.0$length = 150$homeX = 160$homeY = 25 def show_pendulum  angle = $Theta * Math::PI / 180  x = $homeX + $length * Math.sin(angle)  y = $homeY + $length * Math.cos(angle)  $canvas.coords('rod', $homeX, $homeY, x, y)  $canvas.coords('bob', x-15, y-15, x+15, y+15)end def recompute_angle  scaling = 3000.0 / ($length ** 2)  
  firstDDTheta = -Math.sin($Theta * Math::PI / 180) * scaling  midDTheta = $dTheta + firstDDTheta  midTheta = $Theta + ($dTheta + midDTheta)/2  
  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling  midDTheta = $dTheta + (firstDDTheta + midDDTheta)/2  midTheta = $Theta + ($dTheta + midDTheta)/2  
  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling  lastDTheta = midDTheta + midDDTheta  lastTheta = midTheta + (midDTheta + lastDTheta)/2  
  lastDDTheta = -Math.sin(lastTheta * Math::PI/180) * scaling  lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2  lastTheta = midTheta + (midDTheta + lastDTheta)/2  
  $dTheta  = lastDTheta  $Theta = lastThetaend def animate  recompute_angle  show_pendulum  $after_id = $root.after(15) {animate}end show_pendulum$after_id = $root.after(500) {animate} $canvas.bind('<Destroy>') {$root.after_cancel($after_id)} Tk.mainloopShoes.app(:width => 320, :height => 200) do  @centerX = 160  @centerY = 25  @length = 150  @diameter = 15   @Theta = 45.0  @dTheta = 0.0   stroke gray  strokewidth 3  line 0,25,320,25  oval 155,20,10   stroke black  @rod = line(@centerX, @centerY, @centerX, @centerY + @length)  @bob = oval(@centerX - @diameter, @centerY + @length - @diameter, 2*@diameter)   animate(24) do |i|    recompute_angle    show_pendulum  end   def show_pendulum    angle = (90 + @Theta) * Math::PI / 180    x = @centerX + (Math.cos(angle) * @length).to_i    y = @centerY + (Math.sin(angle) * @length).to_i     @rod.remove    strokewidth 3    @rod = line(@centerX, @centerY, x, y)    @bob.move(x-@diameter, y-@diameter)  end   def recompute_angle    scaling = 3000.0 / (@length **2)    
    firstDDTheta = -Math.sin(@Theta * Math::PI / 180) * scaling    midDTheta = @dTheta + firstDDTheta    midTheta = @Theta + (@dTheta + midDTheta)/2    
    midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling    midDTheta = @dTheta + (firstDDTheta + midDDTheta)/2    midTheta = @Theta + (@dTheta + midDTheta)/2    
    midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling    lastDTheta = midDTheta + midDDTheta    lastTheta = midTheta + (midDTheta + lastDTheta)/2    
    lastDDTheta = -Math.sin(lastTheta * Math::PI/180) * scaling    lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2    lastTheta = midTheta + (midDTheta + lastDTheta)/2    
    @dTheta  = lastDTheta    @Theta = lastTheta  endend#!/bin/ruby begin; require 'rubygems'; rescue; end require 'gosu'include Gosu 
W = 640H = 480 
FS = false 
FPS = 60 class Pendulum   attr_accessor :theta, :friction   def initialize( win, x, y, length, radius, bob = true, friction = false)    @win = win    @centerX = x    @centerY = y    @length = length    @radius = radius    @bob = bob    @friction = friction     @theta = 60.0    @omega = 0.0    @scale = 2.0 / FPS  end   def draw    @win.translate(@centerX, @centerY) {      @win.rotate(@theta) {        @win.draw_quad(-1, 0, 0x3F_FF_FF_FF, 1, 0, 0x3F_FF_FF_00, 1, @length, 0x3F_FF_FF_00, -1, @length, 0x3F_FF_FF_FF )        if @bob          @win.translate(0, @length) {            @win.draw_quad(0, -@radius, Color::RED, @radius, 0, Color::BLUE, 0, @radius, Color::WHITE, -@radius, 0, Color::BLUE )          }        end      }    }  end   def update    
    @theta += @omega    @omega = @omega - (Math.sin(@theta * Math::PI / 180) / (@length * @scale))    @theta *= 0.999 if @friction  end end 
 class GfxWindow < Window   def initialize    
    super W, H, FS, 1.0 / FPS * 1000    
    self.caption = strv     @n = 1  
    @pendulums = []    (1..@n).each do |i|      @pendulums.push Pendulum.new( self, W / 2, H / 10, H * 0.75 * (i / @n.to_f), H / 60 )    end   end   def draw    @pendulums.each { |pen| pen.draw }  end   def update    @pendulums.each { |pen| pen.update }  end   def button_up(id)    if id == KbSpace      @pendulums.each { |pen|        pen.friction = !pen.friction        pen.theta = (pen.theta <=> 0) * 45.0 unless pen.friction      }    else      close    end  end   def needs_cursor?()    true  end end 
 begin  GfxWindow.new.showrescue Exception => e  puts e.message, e.backtrace  getsendrequire('Tk') var root = %s<MainWindow>.new('-title' => 'Pendulum Animation')var canvas = root.Canvas('-width' => 320, '-height' => 200) canvas.createLine(  0,  25, 320,  25, '-tags' => <plate>,     '-width' => 2, '-fill' => :grey50)canvas.createOval(155,  20, 165,  30, '-tags' => <pivot outline>,            '-fill' => :grey50)canvas.createLine(  1,   1,    1,  1, '-tags' => <rod width>, '-width' => 3, '-fill' => :black)canvas.createOval(  1,   1,    2,  2, '-tags' => <bob outline>,              '-fill' => :yellow) canvas.raise(:pivot)canvas.pack('-fill' => :both, '-expand' => 1)var(θ = 45, Δθ = 0, length = 150, homeX = 160, homeY = 25) func show_pendulum() {    var angle = θ.deg2rad    var x = (homeX + length*sin(angle))    var y = (homeY + length*cos(angle))    canvas.coords(:rod, homeX,  homeY,  x,      y)    canvas.coords(:bob, x - 15, y - 15, x + 15, y + 15)} func recompute_angle() {    var scaling = 3000/(length**2)     
    var firstΔΔθ = (-sin(θ.deg2rad) * scaling)    var midΔθ    = (Δθ + firstΔΔθ)    var midθ     = ((Δθ + midΔθ)/2 + θ)     
    var midΔΔθ = (-sin(midθ.deg2rad) * scaling)    midΔθ      = ((firstΔΔθ + midΔΔθ)/2 + Δθ)    midθ       = ((Δθ + midΔθ)/2 + θ)     
    midΔΔθ     = (-sin(midθ.deg2rad) * scaling)    var lastΔθ = (midΔθ + midΔΔθ)    var lastθ  = ((midΔθ + lastΔθ)/2 + midθ)     
    var lastΔΔθ = (-sin(lastθ.deg2rad) * scaling)    lastΔθ      = ((midΔΔθ + lastΔΔθ)/2 + midΔθ)    lastθ       = ((midΔθ + lastΔθ)/2 + midθ)     
    Δθ = lastΔθ    θ  = lastθ} func animate(Ref id) {    recompute_angle()    show_pendulum()    *id = root.after(15 => { animate(id) })} show_pendulum()var after_id = root.after(500 => { animate(\after_id) }) canvas.bind('<Destroy>' => { after_id.cancel })%S<Tk>.MainLoop()"
"def deranged?(a, b)  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}end def find_derangements(list)  list.combination(2) {|a,b| return a,b  if deranged?(a,b)}  nilend require 'open-uri'anagram = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|  f.read.split.group_by {|s| s.each_char.sort}end anagram = anagram.select{|k,list| list.size>1}.sort_by{|k,list| -k.size} anagram.each do |k,list|  if derangements = find_derangements(list)    puts strv    break  endendfunc find_deranged(Array a) {    for i in range(a) {        for j in range(i+1, a.end) {            overlaps(a[i], a[j]) || (                printf(""length %d: %s => %s"", a[i].len, a[i], a[j])                return true            )        }    }    return false} func main(File file) {     file.open_r(\var fh, \var err) ->        || die ""Can't open file `#{file}' for reading: #{err}""     var letter_list = Hash()     
    fh.words.each { |word|        letter_list{word.sort} := [] << word    }     letter_list.keys                        \         .grep {|k| letter_list{k}.len > 1} \     
         .sort {|a,b| b.len <=> a.len}      \     
         .each {|key|         
        find_deranged(letter_list{key}) && break    }} main(%f'/tmp/unixdict.txt')"
"require strv class Amb  class ExhaustedError < RuntimeError; end   def initialize    @fail = proc { fail ExhaustedError, strv }  end   def choose(*choices)    prev_fail = @fail    callcc { |sk|      choices.each { |choice|	callcc { |fk|	  @fail = proc {	    @fail = prev_fail	    fk.call(:fail)	  }	  if choice.respond_to? :call	    sk.call(choice.call)	  else	    sk.call(choice)	  end	}      }      @fail.call    }  end   def failure    choose  end   def assert(cond)    failure unless cond  endend A = Amb.neww1 = A.choose(strv, strv, strv)w2 = A.choose(strv, strv, strv)w3 = A.choose(strv, strv, strv)w4 = A.choose(strv, strv) A.choose() unless w1[-1] == w2[0]A.choose() unless w2[-1] == w3[0]A.choose() unless w3[-1] == w4[0] puts w1, w2, w3, w4"
"require 'prime' def almost_primes(k=2)  return to_enum(:almost_primes, k) unless block_given?  n = 0  loop do     n += 1    yield n if n.prime_division.map( &:last ).inject( &:+ ) == k  endend (1..5).each{|k| puts almost_primes(k).take(10).join(strv)}require 'prime' p ar = pr = Prime.take(10)4.times{p ar = ar.product(pr).map{|(a,b)| a*b}.uniq.sort.take(10)}func is_k_almost_prime(n, k) {    for (var (p, f) = (2, 0); (f < k) && (p*p <= n); ++p) {        (n /= p; ++f) while p.divides(n);    }    n > 1 ? (f.inc == k) : (f == k)} 5.times { |k|    var x = 10    say gather {        Math.inf.times { |i|            if (is_k_almost_prime(i, k)) {                take(i); (--x).is_zero && break;            }        }    }}"
"h = {}(1..20_000).each{|n| h[n] = n.proper_divisors.inject(:+)}h.select{|k,v| h[v] == k && k < v}.each do |key,val|  
  puts strvend func propdivsum(x) {    gather {        2.to(x.isqrt).each { |d|            if (x %% d) {                take(d)                take(x/d) if !x.is_sqr            }        }    }.sum(x > 0 ? 1 : 0)} 1.to(20000).each { |i|    var j = propdivsum(i)    say strv if (j>i && i==propdivsum(j))}"
"def aliquot(n, maxlen=16, maxterm=2**47)  return strv, [0] if n == 0  s = []  while (s << n).size <= maxlen and n < maxterm    n = n.proper_divisors.inject(0, :+)    if s.include?(n)      case n      when s[0]        case s.size        when 1   then   return strv, s        when 2   then   return strv, s        else            return strv, s        end      when s[-1] then   return strv, s      else              return strv, s      end    elsif n == 0 then   return strv, s << 0    end  end  return strv, send for n in 1..10  puts strv % aliquot(n)endputsfor n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]  puts strv % aliquot(n)end"
">foo = Object.new  
>id = foo.object_id  
>strv % (id << 1)  
 var n = 42;say Sys.refaddr(\n);        
say Sys.refaddr(n);         
"
"class Emptyend e = Empty.newclass << e
  attr_accessor :foo
end
e.foo = 1puts e.foo  
 f = Empty.newf.foo = 1   
 yes_no = strv def yes_no.not  replace( self==strv ? strv: strv)end #Demo:p yes_no.not 
p yes_no.not 
p strv.not  
class Empty{};var e = Empty();    
e{:foo} = 42;       
say e{:foo};        
"
"require 'open-uri' anagram = Hash.new {|hash, key| hash[key] = []} 
 open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|  words = f.read.split  for word in words    anagram[word.split('').sort] << word  endend count = anagram.values.map {|ana| ana.length}.maxanagram.each_value do |ana|  if ana.length >= count    p ana  endendrequire 'open-uri' anagrams = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt'){|f| f.read.split.group_by{|w| w.each_char.sort} }anagrams.values.group_by(&:size).max.last.each{|group| puts group.join(strv) } func main(file) {    file.open_r(\var fh, \var err) ->        || die ""Can't open file `#{file}' for reading: #{err}"";     var vls = fh.words.group_by{.sort}.values;    var max = vls.map{.len}.max;    vls.grep{.len == max}.each{.join("""").say};} main(%f'/tmp/unixdict.txt');"
"require 'polynomial' def x_minus_1_to_the(p)  return Polynomial.new(-1,1)**pend def prime?(p)  return false if p < 2  (x_minus_1_to_the(p) - Polynomial.from_string(strv)).coefs.all?{|n| n%p==0}end 8.times do |n|  
  
  puts ""(x-1)^#{n} = #{x_minus_1_to_the(n).to_s.gsub(//,'^').gsub(//,'')}""end puts ""Primes below 50:"", 50.times.select {|n| prime? n}.join(',')def x_minus_1_to_the(p)  p.times.inject([1]) do |ex, _|    ([0] + ex).zip(ex + [0]).map { |x,y| x - y }  endend def prime?(p)  return false if p < 2  coeff = x_minus_1_to_the(p)  coeff[0] += coeff.pop  coeff.all?{|n| n%p==0}end 8.times do |n|  puts strv +   x_minus_1_to_the(n).  each_with_index.  map { |c, p|    if p.zero? then c.to_s    else      (c<0 ? strv : strv) + (c.abs==1 ? strv : strv) + (p==1 ? strv : strv)    end  }.joinend puts ""Primes below 50:"", 50.times.select {|n| prime? n}.join(',')func binprime(p) {    p >= 2 || return false    for i in (1 .. p>>1) {        (binomial(p, i) % p) && return false    }    return true} func coef(n, e) {    (e == 0) && return strv    (n == 1) && (n = strv)    (e == 1) ? strv : strv} func binpoly(p) {    join(strv, coef(1, p), ^p -> map {|i|        join(strv, %w(+ -)[(p-i)&1], coef(binomial(p, i), i))    }.reverse...)} say strvfor i in ^10 { say binpoly(i) }say strv"
"require 'rubygems'require 'net/ldap' ldap = Net::LDAP.new(:host => 'hostname', :base => 'base')ldap.authenticate('bind_dn', 'bind_pass') filter = Net::LDAP::Filter.pres('objectclass')filter &= Net::LDAP::Filter.eq('sn','Jackman')
filter = Net::LDAP::Filter.construct('(&(objectclass=*)(sn=Jackman))') results = ldap.search(:filter => filter)  
 puts results[0][:sn]  
"
"require 'rubygems'require 'net/ldap'ldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')ldap.authenticate('bind_dn', 'bind_pass')"
"J2justifier = {Left: :ljust, Right: :rjust, Center: :center} =begin
Justify columns of textual tabular input where the record separator is the newline
and the field separator is a 'dollar' character.
justification can be Symbol; (:Left, :Right, or :Center).
 
Return the justified output as a string
=enddef aligner(infile, justification = :Left)  fieldsbyrow = infile.map {|line| line.strip.split('$')}  
  maxfields = fieldsbyrow.map(&:length).max  fieldsbyrow.map! {|row| row + ['']*(maxfields - row.length)}  
  colwidths = fieldsbyrow.transpose.map {|column|    column.map(&:length).max  }  
  justifier = J2justifier[justification]  fieldsbyrow.map {|row|    row.zip(colwidths).map {|field, width|      field.send(justifier, width)    }.join(strv)  }.join("""")end require 'stringio' textinfile = <<END
Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.
END for align in [:Left, :Right, :Center]  infile = StringIO.new(textinfile)  puts ""# %s Column-aligned output:"" % align  puts aligner(infile, align)end class Format(text, width) {    method align(j) {        text.map { |row|            row.range.map { |i|                '%-*s ' % (width[i],                  '%*s' % (row[i].len + (width[i]-row[i].len * j/2), row[i]));            }.join(strv);        }.join("""") + """";    }} func Formatter(text) {    var textArr = [];    var widthArr = [];     text.each_line {        var words = .split('$');        textArr.append(words);         words.each_kv { |i, word|            if (i == widthArr.len) {                widthArr.append(word.len);            }            elsif (word.len > widthArr[i]) {                widthArr[i] = word.len;            }        }    }     return Format(textArr, widthArr);} enum |left, middle, right|;const text = <<'EOT';Given$a$text$file$of$many$lines,$where$fields$within$a$line$are$delineated$by$a$single$'dollar'$character,$write$a$programthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$column$are$separated$by$at$least$one$space.Further,$allow$for$each$word$in$a$column$to$be$either$left$justified,$right$justified,$or$center$justified$within$its$column.EOT var f = Formatter(text); say f.align(left);say f.align(middle);say f.align(right);"
"res = Hash.new(0)(1 .. 20_000).each{|n| res[n.proper_divisors.inject(0, :+) <=> n] += 1}puts strv func propdivsum(x) {    gather {        for d in (2 .. x.isqrt) {            take(d, x/d) if d.divides(x)        }    }.uniq.sum(x > 1 ? 1 : 0)} var h = Hash()20000.times { |i| ++(h{propdivsum(i) <=> i} := 0) }say strv"
"def accumulator(sum)  lambda {|n| sum += n}end 
x = accumulator(1)x.call(5)p accumulator(3)  
puts x.call(2.3)  
 
require 'rational'require 'complex'y = accumulator(Rational(2, 3))y.call(Rational(1, 2))puts y.call(4)puts y.call(Complex(0, 1))puts y.call(Complex.polar(6, 5 * Math::PI / 4))puts x.call(0)    
 
t = accumulator(Time.utc(1999, 8, 7, 6, 5))puts t.call(4)    
 require 'matrix'm = accumulator(Matrix[[1, 2], [3, 4]])puts m.call(Matrix[[5, 6], [7, 8]])puts t.call(-12 * 60 * 60)  
puts y.call(1e200)puts x.call(0)    
class Accumulator(sum) {    method add(num) {        sum += num;    }} var x = Accumulator(1);x.add(5);Accumulator(3);say x.add(2.3);               
func Accumulator(sum) {    func(num) { sum += num };} var x = Accumulator(1);x(5);Accumulator(3);say x(2.3);                  
"
"require 'abstraction' class AbstractQueue  abstract  def enqueue(object)    raise NotImplementedError  end  def dequeue    raise NotImplementedError  endend class ConcreteQueue < AbstractQueue  def enqueue(object)    puts strv  endendclass A {    
    method abstract() { die 'Unimplemented' };     
    method concrete() { say '# 42' };} class SomeClass << A {    method abstract() {        say strv    }} var obj = SomeClass.new;obj.abstract();   
obj.concrete();   
"
"def ack(m, n)  if m == 0    n + 1  elsif n == 0    ack(m-1, 1)  else    ack(m-1, ack(m, n-1))  endend(0..3).each do |m|  puts (0..6).map { |n| ack(m, n) }.join(' ')endfunc A(m, n) {    m == 0 ? (n + 1)           : (n == 0 ? (A(m - 1, 1))                     : (A(m - 1, A(m, n - 1))));}func A((0), n) { n + 1 }func A(m, (0)) { A(m - 1, 1) }func A(m,  n)  { A(m-1, A(m, n-1)) }say A(3, 2);     
"
"puts gets.not_nil!.split.map(&.to_i).sumif line = gets  puts line.split.map(&.to_i).sumelse  puts strvendputs gets.split.map(&:to_i).inject(:+)say STDIN.readline.words.map{.to_i}.sumsay read(String).words»to_i»()«+»var (a, b) = read(String).words.map{.to_i}...say a+b"
" 

def g(n,g)  return 1 unless 1 < g and g < n-1  (2..g).inject(1){|res,q| res + (q > n-g ? 0 : g(n-g,q))}end (1..25).each {|n|  puts (1..n).map {|g| strv % g(n,g)}.join}  

N = 12345@ng = []@ipn1 = []@ipn2 = []def g(n,g)  t = n-g-2  return 1 if n<4 or t<0  return @ng[g-2][n-4] unless n/2<g  return @ipn1[t]end@ng[0] = [](4..N).each {|q| @ng[0][q-4] = 1 + g(q-2,2)}@ipn1[0] = @ng[0][0]@ipn2[0] = @ng[0][N-4](1...(N/2-1)).each {|n|  @ng[n] = []  (n*2+4..N).each {|q| @ng[n][q-4] = g(q-1,n+1) + g(q-n-2,n+2)}  @ipn1[n] = @ng[n][n*2]  @ipn2[n] = @ng[n][N-4]  @ng[n-1] = nil}@ipn2.pop if N.even? puts ""G(23) = [21]}""puts ""G(123) = [121]}""puts ""G(1234) = [1232]}""n = 3 + @ipn1.inject(:+) + @ipn2.inject(:+)puts strv var cache = [[1]] func cumu (n) {    for l in range(cache.len, n) {        var r = [0]        l.times { |i|            r << (r[-1] + cache[l-i][min(i, l-i)])        }        cache << r    }    cache[n]} func row (n) {    var r = cumu(n)    n.of {|i| r[i] - r[i-1] }} say strv15.times { |i|    ""%2s: %s"".printf(i, row(i))} say ""sums:"" for i in [23, 123, 1234, 12345] {    ""%2s : %4s"".printf(i, cumu(i)[-1])}"
"words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << strv words.each do |word|  blocks = strv  res = word.each_char.all?{|c| blocks.sub!(/\w?#{c}\w?/i, strv)}  #regexps can be interpolated like strings  puts strvend func can_make_word(word, blocks) {     blocks.map! { |b| b.uc.chars.sort.join }.freq!     func(word, blocks) {        var char = word.shift        var candidates = blocks.keys.grep { |k| 0 <= k.index(char) }         for candidate in candidates {            blocks{candidate} <= 0 && next;            local blocks{candidate} = (blocks{candidate} - 1);            return true if (word.is_empty || __FUNC__(word, blocks));        }         return false;    }(word.uc.chars, blocks)}var b1 = %w(BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM)var b2 = %w(US TZ AO QA) var tests = [    [strv, true, b1],    [strv, true, b1],    [strv, false, b1],    [strv, true, b1],    [strv, false, b1],    [strv, true, b1],    [strv, true, b1],    [strv, true, b2],]; tests.each { |t|    var bool = can_make_word(t[0], t[2]);    say (strv % (t[0], bool));    assert(bool == t[1])}"
"def four_squares(low, high, unique=true, show=unique)  f = -> (a,b,c,d,e,f,g) {[a+b, b+c+d, d+e+f, f+g].uniq.size == 1}  if unique    uniq = strv    solutions = [*low..high].permutation(7).select{|ary| f.call(*ary)}  else    uniq = strv    solutions = [*low..high].repeated_permutation(7).select{|ary| f.call(*ary)}  end  if show    puts strv + [*strv..strv].join(strv)    solutions.each{|ary| p ary}  end  puts strv  putsend [[1,7], [3,9]].each do |low, high|  four_squares(low, high)endfour_squares(0, 9, false)"
"plural = 's'99.downto(1) do |i|  puts strv  puts strv  puts strv  plural = '' if i - 1 == 1  if i > 1    puts strv    puts  else    puts strv  endendtrace_var :$bottle_num do |val|  $bottles = %Q{#{val == 0 ? 'No more' : val.to_s} bottle#{val == 1 ? '' : 's'}}end ($bottle_num = 99).times do  puts strv  puts strv  puts strv  $bottle_num -= 1  puts strv  puts strvenddef bottles(of_beer, ending)  puts strv  puts strv  puts strvend 99.downto(0) do |left|  if left > 1    bottles(left, strv)  elsif left == 1    bottles(left, strv)  else    puts strv  endenddef bottles(beer, wall = false)  strvno morestrvsstrv on the wallstrvend 99.downto(0) do |remaining|  puts strv  if remaining==0    print strv    remaining=100  else    print strv  end  puts "", #{bottles(remaining-1,true)}.""end 99.downto(1) do |bottles|  puts strvsstrv,       strvsstrv,       strv,       strvs"" if bottles - 1 != 1} of beer on the wall.""end for i in (100 ^.. 0) {    var bottles = strv    var sentence = strv -> say    if (i > 0) {        say sentence.substr(0, bottles.length + 8)        say ""Take one down, pass it around""    }}for n in (100 ^.. 2) {  say strv  say ""Take one down, pass it around, #{n - 1} bottle#{n > 2 ? 's' : ''} of beer on the wall.""} say strvsay strv"
"class TwentyFourGame  EXPRESSIONS = [    '((%dr %s %dr) %s %dr) %s %dr',    '(%dr %s (%dr %s %dr)) %s %dr',    '(%dr %s %dr) %s (%dr %s %dr)',    '%dr %s ((%dr %s %dr) %s %dr)',    '%dr %s (%dr %s (%dr %s %dr))',  ]   OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a   def self.solve(digits)    solutions = []    perms = digits.permutation.to_a.uniq    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|      
      text = expr % [a, op1, b, op2, c, op3, d]      value = eval(text)  rescue next                 
      solutions << text.delete(strv)  if value == 24    end    solutions  endend 
digits = ARGV.map do |arg|   begin    Integer(arg)  rescue ArgumentError    raise strv  endenddigits.size == 4 or raise strv solutions = TwentyFourGame.solve(digits)if solutions.empty?  puts strvelse  puts strv  puts solutions.sortendvar formats = [    '((%d %s %d) %s %d) %s %d',    '(%d %s (%d %s %d)) %s %d',    '(%d %s %d) %s (%d %s %d)',    '%d %s ((%d %s %d) %s %d)',    '%d %s (%d %s (%d %s %d))',]; var op = %w( + - * / );var operators = op.map { |a| op.map {|b| op.map {|c| strv } } }.flatten; loop {    var input = Sys.scanln(strv);    input == 'q' && break;     input ~~ /^\h*[1-9]\h+[1-9]\h+[1-9]\h+[1-9]\h*$/ || (        say strv; next;    );     var n = input.split.map{.to_i};    var numbers = n.permute;     formats.each { |format|        numbers.each { |n|            operators.each { |operator|                var o = operator.split;                var str = (format % (n[0],o[0],n[1],o[1],n[2],o[2],n[3]));                eval(str) == 24 && say str;            }        }    }}var formats = [    {|a,b,c|        Hash.new(            func   => {|d,e,f,g| ((d.$a(e)).$b(f)).$c(g) },            format => strv        )    },    {|a,b,c|        Hash.new(            func   => {|d,e,f,g| (d.$a((e.$b(f)))).$c(g) },            format => strv,        )    },    {|a,b,c|        Hash.new(            func   => {|d,e,f,g| (d.$a(e)).$b(f.$c(g)) },            format => strv,        )    },    {|a,b,c|        Hash.new(            func   => {|d,e,f,g| (d.$a(e)).$b(f.$c(g)) },            format => strv,        )    },    {|a,b,c|        Hash.new(            func   => {|d,e,f,g| d.$a(e.$b(f.$c(g))) },            format => strv,        )    },]; var op = %w( + - * / );var blocks = op.map { |a| op.map { |b| op.map { |c| formats.map { |format|    format(a,b,c)}}}}.flatten; loop {    var input = Sys.scanln(strv);    input == 'q' && break;     input ~~ /^\h*[1-9]\h+[1-9]\h+[1-9]\h+[1-9]\h*$/ || (        say strv; next;    );     var n = input.split.map{.to_num};    var numbers = n.permute;     blocks.each { |block|        numbers.each { |n|            if (block{:func}.call(n...) == 24) {                say (block{:format} % (n...));            }        }    }}"
" #!/usr/bin/ruby require 'io/console' class Board  def initialize size=4, win_limit=2048, cell_width = 6    @size = size; @cw = cell_width; @win_limit = win_limit    @board = Array.new(size) {Array.new(size, 0)}    @moved = true; @score = 0; @no_more_moves = false    spawn  end   def draw    print """" if @r_vert    print '    ' if @r_hori    print '┌' + (['─' * @cw] * @size).join('┬')  + '┐'    @board.each do |row|      print """"      formated = row.map {|num| num == 0 ? ' ' * @cw : format(num)}      print '    ' if @r_hori      puts '│' + formated.join('│') + '│'      print '    ' if @r_hori      print '├' + ([' '  * @cw] * @size).join('┼') + '┤'    end    print """"    print '    ' if @r_hori    puts '└' + (['─' * @cw] * @size).join('┴')  + '┘'  end   def move direction    case direction    when :up      @board = column_map {|c| logic(c)}      @r_vert = false if $rumble    when :down      @board = column_map {|c| logic(c.reverse).reverse}       @r_vert = true if $rumble    when :left       @board = row_map {|r| logic(r)}      @r_hori = false if $rumble    when :right      @board = row_map {|r| logic(r.reverse).reverse}       @r_hori = true if $rumble    end    spawn    @moved = false  end   def print_score    puts ""Your Score is ""    puts strv if to_enum.any? {|e| e >= @win_limit}  end   def no_more_moves?; @no_more_moves; end  def won?;  to_enum.any? {|e| e >= @win_limit}; end  def reset!; initialize @size, @win_limit, @cw; end   private   def set x, y, val    @board[y][x] = val  end   def spawn     free_pos = to_enum.select{|elem,x,y| elem == 0}.map{|_,x,y| [x,y]}    unless free_pos.empty?      set *free_pos.sample, rand > 0.1 ? 2 : 4 if @moved    else      snap = @board      unless @stop        @stop = true        %i{up down left right}.each{|s| move(s)}        @no_more_moves = true if snap.flatten == @board.flatten        @board = snap        @stop = false      end    end  end   def logic list    jump = false    result =    list.reduce([]) do |res, val|      if res.last == val && !jump	res[-1] += val	@score += val        jump = true      elsif val != 0	res.push val        jump = false      end      res    end    result += [0] * (@size - result.length)    @moved ||= list != result    result  end   def column_map    xboard = @board.transpose    xboard.map!{|c| yield c }    xboard.transpose  end   def row_map    @board.map {|r| yield r }  end   def to_enum    @enum ||= Enumerator.new(@size * @size) do |yielder|      (@size*@size).times do |i|	yielder.yield (@board[i / @size][i % @size]), (i % @size), (i / @size )      end    end    @enum.rewind  end   def format(num)    if $color      cstart = ""["" + $colors[Math.log(num, 2)] + strv      cend = ""[0m""    else      cstart = cend = strv    end    cstart + num.to_s.center(@cw) + cend  endend $color = true$colors = %W{0 1;97 1;93 1;92 1;96 1;91 1;95 1;94 1;30;47 1;43 1;421;46 1;41 1;45 1;44 1;33;43 1;33;42 1;33;41 1;33;44}$rumble = false $check_score = trueunless ARGV.empty?  puts strv; exit if %W[-h --help].include?(ARGV[0])  args = ARGV.map(&:to_i).reject{|n| n == 0}  b = Board.new(*args) unless args.empty?  $rumble = true if ARGV.any?{|a| a =~ /rumble/i }  $color = false if ARGV.any?{|a| a =~ /no.?color/i}end b ||= Board.newputs ""[H[2J""b.drawputs strvloop do  input = STDIN.getch  if input == """"     2.times {input << STDIN.getch}  end   case input  when ""[A"", strv then b.move(:up)  when ""[B"", strv then b.move(:down)  when ""[C"", strv then b.move(:right)  when ""[D"", strv then b.move(:left)   when strv,""0003"",""0004""  then b.print_score; exit   when strv     puts <<-EOM.gsub(/^\s*/, '')      ┌─                                                                                  ─┐      │Use the arrow-keys or WASD on your keyboard to push board in the given direction.         │Tiles with the same number merge into one.                                                │Get a tile with a value of #{ARGV[1] || 2048} to win.                                     │In case you cannot move or merge any tiles anymore, you loose.                            │You can start this game with different settings by providing commandline argument:        │For instance:                                                                             │  %> #$0 6 8192 --rumble                                                                  └─                                                                                  ─┘      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)    EOM    input = STDIN.getch  end   puts ""[H[2J""  b.draw   if b.no_more_moves? or $check_score && b.won?    b.print_score    if b.no_more_moves?      puts strv      puts strv      exit if STDIN.gets.chomp.downcase == strv      $check_score = true      b.reset!      puts ""[H[2J""      b.draw    else      puts strv      exit if STDIN.gets.chomp.downcase == strv      $check_score = false      puts ""[H[2J""      b.draw    end  endend "
"require 'io/console' class Board  SIZE = 4  RANGE = 0...SIZE   def initialize    width = (SIZE*SIZE-1).to_s.size    @frame = (strv + strv*(width+2)) * SIZE + strv    @form = strv * SIZE + strv    @step = 0    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze    @board = @orign.map{|row | row.dup}    randomize    draw    message    play  end   private   def randomize    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]    x, y, dx, dy = 0, 0, 1, 0    50.times do      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}                .sample      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]      x, y, dx, dy = nx, ny, nx-x, ny-y    end    @x, @y = x, y   end   def draw    puts ""[H[2J""    @board.each do |row|      puts @frame      puts (@form % row).sub(strv, strv)    end    puts @frame    puts ""Step: }""  end   DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}  def move(direction)    dx, dy = DIR[direction]    nx, ny = @x + dx, @y + dy    if RANGE.include?(nx) and RANGE.include?(ny)      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]      @x, @y = nx, ny      @step += 1      draw    end  end   def play    until @board == @orign      case  key_in      when ""[A"", strv then move(:up)      when ""[B"", strv then move(:down)      when ""[C"", strv then move(:right)      when ""[D"", strv then move(:left)       when strv,""0003"",""0004""  then exit      when strv  then message      end    end     puts strv  end   def key_in    input = STDIN.getch    if input == """"       2.times {input << STDIN.getch}    end    input  end   def message    puts <<~EOM      Use the arrow-keys or WASD on your keyboard to push board in the given direction.         PRESS q TO QUIT (or Ctrl-C or Ctrl-D)    EOM  endend Board.new"
"class Guess < String  def self.play    nums = Array.new(4){rand(1..9)}    loop do      result = get(nums).evaluate!      break if result == 24.0      puts strv    end    puts strv  end   def self.get(nums)    loop do      print ""Enter a guess using #{nums}: ""      input = gets.chomp      return new(input) if validate(input, nums)    end  end   def self.validate(guess, nums)    name, error =      {        invalid_character:  ->(str){ !str.scan(%r{[^\d\s()+*/-]}).empty? },        wrong_number:       ->(str){ str.scan(/\d/).map(&:to_i).sort != nums.sort },        multi_digit_number: ->(str){ str.match(/\d\d/) }      }        .find {|name, validator| validator[guess] }     error ? puts(strv) : true  end   def evaluate!    as_rat = gsub(/(\d)/, 'r')        
    eval strv  rescue SyntaxError    strv  endend Guess.playconst digits  = (1..9 -> pick(4));const grammar = Regex.new(    '^ (?&exp) 
      (?(DEFINE)
          (?<exp> ( (?&term) (?&op) (?&term) )+ )
          (?<term>  (?&exp)  | [' + digits.join + '])
          (?<op> [-+*/] )
      )', 'x'); say strv; loop {    var input = Sys.scanln(strv);     var expr = input;    expr -= /\s+/g;    
     input == 'q' && (        say strv;        break;    );     var given_digits = digits.map{.to_s}.sort.join;    var entry_digits = input.scan(/\d/).sort.join;     if ((given_digits != entry_digits) || (expr !~ grammar)) {        say strv;        next;    }     given(var n = eval(input)) {        when (24) { say strv; break }        default   { say strv }    }}"
"doors = Array.new(100, false) 1.upto(100) do |i|  i.step(by: i, limit: 100) do |j|    doors[j - 1] = !doors[j - 1]  endend doors.each_with_index do |open, i|  puts strvopenstrvclosedstrvendclass Door  attr_reader :state   def initialize    @state = :closed  end   def close    @state = :closed  end   def open    @state = :open  end   def closed?    @state == :closed  end   def open?    @state == :open  end   def toggle    if closed? then open else close end  end   def to_s    @state.to_s  endend doors = Array.new(100) { Door.new }1.upto(100) do |multiplier|  doors.each_with_index do |door, i|    door.toggle if (i + 1) % multiplier == 0  endend doors.each_with_index { |door, i| puts strv }n = 100Open = strvClosed = strvdef Open.toggle  Closedenddef Closed.toggle  Openenddoors = [Closed] * (n + 1)for mul in 1..n  for x in (mul..n).step(mul)    doors[x] = doors[x].toggle  endenddoors.each_with_index do |b, i|  puts strv if i > 0endn = 100(1..n).each do |i|   puts strvopenstrvclosedstrvenddoors = [false] * 100100.times do |i|  (i ... doors.length).step(i + 1) do |j|    doors[j] = !doors[j]  endendputs doors.map.with_index(1){|d,i| strv}var doors = [] 100.times { |pass|    100.times { |i|        if (i % pass == 0) {            doors[i] := false -> not!        }    }} 100.times { |i|    ""Door %3d is %s"".printf(i, doors[i] ? 'open' : 'closed')}{ |i|    ""Door %3d is %s"".printf(i, [strv, strv][i.is_sqr])} * 100"
"
def f(x)  x = strvend x = strvf(x)puts x  
def f(x)  x.replace(strv)  x << strv  x = strvend x = strvf(x)puts x  
def f(x)  x.replace(strv)  x << strv  $p = proc { x }  x = strvend x = strvf(x)puts x        
puts $p.call  
"
